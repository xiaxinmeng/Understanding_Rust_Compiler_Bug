{"sha": "bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJjOTM5NmI2MmE2NWU4ZWNjNjdiYjJmOGRmODcwZTJiNTA0MGFjNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-01T15:14:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-01T15:14:24Z"}, "message": "common.opt (fdevirtualize-speculatively): New function.\n\n\t* common.opt (fdevirtualize-speculatively): New function.\n\t* invoke.texi (fdevirtualize-speculatively): Document.\n\t* ipa-devirt.c: Include ipa-inline.h\n\t(likely_target_p): New function.\n\t(ipa_devirt): New function.\n\t(gate_ipa_devirt): New function.\n\t(pass_data_ipa_devirt): New static var.\n\t(pass_ipa_devirt): Likewise.\n\t(make_pass_ipa_devirt): New function.\n\t* opts.c (default_options): Add OPT_fdevirtualize_speculatively.\n\t(common_handle_option): Disable devirtualization when\n\tvalue range profiling is available.\n\t* passes.def (pass_ipa_devirt): Add.\n\t* timever.def (TV_IPA_DEVIRT): New timevar.\n\t* tree-pass.h (make_pass_ipa_devirt):\n\nFrom-SVN: r202145", "tree": {"sha": "a04f98f7e7873d1c147343271471b27491c59a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a04f98f7e7873d1c147343271471b27491c59a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/comments", "author": null, "committer": null, "parents": [{"sha": "0cea211ebd67d10e93649074d348d12df67c4d97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cea211ebd67d10e93649074d348d12df67c4d97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cea211ebd67d10e93649074d348d12df67c4d97"}], "stats": {"total": 321, "additions": 316, "deletions": 5}, "files": [{"sha": "c4cc9b7839282587e6235f0abba51fe80a528328", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -1,3 +1,21 @@\n+2013-09-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* common.opt (fdevirtualize-speculatively): New function.\n+\t* invoke.texi (fdevirtualize-speculatively): Document.\n+\t* ipa-devirt.c: Include ipa-inline.h\n+\t(likely_target_p): New function.\n+\t(ipa_devirt): New function.\n+\t(gate_ipa_devirt): New function.\n+\t(pass_data_ipa_devirt): New static var.\n+\t(pass_ipa_devirt): Likewise.\n+\t(make_pass_ipa_devirt): New function.\n+\t* opts.c (default_options): Add OPT_fdevirtualize_speculatively.\n+\t(common_handle_option): Disable devirtualization when\n+\tvalue range profiling is available.\n+\t* passes.def (pass_ipa_devirt): Add.\n+\t* timever.def (TV_IPA_DEVIRT): New timevar.\n+\t* tree-pass.h (make_pass_ipa_devirt): \n+\n 2013-09-01  Iain Sandoe  <iain@codesourcery.com>\n \n \t* config/darwin.h (LINK_COMMAND_SPEC_A): Revise sanitizer specs to"}, {"sha": "a18a42b410a13034275d6b4be974c1e8c84e41d3", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -1007,6 +1007,10 @@ fdevirtualize\n Common Report Var(flag_devirtualize) Optimization\n Try to convert virtual calls to direct ones.\n \n+fdevirtualize-speculatively\n+Common Report Var(flag_devirtualize_speculatively) Optimization\n+Perform speculative devirtualization\n+\n fdiagnostics-show-location=\n Common Joined RejectNegative Enum(diagnostic_prefixing_rule)\n -fdiagnostics-show-location=[once|every-line]\tHow often to emit source location at the beginning of line-wrapped diagnostics\n@@ -1366,7 +1370,7 @@ Common RejectNegative Joined\n \n fipa-cp\n Common Report Var(flag_ipa_cp) Optimization\n-Perform Interprocedural constant propagation\n+Perform interprocedural constant propagation\n \n fipa-cp-clone\n Common Report Var(flag_ipa_cp_clone) Optimization"}, {"sha": "9dfb4d790192c6cbe5359cbd1618181529460725", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -365,7 +365,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules @gol\n -fcx-limited-range @gol\n -fdata-sections -fdce -fdelayed-branch @gol\n--fdelete-null-pointer-checks -fdevirtualize -fdse @gol\n+-fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively -fdse @gol\n -fearly-inlining -fipa-sra -fexpensive-optimizations -ffat-lto-objects @gol\n -ffast-math -ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol\n -fforward-propagate -ffp-contract=@var{style} -ffunction-sections @gol\n@@ -6712,7 +6712,7 @@ also turns on the following optimization flags:\n -fcrossjumping @gol\n -fcse-follow-jumps  -fcse-skip-blocks @gol\n -fdelete-null-pointer-checks @gol\n--fdevirtualize @gol\n+-fdevirtualize -fdevirtualize-speculatively @gol\n -fexpensive-optimizations @gol\n -fgcse  -fgcse-lm  @gol\n -fhoist-adjacent-loads @gol\n@@ -7257,6 +7257,15 @@ indirect inlining (@code{-findirect-inlining}) and interprocedural constant\n propagation (@option{-fipa-cp}).\n Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -fdevirtualize-speculatively\n+@opindex fdevirtualize-speculatively\n+Attempt to convert calls to virtual functions to speculative direct calls.\n+Based on the analysis of the type inheritance graph, determine for a given call\n+the set of likely targets. If the set is small, preferably of size 1, change\n+the call into an conditional deciding on direct and indirect call.  The\n+speculative calls enable more optimizations, such as inlining.  When they seem\n+useless after further optimization, they are converted back into original form.\n+\n @item -fexpensive-optimizations\n @opindex fexpensive-optimizations\n Perform a number of minor optimizations that are relatively expensive."}, {"sha": "cab583eb1917dac18339b1c0083a3e997ccda438", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -101,6 +101,8 @@ along with GCC; see the file COPYING3.  If not see\n \n   possible_polymorphic_call_targets returns, given an parameters found in\n   indirect polymorphic edge all possible polymorphic call targets of the call.\n+\n+  pass_ipa_devirt performs simple speculative devirtualization.\n */\n \n #include \"config.h\"\n@@ -116,6 +118,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"ipa-utils.h\"\n #include \"gimple.h\"\n+#include \"ipa-inline.h\"\n \n /* Pointer set of all call targets appearing in the cache.  */\n static pointer_set_t *cached_polymorphic_call_targets;\n@@ -728,4 +731,267 @@ update_type_inheritance_graph (void)\n       get_odr_type (method_class_type (TREE_TYPE (n->symbol.decl)), true);\n   timevar_pop (TV_IPA_INHERITANCE);\n }\n+\n+\n+/* Return true if N looks like likely target of a polymorphic call.\n+   Rule out cxa_pure_virtual, noreturns, function declared cold and\n+   other obvious cases.  */\n+\n+bool\n+likely_target_p (struct cgraph_node *n)\n+{\n+  int flags;\n+  /* cxa_pure_virtual and similar things are not likely.  */\n+  if (TREE_CODE (TREE_TYPE (n->symbol.decl)) != METHOD_TYPE)\n+    return false;\n+  flags = flags_from_decl_or_type (n->symbol.decl);\n+  if (flags & ECF_NORETURN)\n+    return false;\n+  if (lookup_attribute (\"cold\",\n+\t\t\tDECL_ATTRIBUTES (n->symbol.decl)))\n+    return false;\n+  if (n->frequency < NODE_FREQUENCY_NORMAL)\n+    return false;\n+  return true;\n+}\n+\n+/* The ipa-devirt pass.\n+   This performs very trivial devirtualization:\n+     1) when polymorphic call is known to have precisely one target,\n+        turn it into direct call\n+     2) when polymorphic call has only one likely target in the unit,\n+        turn it into speculative call.  */\n+\n+static unsigned int\n+ipa_devirt (void)\n+{\n+  struct cgraph_node *n;\n+  struct pointer_set_t *bad_call_targets = pointer_set_create ();\n+  struct cgraph_edge *e;\n+\n+  int npolymorphic = 0, nspeculated = 0, nconverted = 0, ncold = 0;\n+  int nmultiple = 0, noverwritable = 0, ndevirtualized = 0, nnotdefined = 0;\n+  int nwrong = 0, nok = 0, nexternal = 0;;\n+\n+  FOR_EACH_DEFINED_FUNCTION (n)\n+    {\t\n+      bool update = false;\n+      if (dump_file && n->indirect_calls)\n+\tfprintf (dump_file, \"\\n\\nProcesing function %s/%i\\n\",\n+\t\t cgraph_node_name (n), n->symbol.order);\n+      for (e = n->indirect_calls; e; e = e->next_callee)\n+\tif (e->indirect_info->polymorphic)\n+\t  {\n+\t    struct cgraph_node *likely_target = NULL;\n+\t    void *cache_token;\n+\t    bool final;\n+\t    vec <cgraph_node *>targets\n+\t       = possible_polymorphic_call_targets\n+\t\t    (e, &final, &cache_token);\n+\t    unsigned int i;\n+\n+\t    if (dump_file)\n+\t      dump_possible_polymorphic_call_targets \n+\t\t(dump_file, e);\n+\t    npolymorphic++;\n+\n+\t    if (final)\n+\t      {\n+\t\tgcc_assert (targets.length());\n+\t\tif (targets.length() == 1)\n+\t\t  {\n+\t\t    if (dump_file)\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"Devirtualizing call in %s/%i to %s/%i\\n\",\n+\t\t\t       cgraph_node_name (n), n->symbol.order,\n+\t\t\t       cgraph_node_name (targets[0]), targets[0]->symbol.order);\n+\t\t    cgraph_make_edge_direct (e, targets[0]);\n+\t\t    ndevirtualized++;\n+\t\t    update = true;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\t    if (!flag_devirtualize_speculatively)\n+\t      continue;\n+\t    if (!cgraph_maybe_hot_edge_p (e))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Call is cold\\n\");\n+\t\tncold++;\n+\t\tcontinue;\n+\t      }\n+\t    if (e->speculative)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Call is aready speculated\\n\");\n+\t\tnspeculated++;\n+\n+\t\t/* When dumping see if we agree with speculation.  */\n+\t\tif (!dump_file)\n+\t\t  continue;\n+\t      }\n+\t    if (pointer_set_contains (bad_call_targets,\n+\t\t\t\t      cache_token))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Target list is known to be useless\\n\");\n+\t\tnmultiple++;\n+\t\tcontinue;\n+\t      }\n+\t    for (i = 0; i < targets.length(); i++)\n+\t      if (likely_target_p (targets[i]))\n+\t\t{\n+\t\t  if (likely_target)\n+\t\t    {\n+\t\t      likely_target = NULL;\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"More than one likely target\\n\");\n+\t\t      nmultiple++;\n+\t\t      break;\n+\t\t    }\n+\t\t  likely_target = targets[i];\n+\t\t}\n+\t    if (!likely_target)\n+\t      {\n+\t\tpointer_set_insert (bad_call_targets, cache_token);\n+\t        continue;\n+\t      }\n+\t    /* This is reached only when dumping; check if we agree or disagree\n+ \t       with the speculation.  */\n+\t    if (e->speculative)\n+\t      {\n+\t\tstruct cgraph_edge *e2;\n+\t\tstruct ipa_ref *ref;\n+\t\tcgraph_speculative_call_info (e, e2, e, ref);\n+\t\tif (cgraph_function_or_thunk_node (e2->callee, NULL)\n+\t\t    == cgraph_function_or_thunk_node (likely_target, NULL))\n+\t\t  {\n+\t\t    fprintf (dump_file, \"We agree with speculation\\n\");\n+\t\t    nok++;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    fprintf (dump_file, \"We disagree with speculation\\n\");\n+\t\t    nwrong++;\n+\t\t  }\n+\t\tcontinue;\n+\t      }\n+\t    if (!likely_target->symbol.definition)\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Target is not an definition\\n\");\n+\t\tnnotdefined++;\n+\t\tcontinue;\n+\t      }\n+\t    /* Do not introduce new references to external symbols.  While we\n+\t       can handle these just well, it is common for programs to\n+\t       incorrectly with headers defining methods they are linked\n+\t       with.  */\n+\t    if (DECL_EXTERNAL (likely_target->symbol.decl))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Target is external\\n\");\n+\t\tnexternal++;\n+\t\tcontinue;\n+\t      }\n+\t    if (cgraph_function_body_availability (likely_target)\n+\t\t<= AVAIL_OVERWRITABLE\n+\t\t&& symtab_can_be_discarded ((symtab_node) likely_target))\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file, \"Target is overwritable\\n\");\n+\t\tnoverwritable++;\n+\t\tcontinue;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (dump_file)\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Speculatively devirtualizing call in %s/%i to %s/%i\\n\",\n+\t\t\t   cgraph_node_name (n), n->symbol.order,\n+\t\t\t   cgraph_node_name (likely_target),\n+\t\t\t   likely_target->symbol.order);\n+\t\tif (!symtab_can_be_discarded ((symtab_node) likely_target))\n+\t\t  likely_target = cgraph (symtab_nonoverwritable_alias ((symtab_node)likely_target));\n+\t\tnconverted++;\n+\t\tupdate = true;\n+\t\tcgraph_turn_edge_to_speculative\n+\t\t  (e, likely_target, e->count * 8 / 10, e->frequency * 8 / 10);\n+\t      }\n+\t  }\n+      if (update)\n+\tinline_update_overall_summary (n);\n+    }\n+  pointer_set_destroy (bad_call_targets);\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"%i polymorphic calls, %i devirtualized,\"\n+\t     \" %i speculatively devirtualized, %i cold\\n\"\n+\t     \"%i have multiple targets, %i overwritable,\"\n+\t     \" %i already speculated (%i agree, %i disagree),\"\n+\t     \" %i external, %i not defined\\n\",\n+\t     npolymorphic, ndevirtualized, nconverted, ncold,\n+\t     nmultiple, noverwritable, nspeculated, nok, nwrong,\n+\t     nexternal, nnotdefined);\n+  return ndevirtualized ? TODO_remove_functions : 0;\n+}\n+\n+/* Gate for IPCP optimization.  */\n+\n+static bool\n+gate_ipa_devirt (void)\n+{\n+  /* FIXME: We should remove the optimize check after we ensure we never run\n+     IPA passes when not optimizing.  */\n+  return (flag_devirtualize || flag_devirtualize_speculatively) && !in_lto_p;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_devirt =\n+{\n+  IPA_PASS, /* type */\n+  \"devirt\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_IPA_DEVIRT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  ( TODO_dump_symtab ), /* todo_flags_finish */\n+};\n+\n+class pass_ipa_devirt : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_devirt(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_devirt, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     NULL, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate () { return gate_ipa_devirt (); }\n+  unsigned int execute () { return ipa_devirt (); }\n+\n+}; // class pass_ipa_devirt\n+\n+} // anon namespace\n+\n+ipa_opt_pass_d *\n+make_pass_ipa_devirt (gcc::context *ctxt)\n+{\n+  return new pass_ipa_devirt (ctxt);\n+}\n+\n #include \"gt-ipa-devirt.h\""}, {"sha": "6b6652d89ca4997ef536193355e56da6d45fd5b2", "filename": "gcc/opts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -479,6 +479,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_ftree_switch_conversion, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fdevirtualize, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fdevirtualize_speculatively, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_sra, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_falign_loops, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_falign_jumps, NULL, 1 },\n@@ -1665,6 +1666,11 @@ common_handle_option (struct gcc_options *opts,\n \topts->x_flag_vect_cost_model = value;\n       if (!opts_set->x_flag_tree_loop_distribute_patterns)\n \topts->x_flag_tree_loop_distribute_patterns = value;\n+      /* Indirect call profiling should do all useful transformations\n+ \t speculative devirutalization does.  */\n+      if (!opts_set->x_flag_devirtualize_speculatively\n+\t  && opts->x_flag_value_profile_transformations)\n+\topts->x_flag_devirtualize_speculatively = false;\n       break;\n \n     case OPT_fprofile_generate_:"}, {"sha": "736a28b64dc92ca0fd9643d36242a4476f05a55d", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -104,6 +104,7 @@ along with GCC; see the file COPYING3.  If not see\n   INSERT_PASSES_AFTER (all_regular_ipa_passes)\n   NEXT_PASS (pass_ipa_whole_program_visibility);\n   NEXT_PASS (pass_ipa_profile);\n+  NEXT_PASS (pass_ipa_devirt);\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_cdtor_merge);\n   NEXT_PASS (pass_ipa_inline);"}, {"sha": "d36b9f5b32cab40031131a3f5f7a85eab6a44097", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -1,3 +1,8 @@\n+2013-08-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* g++.dg/ipa/devirt-11.C: Use -fno-devirtualize-speuclatively\n+\t* g++.dg/tree-ssa/pr45453.C: Likewise.\n+\n 2013-08-31  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/fork-instrumentation.c: New testcase."}, {"sha": "53f95bbcd3a05a10003d8f89398b757ddc58bab1", "filename": "gcc/testsuite/g++.dg/ipa/devirt-11.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-ipa-inline\" } */\n+/* { dg-options \"-O2 -fdump-ipa-inline -fno-devirtualize-speuclatively\" } */\n int baz ();\n struct A\n {"}, {"sha": "c8ef8955f0ecbfabef06c47c888ac317082ed32d", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr45453.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45453.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45453.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr45453.C?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-devirtualize-speculatively\" } */\n struct S\n {\n   S();"}, {"sha": "5fe9095323578d361fa176f550b424da9949ad79", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -66,6 +66,7 @@ DEFTIMEVAR (TV_CGRAPH                , \"callgraph construction\")\n DEFTIMEVAR (TV_CGRAPHOPT             , \"callgraph optimization\")\n DEFTIMEVAR (TV_IPA_INHERITANCE       , \"ipa inheritance graph\")\n DEFTIMEVAR (TV_IPA_VIRTUAL_CALL      , \"ipa virtual call target\")\n+DEFTIMEVAR (TV_IPA_DEVIRT\t     , \"ipa devirtualization\")\n DEFTIMEVAR (TV_IPA_CONSTANT_PROP     , \"ipa cp\")\n DEFTIMEVAR (TV_IPA_INLINING          , \"ipa inlining heuristics\")\n DEFTIMEVAR (TV_IPA_FNSPLIT           , \"ipa function splitting\")"}, {"sha": "ea1a62f4368e7fd504ae3c1f16239386a4c1430f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=bbc9396b62a65e8ecc67bb2f8df870e2b5040ac7", "patch": "@@ -468,6 +468,7 @@ extern simple_ipa_opt_pass *make_pass_ipa_free_lang_data (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_free_inline_summary (gcc::context\n \t\t\t\t\t\t\t       *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_cp (gcc::context *ctxt);\n+extern ipa_opt_pass_d *make_pass_ipa_devirt (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_reference (gcc::context *ctxt);\n extern ipa_opt_pass_d *make_pass_ipa_pure_const (gcc::context *ctxt);\n extern simple_ipa_opt_pass *make_pass_ipa_pta (gcc::context *ctxt);"}]}