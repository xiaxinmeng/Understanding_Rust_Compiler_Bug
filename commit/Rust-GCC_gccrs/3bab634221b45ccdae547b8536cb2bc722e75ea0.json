{"sha": "3bab634221b45ccdae547b8536cb2bc722e75ea0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JhYjYzNDIyMWI0NWNjZGFlNTQ3Yjg1MzZjYjJiYzcyMmU3NWVhMA==", "commit": {"author": {"name": "Andrey Turetskiy", "email": "andrey.turetskiy@intel.com", "date": "2015-09-04T08:51:44Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2015-09-04T08:51:44Z"}, "message": "tm.texi.in (TARGET_VECTORIZE_BUILTIN_SCATTER): New.\n\n\ngcc/\n\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_SCATTER): New.\n\t* doc/tm.texi: Regenerate.\n\t* target.def: Add scatter builtin.\n\t* tree-vectorizer.h: Rename gather_p to gather_scatter_p and use it\n\tfor loads/stores in case of gather/scatter accordingly.\n\t(STMT_VINFO_GATHER_SCATTER_P(S)): Use it instead of STMT_VINFO_GATHER_P(S).\n\t(vect_check_gather): Rename to ...\n\t(vect_check_gather_scatter): this.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Use\n\tSTMT_VINFO_GATHER_SCATTER_P instead of STMT_VINFO_SCATTER_P.\n\t(vect_check_gather_scatter): Use it instead of vect_check_gather.\n\t(vect_analyze_data_refs): Add gatherscatter enum and maybe_scatter variable\n\tand new checkings for it accordingly.\n\t* tree-vect-stmts.c\n\t(STMT_VINFO_GATHER_SCATTER_P(S)): Use it instead of STMT_VINFO_GATHER_P(S).\n\t(vect_check_gather_scatter): Use it instead of vect_check_gather.\n\t(vectorizable_store): Add checkings for STMT_VINFO_GATHER_SCATTER_P.\n\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Petr Murzin <petr.murzin@intel.com>\n\nFrom-SVN: r227481", "tree": {"sha": "136c31e4bcb07d3fdb5cc05b362b1dc480b14845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/136c31e4bcb07d3fdb5cc05b362b1dc480b14845"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bab634221b45ccdae547b8536cb2bc722e75ea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bab634221b45ccdae547b8536cb2bc722e75ea0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bab634221b45ccdae547b8536cb2bc722e75ea0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bab634221b45ccdae547b8536cb2bc722e75ea0/comments", "author": null, "committer": null, "parents": [{"sha": "301c092c8558aa6366013df03efa4a077d3ba61b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/301c092c8558aa6366013df03efa4a077d3ba61b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/301c092c8558aa6366013df03efa4a077d3ba61b"}], "stats": {"total": 332, "additions": 274, "deletions": 58}, "files": [{"sha": "3b783cccbc1b92448b3d50e02d80987f1af05c6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -1,3 +1,25 @@\n+2015-09-04  Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Petr Murzin  <petr.murzin@intel.com>\n+\t    Kirill Yukhin <kirill.yukhin@intel.com>\n+\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_SCATTER): New.\n+\t* doc/tm.texi: Regenerate.\n+\t* target.def: Add scatter builtin.\n+\t* tree-vectorizer.h: Rename gather_p to gather_scatter_p and use it\n+\tfor loads/stores in case of gather/scatter accordingly.\n+\t(STMT_VINFO_GATHER_SCATTER_P(S)): Use it instead of STMT_VINFO_GATHER_P(S).\n+\t(vect_check_gather): Rename to ...\n+\t(vect_check_gather_scatter): this.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Use\n+\tSTMT_VINFO_GATHER_SCATTER_P instead of STMT_VINFO_SCATTER_P.\n+\t(vect_check_gather_scatter): Use it instead of vect_check_gather.\n+\t(vect_analyze_data_refs): Add gatherscatter enum and maybe_scatter variable\n+\tand new checkings for it accordingly.\n+\t* tree-vect-stmts.c\n+\t(STMT_VINFO_GATHER_SCATTER_P(S)): Use it instead of STMT_VINFO_GATHER_P(S).\n+\t(vect_check_gather_scatter): Use it instead of vect_check_gather.\n+\t(vectorizable_store): Add checkings for STMT_VINFO_GATHER_SCATTER_P.\n+\n 2015-09-03  Bill Schmidt  <wschmidt@vnet.linux.ibm.com>\n \n \t* config/rs6000/altivec.md (altivec_vperm_v8hiv16qi): New"}, {"sha": "d548d96b234737664a3293b23d19451524521c74", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -5720,6 +5720,14 @@ The default is @code{NULL_TREE} which means to not vectorize gather\n loads.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_SCATTER (const_tree @var{vectype}, const_tree @var{index_type}, int @var{scale})\n+Target builtin that implements vector scatter operation.  @var{vectype}\n+is the vector type of the store and @var{index_type} is scalar type of\n+the index, scaled by @var{scale}.\n+The default is @code{NULL_TREE} which means to not vectorize scatter\n+stores.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN (struct cgraph_node *@var{}, struct cgraph_simd_clone *@var{}, @var{tree}, @var{int})\n This hook should set @var{vecsize_mangle}, @var{vecsize_int}, @var{vecsize_float}\n fields in @var{simd_clone} structure pointed by @var{clone_info} argument and also"}, {"sha": "9bef4a59bed252a58c77f9e02eae9da59739ebc7", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -4239,6 +4239,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_BUILTIN_GATHER\n \n+@hook TARGET_VECTORIZE_BUILTIN_SCATTER\n+\n @hook TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN\n \n @hook TARGET_SIMD_CLONE_ADJUST"}, {"sha": "aa5a1f1b193ed66766cc271296a12e7326d1c9aa", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -1801,6 +1801,18 @@ loads.\",\n  (const_tree mem_vectype, const_tree index_type, int scale),\n  NULL)\n \n+/* Target builtin that implements vector scatter operation.  */\n+DEFHOOK\n+(builtin_scatter,\n+\"Target builtin that implements vector scatter operation.  @var{vectype}\\n\\\n+is the vector type of the store and @var{index_type} is scalar type of\\n\\\n+the index, scaled by @var{scale}.\\n\\\n+The default is @code{NULL_TREE} which means to not vectorize scatter\\n\\\n+stores.\",\n+ tree,\n+ (const_tree vectype, const_tree index_type, int scale),\n+ NULL)\n+\n /* Target function to initialize the cost model for a loop or block.  */\n DEFHOOK\n (init_cost,"}, {"sha": "2439bd6390bad01ca57d2a090277f35480acc7d5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -267,8 +267,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  return false;\n \t}\n \n-      if (STMT_VINFO_GATHER_P (stmtinfo_a)\n-\t  || STMT_VINFO_GATHER_P (stmtinfo_b))\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n+\t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n@@ -315,8 +315,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  return false;\n \t}\n \n-      if (STMT_VINFO_GATHER_P (stmtinfo_a)\n-\t  || STMT_VINFO_GATHER_P (stmtinfo_b))\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmtinfo_a)\n+\t  || STMT_VINFO_GATHER_SCATTER_P (stmtinfo_b))\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n@@ -2344,10 +2344,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t                     \"zero step in outer loop.\\n\");\n-\t  if (DR_IS_READ (dr))\n-  \t    return true;\n-\t  else\n-\t    return false;\n+\t  return DR_IS_READ (dr);\n \t}\n     }\n \n@@ -2997,12 +2994,12 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   return true;\n }\n \n-/* Check whether a non-affine read in stmt is suitable for gather load\n-   and if so, return a builtin decl for that operation.  */\n+/* Check whether a non-affine read or write in stmt is suitable for gather load\n+   or scatter store and if so, return a builtin decl for that operation.  */\n \n tree\n-vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n-\t\t   tree *offp, int *scalep)\n+vect_check_gather_scatter (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n+\t\t\t   tree *offp, int *scalep)\n {\n   HOST_WIDE_INT scale = 1, pbitpos, pbitsize;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -3031,7 +3028,7 @@ vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n \tbase = TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0);\n     }\n \n-  /* The gather builtins need address of the form\n+  /* The gather and scatter builtins need address of the form\n      loop_invariant + vector * {1, 2, 4, 8}\n      or\n      loop_invariant + sign_extend (vector) * { 1, 2, 4, 8 }.\n@@ -3194,8 +3191,13 @@ vect_check_gather (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n   if (offtype == NULL_TREE)\n     offtype = TREE_TYPE (off);\n \n-  decl = targetm.vectorize.builtin_gather (STMT_VINFO_VECTYPE (stmt_info),\n-\t\t\t\t\t   offtype, scale);\n+  if (DR_IS_READ (dr))\n+    decl = targetm.vectorize.builtin_gather (STMT_VINFO_VECTYPE (stmt_info),\n+\t\t\t\t\t     offtype, scale);\n+  else\n+    decl = targetm.vectorize.builtin_scatter (STMT_VINFO_VECTYPE (stmt_info),\n+\t\t\t\t\t      offtype, scale);\n+\n   if (decl == NULL_TREE)\n     return NULL_TREE;\n \n@@ -3344,7 +3346,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       gimple stmt;\n       stmt_vec_info stmt_info;\n       tree base, offset, init;\n-      bool gather = false;\n+      enum { SG_NONE, GATHER, SCATTER } gatherscatter = SG_NONE;\n       bool simd_lane_access = false;\n       int vf;\n \n@@ -3383,18 +3385,22 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    = DR_IS_READ (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n \t      && targetm.vectorize.builtin_gather != NULL;\n+\t  bool maybe_scatter\n+\t    = DR_IS_WRITE (dr)\n+\t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n+\t      && targetm.vectorize.builtin_scatter != NULL;\n \t  bool maybe_simd_lane_access\n \t    = loop_vinfo && loop->simduid;\n \n-\t  /* If target supports vector gather loads, or if this might be\n-\t     a SIMD lane access, see if they can't be used.  */\n+\t  /* If target supports vector gather loads or scatter stores, or if\n+\t     this might be a SIMD lane access, see if they can't be used.  */\n \t  if (loop_vinfo\n-\t      && (maybe_gather || maybe_simd_lane_access)\n+\t      && (maybe_gather || maybe_scatter || maybe_simd_lane_access)\n \t      && !nested_in_vect_loop_p (loop, stmt))\n \t    {\n \t      struct data_reference *newdr\n \t\t= create_data_ref (NULL, loop_containing_stmt (stmt),\n-\t\t\t\t   DR_REF (dr), stmt, true);\n+\t\t\t\t   DR_REF (dr), stmt, maybe_scatter ? false : true);\n \t      gcc_assert (newdr != NULL && DR_REF (newdr));\n \t      if (DR_BASE_ADDRESS (newdr)\n \t\t  && DR_OFFSET (newdr)\n@@ -3447,17 +3453,20 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t\t    }\n \t\t\t}\n \t\t    }\n-\t\t  if (!simd_lane_access && maybe_gather)\n+\t\t  if (!simd_lane_access && (maybe_gather || maybe_scatter))\n \t\t    {\n \t\t      dr = newdr;\n-\t\t      gather = true;\n+\t\t      if (maybe_gather)\n+\t\t\tgatherscatter = GATHER;\n+\t\t      else\n+\t\t\tgatherscatter = SCATTER;\n \t\t    }\n \t\t}\n-\t      if (!gather && !simd_lane_access)\n+\t      if (gatherscatter == SG_NONE && !simd_lane_access)\n \t\tfree_data_ref (newdr);\n \t    }\n \n-\t  if (!gather && !simd_lane_access)\n+\t  if (gatherscatter == SG_NONE && !simd_lane_access)\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -3485,7 +3494,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    free_data_ref (dr);\n \t  return false;\n         }\n@@ -3520,7 +3529,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n         }\n@@ -3540,7 +3549,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n \t}\n@@ -3565,7 +3574,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    free_data_ref (dr);\n \t  return false;\n \t}\n@@ -3703,7 +3712,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n         }\n@@ -3736,10 +3745,10 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather || simd_lane_access)\n+\t  if (gatherscatter != SG_NONE || simd_lane_access)\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n-\t      if (gather)\n+\t      if (gatherscatter != SG_NONE)\n \t\tfree_data_ref (dr);\n \t    }\n \t  return false;\n@@ -3763,32 +3772,32 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (vf > *min_vf)\n \t*min_vf = vf;\n \n-      if (gather)\n+      if (gatherscatter != SG_NONE)\n \t{\n \t  tree off;\n-\n-\t  gather = 0 != vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL);\n-\t  if (gather\n-\t      && get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n-\t    gather = false;\n-\t  if (!gather)\n+\t  if (!vect_check_gather_scatter (stmt, loop_vinfo, NULL, &off, NULL)\n+\t      || get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n \t      free_data_ref (dr);\n \t      if (dump_enabled_p ())\n \t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                   \"not vectorized: not suitable for gather \"\n-                                   \"load \");\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   (gatherscatter == GATHER) ?\n+\t\t\t\t   \"not vectorized: not suitable for gather \"\n+\t\t\t\t   \"load \" :\n+\t\t\t\t   \"not vectorized: not suitable for scatter \"\n+\t\t\t\t   \"store \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n                   dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n \n \t  datarefs[i] = dr;\n-\t  STMT_VINFO_GATHER_P (stmt_info) = true;\n+\t  STMT_VINFO_GATHER_SCATTER_P (stmt_info) = gatherscatter;\n \t}\n+\n       else if (loop_vinfo\n \t       && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n \t{"}, {"sha": "359e010f7f9eb5a39b64b043c7bd5e4ebbed7fd7", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 174, "deletions": 11, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -810,10 +810,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               return false;\n           }\n \n-      if (STMT_VINFO_GATHER_P (stmt_vinfo))\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo))\n \t{\n \t  tree off;\n-\t  tree decl = vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL);\n+\t  tree decl = vect_check_gather_scatter (stmt, loop_vinfo, NULL, &off, NULL);\n \t  gcc_assert (decl);\n \t  if (!process_use (stmt, off, loop_vinfo, live_p, relevant,\n \t\t\t    &worklist, true))\n@@ -1815,11 +1815,11 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_STRIDED_P (stmt_info))\n     return false;\n \n-  if (STMT_VINFO_GATHER_P (stmt_info))\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple def_stmt;\n       tree def;\n-      gather_decl = vect_check_gather (stmt, loop_vinfo, &gather_base,\n+      gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n \t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n       if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo, NULL,\n@@ -1879,7 +1879,7 @@ vectorizable_mask_load_store (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /** Transform.  **/\n \n-  if (STMT_VINFO_GATHER_P (stmt_info))\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gather_decl));\n@@ -5140,6 +5140,12 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   unsigned int vec_num;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   tree aggr_type;\n+  tree scatter_base = NULL_TREE, scatter_off = NULL_TREE;\n+  tree scatter_off_vectype = NULL_TREE, scatter_decl = NULL_TREE;\n+  int scatter_scale = 1;\n+  enum vect_def_type scatter_idx_dt = vect_unknown_def_type;\n+  enum vect_def_type scatter_src_dt = vect_unknown_def_type;\n+  gimple new_stmt;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -5297,6 +5303,24 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n         }\n     }\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    {\n+      gimple def_stmt;\n+      tree def;\n+      scatter_decl = vect_check_gather_scatter (stmt, loop_vinfo, &scatter_base,\n+\t\t\t\t\t\t&scatter_off, &scatter_scale);\n+      gcc_assert (scatter_decl);\n+      if (!vect_is_simple_use_1 (scatter_off, NULL, loop_vinfo, bb_vinfo,\n+\t\t\t\t &def_stmt, &def, &scatter_idx_dt,\n+\t\t\t\t &scatter_off_vectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                             \"scatter index use not simple.\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n@@ -5311,6 +5335,146 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   ensure_base_align (stmt_info, dr);\n \n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    {\n+      tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE, op, src;\n+      tree arglist = TYPE_ARG_TYPES (TREE_TYPE (scatter_decl));\n+      tree rettype, srctype, ptrtype, idxtype, masktype, scaletype;\n+      tree ptr, mask, var, scale, perm_mask = NULL_TREE;\n+      edge pe = loop_preheader_edge (loop);\n+      gimple_seq seq;\n+      basic_block new_bb;\n+      enum { NARROW, NONE, WIDEN } modifier;\n+      int scatter_off_nunits = TYPE_VECTOR_SUBPARTS (scatter_off_vectype);\n+\n+      if (nunits == (unsigned int) scatter_off_nunits)\n+\tmodifier = NONE;\n+      else if (nunits == (unsigned int) scatter_off_nunits / 2)\n+\t{\n+\t  unsigned char *sel = XALLOCAVEC (unsigned char, scatter_off_nunits);\n+\t  modifier = WIDEN;\n+\n+\t  for (i = 0; i < (unsigned int) scatter_off_nunits; ++i)\n+\t    sel[i] = i | nunits;\n+\n+\t  perm_mask = vect_gen_perm_mask_checked (scatter_off_vectype, sel);\n+\t  gcc_assert (perm_mask != NULL_TREE);\n+\t}\n+      else if (nunits == (unsigned int) scatter_off_nunits * 2)\n+\t{\n+\t  unsigned char *sel = XALLOCAVEC (unsigned char, nunits);\n+\t  modifier = NARROW;\n+\n+\t  for (i = 0; i < (unsigned int) nunits; ++i)\n+\t    sel[i] = i | scatter_off_nunits;\n+\n+\t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n+\t  gcc_assert (perm_mask != NULL_TREE);\n+\t  ncopies *= 2;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      rettype = TREE_TYPE (TREE_TYPE (scatter_decl));\n+      ptrtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+      masktype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+      idxtype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+      srctype = TREE_VALUE (arglist); arglist = TREE_CHAIN (arglist);\n+      scaletype = TREE_VALUE (arglist);\n+\n+      gcc_checking_assert (TREE_CODE (masktype) == INTEGER_TYPE\n+\t\t\t   && TREE_CODE (rettype) == VOID_TYPE);\n+\n+      ptr = fold_convert (ptrtype, scatter_base);\n+      if (!is_gimple_min_invariant (ptr))\n+\t{\n+\t  ptr = force_gimple_operand (ptr, &seq, true, NULL_TREE);\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n+      /* Currently we support only unconditional scatter stores,\n+\t so mask should be all ones.  */\n+      mask = build_int_cst (masktype, -1);\n+      mask = vect_init_vector (stmt, mask, masktype, NULL);\n+\n+      scale = build_int_cst (scaletype, scatter_scale);\n+\n+      prev_stmt_info = NULL;\n+      for (j = 0; j < ncopies; ++j)\n+\t{\n+\t  if (j == 0)\n+\t    {\n+\t      src = vec_oprnd1\n+\t\t= vect_get_vec_def_for_operand (gimple_assign_rhs1 (stmt), stmt, NULL);\n+\t      op = vec_oprnd0\n+\t\t= vect_get_vec_def_for_operand (scatter_off, stmt, NULL);\n+\t    }\n+\t  else if (modifier != NONE && (j & 1))\n+\t    {\n+\t      if (modifier == WIDEN)\n+\t\t{\n+\t\t  src = vec_oprnd1\n+\t\t    = vect_get_vec_def_for_stmt_copy (scatter_src_dt, vec_oprnd1);\n+\t\t  op = permute_vec_elements (vec_oprnd0, vec_oprnd0, perm_mask,\n+\t\t\t\t\t     stmt, gsi);\n+\t\t}\n+\t      else if (modifier == NARROW)\n+\t\t{\n+\t\t  src = permute_vec_elements (vec_oprnd1, vec_oprnd1, perm_mask,\n+\t\t\t\t\t      stmt, gsi);\n+\t\t  op = vec_oprnd0\n+\t\t    = vect_get_vec_def_for_stmt_copy (scatter_idx_dt, vec_oprnd0);\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else\n+\t    {\n+\t      src = vec_oprnd1\n+\t\t= vect_get_vec_def_for_stmt_copy (scatter_src_dt, vec_oprnd1);\n+\t      op = vec_oprnd0\n+\t\t= vect_get_vec_def_for_stmt_copy (scatter_idx_dt, vec_oprnd0);\n+\t    }\n+\n+\t  if (!useless_type_conversion_p (srctype, TREE_TYPE (src)))\n+\t    {\n+\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (src))\n+\t\t\t  == TYPE_VECTOR_SUBPARTS (srctype));\n+\t      var = vect_get_new_vect_var (srctype, vect_simple_var, NULL);\n+\t      var = make_ssa_name (var);\n+\t      src = build1 (VIEW_CONVERT_EXPR, srctype, src);\n+\t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, src);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      src = var;\n+\t    }\n+\n+\t  if (!useless_type_conversion_p (idxtype, TREE_TYPE (op)))\n+\t    {\n+\t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n+\t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n+\t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n+\t      var = make_ssa_name (var);\n+\t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n+\t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      op = var;\n+\t    }\n+\n+\t  new_stmt\n+\t    = gimple_build_call (scatter_decl, 5, ptr, mask, op, src, scale);\n+\n+\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\n+\t  if (prev_stmt_info == NULL)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n+      return true;\n+    }\n+\n   if (grouped_store)\n     {\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n@@ -5584,7 +5748,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n-      gimple new_stmt;\n \n       if (j == 0)\n \t{\n@@ -6071,7 +6234,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       grouped_load = true;\n       /* FORNOW */\n-      gcc_assert (! nested_in_vect_loop && !STMT_VINFO_GATHER_P (stmt_info));\n+      gcc_assert (!nested_in_vect_loop && !STMT_VINFO_GATHER_SCATTER_P (stmt_info));\n \n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n \n@@ -6134,12 +6297,12 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     }\n \n \n-  if (STMT_VINFO_GATHER_P (stmt_info))\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       gimple def_stmt;\n       tree def;\n-      gather_decl = vect_check_gather (stmt, loop_vinfo, &gather_base,\n-\t\t\t\t       &gather_off, &gather_scale);\n+      gather_decl = vect_check_gather_scatter (stmt, loop_vinfo, &gather_base,\n+\t\t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n       if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n@@ -6225,7 +6388,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   ensure_base_align (stmt_info, dr);\n \n-  if (STMT_VINFO_GATHER_P (stmt_info))\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gather_decl));"}, {"sha": "95276fa3069f5dd6cd582b86e1cc8ce8b97c54f9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bab634221b45ccdae547b8536cb2bc722e75ea0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=3bab634221b45ccdae547b8536cb2bc722e75ea0", "patch": "@@ -646,8 +646,8 @@ typedef struct _stmt_vec_info {\n      vectorization.  */\n   bool vectorizable;\n \n-  /* For loads only, true if this is a gather load.  */\n-  bool gather_p;\n+  /* For loads if this is a gather, for stores if this is a scatter.  */\n+  bool gather_scatter_p;\n \n   /* True if this is an access with loop-invariant stride.  */\n   bool strided_p;\n@@ -667,7 +667,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VEC_STMT(S)             (S)->vectorized_stmt\n #define STMT_VINFO_VECTORIZABLE(S)         (S)->vectorizable\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n-#define STMT_VINFO_GATHER_P(S)\t\t   (S)->gather_p\n+#define STMT_VINFO_GATHER_SCATTER_P(S)\t   (S)->gather_scatter_p\n #define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n \n@@ -1063,8 +1063,8 @@ extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n-extern tree vect_check_gather (gimple, loop_vec_info, tree *, tree *,\n-\t\t\t       int *);\n+extern tree vect_check_gather_scatter (gimple, loop_vec_info, tree *, tree *,\n+\t\t\t\t       int *);\n extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *,\n \t\t\t\t    unsigned *);\n extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,"}]}