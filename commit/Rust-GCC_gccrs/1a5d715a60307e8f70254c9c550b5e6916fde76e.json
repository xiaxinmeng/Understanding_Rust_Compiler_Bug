{"sha": "1a5d715a60307e8f70254c9c550b5e6916fde76e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE1ZDcxNWE2MDMwN2U4ZjcwMjU0YzljNTUwYjVlNjkxNmZkZTc2ZQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2008-03-26T07:41:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:41:16Z"}, "message": "prj-dect.adb (Parse_Package_Declaration): When a package name is not known...\n\n2008-03-26  Vincent Celier  <celier@adacore.com>\n\n\t* prj-dect.adb (Parse_Package_Declaration): When a package name is not\n\tknown, check if it may be a missspelling of a known package name. In\n\tnot verbose, not mode, issue warnings only if the package name is a\n\tpossible misspelling.\n\tIn verbose mode, always issue a warning for a not known package name,\n\tplus a warning if the name is a misspelling of a known package name.\n\n\t* prj-part.adb (Post_Parse_Context_Clause): Modify so that only non\n\tlimited withs or limited withs are parse during one call.\n\t(Parse_Single_Project): Post parse context clause in two passes: non\n\tlimited withs before current project and limited withs after current\n\tproject.\n\n\t* prj-proc.adb (Imported_Or_Extended_Project_From): Returns an extended\n\tproject with the name With_Name, even if it is only extended indirectly.\n\t(Recursive_Process): Process projects in order: first single withs, then\n\tcurrent project, then limited withs.\n\n\t* prj-tree.adb (Imported_Or_Extended_Project_Of): Returns an extended\n\tproject with the name With_Name, even if it is only extended indirectly.\n\nFrom-SVN: r133573", "tree": {"sha": "54e5aca690e7c8b722828bd61f591179adac950e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54e5aca690e7c8b722828bd61f591179adac950e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a5d715a60307e8f70254c9c550b5e6916fde76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5d715a60307e8f70254c9c550b5e6916fde76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5d715a60307e8f70254c9c550b5e6916fde76e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5d715a60307e8f70254c9c550b5e6916fde76e/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b2b6798119883d6cc535db15cc19baaae32bb49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b2b6798119883d6cc535db15cc19baaae32bb49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b2b6798119883d6cc535db15cc19baaae32bb49"}], "stats": {"total": 700, "additions": 435, "deletions": 265}, "files": [{"sha": "f9528d0de9a337ff34af34485be36be020181dd1", "filename": "gcc/ada/prj-dect.adb", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-dect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-dect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-dect.adb?ref=1a5d715a60307e8f70254c9c550b5e6916fde76e", "patch": "@@ -25,7 +25,8 @@\n \n with Err_Vars; use Err_Vars;\n \n-with GNAT.Case_Util; use GNAT.Case_Util;\n+with GNAT.Case_Util;        use GNAT.Case_Util;\n+with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n \n with Opt;         use Opt;\n with Prj.Attr;    use Prj.Attr;\n@@ -36,8 +37,12 @@ with Prj.Tree;    use Prj.Tree;\n with Snames;\n with Uintp;       use Uintp;\n \n+with System.Strings;\n+\n package body Prj.Dect is\n \n+   use System;\n+\n    type Zone is (In_Project, In_Package, In_Case_Construction);\n    --  Used to indicate if we are parsing a package (In_Package),\n    --  a case construction (In_Case_Construction) or none of those two\n@@ -983,11 +988,44 @@ package body Prj.Dect is\n \n          if Current_Package = Empty_Package then\n             if not Quiet_Output then\n-               Error_Msg (\"?\"\"\" &\n-                          Get_Name_String\n-                            (Name_Of (Package_Declaration, In_Tree)) &\n-                          \"\"\" is not a known package name\",\n-                          Token_Ptr);\n+               declare\n+                  List  : constant Strings.String_List := Package_Name_List;\n+                  Index : Natural;\n+                  Name  : constant String := Get_Name_String (Token_Name);\n+\n+               begin\n+                  --  Check for possible misspelling of a known package name\n+\n+                  Index := 0;\n+                  loop\n+                     if Index >= List'Last then\n+                        Index := 0;\n+                        exit;\n+                     end if;\n+\n+                     Index := Index + 1;\n+                     exit when\n+                       GNAT.Spelling_Checker.Is_Bad_Spelling_Of\n+                         (Name, List (Index).all);\n+                  end loop;\n+\n+                  --  Issue warning(s) in verbose mode or when a possible\n+                  --  misspelling has been found.\n+\n+                  if Verbose_Mode or else Index /= 0 then\n+                     Error_Msg (\"?\"\"\" &\n+                                Get_Name_String\n+                                 (Name_Of (Package_Declaration, In_Tree)) &\n+                                \"\"\" is not a known package name\",\n+                                Token_Ptr);\n+                  end if;\n+\n+                  if Index /= 0 then\n+                     Error_Msg (\"\\?possible misspelling of \"\"\" &\n+                                List (Index).all & \"\"\"\",\n+                                Token_Ptr);\n+                  end if;\n+               end;\n             end if;\n \n             --  Set the package declaration to \"ignored\" so that it is not"}, {"sha": "a7864c5df813e9f0de6ff7f879404871fc7a2294", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 216, "deletions": 161, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=1a5d715a60307e8f70254c9c550b5e6916fde76e", "patch": "@@ -72,13 +72,16 @@ package body Prj.Part is\n       Table_Increment      => 100,\n       Table_Name           => \"Prj.Part.Withs\");\n    --  Table used to store temporarily paths and locations of imported\n-   --  projects. These imported projects will be effectively parsed after the\n-   --  name of the current project has been extablished.\n+   --  projects. These imported projects will be effectively parsed later: just\n+   --  before parsing the current project for the non limited withed projects,\n+   --  after getting its name; after complete parsing of the current project\n+   --  for the limited withed projects.\n \n    type Names_And_Id is record\n       Path_Name           : Path_Name_Type;\n       Canonical_Path_Name : Path_Name_Type;\n       Id                  : Project_Node_Id;\n+      Limited_With        : Boolean;\n    end record;\n \n    package Project_Stack is new Table.Table\n@@ -147,25 +150,28 @@ package body Prj.Part is\n    procedure Pre_Parse_Context_Clause\n      (In_Tree        : Project_Node_Tree_Ref;\n       Context_Clause : out With_Id);\n-   --  Parse the context clause of a project.\n-   --  Store the paths and locations of the imported projects in table Withs.\n-   --  Does nothing if there is no context clause (if the current\n-   --  token is not \"with\" or \"limited\" followed by \"with\").\n+   --  Parse the context clause of a project. Store the paths and locations of\n+   --  the imported projects in table Withs. Does nothing if there is no\n+   --  context clause (if the current token is not \"with\" or \"limited\" followed\n+   --  by \"with\").\n \n    procedure Post_Parse_Context_Clause\n      (Context_Clause    : With_Id;\n       In_Tree           : Project_Node_Tree_Ref;\n-      Imported_Projects : out Project_Node_Id;\n+      Limited_Withs     : Boolean;\n+      Imported_Projects : in out Project_Node_Id;\n       Project_Directory : Path_Name_Type;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n       Packages_To_Check : String_List_Access;\n       Depth             : Natural;\n       Current_Dir       : String);\n-   --  Parse the imported projects that have been stored in table Withs,\n-   --  if any. From_Extended is used for the call to Parse_Single_Project\n-   --  below. When In_Limited is True, the importing path includes at least\n-   --  one \"limited with\".\n+   --  Parse the imported projects that have been stored in table Withs, if\n+   --  any. From_Extended is used for the call to Parse_Single_Project below.\n+   --  When In_Limited is True, the importing path includes at least one\n+   --  \"limited with\". When Limited_Withs is False, only non limited withed\n+   --  projects are parsed. When Limited_Withs is True, only limited withed\n+   --  projects are parsed.\n \n    function Project_Path_Name_Of\n      (Project_File_Name : String;\n@@ -645,7 +651,7 @@ package body Prj.Part is\n \n          Comma_Loop :\n          loop\n-            Scan (In_Tree); -- scan past WITH or \",\"\n+            Scan (In_Tree); -- past WITH or \",\"\n \n             Expect (Tok_String_Literal, \"literal string\");\n \n@@ -682,7 +688,7 @@ package body Prj.Part is\n \n                --  End of (possibly multiple) with clause;\n \n-               Scan (In_Tree); -- scan past the semicolon.\n+               Scan (In_Tree); -- past the semicolon\n                exit Comma_Loop;\n \n             elsif Token = Tok_Comma then\n@@ -707,7 +713,8 @@ package body Prj.Part is\n    procedure Post_Parse_Context_Clause\n      (Context_Clause    : With_Id;\n       In_Tree           : Project_Node_Tree_Ref;\n-      Imported_Projects : out Project_Node_Id;\n+      Limited_Withs     : Boolean;\n+      Imported_Projects : in out Project_Node_Id;\n       Project_Directory : Path_Name_Type;\n       From_Extended     : Extension_Origin;\n       In_Limited        : Boolean;\n@@ -717,171 +724,185 @@ package body Prj.Part is\n    is\n       Current_With_Clause : With_Id := Context_Clause;\n \n-      Current_Project  : Project_Node_Id := Empty_Node;\n+      Current_Project  : Project_Node_Id := Imported_Projects;\n       Previous_Project : Project_Node_Id := Empty_Node;\n       Next_Project     : Project_Node_Id := Empty_Node;\n \n       Project_Directory_Path : constant String :=\n                                  Get_Name_String (Project_Directory);\n \n       Current_With : With_Record;\n-      Limited_With : Boolean := False;\n       Extends_All  : Boolean := False;\n \n    begin\n-      Imported_Projects := Empty_Node;\n+      --  Set Current_Project to the last project in the current list, if the\n+      --  list is not empty.\n+\n+      if Current_Project /= Empty_Node then\n+         while\n+           Next_With_Clause_Of (Current_Project, In_Tree) /= Empty_Node\n+         loop\n+            Current_Project := Next_With_Clause_Of (Current_Project, In_Tree);\n+         end loop;\n+      end if;\n \n       while Current_With_Clause /= No_With loop\n          Current_With := Withs.Table (Current_With_Clause);\n          Current_With_Clause := Current_With.Next;\n \n-         Limited_With := In_Limited or Current_With.Limited_With;\n-\n-         declare\n-            Original_Path : constant String :=\n-                              Get_Name_String (Current_With.Path);\n-\n-            Imported_Path_Name : constant String :=\n-                                   Project_Path_Name_Of\n-                                     (Original_Path, Project_Directory_Path);\n-\n-            Resolved_Path : constant String :=\n-                              Normalize_Pathname\n-                                (Imported_Path_Name,\n-                                 Directory     => Current_Dir,\n-                                 Resolve_Links => Opt.Follow_Links_For_Files,\n-                                 Case_Sensitive => True);\n-\n-            Withed_Project : Project_Node_Id := Empty_Node;\n+         if Limited_Withs = Current_With.Limited_With then\n+            declare\n+               Original_Path : constant String :=\n+                                 Get_Name_String (Current_With.Path);\n \n-         begin\n-            if Imported_Path_Name = \"\" then\n+               Imported_Path_Name : constant String :=\n+                                      Project_Path_Name_Of\n+                                        (Original_Path,\n+                                         Project_Directory_Path);\n \n-               --  The project file cannot be found\n+               Resolved_Path : constant String :=\n+                                 Normalize_Pathname\n+                                   (Imported_Path_Name,\n+                                    Directory      => Current_Dir,\n+                                    Resolve_Links  =>\n+                                      Opt.Follow_Links_For_Files,\n+                                    Case_Sensitive => True);\n \n-               Error_Msg_File_1 := File_Name_Type (Current_With.Path);\n+               Withed_Project : Project_Node_Id := Empty_Node;\n \n-               Error_Msg (\"unknown project file: {\", Current_With.Location);\n+            begin\n+               if Imported_Path_Name = \"\" then\n \n-               --  If this is not imported by the main project file,\n-               --  display the import path.\n+                  --  The project file cannot be found\n \n-               if Project_Stack.Last > 1 then\n-                  for Index in reverse 1 .. Project_Stack.Last loop\n-                     Error_Msg_File_1 :=\n-                       File_Name_Type (Project_Stack.Table (Index).Path_Name);\n-                     Error_Msg (\"\\imported by {\", Current_With.Location);\n-                  end loop;\n-               end if;\n+                  Error_Msg_File_1 := File_Name_Type (Current_With.Path);\n+                  Error_Msg\n+                    (\"unknown project file: {\", Current_With.Location);\n \n-            else\n-               --  New with clause\n+                  --  If this is not imported by the main project file, display\n+                  --  the import path.\n \n-               Previous_Project := Current_Project;\n+                  if Project_Stack.Last > 1 then\n+                     for Index in reverse 1 .. Project_Stack.Last loop\n+                        Error_Msg_File_1 :=\n+                          File_Name_Type\n+                            (Project_Stack.Table (Index).Path_Name);\n+                        Error_Msg\n+                          (\"\\imported by {\", Current_With.Location);\n+                     end loop;\n+                  end if;\n \n-               if Current_Project = Empty_Node then\n+               else\n+                  --  New with clause\n \n-                  --  First with clause of the context clause\n+                  Previous_Project := Current_Project;\n \n-                  Current_Project := Current_With.Node;\n-                  Imported_Projects := Current_Project;\n+                  if Current_Project = Empty_Node then\n \n-               else\n-                  Next_Project := Current_With.Node;\n-                  Set_Next_With_Clause_Of\n-                    (Current_Project, In_Tree, Next_Project);\n-                  Current_Project := Next_Project;\n-               end if;\n+                     --  First with clause of the context clause\n \n-               Set_String_Value_Of\n-                 (Current_Project, In_Tree, Name_Id (Current_With.Path));\n-               Set_Location_Of\n-                 (Current_Project, In_Tree, Current_With.Location);\n+                     Current_Project := Current_With.Node;\n+                     Imported_Projects := Current_Project;\n \n-               --  If this is a \"limited with\", check if we have a circularity.\n-               --  If we have one, get the project id of the limited imported\n-               --  project file, and do not parse it.\n+                  else\n+                     Next_Project := Current_With.Node;\n+                     Set_Next_With_Clause_Of\n+                       (Current_Project, In_Tree, Next_Project);\n+                     Current_Project := Next_Project;\n+                  end if;\n \n-               if Limited_With and then Project_Stack.Last > 1 then\n-                  declare\n-                     Canonical_Path_Name : Path_Name_Type;\n+                  Set_String_Value_Of\n+                    (Current_Project,\n+                     In_Tree,\n+                     Name_Id (Current_With.Path));\n+                  Set_Location_Of\n+                    (Current_Project, In_Tree, Current_With.Location);\n+\n+                  --  If it is a limited with, check if we have a circularity.\n+                  --  If we have one, get the project id of the limited\n+                  --  imported project file, and do not parse it.\n+\n+                  if Limited_Withs and then Project_Stack.Last > 1 then\n+                     declare\n+                        Canonical_Path_Name : Path_Name_Type;\n+\n+                     begin\n+                        Name_Len := Resolved_Path'Length;\n+                        Name_Buffer (1 .. Name_Len) := Resolved_Path;\n+                        Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n+                        Canonical_Path_Name := Name_Find;\n+\n+                        for Index in 1 .. Project_Stack.Last loop\n+                           if Project_Stack.Table (Index).Canonical_Path_Name =\n+                             Canonical_Path_Name\n+                           then\n+                              --  We have found the limited imported project,\n+                              --  get its project id, and do not parse it.\n \n-                  begin\n-                     Name_Len := Resolved_Path'Length;\n-                     Name_Buffer (1 .. Name_Len) := Resolved_Path;\n-                     Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                     Canonical_Path_Name := Name_Find;\n+                              Withed_Project := Project_Stack.Table (Index).Id;\n+                              exit;\n+                           end if;\n+                        end loop;\n+                     end;\n+                  end if;\n \n-                     for Index in 1 .. Project_Stack.Last loop\n-                        if Project_Stack.Table (Index).Canonical_Path_Name =\n-                             Canonical_Path_Name\n-                        then\n-                           --  We have found the limited imported project,\n-                           --  get its project id, and do not parse it.\n+                  --  Parse the imported project, if its project id is unknown\n \n-                           Withed_Project := Project_Stack.Table (Index).Id;\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end;\n-               end if;\n+                  if Withed_Project = Empty_Node then\n+                     Parse_Single_Project\n+                       (In_Tree           => In_Tree,\n+                        Project           => Withed_Project,\n+                        Extends_All       => Extends_All,\n+                        Path_Name         => Imported_Path_Name,\n+                        Extended          => False,\n+                        From_Extended     => From_Extended,\n+                        In_Limited        => Limited_Withs,\n+                        Packages_To_Check => Packages_To_Check,\n+                        Depth             => Depth,\n+                        Current_Dir       => Current_Dir);\n \n-               --  Parse the imported project, if its project id is unknown\n-\n-               if Withed_Project = Empty_Node then\n-                  Parse_Single_Project\n-                    (In_Tree           => In_Tree,\n-                     Project           => Withed_Project,\n-                     Extends_All       => Extends_All,\n-                     Path_Name         => Imported_Path_Name,\n-                     Extended          => False,\n-                     From_Extended     => From_Extended,\n-                     In_Limited        => Limited_With,\n-                     Packages_To_Check => Packages_To_Check,\n-                     Depth             => Depth,\n-                     Current_Dir       => Current_Dir);\n+                  else\n+                     Extends_All := Is_Extending_All (Withed_Project, In_Tree);\n+                  end if;\n \n-               else\n-                  Extends_All := Is_Extending_All (Withed_Project, In_Tree);\n-               end if;\n+                  if Withed_Project = Empty_Node then\n \n-               if Withed_Project = Empty_Node then\n-                  --  If parsing was not successful, remove the\n-                  --  context clause.\n+                     --  If parsing unsuccessful, remove the context clause\n \n-                  Current_Project := Previous_Project;\n+                     Current_Project := Previous_Project;\n \n-                  if Current_Project = Empty_Node then\n-                     Imported_Projects := Empty_Node;\n+                     if Current_Project = Empty_Node then\n+                        Imported_Projects := Empty_Node;\n \n+                     else\n+                        Set_Next_With_Clause_Of\n+                          (Current_Project, In_Tree, Empty_Node);\n+                     end if;\n                   else\n-                     Set_Next_With_Clause_Of\n-                       (Current_Project, In_Tree, Empty_Node);\n-                  end if;\n-               else\n-                  --  If parsing was successful, record project name\n-                  --  and path name in with clause\n-\n-                  Set_Project_Node_Of\n-                    (Node         => Current_Project,\n-                     In_Tree      => In_Tree,\n-                     To           => Withed_Project,\n-                     Limited_With => Current_With.Limited_With);\n-                  Set_Name_Of\n-                    (Current_Project,\n-                     In_Tree,\n-                     Name_Of (Withed_Project, In_Tree));\n+                     --  If parsing was successful, record project name and\n+                     --  path name in with clause\n+\n+                     Set_Project_Node_Of\n+                       (Node         => Current_Project,\n+                        In_Tree      => In_Tree,\n+                        To           => Withed_Project,\n+                        Limited_With => Current_With.Limited_With);\n+                     Set_Name_Of\n+                       (Current_Project,\n+                        In_Tree,\n+                        Name_Of (Withed_Project, In_Tree));\n \n-                  Name_Len := Resolved_Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := Resolved_Path;\n-                  Set_Path_Name_Of (Current_Project, In_Tree, Name_Find);\n+                     Name_Len := Resolved_Path'Length;\n+                     Name_Buffer (1 .. Name_Len) := Resolved_Path;\n+                     Set_Path_Name_Of (Current_Project, In_Tree, Name_Find);\n \n-                  if Extends_All then\n-                     Set_Is_Extending_All (Current_Project, In_Tree);\n+                     if Extends_All then\n+                        Set_Is_Extending_All (Current_Project, In_Tree);\n+                     end if;\n                   end if;\n                end if;\n-            end if;\n-         end;\n+            end;\n+         end if;\n       end loop;\n    end Post_Parse_Context_Clause;\n \n@@ -909,17 +930,16 @@ package body Prj.Part is\n \n       Extending : Boolean := False;\n \n-      Extended_Project    : Project_Node_Id := Empty_Node;\n+      Extended_Project : Project_Node_Id := Empty_Node;\n \n       A_Project_Name_And_Node : Tree_Private_Part.Project_Name_And_Node :=\n                                   Tree_Private_Part.Projects_Htable.Get_First\n                                     (In_Tree.Projects_HT);\n \n-      Name_From_Path      : constant Name_Id := Project_Name_From (Path_Name);\n-\n-      Name_Of_Project : Name_Id := No_Name;\n-\n-      First_With : With_Id;\n+      Name_From_Path    : constant Name_Id := Project_Name_From (Path_Name);\n+      Name_Of_Project   : Name_Id := No_Name;\n+      First_With        : With_Id;\n+      Imported_Projects : Project_Node_Id := Empty_Node;\n \n       use Tree_Private_Part;\n \n@@ -939,7 +959,6 @@ package body Prj.Part is\n                              Directory      => Current_Dir,\n                              Resolve_Links  => Opt.Follow_Links_For_Files,\n                              Case_Sensitive => False);\n-\n       begin\n          Name_Len := Normed_Path'Length;\n          Name_Buffer (1 .. Name_Len) := Normed_Path;\n@@ -951,7 +970,9 @@ package body Prj.Part is\n \n       --  Check for a circular dependency\n \n-      for Index in 1 .. Project_Stack.Last loop\n+      for Index in reverse 1 .. Project_Stack.Last loop\n+         exit when Project_Stack.Table (Index).Limited_With;\n+\n          if Canonical_Path_Name =\n               Project_Stack.Table (Index).Canonical_Path_Name\n          then\n@@ -982,10 +1003,11 @@ package body Prj.Part is\n \n       --  Put the new path name on the stack\n \n-      Project_Stack.Increment_Last;\n-      Project_Stack.Table (Project_Stack.Last).Path_Name := Normed_Path_Name;\n-      Project_Stack.Table (Project_Stack.Last).Canonical_Path_Name :=\n-        Canonical_Path_Name;\n+      Project_Stack.Append\n+        ((Path_Name           => Normed_Path_Name,\n+          Canonical_Path_Name => Canonical_Path_Name,\n+          Id                  => Empty_Node,\n+          Limited_With        => In_Limited));\n \n       --  Check if the project file has already been parsed\n \n@@ -1009,9 +1031,9 @@ package body Prj.Part is\n                Extends_All :=\n                  Is_Extending_All (A_Project_Name_And_Node.Node, In_Tree);\n \n-               --  If the imported project is an extended project A,\n-               --  and we are in an extended project, replace A with the\n-               --  ultimate project extending A.\n+               --  If the imported project is an extended project A, and we are\n+               --  in an extended project, replace A with the ultimate project\n+               --  extending A.\n \n                if From_Extended /= None then\n                   declare\n@@ -1048,8 +1070,8 @@ package body Prj.Part is\n            Tree_Private_Part.Projects_Htable.Get_Next (In_Tree.Projects_HT);\n       end loop;\n \n-      --  We never encountered this project file\n-      --  Save the scan state, load the project file and start to scan it.\n+      --  We never encountered this project file. Save the scan state, load the\n+      --  project file and start to scan it.\n \n       Save_Project_Scan_State (Project_Scan_State);\n       Source_Index := Load_Project_File (Path_Name);\n@@ -1069,8 +1091,8 @@ package body Prj.Part is\n \n       if (not In_Configuration) and then (Name_From_Path = No_Name) then\n \n-         --  The project file name is not correct (no or bad extension,\n-         --  or not following Ada identifier's syntax).\n+         --  The project file name is not correct (no or bad extension, or not\n+         --  following Ada identifier's syntax).\n \n          Error_Msg_File_1 := File_Name_Type (Canonical_Path_Name);\n          Error_Msg (\"?{ is not a valid path name for a project file\",\n@@ -1084,24 +1106,27 @@ package body Prj.Part is\n          Write_Eol;\n       end if;\n \n+      Project_Directory := Immediate_Directory_Of (Normed_Path_Name);\n+\n       --  Is there any imported project?\n \n-      Pre_Parse_Context_Clause (In_Tree, First_With);\n+      Pre_Parse_Context_Clause\n+        (In_Tree        => In_Tree,\n+         Context_Clause => First_With);\n \n-      Project_Directory := Immediate_Directory_Of (Normed_Path_Name);\n       Project := Default_Project_Node\n                    (Of_Kind => N_Project, In_Tree => In_Tree);\n       Project_Stack.Table (Project_Stack.Last).Id := Project;\n       Set_Directory_Of (Project, In_Tree, Project_Directory);\n       Set_Path_Name_Of (Project, In_Tree,  Normed_Path_Name);\n       Set_Location_Of (Project, In_Tree, Token_Ptr);\n-\n+      Set_First_With_Clause_Of (Project, In_Tree, Imported_Projects);\n       Expect (Tok_Project, \"PROJECT\");\n \n       --  Mark location of PROJECT token if present\n \n       if Token = Tok_Project then\n-         Scan (In_Tree); -- scan past PROJECT\n+         Scan (In_Tree); -- past PROJECT\n          Set_Location_Of (Project, In_Tree, Token_Ptr);\n       end if;\n \n@@ -1156,7 +1181,7 @@ package body Prj.Part is\n \n          Extending := True;\n \n-         Scan (In_Tree); -- scan past EXTENDS\n+         Scan (In_Tree); -- past EXTENDS\n \n          if Token = Tok_All then\n             Extends_All := True;\n@@ -1216,7 +1241,6 @@ package body Prj.Part is\n          end;\n \n          declare\n-            Imported_Projects : Project_Node_Id := Empty_Node;\n             From_Ext : Extension_Origin := None;\n \n          begin\n@@ -1235,6 +1259,7 @@ package body Prj.Part is\n             Post_Parse_Context_Clause\n               (In_Tree           => In_Tree,\n                Context_Clause    => First_With,\n+               Limited_Withs     => False,\n                Imported_Projects => Imported_Projects,\n                Project_Directory => Project_Directory,\n                From_Extended     => From_Ext,\n@@ -1372,7 +1397,7 @@ package body Prj.Part is\n                end if;\n             end;\n \n-            Scan (In_Tree); -- scan past the extended project path\n+            Scan (In_Tree); -- past the extended project path\n          end if;\n       end if;\n \n@@ -1553,6 +1578,36 @@ package body Prj.Part is\n          end if;\n       end if;\n \n+      declare\n+         From_Ext : Extension_Origin := None;\n+\n+      begin\n+         --  Extending_All is always propagated\n+\n+         if From_Extended = Extending_All or else Extends_All then\n+            From_Ext := Extending_All;\n+\n+            --  Otherwise, From_Extended is set to Extending_Single if the\n+            --  current project is an extending project.\n+\n+         elsif Extended then\n+            From_Ext := Extending_Simple;\n+         end if;\n+\n+         Post_Parse_Context_Clause\n+           (In_Tree           => In_Tree,\n+            Context_Clause    => First_With,\n+            Limited_Withs     => True,\n+            Imported_Projects => Imported_Projects,\n+            Project_Directory => Project_Directory,\n+            From_Extended     => From_Ext,\n+            In_Limited        => In_Limited,\n+            Packages_To_Check => Packages_To_Check,\n+            Depth             => Depth + 1,\n+            Current_Dir       => Current_Dir);\n+         Set_First_With_Clause_Of (Project, In_Tree, Imported_Projects);\n+      end;\n+\n       --  Restore the scan state, in case we are not the main project\n \n       Restore_Project_Scan_State (Project_Scan_State);"}, {"sha": "e1a660946c7819c1d6e32e6e3802c34bfa5fd145", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 164, "deletions": 87, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=1a5d715a60307e8f70254c9c550b5e6916fde76e", "patch": "@@ -1,13 +1,12 @@\n ------------------------------------------------------------------------------\n-\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n --                              P R J . P R O C                             --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1104,64 +1103,59 @@ package body Prj.Proc is\n       In_Tree   : Project_Tree_Ref;\n       With_Name : Name_Id) return Project_Id\n    is\n-      Data        : constant Project_Data :=\n-                      In_Tree.Projects.Table (Project);\n-      List        : Project_List          := Data.Imported_Projects;\n-      Result      : Project_Id := No_Project;\n-      Temp_Result : Project_Id := No_Project;\n+      Data        : constant Project_Data := In_Tree.Projects.Table (Project);\n+      List        : Project_List;\n+      Result      : Project_Id;\n+      Temp_Result : Project_Id;\n \n    begin\n       --  First check if it is the name of an extended project\n \n-      if Data.Extends /= No_Project\n-        and then In_Tree.Projects.Table (Data.Extends).Name =\n-                   With_Name\n-      then\n-         return Data.Extends;\n+      Result := Data.Extends;\n+      while Result /= No_Project loop\n+         if In_Tree.Projects.Table (Result).Name = With_Name then\n+            return Result;\n+         else\n+            Result := In_Tree.Projects.Table (Result).Extends;\n+         end if;\n+      end loop;\n \n-      else\n-         --  Then check the name of each imported project\n+      --  Then check the name of each imported project\n \n-         while List /= Empty_Project_List loop\n-            Result := In_Tree.Project_Lists.Table (List).Project;\n+      Temp_Result := No_Project;\n+      List := Data.Imported_Projects;\n+      while List /= Empty_Project_List loop\n+         Result := In_Tree.Project_Lists.Table (List).Project;\n \n-            --  If the project is directly imported, then returns its ID\n+         --  If the project is directly imported, then returns its ID\n \n-            if\n-              In_Tree.Projects.Table (Result).Name = With_Name\n-            then\n-               return Result;\n-            end if;\n+         if In_Tree.Projects.Table (Result).Name = With_Name then\n+            return Result;\n+         end if;\n \n-            --  If a project extending the project is imported, then keep\n-            --  this extending project as a possibility. It will be the\n-            --  returned ID if the project is not imported directly.\n+         --  If a project extending the project is imported, then keep this\n+         --  extending project as a possibility. It will be the returned ID\n+         --  if the project is not imported directly.\n \n-            declare\n-               Proj : Project_Id :=\n-                 In_Tree.Projects.Table (Result).Extends;\n-            begin\n-               while Proj /= No_Project loop\n-                  if In_Tree.Projects.Table (Proj).Name =\n-                       With_Name\n-                  then\n-                     Temp_Result := Result;\n-                     exit;\n-                  end if;\n+         declare\n+            Proj : Project_Id := In_Tree.Projects.Table (Result).Extends;\n \n-                  Proj := In_Tree.Projects.Table (Proj).Extends;\n-               end loop;\n-            end;\n+         begin\n+            while Proj /= No_Project loop\n+               if In_Tree.Projects.Table (Proj).Name = With_Name then\n+                  Temp_Result := Result;\n+                  exit;\n+               end if;\n \n-            List := In_Tree.Project_Lists.Table (List).Next;\n-         end loop;\n+               Proj := In_Tree.Projects.Table (Proj).Extends;\n+            end loop;\n+         end;\n \n-         pragma Assert\n-           (Temp_Result /= No_Project,\n-           \"project not found\");\n+         List := In_Tree.Project_Lists.Table (List).Next;\n+      end loop;\n \n-         return Temp_Result;\n-      end if;\n+      pragma Assert (Temp_Result /= No_Project, \"project not found\");\n+      return Temp_Result;\n    end Imported_Or_Extended_Project_From;\n \n    ------------------\n@@ -2530,6 +2524,7 @@ package body Prj.Proc is\n             Processed_Projects.Set (Name, Project);\n \n             Processed_Data.Name := Name;\n+            In_Tree.Projects.Table (Project).Name := Name;\n \n             Get_Name_String (Name);\n \n@@ -2588,61 +2583,74 @@ package body Prj.Proc is\n                Prj.Attr.Attribute_First,\n                Project_Level => True);\n \n+            --  Process non limited withed projects\n+\n             With_Clause :=\n               First_With_Clause_Of (From_Project_Node, From_Project_Node_Tree);\n             while With_Clause /= Empty_Node loop\n                declare\n                   New_Project : Project_Id;\n                   New_Data    : Project_Data;\n+                  Proj_Node   : Project_Node_Id;\n \n                begin\n-                  Recursive_Process\n-                    (In_Tree                => In_Tree,\n-                     Project                => New_Project,\n-                     From_Project_Node      =>\n-                       Project_Node_Of (With_Clause, From_Project_Node_Tree),\n-                     From_Project_Node_Tree => From_Project_Node_Tree,\n-                     Extended_By            => No_Project);\n-                  New_Data :=\n-                    In_Tree.Projects.Table (New_Project);\n-\n-                  --  If we were the first project to import it,\n-                  --  set First_Referred_By to us.\n-\n-                  if New_Data.First_Referred_By = No_Project then\n-                     New_Data.First_Referred_By := Project;\n-                     In_Tree.Projects.Table (New_Project) :=\n-                       New_Data;\n-                  end if;\n+                  Proj_Node :=\n+                    Non_Limited_Project_Node_Of\n+                      (With_Clause, From_Project_Node_Tree);\n+\n+                  if Proj_Node /= Empty_Node then\n+                     Recursive_Process\n+                       (In_Tree                => In_Tree,\n+                        Project                => New_Project,\n+                        From_Project_Node      =>\n+                          Project_Node_Of\n+                            (With_Clause, From_Project_Node_Tree),\n+                        From_Project_Node_Tree => From_Project_Node_Tree,\n+                        Extended_By            => No_Project);\n \n-                  --  Add this project to our list of imported projects\n+                     New_Data :=\n+                       In_Tree.Projects.Table (New_Project);\n \n-                  Project_List_Table.Increment_Last\n-                    (In_Tree.Project_Lists);\n-                  In_Tree.Project_Lists.Table\n-                    (Project_List_Table.Last\n-                       (In_Tree.Project_Lists)) :=\n-                    (Project => New_Project, Next => Empty_Project_List);\n+                     --  If we were the first project to import it,\n+                     --  set First_Referred_By to us.\n \n-                  --  Imported is the id of the last imported project.\n-                  --  If it is nil, then this imported project is our first.\n+                     if New_Data.First_Referred_By = No_Project then\n+                        New_Data.First_Referred_By := Project;\n+                        In_Tree.Projects.Table (New_Project) :=\n+                          New_Data;\n+                     end if;\n \n-                  if Imported = Empty_Project_List then\n-                     Processed_Data.Imported_Projects :=\n-                       Project_List_Table.Last\n-                         (In_Tree.Project_Lists);\n+                     --  Add this project to our list of imported projects\n+\n+                     Project_List_Table.Increment_Last\n+                       (In_Tree.Project_Lists);\n \n-                  else\n                      In_Tree.Project_Lists.Table\n-                       (Imported).Next := Project_List_Table.Last\n+                       (Project_List_Table.Last\n+                          (In_Tree.Project_Lists)) :=\n+                       (Project => New_Project, Next => Empty_Project_List);\n+\n+                     --  Imported is the id of the last imported project. If it\n+                     --  is nil, then this imported project is our first.\n+\n+                     if Imported = Empty_Project_List then\n+                        Processed_Data.Imported_Projects :=\n+                          Project_List_Table.Last\n+                            (In_Tree.Project_Lists);\n+\n+                     else\n+                        In_Tree.Project_Lists.Table\n+                          (Imported).Next := Project_List_Table.Last\n                           (In_Tree.Project_Lists);\n-                  end if;\n+                     end if;\n \n-                  Imported := Project_List_Table.Last\n-                                (In_Tree.Project_Lists);\n+                     Imported := Project_List_Table.Last\n+                       (In_Tree.Project_Lists);\n+                  end if;\n \n                   With_Clause :=\n-                    Next_With_Clause_Of (With_Clause, From_Project_Node_Tree);\n+                    Next_With_Clause_Of\n+                      (With_Clause, From_Project_Node_Tree);\n                end;\n             end loop;\n \n@@ -2676,9 +2684,9 @@ package body Prj.Proc is\n             --  or renamed. Also inherit the languages, if attribute Languages\n             --  is not explicitely defined.\n \n-            if Processed_Data.Extends /= No_Project then\n-               Processed_Data := In_Tree.Projects.Table (Project);\n+            Processed_Data := In_Tree.Projects.Table (Project);\n \n+            if Processed_Data.Extends /= No_Project then\n                declare\n                   Extended_Pkg : Package_Id;\n                   Current_Pkg  : Package_Id;\n@@ -2778,9 +2786,78 @@ package body Prj.Proc is\n                      end if;\n                   end if;\n                end;\n-\n-               In_Tree.Projects.Table (Project) := Processed_Data;\n             end if;\n+\n+            --  Process limited withed projects\n+\n+            With_Clause :=\n+              First_With_Clause_Of\n+                (From_Project_Node, From_Project_Node_Tree);\n+            while With_Clause /= Empty_Node loop\n+               declare\n+                  New_Project : Project_Id;\n+                  New_Data    : Project_Data;\n+                  Proj_Node   : Project_Node_Id;\n+\n+               begin\n+                  Proj_Node :=\n+                    Non_Limited_Project_Node_Of\n+                      (With_Clause, From_Project_Node_Tree);\n+\n+                  if Proj_Node = Empty_Node then\n+                     Recursive_Process\n+                       (In_Tree                => In_Tree,\n+                        Project                => New_Project,\n+                        From_Project_Node      =>\n+                          Project_Node_Of\n+                            (With_Clause, From_Project_Node_Tree),\n+                        From_Project_Node_Tree => From_Project_Node_Tree,\n+                        Extended_By            => No_Project);\n+\n+                     New_Data :=\n+                       In_Tree.Projects.Table (New_Project);\n+\n+                     --  If we were the first project to import it, set\n+                     --  First_Referred_By to us.\n+\n+                     if New_Data.First_Referred_By = No_Project then\n+                        New_Data.First_Referred_By := Project;\n+                        In_Tree.Projects.Table (New_Project) :=\n+                          New_Data;\n+                     end if;\n+\n+                     --  Add this project to our list of imported projects\n+\n+                     Project_List_Table.Increment_Last\n+                       (In_Tree.Project_Lists);\n+\n+                     In_Tree.Project_Lists.Table\n+                       (Project_List_Table.Last\n+                          (In_Tree.Project_Lists)) :=\n+                       (Project => New_Project, Next => Empty_Project_List);\n+\n+                     --  Imported is the id of the last imported project. If\n+                     --  it is nil, then this imported project is our first.\n+\n+                     if Imported = Empty_Project_List then\n+                        In_Tree.Projects.Table (Project).Imported_Projects :=\n+                          Project_List_Table.Last\n+                            (In_Tree.Project_Lists);\n+                     else\n+                        In_Tree.Project_Lists.Table\n+                          (Imported).Next := Project_List_Table.Last\n+                          (In_Tree.Project_Lists);\n+                     end if;\n+\n+                     Imported := Project_List_Table.Last\n+                       (In_Tree.Project_Lists);\n+                  end if;\n+\n+                  With_Clause :=\n+                    Next_With_Clause_Of\n+                      (With_Clause, From_Project_Node_Tree);\n+               end;\n+            end loop;\n          end;\n       end if;\n    end Recursive_Process;"}, {"sha": "db32e4a0a07ae8b2b9fd3e097e9764b364ccc580", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a5d715a60307e8f70254c9c550b5e6916fde76e/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=1a5d715a60307e8f70254c9c550b5e6916fde76e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1047,18 +1047,18 @@ package body Prj.Tree is\n          With_Clause := Next_With_Clause_Of (With_Clause, In_Tree);\n       end loop;\n \n-      --  If it is not an imported project, it might be the imported project\n+      --  If it is not an imported project, it might be an extended project\n \n       if With_Clause = Empty_Node then\n-         Result :=\n-           Extended_Project_Of\n-             (Project_Declaration_Of (Project, In_Tree), In_Tree);\n-\n-         if Result /= Empty_Node\n-           and then Name_Of (Result, In_Tree) /= With_Name\n-         then\n-            Result := Empty_Node;\n-         end if;\n+         Result := Project;\n+         loop\n+            Result :=\n+              Extended_Project_Of\n+                (Project_Declaration_Of (Result, In_Tree), In_Tree);\n+\n+            exit when Result = Empty_Node\n+              or else Name_Of (Result, In_Tree) = With_Name;\n+         end loop;\n       end if;\n \n       return Result;"}]}