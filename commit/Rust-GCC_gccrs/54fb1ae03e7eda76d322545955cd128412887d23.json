{"sha": "54fb1ae03e7eda76d322545955cd128412887d23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRmYjFhZTAzZTdlZGE3NmQzMjI1NDU5NTVjZDEyODQxMjg4N2QyMw==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-04-20T16:33:46Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-04-20T16:33:46Z"}, "message": "double-int.h (double_int_setbit): Declare.\n\n\t* double-int.h (double_int_setbit): Declare.\n\t* double-int.c (double_int_setbit): New function.\n\t* rtl.h (immed_double_int_const): Declare.\n\t* emit-rtl.c (immed_double_int_const): New function.\n\t* builtins.c (expand_builtin_signbit): Clean up, use double_int_*\n\tand immed_double_int_const functions.\n\t* optabs.c (expand_absneg_bit, expand_copysign_absneg,\n\texpand_copysign_bit):  (Ditto.).\n\t* simplify-rtx.c (simplify_binary_operation_1): (Ditto.).\n\t* tree-ssa-address.c (addr_for_mem_ref): (Ditto.).\n\t* dojump.c (prefer_and_bit_test): (Ditto.).\n\t* expr.c (convert_modes, reduce_to_bit_field_precision,\n\tconst_vector_from_tree): (Ditto.).\n\t* expmed.c (mask_rtx, lshift_value): (Ditto.).\n\nFrom-SVN: r158566", "tree": {"sha": "fc2fe7aa9ff67f2d7f7bb70f4b04a3ccb15037d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc2fe7aa9ff67f2d7f7bb70f4b04a3ccb15037d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54fb1ae03e7eda76d322545955cd128412887d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54fb1ae03e7eda76d322545955cd128412887d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54fb1ae03e7eda76d322545955cd128412887d23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54fb1ae03e7eda76d322545955cd128412887d23/comments", "author": null, "committer": null, "parents": [{"sha": "e4ba7a600e70bce0065a2fde0f2f85cdee746cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ba7a600e70bce0065a2fde0f2f85cdee746cfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ba7a600e70bce0065a2fde0f2f85cdee746cfb"}], "stats": {"total": 233, "additions": 110, "deletions": 123}, "files": [{"sha": "15507e29d3dddf88e63d0c2b826bdb79171cf135", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1,3 +1,20 @@\n+2010-04-20  Anatoly Sokolov  <aesok@post.ru\n+\n+\t* double-int.h (double_int_setbit): Declare.\n+\t* double-int.c (double_int_setbit): New function.\n+\t* rtl.h (immed_double_int_const): Declare.\n+\t* emit-rtl.c (immed_double_int_const): New function.\n+\t* builtins.c (expand_builtin_signbit): Clean up, use double_int_*\n+\tand immed_double_int_const functions.\n+\t* optabs.c (expand_absneg_bit, expand_copysign_absneg,\n+\texpand_copysign_bit):  (Ditto.).\n+\t* simplify-rtx.c (simplify_binary_operation_1): (Ditto.).\n+\t* tree-ssa-address.c (addr_for_mem_ref): (Ditto.).\n+\t* dojump.c (prefer_and_bit_test): (Ditto.).\n+\t* expr.c (convert_modes, reduce_to_bit_field_precision,\n+\tconst_vector_from_tree): (Ditto.).\n+\t* expmed.c (mask_rtx, lshift_value): (Ditto.).\n+\n 2010-04-20  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_remove_node): Kill bodies in other partitoin."}, {"sha": "65940ddf4f7e625908b4e6a163e7a46d5886c6bf", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -5279,7 +5279,6 @@ expand_builtin_signbit (tree exp, rtx target)\n {\n   const struct real_format *fmt;\n   enum machine_mode fmode, imode, rmode;\n-  HOST_WIDE_INT hi, lo;\n   tree arg;\n   int word, bitpos;\n   enum insn_code icode;\n@@ -5355,21 +5354,12 @@ expand_builtin_signbit (tree exp, rtx target)\n \n   if (bitpos < GET_MODE_BITSIZE (rmode))\n     {\n-      if (bitpos < HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (HOST_WIDE_INT) 1 << bitpos;\n-\t}\n-      else\n-\t{\n-\t  hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-\t  lo = 0;\n-\t}\n+      double_int mask = double_int_setbit (double_int_zero, bitpos);\n \n       if (GET_MODE_SIZE (imode) > GET_MODE_SIZE (rmode))\n \ttemp = gen_lowpart (rmode, temp);\n       temp = expand_binop (rmode, and_optab, temp,\n-\t\t\t   immed_double_const (lo, hi, rmode),\n+\t\t\t   immed_double_int_const (mask, rmode),\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n   else"}, {"sha": "d4ce6cfc45806ab4fb3c2e30e8defde89064bc70", "filename": "gcc/dojump.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -163,7 +163,8 @@ prefer_and_bit_test (enum machine_mode mode, int bitnum)\n \n   /* Fill in the integers.  */\n   XEXP (and_test, 1)\n-    = immed_double_const ((unsigned HOST_WIDE_INT) 1 << bitnum, 0, mode);\n+    = immed_double_int_const (double_int_setbit (double_int_zero, bitnum),\n+\t\t\t\t\t\t mode);\n   XEXP (XEXP (shift_test, 0), 1) = GEN_INT (bitnum);\n \n   return (rtx_cost (and_test, IF_THEN_ELSE, optimize_insn_for_speed_p ())"}, {"sha": "8e4a3f5e59605755623d5fee51e3406fe05c935f", "filename": "gcc/double-int.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1013,6 +1013,18 @@ double_int_umod (double_int a, double_int b, unsigned code)\n   return double_int_mod (a, b, true, code);\n }\n \n+/* Set BITPOS bit in A.  */\n+double_int\n+double_int_setbit (double_int a, unsigned bitpos)\n+{\n+  if (bitpos < HOST_BITS_PER_WIDE_INT)\n+    a.low |= (unsigned HOST_WIDE_INT) 1 << bitpos;\n+  else\n+    a.high |= (HOST_WIDE_INT) 1 <<  (bitpos - HOST_BITS_PER_WIDE_INT);\n+ \n+  return a;\n+}\n+\n /* Shift A left by COUNT places keeping only PREC bits of result.  Shift\n    right if COUNT is negative.  ARITH true specifies arithmetic shifting;\n    otherwise use logical shift.  */"}, {"sha": "47991ca41b8feaf579023bb241961c277aa34b69", "filename": "gcc/double-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -130,6 +130,7 @@ double_int double_int_umod (double_int, double_int, unsigned);\n double_int double_int_divmod (double_int, double_int, bool, unsigned, double_int *);\n double_int double_int_sdivmod (double_int, double_int, unsigned, double_int *);\n double_int double_int_udivmod (double_int, double_int, unsigned, double_int *);\n+double_int double_int_setbit (double_int, unsigned);\n \n /* Logical operations.  */\n static inline double_int"}, {"sha": "d4ba5d706ed90a113b8a979ee03abb5295161c72", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1,6 +1,7 @@\n /* Emit RTL for the GCC expander.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -517,6 +518,15 @@ const_fixed_from_fixed_value (FIXED_VALUE_TYPE value, enum machine_mode mode)\n   return lookup_const_fixed (fixed);\n }\n \n+/* Return a CONST_DOUBLE or CONST_INT for a value specified as\n+   a double_int.  */\n+\n+rtx\n+immed_double_int_const (double_int i, enum machine_mode mode)\n+{\n+  return immed_double_const (i.low, i.high, mode);\n+}\n+\n /* Return a CONST_DOUBLE or CONST_INT for a value specified as a pair\n    of ints: I0 is the low-order word and I1 is the high-order word.\n    Do not use this routine for non-integer modes; convert to"}, {"sha": "d4b05837aeb99af1163c0aae9b222a370041c5b9", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1847,7 +1847,7 @@ mask_rtx (enum machine_mode mode, int bitpos, int bitsize, int complement)\n   if (complement)\n     mask = double_int_not (mask);\n \n-  return immed_double_const (mask.low, mask.high, mode);\n+  return immed_double_int_const (mask, mode);\n }\n \n /* Return a constant integer (CONST_INT or CONST_DOUBLE) rtx with the value\n@@ -1861,7 +1861,7 @@ lshift_value (enum machine_mode mode, rtx value, int bitpos, int bitsize)\n   val = double_int_zext (uhwi_to_double_int (INTVAL (value)), bitsize);\n   val = double_int_lshift (val, bitpos, HOST_BITS_PER_DOUBLE_INT, false);\n \n-  return immed_double_const (val.low, val.high, mode);\n+  return immed_double_int_const (val, mode);\n }\n \f\n /* Extract a bit field that is split across two words"}, {"sha": "254751134bff801fffd7102aea75c9ff5b2d7b57", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -774,18 +774,13 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n       && GET_MODE_BITSIZE (mode) == 2 * HOST_BITS_PER_WIDE_INT\n       && CONST_INT_P (x) && INTVAL (x) < 0)\n     {\n-      HOST_WIDE_INT val = INTVAL (x);\n+      double_int val = uhwi_to_double_int (INTVAL (x));\n \n-      if (oldmode != VOIDmode\n-\t  && HOST_BITS_PER_WIDE_INT > GET_MODE_BITSIZE (oldmode))\n-\t{\n-\t  int width = GET_MODE_BITSIZE (oldmode);\n-\n-\t  /* We need to zero extend VAL.  */\n-\t  val &= ((HOST_WIDE_INT) 1 << width) - 1;\n-\t}\n+      /* We need to zero extend VAL.  */\n+      if (oldmode != VOIDmode)\n+\tval = double_int_zext (val, GET_MODE_BITSIZE (oldmode));\n \n-      return immed_double_const (val, (HOST_WIDE_INT) 0, mode);\n+      return immed_double_int_const (val, mode);\n     }\n \n   /* We can do this with a gen_lowpart if both desired and current modes\n@@ -9686,15 +9681,8 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n     }\n   else if (TYPE_UNSIGNED (type))\n     {\n-      rtx mask;\n-      if (prec < HOST_BITS_PER_WIDE_INT)\n-\tmask = immed_double_const (((unsigned HOST_WIDE_INT) 1 << prec) - 1, 0,\n-\t\t\t\t   GET_MODE (exp));\n-      else\n-\tmask = immed_double_const ((unsigned HOST_WIDE_INT) -1,\n-\t\t\t\t   ((unsigned HOST_WIDE_INT) 1\n-\t\t\t\t    << (prec - HOST_BITS_PER_WIDE_INT)) - 1,\n-\t\t\t\t   GET_MODE (exp));\n+      rtx mask = immed_double_int_const (double_int_mask (prec),\n+\t\t\t\t\t GET_MODE (exp));\n       return expand_and (GET_MODE (exp), exp, mask, target);\n     }\n   else\n@@ -10280,9 +10268,8 @@ const_vector_from_tree (tree exp)\n \tRTVEC_ELT (v, i) = CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n \t\t\t\t\t\t\t inner);\n       else\n-\tRTVEC_ELT (v, i) = immed_double_const (TREE_INT_CST_LOW (elt),\n-\t\t\t\t\t       TREE_INT_CST_HIGH (elt),\n-\t\t\t\t\t       inner);\n+\tRTVEC_ELT (v, i) = immed_double_int_const (tree_to_double_int (elt),\n+\t\t\t\t\t\t   inner);\n     }\n \n   /* Initialize remaining elements to 0.  */"}, {"sha": "5a3e61092b978694b632c00499312054490903bc", "filename": "gcc/optabs.c", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -2928,7 +2928,7 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n   const struct real_format *fmt;\n   int bitpos, word, nwords, i;\n   enum machine_mode imode;\n-  HOST_WIDE_INT hi, lo;\n+  double_int mask;\n   rtx temp, insns;\n \n   /* The format has to have a simple sign bit.  */\n@@ -2964,18 +2964,9 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n       nwords = (GET_MODE_BITSIZE (mode) + BITS_PER_WORD - 1) / BITS_PER_WORD;\n     }\n \n-  if (bitpos < HOST_BITS_PER_WIDE_INT)\n-    {\n-      hi = 0;\n-      lo = (HOST_WIDE_INT) 1 << bitpos;\n-    }\n-  else\n-    {\n-      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-      lo = 0;\n-    }\n+  mask = double_int_setbit (double_int_zero, bitpos);\n   if (code == ABS)\n-    lo = ~lo, hi = ~hi;\n+    mask = double_int_not (mask);\n \n   if (target == 0 || target == op0)\n     target = gen_reg_rtx (mode);\n@@ -2993,7 +2984,7 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n \t    {\n \t      temp = expand_binop (imode, code == ABS ? and_optab : xor_optab,\n \t\t\t\t   op0_piece,\n-\t\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t\t\t   immed_double_int_const (mask, imode),\n \t\t\t\t   targ_piece, 1, OPTAB_LIB_WIDEN);\n \t      if (temp != targ_piece)\n \t\temit_move_insn (targ_piece, temp);\n@@ -3011,7 +3002,7 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n     {\n       temp = expand_binop (imode, code == ABS ? and_optab : xor_optab,\n \t\t\t   gen_lowpart (imode, op0),\n-\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t\t   immed_double_int_const (mask, imode),\n \t\t           gen_lowpart (imode, target), 1, OPTAB_LIB_WIDEN);\n       target = lowpart_subreg_maybe_copy (mode, temp, imode);\n \n@@ -3562,7 +3553,7 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n     }\n   else\n     {\n-      HOST_WIDE_INT hi, lo;\n+      double_int mask;\n \n       if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n \t{\n@@ -3584,20 +3575,10 @@ expand_copysign_absneg (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t  op1 = operand_subword_force (op1, word, mode);\n \t}\n \n-      if (bitpos < HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  hi = 0;\n-\t  lo = (HOST_WIDE_INT) 1 << bitpos;\n-\t}\n-      else\n-\t{\n-\t  hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-\t  lo = 0;\n-\t}\n+      mask = double_int_setbit (double_int_zero, bitpos);\n \n-      sign = gen_reg_rtx (imode);\n       sign = expand_binop (imode, and_optab, op1,\n-\t\t\t   immed_double_const (lo, hi, imode),\n+\t\t\t   immed_double_int_const (mask, imode),\n \t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n     }\n \n@@ -3641,7 +3622,7 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t     int bitpos, bool op0_is_abs)\n {\n   enum machine_mode imode;\n-  HOST_WIDE_INT hi, lo;\n+  double_int mask;\n   int word, nwords, i;\n   rtx temp, insns;\n \n@@ -3665,16 +3646,7 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n       nwords = (GET_MODE_BITSIZE (mode) + BITS_PER_WORD - 1) / BITS_PER_WORD;\n     }\n \n-  if (bitpos < HOST_BITS_PER_WIDE_INT)\n-    {\n-      hi = 0;\n-      lo = (HOST_WIDE_INT) 1 << bitpos;\n-    }\n-  else\n-    {\n-      hi = (HOST_WIDE_INT) 1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-      lo = 0;\n-    }\n+  mask = double_int_setbit (double_int_zero, bitpos);\n \n   if (target == 0 || target == op0 || target == op1)\n     target = gen_reg_rtx (mode);\n@@ -3691,13 +3663,15 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t  if (i == word)\n \t    {\n \t      if (!op0_is_abs)\n-\t\top0_piece = expand_binop (imode, and_optab, op0_piece,\n-\t\t\t\t\t  immed_double_const (~lo, ~hi, imode),\n-\t\t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t\top0_piece\n+\t\t  = expand_binop (imode, and_optab, op0_piece,\n+\t\t\t\t  immed_double_int_const (double_int_not (mask),\n+\t\t\t\t\t\t\t  imode),\n+\t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n \t      op1 = expand_binop (imode, and_optab,\n \t\t\t\t  operand_subword_force (op1, i, mode),\n-\t\t\t\t  immed_double_const (lo, hi, imode),\n+\t\t\t\t  immed_double_int_const (mask, imode),\n \t\t\t\t  NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n \t      temp = expand_binop (imode, ior_optab, op0_piece, op1,\n@@ -3717,13 +3691,14 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n   else\n     {\n       op1 = expand_binop (imode, and_optab, gen_lowpart (imode, op1),\n-\t\t          immed_double_const (lo, hi, imode),\n+\t\t          immed_double_int_const (mask, imode),\n \t\t          NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n       op0 = gen_lowpart (imode, op0);\n       if (!op0_is_abs)\n \top0 = expand_binop (imode, and_optab, op0,\n-\t\t\t    immed_double_const (~lo, ~hi, imode),\n+\t\t\t    immed_double_int_const (double_int_not (mask),\n+\t\t\t\t\t\t    imode),\n \t\t\t    NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \n       temp = expand_binop (imode, ior_optab, op0, op1,"}, {"sha": "ccb3c1a044a9491278a726b1d9c0fb84840a34ca", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1627,6 +1627,7 @@ extern void start_sequence (void);\n extern void push_to_sequence (rtx);\n extern void push_to_sequence2 (rtx, rtx);\n extern void end_sequence (void);\n+extern rtx immed_double_int_const (double_int, enum machine_mode);\n extern rtx immed_double_const (HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t       enum machine_mode);\n "}, {"sha": "fbbf7ad5e12b94363fa08a86171b4d8456b3eaaf", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -1770,66 +1770,63 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       if (SCALAR_INT_MODE_P (mode))\n \t{\n-\t  HOST_WIDE_INT coeff0h = 0, coeff1h = 0;\n-\t  unsigned HOST_WIDE_INT coeff0l = 1, coeff1l = 1;\n+\t  double_int coeff0, coeff1;\n \t  rtx lhs = op0, rhs = op1;\n \n+\t  coeff0 = double_int_one;\n+\t  coeff1 = double_int_one;\n+\n \t  if (GET_CODE (lhs) == NEG)\n \t    {\n-\t      coeff0l = -1;\n-\t      coeff0h = -1;\n+\t      coeff0 = double_int_minus_one;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == MULT\n \t\t   && CONST_INT_P (XEXP (lhs, 1)))\n \t    {\n-\t      coeff0l = INTVAL (XEXP (lhs, 1));\n-\t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n+\t      coeff0 = shwi_to_double_int (INTVAL (XEXP (lhs, 1)));\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n \t\t   && CONST_INT_P (XEXP (lhs, 1))\n-\t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n+                   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff0l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n-\t      coeff0h = 0;\n+\t      coeff0 = double_int_setbit (double_int_zero,\n+\t\t\t\t\t  INTVAL (XEXP (lhs, 1)));\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \n \t  if (GET_CODE (rhs) == NEG)\n \t    {\n-\t      coeff1l = -1;\n-\t      coeff1h = -1;\n+\t      coeff1 = double_int_minus_one;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == MULT\n \t\t   && CONST_INT_P (XEXP (rhs, 1)))\n \t    {\n-\t      coeff1l = INTVAL (XEXP (rhs, 1));\n-\t      coeff1h = INTVAL (XEXP (rhs, 1)) < 0 ? -1 : 0;\n+\t      coeff1 = shwi_to_double_int (INTVAL (XEXP (rhs, 1)));\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n \t\t   && CONST_INT_P (XEXP (rhs, 1))\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff1l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n-\t      coeff1h = 0;\n+\t      coeff1 = double_int_setbit (double_int_zero,\n+\t\t\t\t\t  INTVAL (XEXP (rhs, 1)));\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \n \t  if (rtx_equal_p (lhs, rhs))\n \t    {\n \t      rtx orig = gen_rtx_PLUS (mode, op0, op1);\n \t      rtx coeff;\n-\t      unsigned HOST_WIDE_INT l;\n-\t      HOST_WIDE_INT h;\n+\t      double_int val;\n \t      bool speed = optimize_function_for_speed_p (cfun);\n \n-\t      add_double (coeff0l, coeff0h, coeff1l, coeff1h, &l, &h);\n-\t      coeff = immed_double_const (l, h, mode);\n+\t      val = double_int_add (coeff0, coeff1);\n+\t      coeff = immed_double_int_const (val, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n \t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)\n@@ -1953,66 +1950,64 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       if (SCALAR_INT_MODE_P (mode))\n \t{\n-\t  HOST_WIDE_INT coeff0h = 0, negcoeff1h = -1;\n-\t  unsigned HOST_WIDE_INT coeff0l = 1, negcoeff1l = -1;\n+\t  double_int coeff0, negcoeff1;\n \t  rtx lhs = op0, rhs = op1;\n \n+\t  coeff0 = double_int_one;\n+\t  negcoeff1 = double_int_minus_one;\n+\n \t  if (GET_CODE (lhs) == NEG)\n \t    {\n-\t      coeff0l = -1;\n-\t      coeff0h = -1;\n+\t      coeff0 = double_int_minus_one;\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == MULT\n \t\t   && CONST_INT_P (XEXP (lhs, 1)))\n \t    {\n-\t      coeff0l = INTVAL (XEXP (lhs, 1));\n-\t      coeff0h = INTVAL (XEXP (lhs, 1)) < 0 ? -1 : 0;\n+\t      coeff0 = shwi_to_double_int (INTVAL (XEXP (lhs, 1)));\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \t  else if (GET_CODE (lhs) == ASHIFT\n \t\t   && CONST_INT_P (XEXP (lhs, 1))\n \t\t   && INTVAL (XEXP (lhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      coeff0l = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n-\t      coeff0h = 0;\n+\t      coeff0 = double_int_setbit (double_int_zero,\n+\t\t\t\t\t  INTVAL (XEXP (lhs, 1)));\n \t      lhs = XEXP (lhs, 0);\n \t    }\n \n \t  if (GET_CODE (rhs) == NEG)\n \t    {\n-\t      negcoeff1l = 1;\n-\t      negcoeff1h = 0;\n+\t      negcoeff1 = double_int_one;\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == MULT\n \t\t   && CONST_INT_P (XEXP (rhs, 1)))\n \t    {\n-\t      negcoeff1l = -INTVAL (XEXP (rhs, 1));\n-\t      negcoeff1h = INTVAL (XEXP (rhs, 1)) <= 0 ? 0 : -1;\n+\t      negcoeff1 = shwi_to_double_int (-INTVAL (XEXP (rhs, 1)));\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \t  else if (GET_CODE (rhs) == ASHIFT\n \t\t   && CONST_INT_P (XEXP (rhs, 1))\n \t\t   && INTVAL (XEXP (rhs, 1)) >= 0\n \t\t   && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      negcoeff1l = -(((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1)));\n-\t      negcoeff1h = -1;\n+\t      negcoeff1 = double_int_setbit (double_int_zero,\n+\t\t\t\t\t     INTVAL (XEXP (rhs, 1)));\n+\t      negcoeff1 = double_int_neg (negcoeff1);\n \t      rhs = XEXP (rhs, 0);\n \t    }\n \n \t  if (rtx_equal_p (lhs, rhs))\n \t    {\n \t      rtx orig = gen_rtx_MINUS (mode, op0, op1);\n \t      rtx coeff;\n-\t      unsigned HOST_WIDE_INT l;\n-\t      HOST_WIDE_INT h;\n+\t      double_int val;\n \t      bool speed = optimize_function_for_speed_p (cfun);\n \n-\t      add_double (coeff0l, coeff0h, negcoeff1l, negcoeff1h, &l, &h);\n-\t      coeff = immed_double_const (l, h, mode);\n+\t      val = double_int_add (coeff0, negcoeff1);\n+\t      coeff = immed_double_int_const (val, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n \t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)"}, {"sha": "f0cbdfee8c99949c12fec729476d4790dd60024a", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54fb1ae03e7eda76d322545955cd128412887d23/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=54fb1ae03e7eda76d322545955cd128412887d23", "patch": "@@ -192,14 +192,12 @@ addr_for_mem_ref (struct mem_address *addr, addr_space_t as,\n   struct mem_addr_template *templ;\n \n   if (addr->step && !integer_onep (addr->step))\n-    st = immed_double_const (TREE_INT_CST_LOW (addr->step),\n-\t\t\t     TREE_INT_CST_HIGH (addr->step), address_mode);\n+    st = immed_double_int_const (tree_to_double_int (addr->step), address_mode);\n   else\n     st = NULL_RTX;\n \n   if (addr->offset && !integer_zerop (addr->offset))\n-    off = immed_double_const (TREE_INT_CST_LOW (addr->offset),\n-\t\t\t      TREE_INT_CST_HIGH (addr->offset), address_mode);\n+    off = immed_double_int_const (tree_to_double_int (addr->offset), address_mode);\n   else\n     off = NULL_RTX;\n "}]}