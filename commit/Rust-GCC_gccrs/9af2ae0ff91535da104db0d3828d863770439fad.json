{"sha": "9af2ae0ff91535da104db0d3828d863770439fad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmMmFlMGZmOTE1MzVkYTEwNGRiMGQzODI4ZDg2Mzc3MDQzOWZhZA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-16T15:40:28Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-03-01T10:35:07Z"}, "message": "Support Generic arguments to Structs\n\nThis removes StructFieldType from the TyTy base as it is not a type that\ncan be unified against.\n\nIt adds in a substition mapper implementation which will likely change\nover time when this this support is extended over to Functions and\nTupleStructs.\n\nNote generic argument binding is not supported as part of this yet.\n\nFixes #235", "tree": {"sha": "57b375ba818f22c70066c87a4d9c2a1c1b78f69e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57b375ba818f22c70066c87a4d9c2a1c1b78f69e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af2ae0ff91535da104db0d3828d863770439fad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af2ae0ff91535da104db0d3828d863770439fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af2ae0ff91535da104db0d3828d863770439fad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af2ae0ff91535da104db0d3828d863770439fad/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06bb1d6542a9d07f4d866613a5b039be7bcb5f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bb1d6542a9d07f4d866613a5b039be7bcb5f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bb1d6542a9d07f4d866613a5b039be7bcb5f95"}], "stats": {"total": 1460, "additions": 1169, "deletions": 291}, "files": [{"sha": "7d3a075efc03e6a6f47ce825e871c40b20993132", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -1209,9 +1209,18 @@ class GenericParam\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual Location get_locus_slow () const = 0;\n+\n+  NodeId get_node_id () { return node_id; }\n+\n protected:\n+  GenericParam () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+  GenericParam (NodeId node_id) : node_id (node_id) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual GenericParam *clone_generic_param_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // A lifetime generic parameter (as opposed to a type generic parameter)\n@@ -1251,6 +1260,10 @@ class LifetimeParam : public GenericParam\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "35d1827ec86d1a24d6d7402a989138dc25e90ac4", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -66,6 +66,8 @@ class TypeParam : public GenericParam\n   Location locus;\n \n public:\n+  Identifier get_type_representation () const { return type_representation; }\n+\n   // Returns whether the type of the type param has been specified.\n   bool has_type () const { return type != nullptr; }\n \n@@ -80,15 +82,16 @@ class TypeParam : public GenericParam\n \t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n-    : outer_attr (std::move (outer_attr)),\n+    : GenericParam (Analysis::Mappings::get ()->get_next_node_id ()),\n+      outer_attr (std::move (outer_attr)),\n       type_representation (std::move (type_representation)),\n       type_param_bounds (std::move (type_param_bounds)),\n       type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor uses clone\n   TypeParam (TypeParam const &other)\n-    : outer_attr (other.outer_attr),\n+    : GenericParam (other.node_id), outer_attr (other.outer_attr),\n       type_representation (other.type_representation), locus (other.locus)\n   {\n     // guard to prevent null pointer dereference\n@@ -106,6 +109,7 @@ class TypeParam : public GenericParam\n     type_representation = other.type_representation;\n     outer_attr = other.outer_attr;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent null pointer dereference\n     if (other.type != nullptr)\n@@ -128,6 +132,8 @@ class TypeParam : public GenericParam\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n@@ -1756,6 +1762,8 @@ class Struct : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const final { return get_locus (); };\n+\n   // Invalid if name is empty, so base stripping on that.\n   void mark_for_strip () override { struct_name = \"\"; }\n   bool is_marked_for_strip () const override { return struct_name.empty (); }\n@@ -1949,7 +1957,6 @@ class StructStruct : public Struct\n \t      std::move (outer_attrs)),\n       is_unit (true)\n   {}\n-  // TODO: can a unit struct have generic fields? assuming yes for now.\n \n   /* Returns whether the struct is a unit struct - struct defined without\n    * fields. This is important because it also means an implicit constant of its"}, {"sha": "81fce576cb25a76ca35d7cff2f8a0a786d983046", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -196,6 +196,8 @@ struct GenericArgs\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n   std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n+\n+  std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; };\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe"}, {"sha": "b191554178da5f8ae3bda390e9927b7446d62d45", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -274,7 +274,15 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::StructFieldType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &param) override\n+  {\n+    rust_assert (param.get_ref () != param.get_ty_ref ());\n+\n+    TyTy::BaseType *lookup = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (param.get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+    lookup->accept_vis (*this);\n+  }\n \n   void visit (TyTy::FnType &type) override\n   {\n@@ -338,7 +346,7 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     Btype *named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), struct_type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n+\t\t\t\t\t   type.get_ref ()));\n \n     ctx->push_type (named_struct);\n     ctx->insert_compiled_type (type.get_ty_ref (), named_struct);"}, {"sha": "95a6744aeecf824b81fafd9d1c544c5e7da26fda", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -539,8 +539,16 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::StructExprStructFields &struct_expr)\n   {\n-    Btype *type\n-      = ResolvePathType::Compile (&struct_expr.get_struct_name (), ctx);\n+    TyTy::BaseType *tyty = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  struct_expr.get_mappings ().get_hirid (), &tyty))\n+      {\n+\trust_error_at (struct_expr.get_locus (), \"unknown type\");\n+\treturn;\n+      }\n+\n+    Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+    rust_assert (type != nullptr);\n \n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n@@ -573,8 +581,8 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n     rust_assert (receiver->get_kind () == TyTy::TypeKind::ADT);\n+    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n \n-    TyTy::ADTType *adt = (TyTy::ADTType *) receiver;\n     size_t index = 0;\n     adt->get_field (expr.get_field_name (), &index);\n "}, {"sha": "8018367902f8b32ed902e3e058f0496079482c2a", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -50,7 +50,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n-    std::string ident = self->as_string () + \"::\" + constant.get_identifier ();\n+    std::string ident = self->get_name () + \"::\" + constant.get_identifier ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n@@ -95,7 +95,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     unsigned int flags = 0;\n     std::string fn_identifier\n-      = self->as_string () + \"::\" + function.function_name;\n+      = self->get_name () + \"::\" + function.function_name;\n \n     // if its the main fn or pub visibility mark its as DECL_PUBLIC\n     // please see https://github.com/Rust-GCC/gccrs/pull/137\n@@ -259,7 +259,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     unsigned int flags = 0;\n     std::string fn_identifier\n-      = self->as_string () + \"::\" + method.get_method_name ();\n+      = self->get_name () + \"::\" + method.get_method_name ();\n \n     // if its the main fn or pub visibility mark its as DECL_PUBLIC\n     // please see https://github.com/Rust-GCC/gccrs/pull/137"}, {"sha": "c6b135bce0dcbbc0f13f289e74ddbfb0a0857ecb", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -39,34 +39,6 @@ class CompileItem : public HIRCompileBase\n     item->accept_vis (compiler);\n   }\n \n-  void visit (HIR::TupleStruct &struct_decl)\n-  {\n-    TyTy::BaseType *resolved = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n-      {\n-\trust_fatal_error (struct_decl.get_locus (),\n-\t\t\t  \"Failed to lookup type for struct decl\");\n-\treturn;\n-      }\n-\n-    TyTyResolveCompile::compile (ctx, resolved);\n-  }\n-\n-  void visit (HIR::StructStruct &struct_decl)\n-  {\n-    TyTy::BaseType *resolved = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  struct_decl.get_mappings ().get_hirid (), &resolved))\n-      {\n-\trust_fatal_error (struct_decl.get_locus (),\n-\t\t\t  \"Failed to lookup type for struct decl\");\n-\treturn;\n-      }\n-\n-    TyTyResolveCompile::compile (ctx, resolved);\n-  }\n-\n   void visit (HIR::StaticItem &var)\n   {\n     TyTy::BaseType *resolved_type = nullptr;"}, {"sha": "ffc2655a4a03e2261e9aa66dcc0e1ba355b29ba7", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -84,7 +84,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n       CompileItem::compile (resolved_item, ctx);\n       if (!ctx->lookup_function_decl (ref, &fn))\n \t{\n-\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n+\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled 1\");\n \t  return;\n \t}\n     }\n@@ -112,12 +112,14 @@ ResolvePathType::visit (HIR::PathInExpression &expr)\n       return;\n     }\n \n-  // assumes paths are functions for now\n-  if (!ctx->lookup_compiled_types (ref, &resolved))\n+  TyTy::BaseType *tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (ref, &tyty))\n     {\n-      rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n+      rust_error_at (expr.get_locus (), \"unknown type\");\n       return;\n     }\n+\n+  resolved = TyTyResolveCompile::compile (ctx, tyty);\n }\n \n } // namespace Compile"}, {"sha": "683a9a784aef48da73156655a4b0c868feead03f", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -48,8 +48,6 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::StructFieldType &) override { gcc_unreachable (); }\n-\n   void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n \n   void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n@@ -58,6 +56,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+\n   void visit (TyTy::UnitType &) override { translated = backend->void_type (); }\n \n   void visit (TyTy::FnType &type) override"}, {"sha": "b46861e40dead6e227aba684db7828e557f0bed9", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -74,27 +74,7 @@ class ASTLowerPathInExpression : public ASTLoweringBase\n     return compiler.translated;\n   }\n \n-  void visit (AST::PathInExpression &expr)\n-  {\n-    std::vector<HIR::PathExprSegment> path_segments;\n-    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n-      rust_assert (s.has_generic_args () == false); // TODO\n-\n-      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n-      HIR::PathExprSegment seg (is, s.get_locus ());\n-      path_segments.push_back (seg);\n-      return true;\n-    });\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-\n-    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n-\t\t\t\t\t    expr.get_locus (),\n-\t\t\t\t\t    expr.opening_scope_resolution ());\n-  }\n+  void visit (AST::PathInExpression &expr) override;\n \n private:\n   ASTLowerPathInExpression () : translated (nullptr) {}"}, {"sha": "2865a6a787b8da60b79934372bd48979c2467b8d", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -54,6 +54,12 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::TupleStruct &struct_decl)\n   {\n     std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (struct_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (struct_decl.get_generic_params ());\n+      }\n+\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n@@ -104,6 +110,12 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::StructStruct &struct_decl)\n   {\n     std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (struct_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (struct_decl.get_generic_params ());\n+      }\n+\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n@@ -324,6 +336,19 @@ class ASTLoweringItem : public ASTLoweringBase\n   }\n \n private:\n+  std::vector<std::unique_ptr<HIR::GenericParam> > lower_generic_params (\n+    std::vector<std::unique_ptr<AST::GenericParam> > &params)\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam> > lowered;\n+    for (auto &ast_param : params)\n+      {\n+\tauto hir_param = ASTLowerGenericParam::translate (ast_param.get ());\n+\tlowered.push_back (std::unique_ptr<HIR::GenericParam> (hir_param));\n+      }\n+\n+    return lowered;\n+  }\n+\n   ASTLoweringItem () : translated (nullptr) {}\n \n   HIR::Item *translated;"}, {"sha": "b5d0b7eba826352944282b619957cb7d23dce29f", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -121,6 +121,33 @@ class ASTLoweringType : public ASTLoweringBase\n \t\t\t\t  segment.get_locus ());\n   }\n \n+  void visit (AST::TypePathSegmentGeneric &segment)\n+  {\n+    std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+    std::string segment_name = segment.get_ident_segment ().as_string ();\n+    bool has_separating_scope_resolution\n+      = segment.get_separating_scope_resolution ();\n+\n+    std::vector<HIR::Lifetime> lifetime_args;\n+    for (auto &lifetime : segment.get_generic_args ().get_lifetime_args ())\n+      {\n+\tHIR::Lifetime l = lower_lifetime (lifetime);\n+\tlifetime_args.push_back (std::move (l));\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::Type> > type_args;\n+    for (auto &type : segment.get_generic_args ().get_type_args ())\n+      {\n+\tHIR::Type *t = ASTLoweringType::translate (type.get ());\n+\ttype_args.push_back (std::unique_ptr<HIR::Type> (t));\n+      }\n+\n+    translated_segment = new HIR::TypePathSegmentGeneric (\n+      segment_name, has_separating_scope_resolution, std::move (lifetime_args),\n+      std::move (type_args), std::move (binding_args), segment.get_locus ());\n+  }\n+\n   void visit (AST::TypePath &path)\n   {\n     std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n@@ -215,6 +242,49 @@ class ASTLoweringType : public ASTLoweringBase\n   HIR::TypePathSegment *translated_segment;\n };\n \n+class ASTLowerGenericParam : public ASTLoweringBase\n+{\n+public:\n+  static HIR::GenericParam *translate (AST::GenericParam *param)\n+  {\n+    ASTLowerGenericParam resolver;\n+    param->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_crate_num (),\n+      resolver.translated->get_mappings ().get_hirid (),\n+      param->get_locus_slow ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TypeParam &param) override\n+  {\n+    HIR::Attribute outer_attr = HIR::Attribute::create_empty ();\n+    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+    HIR::Type *type = param.has_type ()\n+\t\t\t? ASTLoweringType::translate (param.get_type ().get ())\n+\t\t\t: nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::TypeParam (mapping, param.get_type_representation (),\n+\t\t\t    param.get_locus (), std::move (type_param_bounds),\n+\t\t\t    std::unique_ptr<Type> (type),\n+\t\t\t    std::move (outer_attr));\n+  }\n+\n+private:\n+  ASTLowerGenericParam () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::GenericParam *translated;\n+};\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "355d5706fcf99a4329cf1dc4b5d5d90f4c4da1b5", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -269,5 +269,51 @@ ASTLoweringExprWithBlock::visit (AST::WhileLoopExpr &expr)\n \t\t\t      std::move (outer_attribs));\n }\n \n+// rust-ast-lower-expr.h\n+\n+void\n+ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n+{\n+  std::vector<HIR::PathExprSegment> path_segments;\n+  expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+    std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+    std::vector<HIR::Lifetime> lifetime_args;\n+    if (s.has_generic_args ())\n+      {\n+\tfor (auto &lifetime : s.get_generic_args ().get_lifetime_args ())\n+\t  {\n+\t    HIR::Lifetime l = lower_lifetime (lifetime);\n+\t    lifetime_args.push_back (std::move (l));\n+\t  }\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::Type> > type_args;\n+    if (s.has_generic_args ())\n+      {\n+\tfor (auto &type : s.get_generic_args ().get_type_args ())\n+\t  {\n+\t    HIR::Type *t = ASTLoweringType::translate (type.get ());\n+\t    type_args.push_back (std::unique_ptr<HIR::Type> (t));\n+\t  }\n+      }\n+\n+    PathExprSegment seg (s.get_ident_segment ().as_string (), s.get_locus (),\n+\t\t\t std::move (lifetime_args), std::move (type_args),\n+\t\t\t std::move (binding_args));\n+    path_segments.push_back (seg);\n+    return true;\n+  });\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t  expr.get_locus (),\n+\t\t\t\t\t  expr.opening_scope_resolution ());\n+}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "1415727486d08f33be42fea40b99d9cb84c9811d", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -57,20 +57,21 @@ class TypeParam : public GenericParam\n   // Returns whether the type param has an outer attribute.\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n-  TypeParam (Identifier type_representation, Location locus = Location (),\n+  TypeParam (Analysis::NodeMapping mappings, Identifier type_representation,\n+\t     Location locus = Location (),\n \t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n \t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n-    : outer_attr (std::move (outer_attr)),\n+    : GenericParam (mappings), outer_attr (std::move (outer_attr)),\n       type_representation (std::move (type_representation)),\n       type_param_bounds (std::move (type_param_bounds)),\n       type (std::move (type)), locus (locus)\n   {}\n \n   // Copy constructor uses clone\n   TypeParam (TypeParam const &other)\n-    : outer_attr (other.outer_attr),\n+    : GenericParam (other.mappings), outer_attr (other.outer_attr),\n       type_representation (other.type_representation),\n       type (other.type->clone_type ()), locus (other.locus)\n   {\n@@ -87,6 +88,7 @@ class TypeParam : public GenericParam\n     type = other.type->clone_type ();\n     outer_attr = other.outer_attr;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -103,8 +105,12 @@ class TypeParam : public GenericParam\n \n   Location get_locus () const { return locus; }\n \n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_type_representation () const { return type_representation; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeParam *clone_generic_param_impl () const override\n@@ -1502,6 +1508,11 @@ class Struct : public VisItem\n \n   Location get_locus () const { return locus; }\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n protected:\n   Struct (Analysis::NodeMapping mappings, Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam> > generic_params,"}, {"sha": "c4fe0da7b9722bb21eb3e5bc58777615276c0fee", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -172,7 +172,21 @@ struct GenericArgs\n \t\t\tstd::vector<GenericArgsBinding> ());\n   }\n \n+  bool is_empty () const\n+  {\n+    return lifetime_args.size () == 0 && type_args.size () == 0\n+\t   && binding_args.size () == 0;\n+  }\n+\n   std::string as_string () const;\n+\n+  std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; }\n+\n+  std::vector<std::unique_ptr<Type> > &get_type_args () { return type_args; }\n+\n+  std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n+\n+  Location get_locus () const { return locus; }\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe\n@@ -230,6 +244,8 @@ class PathExprSegment\n   Location get_locus () const { return locus; }\n \n   PathIdentSegment get_segment () const { return segment_name; }\n+\n+  GenericArgs &get_generic_args () { return generic_args; }\n };\n \n // HIR node representing a pattern that involves a \"path\" - abstract base class\n@@ -264,6 +280,8 @@ class PathPattern : public Pattern\n \t  return;\n       }\n   }\n+\n+  PathExprSegment get_final_segment () const { return segments.back (); }\n };\n \n /* HIR node representing a path-in-expression pattern (path that allows generic\n@@ -432,6 +450,8 @@ class TypePathSegmentGeneric : public TypePathSegment\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  GenericArgs get_generic_args () { return generic_args; }\n+\n protected:\n   // Use covariance to override base class method\n   TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n@@ -653,12 +673,14 @@ class TypePath : public TypeNoBounds\n \n   void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n   {\n-    for (auto it = segments.begin (); it != segments.end (); it++)\n+    for (auto &seg : segments)\n       {\n-\tif (!cb ((*it).get ()))\n+\tif (!cb (seg.get ()))\n \t  return;\n       }\n   }\n+\n+  TypePathSegment *get_final_segment () { return segments.back ().get (); }\n };\n \n struct QualifiedPathType"}, {"sha": "97f303c5dca2c07062c82664d687e40fdc4f80c7", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -1114,9 +1114,17 @@ class GenericParam\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual Location get_locus_slow () const = 0;\n+\n+  Analysis::NodeMapping get_mappings () const { return mappings; }\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual GenericParam *clone_generic_param_impl () const = 0;\n+\n+  GenericParam (Analysis::NodeMapping mapping) : mappings (mapping) {}\n+\n+  Analysis::NodeMapping mappings;\n };\n \n // A lifetime generic parameter (as opposed to a type generic parameter)\n@@ -1145,11 +1153,12 @@ class LifetimeParam : public GenericParam\n   bool is_error () const { return lifetime.is_error (); }\n \n   // Constructor\n-  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n+  LifetimeParam (Analysis::NodeMapping mappings, Lifetime lifetime,\n+\t\t Location locus = Location (),\n \t\t std::vector<Lifetime> lifetime_bounds\n \t\t = std::vector<Lifetime> (),\n \t\t Attribute outer_attr = Attribute::create_empty ())\n-    : lifetime (std::move (lifetime)),\n+    : GenericParam (mappings), lifetime (std::move (lifetime)),\n       lifetime_bounds (std::move (lifetime_bounds)),\n       outer_attr (std::move (outer_attr)), locus (locus)\n   {}\n@@ -1158,8 +1167,9 @@ class LifetimeParam : public GenericParam\n \n   // Copy constructor with clone\n   LifetimeParam (LifetimeParam const &other)\n-    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n-      outer_attr (other.outer_attr), locus (other.locus)\n+    : GenericParam (other.mappings), lifetime (other.lifetime),\n+      lifetime_bounds (other.lifetime_bounds), outer_attr (other.outer_attr),\n+      locus (other.locus)\n   {}\n \n   // Overloaded assignment operator to clone attribute\n@@ -1169,6 +1179,7 @@ class LifetimeParam : public GenericParam\n     lifetime_bounds = other.lifetime_bounds;\n     outer_attr = other.outer_attr;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -1181,6 +1192,10 @@ class LifetimeParam : public GenericParam\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Location get_locus () const { return locus; }\n+\n+  Location get_locus_slow () const override final { return get_locus (); }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "216ab411e89b136957c9af65ef0af5563793a337", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -27,6 +27,21 @@\n namespace Rust {\n namespace Resolver {\n \n+class ResolvePath : public ResolverBase\n+{\n+public:\n+  static void go (AST::PathInExpression *expr, NodeId parent)\n+  {\n+    ResolvePath resolver (parent);\n+    resolver.resolve_path (expr);\n+  }\n+\n+private:\n+  ResolvePath (NodeId parent) : ResolverBase (parent) {}\n+\n+  void resolve_path (AST::PathInExpression *expr);\n+};\n+\n class ResolveExpr : public ResolverBase\n {\n public:\n@@ -50,31 +65,7 @@ class ResolveExpr : public ResolverBase\n       ResolveExpr::go (elem.get (), expr.get_node_id ());\n   }\n \n-  void visit (AST::PathInExpression &expr)\n-  {\n-    // name scope first\n-    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n-      {\n-\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    // check the type scope\n-    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n-\t\t\t\t\t\t &resolved_node))\n-      {\n-\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    else\n-      {\n-\trust_error_at (expr.get_locus (), \"unknown path %s\",\n-\t\t       expr.as_string ().c_str ());\n-      }\n-  }\n+  void visit (AST::PathInExpression &expr) { ResolvePath::go (&expr, parent); }\n \n   void visit (AST::ReturnExpr &expr)\n   {"}, {"sha": "02d864fd0cf3eba69f9be2f9c8e82ac803056cf3", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -37,8 +37,6 @@ class ResolveItem : public ResolverBase\n     item->accept_vis (resolver);\n   };\n \n-  ~ResolveItem () {}\n-\n   void visit (AST::TupleStruct &struct_decl)\n   {\n     struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n@@ -50,11 +48,25 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl)\n   {\n+    NodeId scope_node_id = struct_decl.get_node_id ();\n+    resolver->get_type_scope ().push (scope_node_id);\n+\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic : struct_decl.get_generic_params ())\n+\t  {\n+\t    ResolveGenericParam::go (generic.get (),\n+\t\t\t\t     struct_decl.get_node_id ());\n+\t  }\n+      }\n+\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n       return true;\n     });\n+\n+    resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::StaticItem &var)"}, {"sha": "24090a0af7e6c277fb99cf81786c683964067b32", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -25,6 +25,53 @@\n namespace Rust {\n namespace Resolver {\n \n+class ResolveTypePath : public ResolverBase\n+{\n+public:\n+  static NodeId go (AST::TypePath &path, NodeId parent)\n+  {\n+    ResolveTypePath resolver (parent);\n+    resolver.resolve (path);\n+    return resolver.resolved_node;\n+  }\n+\n+  void visit (AST::TypePathSegmentGeneric &seg) override;\n+\n+  void visit (AST::TypePathSegment &seg) override;\n+\n+private:\n+  void resolve (AST::TypePath &path)\n+  {\n+    for (auto &seg : path.get_segments ())\n+      {\n+\tseg->accept_vis (*this);\n+\tif (type_seg_failed_flag)\n+\t  return;\n+      }\n+\n+    if (path_buffer.empty ())\n+      {\n+\trust_error_at (path.get_locus (), \"failed to resolve path: %s\",\n+\t\t       path.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    if (!resolver->get_type_scope ().lookup (path_buffer, &resolved_node))\n+      {\n+\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n+\t\t       path_buffer.c_str ());\n+\treturn;\n+      }\n+  }\n+\n+  ResolveTypePath (NodeId parent)\n+    : ResolverBase (parent), type_seg_failed_flag (false)\n+  {}\n+\n+  std::string path_buffer;\n+  bool type_seg_failed_flag;\n+};\n+\n class ResolveType : public ResolverBase\n {\n public:\n@@ -63,16 +110,8 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path)\n   {\n-    // this will need changed to handle mod/crate/use globs and look\n-    // at the segments in granularity\n-    if (!resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n-      {\n-\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    ok = true;\n+    resolved_node = ResolveTypePath::go (path, parent);\n+    ok = resolved_node != UNKNOWN_NODEID;\n     resolver->insert_resolved_type (path.get_node_id (), resolved_node);\n     resolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t     Definition{path.get_node_id (), parent});\n@@ -97,6 +136,40 @@ class ResolveType : public ResolverBase\n   bool ok;\n };\n \n+class ResolveGenericParam : public ResolverBase\n+{\n+public:\n+  static NodeId go (AST::GenericParam *param, NodeId parent)\n+  {\n+    ResolveGenericParam resolver (parent);\n+    param->accept_vis (resolver);\n+    if (!resolver.ok)\n+      rust_error_at (param->get_locus_slow (), \"unresolved generic parameter\");\n+\n+    return resolver.resolved_node;\n+  };\n+\n+  void visit (AST::TypeParam &param) override\n+  {\n+    ok = true;\n+\n+    // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n+    resolver->get_type_scope ().insert (\n+      param.get_type_representation (), param.get_node_id (),\n+      param.get_locus (), false,\n+      [&] (std::string, NodeId, Location locus) -> void {\n+\trust_error_at (param.get_locus (),\n+\t\t       \"generic param redefined multiple times\");\n+\trust_error_at (locus, \"was defined here\");\n+      });\n+  }\n+\n+private:\n+  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n+\n+  bool ok;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "6bc356a50abd8d4ecab78c6ff05e24cee681b72e", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -368,5 +368,103 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   ResolveExpr::go (&expr, field.get_node_id ());\n }\n \n+// rust-ast-resolve-type.h\n+\n+void\n+ResolveTypePath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n+  AST::GenericArgs &generics = seg.get_generic_args ();\n+  for (auto &gt : generics.get_type_args ())\n+    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+\n+  if (seg.is_error ())\n+    {\n+      type_seg_failed_flag = true;\n+      rust_error_at (Location (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (seg.get_separating_scope_resolution ())\n+    path_buffer += \"::\";\n+\n+  path_buffer += seg.get_ident_segment ().as_string ();\n+}\n+\n+void\n+ResolveTypePath::visit (AST::TypePathSegment &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      type_seg_failed_flag = true;\n+      rust_error_at (Location (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (seg.get_separating_scope_resolution ())\n+    path_buffer += \"::\";\n+\n+  path_buffer += seg.get_ident_segment ().as_string ();\n+}\n+\n+// rust-ast-resolve-expr.h\n+\n+void\n+ResolvePath::resolve_path (AST::PathInExpression *expr)\n+{\n+  // this needs extended similar to the TypePath to lookup each segment\n+  // in turn then look its rib for the next segment and so forth until we\n+  // resolve to a final NodeId generic args can be ignored\n+  std::string path_buf;\n+  for (auto &seg : expr->get_segments ())\n+    {\n+      auto s = seg.get_ident_segment ();\n+      if (s.is_error () && !seg.has_generic_args ())\n+\t{\n+\t  rust_error_at (expr->get_locus (), \"malformed path\");\n+\t  return;\n+\t}\n+\n+      if (seg.has_generic_args ())\n+\t{\n+\t  AST::GenericArgs &args = seg.get_generic_args ();\n+\t  for (auto &gt : args.get_type_args ())\n+\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+\t}\n+\n+      if (!s.is_error ())\n+\t{\n+\t  bool needs_sep = !path_buf.empty ();\n+\t  if (needs_sep)\n+\t    path_buf += \"::\";\n+\n+\t  path_buf += s.as_string ();\n+\t}\n+    }\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (path_buf, &resolved_node))\n+    {\n+      resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (path_buf, &resolved_node))\n+    {\n+      resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (), \"unknown path %s\",\n+\t\t     expr->as_string ().c_str (), path_buf.c_str ());\n+    }\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "7cb24d8d4e61e20d3926f910b047eab47cc0e00c", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -1200,27 +1200,10 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n   if (type == error_mark_node)\n     return this->error_type ();\n \n-  // The middle-end expects a basic type to have a name.  In Go every\n-  // basic type will have a name.  The first time we see a basic type,\n-  // give it whatever Go name we have at this point.\n-  if (TYPE_NAME (type) == NULL_TREE\n-      && location.gcc_location () == BUILTINS_LOCATION\n-      && (TREE_CODE (type) == INTEGER_TYPE || TREE_CODE (type) == REAL_TYPE\n-\t  || TREE_CODE (type) == COMPLEX_TYPE\n-\t  || TREE_CODE (type) == BOOLEAN_TYPE))\n-    {\n-      tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), type);\n-      TYPE_NAME (type) = decl;\n-      return this->make_type (type);\n-    }\n-\n-  tree copy = build_variant_type_copy (type);\n   tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t  get_identifier_from_string (name), copy);\n-  DECL_ORIGINAL_TYPE (decl) = type;\n-  TYPE_NAME (copy) = decl;\n-  return this->make_type (copy);\n+\t\t\t  get_identifier_from_string (name), type);\n+  TYPE_NAME (type) = decl;\n+  return this->make_type (type);\n }\n \n // Return a pointer type used as a marker for a circular type."}, {"sha": "525381f3ffdd3607f496ca75d635537a228c9f08", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -32,9 +32,8 @@ class TypeCheckStructExpr : public TypeCheckBase\n public:\n   static TyTy::BaseType *Resolve (HIR::StructExprStructFields *expr)\n   {\n-    TypeCheckStructExpr resolver;\n+    TypeCheckStructExpr resolver (expr);\n     expr->accept_vis (resolver);\n-    rust_assert (resolver.resolved != nullptr);\n     return resolver.resolved;\n   }\n \n@@ -49,13 +48,18 @@ class TypeCheckStructExpr : public TypeCheckBase\n   void visit (HIR::StructExprFieldIdentifier &field);\n \n private:\n-  TypeCheckStructExpr ()\n-    : TypeCheckBase (), resolved (nullptr), struct_path_resolved (nullptr)\n+  TypeCheckStructExpr (HIR::Expr *e)\n+    : TypeCheckBase (),\n+      resolved (new TyTy::ErrorType (e->get_mappings ().get_hirid ())),\n+      struct_path_resolved (nullptr)\n   {}\n \n+  // result\n   TyTy::BaseType *resolved;\n+\n+  // internal state:\n   TyTy::ADTType *struct_path_resolved;\n-  TyTy::BaseType *resolved_field;\n+  TyTy::BaseType *resolved_field_value_expr;\n   std::set<std::string> fields_assigned;\n   std::map<size_t, HIR::StructExprField *> adtFieldIndexToField;\n };"}, {"sha": "a7fa604061570e259436773003e324a1a03a91d7", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -40,6 +40,20 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::TupleStruct &struct_decl)\n   {\n+    std::vector<TyTy::SubstitionMapping> substitions;\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : struct_decl.get_generic_params ())\n+\t  {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitions.push_back (\n+\t      TyTy::SubstitionMapping (generic_param, param_type));\n+\t  }\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n \n     size_t idx = 0;\n@@ -57,13 +71,29 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   struct_decl.get_identifier (), std::move (fields),\n+\t\t\t   std::move (substitions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n \n   void visit (HIR::StructStruct &struct_decl)\n   {\n+    std::vector<TyTy::SubstitionMapping> substitions;\n+    if (struct_decl.has_generics ())\n+      {\n+\tfor (auto &generic_param : struct_decl.get_generic_params ())\n+\t  {\n+\t    auto param_type\n+\t      = TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t    context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t    substitions.push_back (\n+\t      TyTy::SubstitionMapping (generic_param, param_type));\n+\t  }\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n     struct_decl.iterate ([&] (HIR::StructField &field) mutable -> bool {\n       TyTy::BaseType *field_type\n@@ -78,7 +108,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   struct_decl.get_identifier (), std::move (fields));\n+\t\t\t   mappings->get_next_hir_id (),\n+\t\t\t   struct_decl.get_identifier (), std::move (fields),\n+\t\t\t   std::move (substitions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }"}, {"sha": "1592e220d0f18ba2a1160be53165c901c0650a79", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 110, "deletions": 6, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -62,6 +62,29 @@ class ArrayCapacityConstant : public TypeCheckBase\n   size_t result;\n }; // namespace Resolver\n \n+class TypeCheckResolveGenericArguments : public TypeCheckBase\n+{\n+public:\n+  static HIR::GenericArgs resolve (HIR::TypePathSegment *segment)\n+  {\n+    TypeCheckResolveGenericArguments resolver;\n+    segment->accept_vis (resolver);\n+    return resolver.args;\n+  };\n+\n+  void visit (HIR::TypePathSegmentGeneric &generic) override\n+  {\n+    args = generic.get_generic_args ();\n+  }\n+\n+private:\n+  TypeCheckResolveGenericArguments ()\n+    : TypeCheckBase (), args (HIR::GenericArgs::create_empty ())\n+  {}\n+\n+  HIR::GenericArgs args;\n+};\n+\n class TypeCheckType : public TypeCheckBase\n {\n public:\n@@ -71,11 +94,7 @@ class TypeCheckType : public TypeCheckBase\n     type->accept_vis (resolver);\n \n     if (resolver.translated == nullptr)\n-      {\n-\trust_error_at (Location (), \"failed to translate %s\",\n-\t\t       type->as_string ().c_str ());\n-\treturn new TyTy::ErrorType (type->get_mappings ().get_hirid ());\n-      }\n+      return new TyTy::ErrorType (type->get_mappings ().get_hirid ());\n \n     resolver.context->insert_type (type->get_mappings (), resolver.translated);\n     return resolver.translated;\n@@ -156,10 +175,65 @@ class TypeCheckType : public TypeCheckBase\n \t    translated = translated->clone ();\n \t    auto ref = path.get_mappings ().get_hirid ();\n \t    translated->set_ref (ref);\n+\n+\t    HIR::TypePathSegment *final_seg = path.get_final_segment ();\n+\t    HIR::GenericArgs args\n+\t      = TypeCheckResolveGenericArguments::resolve (final_seg);\n+\n+\t    bool path_declared_generic_arguments = !args.is_empty ();\n+\t    if (path_declared_generic_arguments)\n+\t      {\n+\t\tif (translated->has_subsititions_defined ())\n+\t\t  {\n+\t\t    // so far we only support ADT so lets just handle it here\n+\t\t    // for now\n+\t\t    if (translated->get_kind () != TyTy::TypeKind::ADT)\n+\t\t      {\n+\t\t\trust_error_at (\n+\t\t\t  path.get_locus (),\n+\t\t\t  \"unsupported type for generic substitution: %s\",\n+\t\t\t  translated->as_string ().c_str ());\n+\t\t\treturn;\n+\t\t      }\n+\n+\t\t    TyTy::ADTType *adt\n+\t\t      = static_cast<TyTy::ADTType *> (translated);\n+\t\t    translated = adt->handle_substitions (args);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    rust_error_at (\n+\t\t      path.get_locus (),\n+\t\t      \"TypePath %s declares generic argument's but \"\n+\t\t      \"the type %s does not have any\",\n+\t\t      path.as_string ().c_str (),\n+\t\t      translated->as_string ().c_str ());\n+\t\t    return;\n+\t\t  }\n+\t      }\n+\t    else if (translated->supports_substitions ())\n+\t      {\n+\t\t// so far we only support ADT so lets just handle it here\n+\t\t// for now\n+\t\tif (translated->get_kind () != TyTy::TypeKind::ADT)\n+\t\t  {\n+\t\t    rust_error_at (\n+\t\t      path.get_locus (),\n+\t\t      \"unsupported type for generic substitution: %s\",\n+\t\t      translated->as_string ().c_str ());\n+\t\t    return;\n+\t\t  }\n+\n+\t\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (translated);\n+\t\ttranslated = adt->infer_substitions ();\n+\t      }\n+\n \t    return;\n \t  }\n       }\n-    gcc_unreachable ();\n+\n+    rust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n+\t\t   path.as_string ().c_str ());\n   }\n \n   void visit (HIR::ArrayType &type)\n@@ -197,6 +271,36 @@ class TypeCheckType : public TypeCheckBase\n   TyTy::BaseType *translated;\n };\n \n+class TypeResolveGenericParam : public TypeCheckBase\n+{\n+public:\n+  static TyTy::ParamType *Resolve (HIR::GenericParam *param)\n+  {\n+    TypeResolveGenericParam resolver;\n+    param->accept_vis (resolver);\n+\n+    if (resolver.resolved == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to setup generic parameter\");\n+\treturn nullptr;\n+      }\n+\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::TypeParam &param) override\n+  {\n+    resolved = new TyTy::ParamType (param.get_type_representation (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), param);\n+  }\n+\n+private:\n+  TypeResolveGenericParam () : TypeCheckBase (), resolved (nullptr) {}\n+\n+  TyTy::ParamType *resolved;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "69f13dbf9724c05be47e9b75d6b34ed098a18456", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -158,14 +158,15 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n       return;\n     }\n \n-  resolved = struct_path_resolved;\n+  TyTy::ADTType *struct_def = struct_path_resolved;\n   if (struct_expr.has_struct_base ())\n     {\n       TyTy::BaseType *base_resolved\n \t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n \t\t\t\t  false);\n-      resolved = struct_path_resolved->unify (base_resolved);\n-      if (resolved == nullptr)\n+      struct_def\n+\t= (TyTy::ADTType *) struct_path_resolved->unify (base_resolved);\n+      if (struct_def == nullptr)\n \t{\n \t  rust_fatal_error (\n \t    struct_expr.struct_base->base_struct->get_locus_slow (),\n@@ -174,25 +175,30 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \t}\n     }\n \n+  std::vector<TyTy::StructFieldType *> infered_fields;\n   bool ok = true;\n   struct_expr.iterate ([&] (HIR::StructExprField *field) mutable -> bool {\n-    resolved_field = nullptr;\n+    resolved_field_value_expr = nullptr;\n     field->accept_vis (*this);\n-    if (resolved_field == nullptr)\n+    if (resolved_field_value_expr == nullptr)\n       {\n \trust_fatal_error (field->get_locus (),\n \t\t\t  \"failed to resolve type for field\");\n \tok = false;\n \treturn false;\n       }\n \n-    context->insert_type (field->get_mappings (), resolved_field);\n+    context->insert_type (field->get_mappings (), resolved_field_value_expr);\n     return true;\n   });\n \n   // something failed setting up the fields\n   if (!ok)\n-    return;\n+    {\n+      rust_error_at (struct_expr.get_locus (),\n+\t\t     \"constructor type resolution failure\");\n+      return;\n+    }\n \n   // check the arguments are all assigned and fix up the ordering\n   if (fields_assigned.size () != struct_path_resolved->num_fields ())\n@@ -270,6 +276,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \tstd::unique_ptr<HIR::StructExprField> (adtFieldIndexToField[i]));\n     }\n   struct_expr.set_fields_as_owner (std::move (ordered_fields));\n+\n+  resolved = struct_def;\n }\n \n void\n@@ -315,7 +323,16 @@ TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n \t\t\t\"expected an ADT type\");\n       return;\n     }\n-  struct_path_resolved = (TyTy::ADTType *) lookup;\n+\n+  struct_path_resolved = static_cast<TyTy::ADTType *> (lookup);\n+  if (struct_path_resolved->has_substitions ())\n+    {\n+      HIR::PathExprSegment seg = expr.get_final_segment ();\n+      struct_path_resolved\n+\t= seg.has_generic_args ()\n+\t    ? struct_path_resolved->handle_substitions (seg.get_generic_args ())\n+\t    : struct_path_resolved->infer_substitions ();\n+    }\n }\n \n void\n@@ -329,7 +346,6 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n     }\n \n   size_t field_index;\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n   TyTy::StructFieldType *field_type\n     = struct_path_resolved->get_field (field.field_name, &field_index);\n   if (field_type == nullptr)\n@@ -338,8 +354,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n       return;\n     }\n \n-  resolved_field = field_type->get_field_type ()->unify (value);\n-  if (resolved_field != nullptr)\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field.field_name);\n       adtFieldIndexToField[field_index] = &field;\n@@ -358,7 +375,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n     }\n \n   size_t field_index;\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+\n   TyTy::StructFieldType *field_type\n     = struct_path_resolved->get_field (field_name, &field_index);\n   if (field_type == nullptr)\n@@ -367,8 +384,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n       return;\n     }\n \n-  resolved_field = field_type->get_field_type ()->unify (value);\n-  if (resolved_field != nullptr)\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n     {\n       fields_assigned.insert (field_name);\n       adtFieldIndexToField[field_index] = &field;\n@@ -400,8 +418,9 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n \t\t\t    field.get_locus ());\n   TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n \n-  resolved_field = field_type->get_field_type ()->unify (value);\n-  if (resolved_field != nullptr)\n+  resolved_field_value_expr = field_type->get_field_type ()->unify (value);\n+  if (resolved_field_value_expr != nullptr)\n+\n     {\n       fields_assigned.insert (field.field_name);\n       adtFieldIndexToField[field_index] = &field;"}, {"sha": "5bb33c920b1192117daeaf79c02d567057e11d8d", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -32,11 +32,20 @@ class TypeResolverDump : public TypeCheckBase\n   {\n     TypeResolverDump dumper;\n     for (auto &item : crate.items)\n-      item->accept_vis (dumper);\n+      {\n+\titem->accept_vis (dumper);\n+\tdumper.dump += \"\\n\";\n+      }\n \n     out << dumper.dump;\n   }\n \n+  void visit (HIR::StructStruct &struct_decl) override\n+  {\n+    dump += indent () + \"struct \" + type_string (struct_decl.get_mappings ())\n+\t    + \"\\n\";\n+  }\n+\n   void visit (HIR::InherentImpl &impl_block) override\n   {\n     dump += indent () + \"impl \"\n@@ -177,6 +186,11 @@ class TypeResolverDump : public TypeCheckBase\n     dump += type_string (expr.get_mappings ());\n   }\n \n+  void visit (HIR::StructExprStructFields &expr) override\n+  {\n+    dump += \"ctor: \" + type_string (expr.get_mappings ());\n+  }\n+\n protected:\n   std::string type_string (const Analysis::NodeMapping &mappings)\n   {\n@@ -192,8 +206,8 @@ class TypeResolverDump : public TypeCheckBase\n       }\n     buf += \"]\";\n \n-    return \"<\" + lookup->as_string ()\n-\t   + \" HIRID: \" + std::to_string (mappings.get_hirid ())\n+    std::string repr = lookup->as_string ();\n+    return \"<\" + repr + \" HIRID: \" + std::to_string (mappings.get_hirid ())\n \t   + \" RF:\" + std::to_string (lookup->get_ref ()) + \" TF:\"\n \t   + std::to_string (lookup->get_ty_ref ()) + +\" - \" + buf + \">\";\n   }"}, {"sha": "612a5e856021b4ab24086ed6278031637d3c22c4", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -42,7 +42,6 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n   void visit (TupleType &type) override { gcc_unreachable (); }\n-  void visit (StructFieldType &type) override { gcc_unreachable (); }\n   void visit (ArrayType &type) override { gcc_unreachable (); }\n   void visit (BoolType &type) override { gcc_unreachable (); }\n   void visit (IntType &type) override { gcc_unreachable (); }\n@@ -53,6 +52,7 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (ErrorType &type) override { gcc_unreachable (); }\n   void visit (CharType &type) override { gcc_unreachable (); }\n   void visit (ReferenceType &type) override { gcc_unreachable (); }\n+  void visit (ParamType &) override { gcc_unreachable (); }\n \n   // tuple-structs\n   void visit (ADTType &type) override;\n@@ -86,7 +86,6 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n   void visit (TupleType &type) override { gcc_unreachable (); }\n-  void visit (StructFieldType &type) override { gcc_unreachable (); }\n   void visit (ArrayType &type) override { gcc_unreachable (); }\n   void visit (BoolType &type) override { gcc_unreachable (); }\n   void visit (IntType &type) override { gcc_unreachable (); }\n@@ -98,6 +97,7 @@ class TypeCheckMethodCallExpr : private TyVisitor\n   void visit (ADTType &type) override { gcc_unreachable (); };\n   void visit (CharType &type) override { gcc_unreachable (); }\n   void visit (ReferenceType &type) override { gcc_unreachable (); }\n+  void visit (ParamType &) override { gcc_unreachable (); }\n \n   // call fns\n   void visit (FnType &type) override;"}, {"sha": "ef7a60cea40113770083631197341479df074191", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -55,8 +55,17 @@ class BaseRules : public TyVisitor\n \n      This method is meant to be used internally by Ty. If you're trying to unify\n      two ty, you can simply call `unify` on ty themselves. */\n-  BaseType *unify (BaseType *other)\n+  virtual BaseType *unify (BaseType *other)\n   {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+\n     other->accept_vis (*this);\n     if (resolved != nullptr)\n       {\n@@ -197,28 +206,29 @@ class BaseRules : public TyVisitor\n \t\t   type.as_string ().c_str ());\n   }\n \n-  virtual void visit (StructFieldType &type) override\n+  virtual void visit (CharType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n   }\n \n-  virtual void visit (CharType &type) override\n+  virtual void visit (ReferenceType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n   }\n \n-  virtual void visit (ReferenceType &type) override\n+  virtual void visit (ParamType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+    rust_error_at (ref_locus, \"expected [%s] got [ParamTy <%s>]\",\n \t\t   get_base ()->as_string ().c_str (),\n \t\t   type.as_string ().c_str ());\n+    gcc_unreachable ();\n   }\n \n protected:\n@@ -461,28 +471,6 @@ class InferRules : public BaseRules\n   InferType *base;\n };\n \n-class StructFieldTypeRules : public BaseRules\n-{\n-public:\n-  StructFieldTypeRules (StructFieldType *base) : BaseRules (base), base (base)\n-  {}\n-\n-  void visit (StructFieldType &type)\n-  {\n-    BaseType *ty = base->get_field_type ()->unify (type.get_field_type ());\n-    if (ty == nullptr)\n-      return;\n-\n-    resolved = new TyTy::StructFieldType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t\t  type.get_name (), ty);\n-  }\n-\n-private:\n-  BaseType *get_base () override { return base; }\n-\n-  StructFieldType *base;\n-};\n-\n class UnitRules : public BaseRules\n {\n public:\n@@ -718,32 +706,31 @@ class ADTRules : public BaseRules\n public:\n   ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n \n-  void visit (ADTType &type)\n+  void visit (ADTType &type) override\n   {\n     if (base->num_fields () != type.num_fields ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    std::vector<TyTy::StructFieldType *> fields;\n     for (size_t i = 0; i < type.num_fields (); ++i)\n       {\n \tTyTy::StructFieldType *base_field = base->get_field (i);\n \tTyTy::StructFieldType *other_field = type.get_field (i);\n \n-\tBaseType *unified_ty = base_field->unify (other_field);\n+\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n \tif (unified_ty == nullptr)\n \t  {\n \t    BaseRules::visit (type);\n \t    return;\n \t  }\n-\n-\tfields.push_back ((TyTy::StructFieldType *) unified_ty);\n       }\n \n-    resolved = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t\t  type.get_name (), fields);\n+    resolved = base->clone ();\n   }\n \n private:\n@@ -889,6 +876,46 @@ class ReferenceRules : public BaseRules\n   ReferenceType *base;\n };\n \n+class ParamRules : public BaseRules\n+{\n+public:\n+  ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  BaseType *unify (BaseType *other) override final\n+  {\n+    if (base->get_ref () == base->get_ty_ref ())\n+      {\n+\tLocation locus = mappings->lookup_location (base->get_ref ());\n+\trust_fatal_error (locus,\n+\t\t\t  \"invalid use of unify with ParamTy [%s] and [%s]\",\n+\t\t\t  base->as_string ().c_str (),\n+\t\t\t  other->as_string ().c_str ());\n+\treturn nullptr;\n+      }\n+\n+    auto context = Resolver::TypeCheckContext::get ();\n+    BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+\n+    return lookup->unify (other);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "b49085d6e1ade9d62b9c609d52d83dba63c4ccd3", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -29,7 +29,6 @@ class TyVisitor\n public:\n   virtual void visit (UnitType &type) = 0;\n   virtual void visit (InferType &type) = 0;\n-  virtual void visit (StructFieldType &type) = 0;\n   virtual void visit (ADTType &type) = 0;\n   virtual void visit (TupleType &type) = 0;\n   virtual void visit (FnType &type) = 0;\n@@ -43,6 +42,7 @@ class TyVisitor\n   virtual void visit (ErrorType &type) = 0;\n   virtual void visit (CharType &type) = 0;\n   virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ParamType &type) = 0;\n };\n \n } // namespace TyTy"}, {"sha": "89507c7c79d73abc1ae449a69d63ad92c4f741ca", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 189, "deletions": 64, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -20,7 +20,9 @@\n #include \"rust-tyty-visitor.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-expr.h\"\n+#include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n+#include \"rust-hir-map.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -100,8 +102,6 @@ ErrorType::as_string () const\n BaseType *\n ErrorType::unify (BaseType *other)\n {\n-  // FIXME\n-  // rust_error_at ();\n   return this;\n }\n \n@@ -111,45 +111,24 @@ ErrorType::clone ()\n   return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n-void\n-StructFieldType::accept_vis (TyVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n std::string\n StructFieldType::as_string () const\n {\n   return name + \":\" + ty->as_string ();\n }\n \n-BaseType *\n-StructFieldType::unify (BaseType *other)\n-{\n-  StructFieldTypeRules r (this);\n-  return r.unify (other);\n-}\n-\n bool\n-StructFieldType::is_equal (const BaseType &other) const\n+StructFieldType::is_equal (const StructFieldType &other) const\n {\n-  if (get_kind () != other.get_kind ())\n-    {\n-      return false;\n-    }\n-  else\n-    {\n-      auto other2 = static_cast<const StructFieldType &> (other);\n-      return get_field_type () == other2.get_field_type ();\n-    }\n+  return get_name ().compare (other.get_name ()) == 0\n+\t && get_field_type ()->is_equal (*other.get_field_type ());\n }\n \n-BaseType *\n-StructFieldType::clone ()\n+StructFieldType *\n+StructFieldType::clone () const\n {\n-  return new StructFieldType (get_ref (), get_ty_ref (), get_name (),\n-\t\t\t      get_field_type ()->clone (),\n-\t\t\t      get_combined_refs ());\n+  return new StructFieldType (get_ref (), get_name (),\n+\t\t\t      get_field_type ()->clone ());\n }\n \n void\n@@ -161,15 +140,35 @@ ADTType::accept_vis (TyVisitor &vis)\n std::string\n ADTType::as_string () const\n {\n-  // if (num_fields () == 0)\n-  //   return identifier;\n+  if (num_fields () == 0)\n+    return identifier;\n+\n+  std::string fields_buffer;\n+  for (size_t i = 0; i < num_fields (); ++i)\n+    {\n+      fields_buffer += get_field (i)->as_string ();\n+      if ((i + 1) < num_fields ())\n+\tfields_buffer += \", \";\n+    }\n+\n+  return identifier + subst_as_string () + \"{\" + fields_buffer + \"}\";\n+}\n \n-  // std::string fields_buffer;\n-  // for (auto &field : fields)\n-  //   fields_buffer += field->as_string () + \", \";\n+const StructFieldType *\n+ADTType::get_field (size_t index) const\n+{\n+  return fields.at (index);\n+}\n \n-  // return identifier + \"{\" + fields_buffer + \"}\";\n-  return identifier;\n+const BaseType *\n+ADTType::get_field_type (size_t index) const\n+{\n+  const StructFieldType *ref = get_field (index);\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (ref->get_field_type ()->get_ref (), &lookup);\n+  rust_assert (ok);\n+  return lookup;\n }\n \n BaseType *\n@@ -183,25 +182,19 @@ bool\n ADTType::is_equal (const BaseType &other) const\n {\n   if (get_kind () != other.get_kind ())\n+    return false;\n+\n+  auto other2 = static_cast<const ADTType &> (other);\n+  if (num_fields () != other2.num_fields ())\n+    return false;\n+\n+  for (size_t i = 0; i < num_fields (); i++)\n     {\n-      return false;\n-    }\n-  else\n-    {\n-      auto other2 = static_cast<const ADTType &> (other);\n-      if (num_fields () != other2.num_fields ())\n-\t{\n-\t  return false;\n-\t}\n-      for (size_t i = 0; i < num_fields (); i++)\n-\t{\n-\t  if (!get_field (i)->is_equal (*other2.get_field (i)))\n-\t    {\n-\t      return false;\n-\t    }\n-\t}\n-      return true;\n+      if (!get_field (i)->is_equal (*other2.get_field (i)))\n+\treturn false;\n     }\n+\n+  return true;\n }\n \n BaseType *\n@@ -211,8 +204,93 @@ ADTType::clone ()\n   for (auto &f : fields)\n     cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-  return new ADTType (get_ref (), get_ty_ref (), get_name (), cloned_fields,\n-\t\t      get_combined_refs ());\n+  return new ADTType (get_ref (), get_ty_ref (), identifier, cloned_fields,\n+\t\t      clone_substs (), get_combined_refs ());\n+}\n+\n+ADTType *\n+ADTType::infer_substitions ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  ADTType *adt = static_cast<ADTType *> (clone ());\n+\n+  for (auto &sub : adt->get_substs ())\n+    {\n+      // generate an new inference variable\n+      InferType *infer = new InferType (mappings->get_next_hir_id (),\n+\t\t\t\t\tInferType::InferTypeKind::GENERAL);\n+      context->insert_type (\n+\tAnalysis::NodeMapping (mappings->get_current_crate (), UNKNOWN_NODEID,\n+\t\t\t       infer->get_ref (), UNKNOWN_LOCAL_DEFID),\n+\tinfer);\n+\n+      sub.fill_param_ty (infer);\n+      adt->fill_in_params_for (sub, infer);\n+    }\n+\n+  // generate new ty ref id since this is an instantiate of the generic\n+  adt->set_ty_ref (mappings->get_next_hir_id ());\n+\n+  return adt;\n+}\n+\n+ADTType *\n+ADTType::handle_substitions (HIR::GenericArgs &generic_args)\n+{\n+  if (generic_args.get_type_args ().size () != get_num_substitions ())\n+    {\n+      rust_error_at (generic_args.get_locus (),\n+\t\t     \"invalid number of generic arguments to generic ADT type\");\n+      return nullptr;\n+    }\n+\n+  ADTType *adt = static_cast<ADTType *> (clone ());\n+  size_t index = 0;\n+  for (auto &arg : generic_args.get_type_args ())\n+    {\n+      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n+      if (resolved == nullptr)\n+\t{\n+\t  rust_error_at (generic_args.get_locus (),\n+\t\t\t \"failed to resolve type arguments\");\n+\t  return nullptr;\n+\t}\n+\n+      adt->fill_in_at (index, resolved);\n+      index++;\n+    }\n+\n+  // generate new ty ref id since this is an instantiate of the generic\n+  adt->set_ty_ref (mappings->get_next_hir_id ());\n+\n+  return adt;\n+}\n+\n+void\n+ADTType::fill_in_at (size_t index, BaseType *type)\n+{\n+  SubstitionMapping sub = get_substition_mapping_at (index);\n+  SubstitionRef<ADTType>::fill_in_at (index, type);\n+  fill_in_params_for (sub, type);\n+}\n+\n+void\n+ADTType::fill_in_params_for (SubstitionMapping sub, BaseType *type)\n+{\n+  iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n+    bool is_param_ty = field->get_field_type ()->get_kind () == TypeKind::PARAM;\n+    if (!is_param_ty)\n+      return true;\n+\n+    const ParamType *pp = sub.get_param_ty ();\n+    ParamType *p = static_cast<ParamType *> (field->get_field_type ());\n+\n+    // for now let just see what symbols match up for the substitution\n+    if (p->get_symbol ().compare (pp->get_symbol ()) == 0)\n+      p->set_ty_ref (type->get_ref ());\n+\n+    return true;\n+  });\n }\n \n void\n@@ -637,14 +715,10 @@ bool\n ReferenceType::is_equal (const BaseType &other) const\n {\n   if (get_kind () != other.get_kind ())\n-    {\n-      return false;\n-    }\n-  else\n-    {\n-      auto other2 = static_cast<const ReferenceType &> (other);\n-      return get_base () == other2.get_base ();\n-    }\n+    return false;\n+\n+  auto other2 = static_cast<const ReferenceType &> (other);\n+  return get_base ()->is_equal (*other2.get_base ());\n }\n \n const BaseType *\n@@ -674,6 +748,57 @@ ReferenceType::clone ()\n \t\t\t    get_combined_refs ());\n }\n \n+void\n+ParamType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ParamType::as_string () const\n+{\n+  if (get_ref () == get_ty_ref ())\n+    return get_symbol ();\n+\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (get_ty_ref (), &lookup);\n+  rust_assert (ok);\n+\n+  return lookup->as_string ();\n+}\n+\n+BaseType *\n+ParamType::unify (BaseType *other)\n+{\n+  ParamRules r (this);\n+  return r.unify (other);\n+}\n+\n+BaseType *\n+ParamType::clone ()\n+{\n+  return new ParamType (get_symbol (), get_ref (), get_ty_ref (),\n+\t\t\tget_generic_param (), get_combined_refs ());\n+}\n+\n+std::string\n+ParamType::get_symbol () const\n+{\n+  return symbol;\n+}\n+\n+BaseType *\n+ParamType::resolve ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  BaseType *lookup = nullptr;\n+  bool ok = context->lookup_type (get_ty_ref (), &lookup);\n+  rust_assert (ok);\n+\n+  return lookup;\n+}\n+\n // rust-tyty-call.h\n \n void"}, {"sha": "50fc3521dd1de95698ad4ae68493ca13b199a76a", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 200, "deletions": 26, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -42,7 +42,6 @@ enum TypeKind\n   UINT,\n   FLOAT,\n   UNIT,\n-  FIELD,\n   USIZE,\n   ISIZE,\n   // there are more to add...\n@@ -68,6 +67,8 @@ class BaseType\n \n   virtual std::string as_string () const = 0;\n \n+  virtual std::string get_name () const = 0;\n+\n   /* Unify two types. Returns a pointer to the newly-created unified ty, or\n      nullptr if the two ty cannot be unified. The caller is responsible for\n      releasing the memory of the returned ty. */\n@@ -90,21 +91,28 @@ class BaseType\n    * releasing the memory of the returned ty. */\n   virtual BaseType *clone () = 0;\n \n+  // get_combined_refs returns the chain of node refs involved in unification\n   std::set<HirId> get_combined_refs () { return combined; }\n \n   void append_reference (HirId id) { combined.insert (id); }\n \n+  virtual bool supports_substitions () const { return false; }\n+\n+  virtual bool has_subsititions_defined () const { return false; }\n+\n protected:\n   BaseType (HirId ref, HirId ty_ref, TypeKind kind,\n \t    std::set<HirId> refs = std::set<HirId> ())\n-    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs)\n+    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs),\n+      mappings (Analysis::Mappings::get ())\n   {}\n \n   TypeKind kind;\n   HirId ref;\n   HirId ty_ref;\n-\n   std::set<HirId> combined;\n+\n+  Analysis::Mappings *mappings;\n };\n \n class InferType : public BaseType\n@@ -129,7 +137,7 @@ class InferType : public BaseType\n \n   void accept_vis (TyVisitor &vis) override;\n \n-  bool is_unit () const override { return true; }\n+  bool is_unit () const override { return false; }\n \n   std::string as_string () const override;\n \n@@ -139,6 +147,8 @@ class InferType : public BaseType\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n \n+  std::string get_name () const override final { return as_string (); }\n+\n private:\n   InferTypeKind infer_kind;\n };\n@@ -163,6 +173,8 @@ class ErrorType : public BaseType\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n };\n \n class UnitType : public BaseType\n@@ -185,38 +197,31 @@ class UnitType : public BaseType\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n+\n+  std::string get_name () const override final { return as_string (); }\n };\n \n-class StructFieldType : public BaseType\n+class StructFieldType\n {\n public:\n-  StructFieldType (HirId ref, std::string name, BaseType *ty,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::FIELD, refs), name (name), ty (ty)\n-  {}\n-\n-  StructFieldType (HirId ref, HirId ty_ref, std::string name, BaseType *ty,\n-\t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::FIELD, refs), name (name), ty (ty)\n+  StructFieldType (HirId ref, std::string name, BaseType *ty)\n+    : ref (ref), name (name), ty (ty)\n   {}\n \n-  void accept_vis (TyVisitor &vis) override;\n-\n-  bool is_unit () const override { return ty->is_unit (); }\n-\n-  std::string as_string () const override;\n+  HirId get_ref () const { return ref; }\n \n-  BaseType *unify (BaseType *other) override;\n+  std::string as_string () const;\n \n-  virtual bool is_equal (const BaseType &other) const override;\n+  bool is_equal (const StructFieldType &other) const;\n \n   std::string get_name () const { return name; }\n \n   BaseType *get_field_type () const { return ty; }\n \n-  BaseType *clone () final override;\n+  StructFieldType *clone () const;\n \n private:\n+  HirId ref;\n   std::string name;\n   BaseType *ty;\n };\n@@ -225,6 +230,7 @@ class TupleType : public BaseType\n {\n public:\n   TupleType (HirId ref, std::vector<HirId> fields,\n+\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::TUPLE, refs), fields (fields)\n   {}\n@@ -259,24 +265,148 @@ class TupleType : public BaseType\n       }\n   }\n \n+  std::string get_name () const override final { return as_string (); }\n+\n private:\n   std::vector<HirId> fields;\n };\n \n-class ADTType : public BaseType\n+class ParamType : public BaseType\n+{\n+public:\n+  ParamType (std::string symbol, HirId ref, HIR::GenericParam &param,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PARAM), symbol (symbol), param (param)\n+  {}\n+\n+  ParamType (std::string symbol, HirId ref, HirId ty_ref,\n+\t     HIR::GenericParam &param,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ty_ref, TypeKind::PARAM), symbol (symbol), param (param)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  BaseType *unify (BaseType *other) override;\n+\n+  BaseType *clone () final override;\n+\n+  std::string get_symbol () const;\n+\n+  HIR::GenericParam &get_generic_param () { return param; }\n+\n+  bool can_resolve () const { return get_ref () != get_ty_ref (); }\n+\n+  BaseType *resolve ();\n+\n+  std::string get_name () const override final { return as_string (); }\n+\n+private:\n+  std::string symbol;\n+  HIR::GenericParam &param;\n+};\n+\n+class SubstitionMapping\n+{\n+public:\n+  SubstitionMapping (std::unique_ptr<HIR::GenericParam> &generic,\n+\t\t     ParamType *param)\n+    : generic (generic), param (param)\n+  {}\n+\n+  std::string as_string () const { return param->as_string (); }\n+\n+  void fill_param_ty (BaseType *type) { param->set_ty_ref (type->get_ref ()); }\n+\n+  SubstitionMapping clone ()\n+  {\n+    return SubstitionMapping (generic,\n+\t\t\t      static_cast<ParamType *> (param->clone ()));\n+  }\n+\n+  const ParamType *get_param_ty () const { return param; }\n+\n+private:\n+  std::unique_ptr<HIR::GenericParam> &generic;\n+  ParamType *param;\n+};\n+\n+template <class T> class SubstitionRef\n+{\n+public:\n+  SubstitionRef (std::vector<SubstitionMapping> substitions)\n+    : substitions (substitions)\n+  {}\n+\n+  bool has_substitions () const { return substitions.size () > 0; }\n+\n+  std::string subst_as_string () const\n+  {\n+    std::string buffer;\n+    for (size_t i = 0; i < substitions.size (); i++)\n+      {\n+\tconst SubstitionMapping &sub = substitions.at (i);\n+\tbuffer += sub.as_string ();\n+\n+\tif ((i + 1) < substitions.size ())\n+\t  buffer += \", \";\n+      }\n+\n+    return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n+  }\n+\n+  size_t get_num_substitions () const { return substitions.size (); }\n+\n+  std::vector<SubstitionMapping> &get_substs () { return substitions; }\n+\n+  std::vector<SubstitionMapping> clone_substs ()\n+  {\n+    std::vector<SubstitionMapping> clone;\n+    for (auto &sub : substitions)\n+      clone.push_back (sub.clone ());\n+\n+    return clone;\n+  }\n+\n+  virtual T *infer_substitions () = 0;\n+\n+  virtual T *handle_substitions (HIR::GenericArgs &generic_args) = 0;\n+\n+protected:\n+  virtual void fill_in_at (size_t index, BaseType *type)\n+  {\n+    substitions.at (index).fill_param_ty (type);\n+  }\n+\n+  SubstitionMapping get_substition_mapping_at (size_t index)\n+  {\n+    return substitions.at (index);\n+  }\n+\n+private:\n+  std::vector<SubstitionMapping> substitions;\n+};\n+\n+class ADTType : public BaseType, public SubstitionRef<ADTType>\n {\n public:\n   ADTType (HirId ref, std::string identifier,\n \t   std::vector<StructFieldType *> fields,\n+\t   std::vector<SubstitionMapping> subst_refs,\n \t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ADT, refs), identifier (identifier),\n+    : BaseType (ref, ref, TypeKind::ADT, refs),\n+      SubstitionRef (std::move (subst_refs)), identifier (identifier),\n       fields (fields)\n   {}\n \n   ADTType (HirId ref, HirId ty_ref, std::string identifier,\n \t   std::vector<StructFieldType *> fields,\n+\t   std::vector<SubstitionMapping> subst_refs,\n \t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ADT, refs), identifier (identifier),\n+    : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n+      SubstitionRef (std::move (subst_refs)), identifier (identifier),\n       fields (fields)\n   {}\n \n@@ -292,9 +422,18 @@ class ADTType : public BaseType\n \n   size_t num_fields () const { return fields.size (); }\n \n-  std::string get_name () const { return identifier; }\n+  std::string get_name () const override final\n+  {\n+    return identifier + subst_as_string ();\n+  }\n+\n+  BaseType *get_field_type (size_t index);\n+\n+  const BaseType *get_field_type (size_t index) const;\n \n-  StructFieldType *get_field (size_t index) const { return fields.at (index); }\n+  const StructFieldType *get_field (size_t index) const;\n+\n+  StructFieldType *get_field (size_t index) { return fields.at (index); }\n \n   StructFieldType *get_field (const std::string &lookup,\n \t\t\t      size_t *index = nullptr) const\n@@ -327,6 +466,21 @@ class ADTType : public BaseType\n       }\n   }\n \n+  bool supports_substitions () const override final { return true; }\n+\n+  bool has_subsititions_defined () const override final\n+  {\n+    return has_substitions ();\n+  }\n+\n+  ADTType *infer_substitions () override final;\n+\n+  ADTType *handle_substitions (HIR::GenericArgs &generic_args) override final;\n+\n+  void fill_in_at (size_t index, BaseType *type) override final;\n+\n+  void fill_in_params_for (SubstitionMapping sub, BaseType *type);\n+\n private:\n   std::string identifier;\n   std::vector<StructFieldType *> fields;\n@@ -352,6 +506,8 @@ class FnType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *return_type () { return type; }\n \n   BaseType *unify (BaseType *other) override;\n@@ -408,6 +564,8 @@ class ArrayType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   virtual bool is_equal (const BaseType &other) const override;\n@@ -440,6 +598,8 @@ class BoolType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n@@ -470,6 +630,8 @@ class IntType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   IntKind get_kind () const { return int_kind; }\n@@ -505,6 +667,8 @@ class UintType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   UintKind get_kind () const { return uint_kind; }\n@@ -538,6 +702,8 @@ class FloatType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   FloatKind get_kind () const { return float_kind; }\n@@ -563,6 +729,8 @@ class USizeType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n@@ -583,6 +751,8 @@ class ISizeType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n@@ -604,6 +774,8 @@ class CharType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   BaseType *clone () final override;\n@@ -630,6 +802,8 @@ class ReferenceType : public BaseType\n \n   std::string as_string () const override;\n \n+  std::string get_name () const override final { return as_string (); }\n+\n   BaseType *unify (BaseType *other) override;\n \n   virtual bool is_equal (const BaseType &other) const override;"}, {"sha": "8a2965ad93fe762492215bc98fa7ae2f2c0cbb39", "filename": "gcc/testsuite/rust.test/compilable/generics1.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af2ae0ff91535da104db0d3828d863770439fad/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fgenerics1.rs?ref=9af2ae0ff91535da104db0d3828d863770439fad", "patch": "@@ -0,0 +1,41 @@\n+struct Foo {\n+    a: f32,\n+    b: bool,\n+}\n+\n+struct GenericStruct<T> {\n+    a: T,\n+    b: usize,\n+}\n+\n+fn main() {\n+    let a1;\n+    a1 = Foo { a: 1.0, b: false };\n+\n+    let b1: f32 = a1.a;\n+    let c1: bool = a1.b;\n+\n+    let a2: GenericStruct<i8>;\n+    a2 = GenericStruct::<i8> { a: 1, b: 456 };\n+\n+    let b2: i8 = a2.a;\n+    let c2: usize = a2.b;\n+\n+    let a3;\n+    a3 = GenericStruct::<i32> { a: 123, b: 456 };\n+\n+    let b3: i32 = a3.a;\n+    let c3: usize = a3.b;\n+\n+    let a4;\n+    a4 = GenericStruct { a: 1.0, b: 456 };\n+\n+    let b4: f32 = a4.a;\n+    let c4: usize = a4.b;\n+\n+    let a5;\n+    a5 = GenericStruct::<_> { a: true, b: 456 };\n+\n+    let b5: bool = a5.a;\n+    let c5: usize = a5.b;\n+}"}]}