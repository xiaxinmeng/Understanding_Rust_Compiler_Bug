{"sha": "1e4b91fc4f5c6d15955594c01553462a38db97d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0YjkxZmM0ZjVjNmQxNTk1NTU5NGMwMTU1MzQ2MmEzOGRiOTdkNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:33:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-12T10:33:23Z"}, "message": "[multiple changes]\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-bytswa.adb (Swapped2.Bswap16): Remove local function,\n\tno longer needed.\n\n2012-07-12  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): For\n\tattributes 'access, 'unchecked_access and 'unrestricted_access,\n\tiff the current instance reference is located in a protected\n\tsubprogram or entry then rewrite the access attribute to be the\n\tname of the \"_object\" parameter.\n\n2012-07-12  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise.h: Revert previous patch: structure is used in init.c\n\tby vms.\n\n2012-07-12  Vincent Celier  <celier@adacore.com>\n\n\t* make.adb (Binding_Phase): If --subdirs was used, but not\n\t-P, change the working directory to the specified subdirectory\n\tbefore invoking gnatbind.\n\t(Linking_Phase): If --subdirs was used, but not -P, change the working\n\tdirectory to the specified subdirectory before invoking gnatlink.\n\n2012-07-12  Vincent Pucci  <pucci@adacore.com>\n\n\t* exp_ch9.adb (Build_Lock_Free_Unprotected_Subprogram_Body):\n\tFor a procedure, instead of replacing each Comp reference by a\n\treference to Current_Comp, make a renaming Comp of Current_Comp\n\tthat rewrites the original renaming generated by the compiler\n\tduring the analysis. Move the declarations of the procedure\n\tinside the generated block.\n\t(Process_Stmts): Moved in the body\n\tof Build_Lock_Free_Unprotected_Subprogram_Body.\n\t(Process_Node):\n\tMoved in the body of Build_Lock_Free_Unprotected_Subprogram_Body.\n\t* sem_ch9.adb (Allows_Lock_Free_Implementation): Restrict any\n\tnon-elementary out parameters in protected procedures.\n\n2012-07-12  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause, case\n\tScalar_Storage_Order): Attribute applies to base type only.\n\nFrom-SVN: r189435", "tree": {"sha": "fb8c68ef22595e504bcebbd574dc5416017bbb2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb8c68ef22595e504bcebbd574dc5416017bbb2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e4b91fc4f5c6d15955594c01553462a38db97d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4b91fc4f5c6d15955594c01553462a38db97d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4b91fc4f5c6d15955594c01553462a38db97d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4b91fc4f5c6d15955594c01553462a38db97d4/comments", "author": null, "committer": null, "parents": [{"sha": "d9819bbd70137cde670497826160c6ae964454a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9819bbd70137cde670497826160c6ae964454a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9819bbd70137cde670497826160c6ae964454a7"}], "stats": {"total": 545, "additions": 336, "deletions": 209}, "files": [{"sha": "81f63248f9656bcb715498e161d5f5c9cdbe31dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -1,3 +1,49 @@\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-bytswa.adb (Swapped2.Bswap16): Remove local function,\n+\tno longer needed.\n+\n+2012-07-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): For\n+\tattributes 'access, 'unchecked_access and 'unrestricted_access,\n+\tiff the current instance reference is located in a protected\n+\tsubprogram or entry then rewrite the access attribute to be the\n+\tname of the \"_object\" parameter.\n+\n+2012-07-12  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise.h: Revert previous patch: structure is used in init.c\n+\tby vms.\n+\n+2012-07-12  Vincent Celier  <celier@adacore.com>\n+\n+\t* make.adb (Binding_Phase): If --subdirs was used, but not\n+\t-P, change the working directory to the specified subdirectory\n+\tbefore invoking gnatbind.\n+\t(Linking_Phase): If --subdirs was used, but not -P, change the working\n+\tdirectory to the specified subdirectory before invoking gnatlink.\n+\n+2012-07-12  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* exp_ch9.adb (Build_Lock_Free_Unprotected_Subprogram_Body):\n+\tFor a procedure, instead of replacing each Comp reference by a\n+\treference to Current_Comp, make a renaming Comp of Current_Comp\n+\tthat rewrites the original renaming generated by the compiler\n+\tduring the analysis. Move the declarations of the procedure\n+\tinside the generated block.\n+\t(Process_Stmts): Moved in the body\n+\tof Build_Lock_Free_Unprotected_Subprogram_Body.\n+\t(Process_Node):\n+\tMoved in the body of Build_Lock_Free_Unprotected_Subprogram_Body.\n+\t* sem_ch9.adb (Allows_Lock_Free_Implementation): Restrict any\n+\tnon-elementary out parameters in protected procedures.\n+\n+2012-07-12  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause, case\n+\tScalar_Storage_Order): Attribute applies to base type only.\n+\n 2012-07-12  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_aggr.adb (Convert_To_Positional): Increase acceptable size"}, {"sha": "352aab1778a75706e71909c534db036102ff193c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -815,11 +815,19 @@ package body Exp_Attr is\n       --  rewrite into reference to current instance.\n \n       if Is_Protected_Self_Reference (Pref)\n-           and then not\n+        and then not\n              (Nkind_In (Parent (N), N_Index_Or_Discriminant_Constraint,\n                                     N_Discriminant_Association)\n                 and then Nkind (Parent (Parent (Parent (Parent (N))))) =\n                                                       N_Component_Definition)\n+\n+         --  No action needed for these attributes since the current instance\n+         --  will be rewritten to be the name of the _object parameter\n+         --  associated with the enclosing protected subprogram (see below).\n+\n+        and then Id /= Attribute_Access\n+        and then Id /= Attribute_Unchecked_Access\n+        and then Id /= Attribute_Unrestricted_Access\n       then\n          Rewrite (Pref, Concurrent_Ref (Pref));\n          Analyze (Pref);\n@@ -1028,10 +1036,36 @@ package body Exp_Attr is\n                          New_Occurrence_Of (Formal, Loc)));\n                      Set_Etype (N, Typ);\n \n-                     --  The expression must appear in a default expression,\n-                     --  (which in the initialization procedure is the\n-                     --  right-hand side of an assignment), and not in a\n-                     --  discriminant constraint.\n+                  elsif Is_Protected_Type (Entity (Pref)) then\n+\n+                     --  No action needed for current instance located in a\n+                     --  component definition (expansion will occur in the\n+                     --  init proc)\n+\n+                     if Is_Protected_Type (Current_Scope) then\n+                        null;\n+\n+                     --  If the current instance reference is located in a\n+                     --  protected subprogram or entry then rewrite the access\n+                     --  attribute to be the name of the \"_object\" parameter.\n+                     --  An unchecked conversion is applied to ensure a type\n+                     --  match in cases of expander-generated calls (e.g. init\n+                     --  procs).\n+\n+                     else\n+                        Formal :=\n+                          First_Entity\n+                            (Protected_Body_Subprogram (Current_Scope));\n+                        Rewrite (N,\n+                          Unchecked_Convert_To (Typ,\n+                            New_Occurrence_Of (Formal, Loc)));\n+                        Set_Etype (N, Typ);\n+                     end if;\n+\n+                  --  The expression must appear in a default expression,\n+                  --  (which in the initialization procedure is the right-hand\n+                  --  side of an assignment), and not in a discriminant\n+                  --  constraint.\n \n                   else\n                      Par := Parent (N);"}, {"sha": "bf1cbc48f23206c0d6184b2497a9934aabafc142", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 204, "deletions": 183, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -2955,26 +2955,30 @@ package body Exp_Ch9 is\n    --  manner:\n \n    --    procedure P (...) is\n-   --       <original declarations>\n    --    begin\n    --       loop\n    --          declare\n+   --             <original declarations before the object renaming declaration\n+   --              of Comp>\n    --             Saved_Comp   : constant ... :=\n-   --                              Atomic_Load (Comp'Address, Relaxed);\n+   --                              Atomic_Load (_Object.Comp'Address, Relaxed);\n    --             Current_Comp : ... := Saved_Comp;\n+   --             Comp         : Comp_Type renames Current_Comp;\n+   --             <original delarations after the object renaming declaration\n+   --              of Comp>\n    --          begin\n    --             <original statements>\n-   --             exit when Atomic_Compare (Comp, Saved_Comp, Current_Comp);\n+   --             exit when Atomic_Compare\n+   --                         (_Object.Comp, Saved_Comp, Current_Comp);\n    --          end;\n    --          <<L0>>\n    --       end loop;\n    --    end P;\n \n-   --  References to Comp which appear in the original statements are replaced\n-   --  with references to Current_Comp. Each return and raise statement of P is\n-   --  transformed into an atomic status check:\n+   --  Each return and raise statement of P is transformed into an atomic\n+   --  status check:\n \n-   --    if Atomic_Compare (Comp, Saved_Comp, Current_Comp) then\n+   --    if Atomic_Compare (_Object.Comp, Saved_Comp, Current_Comp) then\n    --       <original statement>\n    --    else\n    --       goto L0;\n@@ -2985,15 +2989,16 @@ package body Exp_Ch9 is\n    --  manner:\n \n    --    function F (...) return ... is\n-   --       <original declarations>\n-   --       Saved_Comp : constant ... := Atomic_Load (Comp'Address);\n+   --       <original declarations before the object renaming declaration\n+   --        of Comp>\n+   --       Saved_Comp : constant ... := Atomic_Load (_Object.Comp'Address);\n+   --       Comp       : Comp_Type renames Saved_Comp;\n+   --       <original delarations after the object renaming declaration of\n+   --        Comp>\n    --    begin\n    --       <original statements>\n    --    end F;\n \n-   --  References to Comp which appear in the original statements are replaced\n-   --  with references to Saved_Comp.\n-\n    function Build_Lock_Free_Unprotected_Subprogram_Body\n      (N        : Node_Id;\n       Prot_Typ : Node_Id) return Node_Id\n@@ -3003,162 +3008,11 @@ package body Exp_Ch9 is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Label_Id     : Entity_Id := Empty;\n \n-      procedure Process_Stmts\n-        (Stmts        : List_Id;\n-         Compare      : Entity_Id;\n-         Unsigned     : Entity_Id;\n-         Comp         : Entity_Id;\n-         Saved_Comp   : Entity_Id;\n-         Current_Comp : Entity_Id);\n-      --  Given a statement sequence Stmts, wrap any return or raise statements\n-      --  in the following manner:\n-      --\n-      --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n-      --         (Comp'Address,\n-      --          Interfaces.Unsigned (Saved_Comp),\n-      --          Interfaces.Unsigned (Current_Comp))\n-      --    then\n-      --       <Stmt>;\n-      --    else\n-      --       goto L0;\n-      --    end if;\n-      --\n-      --  Replace all references to Comp with a reference to Current_Comp.\n-\n       function Referenced_Component (N : Node_Id) return Entity_Id;\n       --  Subprograms which meet the lock-free implementation criteria are\n       --  allowed to reference only one unique component. Return the prival\n       --  of the said component.\n \n-      -------------------\n-      -- Process_Stmts --\n-      -------------------\n-\n-      procedure Process_Stmts\n-        (Stmts        : List_Id;\n-         Compare      : Entity_Id;\n-         Unsigned     : Entity_Id;\n-         Comp         : Entity_Id;\n-         Saved_Comp   : Entity_Id;\n-         Current_Comp : Entity_Id)\n-      is\n-         function Process_Node (N : Node_Id) return Traverse_Result;\n-         --  Transform a single node if it is a return statement, a raise\n-         --  statement or a reference to Comp.\n-\n-         ------------------\n-         -- Process_Node --\n-         ------------------\n-\n-         function Process_Node (N : Node_Id) return Traverse_Result is\n-\n-            procedure Wrap_Statement (Stmt : Node_Id);\n-            --  Wrap an arbitrary statement inside an if statement where the\n-            --  condition does an atomic check on the state of the object.\n-\n-            --------------------\n-            -- Wrap_Statement --\n-            --------------------\n-\n-            procedure Wrap_Statement (Stmt : Node_Id) is\n-            begin\n-               --  The first time through, create the declaration of a label\n-               --  which is used to skip the remainder of source statements if\n-               --  the state of the object has changed.\n-\n-               if No (Label_Id) then\n-                  Label_Id :=\n-                    Make_Identifier (Loc, New_External_Name ('L', 0));\n-                  Set_Entity (Label_Id,\n-                    Make_Defining_Identifier (Loc, Chars (Label_Id)));\n-               end if;\n-\n-               --  Generate:\n-\n-               --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n-               --         (Comp'Address,\n-               --          Interfaces.Unsigned (Saved_Comp),\n-               --          Interfaces.Unsigned (Current_Comp))\n-               --    then\n-               --       <Stmt>;\n-               --    else\n-               --       goto L0;\n-               --    end if;\n-\n-               Rewrite (Stmt,\n-                 Make_If_Statement (Loc,\n-                   Condition =>\n-                     Make_Function_Call (Loc,\n-                       Name                   =>\n-                         New_Reference_To (Compare, Loc),\n-                       Parameter_Associations => New_List (\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix         => New_Reference_To (Comp, Loc),\n-                           Attribute_Name => Name_Address),\n-\n-                         Unchecked_Convert_To (Unsigned,\n-                           New_Reference_To (Saved_Comp, Loc)),\n-\n-                         Unchecked_Convert_To (Unsigned,\n-                           New_Reference_To (Current_Comp, Loc)))),\n-\n-                   Then_Statements => New_List (Relocate_Node (Stmt)),\n-\n-                   Else_Statements => New_List (\n-                     Make_Goto_Statement (Loc,\n-                       Name => New_Reference_To (Entity (Label_Id), Loc)))));\n-            end Wrap_Statement;\n-\n-         --  Start of processing for Process_Node\n-\n-         begin\n-            --  Wrap each return and raise statement that appear inside a\n-            --  procedure. Skip the last return statement which is added by\n-            --  default since it is transformed into an exit statement.\n-\n-            if Is_Procedure\n-              and then Nkind_In (N, N_Simple_Return_Statement,\n-                                    N_Extended_Return_Statement,\n-                                    N_Raise_Statement)\n-              and then Nkind (Last (Stmts)) /= N_Simple_Return_Statement\n-            then\n-               Wrap_Statement (N);\n-               return Skip;\n-\n-            --  Replace all references to the original component by a reference\n-            --  to the current state of the component.\n-\n-            elsif Nkind (N) = N_Identifier\n-              and then Present (Entity (N))\n-              and then Entity (N) = Comp\n-            then\n-               Rewrite (N, Make_Identifier (Loc, Chars (Current_Comp)));\n-               return Skip;\n-            end if;\n-\n-            --  Force reanalysis\n-\n-            Set_Analyzed (N, False);\n-\n-            return OK;\n-         end Process_Node;\n-\n-         procedure Process_Nodes is new Traverse_Proc (Process_Node);\n-\n-         --  Local variables\n-\n-         Stmt : Node_Id;\n-\n-      --  Start of processing for Process_Stmts\n-\n-      begin\n-         Stmt := First (Stmts);\n-         while Present (Stmt) loop\n-            Process_Nodes (Stmt);\n-            Next (Stmt);\n-         end loop;\n-      end Process_Stmts;\n-\n       --------------------------\n       -- Referenced_Component --\n       --------------------------\n@@ -3214,20 +3068,25 @@ package body Exp_Ch9 is\n \n       --  Local variables\n \n-      Comp  : constant Entity_Id := Referenced_Component (N);\n-      Decls : constant List_Id   := Declarations (N);\n-      Stmts : List_Id;\n+      Comp          : constant Entity_Id := Referenced_Component (N);\n+      Hand_Stmt_Seq : Node_Id            := Handled_Statement_Sequence (N);\n+      Decls         : List_Id            := Declarations (N);\n \n    --  Start of processing for Build_Lock_Free_Unprotected_Subprogram_Body\n \n    begin\n-      Stmts := New_Copy_List (Statements (Handled_Statement_Sequence (N)));\n+      --  Add renamings for the protection object, discriminals, privals and\n+      --  the entry index constant for use by debugger.\n+\n+      Debug_Private_Data_Declarations (Decls);\n \n       --  Perform the lock-free expansion when the subprogram references a\n       --  protected component.\n \n       if Present (Comp) then\n          declare\n+            Comp_Decl    : constant Node_Id   := Parent (Comp);\n+            Comp_Sel_Nam : constant Node_Id   := Name (Comp_Decl);\n             Comp_Type    : constant Entity_Id := Etype (Comp);\n             Block_Decls  : List_Id;\n             Compare      : Entity_Id;\n@@ -3238,9 +3097,138 @@ package body Exp_Ch9 is\n             Load_Params  : List_Id;\n             Saved_Comp   : Entity_Id;\n             Stmt         : Node_Id;\n+            Stmts        : List_Id :=\n+                             New_Copy_List (Statements (Hand_Stmt_Seq));\n             Typ_Size     : Int;\n             Unsigned     : Entity_Id;\n \n+            function Process_Node (N : Node_Id) return Traverse_Result;\n+            --  Transform a single node if it is a return statement, a raise\n+            --  statement or a reference to Comp.\n+\n+            procedure Process_Stmts (Stmts : List_Id);\n+            --  Given a statement sequence Stmts, wrap any return or raise\n+            --  statements in the following manner:\n+            --\n+            --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n+            --         (Comp'Address,\n+            --          Interfaces.Unsigned (Saved_Comp),\n+            --          Interfaces.Unsigned (Current_Comp))\n+            --    then\n+            --       <Stmt>;\n+            --    else\n+            --       goto L0;\n+            --    end if;\n+\n+            ------------------\n+            -- Process_Node --\n+            ------------------\n+\n+            function Process_Node (N : Node_Id) return Traverse_Result is\n+\n+               procedure Wrap_Statement (Stmt : Node_Id);\n+               --  Wrap an arbitrary statement inside an if statement where the\n+               --  condition does an atomic check on the state of the object.\n+\n+               --------------------\n+               -- Wrap_Statement --\n+               --------------------\n+\n+               procedure Wrap_Statement (Stmt : Node_Id) is\n+               begin\n+                  --  The first time through, create the declaration of a label\n+                  --  which is used to skip the remainder of source statements\n+                  --  if the state of the object has changed.\n+\n+                  if No (Label_Id) then\n+                     Label_Id :=\n+                       Make_Identifier (Loc, New_External_Name ('L', 0));\n+                     Set_Entity (Label_Id,\n+                       Make_Defining_Identifier (Loc, Chars (Label_Id)));\n+                  end if;\n+\n+                  --  Generate:\n+\n+                  --    if System.Atomic_Primitives.Atomic_Compare_Exchange\n+                  --         (Comp'Address,\n+                  --          Interfaces.Unsigned (Saved_Comp),\n+                  --          Interfaces.Unsigned (Current_Comp))\n+                  --    then\n+                  --       <Stmt>;\n+                  --    else\n+                  --       goto L0;\n+                  --    end if;\n+\n+                  Rewrite (Stmt,\n+                    Make_If_Statement (Loc,\n+                      Condition =>\n+                        Make_Function_Call (Loc,\n+                          Name                   =>\n+                            New_Reference_To (Compare, Loc),\n+                          Parameter_Associations => New_List (\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         => Relocate_Node (Comp_Sel_Nam),\n+                              Attribute_Name => Name_Address),\n+\n+                            Unchecked_Convert_To (Unsigned,\n+                              New_Reference_To (Saved_Comp, Loc)),\n+\n+                            Unchecked_Convert_To (Unsigned,\n+                              New_Reference_To (Current_Comp, Loc)))),\n+\n+                      Then_Statements => New_List (Relocate_Node (Stmt)),\n+\n+                      Else_Statements => New_List (\n+                        Make_Goto_Statement (Loc,\n+                          Name =>\n+                            New_Reference_To (Entity (Label_Id), Loc)))));\n+               end Wrap_Statement;\n+\n+            --  Start of processing for Process_Node\n+\n+            begin\n+               --  Wrap each return and raise statement that appear inside a\n+               --  procedure. Skip the last return statement which is added by\n+               --  default since it is transformed into an exit statement.\n+\n+               if Is_Procedure\n+                 and then ((Nkind (N) = N_Simple_Return_Statement\n+                             and then N /= Last (Stmts))\n+                            or else Nkind (N) = N_Extended_Return_Statement\n+                            or else (Nkind_In (N, N_Raise_Constraint_Error,\n+                                                  N_Raise_Program_Error,\n+                                                  N_Raise_Statement,\n+                                                  N_Raise_Storage_Error)\n+                                      and then Comes_From_Source (N)))\n+               then\n+                  Wrap_Statement (N);\n+                  return Skip;\n+               end if;\n+\n+               --  Force reanalysis\n+\n+               Set_Analyzed (N, False);\n+\n+               return OK;\n+            end Process_Node;\n+\n+            procedure Process_Nodes is new Traverse_Proc (Process_Node);\n+\n+            -------------------\n+            -- Process_Stmts --\n+            -------------------\n+\n+            procedure Process_Stmts (Stmts : List_Id) is\n+               Stmt : Node_Id;\n+\n+            begin\n+               Stmt := First (Stmts);\n+               while Present (Stmt) loop\n+                  Process_Nodes (Stmt);\n+                  Next (Stmt);\n+               end loop;\n+            end Process_Stmts;\n+\n          begin\n             --  Get the type size\n \n@@ -3305,7 +3293,7 @@ package body Exp_Ch9 is\n \n             Load_Params := New_List (\n               Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (Comp, Loc),\n+                Prefix         => Relocate_Node (Comp_Sel_Nam),\n                 Attribute_Name => Name_Address));\n \n             --  For protected procedures, set the memory model to be relaxed\n@@ -3329,7 +3317,14 @@ package body Exp_Ch9 is\n             --  Protected procedures\n \n             if Is_Procedure then\n-               Block_Decls := New_List (Decl);\n+               --  Move the original declarations inside the generated block\n+\n+               Block_Decls := Decls;\n+\n+               --  Reset the declarations list of the protected procedure to be\n+               --  an empty list.\n+\n+               Decls := Empty_List;\n \n                --  Generate:\n                --    Current_Comp : Comp_Type := Saved_Comp;\n@@ -3338,21 +3333,50 @@ package body Exp_Ch9 is\n                  Make_Defining_Identifier (Loc,\n                    New_External_Name (Chars (Comp), Suffix => \"_current\"));\n \n-               Append_To (Block_Decls,\n+               --  Insert the declarations of Saved_Comp and Current_Comp in\n+               --  the block declarations right before the renaming of the\n+               --  protected component.\n+\n+               Insert_Before (Comp_Decl, Decl);\n+\n+               Insert_Before (Comp_Decl,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Current_Comp,\n                    Object_Definition   => New_Reference_To (Comp_Type, Loc),\n-                   Expression          => New_Reference_To (Saved_Comp, Loc)));\n+                   Expression          =>\n+                     New_Reference_To (Saved_Comp, Loc)));\n \n             --  Protected function\n \n             else\n-               Append_To (Decls, Decl);\n                Current_Comp := Saved_Comp;\n+\n+               --  Insert the declaration of Saved_Comp in the function\n+               --  declarations right before the renaming of the protected\n+               --  component.\n+\n+               Insert_Before (Comp_Decl, Decl);\n             end if;\n \n-            Process_Stmts\n-              (Stmts, Compare, Unsigned, Comp, Saved_Comp, Current_Comp);\n+            --  Rewrite the protected component renaming declaration to be a\n+            --  renaming of Current_Comp.\n+\n+            --  Generate:\n+            --    Comp : Comp_Type renames Current_Comp;\n+\n+            Rewrite (Comp_Decl,\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Defining_Identifier (Comp_Decl),\n+                Subtype_Mark      =>\n+                  New_Occurrence_Of (Comp_Type, Loc),\n+                Name              =>\n+                  New_Reference_To (Current_Comp, Loc)));\n+\n+            --  Wrap any return or raise statements in Stmts in same the manner\n+            --  described in Process_Stmts.\n+\n+            Process_Stmts (Stmts);\n \n             --  Generate:\n \n@@ -3370,7 +3394,7 @@ package body Exp_Ch9 is\n                          New_Reference_To (Compare, Loc),\n                        Parameter_Associations => New_List (\n                          Make_Attribute_Reference (Loc,\n-                           Prefix         => New_Reference_To (Comp, Loc),\n+                           Prefix         => Relocate_Node (Comp_Sel_Nam),\n                            Attribute_Name => Name_Address),\n \n                          Unchecked_Convert_To (Unsigned,\n@@ -3413,7 +3437,7 @@ package body Exp_Ch9 is\n \n             if Is_Procedure then\n                Stmts := New_List (\n-                Make_Procedure_Call_Statement (Loc,\n+                 Make_Procedure_Call_Statement (Loc,\n                     Name =>\n                       New_Reference_To (RTE (RE_Atomic_Synchronize), Loc)),\n                  Make_Loop_Statement (Loc,\n@@ -3425,14 +3449,12 @@ package body Exp_Ch9 is\n                            Statements => Stmts))),\n                    End_Label  => Empty));\n             end if;\n+\n+            Hand_Stmt_Seq :=\n+              Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts);\n          end;\n       end if;\n \n-      --  Add renamings for the protection object, discriminals, privals and\n-      --  the entry index constant for use by debugger.\n-\n-      Debug_Private_Data_Declarations (Decls);\n-\n       --  Make an unprotected version of the subprogram for use within the same\n       --  object, with new name and extra parameter representing the object.\n \n@@ -3441,8 +3463,7 @@ package body Exp_Ch9 is\n           Specification              =>\n             Build_Protected_Sub_Specification (N, Prot_Typ, Unprotected_Mode),\n           Declarations               => Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts));\n+          Handled_Statement_Sequence => Hand_Stmt_Seq);\n    end Build_Lock_Free_Unprotected_Subprogram_Body;\n \n    -------------------------"}, {"sha": "0eed65d90fd24aa4d61ad2e91c43960ad825b0ba", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -4435,6 +4435,13 @@ package body Make is\n          declare\n             Success : Boolean := False;\n          begin\n+            --  If gnatmake was invoked with --subdirs and no project file,\n+            --  put the executable in the subdirectory specified.\n+\n+            if Prj.Subdirs /= null and then Main_Project = No_Project then\n+               Change_Dir (Object_Directory_Path.all);\n+            end if;\n+\n             Link (Main_ALI_File,\n                   Link_With_Shared_Libgcc.all &\n                   Args (Args'First .. Last_Arg),\n@@ -4571,6 +4578,13 @@ package body Make is\n          end if;\n       end if;\n \n+      --  If gnatmake was invoked with --subdirs and no project file, put the\n+      --  binder generated files in the subdirectory specified.\n+\n+      if Main_Project = No_Project and then Prj.Subdirs /= null then\n+         Change_Dir (Object_Directory_Path.all);\n+      end if;\n+\n       begin\n          Bind (Main_ALI_File,\n                Bind_Shared.all & Args (Args'First .. Last_Arg));"}, {"sha": "7fb18597ec68051383e8cc6e27eb20790afdfcbb", "filename": "gcc/ada/raise.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fraise.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fraise.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.h?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -37,7 +37,16 @@ extern \"C\" {\n \n typedef unsigned Exception_Code;\n \n-struct Exception_Data;\n+struct Exception_Data\n+{\n+  char Not_Handled_By_Others;\n+  char Lang;\n+  int Name_Length;\n+  char *Full_Name, *Htable_Ptr;\n+  Exception_Code Import_Code;\n+  void (*Raise_Hook)(void);\n+};\n+\n typedef struct Exception_Data *Exception_Id;\n \n extern void _gnat_builtin_longjmp\t(void *, int);"}, {"sha": "e029980c0bcc8fa4d4c05f78ca03d54d3be4f358", "filename": "gcc/ada/s-bytswa.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fs-bytswa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fs-bytswa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bytswa.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -56,9 +56,6 @@ package body System.Byte_Swapping is\n    function Swapped2 (Input : Item) return Item is\n       function As_U16 is new Unchecked_Conversion (Item, U16);\n       function As_Item is new Unchecked_Conversion (U16, Item);\n-\n-      function Bswap_16 (X : U16) return U16 is (X / 256 or X * 256);\n-      --  ??? Need to have function local here to allow inlining\n       pragma Compile_Time_Error (Item'Max_Size_In_Storage_Elements /= 2,\n         \"storage size must be 2 bytes\");\n    begin"}, {"sha": "58d649214f3eece430924d9f202352cac7facd30", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -3332,7 +3332,7 @@ package body Sem_Ch13 is\n \n                else\n                   if (Expr_Value (Expr) = 0) /= Bytes_Big_Endian then\n-                     Set_Reverse_Storage_Order (U_Ent, True);\n+                     Set_Reverse_Storage_Order (Base_Type (U_Ent), True);\n                   end if;\n                end if;\n             end if;"}, {"sha": "e6eba7453700019ea6574014d1efd9e2585b7132", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4b91fc4f5c6d15955594c01553462a38db97d4/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=1e4b91fc4f5c6d15955594c01553462a38db97d4", "patch": "@@ -170,24 +170,30 @@ package body Sem_Ch9 is\n                      Par_Specs : constant List_Id   :=\n                                    Parameter_Specifications\n                                      (Specification (Decl));\n-                     Par       : constant Node_Id   := First (Par_Specs);\n-                     Par_Typ   : constant Entity_Id :=\n-                                   Etype (Parameter_Type (Par));\n+\n+                     Par : Node_Id;\n \n                   begin\n-                     if Out_Present (Par)\n-                       and then not Is_Elementary_Type (Par_Typ)\n-                     then\n-                        if Complain then\n-                           Error_Msg_NE\n-                             (\"non-elementary out parameter& not allowed \" &\n-                              \"when Lock_Free given\",\n-                              Par,\n-                              Defining_Identifier (Par));\n+                     Par := First (Par_Specs);\n+\n+                     while Present (Par) loop\n+                        if Out_Present (Par)\n+                          and then not Is_Elementary_Type\n+                                         (Etype (Parameter_Type (Par)))\n+                        then\n+                           if Complain then\n+                              Error_Msg_NE\n+                                (\"non-elementary out parameter& not allowed \" &\n+                                 \"when Lock_Free given\",\n+                                 Par,\n+                                 Defining_Identifier (Par));\n+                           end if;\n+\n+                           return False;\n                         end if;\n \n-                        return False;\n-                     end if;\n+                        Next (Par);\n+                     end loop;\n                   end;\n                end if;\n \n@@ -451,9 +457,9 @@ package body Sem_Ch9 is\n                               --  already been accessed by the subprogram body.\n \n                               if No (Comp) then\n-                                 Comp := Id;\n+                                 Comp := Comp_Id;\n \n-                              elsif Comp /= Id then\n+                              elsif Comp /= Comp_Id then\n                                  if Complain then\n                                     Error_Msg_N\n                                       (\"only one protected component allowed\","}]}