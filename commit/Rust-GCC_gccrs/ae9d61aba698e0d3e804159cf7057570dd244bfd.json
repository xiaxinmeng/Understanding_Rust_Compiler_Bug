{"sha": "ae9d61aba698e0d3e804159cf7057570dd244bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5ZDYxYWJhNjk4ZTBkM2U4MDQxNTljZjcwNTc1NzBkZDI0NGJmZA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2011-10-29T18:58:48Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2011-10-29T18:58:48Z"}, "message": "re PR target/50617 (ICE: RTL flag check: INSN_ANNULLED_BRANCH_P used with unexpected rtx code 'simplify_immed_subreg' in output_bb, at config/pa/pa.c:6631)\n\n\tPR target/50617\n\t* config/pa/protos.h (attr_length_save_restore_dltp): Delete.\n\t(cmpib_comparison_operator): Likewise.\n\t(following_cal, output_and, output_ior, output_move_double,\n\toutput_fp_move_double, output_block_move, output_block_clear,\n\toutput_cbranch, output_lbranch, output_bb, output_bvb, output_dbra,\n\toutput_movb, output_parallel_movb, output_parallel_addb, output_call,\n\toutput_indirect_call, output_millicode_call, output_mul_insn,\n\toutput_div_insn, output_mod_insn, singlemove_string,\n\toutput_arg_descriptor, output_global_address, print_operand,\n\tlegitimize_pic_address, hppa_encode_label, symbolic_expression_p,\n\tfmpyaddoperands, fmpysuboperands, emit_bcond_fp, emit_move_sequence,\n\temit_hpdiv_const, is_function_label_plus_const, jump_in_call_delay,\n\thppa_fpstore_bypass_p, attr_length_millicode_call, attr_length_call,\n\tattr_length_indirect_call, return_addr_rtx, function_arg_padding,\n\tinsn_refs_are_delayed, get_deferred_plabel, ldil_cint_p, zdepi_cint_p,\n\toutput_ascii, compute_frame_size, and_mask_p, cint_ok_for_move,\n\thppa_expand_prologue, hppa_expand_epilogue, ior_mask_p,\n\tcompute_zdepdi_operands, output_64bit_and, output_64bit_ior,\n\treloc_needed, magic_milli, shadd_constant_p): Consistently prefix\n\texported functions and variables with \"pa_\".\n\t* config/pa/predicates.md: Likewise.\n\t* config/pa/pa64-hpux.h: likewise.\n\t* config/pa/som.h: Likewise.\n\t* config/pa/elf.h: Likewise.\n\t* config/pa/pa64-linux.h: Likewise.\n\t* config/pa/pa.md: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/pa/pa-linux.h: Likewise.\n\t* config/pa/pa.h: Likewise.\n\t* config/pa/constraints.md: Likewise.\n\nFrom-SVN: r180660", "tree": {"sha": "89499821369942b54a8dad376e9075f28a1c9821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89499821369942b54a8dad376e9075f28a1c9821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9d61aba698e0d3e804159cf7057570dd244bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9d61aba698e0d3e804159cf7057570dd244bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9d61aba698e0d3e804159cf7057570dd244bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9d61aba698e0d3e804159cf7057570dd244bfd/comments", "author": null, "committer": null, "parents": [{"sha": "b99f906a4e106ff22f5637f8eb46558b7816b078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99f906a4e106ff22f5637f8eb46558b7816b078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99f906a4e106ff22f5637f8eb46558b7816b078"}], "stats": {"total": 854, "additions": 435, "deletions": 419}, "files": [{"sha": "82600547312fe3db44677e38d8442910362f91bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -1,3 +1,37 @@\n+2011-10-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/50617\n+\t* config/pa/protos.h (attr_length_save_restore_dltp): Delete.\n+\t(cmpib_comparison_operator): Likewise.\n+\t(following_cal, output_and, output_ior, output_move_double,\n+\toutput_fp_move_double, output_block_move, output_block_clear,\n+\toutput_cbranch, output_lbranch, output_bb, output_bvb, output_dbra,\n+\toutput_movb, output_parallel_movb, output_parallel_addb, output_call,\n+\toutput_indirect_call, output_millicode_call, output_mul_insn,\n+\toutput_div_insn, output_mod_insn, singlemove_string,\n+\toutput_arg_descriptor, output_global_address, print_operand,\n+\tlegitimize_pic_address, hppa_encode_label, symbolic_expression_p,\n+\tfmpyaddoperands, fmpysuboperands, emit_bcond_fp, emit_move_sequence,\n+\temit_hpdiv_const, is_function_label_plus_const, jump_in_call_delay,\n+\thppa_fpstore_bypass_p, attr_length_millicode_call, attr_length_call,\n+\tattr_length_indirect_call, return_addr_rtx, function_arg_padding,\n+\tinsn_refs_are_delayed, get_deferred_plabel, ldil_cint_p, zdepi_cint_p,\n+\toutput_ascii, compute_frame_size, and_mask_p, cint_ok_for_move,\n+\thppa_expand_prologue, hppa_expand_epilogue, ior_mask_p,\n+\tcompute_zdepdi_operands, output_64bit_and, output_64bit_ior,\n+\treloc_needed, magic_milli, shadd_constant_p): Consistently prefix\n+\texported functions and variables with \"pa_\".\n+\t* config/pa/predicates.md: Likewise.\n+\t* config/pa/pa64-hpux.h: likewise.\n+\t* config/pa/som.h: Likewise.\n+\t* config/pa/elf.h: Likewise.\n+\t* config/pa/pa64-linux.h: Likewise.\n+\t* config/pa/pa.md: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/pa/pa-linux.h: Likewise.\n+\t* config/pa/pa.h: Likewise.\n+\t* config/pa/constraints.md: Likewise.\n+\n 2011-10-29  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (xop_sha<mode>3): Rename from xop_ashl<mode>3."}, {"sha": "ce5a5f7306aad29e1204876f754c0b14d075c436", "filename": "gcc/config/pa/constraints.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fconstraints.md?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -55,7 +55,7 @@\n (define_constraint \"K\"\n   \"Integer constant that can be deposited with a zdepi instruction.\"\n   (and (match_code \"const_int\")\n-       (match_test \"zdepi_cint_p (ival)\")))\n+       (match_test \"pa_zdepi_cint_p (ival)\")))\n \n (define_constraint \"L\"\n   \"Signed 5-bit integer constant.\"\n@@ -70,7 +70,7 @@\n (define_constraint \"N\"\n   \"Integer constant that can be loaded with a ldil instruction.\"\n   (and (match_code \"const_int\")\n-       (match_test \"ldil_cint_p (ival)\")))\n+       (match_test \"pa_ldil_cint_p (ival)\")))\n \n (define_constraint \"O\"\n   \"Integer constant such that ival+1 is a power of 2.\"\n@@ -81,7 +81,7 @@\n   \"Integer constant that can be used as an and mask in depi and\n    extru instructions.\"\n   (and (match_code \"const_int\")\n-       (match_test \"and_mask_p (ival)\")))\n+       (match_test \"pa_and_mask_p (ival)\")))\n \n (define_constraint \"S\"\n   \"Integer constant 31.\""}, {"sha": "dc436a3fe960762f3ae55b0f26d9c798e385579a", "filename": "gcc/config/pa/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Felf.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -80,7 +80,7 @@ do {  \\\n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, RTL) \\\n   do { fputs (\"\\t.IMPORT \", FILE);\t\t\t\t\t\\\n        if (!function_label_operand (RTL, VOIDmode))\t\t\t\\\n-\t hppa_encode_label (RTL);\t\t\t\t\t\\\n+\t pa_encode_label (RTL);\t\t\t\t\t\t\\\n        assemble_name (FILE, XSTR ((RTL), 0));\t\t       \t\t\\\n        fputs (\",ENTRY\\n\", FILE);\t\t\t\t\t\\\n      } while (0)"}, {"sha": "6c6cf210aa4dd719388b44668c44ce184bf1040f", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -128,7 +128,7 @@ along with GCC; see the file COPYING3.  If not see\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       if (!FUNCTION_NAME_P (XSTR (FUN, 0)))\t\t\t\\\n-\thppa_encode_label (FUN);\t\t\t\t\\\n+\tpa_encode_label (FUN);\t\t\t\t\t\\\n       (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0));\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)"}, {"sha": "d28ee3cb862abbfb7b619676e9005e8608799371", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 57, "deletions": 65, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -24,89 +24,82 @@ along with GCC; see the file COPYING3.  If not see\n extern rtx pa_eh_return_handler_rtx (void);\n \n /* Used in insn-*.c.  */\n-extern int following_call (rtx);\n+extern int pa_following_call (rtx);\n \n /* Define functions in pa.c and used in insn-output.c.  */\n \n-extern const char *output_and (rtx *);\n-extern const char *output_ior (rtx *);\n-extern const char *output_move_double (rtx *);\n-extern const char *output_fp_move_double (rtx *);\n-extern const char *output_block_move (rtx *, int);\n-extern const char *output_block_clear (rtx *, int);\n-extern const char *output_cbranch (rtx *, int, rtx);\n-extern const char *output_lbranch (rtx, rtx, int);\n-extern const char *output_bb (rtx *, int, rtx, int);\n-extern const char *output_bvb (rtx *, int, rtx, int);\n-extern const char *output_dbra (rtx *, rtx, int);\n-extern const char *output_movb (rtx *, rtx, int, int);\n-extern const char *output_parallel_movb (rtx *, rtx);\n-extern const char *output_parallel_addb (rtx *, rtx);\n-extern const char *output_call (rtx, rtx, int);\n-extern const char *output_indirect_call (rtx, rtx);\n-extern const char *output_millicode_call (rtx, rtx);\n-extern const char *output_mul_insn (int, rtx);\n-extern const char *output_div_insn (rtx *, int, rtx);\n-extern const char *output_mod_insn (int, rtx);\n-extern const char *singlemove_string (rtx *);\n-extern void output_arg_descriptor (rtx);\n-extern void output_global_address (FILE *, rtx, int);\n-extern void print_operand (FILE *, rtx, int);\n-extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n-extern void hppa_encode_label (rtx);\n-extern int symbolic_expression_p (rtx);\n+extern const char *pa_output_and (rtx *);\n+extern const char *pa_output_64bit_and (rtx *);\n+extern const char *pa_output_ior (rtx *);\n+extern const char *pa_output_64bit_ior (rtx *);\n+extern const char *pa_output_move_double (rtx *);\n+extern const char *pa_output_fp_move_double (rtx *);\n+extern const char *pa_output_block_move (rtx *, int);\n+extern const char *pa_output_block_clear (rtx *, int);\n+extern const char *pa_output_cbranch (rtx *, int, rtx);\n+extern const char *pa_output_lbranch (rtx, rtx, int);\n+extern const char *pa_output_bb (rtx *, int, rtx, int);\n+extern const char *pa_output_bvb (rtx *, int, rtx, int);\n+extern const char *pa_output_dbra (rtx *, rtx, int);\n+extern const char *pa_output_movb (rtx *, rtx, int, int);\n+extern const char *pa_output_parallel_movb (rtx *, rtx);\n+extern const char *pa_output_parallel_addb (rtx *, rtx);\n+extern const char *pa_output_call (rtx, rtx, int);\n+extern const char *pa_output_indirect_call (rtx, rtx);\n+extern const char *pa_output_millicode_call (rtx, rtx);\n+extern const char *pa_output_mul_insn (int, rtx);\n+extern const char *pa_output_div_insn (rtx *, int, rtx);\n+extern const char *pa_output_mod_insn (int, rtx);\n+extern const char *pa_singlemove_string (rtx *);\n+extern void pa_output_arg_descriptor (rtx);\n+extern void pa_output_global_address (FILE *, rtx, int);\n+extern void pa_print_operand (FILE *, rtx, int);\n+extern void pa_encode_label (rtx);\n+extern int pa_symbolic_expression_p (rtx);\n extern bool pa_tls_referenced_p (rtx);\n extern int pa_adjust_insn_length (rtx, int);\n-extern int fmpyaddoperands (rtx *);\n-extern int fmpysuboperands (rtx *);\n-extern void emit_bcond_fp (rtx[]);\n-extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n-extern int emit_hpdiv_const (rtx *, int);\n-extern int is_function_label_plus_const (rtx);\n-extern int jump_in_call_delay (rtx);\n-extern int hppa_fpstore_bypass_p (rtx, rtx);\n-extern int attr_length_millicode_call (rtx);\n-extern int attr_length_call (rtx, int);\n-extern int attr_length_indirect_call (rtx);\n-extern int attr_length_save_restore_dltp (rtx);\n+extern int pa_fmpyaddoperands (rtx *);\n+extern int pa_fmpysuboperands (rtx *);\n+extern void pa_emit_bcond_fp (rtx[]);\n+extern int pa_emit_move_sequence (rtx *, enum machine_mode, rtx);\n+extern int pa_emit_hpdiv_const (rtx *, int);\n+extern int pa_is_function_label_plus_const (rtx);\n+extern int pa_jump_in_call_delay (rtx);\n+extern int pa_fpstore_bypass_p (rtx, rtx);\n+extern int pa_attr_length_millicode_call (rtx);\n+extern int pa_attr_length_call (rtx, int);\n+extern int pa_attr_length_indirect_call (rtx);\n \n /* Declare functions defined in pa.c and used in templates.  */\n \n-extern rtx return_addr_rtx (int, rtx);\n+extern rtx pa_return_addr_rtx (int, rtx);\n \n #ifdef ARGS_SIZE_RTX\n /* expr.h defines ARGS_SIZE_RTX and `enum direction' */\n #ifdef TREE_CODE\n-extern enum direction function_arg_padding (enum machine_mode, const_tree);\n+extern enum direction pa_function_arg_padding (enum machine_mode, const_tree);\n #endif\n #endif /* ARGS_SIZE_RTX */\n-extern int insn_refs_are_delayed (rtx);\n-extern rtx get_deferred_plabel (rtx);\n+extern int pa_insn_refs_are_delayed (rtx);\n+extern rtx pa_get_deferred_plabel (rtx);\n #endif /* RTX_CODE */\n \n-extern int ldil_cint_p (HOST_WIDE_INT);\n-extern int zdepi_cint_p (unsigned HOST_WIDE_INT);\n-\n-extern void output_ascii (FILE *, const char *, int);\n-extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT, int *);\n-extern int and_mask_p (unsigned HOST_WIDE_INT);\n-extern int cint_ok_for_move (HOST_WIDE_INT);\n-extern void hppa_expand_prologue (void);\n-extern void hppa_expand_epilogue (void);\n+extern int pa_and_mask_p (unsigned HOST_WIDE_INT);\n+extern int pa_cint_ok_for_move (HOST_WIDE_INT);\n+extern int pa_ior_mask_p (unsigned HOST_WIDE_INT);\n+extern int pa_ldil_cint_p (HOST_WIDE_INT);\n+extern int pa_shadd_constant_p (int);\n+extern int pa_zdepi_cint_p (unsigned HOST_WIDE_INT);\n+\n+extern void pa_output_ascii (FILE *, const char *, int);\n+extern HOST_WIDE_INT pa_compute_frame_size (HOST_WIDE_INT, int *);\n+extern void pa_expand_prologue (void);\n+extern void pa_expand_epilogue (void);\n extern bool pa_can_use_return_insn (void);\n-extern int ior_mask_p (unsigned HOST_WIDE_INT);\n-extern void compute_zdepdi_operands (unsigned HOST_WIDE_INT,\n-\t\t\t\t     unsigned *);\n-#ifdef RTX_CODE\n-extern const char * output_64bit_and (rtx *);\n-extern const char * output_64bit_ior (rtx *);\n-extern int cmpib_comparison_operator (rtx, enum machine_mode);\n-#endif\n-\n \n /* Miscellaneous functions in pa.c.  */\n #ifdef TREE_CODE\n-extern int reloc_needed (tree);\n+extern int pa_reloc_needed (tree);\n extern bool pa_return_in_memory (const_tree, const_tree);\n #endif /* TREE_CODE */\n \n@@ -125,5 +118,4 @@ extern bool pa_cannot_change_mode_class (enum machine_mode, enum machine_mode,\n extern bool pa_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);\n \n-extern const int magic_milli[];\n-extern int shadd_constant_p (int);\n+extern const int pa_magic_milli[];"}, {"sha": "6d2f67d00c3e39aa30ed09ca3df014ef0b4bac70", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 142, "deletions": 154, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Return nonzero if there is a bypass for the output of \n    OUT_INSN and the fp store IN_INSN.  */\n int\n-hppa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n+pa_fpstore_bypass_p (rtx out_insn, rtx in_insn)\n {\n   enum machine_mode store_mode;\n   enum machine_mode other_mode;\n@@ -99,6 +99,7 @@ static void pa_combine_instructions (void);\n static int pa_can_combine_p (rtx, rtx, rtx, int, rtx, rtx, rtx);\n static bool forward_branch_p (rtx);\n static void compute_zdepwi_operands (unsigned HOST_WIDE_INT, unsigned *);\n+static void compute_zdepdi_operands (unsigned HOST_WIDE_INT, unsigned *);\n static int compute_movmem_length (rtx);\n static int compute_clrmem_length (rtx);\n static bool pa_assemble_integer (rtx, unsigned int, int);\n@@ -677,7 +678,7 @@ copy_reg_pointer (rtx to, rtx from)\n    expressions will have one of a few well defined forms, so\n    we need only check those forms.  */\n int\n-symbolic_expression_p (rtx x)\n+pa_symbolic_expression_p (rtx x)\n {\n \n   /* Strip off any HIGH.  */\n@@ -690,19 +691,19 @@ symbolic_expression_p (rtx x)\n /* Accept any constant that can be moved in one instruction into a\n    general register.  */\n int\n-cint_ok_for_move (HOST_WIDE_INT ival)\n+pa_cint_ok_for_move (HOST_WIDE_INT ival)\n {\n   /* OK if ldo, ldil, or zdepi, can be used.  */\n   return (VAL_14_BITS_P (ival)\n-\t  || ldil_cint_p (ival)\n-\t  || zdepi_cint_p (ival));\n+\t  || pa_ldil_cint_p (ival)\n+\t  || pa_zdepi_cint_p (ival));\n }\n \f\n /* True iff ldil can be used to load this CONST_INT.  The least\n    significant 11 bits of the value must be zero and the value must\n    not change sign when extended from 32 to 64 bits.  */\n int\n-ldil_cint_p (HOST_WIDE_INT ival)\n+pa_ldil_cint_p (HOST_WIDE_INT ival)\n {\n   HOST_WIDE_INT x = ival & (((HOST_WIDE_INT) -1 << 31) | 0x7ff);\n \n@@ -713,7 +714,7 @@ ldil_cint_p (HOST_WIDE_INT ival)\n    zdepi first sign extends a 5-bit signed number to a given field\n    length, then places this field anywhere in a zero.  */\n int\n-zdepi_cint_p (unsigned HOST_WIDE_INT x)\n+pa_zdepi_cint_p (unsigned HOST_WIDE_INT x)\n {\n   unsigned HOST_WIDE_INT lsb_mask, t;\n \n@@ -731,7 +732,7 @@ zdepi_cint_p (unsigned HOST_WIDE_INT x)\n    1....10....0\n    1..10..01..1  */\n int\n-and_mask_p (unsigned HOST_WIDE_INT mask)\n+pa_and_mask_p (unsigned HOST_WIDE_INT mask)\n {\n   mask = ~mask;\n   mask += mask & -mask;\n@@ -740,7 +741,7 @@ and_mask_p (unsigned HOST_WIDE_INT mask)\n \n /* True iff depi can be used to compute (reg | MASK).  */\n int\n-ior_mask_p (unsigned HOST_WIDE_INT mask)\n+pa_ior_mask_p (unsigned HOST_WIDE_INT mask)\n {\n   mask += mask & -mask;\n   return (mask & (mask - 1)) == 0;\n@@ -751,7 +752,7 @@ ior_mask_p (unsigned HOST_WIDE_INT mask)\n    position-independent addresses go to REG.  If we need more\n    than one register, we lose.  */\n \n-rtx\n+static rtx\n legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n {\n   rtx pic_ref = orig;\n@@ -1102,7 +1103,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n   if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n+      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1)))\n       && (OBJECT_P (XEXP (x, 1))\n \t  || GET_CODE (XEXP (x, 1)) == SUBREG)\n       && GET_CODE (XEXP (x, 1)) != CONST)\n@@ -1133,7 +1134,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n       && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n-      && shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n+      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1)))\n       && (mode == SFmode || mode == DFmode))\n     {\n \n@@ -1146,7 +1147,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       idx = NULL_RTX;\n \n       /* Make sure they're both regs.  If one was a SYMBOL_REF [+ const],\n-\t then emit_move_sequence will turn on REG_POINTER so we'll know\n+\t then pa_emit_move_sequence will turn on REG_POINTER so we'll know\n \t it's a base register below.  */\n       if (GET_CODE (reg1) != REG)\n \treg1 = force_reg (Pmode, force_operand (reg1, 0));\n@@ -1259,7 +1260,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n      do the optimization for floatint point modes.  */\n \n   if (GET_CODE (x) == PLUS\n-      && symbolic_expression_p (XEXP (x, 1)))\n+      && pa_symbolic_expression_p (XEXP (x, 1)))\n     {\n       /* Ugly.  We modify things here so that the address offset specified\n \t by the index expression is computed first, then added to x to form\n@@ -1289,7 +1290,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t      && INTVAL (XEXP (y, 1)) >= -4096\n \t      && INTVAL (XEXP (y, 1)) <= 4095\n \t      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t      && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+\t      && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n \t    {\n \t      int val = INTVAL (XEXP (XEXP (x, 0), 1));\n \t      rtx reg1, reg2;\n@@ -1315,7 +1316,7 @@ hppa_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t   && GET_CODE (XEXP (y, 1)) == CONST_INT\n \t\t   && INTVAL (XEXP (y, 1)) % INTVAL (XEXP (XEXP (x, 0), 1)) == 0\n \t\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t\t   && shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n+\t\t   && pa_shadd_constant_p (INTVAL (XEXP (XEXP (x, 0), 1))))\n \t    {\n \t      regx1\n \t\t= force_reg (Pmode, GEN_INT (INTVAL (XEXP (y, 1))\n@@ -1541,7 +1542,7 @@ pa_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n    of SCRATCH_REG in the proper mode.  */\n \n int\n-emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n+pa_emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n@@ -1722,7 +1723,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n       const_mem = force_const_mem (mode, operand1);\n       xoperands[0] = scratch_reg;\n       xoperands[1] = XEXP (const_mem, 0);\n-      emit_move_sequence (xoperands, Pmode, 0);\n+      pa_emit_move_sequence (xoperands, Pmode, 0);\n \n       /* Now load the destination register.  */\n       emit_insn (gen_rtx_SET (mode, operand0,\n@@ -1788,7 +1789,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \n       if (register_operand (operand1, mode)\n \t  || (GET_CODE (operand1) == CONST_INT\n-\t      && cint_ok_for_move (INTVAL (operand1)))\n+\t      && pa_cint_ok_for_move (INTVAL (operand1)))\n \t  || (operand1 == CONST0_RTX (mode))\n \t  || (GET_CODE (operand1) == HIGH\n \t      && !symbolic_operand (XEXP (operand1, 0), VOIDmode))\n@@ -1946,12 +1947,12 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t      /* Put the address of the memory location into our destination\n \t\t register.  */\n \t      operands[1] = temp;\n-\t      emit_move_sequence (operands, mode, scratch_reg);\n+\t      pa_emit_move_sequence (operands, mode, scratch_reg);\n \n \t      /* Now load from the memory location into our destination\n \t\t register.  */\n \t      operands[1] = gen_rtx_MEM (Pmode, operands[0]);\n-\t      emit_move_sequence (operands, mode, scratch_reg);\n+\t      pa_emit_move_sequence (operands, mode, scratch_reg);\n \n \t      /* And add back in the constant part.  */\n \t      if (const_part != NULL_RTX)\n@@ -1989,7 +1990,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t\t  operands[1] = legitimize_pic_address (XEXP (const_mem, 0),\n \t\t\t\t\t\t\tmode, temp);\n \t\t  operands[1] = replace_equiv_address (const_mem, operands[1]);\n-\t\t  emit_move_sequence (operands, mode, temp);\n+\t\t  pa_emit_move_sequence (operands, mode, temp);\n \t\t}\n \t      else\n \t\t{\n@@ -2063,7 +2064,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t  operands[1] = tmp;\n \t}\n       else if (GET_CODE (operand1) != CONST_INT\n-\t       || !cint_ok_for_move (INTVAL (operand1)))\n+\t       || !pa_cint_ok_for_move (INTVAL (operand1)))\n \t{\n \t  rtx insn, temp;\n \t  rtx op1 = operand1;\n@@ -2206,7 +2207,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n    it will need a link/runtime reloc).  */\n \n int\n-reloc_needed (tree exp)\n+pa_reloc_needed (tree exp)\n {\n   int reloc = 0;\n \n@@ -2218,13 +2219,13 @@ reloc_needed (tree exp)\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      reloc = reloc_needed (TREE_OPERAND (exp, 0));\n-      reloc |= reloc_needed (TREE_OPERAND (exp, 1));\n+      reloc = pa_reloc_needed (TREE_OPERAND (exp, 0));\n+      reloc |= pa_reloc_needed (TREE_OPERAND (exp, 1));\n       break;\n \n     CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n-      reloc = reloc_needed (TREE_OPERAND (exp, 0));\n+      reloc = pa_reloc_needed (TREE_OPERAND (exp, 0));\n       break;\n \n     case CONSTRUCTOR:\n@@ -2234,7 +2235,7 @@ reloc_needed (tree exp)\n \n \tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), ix, value)\n \t  if (value)\n-\t    reloc |= reloc_needed (value);\n+\t    reloc |= pa_reloc_needed (value);\n       }\n       break;\n \n@@ -2251,7 +2252,7 @@ reloc_needed (tree exp)\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */\n const char *\n-singlemove_string (rtx *operands)\n+pa_singlemove_string (rtx *operands)\n {\n   HOST_WIDE_INT intval;\n \n@@ -2282,7 +2283,7 @@ singlemove_string (rtx *operands)\n \treturn \"ldi %1,%0\";\n       else if ((intval & 0x7ff) == 0)\n \treturn \"ldil L'%1,%0\";\n-      else if (zdepi_cint_p (intval))\n+      else if (pa_zdepi_cint_p (intval))\n \treturn \"{zdepi %Z1,%0|depwi,z %Z1,%0}\";\n       else\n \treturn \"ldil L'%1,%0\\n\\tldo R'%1(%0),%0\";\n@@ -2331,7 +2332,8 @@ compute_zdepwi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)\n /* Compute position (in OP[1]) and width (in OP[2])\n    useful for copying IMM to a register using the depdi,z\n    instructions.  Store the immediate value to insert in OP[0].  */\n-void\n+\n+static void\n compute_zdepdi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)\n {\n   int lsb, len, maxlen;\n@@ -2375,7 +2377,7 @@ compute_zdepdi_operands (unsigned HOST_WIDE_INT imm, unsigned *op)\n    with operands OPERANDS.  */\n \n const char *\n-output_move_double (rtx *operands)\n+pa_output_move_double (rtx *operands)\n {\n   enum { REGOP, OFFSOP, MEMOP, CNSTOP, RNDOP } optype0, optype1;\n   rtx latehalf[2];\n@@ -2617,25 +2619,25 @@ output_move_double (rtx *operands)\n       /* Do the late half first.  */\n       if (addreg1)\n \toutput_asm_insn (\"ldo 4(%0),%0\", &addreg1);\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      output_asm_insn (pa_singlemove_string (latehalf), latehalf);\n \n       /* Then clobber.  */\n       if (addreg1)\n \toutput_asm_insn (\"ldo -4(%0),%0\", &addreg1);\n-      return singlemove_string (operands);\n+      return pa_singlemove_string (operands);\n     }\n \n   /* Now handle register -> register case.  */\n   if (optype0 == REGOP && optype1 == REGOP\n       && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n     {\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-      return singlemove_string (operands);\n+      output_asm_insn (pa_singlemove_string (latehalf), latehalf);\n+      return pa_singlemove_string (operands);\n     }\n \n   /* Normal case: do the two words, low-numbered first.  */\n \n-  output_asm_insn (singlemove_string (operands), operands);\n+  output_asm_insn (pa_singlemove_string (operands), operands);\n \n   /* Make any unoffsettable addresses point at high-numbered word.  */\n   if (addreg0)\n@@ -2644,7 +2646,7 @@ output_move_double (rtx *operands)\n     output_asm_insn (\"ldo 4(%0),%0\", &addreg1);\n \n   /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n+  output_asm_insn (pa_singlemove_string (latehalf), latehalf);\n \n   /* Undo the adds we just did.  */\n   if (addreg0)\n@@ -2656,7 +2658,7 @@ output_move_double (rtx *operands)\n }\n \f\n const char *\n-output_fp_move_double (rtx *operands)\n+pa_output_fp_move_double (rtx *operands)\n {\n   if (FP_REG_P (operands[0]))\n     {\n@@ -2723,7 +2725,7 @@ find_addr_reg (rtx addr)\n    OPERANDS[6] is another temporary register.  */\n \n const char *\n-output_block_move (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n+pa_output_block_move (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n {\n   int align = INTVAL (operands[5]);\n   unsigned long n_bytes = INTVAL (operands[4]);\n@@ -2887,7 +2889,7 @@ compute_movmem_length (rtx insn)\n    OPERANDS[3] is the alignment safe to use, as a CONST_INT.  */\n \n const char *\n-output_block_clear (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n+pa_output_block_clear (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n {\n   int align = INTVAL (operands[3]);\n   unsigned long n_bytes = INTVAL (operands[2]);\n@@ -3023,7 +3025,7 @@ compute_clrmem_length (rtx insn)\n \f\n \n const char *\n-output_and (rtx *operands)\n+pa_output_and (rtx *operands)\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n@@ -3073,7 +3075,7 @@ output_and (rtx *operands)\n /* Return a string to perform a bitwise-and of operands[1] with operands[2]\n    storing the result in operands[0].  */\n const char *\n-output_64bit_and (rtx *operands)\n+pa_output_64bit_and (rtx *operands)\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n@@ -3121,7 +3123,7 @@ output_64bit_and (rtx *operands)\n }\n \n const char *\n-output_ior (rtx *operands)\n+pa_output_ior (rtx *operands)\n {\n   unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n   int bs0, bs1, p, len;\n@@ -3150,7 +3152,7 @@ output_ior (rtx *operands)\n /* Return a string to perform a bitwise-and of operands[1] with operands[2]\n    storing the result in operands[0].  */\n const char *\n-output_64bit_ior (rtx *operands)\n+pa_output_64bit_ior (rtx *operands)\n {\n   unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n   int bs0, bs1, p, len;\n@@ -3198,7 +3200,7 @@ pa_assemble_integer (rtx x, unsigned int size, int aligned_p)\n \f\n /* Output an ascii string.  */\n void\n-output_ascii (FILE *file, const char *p, int size)\n+pa_output_ascii (FILE *file, const char *p, int size)\n {\n   int i;\n   int chars_output;\n@@ -3602,12 +3604,12 @@ set_reg_plus_d (int reg, int base, HOST_WIDE_INT disp, int note)\n }\n \n HOST_WIDE_INT\n-compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n+pa_compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n {\n   int freg_saved = 0;\n   int i, j;\n \n-  /* The code in hppa_expand_prologue and hppa_expand_epilogue must\n+  /* The code in pa_expand_prologue and pa_expand_epilogue must\n      be consistent with the rounding and size calculation done here.\n      Change them at the same time.  */\n \n@@ -3703,7 +3705,7 @@ pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   ASM_OUTPUT_LABEL (file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n   fputs (\"\\t.PROC\\n\", file);\n \n-  /* hppa_expand_prologue does the dirty work now.  We just need\n+  /* pa_expand_prologue does the dirty work now.  We just need\n      to output the assembler directives which denote the start\n      of a function.  */\n   fprintf (file, \"\\t.CALLINFO FRAME=\" HOST_WIDE_INT_PRINT_DEC, actual_fsize);\n@@ -3746,7 +3748,7 @@ pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n }\n \n void\n-hppa_expand_prologue (void)\n+pa_expand_prologue (void)\n {\n   int merge_sp_adjust_with_store = 0;\n   HOST_WIDE_INT size = get_frame_size ();\n@@ -3759,13 +3761,13 @@ hppa_expand_prologue (void)\n   save_fregs = 0;\n \n   /* Compute total size for frame pointer, filler, locals and rounding to\n-     the next word boundary.  Similar code appears in compute_frame_size\n+     the next word boundary.  Similar code appears in pa_compute_frame_size\n      and must be changed in tandem with this code.  */\n   local_fsize = (size + UNITS_PER_WORD - 1) & ~(UNITS_PER_WORD - 1);\n   if (local_fsize || frame_pointer_needed)\n     local_fsize += STARTING_FRAME_OFFSET;\n \n-  actual_fsize = compute_frame_size (size, &save_fregs);\n+  actual_fsize = pa_compute_frame_size (size, &save_fregs);\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = actual_fsize;\n \n@@ -4109,7 +4111,7 @@ pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n   last_address = 0;\n \n-  /* hppa_expand_epilogue does the dirty work now.  We just need\n+  /* pa_expand_epilogue does the dirty work now.  We just need\n      to output the assembler directives which denote the end\n      of a function.\n \n@@ -4162,7 +4164,7 @@ pa_output_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n }\n \n void\n-hppa_expand_epilogue (void)\n+pa_expand_epilogue (void)\n {\n   rtx tmpreg;\n   HOST_WIDE_INT offset;\n@@ -4354,7 +4356,7 @@ pa_can_use_return_insn (void)\n   if (crtl->profile)\n     return false;\n \n-  return compute_frame_size (get_frame_size (), 0) == 0;\n+  return pa_compute_frame_size (get_frame_size (), 0) == 0;\n }\n \n rtx\n@@ -4494,7 +4496,7 @@ hppa_profile_hook (int label_no)\n    return location is in a shared library.  */\n \n rtx\n-return_addr_rtx (int count, rtx frameaddr)\n+pa_return_addr_rtx (int count, rtx frameaddr)\n {\n   rtx label;\n   rtx rp;\n@@ -4563,7 +4565,7 @@ return_addr_rtx (int count, rtx frameaddr)\n }\n \n void\n-emit_bcond_fp (rtx operands[])\n+pa_emit_bcond_fp (rtx operands[])\n {\n   enum rtx_code code = GET_CODE (operands[0]);\n   rtx operand0 = operands[1];\n@@ -4919,7 +4921,7 @@ pa_print_operand_punct_valid_p (unsigned char code)\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n \n void\n-print_operand (FILE *file, rtx x, int code)\n+pa_print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -4969,7 +4971,7 @@ print_operand (FILE *file, rtx x, int code)\n \n \txoperands[0] = XEXP (XEXP (x, 0), 0);\n \txoperands[1] = XVECEXP (XEXP (XEXP (x, 0), 1), 0, 0);\n-\toutput_global_address (file, xoperands[1], 0);\n+\tpa_output_global_address (file, xoperands[1], 0);\n         fprintf (file, \"(%s)\", reg_names [REGNO (xoperands[0])]);\n \treturn;\n       }\n@@ -5194,10 +5196,10 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n     case 'G':\n-      output_global_address (file, x, 0);\n+      pa_output_global_address (file, x, 0);\n       return;\n     case 'H':\n-      output_global_address (file, x, 1);\n+      pa_output_global_address (file, x, 1);\n       return;\n     case 0:\t\t\t/* Don't do anything special */\n       break;\n@@ -5288,7 +5290,7 @@ print_operand (FILE *file, rtx x, int code)\n /* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF.  */\n \n void\n-output_global_address (FILE *file, rtx x, int round_constant)\n+pa_output_global_address (FILE *file, rtx x, int round_constant)\n {\n \n   /* Imagine  (high (const (plus ...))).  */\n@@ -5477,7 +5479,7 @@ pa_hpux64_hpas_file_start (void)\n    label.  If an entry for SYMBOL is not found, a new entry is created.  */\n \n rtx\n-get_deferred_plabel (rtx symbol)\n+pa_get_deferred_plabel (rtx symbol)\n {\n   const char *fname = XSTR (symbol, 0);\n   size_t i;\n@@ -5610,16 +5612,16 @@ import_milli (enum millicodes code)\n    the proper registers.  */\n \n const char *\n-output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx insn)\n+pa_output_mul_insn (int unsignedp ATTRIBUTE_UNUSED, rtx insn)\n {\n   import_milli (mulI);\n-  return output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n+  return pa_output_millicode_call (insn, gen_rtx_SYMBOL_REF (Pmode, \"$$mulI\"));\n }\n \n /* Emit the rtl for doing a division by a constant.  */\n \n /* Do magic division millicodes exist for this value? */\n-const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1};\n+const int pa_magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1};\n \n /* We'll use an array to keep track of the magic millicodes and\n    whether or not we've used them already. [n][0] is signed, [n][1] is\n@@ -5628,12 +5630,12 @@ const int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1};\n static int div_milli[16][2];\n \n int\n-emit_hpdiv_const (rtx *operands, int unsignedp)\n+pa_emit_hpdiv_const (rtx *operands, int unsignedp)\n {\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) > 0\n       && INTVAL (operands[2]) < 16\n-      && magic_milli[INTVAL (operands[2])])\n+      && pa_magic_milli[INTVAL (operands[2])])\n     {\n       rtx ret = gen_rtx_REG (SImode, TARGET_64BIT ? 2 : 31);\n \n@@ -5658,7 +5660,7 @@ emit_hpdiv_const (rtx *operands, int unsignedp)\n }\n \n const char *\n-output_div_insn (rtx *operands, int unsignedp, rtx insn)\n+pa_output_div_insn (rtx *operands, int unsignedp, rtx insn)\n {\n   int divisor;\n \n@@ -5680,15 +5682,15 @@ output_div_insn (rtx *operands, int unsignedp, rtx insn)\n \t{\n \t  sprintf (buf, \"$$divU_\" HOST_WIDE_INT_PRINT_DEC,\n \t\t   INTVAL (operands[0]));\n-\t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, buf));\n+\t  return pa_output_millicode_call (insn,\n+\t\t\t\t\t   gen_rtx_SYMBOL_REF (SImode, buf));\n \t}\n       else\n \t{\n \t  sprintf (buf, \"$$divI_\" HOST_WIDE_INT_PRINT_DEC,\n \t\t   INTVAL (operands[0]));\n-\t  return output_millicode_call (insn,\n-\t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, buf));\n+\t  return pa_output_millicode_call (insn,\n+\t\t\t\t\t   gen_rtx_SYMBOL_REF (SImode, buf));\n \t}\n     }\n   /* Divisor isn't a special constant.  */\n@@ -5697,13 +5699,13 @@ output_div_insn (rtx *operands, int unsignedp, rtx insn)\n       if (unsignedp)\n \t{\n \t  import_milli (divU);\n-\t  return output_millicode_call (insn,\n+\t  return pa_output_millicode_call (insn,\n \t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \"$$divU\"));\n \t}\n       else\n \t{\n \t  import_milli (divI);\n-\t  return output_millicode_call (insn,\n+\t  return pa_output_millicode_call (insn,\n \t\t\t\t\tgen_rtx_SYMBOL_REF (SImode, \"$$divI\"));\n \t}\n     }\n@@ -5712,24 +5714,24 @@ output_div_insn (rtx *operands, int unsignedp, rtx insn)\n /* Output a $$rem millicode to do mod.  */\n \n const char *\n-output_mod_insn (int unsignedp, rtx insn)\n+pa_output_mod_insn (int unsignedp, rtx insn)\n {\n   if (unsignedp)\n     {\n       import_milli (remU);\n-      return output_millicode_call (insn,\n-\t\t\t\t    gen_rtx_SYMBOL_REF (SImode, \"$$remU\"));\n+      return pa_output_millicode_call (insn,\n+\t\t\t\t       gen_rtx_SYMBOL_REF (SImode, \"$$remU\"));\n     }\n   else\n     {\n       import_milli (remI);\n-      return output_millicode_call (insn,\n-\t\t\t\t    gen_rtx_SYMBOL_REF (SImode, \"$$remI\"));\n+      return pa_output_millicode_call (insn,\n+\t\t\t\t       gen_rtx_SYMBOL_REF (SImode, \"$$remI\"));\n     }\n }\n \n void\n-output_arg_descriptor (rtx call_insn)\n+pa_output_arg_descriptor (rtx call_insn)\n {\n   const char *arg_regs[4];\n   enum machine_mode arg_mode;\n@@ -5847,7 +5849,7 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   /* Secondary reloads of symbolic operands require %r1 as a scratch\n      register when we're generating PIC code and when the operand isn't\n      readonly.  */\n-  if (symbolic_expression_p (x))\n+  if (pa_symbolic_expression_p (x))\n     {\n       if (GET_CODE (x) == HIGH)\n \tx = XEXP (x, 0);\n@@ -5869,7 +5871,7 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   /* In order to allow 14-bit displacements in integer loads and stores,\n      we need to prevent reload from generating out of range integer mode\n      loads and stores to the floating point registers.  Previously, we\n-     used to call for a secondary reload and have emit_move_sequence()\n+     used to call for a secondary reload and have pa_emit_move_sequence()\n      fix the instruction sequence.  However, reload occasionally wouldn't\n      generate the reload and we would end up with an invalid REG+D memory\n      address.  So, now we use an intermediate general register for most\n@@ -5994,7 +5996,7 @@ pa_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n }\n \n enum direction\n-function_arg_padding (enum machine_mode mode, const_tree type)\n+pa_function_arg_padding (enum machine_mode mode, const_tree type)\n {\n   if (mode == BLKmode\n       || (TARGET_64BIT\n@@ -6308,7 +6310,7 @@ use_skip_p (rtx insn)\n    parameters.  */\n \n const char *\n-output_cbranch (rtx *operands, int negated, rtx insn)\n+pa_output_cbranch (rtx *operands, int negated, rtx insn)\n {\n   static char buf[100];\n   bool useskip;\n@@ -6434,7 +6436,7 @@ output_cbranch (rtx *operands, int negated, rtx insn)\n       default:\n \t/* The reversed conditional branch must branch over one additional\n \t   instruction if the delay slot is filled and needs to be extracted\n-\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   by pa_output_lbranch.  If the delay slot is empty or this is a\n \t   nullified forward branch, the instruction after the reversed\n \t   condition branch must be nullified.  */\n \tif (dbr_sequence_length () == 0\n@@ -6496,7 +6498,7 @@ output_cbranch (rtx *operands, int negated, rtx insn)\n \t  }\n \n \toutput_asm_insn (buf, operands);\n-\treturn output_lbranch (operands[0], insn, xdelay);\n+\treturn pa_output_lbranch (operands[0], insn, xdelay);\n     }\n   return buf;\n }\n@@ -6519,7 +6521,7 @@ output_cbranch (rtx *operands, int negated, rtx insn)\n    bytes for the portable runtime, non-PIC and PIC cases, respectively.  */\n \n const char *\n-output_lbranch (rtx dest, rtx insn, int xdelay)\n+pa_output_lbranch (rtx dest, rtx insn, int xdelay)\n {\n   rtx xoperands[2];\n  \n@@ -6634,7 +6636,7 @@ output_lbranch (rtx dest, rtx insn, int xdelay)\n    above.  it returns the appropriate output template to emit the branch.  */\n \n const char *\n-output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n+pa_output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n {\n   static char buf[100];\n   bool useskip;\n@@ -6776,7 +6778,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n       default:\n \t/* The reversed conditional branch must branch over one additional\n \t   instruction if the delay slot is filled and needs to be extracted\n-\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   by pa_output_lbranch.  If the delay slot is empty or this is a\n \t   nullified forward branch, the instruction after the reversed\n \t   condition branch must be nullified.  */\n \tif (dbr_sequence_length () == 0\n@@ -6806,8 +6808,8 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n \telse\n \t  strcat (buf, \" %0,%1,.+%4\");\n \toutput_asm_insn (buf, operands);\n-\treturn output_lbranch (negated ? operands[3] : operands[2],\n-\t\t\t       insn, xdelay);\n+\treturn pa_output_lbranch (negated ? operands[3] : operands[2],\n+\t\t\t\t  insn, xdelay);\n     }\n   return buf;\n }\n@@ -6819,7 +6821,8 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n    branch.  */\n \n const char *\n-output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n+pa_output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn,\n+\t       int which)\n {\n   static char buf[100];\n   bool useskip;\n@@ -6960,7 +6963,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n       default:\n \t/* The reversed conditional branch must branch over one additional\n \t   instruction if the delay slot is filled and needs to be extracted\n-\t   by output_lbranch.  If the delay slot is empty or this is a\n+\t   by pa_output_lbranch.  If the delay slot is empty or this is a\n \t   nullified forward branch, the instruction after the reversed\n \t   condition branch must be nullified.  */\n \tif (dbr_sequence_length () == 0\n@@ -6990,8 +6993,8 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n \telse\n \t  strcat (buf, \" {%0,.+%4|%0,%%sar,.+%4}\");\n \toutput_asm_insn (buf, operands);\n-\treturn output_lbranch (negated ? operands[3] : operands[2],\n-\t\t\t       insn, xdelay);\n+\treturn pa_output_lbranch (negated ? operands[3] : operands[2],\n+\t\t\t\t  insn, xdelay);\n     }\n   return buf;\n }\n@@ -7001,7 +7004,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-output_dbra (rtx *operands, rtx insn, int which_alternative)\n+pa_output_dbra (rtx *operands, rtx insn, int which_alternative)\n {\n   int length = get_attr_length (insn);\n \n@@ -7080,7 +7083,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \tdefault:\n \t  /* The reversed conditional branch must branch over one additional\n \t     instruction if the delay slot is filled and needs to be extracted\n-\t     by output_lbranch.  If the delay slot is empty or this is a\n+\t     by pa_output_lbranch.  If the delay slot is empty or this is a\n \t     nullified forward branch, the instruction after the reversed\n \t     condition branch must be nullified.  */\n \t  if (dbr_sequence_length () == 0\n@@ -7101,7 +7104,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \t  else\n \t    output_asm_insn (\"addib,%N2 %1,%0,.+%4\", operands);\n \n-\t  return output_lbranch (operands[3], insn, xdelay);\n+\t  return pa_output_lbranch (operands[3], insn, xdelay);\n \t}\n       \n     }\n@@ -7123,7 +7126,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \t  operands[5] = GEN_INT (length - 16);\n \t  output_asm_insn (\"{comb|cmpb},%B2 %%r0,%4,.+%5\", operands);\n \t  output_asm_insn (\"{fldws|fldw} -16(%%r30),%0\", operands);\n-\t  return output_lbranch (operands[3], insn, 0);\n+\t  return pa_output_lbranch (operands[3], insn, 0);\n \t}\n     }\n   /* Deal with gross reload from memory case.  */\n@@ -7140,7 +7143,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \t{\n \t  operands[5] = GEN_INT (length - 4);\n \t  output_asm_insn (\"addib,%N2 %1,%4,.+%5\\n\\tstw %4,%0\", operands);\n-\t  return output_lbranch (operands[3], insn, 0);\n+\t  return pa_output_lbranch (operands[3], insn, 0);\n \t}\n     }\n }\n@@ -7150,7 +7153,7 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n    Note it may perform some output operations on its own before\n    returning the final output string.  */\n const char *\n-output_movb (rtx *operands, rtx insn, int which_alternative,\n+pa_output_movb (rtx *operands, rtx insn, int which_alternative,\n \t     int reverse_comparison)\n {\n   int length = get_attr_length (insn);\n@@ -7231,7 +7234,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \tdefault:\n \t  /* The reversed conditional branch must branch over one additional\n \t     instruction if the delay slot is filled and needs to be extracted\n-\t     by output_lbranch.  If the delay slot is empty or this is a\n+\t     by pa_output_lbranch.  If the delay slot is empty or this is a\n \t     nullified forward branch, the instruction after the reversed\n \t     condition branch must be nullified.  */\n \t  if (dbr_sequence_length () == 0\n@@ -7252,7 +7255,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t  else\n \t    output_asm_insn (\"movb,%N2 %1,%0,.+%4\", operands);\n \n-\t  return output_lbranch (operands[3], insn, xdelay);\n+\t  return pa_output_lbranch (operands[3], insn, xdelay);\n \t}\n     }\n   /* Deal with gross reload for FP destination register case.  */\n@@ -7271,7 +7274,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t  operands[4] = GEN_INT (length - 4);\n \t  output_asm_insn (\"{comb|cmpb},%B2 %%r0,%1,.+%4\", operands);\n \t  output_asm_insn (\"{fldws|fldw} -16(%%r30),%0\", operands);\n-\t  return output_lbranch (operands[3], insn, 0);\n+\t  return pa_output_lbranch (operands[3], insn, 0);\n \t}\n     }\n   /* Deal with gross reload from memory case.  */\n@@ -7288,7 +7291,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t  operands[4] = GEN_INT (length);\n \t  output_asm_insn (\"{comb|cmpb},%B2 %%r0,%1,.+%4\\n\\tstw %1,%0\",\n \t\t\t   operands);\n-\t  return output_lbranch (operands[3], insn, 0);\n+\t  return pa_output_lbranch (operands[3], insn, 0);\n \t}\n     }\n   /* Handle SAR as a destination.  */\n@@ -7303,7 +7306,7 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t  operands[4] = GEN_INT (length);\n \t  output_asm_insn (\"{comb|cmpb},%B2 %%r0,%1,.+%4\\n\\tmtsar %r1\",\n \t\t\t   operands);\n-\t  return output_lbranch (operands[3], insn, 0);\n+\t  return pa_output_lbranch (operands[3], insn, 0);\n \t}\n     }\n }\n@@ -7385,12 +7388,12 @@ length_fp_args (rtx insn)\n }\n \n /* Return the attribute length for the millicode call instruction INSN.\n-   The length must match the code generated by output_millicode_call.\n+   The length must match the code generated by pa_output_millicode_call.\n    We include the delay slot in the returned length as it is better to\n    over estimate the length than to under estimate it.  */\n \n int\n-attr_length_millicode_call (rtx insn)\n+pa_attr_length_millicode_call (rtx insn)\n {\n   unsigned long distance = -1;\n   unsigned long total = IN_NAMED_SECTION_P (cfun->decl) ? 0 : total_code_bytes;\n@@ -7429,7 +7432,7 @@ attr_length_millicode_call (rtx insn)\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-output_millicode_call (rtx insn, rtx call_dest)\n+pa_output_millicode_call (rtx insn, rtx call_dest)\n {\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n@@ -7577,7 +7580,7 @@ output_millicode_call (rtx insn, rtx call_dest)\n /* Return the attribute length of the call instruction INSN.  The SIBCALL\n    flag indicates whether INSN is a regular call or a sibling call.  The\n    length returned must be longer than the code actually generated by\n-   output_call.  Since branch shortening is done before delay branch\n+   pa_output_call.  Since branch shortening is done before delay branch\n    sequencing, there is no way to determine whether or not the delay\n    slot will be filled during branch shortening.  Even when the delay\n    slot is filled, we may have to add a nop if the delay slot contains\n@@ -7588,7 +7591,7 @@ output_millicode_call (rtx insn, rtx call_dest)\n    these sequences.  */\n \n int\n-attr_length_call (rtx insn, int sibcall)\n+pa_attr_length_call (rtx insn, int sibcall)\n {\n   int local_call;\n   rtx call, call_dest;\n@@ -7678,7 +7681,7 @@ attr_length_call (rtx insn, int sibcall)\n    CALL_DEST is the routine we are calling.  */\n \n const char *\n-output_call (rtx insn, rtx call_dest, int sibcall)\n+pa_output_call (rtx insn, rtx call_dest, int sibcall)\n {\n   int delay_insn_deleted = 0;\n   int delay_slot_filled = 0;\n@@ -7692,7 +7695,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n   /* Handle the common case where we're sure that the branch will reach\n      the beginning of the \"$CODE$\" subspace.  This is the beginning of\n      the current function if we are in a named section.  */\n-  if (!TARGET_LONG_CALLS && attr_length_call (insn, sibcall) == 8)\n+  if (!TARGET_LONG_CALLS && pa_attr_length_call (insn, sibcall) == 8)\n     {\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n       output_asm_insn (\"{bl|b,l} %0,%1\", xoperands);\n@@ -7704,7 +7707,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n \t  /* ??? As far as I can tell, the HP linker doesn't support the\n \t     long pc-relative sequence described in the 64-bit runtime\n \t     architecture.  So, we use a slightly longer indirect call.  */\n-\t  xoperands[0] = get_deferred_plabel (call_dest);\n+\t  xoperands[0] = pa_get_deferred_plabel (call_dest);\n \t  xoperands[1] = gen_label_rtx ();\n \n \t  /* If this isn't a sibcall, we put the load of %r27 into the\n@@ -7830,7 +7833,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n \t\t     essentially an inline implementation of $$dyncall.\n \t\t     We don't actually try to call $$dyncall as this is\n \t\t     as difficult as calling the function itself.  */\n-\t\t  xoperands[0] = get_deferred_plabel (call_dest);\n+\t\t  xoperands[0] = pa_get_deferred_plabel (call_dest);\n \t\t  xoperands[1] = gen_label_rtx ();\n \n \t\t  /* Since the call is indirect, FP arguments in registers\n@@ -7967,7 +7970,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n    the sequence itself.  */\n \n int\n-attr_length_indirect_call (rtx insn)\n+pa_attr_length_indirect_call (rtx insn)\n {\n   unsigned long distance = -1;\n   unsigned long total = IN_NAMED_SECTION_P (cfun->decl) ? 0 : total_code_bytes;\n@@ -7999,7 +8002,7 @@ attr_length_indirect_call (rtx insn)\n }\n \n const char *\n-output_indirect_call (rtx insn, rtx call_dest)\n+pa_output_indirect_call (rtx insn, rtx call_dest)\n {\n   rtx xoperands[1];\n \n@@ -8020,7 +8023,7 @@ output_indirect_call (rtx insn, rtx call_dest)\n \n      No need to check target flags as the length uniquely identifies\n      the remaining cases.  */\n-  if (attr_length_indirect_call (insn) == 8)\n+  if (pa_attr_length_indirect_call (insn) == 8)\n     {\n       /* The HP linker sometimes substitutes a BLE for BL/B,L calls to\n \t $$dyncall.  Since BLE uses %r31 as the link register, the 22-bit\n@@ -8033,11 +8036,11 @@ output_indirect_call (rtx insn, rtx call_dest)\n \n   /* Long millicode call, but we are not generating PIC or portable runtime\n      code.  */\n-  if (attr_length_indirect_call (insn) == 12)\n+  if (pa_attr_length_indirect_call (insn) == 12)\n     return \".CALL\\tARGW0=GR\\n\\tldil L'$$dyncall,%%r2\\n\\tble R'$$dyncall(%%sr4,%%r2)\\n\\tcopy %%r31,%%r2\";\n \n   /* Long millicode call for portable runtime.  */\n-  if (attr_length_indirect_call (insn) == 20)\n+  if (pa_attr_length_indirect_call (insn) == 20)\n     return \"ldil L'$$dyncall,%%r31\\n\\tldo R'$$dyncall(%%r31),%%r31\\n\\tblr %%r0,%%r2\\n\\tbv,n %%r0(%%r31)\\n\\tnop\";\n \n   /* We need a long PIC call to $$dyncall.  */\n@@ -8062,28 +8065,13 @@ output_indirect_call (rtx insn, rtx call_dest)\n   return \"\";\n }\n \n-/* Return the total length of the save and restore instructions needed for\n-   the data linkage table pointer (i.e., the PIC register) across the call\n-   instruction INSN.  No-return calls do not require a save and restore.\n-   In addition, we may be able to avoid the save and restore for calls\n-   within the same translation unit.  */\n-\n-int\n-attr_length_save_restore_dltp (rtx insn)\n-{\n-  if (find_reg_note (insn, REG_NORETURN, NULL_RTX))\n-    return 0;\n-\n-  return 8;\n-}\n-\n /* In HPUX 8.0's shared library scheme, special relocations are needed\n    for function labels if they might be passed to a function\n    in a shared library (because shared libraries don't live in code\n    space), and special magic is needed to construct their address.  */\n \n void\n-hppa_encode_label (rtx sym)\n+pa_encode_label (rtx sym)\n {\n   const char *str = XSTR (sym, 0);\n   int len = strlen (str) + 1;\n@@ -8111,7 +8099,7 @@ pa_encode_section_info (tree decl, rtx rtl, int first)\n     {\n       SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n-\thppa_encode_label (XEXP (rtl, 0));\n+\tpa_encode_label (XEXP (rtl, 0));\n     }\n   else if (old_referenced)\n     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= old_referenced;\n@@ -8131,7 +8119,7 @@ pa_strip_name_encoding (const char *str)\n    with a constant.  Used to keep certain patterns from matching\n    during instruction combination.  */\n int\n-is_function_label_plus_const (rtx op)\n+pa_is_function_label_plus_const (rtx op)\n {\n   /* Strip off any CONST.  */\n   if (GET_CODE (op) == CONST)\n@@ -8427,7 +8415,7 @@ pa_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n      single subspace mode and the call is not indirect.  As far as I know,\n      there is no operating system support for the multiple subspace mode.\n      It might be possible to support indirect calls if we didn't use\n-     $$dyncall (see the indirect sequence generated in output_call).  */\n+     $$dyncall (see the indirect sequence generated in pa_output_call).  */\n   if (TARGET_ELF32)\n     return (decl != NULL_TREE);\n \n@@ -8459,7 +8447,7 @@ pa_commutative_p (const_rtx x, int outer_code)\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpyadd instructions.  */\n int\n-fmpyaddoperands (rtx *operands)\n+pa_fmpyaddoperands (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -8519,7 +8507,7 @@ static void\n pa_asm_out_constructor (rtx symbol, int priority)\n {\n   if (!function_label_operand (symbol, VOIDmode))\n-    hppa_encode_label (symbol);\n+    pa_encode_label (symbol);\n \n #ifdef CTORS_SECTION_ASM_OP\n   default_ctor_section_asm_out_constructor (symbol, priority);\n@@ -8536,7 +8524,7 @@ static void\n pa_asm_out_destructor (rtx symbol, int priority)\n {\n   if (!function_label_operand (symbol, VOIDmode))\n-    hppa_encode_label (symbol);\n+    pa_encode_label (symbol);\n \n #ifdef DTORS_SECTION_ASM_OP\n   default_dtor_section_asm_out_destructor (symbol, priority);\n@@ -8637,7 +8625,7 @@ pa_asm_output_aligned_local (FILE *stream,\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpysub instructions.  */\n int\n-fmpysuboperands (rtx *operands)\n+pa_fmpysuboperands (rtx *operands)\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n \n@@ -8693,7 +8681,7 @@ fmpysuboperands (rtx *operands)\n /* Return 1 if the given constant is 2, 4, or 8.  These are the valid\n    constants for shadd instructions.  */\n int\n-shadd_constant_p (int val)\n+pa_shadd_constant_p (int val)\n {\n   if (val == 2 || val == 4 || val == 8)\n     return 1;\n@@ -8727,7 +8715,7 @@ forward_branch_p (rtx insn)\n \n /* Return 1 if INSN is in the delay slot of a call instruction.  */\n int\n-jump_in_call_delay (rtx insn)\n+pa_jump_in_call_delay (rtx insn)\n {\n \n   if (GET_CODE (insn) != JUMP_INSN)\n@@ -8750,7 +8738,7 @@ jump_in_call_delay (rtx insn)\n /* Output an unconditional move and branch insn.  */\n \n const char *\n-output_parallel_movb (rtx *operands, rtx insn)\n+pa_output_parallel_movb (rtx *operands, rtx insn)\n {\n   int length = get_attr_length (insn);\n \n@@ -8784,13 +8772,13 @@ output_parallel_movb (rtx *operands, rtx insn)\n     output_asm_insn (\"ldi %1,%0\", operands);\n   else\n     output_asm_insn (\"copy %1,%0\", operands);\n-  return output_lbranch (operands[2], insn, 1);\n+  return pa_output_lbranch (operands[2], insn, 1);\n }\n \n /* Output an unconditional add and branch insn.  */\n \n const char *\n-output_parallel_addb (rtx *operands, rtx insn)\n+pa_output_parallel_addb (rtx *operands, rtx insn)\n {\n   int length = get_attr_length (insn);\n \n@@ -8816,7 +8804,7 @@ output_parallel_addb (rtx *operands, rtx insn)\n     }\n \n   output_asm_insn (\"add%I1 %1,%0,%0\", operands);\n-  return output_lbranch (operands[3], insn, 1);\n+  return pa_output_lbranch (operands[3], insn, 1);\n }\n \n /* Return nonzero if INSN (a jump insn) immediately follows a call\n@@ -8825,7 +8813,7 @@ output_parallel_addb (rtx *operands, rtx insn)\n    the delay slot of the call.  */\n \n int\n-following_call (rtx insn)\n+pa_following_call (rtx insn)\n {\n   if (! TARGET_JUMP_IN_DELAY)\n     return 0;\n@@ -9288,7 +9276,7 @@ pa_can_combine_p (rtx new_rtx, rtx anchor, rtx floater, int reversed, rtx dest,\n    filter out things it will not accept -- SEQUENCE, USE and CLOBBER insns\n    in particular.  */\n int\n-insn_refs_are_delayed (rtx insn)\n+pa_insn_refs_are_delayed (rtx insn)\n {\n   return ((GET_CODE (insn) == INSN\n \t   && GET_CODE (PATTERN (insn)) != SEQUENCE\n@@ -10191,7 +10179,7 @@ pa_initial_elimination_offset (int from, int to)\n \n   if ((from == HARD_FRAME_POINTER_REGNUM || from == FRAME_POINTER_REGNUM)\n       && to == STACK_POINTER_REGNUM)\n-    offset = -compute_frame_size (get_frame_size (), 0);\n+    offset = -pa_compute_frame_size (get_frame_size (), 0);\n   else if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     offset = 0;\n   else\n@@ -10295,7 +10283,7 @@ pa_legitimate_constant_p (enum machine_mode mode, rtx x)\n       && !reload_in_progress\n       && !reload_completed\n       && !LEGITIMATE_64BIT_CONST_INT_P (INTVAL (x))\n-      && !cint_ok_for_move (INTVAL (x)))\n+      && !pa_cint_ok_for_move (INTVAL (x)))\n     return false;\n \n   if (function_label_operand (x, mode))"}, {"sha": "2f1295b0fbf2430cc792cc0fadd67e974dcdb6b1", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -162,11 +162,11 @@ extern unsigned long total_code_bytes;\n    the stack pointer at the function's entry.  Yuk!  */\n #define DEBUGGER_AUTO_OFFSET(X) \\\n   ((GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0) \\\n-    + (frame_pointer_needed ? 0 : compute_frame_size (get_frame_size (), 0)))\n+    + (frame_pointer_needed ? 0 : pa_compute_frame_size (get_frame_size (), 0)))\n \n #define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n   ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n-    + (frame_pointer_needed ? 0 : compute_frame_size (get_frame_size (), 0)))\n+    + (frame_pointer_needed ? 0 : pa_compute_frame_size (get_frame_size (), 0)))\n \n #define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n@@ -457,7 +457,7 @@ extern rtx hppa_pic_save_rtx (void);\n       {\t\t\t\t\t\t\t\t\t\\\n \tfputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\t\\\n \tif ((ENCODING) & DW_EH_PE_indirect)\t\t\t\t\\\n-\t  output_addr_const (FILE, get_deferred_plabel (ADDR));\t\t\\\n+\t  output_addr_const (FILE, pa_get_deferred_plabel (ADDR));\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  assemble_name (FILE, XSTR ((ADDR), 0));\t\t\t\\\n \tfputs (\"+8-$PIC_pcrel$0\", FILE);\t\t\t\t\\\n@@ -661,7 +661,8 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n \n /* If defined, a C expression which determines whether, and in which\n    direction, to pad out an argument with extra space.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding ((MODE), (TYPE))\n+#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n+  pa_function_arg_padding ((MODE), (TYPE))\n \n /* Specify padding for the last element of a block move between registers\n    and memory.\n@@ -673,7 +674,7 @@ struct hppa_args {int words, nargs_prototype, incoming, indirect; };\n    so that there is only one element.  This allows the object to be\n    correctly padded.  */\n #define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  function_arg_padding ((MODE), (TYPE))\n+  pa_function_arg_padding ((MODE), (TYPE))\n \n \f\n /* On HPPA, we emit profiling code as rtl via PROFILE_HOOK rather than\n@@ -793,7 +794,8 @@ extern int may_call_alloca;\n    || (GET_CODE (X) == SYMBOL_REF && !SYMBOL_REF_TLS_MODEL (X))\t\t\\\n    || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n    || GET_CODE (X) == HIGH) \t\t\t\t\t\t\\\n-   && (reload_in_progress || reload_completed || ! symbolic_expression_p (X)))\n+   && (reload_in_progress || reload_completed\t\t\t\t\\\n+       || ! pa_symbolic_expression_p (X)))\n \n /* A C expression that is nonzero if we are using the new HP assembler.  */\n \n@@ -926,7 +928,7 @@ extern int may_call_alloca;\n    the REG_POINTER lossage can be fixed, it seems better canonicalize.\n \n    We initially break out scaled indexed addresses in canonical order\n-   in emit_move_sequence.  LEGITIMIZE_ADDRESS also canonicalizes\n+   in pa_emit_move_sequence.  LEGITIMIZE_ADDRESS also canonicalizes\n    scaled indexed addresses during RTL generation.  However, fold_rtx\n    has its own opinion on how the operands of a PLUS should be ordered.\n    If one of the operands is equivalent to a constant, it will make\n@@ -1183,7 +1185,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n   (TREE_CODE (DECL) == FUNCTION_DECL\t\t\t\t\t\\\n    || (TREE_CODE (DECL) == VAR_DECL\t\t\t\t\t\\\n        && TREE_READONLY (DECL) && ! TREE_SIDE_EFFECTS (DECL)\t\t\\\n-       && (! DECL_INITIAL (DECL) || ! reloc_needed (DECL_INITIAL (DECL))) \\\n+       && (! DECL_INITIAL (DECL) || ! pa_reloc_needed (DECL_INITIAL (DECL))) \\\n        && !flag_pic)\t\t\t\t\t\t\t\\\n    || CONSTANT_CLASS_P (DECL))\n \n@@ -1290,7 +1292,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n    get_attr_type will try to recognize the given insn, so make sure to\n    filter out things it will not accept -- SEQUENCE, USE and CLOBBER insns\n    in particular.  */\n-#define INSN_REFERENCES_ARE_DELAYED(X) (insn_refs_are_delayed (X))\n+#define INSN_REFERENCES_ARE_DELAYED(X) (pa_insn_refs_are_delayed (X))\n \n \f\n /* Control the assembler format that we output.  */\n@@ -1368,7 +1370,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n #define TARGET_ASM_GLOBALIZE_LABEL pa_globalize_label\n \n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n-  output_ascii ((FILE), (P), (SIZE))\n+  pa_output_ascii ((FILE), (P), (SIZE))\n \n /* Jump tables are always placed in the text section.  Technically, it\n    is possible to put them in the readonly data section when -mbig-switch\n@@ -1452,7 +1454,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n    M modifier to handle preincrement addressing for memory refs.\n    F modifier to handle preincrement addressing for fp memory refs */\n \n-#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+#define PRINT_OPERAND(FILE, X, CODE) pa_print_operand (FILE, X, CODE)\n \n \f\n /* Print a memory address as an operand to reference that memory location.  */\n@@ -1476,7 +1478,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n \tfputs (\"RR'\", FILE);\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tfputs (\"RT'\", FILE);\t\t\t\t\t\t\\\n-      output_global_address (FILE, XEXP (addr, 1), 0);\t\t\t\\\n+      pa_output_global_address (FILE, XEXP (addr, 1), 0);\t\t\\\n       fputs (\"(\", FILE);\t\t\t\t\t\t\\\n       output_operand (XEXP (addr, 0), 0);\t\t\t\t\\\n       fputs (\")\", FILE);\t\t\t\t\t\t\\\n@@ -1492,7 +1494,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n /* Find the return address associated with the frame given by\n    FRAMEADDR.  */\n #define RETURN_ADDR_RTX(COUNT, FRAMEADDR)\t\t\t\t \\\n-  (return_addr_rtx (COUNT, FRAMEADDR))\n+  (pa_return_addr_rtx (COUNT, FRAMEADDR))\n \n /* Used to mask out junk bits from the return address, such as\n    processor state, interrupt status, condition codes and the like.  */"}, {"sha": "1be614c3241955742e581410d0479c5f7787c465", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 172, "deletions": 172, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -180,7 +180,7 @@\n \t(attr_flag \"backward\"))])\n \n (define_delay (and (eq_attr \"type\" \"uncond_branch\")\n-\t\t   (not (match_test \"following_call (insn)\")))\n+\t\t   (not (match_test \"pa_following_call (insn)\")))\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n ;; Memory. Disregarding Cache misses, the Mustang memory times are:\n@@ -286,14 +286,14 @@\n \n ;; We have a bypass for all computations in the FP unit which feed an\n ;; FP store as long as the sizes are the same.\n-(define_bypass 2 \"W1,W2\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 9 \"W3\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 11 \"W4\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 13 \"W5\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 17 \"W6\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 2 \"W1,W2\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n+(define_bypass 9 \"W3\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n+(define_bypass 11 \"W4\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n+(define_bypass 13 \"W5\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n+(define_bypass 17 \"W6\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n \n ;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n-(define_bypass 4 \"W8,W12\" \"W10,W11\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 4 \"W8,W12\" \"W10,W11\" \"pa_fpstore_bypass_p\")\n \n ;; Function units for the 7100 and 7150.  The 7100/7150 can dual-issue\n ;; floating point computations with non-floating point computations (fp loads\n@@ -382,12 +382,12 @@\n \n ;; We have a bypass for all computations in the FP unit which feed an\n ;; FP store as long as the sizes are the same.\n-(define_bypass 1 \"X0\" \"X6,X7\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 7 \"X1\" \"X6,X7\" \"hppa_fpstore_bypass_p\")\n-(define_bypass 14 \"X2\" \"X6,X7\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 1 \"X0\" \"X6,X7\" \"pa_fpstore_bypass_p\")\n+(define_bypass 7 \"X1\" \"X6,X7\" \"pa_fpstore_bypass_p\")\n+(define_bypass 14 \"X2\" \"X6,X7\" \"pa_fpstore_bypass_p\")\n \n ;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n-(define_bypass 3 \"X4,X8\" \"X6,X7\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 3 \"X4,X8\" \"X6,X7\" \"pa_fpstore_bypass_p\")\n \n ;; The 7100LC has three floating-point units: ALU, MUL, and DIV.\n ;; There's no value in modeling the ALU and MUL separately though\n@@ -543,7 +543,7 @@\n   \"i1_7100lc,i1_7100lc+mem_7100lc\")\n \n ;; We have an \"anti-bypass\" for FP loads which feed an FP store.\n-(define_bypass 3 \"Y3,Y7,Y13,Y17\" \"Y5,Y6,Y11,Y12,Y15,Y16\" \"hppa_fpstore_bypass_p\")\n+(define_bypass 3 \"Y3,Y7,Y13,Y17\" \"Y5,Y6,Y11,Y12,Y15,Y16\" \"pa_fpstore_bypass_p\")\n \n ;; Scheduling for the PA8000 is somewhat different than scheduling for a\n ;; traditional architecture.\n@@ -1301,7 +1301,7 @@\n   \"\"\n   \"\n {\n-  emit_bcond_fp (operands);\n+  pa_emit_bcond_fp (operands);\n   DONE;\n }\")\n \n@@ -1316,7 +1316,7 @@\n   \"\"\n   \"\n {\n-  emit_bcond_fp (operands);\n+  pa_emit_bcond_fp (operands);\n   DONE;\n }\")\n \n@@ -1336,7 +1336,7 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, 0, insn);\n+  return pa_output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1365,7 +1365,7 @@\n   \"\"\n   \"*\n {\n-  return output_cbranch (operands, 1, insn);\n+  return pa_output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1392,7 +1392,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, 0, insn);\n+  return pa_output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1421,7 +1421,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, 1, insn);\n+  return pa_output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1447,7 +1447,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, 0, insn);\n+  return pa_output_cbranch (operands, 0, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1476,7 +1476,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_cbranch (operands, 1, insn);\n+  return pa_output_cbranch (operands, 1, insn);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1505,7 +1505,7 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, 0, insn, 0);\n+  return pa_output_bb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1533,7 +1533,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, 0, insn, 0);\n+  return pa_output_bb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1561,7 +1561,7 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, 1, insn, 0);\n+  return pa_output_bb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1589,7 +1589,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, 1, insn, 0);\n+  return pa_output_bb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1617,7 +1617,7 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, 0, insn, 1);\n+  return pa_output_bb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1645,7 +1645,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, 0, insn, 1);\n+  return pa_output_bb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1673,7 +1673,7 @@\n   \"\"\n   \"*\n {\n-  return output_bb (operands, 1, insn, 1);\n+  return pa_output_bb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1701,7 +1701,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bb (operands, 1, insn, 1);\n+  return pa_output_bb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1730,7 +1730,7 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, 0, insn, 0);\n+  return pa_output_bvb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1758,7 +1758,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, 0, insn, 0);\n+  return pa_output_bvb (operands, 0, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1786,7 +1786,7 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, 1, insn, 0);\n+  return pa_output_bvb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1814,7 +1814,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, 1, insn, 0);\n+  return pa_output_bvb (operands, 1, insn, 0);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1842,7 +1842,7 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, 0, insn, 1);\n+  return pa_output_bvb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1870,7 +1870,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, 0, insn, 1);\n+  return pa_output_bvb (operands, 0, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1898,7 +1898,7 @@\n   \"\"\n   \"*\n {\n-  return output_bvb (operands, 1, insn, 1);\n+  return pa_output_bvb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1926,7 +1926,7 @@\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_bvb (operands, 1, insn, 1);\n+  return pa_output_bvb (operands, 1, insn, 1);\n }\"\n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n@@ -1978,7 +1978,7 @@\n     output_asm_insn (\\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b,n .+%0\\\", xoperands);\n   else\n     output_asm_insn (\\\"ftest\\;add,tr %%r0,%%r0,%%r0\\;b .+%0\\\", xoperands);\n-  return output_lbranch (operands[0], insn, xdelay);\n+  return pa_output_lbranch (operands[0], insn, xdelay);\n }\"\n [(set_attr \"type\" \"fbranch\")\n  (set (attr \"length\")\n@@ -2022,7 +2022,7 @@\n     output_asm_insn (\\\"ftest\\;b,n .+%0\\\", xoperands);\n   else\n     output_asm_insn (\\\"ftest\\;b .+%0\\\", xoperands);\n-  return output_lbranch (operands[0], insn, xdelay);\n+  return pa_output_lbranch (operands[0], insn, xdelay);\n }\"\n [(set_attr \"type\" \"fbranch\")\n  (set (attr \"length\")\n@@ -2043,7 +2043,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SImode, 0))\n+  if (pa_emit_move_sequence (operands, SImode, 0))\n     DONE;\n }\")\n \n@@ -2055,7 +2055,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, SImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2072,7 +2072,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, SImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2089,7 +2089,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, SImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2624,7 +2624,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n   \"(!flag_pic || !symbolic_operand (operands[1], Pmode))\n-    && !is_function_label_plus_const (operands[1])\"\n+    && !pa_is_function_label_plus_const (operands[1])\"\n   \"*\n {\n   if (symbolic_operand (operands[1], Pmode))\n@@ -2656,7 +2656,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"!is_function_label_plus_const (operands[2])\"\n+  \"!pa_is_function_label_plus_const (operands[2])\"\n   \"*\n {\n   gcc_assert (!flag_pic || !symbolic_operand (operands[2], Pmode));\n@@ -2735,7 +2735,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, HImode, 0))\n+  if (pa_emit_move_sequence (operands, HImode, 0))\n     DONE;\n }\")\n \n@@ -2748,7 +2748,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, HImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, HImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2765,7 +2765,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, HImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, HImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2893,7 +2893,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, QImode, 0))\n+  if (pa_emit_move_sequence (operands, QImode, 0))\n     DONE;\n }\")\n \n@@ -2906,7 +2906,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, QImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, QImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -2923,7 +2923,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, QImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, QImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -3121,7 +3121,7 @@\n }\")\n \n ;; The operand constraints are written like this to support both compile-time\n-;; and run-time determined byte counts.  The expander and output_block_move\n+;; and run-time determined byte counts.  The expander and pa_output_block_move\n ;; only support compile-time determined counts at this time.\n ;;\n ;; If the count is run-time determined, the register with the byte count\n@@ -3238,7 +3238,7 @@\n    (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"!TARGET_64BIT && reload_completed\"\n-  \"* return output_block_move (operands, !which_alternative);\"\n+  \"* return pa_output_block_move (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_expand \"movmemdi\"\n@@ -3309,7 +3309,7 @@\n }\")\n \n ;; The operand constraints are written like this to support both compile-time\n-;; and run-time determined byte counts.  The expander and output_block_move\n+;; and run-time determined byte counts.  The expander and pa_output_block_move\n ;; only support compile-time determined counts at this time.\n ;;\n ;; If the count is run-time determined, the register with the byte count\n@@ -3426,7 +3426,7 @@\n    (use (match_operand:DI 5 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"TARGET_64BIT && reload_completed\"\n-  \"* return output_block_move (operands, !which_alternative);\"\n+  \"* return pa_output_block_move (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_expand \"setmemsi\"\n@@ -3540,7 +3540,7 @@\n    (use (match_operand:SI 3 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"!TARGET_64BIT && reload_completed\"\n-  \"* return output_block_clear (operands, !which_alternative);\"\n+  \"* return pa_output_block_clear (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_expand \"setmemdi\"\n@@ -3654,7 +3654,7 @@\n    (use (match_operand:DI 3 \"const_int_operand\" \"n,n\"))  ;alignment\n    (const_int 0)]\n   \"TARGET_64BIT && reload_completed\"\n-  \"* return output_block_clear (operands, !which_alternative);\"\n+  \"* return pa_output_block_clear (operands, !which_alternative);\"\n   [(set_attr \"type\" \"multi,multi\")])\n \f\n ;; Floating point move insns\n@@ -3675,7 +3675,7 @@\n    && operands[1] != CONST0_RTX (DFmode)\n    && !TARGET_64BIT\n    && !TARGET_SOFT_FLOAT\"\n-  \"* return (which_alternative == 0 ? output_move_double (operands)\n+  \"* return (which_alternative == 0 ? pa_output_move_double (operands)\n \t\t\t\t    : \\\"fldd%F1 %1,%0\\\");\"\n   [(set_attr \"type\" \"move,fpload\")\n    (set_attr \"length\" \"16,4\")])\n@@ -3701,7 +3701,7 @@\n \toperands[1] = force_const_mem (DFmode, operands[1]);\n     }\n \n-  if (emit_move_sequence (operands, DFmode, 0))\n+  if (pa_emit_move_sequence (operands, DFmode, 0))\n     DONE;\n }\")\n \n@@ -3714,7 +3714,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DFmode, operands[2]))\n+  if (pa_emit_move_sequence (operands, DFmode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -3731,7 +3731,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DFmode, operands[2]))\n+  if (pa_emit_move_sequence (operands, DFmode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -3756,8 +3756,8 @@\n        || operands[1] == CONST0_RTX (DFmode))\n       && !(REG_P (operands[0]) && REG_P (operands[1])\n \t   && FP_REG_P (operands[0]) ^ FP_REG_P (operands[1])))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n+    return pa_output_fp_move_double (operands);\n+  return pa_output_move_double (operands);\n }\"\n   [(set_attr \"type\" \"fpalu,move,fpstore,store,store,fpload,load,load,fpstore_load,store_fpload\")\n    (set_attr \"length\" \"4,8,4,8,16,4,8,16,12,12\")])\n@@ -3924,7 +3924,7 @@\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  return output_move_double (operands);\n+  return pa_output_move_double (operands);\n }\"\n   [(set_attr \"type\" \"move,store,store,load,load\")\n    (set_attr \"length\" \"8,8,16,8,16\")])\n@@ -3970,7 +3970,7 @@\n       && REGNO (operands[0]) >= 32)\n     FAIL;\n \n-  if (emit_move_sequence (operands, DImode, 0))\n+  if (pa_emit_move_sequence (operands, DImode, 0))\n     DONE;\n }\")\n \n@@ -3982,7 +3982,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, DImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -3999,7 +3999,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, DImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -4016,7 +4016,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, DImode, operands[2]))\n+  if (pa_emit_move_sequence (operands, DImode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -4052,7 +4052,7 @@\n \n       operands[0] = operand_subword (op0, 0, 0, DImode);\n       operands[1] = GEN_INT (INTVAL (op1) >> 32);\n-      output_asm_insn (singlemove_string (operands), operands);\n+      output_asm_insn (pa_singlemove_string (operands), operands);\n #endif\n       break;\n \n@@ -4063,7 +4063,7 @@\n \n       operands[0] = operand_subword (op0, 0, 0, DImode);\n       operands[1] = GEN_INT (CONST_DOUBLE_HIGH (op1));\n-      output_asm_insn (singlemove_string (operands), operands);\n+      output_asm_insn (pa_singlemove_string (operands), operands);\n       break;\n \n     default:\n@@ -4089,8 +4089,8 @@\n        || operands[1] == CONST0_RTX (DFmode))\n       && !(REG_P (operands[0]) && REG_P (operands[1])\n \t   && FP_REG_P (operands[0]) ^ FP_REG_P (operands[1])))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n+    return pa_output_fp_move_double (operands);\n+  return pa_output_move_double (operands);\n }\"\n   [(set_attr \"type\"\n     \"move,store,store,load,load,multi,fpalu,fpload,fpstore,fpstore_load,store_fpload\")\n@@ -4216,7 +4216,7 @@\n    && TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  return output_move_double (operands);\n+  return pa_output_move_double (operands);\n }\"\n   [(set_attr \"type\" \"move,store,store,load,load,multi\")\n    (set_attr \"length\" \"8,8,16,8,16,16\")])\n@@ -4257,7 +4257,7 @@\n   \"GET_CODE (operands[1]) == CONST_DOUBLE\n    && operands[1] != CONST0_RTX (SFmode)\n    && ! TARGET_SOFT_FLOAT\"\n-  \"* return (which_alternative == 0 ? singlemove_string (operands)\n+  \"* return (which_alternative == 0 ? pa_singlemove_string (operands)\n \t\t\t\t    : \\\" fldw%F1 %1,%0\\\");\"\n   [(set_attr \"type\" \"move,fpload\")\n    (set_attr \"length\" \"8,4\")])\n@@ -4276,7 +4276,7 @@\n       && REGNO (operands[0]) >= 32)\n     FAIL;\n \n-  if (emit_move_sequence (operands, SFmode, 0))\n+  if (pa_emit_move_sequence (operands, SFmode, 0))\n     DONE;\n }\")\n \n@@ -4289,7 +4289,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SFmode, operands[2]))\n+  if (pa_emit_move_sequence (operands, SFmode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -4306,7 +4306,7 @@\n   \"\"\n   \"\n {\n-  if (emit_move_sequence (operands, SFmode, operands[2]))\n+  if (pa_emit_move_sequence (operands, SFmode, operands[2]))\n     DONE;\n \n   /* We don't want the clobber emitted, so handle this ourselves.  */\n@@ -5026,7 +5026,7 @@\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 4 \"register_operand\" \"\"))]\n-  \"! cint_ok_for_move (INTVAL (operands[2]))\n+  \"! pa_cint_ok_for_move (INTVAL (operands[2]))\n    && VAL_14_BITS_P (INTVAL (operands[2]) >> 1)\"\n   [(set (match_dup 4) (plus:SI (match_dup 1) (match_dup 2)))\n    (set (match_dup 0) (plus:SI (match_dup 4) (match_dup 3)))]\n@@ -5045,7 +5045,7 @@\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n    (clobber (match_operand:SI 4 \"register_operand\" \"\"))]\n-  \"! cint_ok_for_move (INTVAL (operands[2]))\"\n+  \"! pa_cint_ok_for_move (INTVAL (operands[2]))\"\n   [(set (match_dup 4) (match_dup 2))\n    (set (match_dup 0) (plus:SI (mult:SI (match_dup 4) (match_dup 3))\n \t\t\t       (match_dup 1)))]\n@@ -5055,26 +5055,26 @@\n \n   /* Try dividing the constant by 2, then 4, and finally 8 to see\n      if we can get a constant which can be loaded into a register\n-     in a single instruction (cint_ok_for_move). \n+     in a single instruction (pa_cint_ok_for_move). \n \n      If that fails, try to negate the constant and subtract it\n      from our input operand.  */\n-  if (intval % 2 == 0 && cint_ok_for_move (intval / 2))\n+  if (intval % 2 == 0 && pa_cint_ok_for_move (intval / 2))\n     {\n       operands[2] = GEN_INT (intval / 2);\n       operands[3] = const2_rtx;\n     }\n-  else if (intval % 4 == 0 && cint_ok_for_move (intval / 4))\n+  else if (intval % 4 == 0 && pa_cint_ok_for_move (intval / 4))\n     {\n       operands[2] = GEN_INT (intval / 4);\n       operands[3] = GEN_INT (4);\n     }\n-  else if (intval % 8 == 0 && cint_ok_for_move (intval / 8))\n+  else if (intval % 8 == 0 && pa_cint_ok_for_move (intval / 8))\n     {\n       operands[2] = GEN_INT (intval / 8);\n       operands[3] = GEN_INT (8);\n     }\n-  else if (cint_ok_for_move (-intval))\n+  else if (pa_cint_ok_for_move (-intval))\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, operands[4], GEN_INT (-intval)));\n       emit_insn (gen_subsi3 (operands[0], operands[1], operands[4]));\n@@ -5328,9 +5328,9 @@\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 31))]\n   \"!TARGET_64BIT\"\n-  \"* return output_mul_insn (0, insn);\"\n+  \"* return pa_output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n@@ -5339,9 +5339,9 @@\n    (clobber (reg:SI 25))\n    (clobber (reg:SI 2))]\n   \"TARGET_64BIT\"\n-  \"* return output_mul_insn (0, insn);\"\n+  \"* return pa_output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -5416,7 +5416,7 @@\n       operands[5] = gen_rtx_REG (SImode, 31);\n       operands[4] = gen_reg_rtx (SImode);\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 0))\n+  if (GET_CODE (operands[2]) == CONST_INT && pa_emit_hpdiv_const (operands, 0))\n     DONE;\n }\")\n \n@@ -5430,9 +5430,9 @@\n    (clobber (reg:SI 31))]\n   \"!TARGET_64BIT\"\n   \"*\n-   return output_div_insn (operands, 0, insn);\"\n+   return pa_output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -5444,9 +5444,9 @@\n    (clobber (reg:SI 2))]\n   \"TARGET_64BIT\"\n   \"*\n-   return output_div_insn (operands, 0, insn);\"\n+   return pa_output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n@@ -5473,7 +5473,7 @@\n       operands[5] = gen_rtx_REG (SImode, 31);\n       operands[4] = gen_reg_rtx (SImode);\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT && emit_hpdiv_const (operands, 1))\n+  if (GET_CODE (operands[2]) == CONST_INT && pa_emit_hpdiv_const (operands, 1))\n     DONE;\n }\")\n \n@@ -5487,9 +5487,9 @@\n    (clobber (reg:SI 31))]\n   \"!TARGET_64BIT\"\n   \"*\n-   return output_div_insn (operands, 1, insn);\"\n+   return pa_output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -5501,9 +5501,9 @@\n    (clobber (reg:SI 2))]\n   \"TARGET_64BIT\"\n   \"*\n-   return output_div_insn (operands, 1, insn);\"\n+   return pa_output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n@@ -5540,9 +5540,9 @@\n    (clobber (reg:SI 31))]\n   \"!TARGET_64BIT\"\n   \"*\n-  return output_mod_insn (0, insn);\"\n+  return pa_output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n@@ -5553,9 +5553,9 @@\n    (clobber (reg:SI 2))]\n   \"TARGET_64BIT\"\n   \"*\n-  return output_mod_insn (0, insn);\"\n+  return pa_output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_src_operand\" \"\"))\n@@ -5592,9 +5592,9 @@\n    (clobber (reg:SI 31))]\n   \"!TARGET_64BIT\"\n   \"*\n-  return output_mod_insn (1, insn);\"\n+  return pa_output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n@@ -5605,9 +5605,9 @@\n    (clobber (reg:SI 2))]\n   \"TARGET_64BIT\"\n   \"*\n-  return output_mod_insn (1, insn);\"\n+  return pa_output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_millicode_call (insn)\"))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -5639,7 +5639,7 @@\n \t(and:DI (match_operand:DI 1 \"register_operand\" \"%?r,0\")\n \t\t(match_operand:DI 2 \"and_operand\" \"rO,P\")))]\n   \"TARGET_64BIT\"\n-  \"* return output_64bit_and (operands); \"\n+  \"* return pa_output_64bit_and (operands); \"\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"4\")])\n \n@@ -5650,7 +5650,7 @@\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%?r,0\")\n \t\t(match_operand:SI 2 \"and_operand\" \"rO,P\")))]\n   \"\"\n-  \"* return output_and (operands); \"\n+  \"* return pa_output_and (operands); \"\n   [(set_attr \"type\" \"binary,shift\")\n    (set_attr \"length\" \"4,4\")])\n \n@@ -5707,7 +5707,7 @@\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n \t\t(match_operand:DI 2 \"cint_ior_operand\" \"M,i\")))]\n   \"TARGET_64BIT\"\n-  \"* return output_64bit_ior (operands); \"\n+  \"* return pa_output_64bit_ior (operands); \"\n   [(set_attr \"type\" \"binary,shift\")\n    (set_attr \"length\" \"4,4\")])\n \n@@ -5733,7 +5733,7 @@\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n \t\t(match_operand:SI 2 \"cint_ior_operand\" \"M,i\")))]\n   \"\"\n-  \"* return output_ior (operands); \"\n+  \"* return pa_output_ior (operands); \"\n   [(set_attr \"type\" \"binary,shift\")\n    (set_attr \"length\" \"4,4\")])\n \n@@ -6711,14 +6711,14 @@\n (define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n-  \"hppa_expand_prologue ();DONE;\")\n+  \"pa_expand_prologue ();DONE;\")\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n   \"\"\n   \"\n {\n-  hppa_expand_epilogue ();\n+  pa_expand_epilogue ();\n   DONE;\n }\")\n \n@@ -6734,7 +6734,7 @@\n     x = gen_return ();\n   else\n     {\n-      hppa_expand_epilogue ();\n+      pa_expand_epilogue ();\n \n       /* EH returns bypass the normal return stub.  Thus, we must do an\n \t interspace branch to return from functions that call eh_return.\n@@ -6808,12 +6808,12 @@\n   if (get_attr_length (insn) < 16)\n     return \\\"b%* %l0\\\";\n \n-  return output_lbranch (operands[0], insn, 1);\n+  return pa_output_lbranch (operands[0], insn, 1);\n }\"\n   [(set_attr \"type\" \"uncond_branch\")\n    (set_attr \"pa_combine_type\" \"uncond_branch\")\n    (set (attr \"length\")\n-    (cond [(match_test \"jump_in_call_delay (insn)\")\n+    (cond [(match_test \"pa_jump_in_call_delay (insn)\")\n \t   (if_then_else (lt (abs (minus (match_dup 0)\n \t\t\t\t\t (plus (pc) (const_int 8))))\n \t\t\t     (const_int MAX_12BIT_OFFSET))\n@@ -7179,11 +7179,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[0], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_symref_pic\"\n   [(set (match_operand:SI 2 \"register_operand\" \"=&r\") (reg:SI 19))\n@@ -7256,11 +7256,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[0], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -7341,11 +7341,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[0], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_reg\"\n   [(call (mem:SI (reg:SI 22))\n@@ -7356,10 +7356,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+  return pa_output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -7434,10 +7434,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+  return pa_output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -7518,10 +7518,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, operands[0]);\n+  return pa_output_indirect_call (insn, operands[0]);\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -7643,11 +7643,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_val_symref_pic\"\n   [(set (match_operand:SI 3 \"register_operand\" \"=&r\") (reg:SI 19))\n@@ -7726,11 +7726,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -7817,11 +7817,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 0);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_val_reg\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -7833,10 +7833,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+  return pa_output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -7917,10 +7917,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n+  return pa_output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n@@ -8007,10 +8007,10 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  return output_indirect_call (insn, operands[1]);\n+  return pa_output_indirect_call (insn, operands[1]);\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_indirect_call (insn)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_indirect_call (insn)\"))])\n \n ;; Call subroutine returning any type.\n \n@@ -8100,11 +8100,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 1);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[0], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 1)\"))])\n \n (define_insn \"sibcall_internal_symref_64bit\"\n   [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n@@ -8115,11 +8115,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 1);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[0], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 1)\"))])\n \n (define_expand \"sibcall_value\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -8184,11 +8184,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 1);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 1)\"))])\n \n (define_insn \"sibcall_value_internal_symref_64bit\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -8200,11 +8200,11 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"TARGET_64BIT\"\n   \"*\n {\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 1);\n+  pa_output_arg_descriptor (insn);\n+  return pa_output_call (insn, operands[1], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+   (set (attr \"length\") (symbol_ref \"pa_attr_length_call (insn, 1)\"))])\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -8593,7 +8593,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(plus:SI (match_dup 0) (match_dup 1)))\n    (clobber (match_scratch:SI 4 \"=X,r,r\"))]\n   \"\"\n-  \"* return output_dbra (operands, insn, which_alternative); \"\n+  \"* return pa_output_dbra (operands, insn, which_alternative); \"\n ;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi\")\n  (set (attr \"length\")\n@@ -8676,7 +8676,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*m,!*q\")\n \t(match_dup 1))]\n   \"\"\n-\"* return output_movb (operands, insn, which_alternative, 0); \"\n+\"* return pa_output_movb (operands, insn, which_alternative, 0); \"\n ;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi,multi\")\n  (set (attr \"length\")\n@@ -8748,7 +8748,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*m,!*q\")\n \t(match_dup 1))]\n   \"\"\n-\"* return output_movb (operands, insn, which_alternative, 1); \"\n+\"* return pa_output_movb (operands, insn, which_alternative, 1); \"\n ;; Do not expect to understand this the first time through.\n [(set_attr \"type\" \"cbranch,multi,multi,multi\")\n  (set (attr \"length\")\n@@ -8817,7 +8817,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"(reload_completed && operands[0] == operands[1]) || operands[0] == operands[2]\"\n   \"*\n {\n-  return output_parallel_addb (operands, insn);\n+  return pa_output_parallel_addb (operands, insn);\n }\"\n [(set_attr \"type\" \"parallel_branch\")\n  (set (attr \"length\")\n@@ -8840,7 +8840,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, insn);\n+  return pa_output_parallel_movb (operands, insn);\n }\"\n [(set_attr \"type\" \"parallel_branch\")\n  (set (attr \"length\")\n@@ -8863,7 +8863,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, insn);\n+  return pa_output_parallel_movb (operands, insn);\n }\"\n [(set_attr \"type\" \"parallel_branch\")\n  (set (attr \"length\")\n@@ -8886,7 +8886,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, insn);\n+  return pa_output_parallel_movb (operands, insn);\n }\"\n [(set_attr \"type\" \"parallel_branch\")\n  (set (attr \"length\")\n@@ -8909,7 +8909,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   \"reload_completed\"\n   \"*\n {\n-  return output_parallel_movb (operands, insn);\n+  return pa_output_parallel_movb (operands, insn);\n }\"\n [(set_attr \"type\" \"parallel_branch\")\n  (set (attr \"length\")\n@@ -8933,7 +8933,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(plus (match_operand 4 \"register_operand\" \"f\")\n \t      (match_operand 5 \"register_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_SOFT_FLOAT\n-   && reload_completed && fmpyaddoperands (operands)\"\n+   && reload_completed && pa_fmpyaddoperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n@@ -8962,7 +8962,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(mult (match_operand 1 \"register_operand\" \"f\")\n \t      (match_operand 2 \"register_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_SOFT_FLOAT\n-   && reload_completed && fmpyaddoperands (operands)\"\n+   && reload_completed && pa_fmpyaddoperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n@@ -8991,7 +8991,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(minus (match_operand 4 \"register_operand\" \"f\")\n \t       (match_operand 5 \"register_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_SOFT_FLOAT\n-   && reload_completed && fmpysuboperands (operands)\"\n+   && reload_completed && pa_fmpysuboperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n@@ -9010,7 +9010,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t(mult (match_operand 1 \"register_operand\" \"f\")\n \t      (match_operand 2 \"register_operand\" \"f\")))]\n   \"TARGET_PA_11 && ! TARGET_SOFT_FLOAT\n-   && reload_completed && fmpysuboperands (operands)\"\n+   && reload_completed && pa_fmpysuboperands (operands)\"\n   \"*\n {\n   if (GET_MODE (operands[0]) == DFmode)\n@@ -9236,13 +9236,13 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   output_asm_insn (\\\"{comb|cmpb},<<,n %%r26,%%r31,.+%1\\\", xoperands);\n \n   /* Finally, call $$sh_func_adrs to extract the function's real add24.  */\n-  return output_millicode_call (insn,\n-\t\t\t\tgen_rtx_SYMBOL_REF (SImode,\n-\t\t\t\t\t\t    \\\"$$sh_func_adrs\\\"));\n+  return pa_output_millicode_call (insn,\n+\t\t\t\t   gen_rtx_SYMBOL_REF (SImode,\n+\t\t\t\t\t\t       \\\"$$sh_func_adrs\\\"));\n }\"\n   [(set_attr \"type\" \"multi\")\n    (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_millicode_call (insn)\")\n+\t(plus (symbol_ref \"pa_attr_length_millicode_call (insn)\")\n \t      (const_int 20)))])\n \n ;; On the PA, the PIC register is call clobbered, so it must"}, {"sha": "66eeecb35dd77480385579723f025431c0e41aeb", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -236,7 +236,7 @@ do {\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n   if (!FUNCTION_NAME_P (XSTR (FUN, 0)))\t\t\t\t\\\n-    hppa_encode_label (FUN);\t\t\t\t\t\\\n+    pa_encode_label (FUN);\t\t\t\t\t\\\n   ASM_OUTPUT_TYPE_DIRECTIVE (FILE, XSTR (FUN, 0), \"function\");\t\\\n } while (0)\n "}, {"sha": "1d5fa93b5a9c8d12a5c391489e981ad0a368fb0b", "filename": "gcc/config/pa/pa64-linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpa64-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-linux.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -37,7 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n     {\t\t\t\t\t\t\t\t\\\n       int fsize;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-      fsize = compute_frame_size (get_frame_size (), 0);\t\\\n+      fsize = pa_compute_frame_size (get_frame_size (), 0);\t\\\n       if ((TO) == FRAME_POINTER_REGNUM\t\t\t\t\\\n \t  && (FROM) == ARG_POINTER_REGNUM)\t\t\t\\\n \t{\t\t\t\t\t\t\t\\"}, {"sha": "962e2f6e8171b16870947eb6b15477e4b8fd10fb", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -59,14 +59,14 @@\n \n (define_predicate \"cint_ior_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"ior_mask_p (INTVAL (op))\")))\n+       (match_test \"pa_ior_mask_p (INTVAL (op))\")))\n \n ;; True iff OP is CONST_INT that can be moved in one instruction\n ;; into a general register.\n \n (define_predicate \"cint_move_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"cint_ok_for_move (INTVAL (op))\")))\n+       (match_test \"pa_cint_ok_for_move (INTVAL (op))\")))\n \n ;; True iff OP is a CONST0_RTX for MODE.\n \n@@ -91,7 +91,7 @@\n (define_predicate \"and_operand\"\n   (ior (match_operand 0 \"register_operand\")\n        (and (match_code \"const_int\")\n-\t    (match_test \"and_mask_p (INTVAL (op))\"))))\n+\t    (match_test \"pa_and_mask_p (INTVAL (op))\"))))\n \n ;; Return truth value of whether OP can be used as an operand in a\n ;; three operand arithmetic insn that accepts registers of mode MODE\n@@ -179,7 +179,7 @@\n \t  && ((REG_P (op) && REGNO (op) == 25)\n \t      || (CONST_INT_P (op)\n \t\t  && INTVAL (op) > 0 && INTVAL (op) < 16\n-\t\t  && magic_milli[INTVAL (op)])));\n+\t\t  && pa_magic_milli[INTVAL (op)])));\n })\n \n ;; True iff OP is a reloading floating point register\n@@ -304,7 +304,7 @@\n     return true;\n \n   if (CONST_INT_P (op))\n-    return cint_ok_for_move (INTVAL (op));\n+    return pa_cint_ok_for_move (INTVAL (op));\n \n   if (GET_MODE (op) != mode)\n     return false;\n@@ -452,7 +452,7 @@\n \n (define_predicate \"shadd_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"shadd_constant_p (INTVAL (op))\")))\n+       (match_test \"pa_shadd_constant_p (INTVAL (op))\")))\n \n ;; Return truth value of statement that OP is a symbolic memory operand.\n \n@@ -463,7 +463,7 @@\n     op = SUBREG_REG (op);\n   if (!MEM_P (op))\n     return false;\n-  return symbolic_expression_p (XEXP (op, 0));\n+  return pa_symbolic_expression_p (XEXP (op, 0));\n })\n \n ;; True iff OP is a symbolic operand."}, {"sha": "51476157fcae704c381d0cc72ddc7b6d9c0abb4d", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d61aba698e0d3e804159cf7057570dd244bfd/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=ae9d61aba698e0d3e804159cf7057570dd244bfd", "patch": "@@ -227,7 +227,7 @@ do {\t\t\t\t\t\t\t\t\\\n        tree id;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n        if (!function_label_operand (RTL, VOIDmode))\t\t\t\\\n-\t hppa_encode_label (RTL);\t\t\t\t\t\\\n+\t pa_encode_label (RTL);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n        name = targetm.strip_name_encoding (XSTR ((RTL), 0));\t\t\\\n        id = maybe_get_identifier (name);\t\t\t\t\\"}]}