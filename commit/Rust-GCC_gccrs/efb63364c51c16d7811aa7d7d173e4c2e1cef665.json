{"sha": "efb63364c51c16d7811aa7d7d173e4c2e1cef665", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZiNjMzNjRjNTFjMTZkNzgxMWFhN2Q3ZDE3M2U0YzJlMWNlZjY2NQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-10-04T17:32:06Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-10-04T17:32:06Z"}, "message": "expr.c (scalarize_intrinsic_call): Plug memory leak.\n\n2012-10-04  Tobias Burnus  <burnus@net-b.de>\n\n        * expr.c (scalarize_intrinsic_call): Plug memory leak.\n        * frontend-passes.c (gcc_assert): Extend assert.\n        * interface.c (gfc_compare_derived_types): Fix comparison.\n        (gfc_check_operator_interface): Move up to make this error\n        message reachable.\n        (get_sym_storage_size): Remove always-true checks.\n        * io.c (format_lex): Add comment.\n        (gfc_free_wait): Free memory.\n        * match.c (gfc_match_select_type): Ditto.\n        * matchexpr.c (match_level_3): Ditto.\n        * primary.c (match_string_constant): Ditto.\n        (match_actual_arg): Check return value.\n        * resolve.c (gfc_resolve_substring_charlen,\n        resolve_typebound_generic_call, resolve_typebound_function,\n        resolve_typebound_subroutine): Free memory.\n        * trans-types.c (gfc_get_derived_type): Remove always-true\n        * check.\n\nFrom-SVN: r192094", "tree": {"sha": "263258155d4031ec0367ac574033137c812ebaa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/263258155d4031ec0367ac574033137c812ebaa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efb63364c51c16d7811aa7d7d173e4c2e1cef665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb63364c51c16d7811aa7d7d173e4c2e1cef665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efb63364c51c16d7811aa7d7d173e4c2e1cef665", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb63364c51c16d7811aa7d7d173e4c2e1cef665/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35057bf7360505c67261d0a8b3650c0fb7ae0637", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35057bf7360505c67261d0a8b3650c0fb7ae0637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35057bf7360505c67261d0a8b3650c0fb7ae0637"}], "stats": {"total": 90, "additions": 64, "deletions": 26}, "files": [{"sha": "a861601e0c2957b48f0d7ac4c36c6d7cc89de056", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -1,3 +1,22 @@\n+2012-10-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* expr.c (scalarize_intrinsic_call): Plug memory leak.\n+\t* frontend-passes.c (gcc_assert): Extend assert.\n+\t* interface.c (gfc_compare_derived_types): Fix comparison.\n+\t(gfc_check_operator_interface): Move up to make this error\n+\tmessage reachable.\n+\t(get_sym_storage_size): Remove always-true checks.\n+\t* io.c (format_lex): Add comment.\n+\t(gfc_free_wait): Free memory.\n+\t* match.c (gfc_match_select_type): Ditto. \n+\t* matchexpr.c (match_level_3): Ditto.\n+\t* primary.c (match_string_constant): Ditto.\n+\t(match_actual_arg): Check return value.\n+\t* resolve.c (gfc_resolve_substring_charlen,\n+\tresolve_typebound_generic_call, resolve_typebound_function,\n+\tresolve_typebound_subroutine): Free memory.\n+\t* trans-types.c (gfc_get_derived_type): Remove always-true check.\n+\n 2012-10-02  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/54778"}, {"sha": "9ac0fc6858f96b5496a6eb00980e4e9281f23a7a", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -2059,6 +2059,8 @@ scalarize_intrinsic_call (gfc_expr *e)\n \n   free_expr0 (e);\n   *e = *expr;\n+  /* Free \"expr\" but not the pointers it contains.  */\n+  free (expr);\n   gfc_free_expr (old);\n   return SUCCESS;\n "}, {"sha": "0cba9112a08811c492c50ae3769c00e2106f03bc", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -1177,7 +1177,7 @@ optimize_trim (gfc_expr *e)\n   /* Set the end of the reference to the call to len_trim.  */\n \n   ref->u.ss.end = fcn;\n-  gcc_assert (*rr == NULL);\n+  gcc_assert (rr != NULL && *rr == NULL);\n   *rr = ref;\n   return true;\n }"}, {"sha": "fb3da1fb7baa88100d2e8004aa2ec50db9422ebd", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -449,7 +449,7 @@ gfc_compare_derived_types (gfc_symbol *derived1, gfc_symbol *derived2)\n       /* Make sure that link lists do not put this function into an \n \t endless recursive loop!  */\n       if (!(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n-\t    && !(dt1->ts.type == BT_DERIVED && derived1 == dt1->ts.u.derived)\n+\t    && !(dt2->ts.type == BT_DERIVED && derived2 == dt2->ts.u.derived)\n \t    && gfc_compare_types (&dt1->ts, &dt2->ts) == 0)\n \treturn 0;\n \n@@ -641,8 +641,12 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n \t\t\t\t&& op != INTRINSIC_NOT)\n       || (args == 2 && op == INTRINSIC_NOT))\n     {\n-      gfc_error (\"Operator interface at %L has the wrong number of arguments\",\n-\t\t &sym->declared_at);\n+      if (op == INTRINSIC_ASSIGN)\n+\tgfc_error (\"Assignment operator interface at %L must have \"\n+\t\t   \"two arguments\", &sym->declared_at);\n+      else\n+\tgfc_error (\"Operator interface at %L has the wrong number of arguments\",\n+\t\t   &sym->declared_at);\n       return false;\n     }\n \n@@ -656,12 +660,6 @@ gfc_check_operator_interface (gfc_symbol *sym, gfc_intrinsic_op op,\n \t\t     \"a SUBROUTINE\", &sym->declared_at);\n \t  return false;\n \t}\n-      if (args != 2)\n-\t{\n-\t  gfc_error (\"Assignment operator interface at %L must have \"\n-\t\t     \"two arguments\", &sym->declared_at);\n-\t  return false;\n-\t}\n \n       /* Allowed are (per F2003, 12.3.2.1.2 Defined assignments):\n \t - First argument an array with different rank than second,\n@@ -2149,7 +2147,7 @@ get_sym_storage_size (gfc_symbol *sym)\n     return 0;\n   for (i = 0; i < sym->as->rank; i++)\n     {\n-      if (!sym->as || sym->as->upper[i]->expr_type != EXPR_CONSTANT\n+      if (sym->as->upper[i]->expr_type != EXPR_CONSTANT\n \t  || sym->as->lower[i]->expr_type != EXPR_CONSTANT)\n \treturn 0;\n \n@@ -2224,9 +2222,7 @@ get_expr_storage_size (gfc_expr *e)\n \t  continue;\n \t}\n \n-      if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION\n-\t  && ref->u.ar.start && ref->u.ar.end && ref->u.ar.stride\n-\t  && ref->u.ar.as->upper)\n+      if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n \tfor (i = 0; i < ref->u.ar.dimen; i++)\n \t  {\n \t    long int start, end, stride;"}, {"sha": "447d03f0d503514c2d30c65aed12d09df14fdae8", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -243,6 +243,8 @@ format_lex (void)\n     {\n     case '-':\n       negative_flag = 1;\n+      /* Falls through.  */\n+\n     case '+':\n       c = next_char_not_space (&error);\n       if (!ISDIGIT (c))\n@@ -4117,6 +4119,7 @@ gfc_free_wait (gfc_wait *wait)\n   gfc_free_expr (wait->iostat);\n   gfc_free_expr (wait->iomsg);\n   gfc_free_expr (wait->id);\n+  free (wait);\n }\n \n "}, {"sha": "06585af94e99331ed38d5d774e197af80d266f0e", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -5325,6 +5325,7 @@ gfc_match_select_type (void)\n   char name[GFC_MAX_SYMBOL_LEN];\n   bool class_array;\n   gfc_symbol *sym;\n+  gfc_namespace *parent_ns;\n \n   m = gfc_match_label ();\n   if (m == MATCH_ERROR)\n@@ -5404,7 +5405,9 @@ gfc_match_select_type (void)\n   return MATCH_YES;\n   \n cleanup:\n-  gfc_current_ns = gfc_current_ns->parent;\n+  parent_ns = gfc_current_ns->parent;\n+  gfc_free_namespace (gfc_current_ns);\n+  gfc_current_ns = parent_ns;\n   return m;\n }\n "}, {"sha": "c1196a8802c015baa675701f05b0ed8faeb4d8bc", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -543,7 +543,7 @@ match_level_2 (gfc_expr **result)\n static match\n match_level_3 (gfc_expr **result)\n {\n-  gfc_expr *all, *e, *total;\n+  gfc_expr *all, *e, *total = NULL;\n   locus where;\n   match m;\n \n@@ -560,12 +560,12 @@ match_level_3 (gfc_expr **result)\n \n       m = match_level_2 (&e);\n       if (m == MATCH_NO)\n+\tgfc_error (expression_syntax);\n+      if (m != MATCH_YES)\n \t{\n-\t  gfc_error (expression_syntax);\n \t  gfc_free_expr (all);\n+\t  return MATCH_ERROR;\n \t}\n-      if (m != MATCH_YES)\n-\treturn MATCH_ERROR;\n \n       total = gfc_concat (all, e);\n       if (total == NULL)"}, {"sha": "7b64a3c6854e240cac78a90ce02234c00c753c1f", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -1087,6 +1087,7 @@ match_string_constant (gfc_expr **result)\n \n       if (!gfc_check_character_range (c, kind))\n \t{\n+\t  gfc_free_expr (e);\n \t  gfc_error (\"Character '%s' in string at %C is not representable \"\n \t\t     \"in character kind %d\", gfc_print_wide_char (c), kind);\n \t  return MATCH_ERROR;\n@@ -1507,8 +1508,9 @@ match_actual_arg (gfc_expr **result)\n \n \t  if (sym->attr.in_common && !sym->attr.proc_pointer)\n \t    {\n-\t      gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name,\n-\t\t\t      &sym->declared_at);\n+\t      if (gfc_add_flavor (&sym->attr, FL_VARIABLE, sym->name,\n+\t\t\t\t  &sym->declared_at) == FAILURE)\n+\t\treturn MATCH_ERROR;\n \t      break;\n \t    }\n "}, {"sha": "7c30cba9756d33ca65ee2525f6d13d42befa5012", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -4964,7 +4964,11 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n     end = NULL;\n \n   if (!start || !end)\n-    return;\n+    {\n+      gfc_free_expr (start);\n+      gfc_free_expr (end);\n+      return;\n+    }\n \n   /* Length = (end - start +1).  */\n   e->ts.u.cl->length = gfc_subtract (end, start);\n@@ -6004,7 +6008,10 @@ resolve_typebound_generic_call (gfc_expr* e, const char **name)\n \t      gfc_expr* po;\n \t      po = extract_compcall_passed_object (e);\n \t      if (!po)\n-\t\treturn FAILURE;\n+\t\t{\n+\t\t  gfc_free_actual_arglist (args);\n+\t\t  return FAILURE;\n+\t\t}\n \n \t      gcc_assert (g->specific->pass_arg_num > 0);\n \t      gcc_assert (!g->specific->error);\n@@ -6253,7 +6260,10 @@ resolve_typebound_function (gfc_expr* e)\n   /* Treat the call as if it is a typebound procedure, in order to roll\n      out the correct name for the specific function.  */\n   if (resolve_compcall (e, &name) == FAILURE)\n-    return FAILURE;\n+    {\n+      gfc_free_ref_list (new_ref);\n+      return FAILURE;\n+    }\n   ts = e->ts;\n \n   if (overridable)\n@@ -6374,7 +6384,10 @@ resolve_typebound_subroutine (gfc_code *code)\n     }\n \n   if (resolve_typebound_call (code, &name) == FAILURE)\n-    return FAILURE;\n+    {\n+      gfc_free_ref_list (new_ref);\n+      return FAILURE;\n+    }\n   ts = code->expr1->ts;\n \n   if (overridable)"}, {"sha": "81b7fa5ca27f8515b633cdd92023d1415af4134c", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efb63364c51c16d7811aa7d7d173e4c2e1cef665/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=efb63364c51c16d7811aa7d7d173e4c2e1cef665", "patch": "@@ -2445,7 +2445,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t  || c->ts.u.derived->backend_decl == NULL)\n \tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived);\n \n-      if (c->ts.u.derived && c->ts.u.derived->attr.is_iso_c)\n+      if (c->ts.u.derived->attr.is_iso_c)\n         {\n           /* Need to copy the modified ts from the derived type.  The\n              typespec was modified because C_PTR/C_FUNPTR are translated"}]}