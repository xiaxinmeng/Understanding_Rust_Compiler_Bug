{"sha": "77ad54d911dd7cb88caf697ac213929f6132fdcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdhZDU0ZDkxMWRkN2NiODhjYWY2OTdhYzIxMzkyOWY2MTMyZmRjZg==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2014-12-04T19:40:50Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2014-12-04T19:40:50Z"}, "message": "x86-64: Optimize access to globals in PIE with copy reloc\n\nNormally, with -fPIE/-fpie, GCC accesses globals that are extern to the\nmodule using the GOT.  This is two instructions, one to get the address\nof the global from the GOT and the other to get the value.  If it turns\nout that the global gets defined in the executable at link-time, it still\nneeds to go through the GOT as it is too late then to generate a direct\n access.\n\nExamples:\n\nfoo.cc\n------\nint a_glob;\nint main () {\n  return a_glob; // defined in this file\n}\n\nWith -O2 -fpie -pie, the generated code directly accesses the global via\nPC-relative insn:\n\n5e0   <main>:\n   mov    0x165a(%rip),%eax        # 1c40 <a_glob>\n\nfoo.cc\n------\n\nextern int a_glob;\nint main () {\n  return a_glob; // defined in this file\n}\n\nWith -O2 -fpie -pie, the generated code accesses global via GOT using\ntwo memory loads:\n\n6f0  <main>:\n   mov    0x1609(%rip),%rax   # 1d00 <_DYNAMIC+0x230>\n   mov    (%rax),%eax\n\nThis is true even if in the latter case the global was defined in the\nexecutable through a different file.\n\nSome experiments on google benchmarks shows that the extra memory loads\naffects performance by 1% to 5%.\n\nSolution - Copy Relocations:\n\nWhen the linker supports copy relocations, GCC can always assume that\nthe global will be defined in the executable.  For globals that are truly\nextern (come from shared objects), the linker will create copy relocations\nand have them defined in the executable. Result is that no global access\nneeds to go through the GOT and hence improves performance.\n\nThis optimization only applies to undefined, non-weak global data.\nUndefined, weak global data access still must go through the GOT.\n\nThis patch checks if linker supports PIE with copy reloc, which is\nenabled in gold and bfd linker in bininutils 2.25, at configure time\nand enables this optimization if the linker support is available.\n\ngcc/\n\n\t* configure.ac (HAVE_LD_PIE_COPYRELOC): Defined to 1 if\n\tLinux/x86-64 linker supports PIE with copy reloc.\n\t* config.in: Regenerated.\n\t* configure: Likewise.\n\n\t* config/i386/i386.c (legitimate_pic_address_disp_p): Allow\n\tpc-relative address for undefined, non-weak, non-function\n\tsymbol reference in 64-bit PIE if linker supports PIE with\n\tcopy reloc.\n\n\t* doc/sourcebuild.texi: Document pie_copyreloc target.\n\ngcc/testsuite/\n\n\t* gcc.target/i386/pie-copyrelocs-1.c: New test.\n\t* gcc.target/i386/pie-copyrelocs-2.c: Likewise.\n\t* gcc.target/i386/pie-copyrelocs-3.c: Likewise.\n\t* gcc.target/i386/pie-copyrelocs-4.c: Likewise.\n\n\t* lib/target-supports.exp (check_effective_target_pie_copyreloc):\n\tNew procedure.\n\nCo-Authored-By: H.J. Lu <hongjiu.lu@intel.com>\n\nFrom-SVN: r218397", "tree": {"sha": "dfb0a4ba0d6eed5352695a1798710724f7b48fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfb0a4ba0d6eed5352695a1798710724f7b48fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77ad54d911dd7cb88caf697ac213929f6132fdcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ad54d911dd7cb88caf697ac213929f6132fdcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ad54d911dd7cb88caf697ac213929f6132fdcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ad54d911dd7cb88caf697ac213929f6132fdcf/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3119ac2925882e0e7b30984d71093eef349cabcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3119ac2925882e0e7b30984d71093eef349cabcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3119ac2925882e0e7b30984d71093eef349cabcc"}], "stats": {"total": 241, "additions": 240, "deletions": 1}, "files": [{"sha": "18b481e11a0dbc69ec430c8f4f6bdf67f7ae3550", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -1,3 +1,18 @@\n+2014-12-04  Sriraman Tallam  <tmsriram@google.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* configure.ac (HAVE_LD_PIE_COPYRELOC): Defined to 1 if\n+\tLinux/x86-64 linker supports PIE with copy reloc.\n+\t* config.in: Regenerated.\n+\t* configure: Likewise.\n+\n+\t* config/i386/i386.c (legitimate_pic_address_disp_p): Allow\n+\tpc-relative address for undefined, non-weak, non-function\n+\tsymbol reference in 64-bit PIE if linker supports PIE with\n+\tcopy reloc.\n+\n+\t* doc/sourcebuild.texi: Document pie_copyreloc target.\n+\n 2014-12-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/56917"}, {"sha": "f34adb57e6ddd9a71f4ed53bafb7c1f080e17d18", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -1411,6 +1411,12 @@\n #endif\n \n \n+/* Define 0/1 if your linker supports -pie option with copy reloc. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_LD_PIE_COPYRELOC\n+#endif\n+\n+\n /* Define if your linker links a mix of read-only and read-write sections into\n    a read-write section. */\n #ifndef USED_FOR_TARGET"}, {"sha": "4f1a18b993a7ca5ea6c3cb0593794a20f456c090", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -13113,7 +13113,11 @@ legitimate_pic_address_disp_p (rtx disp)\n \t\treturn true;\n \t    }\n \t  else if (!SYMBOL_REF_FAR_ADDR_P (op0)\n-\t\t   && SYMBOL_REF_LOCAL_P (op0)\n+\t\t   && (SYMBOL_REF_LOCAL_P (op0)\n+\t\t       || (HAVE_LD_PIE_COPYRELOC\n+\t\t\t   && flag_pie\n+\t\t\t   && !SYMBOL_REF_WEAK (op0)\n+\t\t\t   && !SYMBOL_REF_FUNCTION_P (op0)))\n \t\t   && ix86_cmodel != CM_LARGE_PIC)\n \t    return true;\n \t  break;"}, {"sha": "811f05dc78a583f2c8adc001834c476ab0edd4d7", "filename": "gcc/configure", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -27025,6 +27025,53 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_pie\" >&5\n $as_echo \"$gcc_cv_ld_pie\" >&6; }\n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking linker PIE support with copy reloc\" >&5\n+$as_echo_n \"checking linker PIE support with copy reloc... \" >&6; }\n+gcc_cv_ld_pie_copyreloc=no\n+if test $gcc_cv_ld_pie = yes ; then\n+  if test $in_tree_ld = yes ; then\n+    if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 25 -o \"$gcc_cv_gld_major_version\" -gt 2; then\n+      gcc_cv_ld_pie_copyreloc=yes\n+    fi\n+  elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+    # Check if linker supports -pie option with copy reloc\n+    case \"$target\" in\n+    i?86-*-linux* | x86_64-*-linux*)\n+      cat > conftest1.s <<EOF\n+\t.globl\ta_glob\n+\t.data\n+\t.type\ta_glob, @object\n+\t.size\ta_glob, 4\n+a_glob:\n+\t.long\t2\n+EOF\n+      cat > conftest2.s <<EOF\n+\t.text\n+\t.globl\tmain\n+\t.type\tmain, @function\n+main:\n+\tmovl\t%eax, a_glob(%rip)\n+\t.size\tmain, .-main\n+EOF\n+      if $gcc_cv_as --64 -o conftest1.o conftest1.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -shared -melf_x86_64 -o conftest1.so conftest1.o > /dev/null 2>&1 \\\n+         && $gcc_cv_as --64 -o conftest2.o conftest2.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -pie -melf_x86_64 -o conftest conftest2.o conftest1.so > /dev/null 2>&1; then\n+        gcc_cv_ld_pie_copyreloc=yes\n+      fi\n+      rm -f conftest conftest1.so conftest1.o conftest2.o conftest1.s conftest2.s\n+      ;;\n+    esac\n+  fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_LD_PIE_COPYRELOC `if test x\"$gcc_cv_ld_pie_copyreloc\" = xyes; then echo 1; else echo 0; fi`\n+_ACEOF\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_ld_pie_copyreloc\" >&5\n+$as_echo \"$gcc_cv_ld_pie_copyreloc\" >&6; }\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking linker EH-compatible garbage collection of sections\" >&5\n $as_echo_n \"checking linker EH-compatible garbage collection of sections... \" >&6; }\n gcc_cv_ld_eh_gc_sections=no"}, {"sha": "a33f3a57bb4d87b0e81e63ab5948d7f8b86c7b2c", "filename": "gcc/configure.ac", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -4693,6 +4693,49 @@ if test x\"$gcc_cv_ld_pie\" = xyes; then\n fi\n AC_MSG_RESULT($gcc_cv_ld_pie)\n \n+AC_MSG_CHECKING(linker PIE support with copy reloc)\n+gcc_cv_ld_pie_copyreloc=no\n+if test $gcc_cv_ld_pie = yes ; then\n+  if test $in_tree_ld = yes ; then\n+    if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 25 -o \"$gcc_cv_gld_major_version\" -gt 2; then\n+      gcc_cv_ld_pie_copyreloc=yes\n+    fi\n+  elif test x$gcc_cv_as != x -a x$gcc_cv_ld != x ; then\n+    # Check if linker supports -pie option with copy reloc\n+    case \"$target\" in\n+    i?86-*-linux* | x86_64-*-linux*)\n+      cat > conftest1.s <<EOF\n+\t.globl\ta_glob\n+\t.data\n+\t.type\ta_glob, @object\n+\t.size\ta_glob, 4\n+a_glob:\n+\t.long\t2\n+EOF\n+      cat > conftest2.s <<EOF\n+\t.text\n+\t.globl\tmain\n+\t.type\tmain, @function\n+main:\n+\tmovl\t%eax, a_glob(%rip)\n+\t.size\tmain, .-main\n+EOF\n+      if $gcc_cv_as --64 -o conftest1.o conftest1.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -shared -melf_x86_64 -o conftest1.so conftest1.o > /dev/null 2>&1 \\\n+         && $gcc_cv_as --64 -o conftest2.o conftest2.s > /dev/null 2>&1 \\\n+         && $gcc_cv_ld -pie -melf_x86_64 -o conftest conftest2.o conftest1.so > /dev/null 2>&1; then\n+        gcc_cv_ld_pie_copyreloc=yes\n+      fi\n+      rm -f conftest conftest1.so conftest1.o conftest2.o conftest1.s conftest2.s\n+      ;;\n+    esac\n+  fi\n+  AC_DEFINE_UNQUOTED(HAVE_LD_PIE_COPYRELOC,\n+    [`if test x\"$gcc_cv_ld_pie_copyreloc\" = xyes; then echo 1; else echo 0; fi`],\n+    [Define 0/1 if your linker supports -pie option with copy reloc.])\n+fi\n+AC_MSG_RESULT($gcc_cv_ld_pie_copyreloc)\n+\n AC_MSG_CHECKING(linker EH-compatible garbage collection of sections)\n gcc_cv_ld_eh_gc_sections=no\n if test $in_tree_ld = yes ; then"}, {"sha": "98ba1a67c2a7921184542a5ce00639bda827922d", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -1717,6 +1717,9 @@ or @code{EM_SPARCV9} executables.\n \n @item vect_cmdline_needed\n Target requires a command line argument to enable a SIMD instruction set.\n+\n+@item pie_copyreloc\n+The x86-64 target linker supports PIE with copy reloc.\n @end table\n \n @subsubsection Environment attributes"}, {"sha": "295a8103accf465eb17630243fde228a1eef70d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -1,3 +1,14 @@\n+2014-12-04  Sriraman Tallam  <tmsriram@google.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/pie-copyrelocs-1.c: New test.\n+\t* gcc.target/i386/pie-copyrelocs-2.c: Likewise.\n+\t* gcc.target/i386/pie-copyrelocs-3.c: Likewise.\n+\t* gcc.target/i386/pie-copyrelocs-4.c: Likewise.\n+\n+\t* lib/target-supports.exp (check_effective_target_pie_copyreloc):\n+\tNew procedure.\n+\n 2014-12-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/56917"}, {"sha": "7af851bde9bc0ea23724317f0bbeebb0fe081a49", "filename": "gcc/testsuite/gcc.target/i386/pie-copyrelocs-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-1.c?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -0,0 +1,14 @@\n+/* Check that GOTPCREL isn't used to access glob_a.  */\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-require-effective-target pie_copyreloc } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+extern int glob_a;\n+\n+int foo ()\n+{\n+  return glob_a;\n+}\n+\n+/* glob_a should never be accessed with a GOTPCREL.  */\n+/* { dg-final { scan-assembler-not \"glob_a@GOTPCREL\" { target { ! ia32 } } } } */"}, {"sha": "19cb97e882c69e0c079ccaa381f0ca04e5b382a5", "filename": "gcc/testsuite/gcc.target/i386/pie-copyrelocs-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-2.c?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -0,0 +1,14 @@\n+/* Check that GOTPCREL isn't used to access glob_a.  */\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-require-effective-target pie_copyreloc } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+int glob_a;\n+\n+int foo ()\n+{\n+  return glob_a;\n+}\n+\n+/* glob_a should never be accessed with a GOTPCREL.  */\n+/* { dg-final { scan-assembler-not \"glob_a@GOTPCREL\" { target { ! ia32 } } } } */"}, {"sha": "c2fa8968e7732e510aafdd4a3c0183168b295c4d", "filename": "gcc/testsuite/gcc.target/i386/pie-copyrelocs-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-3.c?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -0,0 +1,14 @@\n+/* Check that PLT is used to access glob_a.  */\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-require-effective-target pie_copyreloc } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+extern int glob_a (void);\n+\n+int foo ()\n+{\n+  return glob_a ();\n+}\n+\n+/* glob_a should be accessed with a PLT.  */\n+/* { dg-final { scan-assembler \"glob_a@PLT\" { target { ! ia32 } } } } */"}, {"sha": "413cdf381c3a1ba6546ba21c0445b11b73f3748d", "filename": "gcc/testsuite/gcc.target/i386/pie-copyrelocs-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpie-copyrelocs-4.c?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -0,0 +1,17 @@\n+/* Check that GOTPCREL is used to access glob_a.  */\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-require-effective-target pie_copyreloc } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+extern int glob_a  __attribute__((weak));\n+\n+int foo ()\n+{\n+  if (&glob_a != 0)\n+    return glob_a;\n+  else\n+    return 0;\n+}\n+\n+/* weak glob_a should be accessed with a GOTPCREL.  */\n+/* { dg-final { scan-assembler \"glob_a@GOTPCREL\" { target { ! ia32 } } } } */"}, {"sha": "4846724378b70c64916e4010c194d21ae5258882", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ad54d911dd7cb88caf697ac213929f6132fdcf/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=77ad54d911dd7cb88caf697ac213929f6132fdcf", "patch": "@@ -6098,3 +6098,54 @@ proc force_conventional_output_for { test } {\n     }\n }\n \n+# Return 1 if the x86-64 target supports PIE with copy reloc, 0\n+# otherwise.  Cache the result.\n+\n+proc check_effective_target_pie_copyreloc { } {\n+    global pie_copyreloc_available_saved\n+    global tool\n+    global GCC_UNDER_TEST\n+\n+    if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {\n+\treturn 0\n+    }\n+\n+    # Need auto-host.h to check linker support.\n+    if { ![file exists ../../auto-host.h ] } {\n+\treturn 0\n+    }\n+\n+    if [info exists pie_copyreloc_available_saved] {\n+\tverbose \"check_effective_target_pie_copyreloc returning saved $pie_copyreloc_available_saved\" 2\n+    } else {\n+\t# Set up and compile to see if linker supports PIE with copy\n+\t# reloc.  Include the current process ID in the file names to\n+\t# prevent conflicts with invocations for multiple testsuites.\n+\n+\tset src pie[pid].c\n+\tset obj pie[pid].o\n+\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include \\\"../../auto-host.h\\\"\"\n+\tputs $f \"#if HAVE_LD_PIE_COPYRELOC == 0\"\n+\tputs $f \"# error Linker does not support PIE with copy reloc.\"\n+\tputs $f \"#endif\"\n+\tclose $f\n+\n+\tverbose \"check_effective_target_pie_copyreloc compiling testfile $src\" 2\n+\tset lines [${tool}_target_compile $src $obj object \"\"]\n+\n+\tfile delete $src\n+\tfile delete $obj\n+\n+\tif [string match \"\" $lines] then {\n+\t    verbose \"check_effective_target_pie_copyreloc testfile compilation passed\" 2\n+\t    set pie_copyreloc_available_saved 1\n+\t} else {\n+\t    verbose \"check_effective_target_pie_copyreloc testfile compilation failed\" 2\n+\t    set pie_copyreloc_available_saved 0\n+\t}\n+    }\n+\n+    return $pie_copyreloc_available_saved\n+}"}]}