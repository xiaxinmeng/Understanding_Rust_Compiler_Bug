{"sha": "f2b63869e3f184f3092f549caadb89f0f12416ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJiNjM4NjllM2YxODRmMzA5MmY1NDljYWFkYjg5ZjBmMTI0MTZhYg==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T19:54:42Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T19:54:42Z"}, "message": "Initial revision\n\nFrom-SVN: r1465", "tree": {"sha": "b7ebef6c2f0776a53bbb971926d2487f71ad91e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7ebef6c2f0776a53bbb971926d2487f71ad91e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2b63869e3f184f3092f549caadb89f0f12416ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b63869e3f184f3092f549caadb89f0f12416ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2b63869e3f184f3092f549caadb89f0f12416ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2b63869e3f184f3092f549caadb89f0f12416ab/comments", "author": null, "committer": null, "parents": [{"sha": "a9f95fb69678bb804dc17448dd5b4fb30d6f5f3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9f95fb69678bb804dc17448dd5b4fb30d6f5f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9f95fb69678bb804dc17448dd5b4fb30d6f5f3a"}], "stats": {"total": 896, "additions": 896, "deletions": 0}, "files": [{"sha": "90d867e0819b06824735ec86658bffcd0ff4bf73", "filename": "gcc/cexp.y", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2b63869e3f184f3092f549caadb89f0f12416ab/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2b63869e3f184f3092f549caadb89f0f12416ab/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=f2b63869e3f184f3092f549caadb89f0f12416ab", "patch": "@@ -0,0 +1,896 @@\n+/* Parse C expressions for CCCP.\n+   Copyright (C) 1987, 1992 Free Software Foundation.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!\n+\n+ Adapted from expread.y of GDB by Paul Rubin, July 1986.\n+\n+/* Parse a C expression from text in a string  */\n+   \n+%{\n+#include \"config.h\"\n+#include <setjmp.h>\n+/* #define YYDEBUG 1 */\n+\n+#ifdef MULTIBYTE_CHARS\n+#include <stdlib.h>\n+#include <locale.h>\n+#endif\n+\n+typedef unsigned char U_CHAR;\n+\n+/* This is used for communicating lists of keywords with cccp.c.  */\n+struct arglist {\n+  struct arglist *next;\n+  U_CHAR *name;\n+  int length;\n+  int argno;\n+};\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR (char *) NULL\n+#endif\n+\n+int yylex ();\n+void yyerror ();\n+int expression_value;\n+\n+static jmp_buf parse_return_error;\n+\n+/* Nonzero means count most punctuation as part of a name.  */\n+static int keyword_parsing = 0;\n+\n+/* some external tables of character types */\n+extern unsigned char is_idstart[], is_idchar[], is_hor_space[];\n+\n+/* Flag for -pedantic.  */\n+extern int pedantic;\n+\n+/* Flag for -traditional.  */\n+extern int traditional;\n+\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE INT_TYPE_SIZE\n+#endif\n+%}\n+\n+%union {\n+  struct constant {long value; int unsignedp;} integer;\n+  struct name {U_CHAR *address; int length;} name;\n+  struct arglist *keywords;\n+  int voidval;\n+  char *sval;\n+}\n+\n+%type <integer> exp exp1 start\n+%type <keywords> keywords\n+%token <integer> INT CHAR\n+%token <name> NAME\n+%token <integer> ERROR\n+\n+%right '?' ':'\n+%left ','\n+%left OR\n+%left AND\n+%left '|'\n+%left '^'\n+%left '&'\n+%left EQUAL NOTEQUAL\n+%left '<' '>' LEQ GEQ\n+%left LSH RSH\n+%left '+' '-'\n+%left '*' '/' '%'\n+%right UNARY\n+\n+/* %expect 40 */\n+\f\n+%%\n+\n+start   :\texp1\n+\t\t{ expression_value = $1.value; }\n+\t;\n+\n+/* Expressions, including the comma operator.  */\n+exp1\t:\texp\n+\t|\texp1 ',' exp\n+\t\t\t{ if (pedantic)\n+\t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n+\t\t\t  $$ = $3; }\n+\t;\n+\n+/* Expressions, not including the comma operator.  */\n+exp\t:\t'-' exp    %prec UNARY\n+\t\t\t{ $$.value = - $2.value;\n+\t\t\t  $$.unsignedp = $2.unsignedp; }\n+\t|\t'!' exp    %prec UNARY\n+\t\t\t{ $$.value = ! $2.value;\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\t'+' exp    %prec UNARY\n+\t\t\t{ $$ = $2; }\n+\t|\t'~' exp    %prec UNARY\n+\t\t\t{ $$.value = ~ $2.value;\n+\t\t\t  $$.unsignedp = $2.unsignedp; }\n+\t|\t'#' NAME\n+  \t\t\t{ $$.value = check_assertion ($2.address, $2.length,\n+\t\t\t\t\t\t      0, NULL_PTR);\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\t'#' NAME\n+\t\t\t{ keyword_parsing = 1; }\n+\t\t'(' keywords ')'\n+  \t\t\t{ $$.value = check_assertion ($2.address, $2.length,\n+\t\t\t\t\t\t      1, $5);\n+\t\t\t  keyword_parsing = 0;\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\t'(' exp1 ')'\n+\t\t\t{ $$ = $2; }\n+\t;\n+\n+/* Binary operators in order of decreasing precedence.  */\n+exp\t:\texp '*' exp\n+\t\t\t{ $$.unsignedp = $1.unsignedp || $3.unsignedp;\n+\t\t\t  if ($$.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value * $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value * $3.value; }\n+\t|\texp '/' exp\n+\t\t\t{ if ($3.value == 0)\n+\t\t\t    {\n+\t\t\t      error (\"division by zero in #if\");\n+\t\t\t      $3.value = 1;\n+\t\t\t    }\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n+\t\t\t  if ($$.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value / $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value / $3.value; }\n+\t|\texp '%' exp\n+\t\t\t{ if ($3.value == 0)\n+\t\t\t    {\n+\t\t\t      error (\"division by zero in #if\");\n+\t\t\t      $3.value = 1;\n+\t\t\t    }\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp;\n+\t\t\t  if ($$.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value % $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value % $3.value; }\n+\t|\texp '+' exp\n+\t\t\t{ $$.value = $1.value + $3.value;\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t|\texp '-' exp\n+\t\t\t{ $$.value = $1.value - $3.value;\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t|\texp LSH exp\n+\t\t\t{ $$.unsignedp = $1.unsignedp;\n+\t\t\t  if ($$.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value << $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value << $3.value; }\n+\t|\texp RSH exp\n+\t\t\t{ $$.unsignedp = $1.unsignedp;\n+\t\t\t  if ($$.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value >> $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value >> $3.value; }\n+\t|\texp EQUAL exp\n+\t\t\t{ $$.value = ($1.value == $3.value);\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\texp NOTEQUAL exp\n+\t\t\t{ $$.value = ($1.value != $3.value);\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\texp LEQ exp\n+\t\t\t{ $$.unsignedp = 0;\n+\t\t\t  if ($1.unsignedp || $3.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value <= $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value <= $3.value; }\n+\t|\texp GEQ exp\n+\t\t\t{ $$.unsignedp = 0;\n+\t\t\t  if ($1.unsignedp || $3.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value >= $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value >= $3.value; }\n+\t|\texp '<' exp\n+\t\t\t{ $$.unsignedp = 0;\n+\t\t\t  if ($1.unsignedp || $3.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value < $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value < $3.value; }\n+\t|\texp '>' exp\n+\t\t\t{ $$.unsignedp = 0;\n+\t\t\t  if ($1.unsignedp || $3.unsignedp)\n+\t\t\t    $$.value = (unsigned) $1.value > $3.value;\n+\t\t\t  else\n+\t\t\t    $$.value = $1.value > $3.value; }\n+\t|\texp '&' exp\n+\t\t\t{ $$.value = $1.value & $3.value;\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t|\texp '^' exp\n+\t\t\t{ $$.value = $1.value ^ $3.value;\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t|\texp '|' exp\n+\t\t\t{ $$.value = $1.value | $3.value;\n+\t\t\t  $$.unsignedp = $1.unsignedp || $3.unsignedp; }\n+\t|\texp AND exp\n+\t\t\t{ $$.value = ($1.value && $3.value);\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\texp OR exp\n+\t\t\t{ $$.value = ($1.value || $3.value);\n+\t\t\t  $$.unsignedp = 0; }\n+\t|\texp '?' exp ':' exp\n+\t\t\t{ $$.value = $1.value ? $3.value : $5.value;\n+\t\t\t  $$.unsignedp = $3.unsignedp || $5.unsignedp; }\n+\t|\tINT\n+\t\t\t{ $$ = yylval.integer; }\n+\t|\tCHAR\n+\t\t\t{ $$ = yylval.integer; }\n+\t|\tNAME\n+\t\t\t{ $$.value = 0;\n+\t\t\t  $$.unsignedp = 0; }\n+\t;\n+\n+keywords :\n+\t\t\t{ $$ = 0; } \n+\t|\t'(' keywords ')' keywords\n+\t\t\t{ struct arglist *temp;\n+\t\t\t  $$ = (struct arglist *) xmalloc (sizeof (struct arglist));\n+\t\t\t  $$->next = $2;\n+\t\t\t  $$->name = (U_CHAR *) \"(\";\n+\t\t\t  $$->length = 1;\n+\t\t\t  temp = $$;\n+\t\t\t  while (temp != 0 && temp->next != 0)\n+\t\t\t    temp = temp->next;\n+\t\t\t  temp->next = (struct arglist *) xmalloc (sizeof (struct arglist));\n+\t\t\t  temp->next->next = $4;\n+\t\t\t  temp->next->name = (U_CHAR *) \")\";\n+\t\t\t  temp->next->length = 1; }\n+\t|\tNAME keywords\n+\t\t\t{ $$ = (struct arglist *) xmalloc (sizeof (struct arglist));\n+\t\t\t  $$->name = $1.address;\n+\t\t\t  $$->length = $1.length;\n+\t\t\t  $$->next = $2; } \n+\t;\n+%%\n+\f\n+/* During parsing of a C expression, the pointer to the next character\n+   is in this variable.  */\n+\n+static char *lexptr;\n+\n+/* Take care of parsing a number (anything that starts with a digit).\n+   Set yylval and return the token type; update lexptr.\n+   LEN is the number of characters in it.  */\n+\n+/* maybe needs to actually deal with floating point numbers */\n+\n+int\n+parse_number (olen)\n+     int olen;\n+{\n+  register char *p = lexptr;\n+  register long n = 0;\n+  register int c;\n+  register int base = 10;\n+  register int len = olen;\n+\n+  for (c = 0; c < len; c++)\n+    if (p[c] == '.') {\n+      /* It's a float since it contains a point.  */\n+      yyerror (\"floating point numbers not allowed in #if expressions\");\n+      return ERROR;\n+    }\n+\n+  yylval.integer.unsignedp = 0;\n+\n+  if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n+    p += 2;\n+    base = 16;\n+    len -= 2;\n+  }\n+  else if (*p == '0')\n+    base = 8;\n+\n+  while (len > 0) {\n+    c = *p++;\n+    len--;\n+    if (c >= 'A' && c <= 'Z') c += 'a' - 'A';\n+\n+    if (c >= '0' && c <= '9') {\n+      n *= base;\n+      n += c - '0';\n+    } else if (base == 16 && c >= 'a' && c <= 'f') {\n+      n *= base;\n+      n += c - 'a' + 10;\n+    } else {\n+      /* `l' means long, and `u' means unsigned.  */\n+      while (1) {\n+\tif (c == 'l' || c == 'L')\n+\t  ;\n+\telse if (c == 'u' || c == 'U')\n+\t  yylval.integer.unsignedp = 1;\n+\telse\n+\t  break;\n+\n+\tif (len == 0)\n+\t  break;\n+\tc = *p++;\n+\tlen--;\n+      }\n+      /* Don't look for any more digits after the suffixes.  */\n+      break;\n+    }\n+  }\n+\n+  if (len != 0) {\n+    yyerror (\"Invalid number in #if expression\");\n+    return ERROR;\n+  }\n+\n+  /* If too big to be signed, consider it unsigned.  */\n+  if (n < 0)\n+    yylval.integer.unsignedp = 1;\n+\n+  lexptr = p;\n+  yylval.integer.value = n;\n+  return INT;\n+}\n+\n+struct token {\n+  char *operator;\n+  int token;\n+};\n+\n+static struct token tokentab2[] = {\n+  {\"&&\", AND},\n+  {\"||\", OR},\n+  {\"<<\", LSH},\n+  {\">>\", RSH},\n+  {\"==\", EQUAL},\n+  {\"!=\", NOTEQUAL},\n+  {\"<=\", LEQ},\n+  {\">=\", GEQ},\n+  {\"++\", ERROR},\n+  {\"--\", ERROR},\n+  {NULL, ERROR}\n+};\n+\n+/* Read one token, getting characters through lexptr.  */\n+\n+int\n+yylex ()\n+{\n+  register int c;\n+  register int namelen;\n+  register char *tokstart;\n+  register struct token *toktab;\n+  int wide_flag;\n+\n+ retry:\n+\n+  tokstart = lexptr;\n+  c = *tokstart;\n+  /* See if it is a special token of length 2.  */\n+  if (! keyword_parsing)\n+    for (toktab = tokentab2; toktab->operator != NULL; toktab++)\n+      if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {\n+\tlexptr += 2;\n+\tif (toktab->token == ERROR)\n+\t  {\n+\t    char *buf = (char *) alloca (40);\n+\t    sprintf (buf, \"`%s' not allowed in operand of `#if'\", toktab->operator);\n+\t    yyerror (buf);\n+\t  }\n+\treturn toktab->token;\n+      }\n+\n+  switch (c) {\n+  case 0:\n+    return 0;\n+    \n+  case ' ':\n+  case '\\t':\n+  case '\\r':\n+  case '\\n':\n+    lexptr++;\n+    goto retry;\n+    \n+  case 'L':\n+    /* Capital L may start a wide-string or wide-character constant.  */\n+    if (lexptr[1] == '\\'')\n+      {\n+\tlexptr++;\n+\twide_flag = 1;\n+\tgoto char_constant;\n+      }\n+    if (lexptr[1] == '\"')\n+      {\n+\tlexptr++;\n+\twide_flag = 1;\n+\tgoto string_constant;\n+      }\n+    break;\n+\n+  case '\\'':\n+    wide_flag = 0;\n+  char_constant:\n+    lexptr++;\n+    if (keyword_parsing) {\n+      char *start_ptr = lexptr - 1;\n+      while (1) {\n+\tc = *lexptr++;\n+\tif (c == '\\\\')\n+\t  c = parse_escape (&lexptr);\n+\telse if (c == '\\'')\n+\t  break;\n+      }\n+      yylval.name.address = (U_CHAR *) tokstart;\n+      yylval.name.length = lexptr - start_ptr;\n+      return NAME;\n+    }\n+\n+    /* This code for reading a character constant\n+       handles multicharacter constants and wide characters.\n+       It is mostly copied from c-lex.c.  */\n+    {\n+      register int result = 0;\n+      register num_chars = 0;\n+      unsigned width = CHAR_TYPE_SIZE;\n+      int max_chars;\n+      char *token_buffer;\n+\n+      if (wide_flag)\n+\t{\n+\t  width = WCHAR_TYPE_SIZE;\n+#ifdef MULTIBYTE_CHARS\n+\t  max_chars = MB_CUR_MAX;\n+#else\n+\t  max_chars = 1;\n+#endif\n+\t}\n+      else\n+\tmax_chars = LONG_TYPE_SIZE / width;\n+\n+      token_buffer = (char *) alloca (max_chars + 1);\n+\n+      while (1)\n+\t{\n+\t  c = *lexptr++;\n+\n+\t  if (c == '\\'' || c == EOF)\n+\t    break;\n+\n+\t  if (c == '\\\\')\n+\t    {\n+\t      c = parse_escape (&lexptr);\n+\t      if (width < HOST_BITS_PER_INT\n+\t\t  && (unsigned) c >= (1 << width))\n+\t\tpedwarn (\"escape sequence out of range for character\");\n+\t    }\n+\n+\t  num_chars++;\n+\n+\t  /* Merge character into result; ignore excess chars.  */\n+\t  if (num_chars < max_chars + 1)\n+\t    {\n+\t      if (width < HOST_BITS_PER_INT)\n+\t\tresult = (result << width) | (c & ((1 << width) - 1));\n+\t      else\n+\t\tresult = c;\n+\t      token_buffer[num_chars - 1] = c;\n+\t    }\n+\t}\n+\n+      token_buffer[num_chars] = 0;\n+\n+      if (c != '\\'')\n+\terror (\"malformatted character constant\");\n+      else if (num_chars == 0)\n+\terror (\"empty character constant\");\n+      else if (num_chars > max_chars)\n+\t{\n+\t  num_chars = max_chars;\n+\t  error (\"character constant too long\");\n+\t}\n+      else if (num_chars != 1 && ! traditional)\n+\twarning (\"multi-character character constant\");\n+\n+      /* If char type is signed, sign-extend the constant.  */\n+      if (! wide_flag)\n+\t{\n+\t  int num_bits = num_chars * width;\n+\n+\t  if (lookup (\"__CHAR_UNSIGNED__\", sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n+\t      || ((result >> (num_bits - 1)) & 1) == 0)\n+\t    yylval.integer.value\n+\t      = result & ((unsigned) ~0 >> (HOST_BITS_PER_INT - num_bits));\n+\t  else\n+\t    yylval.integer.value\n+\t      = result | ~((unsigned) ~0 >> (HOST_BITS_PER_INT - num_bits));\n+\t}\n+      else\n+\t{\n+#ifdef MULTIBYTE_CHARS\n+\t  /* Set the initial shift state and convert the next sequence.  */\n+\t  result = 0;\n+\t  /* In all locales L'\\0' is zero and mbtowc will return zero,\n+\t     so don't use it.  */\n+\t  if (num_chars > 1\n+\t      || (num_chars == 1 && token_buffer[0] != '\\0'))\n+\t    {\n+\t      wchar_t wc;\n+\t      (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n+\t      if (mbtowc (& wc, token_buffer, num_chars) == num_chars)\n+\t\tresult = wc;\n+\t      else\n+\t\twarning (\"Ignoring invalid multibyte character\");\n+\t    }\n+#endif\n+\t  yylval.integer.value = result;\n+\t}\n+    }\n+\n+    /* This is always a signed type.  */\n+    yylval.integer.unsignedp = 0;\n+    \n+    return CHAR;\n+\n+    /* some of these chars are invalid in constant expressions;\n+       maybe do something about them later */\n+  case '/':\n+  case '+':\n+  case '-':\n+  case '*':\n+  case '%':\n+  case '|':\n+  case '&':\n+  case '^':\n+  case '~':\n+  case '!':\n+  case '@':\n+  case '<':\n+  case '>':\n+  case '[':\n+  case ']':\n+  case '.':\n+  case '?':\n+  case ':':\n+  case '=':\n+  case '{':\n+  case '}':\n+  case ',':\n+  case '#':\n+    if (keyword_parsing)\n+      break;\n+  case '(':\n+  case ')':\n+    lexptr++;\n+    return c;\n+\n+  case '\"':\n+  string_constant:\n+    if (keyword_parsing) {\n+      char *start_ptr = lexptr;\n+      lexptr++;\n+      while (1) {\n+\tc = *lexptr++;\n+\tif (c == '\\\\')\n+\t  c = parse_escape (&lexptr);\n+\telse if (c == '\"')\n+\t  break;\n+      }\n+      yylval.name.address = (U_CHAR *) tokstart;\n+      yylval.name.length = lexptr - start_ptr;\n+      return NAME;\n+    }\n+    yyerror (\"string constants not allowed in #if expressions\");\n+    return ERROR;\n+  }\n+\n+  if (c >= '0' && c <= '9' && !keyword_parsing) {\n+    /* It's a number */\n+    for (namelen = 0;\n+\t c = tokstart[namelen], is_idchar[c] || c == '.'; \n+\t namelen++)\n+      ;\n+    return parse_number (namelen);\n+  }\n+\n+  /* It is a name.  See how long it is.  */\n+\n+  if (keyword_parsing) {\n+    for (namelen = 0;; namelen++) {\n+      if (is_hor_space[tokstart[namelen]])\n+\tbreak;\n+      if (tokstart[namelen] == '(' || tokstart[namelen] == ')')\n+\tbreak;\n+      if (tokstart[namelen] == '\"' || tokstart[namelen] == '\\'')\n+\tbreak;\n+    }\n+  } else {\n+    if (!is_idstart[c]) {\n+      yyerror (\"Invalid token in expression\");\n+      return ERROR;\n+    }\n+\n+    for (namelen = 0; is_idchar[tokstart[namelen]]; namelen++)\n+      ;\n+  }\n+  \n+  lexptr += namelen;\n+  yylval.name.address = (U_CHAR *) tokstart;\n+  yylval.name.length = namelen;\n+  return NAME;\n+}\n+\n+\n+/* Parse a C escape sequence.  STRING_PTR points to a variable\n+   containing a pointer to the string to parse.  That pointer\n+   is updated past the characters we use.  The value of the\n+   escape sequence is returned.\n+\n+   A negative value means the sequence \\ newline was seen,\n+   which is supposed to be equivalent to nothing at all.\n+\n+   If \\ is followed by a null character, we return a negative\n+   value and leave the string pointer pointing at the null character.\n+\n+   If \\ is followed by 000, we return 0 and leave the string pointer\n+   after the zeros.  A value of 0 does not mean end of string.  */\n+\n+int\n+parse_escape (string_ptr)\n+     char **string_ptr;\n+{\n+  register int c = *(*string_ptr)++;\n+  switch (c)\n+    {\n+    case 'a':\n+      return TARGET_BELL;\n+    case 'b':\n+      return TARGET_BS;\n+    case 'e':\n+      return 033;\n+    case 'f':\n+      return TARGET_FF;\n+    case 'n':\n+      return TARGET_NEWLINE;\n+    case 'r':\n+      return TARGET_CR;\n+    case 't':\n+      return TARGET_TAB;\n+    case 'v':\n+      return TARGET_VT;\n+    case '\\n':\n+      return -2;\n+    case 0:\n+      (*string_ptr)--;\n+      return 0;\n+    case '^':\n+      c = *(*string_ptr)++;\n+      if (c == '\\\\')\n+\tc = parse_escape (string_ptr);\n+      if (c == '?')\n+\treturn 0177;\n+      return (c & 0200) | (c & 037);\n+      \n+    case '0':\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+    case '5':\n+    case '6':\n+    case '7':\n+      {\n+\tregister int i = c - '0';\n+\tregister int count = 0;\n+\twhile (++count < 3)\n+\t  {\n+\t    c = *(*string_ptr)++;\n+\t    if (c >= '0' && c <= '7')\n+\t      i = (i << 3) + c - '0';\n+\t    else\n+\t      {\n+\t\t(*string_ptr)--;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif ((i & ~((1 << CHAR_TYPE_SIZE) - 1)) != 0)\n+\t  {\n+\t    i &= (1 << CHAR_TYPE_SIZE) - 1;\n+\t    warning (\"octal character constant does not fit in a byte\");\n+\t  }\n+\treturn i;\n+      }\n+    case 'x':\n+      {\n+\tregister int i = 0;\n+\tfor (;;)\n+\t  {\n+\t    c = *(*string_ptr)++;\n+\t    if (c >= '0' && c <= '9')\n+\t      i = (i << 4) + c - '0';\n+\t    else if (c >= 'a' && c <= 'f')\n+\t      i = (i << 4) + c - 'a' + 10;\n+\t    else if (c >= 'A' && c <= 'F')\n+\t      i = (i << 4) + c - 'A' + 10;\n+\t    else\n+\t      {\n+\t\t(*string_ptr)--;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif ((i & ~((1 << BITS_PER_UNIT) - 1)) != 0)\n+\t  {\n+\t    i &= (1 << BITS_PER_UNIT) - 1;\n+\t    warning (\"hex character constant does not fit in a byte\");\n+\t  }\n+\treturn i;\n+      }\n+    default:\n+      return c;\n+    }\n+}\n+\n+void\n+yyerror (s)\n+     char *s;\n+{\n+  error (s);\n+  longjmp (parse_return_error, 1);\n+}\n+\f\n+/* This page contains the entry point to this file.  */\n+\n+/* Parse STRING as an expression, and complain if this fails\n+   to use up all of the contents of STRING.  */\n+/* We do not support C comments.  They should be removed before\n+   this function is called.  */\n+\n+int\n+parse_c_expression (string)\n+     char *string;\n+{\n+  lexptr = string;\n+  \n+  if (lexptr == 0 || *lexptr == 0) {\n+    error (\"empty #if expression\");\n+    return 0;\t\t\t/* don't include the #if group */\n+  }\n+\n+  /* if there is some sort of scanning error, just return 0 and assume\n+     the parsing routine has printed an error message somewhere.\n+     there is surely a better thing to do than this.     */\n+  if (setjmp (parse_return_error))\n+    return 0;\n+\n+  if (yyparse ())\n+    return 0;\t\t\t/* actually this is never reached\n+\t\t\t\t   the way things stand. */\n+  if (*lexptr)\n+    error (\"Junk after end of expression.\");\n+\n+  return expression_value;\t/* set by yyparse () */\n+}\n+\f\n+#ifdef TEST_EXP_READER\n+extern int yydebug;\n+\n+/* Main program for testing purposes.  */\n+int\n+main ()\n+{\n+  int n, c;\n+  char buf[1024];\n+\n+/*\n+  yydebug = 1;\n+*/\n+  initialize_random_junk ();\n+\n+  for (;;) {\n+    printf (\"enter expression: \");\n+    n = 0;\n+    while ((buf[n] = getchar ()) != '\\n' && buf[n] != EOF)\n+      n++;\n+    if (buf[n] == EOF)\n+      break;\n+    buf[n] = '\\0';\n+    printf (\"parser returned %d\\n\", parse_c_expression (buf));\n+  }\n+\n+  return 0;\n+}\n+\n+/* table to tell if char can be part of a C identifier. */\n+unsigned char is_idchar[256];\n+/* table to tell if char can be first char of a c identifier. */\n+unsigned char is_idstart[256];\n+/* table to tell if c is horizontal space.  isspace () thinks that\n+   newline is space; this is not a good idea for this program. */\n+char is_hor_space[256];\n+\n+/*\n+ * initialize random junk in the hash table and maybe other places\n+ */\n+initialize_random_junk ()\n+{\n+  register int i;\n+\n+  /*\n+   * Set up is_idchar and is_idstart tables.  These should be\n+   * faster than saying (is_alpha (c) || c == '_'), etc.\n+   * Must do set up these things before calling any routines tthat\n+   * refer to them.\n+   */\n+  for (i = 'a'; i <= 'z'; i++) {\n+    ++is_idchar[i - 'a' + 'A'];\n+    ++is_idchar[i];\n+    ++is_idstart[i - 'a' + 'A'];\n+    ++is_idstart[i];\n+  }\n+  for (i = '0'; i <= '9'; i++)\n+    ++is_idchar[i];\n+  ++is_idchar['_'];\n+  ++is_idstart['_'];\n+#if DOLLARS_IN_IDENTIFIERS\n+  ++is_idchar['$'];\n+  ++is_idstart['$'];\n+#endif\n+\n+  /* horizontal space table */\n+  ++is_hor_space[' '];\n+  ++is_hor_space['\\t'];\n+}\n+\n+error (msg)\n+{\n+  printf (\"error: %s\\n\", msg);\n+}\n+\n+warning (msg)\n+{\n+  printf (\"warning: %s\\n\", msg);\n+}\n+\n+struct hashnode *\n+lookup (name, len, hash)\n+     char *name;\n+     int len;\n+     int hash;\n+{\n+  return (DEFAULT_SIGNED_CHAR) ? 0 : ((struct hashnode *) -1);\n+}\n+#endif"}]}