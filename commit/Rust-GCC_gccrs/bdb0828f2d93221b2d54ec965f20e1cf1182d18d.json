{"sha": "bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRiMDgyOGYyZDkzMjIxYjJkNTRlYzk2NWYyMGUxY2YxMTgyZDE4ZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-09-22T16:17:11Z"}, "committer": {"name": "Vidya Praveen", "email": "vp@gcc.gnu.org", "date": "2017-09-22T16:17:11Z"}, "message": "[arm] auto-generate arm-isa.h from CPU descriptions\n\nThis patch autogenerates arm-isa.h from new entries in arm-cpus.in.\nThis has the primary advantage that it makes the description file more\nself-contained, but it also solves the 'array dimensioning' problem\nthat Tamar recently encountered.  It adds two new constructs to\narm-cpus.in: features and fgroups.  Fgroups are simply a way of naming\na group of feature bits so that they can be referenced together.  We\nfollow the convention that feature bits are all lower case, while\nfgroups are (predominantly) upper case. This is helpful as in some\ncontexts they share the same namespace. Most of the minor changes in\nthis patch are related to adopting this new naming convention.\n\n2017-09-22  Richard Earnshaw  <richard.earnshaw@arm.com>\n\n\t* config.gcc (arm*-*-*): Don't add arm-isa.h to tm_p_file.\n\t* config/arm/arm-isa.h: Delete.  Move definitions to ...\n\t* arm-cpus.in: ... here.  Use new feature and fgroup values.\n\t* config/arm/arm.c (arm_option_override): Use lower case for feature\n\tbit names.\n\t* config/arm/arm.h (TARGET_HARD_FLOAT): Likewise.\n\t(TARGET_VFP3, TARGET_VFP5, TARGET_FMA): Likewise.\n\t* config/arm/parsecpu.awk (END): Add new command 'isa'.\n\t(isa_pfx): Delete.\n\t(print_isa_bits_for): New function.\n\t(gen_isa): New function.\n\t(gen_comm_data): Use print_isa_bits_for.\n\t(define feature): New keyword.\n\t(define fgroup): New keyword.\n\t* config/arm/t-arm (TM_H): Remove.\n\t(GTM_H): Add arm-isa.h.\n\t(arm-isa.h): Add rule to generate file.\n\t* common/config/arm/arm-common.c: (arm_canon_arch_option): Use lower\n\tcase for feature bit names.\n\nFrom-SVN: r253097", "tree": {"sha": "a1fab0206841b50b224939c5d560fefc8f42f7d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1fab0206841b50b224939c5d560fefc8f42f7d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/comments", "author": null, "committer": null, "parents": [{"sha": "9003adc732305c69346b8ae5699a250c033c31c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9003adc732305c69346b8ae5699a250c033c31c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9003adc732305c69346b8ae5699a250c033c31c1"}], "stats": {"total": 706, "additions": 419, "deletions": 287}, "files": [{"sha": "166352f14a708f8a5ec9a1bc999e612e1052895d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -1,3 +1,25 @@\n+2017-09-22  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* config.gcc (arm*-*-*): Don't add arm-isa.h to tm_p_file.\n+\t* config/arm/arm-isa.h: Delete.  Move definitions to ...\n+\t* arm-cpus.in: ... here.  Use new feature and fgroup values.\n+\t* config/arm/arm.c (arm_option_override): Use lower case for feature\n+\tbit names.\n+\t* config/arm/arm.h (TARGET_HARD_FLOAT): Likewise.\n+\t(TARGET_VFP3, TARGET_VFP5, TARGET_FMA): Likewise.\n+\t* config/arm/parsecpu.awk (END): Add new command 'isa'.\n+\t(isa_pfx): Delete.\n+\t(print_isa_bits_for): New function.\n+\t(gen_isa): New function.\n+\t(gen_comm_data): Use print_isa_bits_for.\n+\t(define feature): New keyword.\n+\t(define fgroup): New keyword.\n+\t* config/arm/t-arm (TM_H): Remove.\n+\t(GTM_H): Add arm-isa.h.\n+\t(arm-isa.h): Add rule to generate file.\n+\t* common/config/arm/arm-common.c: (arm_canon_arch_option): Use lower\n+\tcase for feature bit names.\n+\n 2017-09-22  Richard Biener  <rguenther@suse.de>\n \n \t* graphite-isl-ast-to-gimple.c (graphite_verify): Inline into"}, {"sha": "7cb99ece710629e56ac811e940060d2ec5a169b0", "filename": "gcc/common/config/arm/arm-common.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Farm%2Farm-common.c?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -574,7 +574,7 @@ arm_canon_arch_option (int argc, const char **argv)\n \t{\n \t  /* The easiest and safest way to remove the default fpu\n \t     capabilities is to look for a '+no..' option that removes\n-\t     the base FPU bit (isa_bit_VFPv2).  If that doesn't exist\n+\t     the base FPU bit (isa_bit_vfpv2).  If that doesn't exist\n \t     then the best we can do is strip out all the bits that\n \t     might be part of the most capable FPU we know about,\n \t     which is \"crypto-neon-fp-armv8\".  */\n@@ -586,7 +586,7 @@ arm_canon_arch_option (int argc, const char **argv)\n \t\t   ++ext)\n \t\t{\n \t\t  if (ext->remove\n-\t\t      && check_isa_bits_for (ext->isa_bits, isa_bit_VFPv2))\n+\t\t      && check_isa_bits_for (ext->isa_bits, isa_bit_vfpv2))\n \t\t    {\n \t\t      arm_initialize_isa (fpu_isa, ext->isa_bits);\n \t\t      bitmap_and_compl (target_isa, target_isa, fpu_isa);\n@@ -620,7 +620,7 @@ arm_canon_arch_option (int argc, const char **argv)\n     {\n       /* Clearing the VFPv2 bit is sufficient to stop any extention that\n \t builds on the FPU from matching.  */\n-      bitmap_clear_bit (target_isa, isa_bit_VFPv2);\n+      bitmap_clear_bit (target_isa, isa_bit_vfpv2);\n     }\n \n   /* If we don't have a selected architecture by now, something's\n@@ -692,8 +692,8 @@ arm_canon_arch_option (int argc, const char **argv)\n      capable FPU variant that we do support.  This is sufficient for\n      multilib selection.  */\n \n-  if (bitmap_bit_p (target_isa_unsatisfied, isa_bit_VFPv2)\n-      && bitmap_bit_p (fpu_isa, isa_bit_VFPv2))\n+  if (bitmap_bit_p (target_isa_unsatisfied, isa_bit_vfpv2)\n+      && bitmap_bit_p (fpu_isa, isa_bit_vfpv2))\n     {\n       std::list<candidate_extension *>::iterator ipoint = extensions.begin ();\n "}, {"sha": "002251040386955708d53764a01a4e5f0e3e442c", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -593,7 +593,7 @@ x86_64-*-*)\n \ttm_file=\"vxworks-dummy.h ${tm_file}\"\n \t;;\n arm*-*-*)\n-\ttm_p_file=\"arm/arm-flags.h arm/arm-isa.h ${tm_p_file} arm/aarch-common-protos.h\"\n+\ttm_p_file=\"arm/arm-flags.h ${tm_p_file} arm/aarch-common-protos.h\"\n \ttm_file=\"vxworks-dummy.h ${tm_file}\"\n \t;;\n mips*-*-* | sh*-*-* | sparc*-*-*)"}, {"sha": "07de4c9375ba7a0df0d8bd00385e54a4042e5264", "filename": "gcc/config/arm/arm-cpus.in", "status": "modified", "additions": 233, "deletions": 29, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm-cpus.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm-cpus.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-cpus.in?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -40,6 +40,210 @@\n # names in the final compiler.  The order within each group is preserved and\n # forms the order for the list within the compiler.\n \n+# Most objects in this file support forward references.  The major\n+# exception is feature groups, which may only refer to previously\n+# defined features or feature groups.  This is done to avoid the risk\n+# of feature groups recursively referencing each other and causing\n+# the parser to hang.\n+\n+# Features - general convention: all lower case.\n+\n+# Extended multiply\n+define feature armv3m\n+\n+# 26-bit mode support\n+define feature mode26\n+\n+# 32-bit mode support\n+define feature mode32\n+\n+# Architecture rel 4\n+define feature armv4\n+\n+# Architecture rel 5\n+define feature armv5\n+\n+# Thumb aware.\n+define feature thumb\n+\n+# Architecture rel 5e.\n+define feature armv5e\n+\n+# XScale.\n+define feature xscale\n+\n+# Architecture rel 6.\n+define feature armv6\n+\n+# Architecture rel 6k.\n+define feature armv6k\n+\n+# Thumb-2.\n+define feature thumb2\n+\n+# Instructions not present in 'M' profile.\n+define feature notm\n+\n+# Architecture uses be8 mode in big-endian.\n+define feature be8\n+\n+# Thumb division instructions.\n+define feature tdiv\n+\n+# Architecture rel 7e-m.\n+define feature armv7em\n+\n+# Architecture rel 7.\n+define feature armv7\n+\n+# ARM division instructions.\n+define feature adiv\n+\n+# Architecture rel 8.\n+define feature armv8\n+\n+# ARMv8 CRC32 instructions.\n+define feature crc32\n+\n+# XScale v2 (Wireless MMX).\n+define feature iwmmxt\n+\n+# XScale Wireless MMX2.\n+define feature iwmmxt2\n+\n+# Architecture rel 8.1.\n+define feature armv8_1\n+\n+# Architecutre rel 8.2.\n+define feature armv8_2\n+\n+# M-Profile security extensions.\n+define feature cmse\n+\n+# Floating point and Neon extensions.\n+# VFPv1 is not supported in GCC.\n+\n+# Vector floating point v2.\n+define feature vfpv2\n+\n+# Vector floating point v3.\n+define feature vfpv3\n+\n+# Vector floating point v4.\n+define feature vfpv4\n+\n+# Floating point v5.\n+define feature fpv5\n+\n+# ARMv7-A LPAE.\n+define feature lpae\n+\n+# Advanced SIMD instructions.\n+define feature neon\n+\n+# Conversions to/from fp16 (VFPv3 extension).\n+define feature fp16conv\n+\n+# Double precision operations supported.\n+define feature fp_dbl\n+\n+# 32 Double precision registers.\n+define feature fp_d32\n+\n+# Crypto extension to ARMv8.\n+define feature crypto\n+\n+# FP16 data processing (half-precision float).\n+define feature fp16\n+\n+\n+# ISA Quirks (errata?).  Don't forget to add this to the fgroup\n+# ALL_QUIRKS below.\n+\n+# No volatile memory in IT blocks.\n+define feature quirk_no_volatile_ce\n+\n+# Previously mis-identified by GCC.\n+define feature quirk_armv6kz\n+\n+# Cortex-M3 LDRD quirk.\n+define feature quirk_cm3_ldrd\n+\n+# (Very) slow multiply operations.  Should probably be a tuning bit.\n+define feature smallmul\n+\n+# Feature groups.  Conventionally all (or mostly) upper case.\n+\n+# List of all cryptographic extensions to stripout if crypto is\n+# disabled.  Currently, that's trivial, but we define it anyway for\n+# consistency with the SIMD and FP disable lists.\n+define fgroup ALL_CRYPTO\tcrypto\n+\n+# List of all SIMD bits to strip out if SIMD is disabled.  This does\n+# strip off 32 D-registers, but does not remove support for\n+# double-precision FP.\n+define fgroup ALL_SIMD\tfp_d32 neon ALL_CRYPTO\n+\n+# List of all FPU bits to strip out if -mfpu is used to override the\n+# default.  fp16 is deliberately missing from this list.\n+define fgroup ALL_FPU_INTERNAL\tvfpv2 vfpv3 vfpv4 fpv5 fp16conv fp_dbl ALL_SIMD\n+\n+# Similarly, but including fp16 and other extensions that aren't part of\n+# -mfpu support.\n+define fgroup ALL_FP\tfp16 ALL_FPU_INTERNAL\n+\n+define fgroup ARMv2       notm\n+define fgroup ARMv3       ARMv2 mode32\n+define fgroup ARMv3m      ARMv3 armv3m\n+define fgroup ARMv4       ARMv3m armv4\n+define fgroup ARMv4t      ARMv4 thumb\n+define fgroup ARMv5       ARMv4 armv5\n+define fgroup ARMv5t      ARMv5 thumb\n+define fgroup ARMv5e      ARMv5 armv5e\n+define fgroup ARMv5te     ARMv5e thumb\n+define fgroup ARMv5tej    ARMv5te\n+define fgroup ARMv6       ARMv5te armv6 be8\n+define fgroup ARMv6j      ARMv6\n+define fgroup ARMv6k      ARMv6 armv6k\n+define fgroup ARMv6z      ARMv6\n+define fgroup ARMv6kz     ARMv6k quirk_armv6kz\n+define fgroup ARMv6zk     ARMv6k\n+define fgroup ARMv6t2     ARMv6 thumb2\n+# This is suspect.  ARMv6-m doesn't really pull in any useful features\n+# from ARMv5* or ARMv6.\n+define fgroup ARMv6m      mode32 armv3m armv4 thumb armv5 armv5e armv6\n+# This is suspect, the 'common' ARMv7 subset excludes the thumb2 'DSP' and\n+# integer SIMD instructions that are in ARMv6T2.  */\n+define fgroup ARMv7       ARMv6m thumb2 armv7\n+\n+define fgroup ARMv7a      ARMv7 notm armv6k\n+define fgroup ARMv7ve     ARMv7a adiv tdiv lpae\n+define fgroup ARMv7r      ARMv7a tdiv\n+define fgroup ARMv7m      ARMv7 tdiv\n+define fgroup ARMv7em     ARMv7m armv7em\n+define fgroup ARMv8a      ARMv7ve armv8\n+define fgroup ARMv8_1a    ARMv8a crc32 armv8_1\n+define fgroup ARMv8_2a    ARMv8_1a armv8_2\n+define fgroup ARMv8m_base ARMv6m armv8 cmse tdiv\n+define fgroup ARMv8m_main ARMv7m armv8 cmse\n+define fgroup ARMv8r      ARMv8a\n+\n+# Useful combinations.\n+define fgroup VFPv2\tvfpv2\n+define fgroup VFPv3\tVFPv2 vfpv3\n+define fgroup VFPv4\tVFPv3 vfpv4 fp16conv\n+define fgroup FPv5\tVFPv4 fpv5\n+\n+define fgroup FP_DBL\tfp_dbl\n+define fgroup FP_D32\tFP_DBL fp_d32\n+define fgroup FP_ARMv8\tFPv5 FP_D32\n+define fgroup NEON\tFP_D32 neon\n+define fgroup CRYPTO\tNEON crypto\n+\n+# List of all quirk bits to strip out when comparing CPU features with\n+# architectures.\n+define fgroup ALL_QUIRKS   quirk_no_volatile_ce quirk_armv6kz quirk_cm3_ldrd\n+\n # Architecture entries\n # format:\n # begin arch <name>\n@@ -55,38 +259,38 @@ begin arch armv2\n  tune for arm2\n  tune flags CO_PROC NO_MODE32\n  base 2\n- isa ARMv2 bit_mode26\n+ isa ARMv2 mode26\n end arch armv2\n \n begin arch armv2a\n  tune for arm2\n  tune flags CO_PROC NO_MODE32\n  base 2\n- isa ARMv2 bit_mode26\n+ isa ARMv2 mode26\n end arch armv2a\n \n begin arch armv3\n  tune for arm6\n  tune flags CO_PROC\n  base 3\n- isa ARMv3 bit_mode26\n+ isa ARMv3 mode26\n end arch armv3\n \n begin arch armv3m\n  tune for arm7m\n  tune flags CO_PROC\n  base 3M\n- isa ARMv3m bit_mode26\n+ isa ARMv3m mode26\n end arch armv3m\n \n begin arch armv4\n  tune for arm7tdmi\n  tune flags CO_PROC\n  base 4\n- isa ARMv4 bit_mode26\n+ isa ARMv4 mode26\n end arch armv4\n \n-# Strictly, bit_mode26 is a permitted option for v4t, but there are no\n+# Strictly, mode26 is a permitted option for v4t, but there are no\n # implementations that support it, so we will leave it out for now.\n begin arch armv4t\n  tune for arm7tdmi\n@@ -244,14 +448,14 @@ begin arch armv7-a\n  option fp\t       add VFPv3 FP_DBL\n  optalias vfpv3-d16    fp\n  option vfpv3\t       add VFPv3 FP_D32\n- option vfpv3-d16-fp16 add VFPv3 FP_DBL bit_fp16conv\n- option vfpv3-fp16     add VFPv3 FP_DBL FP_D32 bit_fp16conv\n+ option vfpv3-d16-fp16 add VFPv3 FP_DBL fp16conv\n+ option vfpv3-fp16     add VFPv3 FP_DBL FP_D32 fp16conv\n  option vfpv4-d16      add VFPv4 FP_DBL\n  option vfpv4\t       add VFPv4 FP_D32\n  option simd\t       add VFPv3 NEON\n  optalias neon\t       simd\n  optalias neon-vfpv3   simd\n- option neon-fp16      add VFPv3 NEON bit_fp16conv\n+ option neon-fp16      add VFPv3 NEON fp16conv\n  option neon-vfpv4     add VFPv4 NEON\n  option nosimd\t    remove ALL_SIMD\n  option nofp\t    remove ALL_FP\n@@ -266,14 +470,14 @@ begin arch armv7ve\n # fp => VFPv4-d16, simd => neon-vfpv4\n  option vfpv3-d16      add VFPv3 FP_DBL\n  option vfpv3 \t       add VFPv3 FP_D32\n- option vfpv3-d16-fp16 add VFPv3 FP_DBL bit_fp16conv\n- option vfpv3-fp16     add VFPv3 FP_DBL FP_D32 bit_fp16conv\n+ option vfpv3-d16-fp16 add VFPv3 FP_DBL fp16conv\n+ option vfpv3-fp16     add VFPv3 FP_DBL FP_D32 fp16conv\n  option fp \t       add VFPv4 FP_DBL\n  optalias vfpv4-d16    fp\n  option vfpv4 \t       add VFPv4 FP_D32\n  option neon \t       add VFPv3 NEON\n  optalias neon-vfpv3   neon\n- option neon-fp16      add VFPv3 NEON bit_fp16conv\n+ option neon-fp16      add VFPv3 NEON fp16conv\n  option simd \t       add VFPv4 NEON\n  optalias neon-vfpv4   simd\n  option nosimd\t    remove ALL_SIMD\n@@ -291,9 +495,9 @@ begin arch armv7-r\n  optalias vfpv3xd fp.sp\n  option fp add VFPv3 FP_DBL\n  optalias vfpv3-d16 fp\n- option idiv add bit_adiv\n+ option idiv add adiv\n  option nofp remove ALL_FP\n- option noidiv remove bit_adiv\n+ option noidiv remove adiv\n end arch armv7-r\n \n begin arch armv7-m\n@@ -327,7 +531,7 @@ begin arch armv8-a\n  base 8A\n  profile A\n  isa ARMv8a\n- option crc add bit_crc32\n+ option crc add crc32\n  option simd add FP_ARMv8 NEON\n  option crypto add FP_ARMv8 CRYPTO\n  option nocrypto remove ALL_CRYPTO\n@@ -353,7 +557,7 @@ begin arch armv8.2-a\n  profile A\n  isa ARMv8_2a\n  option simd add FP_ARMv8 NEON\n- option fp16 add bit_fp16 FP_ARMv8 NEON\n+ option fp16 add fp16 FP_ARMv8 NEON\n  option crypto add FP_ARMv8 CRYPTO\n  option nocrypto remove ALL_CRYPTO\n  option nofp remove ALL_FP\n@@ -372,12 +576,12 @@ begin arch armv8-m.main\n  base 8M_MAIN\n  profile M\n  isa ARMv8m_main\n- option dsp add bit_ARMv7em\n+ option dsp add armv7em\n # fp => FPv5-sp-d16; fp.dp => FPv5-d16\n  option fp add FPv5\n  option fp.dp add FPv5 FP_DBL\n  option nofp remove ALL_FP\n- option nodsp remove bit_ARMv7em\n+ option nodsp remove armv7em\n end arch armv8-m.main\n \n begin arch armv8-r\n@@ -386,7 +590,7 @@ begin arch armv8-r\n  base 8R\n  profile R\n  isa ARMv8r\n- option crc add bit_crc32\n+ option crc add crc32\n # fp.sp => fp-armv8 (d16); simd => simd + fp-armv8 + d32 + double precision\n # note: no fp option for fp-armv8 (d16) + double precision at the moment\n  option fp.sp add FPv5\n@@ -400,14 +604,14 @@ begin arch iwmmxt\n  tune for iwmmxt\n  tune flags LDSCHED STRONG XSCALE\n  base 5TE\n- isa ARMv5te bit_xscale bit_iwmmxt\n+ isa ARMv5te xscale iwmmxt\n end arch iwmmxt\n \n begin arch iwmmxt2\n  tune for iwmmxt2\n  tune flags LDSCHED STRONG XSCALE\n  base 5TE\n- isa ARMv5te bit_xscale bit_iwmmxt bit_iwmmxt2\n+ isa ARMv5te xscale iwmmxt iwmmxt2\n end arch iwmmxt2\n \n # CPU entries\n@@ -783,7 +987,7 @@ end cpu arm1022e\n begin cpu xscale\n  tune flags LDSCHED XSCALE\n  architecture armv5te\n- isa bit_xscale\n+ isa xscale\n  costs xscale\n end cpu xscale\n \n@@ -961,14 +1165,14 @@ begin cpu generic-armv7-a\n  fpu vfpv3-d16\n  option vfpv3-d16 add VFPv3 FP_DBL\n  option vfpv3 add VFPv3 FP_D32\n- option vfpv3-d16-fp16 add VFPv3 FP_DBL bit_fp16conv\n- option vfpv3-fp16 add VFPv3 FP_D32 bit_fp16conv\n+ option vfpv3-d16-fp16 add VFPv3 FP_DBL fp16conv\n+ option vfpv3-fp16 add VFPv3 FP_D32 fp16conv\n  option vfpv4-d16 add VFPv4 FP_DBL\n  option vfpv4 add VFPv4 FP_D32\n  option simd add VFPv3 NEON\n  optalias neon simd\n  optalias neon-vfpv3 simd\n- option neon-fp16 add VFPv3 NEON bit_fp16conv\n+ option neon-fp16 add VFPv3 NEON fp16conv\n  option neon-vfpv4 add VFPv4 NEON\n  option nosimd remove ALL_SIMD\n  option nofp remove ALL_FP\n@@ -1344,23 +1548,23 @@ begin fpu vfpv3\n end fpu vfpv3\n \n begin fpu vfpv3-fp16\n- isa VFPv3 FP_D32 bit_fp16conv\n+ isa VFPv3 FP_D32 fp16conv\n end fpu vfpv3-fp16\n \n begin fpu vfpv3-d16\n  isa VFPv3 FP_DBL\n end fpu vfpv3-d16\n \n begin fpu vfpv3-d16-fp16\n- isa VFPv3 FP_DBL bit_fp16conv\n+ isa VFPv3 FP_DBL fp16conv\n end fpu vfpv3-d16-fp16\n \n begin fpu vfpv3xd\n  isa VFPv3\n end fpu vfpv3xd\n \n begin fpu vfpv3xd-fp16\n- isa VFPv3 bit_fp16conv\n+ isa VFPv3 fp16conv\n end fpu vfpv3xd-fp16\n \n begin fpu neon\n@@ -1372,7 +1576,7 @@ begin fpu neon-vfpv3\n end fpu neon-vfpv3\n \n begin fpu neon-fp16\n- isa VFPv3 NEON bit_fp16conv\n+ isa VFPv3 NEON fp16conv\n end fpu neon-fp16\n \n begin fpu vfpv4"}, {"sha": "dbd29eaa52f2007498c2aff6263b8b6c3a70e2c2", "filename": "gcc/config/arm/arm-isa.h", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9003adc732305c69346b8ae5699a250c033c31c1/gcc%2Fconfig%2Farm%2Farm-isa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9003adc732305c69346b8ae5699a250c033c31c1/gcc%2Fconfig%2Farm%2Farm-isa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-isa.h?ref=9003adc732305c69346b8ae5699a250c033c31c1", "patch": "@@ -1,172 +0,0 @@\n-/* ISA feature bits for ARM.\n-   Copyright (C) 2016-2017 Free Software Foundation, Inc.\n-   Contributed by ARM Ltd.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef ARM_ISA_FEATURE_H\n-#define ARM_ISA_FEATURE_H\n-\n-enum isa_feature\n-  {\n-    isa_nobit,\t\t/* Must be first.  */\n-    isa_bit_ARMv3m,\t/* Extended multiply.  */\n-    isa_bit_mode26,\t/* 26-bit mode support.  */\n-    isa_bit_mode32,\t/* 32-bit mode support.  */\n-    isa_bit_ARMv4,\t/* Architecture rel 4.  */\n-    isa_bit_ARMv5,\t/* Architecture rel 5.\t*/\n-    isa_bit_thumb,\t/* Thumb aware.  */\n-    isa_bit_ARMv5e,\t/* Architecture rel 5e.  */\n-    isa_bit_xscale,\t/* XScale.  */\n-    isa_bit_ARMv6,\t/* Architecture rel 6.  */\n-    isa_bit_ARMv6k,\t/* Architecture rel 6k.  */\n-    isa_bit_thumb2,\t/* Thumb-2.  */\n-    isa_bit_notm,\t/* Instructions not present in 'M' profile.  */\n-    isa_bit_be8,\t/* Architecture uses be8 mode in big-endian.  */\n-    isa_bit_tdiv,\t/* Thumb division instructions.  */\n-    isa_bit_ARMv7em,\t/* Architecture rel 7e-m.  */\n-    isa_bit_ARMv7,\t/* Architecture rel 7.  */\n-    isa_bit_adiv,\t/* ARM division instructions.  */\n-    isa_bit_ARMv8,\t/* Architecture rel 8.  */\n-    isa_bit_crc32,\t/* ARMv8 CRC32 instructions.  */\n-    isa_bit_iwmmxt,\t/* XScale v2 (Wireless MMX).  */\n-    isa_bit_iwmmxt2,\t/* XScale Wireless MMX2.  */\n-    isa_bit_ARMv8_1,\t/* Architecture rel 8.1.  */\n-    isa_bit_ARMv8_2,\t/* Architecutre rel 8.2.  */\n-    isa_bit_cmse,\t/* M-Profile security extensions.  */\n-    /* Floating point and Neon extensions.  */\n-    /* VFPv1 is not supported in GCC.  */\n-    isa_bit_VFPv2,\t/* Vector floating point v2.  */\n-    isa_bit_VFPv3,\t/* Vector floating point v3.  */\n-    isa_bit_VFPv4,\t/* Vector floating point v4.  */\n-    isa_bit_FPv5,\t/* Floating point v5.  */\n-    isa_bit_lpae,\t/* ARMv7-A LPAE.  */\n-    isa_bit_neon,\t/* Advanced SIMD instructions.  */\n-    isa_bit_fp16conv,\t/* Conversions to/from fp16 (VFPv3 extension).  */\n-    isa_bit_fp_dbl,\t/* Double precision operations supported.  */\n-    isa_bit_fp_d32,\t/* 32 Double precision registers.  */\n-    isa_bit_crypto,\t/* Crypto extension to ARMv8.  */\n-    isa_bit_fp16,\t/* FP16 data processing (half-precision float).  */\n-\n-    /* ISA Quirks (errata?).  Don't forget to add this to the list of\n-       all quirks below.  */\n-    isa_quirk_no_volatile_ce,\t/* No volatile memory in IT blocks.  */\n-    isa_quirk_ARMv6kz,\t\t/* Previously mis-identified by GCC.  */\n-    isa_quirk_cm3_ldrd,\t\t/* Cortex-M3 LDRD quirk.  */\n-\n-    /* Aren't currently, but probably should be tuning bits.  */\n-    isa_bit_smallmul,\t/* Slow multiply operations.  */\n-\n-    /* Tuning bits.  Should be elsewhere.  */\n-    isa_tune_co_proc,\t/* Has co-processor bus.  */\n-    isa_tune_ldsched,\t/* Load scheduling necessary.  */\n-    isa_tune_strong,\t/* StrongARM.  */\n-    isa_tune_wbuf,\t/* Schedule for write buffer ops (ARM6 & 7 only).  */\n-\n-    /* Must be last, used to dimension arrays.  */\n-    isa_num_bits\n-  };\n-\n-/* Helper macros for use when defining CPUs and architectures.\n-\n-   There must be no parenthesees in these lists, since they are used\n-   to initialize arrays.  */\n-\n-#define ISA_ARMv2\tisa_bit_notm\n-#define ISA_ARMv3\tISA_ARMv2, isa_bit_mode32\n-#define ISA_ARMv3m\tISA_ARMv3, isa_bit_ARMv3m\n-#define ISA_ARMv4\tISA_ARMv3m, isa_bit_ARMv4\n-#define ISA_ARMv4t\tISA_ARMv4, isa_bit_thumb\n-#define ISA_ARMv5\tISA_ARMv4, isa_bit_ARMv5\n-#define ISA_ARMv5t\tISA_ARMv5, isa_bit_thumb\n-#define ISA_ARMv5e\tISA_ARMv5, isa_bit_ARMv5e\n-#define ISA_ARMv5te\tISA_ARMv5e, isa_bit_thumb\n-#define ISA_ARMv5tej\tISA_ARMv5te\n-#define ISA_ARMv6\tISA_ARMv5te, isa_bit_ARMv6, isa_bit_be8\n-#define ISA_ARMv6j\tISA_ARMv6\n-#define ISA_ARMv6k\tISA_ARMv6, isa_bit_ARMv6k\n-#define ISA_ARMv6z\tISA_ARMv6\n-#define ISA_ARMv6kz\tISA_ARMv6k, isa_quirk_ARMv6kz\n-#define ISA_ARMv6zk\tISA_ARMv6k\n-#define ISA_ARMv6t2\tISA_ARMv6, isa_bit_thumb2\n-\n-/* This is suspect.  ARMv6-m doesn't really pull in any useful features\n-   from ARMv5* or ARMv6.  */\n-#define ISA_ARMv6m\tisa_bit_mode32, isa_bit_ARMv3m, isa_bit_ARMv4, \\\n-    isa_bit_thumb, isa_bit_ARMv5, isa_bit_ARMv5e, isa_bit_ARMv6\n-/* This is suspect, the 'common' ARMv7 subset excludes the thumb2 'DSP' and\n-   integer SIMD instructions that are in ARMv6T2.  */\n-#define ISA_ARMv7\tISA_ARMv6m, isa_bit_thumb2, isa_bit_ARMv7\n-#define ISA_ARMv7a\tISA_ARMv7, isa_bit_notm, isa_bit_ARMv6k\n-#define ISA_ARMv7ve\tISA_ARMv7a, isa_bit_adiv, isa_bit_tdiv, isa_bit_lpae\n-#define ISA_ARMv7r\tISA_ARMv7a, isa_bit_tdiv\n-#define ISA_ARMv7m\tISA_ARMv7, isa_bit_tdiv\n-#define ISA_ARMv7em\tISA_ARMv7m, isa_bit_ARMv7em\n-#define ISA_ARMv8a\tISA_ARMv7ve, isa_bit_ARMv8\n-#define ISA_ARMv8_1a\tISA_ARMv8a, isa_bit_crc32, isa_bit_ARMv8_1\n-#define ISA_ARMv8_2a\tISA_ARMv8_1a, isa_bit_ARMv8_2\n-#define ISA_ARMv8m_base ISA_ARMv6m, isa_bit_ARMv8, isa_bit_cmse, isa_bit_tdiv\n-#define ISA_ARMv8m_main ISA_ARMv7m, isa_bit_ARMv8, isa_bit_cmse\n-#define ISA_ARMv8r\tISA_ARMv8a\n-\n-/* List of all cryptographic extensions to stripout if crypto is\n-   disabled.  Currently, that's trivial, but we define it anyway for\n-   consistency with the SIMD and FP disable lists.  */\n-#define ISA_ALL_CRYPTO\tisa_bit_crypto\n-\n-/* List of all SIMD bits to strip out if SIMD is disabled.  This does\n-   strip off 32 D-registers, but does not remove support for\n-   double-precision FP.  */\n-#define ISA_ALL_SIMD\tisa_bit_fp_d32, isa_bit_neon, ISA_ALL_CRYPTO\n-\n-/* List of all FPU bits to strip out if -mfpu is used to override the\n-   default.  isa_bit_fp16 is deliberately missing from this list.  */\n-#define ISA_ALL_FPU_INTERNAL\t\t\t\t\t\t\\\n-  isa_bit_VFPv2, isa_bit_VFPv3, isa_bit_VFPv4, isa_bit_FPv5,\t\t\\\n-  isa_bit_fp16conv, isa_bit_fp_dbl, ISA_ALL_SIMD\n-\n-/* Similarly, but including fp16 and other extensions that aren't part of\n-   -mfpu support.  */\n-#define ISA_ALL_FP\tisa_bit_fp16, ISA_ALL_FPU_INTERNAL\n-\n-/* Useful combinations.  */\n-#define ISA_VFPv2\tisa_bit_VFPv2\n-#define ISA_VFPv3\tISA_VFPv2, isa_bit_VFPv3\n-#define ISA_VFPv4\tISA_VFPv3, isa_bit_VFPv4, isa_bit_fp16conv\n-#define ISA_FPv5\tISA_VFPv4, isa_bit_FPv5\n-\n-#define ISA_FP_DBL\tisa_bit_fp_dbl\n-#define ISA_FP_D32\tISA_FP_DBL, isa_bit_fp_d32\n-#define ISA_FP_ARMv8\tISA_FPv5, ISA_FP_D32\n-#define ISA_NEON\tISA_FP_D32, isa_bit_neon\n-#define ISA_CRYPTO\tISA_NEON, isa_bit_crypto\n-\n-/* List of all quirk bits to strip out when comparing CPU features with\n-   architectures.  */\n-#define ISA_ALL_QUIRKS\tisa_quirk_no_volatile_ce, isa_quirk_ARMv6kz,\t\\\n-    isa_quirk_cm3_ldrd\n-\n-/* Helper macro so that we can concatenate multiple features together\n-   with arm-*.def files, since macro substitution can't have commas within an\n-   argument that lacks parenthesis.  */\n-#define ISA_FEAT(X)\tX,\n-#endif"}, {"sha": "3e5438ac5c4f6b8aaf347d8ba54af56a6cf58d0b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -3367,22 +3367,22 @@ arm_option_override (void)\n \n   /* Initialize boolean versions of the architectural flags, for use\n      in the arm.md file.  */\n-  arm_arch3m = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv3m);\n-  arm_arch4 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv4);\n+  arm_arch3m = bitmap_bit_p (arm_active_target.isa, isa_bit_armv3m);\n+  arm_arch4 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv4);\n   arm_arch4t = arm_arch4 && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n-  arm_arch5 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv5);\n-  arm_arch5e = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv5e);\n+  arm_arch5 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5);\n+  arm_arch5e = bitmap_bit_p (arm_active_target.isa, isa_bit_armv5e);\n   arm_arch5te = arm_arch5e\n     && bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n-  arm_arch6 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv6);\n-  arm_arch6k = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv6k);\n+  arm_arch6 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6);\n+  arm_arch6k = bitmap_bit_p (arm_active_target.isa, isa_bit_armv6k);\n   arm_arch_notm = bitmap_bit_p (arm_active_target.isa, isa_bit_notm);\n   arm_arch6m = arm_arch6 && !arm_arch_notm;\n-  arm_arch7 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv7);\n-  arm_arch7em = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv7em);\n-  arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8);\n-  arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8_1);\n-  arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_ARMv8_2);\n+  arm_arch7 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7);\n+  arm_arch7em = bitmap_bit_p (arm_active_target.isa, isa_bit_armv7em);\n+  arm_arch8 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8);\n+  arm_arch8_1 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_1);\n+  arm_arch8_2 = bitmap_bit_p (arm_active_target.isa, isa_bit_armv8_2);\n   arm_arch_thumb1 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb);\n   arm_arch_thumb2 = bitmap_bit_p (arm_active_target.isa, isa_bit_thumb2);\n   arm_arch_xscale = bitmap_bit_p (arm_active_target.isa, isa_bit_xscale);\n@@ -3412,9 +3412,9 @@ arm_option_override (void)\n \n   /* And finally, set up some quirks.  */\n   arm_arch_no_volatile_ce\n-    = bitmap_bit_p (arm_active_target.isa, isa_quirk_no_volatile_ce);\n-  arm_arch6kz\n-    = arm_arch6k && bitmap_bit_p (arm_active_target.isa, isa_quirk_ARMv6kz);\n+    = bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_no_volatile_ce);\n+  arm_arch6kz = arm_arch6k && bitmap_bit_p (arm_active_target.isa,\n+\t\t\t\t\t    isa_bit_quirk_armv6kz);\n \n   /* V5 code we generate is completely interworking capable, so we turn off\n      TARGET_INTERWORK here to avoid many tests later on.  */\n@@ -3459,7 +3459,7 @@ arm_option_override (void)\n       else if (TARGET_HARD_FLOAT_ABI)\n \t{\n \t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n-\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv2))\n+\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2))\n \t    error (\"-mfloat-abi=hard: selected processor lacks an FPU\");\n \t}\n       else\n@@ -3562,7 +3562,7 @@ arm_option_override (void)\n   /* Enable -mfix-cortex-m3-ldrd by default for Cortex-M3 cores.  */\n   if (fix_cm3_ldrd == 2)\n     {\n-      if (bitmap_bit_p (arm_active_target.isa, isa_quirk_cm3_ldrd))\n+      if (bitmap_bit_p (arm_active_target.isa, isa_bit_quirk_cm3_ldrd))\n \tfix_cm3_ldrd = 1;\n       else\n \tfix_cm3_ldrd = 0;"}, {"sha": "9a171b07033c4d8b856f74afc5da85bcbfa53487", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -122,7 +122,7 @@ extern tree arm_fp16_type_node;\n /* Use hardware floating point instructions. */\n #define TARGET_HARD_FLOAT\t(arm_float_abi != ARM_FLOAT_ABI_SOFT\t\\\n \t\t\t\t && bitmap_bit_p (arm_active_target.isa, \\\n-\t\t\t\t\t\t  isa_bit_VFPv2))\n+\t\t\t\t\t\t  isa_bit_vfpv2))\n #define TARGET_SOFT_FLOAT\t(!TARGET_HARD_FLOAT)\n /* User has permitted use of FP instructions, if they exist for this\n    target.  */\n@@ -169,10 +169,10 @@ extern tree arm_fp16_type_node;\n #define TARGET_VFPD32 (bitmap_bit_p (arm_active_target.isa, isa_bit_fp_d32))\n \n /* FPU supports VFPv3 instructions.  */\n-#define TARGET_VFP3 (bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv3))\n+#define TARGET_VFP3 (bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv3))\n \n /* FPU supports FPv5 instructions.  */\n-#define TARGET_VFP5 (bitmap_bit_p (arm_active_target.isa, isa_bit_FPv5))\n+#define TARGET_VFP5 (bitmap_bit_p (arm_active_target.isa, isa_bit_fpv5))\n \n /* FPU only supports VFP single-precision instructions.  */\n #define TARGET_VFP_SINGLE (!TARGET_VFP_DOUBLE)\n@@ -194,7 +194,7 @@ extern tree arm_fp16_type_node;\n   (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))\n \n /* FPU supports fused-multiply-add operations.  */\n-#define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_VFPv4))\n+#define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv4))\n \n /* FPU supports Crypto extensions.  */\n #define TARGET_CRYPTO (bitmap_bit_p (arm_active_target.isa, isa_bit_crypto))"}, {"sha": "d07d3fc39a52ba0269d553a73b067e9cdcdb6732", "filename": "gcc/config/arm/parsecpu.awk", "status": "modified", "additions": 129, "deletions": 58, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Fparsecpu.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Fparsecpu.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fparsecpu.awk?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -22,6 +22,7 @@\n #\tdata: Print the standard 'C' data tables for the CPUs\n #\tcommon-data: Print the 'C' data for shared driver/compiler files\n #\theaders: Print the standard 'C' headers for the CPUs\n+#\tisa: Generate the arm-isa.h header\n #\tmd: Print the machine description fragment\n #\topt: Print the option tables fragment\n #\tchkcpu <name>: Checks that <name> is a valid CPU\n@@ -83,9 +84,44 @@ function tune_flag_pfx (f) {\n     return \"TF_\" f\n }\n \n-function isa_pfx (f) {\n-    if (f ~ /^(bit|quirk)_.*/) return \"isa_\" f\n-    return \"ISA_\" f\n+# Print out the bits for the features in FLIST, which may be a\n+# mixture of fgroup and individual bits.  Print each feature needed\n+# exactly once.  Terminate the list with isa_nobit.  Prefix each line by\n+# INDENT.  Does not print a new line at the end.\n+function print_isa_bits_for (flist, indent) {\n+    nbits = split (flist, bits)\n+\n+    for (bit = 1; bit <= nbits; bit++) {\n+\tif (bits[bit] in features) {\n+\t    pbit[bits[bit]] = 1\n+\t} else if (bits[bit] in fgroup) {\n+\t    for (gbits in fgrp_bits) {\n+\t\tsplit (gbits, bitsep, SUBSEP)\n+\t\tif (bitsep[1] == bits[bit]) {\n+\t\t    pbit[bitsep[2]] = 1\n+\t\t}\n+\t    }\n+\t} else fatal(\"feature \" bits[bit] \" not declared\")\n+    }\n+    zbit = ORS\n+    ORS = \"\"\n+    print indent \"{\\n\" indent \"  \"\n+    ORS = \", \"\n+    count = 0\n+    for (bname in pbit) {\n+\tprint \"isa_bit_\" bname\n+\tcount++\n+\tif (count == 4) {\n+\t    count = 0\n+\t    ORS = \"\"\n+\t    print \"\\n\" indent \"  \"\n+\t    ORS = \", \"\n+\t}\n+    }\n+    ORS = \"\"\n+    print \"isa_nobit\\n\" indent \"}\"\n+    ORS = zbit\n+    delete pbit\n }\n \n function gen_headers () {\n@@ -125,6 +161,35 @@ function gen_headers () {\n     print \"};\"\n }\n \n+function gen_isa () {\n+    boilerplate(\"C\")\n+    print \"enum isa_feature {\"\n+    print \"  isa_nobit = 0,\"\n+    for (fbit in features) {\n+\tprint \"  isa_bit_\" fbit \",\"\n+    }\n+    print \"  isa_num_bits\"\n+    print \"};\\n\"\n+\n+    for (fgrp in fgroup) {\n+\tprint \"#define ISA_\"fgrp \" \\\\\"\n+\tz = ORS\n+\tORS = \"\"\n+\tfirst = 1\n+\tfor (bitcomb in fgrp_bits) {\n+\t    split (bitcomb, bitsep, SUBSEP)\n+\t    if (bitsep[1] == fgrp) {\n+\t\tif (first) {\n+\t\t    first = 0\n+\t\t} else print \", \\\\\\n\"\n+\t\tprint \"  isa_bit_\" bitsep[2]\n+\t    }\n+\t}\n+\tORS = z\n+\tprint \"\\n\"\n+    }\n+}\n+\n function gen_data () {\n     boilerplate(\"C\")\n \n@@ -155,7 +220,6 @@ function gen_data () {\n     }\n     print \"  {TARGET_CPU_arm_none, 0, NULL}\"\n     print \"};\"\n-    \n }\n \n function gen_comm_data () {\n@@ -172,8 +236,8 @@ function gen_comm_data () {\n \t\tprint \"  {\"\n \t\tprint \"    \\\"\" opts[opt] \"\\\", \" \\\n \t\t    cpu_opt_remove[cpus[n],opts[opt]] \", false,\"\n-\t\tprint \"    { \" cpu_opt_isa[cpus[n],opts[opt]] \", isa_nobit }\"\n-\t\tprint \"  },\"\n+\t\tprint_isa_bits_for(cpu_opt_isa[cpus[n],opts[opt]], \"    \")\n+\t\tprint \"\\n  },\"\n \t    }\n \t    if (cpus[n] in cpu_optaliases) {\n \t\tnaliases = split (cpu_optaliases[cpus[n]], aliases)\n@@ -188,8 +252,8 @@ function gen_comm_data () {\n \t\t    print \"  {\"\n \t\t    print \"    \\\"\" aliases[alias] \"\\\", \" \\\n \t\t\tcpu_opt_remove[cpus[n],equiv] \", true, \"\n-\t\t    print \"    { \" cpu_opt_isa[cpus[n],equiv] \", isa_nobit }\"\n-\t\t    print \"  },\"\n+\t\t    print_isa_bits_for(cpu_opt_isa[cpus[n],equiv], \"    \")\n+\t\t    print \"\\n  },\"\n \t\t}\n \t    }\n \t    print \"  { NULL, false, false, {isa_nobit}}\"\n@@ -214,51 +278,24 @@ function gen_comm_data () {\n \tif (! (feats[1] in arch_isa)) {\n \t    fatal(\"unknown arch \" feats[1] \" for cpu \" cpus[n])\n \t}\n-\tprint \"      {\"\n-\tprint \"        \" arch_isa[feats[1]] \",\"\n+\tall_isa_bits = arch_isa[feats[1]]\n \tfor (m = 2; m <= nfeats; m++) {\n \t    if (! ((feats[1], feats[m]) in arch_opt_isa)) {\n \t\tfatal(\"unknown feature \" feats[m] \" for architecture \" feats[1])\n \t    }\n \t    if (arch_opt_remove[feats[1],feats[m]] == \"true\") {\n \t\tfatal(\"cannot remove features from architecture specs\")\n \t    }\n-\t    # The isa_features array that is being initialized here has a length\n-\t    # of max isa_bit_num, which is the last entry in the enum.\n-\t    # Logically this means that the number of features is implicitly\n-\t    # never more than the number of feature bits we have.  This is only\n-\t    # true if we don't emit duplicates here.  So keep track of which\n-\t    # options we have already emitted so we don't emit them twice.\n-\t    nopts = split (arch_opt_isa[feats[1],feats[m]], opts, \",\")\n-\t    for (i = 1; i <= nopts; i++) {\n-\t\tif (! (opts[i] in seen)) {\n-\t\t  print \"        \" opts[i] \",\"\n-\t\t  seen[opts[i]]\n-\t\t}\n-\t    }\n+\t    all_isa_bits = all_isa_bits \" \" arch_opt_isa[feats[1],feats[m]]\n \t}\n \tif (cpus[n] in cpu_fpu) {\n-\t    nopts = split (fpu_isa[cpu_fpu[cpus[n]]], opts, \",\")\n-\t    for (i = 1; i <= nopts; i++) {\n-\t\tif (! (opts[i] in seen)) {\n-\t\t  print \"        \" opts[i] \",\"\n-\t\t  seen[opts[i]]\n-\t\t}\n-\t    }\n+\t    all_isa_bits = all_isa_bits \" \" fpu_isa[cpu_fpu[cpus[n]]]\n \t}\n \tif (cpus[n] in cpu_isa) {\n-\t    nopts = split (cpu_isa[cpus[n]], opts, \",\")\n-\t    for (i = 1; i <= nopts; i++) {\n-\t\tif (! (opts[i] in seen)) {\n-\t\t  print \"        \" opts[i] \",\"\n-\t\t  seen[opts[i]]\n-\t\t}\n-\t    }\n+\t    all_isa_bits = all_isa_bits \" \" cpu_isa[cpus[n]]\n \t}\n-\tdelete seen\n-\tprint \"        isa_nobit\"\n-\tprint \"      }\"\n-\tprint \"    },\"\n+\tprint_isa_bits_for(all_isa_bits, \"      \")\n+\tprint \"\\n    },\"\n \t# arch\n \tprint \"    TARGET_ARCH_\" arch_cnames[feats[1]]\n \tprint \"  },\"\n@@ -278,8 +315,8 @@ function gen_comm_data () {\n \t\tprint \"  {\"\n \t\tprint \"    \\\"\" opts[opt] \"\\\", \" \\\n \t\t    arch_opt_remove[archs[n],opts[opt]] \", false,\"\n-\t\tprint \"    { \" arch_opt_isa[archs[n],opts[opt]] \", isa_nobit }\"\n-\t\tprint \"  },\"\n+\t\tprint_isa_bits_for(arch_opt_isa[archs[n],opts[opt]], \"    \")\n+\t\tprint \"\\n  },\"\n \t    }\n \t    if (archs[n] in arch_optaliases) {\n \t\tnaliases = split (arch_optaliases[archs[n]], aliases)\n@@ -294,8 +331,8 @@ function gen_comm_data () {\n \t\t    print \"  {\"\n \t\t    print \"    \\\"\" aliases[alias] \"\\\", \" \\\n \t\t\tarch_opt_remove[archs[n],equiv] \", true, \"\n-\t\t    print \"    { \" arch_opt_isa[archs[n],equiv] \", isa_nobit }\"\n-\t\t    print \"  },\"\n+\t\t    print_isa_bits_for(arch_opt_isa[archs[n],equiv], \"    \")\n+\t\t    print \"\\n  },\"\n \t\t}\n \t    }\n \t    print \"  { NULL, false, false, {isa_nobit}}\"\n@@ -321,10 +358,8 @@ function gen_comm_data () {\n \t    print \"    arch_opttab_\" arch_cnames[archs[n]] \",\"\n \t} else print \"    NULL,\"\n \t# common.isa_bits\n-\tprint \"    {\"\n-\tprint \"      \" arch_isa[archs[n]] \",\"\n-\tprint \"      isa_nobit\"\n-\tprint \"    },\"\n+\tprint_isa_bits_for(arch_isa[archs[n]], \"    \")\n+\tprint \",\"\n \t# arch, base_arch\n \tprint \"    \\\"\" arch_base[archs[n]] \"\\\", BASE_ARCH_\" \\\n \t    arch_base[archs[n]] \",\"\n@@ -351,11 +386,8 @@ function gen_comm_data () {\n     for (n = 1; n <= nfpus; n++) {\n \tprint \"  {\"\n \tprint \"    \\\"\" fpus[n] \"\\\",\"\n-\tprint \"    {\"\n-\tprint \"      \" fpu_isa[fpus[n]] \",\"\n-\tprint \"      isa_nobit\"\n-\tprint \"    }\"\n-\tprint \"  },\"\n+\tprint_isa_bits_for(fpu_isa[fpus[n]], \"    \")\n+\tprint \"\\n  },\"\n     }\n \n     print \"};\"\n@@ -482,6 +514,43 @@ BEGIN {\n     parse_ok = 1\n }\n \n+/^define feature / {\n+    if (NF != 3) fatal(\"syntax: define feature <name>\")\n+    toplevel()\n+    fbit = $3\n+    if (fbit in features) fatal(\"feature \" fbit \" already defined\")\n+    features[fbit] = 1\n+    parse_ok = 1\n+}\n+\n+/^define fgroup / {\n+    if (NF < 4) fatal(\"syntax: define fgroup <name> <feature> [<feature>]*\")\n+    toplevel()\n+    fgrp = $3\n+    if (fgrp in fgroup) fatal(\"feature group \" fgrp \" already defined\")\n+    if (fgrp in features) fatal(\"feature group \" fgrp \" aliases a feature\")\n+    fcount = NF\n+    for (n = 4; n <= fcount; n++) {\n+\tfeat = $n\n+\tif (feat in features) {\n+\t    fgrp_bits[fgrp,feat] = 1\n+\t} else if (feat in fgroup) {\n+\t    # fgroups may reference other fgroups, copy their bits\n+\t    # to our bits.  To avoid recursion we don't set fgroup[fgrp]\n+\t    # until after we have done this, so such attempts will result\n+\t    # in an invalid group definition.\n+\t    for (bitcomb in fgrp_bits) {\n+\t\tsplit (bitcomb, bitsep, SUBSEP)\n+\t\tif (bitsep[1] == feat) {\n+\t\t    fgrp_bits[fgrp,bitsep[2]] = 1\n+\t\t}\n+\t    }\n+\t} else fatal(\"feature group member \" feat \" unrecognized\")\n+    }\n+    fgroup[fgrp] = 1\n+    parse_ok = 1\n+}\n+\n /^begin fpu / {\n     toplevel()\n     fpu_name = $3\n@@ -587,8 +656,8 @@ BEGIN {\n     flag_count = NF\n     for (n = 2; n <= flag_count; n++) {\n \tif (n == 2) {\n-\t    flags = isa_pfx($n)\n-\t} else flags = flags \",\" isa_pfx($n)\n+\t    flags = $n\n+\t} else flags = flags \" \" $n\n     }\n     if (cpu_name != \"\") {\n \tcpu_isa[cpu_name] = flags\n@@ -611,8 +680,8 @@ BEGIN {\n     flag_count = NF\n     for (n = 4; n <= flag_count; n++) {\n \tif (n == 4) {\n-\t    flags = isa_pfx($n)\n-\t} else flags = flags \",\" isa_pfx($n)\n+\t    flags = $n\n+\t} else flags = flags \" \" $n\n     }\n     if (cpu_name != \"\") {\n \tcpu_opts[cpu_name] = cpu_opts[cpu_name] \" \" name\n@@ -669,6 +738,8 @@ END {\n \tgen_comm_data()\n     } else if (cmd == \"headers\") {\n \tgen_headers()\n+    } else if (cmd == \"isa\") {\n+\tgen_isa()\n     } else if (cmd == \"md\") {\n \tgen_md()\n     } else if (cmd == \"opt\") {"}, {"sha": "d9ff654ba4182e28509ae9a818e4e38b9dc7d2ae", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdb0828f2d93221b2d54ec965f20e1cf1182d18d/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=bdb0828f2d93221b2d54ec965f20e1cf1182d18d", "patch": "@@ -18,8 +18,7 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-TM_H += arm-cpu.h\n-GTM_H += arm-cpu.h\n+GTM_H += arm-cpu.h arm-isa.h\n \n # All md files - except for arm.md.\n # This list should be kept in alphabetical order and updated whenever an md\n@@ -87,6 +86,14 @@ s-arm-cpu: $(srcdir)/config/arm/parsecpu.awk \\\n \t$(SHELL) $(srcdir)/../move-if-change tmp-arm-cpu.h arm-cpu.h\n \t$(STAMP) s-arm-cpu\n \n+arm-isa.h: s-arm-isa ; @true\n+s-arm-isa: $(srcdir)/config/arm/parsecpu.awk \\\n+  $(srcdir)/config/arm/arm-cpus.in\n+\t$(AWK) -f $(srcdir)/config/arm/parsecpu.awk -v cmd=isa \\\n+\t\t$(srcdir)/config/arm/arm-cpus.in > tmp-arm-isa.h\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-arm-isa.h arm-isa.h\n+\t$(STAMP) s-arm-isa\n+\n arm-cpu-data.h: s-arm-data ; @true\n s-arm-data: $(srcdir)/config/arm/parsecpu.awk \\\n   $(srcdir)/config/arm/arm-cpus.in"}]}