{"sha": "546b63fb94a89bdae2e8ec1ac74ea77a809458df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ2YjYzZmI5NGE4OWJkYWUyZThlYzFhYzc0ZWE3N2E4MDk0NThkZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:24:36Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T11:24:36Z"}, "message": "Add prototypes for static functions.\n\n(REGISTER_MOVE_COST, MEMORY_MOVE_COST): Include default definitions.\n(reload): Count number of registers needed for insn using new reload type\ninformation.\nIf mode of insn is DImode, don't change it.\nRefine the way we handle conflict with the return value register.\nDon't try to account for needs already covered by previously spilled\nregisters; instead, put them back in the front of potential_reload_regs and\nlet them be allocated again.\n(order_regs_for_reload): Don't restrict regs explicitly used if we have\nSMALL_REGISTER_CLASSES defined.\n(reload_as_needed): Don't need to deactivate optional reloads ever; if they\ninherit, it must have been safe.\nCall merge_assigned_reloads if SMALL_REGISTER_CLASSES.\n(reload_reg_used_*): Refine our tracking of reload reg usage by defining more\nof these HARD_REG_SETs.\n(mark_reload_reg_in_use, reload_reg_free_p): Rework to use new method of\ndescribing where a reload register is used.\n(reload_reg_free_before_p, reload_reg_reaches_end_p): Likewise.\n(allocate_reload_reg): Pass new reload descriptions.\n(choose_reload_regs): Likewise.\nSave and restore the new HARD_REG_SETs.\nRemove now-redundant code to prevent conflicts.\n(merge_assigned_reloads): New function.\n(emit_reload_insns): Output each reload type into its own sequence, then\noutput the sequences in the proper order.\nPut our output reloads after a CLOBBER made by find_reloads.\nPass ALL_REGS to find_equiv_regs; nothing special about GENERAL_REGS.\nDon't use an old equivalence if doing so would be more expensive.\nClean up tracking of values still in reload regs using reload description\ninfo to see if the reload reaches the end of the insn.\n(gen_input_reload): Pass reload description and emit insns to end of current\nsequence.\n(inc_for_reload): Return void; no longer need INSN as operand.\nEmit insns to end of current sequence.\n\nFrom-SVN: r3910", "tree": {"sha": "c12570b807a6c58c116e33b23f2e87f5b1daa24d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c12570b807a6c58c116e33b23f2e87f5b1daa24d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/546b63fb94a89bdae2e8ec1ac74ea77a809458df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546b63fb94a89bdae2e8ec1ac74ea77a809458df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546b63fb94a89bdae2e8ec1ac74ea77a809458df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546b63fb94a89bdae2e8ec1ac74ea77a809458df/comments", "author": null, "committer": null, "parents": [{"sha": "f81497d9055fc3635140c6d6ecaf00f06a5509a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f81497d9055fc3635140c6d6ecaf00f06a5509a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f81497d9055fc3635140c6d6ecaf00f06a5509a1"}], "stats": {"total": 1502, "additions": 987, "deletions": 515}, "files": [{"sha": "ac8eaf6ed7f7464648b5f15c1bf164eb8362d601", "filename": "gcc/reload1.c", "status": "modified", "additions": 987, "deletions": 515, "changes": 1502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/546b63fb94a89bdae2e8ec1ac74ea77a809458df/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/546b63fb94a89bdae2e8ec1ac74ea77a809458df/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=546b63fb94a89bdae2e8ec1ac74ea77a809458df", "patch": "@@ -66,6 +66,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    reload needs, spilling, assigning reload registers to use for\n    fixing up each insn, and generating the new insns to copy values\n    into the reload registers.  */\n+\n+\n+#ifndef REGISTER_MOVE_COST\n+#define REGISTER_MOVE_COST(x, y) 2\n+#endif\n+\n+#ifndef MEMORY_MOVE_COST\n+#define MEMORY_MOVE_COST(x) 4\n+#endif\n \f\n /* During reload_as_needed, element N contains a REG rtx for the hard reg\n    into which pseudo reg N has been reloaded (perhaps for a previous insn). */\n@@ -147,8 +156,8 @@ HARD_REG_SET forbidden_regs;\n \n /* This reg set indicates registers that are not good for spill registers.\n    They will not be used to complete groups of spill registers.  This includes\n-   all fixed registers, registers that may be eliminated, and registers\n-   explicitly used in the rtl.\n+   all fixed registers, registers that may be eliminated, and, if\n+   SMALL_REGISTER_CLASSES is not defined, registers explicitly used in the rtl.\n \n    (spill_reg_order prevents these registers from being used to start a\n    group.)  */\n@@ -307,34 +316,47 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n /* Number of labels in the current function.  */\n \n static int num_labels;\n+\n+struct hard_reg_n_uses { int regno; int uses; };\n \f\n-void mark_home_live ();\n-static void count_possible_groups ();\n-static int possible_group_p ();\n-static void scan_paradoxical_subregs ();\n-static void reload_as_needed ();\n-static int modes_equiv_for_class_p ();\n-static void alter_reg ();\n-static void delete_dead_insn ();\n-static void spill_failure ();\n-static int new_spill_reg();\n-static void set_label_offsets ();\n-static int eliminate_regs_in_insn ();\n-static void mark_not_eliminable ();\n-static int spill_hard_reg ();\n-static void choose_reload_regs ();\n-static void emit_reload_insns ();\n-static void delete_output_reload ();\n-static void forget_old_reloads_1 ();\n-static void order_regs_for_reload ();\n-static rtx inc_for_reload ();\n-static int constraint_accepts_reg_p ();\n-static int count_occurrences ();\n-\n-extern void remove_death ();\n-extern rtx adj_offsettable_operand ();\n-extern rtx form_sum ();\n+static int possible_group_p\t\tPROTO((int, int *));\n+static void count_possible_groups\tPROTO((int *, enum machine_mode *,\n+\t\t\t\t\t       int *));\n+static int modes_equiv_for_class_p\tPROTO((enum machine_mode,\n+\t\t\t\t\t       enum machine_mode,\n+\t\t\t\t\t       enum reg_class));\n+static void spill_failure\t\tPROTO((rtx));\n+static int new_spill_reg\t\tPROTO((int, int, int *, int *, int,\n+\t\t\t\t\t       FILE *));\n+static void delete_dead_insn\t\tPROTO((rtx));\n+static void alter_reg  \t\t\tPROTO((int, int));\n+static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n+static int eliminate_regs_in_insn\tPROTO((rtx, int));\n+static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n+static int spill_hard_reg\t\tPROTO((int, int, FILE *, int));\n+static void scan_paradoxical_subregs\tPROTO((rtx));\n+static int hard_reg_use_compare\t\tPROTO((struct hard_reg_n_uses *,\n+\t\t\t\t\t       struct hard_reg_n_uses *));\n+static void order_regs_for_reload\tPROTO((void));\n+static void reload_as_needed\t\tPROTO((rtx, int));\n+static void forget_old_reloads_1\tPROTO((rtx));\n+static int reload_reg_class_lower\tPROTO((short *, short *));\n+static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n+\t\t\t\t\t       enum machine_mode));\n+static int reload_reg_free_p\t\tPROTO((int, int, enum reload_type));\n+static int reload_reg_free_before_p\tPROTO((int, int, enum reload_type));\n+static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n+static int allocate_reload_reg\t\tPROTO((int, rtx, int, int));\n+static void choose_reload_regs\t\tPROTO((rtx, rtx));\n+static void merge_assigned_reloads\tPROTO((rtx));\n+static void emit_reload_insns\t\tPROTO((rtx));\n+static void delete_output_reload\tPROTO((rtx, int, rtx));\n+static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n+static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n+static int count_occurrences\t\tPROTO((rtx, rtx));\n \f\n+/* Initialize the reload pass once per compilation.  */\n+\n void\n init_reload ()\n {\n@@ -484,8 +506,7 @@ init_reload ()\n \n }\n \n-/* Main entry point for the reload pass, and only entry point\n-   in this file.\n+/* Main entry point for the reload pass.\n \n    FIRST is the first insn of the function being compiled.\n \n@@ -510,7 +531,7 @@ reload (first, global, dumpfile)\n      FILE *dumpfile;\n {\n   register int class;\n-  register int i;\n+  register int i, j;\n   register rtx insn;\n   register struct elim_table *ep;\n \n@@ -966,27 +987,65 @@ reload (first, global, dumpfile)\n \t      int old_code = INSN_CODE (insn);\n  \t      rtx old_notes = REG_NOTES (insn);\n \t      int did_elimination = 0;\n-\n-\t      /* Initially, count RELOAD_OTHER reloads.\n-\t\t Later, merge in the other kinds.  */\n+\t      int max_total_input_groups = 0, max_total_output_groups = 0;\n+\n+\t      /* To compute the number of reload registers of each class \n+\t\t needed for an insn, we must similate what choose_reload_regs\n+\t\t can do.  We do this by splitting an insn into an \"input\" and\n+\t\t an \"output\" part.  RELOAD_OTHER reloads are used in both. \n+\t\t The input part uses those reloads, RELOAD_FOR_INPUT reloads,\n+\t\t which must be live over the entire input section of reloads,\n+\t\t and the maximum of all the RELOAD_FOR_INPUT_ADDRESS and\n+\t\t RELOAD_FOR_OPERAND_ADDRESS reloads, which conflict with the\n+\t\t inputs.\n+\n+\t\t The registers needed for output are RELOAD_OTHER and\n+\t\t RELOAD_FOR_OUTPUT, which are live for the entire output\n+\t\t portion, and the maximum of all the RELOAD_FOR_OUTPUT_ADDRESS\n+\t\t reloads for each operand.\n+\n+\t\t The total number of registers needed is the maximum of the\n+\t\t inputs and outputs.  */\n+\n+\t      /* These just count RELOAD_OTHER.  */\n \t      int insn_needs[N_REG_CLASSES];\n \t      int insn_groups[N_REG_CLASSES];\n \t      int insn_total_groups = 0;\n \n-\t      /* Count RELOAD_FOR_INPUT_RELOAD_ADDRESS reloads.  */\n+\t      /* Count RELOAD_FOR_INPUT reloads.  */\n \t      int insn_needs_for_inputs[N_REG_CLASSES];\n \t      int insn_groups_for_inputs[N_REG_CLASSES];\n \t      int insn_total_groups_for_inputs = 0;\n \n-\t      /* Count RELOAD_FOR_OUTPUT_RELOAD_ADDRESS reloads.  */\n+\t      /* Count RELOAD_FOR_OUTPUT reloads.  */\n \t      int insn_needs_for_outputs[N_REG_CLASSES];\n \t      int insn_groups_for_outputs[N_REG_CLASSES];\n \t      int insn_total_groups_for_outputs = 0;\n \n+\t      /* Count RELOAD_FOR_INSN reloads.  */\n+\t      int insn_needs_for_insn[N_REG_CLASSES];\n+\t      int insn_groups_for_insn[N_REG_CLASSES];\n+\t      int insn_total_groups_for_insn = 0;\n+\n+\t      /* Count RELOAD_FOR_OTHER_ADDRESS reloads.  */\n+\t      int insn_needs_for_other_addr[N_REG_CLASSES];\n+\t      int insn_groups_for_other_addr[N_REG_CLASSES];\n+\t      int insn_total_groups_for_other_addr = 0;\n+\n+\t      /* Count RELOAD_FOR_INPUT_ADDRESS reloads.  */\n+\t      int insn_needs_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_groups_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_total_groups_for_in_addr[MAX_RECOG_OPERANDS];\n+\n+\t      /* Count RELOAD_FOR_OUTPUT_ADDRESS reloads.  */\n+\t      int insn_needs_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_groups_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_total_groups_for_out_addr[MAX_RECOG_OPERANDS];\n+\n \t      /* Count RELOAD_FOR_OPERAND_ADDRESS reloads.  */\n-\t      int insn_needs_for_operands[N_REG_CLASSES];\n-\t      int insn_groups_for_operands[N_REG_CLASSES];\n-\t      int insn_total_groups_for_operands = 0;\n+\t      int insn_needs_for_op_addr[N_REG_CLASSES];\n+\t      int insn_groups_for_op_addr[N_REG_CLASSES];\n+\t      int insn_total_groups_for_op_addr = 0;\n \n #if 0  /* This wouldn't work nowadays, since optimize_bit_field\n \t  looks for non-strict memory addresses.  */\n@@ -1055,6 +1114,7 @@ reload (first, global, dumpfile)\n \n \t      PUT_MODE (insn, (did_elimination ? QImode\n \t\t\t       : n_reloads ? HImode\n+\t\t\t       : GET_MODE (insn) == DImode ? DImode\n \t\t\t       : VOIDmode));\n \n \t      /* Discard any register replacements done.  */\n@@ -1083,9 +1143,26 @@ reload (first, global, dumpfile)\n \t\t  insn_needs[i] = 0, insn_groups[i] = 0;\n \t\t  insn_needs_for_inputs[i] = 0, insn_groups_for_inputs[i] = 0;\n \t\t  insn_needs_for_outputs[i] = 0, insn_groups_for_outputs[i] = 0;\n-\t\t  insn_needs_for_operands[i] = 0, insn_groups_for_operands[i] = 0;\n+\t\t  insn_needs_for_insn[i] = 0, insn_groups_for_insn[i] = 0;\n+\t\t  insn_needs_for_op_addr[i] = 0, insn_groups_for_op_addr[i] = 0;\n+\t\t  insn_needs_for_other_addr[i] = 0;\n+\t\t  insn_groups_for_other_addr[i] = 0;\n \t\t}\n \n+\t      for (i = 0; i < reload_n_operands; i++)\n+\t\t{\n+\t\t  insn_total_groups_for_in_addr[i] = 0;\n+\t\t  insn_total_groups_for_out_addr[i] = 0;\n+\n+\t\t  for (j = 0; j < N_REG_CLASSES; j++)\n+\t\t    {\n+\t\t      insn_needs_for_in_addr[i][j] = 0;\n+\t\t      insn_needs_for_out_addr[i][j] = 0;\n+\t\t      insn_groups_for_in_addr[i][j] = 0;\n+\t\t      insn_groups_for_out_addr[i][j] = 0;\n+\t\t    }\n+\t\t}\n+\t\t    \n \t      /* Count each reload once in every class\n \t\t containing the reload's own class.  */\n \n@@ -1123,29 +1200,53 @@ reload (first, global, dumpfile)\n \t\t  switch (reload_when_needed[i])\n \t\t    {\n \t\t    case RELOAD_OTHER:\n-\t\t    case RELOAD_FOR_OUTPUT:\n-\t\t    case RELOAD_FOR_INPUT:\n \t\t      this_needs = insn_needs;\n \t\t      this_groups = insn_groups;\n \t\t      this_total_groups = &insn_total_groups;\n \t\t      break;\n \n-\t\t    case RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n+\t\t    case RELOAD_FOR_INPUT:\n \t\t      this_needs = insn_needs_for_inputs;\n \t\t      this_groups = insn_groups_for_inputs;\n \t\t      this_total_groups = &insn_total_groups_for_inputs;\n \t\t      break;\n \n-\t\t    case RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n+\t\t    case RELOAD_FOR_OUTPUT:\n \t\t      this_needs = insn_needs_for_outputs;\n \t\t      this_groups = insn_groups_for_outputs;\n \t\t      this_total_groups = &insn_total_groups_for_outputs;\n \t\t      break;\n \n+\t\t    case RELOAD_FOR_INSN:\n+\t\t      this_needs = insn_needs_for_insn;\n+\t\t      this_groups = insn_groups_for_outputs;\n+\t\t      this_total_groups = &insn_total_groups_for_insn;\n+\t\t      break;\n+\n+\t\t    case RELOAD_FOR_OTHER_ADDRESS:\n+\t\t      this_needs = insn_needs_for_other_addr;\n+\t\t      this_groups = insn_groups_for_other_addr;\n+\t\t      this_total_groups = &insn_total_groups_for_other_addr;\n+\t\t      break;\n+\n+\t\t    case RELOAD_FOR_INPUT_ADDRESS:\n+\t\t      this_needs = insn_needs_for_in_addr[reload_opnum[i]];\n+\t\t      this_groups = insn_groups_for_in_addr[reload_opnum[i]];\n+\t\t      this_total_groups\n+\t\t\t= &insn_total_groups_for_in_addr[reload_opnum[i]];\n+\t\t      break;\n+\n+\t\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n+\t\t      this_needs = insn_needs_for_out_addr[reload_opnum[i]];\n+\t\t      this_groups = insn_groups_for_out_addr[reload_opnum[i]];\n+\t\t      this_total_groups\n+\t\t\t= &insn_total_groups_for_out_addr[reload_opnum[i]];\n+\t\t      break;\n+\n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t      this_needs = insn_needs_for_operands;\n-\t\t      this_groups = insn_groups_for_operands;\n-\t\t      this_total_groups = &insn_total_groups_for_operands;\n+\t\t      this_needs = insn_needs_for_op_addr;\n+\t\t      this_groups = insn_groups_for_op_addr;\n+\t\t      this_total_groups = &insn_total_groups_for_op_addr;\n \t\t      break;\n \t\t    }\n \n@@ -1210,24 +1311,82 @@ reload (first, global, dumpfile)\n \n \t      for (i = 0; i < N_REG_CLASSES; i++)\n \t\t{\n-\t\t  int this_max;\n-\t\t  this_max = insn_needs_for_inputs[i];\n-\t\t  if (insn_needs_for_outputs[i] > this_max)\n-\t\t    this_max = insn_needs_for_outputs[i];\n-\t\t  if (insn_needs_for_operands[i] > this_max)\n-\t\t    this_max = insn_needs_for_operands[i];\n-\t\t  insn_needs[i] += this_max;\n-\t\t  this_max = insn_groups_for_inputs[i];\n-\t\t  if (insn_groups_for_outputs[i] > this_max)\n-\t\t    this_max = insn_groups_for_outputs[i];\n-\t\t  if (insn_groups_for_operands[i] > this_max)\n-\t\t    this_max = insn_groups_for_operands[i];\n-\t\t  insn_groups[i] += this_max;\n+\t\t  int in_max, out_max;\n+\n+\t\t  for (in_max = 0, out_max = 0, j = 0;\n+\t\t       j < reload_n_operands; j++)\n+\t\t    {\n+\t\t      in_max = MAX (in_max, insn_needs_for_in_addr[j][i]);\n+\t\t      out_max = MAX (out_max, insn_needs_for_out_addr[j][i]);\n+\t\t    }\n+\n+\t\t  /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n+\t\t     and operand addresses but not things used to reload them.\n+\t\t     Similarly, RELOAD_FOR_OPERAND_ADDRESS reloads don't\n+\t\t     conflict with things needed to reload inputs or\n+\t\t     outputs. */\n+\n+\t\t  in_max = MAX (in_max, insn_needs_for_op_addr[i]);\n+\t\t  out_max = MAX (out_max, insn_needs_for_insn[i]);\n+\n+\t\t  insn_needs_for_inputs[i]\n+\t\t    = MAX (insn_needs_for_inputs[i]\n+\t\t\t   + insn_needs_for_op_addr[i]\n+\t\t\t   + insn_needs_for_insn[i],\n+\t\t\t   in_max + insn_needs_for_inputs[i]);\n+\n+\t\t  insn_needs_for_outputs[i] += out_max;\n+\t\t  insn_needs[i] += MAX (MAX (insn_needs_for_inputs[i],\n+\t\t\t\t\t     insn_needs_for_outputs[i]),\n+\t\t\t\t\tinsn_needs_for_other_addr[i]);\n+\n+\t\t  for (in_max = 0, out_max = 0, j = 0;\n+\t\t       j < reload_n_operands; j++)\n+\t\t    {\n+\t\t      in_max = MAX (in_max, insn_groups_for_in_addr[j][i]);\n+\t\t      out_max = MAX (out_max, insn_groups_for_out_addr[j][i]);\n+\t\t    }\n+\n+\t\t  in_max = MAX (in_max, insn_groups_for_op_addr[i]);\n+\t\t  out_max = MAX (out_max, insn_groups_for_insn[i]);\n+\n+\t\t  insn_groups_for_inputs[i]\n+\t\t    = MAX (insn_groups_for_inputs[i]\n+\t\t\t   + insn_groups_for_op_addr[i]\n+\t\t\t   + insn_groups_for_insn[i],\n+\t\t\t   in_max + insn_groups_for_inputs[i]);\n+\n+\t\t  insn_groups_for_outputs[i] += out_max;\n+\t\t  insn_groups[i] += MAX (MAX (insn_groups_for_inputs[i],\n+\t\t\t\t\t      insn_groups_for_outputs[i]),\n+\t\t\t\t\t insn_groups_for_other_addr[i]);\n \t\t}\n \n-\t      insn_total_groups += MAX (insn_total_groups_for_inputs,\n-\t\t\t\t\tMAX (insn_total_groups_for_outputs,\n-\t\t\t\t\t     insn_total_groups_for_operands));\n+\t      for (i = 0; i < reload_n_operands; i++)\n+\t\t{\n+\t\t  max_total_input_groups\n+\t\t    = MAX (max_total_input_groups,\n+\t\t\t   insn_total_groups_for_in_addr[i]);\n+\t\t  max_total_output_groups\n+\t\t    = MAX (max_total_output_groups,\n+\t\t\t   insn_total_groups_for_out_addr[i]);\n+\t\t}\n+\n+\t      max_total_input_groups = MAX (max_total_input_groups,\n+\t\t\t\t\t    insn_total_groups_for_op_addr);\n+\t      max_total_output_groups = MAX (max_total_output_groups,\n+\t\t\t\t\t     insn_total_groups_for_insn);\n+\n+\t      insn_total_groups_for_inputs\n+\t\t= MAX (max_total_input_groups + insn_total_groups_for_op_addr\n+\t\t       + insn_total_groups_for_insn,\n+\t\t       max_total_input_groups + insn_total_groups_for_inputs);\n+\n+\t      insn_total_groups_for_outputs += max_total_output_groups;\n+\n+\t      insn_total_groups += MAX (MAX (insn_total_groups_for_outputs,\n+\t\t\t\t\t     insn_total_groups_for_inputs),\n+\t\t\t\t\tinsn_total_groups_for_other_addr);\n \n \t      /* If this is a CALL_INSN and caller-saves will need\n \t\t a spill register, act as if the spill register is\n@@ -1293,16 +1452,52 @@ reload (first, global, dumpfile)\n \t\t  int nregs\n \t\t    = HARD_REGNO_NREGS (regno, GET_MODE (avoid_return_reg));\n \t\t  int r;\n+\t\t  int basic_needs[N_REG_CLASSES], basic_groups[N_REG_CLASSES];\n+\n+\t\t  /* First compute the \"basic needs\", which counts a\n+\t\t     need only in the smallest class in which it\n+\t\t     is required.  */\n+\n+\t\t  bcopy (insn_needs, basic_needs, sizeof basic_needs);\n+\t\t  bcopy (insn_groups, basic_groups, sizeof basic_groups);\n+\n+\t\t  for (i = 0; i < N_REG_CLASSES; i++)\n+\t\t    {\n+\t\t      enum reg_class *p;\n+\n+\t\t      if (basic_needs[i] >= 0)\n+\t\t\tfor (p = reg_class_superclasses[i];\n+\t\t\t     *p != LIM_REG_CLASSES; p++)\n+\t\t\t  basic_needs[(int) *p] -= basic_needs[i];\n+\n+\t\t      if (basic_groups[i] >= 0)\n+\t\t\tfor (p = reg_class_superclasses[i];\n+\t\t\t     *p != LIM_REG_CLASSES; p++)\n+\t\t\t  basic_groups[(int) *p] -= basic_groups[i];\n+\t\t    }\n+\n+\t\t  /* Now count extra regs if there might be a conflict with\n+\t\t     the return value register.\n+\n+\t\t     ??? This is not quite correct because we don't properly\n+\t\t     handle the case of groups, but if we end up doing\n+\t\t     something wrong, it either will end up not mattering or\n+\t\t     we will abort elsewhere.  */\n+\t\t   \n \t\t  for (r = regno; r < regno + nregs; r++)\n \t\t    if (spill_reg_order[r] >= 0)\n \t\t      for (i = 0; i < N_REG_CLASSES; i++)\n \t\t\tif (TEST_HARD_REG_BIT (reg_class_contents[i], r))\n \t\t\t  {\n-\t\t\t    /* ??? It's not clear what is really\n-\t\t\t       right to do if this insn needs a group.\n-\t\t\t       But maybe that cannot happen.  */\n-\t\t\t    if (insn_needs[i] > 0 || insn_groups[i] > 0)\n-\t\t\t      insn_needs[i]++;\n+\t\t\t    if (basic_needs[i] > 0 || basic_groups[i] > 0)\n+\t\t\t      {\n+\t\t\t\tenum reg_class *p;\n+\n+\t\t\t\tinsn_needs[i]++;\n+\t\t\t\tp = reg_class_superclasses[i];\n+\t\t\t\twhile (*p != LIM_REG_CLASSES)\n+\t\t\t\t  insn_needs[(int) *p++]++;\n+\t\t\t      }\n \t\t\t  }\n \t\t}\n #endif /* SMALL_REGISTER_CLASSES */\n@@ -1376,87 +1571,6 @@ reload (first, global, dumpfile)\n \t  something_changed = 1;\n \t}\n \n-      /* Now deduct from the needs for the registers already\n-\t available (already spilled).  */\n-\n-      CLEAR_HARD_REG_SET (counted_for_groups);\n-      CLEAR_HARD_REG_SET (counted_for_nongroups);\n-\n-      /* First find all regs alone in their class\n-\t and count them (if desired) for non-groups.\n-\t We would be screwed if a group took the only reg in a class\n-\t for which a non-group reload is needed.\n-\t (Note there is still a bug; if a class has 2 regs,\n-\t both could be stolen by groups and we would lose the same way.\n-\t With luck, no machine will need a nongroup in a 2-reg class.)  */\n-\n-      for (i = 0; i < n_spills; i++)\n-\t{\n-\t  register enum reg_class *p;\n-\t  class = (int) REGNO_REG_CLASS (spill_regs[i]);\n-\n-\t  if (reg_class_size[class] == 1 && max_nongroups[class] > 0)\n-\t    {\n-\t      max_needs[class]--;\n-\t      p = reg_class_superclasses[class];\n-\t      while (*p != LIM_REG_CLASSES)\n-\t\tmax_needs[(int) *p++]--;\n-\n-\t      SET_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]);\n-\t      max_nongroups[class]--;\n-\t      p = reg_class_superclasses[class];\n-\t      while (*p != LIM_REG_CLASSES)\n-\t\t{\n-\t\t  if (max_nongroups[(int) *p] > 0)\n-\t\t    SET_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]);\n-\t\t  max_nongroups[(int) *p++]--;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Now find all consecutive groups of spilled registers\n-\t and mark each group off against the need for such groups.\n-\t But don't count them against ordinary need, yet.  */\n-\n-      count_possible_groups (group_size, group_mode, max_groups);\n-\n-      /* Now count all spill regs against the individual need,\n-\t This includes those counted above for groups,\n-\t but not those previously counted for nongroups.\n-\n-\t Those that weren't counted_for_groups can also count against\n-\t the not-in-group need.  */\n-\n-      for (i = 0; i < n_spills; i++)\n-\t{\n-\t  register enum reg_class *p;\n-\t  class = (int) REGNO_REG_CLASS (spill_regs[i]);\n-\n-\t  /* Those counted at the beginning shouldn't be counted twice.  */\n-\t  if (! TEST_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]))\n-\t    {\n-\t      max_needs[class]--;\n-\t      p = reg_class_superclasses[class];\n-\t      while (*p != LIM_REG_CLASSES)\n-\t\tmax_needs[(int) *p++]--;\n-\n-\t      if (! TEST_HARD_REG_BIT (counted_for_groups, spill_regs[i]))\n-\t\t{\n-\t\t  if (max_nongroups[class] > 0)\n-\t\t    SET_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]);\n-\t\t  max_nongroups[class]--;\n-\t\t  p = reg_class_superclasses[class];\n-\t\t  while (*p != LIM_REG_CLASSES)\n-\t\t    {\n-\t\t      if (max_nongroups[(int) *p] > 0)\n-\t\t\tSET_HARD_REG_BIT (counted_for_nongroups,\n-\t\t\t\t\t  spill_regs[i]);\n-\t\t      max_nongroups[(int) *p++]--;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n       /* See if anything that happened changes which eliminations are valid.\n \t For example, on the Sparc, whether or not the frame pointer can\n \t be eliminated can depend on what registers have been used.  We need\n@@ -1534,16 +1648,44 @@ reload (first, global, dumpfile)\n       if (i == N_REG_CLASSES && !new_basic_block_needs && ! something_changed)\n \tbreak;\n \n-      /* Not all needs are met; must spill more hard regs.  */\n+      /* Not all needs are met; must spill some hard regs.  */\n+\n+      /* Put all registers spilled so far back in potential_reload_regs, but\n+\t put them at the front, since we've already spilled most of the\n+\t psuedos in them (we might have left some pseudos unspilled if they\n+\t were in a block that didn't need any spill registers of a conflicting\n+\t class.  We used to try to mark off the need for those registers,\n+\t but doing so properly is very complex and reallocating them is the\n+\t simpler approach.  First, \"pack\" potential_reload_regs by pushing \n+\t any nonnegative entries towards the end.  That will leave room \n+\t for the registers we already spilled.\n+\n+\t Also, undo the marking of the spill registers from the last time\n+\t around in FORBIDDEN_REGS since we will be probably be allocating\n+\t them again below.\n+\n+\t ??? It is theoretically possible that we might end up not using one\n+\t of our previously-spilled registers in this allocation, even though\n+\t they are at the head of the list.  It's not clear what to do about\n+\t this, but it was no better before, when we marked off the needs met\n+\t by the previously-spilled registers.  With the current code, globals\n+\t can be allocated into these registers, but locals cannot.  */\n+\n+      if (n_spills)\n+\t{\n+\t  for (i = j = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n+\t    if (potential_reload_regs[i] != -1)\n+\t      potential_reload_regs[j--] = potential_reload_regs[i];\n \n-      /* If any element of basic_block_needs changed from 0 to 1,\n-\t re-spill all the regs already spilled.  This may spill\n-\t additional pseudos that didn't spill before.  */\n+\t  for (i = 0; i < n_spills; i++)\n+\t    {\n+\t      potential_reload_regs[i] = spill_regs[i];\n+\t      spill_reg_order[spill_regs[i]] = -1;\n+\t      CLEAR_HARD_REG_BIT (forbidden_regs, spill_regs[i]);\n+\t    }\n \n-      if (new_basic_block_needs)\n-\tfor (i = 0; i < n_spills; i++)\n-\t  something_changed\n-\t    |= spill_hard_reg (spill_regs[i], global, dumpfile, 0);\n+\t  n_spills = 0;\n+\t}\n \n       /* Now find more reload regs to satisfy the remaining need\n \t Do it by ascending class number, since otherwise a reg\n@@ -1567,6 +1709,9 @@ reload (first, global, dumpfile)\n \t in counting the regs already spilled, and in choose_reload_regs.\n \t It might be hard to avoid introducing bugs there.  */\n \n+      CLEAR_HARD_REG_SET (counted_for_groups);\n+      CLEAR_HARD_REG_SET (counted_for_nongroups);\n+\n       for (class = 0; class < N_REG_CLASSES; class++)\n \t{\n \t  /* First get the groups of registers.\n@@ -1589,8 +1734,9 @@ reload (first, global, dumpfile)\n \t\t  /* First, look for a register that will complete a group.  */\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    {\n-\t\t      int j = potential_reload_regs[i];\n \t\t      int other;\n+\n+\t\t      j = potential_reload_regs[i];\n \t\t      if (j >= 0 && ! TEST_HARD_REG_BIT (bad_spill_regs, j)\n \t\t\t  &&\n \t\t\t  ((j > 0 && (other = j - 1, spill_reg_order[other] >= 0)\n@@ -1632,7 +1778,7 @@ reload (first, global, dumpfile)\n \t\t  if (i == FIRST_PSEUDO_REGISTER)\n \t\t    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t      {\n-\t\t\tint j = potential_reload_regs[i];\n+\t\t\tj = potential_reload_regs[i];\n \t\t\tif (j >= 0 && j + 1 < FIRST_PSEUDO_REGISTER\n \t\t\t    && spill_reg_order[j] < 0 && spill_reg_order[j + 1] < 0\n \t\t\t    && TEST_HARD_REG_BIT (reg_class_contents[class], j)\n@@ -1665,8 +1811,9 @@ reload (first, global, dumpfile)\n \t\t     and spill them all at once.  */\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    {\n-\t\t      int j = potential_reload_regs[i];\n \t\t      int k;\n+\n+\t\t      j = potential_reload_regs[i];\n \t\t      if (j >= 0\n \t\t\t  && j + group_size[class] <= FIRST_PSEUDO_REGISTER\n \t\t\t  && HARD_REGNO_MODE_OK (j, group_mode[class]))\n@@ -1822,7 +1969,7 @@ reload (first, global, dumpfile)\n     reload_as_needed (first, global);\n \n   /* If we were able to eliminate the frame pointer, show that it is no\n-     longer live at the start of any basic block.  If it is live by\n+     longer live at the start of any basic block.  If it ls live by\n      virtue of being in a pseudo, that pseudo will be marked live\n      and hence the frame pointer will be known to be live via that\n      pseudo.  */\n@@ -1968,8 +2115,9 @@ possible_group_p (regno, max_groups)\n \n static void\n count_possible_groups (group_size, group_mode, max_groups)\n-     int *group_size, *max_groups;\n+     int *group_size;\n      enum machine_mode *group_mode;\n+     int *max_groups;\n {\n   int i;\n   /* Now find all consecutive groups of spilled registers\n@@ -3263,8 +3411,6 @@ scan_paradoxical_subregs (x)\n     }\n }\n \f\n-struct hard_reg_n_uses { int regno; int uses; };\n-\n static int\n hard_reg_use_compare (p1, p2)\n      struct hard_reg_n_uses *p1, *p2;\n@@ -3329,12 +3475,14 @@ order_regs_for_reload ()\n       else if (regs_explicitly_used[i])\n \t{\n \t  hard_reg_n_uses[i].uses += large + 1;\n+#ifndef SMALL_REGISTER_CLASSES\n \t  /* ??? We are doing this here because of the potential that\n \t     bad code may be generated if a register explicitly used in\n \t     an insn was used as a spill register for that insn.  But\n \t     not using these are spill registers may lose on some machine.\n \t     We'll have to see how this works out.  */\n \t  SET_HARD_REG_BIT (bad_spill_regs, i);\n+#endif\n \t}\n     }\n   hard_reg_n_uses[FRAME_POINTER_REGNUM].uses += 2 * large + 2;\n@@ -3530,34 +3678,33 @@ reload_as_needed (first, live_known)\n \t      int class;\n \n \t      /* If this block has not had spilling done for a\n-\t\t particular class, deactivate any optional reloads\n-\t\t of that class lest they try to use a spill-reg which isn't\n-\t\t available here.  If we have any non-optionals that need a\n-\t\t spill reg, abort.  */\n+\t\t particular clas and we have any non-optionals that need a\n+\t\t spill reg in that class, abort.  */\n \n \t      for (class = 0; class < N_REG_CLASSES; class++)\n \t\tif (basic_block_needs[class] != 0\n \t\t    && basic_block_needs[class][this_block] == 0)\n \t\t  for (i = 0; i < n_reloads; i++)\n-\t\t    if (class == (int) reload_reg_class[i])\n-\t\t      {\n-\t\t\tif (reload_optional[i])\n-\t\t\t  {\n-\t\t\t    reload_in[i] = reload_out[i] = 0;\n-\t\t\t    reload_secondary_p[i] = 0;\n-\t\t\t  }\n-\t\t\telse if (reload_reg_rtx[i] == 0\n-\t\t\t\t && (reload_in[i] != 0 || reload_out[i] != 0\n-\t\t\t\t     || reload_secondary_p[i] != 0))\n-\t\t\t  abort ();\n-\t\t      }\n+\t\t    if (class == (int) reload_reg_class[i]\n+\t\t\t&& reload_reg_rtx[i] == 0\n+\t\t\t&& ! reload_optional[i]\n+\t\t\t&& (reload_in[i] != 0 || reload_out[i] != 0\n+\t\t\t    || reload_secondary_p[i] != 0))\n+\t\t      abort ();\n \n \t      /* Now compute which reload regs to reload them into.  Perhaps\n \t\t reusing reload regs from previous insns, or else output\n \t\t load insns to reload them.  Maybe output store insns too.\n \t\t Record the choices of reload reg in reload_reg_rtx.  */\n \t      choose_reload_regs (insn, avoid_return_reg);\n \n+#ifdef SMALL_REGISTER_CLASSES\n+\t      /* Merge any reloads that we didn't combine for fear of \n+\t\t increasing the number of spill registers needed but now\n+\t\t discover can be safely merged.  */\n+\t      merge_assigned_reloads (insn);\n+#endif\n+\n \t      /* Generate the insns to reload operands into or out of\n \t\t their reload regs.  */\n \t      emit_reload_insns (insn);\n@@ -3629,7 +3776,7 @@ reload_as_needed (first, live_known)\n \n       /* Don't assume a reload reg is still good after a call insn\n \t if it is a call-used reg.  */\n-      if (GET_CODE (insn) == CODE_LABEL || GET_CODE (insn) == CALL_INSN)\n+      else if (GET_CODE (insn) == CALL_INSN)\n \tfor (i = 0; i < n_spills; i++)\n \t  if (call_used_regs[spill_regs[i]])\n \t    {\n@@ -3763,58 +3910,72 @@ reload_reg_class_lower (p1, p2)\n \n /* If reg is in use as a reload reg for a RELOAD_OTHER reload.  */\n static HARD_REG_SET reload_reg_used;\n-/* If reg is in use for a RELOAD_FOR_INPUT_RELOAD_ADDRESS reload.  */\n-static HARD_REG_SET reload_reg_used_in_input_addr;\n-/* If reg is in use for a RELOAD_FOR_OUTPUT_RELOAD_ADDRESS reload.  */\n-static HARD_REG_SET reload_reg_used_in_output_addr;\n+/* If reg is in use for a RELOAD_FOR_INPUT_ADDRESS reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_input_addr[MAX_RECOG_OPERANDS];\n+/* If reg is in use for a RELOAD_FOR_OUTPUT_ADDRESS reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_output_addr[MAX_RECOG_OPERANDS];\n+/* If reg is in use for a RELOAD_FOR_INPUT reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n+/* If reg is in use for a RELOAD_FOR_OUTPUT reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n /* If reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */\n static HARD_REG_SET reload_reg_used_in_op_addr;\n-/* If reg is in use for a RELOAD_FOR_INPUT reload.  */\n-static HARD_REG_SET reload_reg_used_in_input;\n-/* If reg is in use for a RELOAD_FOR_OUTPUT reload.  */\n-static HARD_REG_SET reload_reg_used_in_output;\n+/* If reg is in use for a RELOAD_FOR_INSN reload.  */\n+static HARD_REG_SET reload_reg_used_in_insn;\n+/* If reg is in use for a RELOAD_FOR_OTHER_ADDRESS reload.  */\n+static HARD_REG_SET reload_reg_used_in_other_addr;\n \n /* If reg is in use as a reload reg for any sort of reload.  */\n static HARD_REG_SET reload_reg_used_at_all;\n \n-/* Mark reg REGNO as in use for a reload of the sort spec'd by WHEN_NEEDED.\n-   MODE is used to indicate how many consecutive regs are actually used.  */\n+/* Mark reg REGNO as in use for a reload of the sort spec'd by OPNUM and\n+   TYPE. MODE is used to indicate how many consecutive regs are\n+   actually used.  */\n \n static void\n-mark_reload_reg_in_use (regno, when_needed, mode)\n+mark_reload_reg_in_use (regno, opnum, type, mode)\n      int regno;\n-     enum reload_when_needed when_needed;\n+     int opnum;\n+     enum reload_type type;\n      enum machine_mode mode;\n {\n   int nregs = HARD_REGNO_NREGS (regno, mode);\n   int i;\n \n   for (i = regno; i < nregs + regno; i++)\n     {\n-      switch (when_needed)\n+      switch (type)\n \t{\n \tcase RELOAD_OTHER:\n \t  SET_HARD_REG_BIT (reload_reg_used, i);\n \t  break;\n \n-\tcase RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_input_addr, i);\n+\tcase RELOAD_FOR_INPUT_ADDRESS:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n \t  break;\n \n-\tcase RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_output_addr, i);\n+\tcase RELOAD_FOR_OUTPUT_ADDRESS:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n \t  break;\n \n \tcase RELOAD_FOR_OPERAND_ADDRESS:\n \t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n \t  break;\n \n+\tcase RELOAD_FOR_OTHER_ADDRESS:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_other_addr, i);\n+\t  break;\n+\n \tcase RELOAD_FOR_INPUT:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_input, i);\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_input[opnum], i);\n \t  break;\n \n \tcase RELOAD_FOR_OUTPUT:\n-\t  SET_HARD_REG_BIT (reload_reg_used_in_output, i);\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_output[opnum], i);\n+\t  break;\n+\n+\tcase RELOAD_FOR_INSN:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_insn, i);\n \t  break;\n \t}\n \n@@ -3823,117 +3984,328 @@ mark_reload_reg_in_use (regno, when_needed, mode)\n }\n \n /* 1 if reg REGNO is free as a reload reg for a reload of the sort\n-   specified by WHEN_NEEDED.  */\n+   specified by OPNUM and TYPE.  */\n \n static int\n-reload_reg_free_p (regno, when_needed)\n+reload_reg_free_p (regno, opnum, type)\n      int regno;\n-     enum reload_when_needed when_needed;\n+     int opnum;\n+     enum reload_type type;\n {\n-  /* In use for a RELOAD_OTHER means it's not available for anything.  */\n-  if (TEST_HARD_REG_BIT (reload_reg_used, regno))\n+  int i;\n+\n+  /* In use for a RELOAD_OTHER means it's not available for anything except\n+     RELOAD_FOR_OTHER_ADDRESS.  Recall that RELOAD_FOR_OTHER_ADDRESS is known\n+     to be used only for inputs.  */\n+\n+  if (type != RELOAD_FOR_OTHER_ADDRESS\n+      && TEST_HARD_REG_BIT (reload_reg_used, regno))\n     return 0;\n-  switch (when_needed)\n+\n+  switch (type)\n     {\n     case RELOAD_OTHER:\n       /* In use for anything means not available for a RELOAD_OTHER.  */\n       return ! TEST_HARD_REG_BIT (reload_reg_used_at_all, regno);\n \n       /* The other kinds of use can sometimes share a register.  */\n     case RELOAD_FOR_INPUT:\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_input, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_input_addr, regno));\n-    case RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_input_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_input, regno));\n-    case RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_output_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_output, regno));\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t  || TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n+\treturn 0;\n+\n+      /* If it is used for some other input, can't use it.  */\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      /* If it is used in a later operand's address, can't use it.  */\n+      for (i = opnum + 1; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      /* Can't use a register if it is used for an input address for this\n+\t operand or used as an input in an earlier one.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], regno))\n+\treturn 0;\n+\n+      for (i = 0; i < opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      /* Can't use a register if it is used for an output address for this\n+\t operand or used as an output in this or a later operand.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno))\n+\treturn 0;\n+\n+      for (i = opnum; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n     case RELOAD_FOR_OPERAND_ADDRESS:\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_input, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_output, regno));\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n+\n     case RELOAD_FOR_OUTPUT:\n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_output_addr, regno)\n-\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_output, regno));\n+      /* This cannot share a register with RELOAD_FOR_INSN reloads, other\n+\t outputs, or an operand address for this or an earlier output.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno))\n+\treturn 0;\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      for (i = 0; i <= opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n+    case RELOAD_FOR_INSN:\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n+\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n     }\n   abort ();\n }\n \n /* Return 1 if the value in reload reg REGNO, as used by a reload\n-   needed for the part of the insn specified by WHEN_NEEDED,\n+   needed for the part of the insn specified by OPNUM and TYPE,\n    is not in use for a reload in any prior part of the insn.\n \n    We can assume that the reload reg was already tested for availability\n    at the time it is needed, and we should not check this again,\n    in case the reg has already been marked in use.  */\n \n static int\n-reload_reg_free_before_p (regno, when_needed)\n+reload_reg_free_before_p (regno, opnum, type)\n      int regno;\n-     enum reload_when_needed when_needed;\n+     int opnum;\n+     enum reload_type type;\n {\n-  switch (when_needed)\n+  int i;\n+\n+  switch (type)\n     {\n-    case RELOAD_OTHER:\n-      /* Since a RELOAD_OTHER reload claims the reg for the entire insn,\n-\t its use starts from the beginning, so nothing can use it earlier.  */\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      /* These always come first.  */\n       return 1;\n \n+    case RELOAD_OTHER:\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n+\n       /* If this use is for part of the insn,\n-\t check the reg is not in use for any prior part.  */\n-    case RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n+\t check the reg is not in use for any prior part.  It is tempting\n+\t to try to do this by falling through from objecs that occur\n+\t later in the insn to ones that occur earlier, but that will not\n+\t correctly take into account the fact that here we MUST ignore\n+\t things that would prevent the register from being allocated in\n+\t the first place, since we know that it was allocated.  */\n+\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      /* Earlier reloads are for earlier outputs or their addresses,\n+\t any RELOAD_FOR_INSN reloads, any inputs or their addresses, or any\n+\t RELOAD_FOR_OTHER_ADDRESS reloads (we know it can't conflict with\n+\t RELOAD_OTHER)..  */\n+      for (i = 0; i < opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno))\n \treturn 0;\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n+\t\t\t\t   \n     case RELOAD_FOR_OUTPUT:\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_input, regno))\n+      /* This can't be used in the output address for this operand and\n+\t anything that can't be used for it, except that we've already\n+\t tested for RELOAD_FOR_INSN objects.  */\n+\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno))\n \treturn 0;\n+\n+      for (i = 0; i < opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n+\t  return 0;\n+\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n+\n     case RELOAD_FOR_OPERAND_ADDRESS:\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr, regno))\n-\treturn 0;\n-    case RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n+    case RELOAD_FOR_INSN:\n+      /* These can't conflict with inputs, or each other, so all we have to\n+\t test is input addresses and the addresses of OTHER items.  */\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\t  return 0;\n+\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n+\n     case RELOAD_FOR_INPUT:\n-      return 1;\n+      /* The only things earlier are the address for this and\n+\t earlier inputs, other inputs (which we know we don't conflict\n+\t with), and addresses of RELOAD_OTHER objects.  */\n+\n+      for (i = 0; i <= opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\t  return 0;\n+\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n+\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      /* Similarly, all we have to check is for use in earlier inputs'\n+\t addresses.  */\n+      for (i = 0; i < opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\t  return 0;\n+\n+      return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n     }\n   abort ();\n }\n \n /* Return 1 if the value in reload reg REGNO, as used by a reload\n-   needed for the part of the insn specified by WHEN_NEEDED,\n+   needed for the part of the insn specified by OPNUM and TYPE,\n    is still available in REGNO at the end of the insn.\n \n    We can assume that the reload reg was already tested for availability\n    at the time it is needed, and we should not check this again,\n    in case the reg has already been marked in use.  */\n \n static int\n-reload_reg_reaches_end_p (regno, when_needed)\n+reload_reg_reaches_end_p (regno, opnum, type)\n      int regno;\n-     enum reload_when_needed when_needed;\n+     int opnum;\n+     enum reload_type type;\n {\n-  switch (when_needed)\n+  int i;\n+\n+  switch (type)\n     {\n     case RELOAD_OTHER:\n       /* Since a RELOAD_OTHER reload claims the reg for the entire insn,\n \t its value must reach the end.  */\n       return 1;\n \n       /* If this use is for part of the insn,\n-\t its value reaches if no subsequent part uses the same register.  */\n-    case RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n+\t its value reaches if no subsequent part uses the same register. \n+\t Just like the above function, don't try to do this with lots\n+\t of fallthroughs.  */\n+\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      /* Here we check for everything else, since these don't conflict\n+\t with anything else and everything comes later.  */\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used, regno));\n+\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      /* Similar, except that we check only for this and subsequent inputs\n+\t and the address of only subsequent inputs and we do not need\n+\t to check for RELOAD_OTHER objects since they are known not to\n+\t conflict.  */\n+\n+      for (i = opnum; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      for (i = opnum + 1; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\t  return 0;\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n+\n     case RELOAD_FOR_INPUT:\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n-\t  || TEST_HARD_REG_BIT (reload_reg_used_in_output, regno))\n-\treturn 0;\n+      /* Similar to input address, except we start at the next operand for\n+\t both input and input address and we do not check for \n+\t RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_INSN since these\n+\t would conflict.  */\n+\n+      for (i = opnum + 1; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      /* ... fall through ... */\n+\n     case RELOAD_FOR_OPERAND_ADDRESS:\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr, regno))\n-\treturn 0;\n+      /* Check outputs and their addresses.  */\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n+    case RELOAD_FOR_INSN:\n+      /* These conflict with other outputs with with RELOAD_OTHER.  So\n+\t we need only check for output addresses.  */\n+\n+      opnum = -1;\n+\n+      /* ... fall through ... */\n+\n     case RELOAD_FOR_OUTPUT:\n-    case RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      /* We already know these can't conflict with a later output.  So the\n+\t only thing to check are later output addresses.  */\n+      for (i = opnum + 1; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno))\n+\t  return 0;\n+\n       return 1;\n     }\n+\n   abort ();\n }\n \f\n@@ -4024,7 +4396,8 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \n \t  i = (i + 1) % n_spills;\n \n-\t  if (reload_reg_free_p (spill_regs[i], reload_when_needed[r])\n+\t  if (reload_reg_free_p (spill_regs[i], reload_opnum[r],\n+\t\t\t\t reload_when_needed[r])\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], spill_regs[i])\n \t      && HARD_REGNO_MODE_OK (spill_regs[i], reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  */\n@@ -4055,7 +4428,8 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \t\t    regno = spill_regs[i] + nr - 1;\n \t\t    if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n \t\t\t  && spill_reg_order[regno] >= 0\n-\t\t\t  && reload_reg_free_p (regno, reload_when_needed[r])\n+\t\t\t  && reload_reg_free_p (regno, reload_opnum[r],\n+\t\t\t\t\t\treload_when_needed[r])\n \t\t\t  && ! TEST_HARD_REG_BIT (counted_for_nongroups,\n \t\t\t\t\t\t  regno)))\n \t\t      break;\n@@ -4082,8 +4456,8 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n   last_spill_reg = i;\n \n   /* Mark as in use for this insn the reload regs we use for this.  */\n-  mark_reload_reg_in_use (spill_regs[i], reload_when_needed[r],\n-\t\t\t  reload_mode[r]);\n+  mark_reload_reg_in_use (spill_regs[i], reload_opnum[r],\n+\t\t\t  reload_when_needed[r], reload_mode[r]);\n \n   new = spill_reg_rtx[i];\n \n@@ -4147,7 +4521,6 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n static void\n choose_reload_regs (insn, avoid_return_reg)\n      rtx insn;\n-     /* This argument is currently ignored.  */\n      rtx avoid_return_reg;\n {\n   register int i, j;\n@@ -4161,11 +4534,13 @@ choose_reload_regs (insn, avoid_return_reg)\n   rtx save_reload_override_in[MAX_RELOADS];\n   int save_reload_spill_index[MAX_RELOADS];\n   HARD_REG_SET save_reload_reg_used;\n-  HARD_REG_SET save_reload_reg_used_in_input_addr;\n-  HARD_REG_SET save_reload_reg_used_in_output_addr;\n+  HARD_REG_SET save_reload_reg_used_in_input_addr[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET save_reload_reg_used_in_output_addr[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET save_reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET save_reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_op_addr;\n-  HARD_REG_SET save_reload_reg_used_in_input;\n-  HARD_REG_SET save_reload_reg_used_in_output;\n+  HARD_REG_SET save_reload_reg_used_in_insn;\n+  HARD_REG_SET save_reload_reg_used_in_other_addr;\n   HARD_REG_SET save_reload_reg_used_at_all;\n \n   bzero (reload_inherited, MAX_RELOADS);\n@@ -4174,41 +4549,17 @@ choose_reload_regs (insn, avoid_return_reg)\n \n   CLEAR_HARD_REG_SET (reload_reg_used);\n   CLEAR_HARD_REG_SET (reload_reg_used_at_all);\n-  CLEAR_HARD_REG_SET (reload_reg_used_in_input_addr);\n-  CLEAR_HARD_REG_SET (reload_reg_used_in_output_addr);\n   CLEAR_HARD_REG_SET (reload_reg_used_in_op_addr);\n-  CLEAR_HARD_REG_SET (reload_reg_used_in_output);\n-  CLEAR_HARD_REG_SET (reload_reg_used_in_input);\n+  CLEAR_HARD_REG_SET (reload_reg_used_in_insn);\n+  CLEAR_HARD_REG_SET (reload_reg_used_in_other_addr);\n \n-  /* Distinguish output-only and input-only reloads\n-     because they can overlap with other things.  */\n-  for (j = 0; j < n_reloads; j++)\n-    if (reload_when_needed[j] == RELOAD_OTHER\n-\t&& ! reload_needed_for_multiple[j])\n-      {\n-\tif (reload_in[j] == 0 && reload_out[j] != 0)\n-\t  {\n-\t    /* But earlyclobber operands must stay as RELOAD_OTHER.  */\n-\t    for (i = 0; i < n_earlyclobbers; i++)\n-\t      {\n-\t\tif (GET_CODE (reload_earlyclobbers[i]) == SUBREG\n-\t\t    && reg_overlap_mentioned_for_reload_p (reload_out[j],\n-\t\t\t\t    SUBREG_REG (reload_earlyclobbers[i])))\n-\t\t  break;\n-\t\tif (rtx_equal_p (reload_out[j], reload_earlyclobbers[i]))\n-\t\t  break;\n-\t      }\n-\t    if (i == n_earlyclobbers)\n-\t      reload_when_needed[j] = RELOAD_FOR_OUTPUT;\n-\t  }\n-\tif (reload_out[j] == 0)\n-\t  reload_when_needed[j] = RELOAD_FOR_INPUT;\n-\n-\tif (reload_secondary_reload[j] >= 0\n-\t    && ! reload_needed_for_multiple[reload_secondary_reload[j]])\n-\t  reload_when_needed[reload_secondary_reload[j]]\n-\t    = reload_when_needed[j];\n-      }\n+  for (i = 0; i < reload_n_operands; i++)\n+    {\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_output[i]);\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_input[i]);\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_input_addr[i]);\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_output_addr[i]);\n+    }\n \n #ifdef SMALL_REGISTER_CLASSES\n   /* Don't bother with avoiding the return reg\n@@ -4291,12 +4642,10 @@ choose_reload_regs (insn, avoid_return_reg)\n       reload_spill_index[j] = -1;\n \n       reload_mode[j]\n-\t= (reload_strict_low[j] && reload_out[j]\n-\t   ? GET_MODE (SUBREG_REG (reload_out[j]))\n-\t   : (reload_inmode[j] == VOIDmode\n-\t      || (GET_MODE_SIZE (reload_outmode[j])\n-\t\t  > GET_MODE_SIZE (reload_inmode[j])))\n-\t   ? reload_outmode[j] : reload_inmode[j]);\n+\t= (reload_inmode[j] == VOIDmode\n+\t   || (GET_MODE_SIZE (reload_outmode[j])\n+\t       > GET_MODE_SIZE (reload_inmode[j])))\n+\t  ? reload_outmode[j] : reload_inmode[j];\n \n       reload_nregs[j] = CLASS_MAX_NREGS (reload_reg_class[j], reload_mode[j]);\n \n@@ -4309,7 +4658,7 @@ choose_reload_regs (insn, avoid_return_reg)\n       /* If we have already decided to use a certain register,\n \t don't use it in another way.  */\n       if (reload_reg_rtx[j])\n-\tmark_reload_reg_in_use (REGNO (reload_reg_rtx[j]),\n+\tmark_reload_reg_in_use (REGNO (reload_reg_rtx[j]), reload_opnum[j],\n \t\t\t\treload_when_needed[j], reload_mode[j]);\n     }\n \n@@ -4326,16 +4675,24 @@ choose_reload_regs (insn, avoid_return_reg)\n \t sizeof reload_spill_index);\n   COPY_HARD_REG_SET (save_reload_reg_used, reload_reg_used);\n   COPY_HARD_REG_SET (save_reload_reg_used_at_all, reload_reg_used_at_all);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_output,\n-\t\t     reload_reg_used_in_output);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_input,\n-\t\t     reload_reg_used_in_input);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_input_addr,\n-\t\t     reload_reg_used_in_input_addr);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_output_addr,\n-\t\t     reload_reg_used_in_output_addr);\n   COPY_HARD_REG_SET (save_reload_reg_used_in_op_addr,\n \t\t     reload_reg_used_in_op_addr);\n+  COPY_HARD_REG_SET (save_reload_reg_used_in_insn,\n+\t\t     reload_reg_used_in_insn);\n+  COPY_HARD_REG_SET (save_reload_reg_used_in_other_addr,\n+\t\t     reload_reg_used_in_other_addr);\n+\n+  for (i = 0; i < reload_n_operands; i++)\n+    {\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_output[i],\n+\t\t\t reload_reg_used_in_output[i]);\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_input[i],\n+\t\t\t reload_reg_used_in_input[i]);\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_input_addr[i],\n+\t\t\t reload_reg_used_in_input_addr[i]);\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_output_addr[i],\n+\t\t\t reload_reg_used_in_output_addr[i]);\n+    }\n \n   /* If -O, try first with inheritance, then turning it off.\n      If not -O, don't do inheritance.\n@@ -4448,8 +4805,10 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t      && (reload_nregs[r] == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  spill_regs[i]))\n-\t\t      && reload_reg_free_p (spill_regs[i], reload_when_needed[r])\n+\t\t      && reload_reg_free_p (spill_regs[i], reload_opnum[r],\n+\t\t\t\t\t    reload_when_needed[r])\n \t\t      && reload_reg_free_before_p (spill_regs[i],\n+\t\t\t\t\t\t   reload_opnum[r],\n \t\t\t\t\t\t   reload_when_needed[r]))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n@@ -4468,6 +4827,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t  /* Mark the register as in use for this part of\n \t\t\t     the insn.  */\n \t\t\t  mark_reload_reg_in_use (spill_regs[i],\n+\t\t\t\t\t\t  reload_opnum[r],\n \t\t\t\t\t\t  reload_when_needed[r],\n \t\t\t\t\t\t  reload_mode[r]);\n \t\t\t  reload_reg_rtx[r] = reg_last_reload_reg[regno];\n@@ -4514,7 +4874,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t and of the desired class.  */\n \t      if (equiv != 0\n \t\t  && ((spill_reg_order[regno] >= 0\n-\t\t       && ! reload_reg_free_before_p (regno,\n+\t\t       && ! reload_reg_free_before_p (regno, reload_opnum[r],\n \t\t\t\t\t\t      reload_when_needed[r]))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[r]],\n \t\t\t\t\t      regno)))\n@@ -4560,7 +4920,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t     mark the spill reg as in use for this insn.  */\n \t\t  i = spill_reg_order[regno];\n \t\t  if (i >= 0)\n-\t\t    mark_reload_reg_in_use (regno, reload_when_needed[r],\n+\t\t    mark_reload_reg_in_use (regno, reload_opnum[r],\n+\t\t\t\t\t    reload_when_needed[r],\n \t\t\t\t\t    reload_mode[r]);\n \t\t}\n \t    }\n@@ -4642,16 +5003,24 @@ choose_reload_regs (insn, avoid_return_reg)\n \t     sizeof reload_spill_index);\n       COPY_HARD_REG_SET (reload_reg_used, save_reload_reg_used);\n       COPY_HARD_REG_SET (reload_reg_used_at_all, save_reload_reg_used_at_all);\n-      COPY_HARD_REG_SET (reload_reg_used_in_input,\n-\t\t\t save_reload_reg_used_in_input);\n-      COPY_HARD_REG_SET (reload_reg_used_in_output,\n-\t\t\t save_reload_reg_used_in_output);\n-      COPY_HARD_REG_SET (reload_reg_used_in_input_addr,\n-\t\t\t save_reload_reg_used_in_input_addr);\n-      COPY_HARD_REG_SET (reload_reg_used_in_output_addr,\n-\t\t\t save_reload_reg_used_in_output_addr);\n       COPY_HARD_REG_SET (reload_reg_used_in_op_addr,\n \t\t\t save_reload_reg_used_in_op_addr);\n+      COPY_HARD_REG_SET (reload_reg_used_in_insn,\n+\t\t\t save_reload_reg_used_in_insn);\n+      COPY_HARD_REG_SET (reload_reg_used_in_other_addr,\n+\t\t\t save_reload_reg_used_in_other_addr);\n+\n+      for (i = 0; i < reload_n_operands; i++)\n+\t{\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_input[i],\n+\t\t\t     save_reload_reg_used_in_input[i]);\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_output[i],\n+\t\t\t     save_reload_reg_used_in_output[i]);\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_input_addr[i],\n+\t\t\t     save_reload_reg_used_in_input_addr[i]);\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_output_addr[i],\n+\t\t\t     save_reload_reg_used_in_output_addr[i]);\n+\t}\n     }\n \n   /* If we thought we could inherit a reload, because it seemed that\n@@ -4664,6 +5033,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \n       if (reload_inherited[r] && reload_reg_rtx[r] != 0\n \t  && ! reload_reg_free_before_p (true_regnum (reload_reg_rtx[r]),\n+\t\t\t\t\t reload_opnum[r],\n \t\t\t\t\t reload_when_needed[r]))\n \treload_inherited[r] = 0;\n \n@@ -4675,7 +5045,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \t{\n \t  int regno = true_regnum (reload_override_in[r]);\n \t  if (spill_reg_order[regno] >= 0\n-\t      && ! reload_reg_free_before_p (regno, reload_when_needed[r]))\n+\t      && ! reload_reg_free_before_p (regno, reload_opnum[r],\n+\t\t\t\t\t     reload_when_needed[r]))\n \t    reload_override_in[r] = 0;\n \t}\n     }\n@@ -4725,37 +5096,144 @@ choose_reload_regs (insn, avoid_return_reg)\n \t    }\n \n \t  if (reload_when_needed[r] != RELOAD_OTHER\n-\t      && reload_when_needed[r] != RELOAD_FOR_OUTPUT)\n+\t      && reload_when_needed[r] != RELOAD_FOR_OUTPUT\n+\t      && reload_when_needed[r] != RELOAD_FOR_INSN)\n \t    abort ();\n \t}\n     }\n }\n \f\n+/* If SMALL_REGISTER_CLASSES are defined, we may not have merged two\n+   reloads of the same item for fear that we might not have enough reload\n+   registers. However, normally they will get the same reload register\n+   and hence actually need not be loaded twice.  \n+\n+   Here we check for the most common case of this phenomenon: when we have\n+   a number of reloads for the same object, each of which were allocated\n+   the same reload_reg_rtx, that reload_reg_rtx is not used for any other\n+   reload, and is not modified in the insn itself.  If we find such,\n+   merge all the reloads and set the resulting reload to RELOAD_OTHER.\n+   This will not increase the number of spill registers needed and will\n+   prevent redundant code.  */\n+\n+#ifdef SMALL_REGISTER_CLASSES\n+\n+static void\n+merge_assigned_reloads (insn)\n+     rtx insn;\n+{\n+  int i, j;\n+\n+  /* Scan all the reloads looking for ones that only load values and\n+     are not already RELOAD_OTHER and ones whose reload_reg_rtx are\n+     assigned and not modified by INSN.  */\n+\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      if (reload_in[i] == 0 || reload_when_needed[i] == RELOAD_OTHER\n+\t  || reload_out[i] != 0 || reload_reg_rtx[i] == 0\n+\t  || reg_set_p (reload_reg_rtx[i], insn))\n+\tcontinue;\n+\n+      /* Look at all other reloads.  Ensure that the only use of this\n+\t reload_reg_rtx is in a reload that just loads the same value\n+\t as we do.  Note that any secondary reloads must be of the identical\n+\t class since the values, modes, and result registers are the\n+\t same, so we need not do anything with any secondary reloads.  */\n+\n+      for (j = 0; j < n_reloads; j++)\n+\t{\n+\t  if (i == j || reload_reg_rtx[j] == 0\n+\t      || ! reg_overlap_mentioned_p (reload_reg_rtx[j],\n+\t\t\t\t\t    reload_reg_rtx[i]))\n+\t    continue;\n+\n+\t  /* If the reload regs aren't exactly the same (e.g, different modes)\n+\t     or if the values are different, we can't merge anything with this\n+\t     reload register.  */\n+\n+\t  if (! rtx_equal_p (reload_reg_rtx[i], reload_reg_rtx[j])\n+\t      || reload_out[j] != 0 || reload_in[j] == 0\n+\t      || ! rtx_equal_p (reload_in[i], reload_in[j]))\n+\t    break;\n+\t}\n+\n+      /* If all is OK, merge the reloads.  Only set this to RELOAD_OTHER if\n+\t we, in fact, found any matching reloads.  */\n+\n+      if (j == n_reloads)\n+\t{\n+\t  for (j = 0; j < n_reloads; j++)\n+\t    if (i != j && reload_reg_rtx[j] != 0\n+\t\t&& rtx_equal_p (reload_reg_rtx[i], reload_reg_rtx[j]))\n+\t      {\n+\t\treload_when_needed[i] = RELOAD_OTHER;\n+\t\treload_in[j] = 0;\n+\t\ttransfer_replacements (i, j);\n+\t      }\n+\n+\t  /* If this is now RELOAD_OTHER, look for any reloads that load\n+\t     parts of this operand and set them to RELOAD_FOR_OTHER_ADDRESS\n+\t     if they were for inputs, RELOAD_OTHER for outputs.  Note that\n+\t     this test is equivalent to looking for reloads for this operand\n+\t     number.  */\n+\n+\t  if (reload_when_needed[i] == RELOAD_OTHER)\n+\t    for (j = 0; j < n_reloads; j++)\n+\t      if (reload_in[j] != 0\n+\t\t  && reload_when_needed[i] != RELOAD_OTHER\n+\t\t  && reg_overlap_mentioned_for_reload_p (reload_in[j],\n+\t\t\t\t\t\t\t reload_in[i]))\n+\t\treload_when_needed[j]\n+\t\t  = reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t\t    ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER;\n+\t}\n+    }\n+}\t    \n+#endif /* SMALL_RELOAD_CLASSES */\n+\f\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n emit_reload_insns (insn)\n      rtx insn;\n {\n   register int j;\n+  rtx input_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx other_input_address_reload_insns = 0;\n+  rtx other_input_reload_insns = 0;\n+  rtx input_address_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx output_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx operand_reload_insns = 0;\n   rtx following_insn = NEXT_INSN (insn);\n   rtx before_insn = insn;\n-  rtx first_output_reload_insn = NEXT_INSN (insn);\n-  rtx first_other_reload_insn = insn;\n-  rtx first_operand_address_reload_insn = insn;\n   int special;\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n \n+  for (j = 0; j < reload_n_operands; j++)\n+    input_reload_insns[j] = input_address_reload_insns[j]\n+      = output_reload_insns[j] = output_address_reload_insns[j] = 0;\n+\n   /* If this is a CALL_INSN preceded by USE insns, any reload insns\n      must go in front of the first USE insn, not in front of INSN.  */\n \n   if (GET_CODE (insn) == CALL_INSN && GET_CODE (PREV_INSN (insn)) == INSN\n       && GET_CODE (PATTERN (PREV_INSN (insn))) == USE)\n     while (GET_CODE (PREV_INSN (before_insn)) == INSN\n \t   && GET_CODE (PATTERN (PREV_INSN (before_insn))) == USE)\n-      first_other_reload_insn = first_operand_address_reload_insn\n-\t= before_insn = PREV_INSN (before_insn);\n+      before_insn = PREV_INSN (before_insn);\n+\n+  /* If this insn is followed by any CLOBBER insns made by find_reloads,\n+     put our reloads after them since they may otherwise be \n+     misinterpreted.  */\n+\n+  while (NEXT_INSN (following_insn) != 0\n+\t && GET_CODE (NEXT_INSN (following_insn)) == INSN\n+\t && GET_MODE (NEXT_INSN (following_insn)) == DImode\n+\t && GET_CODE (PATTERN (NEXT_INSN (following_insn))) == CLOBBER)\n+    following_insn = NEXT_INSN (following_insn);\n \n   /* Now output the instructions to copy the data into and out of the\n      reload registers.  Do these in the order that the reloads were reported,\n@@ -4766,7 +5244,6 @@ emit_reload_insns (insn)\n     {\n       register rtx old;\n       rtx oldequiv_reg = 0;\n-      rtx this_reload_insn = 0;\n       rtx store_insn = 0;\n \n       old = reload_in[j];\n@@ -4777,8 +5254,7 @@ emit_reload_insns (insn)\n \t  register rtx reloadreg = reload_reg_rtx[j];\n \t  rtx oldequiv = 0;\n \t  enum machine_mode mode;\n-\t  rtx where;\n-\t  rtx reload_insn;\n+\t  rtx *where;\n \n \t  /* Determine the mode to reload in.\n \t     This is very tricky because we have three to choose from.\n@@ -4815,8 +5291,6 @@ emit_reload_insns (insn)\n \t  mode = GET_MODE (old);\n \t  if (mode == VOIDmode)\n \t    mode = reload_inmode[j];\n-\t  if (reload_strict_low[j])\n-\t    mode = GET_MODE (SUBREG_REG (reload_in[j]));\n \n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t  /* If we need a secondary register for this operation, see if\n@@ -4846,7 +5320,7 @@ emit_reload_insns (insn)\n \t\t  || (GET_CODE (old) == REG\n \t\t      && REGNO (old) >= FIRST_PSEUDO_REGISTER\n \t\t      && reg_renumber[REGNO (old)] < 0)))\n-\t    oldequiv = find_equiv_reg (old, insn, GENERAL_REGS,\n+\t    oldequiv = find_equiv_reg (old, insn, ALL_REGS,\n \t\t\t\t       -1, NULL_PTR, 0, mode);\n \n \t  if (oldequiv)\n@@ -4857,8 +5331,9 @@ emit_reload_insns (insn)\n \t\t if any other reload needs it at an earlier stage of this insn\n \t\t or at this stage.  */\n \t      if (spill_reg_order[regno] >= 0\n-\t\t  && (! reload_reg_free_p (regno, reload_when_needed[j])\n-\t\t      || ! reload_reg_free_before_p (regno,\n+\t\t  && (! reload_reg_free_p (regno, reload_opnum[j],\n+\t\t\t\t\t   reload_when_needed[j])\n+\t\t      || ! reload_reg_free_before_p (regno, reload_opnum[j],\n \t\t\t\t\t\t     reload_when_needed[j])))\n \t\toldequiv = 0;\n \n@@ -4876,6 +5351,29 @@ emit_reload_insns (insn)\n \t\t\tbreak;\n \t\t      }\n \t\t}\n+\n+\t      /* If it is no cheaper to copy from OLDEQUIV into the\n+\t\t reload register than it would be to move from memory,\n+\t\t don't use it. Likewise, if we need a secondary register\n+\t\t or memory.   */\n+\n+\t      if (oldequiv != 0\n+\t\t  && ((REGNO_REG_CLASS (regno) != reload_reg_class[j]\n+\t\t       && (REGISTER_MOVE_COST (REGNO_REG_CLASS (regno),\n+\t\t\t\t\t       reload_reg_class[j])\n+\t\t\t   >= MEMORY_MOVE_COST (mode)))\n+#ifdef SECONDARY_INPUT_RELOAD_CLASS\n+\t\t      || (SECONDARY_INPUT_RELOAD_CLASS (reload_reg_class[j],\n+\t\t\t\t\t\t\tmode, oldequiv)\n+\t\t\t  != NO_REGS)\n+#endif\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t\t      || SECONDARY_MEMORY_NEEDED (reload_reg_class[j],\n+\t\t\t\t\t\t  REGNO_REG_CLASS (regno),\n+\t\t\t\t\t\t  mode)\n+#endif\n+\t\t      ))\n+\t\toldequiv = 0;\n \t    }\n \n \t  if (oldequiv == 0)\n@@ -4896,23 +5394,32 @@ emit_reload_insns (insn)\n \t      && mode != GET_MODE (oldequiv))\n \t    oldequiv = gen_rtx (SUBREG, mode, oldequiv, 0);\n \n-\t  /* Decide where to put reload insn for this reload.  */\n+\t  /* Switch to the right place to emit the reload insns.  */\n \t  switch (reload_when_needed[j])\n \t    {\n-\t    case RELOAD_FOR_INPUT:\n \t    case RELOAD_OTHER:\n-\t      where = first_operand_address_reload_insn;\n+\t      where = &other_input_reload_insns;\n \t      break;\n-\t    case RELOAD_FOR_INPUT_RELOAD_ADDRESS:\n-\t      where = first_other_reload_insn;\n+\t    case RELOAD_FOR_INPUT:\n+\t      where = &input_reload_insns[reload_opnum[j]];\n \t      break;\n-\t    case RELOAD_FOR_OUTPUT_RELOAD_ADDRESS:\n-\t      where = first_output_reload_insn;\n+\t    case RELOAD_FOR_INPUT_ADDRESS:\n+\t      where = &input_address_reload_insns[reload_opnum[j]];\n+\t      break;\n+\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n+\t      where = &output_address_reload_insns[reload_opnum[j]];\n \t      break;\n \t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t      where = before_insn;\n+\t      where = &operand_reload_insns;\n+\t      break;\n+\t    case RELOAD_FOR_OTHER_ADDRESS:\n+\t      where = &other_input_address_reload_insns;\n+\t      break;\n+\t    default:\n+\t      abort ();\n \t    }\n \n+\t  push_to_sequence (*where);\n \t  special = 0;\n \n \t  /* Auto-increment addresses must be reloaded in a special way.  */\n@@ -4929,8 +5436,7 @@ emit_reload_insns (insn)\n \t      /* Prevent normal processing of this reload.  */\n \t      special = 1;\n \t      /* Output a special code sequence for this case.  */\n-\t      this_reload_insn\n-\t\t= inc_for_reload (reloadreg, oldequiv, reload_inc[j], where);\n+\t      inc_for_reload (reloadreg, oldequiv, reload_inc[j]);\n \t    }\n \n \t  /* If we are reloading a pseudo-register that was set by the previous\n@@ -4942,9 +5448,9 @@ emit_reload_insns (insn)\n \t\t   && dead_or_set_p (insn, old)\n \t\t   /* This is unsafe if some other reload\n \t\t      uses the same reg first.  */\n-\t\t   && (reload_when_needed[j] == RELOAD_OTHER\n-\t\t       || reload_when_needed[j] == RELOAD_FOR_INPUT\n-\t\t       || reload_when_needed[j] == RELOAD_FOR_INPUT_RELOAD_ADDRESS))\n+\t\t   && reload_reg_free_before_p (REGNO (reloadreg),\n+\t\t\t\t\t\treload_opnum[j],\n+\t\t\t\t\t\treload_when_needed[j]))\n \t    {\n \t      rtx temp = PREV_INSN (insn);\n \t      while (temp && GET_CODE (temp) == NOTE)\n@@ -4978,14 +5484,8 @@ emit_reload_insns (insn)\n \t\t}\n \t    }\n \n-\t  /* We can't do that, so output an insn to load RELOADREG.\n-\t     Keep them in the following order:\n-\t     all reloads for input reload addresses,\n-\t     all reloads for ordinary input operands,\n-\t     all reloads for addresses of non-reloaded operands,\n-\t     the insn being reloaded,\n-\t     all reloads for addresses of output reloads,\n-\t     the output reloads.  */\n+\t  /* We can't do that, so output an insn to load RELOADREG.  */\n+\n \t  if (! special)\n \t    {\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n@@ -5084,13 +5584,8 @@ emit_reload_insns (insn)\n \t\t    {\n \t\t      if (icode != CODE_FOR_nothing)\n \t\t\t{\n-\t\t\t  reload_insn = emit_insn_before (GEN_FCN (icode)\n-\t\t\t\t\t\t\t  (reloadreg,\n-\t\t\t\t\t\t\t   real_oldequiv,\n-\t\t\t\t\t\t\t   second_reload_reg),\n-\t\t\t\t\t\t\t  where);\n-\t\t\t  if (this_reload_insn == 0)\n-\t\t\t    this_reload_insn = reload_insn;\n+\t\t\t  emit_insn (GEN_FCN (icode) (reloadreg, real_oldequiv,\n+\t\t\t\t\t\t      second_reload_reg));\n \t\t\t  special = 1;\n \t\t\t}\n \t\t      else\n@@ -5105,35 +5600,24 @@ emit_reload_insns (insn)\n \t\t\t      rtx third_reload_reg\n \t\t\t        = reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n \n-\t\t\t      reload_insn\n-\t\t\t\t= emit_insn_before ((GEN_FCN (tertiary_icode)\n-\t\t\t\t\t\t     (second_reload_reg,\n-\t\t\t\t\t\t      real_oldequiv,\n-\t\t\t\t\t\t      third_reload_reg)),\n-\t\t\t\t\t\t    where);\n-\t\t\t      if (this_reload_insn == 0)\n-\t\t\t\tthis_reload_insn = reload_insn;\n+\t\t\t      emit_insn ((GEN_FCN (tertiary_icode)\n+\t\t\t\t\t  (second_reload_reg, real_oldequiv,\n+\t\t\t\t\t   third_reload_reg)));\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    {\n-\t\t\t      reload_insn\n-\t\t\t\t= gen_input_reload (second_reload_reg,\n-\t\t\t\t\t\t    oldequiv, where);\n-\t\t\t      if (this_reload_insn == 0)\n-\t\t\t\tthis_reload_insn = reload_insn;\n-\t\t\t      oldequiv = second_reload_reg;\n-\t\t\t    }\n+\t\t\t    gen_input_reload (second_reload_reg, oldequiv,\n+\t\t\t\t\t      reload_opnum[j],\n+\t\t\t\t\t      reload_when_needed[j]);\n+\n+\t\t\t  oldequiv = second_reload_reg;\n \t\t\t}\n \t\t    }\n \t\t}\n #endif\n \n \t      if (! special)\n-\t\t{\n-\t\t  reload_insn = gen_input_reload (reloadreg, oldequiv, where);\n-\t\t  if (this_reload_insn == 0)\n-\t\t    this_reload_insn = reload_insn;\n-\t\t}\n+\t\tgen_input_reload (reloadreg, oldequiv, reload_opnum[j],\n+\t\t\t\t  reload_when_needed[j]);\n \n #if defined(SECONDARY_INPUT_RELOAD_CLASS) && defined(PRESERVE_DEATH_INFO_REGNO_P)\n \t      /* We may have to make a REG_DEAD note for the secondary reload\n@@ -5144,8 +5628,7 @@ emit_reload_insns (insn)\n \t\t{\n \t\t  rtx prev;\n \n-\t\t  for (prev = where;\n-\t\t       prev != PREV_INSN (this_reload_insn);\n+\t\t  for (prev = get_last_insn (); prev;\n \t\t       prev = PREV_INSN (prev))\n \t\t    if (GET_RTX_CLASS (GET_CODE (prev) == 'i')\n \t\t\t&& reg_overlap_mentioned_for_reload_p (second_reload_reg,\n@@ -5160,23 +5643,9 @@ emit_reload_insns (insn)\n #endif\n \t    }\n \n-\t  /* Update where to put other reload insns.  */\n-\t  if (this_reload_insn)\n-\t    switch (reload_when_needed[j])\n-\t      {\n-\t      case RELOAD_FOR_INPUT:\n-\t      case RELOAD_OTHER:\n-\t\tif (first_other_reload_insn == first_operand_address_reload_insn)\n-\t\t  first_other_reload_insn = this_reload_insn;\n-\t\tbreak;\n-\t      case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\tif (first_operand_address_reload_insn == before_insn)\n-\t\t  first_operand_address_reload_insn = this_reload_insn;\n-\t\tif (first_other_reload_insn == before_insn)\n-\t\t  first_other_reload_insn = this_reload_insn;\n-\t      }\n-\n-\t  /* reload_inc[j] was formerly processed here.  */\n+\t  /* End this sequence.  */\n+\t  *where = get_insns ();\n+\t  end_sequence ();\n \t}\n \n       /* Add a note saying the input reload reg\n@@ -5297,10 +5766,7 @@ emit_reload_insns (insn)\n \t actually no need to store the old value in it.  */\n \n       if (optimize && reload_inherited[j] && reload_spill_index[j] >= 0\n-\t  /* This is unsafe if some other reload uses the same reg first.  */\n-\t  && (reload_when_needed[j] == RELOAD_OTHER\n-\t      || reload_when_needed[j] == RELOAD_FOR_INPUT\n-\t      || reload_when_needed[j] == RELOAD_FOR_INPUT_RELOAD_ADDRESS)\n+\t  && reload_in[j] != 0\n \t  && GET_CODE (reload_in[j]) == REG\n #if 0\n \t  /* There doesn't seem to be any reason to restrict this to pseudos\n@@ -5309,6 +5775,9 @@ emit_reload_insns (insn)\n \t  && REGNO (reload_in[j]) >= FIRST_PSEUDO_REGISTER\n #endif\n \t  && spill_reg_store[reload_spill_index[j]] != 0\n+\t  /* This is unsafe if some other reload uses the same reg first.  */\n+\t  && reload_reg_free_before_p (spill_regs[reload_spill_index[j]],\n+\t\t\t\t       reload_opnum[j], reload_when_needed[j])\n \t  && dead_or_set_p (insn, reload_in[j])\n \t  /* This is unsafe if operand occurs more than once in current\n \t     insn.  Perhaps some occurrences weren't reloaded.  */\n@@ -5329,7 +5798,6 @@ emit_reload_insns (insn)\n \t{\n \t  register rtx reloadreg = reload_reg_rtx[j];\n \t  register rtx second_reloadreg = 0;\n-\t  rtx prev_insn = PREV_INSN (first_output_reload_insn);\n \t  rtx note, p;\n \t  enum machine_mode mode;\n \t  int special = 0;\n@@ -5362,6 +5830,8 @@ emit_reload_insns (insn)\n \t  if (GET_CODE (insn) == JUMP_INSN)\n \t    abort ();\n \n+\t  push_to_sequence (output_reload_insns[reload_opnum[j]]);\n+\n \t  /* Determine the mode to reload in.\n \t     See comments above (for input reloading).  */\n \n@@ -5378,21 +5848,6 @@ emit_reload_insns (insn)\n \t      old = gen_rtx (REG, mode, REGNO (reloadreg));\n \t    }\n \n-\t  /* A strict-low-part output operand needs to be reloaded\n-\t     in the mode of the entire value.  */\n-\t  if (reload_strict_low[j])\n-\t    {\n-\t      mode = GET_MODE (SUBREG_REG (reload_out[j]));\n-\t      /* Encapsulate OLD into that mode.  */\n-\t      /* If OLD is a subreg, then strip it, since the subreg will\n-\t\t be altered by this very reload.  */\n-\t      while (GET_CODE (old) == SUBREG && GET_MODE (old) != mode)\n-\t\told = SUBREG_REG (old);\n-\t      if (GET_MODE (old) != VOIDmode\n-\t\t  && mode != GET_MODE (old))\n-\t\told = gen_rtx (SUBREG, mode, old, 0);\n-\t    }\n-\n \t  if (GET_MODE (reloadreg) != mode)\n \t    reloadreg = gen_lowpart_common (mode, reloadreg);\n \n@@ -5421,10 +5876,8 @@ emit_reload_insns (insn)\n \t\t     or as an intermediate register.  */\n \t\t  if (reload_secondary_icode[j] != CODE_FOR_nothing)\n \t\t    {\n-\t\t      emit_insn_before ((GEN_FCN (reload_secondary_icode[j])\n-\t\t\t\t\t (real_old, second_reloadreg,\n-\t\t\t\t\t  reloadreg)),\n-\t\t\t\t\tfirst_output_reload_insn);\n+\t\t      emit_insn ((GEN_FCN (reload_secondary_icode[j])\n+\t\t\t\t  (real_old, second_reloadreg, reloadreg)));\n \t\t      special = 1;\n \t\t    }\n \t\t  else\n@@ -5456,8 +5909,11 @@ emit_reload_insns (insn)\n \t\t\t{\n \t\t\t  /* Get the memory to use and rewrite both registers\n \t\t\t     to its mode.  */\n-\t\t\t  rtx loc = get_secondary_mem (reloadreg,\n-\t\t\t\t\t\t       GET_MODE (second_reloadreg));\n+\t\t\t  rtx loc\n+\t\t\t    = get_secondary_mem (reloadreg,\n+\t\t\t\t\t\t GET_MODE (second_reloadreg),\n+\t\t\t\t\t\t reload_opnum[j],\n+\t\t\t\t\t\t reload_when_needed[j]);\n \t\t\t  rtx tmp_reloadreg;\n \t\t\t    \n \t\t\t  if (GET_MODE (loc) != GET_MODE (second_reloadreg))\n@@ -5470,15 +5926,14 @@ emit_reload_insns (insn)\n \t\t\t  else\n \t\t\t    tmp_reloadreg = reloadreg;\n \t\t\t  \n-\t\t\t  emit_insn_before (gen_move_insn (loc, second_reloadreg),\n-\t\t\t\t\t    first_output_reload_insn);\n+\t\t\t  emit_move_insn (loc, second_reloadreg);\n \t\t\t  pat = gen_move_insn (tmp_reloadreg, loc);\n \t\t\t}\n #endif\n \t\t      else\n \t\t\tpat = gen_move_insn (reloadreg, second_reloadreg);\n \n-\t\t      emit_insn_before (pat, first_output_reload_insn);\n+\t\t      emit_insn (pat);\n \t\t    }\n \t\t}\n \t    }\n@@ -5496,7 +5951,9 @@ emit_reload_insns (insn)\n \t\t{\n \t\t  /* Get the memory to use and rewrite both registers to\n \t\t     its mode.  */\n-\t\t  rtx loc = get_secondary_mem (old, GET_MODE (reloadreg));\n+\t\t  rtx loc = get_secondary_mem (old, GET_MODE (reloadreg),\n+\t\t\t\t\t       reload_opnum[j],\n+\t\t\t\t\t       reload_when_needed[j]);\n \n \t\t  if (GET_MODE (loc) != GET_MODE (reloadreg))\n \t\t    reloadreg = gen_rtx (REG, GET_MODE (loc),\n@@ -5505,24 +5962,20 @@ emit_reload_insns (insn)\n \t\t  if (GET_MODE (loc) != GET_MODE (old))\n \t\t    old = gen_rtx (REG, GET_MODE (loc), REGNO (old));\n \n-\t\t  emit_insn_before (gen_move_insn (loc, reloadreg),\n-\t\t\t\t    first_output_reload_insn);\n-\t\t  emit_insn_before (gen_move_insn (old, loc),\n-\t\t\t\t    first_output_reload_insn);\n+\t\t  emit_insn (gen_move_insn (loc, reloadreg));\n+\t\t  emit_insn (gen_move_insn (old, loc));\n \t\t}\n \t      else\n #endif\n-\t\temit_insn_before (gen_move_insn (old, reloadreg),\n-\t\t\t\t  first_output_reload_insn);\n+\t\temit_insn (gen_move_insn (old, reloadreg));\n \t    }\n \n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n \t  /* If final will look at death notes for this reg,\n \t     put one on the last output-reload insn to use it.  Similarly\n \t     for any secondary register.  */\n \t  if (PRESERVE_DEATH_INFO_REGNO_P (REGNO (reloadreg)))\n-\t    for (p = PREV_INSN (first_output_reload_insn);\n-\t\t p != prev_insn; p = PREV_INSN (p))\n+\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t\t  && reg_overlap_mentioned_for_reload_p (reloadreg,\n \t\t\t\t\t\t\t PATTERN (p)))\n@@ -5532,8 +5985,7 @@ emit_reload_insns (insn)\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  if (! special\n \t      && PRESERVE_DEATH_INFO_REGNO_P (REGNO (second_reloadreg)))\n-\t    for (p = PREV_INSN (first_output_reload_insn);\n-\t\t p != prev_insn; p = PREV_INSN (p))\n+\t    for (p = get_last_insn (); p; p = PREV_INSN (p))\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t\t  && reg_overlap_mentioned_for_reload_p (second_reloadreg,\n \t\t\t\t\t\t\t PATTERN (p)))\n@@ -5542,8 +5994,7 @@ emit_reload_insns (insn)\n #endif\n #endif\n \t  /* Look at all insns we emitted, just to be safe.  */\n-\t  for (p = NEXT_INSN (prev_insn); p != first_output_reload_insn;\n-\t       p = NEXT_INSN (p))\n+\t  for (p = get_insns (); p; p = NEXT_INSN (p))\n \t    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n \t      {\n \t\t/* If this output reload doesn't come from a spill reg,\n@@ -5556,13 +6007,50 @@ emit_reload_insns (insn)\n \t\t  store_insn = p;\n \t      }\n \n-\t  first_output_reload_insn = NEXT_INSN (prev_insn);\n+\t  output_reload_insns[reload_opnum[j]] = get_insns ();\n+\t  end_sequence ();\n+\n \t}\n \n       if (reload_spill_index[j] >= 0)\n \tnew_spill_reg_store[reload_spill_index[j]] = store_insn;\n     }\n \n+  /* Now write all the insns we made for reloads in the order expected by\n+     the allocation functions.  Prior to the insn being reloaded, we write\n+     the following reloads:\n+\n+     RELOAD_FOR_OTHER_ADDRESS reloads for input addresses.\n+\n+     RELOAD_OTHER reloads.\n+\n+     For each operand, any RELOAD_FOR_INPUT_ADDRESS reloads followed by\n+     the RELOAD_FOR_INPUT reload for the operand.\n+\n+     RELOAD_FOR_OPERAND_ADDRESS reloads.\n+\n+     After the insn being reloaded, we write the following:\n+\n+     For each operand, any RELOAD_FOR_OUTPUT_ADDRESS reload followed by\n+     the RELOAD_FOR_OUTPUT reload for that operand.  */\n+\n+  emit_insns_before (other_input_address_reload_insns, before_insn);\n+  emit_insns_before (other_input_reload_insns, before_insn);\n+\n+  for (j = 0; j < reload_n_operands; j++)\n+    {\n+      emit_insns_before (input_address_reload_insns[j], before_insn);\n+      emit_insns_before (input_reload_insns[j], before_insn);\n+    }\n+\n+  emit_insns_before (operand_reload_insns, before_insn);\n+\n+  for (j = 0; j < reload_n_operands; j++)\n+    {\n+      emit_insns_before (output_address_reload_insns[j], following_insn);\n+      emit_insns_before (output_reload_insns[j], following_insn);\n+    }\n+\n   /* Move death notes from INSN\n      to output-operand-address and output reload insns.  */\n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n@@ -5621,9 +6109,14 @@ emit_reload_insns (insn)\n \n       /* I is nonneg if this reload used one of the spill regs.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n-\t that we opted to ignore.  */\n+\t that we opted to ignore.\n \n-      if (i >= 0 && reload_reg_rtx[r] != 0)\n+\t Also ignore reloads that don't reach the end of the insn,\n+\t since we will eventually see the one that does.  */\n+\n+      if (i >= 0 && reload_reg_rtx[r] != 0\n+\t  && reload_reg_reaches_end_p (spill_regs[i], reload_opnum[r],\n+\t\t\t\t       reload_when_needed[r]))\n \t{\n \t  /* First, clear out memory of what used to be in this spill reg.\n \t     If consecutive registers are used, clear them all.  */\n@@ -5665,31 +6158,19 @@ emit_reload_insns (insn)\n \t      else\n \t\tnregno = REGNO (reload_in_reg[r]);\n \n-\t      /* If there are two separate reloads (one in and one out)\n-\t\t for the same (hard or pseudo) reg,\n-\t\t leave reg_last_reload_reg set\n-\t\t based on the output reload.\n-\t\t Otherwise, set it from this input reload.  */\n-\t      if (!reg_has_output_reload[nregno]\n-\t\t  /* But don't do so if another input reload\n-\t\t     will clobber this one's value.  */\n-\t\t  && reload_reg_reaches_end_p (spill_regs[i],\n-\t\t\t\t\t       reload_when_needed[r]))\n-\t\t{\n-\t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n+\t      reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n-\t\t  /* Unless we inherited this reload, show we haven't\n-\t\t     recently done a store.  */\n-\t\t  if (! reload_inherited[r])\n-\t\t    spill_reg_store[i] = 0;\n+\t      /* Unless we inherited this reload, show we haven't\n+\t\t recently done a store.  */\n+\t      if (! reload_inherited[r])\n+\t\tspill_reg_store[i] = 0;\n \n-\t\t  for (k = 0; k < nr; k++)\n-\t\t    {\n-\t\t      reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n-\t\t\t= nregno;\n-\t\t      reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n-\t\t\t= insn;\n-\t\t    }\n+\t      for (k = 0; k < nr; k++)\n+\t\t{\n+\t\t  reg_reloaded_contents[spill_reg_order[spill_regs[i] + k]]\n+\t\t    = nregno;\n+\t\t  reg_reloaded_insn[spill_reg_order[spill_regs[i] + k]]\n+\t\t    = insn;\n \t\t}\n \t    }\n \t}\n@@ -5710,16 +6191,19 @@ emit_reload_insns (insn)\n     }\n }\n \f\n-/* Emit code before BEFORE_INSN to perform an input reload of IN to RELOADREG.\n+/* Emit code to perform an input reload of IN to RELOADREG.  IN is from\n+   operand OPNUM with reload type TYPE. \n+\n    Returns first insn emitted.  */\n \n rtx\n-gen_input_reload (reloadreg, in, before_insn)\n+gen_input_reload (reloadreg, in, opnum, type)\n      rtx reloadreg;\n      rtx in;\n-     rtx before_insn;\n+     int opnum;\n+     enum reload_type type;\n {\n-  register rtx prev_insn = PREV_INSN (before_insn);\n+  rtx last = get_last_insn ();\n \n   /* How to do this reload can get quite tricky.  Normally, we are being\n      asked to reload a simple operand, such as a MEM, a constant, or a pseudo\n@@ -5789,8 +6273,7 @@ gen_input_reload (reloadreg, in, before_insn)\n       if (op0 != XEXP (in, 0) || op1 != XEXP (in, 1))\n \tin = gen_rtx (PLUS, GET_MODE (in), op0, op1);\n \n-      insn = emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in),\n-\t\t\t\t   before_insn);\n+      insn = emit_insn (gen_rtx (SET, VOIDmode, reloadreg, in));\n       code = recog_memoized (insn);\n \n       if (code >= 0)\n@@ -5803,10 +6286,7 @@ gen_input_reload (reloadreg, in, before_insn)\n \t    return insn;\n \t}\n \n-      if (PREV_INSN (insn))\n-\tNEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n-      if (NEXT_INSN (insn))\n-\tPREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n+      delete_insns_since (last);\n \n       /* If that failed, we must use a conservative two-insn sequence.\n \t use move to copy constant, MEM, or pseudo register to the reload\n@@ -5822,7 +6302,7 @@ gen_input_reload (reloadreg, in, before_insn)\n \t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER))\n \ttem = op0, op0 = op1, op1 = tem;\n \n-      emit_insn_before (gen_move_insn (reloadreg, op0), before_insn);\n+      emit_insn (gen_move_insn (reloadreg, op0));\n \n       /* If OP0 and OP1 are the same, we can use RELOADREG for OP1.\n \t This fixes a problem on the 32K where the stack pointer cannot\n@@ -5831,7 +6311,7 @@ gen_input_reload (reloadreg, in, before_insn)\n       if (rtx_equal_p (op0, op1))\n \top1 = reloadreg;\n \n-      emit_insn_before (gen_add2_insn (reloadreg, op1), before_insn);\n+      emit_insn (gen_add2_insn (reloadreg, op1));\n     }\n \n #ifdef SECONDARY_MEMORY_NEEDED\n@@ -5842,39 +6322,39 @@ gen_input_reload (reloadreg, in, before_insn)\n \t\t\t\t       GET_MODE (reloadreg)))\n     {\n       /* Get the memory to use and rewrite both registers to its mode.  */\n-      rtx loc = get_secondary_mem (in, GET_MODE (reloadreg));\n+      rtx loc = get_secondary_mem (in, GET_MODE (reloadreg), opnum, type);\n \n       if (GET_MODE (loc) != GET_MODE (reloadreg))\n \treloadreg = gen_rtx (REG, GET_MODE (loc), REGNO (reloadreg));\n \n       if (GET_MODE (loc) != GET_MODE (in))\n \tin = gen_rtx (REG, GET_MODE (loc), REGNO (in));\n \n-      emit_insn_before (gen_move_insn (loc, in), before_insn);\n-      emit_insn_before (gen_move_insn (reloadreg, loc), before_insn);\n+      emit_insn (gen_move_insn (loc, in));\n+      emit_insn (gen_move_insn (reloadreg, loc));\n     }\n #endif\n \n   /* If IN is a simple operand, use gen_move_insn.  */\n   else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n-    emit_insn_before (gen_move_insn (reloadreg, in), before_insn);\n+    emit_insn (gen_move_insn (reloadreg, in));\n \n #ifdef HAVE_reload_load_address\n   else if (HAVE_reload_load_address)\n-    emit_insn_before (gen_reload_load_address (reloadreg, in), before_insn);\n+    emit_insn (gen_reload_load_address (reloadreg, in));\n #endif\n \n   /* Otherwise, just write (set REGLOADREG IN) and hope for the best.  */\n   else\n-    emit_insn_before (gen_rtx (SET, VOIDmode, reloadreg, in), before_insn);\n+    emit_insn (gen_rtx (SET, VOIDmode, reloadreg, in));\n \n   /* Return the first insn emitted.\n-     We can not just return PREV_INSN (before_insn), because there may have\n+     We can not just return get_last_insn, because there may have\n      been multiple instructions emitted.  Also note that gen_move_insn may\n      emit more than one insn itself, so we can not assume that there is one\n      insn emitted per emit_insn_before call.  */\n \n-  return NEXT_INSN (prev_insn);\n+  return last ? NEXT_INSN (last) : get_insns ();\n }\n \f\n /* Delete a previously made output-reload\n@@ -5969,32 +6449,26 @@ delete_output_reload (insn, j, output_reload_insn)\n       alter_reg (REGNO (reg), -1);\n     }\n }\n-\n \f\n /* Output reload-insns to reload VALUE into RELOADREG.\n    VALUE is an autoincrement or autodecrement RTX whose operand\n    is a register or memory location;\n    so reloading involves incrementing that location.\n \n    INC_AMOUNT is the number to increment or decrement by (always positive).\n-   This cannot be deduced from VALUE.\n-\n-   INSN is the insn before which the new insns should be emitted.\n+   This cannot be deduced from VALUE.  */\n \n-   The return value is the first of the insns emitted.  */\n-\n-static rtx\n-inc_for_reload (reloadreg, value, inc_amount, insn)\n+static void\n+inc_for_reload (reloadreg, value, inc_amount)\n      rtx reloadreg;\n      rtx value;\n      int inc_amount;\n-     rtx insn;\n {\n   /* REG or MEM to be copied and incremented.  */\n   rtx incloc = XEXP (value, 0);\n   /* Nonzero if increment after copying.  */\n   int post = (GET_CODE (value) == POST_DEC || GET_CODE (value) == POST_INC);\n-  rtx prev = PREV_INSN (insn);\n+  rtx last;\n   rtx inc;\n   rtx add_insn;\n   int code;\n@@ -6013,14 +6487,15 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \n   /* If this is post-increment, first copy the location to the reload reg.  */\n   if (post)\n-    emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n+    emit_insn (gen_move_insn (reloadreg, incloc));\n \n   /* See if we can directly increment INCLOC.  Use a method similar to that\n      in gen_input_reload.  */\n \n-  add_insn = emit_insn_before (gen_rtx (SET, VOIDmode, incloc,\n-\t\t\t\t\tgen_rtx (PLUS, GET_MODE (incloc),\n-\t\t\t\t\t\t incloc, inc)), insn);\n+  last = get_last_insn ();\n+  add_insn = emit_insn (gen_rtx (SET, VOIDmode, incloc,\n+\t\t\t\t gen_rtx (PLUS, GET_MODE (incloc),\n+\t\t\t\t\t  incloc, inc)));\n \t\t\t\t\t\t\t  \n   code = recog_memoized (add_insn);\n   if (code >= 0)\n@@ -6033,15 +6508,13 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \t     be used as an address.  */\n \n \t  if (! post)\n-\t    emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n-\t  return NEXT_INSN (prev);\n+\t    emit_insn (gen_move_insn (reloadreg, incloc));\n+\n+\t  return;\n \t}\n     }\n \n-  if (PREV_INSN (add_insn))\n-    NEXT_INSN (PREV_INSN (add_insn)) = NEXT_INSN (add_insn);\n-  if (NEXT_INSN (add_insn))\n-    PREV_INSN (NEXT_INSN (add_insn)) = PREV_INSN (add_insn);\n+  delete_insns_since (last);\n \n   /* If couldn't do the increment directly, must increment in RELOADREG.\n      The way we do this depends on whether this is pre- or post-increment.\n@@ -6050,9 +6523,9 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \n   if (! post)\n     {\n-      emit_insn_before (gen_move_insn (reloadreg, incloc), insn);\n-      emit_insn_before (gen_add2_insn (reloadreg, inc), insn);\n-      emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n+      emit_insn (gen_move_insn (reloadreg, incloc));\n+      emit_insn (gen_add2_insn (reloadreg, inc));\n+      emit_insn (gen_move_insn (incloc, reloadreg));\n     }\n   else\n     {\n@@ -6065,13 +6538,12 @@ inc_for_reload (reloadreg, value, inc_amount, insn)\n \t RELOADREG, save that back, then decrement RELOADREG so it has\n \t the original value.  */\n \n-      emit_insn_before (gen_add2_insn (reloadreg, inc), insn);\n-      emit_insn_before (gen_move_insn (incloc, reloadreg), insn);\n-      emit_insn_before (gen_add2_insn (reloadreg, GEN_INT (-inc_amount)),\n-\t\t\tinsn);\n+      emit_insn (gen_add2_insn (reloadreg, inc));\n+      emit_insn (gen_move_insn (incloc, reloadreg));\n+      emit_insn (gen_add2_insn (reloadreg, GEN_INT (-inc_amount)));\n     }\n \n-  return NEXT_INSN (prev);\n+  return;\n }\n \f\n /* Return 1 if we are certain that the constraint-string STRING allows"}]}