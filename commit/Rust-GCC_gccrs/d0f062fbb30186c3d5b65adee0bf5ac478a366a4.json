{"sha": "d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBmMDYyZmJiMzAxODZjM2Q1YjY1YWRlZTBiZjVhYzQ3OGEzNjZhNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-03-21T18:10:48Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-03-21T18:10:48Z"}, "message": "tree.h (COMPLETE_TYPE_P): New macro.\n\ngcc\n\t* tree.h (COMPLETE_TYPE_P): New macro.\n\t(COMPLETE_OR_VOID_TYPE_P): New macro.\n\t(COMPLETE_OR_UNBOUND_ARRAY_TYPE_P): New macro.\n\t* stor-layout.c (layout_type, case VOID_TYPE): Don't set TYPE_SIZE.\n\t* c-aux-info.c (gen_type): Use them.\n\t* c-common.c (c_expand_expr_stmt): Likewise.\n\t* c-decl.c (poplevel, pushdecl, start_decl, finish_decl,\n\tgrokdeclarator, grokparms, finish_struct, start_function,\n\tstore_parm_decls, combine_parm_decls): Likewise.\n\t* c-parse.y (cast_expr): Likewise.\n\t* c-typeck.c (require_complete_type, c_sizeof, c_sizeof_nowarn,\n\tc_size_in_bytes, c_alignof, build_component_ref,\n\tbuild_indirect_ref, build_array_ref, convert_arguments,\n\tbuild_binary_op, pointer_diff, build_unary_op, digest_init: Likewise.\n\t* calls.c (initialize_argument_information): Likewise.\n\t* convert.c (convert_to_integer): Likewise.\n\t* dbxout.c (dbxout_typedefs, dbxout_type, dbxout_symbol): Likewise.\n\t* dwarfout.c (location_or_const_value_attribute,\n\toutput_enumeration_type_die, output_structure_type_die,\n\toutput_union_type_die, output_type): Likewise.\n\t* expr.c (safe_from_p, expand_expr): Likewise.\n\t* function.c (assign_parms): Likewise.\n\t* sdbout.c (sdbout_symbol, sdbout_one_type): Likewise.\n\t* tree.c (build_array_type, build_function_type,\n\tbuild_method_type, build_offset_type, build_complex_type): Likewise.\n\t* c-parse.c, c-parse.h: Regenerated.\ngcc/cp\n\t* typeck.c (require_complete_type, complete_type,\n\tcomplete_type_or_else, c_sizeof, c_sizeof_nowarn,\n\tbuild_array_ref, convert_arguments, pointer_diff,\n\tbuild_x_unary_op, build_unary_op, build_c_cast,\n\tbuild_modify_expr): Use COMPLETE_TYPE_P etc.\n\t* call.c (is_complete, convert_like_real,\n\tbuild_new_method_call): Likewise.\n\t* class.c (build_vbase_pointer_fields, check_bases,\n\tbuild_base_field, finish_struct_1, pushclass): Likewise.\n\t* cvt.c (cp_convert_to_pointer, convert_to_void): Likewise.\n\t* decl.c (maybe_process_template_type_declaration, pushtag,\n\tpushdecl, redeclaration_error_message, start_decl, start_decl_1,\n\tlayout_var_decl, check_initializer, cp_finish_decl,\n\tgrokdeclarator, require_complete_types_for_parms,\n\tgrok_op_properties, xref_tag, xref_basetypes,\n\tcheck_function_type): Likewise.\n\t* decl2.c (check_classfn, reparse_absdcl_as_casts): Likewise.\n\t* friend.c (do_friend): Likewise.\n\t* init.c (build_offset_ref): Likewise.\n\t* parse.y (structsp): Likewise.\n\t* pt.c (maybe_process_partial_specialization,\n\ttsubst_friend_function, instantiate_class_template, tsubst,\n\tdo_type_instantiation, instantiate_pending_templates): Likewise.\n\t* repo.c (repo_get_id): Likewise.\n\t* rtti.c (build_typeid, get_typeid, build_dynamic_cast_1,\n\tsynthesize_tinfo_var, emit_support_tinfos): Likewise.\n\t* search.c (lookup_fnfields_1, lookup_conversions): Likewise.\n\t* semantics.c (begin_class_definition): Likewise.\n\t* tree.c (build_cplus_method_type): Likewise.\n\t* typeck2.c (digest_init, build_functional_cast,\n\tadd_exception_specifier): Likewise.\n\t* parse.h, parse.c: Regenerated.\n\nFrom-SVN: r32671", "tree": {"sha": "60cf3d06d6cd7ec81aa72cfba4859f1a66850aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60cf3d06d6cd7ec81aa72cfba4859f1a66850aad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/comments", "author": null, "committer": null, "parents": [{"sha": "b9712646fb41219bfee574767c3d0bddb8a16ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9712646fb41219bfee574767c3d0bddb8a16ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9712646fb41219bfee574767c3d0bddb8a16ab5"}], "stats": {"total": 391, "additions": 232, "deletions": 159}, "files": [{"sha": "e11a573be355d66c6182d1a9913f1735e52a387a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1,3 +1,32 @@\n+2000-03-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (COMPLETE_TYPE_P): New macro.\n+\t(COMPLETE_OR_VOID_TYPE_P): New macro.\n+\t(COMPLETE_OR_UNBOUND_ARRAY_TYPE_P): New macro.\n+\t* stor-layout.c (layout_type, case VOID_TYPE): Don't set TYPE_SIZE.\n+\t* c-aux-info.c (gen_type): Use them.\n+\t* c-common.c (c_expand_expr_stmt): Likewise.\n+\t* c-decl.c (poplevel, pushdecl, start_decl, finish_decl,\n+\tgrokdeclarator, grokparms, finish_struct, start_function,\n+\tstore_parm_decls, combine_parm_decls): Likewise.\n+\t* c-parse.y (cast_expr): Likewise.\n+\t* c-typeck.c (require_complete_type, c_sizeof, c_sizeof_nowarn,\n+\tc_size_in_bytes, c_alignof, build_component_ref,\n+\tbuild_indirect_ref, build_array_ref, convert_arguments,\n+\tbuild_binary_op, pointer_diff, build_unary_op, digest_init: Likewise.\n+\t* calls.c (initialize_argument_information): Likewise.\n+\t* convert.c (convert_to_integer): Likewise.\n+\t* dbxout.c (dbxout_typedefs, dbxout_type, dbxout_symbol): Likewise.\n+\t* dwarfout.c (location_or_const_value_attribute,\n+\toutput_enumeration_type_die, output_structure_type_die,\n+\toutput_union_type_die, output_type): Likewise.\n+\t* expr.c (safe_from_p, expand_expr): Likewise.\n+\t* function.c (assign_parms): Likewise.\n+\t* sdbout.c (sdbout_symbol, sdbout_one_type): Likewise.\n+\t* tree.c (build_array_type, build_function_type,\n+\tbuild_method_type, build_offset_type, build_complex_type): Likewise.\n+\t* c-parse.c, c-parse.h: Regenerated.\n+\n 2000-03-21  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/rtems.h: Include config/rtems.h.\n@@ -17161,7 +17190,7 @@ Fri Aug 20 18:53:43 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \tcopy_rtx_and_substitute, subst_constants, restore_constants):\n \tLikewise.\n \n-\t* jump.c  (mark_jump_label, invert_exp, redirect_e\u0000\u0000\u0000xp,\n+\t* jump.c  (mark_jump_label, invert_exp, redirect_exp,\n \trtx_renumbered_equal_p, rtx_equal_for_thread_p): Likewise.\n \n \t* local-alloc.c (contains_replace_regs, memref_referenced_p):\n@@ -18001,7 +18030,7 @@ Mon Aug  9 10:08:50 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \t(unroll_loop): Access regno_pointer_* variables through\n \tcurrent_function.\n \n-\t* tree.h (struct tree_decl): Add elt f to saved_ins\u0000\u0000\u0000ns member.\n+\t* tree.h (struct tree_decl): Add elt f to saved_insns member.\n \t(DECL_SAVED_INSNS): use it.\n \t(expand_dummy_function_end): Declare.\n \t(init_function_for_compilation): Declare.\n@@ -18904,7 +18933,7 @@ Wed Jul 28 11:22:21 1999  Richard Henderson  <rth@cygnus.com>\n \n Wed Jul 28 11:20:19 1999  Richard Henderson  <rth@cygnus.com>\n \n-\t* mn102\u0000\u0000\u000000.c (mn10200_va_arg): New.\n+\t* mn10200.c (mn10200_va_arg): New.\n \t* mn10200.h (EXPAND_BUILTIN_VA_ARG): New.\n \n Wed Jul 28 11:19:06 1999  Richard Henderson  <rth@cygnus.com>"}, {"sha": "f3b375f5794a66191ab7fbfd466febe879e846ba", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -334,7 +334,7 @@ gen_type (ret_val, t, style)\n           return ret_val;\n \n         case ARRAY_TYPE:\n-\t  if (TYPE_SIZE (t) == 0 || TREE_CODE (TYPE_SIZE (t)) != INTEGER_CST)\n+\t  if (!COMPLETE_TYPE_P (t) || TREE_CODE (TYPE_SIZE (t)) != INTEGER_CST)\n \t    ret_val = gen_type (concat (ret_val, \"[]\", NULL_PTR),\n \t\t\t\tTREE_TYPE (t), style);\n \t  else if (int_size_in_bytes (t) == 0)"}, {"sha": "f0ff8eb55fb0660b16349a4cf6d1202d4571e747", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -2139,7 +2139,7 @@ c_expand_expr_stmt (expr)\n     expr = default_conversion (expr);\n \n   if (TREE_TYPE (expr) != error_mark_node\n-      && TYPE_SIZE (TREE_TYPE (expr)) == 0\n+      && !COMPLETE_TYPE_P (TREE_TYPE (expr))\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n     error (\"expression statement has incomplete type\");\n "}, {"sha": "c3ba2794b9cd3d19aae8d3d6929a213b3220a3a2", "filename": "gcc/c-decl.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -985,7 +985,7 @@ poplevel (keep, reverse, functionbody)\n #if 0\n   /* Warn about incomplete structure types in this level.  */\n   for (link = tags; link; link = TREE_CHAIN (link))\n-    if (TYPE_SIZE (TREE_VALUE (link)) == 0)\n+    if (!COMPLETE_TYPE_P (TREE_VALUE (link)))\n       {\n \ttree type = TREE_VALUE (link);\n \ttree type_name = TYPE_NAME (type);\n@@ -2409,7 +2409,7 @@ pushdecl (x)\n \t}\n \n       /* Keep count of variables in this level with incomplete type.  */\n-      if (TYPE_SIZE (TREE_TYPE (x)) == 0)\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (x)))\n \t++b->n_incomplete;\n     }\n \n@@ -3338,7 +3338,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       default:\n \t/* Don't allow initializations for incomplete types\n \t   except for arrays which might be completed by the initialization.  */\n-\tif (TYPE_SIZE (TREE_TYPE (decl)) != 0)\n+\tif (COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \t  {\n \t    /* A complete type is ok if size is fixed.  */\n \n@@ -3355,7 +3355,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n \t    initialized = 0;\n \t  }\n-\telse if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl))) == 0)\n+\telse if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n \t  {\n \t    error (\"elements of array `%s' have incomplete type\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n@@ -3414,7 +3414,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \t (which may or may not happen).  */\n       && DECL_RTL (tem) == 0)\n     {\n-      if (TYPE_SIZE (TREE_TYPE (tem)) != 0)\n+      if (COMPLETE_TYPE_P (TREE_TYPE (tem)))\n \texpand_decl (tem);\n       else if (TREE_CODE (TREE_TYPE (tem)) == ARRAY_TYPE\n \t       && DECL_INITIAL (tem) != 0)\n@@ -3517,7 +3517,7 @@ finish_decl (decl, init, asmspec_tree)\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      if (DECL_SIZE (decl) == 0 && TYPE_SIZE (TREE_TYPE (decl)) != 0)\n+      if (DECL_SIZE (decl) == 0 && COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \tlayout_decl (decl, 0);\n \n       if (DECL_SIZE (decl) == 0\n@@ -4319,7 +4319,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t union incomplete (*foo)[4];  */\n \t  /* Complain about arrays of incomplete types, except in typedefs.  */\n \n-\t  if (TYPE_SIZE (type) == 0\n+\t  if (!COMPLETE_TYPE_P (type)\n \t      /* Avoid multiple warnings for nested array types.  */\n \t      && TREE_CODE (type) != ARRAY_TYPE\n \t      && !(specbits & (1 << (int) RID_TYPEDEF))\n@@ -4480,7 +4480,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   /* Did array size calculations overflow?  */\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_SIZE (type)\n+      && COMPLETE_TYPE_P (type)\n       && TREE_OVERFLOW (TYPE_SIZE (type)))\n     error (\"size of array `%s' is too large\", name);\n \n@@ -4614,7 +4614,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    error (\"field `%s' declared as a function\", name);\n \t    type = build_pointer_type (type);\n \t  }\n-\telse if (TREE_CODE (type) != ERROR_MARK && TYPE_SIZE (type) == 0)\n+\telse if (TREE_CODE (type) != ERROR_MARK\n+\t         && !COMPLETE_OR_UNBOUND_ARRAY_TYPE_P (type))\n \t  {\n \t    error (\"field `%s' has incomplete type\", name);\n \t    type = error_mark_node;\n@@ -4822,7 +4823,7 @@ grokparms (parms_info, funcdef_flag)\n \t    {\n \t      /* Barf if the parameter itself has an incomplete type.  */\n \t      tree type = TREE_VALUE (typelt);\n-\t      if (TYPE_SIZE (type) == 0)\n+\t      if (!COMPLETE_TYPE_P (type))\n \t\t{\n \t\t  if (funcdef_flag && DECL_NAME (parm) != 0)\n \t\t    error (\"parameter `%s' has incomplete type\",\n@@ -4844,7 +4845,7 @@ grokparms (parms_info, funcdef_flag)\n \t\t\t || TREE_CODE (type) == REFERENCE_TYPE)\n \t\t    type = TREE_TYPE (type);\n \t\t  type = TYPE_MAIN_VARIANT (type);\n-\t\t  if (TYPE_SIZE (type) == 0)\n+\t\t  if (!COMPLETE_TYPE_P (type))\n \t\t    {\n \t\t      if (DECL_NAME (parm) != 0)\n \t\t\twarning (\"parameter `%s' points to incomplete type\",\n@@ -5361,7 +5362,7 @@ finish_struct (t, fieldlist, attributes)\n \t\texpand_decl (decl);\n \t      --current_binding_level->n_incomplete;\n \t    }\n-\t  else if (TYPE_SIZE (TREE_TYPE (decl)) == 0\n+\t  else if (!COMPLETE_TYPE_P (TREE_TYPE (decl))\n \t\t   && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t    {\n \t      tree element = TREE_TYPE (decl);\n@@ -5660,7 +5661,7 @@ start_function (declspecs, declarator, prefix_attributes, attributes)\n \n   announce_function (decl1);\n \n-  if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl1))) == 0)\n+  if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl1))))\n     {\n       error (\"return-type is an incomplete type\");\n       /* Make it return void instead.  */\n@@ -6086,7 +6087,7 @@ store_parm_decls ()\n \t  else\n \t    {\n \t      /* Complain about args with incomplete types.  */\n-\t      if (TYPE_SIZE (TREE_TYPE (parm)) == 0)\n+\t      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t        {\n \t          error_with_decl (parm, \"parameter `%s' has incomplete type\");\n \t          TREE_TYPE (parm) = error_mark_node;\n@@ -6376,7 +6377,7 @@ combine_parm_decls (specparms, parmlist, void_at_end)\n       TREE_CHAIN (parm) = 0;\n \n       /* Complain about args with incomplete types.  */\n-      if (TYPE_SIZE (TREE_TYPE (parm)) == 0)\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n \t  error_with_decl (parm, \"parameter `%s' has incomplete type\");\n \t  TREE_TYPE (parm) = error_mark_node;"}, {"sha": "9c71df91a20d973108285b5f0b874b25830fc41d", "filename": "gcc/c-parse.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1,7 +1,6 @@\n \n /*  A Bison parser, made from c-parse.y\n- by  GNU Bison version 1.27\n-  */\n+    by GNU Bison version 1.28  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -1275,8 +1274,8 @@ static const short yycheck[] = {    38,\n     48,    49,    50,    51,    52,    53,    54,    55,    56,    57\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/bison.simple\"\n-/* This file comes from bison-1.27.  */\n+#line 3 \"/usr/lib/bison.simple\"\n+/* This file comes from bison-1.28.  */\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1489,7 +1488,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 216 \"/usr/share/bison.simple\"\n+#line 217 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2110,7 +2109,7 @@ case 62:\n \t\t  else\n \t\t    name = \"\";\n \t\t  yyval.ttype = result;\n-\t\t  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n+\t\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n \t\t    {\n \t\t      int failure = complete_array_type (type, yyval.ttype, 1);\n \t\t      if (failure)\n@@ -3836,7 +3835,7 @@ case 407:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 542 \"/usr/share/bison.simple\"\n+#line 543 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "99998fce41a4c76759b757717e58ef3d7145c165", "filename": "gcc/c-parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -488,7 +488,7 @@ cast_expr:\n \t\t  else\n \t\t    name = \"\";\n \t\t  $$ = result;\n-\t\t  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n+\t\t  if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n \t\t    {\n \t\t      int failure = complete_array_type (type, $$, 1);\n \t\t      if (failure)"}, {"sha": "d64d566e7e8528da0f43cb90ec0a0cde9ddd551a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -90,8 +90,7 @@ require_complete_type (value)\n     return error_mark_node;\n \n   /* First, detect a valid value with a complete type.  */\n-  if (TYPE_SIZE (type) != 0\n-      && type != void_type_node)\n+  if (COMPLETE_TYPE_P (type))\n     return value;\n \n   incomplete_type_error (value, type);\n@@ -713,7 +712,7 @@ c_sizeof (type)\n   if (code == ERROR_MARK)\n     return size_one_node;\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (!COMPLETE_TYPE_P (type))\n     {\n       error (\"sizeof applied to an incomplete type\");\n       return size_zero_node;\n@@ -734,7 +733,7 @@ c_sizeof_nowarn (type)\n   if (code == FUNCTION_TYPE || code == VOID_TYPE || code == ERROR_MARK)\n     return size_one_node;\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (!COMPLETE_TYPE_P (type))\n     return size_zero_node;\n \n   /* Convert in case a char is more than one unit.  */\n@@ -754,7 +753,7 @@ c_size_in_bytes (type)\n   if (code == FUNCTION_TYPE || code == VOID_TYPE || code == ERROR_MARK)\n     return size_one_node;\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (!COMPLETE_OR_VOID_TYPE_P (type))\n     {\n       error (\"arithmetic on pointer to an incomplete type\");\n       return size_one_node;\n@@ -781,7 +780,7 @@ c_alignof (type)\n   if (code == VOID_TYPE || code == ERROR_MARK)\n     return size_one_node;\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (!COMPLETE_TYPE_P (type))\n     {\n       error (\"__alignof__ applied to an incomplete type\");\n       return size_zero_node;\n@@ -1144,7 +1143,7 @@ build_component_ref (datum, component)\n     {\n       tree indirect = 0;\n \n-      if (TYPE_SIZE (type) == 0)\n+      if (!COMPLETE_TYPE_P (type))\n \t{\n \t  incomplete_type_error (NULL_TREE, type);\n \t  return error_mark_node;\n@@ -1216,7 +1215,7 @@ build_indirect_ref (ptr, errorstring)\n \t  register tree ref = build1 (INDIRECT_REF,\n \t\t\t\t      TYPE_MAIN_VARIANT (t), pointer);\n \n-\t  if (TYPE_SIZE (t) == 0 && TREE_CODE (t) != ARRAY_TYPE)\n+\t  if (!COMPLETE_TYPE_P (t) && TREE_CODE (t) != ARRAY_TYPE)\n \t    {\n \t      error (\"dereferencing pointer to incomplete type\");\n \t      return error_mark_node;\n@@ -1296,7 +1295,7 @@ build_array_ref (array, index)\n \t address arithmetic on its address.\n \t Likewise an array of elements of variable size.  */\n       if (TREE_CODE (index) != INTEGER_CST\n-\t  || (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))) != 0\n+\t  || (COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (array)))\n \t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array)))) != INTEGER_CST))\n \t{\n \t  if (mark_addressable (array) == 0)\n@@ -1537,7 +1536,7 @@ convert_arguments (typelist, values, name, fundecl)\n \t  /* Formal parm type is specified by a function prototype.  */\n \t  tree parmval;\n \n-\t  if (TYPE_SIZE (type) == 0)\n+\t  if (!COMPLETE_TYPE_P (type))\n \t    {\n \t      error (\"type of formal parameter %d is incomplete\", parmnum + 1);\n \t      parmval = val;\n@@ -2176,8 +2175,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  if (comp_target_types (type0, type1))\n \t    {\n \t      result_type = common_type (type0, type1);\n-\t      if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n-\t\t  != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n+\t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))\n+\t\t  != !COMPLETE_TYPE_P (TREE_TYPE (type1)))\n \t\tpedwarn (\"comparison of complete and incomplete pointers\");\n \t      else if (pedantic \n \t\t       && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n@@ -2653,7 +2652,7 @@ pointer_diff (op0, op1)\n   op0 = build_binary_op (MINUS_EXPR, convert (restype, op0),\n \t\t\t convert (restype, op1), 0);\n   /* This generates an error if op1 is pointer to incomplete type.  */\n-  if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n+  if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n     error (\"arithmetic on pointer to an incomplete type\");\n \n   /* This generates an error if op0 is pointer to incomplete type.  */\n@@ -2837,7 +2836,7 @@ build_unary_op (code, xarg, noconvert)\n \t  {\n \t    /* If pointer target is an undefined struct,\n \t       we just cannot know how to do the arithmetic.  */\n-\t    if (TYPE_SIZE (TREE_TYPE (result_type)) == 0)\n+\t    if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (result_type)))\n \t      error (\"%s of pointer to unknown structure\",\n \t\t     code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR\n \t\t     ? \"increment\" : \"decrement\");\n@@ -4666,7 +4665,7 @@ digest_init (type, init, require_constant, constructor_constant)\n \n   /* Come here only for records and arrays.  */\n \n-  if (TYPE_SIZE (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+  if (COMPLETE_TYPE_P (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       error_init (\"variable-sized object may not be initialized\");\n       return error_mark_node;"}, {"sha": "cb5278847207b2ffbb1bbe3b6ea0d0b3f111bc19", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1026,7 +1026,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n       args[i].tree_value = TREE_VALUE (p);\n \n       /* Replace erroneous argument with constant zero.  */\n-      if (type == error_mark_node || TYPE_SIZE (type) == 0)\n+      if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n \targs[i].tree_value = integer_zero_node, type = integer_type_node;\n \n       /* If TYPE is a transparent union, pass things the way we would\n@@ -1100,7 +1100,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\t function being called.  */\n \t      rtx copy;\n \n-\t      if (TYPE_SIZE (type) == 0\n+\t      if (!COMPLETE_TYPE_P (type)\n \t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n \t\t  || (flag_stack_check && ! STACK_CHECK_BUILTIN\n \t\t      && (0 < compare_tree_int (TYPE_SIZE_UNIT (type),"}, {"sha": "9b43485b3d5c3b47ea50d4c0b8006b2655a6a311", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -125,7 +125,7 @@ convert_to_integer (type, expr)\n \n   /* An INTEGER_TYPE cannot be incomplete, but an ENUMERAL_TYPE can\n      be.  Consider `enum E = { a, b = (enum E) 3 };'.  */\n-  if (!TYPE_SIZE (type))\n+  if (!COMPLETE_TYPE_P (type))\n     {\n       error (\"conversion to incomplete type\");\n       return error_mark_node;"}, {"sha": "79297e3b60d30a46ad33dc90e3a8c3cfd66592f3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1,3 +1,38 @@\n+2000-03-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* typeck.c (require_complete_type, complete_type,\n+\tcomplete_type_or_else, c_sizeof, c_sizeof_nowarn,\n+\tbuild_array_ref, convert_arguments, pointer_diff,\n+\tbuild_x_unary_op, build_unary_op, build_c_cast,\n+\tbuild_modify_expr): Use COMPLETE_TYPE_P etc.\n+\t* call.c (is_complete, convert_like_real,\n+\tbuild_new_method_call): Likewise.\n+\t* class.c (build_vbase_pointer_fields, check_bases,\n+\tbuild_base_field, finish_struct_1, pushclass): Likewise.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_void): Likewise.\n+\t* decl.c (maybe_process_template_type_declaration, pushtag,\n+\tpushdecl, redeclaration_error_message, start_decl, start_decl_1,\n+\tlayout_var_decl, check_initializer, cp_finish_decl,\n+\tgrokdeclarator, require_complete_types_for_parms,\n+\tgrok_op_properties, xref_tag, xref_basetypes,\n+\tcheck_function_type): Likewise.\n+\t* decl2.c (check_classfn, reparse_absdcl_as_casts): Likewise.\n+\t* friend.c (do_friend): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t* parse.y (structsp): Likewise.\n+\t* pt.c (maybe_process_partial_specialization,\n+\ttsubst_friend_function, instantiate_class_template, tsubst,\n+\tdo_type_instantiation, instantiate_pending_templates): Likewise.\n+\t* repo.c (repo_get_id): Likewise.\n+\t* rtti.c (build_typeid, get_typeid, build_dynamic_cast_1,\n+\tsynthesize_tinfo_var, emit_support_tinfos): Likewise.\n+\t* search.c (lookup_fnfields_1, lookup_conversions): Likewise.\n+\t* semantics.c (begin_class_definition): Likewise.\n+\t* tree.c (build_cplus_method_type): Likewise.\n+\t* typeck2.c (digest_init, build_functional_cast,\n+\tadd_exception_specifier): Likewise.\n+\t* parse.h, parse.c: Regenerated.\n+\n 2000-03-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* inc/cxxabi.h: New header file. Define new-abi entry points."}, {"sha": "b505b748649eb0b66a438f54cf7747efe8a20d4d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1514,7 +1514,7 @@ static int\n is_complete (t)\n      tree t;\n {\n-  return TYPE_SIZE (complete_type (t)) != NULL_TREE;\n+  return COMPLETE_TYPE_P (complete_type (t));\n }\n \n /* Returns non-zero if TYPE is a promoted arithmetic type.  */\n@@ -3736,7 +3736,7 @@ convert_like_real (convs, expr, fn, argnum, inner)\n \t       conversion because the type might be an incomplete\n \t       array type, which is OK if some constructor for the\n \t       destination type takes a pointer argument.  */\n-\t    if (TYPE_SIZE (TREE_TYPE (expr)) == 0)\n+\t    if (!COMPLETE_TYPE_P (TREE_TYPE (expr)))\n \t      {\n \t\tif (same_type_p (TREE_TYPE (expr), TREE_TYPE (convs)))\n \t\t  incomplete_type_error (expr, TREE_TYPE (expr));\n@@ -4313,7 +4313,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       /* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */\n       if (flags & LOOKUP_SPECULATIVELY)\n \treturn NULL_TREE;\n-      if (TYPE_SIZE (basetype) == 0)\n+      if (!COMPLETE_TYPE_P (basetype))\n \tincomplete_type_error (instance_ptr, basetype);\n       else\n \tcp_error (\"no matching function for call to `%T::%D (%A)%V'\","}, {"sha": "4be6f3e1b330c3acec06e300988abb5f3e73825d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -200,7 +200,7 @@ build_vbase_pointer_fields (rli, empty_p)\n       register tree base_binfo = TREE_VEC_ELT (binfos, i);\n       register tree basetype = BINFO_TYPE (base_binfo);\n \n-      if (TYPE_SIZE (basetype) == 0)\n+      if (!COMPLETE_TYPE_P (basetype))\n \t/* This error is now reported in xref_tag, thus giving better\n \t   location information.  */\n \tcontinue;\n@@ -1876,7 +1876,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n       /* If the type of basetype is incomplete, then we already\n \t complained about that fact (and we should have fixed it up as\n \t well).  */\n-      if (TYPE_SIZE (basetype) == 0)\n+      if (!COMPLETE_TYPE_P (basetype))\n \t{\n \t  int j;\n \t  /* The base type is of incomplete type.  It is\n@@ -4246,7 +4246,7 @@ build_base_field (rli, binfo, empty_p, base_align, v)\n   tree basetype = BINFO_TYPE (binfo);\n   tree decl;\n \n-  if (TYPE_SIZE (basetype) == 0)\n+  if (!COMPLETE_TYPE_P (basetype))\n     /* This error is now reported in xref_tag, thus giving better\n        location information.  */\n     return;\n@@ -5133,7 +5133,7 @@ finish_struct_1 (t)\n   tree vfield;\n   int empty = 1;\n \n-  if (TYPE_SIZE (t))\n+  if (COMPLETE_TYPE_P (t))\n     {\n       if (IS_AGGR_TYPE (t))\n \tcp_error (\"redefinition of `%#T'\", t);\n@@ -5642,7 +5642,7 @@ pushclass (type, modify)\n \n   if (previous_class_type != NULL_TREE\n       && (type != previous_class_type \n-\t  || TYPE_SIZE (previous_class_type) == NULL_TREE)\n+\t  || !COMPLETE_TYPE_P (previous_class_type))\n       && current_class_depth == 1)\n     {\n       /* Forcibly remove any old class remnants.  */"}, {"sha": "ad114d6db04e1d1973b6d340de7fd44185b1af98", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -79,7 +79,7 @@ cp_convert_to_pointer (type, expr)\n   if (IS_AGGR_TYPE (intype))\n     {\n       intype = complete_type (intype);\n-      if (TYPE_SIZE (intype) == NULL_TREE)\n+      if (!COMPLETE_TYPE_P (intype))\n \t{\n \t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n \t\t    intype, type);\n@@ -901,7 +901,7 @@ convert_to_void (expr, implicit)\n         int is_reference = TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0)))\n                            == REFERENCE_TYPE;\n         int is_volatile = TYPE_VOLATILE (type);\n-        int is_complete = TYPE_SIZE (complete_type (type)) != NULL_TREE;\n+        int is_complete = COMPLETE_TYPE_P (complete_type (type));\n         \n         if (is_volatile && !is_complete)\n           cp_warning (\"object of incomplete type `%T' will not be accessed in %s\",\n@@ -920,7 +920,7 @@ convert_to_void (expr, implicit)\n       {\n         /* External variables might be incomplete.  */\n         tree type = TREE_TYPE (expr);\n-        int is_complete = TYPE_SIZE (complete_type (type)) != NULL_TREE;\n+        int is_complete = COMPLETE_TYPE_P (complete_type (type));\n         \n         if (TYPE_VOLATILE (type) && !is_complete)\n           cp_warning (\"object `%E' of incomplete type `%T' will not be accessed in %s\","}, {"sha": "813ef6f2668a73113707ec89d973d996547932a6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -2722,7 +2722,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t\t binding level, but is instead the pseudo-global level.  */\n \t      b->level_chain->tags =\n \t\ttree_cons (name, type, b->level_chain->tags);\n-\t      if (TYPE_SIZE (current_class_type) == NULL_TREE)\n+\t      if (!COMPLETE_TYPE_P (current_class_type))\n \t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n \t    }\n \t}\n@@ -2838,7 +2838,7 @@ pushtag (name, type, globalize)\n         }\n       if (b->parm_flag == 2)\n \t{\n-\t  if (TYPE_SIZE (current_class_type) == NULL_TREE)\n+\t  if (!COMPLETE_TYPE_P (current_class_type))\n \t    CLASSTYPE_TAGS (current_class_type) = b->tags;\n \t}\n     }\n@@ -4144,7 +4144,7 @@ pushdecl (x)\n       /* Keep count of variables in this level with incomplete type.  */\n       if (TREE_CODE (x) == VAR_DECL\n \t  && TREE_TYPE (x) != error_mark_node\n-\t  && ((TYPE_SIZE (TREE_TYPE (x)) == NULL_TREE\n+\t  && ((!COMPLETE_TYPE_P (TREE_TYPE (x))\n \t       && PROMOTES_TO_AGGR_TYPE (TREE_TYPE (x), ARRAY_TYPE))\n \t      /* RTTI TD entries are created while defining the type_info.  */\n \t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n@@ -4668,8 +4668,8 @@ redeclaration_error_message (newdecl, olddecl)\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl))\n \t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)))\n \t  || (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL\n-\t      && TYPE_SIZE (TREE_TYPE (newdecl))\n-\t      && TYPE_SIZE (TREE_TYPE (olddecl))))\n+\t      && COMPLETE_TYPE_P (TREE_TYPE (newdecl))\n+\t      && COMPLETE_TYPE_P (TREE_TYPE (olddecl))))\n \treturn \"redefinition of `%#D'\";\n       return 0;\n     }\n@@ -7003,7 +7003,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n   cplus_decl_attributes (decl, attributes, prefix_attributes);\n \n-  if (context && TYPE_SIZE (complete_type (context)) != NULL_TREE)\n+  if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n       push_nested_class (context, 2);\n \n@@ -7110,7 +7110,7 @@ start_decl_1 (decl)\n     {\n       /* Don't allow initializations for incomplete types except for\n \t arrays which might be completed by the initialization.  */\n-      if (TYPE_SIZE (complete_type (type)) != NULL_TREE)\n+      if (COMPLETE_TYPE_P (complete_type (type)))\n \t;\t\t\t/* A complete type is ok.  */\n       else if (TREE_CODE (type) != ARRAY_TYPE)\n \t{\n@@ -7119,7 +7119,7 @@ start_decl_1 (decl)\n \t  initialized = 0;\n \t  type = TREE_TYPE (decl) = error_mark_node;\n \t}\n-      else if (TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n+      else if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n \t  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n \t    cp_error (\"elements of array `%#D' have incomplete type\", decl);\n@@ -7136,7 +7136,7 @@ start_decl_1 (decl)\n       && ! DECL_EXTERNAL (decl))\n     {\n       if ((! processing_template_decl || ! uses_template_parms (type))\n-\t  && TYPE_SIZE (complete_type (type)) == NULL_TREE)\n+\t  && !COMPLETE_TYPE_P (complete_type (type)))\n \t{\n \t  cp_error (\"aggregate `%#D' has incomplete type and cannot be initialized\",\n \t\t decl);\n@@ -7337,7 +7337,7 @@ layout_var_decl (decl)\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);\n-  if (!DECL_SIZE (decl) && TYPE_SIZE (type))\n+  if (!DECL_SIZE (decl) && COMPLETE_TYPE_P (type))\n     layout_decl (decl, 0);\n \n   if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)\n@@ -7480,18 +7480,18 @@ check_initializer (decl, init)\n       if (type == error_mark_node)\n \t/* We will have already complained.  */\n \tinit = NULL_TREE;\n-      else if (TYPE_SIZE (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n+      else if (COMPLETE_TYPE_P (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n \t{\n \t  cp_error (\"variable-sized object `%D' may not be initialized\", decl);\n \t  init = NULL_TREE;\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE\n-\t       && !TYPE_SIZE (TREE_TYPE (type)))\n+\t       && !COMPLETE_TYPE_P (TREE_TYPE (type)))\n \t{\n \t  cp_error (\"elements of array `%#D' have incomplete type\", decl);\n \t  init = NULL_TREE;\n \t}\n-      else if (!TYPE_SIZE (type))\n+      else if (!COMPLETE_TYPE_P (type))\n \t{\n \t  cp_error (\"`%D' has incomplete type\", decl);\n \t  TREE_TYPE (decl) = error_mark_node;\n@@ -7565,8 +7565,7 @@ check_initializer (decl, init)\n \n       check_for_uninitialized_const_var (decl);\n \n-      if (TYPE_SIZE (type) != NULL_TREE\n-\t  && TYPE_NEEDS_CONSTRUCTING (type))\n+      if (COMPLETE_TYPE_P (type) && TYPE_NEEDS_CONSTRUCTING (type))\n \tinit = obscure_complex_init (decl, NULL_TREE);\n \n     }\n@@ -7944,7 +7943,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t type, and that type has not been defined yet, delay emitting\n \t the debug information for it, as we will emit it later.  */\n       if (TYPE_MAIN_DECL (TREE_TYPE (decl)) == decl\n-\t  && TYPE_SIZE (TREE_TYPE (decl)) == NULL_TREE)\n+\t  && !COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \tTYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n \n       rest_of_decl_compilation (decl, NULL_PTR,\n@@ -8059,7 +8058,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \t    /* If size hasn't been set, we're still defining it,\n \t       and therefore inside the class body; don't pop\n \t       the binding level..  */\n-\t    && TYPE_SIZE (context) != NULL_TREE\n+\t    && COMPLETE_TYPE_P (context)\n \t    && context == current_class_type)\n \t  pop_nested_class ();\n       }\n@@ -10695,7 +10694,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      }\n \t\t  }\n \t\telse if (RIDBIT_SETP (RID_TYPEDEF, specbits)\n-\t\t\t || TYPE_SIZE (complete_type (ctype)) != NULL_TREE)\n+\t\t\t || COMPLETE_TYPE_P (complete_type (ctype)))\n \t\t  {\n \t\t    /* Have to move this code elsewhere in this function.\n \t\t       this code is used for i.e., typedef int A::M; M *pm;\n@@ -11212,7 +11211,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      return NULL_TREE;\n \t  }\n \telse if (!staticp && ! processing_template_decl\n-\t\t && TYPE_SIZE (complete_type (type)) == NULL_TREE\n+\t\t && !COMPLETE_TYPE_P (complete_type (type))\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n \t    if (declarator)\n@@ -11532,7 +11531,7 @@ require_complete_types_for_parms (parms)\n       if (type == error_mark_node)\n \tcontinue;\n \n-      if (TYPE_SIZE (type) == NULL_TREE)\n+      if (!COMPLETE_TYPE_P (type))\n \t{\n \t  if (DECL_NAME (parms))\n \t    error (\"parameter `%s' has incomplete type\",\n@@ -12160,7 +12159,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t\twhat = \"the same type\";\n \t      /* Don't force t to be complete here.  */\n \t      else if (IS_AGGR_TYPE (t)\n-\t\t       && TYPE_SIZE (t)\n+\t\t       && COMPLETE_TYPE_P (t)\n \t\t       && DERIVED_FROM_P (t, current_class_type))\n \t\twhat = \"a base class\";\n \n@@ -12533,7 +12532,7 @@ xref_tag (code_type_node, name, globalize)\n \n   /* Until the type is defined, tentatively accept whatever\n      structure tag the user hands us.  */\n-  if (TYPE_SIZE (ref) == NULL_TREE\n+  if (!COMPLETE_TYPE_P (ref)\n       && ref != current_class_type\n       /* Have to check this, in case we have contradictory tag info.  */\n       && IS_AGGR_TYPE_CODE (TREE_CODE (ref)))\n@@ -12643,7 +12642,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n       /* This code replaces similar code in layout_basetypes.\n          We put the complete_type first for implicit `typename'.  */\n-      if (TYPE_SIZE (basetype) == NULL_TREE\n+      if (!COMPLETE_TYPE_P (basetype)\n \t  && ! (current_template_parms && uses_template_parms (basetype)))\n \t{\n \t  cp_error (\"base class `%T' has incomplete type\", basetype);\n@@ -13058,11 +13057,12 @@ check_function_type (decl)\n      tree decl;\n {\n   tree fntype = TREE_TYPE (decl);\n+  tree return_type = complete_type (TREE_TYPE (fntype));\n \n   /* In a function definition, arg types must be complete.  */\n   require_complete_types_for_parms (current_function_parms);\n \n-  if (TYPE_SIZE (complete_type (TREE_TYPE (fntype))) == NULL_TREE)\n+  if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n     {\n       cp_error (\"return type `%#T' is incomplete\", TREE_TYPE (fntype));\n "}, {"sha": "3d51808954e932e5558e34530afcdf2cf97ba7ba", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1457,7 +1457,7 @@ check_classfn (ctype, function)\n   else\n     {\n       methods = 0;\n-      if (TYPE_SIZE (ctype) == 0)\n+      if (!COMPLETE_TYPE_P (ctype))\n         incomplete_type_error (function, ctype);\n       else\n         cp_error (\"no `%#D' member function declared in class `%T'\",\n@@ -1468,7 +1468,7 @@ check_classfn (ctype, function)\n      spurious errors (unless the CTYPE is not yet defined, in which\n      case we'll only confuse ourselves when the function is declared\n      properly within the class.  */\n-  if (TYPE_SIZE (ctype))\n+  if (COMPLETE_TYPE_P (ctype))\n     add_method (ctype, methods, function);\n   return NULL_TREE;\n }\n@@ -3734,7 +3734,7 @@ reparse_absdcl_as_casts (decl, expr)\n       decl = TREE_OPERAND (decl, 0);\n \n       expr = digest_init (type, expr, (tree *) 0);\n-      if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n+      if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n \t{\n \t  int failure = complete_array_type (type, expr, 1);\n \t  if (failure)"}, {"sha": "20bb5d82721533b3a9a29ac48a3ec1879f88ee26", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -362,7 +362,7 @@ do_friend (ctype, declarator, decl, parmdecls, attrlist,\n       /* A nested class may declare a member of an enclosing class\n \t to be a friend, so we do lookup here even if CTYPE is in\n \t the process of being defined.  */\n-      else if (TYPE_SIZE (ctype) != 0 || TYPE_BEING_DEFINED (ctype))\n+      else if (COMPLETE_TYPE_P (ctype) || TYPE_BEING_DEFINED (ctype))\n \t{\n \t  decl = check_classfn (ctype, decl);\n "}, {"sha": "ff8e0583434eb30889e951e44218937b6613bbf6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1610,7 +1610,7 @@ build_offset_ref (type, name)\n     name = ctor_identifier;\n #endif\n \n-  if (TYPE_SIZE (complete_type (type)) == 0\n+  if (!COMPLETE_TYPE_P (complete_type (type))\n       && !TYPE_BEING_DEFINED (type))\n     {\n       cp_error (\"incomplete type `%T' does not have member `%D'\", type,"}, {"sha": "306bd16e05e95397177a22a5818ffaf023bb0ade", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1,7 +1,6 @@\n \n /*  A Bison parser, made from parse.y\n- by  GNU Bison version 1.27\n-  */\n+    by GNU Bison version 1.28  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -4031,8 +4030,8 @@ static const short yycheck[] = {     4,\n     78,    79,    80,    81,    82,    83,    84,    85\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/bison.simple\"\n-/* This file comes from bison-1.27.  */\n+#line 3 \"/usr/lib/bison.simple\"\n+/* This file comes from bison-1.28.  */\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -4245,7 +4244,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 216 \"/usr/share/bison.simple\"\n+#line 217 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -6543,7 +6542,7 @@ case 480:\n \t\t      /* struct B: public A; is not accepted by the standard grammar.  */\n \t\t      if (CLASS_TYPE_P (yyval.ftype.t)\n \t\t\t  && TYPE_BINFO_BASETYPES (yyval.ftype.t) \n-\t\t\t  && !TYPE_SIZE (yyval.ftype.t)\n+\t\t\t  && !COMPLETE_TYPE_P (yyval.ftype.t)\n \t\t\t  && ! TYPE_BEING_DEFINED (yyval.ftype.t))\n \t\t\tcp_error (\"base clause without member specification for `%#T'\",\n \t\t\t\t  yyval.ftype.t);\n@@ -8230,7 +8229,7 @@ case 878:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 542 \"/usr/share/bison.simple\"\n+#line 543 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "b593c1d03208f3d40738339444b19e23439a0c53", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -2206,7 +2206,7 @@ structsp:\n \t\t      /* struct B: public A; is not accepted by the standard grammar.  */\n \t\t      if (CLASS_TYPE_P ($$.t)\n \t\t\t  && TYPE_BINFO_BASETYPES ($$.t) \n-\t\t\t  && !TYPE_SIZE ($$.t)\n+\t\t\t  && !COMPLETE_TYPE_P ($$.t)\n \t\t\t  && ! TYPE_BEING_DEFINED ($$.t))\n \t\t\tcp_error (\"base clause without member specification for `%#T'\",\n \t\t\t\t  $$.t);"}, {"sha": "abb9539439d607ead6cc66dedb7d03a95ad51bd5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -657,7 +657,7 @@ maybe_process_partial_specialization (type)\n   if (IS_AGGR_TYPE (type) && CLASSTYPE_USE_TEMPLATE (type))\n     {\n       if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n-\t  && TYPE_SIZE (type) == NULL_TREE)\n+\t  && !COMPLETE_TYPE_P (type))\n \t{\n \t  if (current_namespace\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n@@ -4577,7 +4577,7 @@ tsubst_friend_function (decl, args)\n \t  new_friend = old_decl;\n \t}\n     }\n-  else if (TYPE_SIZE (DECL_CONTEXT (new_friend)))\n+  else if (COMPLETE_TYPE_P (DECL_CONTEXT (new_friend)))\n     {\n       /* Check to see that the declaration is really present, and,\n \t possibly obtain an improved declaration.  */\n@@ -4673,7 +4673,7 @@ instantiate_class_template (type)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TYPE_BEING_DEFINED (type) || TYPE_SIZE (type))\n+  if (TYPE_BEING_DEFINED (type) || COMPLETE_TYPE_P (type))\n     return type;\n \n   /* Figure out which template is being instantiated.  */\n@@ -4749,7 +4749,7 @@ instantiate_class_template (type)\n \n   /* If the template we're instantiating is incomplete, then clearly\n      there's nothing we can do.  */\n-  if (TYPE_SIZE (pattern) == NULL_TREE)\n+  if (!COMPLETE_TYPE_P (pattern))\n     return type;\n \n   /* If this is a partial instantiation, don't tsubst anything.  We will\n@@ -6623,7 +6623,7 @@ tsubst (t, args, complain, in_decl)\n \t       point, so here CTX really should have complete type, unless\n \t       it's a partial instantiation.  */\n \t    ctx = complete_type (ctx);\n-\t    if (!TYPE_SIZE (ctx))\n+\t    if (!COMPLETE_TYPE_P (ctx))\n \t      {\n \t\tif (complain)\n \t\t  incomplete_type_error (NULL_TREE, ctx);\n@@ -9177,7 +9177,7 @@ do_type_instantiation (t, storage)\n   if (flag_external_templates)\n     return;\n \n-  if (TYPE_SIZE (t) == NULL_TREE)\n+  if (!COMPLETE_TYPE_P (t))\n     {\n       cp_error (\"explicit instantiation of `%#T' before definition of template\",\n \t\tt);\n@@ -9653,7 +9653,7 @@ instantiate_pending_templates ()\n \t    {\n \t      tree fn;\n \n-\t      if (!TYPE_SIZE (instantiation))\n+\t      if (!COMPLETE_TYPE_P (instantiation))\n \t\t{\n \t\t  instantiate_class_template (instantiation);\n \t\t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (instantiation))\n@@ -9662,14 +9662,14 @@ instantiate_pending_templates ()\n \t\t\t fn = TREE_CHAIN (fn))\n \t\t      if (! DECL_ARTIFICIAL (fn))\n \t\t\tinstantiate_decl (fn);\n-\t\t  if (TYPE_SIZE (instantiation))\n+\t\t  if (COMPLETE_TYPE_P (instantiation))\n \t\t    {\n \t\t      instantiated_something = 1;\n \t\t      reconsider = 1;\n \t\t    }\n \t\t}\n \n-\t      if (TYPE_SIZE (instantiation))\n+\t      if (COMPLETE_TYPE_P (instantiation))\n \t\t/* If INSTANTIATION has been instantiated, then we don't\n \t\t   need to consider it again in the future.  */\n \t\t*t = TREE_CHAIN (*t);"}, {"sha": "0724a45c0151273d99bb0e8433d205b98d50a6bc", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -100,7 +100,7 @@ repo_get_id (t)\n       /* If we're not done setting up the class, we may not have set up\n \t the vtable, so going ahead would give the wrong answer.\n          See g++.pt/instantiate4.C.  */\n-      if (TYPE_SIZE (t) == NULL_TREE || TYPE_BEING_DEFINED (t))\n+      if (!COMPLETE_TYPE_P (t) || TYPE_BEING_DEFINED (t))\n \tmy_friendly_abort (981113);\n \n       t = TYPE_BINFO_VTABLE (t);"}, {"sha": "7a8baac75e8e732337669724e9fc141b858fed28", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -273,7 +273,7 @@ build_typeid (exp)\n       return error_mark_node;\n     }\n   \n-  if (TYPE_SIZE (type_info_type_node) == NULL_TREE)\n+  if (!COMPLETE_TYPE_P (type_info_type_node))\n     {\n       error (\"must #include <typeinfo> before using typeid\");\n       return error_mark_node;\n@@ -462,7 +462,7 @@ get_typeid (type)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  if (TYPE_SIZE (type_info_type_node) == NULL_TREE)\n+  if (!COMPLETE_TYPE_P (type_info_type_node))\n     {\n       error (\"must #include <typeinfo> before using typeid\");\n       return error_mark_node;\n@@ -564,7 +564,7 @@ build_dynamic_cast_1 (type, expr)\n \t  errstr = \"target is not pointer or reference to class\";\n \t  goto fail;\n \t}\n-      if (TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n+      if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n \t  errstr = \"target is not pointer or reference to complete type\";\n \t  goto fail;\n@@ -609,7 +609,7 @@ build_dynamic_cast_1 (type, expr)\n \t  errstr = \"source is not a pointer to class\";\n \t  goto fail;\n \t}\n-      if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n+      if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (exprtype))))\n \t{\n \t  errstr = \"source is a pointer to incomplete type\";\n \t  goto fail;\n@@ -625,7 +625,7 @@ build_dynamic_cast_1 (type, expr)\n \t  errstr = \"source is not of class type\";\n \t  goto fail;\n \t}\n-      if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n+      if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (exprtype))))\n \t{\n \t  errstr = \"source is of incomplete class type\";\n \t  goto fail;\n@@ -1466,7 +1466,7 @@ synthesize_tinfo_var (target_type, real_name)\n       break;\n     case UNION_TYPE:\n     case RECORD_TYPE:\n-      if (!TYPE_SIZE (target_type))\n+      if (!COMPLETE_TYPE_P (target_type))\n         {\n           /* FIXME: incomplete type. Awaiting specification.  */\n           return NULL_TREE;\n@@ -1820,7 +1820,7 @@ emit_support_tinfos ()\n   bltn_type = xref_tag (class_type_node,\n                         get_identifier (\"__fundamental_type_info\"), 1);\n   pop_nested_namespace (abi_node);\n-  if (!TYPE_SIZE (bltn_type))\n+  if (!COMPLETE_TYPE_P (bltn_type))\n     return;\n   dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (bltn_type), 1);\n   if (DECL_EXTERNAL (dtor))"}, {"sha": "06673577794aad0c65b72bb5d4d5283e4be0c2dc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1692,7 +1692,7 @@ lookup_fnfields_1 (type, name)\n \t  /* If the type is complete and we're past the conversion ops,\n \t     switch to binary search.  */\n \t  if (! DECL_CONV_FN_P (tmp)\n-\t      && TYPE_SIZE (type))\n+\t      && COMPLETE_TYPE_P (type))\n \t    {\n \t      int lo = i + 1, hi = len;\n \n@@ -3560,7 +3560,7 @@ lookup_conversions (type)\n   tree t;\n   tree conversions = NULL_TREE;\n \n-  if (TYPE_SIZE (type))\n+  if (COMPLETE_TYPE_P (type))\n     bfs_walk (TYPE_BINFO (type), add_conversions, 0, &conversions);\n \n   for (t = conversions; t; t = TREE_CHAIN (t))"}, {"sha": "9b2fa8763d648ed81cfd0e7b49dba7e66d91b904", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1919,7 +1919,7 @@ begin_class_definition (t)\n     }\n   /* If this type was already complete, and we see another definition,\n      that's an error.  */\n-  else if (TYPE_SIZE (t))\n+  else if (COMPLETE_TYPE_P (t))\n     duplicate_tag_error (t);\n \n   /* Update the location of the decl.  */"}, {"sha": "84c7f3f0470569f5765510d2f069006752f2bbf1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -474,7 +474,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n \n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n   return t;"}, {"sha": "0c45c9bcb14e258cfc4dfaf2f244cd06d97dc1c0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -106,7 +106,7 @@ require_complete_type (value)\n     type = TREE_TYPE (value);\n \n   /* First, detect a valid value with a complete type.  */\n-  if (TYPE_SIZE (type) && !integer_zerop (TYPE_SIZE (type)))\n+  if (COMPLETE_TYPE_P (type))\n     return value;\n \n   /* If we see X::Y, we build an OFFSET_TYPE which has\n@@ -145,12 +145,12 @@ complete_type (type)\n        at some point.  */\n     return error_mark_node;\n \n-  if (type == error_mark_node || TYPE_SIZE (type) != NULL_TREE)\n+  if (type == error_mark_node || COMPLETE_TYPE_P (type))\n     ;\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n       tree t = complete_type (TREE_TYPE (type));\n-      if (TYPE_SIZE (t) != NULL_TREE && ! processing_template_decl)\n+      if (COMPLETE_TYPE_P (t) && ! processing_template_decl)\n \tlayout_type (type);\n       TYPE_NEEDS_CONSTRUCTING (type)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n@@ -176,7 +176,7 @@ complete_type_or_else (type, value)\n   if (type == error_mark_node)\n     /* We already issued an error.  */\n     return NULL_TREE;\n-  else if (!TYPE_SIZE (type) || integer_zerop (TYPE_SIZE (type)))\n+  else if (!COMPLETE_TYPE_P (type))\n     {\n       incomplete_type_error (value, type);\n       return NULL_TREE;\n@@ -1584,7 +1584,7 @@ c_sizeof (type)\n       return size_zero_node;\n     }\n \n-  if (TYPE_SIZE (complete_type (type)) == 0)\n+  if (!COMPLETE_TYPE_P (complete_type (type)))\n     {\n       cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n       return size_zero_node;\n@@ -1643,7 +1643,7 @@ c_sizeof_nowarn (type)\n   if (code == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  if (TYPE_SIZE (type) == 0)\n+  if (!COMPLETE_TYPE_P (type))\n     return size_zero_node;\n \n   /* Convert in case a char is more than one unit.  */\n@@ -2436,7 +2436,7 @@ build_array_ref (array, idx)\n \t address arithmetic on its address.\n \t Likewise an array of elements of variable size.  */\n       if (TREE_CODE (idx) != INTEGER_CST\n-\t  || (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))) != 0\n+\t  || (COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (array)))\n \t      && (TREE_CODE (TYPE_SIZE (TREE_TYPE (TREE_TYPE (array))))\n \t\t  != INTEGER_CST)))\n \t{\n@@ -3163,7 +3163,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  /* Formal parm type is specified by a function prototype.  */\n \t  tree parmval;\n \n-\t  if (TYPE_SIZE (complete_type (type)) == 0)\n+\t  if (!COMPLETE_TYPE_P (complete_type (type)))\n \t    {\n \t      error (\"parameter type of called function is incomplete\");\n \t      parmval = val;\n@@ -4228,7 +4228,7 @@ pointer_diff (op0, op1, ptrtype)\n \t\t\t cp_convert (restype, op1));\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n-  if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n+  if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n     error (\"invalid use of a pointer to an incomplete type in pointer arithmetic\");\n \n   op1 = ((TREE_CODE (target_type) == VOID_TYPE\n@@ -4316,7 +4316,7 @@ build_x_unary_op (code, xarg)\n   if (code == ADDR_EXPR\n       && TREE_CODE (xarg) != TEMPLATE_ID_EXPR\n       && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n-\t   && TYPE_SIZE (TREE_TYPE (xarg)) == NULL_TREE)\n+\t   && !COMPLETE_TYPE_P (TREE_TYPE (xarg)))\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n     /* don't look for a function */;\n   else\n@@ -4524,7 +4524,9 @@ build_unary_op (code, xarg, noconvert)\n \tif (TREE_CODE (argtype) == POINTER_TYPE)\n \t  {\n \t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n-\t    if (TYPE_SIZE (complete_type (TREE_TYPE (argtype))) == 0)\n+\t    tree type = complete_type (TREE_TYPE (argtype));\n+\t    \n+\t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n \t      cp_error (\"cannot %s a pointer to incomplete type `%T'\",\n \t\t\t((code == PREINCREMENT_EXPR\n \t\t\t  || code == POSTINCREMENT_EXPR)\n@@ -5536,8 +5538,8 @@ build_c_cast (type, expr)\n       && TREE_CODE (otype) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n       && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n-      && TYPE_SIZE (TREE_TYPE (otype))\n-      && TYPE_SIZE (TREE_TYPE (type))\n+      && COMPLETE_TYPE_P (TREE_TYPE (otype))\n+      && COMPLETE_TYPE_P (TREE_TYPE (type))\n       && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n     cp_warning (\"cast from `%T' to `%T' increases required alignment of target type\",\n                 otype, type);\n@@ -5819,7 +5821,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t{\n \t  tree tmp = convert_from_reference (lhs);\n \t  lhstype = TREE_TYPE (tmp);\n-\t  if (TYPE_SIZE (lhstype) == 0)\n+\t  if (!COMPLETE_TYPE_P (lhstype))\n \t    {\n \t      incomplete_type_error (lhs, lhstype);\n \t      return error_mark_node;\n@@ -5830,7 +5832,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (TREE_CODE (TREE_TYPE (newrhs)) == REFERENCE_TYPE)\n \t{\n \t  tree tmp = convert_from_reference (newrhs);\n-\t  if (TYPE_SIZE (TREE_TYPE (tmp)) == 0)\n+\t  if (!COMPLETE_TYPE_P (TREE_TYPE (tmp)))\n \t    {\n \t      incomplete_type_error (newrhs, TREE_TYPE (tmp));\n \t      return error_mark_node;"}, {"sha": "de52481228b48fbb5791e770b7d4bb4b0e1edb28", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -648,7 +648,7 @@ digest_init (type, init, tail)\n \n   /* Come here only for records and arrays (and unions with constructors).  */\n \n-  if (TYPE_SIZE (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n+  if (COMPLETE_TYPE_P (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n       cp_error (\"variable-sized object of type `%T' may not be initialized\",\n \t\ttype);\n@@ -1267,11 +1267,8 @@ build_functional_cast (exp, parms)\n \t \n      then the slot being initialized will be filled in.  */\n \n-  if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n-    {\n-      cp_error (\"type `%T' is not yet defined\", type);\n-      return error_mark_node;\n-    }\n+  if (!complete_type_or_else (type, NULL_TREE))\n+    return error_mark_node;\n   if (abstract_virtuals_error (NULL_TREE, type))\n     return error_mark_node;\n \n@@ -1474,7 +1471,7 @@ add_exception_specifier (list, spec, complain)\n   else if (TREE_CODE (core) == TEMPLATE_TYPE_PARM)\n     ok = 1;\n   else\n-    ok = TYPE_SIZE (complete_type (core)) != NULL_TREE;\n+    ok = COMPLETE_TYPE_P (complete_type (core));\n   \n   if (ok)\n     {"}, {"sha": "eb51d2b43ee390072e09e333818da1c6f70e3091", "filename": "gcc/dbxout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -473,7 +473,7 @@ dbxout_typedefs (syms)\n \t  tree type = TREE_TYPE (syms);\n \t  if (TYPE_NAME (type)\n \t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t      && TYPE_SIZE (type) != NULL_TREE\n+\t      && COMPLETE_TYPE_P (type)\n \t      && ! TREE_ASM_WRITTEN (TYPE_NAME (type)))\n \t    dbxout_symbol (TYPE_NAME (type), 0);\n \t}\n@@ -1072,7 +1072,7 @@ dbxout_type (type, full, show_arg_types)\n \t and either that's all we want or that's the best we could do,\n \t don't repeat the cross reference.\n \t Sun dbx crashes if we do.  */\n-      if (! full || TYPE_SIZE (type) == 0\n+      if (! full || !COMPLETE_TYPE_P (type)\n \t  /* No way in DBX fmt to describe a variable size.  */\n \t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \treturn;\n@@ -1097,7 +1097,7 @@ dbxout_type (type, full, show_arg_types)\n \t && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t       && DECL_IGNORED_P (TYPE_NAME (type)))\n \t && !full)\n-\t|| TYPE_SIZE (type) == 0\n+\t|| !COMPLETE_TYPE_P (type)\n \t/* No way in DBX fmt to describe a variable size.  */\n \t|| TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n       {\n@@ -1362,7 +1362,7 @@ dbxout_type (type, full, show_arg_types)\n \t     && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t\t   && DECL_IGNORED_P (TYPE_NAME (type)))\n \t     && !full)\n-\t    || TYPE_SIZE (type) == 0\n+\t    || !COMPLETE_TYPE_P (type)\n \t    /* No way in DBX fmt to describe a variable size.  */\n \t    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \t  {\n@@ -1487,7 +1487,7 @@ dbxout_type (type, full, show_arg_types)\n \t   && ! (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t\t && DECL_IGNORED_P (TYPE_NAME (type)))\n \t   && !full)\n-\t  || TYPE_SIZE (type) == 0)\n+\t  || !COMPLETE_TYPE_P (type))\n \t{\n \t  fprintf (asmfile, \"xe\");\n \t  CHARS (3);\n@@ -1866,7 +1866,7 @@ dbxout_symbol (decl, local)\n \tif (tag_needed && TYPE_NAME (type) != 0\n \t    && (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE\n \t\t|| (DECL_NAME (TYPE_NAME (type)) != 0))\n-\t    && TYPE_SIZE (type) != 0\n+\t    && COMPLETE_TYPE_P (type)\n \t    && !TREE_ASM_WRITTEN (TYPE_NAME (type)))\n \t  {\n \t    /* For a TYPE_DECL with no name, but the type has a name,"}, {"sha": "5bac9060a53ea5a898bdb234a8ab55fa6e23804f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -2410,6 +2410,7 @@ location_or_const_value_attribute (decl)\n \t  rtl = DECL_INCOMING_RTL (decl);\n \telse if (! BYTES_BIG_ENDIAN)\n \t  if (TREE_CODE (declared_type) == INTEGER_TYPE)\n+\t    /* NMS WTF? */\n \t    if (TYPE_SIZE (declared_type) <= TYPE_SIZE (passed_type))\n \t      rtl = DECL_INCOMING_RTL (decl);\n       }\n@@ -3361,7 +3362,7 @@ output_enumeration_type_die (arg)\n      given enum type is incomplete, do not generate the AT_byte_size\n      attribute or the AT_element_list attribute.  */\n \n-  if (TYPE_SIZE (type))\n+  if (COMPLETE_TYPE_P (type))\n     {\n       byte_size_attribute (type);\n       element_list_attribute (TYPE_FIELDS (type));\n@@ -3794,7 +3795,7 @@ output_structure_type_die (arg)\n      of members (since we don't have any idea what they might be for an\n      incomplete type).\t*/\n \n-  if (TYPE_SIZE (type))\n+  if (COMPLETE_TYPE_P (type))\n     {\n       dienum_push ();\n       byte_size_attribute (type);\n@@ -3907,7 +3908,7 @@ output_union_type_die (arg)\n      of members (since we don't have any idea what they might be for an\n      incomplete type).\t*/\n \n-  if (TYPE_SIZE (type))\n+  if (COMPLETE_TYPE_P (type))\n     {\n       dienum_push ();\n       byte_size_attribute (type);\n@@ -4408,7 +4409,7 @@ output_type (type, containing_scope)\n \t   can safely generate correct Dwarf descriptions for these file-\n \t   scope tagged types.  */\n \n-\tif (TYPE_SIZE (type) == 0\n+\tif (!COMPLETE_TYPE_P (type)\n \t    && (TYPE_CONTEXT (type) == NULL\n \t\t|| AGGREGATE_TYPE_P (TYPE_CONTEXT (type))\n \t\t|| TREE_CODE (TYPE_CONTEXT (type)) == NAMESPACE_DECL)\n@@ -4463,7 +4464,7 @@ output_type (type, containing_scope)\n \t   appropriate (containing) type.\n \t*/\n \n-\tif (TYPE_SIZE (type))\n+\tif (COMPLETE_TYPE_P (type))\n \t  {\n \t    /* First output info about the base classes.  */\n \t    if (TYPE_BINFO (type) && TYPE_BINFO_BASETYPES (type))"}, {"sha": "3c8c269c702219d70dc893659eefd3d233908509", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -5318,7 +5318,7 @@ safe_from_p (x, exp, top_p)\n \t So we assume here that something at a higher level has prevented a\n \t clash.  This is somewhat bogus, but the best we can do.  Only\n \t do this when X is BLKmode and when we are at the top level.  */\n-      || (top_p && TREE_TYPE (exp) != 0 && TYPE_SIZE (TREE_TYPE (exp)) != 0\n+      || (top_p && TREE_TYPE (exp) != 0 && COMPLETE_TYPE_P (TREE_TYPE (exp))\n \t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST\n \t  && (TREE_CODE (TREE_TYPE (exp)) != ARRAY_TYPE\n \t      || TYPE_ARRAY_MAX_SIZE (TREE_TYPE (exp)) == NULL_TREE\n@@ -5875,7 +5875,7 @@ expand_expr (exp, target, tmode, modifier)\n     case VAR_DECL:\n       /* If a static var's type was incomplete when the decl was written,\n \t but the type is complete now, lay out the decl now.  */\n-      if (DECL_SIZE (exp) == 0 && TYPE_SIZE (TREE_TYPE (exp)) != 0\n+      if (DECL_SIZE (exp) == 0 && COMPLETE_TYPE_P (TREE_TYPE (exp))\n \t  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n \t{\n \t  push_obstacks_nochange ();"}, {"sha": "3308dbba564d5c8a6eef4ff82c5a93e293d734c9", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -4638,7 +4638,7 @@ assign_parms (fndecl)\n \n \t      push_to_sequence (conversion_insns);\n \n-\t      if (TYPE_SIZE (type) == 0\n+\t      if (!COMPLETE_TYPE_P (type)\n \t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \t\t/* This is a variable sized object.  */\n \t\tcopy = gen_rtx_MEM (BLKmode,"}, {"sha": "557ecf0deb3f250adc49dfbb2971cfc3fc593aca", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -860,7 +860,7 @@ sdbout_symbol (decl, local)\n \t  || TREE_CODE (type) == UNION_TYPE\n \t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n \t{\n-\t  if (TYPE_SIZE (type) != 0\t\t/* not a forward reference */\n+\t  if (COMPLETE_TYPE_P (type)\t\t/* not a forward reference */\n \t      && KNOWN_TYPE_TAG (type) == 0)\t/* not yet declared */\n \t    sdbout_one_type (type);\n \t}\n@@ -1131,7 +1131,7 @@ sdbout_one_type (type)\n \treturn;\n \n       /* Output nothing if type is not yet defined.  */\n-      if (TYPE_SIZE (type) == 0)\n+      if (!COMPLETE_TYPE_P (type))\n \treturn;\n \n       TREE_ASM_WRITTEN (type) = 1;"}, {"sha": "8773fa9a8a84d60b0911f7666ad408a87ab973a6", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -1163,7 +1163,7 @@ layout_type (type)\n       break;\n \n     case VOID_TYPE:\n-      TYPE_SIZE (type) = bitsize_int (0);\n+      /* VOID_TYPE is an incompletable type, it has no size */\n       TYPE_SIZE_UNIT (type) = size_zero_node;\n       TYPE_ALIGN (type) = 1;\n       TYPE_MODE (type) = VOIDmode;"}, {"sha": "f43c807a753ebd03579b893e1e63a86a1b546d60", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -4731,7 +4731,7 @@ build_array_type (elt_type, index_type)\n   hashcode = TYPE_HASH (elt_type) + TYPE_HASH (index_type);\n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n   return t;\n }\n@@ -4780,7 +4780,7 @@ build_function_type (value_type, arg_types)\n   hashcode = TYPE_HASH (value_type) + type_hash_list (arg_types);\n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n   return t;\n }\n@@ -4817,7 +4817,7 @@ build_method_type (basetype, type)\n   hashcode = TYPE_HASH (basetype) + TYPE_HASH (type);\n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n   return t;\n@@ -4844,7 +4844,7 @@ build_offset_type (basetype, type)\n   hashcode = TYPE_HASH (basetype) + TYPE_HASH (type);\n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n   return t;\n@@ -4869,7 +4869,7 @@ build_complex_type (component_type)\n   hashcode = TYPE_HASH (component_type);\n   t = type_hash_canon (hashcode, t);\n \n-  if (TYPE_SIZE (t) == 0)\n+  if (!COMPLETE_TYPE_P (t))\n     layout_type (t);\n \n   /* If we are writing Dwarf2 output we need to create a name,"}, {"sha": "3f1d62724924320c013cd220cc10c9d2b152f7e9", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0f062fbb30186c3d5b65adee0bf5ac478a366a4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d0f062fbb30186c3d5b65adee0bf5ac478a366a4", "patch": "@@ -468,6 +468,17 @@ extern void tree_class_check_failed PARAMS ((const tree, char,\n #define POINTER_TYPE_P(TYPE) \\\n   (TREE_CODE (TYPE) == POINTER_TYPE || TREE_CODE (TYPE) == REFERENCE_TYPE)\n \n+/* Nonzero if this type is a complete type.  */\n+#define COMPLETE_TYPE_P(NODE) (TYPE_SIZE (NODE) != NULL_TREE)\n+\n+/* Nonzero if this type is complete or is cv void.  */\n+#define COMPLETE_OR_VOID_TYPE_P(NODE) \\\n+    (COMPLETE_TYPE_P (NODE) || TREE_CODE (NODE) == VOID_TYPE)\n+\n+/* Nonzero if this type is complete or is an array with unspecified bound.  */\n+#define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n+    (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : NODE))\n+\n /* Nonzero if TYPE represents a type.  */\n \n #define TYPE_P(TYPE)\t(TREE_CODE_CLASS (TREE_CODE (TYPE)) == 't')"}]}