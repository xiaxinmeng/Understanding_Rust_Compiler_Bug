{"sha": "dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyZWRlODRlNmJlOGQzYmFjODNmZDBmMzQzM2MxYWI3MTk2NWQyYQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-09T15:58:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-09T15:58:37Z"}, "message": "flow.c (life_analysis_1): Break out some functions.\n\nFri Oct  9 15:57:51 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n        * flow.c (life_analysis_1): Break out some functions.\n        (find_basic_blocks_1): Likewise.  Also move some variables out and\n        make them static.\n        Rename NONLOCAL_LABEL_LIST arg to NONLOCAL_LABELS and initialize\n        new static var nonlocal_label_list with it.\n        (active_eh_region, nested_eh_region, label_value_list,\n        nonlocal_label_list): New static variables.\n        (make_edges, delete_unreachable_blocks, delete_block): New static\n        functions, broken out of find_basic_blocks_1.\n        (record_volatile_insns, mark_regs_live_at_end, set_noop_p,\n        noop_move_p): New static functions, broken out of life_analysis_1.\n\nFrom-SVN: r22963", "tree": {"sha": "fa9bb28c5cf8b2b939742450c2f04b3f3738d4db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9bb28c5cf8b2b939742450c2f04b3f3738d4db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a/comments", "author": null, "committer": null, "parents": [{"sha": "d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d006aa54babb7e5c6074e06b71d6ae65e9172c5b"}], "stats": {"total": 967, "additions": 514, "deletions": 453}, "files": [{"sha": "49187ff1056baeb67b13227082d231842b149610", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "patch": "@@ -1,3 +1,17 @@\n+Fri Oct  9 15:57:51 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n+\n+\t* flow.c (life_analysis_1): Break out some functions.\n+\t(find_basic_blocks_1): Likewise.  Also move some variables out and\n+\tmake them static.\n+\tRename NONLOCAL_LABEL_LIST arg to NONLOCAL_LABELS and initialize\n+\tnew static var nonlocal_label_list with it.\n+\t(active_eh_region, nested_eh_region, label_value_list,\n+\tnonlocal_label_list): New static variables.\n+\t(make_edges, delete_unreachable_blocks, delete_block): New static\n+\tfunctions, broken out of find_basic_blocks_1.\n+\t(record_volatile_insns, mark_regs_live_at_end, set_noop_p,\n+\tnoop_move_p): New static functions, broken out of life_analysis_1.\n+\n Fri Oct  9 15:49:29 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* expmed.c (store_bit_field): Pun non-integral str_rtx modes."}, {"sha": "ce476e21f9e691a8bba90626acc5f2e17d4e2b66", "filename": "gcc/flow.c", "status": "modified", "additions": 500, "deletions": 453, "changes": 953, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=dc2ede84e6be8d3bac83fd0f3433c1ab71965d2a", "patch": "@@ -233,11 +233,6 @@ static char *basic_block_drops_in;\n \n static short *basic_block_loop_depth;\n \n-/* Element N nonzero if basic block N can actually be reached.\n-   Vector exists only during find_basic_blocks.  */\n-\n-static char *block_live_static;\n-\n /* Depth within loops of basic block being scanned for lifetime analysis,\n    plus one.  This is the weight attached to references to registers.  */\n \n@@ -259,11 +254,18 @@ static HARD_REG_SET elim_reg_set;\n \n /* Forward declarations */\n static void find_basic_blocks_1\t\tPROTO((rtx, rtx, int));\n+static void make_edges\t\t\tPROTO((int));\n static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n+static int delete_unreachable_blocks\tPROTO((void));\n+static int delete_block\t\t\tPROTO((int));\n static void life_analysis_1\t\tPROTO((rtx, int));\n static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n \t\t\t\t\t       regset, int));\n static rtx flow_delete_insn\t\tPROTO((rtx));\n+static int set_noop_p\t\t\tPROTO((rtx));\n+static int noop_move_p\t\t\tPROTO((rtx));\n+static void record_volatile_insns\tPROTO((rtx));\n+static void mark_regs_live_at_end\tPROTO((regset));\n static int insn_dead_p\t\t\tPROTO((rtx, regset, int));\n static int libcall_dead_p\t\tPROTO((rtx, regset, rtx, rtx));\n static void mark_set_regs\t\tPROTO((regset, regset, rtx,\n@@ -403,44 +405,55 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n   find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p);\n }\n \n+/* For communication between find_basic_blocks_1 and its subroutines.  */\n+\n+/* An array of CODE_LABELs, indexed by UID for the start of the active\n+   EH handler for each insn in F.  */\n+static int *active_eh_region;\n+static int *nested_eh_region;\n+\n+/* Element N nonzero if basic block N can actually be reached.  */\n+\n+static char *block_live_static;\n+\n+/* List of label_refs to all labels whose addresses are taken\n+   and used as data.  */\n+static rtx label_value_list;\n+\n+/* a list of non-local labels in the function.  */\n+static rtx nonlocal_label_list;\n+\n /* Find all basic blocks of the function whose first insn is F.\n    Store the correct data in the tables that describe the basic blocks,\n    set up the chains of references for each CODE_LABEL, and\n    delete any entire basic blocks that cannot be reached.\n \n-   NONLOCAL_LABEL_LIST is a list of non-local labels in the function.\n+   NONLOCAL_LABELS is a list of non-local labels in the function.\n    Blocks that are otherwise unreachable may be reachable with a non-local\n    goto.\n    LIVE_REACHABLE_P is non-zero if the caller needs all live blocks to\n    be reachable.  This turns on a kludge that causes the control flow\n    information to be inaccurate and not suitable for passes like GCSE.  */\n \n static void\n-find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n-     rtx f, nonlocal_label_list;\n+find_basic_blocks_1 (f, nonlocal_labels, live_reachable_p)\n+     rtx f, nonlocal_labels;\n      int live_reachable_p;\n {\n   register rtx insn;\n   register int i;\n   register char *block_live = (char *) alloca (n_basic_blocks);\n   register char *block_marked = (char *) alloca (n_basic_blocks);\n-  /* An array of CODE_LABELs, indexed by UID for the start of the active\n-     EH handler for each insn in F.  */\n-  int *active_eh_region;\n-  int *nested_eh_region;\n-  /* List of label_refs to all labels whose addresses are taken\n-     and used as data.  */\n-  rtx label_value_list;\n-  rtx x, note, eh_note;\n+  rtx note, eh_note;\n   enum rtx_code prev_code, code;\n   int depth, pass;\n   int in_libcall_block = 0;\n-  int deleted_handler = 0;\n   int call_had_abnormal_edge = 0;\n \n   pass = 1;\n   active_eh_region = (int *) alloca ((max_uid_for_flow + 1) * sizeof (int));\n   nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n+  nonlocal_label_list = nonlocal_labels;\n  restart:\n \n   label_value_list = 0;\n@@ -555,7 +568,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t       && (asynchronous_exceptions\n \t\t   || (GET_CODE (insn) == CALL_INSN\n \t\t       && ! in_libcall_block)))\n-\tactive_eh_region[INSN_UID (insn)] = \n+\tactive_eh_region[INSN_UID (insn)] =\n                                         NOTE_BLOCK_NUMBER (XEXP (eh_note, 0));\n       BLOCK_NUM (insn) = i;\n \n@@ -617,150 +630,8 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t      {\n \t\tblock_marked[i] = 1;\n \t\tsomething_marked = 1;\n-\t\tif (i + 1 < n_basic_blocks && basic_block_drops_in[i + 1])\n-\t\t  block_live[i + 1] = 1;\n-\t\tinsn = basic_block_end[i];\n-\t\tif (GET_CODE (insn) == JUMP_INSN)\n-\t\t  mark_label_ref (PATTERN (insn), insn, 0);\n-\n-\t\t/* If we have any forced labels, mark them as potentially\n-\t\t   reachable from this block.  */\n-\t\tfor (x = forced_labels; x; x = XEXP (x, 1))\n-\t\t  if (! LABEL_REF_NONLOCAL_P (x))\n-\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n-\t\t\t\t    insn, 0);\n \n-\t\t/* Now scan the insns for this block, we may need to make\n-\t\t   edges for some of them to various non-obvious locations\n-\t\t   (exception handlers, nonlocal labels, etc).  */\n-\t\tfor (insn = basic_block_head[i];\n-\t\t     insn != NEXT_INSN (basic_block_end[i]);\n-\t\t     insn = NEXT_INSN (insn))\n-\t\t  {\n-\t\t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t\t      {\n-\t\t\t/* References to labels in non-jumping insns have\n-\t\t\t   REG_LABEL notes attached to them.\n-\n-\t\t\t   This can happen for computed gotos; we don't care\n-\t\t\t   about them here since the values are also on the\n-\t\t\t   label_value_list and will be marked live if we find\n-\t\t\t   a live computed goto.\n-\n-\t\t\t   This can also happen when we take the address of\n-\t\t\t   a label to pass as an argument to __throw.  Note\n-\t\t\t   throw only uses the value to determine what handler\n-\t\t\t   should be called -- ie the label is not used as\n-\t\t\t   a jump target, it just marks regions in the code.\n-\n-\t\t\t   In theory we should be able to ignore the REG_LABEL\n-\t\t\t   notes, but we have to make sure that the label and\n-\t\t\t   associated insns aren't marked dead, so we make\n-\t\t\t   the block in question live and create an edge from\n-\t\t\t   this insn to the label.  This is not strictly\n-\t\t\t   correct, but it is close enough for now.  \n-\n-\t\t\t   See below for code that handles the eh_stub labels\n-\t\t\t   specially.  */\n-\t\t\tfor (note = REG_NOTES (insn);\n-\t\t\t     note;\n-\t\t\t     note = XEXP (note, 1))\n-\t\t\t  {\n-\t\t\t    if (REG_NOTE_KIND (note) == REG_LABEL\n-\t\t\t\t&& XEXP (note, 0) != eh_return_stub_label)\n-\t\t\t      {\n-\t\t\t\tx = XEXP (note, 0);\n-\t\t\t\tblock_live[BLOCK_NUM (x)] = 1;\n-\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode, x),\n-\t\t\t\t\t\tinsn, 0);\n-\t\t\t      }\n-\t\t\t  }\n-\n-\t\t\t/* If this is a computed jump, then mark it as\n-\t\t\t   reaching everything on the label_value_list\n-\t\t\t   and forced_labels list.  */\n-\t\t\tif (computed_jump_p (insn))\n-\t\t\t  {\n-\t\t\t    current_function_has_computed_jump = 1;\n-\t\t\t    for (x = label_value_list; x; x = XEXP (x, 1))\n-\t\t\t      {\n-\t\t\t\tint b = BLOCK_NUM (XEXP (x, 0));\n-\t\t\t\tbasic_block_computed_jump_target[b] = 1;\n-\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t   XEXP (x, 0)),\n-\t\t\t\t\t\tinsn, 0);\n-\t\t\t      }\n-\n-\t\t\t    for (x = forced_labels; x; x = XEXP (x, 1))\n-\t\t\t      {\n-\t\t\t\tint b = BLOCK_NUM (XEXP (x, 0));\n-\t\t\t\tbasic_block_computed_jump_target[b] = 1;\n-\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t   XEXP (x, 0)),\n-\t\t\t\t\t\tinsn, 0);\n-\t\t\t      }\n-\t\t\t  }\n-\n-\t\t\t/* If this is a CALL_INSN, then mark it as reaching\n-\t\t\t   the active EH handler for this CALL_INSN.  If\n-\t\t\t   we're handling asynchronous exceptions mark every\n-\t\t\t   insn as reaching the active EH handler.\n-\n-\t\t\t   Also mark the CALL_INSN as reaching any nonlocal\n-\t\t\t   goto sites.  */\n-\t\t\telse if (asynchronous_exceptions\n-\t\t\t\t || (GET_CODE (insn) == CALL_INSN\n-\t\t\t\t     && ! find_reg_note (insn, REG_RETVAL,\n-\t\t\t\t\t\t\t NULL_RTX)))\n-\t\t\t  {\n-\t\t\t    if (active_eh_region[INSN_UID (insn)]) \n-                              {\n-                                int region;\n-                                handler_info *ptr;\n-                                region = active_eh_region[INSN_UID (insn)];\n-                                for ( ; region; \n-                                             region = nested_eh_region[region]) \n-                                  {\n-                                    ptr = get_first_handler (region);\n-                                    for ( ; ptr ; ptr = ptr->next)\n-                                      mark_label_ref (gen_rtx_LABEL_REF \n-                                       (VOIDmode, ptr->handler_label), insn, 0);\n-                                  }\n-                              }\n-\t\t\t    if (!asynchronous_exceptions)\n-\t\t\t      {\n-\t\t\t\tfor (x = nonlocal_label_list;\n-\t\t\t\t     x;\n-\t\t\t\t     x = XEXP (x, 1))\n-\t\t\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t     XEXP (x, 0)),\n-\t\t\t\t\t\t  insn, 0);\n-\t\t\t      }\n-\t\t\t    /* ??? This could be made smarter:\n-\t\t\t       in some cases it's possible to tell that\n-\t\t\t       certain calls will not do a nonlocal goto.\n-\n-\t\t\t       For example, if the nested functions that\n-\t\t\t       do the nonlocal gotos do not have their\n-\t\t\t       addresses taken, then only calls to those\n-\t\t\t       functions or to other nested functions that\n-\t\t\t       use them could possibly do nonlocal gotos.  */\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\t\t/* We know something about the structure of the function\n-\t\t   __throw in libgcc2.c.  It is the only function that ever\n-\t\t   contains eh_stub labels.  It modifies its return address\n-\t\t   so that the last block returns to one of the eh_stub labels\n-\t\t   within it.  So we have to make additional edges in the\n-\t\t   flow graph.  */\n-\t\tif (i + 1 == n_basic_blocks\n-\t\t    && eh_return_stub_label != 0)\n-\t\t  {\n-\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t       eh_return_stub_label),\n-\t\t\t\t    basic_block_end[i], 0);\n-\t\t  }\n+\t\tmake_edges (i);\n \t      }\n \t}\n \n@@ -777,160 +648,7 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t    && LABEL_REFS (basic_block_head[i]) == basic_block_head[i])\n \t  abort ();\n \n-      /* Now delete the code for any basic blocks that can't be reached.\n-\t They can occur because jump_optimize does not recognize\n-\t unreachable loops as unreachable.  */\n-\n-      deleted = 0;\n-      for (i = 0; i < n_basic_blocks; i++)\n-\tif (!block_live[i])\n-\t  {\n-\t    deleted++;\n-\n-\t    /* Delete the insns in a (non-live) block.  We physically delete\n-\t       every non-note insn except the start and end (so\n-\t       basic_block_head/end needn't be updated), we turn the latter\n-\t       into NOTE_INSN_DELETED notes.\n-\t       We use to \"delete\" the insns by turning them into notes, but\n-\t       we may be deleting lots of insns that subsequent passes would\n-\t       otherwise have to process.  Secondly, lots of deleted blocks in\n-\t       a row can really slow down propagate_block since it will\n-\t       otherwise process insn-turned-notes multiple times when it\n-\t       looks for loop begin/end notes.  */\n-\t    if (basic_block_head[i] != basic_block_end[i])\n-\t      {\n-\t\t/* It would be quicker to delete all of these with a single\n-\t\t   unchaining, rather than one at a time, but we need to keep\n-\t\t   the NOTE's.  */\n-\t\tinsn = NEXT_INSN (basic_block_head[i]);\n-\t\twhile (insn != basic_block_end[i])\n-\t\t  {\n-\t\t    if (GET_CODE (insn) == BARRIER)\n-\t\t      abort ();\n-\t\t    else if (GET_CODE (insn) != NOTE)\n-\t\t      insn = flow_delete_insn (insn);\n-\t\t    else\n-\t\t      insn = NEXT_INSN (insn);\n-\t\t  }\n-\t      }\n-\t    insn = basic_block_head[i];\n-\t    if (GET_CODE (insn) != NOTE)\n-\t      {\n-\t\t/* Turn the head into a deleted insn note.  */\n-\t\tif (GET_CODE (insn) == BARRIER)\n-\t\t  abort ();\n-\n-\t\t/* If the head of this block is a CODE_LABEL, then it might\n-\t\t   be the label for an exception handler which can't be\n-\t\t   reached.\n-\n-\t\t   We need to remove the label from the exception_handler_label\n-\t\t   list and remove the associated NOTE_EH_REGION_BEG and\n-\t\t   NOTE_EH_REGION_END notes.  */\n-\t\tif (GET_CODE (insn) == CODE_LABEL)\n-\t\t  {\n-\t\t    rtx x, *prev = &exception_handler_labels;\n-\n-\t\t    for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-\t\t      {\n-\t\t\tif (XEXP (x, 0) == insn)\n-\t\t\t  {\n-\t\t\t    /* Found a match, splice this label out of the\n-\t\t\t       EH label list.  */\n-\t\t\t    *prev = XEXP (x, 1);\n-\t\t\t    XEXP (x, 1) = NULL_RTX;\n-\t\t\t    XEXP (x, 0) = NULL_RTX;\n-\n-                            /* Remove the handler from all regions */\n-                            remove_handler (insn);\n-                            deleted_handler = 1;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\tprev = &XEXP (x, 1);\n-\t\t      }\n-\t\t  }\n-\t\t \n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n-\t      }\n-\t    insn = basic_block_end[i];\n-\t    if (GET_CODE (insn) != NOTE)\n-\t      {\n-\t\t/* Turn the tail into a deleted insn note.  */\n-\t\tif (GET_CODE (insn) == BARRIER)\n-\t\t  abort ();\n-\t\tPUT_CODE (insn, NOTE);\n-\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\tNOTE_SOURCE_FILE (insn) = 0;\n-\t      }\n-\t    /* BARRIERs are between basic blocks, not part of one.\n-\t       Delete a BARRIER if the preceding jump is deleted.\n-\t       We cannot alter a BARRIER into a NOTE\n-\t       because it is too short; but we can really delete\n-\t       it because it is not part of a basic block.  */\n-\t    if (NEXT_INSN (insn) != 0\n-\t\t&& GET_CODE (NEXT_INSN (insn)) == BARRIER)\n-\t      delete_insn (NEXT_INSN (insn));\n-\n-\t    /* Each time we delete some basic blocks,\n-\t       see if there is a jump around them that is\n-\t       being turned into a no-op.  If so, delete it.  */\n-\n-\t    if (block_live[i - 1])\n-\t      {\n-\t\tregister int j;\n-\t\tfor (j = i + 1; j < n_basic_blocks; j++)\n-\t\t  if (block_live[j])\n-\t\t    {\n-\t\t      rtx label;\n-\t\t      insn = basic_block_end[i - 1];\n-\t\t      if (GET_CODE (insn) == JUMP_INSN\n-\t\t\t  /* An unconditional jump is the only possibility\n-\t\t\t     we must check for, since a conditional one\n-\t\t\t     would make these blocks live.  */\n-\t\t\t  && simplejump_p (insn)\n-\t\t\t  && (label = XEXP (SET_SRC (PATTERN (insn)), 0), 1)\n-\t\t\t  && INSN_UID (label) != 0\n-\t\t\t  && BLOCK_NUM (label) == j)\n-\t\t\t{\n-\t\t\t  int k;\n-\n-\t\t\t  /* The deleted blocks still show up in the cfg,\n-\t\t\t     so we must set basic_block_drops_in for blocks\n-\t\t\t     I to J inclusive to keep the cfg accurate.  */\n-\t\t\t  for (k = i; k <= j; k++)\n-\t\t\t    basic_block_drops_in[k] = 1;\n-\n-\t\t\t  PUT_CODE (insn, NOTE);\n-\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t\t  if (GET_CODE (NEXT_INSN (insn)) != BARRIER)\n-\t\t\t    abort ();\n-\t\t\t  delete_insn (NEXT_INSN (insn));\n-\t\t\t}\n-\t\t      break;\n-\t\t    }\n-\t      }\n-\t  }\n-      /* If we deleted an exception handler, we may have EH region\n-         begin/end blocks to remove as well. */\n-      if (deleted_handler)\n-        for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-          if (GET_CODE (insn) == NOTE)\n-            {\n-              if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n-                  (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n-                {\n-                  int num = CODE_LABEL_NUMBER (insn);\n-                  /* A NULL handler indicates a region is no longer needed */\n-                  if (get_first_handler (num) == NULL)\n-                    {\n-                      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-                      NOTE_SOURCE_FILE (insn) = 0;\n-                    }\n-                }\n-            }\n+      deleted = delete_unreachable_blocks ();\n \n       /* There are pathological cases where one function calling hundreds of\n \t nested inline functions can generate lots and lots of unreachable\n@@ -981,6 +699,144 @@ set_block_num (insn, bb)\n \f\n /* Subroutines of find_basic_blocks.  */\n \n+/* For basic block I, make edges and mark live all blocks which are reachable\n+   from it.  */\n+static void\n+make_edges (i)\n+     int i;\n+{\n+  rtx insn, x;\n+\n+  if (i + 1 < n_basic_blocks && basic_block_drops_in[i + 1])\n+    block_live_static[i + 1] = 1;\n+  insn = basic_block_end[i];\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    mark_label_ref (PATTERN (insn), insn, 0);\n+\n+  /* If we have any forced labels, mark them as potentially reachable from\n+     this block.  */\n+  for (x = forced_labels; x; x = XEXP (x, 1))\n+    if (! LABEL_REF_NONLOCAL_P (x))\n+      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n+\t\t      insn, 0);\n+\n+  /* Now scan the insns for this block, we may need to make edges for some of\n+     them to various non-obvious locations (exception handlers, nonlocal\n+     labels, etc).  */\n+  for (insn = basic_block_head[i];\n+       insn != NEXT_INSN (basic_block_end[i]);\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  rtx note;\n+\t  /* References to labels in non-jumping insns have REG_LABEL notes\n+\t     attached to them.\n+\n+\t     This can happen for computed gotos; we don't care about them\n+\t     here since the values are also on the label_value_list and will\n+\t     be marked live if we find a live computed goto.\n+\n+\t     This can also happen when we take the address of a label to pass\n+\t     as an argument to __throw.  Note throw only uses the value to\n+\t     determine what handler should be called -- ie the label is not\n+\t     used as a jump target, it just marks regions in the code.\n+\n+\t     In theory we should be able to ignore the REG_LABEL notes, but\n+\t     we have to make sure that the label and associated insns aren't\n+\t     marked dead, so we make the block in question live and create an\n+\t     edge from this insn to the label.  This is not strictly correct,\n+\t     but it is close enough for now.  \n+\n+\t     See below for code that handles the eh_stub label specially.  */\n+\t  for (note = REG_NOTES (insn);\n+\t       note;\n+\t       note = XEXP (note, 1))\n+\t    {\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL\n+\t\t  && XEXP (note, 0) != eh_return_stub_label)\n+\t\t{\n+\t\t  x = XEXP (note, 0);\n+\t\t  block_live_static[BLOCK_NUM (x)] = 1;\n+\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, x),\n+\t\t\t\t  insn, 0);\n+\t\t}\n+\t    }\n+\n+\t  /* If this is a computed jump, then mark it as reaching everything\n+\t     on the label_value_list and forced_labels list.  */\n+\t  if (computed_jump_p (insn))\n+\t    {\n+\t      current_function_has_computed_jump = 1;\n+\t      for (x = label_value_list; x; x = XEXP (x, 1))\n+\t\t{\n+\t\t  int b = BLOCK_NUM (XEXP (x, 0));\n+\t\t  basic_block_computed_jump_target[b] = 1;\n+\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n+\t\t\t\t  insn, 0);\n+\t\t}\n+\n+\t      for (x = forced_labels; x; x = XEXP (x, 1))\n+\t\t{\n+\t\t  int b = BLOCK_NUM (XEXP (x, 0));\n+\t\t  basic_block_computed_jump_target[b] = 1;\n+\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n+\t\t\t\t  insn, 0);\n+\t\t}\n+\t    }\n+\n+\t  /* If this is a CALL_INSN, then mark it as reaching the active EH\n+\t     handler for this CALL_INSN.  If we're handling asynchronous\n+\t     exceptions mark every insn as reaching the active EH handler.\n+\n+\t     Also mark the CALL_INSN as reaching any nonlocal goto sites.  */\n+\t  else if (asynchronous_exceptions\n+\t\t   || (GET_CODE (insn) == CALL_INSN\n+\t\t       && ! find_reg_note (insn, REG_RETVAL, NULL_RTX)))\n+\t    {\n+\t      if (active_eh_region[INSN_UID (insn)]) \n+\t\t{\n+\t\t  int region;\n+\t\t  handler_info *ptr;\n+\t\t  region = active_eh_region[INSN_UID (insn)];\n+\t\t  for ( ; region; \n+\t\t\tregion = nested_eh_region[region]) \n+\t\t    {\n+\t\t      ptr = get_first_handler (region);\n+\t\t      for ( ; ptr ; ptr = ptr->next)\n+\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t   ptr->handler_label),\n+\t\t\t\t\tinsn, 0);\n+\t\t    }\n+\t\t}\n+\t      if (! asynchronous_exceptions)\n+\t\t{\n+\t\t  for (x = nonlocal_label_list; x; x = XEXP (x, 1))\n+\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n+\t\t\t\t    insn, 0);\n+\t\t}\n+\t      /* ??? This could be made smarter: in some cases it's possible\n+\t\t to tell that certain calls will not do a nonlocal goto.\n+\n+\t\t For example, if the nested functions that do the nonlocal\n+\t\t gotos do not have their addresses taken, then only calls to\n+\t\t those functions or to other nested functions that use them\n+\t\t could possibly do nonlocal gotos.  */\n+\t    }\n+\t}\n+    }\n+  /* We know something about the structure of the function __throw in\n+     libgcc2.c.  It is the only function that ever contains eh_stub labels.\n+     It modifies its return address so that the last block returns to one of\n+     the eh_stub labels within it.  So we have to make additional edges in\n+     the flow graph.  */\n+  if (i + 1 == n_basic_blocks && eh_return_stub_label != 0)\n+    {\n+      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, eh_return_stub_label),\n+\t\t      basic_block_end[i], 0);\n+    }\n+}\n+\n /* Check expression X for label references;\n    if one is found, add INSN to the label's chain of references.\n \n@@ -1042,6 +898,185 @@ mark_label_ref (x, insn, checkdup)\n     }\n }\n \n+/* Now delete the code for any basic blocks that can't be reached.\n+   They can occur because jump_optimize does not recognize unreachable loops\n+   as unreachable.\n+   Return the number of deleted blocks.  */\n+static int\n+delete_unreachable_blocks ()\n+{\n+  int deleted_handler = 0;\n+  int deleted = 0;\n+  int i;\n+  rtx insn;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (! block_live_static[i])\n+      {\n+\tdeleted++;\n+\n+\tdeleted_handler |= delete_block (i);\n+      }\n+\n+  /* If we deleted an exception handler, we may have EH region\n+     begin/end blocks to remove as well. */\n+  if (deleted_handler)\n+    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  if ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n+\t      (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n+\t    {\n+\t      int num = CODE_LABEL_NUMBER (insn);\n+\t      /* A NULL handler indicates a region is no longer needed */\n+\t      if (get_first_handler (num) == NULL)\n+\t\t{\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t}\n+\t    }\n+\t}\n+  return deleted;\n+}\n+\n+/* Delete the insns in a (non-live) block.  We physically delete every\n+   non-note insn except the start and end (so basic_block_head/end needn't\n+   be updated), we turn the latter into NOTE_INSN_DELETED notes.\n+\n+   We use to \"delete\" the insns by turning them into notes, but we may be\n+   deleting lots of insns that subsequent passes would otherwise have to\n+   process.  Secondly, lots of deleted blocks in a row can really slow down\n+   propagate_block since it will otherwise process insn-turned-notes multiple\n+   times when it looks for loop begin/end notes.\n+\n+   Return nonzero if we deleted an exception handler.  */\n+static int\n+delete_block (i)\n+     int i;\n+{\n+  int deleted_handler = 0;\n+  rtx insn;\n+\n+  if (basic_block_head[i] != basic_block_end[i])\n+    {\n+      /* It would be quicker to delete all of these with a single\n+\t unchaining, rather than one at a time, but we need to keep\n+\t the NOTE's.  */\n+      insn = NEXT_INSN (basic_block_head[i]);\n+      while (insn != basic_block_end[i])\n+\t{\n+\t  if (GET_CODE (insn) == BARRIER)\n+\t    abort ();\n+\t  else if (GET_CODE (insn) != NOTE)\n+\t    insn = flow_delete_insn (insn);\n+\t  else\n+\t    insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  insn = basic_block_head[i];\n+  if (GET_CODE (insn) != NOTE)\n+    {\n+      /* Turn the head into a deleted insn note.  */\n+      if (GET_CODE (insn) == BARRIER)\n+\tabort ();\n+\n+      /* If the head of this block is a CODE_LABEL, then it might\n+\t be the label for an exception handler which can't be\n+\t reached.\n+\n+\t We need to remove the label from the exception_handler_label\n+\t list and remove the associated NOTE_EH_REGION_BEG and\n+\t NOTE_EH_REGION_END notes.  */\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  rtx x, *prev = &exception_handler_labels;\n+\n+\t  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+\t    {\n+\t      if (XEXP (x, 0) == insn)\n+\t\t{\n+\t\t  /* Found a match, splice this label out of the\n+\t\t     EH label list.  */\n+\t\t  *prev = XEXP (x, 1);\n+\t\t  XEXP (x, 1) = NULL_RTX;\n+\t\t  XEXP (x, 0) = NULL_RTX;\n+\n+\t\t  /* Remove the handler from all regions */\n+\t\t  remove_handler (insn);\n+\t\t  deleted_handler = 1;\n+\t\t  break;\n+\t\t}\n+\t      prev = &XEXP (x, 1);\n+\t    }\n+\t}\n+\t\t \n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n+    }\n+  insn = basic_block_end[i];\n+  if (GET_CODE (insn) != NOTE)\n+    {\n+      /* Turn the tail into a deleted insn note.  */\n+      if (GET_CODE (insn) == BARRIER)\n+\tabort ();\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      NOTE_SOURCE_FILE (insn) = 0;\n+    }\n+  /* BARRIERs are between basic blocks, not part of one.\n+     Delete a BARRIER if the preceding jump is deleted.\n+     We cannot alter a BARRIER into a NOTE\n+     because it is too short; but we can really delete\n+     it because it is not part of a basic block.  */\n+  if (NEXT_INSN (insn) != 0\n+      && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+    delete_insn (NEXT_INSN (insn));\n+\n+  /* Each time we delete some basic blocks,\n+     see if there is a jump around them that is\n+     being turned into a no-op.  If so, delete it.  */\n+\n+  if (block_live_static[i - 1])\n+    {\n+      register int j;\n+      for (j = i + 1; j < n_basic_blocks; j++)\n+\tif (block_live_static[j])\n+\t  {\n+\t    rtx label;\n+\t    insn = basic_block_end[i - 1];\n+\t    if (GET_CODE (insn) == JUMP_INSN\n+\t\t/* An unconditional jump is the only possibility\n+\t\t   we must check for, since a conditional one\n+\t\t   would make these blocks live.  */\n+\t\t&& simplejump_p (insn)\n+\t\t&& (label = XEXP (SET_SRC (PATTERN (insn)), 0), 1)\n+\t\t&& INSN_UID (label) != 0\n+\t\t&& BLOCK_NUM (label) == j)\n+\t      {\n+\t\tint k;\n+\n+\t\t/* The deleted blocks still show up in the cfg,\n+\t\t   so we must set basic_block_drops_in for blocks\n+\t\t   I to J inclusive to keep the cfg accurate.  */\n+\t\tfor (k = i; k <= j; k++)\n+\t\t  basic_block_drops_in[k] = 1;\n+\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t\tif (GET_CODE (NEXT_INSN (insn)) != BARRIER)\n+\t\t  abort ();\n+\t\tdelete_insn (NEXT_INSN (insn));\n+\t      }\n+\t    break;\n+\t  }\n+    }\n+\n+  return deleted_handler;\n+}\n+\n /* Delete INSN by patching it out.\n    Return the next insn.  */\n \n@@ -1130,6 +1165,151 @@ free_basic_block_vars (keep_head_end_p)\n     }\n }\n \n+/* Return nonzero if the destination of SET equals the source.  */\n+static int\n+set_noop_p (set)\n+     rtx set;\n+{\n+  rtx src = SET_SRC (set);\n+  rtx dst = SET_DEST (set);\n+  if (GET_CODE (src) == REG && GET_CODE (dst) == REG\n+      && REGNO (src) == REGNO (dst))\n+    return 1;\n+  if (GET_CODE (src) != SUBREG || GET_CODE (dst) != SUBREG\n+      || SUBREG_WORD (src) != SUBREG_WORD (dst))\n+    return 0;\n+  src = SUBREG_REG (src);\n+  dst = SUBREG_REG (dst);\n+  if (GET_CODE (src) == REG && GET_CODE (dst) == REG\n+      && REGNO (src) == REGNO (dst))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Return nonzero if an insn consists only of SETs, each of which only sets a\n+   value to itself.  */\n+static int\n+noop_move_p (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  /* Insns carrying these notes are useful later on.  */\n+  if (find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+    return 0;\n+\n+  if (GET_CODE (pat) == SET && set_noop_p (pat))\n+    return 1;\n+\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i;\n+      /* If nothing but SETs of registers to themselves,\n+\t this insn can also be deleted.  */\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx tem = XVECEXP (pat, 0, i);\n+\n+\t  if (GET_CODE (tem) == USE\n+\t      || GET_CODE (tem) == CLOBBER)\n+\t    continue;\n+\n+\t  if (GET_CODE (tem) != SET || ! set_noop_p (tem))\n+\t    return 0;\n+\t}\n+\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Record which insns refer to any volatile memory\n+   or for any reason can't be deleted just because they are dead stores.\n+   Also, delete any insns that copy a register to itself.  */\n+static void\n+record_volatile_insns (f)\n+     rtx f;\n+{\n+  rtx insn;\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      enum rtx_code code1 = GET_CODE (insn);\n+      if (code1 == CALL_INSN)\n+\tINSN_VOLATILE (insn) = 1;\n+      else if (code1 == INSN || code1 == JUMP_INSN)\n+\t{\n+\t  if (GET_CODE (PATTERN (insn)) != USE\n+\t      && volatile_refs_p (PATTERN (insn)))\n+\t    INSN_VOLATILE (insn) = 1;\n+\n+\t  /* A SET that makes space on the stack cannot be dead.\n+\t     (Such SETs occur only for allocating variable-size data,\n+\t     so they will always have a PLUS or MINUS according to the\n+\t     direction of stack growth.)\n+\t     Even if this function never uses this stack pointer value,\n+\t     signal handlers do!  */\n+\t  else if (code1 == INSN && GET_CODE (PATTERN (insn)) == SET\n+\t\t   && SET_DEST (PATTERN (insn)) == stack_pointer_rtx\n+#ifdef STACK_GROWS_DOWNWARD\n+\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == MINUS\n+#else\n+\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS\n+#endif\n+\t\t   && XEXP (SET_SRC (PATTERN (insn)), 0) == stack_pointer_rtx)\n+\t    INSN_VOLATILE (insn) = 1;\n+\n+\t  /* Delete (in effect) any obvious no-op moves.  */\n+\t  else if (noop_move_p (insn))\n+\t    {\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Mark those regs which are needed at the end of the function as live\n+   at the end of the last basic block.  */\n+static void\n+mark_regs_live_at_end (set)\n+     regset set;\n+{\n+  int i;\n+  \n+#ifdef EXIT_IGNORE_STACK\n+  if (! EXIT_IGNORE_STACK\n+      || (! FRAME_POINTER_REQUIRED\n+\t  && ! current_function_calls_alloca\n+\t  && flag_omit_frame_pointer))\n+#endif\n+    /* If exiting needs the right stack value,\n+       consider the stack pointer live at the end of the function.  */\n+    SET_REGNO_REG_SET (set, STACK_POINTER_REGNUM);\n+\n+  /* Mark the frame pointer is needed at the end of the function.  If\n+     we end up eliminating it, it will be removed from the live list\n+     of each basic block by reload.  */\n+\n+  SET_REGNO_REG_SET (set, FRAME_POINTER_REGNUM);\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+  /* If they are different, also mark the hard frame pointer as live */\n+  SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n+#endif      \n+\n+\n+  /* Mark all global registers and all registers used by the epilogue\n+     as being live at the end of the function since they may be\n+     referenced by our caller.  */\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (global_regs[i]\n+#ifdef EPILOGUE_USES\n+\t|| EPILOGUE_USES (i)\n+#endif\n+\t)\n+      SET_REGNO_REG_SET (set, i);\n+}\n+\n /* Determine which registers are live at the start of each\n    basic block of the function whose first insn is F.\n    NREGS is the number of registers used in F.\n@@ -1198,147 +1378,14 @@ life_analysis_1 (f, nregs)\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n   init_regset_vector (basic_block_significant, n_basic_blocks, &flow_obstack);\n \n-  /* Record which insns refer to any volatile memory\n-     or for any reason can't be deleted just because they are dead stores.\n-     Also, delete any insns that copy a register to itself.  */\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      enum rtx_code code1 = GET_CODE (insn);\n-      if (code1 == CALL_INSN)\n-\tINSN_VOLATILE (insn) = 1;\n-      else if (code1 == INSN || code1 == JUMP_INSN)\n-\t{\n-\t  /* Delete (in effect) any obvious no-op moves.  */\n-\t  if (GET_CODE (PATTERN (insn)) == SET\n-\t      && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n-\t      && GET_CODE (SET_SRC (PATTERN (insn))) == REG\n-\t      && (REGNO (SET_DEST (PATTERN (insn)))\n-\t\t  == REGNO (SET_SRC (PATTERN (insn))))\n-\t      /* Insns carrying these notes are useful later on.  */\n-\t      && ! find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t    }\n-\t  /* Delete (in effect) any obvious no-op moves.  */\n-\t  else if (GET_CODE (PATTERN (insn)) == SET\n-\t      && GET_CODE (SET_DEST (PATTERN (insn))) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (SET_DEST (PATTERN (insn)))) == REG\n-\t      && GET_CODE (SET_SRC (PATTERN (insn))) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (SET_SRC (PATTERN (insn)))) == REG\n-\t      && (REGNO (SUBREG_REG (SET_DEST (PATTERN (insn))))\n-\t\t  == REGNO (SUBREG_REG (SET_SRC (PATTERN (insn)))))\n-\t      && SUBREG_WORD (SET_DEST (PATTERN (insn))) ==\n-\t\t\t      SUBREG_WORD (SET_SRC (PATTERN (insn)))\n-\t      /* Insns carrying these notes are useful later on.  */\n-\t      && ! find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-\t    {\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t    }\n-\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t    {\n-\t      /* If nothing but SETs of registers to themselves,\n-\t\t this insn can also be deleted.  */\n-\t      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-\t\t{\n-\t\t  rtx tem = XVECEXP (PATTERN (insn), 0, i);\n-\n-\t\t  if (GET_CODE (tem) == USE\n-\t\t      || GET_CODE (tem) == CLOBBER)\n-\t\t    continue;\n-\t\t    \n-\t\t  if (GET_CODE (tem) != SET\n-\t\t      || GET_CODE (SET_DEST (tem)) != REG\n-\t\t      || GET_CODE (SET_SRC (tem)) != REG\n-\t\t      || REGNO (SET_DEST (tem)) != REGNO (SET_SRC (tem)))\n-\t\t    break;\n-\t\t}\n-\t\t\n-\t      if (i == XVECLEN (PATTERN (insn), 0)\n-\t\t  /* Insns carrying these notes are useful later on.  */\n-\t\t  && ! find_reg_note (insn, REG_EQUAL, NULL_RTX))\n-\t\t{\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n-\t\t}\n-\t      else\n-\t\tINSN_VOLATILE (insn) = volatile_refs_p (PATTERN (insn));\n-\t    }\n-\t  else if (GET_CODE (PATTERN (insn)) != USE)\n-\t    INSN_VOLATILE (insn) = volatile_refs_p (PATTERN (insn));\n-\t  /* A SET that makes space on the stack cannot be dead.\n-\t     (Such SETs occur only for allocating variable-size data,\n-\t     so they will always have a PLUS or MINUS according to the\n-\t     direction of stack growth.)\n-\t     Even if this function never uses this stack pointer value,\n-\t     signal handlers do!  */\n-\t  else if (code1 == INSN && GET_CODE (PATTERN (insn)) == SET\n-\t\t   && SET_DEST (PATTERN (insn)) == stack_pointer_rtx\n-#ifdef STACK_GROWS_DOWNWARD\n-\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == MINUS\n-#else\n-\t\t   && GET_CODE (SET_SRC (PATTERN (insn))) == PLUS\n-#endif\n-\t\t   && XEXP (SET_SRC (PATTERN (insn)), 0) == stack_pointer_rtx)\n-\t    INSN_VOLATILE (insn) = 1;\n-\t}\n-    }\n-\n-  if (n_basic_blocks > 0)\n-#ifdef EXIT_IGNORE_STACK\n-    if (! EXIT_IGNORE_STACK\n-\t|| (! FRAME_POINTER_REQUIRED\n-\t    && ! current_function_calls_alloca\n-\t    && flag_omit_frame_pointer))\n-#endif\n-      {\n-\t/* If exiting needs the right stack value,\n-\t   consider the stack pointer live at the end of the function.  */\n-\tSET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n-\t\t\t   STACK_POINTER_REGNUM);\n-\tSET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n-\t\t\t   STACK_POINTER_REGNUM);\n-      }\n-\n-  /* Mark the frame pointer is needed at the end of the function.  If\n-     we end up eliminating it, it will be removed from the live list\n-     of each basic block by reload.  */\n+  record_volatile_insns (f);\n \n   if (n_basic_blocks > 0)\n     {\n-      SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n-\t\t\t FRAME_POINTER_REGNUM);\n-      SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n-\t\t\t FRAME_POINTER_REGNUM);\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      /* If they are different, also mark the hard frame pointer as live */\n-      SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1],\n-\t\t\t HARD_FRAME_POINTER_REGNUM);\n-      SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n-\t\t\t HARD_FRAME_POINTER_REGNUM);\n-#endif      \n-      }\n-\n-  /* Mark all global registers and all registers used by the epilogue\n-     as being live at the end of the function since they may be\n-     referenced by our caller.  */\n-\n-  if (n_basic_blocks > 0)\n-    for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (global_regs[i]\n-#ifdef EPILOGUE_USES\n-\t  || EPILOGUE_USES (i)\n-#endif\n-\t  )\n-\t{\n-\t  SET_REGNO_REG_SET (basic_block_live_at_end[n_basic_blocks - 1], i);\n-\t  SET_REGNO_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1], i);\n-\t}\n+      mark_regs_live_at_end (basic_block_live_at_end[n_basic_blocks - 1]);\n+      COPY_REG_SET (basic_block_new_live_at_end[n_basic_blocks - 1],\n+\t\t    basic_block_live_at_end[n_basic_blocks - 1]);\n+    }\n \n   /* Propagate life info through the basic blocks\n      around the graph of basic blocks."}]}