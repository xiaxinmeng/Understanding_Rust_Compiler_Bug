{"sha": "f037632e655c8348b06ffa797c9b1041a5a823ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzNzYzMmU2NTVjODM0OGIwNmZmYTc5N2M5YjEwNDFhNWE4MjNlYw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-05-07T14:41:03Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-06T14:46:53Z"}, "message": "[Ada] Transient scope cleanup\n\ngcc/ada/\n\n\t* sem.ads (Node_To_Be_Wrapped): Minor comment fix.\n\t* exp_ch7.adb (Establish_Transient_Scope): Misc cleanups and\n\tcomment improvements.\n\t(Set_Node_To_Be_Wrapped): Remove -- not worth putting this code\n\tin a separate procedure, called only once.\n\t* sem_util.adb (Requires_Transient_Scope): Assert that our\n\tparameter has the right Kind. It probably shouldn't be E_Void,\n\tbut that is passed in in some cases.\n\t(Ensure_Minimum_Decoration): Move the call later, so we know Typ\n\tis Present, and remove \"if Present (Typ)\" from this procedure.\n\t* exp_aggr.adb (Convert_To_Assignments): Use membership test,\n\tand avoid the \"if False\" idiom.\n\t(Expand_Array_Aggregate): Remove a ??? comment.\n\t* sem_ch8.adb (Push_Scope): Take advantage of the full coverage\n\trules for aggregates.\n\t* sem_res.adb (Resolve_Declare_Expression): Remove test for\n\tIs_Type -- that's all it can be.  Use named notation in call to\n\tEstablish_Transient_Scope.\n\t* libgnat/a-cdlili.adb (Adjust): Remove redundant code.\n\t(Clear): Remove \"pragma Warnings (Off);\", which wasn't actually\n\tsuppressing any warnings.", "tree": {"sha": "db4781372c600674cf3ce742a34efa67d0140a71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db4781372c600674cf3ce742a34efa67d0140a71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f037632e655c8348b06ffa797c9b1041a5a823ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f037632e655c8348b06ffa797c9b1041a5a823ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f037632e655c8348b06ffa797c9b1041a5a823ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f037632e655c8348b06ffa797c9b1041a5a823ec/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5063691c19a20cd3abb1c3f686ca44bea04d889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5063691c19a20cd3abb1c3f686ca44bea04d889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5063691c19a20cd3abb1c3f686ca44bea04d889"}], "stats": {"total": 596, "additions": 287, "deletions": 309}, "files": [{"sha": "1b0843666058b87a2da0c7a07a58e0a35f63523c", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -4919,13 +4919,11 @@ package body Exp_Aggr is\n       --  Just set the Delay flag in the cases where the transformation will be\n       --  done top down from above.\n \n-      if False\n-\n+      if\n          --  Internal aggregate (transformed when expanding the parent)\n \n-         or else Parent_Kind = N_Aggregate\n-         or else Parent_Kind = N_Extension_Aggregate\n-         or else Parent_Kind = N_Component_Association\n+         Parent_Kind in\n+           N_Aggregate | N_Extension_Aggregate | N_Component_Association\n \n          --  Allocator (see Convert_Aggr_In_Allocator)\n \n@@ -6601,8 +6599,8 @@ package body Exp_Aggr is\n       --  For assignments we do the assignment in place if all the component\n       --  associations have compile-time known values, or are default-\n       --  initialized limited components, e.g. tasks. For other cases we\n-      --  create a temporary. The analysis for safety of on-line assignment\n-      --  is delicate, i.e. we don't know how to do it fully yet ???\n+      --  create a temporary. A full analysis for safety of in-place assignment\n+      --  is delicate.\n \n       --  For allocators we assign to the designated object in place if the\n       --  aggregate meets the same conditions as other in-place assignments."}, {"sha": "4c1e16d9e3206cecb7e28a7d6b068b17438cc066", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 230, "deletions": 244, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -131,11 +131,6 @@ package body Exp_Ch7 is\n    -- Transient Blocks and Finalization Management --\n    --------------------------------------------------\n \n-   function Find_Transient_Context (N : Node_Id) return Node_Id;\n-   --  Locate a suitable context for arbitrary node N which may need to be\n-   --  serviced by a transient scope. Return Empty if no suitable context is\n-   --  available.\n-\n    procedure Insert_Actions_In_Scope_Around\n      (N         : Node_Id;\n       Clean     : Boolean;\n@@ -155,9 +150,6 @@ package body Exp_Ch7 is\n    --  involves controlled objects or secondary stack usage, the corresponding\n    --  cleanup actions are performed at the end of the block.\n \n-   procedure Set_Node_To_Be_Wrapped (N : Node_Id);\n-   --  Set the field Node_To_Be_Wrapped of the current scope\n-\n    procedure Store_Actions_In_Scope (AK : Scope_Action_Kind; L : List_Id);\n    --  Shared processing for Store_xxx_Actions_In_Scope\n \n@@ -5151,37 +5143,47 @@ package body Exp_Ch7 is\n      (N                : Node_Id;\n       Manage_Sec_Stack : Boolean)\n    is\n-      procedure Create_Transient_Scope (Constr : Node_Id);\n-      --  Place a new scope on the scope stack in order to service construct\n-      --  Constr. The new scope may also manage the secondary stack.\n+      function Is_Package_Or_Subprogram (Id : Entity_Id) return Boolean;\n+      --  Determine whether arbitrary Id denotes a package or subprogram [body]\n+\n+      function Find_Enclosing_Transient_Scope return Entity_Id;\n+      --  Examine the scope stack looking for the nearest enclosing transient\n+      --  scope within the innermost enclosing package or subprogram. Return\n+      --  Empty if no such scope exists.\n+\n+      function Find_Transient_Context (N : Node_Id) return Node_Id;\n+      --  Locate a suitable context for arbitrary node N which may need to be\n+      --  serviced by a transient scope. Return Empty if no suitable context\n+      --  is available.\n \n       procedure Delegate_Sec_Stack_Management;\n       --  Move the management of the secondary stack to the nearest enclosing\n       --  suitable scope.\n \n-      function Find_Enclosing_Transient_Scope return Entity_Id;\n-      --  Examine the scope stack looking for the nearest enclosing transient\n-      --  scope. Return Empty if no such scope exists.\n-\n-      function Is_Package_Or_Subprogram (Id : Entity_Id) return Boolean;\n-      --  Determine whether arbitrary Id denotes a package or subprogram [body]\n+      procedure Create_Transient_Scope (Context : Node_Id);\n+      --  Place a new scope on the scope stack in order to service construct\n+      --  Context. Context is the node found by Find_Transient_Context. The\n+      --  new scope may also manage the secondary stack.\n \n       ----------------------------\n       -- Create_Transient_Scope --\n       ----------------------------\n \n-      procedure Create_Transient_Scope (Constr : Node_Id) is\n+      procedure Create_Transient_Scope (Context : Node_Id) is\n          Loc : constant Source_Ptr := Sloc (N);\n \n          Iter_Loop  : Entity_Id;\n-         Trans_Scop : Entity_Id;\n+         Trans_Scop : constant Entity_Id :=\n+           New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n \n       begin\n-         Trans_Scop := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n          Set_Etype (Trans_Scop, Standard_Void_Type);\n \n+         --  Push a new scope, and set its Node_To_Be_Wrapped and Is_Transient\n+         --  fields.\n+\n          Push_Scope (Trans_Scop);\n-         Set_Node_To_Be_Wrapped (Constr);\n+         Scope_Stack.Table (Scope_Stack.Last).Node_To_Be_Wrapped := Context;\n          Set_Scope_Is_Transient;\n \n          --  The transient scope must also manage the secondary stack\n@@ -5232,37 +5234,34 @@ package body Exp_Ch7 is\n       -----------------------------------\n \n       procedure Delegate_Sec_Stack_Management is\n-         Scop_Id  : Entity_Id;\n-         Scop_Rec : Scope_Stack_Entry;\n-\n       begin\n          for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n-            Scop_Rec := Scope_Stack.Table (Index);\n-            Scop_Id  := Scop_Rec.Entity;\n-\n-            --  Prevent the search from going too far or within the scope space\n-            --  of another unit.\n+            declare\n+               Scope : Scope_Stack_Entry renames Scope_Stack.Table (Index);\n+            begin\n+               --  Prevent the search from going too far or within the scope\n+               --  space of another unit.\n \n-            if Scop_Id = Standard_Standard then\n-               return;\n+               if Scope.Entity = Standard_Standard then\n+                  return;\n \n-            --  No transient scope should be encountered during the traversal\n-            --  because Establish_Transient_Scope should have already handled\n-            --  this case.\n+               --  No transient scope should be encountered during the\n+               --  traversal because Establish_Transient_Scope should have\n+               --  already handled this case.\n \n-            elsif Scop_Rec.Is_Transient then\n-               pragma Assert (False);\n-               return;\n+               elsif Scope.Is_Transient then\n+                  raise Program_Error;\n \n-            --  The construct which requires secondary stack management is\n-            --  always enclosed by a package or subprogram scope.\n+               --  The construct that requires secondary stack management is\n+               --  always enclosed by a package or subprogram scope.\n \n-            elsif Is_Package_Or_Subprogram (Scop_Id) then\n-               Set_Uses_Sec_Stack (Scop_Id);\n-               Check_Restriction (No_Secondary_Stack, N);\n+               elsif Is_Package_Or_Subprogram (Scope.Entity) then\n+                  Set_Uses_Sec_Stack (Scope.Entity);\n+                  Check_Restriction (No_Secondary_Stack, N);\n \n-               return;\n-            end if;\n+                  return;\n+               end if;\n+            end;\n          end loop;\n \n          --  At this point no suitable scope was found. This should never occur\n@@ -5277,30 +5276,198 @@ package body Exp_Ch7 is\n       ------------------------------------\n \n       function Find_Enclosing_Transient_Scope return Entity_Id is\n-         Scop_Id   : Entity_Id;\n-         Scop_Rec  : Scope_Stack_Entry;\n-\n       begin\n          for Index in reverse Scope_Stack.First .. Scope_Stack.Last loop\n-            Scop_Rec := Scope_Stack.Table (Index);\n-            Scop_Id  := Scop_Rec.Entity;\n-\n-            --  Prevent the search from going too far or within the scope space\n-            --  of another unit.\n+            declare\n+               Scope : Scope_Stack_Entry renames Scope_Stack.Table (Index);\n+            begin\n+               --  Prevent the search from going too far or within the scope\n+               --  space of another unit.\n \n-            if Scop_Id = Standard_Standard\n-              or else Is_Package_Or_Subprogram (Scop_Id)\n-            then\n-               exit;\n+               if Scope.Entity = Standard_Standard\n+                 or else Is_Package_Or_Subprogram (Scope.Entity)\n+               then\n+                  exit;\n \n-            elsif Scop_Rec.Is_Transient then\n-               return Scop_Id;\n-            end if;\n+               elsif Scope.Is_Transient then\n+                  return Scope.Entity;\n+               end if;\n+            end;\n          end loop;\n \n          return Empty;\n       end Find_Enclosing_Transient_Scope;\n \n+      ----------------------------\n+      -- Find_Transient_Context --\n+      ----------------------------\n+\n+      function Find_Transient_Context (N : Node_Id) return Node_Id is\n+         Curr : Node_Id := N;\n+         Prev : Node_Id := Empty;\n+\n+      begin\n+         while Present (Curr) loop\n+            case Nkind (Curr) is\n+\n+               --  Declarations\n+\n+               --  Declarations act as a boundary for a transient scope even if\n+               --  they are not wrapped, see Wrap_Transient_Declaration.\n+\n+               when N_Object_Declaration\n+                  | N_Object_Renaming_Declaration\n+                  | N_Subtype_Declaration\n+               =>\n+                  return Curr;\n+\n+               --  Statements\n+\n+               --  Statements and statement-like constructs act as a boundary\n+               --  for a transient scope.\n+\n+               when N_Accept_Alternative\n+                  | N_Attribute_Definition_Clause\n+                  | N_Case_Statement\n+                  | N_Case_Statement_Alternative\n+                  | N_Code_Statement\n+                  | N_Delay_Alternative\n+                  | N_Delay_Until_Statement\n+                  | N_Delay_Relative_Statement\n+                  | N_Discriminant_Association\n+                  | N_Elsif_Part\n+                  | N_Entry_Body_Formal_Part\n+                  | N_Exit_Statement\n+                  | N_If_Statement\n+                  | N_Iteration_Scheme\n+                  | N_Terminate_Alternative\n+               =>\n+                  pragma Assert (Present (Prev));\n+                  return Prev;\n+\n+               when N_Assignment_Statement =>\n+                  return Curr;\n+\n+               when N_Entry_Call_Statement\n+                  | N_Procedure_Call_Statement\n+               =>\n+                  --  When an entry or procedure call acts as the alternative\n+                  --  of a conditional or timed entry call, the proper context\n+                  --  is that of the alternative.\n+\n+                  if Nkind (Parent (Curr)) = N_Entry_Call_Alternative\n+                    and then Nkind (Parent (Parent (Curr))) in\n+                               N_Conditional_Entry_Call | N_Timed_Entry_Call\n+                  then\n+                     return Parent (Parent (Curr));\n+\n+                  --  General case for entry or procedure calls\n+\n+                  else\n+                     return Curr;\n+                  end if;\n+\n+               when N_Pragma =>\n+\n+                  --  Pragma Check is not a valid transient context in\n+                  --  GNATprove mode because the pragma must remain unchanged.\n+\n+                  if GNATprove_Mode\n+                    and then Get_Pragma_Id (Curr) = Pragma_Check\n+                  then\n+                     return Empty;\n+\n+                  --  General case for pragmas\n+\n+                  else\n+                     return Curr;\n+                  end if;\n+\n+               when N_Raise_Statement =>\n+                  return Curr;\n+\n+               when N_Simple_Return_Statement =>\n+\n+                  --  A return statement is not a valid transient context when\n+                  --  the function itself requires transient scope management\n+                  --  because the result will be reclaimed too early.\n+\n+                  if Requires_Transient_Scope (Etype\n+                       (Return_Applies_To (Return_Statement_Entity (Curr))))\n+                  then\n+                     return Empty;\n+\n+                  --  General case for return statements\n+\n+                  else\n+                     return Curr;\n+                  end if;\n+\n+               --  Special\n+\n+               when N_Attribute_Reference =>\n+                  if Is_Procedure_Attribute_Name (Attribute_Name (Curr)) then\n+                     return Curr;\n+                  end if;\n+\n+               --  An Ada 2012 iterator specification is not a valid context\n+               --  because Analyze_Iterator_Specification already employs\n+               --  special processing for it.\n+\n+               when N_Iterator_Specification =>\n+                  return Empty;\n+\n+               when N_Loop_Parameter_Specification =>\n+\n+                  --  An iteration scheme is not a valid context because\n+                  --  routine Analyze_Iteration_Scheme already employs\n+                  --  special processing.\n+\n+                  if Nkind (Parent (Curr)) = N_Iteration_Scheme then\n+                     return Empty;\n+                  else\n+                     return Parent (Curr);\n+                  end if;\n+\n+               --  Termination\n+\n+               --  The following nodes represent \"dummy contexts\" which do not\n+               --  need to be wrapped.\n+\n+               when N_Component_Declaration\n+                  | N_Discriminant_Specification\n+                  | N_Parameter_Specification\n+               =>\n+                  return Empty;\n+\n+               --  If the traversal leaves a scope without having been able to\n+               --  find a construct to wrap, something is going wrong, but this\n+               --  can happen in error situations that are not detected yet\n+               --  (such as a dynamic string in a pragma Export).\n+\n+               when N_Block_Statement\n+                  | N_Entry_Body\n+                  | N_Package_Body\n+                  | N_Package_Declaration\n+                  | N_Protected_Body\n+                  | N_Subprogram_Body\n+                  | N_Task_Body\n+               =>\n+                  return Empty;\n+\n+               --  Default\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            Prev := Curr;\n+            Curr := Parent (Curr);\n+         end loop;\n+\n+         return Empty;\n+      end Find_Transient_Context;\n+\n       ------------------------------\n       -- Is_Package_Or_Subprogram --\n       ------------------------------\n@@ -5323,8 +5490,8 @@ package body Exp_Ch7 is\n    --  Start of processing for Establish_Transient_Scope\n \n    begin\n-      --  Do not create a new transient scope if there is an existing transient\n-      --  scope on the stack.\n+      --  Do not create a new transient scope if there is already an enclosing\n+      --  transient scope within the innermost enclosing package or subprogram.\n \n       if Present (Trans_Id) then\n \n@@ -5338,9 +5505,8 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n-      --  At this point it is known that the scope stack is free of transient\n-      --  scopes. Locate the proper construct which must be serviced by a new\n-      --  transient scope.\n+      --  Find the construct that must be serviced by a new transient scope, if\n+      --  it exists.\n \n       Context := Find_Transient_Context (N);\n \n@@ -5950,177 +6116,6 @@ package body Exp_Ch7 is\n       end if;\n    end Expand_N_Package_Declaration;\n \n-   ----------------------------\n-   -- Find_Transient_Context --\n-   ----------------------------\n-\n-   function Find_Transient_Context (N : Node_Id) return Node_Id is\n-      Curr : Node_Id;\n-      Prev : Node_Id;\n-\n-   begin\n-      Curr := N;\n-      Prev := Empty;\n-      while Present (Curr) loop\n-         case Nkind (Curr) is\n-\n-            --  Declarations\n-\n-            --  Declarations act as a boundary for a transient scope even if\n-            --  they are not wrapped, see Wrap_Transient_Declaration.\n-\n-            when N_Object_Declaration\n-               | N_Object_Renaming_Declaration\n-               | N_Subtype_Declaration\n-            =>\n-               return Curr;\n-\n-            --  Statements\n-\n-            --  Statements and statement-like constructs act as a boundary for\n-            --  a transient scope.\n-\n-            when N_Accept_Alternative\n-               | N_Attribute_Definition_Clause\n-               | N_Case_Statement\n-               | N_Case_Statement_Alternative\n-               | N_Code_Statement\n-               | N_Delay_Alternative\n-               | N_Delay_Until_Statement\n-               | N_Delay_Relative_Statement\n-               | N_Discriminant_Association\n-               | N_Elsif_Part\n-               | N_Entry_Body_Formal_Part\n-               | N_Exit_Statement\n-               | N_If_Statement\n-               | N_Iteration_Scheme\n-               | N_Terminate_Alternative\n-            =>\n-               pragma Assert (Present (Prev));\n-               return Prev;\n-\n-            when N_Assignment_Statement =>\n-               return Curr;\n-\n-            when N_Entry_Call_Statement\n-               | N_Procedure_Call_Statement\n-            =>\n-               --  When an entry or procedure call acts as the alternative of a\n-               --  conditional or timed entry call, the proper context is that\n-               --  of the alternative.\n-\n-               if Nkind (Parent (Curr)) = N_Entry_Call_Alternative\n-                 and then Nkind (Parent (Parent (Curr))) in\n-                            N_Conditional_Entry_Call | N_Timed_Entry_Call\n-               then\n-                  return Parent (Parent (Curr));\n-\n-               --  General case for entry or procedure calls\n-\n-               else\n-                  return Curr;\n-               end if;\n-\n-            when N_Pragma =>\n-\n-               --  Pragma Check is not a valid transient context in GNATprove\n-               --  mode because the pragma must remain unchanged.\n-\n-               if GNATprove_Mode\n-                 and then Get_Pragma_Id (Curr) = Pragma_Check\n-               then\n-                  return Empty;\n-\n-               --  General case for pragmas\n-\n-               else\n-                  return Curr;\n-               end if;\n-\n-            when N_Raise_Statement =>\n-               return Curr;\n-\n-            when N_Simple_Return_Statement =>\n-\n-               --  A return statement is not a valid transient context when the\n-               --  function itself requires transient scope management because\n-               --  the result will be reclaimed too early.\n-\n-               if Requires_Transient_Scope (Etype\n-                    (Return_Applies_To (Return_Statement_Entity (Curr))))\n-               then\n-                  return Empty;\n-\n-               --  General case for return statements\n-\n-               else\n-                  return Curr;\n-               end if;\n-\n-            --  Special\n-\n-            when N_Attribute_Reference =>\n-               if Is_Procedure_Attribute_Name (Attribute_Name (Curr)) then\n-                  return Curr;\n-               end if;\n-\n-            --  An Ada 2012 iterator specification is not a valid context\n-            --  because Analyze_Iterator_Specification already employs special\n-            --  processing for it.\n-\n-            when N_Iterator_Specification =>\n-               return Empty;\n-\n-            when N_Loop_Parameter_Specification =>\n-\n-               --  An iteration scheme is not a valid context because routine\n-               --  Analyze_Iteration_Scheme already employs special processing.\n-\n-               if Nkind (Parent (Curr)) = N_Iteration_Scheme then\n-                  return Empty;\n-               else\n-                  return Parent (Curr);\n-               end if;\n-\n-            --  Termination\n-\n-            --  The following nodes represent \"dummy contexts\" which do not\n-            --  need to be wrapped.\n-\n-            when N_Component_Declaration\n-               | N_Discriminant_Specification\n-               | N_Parameter_Specification\n-            =>\n-               return Empty;\n-\n-            --  If the traversal leaves a scope without having been able to\n-            --  find a construct to wrap, something is going wrong, but this\n-            --  can happen in error situations that are not detected yet (such\n-            --  as a dynamic string in a pragma Export).\n-\n-            when N_Block_Statement\n-               | N_Entry_Body\n-               | N_Package_Body\n-               | N_Package_Declaration\n-               | N_Protected_Body\n-               | N_Subprogram_Body\n-               | N_Task_Body\n-            =>\n-               return Empty;\n-\n-            --  Default\n-\n-            when others =>\n-               null;\n-         end case;\n-\n-         Prev := Curr;\n-         Curr := Parent (Curr);\n-      end loop;\n-\n-      return Empty;\n-   end Find_Transient_Context;\n-\n    ---------------------------------\n    -- Has_Simple_Protected_Object --\n    ---------------------------------\n@@ -9890,15 +9885,6 @@ package body Exp_Ch7 is\n       return Scope_Stack.Table (Scope_Stack.Last).Node_To_Be_Wrapped;\n    end Node_To_Be_Wrapped;\n \n-   ----------------------------\n-   -- Set_Node_To_Be_Wrapped --\n-   ----------------------------\n-\n-   procedure Set_Node_To_Be_Wrapped (N : Node_Id) is\n-   begin\n-      Scope_Stack.Table (Scope_Stack.Last).Node_To_Be_Wrapped := N;\n-   end Set_Node_To_Be_Wrapped;\n-\n    ----------------------------\n    -- Store_Actions_In_Scope --\n    ----------------------------"}, {"sha": "75961a29ddb8954db2248f30d8cd8240a778afb3", "filename": "gcc/ada/libgnat/a-cdlili.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -130,11 +130,6 @@ is\n       pragma Assert (Container.Last.Next = null);\n       pragma Assert (Container.Length > 0);\n \n-      Container.First := null;\n-      Container.Last := null;\n-      Container.Length := 0;\n-      Zero_Counts (Container.TC);\n-\n       Container.First := new Node_Type'(Src.Element, null, null);\n       Container.Last := Container.First;\n       Container.Length := 1;\n@@ -232,9 +227,7 @@ is\n       Container.Last := null;\n       Container.Length := 0;\n \n-      pragma Warnings (Off);\n       Free (X);\n-      pragma Warnings (On);\n    end Clear;\n \n    ------------------------"}, {"sha": "2fdccf756a6d6fc861423e6b3e91ed825f54680a", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -533,7 +533,7 @@ package Sem is\n       --  See Sem_Ch10 (Install_Parents, Remove_Parents).\n \n       Node_To_Be_Wrapped : Node_Id;\n-      --  Only used in transient scopes. Records the node which will be wrapped\n+      --  Only used in transient scopes. Records the node that will be wrapped\n       --  by the transient block.\n \n       Actions_To_Be_Wrapped : Scope_Actions;"}, {"sha": "f056a189b2d7976c6f49b1d55e2d43cf0e492203", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -8995,6 +8995,28 @@ package body Sem_Ch8 is\n    procedure Push_Scope (S : Entity_Id) is\n       E : constant Entity_Id := Scope (S);\n \n+      function Component_Alignment_Default return Component_Alignment_Kind;\n+      --  Return Component_Alignment_Kind for the newly-pushed scope.\n+\n+      function Component_Alignment_Default return Component_Alignment_Kind is\n+      begin\n+         --  Each new scope pushed onto the scope stack inherits the component\n+         --  alignment of the previous scope. This emulates the \"visibility\"\n+         --  semantics of pragma Component_Alignment.\n+\n+         if Scope_Stack.Last > Scope_Stack.First then\n+            return Scope_Stack.Table\n+              (Scope_Stack.Last - 1).Component_Alignment_Default;\n+\n+         --  Otherwise, this is the first scope being pushed on the scope\n+         --  stack. Inherit the component alignment from the configuration\n+         --  form of pragma Component_Alignment (if any).\n+\n+         else\n+            return Configuration_Component_Alignment;\n+         end if;\n+      end Component_Alignment_Default;\n+\n    begin\n       if Ekind (S) = E_Void then\n          null;\n@@ -9023,49 +9045,27 @@ package body Sem_Ch8 is\n \n       Scope_Stack.Increment_Last;\n \n-      declare\n-         SST : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n-\n-      begin\n-         SST.Entity                        := S;\n-         SST.Save_Scope_Suppress           := Scope_Suppress;\n-         SST.Save_Local_Suppress_Stack_Top := Local_Suppress_Stack_Top;\n-         SST.Save_Check_Policy_List        := Check_Policy_List;\n-         SST.Save_Default_Storage_Pool     := Default_Pool;\n-         SST.Save_No_Tagged_Streams        := No_Tagged_Streams;\n-         SST.Save_SPARK_Mode               := SPARK_Mode;\n-         SST.Save_SPARK_Mode_Pragma        := SPARK_Mode_Pragma;\n-         SST.Save_Default_SSO              := Default_SSO;\n-         SST.Save_Uneval_Old               := Uneval_Old;\n-\n-         --  Each new scope pushed onto the scope stack inherits the component\n-         --  alignment of the previous scope. This emulates the \"visibility\"\n-         --  semantics of pragma Component_Alignment.\n-\n-         if Scope_Stack.Last > Scope_Stack.First then\n-            SST.Component_Alignment_Default :=\n-              Scope_Stack.Table\n-                (Scope_Stack.Last - 1).Component_Alignment_Default;\n-\n-         --  Otherwise, this is the first scope being pushed on the scope\n-         --  stack. Inherit the component alignment from the configuration\n-         --  form of pragma Component_Alignment (if any).\n-\n-         else\n-            SST.Component_Alignment_Default :=\n-              Configuration_Component_Alignment;\n-         end if;\n-\n-         SST.Last_Subprogram_Name           := null;\n-         SST.Is_Transient                   := False;\n-         SST.Node_To_Be_Wrapped             := Empty;\n-         SST.Pending_Freeze_Actions         := No_List;\n-         SST.Actions_To_Be_Wrapped          := (others => No_List);\n-         SST.First_Use_Clause               := Empty;\n-         SST.Is_Active_Stack_Base           := False;\n-         SST.Previous_Visibility            := False;\n-         SST.Locked_Shared_Objects          := No_Elist;\n-      end;\n+      Scope_Stack.Table (Scope_Stack.Last) :=\n+        (Entity                        => S,\n+         Save_Scope_Suppress           => Scope_Suppress,\n+         Save_Local_Suppress_Stack_Top => Local_Suppress_Stack_Top,\n+         Save_Check_Policy_List        => Check_Policy_List,\n+         Save_Default_Storage_Pool     => Default_Pool,\n+         Save_No_Tagged_Streams        => No_Tagged_Streams,\n+         Save_SPARK_Mode               => SPARK_Mode,\n+         Save_SPARK_Mode_Pragma        => SPARK_Mode_Pragma,\n+         Save_Default_SSO              => Default_SSO,\n+         Save_Uneval_Old               => Uneval_Old,\n+         Component_Alignment_Default   => Component_Alignment_Default,\n+         Last_Subprogram_Name          => null,\n+         Is_Transient                  => False,\n+         Node_To_Be_Wrapped            => Empty,\n+         Pending_Freeze_Actions        => No_List,\n+         Actions_To_Be_Wrapped         => (others => No_List),\n+         First_Use_Clause              => Empty,\n+         Is_Active_Stack_Base          => False,\n+         Previous_Visibility           => False,\n+         Locked_Shared_Objects         => No_Elist);\n \n       if Debug_Flag_W then\n          Write_Str (\"--> new scope: \");"}, {"sha": "3ebf93ae080a772a5eb2fe9915b80585349c3f90", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -7521,7 +7521,6 @@ package body Sem_Res is\n             Node := First (Actions (N));\n             while Present (Node) loop\n                if Nkind (Node) = N_Object_Declaration\n-                 and then Is_Type (Etype (Defining_Identifier (Node)))\n                  and then Requires_Transient_Scope\n                             (Etype (Defining_Identifier (Node)))\n                then\n@@ -7534,7 +7533,7 @@ package body Sem_Res is\n          end;\n \n          if Need_Transient_Scope then\n-            Establish_Transient_Scope (Decl, True);\n+            Establish_Transient_Scope (Decl, Manage_Sec_Stack => True);\n          else\n             Push_Scope (Scope (Defining_Identifier (Decl)));\n          end if;"}, {"sha": "5c6a70134af2a9ed6c2d71dcf0e085b1543af45e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f037632e655c8348b06ffa797c9b1041a5a823ec/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f037632e655c8348b06ffa797c9b1041a5a823ec", "patch": "@@ -26956,6 +26956,8 @@ package body Sem_Util is\n    --  generated before the next instruction.\n \n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n+      pragma Assert (if Present (Id) then Ekind (Id) in E_Void | Type_Kind);\n+\n       function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n       --  This is called for untagged records and protected types, with\n       --  nondefaulted discriminants. Returns True if the size of function\n@@ -27036,8 +27038,7 @@ package body Sem_Util is\n          --  Do not set Has_Controlled_Component on a class-wide equivalent\n          --  type. See Make_CW_Equivalent_Type.\n \n-         if Present (Typ)\n-           and then not Is_Frozen (Typ)\n+         if not Is_Frozen (Typ)\n            and then Is_Base_Type (Typ)\n            and then (Is_Record_Type (Typ)\n                        or else Is_Concurrent_Type (Typ)\n@@ -27154,19 +27155,20 @@ package body Sem_Util is\n    --  Start of processing for Requires_Transient_Scope\n \n    begin\n-      Ensure_Minimum_Decoration (Id);\n-\n       --  This is a private type which is not completed yet. This can only\n       --  happen in a default expression (of a formal parameter or of a\n       --  record component). Do not expand transient scope in this case.\n \n       if No (Typ) then\n          return False;\n+      end if;\n+\n+      Ensure_Minimum_Decoration (Id);\n \n       --  Do not expand transient scope for non-existent procedure return or\n       --  string literal types.\n \n-      elsif Typ = Standard_Void_Type\n+      if Typ = Standard_Void_Type\n         or else Ekind (Typ) = E_String_Literal_Subtype\n       then\n          return False;"}]}