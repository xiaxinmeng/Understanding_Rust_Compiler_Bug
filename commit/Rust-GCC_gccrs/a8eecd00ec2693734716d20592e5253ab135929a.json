{"sha": "a8eecd00ec2693734716d20592e5253ab135929a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlZWNkMDBlYzI2OTM3MzQ3MTZkMjA1OTJlNTI1M2FiMTM1OTI5YQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-05-16T09:16:23Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-05-16T09:16:23Z"}, "message": "[AArch64 costs 14/18] Cost comparisons, flag setting operators and IF_THEN_ELSE\n\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Cost comparison\n\toperators.\n\n\nCo-Authored-By: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\n\nFrom-SVN: r210506", "tree": {"sha": "139785b2f2b70b527d8178de13ce576137d290e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/139785b2f2b70b527d8178de13ce576137d290e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8eecd00ec2693734716d20592e5253ab135929a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8eecd00ec2693734716d20592e5253ab135929a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8eecd00ec2693734716d20592e5253ab135929a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8eecd00ec2693734716d20592e5253ab135929a/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4105fe38857a36b4e604d98a7bbc888225bf187f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4105fe38857a36b4e604d98a7bbc888225bf187f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4105fe38857a36b4e604d98a7bbc888225bf187f"}], "stats": {"total": 165, "additions": 154, "deletions": 11}, "files": [{"sha": "86a70cd950f98d5b28e88794092616b5ad748c34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8eecd00ec2693734716d20592e5253ab135929a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8eecd00ec2693734716d20592e5253ab135929a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8eecd00ec2693734716d20592e5253ab135929a", "patch": "@@ -1,3 +1,9 @@\n+2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n+\t    Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Cost comparison\n+\toperators.\n+\n 2014-05-16  James Greenhalgh  <james.greenhalgh@arm.com>\n \t    Philipp Tomsich  <philipp.tomsich@theobroma-systems.com>\n "}, {"sha": "8d863ed9ec79c8077704e519cfee6dcde3002408", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 148, "deletions": 11, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8eecd00ec2693734716d20592e5253ab135929a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8eecd00ec2693734716d20592e5253ab135929a/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a8eecd00ec2693734716d20592e5253ab135929a", "patch": "@@ -4868,7 +4868,7 @@ static bool\n aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t\t   int param ATTRIBUTE_UNUSED, int *cost, bool speed)\n {\n-  rtx op0, op1;\n+  rtx op0, op1, op2;\n   const struct cpu_cost_table *extra_cost\n     = aarch64_tune_params->insn_extra_cost;\n   enum machine_mode mode = GET_MODE (x);\n@@ -5093,16 +5093,77 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t  goto cost_logic;\n \t}\n \n-      /* Comparisons can work if the order is swapped.\n-\t Canonicalization puts the more complex operation first, but\n-\t we want it in op1.  */\n-      if (! (REG_P (op0)\n-\t     || (GET_CODE (op0) == SUBREG && REG_P (SUBREG_REG (op0)))))\n-\t{\n-\t  op0 = XEXP (x, 1);\n-\t  op1 = XEXP (x, 0);\n-\t}\n-      goto cost_minus;\n+      if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n+        {\n+          /* TODO: A write to the CC flags possibly costs extra, this\n+\t     needs encoding in the cost tables.  */\n+\n+          /* CC_ZESWPmode supports zero extend for free.  */\n+          if (GET_MODE (x) == CC_ZESWPmode && GET_CODE (op0) == ZERO_EXTEND)\n+            op0 = XEXP (op0, 0);\n+\n+          /* ANDS.  */\n+          if (GET_CODE (op0) == AND)\n+            {\n+              x = op0;\n+              goto cost_logic;\n+            }\n+\n+          if (GET_CODE (op0) == PLUS)\n+            {\n+\t      /* ADDS (and CMN alias).  */\n+              x = op0;\n+              goto cost_plus;\n+            }\n+\n+          if (GET_CODE (op0) == MINUS)\n+            {\n+\t      /* SUBS.  */\n+              x = op0;\n+              goto cost_minus;\n+            }\n+\n+          if (GET_CODE (op1) == NEG)\n+            {\n+\t      /* CMN.  */\n+\t      if (speed)\n+\t\t*cost += extra_cost->alu.arith;\n+\n+              *cost += rtx_cost (op0, COMPARE, 0, speed);\n+\t      *cost += rtx_cost (XEXP (op1, 0), NEG, 1, speed);\n+              return true;\n+            }\n+\n+          /* CMP.\n+\n+\t     Compare can freely swap the order of operands, and\n+             canonicalization puts the more complex operation first.\n+             But the integer MINUS logic expects the shift/extend\n+             operation in op1.  */\n+          if (! (REG_P (op0)\n+                 || (GET_CODE (op0) == SUBREG && REG_P (SUBREG_REG (op0)))))\n+          {\n+            op0 = XEXP (x, 1);\n+            op1 = XEXP (x, 0);\n+          }\n+          goto cost_minus;\n+        }\n+\n+      if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+        {\n+\t  /* FCMP.  */\n+\t  if (speed)\n+\t    *cost += extra_cost->fp[mode == DFmode].compare;\n+\n+          if (CONST_DOUBLE_P (op1) && aarch64_float_const_zero_rtx_p (op1))\n+            {\n+              /* FCMP supports constant 0.0 for no extra cost. */\n+              return true;\n+            }\n+          return false;\n+        }\n+\n+      return false;\n \n     case MINUS:\n       {\n@@ -5173,6 +5234,7 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \top0 = XEXP (x, 0);\n \top1 = XEXP (x, 1);\n \n+cost_plus:\n \tif (GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMPARE\n \t    || GET_RTX_CLASS (GET_CODE (op0)) == RTX_COMM_COMPARE)\n \t  {\n@@ -5504,6 +5566,81 @@ aarch64_rtx_costs (rtx x, int code, int outer ATTRIBUTE_UNUSED,\n \t}\n       return false;  /* All arguments need to be in registers.  */\n \n+    case IF_THEN_ELSE:\n+      op2 = XEXP (x, 2);\n+      op0 = XEXP (x, 0);\n+      op1 = XEXP (x, 1);\n+\n+      if (GET_CODE (op1) == PC || GET_CODE (op2) == PC)\n+        {\n+          /* Conditional branch.  */\n+          if (GET_MODE_CLASS (GET_MODE (XEXP (op0, 0))) == MODE_CC)\n+\t    return true;\n+\t  else\n+\t    {\n+\t      if (GET_CODE (op0) == NE\n+\t\t  || GET_CODE (op0) == EQ)\n+\t\t{\n+\t\t  rtx inner = XEXP (op0, 0);\n+\t\t  rtx comparator = XEXP (op0, 1);\n+\n+\t\t  if (comparator == const0_rtx)\n+\t\t    {\n+\t\t      /* TBZ/TBNZ/CBZ/CBNZ.  */\n+\t\t      if (GET_CODE (inner) == ZERO_EXTRACT)\n+\t\t\t/* TBZ/TBNZ.  */\n+\t\t\t*cost += rtx_cost (XEXP (inner, 0), ZERO_EXTRACT,\n+\t\t\t\t\t   0, speed);\n+\t\t      else\n+\t\t\t/* CBZ/CBNZ.  */\n+\t\t\t*cost += rtx_cost (inner, GET_CODE (op0), 0, speed);\n+\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t      else if (GET_CODE (op0) == LT\n+\t\t       || GET_CODE (op0) == GE)\n+\t\t{\n+\t\t  rtx comparator = XEXP (op0, 1);\n+\n+\t\t  /* TBZ/TBNZ.  */\n+\t\t  if (comparator == const0_rtx)\n+\t\t    return true;\n+\t\t}\n+\t    }\n+        }\n+      else if (GET_MODE_CLASS (GET_MODE (XEXP (op0, 0))) == MODE_CC)\n+        {\n+          /* It's a conditional operation based on the status flags,\n+             so it must be some flavor of CSEL.  */\n+\n+          /* CSNEG, CSINV, and CSINC are handled for free as part of CSEL.  */\n+          if (GET_CODE (op1) == NEG\n+              || GET_CODE (op1) == NOT\n+              || (GET_CODE (op1) == PLUS && XEXP (op1, 1) == const1_rtx))\n+            op1 = XEXP (op1, 0);\n+\n+          *cost += rtx_cost (op1, IF_THEN_ELSE, 1, speed);\n+          *cost += rtx_cost (op2, IF_THEN_ELSE, 2, speed);\n+          return true;\n+        }\n+\n+      /* We don't know what this is, cost all operands.  */\n+      return false;\n+\n+    case EQ:\n+    case NE:\n+    case GT:\n+    case GTU:\n+    case LT:\n+    case LTU:\n+    case GE:\n+    case GEU:\n+    case LE:\n+    case LEU:\n+\n+      return false; /* All arguments must be in registers.  */\n+\n     default:\n       break;\n     }"}]}