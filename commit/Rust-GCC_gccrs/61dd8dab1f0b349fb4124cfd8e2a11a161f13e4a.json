{"sha": "61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFkZDhkYWIxZjBiMzQ5ZmI0MTI0Y2ZkOGUyYTExYTE2MWYxM2U0YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-10T09:26:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-10T11:11:34Z"}, "message": "Fix wrong code for boolean negation in condition at -O2\n\nThe problem is the bitwise/logical dichotomy for operators and the\ntransition from the former to the latter for boolean types: if they\nare 1-bit, that's straightforward but, if they are larger, then you\nneed to be careful because you cannot, on the one hand, turn a bitwise\nAND into a logical AND and, on the other hand, *not* turn e.g. a\nbitwise NOT into a logical NOT if they occur in the same computation,\nas the first change will drop the masking that may need to be applied\nafter the bitwise NOT if it is not also changed.\n\nGiven that the ranger turns bitwise AND/OR into logical AND/OR for\nbooleans,  the patch does the same for bitwise NOT.\n\ngcc/ChangeLog:\n\t* range-op.cc (operator_logical_not::fold_range): Tidy up.\n\t(operator_logical_not::op1_range): Call above method.\n\t(operator_bitwise_not::fold_range): If the type is compatible\n\twith boolean, call op_logical_not.fold_range.\n\t(operator_bitwise_not::op1_range): If the type is compatible\n\twith boolean, call op_logical_not.op1_range.\n\ngcc/testsuite/ChangeLog:\n\t* gnat.dg/opt88.adb: New test.", "tree": {"sha": "1347f21e992fa9cb9a58d151204f5a0b5ed12968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1347f21e992fa9cb9a58d151204f5a0b5ed12968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a/comments", "author": null, "committer": null, "parents": [{"sha": "15e5f41a1c88fce773cd9d13fe02052ace1803ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e5f41a1c88fce773cd9d13fe02052ace1803ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e5f41a1c88fce773cd9d13fe02052ace1803ce"}], "stats": {"total": 80, "additions": 66, "deletions": 14}, "files": [{"sha": "aff9383d936507a123f514038548f5cc84d92f6c", "filename": "gcc/range-op.cc", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "patch": "@@ -2706,27 +2706,21 @@ operator_logical_not::fold_range (irange &r, tree type,\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n \n-  if (lh.varying_p () || lh.undefined_p ())\n-    r = lh;\n-  else\n-    {\n-      r = lh;\n-      r.invert ();\n-    }\n-  gcc_checking_assert (lh.type() == type);\n+  r = lh;\n+  if (!lh.varying_p () && !lh.undefined_p ())\n+    r.invert ();\n+\n   return true;\n }\n \n bool\n operator_logical_not::op1_range (irange &r,\n-\t\t\t\t tree type ATTRIBUTE_UNUSED,\n+\t\t\t\t tree type,\n \t\t\t\t const irange &lhs,\n-\t\t\t\t const irange &op2 ATTRIBUTE_UNUSED) const\n+\t\t\t\t const irange &op2) const\n {\n-  r = lhs;\n-  if (!lhs.varying_p () && !lhs.undefined_p ())\n-    r.invert ();\n-  return true;\n+  // Logical NOT is involutary...do it again.\n+  return fold_range (r, type, lhs, op2);\n }\n \n \n@@ -2749,6 +2743,9 @@ operator_bitwise_not::fold_range (irange &r, tree type,\n   if (empty_range_varying (r, type, lh, rh))\n     return true;\n \n+  if (types_compatible_p (type, boolean_type_node))\n+    return op_logical_not.fold_range (r, type, lh, rh);\n+\n   // ~X is simply -1 - X.\n   int_range<1> minusone (type, wi::minus_one (TYPE_PRECISION (type)),\n \t\t\t wi::minus_one (TYPE_PRECISION (type)));\n@@ -2761,6 +2758,9 @@ operator_bitwise_not::op1_range (irange &r, tree type,\n \t\t\t\t const irange &lhs,\n \t\t\t\t const irange &op2) const\n {\n+  if (types_compatible_p (type, boolean_type_node))\n+    return op_logical_not.op1_range (r, type, lhs, op2);\n+\n   // ~X is -1 - X and since bitwise NOT is involutary...do it again.\n   return fold_range (r, type, lhs, op2);\n }"}, {"sha": "a6abd018611501fb36e49791c0eca1760b0f0b8d", "filename": "gcc/testsuite/gnat.dg/opt88.adb", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt88.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a/gcc%2Ftestsuite%2Fgnat.dg%2Fopt88.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt88.adb?ref=61dd8dab1f0b349fb4124cfd8e2a11a161f13e4a", "patch": "@@ -0,0 +1,52 @@\n+-- { dg-do run }\n+-- { dg-options \"-O -ftree-vrp -fno-inline\" }\n+\n+procedure Opt88 is\n+\n+  Val : Integer := 1;\n+\n+  procedure Dummy (B : out Boolean) is\n+  begin\n+    B := True;\n+  end;\n+\n+  function Test return Boolean is\n+  begin\n+    return False;\n+  end;\n+\n+  procedure Do_It (OK : out Boolean) is\n+\n+    Blue : Boolean := False;\n+    Red  : Boolean := False;\n+\n+  begin\n+    OK := True;\n+    Blue := True;\n+    Dummy (Red);\n+\n+    if Red then\n+      Red := False;\n+\n+      if Test then\n+        Dummy (Red);\n+      end if;\n+    end if;\n+\n+    if Blue and not Red then\n+      Val := 0;\n+    end if;\n+\n+    if Red then\n+      OK := False;\n+    end if;\n+  end;\n+\n+  OK : Boolean;\n+\n+begin\n+  Do_It (OK);\n+  if not OK then\n+    raise Program_Error;\n+  end if;\n+end;"}]}