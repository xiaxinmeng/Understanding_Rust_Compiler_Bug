{"sha": "2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjMTUzNWQ5NzNiY2FhMWExZjdkODYzNTJiYzlkOGNlZTYwZGEwOQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-11-12T16:36:43Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-12T16:36:43Z"}, "message": "flow.c (find_basic_blocks): Refine further to get a more correct cfg...\n\n        * flow.c (find_basic_blocks): Refine further to get a more correct\n        cfg, especially in the presense of exception handling, computed\n        gotos, and other non-trivial cases.  Call abort if an inaccuracy\n        is detected in the cfg.\n\nFrom-SVN: r16440", "tree": {"sha": "e63ed6dbc6ff5b90d2f205f77384847d870cef90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e63ed6dbc6ff5b90d2f205f77384847d870cef90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09/comments", "author": null, "committer": null, "parents": [{"sha": "6d2b1beeacc0c181091e7881b6c708ff33d2040b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2b1beeacc0c181091e7881b6c708ff33d2040b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d2b1beeacc0c181091e7881b6c708ff33d2040b"}], "stats": {"total": 278, "additions": 157, "deletions": 121}, "files": [{"sha": "036b7614b8dabc1cfac8f7a5e7498565a87a1774", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "patch": "@@ -1,3 +1,10 @@\n+Wed Nov 12 09:37:01 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* flow.c (find_basic_blocks): Refine further to get a more correct\n+\tcfg, especially in the presense of exception handling, computed\n+\tgotos, and other non-trivial cases.  Call abort if an inaccuracy\n+\tis detected in the cfg.\n+\n Tue Nov 11 21:47:27 1997  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* glimits.h (SHRT_MIN): Define in a way suitable for 16 bit hosts."}, {"sha": "d5e777bcee50c3be9d74801f9cd442d7573a9bc8", "filename": "gcc/flow.c", "status": "modified", "additions": 150, "deletions": 121, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "patch": "@@ -372,22 +372,28 @@ find_basic_blocks (f, nonlocal_label_list)\n   register int i;\n   register char *block_live = (char *) alloca (n_basic_blocks);\n   register char *block_marked = (char *) alloca (n_basic_blocks);\n+  /* An array of CODE_LABELs, indexed by UID for the start of the active\n+     EH handler for each insn in F.  */\n+  rtx *active_eh_handler;\n   /* List of label_refs to all labels whose addresses are taken\n      and used as data.  */\n   rtx label_value_list;\n-  int label_value_list_marked_live;\n-  rtx x, note;\n+  /* List of label_refs from REG_LABEL notes.  */\n+  rtx reg_label_list;\n+  rtx x, note, eh_note;\n   enum rtx_code prev_code, code;\n   int depth, pass;\n \n   pass = 1;\n+  active_eh_handler = (rtx *) alloca ((max_uid_for_flow + 1) * sizeof (rtx));\n  restart:\n \n   label_value_list = 0;\n-  label_value_list_marked_live = 0;\n+  reg_label_list = 0;\n   block_live_static = block_live;\n   bzero (block_live, n_basic_blocks);\n   bzero (block_marked, n_basic_blocks);\n+  bzero (active_eh_handler, (max_uid_for_flow + 1) * sizeof (rtx));\n \n   /* Initialize with just block 0 reachable and no blocks marked.  */\n   if (n_basic_blocks > 0)\n@@ -398,7 +404,7 @@ find_basic_blocks (f, nonlocal_label_list)\n      the block it is in.   Also mark as reachable any blocks headed by labels\n      that must not be deleted.  */\n \n-  for (insn = f, i = -1, prev_code = JUMP_INSN, depth = 1;\n+  for (eh_note = NULL_RTX, insn = f, i = -1, prev_code = JUMP_INSN, depth = 1;\n        insn; insn = NEXT_INSN (insn))\n     {\n       code = GET_CODE (insn);\n@@ -448,6 +454,35 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\t\t\t  label_value_list);\n \t}\n \n+      /* Keep a lifo list of the currently active exception handlers.  */\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t    {\n+\t      for (x = exception_handler_labels; x; x = XEXP (x, 1))\n+\t\tif (CODE_LABEL_NUMBER (XEXP (x, 0)) == NOTE_BLOCK_NUMBER (insn))\n+\t\t  {\n+\t\t    eh_note = gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t       XEXP (x, 0), eh_note);\n+\t\t    break;\n+\t\t  }\n+\t      if (x == NULL_RTX)\n+\t\tabort ();\n+\t    }\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n+\t    eh_note = XEXP (eh_note, 1);\n+\t}\n+      /* If we encounter a CALL_INSN, note which exception handler it\n+\t might pass control to.\n+\n+\t If doing asynchronous exceptions, record the active EH handler\n+\t for every insn, since most insns can throw.  */\n+      else if (eh_note\n+\t       && (asynchronous_exceptions\n+\t\t   || (GET_CODE (insn) == CALL_INSN\n+\t\t       && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))))\n+\tactive_eh_handler[INSN_UID (insn)] = XEXP (eh_note, 0);\n+\n       BLOCK_NUM (insn) = i;\n \n       if (code != NOTE)\n@@ -461,14 +496,6 @@ find_basic_blocks (f, nonlocal_label_list)\n     abort ();\n   n_basic_blocks = i + 1;\n \n-  for (x = forced_labels; x; x = XEXP (x, 1))\n-    if (! LABEL_REF_NONLOCAL_P (x))\n-      block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n-\n-  if (asynchronous_exceptions)\n-    for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-      block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n-\n   /* Record which basic blocks control can drop in to.  */\n \n   for (i = 0; i < n_basic_blocks; i++)\n@@ -489,91 +516,6 @@ find_basic_blocks (f, nonlocal_label_list)\n       int something_marked = 1;\n       int deleted;\n \n-      /* Find all indirect jump insns and mark them as possibly jumping to all\n-\t the labels whose addresses are explicitly used.  This is because,\n-\t when there are computed gotos, we can't tell which labels they jump\n-\t to, of all the possibilities.  */\n-\n-      for (insn = f; insn; insn = NEXT_INSN (insn))\n-\tif (computed_jump_p (insn))\n-\t  {\n-\t    if (label_value_list_marked_live == 0)\n-\t      {\n-\t\tlabel_value_list_marked_live = 1;\n-\n-\t\t/* This could be made smarter by only considering\n-\t\t   these live, if the computed goto is live.  */\n-\n-\t\t/* Don't delete the labels (in this function) that\n-\t\t   are referenced by non-jump instructions.  */\n-\n-\t\tfor (x = label_value_list; x; x = XEXP (x, 1))\n-\t\t  if (! LABEL_REF_NONLOCAL_P (x))\n-\t\t    block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n-\t      }\n-\n-\t    for (x = label_value_list; x; x = XEXP (x, 1))\n-\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n-\t\t\t      insn, 0);\n-\n-\t    for (x = forced_labels; x; x = XEXP (x, 1))\n-\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n-\t\t\t      insn, 0);\n-\t  }\n-\n-      /* Find all call insns and mark them as possibly jumping\n-\t to all the nonlocal goto handler labels, or to the current\n-\t exception handler.  */\n-\n-      for (note = NULL_RTX, insn = f; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (! asynchronous_exceptions && GET_CODE (insn) == NOTE)\n-\t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\t\t{\n-\t\t  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n-\t\t    if (CODE_LABEL_NUMBER (XEXP (x, 0))\n-\t\t\t== NOTE_BLOCK_NUMBER (insn))\n-\t\t      {\n-\t\t\tnote = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\t XEXP (x, 0), note);\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  if (x == NULL_RTX)\n-\t\t    abort ();\n-\t\t}\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t\tnote = XEXP (note, 1);\n-\t    }\n-\t  else if (GET_CODE (insn) == CALL_INSN\n-\t\t   && ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t    {\n-\t      if (note)\n-\t\tmark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (note, 0)),\n-\t\t\t\tinsn, 0);\n-\n-\t      for (x = nonlocal_label_list; x; x = XEXP (x, 1))\n-\t\tmark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n-\t\t\t\tinsn, 0);\n-\t    /* ??? This could be made smarter:\n-\t       in some cases it's possible to tell that certain\n-\t       calls will not do a nonlocal goto.\n-\n-\t       For example, if the nested functions that do the\n-\t       nonlocal gotos do not have their addresses taken, then\n-\t       only calls to those functions or to other nested\n-\t       functions that use them could possibly do nonlocal\n-\t       gotos.  */\n-\t    }\n-\t}\n-\n-      /* All blocks associated with labels in label_value_list are\n-\t trivially considered as marked live, if the list is empty.\n-\t We do this to speed up the below code.  */\n-\n-      if (label_value_list == 0)\n-\tlabel_value_list_marked_live = 1;\n-\n       /* Pass over all blocks, marking each block that is reachable\n \t and has not yet been marked.\n \t Keep doing this until, in one pass, no blocks have been marked.\n@@ -594,43 +536,130 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\tif (GET_CODE (insn) == JUMP_INSN)\n \t\t  mark_label_ref (PATTERN (insn), insn, 0);\n \n-\t\tif (label_value_list_marked_live == 0)\n-\t\t  /* Now that we know that this block is live, mark as\n-\t\t     live, all the blocks that we might be able to get\n-\t\t     to as live.  */\n-\n-\t\t  for (insn = basic_block_head[i];\n-\t\t       insn != NEXT_INSN (basic_block_end[i]);\n-\t\t       insn = NEXT_INSN (insn))\n-\t\t    {\n-\t\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t\t\t{\n-\t\t\t  for (note = REG_NOTES (insn);\n-\t\t\t       note;\n-\t\t\t       note = XEXP (note, 1))\n+\t\t/* If we have any forced labels, mark them as potentially\n+\t\t   reachable from this block.  */\n+\t\tfor (x = forced_labels; x; x = XEXP (x, 1))\n+\t\t  if (! LABEL_REF_NONLOCAL_P (x))\n+\t\t    mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t\t    insn, 0);\n+\n+\t\t/* Now scan the insns for this block, we may need to make\n+\t\t   edges for some of them to various non-obvious locations\n+\t\t   (exception handlers, nonlocal labels, etc).  */\n+\t\tfor (insn = basic_block_head[i];\n+\t\t     insn != NEXT_INSN (basic_block_end[i]);\n+\t\t     insn = NEXT_INSN (insn))\n+\t\t  {\n+\t\t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t\t      {\n+\t\t\t\n+\t\t\t/* We have no idea where the label referenced by this\n+\t\t\t   insn will actually be used.\n+\n+\t\t\t   To create an accurate cfg we mark the target blocks\n+\t\t\t   as live and create a list of all the labels\n+\t\t\t   mentioned in REG_LABEL notes.  After we're done\n+\t\t\t   marking blocks, we go back and create an edge from\n+\t\t\t   every live block to labels on the list.  */ \n+\t\t\tfor (note = REG_NOTES (insn);\n+\t\t\t     note;\n+\t\t\t     note = XEXP (note, 1))\n+\t\t\t  {\n \t\t\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n \t\t\t      {\n \t\t\t\tx = XEXP (note, 0);\n \t\t\t\tblock_live[BLOCK_NUM (x)] = 1;\n+\t\t\t\treg_label_list\n+\t\t\t\t  = gen_rtx (EXPR_LIST, VOIDmode, x,\n+\t\t\t\t\t     reg_label_list);\n \t\t\t      }\n-\t\t\t}\n-\t\t    }\n+\t\t\t  }\n+\n+\t\t\t/* If this is a computed jump, then mark it as\n+\t\t\t   reaching everything on the label_value_list\n+\t\t\t   and forced_labels list.  */\n+\t\t\tif (computed_jump_p (insn))\n+\t\t\t  {\n+\t\t\t    for (x = label_value_list; x; x = XEXP (x, 1))\n+\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t       XEXP (x, 0)),\n+\t\t\t\t\t      insn, 0);\n+\n+\t\t\t    for (x = forced_labels; x; x = XEXP (x, 1))\n+\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t       XEXP (x, 0)),\n+\t\t\t\t\t      insn, 0);\n+\t\t\t    }\n+\n+\t\t\t/* If this is a CALL_INSN, then mark it as reaching\n+\t\t\t   the active EH handler for this CALL_INSN.  If\n+\t\t\t   we're handling asynchronous exceptions mark every\n+\t\t\t   insn as reaching the active EH handler.\n+\n+\t\t\t   Also mark the CALL_INSN as reaching any nonlocal\n+\t\t\t   goto sites.  */\n+\t\t\telse if (asynchronous_exceptions\n+\t\t\t\t || (GET_CODE (insn) == CALL_INSN\n+\t\t\t\t     && ! find_reg_note (insn, REG_RETVAL,\n+\t\t\t\t\t\t\t NULL_RTX)))\n+\t\t\t  {\n+\t\t\t    if (active_eh_handler[INSN_UID (insn)])\n+\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t       active_eh_handler[INSN_UID (insn)]),\n+\t\t\t\t\t      insn, 0);\n+\n+\t\t\t    if (!asynchronous_exceptions)\n+\t\t\t      {\n+\t\t\t\tfor (x = nonlocal_label_list;\n+\t\t\t\t     x;\n+\t\t\t\t     x = XEXP (x, 1))\n+\t\t\t\t  mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n+\t\t\t\t\t\t\t   XEXP (x, 0)),\n+\t\t\t\t\t\t  insn, 0);\n+\t\t\t      }\n+\t\t\t    /* ??? This could be made smarter:\n+\t\t\t       in some cases it's possible to tell that\n+\t\t\t       certain calls will not do a nonlocal goto.\n+\n+\t\t\t       For example, if the nested functions that\n+\t\t\t       do the nonlocal gotos do not have their\n+\t\t\t       addresses taken, then only calls to those\n+\t\t\t       functions or to other nested functions that\n+\t\t\t       use them could possibly do nonlocal gotos.  */\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n \t      }\n \t}\n \n-      /* ??? See if we have a \"live\" basic block that is not reachable.\n-\t This can happen if it is headed by a label that is preserved or\n-\t in one of the label lists, but no call or computed jump is in\n-\t the loop.  It's not clear if we can delete the block or not,\n-\t but don't for now.  However, we will mess up register status if\n-\t it remains unreachable, so add a fake reachability from the\n-\t previous block.  */\n+      /* We couldn't determine what edges are needed for labels on the\n+\t reg_label_list above.  So make an edge from every live block to\n+\t to every label on the reg_label_list.  */\n+      if (reg_label_list)\n+\t{\n+\t  for (i = 1; i < n_basic_blocks; i++)\n+\t  if (block_live[i])\n+\t    {\n+\t      rtx x;\n+\n+\t      for (x = reg_label_list; x; x = XEXP (x, 1))\n+\t\tmark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t\tbasic_block_end[i], 0);\n+\t    }\n+\t}\n+\n+      /* This should never happen.  If it does that means we've computed an\n+\t incorrect flow graph, which can lead to aborts/crashes later in the\n+\t compiler or incorrect code generation.\n \n+\t We used to try and continue here, but that's just asking for trouble\n+\t later during the compile or at runtime.  It's easier to debug the\n+\t problem here than later!  */\n       for (i = 1; i < n_basic_blocks; i++)\n \tif (block_live[i] && ! basic_block_drops_in[i]\n \t    && GET_CODE (basic_block_head[i]) == CODE_LABEL\n \t    && LABEL_REFS (basic_block_head[i]) == basic_block_head[i])\n-\t  basic_block_drops_in[i] = 1;\n+\t  abort ();\n \n       /* Now delete the code for any basic blocks that can't be reached.\n \t They can occur because jump_optimize does not recognize"}]}