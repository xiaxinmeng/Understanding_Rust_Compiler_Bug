{"sha": "7dcdacadb24784516b9334ba3755082ba205eaeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RjZGFjYWRiMjQ3ODQ1MTZiOTMzNGJhMzc1NTA4MmJhMjA1ZWFlYg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-10-12T18:24:45Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-10-12T18:24:45Z"}, "message": "tree-ssa-alias.c (verify_name_tags): New function.\n\n2004-10-12  Daniel Berlin <dberlin@dberlin.org>\n\n\t* tree-ssa-alias.c (verify_name_tags): New function.\n\t(verify_flow_sensitive_alias_info): Remove code that used to check name tags.\n\t(verify_alias_info): Call verify_name_tags.\n\nFrom-SVN: r88945", "tree": {"sha": "29f82797041b703b3ecfb250d51f2a82ccba00fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29f82797041b703b3ecfb250d51f2a82ccba00fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dcdacadb24784516b9334ba3755082ba205eaeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcdacadb24784516b9334ba3755082ba205eaeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dcdacadb24784516b9334ba3755082ba205eaeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dcdacadb24784516b9334ba3755082ba205eaeb/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c271ba771118b065187992424ccb86091a4e55a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c271ba771118b065187992424ccb86091a4e55a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c271ba771118b065187992424ccb86091a4e55a9"}], "stats": {"total": 110, "additions": 83, "deletions": 27}, "files": [{"sha": "ca3911db1487b30a5ce6c22240c316e3994beb37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcdacadb24784516b9334ba3755082ba205eaeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcdacadb24784516b9334ba3755082ba205eaeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dcdacadb24784516b9334ba3755082ba205eaeb", "patch": "@@ -1,3 +1,9 @@\n+2004-10-12  Daniel Berlin <dberlin@dberlin.org>\n+\n+\t* tree-ssa-alias.c (verify_name_tags): New function.\n+\t(verify_flow_sensitive_alias_info): Remove code that used to check name tags.\n+\t(verify_alias_info): Call verify_name_tags.\n+\n 2004-10-12  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR rtl-optimization/17931"}, {"sha": "f910c387b255280ff991138d3d8981df2d202a86", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 77, "deletions": 27, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dcdacadb24784516b9334ba3755082ba205eaeb/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dcdacadb24784516b9334ba3755082ba205eaeb/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=7dcdacadb24784516b9334ba3755082ba205eaeb", "patch": "@@ -463,33 +463,6 @@ verify_flow_sensitive_alias_info (void)\n \t  error (\"Pointer escapes but its name tag is not call-clobbered.\");\n \t  goto err;\n \t}\n-\n-      if (pi->name_mem_tag && pi->pt_vars)\n-\t{\n-\t  size_t j;\n-\n-\t  for (j = i + 1; j < num_ssa_names; j++)\n-\t    if (ssa_name (j))\n-\t      {\n-\t\ttree ptr2 = ssa_name (j);\n-\t\tstruct ptr_info_def *pi2 = SSA_NAME_PTR_INFO (ptr2);\n-\n-\t\tif (!TREE_VISITED (ptr2) || !POINTER_TYPE_P (TREE_TYPE (ptr2)))\n-\t\t  continue;\n-\n-\t\tif (pi2\n-\t\t    && pi2->name_mem_tag\n-\t\t    && pi2->pt_vars\n-\t\t    && bitmap_first_set_bit (pi2->pt_vars) >= 0\n-\t\t    && pi->name_mem_tag != pi2->name_mem_tag\n-\t\t    && bitmap_equal_p (pi->pt_vars, pi2->pt_vars))\n-\t\t  {\n-\t\t    error (\"Two pointers with different name tags and identical points-to sets\");\n-\t\t    debug_variable (ptr2);\n-\t\t    goto err;\n-\t\t  }\n-\t      }\n-\t}\n     }\n \n   return;\n@@ -499,13 +472,90 @@ verify_flow_sensitive_alias_info (void)\n   internal_error (\"verify_flow_sensitive_alias_info failed.\");\n }\n \n+DEF_VEC_MALLOC_P (bitmap);\n+\n+/* Verify that all name tags have different points to sets.\n+   This algorithm takes advantage of the fact that every variable with the\n+   same name tag must have the same points-to set. \n+   So we check a single variable for each name tag, and verify that it's\n+   points-to set is different from every other points-to set for other name\n+   tags.  */\n \n+static void\n+verify_name_tags (void)\n+{\n+  size_t i;  \n+  size_t j;\n+  bitmap first, second;  \n+  VEC (tree) *name_tag_reps = NULL;\n+  VEC (bitmap) *pt_vars_for_reps = NULL;\n+\n+  /* First we compute the name tag representatives and their points-to sets.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      if (ssa_name (i))\n+\t{\n+\t  tree ptr = ssa_name (i);\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\t  if (!TREE_VISITED (ptr) \n+\t      || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n+\t      || !pi\n+\t      || !pi->name_mem_tag \n+\t      || TREE_VISITED (pi->name_mem_tag))\n+\t    continue;\n+\t  TREE_VISITED (pi->name_mem_tag) = 1;\n+\t  if (pi->pt_vars != NULL)\n+\t    {    \n+\t      VEC_safe_push (tree, name_tag_reps, ptr);\n+\t      VEC_safe_push (bitmap, pt_vars_for_reps, pi->pt_vars);\n+\t    }\n+\t}\n+    }\n+  \n+  /* Now compare all the representative bitmaps with all other representative\n+     bitmaps, to verify that they are all different.  */\n+  for (i = 0; VEC_iterate (bitmap, pt_vars_for_reps, i, first); i++)\n+    {\n+       for (j = i + 1; VEC_iterate (bitmap, pt_vars_for_reps, j, second); j++)\n+\t { \n+\t   if (bitmap_equal_p (first, second))\n+\t     {\n+\t       error (\"Two different pointers with identical points-to sets but different name tags\");\n+\t       debug_variable (VEC_index (tree, name_tag_reps, j));\n+\t       goto err;\n+\t     }\n+\t }\n+    }\n+\n+  /* Lastly, clear out the visited flags.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      if (ssa_name (i))\n+\t{\n+\t  tree ptr = ssa_name (i);\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\t  if (!TREE_VISITED (ptr) \n+\t      || !POINTER_TYPE_P (TREE_TYPE (ptr)) \n+\t      || !pi\n+\t      || !pi->name_mem_tag)\n+\t    continue;\n+\t  TREE_VISITED (pi->name_mem_tag) = 0;\n+\t}\n+    } \n+  VEC_free (bitmap, pt_vars_for_reps);\n+  return;\n+  \n+err:\n+  debug_variable (VEC_index (tree, name_tag_reps, i));\n+  internal_error (\"verify_name_tags failed\");\n+}\n /* Verify the consistency of aliasing information.  */\n \n static void\n verify_alias_info (void)\n {\n   verify_flow_sensitive_alias_info ();\n+  verify_name_tags ();\n   verify_flow_insensitive_alias_info ();\n }\n "}]}