{"sha": "f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkOTI3YzA3ZjA2ZWU4OGVhYTQ3NjA4YzMwZTJjZDJhMjlhYzI3NA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-09-11T22:00:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-09-11T22:00:04Z"}, "message": "* final.c: Fix formatting.\n\nFrom-SVN: r36338", "tree": {"sha": "5478c45fccab2e49f2d246818b3862df4496c186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5478c45fccab2e49f2d246818b3862df4496c186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d927c07f06ee88eaa47608c30e2cd2a29ac274/comments", "author": null, "committer": null, "parents": [{"sha": "4843bda91e89fec6ce1b7dccfcc541473b2f7296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4843bda91e89fec6ce1b7dccfcc541473b2f7296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4843bda91e89fec6ce1b7dccfcc541473b2f7296"}], "stats": {"total": 206, "additions": 111, "deletions": 95}, "files": [{"sha": "57693f694256b877f54f7ddfa579c1c0a378c062", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d927c07f06ee88eaa47608c30e2cd2a29ac274/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d927c07f06ee88eaa47608c30e2cd2a29ac274/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "patch": "@@ -128,6 +128,8 @@ Mon Sep 11 10:48:41 2000  Ulrich Drepper <drepper@redhat.com>\n \n 2000-09-11  Kazu Hirata  <kazu@hxi.com>\n \n+\t* final.c: Fix formatting.\n+\n \t* integrate.c: Fix formatting.\n \n 2000-09-11  Geoff Keating  <geoffk@cygnus.com>"}, {"sha": "404fcc3627b29a32e8d3ded01a5f83f852747e3d", "filename": "gcc/final.c", "status": "modified", "additions": 109, "deletions": 95, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d927c07f06ee88eaa47608c30e2cd2a29ac274/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d927c07f06ee88eaa47608c30e2cd2a29ac274/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f5d927c07f06ee88eaa47608c30e2cd2a29ac274", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This is the final pass of the compiler.\n    It looks at the rtl code for a function and outputs assembler code.\n \n@@ -241,7 +240,8 @@ rtx current_insn_predicate;\n \n /* Linked list to hold line numbers for each basic block.  */\n \n-struct bb_list {\n+struct bb_list\n+{\n   struct bb_list *next;\t\t/* pointer to next basic block */\n   int line_num;\t\t\t/* line number */\n   int file_label_num;\t\t/* LPBC<n> label # for stored filename */\n@@ -255,7 +255,8 @@ static int bb_func_label_num\t= -1;\t\t/* Current label # for func */\n \n /* Linked list to hold the strings for each file and function name output.  */\n \n-struct bb_str {\n+struct bb_str\n+{\n   struct bb_str *next;\t\t/* pointer to next string */\n   const char *string;\t\t/* string */\n   int label_num;\t\t/* label number */\n@@ -309,7 +310,7 @@ init_final (filename)\n \n void\n end_final (filename)\n-  const char *filename;\n+     const char *filename;\n {\n   int i;\n \n@@ -453,8 +454,8 @@ end_final (filename)\n \t  else\n #endif\n #ifdef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n-\t    ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name, size,\n-\t\t\t\t\t      BIGGEST_ALIGNMENT);\n+\t    ASM_OUTPUT_ALIGNED_DECL_LOCAL (asm_out_file, NULL_TREE, name,\n+\t\t\t\t\t   size, BIGGEST_ALIGNMENT);\n #else\n #ifdef ASM_OUTPUT_ALIGNED_LOCAL\n \t    ASM_OUTPUT_ALIGNED_LOCAL (asm_out_file, name, size,\n@@ -512,7 +513,7 @@ end_final (filename)\n \t\tassemble_integer (const0_rtx, pointer_bytes, 1);\n \t    }\n \n-\t  for ( ; i < count_basic_blocks; i++)\n+\t  for (; i < count_basic_blocks; i++)\n \t    assemble_integer (const0_rtx, pointer_bytes, 1);\n \t}\n \n@@ -523,7 +524,7 @@ end_final (filename)\n \t  for ((ptr = bb_head), (i = 0); ptr != 0; (ptr = ptr->next), i++)\n \t    assemble_integer (GEN_INT (ptr->line_num), long_bytes, 1);\n \n-\t  for ( ; i < count_basic_blocks; i++)\n+\t  for (; i < count_basic_blocks; i++)\n \t    assemble_integer (const0_rtx, long_bytes, 1);\n \n \t  /* Output the table of file names.  */\n@@ -541,7 +542,7 @@ end_final (filename)\n \t\tassemble_integer (const0_rtx, pointer_bytes, 1);\n \t    }\n \n-\t  for ( ; i < count_basic_blocks; i++)\n+\t  for (; i < count_basic_blocks; i++)\n \t    assemble_integer (const0_rtx, pointer_bytes, 1);\n \t}\n \n@@ -582,7 +583,7 @@ app_disable ()\n     }\n }\n \f\n-/* Return the number of slots filled in the current \n+/* Return the number of slots filled in the current\n    delayed branch sequence (we don't count the insn needing the\n    delay slot).   Zero if not in a delayed branch sequence.  */\n \n@@ -630,7 +631,8 @@ int insn_current_align;\n    for each insn we'll call the alignment chain of this insn in the following\n    comments.  */\n \n-struct label_alignment {\n+struct label_alignment\n+{\n   short alignment;\n   short max_skip;\n };\n@@ -741,34 +743,34 @@ get_attr_length (insn)\n \n    Call a sequence of instructions beginning with alignment point X\n    and continuing until the next alignment point `block X'.  When `X'\n-   is used in an expression, it means the alignment value of the \n+   is used in an expression, it means the alignment value of the\n    alignment point.\n-   \n+\n    Call the distance between the start of the first insn of block X, and\n    the end of the last insn of block X `IX', for the `inner size of X'.\n    This is clearly the sum of the instruction lengths.\n-   \n+\n    Likewise with the next alignment-delimited block following X, which we\n    shall call block Y.\n-   \n+\n    Call the distance between the start of the first insn of block X, and\n    the start of the first insn of block Y `OX', for the `outer size of X'.\n-   \n+\n    The estimated padding is then OX - IX.\n-   \n+\n    OX can be safely estimated as\n-   \n+\n            if (X >= Y)\n                    OX = round_up(IX, Y)\n            else\n                    OX = round_up(IX, X) + Y - X\n-   \n+\n    Clearly est(IX) >= real(IX), because that only depends on the\n    instruction lengths, and those being overestimated is a given.\n-   \n+\n    Clearly round_up(foo, Z) >= round_up(bar, Z) if foo >= bar, so\n    we needn't worry about that when thinking about OX.\n-   \n+\n    When X >= Y, the alignment provided by Y adds no uncertainty factor\n    for branch ranges starting before X, so we can just round what we have.\n    But when X < Y, we don't know anything about the, so to speak,\n@@ -811,6 +813,7 @@ final_addr_vec_align (addr_vec)\n   return align;\n \n }\n+\n #define ADDR_VEC_ALIGN(ADDR_VEC) final_addr_vec_align (ADDR_VEC)\n #endif\n \n@@ -829,6 +832,7 @@ static int min_labelno, max_labelno;\n   (label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].max_skip)\n \n /* For the benefit of port specific code do this also as a function.  */\n+\n int\n label_to_alignment (label)\n      rtx label;\n@@ -857,14 +861,14 @@ label_to_alignment (label)\n    For this purpose, align_fuzz with a growth argument of 0 comuptes the\n    appropriate adjustment.  */\n \n-\n /* Compute the maximum delta by which the difference of the addresses of\n    START and END might grow / shrink due to a different address for start\n    which changes the size of alignment insns between START and END.\n    KNOWN_ALIGN_LOG is the alignment known for START.\n    GROWTH should be ~0 if the objective is to compute potential code size\n    increase, and 0 if the objective is to compute potential shrink.\n    The return value is undefined for any other value of GROWTH.  */\n+\n static int\n align_fuzz (start, end, known_align_log, growth)\n      rtx start, end;\n@@ -906,6 +910,7 @@ align_fuzz (start, end, known_align_log, growth)\n    to account for possible size increase due to alignment.\n    NB.: Therefore, the maximum offset allowed for backward branches needs\n    to exclude the branch size.  */\n+\n int\n insn_current_reference_address (branch)\n      rtx branch;\n@@ -930,13 +935,13 @@ insn_current_reference_address (branch)\n   /* BRANCH has no proper alignment chain set, so use SEQ.  */\n   if (INSN_SHUID (branch) < INSN_SHUID (dest))\n     {\n-      /* Forward branch. */\n+      /* Forward branch.  */\n       return (insn_last_address + insn_lengths[seq_uid]\n \t      - align_fuzz (seq, dest, length_unit_log, ~0));\n     }\n   else\n     {\n-      /* Backward branch. */\n+      /* Backward branch.  */\n       return (insn_current_address\n \t      + align_fuzz (dest, seq, length_unit_log, ~0));\n     }\n@@ -992,11 +997,11 @@ shorten_branches (first)\n \t   with only the 'deleted' bit set.  Transform it into a note\n \t   to avoid confusion of subsequent processing.  */\n \tif (INSN_DELETED_P (old))\n-          {\n-            PUT_CODE (old , NOTE);\n-            NOTE_LINE_NUMBER (old) = NOTE_INSN_DELETED;\n-            NOTE_SOURCE_FILE (old) = 0;\n-          }\n+\t  {\n+\t    PUT_CODE (old, NOTE);\n+\t    NOTE_LINE_NUMBER (old) = NOTE_INSN_DELETED;\n+\t    NOTE_SOURCE_FILE (old) = 0;\n+\t  }\n       }\n #endif\n \n@@ -1020,7 +1025,7 @@ shorten_branches (first)\n   /* We use max_log here to keep track of the maximum alignment we want to\n      impose on the next CODE_LABEL (or the current one if we are processing\n      the CODE_LABEL itself).  */\n-     \n+\n   max_log = 0;\n   max_skip = 0;\n \n@@ -1145,7 +1150,7 @@ shorten_branches (first)\n      alignment of n.  */\n   uid_align = (rtx *) xcalloc (max_uid, sizeof *uid_align);\n \n-  for (i = MAX_CODE_ALIGN; --i >= 0; )\n+  for (i = MAX_CODE_ALIGN; --i >= 0;)\n     align_tab[i] = NULL_RTX;\n   seq = get_last_insn ();\n   for (; seq; seq = PREV_INSN (seq))\n@@ -1219,7 +1224,6 @@ shorten_branches (first)\n     }\n #endif /* CASE_VECTOR_SHORTEN_MODE */\n \n-\n   /* Compute initial lengths, addresses, and varying flags for each insn.  */\n   for (insn_current_address = FIRST_INSN_ADDRESS, insn = first;\n        insn != 0;\n@@ -1242,7 +1246,7 @@ shorten_branches (first)\n \t}\n \n       INSN_ADDRESSES (uid) = insn_current_address;\n-      \n+\n       if (GET_CODE (insn) == NOTE || GET_CODE (insn) == BARRIER\n \t  || GET_CODE (insn) == CODE_LABEL)\n \tcontinue;\n@@ -1290,7 +1294,7 @@ shorten_branches (first)\n \t\t\t\t* insn_default_length (inner_insn));\n \t      else\n \t\tinner_length = insn_default_length (inner_insn);\n-\t      \n+\n \t      insn_lengths[inner_uid] = inner_length;\n \t      if (const_delay_slots)\n \t\t{\n@@ -1481,7 +1485,7 @@ shorten_branches (first)\n \t  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t    {\n \t      int i;\n-\t      \n+\n \t      body = PATTERN (insn);\n \t      new_length = 0;\n \t      for (i = 0; i < XVECLEN (body, 0); i++)\n@@ -1555,8 +1559,8 @@ asm_insn_count (body)\n     template = decode_asm_operands (body, NULL_PTR, NULL_PTR,\n \t\t\t\t    NULL_PTR, NULL_PTR);\n \n-  for ( ; *template; template++)\n-    if (IS_ASM_LOGICAL_LINE_SEPARATOR(*template) || *template == '\\n')\n+  for (; *template; template++)\n+    if (IS_ASM_LOGICAL_LINE_SEPARATOR (*template) || *template == '\\n')\n       count++;\n \n   return count;\n@@ -1595,7 +1599,7 @@ final_start_function (first, file, optimize)\n \t  regs_ever_live[i] = 1;\n     }\n #endif\n-  \n+\n   /* Initial line number is supposed to be output\n      before the function's prologue and label\n      so that the function's address will not appear to be\n@@ -1625,7 +1629,7 @@ final_start_function (first, file, optimize)\n     if (write_symbols == XCOFF_DEBUG)\n       xcoffout_begin_function (file, last_linenum);\n     else\n-#endif\t  \n+#endif\n       /* But only output line number for other debug info types if -g2\n \t or better.  */\n       if (NOTE_LINE_NUMBER (first) != NOTE_INSN_DELETED)\n@@ -1678,8 +1682,9 @@ final_start_function (first, file, optimize)\n      of the function name.  */\n   if (profile_block_flag)\n     {\n-      bb_func_label_num\n-\t= add_bb_string ((*decl_printable_name) (current_function_decl, 2), FALSE);\n+      bb_func_label_num =\n+\tadd_bb_string ((*decl_printable_name) (current_function_decl, 2),\n+\t\t       FALSE);\n     }\n }\n \n@@ -1847,7 +1852,8 @@ static void\n add_bb (file)\n      FILE *file;\n {\n-  struct bb_list *ptr = (struct bb_list *) permalloc (sizeof (struct bb_list));\n+  struct bb_list *ptr =\n+    (struct bb_list *) permalloc (sizeof (struct bb_list));\n \n   /* Add basic block to linked list.  */\n   ptr->next = 0;\n@@ -1920,7 +1926,6 @@ add_bb_string (string, perm_p)\n \n   return ptr->label_num;\n }\n-\n \f\n /* Output assembler code for some insns: all or part of a function.\n    For description of args, see `final_start_function', above.\n@@ -1988,9 +1993,9 @@ final (first, file, optimize, prescan)\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_UID (insn) > max_uid)       /* find largest UID */\n-        max_uid = INSN_UID (insn);\n+\tmax_uid = INSN_UID (insn);\n       if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n-        line_note_exists[NOTE_LINE_NUMBER (insn)] = 1;\n+\tline_note_exists[NOTE_LINE_NUMBER (insn)] = 1;\n #ifdef HAVE_cc0\n       /* If CC tracking across branches is enabled, record the insn which\n \t jumps to each branch only reached from one place.  */\n@@ -2005,8 +2010,8 @@ final (first, file, optimize, prescan)\n #endif\n     }\n \n-  /* Initialize insn_eh_region table if eh is being used. */\n-  \n+  /* Initialize insn_eh_region table if eh is being used.  */\n+\n   init_insn_eh_region (first, max_uid);\n \n   init_recog ();\n@@ -2058,16 +2063,17 @@ get_insn_template (code, insn)\n     case INSN_OUTPUT_FORMAT_SINGLE:\n       return (const char *) output;\n     case INSN_OUTPUT_FORMAT_MULTI:\n-      return ((const char * const *) output)[which_alternative];\n+      return ((const char *const *) output)[which_alternative];\n     case INSN_OUTPUT_FORMAT_FUNCTION:\n       if (insn == NULL)\n \tabort ();\n-      return (* (insn_output_fn) output) (recog_data.operand, insn);\n+      return (*(insn_output_fn) output) (recog_data.operand, insn);\n \n     default:\n       abort ();\n     }\n }\n+\n /* The final scan for one insn, INSN.\n    Args are same as in `final', except that INSN\n    is the insn being scanned.\n@@ -2270,11 +2276,11 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      || debug_info_level == DINFO_LEVEL_VERBOSE)\n \t    {\n #ifdef DWARF_DEBUGGING_INFO\n-              if (write_symbols == DWARF_DEBUG)\n+\t      if (write_symbols == DWARF_DEBUG)\n \t\tdwarfout_label (insn);\n #endif\n #ifdef DWARF2_DEBUGGING_INFO\n-              if (write_symbols == DWARF2_DEBUG)\n+\t      if (write_symbols == DWARF2_DEBUG)\n \t\tdwarf2out_label (insn);\n #endif\n \t    }\n@@ -2292,7 +2298,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    register rtx note;\n \t    int note_after = 0;\n \n-\t    /* If there is anything real after this note, output it. \n+\t    /* If there is anything real after this note, output it.\n \t       If another line note follows, omit this one.  */\n \t    for (note = NEXT_INSN (insn); note; note = NEXT_INSN (note))\n \t      {\n@@ -2328,7 +2334,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    if (!note_after)\n \t      output_source_line (file, insn);\n \t  }\n-          break;\n+\t  break;\n \t}\n       break;\n \n@@ -2443,19 +2449,19 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn),\n \t\t\t\t     NEXT_INSN (insn));\n #else\n-              if (LABEL_ALTERNATE_NAME (insn))\n-                ASM_OUTPUT_ALTERNATE_LABEL_NAME (file, insn);\n-              else\n-\t        ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+\t      if (LABEL_ALTERNATE_NAME (insn))\n+\t\tASM_OUTPUT_ALTERNATE_LABEL_NAME (file, insn);\n+\t      else\n+\t\tASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n #endif\n #endif\n \t      break;\n \t    }\n \t}\n       if (LABEL_ALTERNATE_NAME (insn))\n-        ASM_OUTPUT_ALTERNATE_LABEL_NAME (file, insn);\n+\tASM_OUTPUT_ALTERNATE_LABEL_NAME (file, insn);\n       else\n-        ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+\tASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n       break;\n \n     default:\n@@ -2512,15 +2518,15 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n #ifdef ASM_OUTPUT_ADDR_VEC\n \t\tASM_OUTPUT_ADDR_VEC (PREV_INSN (insn), body);\n #else\n-\t\tabort();\n+\t\tabort ();\n #endif\n \t      }\n \t    else\n \t      {\n #ifdef ASM_OUTPUT_ADDR_DIFF_VEC\n \t\tASM_OUTPUT_ADDR_DIFF_VEC (PREV_INSN (insn), body);\n #else\n-\t\tabort();\n+\t\tabort ();\n #endif\n \t      }\n #else\n@@ -2688,7 +2694,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tbody = PATTERN (insn);\n \n #ifdef HAVE_cc0\n-\tset = single_set(insn);\n+\tset = single_set (insn);\n \n \t/* Check for redundant test and compare instructions\n \t   (when the condition codes are already set up as desired).\n@@ -2701,7 +2707,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tif (optimize)\n \t  {\n #if 0\n-\t    rtx set = single_set(insn);\n+\t    rtx set = single_set (insn);\n #endif\n \n \t    if (set\n@@ -2820,7 +2826,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    && set != 0)\n \t  {\n \t    rtx cond_rtx, then_rtx, else_rtx;\n-\t    \n+\n \t    if (GET_CODE (insn) != JUMP_INSN\n \t\t&& GET_CODE (SET_SRC (set)) == IF_THEN_ELSE)\n \t      {\n@@ -2834,7 +2840,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\tthen_rtx = const_true_rtx;\n \t\telse_rtx = const0_rtx;\n \t      }\n-\t    \n+\n \t    switch (GET_CODE (cond_rtx))\n \t      {\n \t      case GTU:\n@@ -2994,7 +3000,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    /* If we didn't split the insn, go away.  */\n \t    if (new == insn && PATTERN (new) == body)\n \t      fatal_insn (\"Could not split insn\", insn);\n-\t      \n+\n #ifdef HAVE_ATTR_length\n \t    /* This instruction should have been split in shorten_branches,\n \t       to ensure that we would have valid length info for the\n@@ -3005,7 +3011,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    new_block = 0;\n \t    return new;\n \t  }\n-\t\n+\n \tif (prescan > 0)\n \t  break;\n \n@@ -3116,9 +3122,9 @@ output_source_line (file, insn)\n     }\n }\n \f\n-\n /* For each operand in INSN, simplify (subreg (reg)) so that it refers\n    directly to the desired hard register.  */\n+\n void\n cleanup_subreg_operands (insn)\n      rtx insn;\n@@ -3129,19 +3135,19 @@ cleanup_subreg_operands (insn)\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n-        recog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n+\trecog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n       else if (GET_CODE (recog_data.operand[i]) == PLUS\n-               || GET_CODE (recog_data.operand[i]) == MULT)\n-       recog_data.operand[i] = walk_alter_subreg (recog_data.operand[i]);\n+\t       || GET_CODE (recog_data.operand[i]) == MULT)\n+\trecog_data.operand[i] = walk_alter_subreg (recog_data.operand[i]);\n     }\n \n   for (i = 0; i < recog_data.n_dups; i++)\n     {\n       if (GET_CODE (*recog_data.dup_loc[i]) == SUBREG)\n-        *recog_data.dup_loc[i] = alter_subreg (*recog_data.dup_loc[i]);\n+\t*recog_data.dup_loc[i] = alter_subreg (*recog_data.dup_loc[i]);\n       else if (GET_CODE (*recog_data.dup_loc[i]) == PLUS\n-               || GET_CODE (*recog_data.dup_loc[i]) == MULT)\n-        *recog_data.dup_loc[i] = walk_alter_subreg (*recog_data.dup_loc[i]);\n+\t       || GET_CODE (*recog_data.dup_loc[i]) == MULT)\n+\t*recog_data.dup_loc[i] = walk_alter_subreg (*recog_data.dup_loc[i]);\n     }\n }\n \n@@ -3173,8 +3179,8 @@ alter_subreg (x)\n \t gen_lowpart and friends.  */\n \n #ifdef ALTER_HARD_SUBREG\n-      regno = ALTER_HARD_SUBREG(GET_MODE (x), SUBREG_WORD (x),\n-\t\t\t\tGET_MODE (y), REGNO (y));\n+      regno = ALTER_HARD_SUBREG (GET_MODE (x), SUBREG_WORD (x),\n+\t\t\t\t GET_MODE (y), REGNO (y));\n #else\n       regno = REGNO (y) + SUBREG_WORD (x);\n #endif\n@@ -3219,7 +3225,7 @@ walk_alter_subreg (x)\n \n     case SUBREG:\n       return alter_subreg (x);\n-      \n+\n     default:\n       break;\n     }\n@@ -3280,7 +3286,7 @@ alter_cond (cond)\n \tPUT_CODE (cond, NE);\n \tvalue = 2;\n \tbreak;\n-\t\n+\n       default:\n \tbreak;\n       }\n@@ -3309,7 +3315,7 @@ alter_cond (cond)\n \tPUT_CODE (cond, NE);\n \tvalue = 2;\n \tbreak;\n-\t\n+\n       default:\n \tbreak;\n       }\n@@ -3334,7 +3340,7 @@ alter_cond (cond)\n       case LTU:\n \t/* Jump becomes no-op.  */\n \treturn -1;\n-\t\n+\n       default:\n \tbreak;\n       }\n@@ -3433,7 +3439,7 @@ output_asm_name ()\n       if (debug_insn)\n \t{\n \t  register int num = INSN_CODE (debug_insn);\n-\t  fprintf (asm_out_file, \"\\t%s %d\\t%s\", \n+\t  fprintf (asm_out_file, \"\\t%s %d\\t%s\",\n \t\t   ASM_COMMENT_START, INSN_UID (debug_insn),\n \t\t   insn_data[num].name);\n \t  if (insn_data[num].n_alternatives > 1)\n@@ -3489,7 +3495,7 @@ output_asm_insn (template, operands)\n       case '{':\n \t{\n \t  register int i;\n-\t  \n+\n \t  /* If we want the first dialect, do nothing.  Otherwise, skip\n \t     DIALECT_NUMBER of strings ending with '|'.  */\n \t  for (i = 0; i < dialect_number; i++)\n@@ -3534,7 +3540,7 @@ output_asm_insn (template, operands)\n \t   Letters `acln' are implemented directly.\n \t   Other letters are passed to `output_operand' so that\n \t   the PRINT_OPERAND macro can define them.  */\n-\telse if (ISLOWER(*p) || ISUPPER(*p))\n+\telse if (ISLOWER (*p) || ISUPPER (*p))\n \t  {\n \t    int letter = *p++;\n \t    c = atoi (p);\n@@ -3567,24 +3573,27 @@ output_asm_insn (template, operands)\n \t      }\n \t    else\n \t      output_operand (operands[c], letter);\n-\t    \n-\t    while ((c = *p) >= '0' && c <= '9') p++;\n+\n+\t    while ((c = *p) >= '0' && c <= '9')\n+\t      p++;\n \t  }\n \t/* % followed by a digit outputs an operand the default way.  */\n \telse if (*p >= '0' && *p <= '9')\n \t  {\n \t    c = atoi (p);\n-\t    if (this_is_asm_operands && (c < 0 || (unsigned int) c >= insn_noperands))\n+\t    if (this_is_asm_operands\n+\t\t&& (c < 0 || (unsigned int) c >= insn_noperands))\n \t      output_operand_lossage (\"operand number out of range\");\n \t    else\n \t      output_operand (operands[c], 0);\n-\t    while ((c = *p) >= '0' && c <= '9') p++;\n+\t    while ((c = *p) >= '0' && c <= '9')\n+\t      p++;\n \t  }\n \t/* % followed by punctuation: output something for that\n \t   punctuation character alone, with no operand.\n \t   The PRINT_OPERAND macro decides what is actually done.  */\n #ifdef PRINT_OPERAND_PUNCT_VALID_P\n-\telse if (PRINT_OPERAND_PUNCT_VALID_P ((unsigned char)*p))\n+\telse if (PRINT_OPERAND_PUNCT_VALID_P ((unsigned char) *p))\n \t  output_operand (NULL_RTX, *p++);\n #endif\n \telse\n@@ -3711,7 +3720,7 @@ output_addr_const (file, x)\n \t  if (CONST_DOUBLE_HIGH (x))\n \t    fprintf (file, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n \t\t     CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n-\t  else if  (CONST_DOUBLE_LOW (x) < 0)\n+\t  else if (CONST_DOUBLE_LOW (x) < 0)\n \t    fprintf (file, HOST_WIDE_INT_PRINT_HEX, CONST_DOUBLE_LOW (x));\n \t  else\n \t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, CONST_DOUBLE_LOW (x));\n@@ -3817,7 +3826,7 @@ asm_fprintf VPARAMS ((FILE *file, const char *p, ...))\n \n \t      if (*p == '|')\n \t\tp++;\n-\t  }\n+\t    }\n \t}\n \tbreak;\n \n@@ -3933,7 +3942,7 @@ asm_fprintf VPARAMS ((FILE *file, const char *p, ...))\n \t  case 'M': case 'N': case 'P': case 'Q': case 'S':\n \t  case 'T': case 'V': case 'W': case 'Y': case 'Z':\n \t    break;\n-\t    \n+\n \t  ASM_FPRINTF_EXTENSIONS (file, argptr, p)\n #endif\n \t  default:\n@@ -3982,7 +3991,7 @@ split_double (value, first, second)\n \n \t  /* Set sign_extend as any remaining bits.  */\n \t  sign_extend = ~mask;\n-\t  \n+\n \t  /* Pick the lower word and sign-extend it.  */\n \t  low = INTVAL (value);\n \t  low &= mask;\n@@ -4061,7 +4070,8 @@ split_double (value, first, second)\n   else\n     {\n #ifdef REAL_ARITHMETIC\n-      REAL_VALUE_TYPE r; long l[2];\n+      REAL_VALUE_TYPE r;\n+      long l[2];\n       REAL_VALUE_FROM_CONST_DOUBLE (r, value);\n \n       /* Note, this converts the REAL_VALUE_TYPE to the target's\n@@ -4136,7 +4146,9 @@ leaf_function_p ()\n \t  && ! SIBLING_CALL_P (XVECEXP (PATTERN (insn), 0, 0)))\n \treturn 0;\n     }\n-  for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))\n+  for (insn = current_function_epilogue_delay_list;\n+       insn;\n+       insn = XEXP (insn, 1))\n     {\n       if (GET_CODE (XEXP (insn, 0)) == CALL_INSN\n \t  && ! SIBLING_CALL_P (insn))\n@@ -4200,7 +4212,9 @@ leaf_renumber_regs (first)\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       leaf_renumber_regs_insn (PATTERN (insn));\n-  for (insn = current_function_epilogue_delay_list; insn; insn = XEXP (insn, 1))\n+  for (insn = current_function_epilogue_delay_list;\n+       insn;\n+       insn = XEXP (insn, 1))\n     if (INSN_P (XEXP (insn, 0)))\n       leaf_renumber_regs_insn (PATTERN (XEXP (insn, 0)));\n }"}]}