{"sha": "a8e3a00f544e678384844899cec3a636442e1517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlM2EwMGY1NDRlNjc4Mzg0ODQ0ODk5Y2VjM2E2MzY0NDJlMTUxNw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2005-01-06T20:40:25Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2005-01-06T20:40:25Z"}, "message": "fstream.tcc: Remove unnecessary qualifications for uglified data members of basic_filebuf...\n\n\n2005-01-06  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/fstream.tcc: Remove unnecessary qualifications for\n\tuglified data members of basic_filebuf, including _M_buf,\n\t_M_buf_size, _M_mode, _M_pback_init.\n\t* include/std/std_fstream.h: Same.\n\nFrom-SVN: r93006", "tree": {"sha": "1f2aeeb11ac0504a481da8ad996b1bcaef4918fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f2aeeb11ac0504a481da8ad996b1bcaef4918fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e3a00f544e678384844899cec3a636442e1517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e3a00f544e678384844899cec3a636442e1517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e3a00f544e678384844899cec3a636442e1517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e3a00f544e678384844899cec3a636442e1517/comments", "author": null, "committer": null, "parents": [{"sha": "0a57b6af88e980d07ea864645055607fa843b5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a57b6af88e980d07ea864645055607fa843b5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a57b6af88e980d07ea864645055607fa843b5d9"}], "stats": {"total": 75, "additions": 41, "deletions": 34}, "files": [{"sha": "8cce55dc5fe78822aa01eaa6e6403dccf1023f77", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a8e3a00f544e678384844899cec3a636442e1517", "patch": "@@ -1,3 +1,10 @@\n+2005-01-06  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/fstream.tcc: Remove unnecessary qualifications for\n+\tuglified data members of basic_filebuf, including _M_buf,\n+\t_M_buf_size, _M_mode, _M_pback_init.\n+\t* include/std/std_fstream.h: Same.\n+\t\n 2005-01-05  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/testsuite_hooks.h: "}, {"sha": "a9d157403fe6fb97c103608bd7158f8d75e94518", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=a8e3a00f544e678384844899cec3a636442e1517", "patch": "@@ -1,6 +1,6 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -51,9 +51,9 @@ namespace std\n     {\n       // Allocate internal buffer only if one doesn't already exist\n       // (either allocated or provided by the user via setbuf).\n-      if (!_M_buf_allocated && !this->_M_buf)\n+      if (!_M_buf_allocated && !_M_buf)\n \t{\n-\t  this->_M_buf = new char_type[this->_M_buf_size];\n+\t  _M_buf = new char_type[_M_buf_size];\n \t  _M_buf_allocated = true;\n \t}\n     }\n@@ -65,8 +65,8 @@ namespace std\n     {\n       if (_M_buf_allocated)\n \t{\n-\t  delete [] this->_M_buf;\n-\t  this->_M_buf = NULL;\n+\t  delete [] _M_buf;\n+\t  _M_buf = NULL;\n \t  _M_buf_allocated = false;\n \t}\n       delete [] _M_ext_buf;\n@@ -102,7 +102,7 @@ namespace std\n \t  if (this->is_open())\n \t    {\n \t      _M_allocate_internal_buffer();\n-\t      this->_M_mode = __mode;\n+\t      _M_mode = __mode;\n \n \t      // Setup initial buffer to 'uncommitted' mode.\n \t      _M_reading = false;\n@@ -142,8 +142,8 @@ namespace std\n \t    { __testfail = true; }\n \n \t  // NB: Do this here so that re-opened filebufs will be cool...\n-\t  this->_M_mode = ios_base::openmode(0);\n-\t  this->_M_pback_init = false;\n+\t  _M_mode = ios_base::openmode(0);\n+\t  _M_pback_init = false;\n \t  _M_destroy_internal_buffer();\n \t  _M_reading = false;\n \t  _M_writing = false;\n@@ -165,7 +165,7 @@ namespace std\n     showmanyc()\n     {\n       streamsize __ret = -1;\n-      const bool __testin = this->_M_mode & ios_base::in;\n+      const bool __testin = _M_mode & ios_base::in;\n       if (__testin && this->is_open())\n \t{\n \t  // For a stateful encoding (-1) the pending sequence might be just\n@@ -183,7 +183,7 @@ namespace std\n     underflow()\n     {\n       int_type __ret = traits_type::eof();\n-      const bool __testin = this->_M_mode & ios_base::in;\n+      const bool __testin = _M_mode & ios_base::in;\n       if (__testin && !_M_writing)\n \t{\n \t  // Check for pback madness, and if so swich back to the\n@@ -195,8 +195,8 @@ namespace std\n \t    return traits_type::to_int_type(*this->gptr());\n \n \t  // Get and convert input sequence.\n-\t  const size_t __buflen = this->_M_buf_size > 1\n-\t                          ? this->_M_buf_size - 1 : 1;\n+\t  const size_t __buflen = _M_buf_size > 1\n+\t                          ? _M_buf_size - 1 : 1;\n \n \t  // Will be set to true if ::read() returns 0 indicating EOF.\n \t  bool __got_eof = false;\n@@ -333,12 +333,12 @@ namespace std\n     pbackfail(int_type __i)\n     {\n       int_type __ret = traits_type::eof();\n-      const bool __testin = this->_M_mode & ios_base::in;\n+      const bool __testin = _M_mode & ios_base::in;\n       if (__testin && !_M_writing)\n \t{\n \t  // Remember whether the pback buffer is active, otherwise below\n \t  // we may try to store in it a second char (libstdc++/9761).\n-\t  const bool __testpb = this->_M_pback_init;\n+\t  const bool __testpb = _M_pback_init;\n \t  const bool __testeof = traits_type::eq_int_type(__i, __ret);\n \t  int_type __tmp;\n \t  if (this->eback() < this->gptr())\n@@ -386,7 +386,7 @@ namespace std\n     {\n       int_type __ret = traits_type::eof();\n       const bool __testeof = traits_type::eq_int_type(__c, __ret);\n-      const bool __testout = this->_M_mode & ios_base::out;\n+      const bool __testout = _M_mode & ios_base::out;\n       if (__testout && !_M_reading)\n \t{\n \t  if (this->pbase() < this->pptr())\n@@ -407,7 +407,7 @@ namespace std\n \t\t  __ret = traits_type::not_eof(__c);\n \t\t}\n \t    }\n-\t  else if (this->_M_buf_size > 1)\n+\t  else if (_M_buf_size > 1)\n \t    {\n \t      // Overflow in 'uncommitted' mode: set _M_writing, set\n \t      // the buffer to the initial 'write' mode, and put __c\n@@ -505,7 +505,7 @@ namespace std\n      {\n        // Clear out pback buffer before going on to the real deal...\n        streamsize __ret = 0;\n-       if (this->_M_pback_init)\n+       if (_M_pback_init)\n \t {\n \t   if (__n > 0 && this->gptr() == this->eback())\n \t     {\n@@ -520,8 +520,8 @@ namespace std\n        // Optimization in the always_noconv() case, to be generalized in the\n        // future: when __n > __buflen we read directly instead of using the\n        // buffer repeatedly.\n-       const bool __testin = this->_M_mode & ios_base::in;\n-       const streamsize __buflen = this->_M_buf_size > 1 ? this->_M_buf_size - 1\n+       const bool __testin = _M_mode & ios_base::in;\n+       const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1\n \t                                                 : 1;\n        if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()\n \t   && __testin && !_M_writing)\n@@ -575,7 +575,7 @@ namespace std\n        // future: when __n is sufficiently large we write directly instead of\n        // using the buffer.\n        streamsize __ret = 0;\n-       const bool __testout = this->_M_mode & ios_base::out;\n+       const bool __testout = _M_mode & ios_base::out;\n        if (__check_facet(_M_codecvt).always_noconv()\n \t   && __testout && !_M_reading)\n \t{\n@@ -584,8 +584,8 @@ namespace std\n \t  streamsize __bufavail = this->epptr() - this->pptr();\n \n \t  // Don't mistake 'uncommitted' mode buffered with unbuffered.\n-\t  if (!_M_writing && this->_M_buf_size > 1)\n-\t    __bufavail = this->_M_buf_size - 1;\n+\t  if (!_M_writing && _M_buf_size > 1)\n+\t    __bufavail = _M_buf_size - 1;\n \n \t  const streamsize __limit = std::min(__chunk, __bufavail);\n \t  if (__n >= __limit)\n@@ -620,7 +620,7 @@ namespace std\n     {\n       if (!this->is_open())\n \tif (__s == 0 && __n == 0)\n-\t  this->_M_buf_size = 1;\n+\t  _M_buf_size = 1;\n \telse if (__s && __n > 0)\n \t  {\n \t    // This is implementation-defined behavior, and assumes that\n@@ -631,8 +631,8 @@ namespace std\n \t    // position to host the overflow char of a full put area.\n \t    // When __n == 1, 1 position will be used for the get area\n \t    // and 0 for the put area, as in the unbuffered case above.\n-\t    this->_M_buf = __s;\n-\t    this->_M_buf_size = __n;\n+\t    _M_buf = __s;\n+\t    _M_buf_size = __n;\n \t  }\n       return this;\n     }\n@@ -831,7 +831,7 @@ namespace std\n \t\t    {\n \t\t      if (_M_codecvt_tmp\n \t\t\t  && !__check_facet(_M_codecvt_tmp).always_noconv())\n-\t\t\t__testvalid = this->seekoff(0, ios_base::cur, this->_M_mode)\n+\t\t\t__testvalid = this->seekoff(0, ios_base::cur, _M_mode)\n \t\t\t              != pos_type(off_type(-1));\n \t\t    }\n \t\t  else"}, {"sha": "ed119d4c8eab915fcb996267ea20fd0c75b55a42", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e3a00f544e678384844899cec3a636442e1517/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=a8e3a00f544e678384844899cec3a636442e1517", "patch": "@@ -1,6 +1,6 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -217,7 +217,7 @@ namespace std\n \t  {\n \t    // Length _M_in_cur moved in the pback buffer.\n \t    _M_pback_cur_save += this->gptr() != this->eback();\n-\t    this->setg(this->_M_buf, _M_pback_cur_save, _M_pback_end_save);\n+\t    this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);\n \t    _M_pback_init = false;\n \t  }\n       }\n@@ -374,16 +374,16 @@ namespace std\n       void\n       _M_set_buffer(streamsize __off)\n       {\n- \tconst bool __testin = this->_M_mode & ios_base::in;\n- \tconst bool __testout = this->_M_mode & ios_base::out;\n+ \tconst bool __testin = _M_mode & ios_base::in;\n+ \tconst bool __testout = _M_mode & ios_base::out;\n \t\n \tif (__testin && __off > 0)\n-\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);\n+\t  this->setg(_M_buf, _M_buf, _M_buf + __off);\n \telse\n-\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf);\n+\t  this->setg(_M_buf, _M_buf, _M_buf);\n \n-\tif (__testout && __off == 0 && this->_M_buf_size > 1 )\n-\t  this->setp(this->_M_buf, this->_M_buf + this->_M_buf_size - 1);\n+\tif (__testout && __off == 0 && _M_buf_size > 1 )\n+\t  this->setp(_M_buf, _M_buf + _M_buf_size - 1);\n \telse\n \t  this->setp(NULL, NULL);\n       }"}]}