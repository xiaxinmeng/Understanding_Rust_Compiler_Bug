{"sha": "82379bdf028762c0eafece56bd69a687d991765b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzNzliZGYwMjg3NjJjMGVhZmVjZTU2YmQ2OWE2ODdkOTkxNzY1Yg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2016-02-05T10:08:17Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2016-02-05T10:08:17Z"}, "message": "S/390: Fix r6 vararg handling.\n\nThis patch fixes a problem introduced with the GPR into FPR slot save\nfeature for leaf functions.\n\nr6 is argument register as well as call-saved.  Currently we might\ndecide that it will be a candidate for being saved into an FPR.  If it\nturns out later that r6 also needs to be saved due to being required\nfor vararg we undo the FPR save decision and put it on the stack\nagain.  Unfortunately the code did not adjust the GPR restore range\naccordingly so that the register does not get restored in the load\nmultiple.\n\nThis fixes the following testcases on s390x:\n\n< FAIL: libgomp.c/doacross-1.c execution test\n< FAIL: libgomp.c/doacross-2.c execution test\n< FAIL: libgomp.c/doacross-3.c execution test\n< FAIL: libgomp.c++/doacross-1.C execution test\n\ngcc/ChangeLog:\n\n2016-02-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t    PR target/69625\n\t    * config/s390/s390.c (SAVE_SLOT_NONE, SAVE_SLOT_STACK): New\n\t    defines.\n\t    (s390_register_info_gprtofpr): Use new macros above.\n\t    (s390_register_info_stdarg_fpr): Adjust max_fpr to better match\n\t    its name.\n\t    (s390_register_info_stdarg_gpr): Adjust max_gpr to better match\n\t    its name.  Adjust restore and save gpr ranges.\n\t    (s390_register_info_set_ranges): New function.\n\t    (s390_register_info): Use new macros above.  Call\n\t    s390_register_info_set_ranges.\n\t    (s390_optimize_register_info): Likewise.\n\t    (s390_hard_regno_rename_ok): Use new macros.\n\t    (s390_hard_regno_scratch_ok): Likewise.\n\t    (s390_emit_epilogue): Likewise.\n\t    (s390_can_use_return_insn): Likewise.\n\t    (s390_optimize_prologue): Likewise.\n\t    * config/s390/s390.md (GPR2_REGNUM, GPR6_REGNUM): New constants.\n\nFrom-SVN: r233168", "tree": {"sha": "9291a93ed65dac84d6043d81213cfd6782ed08f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9291a93ed65dac84d6043d81213cfd6782ed08f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82379bdf028762c0eafece56bd69a687d991765b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82379bdf028762c0eafece56bd69a687d991765b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82379bdf028762c0eafece56bd69a687d991765b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82379bdf028762c0eafece56bd69a687d991765b/comments", "author": null, "committer": null, "parents": [{"sha": "5421e2cab2e132f51d227a4c643eee4e764d7969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5421e2cab2e132f51d227a4c643eee4e764d7969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5421e2cab2e132f51d227a4c643eee4e764d7969"}], "stats": {"total": 162, "additions": 111, "deletions": 51}, "files": [{"sha": "3ce09b6b8bf6a2c5eb156b4c9a97e96fd1cac5b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82379bdf028762c0eafece56bd69a687d991765b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82379bdf028762c0eafece56bd69a687d991765b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82379bdf028762c0eafece56bd69a687d991765b", "patch": "@@ -1,3 +1,24 @@\n+2016-02-05  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\tPR target/69625\n+\t* config/s390/s390.c (SAVE_SLOT_NONE, SAVE_SLOT_STACK): New\n+\tdefines.\n+\t(s390_register_info_gprtofpr): Use new macros above.\n+\t(s390_register_info_stdarg_fpr): Adjust max_fpr to better match\n+\tits name.\n+\t(s390_register_info_stdarg_gpr): Adjust max_gpr to better match\n+\tits name.  Adjust restore and save gpr ranges.\n+\t(s390_register_info_set_ranges): New function.\n+\t(s390_register_info): Use new macros above.  Call\n+\ts390_register_info_set_ranges.\n+\t(s390_optimize_register_info): Likewise.\n+\t(s390_hard_regno_rename_ok): Use new macros.\n+\t(s390_hard_regno_scratch_ok): Likewise.\n+\t(s390_emit_epilogue): Likewise.\n+\t(s390_can_use_return_insn): Likewise.\n+\t(s390_optimize_prologue): Likewise.\n+\t* config/s390/s390.md (GPR2_REGNUM, GPR6_REGNUM): New constants.\n+\n 2016-02-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/69677"}, {"sha": "1667c115f41ea90f757c2ad010d411f099f4861a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 88, "deletions": 51, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82379bdf028762c0eafece56bd69a687d991765b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82379bdf028762c0eafece56bd69a687d991765b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=82379bdf028762c0eafece56bd69a687d991765b", "patch": "@@ -380,6 +380,8 @@ struct GTY (()) s390_frame_layout\n      be saved to.\n       0 - does not need to be saved at all\n      -1 - stack slot  */\n+#define SAVE_SLOT_NONE   0\n+#define SAVE_SLOT_STACK -1\n   signed char gpr_save_slots[16];\n \n   /* Number of first and last gpr to be saved, restored.  */\n@@ -9198,7 +9200,7 @@ s390_register_info_gprtofpr ()\n \n   for (i = 15; i >= 6; i--)\n     {\n-      if (cfun_gpr_save_slot (i) == 0)\n+      if (cfun_gpr_save_slot (i) == SAVE_SLOT_NONE)\n \tcontinue;\n \n       /* Advance to the next FP register which can be used as a\n@@ -9215,7 +9217,7 @@ s390_register_info_gprtofpr ()\n \t     case we ran out of FPR save slots.  */\n \t  for (j = 6; j <= 15; j++)\n \t    if (FP_REGNO_P (cfun_gpr_save_slot (j)))\n-\t      cfun_gpr_save_slot (j) = -1;\n+\t      cfun_gpr_save_slot (j) = SAVE_SLOT_STACK;\n \t  break;\n \t}\n       cfun_gpr_save_slot (i) = save_reg_slot++;\n@@ -9242,12 +9244,16 @@ s390_register_info_stdarg_fpr ()\n     return;\n \n   min_fpr = crtl->args.info.fprs;\n-  max_fpr = min_fpr + cfun->va_list_fpr_size;\n-  if (max_fpr > FP_ARG_NUM_REG)\n-    max_fpr = FP_ARG_NUM_REG;\n+  max_fpr = min_fpr + cfun->va_list_fpr_size - 1;\n+  if (max_fpr >= FP_ARG_NUM_REG)\n+    max_fpr = FP_ARG_NUM_REG - 1;\n \n-  for (i = min_fpr; i < max_fpr; i++)\n-    cfun_set_fpr_save (i + FPR0_REGNUM);\n+  /* FPR argument regs start at f0.  */\n+  min_fpr += FPR0_REGNUM;\n+  max_fpr += FPR0_REGNUM;\n+\n+  for (i = min_fpr; i <= max_fpr; i++)\n+    cfun_set_fpr_save (i);\n }\n \n /* Reserve the GPR save slots for GPRs which need to be saved due to\n@@ -9267,12 +9273,65 @@ s390_register_info_stdarg_gpr ()\n     return;\n \n   min_gpr = crtl->args.info.gprs;\n-  max_gpr = min_gpr + cfun->va_list_gpr_size;\n-  if (max_gpr > GP_ARG_NUM_REG)\n-    max_gpr = GP_ARG_NUM_REG;\n+  max_gpr = min_gpr + cfun->va_list_gpr_size - 1;\n+  if (max_gpr >= GP_ARG_NUM_REG)\n+    max_gpr = GP_ARG_NUM_REG - 1;\n+\n+  /* GPR argument regs start at r2.  */\n+  min_gpr += GPR2_REGNUM;\n+  max_gpr += GPR2_REGNUM;\n+\n+  /* If r6 was supposed to be saved into an FPR and now needs to go to\n+     the stack for vararg we have to adjust the restore range to make\n+     sure that the restore is done from stack as well.  */\n+  if (FP_REGNO_P (cfun_gpr_save_slot (GPR6_REGNUM))\n+      && min_gpr <= GPR6_REGNUM\n+      && max_gpr >= GPR6_REGNUM)\n+    {\n+      if (cfun_frame_layout.first_restore_gpr == -1\n+\t  || cfun_frame_layout.first_restore_gpr > GPR6_REGNUM)\n+\tcfun_frame_layout.first_restore_gpr = GPR6_REGNUM;\n+      if (cfun_frame_layout.last_restore_gpr == -1\n+\t  || cfun_frame_layout.last_restore_gpr < GPR6_REGNUM)\n+\tcfun_frame_layout.last_restore_gpr = GPR6_REGNUM;\n+    }\n+\n+  if (cfun_frame_layout.first_save_gpr == -1\n+      || cfun_frame_layout.first_save_gpr > min_gpr)\n+    cfun_frame_layout.first_save_gpr = min_gpr;\n+\n+  if (cfun_frame_layout.last_save_gpr == -1\n+      || cfun_frame_layout.last_save_gpr < max_gpr)\n+    cfun_frame_layout.last_save_gpr = max_gpr;\n \n-  for (i = min_gpr; i < max_gpr; i++)\n-    cfun_gpr_save_slot (2 + i) = -1;\n+  for (i = min_gpr; i <= max_gpr; i++)\n+    cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;\n+}\n+\n+/* Calculate the save and restore ranges for stm(g) and lm(g) in the\n+   prologue and epilogue.  */\n+\n+static void\n+s390_register_info_set_ranges ()\n+{\n+  int i, j;\n+\n+  /* Find the first and the last save slot supposed to use the stack\n+     to set the restore range.\n+     Vararg regs might be marked as save to stack but only the\n+     call-saved regs really need restoring (i.e. r6).  This code\n+     assumes that the vararg regs have not yet been recorded in\n+     cfun_gpr_save_slot.  */\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != SAVE_SLOT_STACK; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != SAVE_SLOT_STACK; j--);\n+  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;\n+\n+  /* Now the range of GPRs which need saving.  */\n+  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != SAVE_SLOT_STACK; i++);\n+  for (j = 15; j > i && cfun_gpr_save_slot (j) != SAVE_SLOT_STACK; j--);\n+  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;\n+  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;\n }\n \n /* The GPR and FPR save slots in cfun->machine->frame_layout are set\n@@ -9283,7 +9342,7 @@ s390_register_info_stdarg_gpr ()\n static void\n s390_register_info ()\n {\n-  int i, j;\n+  int i;\n   char clobbered_regs[32];\n \n   gcc_assert (!epilogue_completed);\n@@ -9347,33 +9406,20 @@ s390_register_info ()\n \t|| (reload_completed && cfun_frame_layout.frame_size > 0)\n \t|| cfun->calls_alloca);\n \n-  memset (cfun_frame_layout.gpr_save_slots, 0, 16);\n+  memset (cfun_frame_layout.gpr_save_slots, SAVE_SLOT_NONE, 16);\n \n   for (i = 6; i < 16; i++)\n     if (clobbered_regs[i])\n-      cfun_gpr_save_slot (i) = -1;\n+      cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;\n \n   s390_register_info_stdarg_fpr ();\n   s390_register_info_gprtofpr ();\n-\n-  /* First find the range of GPRs to be restored.  Vararg regs don't\n-     need to be restored so we do it before assigning slots to the\n-     vararg GPRs.  */\n-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n-  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;\n-  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;\n-\n+  s390_register_info_set_ranges ();\n   /* stdarg functions might need to save GPRs 2 to 6.  This might\n-     override the GPR->FPR save decision made above for r6 since\n-     vararg regs must go to the stack.  */\n+     override the GPR->FPR save decision made by\n+     s390_register_info_gprtofpr for r6 since vararg regs must go to\n+     the stack.  */\n   s390_register_info_stdarg_gpr ();\n-\n-  /* Now the range of GPRs which need saving.  */\n-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n-  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;\n-  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;\n }\n \n /* This function is called by s390_optimize_prologue in order to get\n@@ -9384,7 +9430,7 @@ static void\n s390_optimize_register_info ()\n {\n   char clobbered_regs[32];\n-  int i, j;\n+  int i;\n \n   gcc_assert (epilogue_completed);\n   gcc_assert (!cfun->machine->split_branches_pending_p);\n@@ -9407,23 +9453,14 @@ s390_optimize_register_info ()\n \t|| cfun_frame_layout.save_return_addr_p\n \t|| crtl->calls_eh_return);\n \n-  memset (cfun_frame_layout.gpr_save_slots, 0, 6);\n+  memset (cfun_frame_layout.gpr_save_slots, SAVE_SLOT_NONE, 6);\n \n   for (i = 6; i < 16; i++)\n     if (!clobbered_regs[i])\n-      cfun_gpr_save_slot (i) = 0;\n-\n-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n-  cfun_frame_layout.first_restore_gpr = (i == 16) ? -1 : i;\n-  cfun_frame_layout.last_restore_gpr = (i == 16) ? -1 : j;\n+      cfun_gpr_save_slot (i) = SAVE_SLOT_NONE;\n \n+  s390_register_info_set_ranges ();\n   s390_register_info_stdarg_gpr ();\n-\n-  for (i = 0; i < 16 && cfun_gpr_save_slot (i) != -1; i++);\n-  for (j = 15; j > i && cfun_gpr_save_slot (j) != -1; j--);\n-  cfun_frame_layout.first_save_gpr = (i == 16) ? -1 : i;\n-  cfun_frame_layout.last_save_gpr = (i == 16) ? -1 : j;\n }\n \n /* Fill cfun->machine with info about frame of current function.  */\n@@ -9844,7 +9881,7 @@ s390_hard_regno_rename_ok (unsigned int old_reg, unsigned int new_reg)\n      regrename manually about it.  */\n   if (GENERAL_REGNO_P (new_reg)\n       && !call_really_used_regs[new_reg]\n-      && cfun_gpr_save_slot (new_reg) == 0)\n+      && cfun_gpr_save_slot (new_reg) == SAVE_SLOT_NONE)\n     return false;\n \n   return true;\n@@ -9859,7 +9896,7 @@ s390_hard_regno_scratch_ok (unsigned int regno)\n   /* See s390_hard_regno_rename_ok.  */\n   if (GENERAL_REGNO_P (regno)\n       && !call_really_used_regs[regno]\n-      && cfun_gpr_save_slot (regno) == 0)\n+      && cfun_gpr_save_slot (regno) == SAVE_SLOT_NONE)\n     return false;\n \n   return true;\n@@ -10875,7 +10912,7 @@ s390_emit_epilogue (bool sibcall)\n \t     be in between two GPRs which need saving.)  Otherwise it\n \t     would be difficult to take that decision back in\n \t     s390_optimize_prologue.  */\n-\t  if (cfun_gpr_save_slot (RETURN_REGNUM) == -1)\n+\t  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)\n \t    {\n \t      int return_regnum = find_unused_clobbered_reg();\n \t      if (!return_regnum)\n@@ -10969,7 +11006,7 @@ s390_can_use_return_insn (void)\n     return false;\n \n   for (i = 0; i < 16; i++)\n-    if (cfun_gpr_save_slot (i))\n+    if (cfun_gpr_save_slot (i) != SAVE_SLOT_NONE)\n       return false;\n \n   /* For 31 bit this is not covered by the frame_size check below\n@@ -12677,9 +12714,9 @@ s390_optimize_prologue (void)\n \n \t  /* It must not happen that what we once saved in an FPR now\n \t     needs a stack slot.  */\n-\t  gcc_assert (cfun_gpr_save_slot (gpr_regno) != -1);\n+\t  gcc_assert (cfun_gpr_save_slot (gpr_regno) != SAVE_SLOT_STACK);\n \n-\t  if (cfun_gpr_save_slot (gpr_regno) == 0)\n+\t  if (cfun_gpr_save_slot (gpr_regno) == SAVE_SLOT_NONE)\n \t    {\n \t      remove_insn (insn);\n \t      continue;"}, {"sha": "ccedeadbc604e8dfa5e5fdf549d20866ffa2ff7d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82379bdf028762c0eafece56bd69a687d991765b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82379bdf028762c0eafece56bd69a687d991765b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=82379bdf028762c0eafece56bd69a687d991765b", "patch": "@@ -305,6 +305,8 @@\n    ; General purpose registers\n    (GPR0_REGNUM                  0)\n    (GPR1_REGNUM                  1)\n+   (GPR2_REGNUM                  2)\n+   (GPR6_REGNUM                  6)\n    ; Floating point registers.\n    (FPR0_REGNUM                 16)\n    (FPR1_REGNUM                 20)"}]}