{"sha": "12f0783111067b68673284665a886cdd0c8f55c3", "node_id": "C_kwDOANBUbNoAKDEyZjA3ODMxMTEwNjdiNjg2NzMyODQ2NjVhODg2Y2RkMGM4ZjU1YzM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-06T09:56:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-06T11:41:18Z"}, "message": "Fix use predicate computation for uninit analysis\n\nIn uninit analysis we try to prove that a use is always properly guarded\nso it is never reached when the used value is not initialized.  This\nfails to be conservative when during the computation of the use\npredicate components of the || .. || .. chain are dropped so we have\nto detect this case and fall back to the conservative computation.\n\n\t* gimple-predicate-analysis.cc (compute_control_dep_chain):\n\tAdd output flag to indicate whether we possibly have dropped\n\tany chains.  Return whether the info is complete from the\n\twrapping overload.\n\t(uninit_analysis::init_use_preds): Adjust accordingly, with\n\ta workaround for PR106754.\n\t(uninit_analysis::init_from_phi_def): Properly guard the\n\tcase where we complete an empty chain.", "tree": {"sha": "ca88b345502522d3648ae64bc1db08f3bb52f2fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca88b345502522d3648ae64bc1db08f3bb52f2fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12f0783111067b68673284665a886cdd0c8f55c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f0783111067b68673284665a886cdd0c8f55c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f0783111067b68673284665a886cdd0c8f55c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f0783111067b68673284665a886cdd0c8f55c3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "190c644c06369766aa2537851ddbf83b1231b65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190c644c06369766aa2537851ddbf83b1231b65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190c644c06369766aa2537851ddbf83b1231b65b"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "ac34b7007a60b0ce539f6c2bc274b3321a5b128b", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12f0783111067b68673284665a886cdd0c8f55c3/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12f0783111067b68673284665a886cdd0c8f55c3/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=12f0783111067b68673284665a886cdd0c8f55c3", "patch": "@@ -990,13 +990,16 @@ dfs_mark_dominating_region (edge exit, basic_block dom, int flag,\n    *NUM_CALLS is the number of recursive calls to control unbounded\n    recursion.\n    Return true if the information is successfully computed, false if\n-   there is no control dependence or not computed.  */\n+   there is no control dependence or not computed.\n+   *COMPLETE_P is set to false if we stopped walking due to limits.\n+   In this case there might be missing chains.  */\n \n static bool\n compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t\t\t   vec<edge> cd_chains[], unsigned *num_chains,\n \t\t\t   vec<edge> &cur_cd_chain, unsigned *num_calls,\n-\t\t\t   unsigned in_region = 0, unsigned depth = 0)\n+\t\t\t   unsigned in_region, unsigned depth,\n+\t\t\t   bool *complete_p)\n {\n   /* In our recursive calls this doesn't happen.  */\n   if (single_succ_p (dom_bb))\n@@ -1009,6 +1012,7 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n       if (dump_file)\n \tfprintf (dump_file, \"MAX_CHAIN_LEN exceeded: %u\\n\", cur_chain_len);\n \n+      *complete_p = false;\n       return false;\n     }\n \n@@ -1077,6 +1081,7 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"param_uninit_control_dep_attempts \"\n \t\t\t \"exceeded: %u\\n\", *num_calls);\n+\t      *complete_p = false;\n \t      break;\n \t    }\n \t  ++*num_calls;\n@@ -1085,7 +1090,8 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t  if (!single_succ_p (cd_bb)\n \t      && compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n \t\t\t\t\t    num_chains, cur_cd_chain,\n-\t\t\t\t\t    num_calls, in_region, depth + 1))\n+\t\t\t\t\t    num_calls, in_region, depth + 1,\n+\t\t\t\t\t    complete_p))\n \t    {\n \t      found_cd_chain = true;\n \t      break;\n@@ -1109,6 +1115,9 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n   return found_cd_chain;\n }\n \n+/* Wrapper around the compute_control_dep_chain worker above.  Returns\n+   true when the collected set of chains in CD_CHAINS is complete.  */\n+\n static bool\n compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \t\t\t   vec<edge> cd_chains[], unsigned *num_chains,\n@@ -1117,8 +1126,11 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n   auto_vec<edge, MAX_CHAIN_LEN + 1> cur_cd_chain;\n   unsigned num_calls = 0;\n   unsigned depth = 0;\n-  return compute_control_dep_chain (dom_bb, dep_bb, cd_chains, num_chains,\n-\t\t\t\t    cur_cd_chain, &num_calls, in_region, depth);\n+  bool complete_p = true;\n+  compute_control_dep_chain (dom_bb, dep_bb, cd_chains, num_chains,\n+\t\t\t     cur_cd_chain, &num_calls, in_region, depth,\n+\t\t\t     &complete_p);\n+  return complete_p;\n }\n \n /* Implemented simplifications:\n@@ -1888,6 +1900,10 @@ bool\n uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n \t\t\t\t basic_block use_bb)\n {\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    fprintf (dump_file, \"init_use_preds (def_bb = %u, use_bb = %u)\\n\",\n+\t     def_bb->index, use_bb->index);\n+\n   gcc_assert (use_preds.is_empty ()\n \t      && dominated_by_p (CDI_DOMINATORS, use_bb, def_bb));\n \n@@ -1919,17 +1935,20 @@ uninit_analysis::init_use_preds (predicate &use_preds, basic_block def_bb,\n   unsigned num_chains = 0;\n   auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n \n-  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains))\n+  if (!compute_control_dep_chain (cd_root, use_bb, dep_chains, &num_chains)\n+      /* ???  Workaround PR106754.  */\n+      || num_chains == 0)\n     {\n-      gcc_assert (num_chains == 0);\n+      /* If the info in dep_chains is not complete we need to use a\n+\t conservative approximation for the use predicate.  */\n+      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+\tfprintf (dump_file, \"init_use_preds: dep_chain incomplete, using \"\n+\t\t \"conservative approximation\\n\");\n+      num_chains = 1;\n+      dep_chains[0].truncate (0);\n       simple_control_dep_chain (dep_chains[0], cd_root, use_bb);\n-      num_chains++;\n     }\n \n-  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n-    fprintf (dump_file, \"init_use_preds (def_bb = %u, use_bb = %u)\\n\",\n-\t     def_bb->index, use_bb->index);\n-\n   /* From the set of edges computed above initialize *THIS as the OR\n      condition under which the definition in DEF_BB is used in USE_BB.\n      Each OR subexpression is represented by one element of DEP_CHAINS,\n@@ -2021,13 +2040,18 @@ uninit_analysis::init_from_phi_def (gphi *phi)\n     {\n       edge e = def_edges[i];\n       unsigned prev_nc = num_chains;\n-      compute_control_dep_chain (cd_root, e->src, dep_chains,\n-\t\t\t\t &num_chains, in_region);\n+      bool complete_p = compute_control_dep_chain (cd_root, e->src, dep_chains,\n+\t\t\t\t\t\t   &num_chains, in_region);\n \n       /* Update the newly added chains with the phi operand edge.  */\n       if (EDGE_COUNT (e->src->succs) > 1)\n \t{\n-\t  if (prev_nc == num_chains && num_chains < MAX_NUM_CHAINS)\n+\t  if (complete_p\n+\t      && prev_nc == num_chains\n+\t      && num_chains < MAX_NUM_CHAINS)\n+\t    /* We can only add a chain for the PHI operand edge when the\n+\t       collected info was complete, otherwise the predicate may\n+\t       not be conservative.  */\n \t    dep_chains[num_chains++] = vNULL;\n \t  for (unsigned j = prev_nc; j < num_chains; j++)\n \t    dep_chains[j].safe_push (e);"}]}