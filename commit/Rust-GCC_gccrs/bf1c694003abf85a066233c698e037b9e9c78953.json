{"sha": "bf1c694003abf85a066233c698e037b9e9c78953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxYzY5NDAwM2FiZjg1YTA2NjIzM2M2OThlMDM3YjllOWM3ODk1Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-27T16:55:54Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-27T16:55:54Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r841", "tree": {"sha": "f12fcbcc9c8b98a3453cc551b29a54105afa50ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f12fcbcc9c8b98a3453cc551b29a54105afa50ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf1c694003abf85a066233c698e037b9e9c78953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1c694003abf85a066233c698e037b9e9c78953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf1c694003abf85a066233c698e037b9e9c78953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf1c694003abf85a066233c698e037b9e9c78953/comments", "author": null, "committer": null, "parents": [{"sha": "a87104d913a70d59e0641e9a68a88f3cd8671b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87104d913a70d59e0641e9a68a88f3cd8671b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87104d913a70d59e0641e9a68a88f3cd8671b9d"}], "stats": {"total": 30, "additions": 14, "deletions": 16}, "files": [{"sha": "b5a07fa0687989fbfe96dcdc29bbba0106e00da1", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=bf1c694003abf85a066233c698e037b9e9c78953", "patch": "@@ -519,7 +519,8 @@ find_basic_blocks (f, nonlocal_label_list)\n \tif (GET_CODE (insn) == JUMP_INSN\n \t    && GET_CODE (PATTERN (insn)) == SET\n \t    && SET_DEST (PATTERN (insn)) == pc_rtx\n-\t    && GET_CODE (SET_SRC (PATTERN (insn))) == REG)\n+\t    && (GET_CODE (SET_SRC (PATTERN (insn))) == REG\n+\t\t|| GET_CODE (SET_SRC (PATTERN (insn))) == MEM))\n \t  {\n \t    rtx x;\n \t    for (x = label_value_list; x; x = XEXP (x, 1))"}, {"sha": "74a6026c8d3905f39b1c54b64005f9cfcc7cae5c", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=bf1c694003abf85a066233c698e037b9e9c78953", "patch": "@@ -467,6 +467,7 @@ print_node (file, prefix, node, indent)\n \tcase BIND_EXPR:\n \t  print_node (file, \"vars\", TREE_OPERAND (node, 0), indent + 4);\n \t  print_node (file, \"body\", TREE_OPERAND (node, 1), indent + 4);\n+\t  print_node (file, \"block\", TREE_OPERAND (node, 2), indent + 4);\n \t  return;\n \t}\n "}, {"sha": "f4719e3de723eca3c540990567d36c57a06b68c3", "filename": "gcc/unroll.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf1c694003abf85a066233c698e037b9e9c78953/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=bf1c694003abf85a066233c698e037b9e9c78953", "patch": "@@ -2435,25 +2435,21 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \n       if (v->new_reg)\n \t{\n-\t  /* If the giv is an address destination, it could be something other\n-\t     than a simple register, these have to be treated differently.  */\n-\t  if (v->giv_type == DEST_REG)\n-\t    splittable_regs[REGNO (v->new_reg)] = value;\n-\n-\t  /* If an addr giv was combined with another addr giv, then we\n-\t     can only split this giv if the addr giv it was combined with\n-\t     was reduced.  This is because the value of v->new_reg is\n-\t     meaningless in this case.  (There is no problem if it was\n-\t     combined with a dest_reg giv which wasn't reduced, v->new_reg\n-\t     is still meaningful in this case.)  */\n-\n-\t  else if (v->same && v->same->giv_type == DEST_ADDR\n-\t\t  && ! v->same->new_reg) \n+\t  /* If a giv was combined with another giv, then we can only split\n+\t     this giv if the giv it was combined with was reduced.  This\n+\t     is because the value of v->new_reg is meaningless in this\n+\t     case.  */\n+\t  if (v->same && ! v->same->new_reg)\n \t    {\n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream,\n-\t\t\t \"DEST_ADDR giv not split, because combined with unreduced DEST_ADDR giv.\\n\");\n+\t\t\t \"giv combined with unreduced giv not split.\\n\");\n+\t      continue;\n \t    }\n+\t  /* If the giv is an address destination, it could be something other\n+\t     than a simple register, these have to be treated differently.  */\n+\t  else if (v->giv_type == DEST_REG)\n+\t    splittable_regs[REGNO (v->new_reg)] = value;\n \t  else\n \t    {\n \t      /* Splitting address givs is useful since it will often allow us"}]}