{"sha": "1565af083011ebc0469a3df4f93350ce1eecf20a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2NWFmMDgzMDExZWJjMDQ2OWEzZGY0ZjkzMzUwY2UxZWVjZjIwYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-06-30T14:03:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-06-30T14:03:25Z"}, "message": "opts.c (finish_options): Do not disable IPA-PTA during ltrans.\n\n2011-06-30  Richard Guenther  <rguenther@suse.de>\n\n\t* opts.c (finish_options): Do not disable IPA-PTA during ltrans.\n\t* tree-ssa-structalias.c (create_variable_info_for): Do not\n\tadd initial constraints for non-var-decls.  Properly handle\n\tglobals in other ltrans partitions.\n\t(intra_create_variable_infos): Manually create constraints for\n\tthe fake no-alias parameter.\n\t(ipa_pta_execute): Dump the cgraph, handle ltrans partitions properly\n\tand assert there are no clones.\n\nFrom-SVN: r175707", "tree": {"sha": "283d02d137114cb2d153800d6261b8ae89987166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/283d02d137114cb2d153800d6261b8ae89987166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1565af083011ebc0469a3df4f93350ce1eecf20a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1565af083011ebc0469a3df4f93350ce1eecf20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1565af083011ebc0469a3df4f93350ce1eecf20a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1565af083011ebc0469a3df4f93350ce1eecf20a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42373e0b05c26d047925387d71fa833540dad8f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42373e0b05c26d047925387d71fa833540dad8f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42373e0b05c26d047925387d71fa833540dad8f0"}], "stats": {"total": 106, "additions": 69, "deletions": 37}, "files": [{"sha": "d0e48227c77978ea4b7ab221f9769bf00933fdb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1565af083011ebc0469a3df4f93350ce1eecf20a", "patch": "@@ -1,3 +1,14 @@\n+2011-06-30  Richard Guenther  <rguenther@suse.de>\n+\n+\t* opts.c (finish_options): Do not disable IPA-PTA during ltrans.\n+\t* tree-ssa-structalias.c (create_variable_info_for): Do not\n+\tadd initial constraints for non-var-decls.  Properly handle\n+\tglobals in other ltrans partitions.\n+\t(intra_create_variable_infos): Manually create constraints for\n+\tthe fake no-alias parameter.\n+\t(ipa_pta_execute): Dump the cgraph, handle ltrans partitions properly\n+\tand assert there are no clones.\n+\n 2011-06-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46787"}, {"sha": "59e8910f18c828196c5bfcfdc9981ad500ae9517", "filename": "gcc/opts.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1565af083011ebc0469a3df4f93350ce1eecf20a", "patch": "@@ -766,11 +766,6 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       maybe_set_param_value (PARAM_STACK_FRAME_GROWTH, 40,\n \t\t\t     opts->x_param_values, opts_set->x_param_values);\n     }\n-  if (opts->x_flag_wpa || opts->x_flag_ltrans)\n-    {\n-      /* These passes are not WHOPR compatible yet.  */\n-      opts->x_flag_ipa_pta = 0;\n-    }\n \n   if (opts->x_flag_lto)\n     {"}, {"sha": "6a9732fa1800160f8add5c59166763302f55a93b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1565af083011ebc0469a3df4f93350ce1eecf20a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=1565af083011ebc0469a3df4f93350ce1eecf20a", "patch": "@@ -5450,6 +5450,9 @@ create_variable_info_for (tree decl, const char *name)\n \n   insert_vi_for_tree (decl, vi);\n \n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return id;\n+\n   /* Create initial constraints for globals.  */\n   for (; vi; vi = vi->next)\n     {\n@@ -5463,37 +5466,44 @@ create_variable_info_for (tree decl, const char *name)\n \t  || vi->only_restrict_pointers)\n \tmake_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n \n-      /* For escaped variables initialize them from nonlocal.  */\n+      /* In non-IPA mode the initializer from nonlocal is all we need.  */\n       if (!in_ipa_mode\n-\t  || DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n+\t  || DECL_HARD_REGISTER (decl))\n \tmake_copy_constraint (vi, nonlocal_id);\n \n-      /* If this is a global variable with an initializer and we are in\n-\t IPA mode generate constraints for it.  In non-IPA mode\n-\t the initializer from nonlocal is all we need.  */\n-      if (in_ipa_mode\n-\t  && DECL_INITIAL (decl))\n+      else\n \t{\n-\t  VEC (ce_s, heap) *rhsc = NULL;\n-\t  struct constraint_expr lhs, *rhsp;\n-\t  unsigned i;\n-\t  get_constraint_for_rhs (DECL_INITIAL (decl), &rhsc);\n-\t  lhs.var = vi->id;\n-\t  lhs.offset = 0;\n-\t  lhs.type = SCALAR;\n-\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n-\t    process_constraint (new_constraint (lhs, *rhsp));\n-\t  /* If this is a variable that escapes from the unit\n-\t     the initializer escapes as well.  */\n-\t  if (DECL_EXTERNAL (decl) || TREE_PUBLIC (decl))\n+\t  struct varpool_node *vnode = varpool_get_node (decl);\n+\n+\t  /* For escaped variables initialize them from nonlocal.  */\n+\t  if (!varpool_all_refs_explicit_p (vnode))\n+\t    make_copy_constraint (vi, nonlocal_id);\n+\n+\t  /* If this is a global variable with an initializer and we are in\n+\t     IPA mode generate constraints for it.  */\n+\t  if (DECL_INITIAL (decl))\n \t    {\n-\t      lhs.var = escaped_id;\n+\t      VEC (ce_s, heap) *rhsc = NULL;\n+\t      struct constraint_expr lhs, *rhsp;\n+\t      unsigned i;\n+\t      get_constraint_for_rhs (DECL_INITIAL (decl), &rhsc);\n+\t      lhs.var = vi->id;\n \t      lhs.offset = 0;\n \t      lhs.type = SCALAR;\n \t      FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n+\t      /* If this is a variable that escapes from the unit\n+\t\t the initializer escapes as well.  */\n+\t      if (!varpool_all_refs_explicit_p (vnode))\n+\t\t{\n+\t\t  lhs.var = escaped_id;\n+\t\t  lhs.offset = 0;\n+\t\t  lhs.type = SCALAR;\n+\t\t  FOR_EACH_VEC_ELT (ce_s, rhsc, i, rhsp)\n+\t\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t\t}\n+\t      VEC_free (ce_s, heap, rhsc);\n \t    }\n-\t  VEC_free (ce_s, heap, rhsc);\n \t}\n     }\n \n@@ -5557,7 +5567,8 @@ intra_create_variable_infos (void)\n \t  varinfo_t vi;\n \t  tree heapvar = build_fake_var_decl (TREE_TYPE (TREE_TYPE (t)));\n \t  DECL_EXTERNAL (heapvar) = 1;\n-\t  vi = get_varinfo (create_variable_info_for (heapvar, \"PARM_NOALIAS\"));\n+\t  vi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\");\n+\t  insert_vi_for_tree (heapvar, vi);\n \t  lhsc.var = get_vi_for_tree (t)->id;\n \t  lhsc.type = SCALAR;\n \t  lhsc.offset = 0;\n@@ -5566,6 +5577,13 @@ intra_create_variable_infos (void)\n \t  rhsc.offset = 0;\n \t  process_constraint (new_constraint (lhsc, rhsc));\n \t  vi->is_restrict_var = 1;\n+\t  for (; vi; vi = vi->next)\n+\t    if (vi->may_have_pointers)\n+\t      {\n+\t\tif (vi->only_restrict_pointers)\n+\t\t  make_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n+\t\tmake_copy_constraint (vi, nonlocal_id);\n+\t      }\n \t  continue;\n \t}\n \n@@ -6744,17 +6762,24 @@ ipa_pta_execute (void)\n \n   init_alias_vars ();\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      dump_cgraph (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n   /* Build the constraints.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       varinfo_t vi;\n       /* Nodes without a body are not interesting.  Especially do not\n          visit clones at this point for now - we get duplicate decls\n \t there for inline clones at least.  */\n-      if (!cgraph_function_with_gimple_body_p (node)\n-\t  || node->clone_of)\n+      if (!cgraph_function_with_gimple_body_p (node))\n \tcontinue;\n \n+      gcc_assert (!node->clone_of);\n+\n       vi = create_function_info_for (node->decl,\n \t\t\t             alias_get_name (node->decl));\n       cgraph_for_node_and_aliases (node, associate_varinfo_to_alias, vi, true);\n@@ -6785,8 +6810,7 @@ ipa_pta_execute (void)\n       tree old_func_decl;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node)\n-\t  || node->clone_of)\n+      if (!cgraph_function_with_gimple_body_p (node))\n \tcontinue;\n \n       if (dump_file)\n@@ -6804,11 +6828,14 @@ ipa_pta_execute (void)\n       push_cfun (func);\n       current_function_decl = node->decl;\n \n-      if (node->local.externally_visible)\n+      /* For externally visible or attribute used annotated functions use\n+\t local constraints for their arguments.\n+\t For local functions we see all callers and thus do not need initial\n+\t constraints for parameters.  */\n+      if (node->reachable_from_other_partition\n+\t  || node->local.externally_visible\n+\t  || node->needed)\n \t{\n-\t  /* For externally visible functions use local constraints for\n-\t     their arguments.  For local functions we see all callers\n-\t     and thus do not need initial constraints for parameters.  */\n \t  intra_create_variable_infos ();\n \n \t  /* We also need to make function return values escape.  Nothing\n@@ -6894,8 +6921,7 @@ ipa_pta_execute (void)\n       struct cgraph_edge *e;\n \n       /* Nodes without a body are not interesting.  */\n-      if (!cgraph_function_with_gimple_body_p (node)\n-\t  || node->clone_of)\n+      if (!cgraph_function_with_gimple_body_p (node))\n \tcontinue;\n \n       fn = DECL_STRUCT_FUNCTION (node->decl);"}]}