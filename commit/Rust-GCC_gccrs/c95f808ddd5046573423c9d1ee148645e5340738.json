{"sha": "c95f808ddd5046573423c9d1ee148645e5340738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk1ZjgwOGRkZDUwNDY1NzM0MjNjOWQxZWUxNDg2NDVlNTM0MDczOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-03-03T17:57:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-19T08:17:29Z"}, "message": "[Ada] AI12-0028-1 Import of variadic C functions\n\n2020-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_param): Tidy up.\n\t(gnat_to_gnu_subprog_type): For a variadic C function, do not\n\tbuild unnamed parameters and do not add final void node.\n\t* gcc-interface/misc.c: Include snames.h.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Tidy up.\n\t(Call_to_gnu): Implement support for unnamed parameters in a\n\tvariadic C function.\n\t* gcc-interface/utils.c: Include snames.h.\n\t(copy_type): Tidy up.", "tree": {"sha": "a99db98e03a04564121575672e8da9a91648c849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a99db98e03a04564121575672e8da9a91648c849"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c95f808ddd5046573423c9d1ee148645e5340738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95f808ddd5046573423c9d1ee148645e5340738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95f808ddd5046573423c9d1ee148645e5340738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95f808ddd5046573423c9d1ee148645e5340738/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "906a759dcbedb3e56d61824cb7981ea395ca1f07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/906a759dcbedb3e56d61824cb7981ea395ca1f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/906a759dcbedb3e56d61824cb7981ea395ca1f07"}], "stats": {"total": 166, "additions": 130, "deletions": 36}, "files": [{"sha": "33d59d556a2bb8b2cecc2c8823471b745697c063", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=c95f808ddd5046573423c9d1ee148645e5340738", "patch": "@@ -5401,8 +5401,8 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n       tree unpadded_type = TREE_TYPE (TYPE_FIELDS (gnu_param_type));\n \n       if (foreign\n-\t  || (!must_pass_by_ref (unpadded_type)\n-\t      && mech != By_Reference\n+\t  || (mech != By_Reference\n+\t      && !must_pass_by_ref (unpadded_type)\n \t      && (mech == By_Copy || !default_pass_by_ref (unpadded_type))\n \t      && TYPE_ALIGN (unpadded_type) >= TYPE_ALIGN (gnu_param_type)))\n \tgnu_param_type = unpadded_type;\n@@ -5424,11 +5424,6 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n \tgnu_param_type = TREE_TYPE (gnu_param_type);\n \n       gnu_param_type = TREE_TYPE (gnu_param_type);\n-\n-      if (ro_param)\n-\tgnu_param_type\n-\t  = change_qualified_type (gnu_param_type, TYPE_QUAL_CONST);\n-\n       gnu_param_type = build_pointer_type (gnu_param_type);\n       by_component_ptr = true;\n     }\n@@ -5760,6 +5755,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n {\n   const Entity_Kind kind = Ekind (gnat_subprog);\n   const bool method_p = is_cplusplus_method (gnat_subprog);\n+  const bool variadic = IN (Convention (gnat_subprog), Convention_C_Variadic);\n   Entity_Id gnat_return_type = Etype (gnat_subprog);\n   Entity_Id gnat_param;\n   tree gnu_type = present_gnu_tree (gnat_subprog)\n@@ -5792,7 +5788,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   bool return_by_invisi_ref_p = false;\n   bool return_unconstrained_p = false;\n   bool incomplete_profile_p = false;\n-  unsigned int num;\n+  int num;\n \n   /* Look into the return type and get its associated GCC tree if it is not\n      void, and then compute various flags for the subprogram type.  But make\n@@ -5962,6 +5958,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n       tree gnu_param, gnu_param_type;\n       bool cico = false;\n \n+      /* For a variadic C function, do not build unnamed parameters.  */\n+      if (variadic\n+\t  && num == (Convention (gnat_subprog) - Convention_C_Variadic_0))\n+\tbreak;\n+\n       /* Fetch an existing parameter with complete type and reuse it.  But we\n \t didn't save the CICO property so we can only do it for In parameters\n \t or parameters passed by reference.  */\n@@ -6195,7 +6196,8 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \n   /* The lists have been built in reverse.  */\n   gnu_param_type_list = nreverse (gnu_param_type_list);\n-  gnu_param_type_list = chainon (gnu_param_type_list, void_list_node);\n+  if (!variadic)\n+    gnu_param_type_list = chainon (gnu_param_type_list, void_list_node);\n   gnu_param_list = nreverse (gnu_param_list);\n   gnu_cico_list = nreverse (gnu_cico_list);\n "}, {"sha": "f360ad4da2295c584f8d8397a2159096cd3cd385", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=c95f808ddd5046573423c9d1ee148645e5340738", "patch": "@@ -47,6 +47,7 @@\n #include \"atree.h\"\n #include \"namet.h\"\n #include \"nlists.h\"\n+#include \"snames.h\"\n #include \"uintp.h\"\n #include \"fe.h\"\n #include \"sinfo.h\""}, {"sha": "5a93c433ec1559a66af75f4bcd1157a6f8c1c121", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 116, "deletions": 26, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=c95f808ddd5046573423c9d1ee148645e5340738", "patch": "@@ -2065,7 +2065,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n     case Attr_Range_Length:\n       prefix_unused = true;\n \n-      if (INTEGRAL_TYPE_P (gnu_type) || TREE_CODE (gnu_type) == REAL_TYPE)\n+      if (INTEGRAL_TYPE_P (gnu_type) || SCALAR_FLOAT_TYPE_P (gnu_type))\n \t{\n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n@@ -4457,9 +4457,10 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   tree gnu_after_list = NULL_TREE;\n   tree gnu_retval = NULL_TREE;\n   tree gnu_call, gnu_result;\n-  bool by_descriptor = false;\n   bool went_into_elab_proc = false;\n   bool pushed_binding_level = false;\n+  bool variadic;\n+  bool by_descriptor;\n   Entity_Id gnat_formal;\n   Node_Id gnat_actual;\n   atomic_acces_t aa_type;\n@@ -4505,20 +4506,32 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n      entity being called.  */\n   if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n     {\n+      const Entity_Id gnat_prefix_type\n+\t= Underlying_Type (Etype (Prefix (Name (gnat_node))));\n+\n       gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n+      variadic = IN (Convention (gnat_prefix_type), Convention_C_Variadic);\n \n       /* If the access type doesn't require foreign-compatible representation,\n \t be prepared for descriptors.  */\n-      if (targetm.calls.custom_function_descriptors > 0\n-\t  && Can_Use_Internal_Rep\n-\t     (Underlying_Type (Etype (Prefix (Name (gnat_node))))))\n-\tby_descriptor = true;\n+      by_descriptor\n+\t= targetm.calls.custom_function_descriptors > 0\n+\t  && Can_Use_Internal_Rep (gnat_prefix_type);\n     }\n   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)\n-    /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n-    gnat_formal = Empty;\n+    {\n+      /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n+      gnat_formal = Empty;\n+      variadic = false;\n+      by_descriptor = false;\n+    }\n   else\n-    gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n+    {\n+      gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n+      variadic\n+\t= IN (Convention (Entity (Name (gnat_node))), Convention_C_Variadic);\n+      by_descriptor = false;\n+    }\n \n   /* The lifetime of the temporaries created for the call ends right after the\n      return value is copied, so we can give them the scope of the elaboration\n@@ -4853,27 +4866,12 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n \n-      /* Otherwise the parameter is passed by copy.  */\n-      else\n+      /* Then see if the parameter is passed by copy.  */\n+      else if (is_true_formal_parm)\n \t{\n \t  if (!in_param)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n-\t  /* If we didn't create a PARM_DECL for the formal, this means that\n-\t     it is an Out parameter not passed by reference and that need not\n-\t     be copied in.  In this case, the value of the actual need not be\n-\t     read.  However, we still need to make sure that its side-effects\n-\t     are evaluated before the call, so we evaluate its address.  */\n-\t  if (!is_true_formal_parm)\n-\t    {\n-\t      if (TREE_SIDE_EFFECTS (gnu_name))\n-\t\t{\n-\t\t  tree addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_name);\n-\t\t  append_to_statement_list (addr, &gnu_stmt_list);\n-\t\t}\n-\t      continue;\n-\t    }\n-\n \t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n \n \t  /* If this is a front-end built-in function, there is no need to\n@@ -4882,6 +4880,98 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    gnu_actual = convert (DECL_ARG_TYPE (gnu_formal), gnu_actual);\n \t}\n \n+      /* Then see if this is an unnamed parameter in a variadic C function.  */\n+      else if (variadic)\n+\t{\n+\t  /* This is based on the processing done in gnat_to_gnu_param, but\n+\t     we expect the mechanism to be set in (almost) all cases.  */\n+\t  const Mechanism_Type mech = Mechanism (gnat_formal);\n+\n+\t  /* Strip off possible padding type.  */\n+\t  if (TYPE_IS_PADDING_P (gnu_formal_type))\n+\t    gnu_formal_type = TREE_TYPE (TYPE_FIELDS (gnu_formal_type));\n+\n+\t  /* Arrays are passed as pointers to element type.  First check for\n+\t     unconstrained array and get the underlying array.  */\n+\t  if (TREE_CODE (gnu_formal_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t    gnu_formal_type\n+\t      = TREE_TYPE\n+\t\t(TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_formal_type))));\n+\n+\t  /* Arrays are passed as pointers to element type.  */\n+\t  if (mech != By_Copy && TREE_CODE (gnu_formal_type) == ARRAY_TYPE)\n+\t    {\n+\t      gnu_actual = maybe_implicit_deref (gnu_actual);\n+\t      gnu_actual = maybe_unconstrained_array (gnu_actual);\n+\n+\t      /* Strip off any multi-dimensional entries, then strip\n+\t\t off the last array to get the component type.  */\n+\t      while (TREE_CODE (TREE_TYPE (gnu_formal_type)) == ARRAY_TYPE\n+\t\t     && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_formal_type)))\n+\t\tgnu_formal_type = TREE_TYPE (gnu_formal_type);\n+\n+\t      gnu_formal_type = TREE_TYPE (gnu_formal_type);\n+\t      gnu_formal_type = build_pointer_type (gnu_formal_type);\n+\t      gnu_actual\n+\t\t= build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n+\t    }\n+\n+\t  /* Fat pointers are passed as thin pointers.  */\n+\t  else if (TYPE_IS_FAT_POINTER_P (gnu_formal_type))\n+\t    gnu_formal_type\n+\t      = make_type_from_size (gnu_formal_type,\n+\t\t\t\t     size_int (POINTER_SIZE), 0);\n+\n+\t  /* If we were requested or muss pass by reference, do so.\n+\t     If we were requested to pass by copy, do so.\n+\t     Otherwise, pass In Out or Out parameters or aggregates by\n+\t     reference.  */\n+\t  else if (mech == By_Reference\n+\t\t   || must_pass_by_ref (gnu_formal_type)\n+\t\t   || (mech != By_Copy\n+\t\t       && (!in_param || AGGREGATE_TYPE_P (gnu_formal_type))))\n+\t    {\n+\t      gnu_formal_type = build_reference_type (gnu_formal_type);\n+\t      gnu_actual\n+\t\t= build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n+\t    }\n+\n+\t  /* Otherwise pass by copy after applying default C promotions.  */\n+\t  else\n+\t    {\n+\t      if (INTEGRAL_TYPE_P (gnu_formal_type)\n+\t\t  && TYPE_PRECISION (gnu_formal_type)\n+\t\t     < TYPE_PRECISION (integer_type_node))\n+\t\tgnu_formal_type = integer_type_node;\n+\n+\t      else if (SCALAR_FLOAT_TYPE_P (gnu_formal_type)\n+\t\t       && TYPE_PRECISION (gnu_formal_type)\n+\t\t\t  < TYPE_PRECISION (double_type_node))\n+\t\tgnu_formal_type = double_type_node;\n+\t    }\n+\n+\t  gnu_actual = convert (gnu_formal_type, gnu_actual);\n+\t}\n+\n+      /* If we didn't create a PARM_DECL for the formal, this means that\n+\t it is an Out parameter not passed by reference and that need not\n+\t be copied in.  In this case, the value of the actual need not be\n+\t read.  However, we still need to make sure that its side-effects\n+\t are evaluated before the call, so we evaluate its address.  */\n+      else\n+\t{\n+\t  if (!in_param)\n+\t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n+\n+\t  if (TREE_SIDE_EFFECTS (gnu_name))\n+\t    {\n+\t      tree addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_name);\n+\t      append_to_statement_list (addr, &gnu_stmt_list);\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n       gnu_actual_vec.safe_push (gnu_actual);\n     }\n "}, {"sha": "2a6ed04756b041207e72a8f4ffaa289703de42a0", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c95f808ddd5046573423c9d1ee148645e5340738/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=c95f808ddd5046573423c9d1ee148645e5340738", "patch": "@@ -50,6 +50,7 @@\n #include \"types.h\"\n #include \"atree.h\"\n #include \"nlists.h\"\n+#include \"snames.h\"\n #include \"uintp.h\"\n #include \"fe.h\"\n #include \"sinfo.h\"\n@@ -2561,7 +2562,7 @@ copy_type (tree type)\n     }\n \n   /* And the contents of the language-specific slot if needed.  */\n-  if ((INTEGRAL_TYPE_P (type) || TREE_CODE (type) == REAL_TYPE)\n+  if ((INTEGRAL_TYPE_P (type) || SCALAR_FLOAT_TYPE_P (type))\n       && TYPE_RM_VALUES (type))\n     {\n       TYPE_RM_VALUES (new_type) = NULL_TREE;"}]}