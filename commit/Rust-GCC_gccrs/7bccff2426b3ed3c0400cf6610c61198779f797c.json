{"sha": "7bccff2426b3ed3c0400cf6610c61198779f797c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JjY2ZmMjQyNmIzZWQzYzA0MDBjZjY2MTBjNjExOTg3NzlmNzk3Yw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-07-13T10:45:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-13T10:45:14Z"}, "message": "gnatcmd.adb, [...] (Prj.Tree.Create*): New subprograms to create new packages and attributes in a project tree.\n\n2009-07-13  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, prj-proc.adb, make.adb, mlib-prj.adb, prj-ext.adb,\n\tgnat_ugn.texi, prj.adb, prj.ads, clean.adb, prj-nmsc.adb, prj-util.adb,\n\tprj-conf.adb, gnatname.adb, prj-env.adb, prj-env.ads, prj-tree.adb,\n\tprj-tree.ads (Prj.Tree.Create*): New subprograms to create new packages\n\tand attributes in a project tree.\n\t(Add_Default_GNAT_Naming_Scheme): Provide real implementation.\n\tRemove last remaining mode-specific code (ada_only or\n\tmulti_language). This was duplicating code\n\t(Get_Mode, Set_Mode): removed, no longer used.\n\t(Initialize_Project_Path): all tools will now take into account both\n\tGPR_PROJECT_PATH and ADA_PROJECT_PATH (in that order).\n\tRemove some global variables and subprograms no longer used\n\tMake temporary files tree-specific, to avoid interferences between\n\ttrees loaded in memory at the same time.\n\t(Prj.Delete_Temporary_File): new subprogram\n\t(Object_Paths, Source_Paths): fields no longer stored in the project\n\ttree, since they are only needed locally in Set_Ada_Paths.\n\t(Set_Mapping_File_Initial_State_To_Empty): removed, since had no\n\teffect in practice.\n\t(Project_Tree_Data.Ada_Path_Buffer): removed, since it can be replaced\n\tby local variables in the appropriate subprograms\n\t(Has_Foreign_Sources): removed.\n\n        * gcc-interface/Makefile.in: prj-pp.o is now needed to build gnatmake\n\nFrom-SVN: r149568", "tree": {"sha": "f36850a6b47b83f1fbdba5bbb834d88e131763f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f36850a6b47b83f1fbdba5bbb834d88e131763f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bccff2426b3ed3c0400cf6610c61198779f797c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bccff2426b3ed3c0400cf6610c61198779f797c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bccff2426b3ed3c0400cf6610c61198779f797c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bccff2426b3ed3c0400cf6610c61198779f797c/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a64837c6b14f97b066772abc1463aa8f2c962d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a64837c6b14f97b066772abc1463aa8f2c962d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a64837c6b14f97b066772abc1463aa8f2c962d5"}], "stats": {"total": 1986, "additions": 911, "deletions": 1075}, "files": [{"sha": "2e12962d541a68e5b499a338ee6ee12f70d3eb79", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -1,3 +1,30 @@\n+2009-07-13  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, prj-proc.adb, make.adb, mlib-prj.adb, prj-ext.adb,\n+\tgnat_ugn.texi, prj.adb, prj.ads, clean.adb, prj-nmsc.adb, prj-util.adb,\n+\tprj-conf.adb, gnatname.adb, prj-env.adb, prj-env.ads, prj-tree.adb,\n+\tprj-tree.ads (Prj.Tree.Create*): New subprograms to create new packages\n+\tand attributes in a project tree.\n+\t(Add_Default_GNAT_Naming_Scheme): Provide real implementation.\n+\tRemove last remaining mode-specific code (ada_only or\n+\tmulti_language). This was duplicating code\n+\t(Get_Mode, Set_Mode): removed, no longer used.\n+\t(Initialize_Project_Path): all tools will now take into account both\n+\tGPR_PROJECT_PATH and ADA_PROJECT_PATH (in that order).\n+\tRemove some global variables and subprograms no longer used\n+\tMake temporary files tree-specific, to avoid interferences between\n+\ttrees loaded in memory at the same time.\n+\t(Prj.Delete_Temporary_File): new subprogram\n+\t(Object_Paths, Source_Paths): fields no longer stored in the project\n+\ttree, since they are only needed locally in Set_Ada_Paths.\n+\t(Set_Mapping_File_Initial_State_To_Empty): removed, since had no\n+\teffect in practice.\n+\t(Project_Tree_Data.Ada_Path_Buffer): removed, since it can be replaced\n+\tby local variables in the appropriate subprograms\n+\t(Has_Foreign_Sources): removed.\n+\n+        * gcc-interface/Makefile.in: prj-pp.o is now needed to build gnatmake\n+\n 2009-07-13  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat1drv.adb (Adjust_Global_Switches): No longer set"}, {"sha": "e4d438732b51f178a5ae7b432a262ebad5637da7", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -1044,7 +1044,18 @@ package body Clean is\n                   begin\n                      Proj := Project_Tree.Projects;\n                      while Proj /= null loop\n-                        if Has_Foreign_Sources (Proj.Project) then\n+\n+                        --  for gnatmake, when the project specifies more than\n+                        --  Ada as a language (even if course we could not find\n+                        --  any source file for the other languages), we will\n+                        --  take all object files found in the object\n+                        --  directories. Since we know the project supports at\n+                        --  least Ada, we just have to test whether it has at\n+                        --  least two languages, and not care about the sources\n+\n+                        if Proj.Project.Languages /= null\n+                          and then Proj.Project.Languages.Next /= null\n+                        then\n                            Global_Archive := True;\n                            exit;\n                         end if;"}, {"sha": "9ec41afa8bafefb0bd15e2c520708599c34780c4", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -295,7 +295,7 @@ GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n  make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o \\\n  mlib-tgt-specific.o mlib-utl.o namet.o nlists.o opt.o osint.o osint-m.o \\\n  output.o prj.o prj-attr.o prj-attr-pm.o prj-com.o prj-dect.o prj-env.o \\\n- prj-conf.o \\\n+ prj-conf.o prj-pp.o \\\n  prj-err.o prj-ext.o prj-nmsc.o prj-pars.o prj-part.o prj-proc.o prj-strt.o \\\n  prj-tree.o prj-util.o rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n  scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o sinfo.o sinput.o \\"}, {"sha": "08e6a6e88b3dc9b66021960299270790aec53a78", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -12249,6 +12249,7 @@ is equivalent to the @command{gnatmake} invocation using the project file\n @node Importing Other Projects\n @subsection Importing Other Projects\n @cindex @code{ADA_PROJECT_PATH}\n+@cindex @code{GPR_PROJECT_PATH}\n \n @noindent\n A compilation unit in a source file in one project may depend on compilation\n@@ -12335,15 +12336,17 @@ if either\n The imported project file is in the same directory as the importing project\n file, or\n @item\n-You have defined ^an environment variable^a logical name^\n+You have defined one or two ^environment variables^logical names^\n that includes the directory containing\n-the needed project file. The syntax of @code{ADA_PROJECT_PATH} is the same as\n+the needed project file. The syntax of @code{GPR_PROJECT_PATH} and\n+@code{ADA_PROJECT_PATH} is the same as\n the syntax of @code{ADA_INCLUDE_PATH} and @code{ADA_OBJECTS_PATH}: a list of\n directory names separated by colons (semicolons on Windows).\n @end itemize\n \n @noindent\n-Thus, if we define @code{ADA_PROJECT_PATH} to include @file{^/gui^[GUI]^} and\n+Thus, if we define @code{ADA_PROJECT_PATH} or @code{GPR_PROJECT_PATH}\n+to include @file{^/gui^[GUI]^} and\n @file{^/comm^[COMM]^}, then our project file @file{app_proj.gpr} can be written\n as follows:\n \n@@ -13345,6 +13348,7 @@ define a package @code{Naming} (@pxref{Naming Schemes}).\n @node  Importing Projects\n @section Importing Projects\n @cindex @code{ADA_PROJECT_PATH}\n+@cindex @code{GPR_PROJECT_PATH}\n \n @noindent\n An immediate source of a project P may depend on source files that\n@@ -13385,7 +13389,8 @@ files giving access to standard support libraries.\n \n @item\n In between, all the directories referenced in the\n-^environment variable^logical name^ @env{ADA_PROJECT_PATH} if it exists.\n+^environment variables^logical names^ @env{GPR_PROJECT_PATH}\n+and @env{ADA_PROJECT_PATH} if they exist, and in that order.\n @end itemize\n \n @noindent\n@@ -19049,6 +19054,7 @@ be accessed by the directive @option{-l@var{xxx}} at link time.\n @node Installing a library\n @subsection Installing a library\n @cindex @code{ADA_PROJECT_PATH}\n+@cindex @code{GPR_PROJECT_PATH}\n \n @noindent\n If you use project files, library installation is part of the library build\n@@ -19088,7 +19094,7 @@ responsibility of the library provider to install the necessary sources, ALI\n files and libraries in the directories mentioned in the project file. For\n convenience, the user's library project file should be installed in a location\n that will be searched automatically by the GNAT\n-builder. These are the directories referenced in the @env{ADA_PROJECT_PATH}\n+builder. These are the directories referenced in the @env{GPR_PROJECT_PATH}\n environment variable (@pxref{Importing Projects}), and also the default GNAT\n library location that can be queried with @command{gnatls -v} and is usually of\n the form $gnat_install_root/lib/gnat."}, {"sha": "fabf31ecaca80e813da7c6b3226a5a5cc3f6acd9", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -681,16 +681,8 @@ procedure GNATCmd is\n          Proj := Project_Tree.Projects;\n          while Proj /= null loop\n             if Proj.Project.Config_File_Temp then\n-               if Verbose_Mode then\n-                  Output.Write_Str (\"Deleting temp configuration file \"\"\");\n-                  Output.Write_Str\n-                    (Get_Name_String (Proj.Project.Config_File_Name));\n-                  Output.Write_Line (\"\"\"\");\n-               end if;\n-\n-               Delete_File\n-                 (Name    => Get_Name_String (Proj.Project.Config_File_Name),\n-                  Success => Success);\n+               Delete_Temporary_File\n+                 (Project_Tree, Proj.Project.Config_File_Name);\n             end if;\n \n             Proj := Proj.Next;\n@@ -701,7 +693,7 @@ procedure GNATCmd is\n       --  has been created, delete this temporary file.\n \n       if Temp_File_Name /= No_Path then\n-         Delete_File (Get_Name_String (Temp_File_Name), Success);\n+         Delete_Temporary_File (Project_Tree, Temp_File_Name);\n       end if;\n    end Delete_Temp_Config_Files;\n \n@@ -1290,8 +1282,6 @@ begin\n \n    VMS_Conv.Initialize;\n \n-   Set_Mode (Ada_Only);\n-\n    --  Add the default search directories, to be able to find system.ads in the\n    --  subsequent call to Targparm.Get_Target_Parameters.\n \n@@ -2132,9 +2122,7 @@ begin\n                --  indicate to gnatstub the name of the body file with\n                --  a -o switch.\n \n-               if Lang.Config.Naming_Data.Body_Suffix /=\n-                    Prj.Default_Ada_Spec_Suffix\n-               then\n+               if Is_Standard_GNAT_Naming (Lang.Config.Naming_Data) then\n                   if File_Index /= 0 then\n                      declare\n                         Spec : constant String :=\n@@ -2355,15 +2343,15 @@ begin\n exception\n    when Error_Exit =>\n       if not Keep_Temporary_Files then\n-         Prj.Env.Delete_All_Path_Files (Project_Tree);\n+         Prj.Delete_All_Temp_Files (Project_Tree);\n          Delete_Temp_Config_Files;\n       end if;\n \n       Set_Exit_Status (Failure);\n \n    when Normal_Exit =>\n       if not Keep_Temporary_Files then\n-         Prj.Env.Delete_All_Path_Files (Project_Tree);\n+         Prj.Delete_All_Temp_Files (Project_Tree);\n          Delete_Temp_Config_Files;\n       end if;\n "}, {"sha": "4e02ccae7dc7a668b62daacbbf4e444f412e2302", "filename": "gcc/ada/gnatname.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnatname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fgnatname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatname.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -524,8 +524,6 @@ procedure Gnatname is\n --  Start of processing for Gnatname\n \n begin\n-   Prj.Set_Mode (Prj.Ada_Only);\n-\n    --  Add the directory where gnatname is invoked in front of the\n    --  path, if gnatname is invoked with directory information.\n    --  Only do this if the platform is not VMS, where the notion of path"}, {"sha": "e69cec4a5ac8a7c345ccae7ec09e253a78ee054e", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 11, "deletions": 60, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -835,10 +835,6 @@ package body Make is\n    Gnatmake_Mapping_File : String_Access := null;\n    --  The path name of a mapping file specified by switch -C=\n \n-   procedure Delete_Mapping_Files;\n-   --  Delete all temporary mapping files. Called only in Delete_All_Temp_Files\n-   --  which ensures that Debug_Flag_N is False.\n-\n    procedure Init_Mapping_File\n      (Project    : Project_Id;\n       Data       : in out Project_Compilation_Data;\n@@ -3881,45 +3877,11 @@ package body Make is\n    procedure Delete_All_Temp_Files is\n    begin\n       if not Debug.Debug_Flag_N then\n-         Delete_Mapping_Files;\n          Delete_Temp_Config_Files;\n-         Prj.Env.Delete_All_Path_Files (Project_Tree);\n+         Prj.Delete_All_Temp_Files (Project_Tree);\n       end if;\n    end Delete_All_Temp_Files;\n \n-   --------------------------\n-   -- Delete_Mapping_Files --\n-   --------------------------\n-\n-   procedure Delete_Mapping_Files is\n-      Success : Boolean;\n-      pragma Warnings (Off, Success);\n-\n-      Proj : Project_List;\n-      Data : Project_Compilation_Access;\n-\n-   begin\n-      --  The caller is responsible for ensuring that Debug_Flag_N is False\n-\n-      pragma Assert (not Debug.Debug_Flag_N);\n-\n-      Proj := Project_Tree.Projects;\n-      while Proj /= null loop\n-         Data := Project_Compilation_Htable.Get\n-           (Project_Compilation, Proj.Project);\n-\n-         if Data /= null and then Data.Mapping_File_Names /= null then\n-            for Index in 1 .. Data.Last_Mapping_File_Names loop\n-               Delete_File\n-                 (Name => Get_Name_String (Data.Mapping_File_Names (Index)),\n-                  Success => Success);\n-            end loop;\n-         end if;\n-\n-         Proj := Proj.Next;\n-      end loop;\n-   end Delete_Mapping_Files;\n-\n    ------------------------------\n    -- Delete_Temp_Config_Files --\n    ------------------------------\n@@ -3938,15 +3900,8 @@ package body Make is\n          Proj := Project_Tree.Projects;\n          while Proj /= null loop\n             if Proj.Project.Config_File_Temp then\n-               if Verbose_Mode then\n-                  Write_Str (\"Deleting temp configuration file \"\"\");\n-                  Write_Str (Get_Name_String (Proj.Project.Config_File_Name));\n-                  Write_Line (\"\"\"\");\n-               end if;\n-\n-               Delete_File\n-                 (Name    => Get_Name_String (Proj.Project.Config_File_Name),\n-                  Success => Success);\n+               Delete_Temporary_File\n+                 (Project_Tree, Proj.Project.Config_File_Name);\n \n                --  Make sure that we don't have a config file for this project,\n                --  in case there are several mains. In this case, we will\n@@ -4375,7 +4330,7 @@ package body Make is\n \n       begin\n          Tempdir.Create_Temp_File (Mapping_FD, Mapping_Path);\n-         Record_Temp_File (Mapping_Path);\n+         Record_Temp_File (Project_Tree, Mapping_Path);\n \n          if Mapping_FD /= Invalid_FD then\n \n@@ -6069,13 +6024,10 @@ package body Make is\n                exception\n                   when others =>\n \n-                     --  If -dn was not specified, delete the temporary mapping\n-                     --  file, if one was created.\n+                     --  Delete the temporary mapping file, if one was created.\n \n-                     if not Debug.Debug_Flag_N\n-                       and then Mapping_Path /= No_Path\n-                     then\n-                        Delete_File (Get_Name_String (Mapping_Path), Discard);\n+                     if Mapping_Path /= No_Path then\n+                        Delete_Temporary_File (Project_Tree, Mapping_Path);\n                      end if;\n \n                      --  And reraise the exception\n@@ -6086,8 +6038,8 @@ package body Make is\n                --  If -dn was not specified, delete the temporary mapping file,\n                --  if one was created.\n \n-               if not Debug.Debug_Flag_N and then Mapping_Path /= No_Path then\n-                  Delete_File (Get_Name_String (Mapping_Path), Discard);\n+               if Mapping_Path /= No_Path then\n+                  Delete_Temporary_File (Project_Tree, Mapping_Path);\n                end if;\n             end Bind_Step;\n          end if;\n@@ -6660,7 +6612,8 @@ package body Make is\n \n          else\n             Record_Temp_File\n-              (Data.Mapping_File_Names (Data.Last_Mapping_File_Names));\n+              (Project_Tree,\n+               Data.Mapping_File_Names (Data.Last_Mapping_File_Names));\n          end if;\n \n          Close (FD, Status);\n@@ -6698,8 +6651,6 @@ package body Make is\n       --  Start of processing for Initialize\n \n    begin\n-      Prj.Set_Mode (Ada_Only);\n-\n       --  Override default initialization of Check_Object_Consistency since\n       --  this is normally False for GNATBIND, but is True for GNATMAKE since\n       --  we do not need to check source consistency again once GNATMAKE has"}, {"sha": "51de49b60a7b49d3b4cab0e873c971861023a19c", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -1328,7 +1328,14 @@ package body MLib.Prj is\n \n          In_Main_Object_Directory := True;\n \n-         Foreign_Sources := Has_Foreign_Sources (For_Project);\n+         --  for gnatmake, when the project specifies more than Ada as a\n+         --  language (even if course we could not find any source file for\n+         --  the other languages), we will take all object files found in the\n+         --  object directories. Since we know the project supports at least\n+         --  Ada, we just have to test whether it has at least two languages,\n+         --  and not care about the sources\n+\n+         Foreign_Sources := For_Project.Languages.Next /= null;\n          Current_Proj := For_Project;\n \n          loop"}, {"sha": "59b6c14025e2ea1756e17557f3610d779c63fbac", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 93, "deletions": 50, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -27,9 +27,11 @@\n with Ada.Directories;  use Ada.Directories;\n with GNAT.HTable;      use GNAT.HTable;\n with Makeutl;          use Makeutl;\n+with MLib.Tgt;\n with Opt;              use Opt;\n with Output;           use Output;\n with Prj.Part;\n+with Prj.PP;\n with Prj.Proc;         use Prj.Proc;\n with Prj.Tree;         use Prj.Tree;\n with Prj.Util;         use Prj.Util;\n@@ -1123,7 +1125,56 @@ package body Prj.Conf is\n      (Config_File  : in out Project_Node_Id;\n       Project_Tree : Project_Node_Tree_Ref)\n    is\n-      Name : Name_Id;\n+      procedure Create_Attribute\n+        (Name  : Name_Id;\n+         Value : String;\n+         Index : String := \"\";\n+         Pkg   : Project_Node_Id := Empty_Node);\n+\n+      ----------------------\n+      -- Create_Attribute --\n+      ----------------------\n+\n+      procedure Create_Attribute\n+        (Name  : Name_Id;\n+         Value : String;\n+         Index : String := \"\";\n+         Pkg   : Project_Node_Id := Empty_Node)\n+      is\n+         Attr : Project_Node_Id;\n+         Val  : Name_Id := No_Name;\n+         Parent : Project_Node_Id := Config_File;\n+      begin\n+         if Index /= \"\" then\n+            Name_Len := Index'Length;\n+            Name_Buffer (1 .. Name_Len) := Index;\n+            Val := Name_Find;\n+         end if;\n+\n+         if Pkg /= Empty_Node then\n+            Parent := Pkg;\n+         end if;\n+\n+         Attr := Create_Attribute\n+           (Tree       => Project_Tree,\n+            Prj_Or_Pkg => Parent,\n+            Name       => Name,\n+            Index_Name => Val,\n+            Kind       => Prj.Single);\n+\n+         Name_Len := Value'Length;\n+         Name_Buffer (1 .. Name_Len) := Value;\n+         Val := Name_Find;\n+\n+         Set_Expression_Of\n+           (Attr, Project_Tree,\n+            Enclose_In_Expression\n+              (Create_Literal_String (Val, Project_Tree),\n+               Project_Tree));\n+      end Create_Attribute;\n+\n+      Name   : Name_Id;\n+      Naming : Project_Node_Id;\n \n    begin\n       if Config_File = Empty_Node then\n@@ -1137,58 +1188,50 @@ package body Prj.Conf is\n          Config_File :=\n            Create_Project\n              (In_Tree        => Project_Tree,\n-              Name           => Name,\n+              Name           => Name_Default,\n               Full_Path      => Path_Name_Type (Name),\n               Is_Config_File => True);\n \n-         --  ??? This isn't strictly required, since Prj.Nmsc.Add_Language\n-         --  already has a workaround in the Ada_Only case. But it would be\n-         --  nicer to do it this way\n-         --  Likewise for the default language, hard-coded in\n-         --  Pjr.Nmsc.Check_Programming_Languages\n-\n-         --  Why is all the following code commented out???\n-\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => \"default_language\",\n---              Value              => \"Ada\");\n---\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => Separate_Suffix_Attribute,\n---              Value              => \".adb\",\n---              Attribute_Index    => \"Ada\");\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => Spec_Suffix_Attribute,\n---              Value              => \".ads\",\n---              Attribute_Index    => \"Ada\");\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => Impl_Suffix_Attribute,\n---              Value              => \".adb\",\n---              Attribute_Index    => \"Ada\");\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => Dot_Replacement_Attribute,\n---              Value              => \"-\");\n---           Update_Attribute_Value_In_Scenario\n---             (Tree               => Project_Tree,\n---              Project            => Config_File,\n---              Scenario_Variables => No_Scenario,\n---              Attribute          => Casing_Attribute,\n---              Value              => \"lowercase\");\n+         --  Setup library support\n+\n+         case MLib.Tgt.Support_For_Libraries is\n+            when None =>\n+               null;\n+\n+            when Static_Only =>\n+               Create_Attribute (Name_Library_Support, \"static_only\");\n+\n+            when Full =>\n+               Create_Attribute (Name_Library_Support, \"full\");\n+         end case;\n+\n+         if MLib.Tgt.Standalone_Library_Auto_Init_Is_Supported then\n+            Create_Attribute (Name_Library_Auto_Init_Supported, \"true\");\n+         else\n+            Create_Attribute (Name_Library_Auto_Init_Supported, \"false\");\n+         end if;\n+\n+         --  Setup Ada support (Ada is the default language here, since this is\n+         --  only called when no config file existed initially, ie for\n+         --  gnatmake).\n+\n+         Create_Attribute (Name_Default_Language, \"ada\");\n+\n+         Naming := Create_Package (Project_Tree, Config_File, \"naming\");\n+         Create_Attribute (Name_Spec_Suffix, \".ads\", \"ada\",     Pkg => Naming);\n+         Create_Attribute (Name_Separate_Suffix, \".adb\", \"ada\", Pkg => Naming);\n+         Create_Attribute (Name_Body_Suffix, \".adb\", \"ada\",     Pkg => Naming);\n+         Create_Attribute (Name_Dot_Replacement, \"-\",           Pkg => Naming);\n+         Create_Attribute (Name_Casing,          \"lowercase\",   Pkg => Naming);\n+\n+         if Current_Verbosity = High then\n+            Write_Line (\"Automatically generated (in-memory) config file\");\n+            Prj.PP.Pretty_Print\n+              (Project                => Config_File,\n+               In_Tree                => Project_Tree,\n+               Backward_Compatibility => False);\n+\n+         end if;\n       end if;\n    end Add_Default_GNAT_Naming_Scheme;\n "}, {"sha": "7541e52fedfa20e385b5320344da4307f1ebddc8", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 157, "deletions": 201, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -36,26 +36,47 @@ package body Prj.Env is\n    -- Local Subprograms --\n    -----------------------\n \n+   package Source_Path_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 100);\n+   --  A table to store the source dirs before creating the source path file\n+\n+   package Object_Path_Table is new GNAT.Dynamic_Tables\n+     (Table_Component_Type => Path_Name_Type,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 100);\n+   --  A table to store the object dirs, before creating the object path file\n+\n    procedure Add_To_Path\n      (Source_Dirs : String_List_Id;\n-      In_Tree     : Project_Tree_Ref);\n+      In_Tree     : Project_Tree_Ref;\n+      Buffer      : in out String_Access;\n+      Buffer_Last : in out Natural);\n    --  Add to Ada_Path_Buffer all the source directories in string list\n-   --  Source_Dirs, if any. Increment Ada_Path_Length.\n+   --  Source_Dirs, if any.\n \n-   procedure Add_To_Path (Dir : String; In_Tree : Project_Tree_Ref);\n+   procedure Add_To_Path\n+     (Dir         : String;\n+      Buffer      : in out String_Access;\n+      Buffer_Last : in out Natural);\n    --  If Dir is not already in the global variable Ada_Path_Buffer, add it.\n-   --  Increment Ada_Path_Length.\n-   --  If Ada_Path_Length /= 0, prepend a Path_Separator character to\n-   --  Path.\n+   --  If Buffer_Last /= 0, prepend a Path_Separator character to Path.\n \n    procedure Add_To_Source_Path\n-     (Source_Dirs : String_List_Id; In_Tree : Project_Tree_Ref);\n+     (Source_Dirs  : String_List_Id;\n+      In_Tree      : Project_Tree_Ref;\n+      Source_Paths : in out Source_Path_Table.Instance);\n    --  Add to Ada_Path_B all the source directories in string list\n    --  Source_Dirs, if any. Increment Ada_Path_Length.\n \n    procedure Add_To_Object_Path\n-     (Object_Dir : Path_Name_Type;\n-      In_Tree    : Project_Tree_Ref);\n+     (Object_Dir   : Path_Name_Type;\n+      Object_Paths : in out Object_Path_Table.Instance);\n    --  Add Object_Dir to object path table. Make sure it is not duplicate\n    --  and it is the last one in the current table.\n \n@@ -67,14 +88,26 @@ package body Prj.Env is\n    --  Return a project that is either Project or an extended ancestor of\n    --  Project that itself is not extended.\n \n+   procedure Create_Temp_File\n+     (In_Tree   : Project_Tree_Ref;\n+      Path_FD   : out File_Descriptor;\n+      Path_Name : out Path_Name_Type;\n+      File_Use  : String);\n+   --  Create a temporary file, and fail with an error if it could not be\n+   --  created.\n+\n    ----------------------\n    -- Ada_Include_Path --\n    ----------------------\n \n    function Ada_Include_Path\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return String_Access\n+     (Project   : Project_Id;\n+      In_Tree   : Project_Tree_Ref;\n+      Recursive : Boolean := False) return String\n    is\n+      Buffer      : String_Access;\n+      Buffer_Last : Natural := 0;\n+\n       procedure Add (Project : Project_Id; Dummy : in out Boolean);\n       --  Add source dirs of Project to the path\n \n@@ -85,50 +118,38 @@ package body Prj.Env is\n       procedure Add (Project : Project_Id; Dummy : in out Boolean) is\n          pragma Unreferenced (Dummy);\n       begin\n-         Add_To_Path (Project.Source_Dirs, In_Tree);\n+         Add_To_Path (Project.Source_Dirs, In_Tree, Buffer, Buffer_Last);\n       end Add;\n \n       procedure For_All_Projects is\n         new For_Every_Project_Imported (Boolean, Add);\n-      Dummy : Boolean := False;\n \n-   --  Start of processing for Ada_Include_Path\n+      Dummy : Boolean := False;\n \n    begin\n-      --  If it is the first time we call this function for\n-      --  this project, compute the source path\n-\n-      if Project.Ada_Include_Path = null then\n-         In_Tree.Private_Part.Ada_Path_Length := 0;\n-         For_All_Projects (Project, Dummy);\n-\n-         Project.Ada_Include_Path :=\n-           new String'\n-             (In_Tree.Private_Part.Ada_Path_Buffer\n-                  (1 .. In_Tree.Private_Part.Ada_Path_Length));\n-      end if;\n+      if Recursive then\n+         --  If it is the first time we call this function for\n+         --  this project, compute the source path\n+\n+         if Project.Ada_Include_Path = null then\n+            Buffer := new String (1 .. 4096);\n+            For_All_Projects (Project, Dummy);\n+            Project.Ada_Include_Path := new String'(Buffer (1 .. Buffer_Last));\n+            Free (Buffer);\n+         end if;\n \n-      return Project.Ada_Include_Path;\n-   end Ada_Include_Path;\n+         return Project.Ada_Include_Path.all;\n \n-   ----------------------\n-   -- Ada_Include_Path --\n-   ----------------------\n-\n-   function Ada_Include_Path\n-     (Project   : Project_Id;\n-      In_Tree   : Project_Tree_Ref;\n-      Recursive : Boolean) return String\n-   is\n-   begin\n-      if Recursive then\n-         return Ada_Include_Path (Project, In_Tree).all;\n       else\n-         In_Tree.Private_Part.Ada_Path_Length := 0;\n-         Add_To_Path (Project.Source_Dirs, In_Tree);\n-         return\n-           In_Tree.Private_Part.Ada_Path_Buffer\n-             (1 .. In_Tree.Private_Part.Ada_Path_Length);\n+         Buffer := new String (1 .. 4096);\n+         Add_To_Path (Project.Source_Dirs, In_Tree, Buffer, Buffer_Last);\n+\n+         declare\n+            Result : constant String := Buffer (1 .. Buffer_Last);\n+         begin\n+            Free (Buffer);\n+            return Result;\n+         end;\n       end if;\n    end Ada_Include_Path;\n \n@@ -138,9 +159,11 @@ package body Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean := True) return String_Access\n    is\n+      Buffer : String_Access;\n+      Buffer_Last : Natural := 0;\n+\n       procedure Add (Project : Project_Id; Dummy : in out Boolean);\n       --  Add all the object directories of a project to the path\n \n@@ -157,7 +180,7 @@ package body Prj.Env is\n                      Only_If_Ada         => False);\n       begin\n          if Path /= No_Path then\n-            Add_To_Path (Get_Name_String (Path), In_Tree);\n+            Add_To_Path (Get_Name_String (Path), Buffer, Buffer_Last);\n          end if;\n       end Add;\n \n@@ -172,13 +195,11 @@ package body Prj.Env is\n       --  this project, compute the objects path\n \n       if Project.Ada_Objects_Path = null then\n-         In_Tree.Private_Part.Ada_Path_Length := 0;\n+         Buffer := new String (1 .. 4096);\n          For_All_Projects (Project, Dummy);\n \n-         Project.Ada_Objects_Path :=\n-           new String'\n-             (In_Tree.Private_Part.Ada_Path_Buffer\n-                  (1 .. In_Tree.Private_Part.Ada_Path_Length));\n+         Project.Ada_Objects_Path := new String'(Buffer (1 .. Buffer_Last));\n+         Free (Buffer);\n       end if;\n \n       return Project.Ada_Objects_Path;\n@@ -189,39 +210,34 @@ package body Prj.Env is\n    ------------------------\n \n    procedure Add_To_Object_Path\n-     (Object_Dir : Path_Name_Type; In_Tree : Project_Tree_Ref)\n+     (Object_Dir   : Path_Name_Type;\n+      Object_Paths : in out Object_Path_Table.Instance)\n    is\n    begin\n       --  Check if the directory is already in the table\n \n       for Index in Object_Path_Table.First ..\n-                   Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)\n+                   Object_Path_Table.Last (Object_Paths)\n       loop\n \n          --  If it is, remove it, and add it as the last one\n \n-         if In_Tree.Private_Part.Object_Paths.Table (Index) = Object_Dir then\n+         if Object_Paths.Table (Index) = Object_Dir then\n             for Index2 in Index + 1 ..\n-                          Object_Path_Table.Last\n-                            (In_Tree.Private_Part.Object_Paths)\n+                          Object_Path_Table.Last (Object_Paths)\n             loop\n-               In_Tree.Private_Part.Object_Paths.Table (Index2 - 1) :=\n-                 In_Tree.Private_Part.Object_Paths.Table (Index2);\n+               Object_Paths.Table (Index2 - 1) := Object_Paths.Table (Index2);\n             end loop;\n \n-            In_Tree.Private_Part.Object_Paths.Table\n-              (Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)) :=\n-                 Object_Dir;\n+            Object_Paths.Table\n+              (Object_Path_Table.Last (Object_Paths)) := Object_Dir;\n             return;\n          end if;\n       end loop;\n \n       --  The directory is not already in the table, add it\n \n-      Object_Path_Table.Increment_Last (In_Tree.Private_Part.Object_Paths);\n-      In_Tree.Private_Part.Object_Paths.Table\n-        (Object_Path_Table.Last (In_Tree.Private_Part.Object_Paths)) :=\n-           Object_Dir;\n+      Object_Path_Table.Append (Object_Paths, Object_Dir);\n    end Add_To_Object_Path;\n \n    -----------------\n@@ -230,19 +246,26 @@ package body Prj.Env is\n \n    procedure Add_To_Path\n      (Source_Dirs : String_List_Id;\n-      In_Tree     : Project_Tree_Ref)\n+      In_Tree     : Project_Tree_Ref;\n+      Buffer      : in out String_Access;\n+      Buffer_Last : in out Natural)\n    is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n    begin\n       while Current /= Nil_String loop\n          Source_Dir := In_Tree.String_Elements.Table (Current);\n-         Add_To_Path (Get_Name_String (Source_Dir.Display_Value), In_Tree);\n+         Add_To_Path (Get_Name_String (Source_Dir.Display_Value),\n+                      Buffer, Buffer_Last);\n          Current := Source_Dir.Next;\n       end loop;\n    end Add_To_Path;\n \n-   procedure Add_To_Path (Dir : String; In_Tree : Project_Tree_Ref) is\n+   procedure Add_To_Path\n+     (Dir         : String;\n+      Buffer      : in out String_Access;\n+      Buffer_Last : in out Natural)\n+   is\n       Len        : Natural;\n       New_Buffer : String_Access;\n       Min_Len    : Natural;\n@@ -280,19 +303,16 @@ package body Prj.Env is\n    --  Start of processing for Add_To_Path\n \n    begin\n-      if Is_Present (In_Tree.Private_Part.Ada_Path_Buffer\n-                       (1 .. In_Tree.Private_Part.Ada_Path_Length),\n-                     Dir)\n-      then\n+      if Is_Present (Buffer (1 .. Buffer_Last), Dir) then\n \n          --  Dir is already in the path, nothing to do\n \n          return;\n       end if;\n \n-      Min_Len := In_Tree.Private_Part.Ada_Path_Length + Dir'Length;\n+      Min_Len := Buffer_Last + Dir'Length;\n \n-      if In_Tree.Private_Part.Ada_Path_Length > 0 then\n+      if Buffer_Last > 0 then\n \n          --  Add 1 for the Path_Separator character\n \n@@ -301,7 +321,7 @@ package body Prj.Env is\n \n       --  If Ada_Path_Buffer is too small, increase it\n \n-      Len := In_Tree.Private_Part.Ada_Path_Buffer'Last;\n+      Len := Buffer'Last;\n \n       if Len < Min_Len then\n          loop\n@@ -310,33 +330,28 @@ package body Prj.Env is\n          end loop;\n \n          New_Buffer := new String (1 .. Len);\n-         New_Buffer (1 .. In_Tree.Private_Part.Ada_Path_Length) :=\n-           In_Tree.Private_Part.Ada_Path_Buffer\n-             (1 .. In_Tree.Private_Part.Ada_Path_Length);\n-         Free (In_Tree.Private_Part.Ada_Path_Buffer);\n-         In_Tree.Private_Part.Ada_Path_Buffer := New_Buffer;\n+         New_Buffer (1 .. Buffer_Last) := Buffer (1 .. Buffer_Last);\n+         Free (Buffer);\n+         Buffer := New_Buffer;\n       end if;\n \n-      if In_Tree.Private_Part.Ada_Path_Length > 0 then\n-         In_Tree.Private_Part.Ada_Path_Length :=\n-           In_Tree.Private_Part.Ada_Path_Length + 1;\n-         In_Tree.Private_Part.Ada_Path_Buffer\n-           (In_Tree.Private_Part.Ada_Path_Length) := Path_Separator;\n+      if Buffer_Last > 0 then\n+         Buffer_Last := Buffer_Last + 1;\n+         Buffer (Buffer_Last) := Path_Separator;\n       end if;\n \n-      In_Tree.Private_Part.Ada_Path_Buffer\n-        (In_Tree.Private_Part.Ada_Path_Length + 1 ..\n-           In_Tree.Private_Part.Ada_Path_Length + Dir'Length) := Dir;\n-      In_Tree.Private_Part.Ada_Path_Length :=\n-        In_Tree.Private_Part.Ada_Path_Length + Dir'Length;\n+      Buffer (Buffer_Last + 1 .. Buffer_Last + Dir'Length) := Dir;\n+      Buffer_Last := Buffer_Last + Dir'Length;\n    end Add_To_Path;\n \n    ------------------------\n    -- Add_To_Source_Path --\n    ------------------------\n \n    procedure Add_To_Source_Path\n-     (Source_Dirs : String_List_Id; In_Tree : Project_Tree_Ref)\n+     (Source_Dirs  : String_List_Id;\n+      In_Tree      : Project_Tree_Ref;\n+      Source_Paths : in out Source_Path_Table.Instance)\n    is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n@@ -352,25 +367,18 @@ package body Prj.Env is\n          --  Check if the source directory is already in the table\n \n          for Index in Source_Path_Table.First ..\n-                      Source_Path_Table.Last\n-                                          (In_Tree.Private_Part.Source_Paths)\n+                      Source_Path_Table.Last (Source_Paths)\n          loop\n             --  If it is already, no need to add it\n \n-            if In_Tree.Private_Part.Source_Paths.Table (Index) =\n-                        Source_Dir.Value\n-            then\n+            if Source_Paths.Table (Index) = Source_Dir.Value then\n                Add_It := False;\n                exit;\n             end if;\n          end loop;\n \n          if Add_It then\n-            Source_Path_Table.Increment_Last\n-              (In_Tree.Private_Part.Source_Paths);\n-            In_Tree.Private_Part.Source_Paths.Table\n-              (Source_Path_Table.Last (In_Tree.Private_Part.Source_Paths)) :=\n-              Source_Dir.Value;\n+            Source_Path_Table.Append (Source_Paths, Source_Dir.Value);\n          end if;\n \n          --  Next source directory\n@@ -533,21 +541,8 @@ package body Prj.Env is\n       procedure Check_Temp_File is\n       begin\n          if File = Invalid_FD then\n-            Tempdir.Create_Temp_File (File, Name => File_Name);\n-\n-            if File = Invalid_FD then\n-               Prj.Com.Fail\n-                 (\"unable to create temporary configuration pragmas file\");\n-\n-            else\n-               Record_Temp_File (File_Name);\n-\n-               if Opt.Verbose_Mode then\n-                  Write_Str (\"Creating temp file \"\"\");\n-                  Write_Str (Get_Name_String (File_Name));\n-                  Write_Line (\"\"\"\");\n-               end if;\n-            end if;\n+            Create_Temp_File\n+              (In_Tree, File, File_Name, \"configuration pragmas\");\n          end if;\n       end Check_Temp_File;\n \n@@ -795,7 +790,7 @@ package body Prj.Env is\n                if Source.Unit /= No_Unit_Index then\n                   Get_Name_String (Source.Unit.Name);\n \n-                  if Get_Mode = Ada_Only then\n+                  if Source.Language.Config.Kind = Unit_Based then\n \n                      --  ??? Mapping_Spec_Suffix could be set in the case of\n                      --  gnatmake as well\n@@ -855,20 +850,7 @@ package body Prj.Env is\n \n       --  Create the temporary file\n \n-      Tempdir.Create_Temp_File (File, Name => Name);\n-\n-      if File = Invalid_FD then\n-         Prj.Com.Fail (\"unable to create temporary mapping file\");\n-\n-      else\n-         Record_Temp_File (Name);\n-\n-         if Opt.Verbose_Mode then\n-            Write_Str (\"Creating temp mapping file \"\"\");\n-            Write_Str (Get_Name_String (Name));\n-            Write_Line (\"\"\"\");\n-         end if;\n-      end if;\n+      Create_Temp_File (In_Tree, File, Name, \"mapping\");\n \n       For_Every_Imported_Project (Project, Dummy);\n       GNAT.OS_Lib.Close (File, Status);\n@@ -883,66 +865,44 @@ package body Prj.Env is\n       end if;\n    end Create_Mapping_File;\n \n-   --------------------------\n-   -- Create_New_Path_File --\n-   --------------------------\n+   ----------------------\n+   -- Create_Temp_File --\n+   ----------------------\n \n-   procedure Create_New_Path_File\n+   procedure Create_Temp_File\n      (In_Tree   : Project_Tree_Ref;\n       Path_FD   : out File_Descriptor;\n-      Path_Name : out Path_Name_Type)\n+      Path_Name : out Path_Name_Type;\n+      File_Use  : String)\n    is\n    begin\n       Tempdir.Create_Temp_File (Path_FD, Path_Name);\n \n       if Path_Name /= No_Path then\n-         Record_Temp_File (Path_Name);\n+         if Current_Verbosity = High then\n+            Write_Line (\"Create temp file (\" & File_Use & \") \"\n+                        & Get_Name_String (Path_Name));\n+         end if;\n \n-         --  Record the name, so that the temp path file will be deleted at the\n-         --  end of the program.\n+         Record_Temp_File (In_Tree, Path_Name);\n \n-         Path_File_Table.Increment_Last (In_Tree.Private_Part.Path_Files);\n-         In_Tree.Private_Part.Path_Files.Table\n-           (Path_File_Table.Last (In_Tree.Private_Part.Path_Files)) :=\n-              Path_Name;\n+      else\n+         Prj.Com.Fail\n+           (\"unable to create temporary \" & File_Use & \" file\");\n       end if;\n-   end Create_New_Path_File;\n-\n-   ---------------------------\n-   -- Delete_All_Path_Files --\n-   ---------------------------\n+   end Create_Temp_File;\n \n-   procedure Delete_All_Path_Files (In_Tree : Project_Tree_Ref) is\n-      Disregard : Boolean := True;\n-      pragma Unreferenced (Disregard);\n+   --------------------------\n+   -- Create_New_Path_File --\n+   --------------------------\n \n+   procedure Create_New_Path_File\n+     (In_Tree   : Project_Tree_Ref;\n+      Path_FD   : out File_Descriptor;\n+      Path_Name : out Path_Name_Type) is\n    begin\n-      for Index in Path_File_Table.First ..\n-                   Path_File_Table.Last (In_Tree.Private_Part.Path_Files)\n-      loop\n-         if In_Tree.Private_Part.Path_Files.Table (Index) /= No_Path then\n-            Delete_File\n-              (Get_Name_String\n-                 (In_Tree.Private_Part.Path_Files.Table (Index)),\n-               Disregard);\n-         end if;\n-      end loop;\n-\n-      --  If any of the environment variables ADA_PRJ_INCLUDE_FILE or\n-      --  ADA_PRJ_OBJECTS_FILE has been set, then reset their value to\n-      --  the empty string. On VMS, this has the effect of deassigning\n-      --  the logical names.\n-\n-      if In_Tree.Private_Part.Ada_Prj_Include_File_Set then\n-         Setenv (Project_Include_Path_File, \"\");\n-         In_Tree.Private_Part.Ada_Prj_Include_File_Set := False;\n-      end if;\n-\n-      if In_Tree.Private_Part.Ada_Prj_Objects_File_Set then\n-         Setenv (Project_Objects_Path_File, \"\");\n-         In_Tree.Private_Part.Ada_Prj_Objects_File_Set := False;\n-      end if;\n-   end Delete_All_Path_Files;\n+      Create_Temp_File (In_Tree, Path_FD, Path_Name, \"path file\");\n+   end Create_New_Path_File;\n \n    ------------------------------------\n    -- File_Name_Of_Library_Unit_Body --\n@@ -1345,7 +1305,6 @@ package body Prj.Env is\n \n    procedure Initialize (In_Tree : Project_Tree_Ref) is\n    begin\n-      In_Tree.Private_Part.Fill_Mapping_File := True;\n       In_Tree.Private_Part.Current_Source_Path_File := No_Path;\n       In_Tree.Private_Part.Current_Object_Path_File := No_Path;\n    end Initialize;\n@@ -1525,8 +1484,15 @@ package body Prj.Env is\n       Including_Libraries : Boolean)\n \n    is\n+      Source_Paths : Source_Path_Table.Instance;\n+      Object_Paths : Object_Path_Table.Instance;\n+      --  List of source or object dirs. Only computed the first time this\n+      --  procedure is called (since Source_FD is then reused)\n+\n       Source_FD : File_Descriptor := Invalid_FD;\n       Object_FD : File_Descriptor := Invalid_FD;\n+      --  The temporary files to store the paths. These are only created the\n+      --  first time this procedure is called, and reused from then on.\n \n       Process_Source_Dirs : Boolean := False;\n       Process_Object_Dirs : Boolean := False;\n@@ -1558,7 +1524,7 @@ package body Prj.Env is\n             --  Ada sources.\n \n             if Has_Ada_Sources (Project) then\n-               Add_To_Source_Path (Project.Source_Dirs, In_Tree);\n+               Add_To_Source_Path (Project.Source_Dirs, In_Tree, Source_Paths);\n             end if;\n          end if;\n \n@@ -1569,7 +1535,7 @@ package body Prj.Env is\n                Only_If_Ada         => True);\n \n             if Path /= No_Path then\n-               Add_To_Object_Path (Path, In_Tree);\n+               Add_To_Object_Path (Path, Object_Paths);\n             end if;\n          end if;\n       end Recursive_Add;\n@@ -1585,6 +1551,7 @@ package body Prj.Env is\n       --  compute the source path and/or the object path.\n \n       if Project.Include_Path_File = No_Path then\n+         Source_Path_Table.Init (Source_Paths);\n          Process_Source_Dirs := True;\n          Create_New_Path_File\n            (In_Tree, Source_FD, Project.Include_Path_File);\n@@ -1595,13 +1562,15 @@ package body Prj.Env is\n \n       if Including_Libraries then\n          if Project.Objects_Path_File_With_Libs = No_Path then\n+            Object_Path_Table.Init (Object_Paths);\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n               (In_Tree, Object_FD, Project.Objects_Path_File_With_Libs);\n          end if;\n \n       else\n          if Project.Objects_Path_File_Without_Libs = No_Path then\n+            Object_Path_Table.Init (Object_Paths);\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n               (In_Tree, Object_FD, Project.Objects_Path_File_Without_Libs);\n@@ -1612,19 +1581,18 @@ package body Prj.Env is\n       --  then call the recursive procedure Add for Project.\n \n       if Process_Source_Dirs or Process_Object_Dirs then\n-         Source_Path_Table.Set_Last (In_Tree.Private_Part.Source_Paths, 0);\n-         Object_Path_Table.Set_Last (In_Tree.Private_Part.Object_Paths, 0);\n          For_All_Projects (Project, Dummy);\n       end if;\n \n-      --  Write and close any file that has been created\n+      --  Write and close any file that has been created. Source_FD is not set\n+      --  when this subprogram is called a second time or more, since we reuse\n+      --  the previous version of the file.\n \n       if Source_FD /= Invalid_FD then\n          for Index in Source_Path_Table.First ..\n-                      Source_Path_Table.Last\n-                        (In_Tree.Private_Part.Source_Paths)\n+                      Source_Path_Table.Last (Source_Paths)\n          loop\n-            Get_Name_String (In_Tree.Private_Part.Source_Paths.Table (Index));\n+            Get_Name_String (Source_Paths.Table (Index));\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := ASCII.LF;\n             Len := Write (Source_FD, Name_Buffer (1)'Address, Name_Len);\n@@ -1643,10 +1611,9 @@ package body Prj.Env is\n \n       if Object_FD /= Invalid_FD then\n          for Index in Object_Path_Table.First ..\n-                      Object_Path_Table.Last\n-                        (In_Tree.Private_Part.Object_Paths)\n+                      Object_Path_Table.Last (Object_Paths)\n          loop\n-            Get_Name_String (In_Tree.Private_Part.Object_Paths.Table (Index));\n+            Get_Name_String (Object_Paths.Table (Index));\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := ASCII.LF;\n             Len := Write (Object_FD, Name_Buffer (1)'Address, Name_Len);\n@@ -1705,17 +1672,6 @@ package body Prj.Env is\n       end if;\n    end Set_Ada_Paths;\n \n-   ---------------------------------------------\n-   -- Set_Mapping_File_Initial_State_To_Empty --\n-   ---------------------------------------------\n-\n-   procedure Set_Mapping_File_Initial_State_To_Empty\n-     (In_Tree : Project_Tree_Ref)\n-   is\n-   begin\n-      In_Tree.Private_Part.Fill_Mapping_File := False;\n-   end Set_Mapping_File_Initial_State_To_Empty;\n-\n    -----------------------\n    -- Set_Path_File_Var --\n    -----------------------"}, {"sha": "ffcea0756b660585cb0467705bbaf7c72d38fa71", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -55,12 +55,6 @@ package Prj.Env is\n    --\n    --  See fmap for a description of the format of the mapping file\n \n-   procedure Set_Mapping_File_Initial_State_To_Empty\n-     (In_Tree : Project_Tree_Ref);\n-   --  When creating a mapping file, create an empty map. This case occurs when\n-   --  run time source files are found in the project files. This only applies\n-   --  to the Ada_Only mode.\n-\n    procedure Create_Config_Pragmas_File\n      (For_Project : Project_Id;\n       In_Tree     : Project_Tree_Ref);\n@@ -72,19 +66,11 @@ package Prj.Env is\n       Path_FD   : out File_Descriptor;\n       Path_Name : out Path_Name_Type);\n    --  Create a new temporary path file. Get the file name in Path_Name.\n-   --  The name is normally obtained by increasing the number in\n-   --  Temp_Path_File_Name by 1.\n-\n-   function Ada_Include_Path\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return String_Access;\n-   --  Get the source search path of a Project file. For the first call,\n-   --  compute it and cache it.\n \n    function Ada_Include_Path\n      (Project   : Project_Id;\n       In_Tree   : Project_Tree_Ref;\n-      Recursive : Boolean) return String;\n+      Recursive : Boolean := False) return String;\n    --  Get the source search path of a Project file. If Recursive it True, get\n    --  all the source directories of the imported and modified project files\n    --  (recursively). If Recursive is False, just get the path for the source\n@@ -93,7 +79,6 @@ package Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n-      In_Tree             : Project_Tree_Ref;\n       Including_Libraries : Boolean := True) return String_Access;\n    --  Get the ADA_OBJECTS_PATH of a Project file. For the first call, compute\n    --  it and cache it. When Including_Libraries is False, do not include the\n@@ -106,9 +91,6 @@ package Prj.Env is\n    --  Set the environment variables for additional project path files, after\n    --  creating the path files if necessary.\n \n-   procedure Delete_All_Path_Files (In_Tree : Project_Tree_Ref);\n-   --  Delete all temporary path files that have been created by Set_Ada_Paths\n-\n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;"}, {"sha": "853542ec494ec9c618a71aedacbf644ccb059d5f", "filename": "gcc/ada/prj-ext.adb", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-ext.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-ext.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-ext.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -25,7 +25,6 @@\n \n with Hostparm;\n with Makeutl;  use Makeutl;\n-with Output;   use Output;\n with Osint;    use Osint;\n with Sdefault;\n with Table;\n@@ -139,23 +138,8 @@ package body Prj.Ext is\n       Last            : Positive;\n       New_Len         : Positive;\n       New_Last        : Positive;\n-      Prj_Path        : String_Access := Gpr_Prj_Path;\n \n    begin\n-      if Gpr_Prj_Path.all /= \"\" then\n-\n-         --  In Ada only mode, warn if both environment variables are defined\n-\n-         if Get_Mode = Ada_Only and then Ada_Prj_Path.all /= \"\" then\n-            Write_Line\n-              (\"Warning: ADA_PROJECT_PATH is not taken into account\");\n-            Write_Line (\"         when GPR_PROJECT_PATH is defined\");\n-         end if;\n-\n-      else\n-         Prj_Path := Ada_Prj_Path;\n-      end if;\n-\n       --  The current directory is always first\n \n       Name_Len := 1;\n@@ -172,11 +156,16 @@ package body Prj.Ext is\n \n       --  If environment variable is defined and not empty, add its content\n \n-      if Prj_Path.all /= \"\" then\n+      if Gpr_Prj_Path.all /= \"\" then\n          Name_Len := Name_Len + 1;\n          Name_Buffer (Name_Len) := Path_Separator;\n+         Add_Str_To_Name_Buffer (Gpr_Prj_Path.all);\n+      end if;\n \n-         Add_Str_To_Name_Buffer (Prj_Path.all);\n+      if Ada_Prj_Path.all /= \"\" then\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := Path_Separator;\n+         Add_Str_To_Name_Buffer (Ada_Prj_Path.all);\n       end if;\n \n       --  Scan the directory path to see if \"-\" is one of the directories.\n@@ -260,12 +249,9 @@ package body Prj.Ext is\n                Prefix := new String'(Executable_Prefix_Path);\n \n                if Prefix.all /= \"\" then\n-                  if Get_Mode = Multi_Language then\n-                     Add_Str_To_Name_Buffer\n-                       (Path_Separator & Prefix.all &\n-                        \"share\" & Directory_Separator & \"gpr\");\n-                  end if;\n-\n+                  Add_Str_To_Name_Buffer\n+                    (Path_Separator & Prefix.all &\n+                     \"share\" & Directory_Separator & \"gpr\");\n                   Add_Str_To_Name_Buffer\n                     (Path_Separator & Prefix.all &\n                      Directory_Separator & \"lib\" &"}, {"sha": "ec4e9a80440c98ec24e2a83ce0ac58eba1fed46e", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 104, "deletions": 337, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -28,11 +28,9 @@ with GNAT.Directory_Operations;  use GNAT.Directory_Operations;\n with GNAT.Dynamic_HTables;\n \n with Err_Vars; use Err_Vars;\n-with MLib.Tgt;\n with Opt;      use Opt;\n with Osint;    use Osint;\n with Output;   use Output;\n-with Prj.Env;  use Prj.Env;\n with Prj.Err;\n with Prj.Util; use Prj.Util;\n with Sinput.P;\n@@ -52,9 +50,6 @@ package body Prj.Nmsc is\n    --  Used in Check_Library for continuation error messages at the same\n    --  location.\n \n-   ALI_Suffix   : constant String := \".ali\";\n-   --  File suffix for ali files\n-\n    type Name_Location is record\n       Name     : File_Name_Type;  --  ??? duplicates the key\n       Location : Source_Ptr;\n@@ -232,9 +227,6 @@ package body Prj.Nmsc is\n    --  Copy Str into Name_Buffer, replacing Pattern with Replacement. Str is\n    --  converted to lower-case at the same time.\n \n-   function ALI_File_Name (Source : String) return String;\n-   --  Return the ALI file name corresponding to a source\n-\n    procedure Check_Ada_Name (Name : String; Unit : out Name_Id);\n    --  Check that a name is a valid Ada unit name\n \n@@ -278,16 +270,8 @@ package body Prj.Nmsc is\n    --  tree Data.Tree and set the components of Data for all the programming\n    --  languages indicated in attribute Languages, if any.\n \n-   function Check_Project\n-     (P            : Project_Id;\n-      Root_Project : Project_Id;\n-      Extending    : Boolean) return Boolean;\n-   --  Returns True if P is Root_Project or, if Extending is True, a project\n-   --  extended by Root_Project.\n-\n    procedure Check_Stand_Alone_Library\n      (Project     : Project_Id;\n-      Extending   : Boolean;\n       Data        : in out Tree_Processing_Data);\n    --  Check if project Project in project tree Data.Tree is a Stand-Alone\n    --  Library project, and modify its data Data accordingly if it is one.\n@@ -304,6 +288,9 @@ package body Prj.Nmsc is\n    --  Output an error message. If Data.Error_Report is null, simply call\n    --  Prj.Err.Error_Msg. Otherwise, disregard Flag_Location and use\n    --  Error_Report.\n+   --  If Msg starts with \"?\", this is a warning, and Warning: is adding at the\n+   --  beginning. If Msg starts with \"<\", see comment\n+   --  for Err_Vars.Error_Msg_Warn\n \n    procedure Search_Directories\n      (Project         : in out Project_Processing_Data;\n@@ -747,12 +734,6 @@ package body Prj.Nmsc is\n       --  is not null.\n \n       if Unit /= No_Name then\n-         Unit_Sources_Htable.Set (Data.Tree.Unit_Sources_HT, Unit, Id);\n-\n-         --  ??? Record_Unit has already fetched that earlier, so this isn't\n-         --  the most efficient way. But we can't really pass a parameter since\n-         --  Process_Exceptions_Unit_Based and Check_File haven't looked it up.\n-\n          UData := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n \n          if UData = No_Unit_Index then\n@@ -797,25 +778,6 @@ package body Prj.Nmsc is\n       Files_Htable.Set (Data.File_To_Source, File_Name, Id);\n    end Add_Source;\n \n-   -------------------\n-   -- ALI_File_Name --\n-   -------------------\n-\n-   function ALI_File_Name (Source : String) return String is\n-   begin\n-      --  If the source name has extension, replace it with the ALI suffix\n-\n-      for Index in reverse Source'First + 1 .. Source'Last loop\n-         if Source (Index) = '.' then\n-            return Source (Source'First .. Index - 1) & ALI_Suffix;\n-         end if;\n-      end loop;\n-\n-      --  If no dot, or if it is the first character, just add the ALI suffix\n-\n-      return Source & ALI_Suffix;\n-   end ALI_File_Name;\n-\n    ------------------------------\n    -- Canonical_Case_File_Name --\n    ------------------------------\n@@ -896,11 +858,11 @@ package body Prj.Nmsc is\n          end;\n       end if;\n \n-      --  Check configuration in multi language mode\n+      --  Check configuration. This must be done even for gnatmake (even though\n+      --  no user configuration file was provided) since the default config we\n+      --  generate indicates whether libraries are supported for instance.\n \n-      if Must_Check_Configuration then\n-         Check_Configuration (Project, Data);\n-      end if;\n+      Check_Configuration (Project, Data);\n \n       --  Library attributes\n \n@@ -982,7 +944,7 @@ package body Prj.Nmsc is\n       --  If it is a library project file, check if it is a standalone library\n \n       if Project.Library then\n-         Check_Stand_Alone_Library (Project, Extending, Data);\n+         Check_Stand_Alone_Library (Project, Data);\n       end if;\n \n       --  Put the list of Mains, if any, in the project data\n@@ -2420,8 +2382,9 @@ package body Prj.Nmsc is\n             --  For file based languages, either Spec_Suffix or Body_Suffix\n             --  need to be specified.\n \n-            if Lang_Index.Config.Naming_Data.Spec_Suffix = No_File and then\n-              Lang_Index.Config.Naming_Data.Body_Suffix = No_File\n+            if Data.Flags.Require_Sources_Other_Lang\n+              and then Lang_Index.Config.Naming_Data.Spec_Suffix = No_File\n+              and then Lang_Index.Config.Naming_Data.Body_Suffix = No_File\n             then\n                Error_Msg_Name_1 := Lang_Index.Display_Name;\n                Error_Msg\n@@ -3652,12 +3615,7 @@ package body Prj.Nmsc is\n       end if;\n \n       if Project.Library then\n-         if Get_Mode = Multi_Language then\n-            Support_For_Libraries := Project.Config.Lib_Support;\n-\n-         else\n-            Support_For_Libraries := MLib.Tgt.Support_For_Libraries;\n-         end if;\n+         Support_For_Libraries := Project.Config.Lib_Support;\n \n          if Support_For_Libraries = Prj.None then\n             Error_Msg\n@@ -4011,26 +3969,8 @@ package body Prj.Nmsc is\n          Lang.Display_Name := Display_Name;\n \n          if Name = Name_Ada then\n-            Lang.Config.Kind := Unit_Based;\n+            Lang.Config.Kind            := Unit_Based;\n             Lang.Config.Dependency_Kind := ALI_File;\n-\n-            if Get_Mode = Ada_Only then\n-\n-               --  Create a default config for Ada (since there is no\n-               --  configuration file to create it for us).\n-\n-               --  ??? We should do as GPS does and create a dummy config file\n-\n-               Lang.Config.Naming_Data :=\n-                 (Dot_Replacement =>\n-                    File_Name_Type\n-                      (First_Name_Id + Character'Pos ('-')),\n-                  Casing          => All_Lower_Case,\n-                  Separate_Suffix => Default_Ada_Body_Suffix,\n-                  Spec_Suffix     => Default_Ada_Spec_Suffix,\n-                  Body_Suffix     => Default_Ada_Body_Suffix);\n-            end if;\n-\n          else\n             Lang.Config.Kind := File_Based;\n          end if;\n@@ -4046,40 +3986,25 @@ package body Prj.Nmsc is\n         Prj.Util.Value_Of\n           (Name_Default_Language, Project.Decl.Attributes, Data.Tree);\n \n-      --  Shouldn't these be set to False by default, and only set to True when\n-      --  we actually find some source file???\n-\n       if Project.Source_Dirs /= Nil_String then\n \n          --  Check if languages are specified in this project\n \n          if Languages.Default then\n \n-            --  In Ada_Only mode, the default language is Ada\n+            --  Fail if there is no default language defined\n \n-            if Get_Mode = Ada_Only then\n-               Def_Lang_Id := Name_Ada;\n+            if Def_Lang.Default then\n+               Error_Msg\n+                 (Project,\n+                  \"no languages defined for this project\",\n+                  Project.Location, Data);\n+               Def_Lang_Id := No_Name;\n \n             else\n-               --  Fail if there is no default language defined\n-\n-               if Def_Lang.Default then\n-                  if not Default_Language_Is_Ada then\n-                     Error_Msg\n-                       (Project,\n-                        \"no languages defined for this project\",\n-                        Project.Location, Data);\n-                     Def_Lang_Id := No_Name;\n-\n-                  else\n-                     Def_Lang_Id := Name_Ada;\n-                  end if;\n-\n-               else\n-                  Get_Name_String (Def_Lang.Value);\n-                  To_Lower (Name_Buffer (1 .. Name_Len));\n-                  Def_Lang_Id := Name_Find;\n-               end if;\n+               Get_Name_String (Def_Lang.Value);\n+               To_Lower (Name_Buffer (1 .. Name_Len));\n+               Def_Lang_Id := Name_Find;\n             end if;\n \n             if Def_Lang_Id /= No_Name then\n@@ -4129,42 +4054,12 @@ package body Prj.Nmsc is\n       end if;\n    end Check_Programming_Languages;\n \n-   -------------------\n-   -- Check_Project --\n-   -------------------\n-\n-   function Check_Project\n-     (P            : Project_Id;\n-      Root_Project : Project_Id;\n-      Extending    : Boolean) return Boolean\n-   is\n-      Prj : Project_Id;\n-\n-   begin\n-      if P = Root_Project then\n-         return True;\n-\n-      elsif Extending then\n-         Prj := Root_Project;\n-         while Prj.Extends /= No_Project loop\n-            if P = Prj.Extends then\n-               return True;\n-            end if;\n-\n-            Prj := Prj.Extends;\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Check_Project;\n-\n    -------------------------------\n    -- Check_Stand_Alone_Library --\n    -------------------------------\n \n    procedure Check_Stand_Alone_Library\n      (Project     : Project_Id;\n-      Extending   : Boolean;\n       Data        : in out Tree_Processing_Data)\n    is\n       Lib_Interfaces      : constant Prj.Variable_Value :=\n@@ -4210,68 +4105,18 @@ package body Prj.Nmsc is\n       Iter                : Source_Iterator;\n \n    begin\n-      if Get_Mode = Multi_Language then\n-         Auto_Init_Supported := Project.Config.Auto_Init_Supported;\n-      else\n-         Auto_Init_Supported :=\n-           MLib.Tgt.Standalone_Library_Auto_Init_Is_Supported;\n-      end if;\n+      Auto_Init_Supported := Project.Config.Auto_Init_Supported;\n \n       pragma Assert (Lib_Interfaces.Kind = List);\n \n       --  It is a stand-alone library project file if attribute\n       --  Library_Interface is defined.\n \n       if not Lib_Interfaces.Default then\n-         SAL_Library : declare\n+         declare\n             Interfaces     : String_List_Id := Lib_Interfaces.Values;\n             Interface_ALIs : String_List_Id := Nil_String;\n             Unit           : Name_Id;\n-            UData          : Unit_Index;\n-\n-            procedure Add_ALI_For (Source : File_Name_Type);\n-            --  Add an ALI file name to the list of Interface ALIs\n-\n-            -----------------\n-            -- Add_ALI_For --\n-            -----------------\n-\n-            procedure Add_ALI_For (Source : File_Name_Type) is\n-            begin\n-               Get_Name_String (Source);\n-\n-               declare\n-                  ALI         : constant String :=\n-                                  ALI_File_Name (Name_Buffer (1 .. Name_Len));\n-                  ALI_Name_Id : Name_Id;\n-\n-               begin\n-                  Name_Len := ALI'Length;\n-                  Name_Buffer (1 .. Name_Len) := ALI;\n-                  ALI_Name_Id := Name_Find;\n-\n-                  String_Element_Table.Increment_Last\n-                    (Data.Tree.String_Elements);\n-\n-                  Data.Tree.String_Elements.Table\n-                    (String_Element_Table.Last\n-                      (Data.Tree.String_Elements)) :=\n-                         (Value         => ALI_Name_Id,\n-                          Index         => 0,\n-                          Display_Value => ALI_Name_Id,\n-                          Location      =>\n-                            Data.Tree.String_Elements.Table\n-                              (Interfaces).Location,\n-                          Flag          => False,\n-                          Next          => Interface_ALIs);\n-\n-                  Interface_ALIs :=\n-                    String_Element_Table.Last\n-                      (Data.Tree.String_Elements);\n-               end;\n-            end Add_ALI_For;\n-\n-         --  Start of processing for SAL_Library\n \n          begin\n             Project.Standalone_Library := True;\n@@ -4304,155 +4149,76 @@ package body Prj.Nmsc is\n                   Unit := Name_Find;\n                   Error_Msg_Name_1 := Unit;\n \n-                  if Get_Mode = Ada_Only then\n-                     UData := Units_Htable.Get (Data.Tree.Units_HT, Unit);\n-\n-                     --  Check that the unit is part of the project\n-\n-                     if UData /= null\n-                       and then UData.File_Names (Impl) /= null\n-                       and then not UData.File_Names (Impl).Locally_Removed\n-                     then\n-                        if Check_Project\n-                             (UData.File_Names (Impl).Project,\n-                              Project, Extending)\n-                        then\n-                           --  There is a body for this unit. If there is no\n-                           --  spec, we need to check that it is not a subunit.\n-\n-                           if UData.File_Names (Spec) = null then\n-                              declare\n-                                 Src_Ind : Source_File_Index;\n-\n-                              begin\n-                                 Src_Ind :=\n-                                   Sinput.P.Load_Project_File\n-                                     (Get_Name_String (UData.File_Names\n-                                      (Impl).Path.Name));\n-\n-                                 if Sinput.P.Source_File_Is_Subunit\n-                                      (Src_Ind)\n-                                 then\n-                                    Error_Msg\n-                                      (Project,\n-                                       \"%% is a subunit; \" &\n-                                       \"it cannot be an interface\",\n-                                       Data.Tree.\n-                                         String_Elements.Table\n-                                           (Interfaces).Location,\n-                                       Data);\n-                                 end if;\n-                              end;\n-                           end if;\n-\n-                           --  The unit is not a subunit, so we add the ALI\n-                           --  file for its body to the Interface ALIs.\n+                  Next_Proj := Project.Extends;\n+                  Iter := For_Each_Source (Data.Tree, Project);\n+                  loop\n+                     while Prj.Element (Iter) /= No_Source\n+                       and then\n+                         (Prj.Element (Iter).Unit = null\n+                          or else Prj.Element (Iter).Unit.Name /= Unit)\n+                     loop\n+                        Next (Iter);\n+                     end loop;\n \n-                           Add_ALI_For (UData.File_Names (Impl).File);\n+                     Source := Prj.Element (Iter);\n+                     exit when Source /= No_Source\n+                       or else Next_Proj = No_Project;\n \n-                        else\n-                           Error_Msg\n-                             (Project,\n-                              \"%% is not an unit of this project\",\n-                              Data.Tree.String_Elements.Table\n-                                (Interfaces).Location, Data);\n-                        end if;\n+                     Iter := For_Each_Source (Data.Tree, Next_Proj);\n+                     Next_Proj := Next_Proj.Extends;\n+                  end loop;\n \n-                     elsif UData /= null\n-                       and then UData.File_Names (Spec) /= null\n-                       and then not UData.File_Names (Spec).Locally_Removed\n-                       and then Check_Project\n-                                  (UData.File_Names (Spec).Project,\n-                                   Project, Extending)\n+                  if Source /= No_Source then\n+                     if Source.Kind = Sep then\n+                        Source := No_Source;\n \n+                     elsif Source.Kind = Spec\n+                       and then Other_Part (Source) /= No_Source\n                      then\n-                        --  The unit is part of the project, it has a spec,\n-                        --  but no body. We add the ALI for its spec to the\n-                        --  Interface ALIs.\n-\n-                        Add_ALI_For (UData.File_Names (Spec).File);\n-\n-                     else\n-                        Error_Msg\n-                          (Project,\n-                           \"%% is not an unit of this project\",\n-                           Data.Tree.String_Elements.Table\n-                             (Interfaces).Location, Data);\n-                     end if;\n-\n-                  else\n-                     Next_Proj := Project.Extends;\n-                     Iter := For_Each_Source (Data.Tree, Project);\n-                     loop\n-                        while Prj.Element (Iter) /= No_Source\n-                          and then\n-                            (Prj.Element (Iter).Unit = null\n-                               or else Prj.Element (Iter).Unit.Name /= Unit)\n-                        loop\n-                           Next (Iter);\n-                        end loop;\n-\n-                        Source := Prj.Element (Iter);\n-                        exit when Source /= No_Source\n-                          or else Next_Proj = No_Project;\n-\n-                        Iter := For_Each_Source (Data.Tree, Next_Proj);\n-                        Next_Proj := Next_Proj.Extends;\n-                     end loop;\n-\n-                     if Source /= No_Source then\n-                        if Source.Kind = Sep then\n-                           Source := No_Source;\n-                        elsif Source.Kind = Spec\n-                          and then Other_Part (Source) /= No_Source\n-                        then\n-                           Source := Other_Part (Source);\n-                        end if;\n+                        Source := Other_Part (Source);\n                      end if;\n+                  end if;\n \n-                     if Source /= No_Source then\n-                        if Source.Project /= Project\n-                          and then not Is_Extending (Project, Source.Project)\n-                        then\n-                           Source := No_Source;\n-                        end if;\n+                  if Source /= No_Source then\n+                     if Source.Project /= Project\n+                       and then not Is_Extending (Project, Source.Project)\n+                     then\n+                        Source := No_Source;\n                      end if;\n+                  end if;\n \n-                     if Source = No_Source then\n-                           Error_Msg\n-                             (Project,\n-                              \"%% is not an unit of this project\",\n-                              Data.Tree.String_Elements.Table\n-                                (Interfaces).Location, Data);\n-\n-                     else\n-                        if Source.Kind = Spec\n-                          and then Other_Part (Source) /= No_Source\n-                        then\n-                           Source := Other_Part (Source);\n-                        end if;\n-\n-                        --  Can't we use Append here???\n-\n-                        String_Element_Table.Increment_Last\n-                          (Data.Tree.String_Elements);\n-\n+                  if Source = No_Source then\n+                     Error_Msg\n+                       (Project,\n+                        \"%% is not a unit of this project\",\n                         Data.Tree.String_Elements.Table\n-                          (String_Element_Table.Last\n-                             (Data.Tree.String_Elements)) :=\n-                               (Value         => Name_Id (Source.Dep_Name),\n-                                Index         => 0,\n-                                Display_Value => Name_Id (Source.Dep_Name),\n-                                Location      =>\n-                                  Data.Tree.String_Elements.Table\n-                                    (Interfaces).Location,\n-                                Flag          => False,\n-                                Next          => Interface_ALIs);\n-\n-                        Interface_ALIs :=\n-                          String_Element_Table.Last\n-                            (Data.Tree.String_Elements);\n+                          (Interfaces).Location, Data);\n+\n+                  else\n+                     if Source.Kind = Spec\n+                       and then Other_Part (Source) /= No_Source\n+                     then\n+                        Source := Other_Part (Source);\n                      end if;\n+\n+                     String_Element_Table.Increment_Last\n+                       (Data.Tree.String_Elements);\n+\n+                     Data.Tree.String_Elements.Table\n+                       (String_Element_Table.Last\n+                          (Data.Tree.String_Elements)) :=\n+                       (Value         => Name_Id (Source.Dep_Name),\n+                        Index         => 0,\n+                        Display_Value => Name_Id (Source.Dep_Name),\n+                        Location      =>\n+                          Data.Tree.String_Elements.Table\n+                            (Interfaces).Location,\n+                        Flag          => False,\n+                        Next          => Interface_ALIs);\n+\n+                     Interface_ALIs :=\n+                       String_Element_Table.Last\n+                         (Data.Tree.String_Elements);\n                   end if;\n                end if;\n \n@@ -4502,7 +4268,7 @@ package body Prj.Nmsc is\n                      Lib_Auto_Init.Location, Data);\n                end if;\n             end if;\n-         end SAL_Library;\n+         end;\n \n          --  If attribute Library_Src_Dir is defined and not the empty string,\n          --  check if the directory exist and is not the object directory or\n@@ -4984,9 +4750,6 @@ package body Prj.Nmsc is\n          First := First + 1;\n       end if;\n \n-      --  Warning character is always the first one in this package\n-      --  this is an undocumented kludge???\n-\n       if Msg (First) = '?' then\n          First := First + 1;\n          Add (\"Warning: \");\n@@ -5880,17 +5643,9 @@ package body Prj.Nmsc is\n    is\n       Filename : constant String  := Get_Name_String (File_Name);\n       Last     : Integer          := Filename'Last;\n-      Sep_Len  : constant Integer :=\n-                   Integer (Length_Of_Name (Naming.Separate_Suffix));\n-      Body_Len : constant Integer :=\n-                   Integer (Length_Of_Name (Naming.Body_Suffix));\n-      Spec_Len : constant Integer :=\n-                   Integer (Length_Of_Name (Naming.Spec_Suffix));\n-\n-      Standard_GNAT : constant Boolean :=\n-                        Naming.Spec_Suffix = Default_Ada_Spec_Suffix\n-                          and then\n-                        Naming.Body_Suffix = Default_Ada_Body_Suffix;\n+      Sep_Len  : Integer;\n+      Body_Len : Integer;\n+      Spec_Len : Integer;\n \n       Unit_Except : Unit_Exception;\n       Masked      : Boolean  := False;\n@@ -5899,6 +5654,13 @@ package body Prj.Nmsc is\n       Unit := No_Name;\n       Kind := Spec;\n \n+      if Naming.Separate_Suffix = No_File\n+        or else Naming.Body_Suffix = No_File\n+        or else Naming.Spec_Suffix = No_File\n+      then\n+         return;\n+      end if;\n+\n       if Naming.Dot_Replacement = No_File then\n          if Current_Verbosity = High then\n             Write_Line (\"  No dot_replacement specified\");\n@@ -5907,6 +5669,10 @@ package body Prj.Nmsc is\n          return;\n       end if;\n \n+      Sep_Len  := Integer (Length_Of_Name (Naming.Separate_Suffix));\n+      Spec_Len := Integer (Length_Of_Name (Naming.Spec_Suffix));\n+      Body_Len := Integer (Length_Of_Name (Naming.Body_Suffix));\n+\n       --  Choose the longest suffix that matches. If there are several matches,\n       --  give priority to specs, then bodies, then separates.\n \n@@ -6008,7 +5774,9 @@ package body Prj.Nmsc is\n       --  In the standard GNAT naming scheme, check for special cases: children\n       --  or separates of A, G, I or S, and run time sources.\n \n-      if Standard_GNAT and then Name_Len >= 3 then\n+      if Is_Standard_GNAT_Naming (Naming)\n+        and then Name_Len >= 3\n+      then\n          declare\n             S1 : constant Character := Name_Buffer (1);\n             S2 : constant Character := Name_Buffer (2);\n@@ -6037,10 +5805,9 @@ package body Prj.Nmsc is\n \n                elsif S2 = '.' then\n \n-                  --  If it is potentially a run time source, disable filling\n-                  --  of the mapping file to avoid warnings.\n+                  --  If it is potentially a run time source\n \n-                  Set_Mapping_File_Initial_State_To_Empty (In_Tree);\n+                  null;\n                end if;\n             end if;\n          end;"}, {"sha": "b0c84d56b32ae165627a60119a748f45946cf52a", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 55, "deletions": 63, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -147,6 +147,13 @@ package body Prj.Proc is\n    --  extended project, if any. Then process the declarative items of the\n    --  project.\n \n+   function Get_Attribute_Index\n+     (Tree  : Project_Node_Tree_Ref;\n+      Attr  : Project_Node_Id;\n+      Index : Name_Id) return Name_Id;\n+   --  Copy the index of the attribute into Name_Buffer, converting to lower\n+   --  case if the attribute is case-insensitive.\n+\n    ---------\n    -- Add --\n    ---------\n@@ -436,6 +443,43 @@ package body Prj.Proc is\n       end loop;\n    end Copy_Package_Declarations;\n \n+   -------------------------\n+   -- Get_Attribute_Index --\n+   -------------------------\n+\n+   function Get_Attribute_Index\n+     (Tree  : Project_Node_Tree_Ref;\n+      Attr  : Project_Node_Id;\n+      Index : Name_Id) return Name_Id\n+   is\n+      Lower : Boolean;\n+   begin\n+      Get_Name_String (Index);\n+      Lower := Case_Insensitive (Attr, Tree);\n+\n+      --  The index is always case insensitive if it does not include any dot.\n+      --  ??? Why not use the properties from prj-attr, simply, maybe because\n+      --  we don't know whether we have a file as an index ?\n+\n+      if not Lower then\n+         Lower := True;\n+\n+         for J in 1 .. Name_Len loop\n+            if Name_Buffer (J) = '.' then\n+               Lower := False;\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      if Lower then\n+         To_Lower (Name_Buffer (1 .. Name_Len));\n+         return Name_Find;\n+      else\n+         return Index;\n+      end if;\n+   end Get_Attribute_Index;\n+\n    ----------------\n    -- Expression --\n    ----------------\n@@ -767,7 +811,6 @@ package body Prj.Proc is\n                         The_Array   : Array_Id := No_Array;\n                         The_Element : Array_Element_Id := No_Array_Element;\n                         Array_Index : Name_Id := No_Name;\n-                        Lower       : Boolean;\n \n                      begin\n                         if The_Package /= No_Package then\n@@ -789,33 +832,11 @@ package body Prj.Proc is\n                         if The_Array /= No_Array then\n                            The_Element := In_Tree.Arrays.Table\n                                             (The_Array).Value;\n-\n-                           Get_Name_String (Index);\n-\n-                           Lower :=\n-                             Case_Insensitive\n-                               (The_Current_Term, From_Project_Node_Tree);\n-\n-                           --  In multi-language mode (gprbuild), the index is\n-                           --  always case insensitive if it does not include\n-                           --  any dot.\n-\n-                           if Get_Mode = Multi_Language and then not Lower then\n-                              Lower := True;\n-\n-                              for J in 1 .. Name_Len loop\n-                                 if Name_Buffer (J) = '.' then\n-                                    Lower := False;\n-                                    exit;\n-                                 end if;\n-                              end loop;\n-                           end if;\n-\n-                           if Lower then\n-                              To_Lower (Name_Buffer (1 .. Name_Len));\n-                           end if;\n-\n-                           Array_Index := Name_Find;\n+                           Array_Index :=\n+                             Get_Attribute_Index\n+                               (From_Project_Node_Tree,\n+                                The_Current_Term,\n+                                Index);\n \n                            while The_Element /= No_Array_Element\n                              and then\n@@ -1835,7 +1856,8 @@ package body Prj.Proc is\n                            pragma Assert\n                              (Kind_Of (Current_Item, From_Project_Node_Tree) /=\n                                 N_Attribute_Declaration,\n-                              \"illegal attribute declaration\");\n+                              \"illegal attribute declaration for \"\n+                              & Get_Name_String (Current_Item_Name));\n \n                            Variable_Element_Table.Increment_Last\n                              (In_Tree.Variable_Elements);\n@@ -1877,47 +1899,17 @@ package body Prj.Proc is\n                            Index_Name : Name_Id :=\n                              Associative_Array_Index_Of\n                                (Current_Item, From_Project_Node_Tree);\n-                           Lower      : Boolean;\n                            The_Array : Array_Id;\n-\n                            The_Array_Element : Array_Element_Id :=\n                                                  No_Array_Element;\n \n                         begin\n                            if Index_Name /= All_Other_Names then\n-                              --  Get the string index\n-\n-                              Get_Name_String\n-                                (Associative_Array_Index_Of\n+                              Index_Name := Get_Attribute_Index\n+                                (From_Project_Node_Tree,\n+                                 Current_Item,\n+                                 Associative_Array_Index_Of\n                                    (Current_Item, From_Project_Node_Tree));\n-\n-                              --  Put in lower case, if necessary\n-\n-                              Lower :=\n-                                Case_Insensitive\n-                                  (Current_Item, From_Project_Node_Tree);\n-\n-                              --  In multi-language mode (gprbuild), the index\n-                              --  is always case insensitive if it does not\n-                              --  include any dot.\n-\n-                              if Get_Mode = Multi_Language\n-                                and then not Lower\n-                              then\n-                                 for J in 1 .. Name_Len loop\n-                                    if Name_Buffer (J) = '.' then\n-                                       Lower := False;\n-                                       exit;\n-                                    end if;\n-                                 end loop;\n-                              end if;\n-\n-                              if Lower then\n-                                 GNAT.Case_Util.To_Lower\n-                                   (Name_Buffer (1 .. Name_Len));\n-                              end if;\n-\n-                              Index_Name := Name_Find;\n                            end if;\n \n                            --  Look for the array in the appropriate list"}, {"sha": "42b281fad1e98fc6177d97831510c2f161634191", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 199, "deletions": 1, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -2853,12 +2853,210 @@ package body Prj.Tree is\n          Name,\n          Prj.Tree.Tree_Private_Part.Project_Name_And_Node'\n          (Name           => Name,\n-          Canonical_Path => No_Path, --  ??? in GPS: Path_Name_Type (Name),\n+          Canonical_Path => No_Path,\n           Node           => Project,\n           Extended       => False,\n           Proj_Qualifier => Qualifier));\n \n       return Project;\n    end Create_Project;\n \n+   ----------------\n+   -- Add_At_End --\n+   ----------------\n+\n+   procedure Add_At_End\n+     (Tree                  : Project_Node_Tree_Ref;\n+      Parent                : Project_Node_Id;\n+      Expr                  : Project_Node_Id;\n+      Add_Before_First_Pkg  : Boolean := False;\n+      Add_Before_First_Case : Boolean := False)\n+   is\n+      Real_Parent          : Project_Node_Id;\n+      New_Decl, Decl, Next : Project_Node_Id;\n+      Last, L              : Project_Node_Id;\n+   begin\n+      if Kind_Of (Expr, Tree) /= N_Declarative_Item then\n+         New_Decl := Default_Project_Node (Tree, N_Declarative_Item);\n+         Set_Current_Item_Node (New_Decl, Tree, Expr);\n+      else\n+         New_Decl := Expr;\n+      end if;\n+\n+      if Kind_Of (Parent, Tree) = N_Project then\n+         Real_Parent := Project_Declaration_Of (Parent, Tree);\n+      else\n+         Real_Parent := Parent;\n+      end if;\n+\n+      Decl := First_Declarative_Item_Of (Real_Parent, Tree);\n+\n+      if Decl = Empty_Node then\n+         Set_First_Declarative_Item_Of (Real_Parent, Tree, New_Decl);\n+      else\n+         loop\n+            Next := Next_Declarative_Item (Decl, Tree);\n+            exit when Next = Empty_Node\n+              or else\n+              (Add_Before_First_Pkg\n+               and then Kind_Of (Current_Item_Node (Next, Tree), Tree)\n+                 = N_Package_Declaration)\n+              or else\n+              (Add_Before_First_Case\n+               and then Kind_Of (Current_Item_Node (Next, Tree), Tree)\n+                 = N_Case_Construction);\n+            Decl := Next;\n+         end loop;\n+\n+         --  In case Expr is in fact a range of declarative items\n+         Last := New_Decl;\n+         loop\n+            L := Next_Declarative_Item (Last, Tree);\n+            exit when L = Empty_Node;\n+            Last := L;\n+         end loop;\n+\n+         --  In case Expr is in fact a range of declarative items\n+         Last := New_Decl;\n+         loop\n+            L := Next_Declarative_Item (Last, Tree);\n+            exit when L = Empty_Node;\n+            Last := L;\n+         end loop;\n+\n+         Set_Next_Declarative_Item (Last, Tree, Next);\n+         Set_Next_Declarative_Item (Decl, Tree, New_Decl);\n+      end if;\n+   end Add_At_End;\n+\n+   ---------------------------\n+   -- Create_Literal_String --\n+   ---------------------------\n+\n+   function Create_Literal_String\n+     (Str  : Namet.Name_Id;\n+      Tree : Project_Node_Tree_Ref)\n+      return Project_Node_Id\n+   is\n+      Node : Project_Node_Id;\n+   begin\n+      Node := Default_Project_Node (Tree, N_Literal_String, Prj.Single);\n+      Set_Next_Literal_String (Node, Tree, Empty_Node);\n+      Set_String_Value_Of (Node, Tree, Str);\n+      return Node;\n+   end Create_Literal_String;\n+\n+   ---------------------------\n+   -- Enclose_In_Expression --\n+   ---------------------------\n+\n+   function Enclose_In_Expression\n+     (Node : Project_Node_Id;\n+      Tree : Project_Node_Tree_Ref) return Project_Node_Id\n+   is\n+      Expr : constant Project_Node_Id :=\n+        Default_Project_Node (Tree, N_Expression, Single);\n+   begin\n+      Set_First_Term (Expr, Tree, Default_Project_Node (Tree, N_Term, Single));\n+      Set_Current_Term (First_Term (Expr, Tree), Tree, Node);\n+      return Expr;\n+   end Enclose_In_Expression;\n+\n+   --------------------\n+   -- Create_Package --\n+   --------------------\n+\n+   function Create_Package\n+     (Tree    : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id;\n+      Pkg     : String) return Project_Node_Id\n+   is\n+      Pack : Project_Node_Id;\n+      N    : Name_Id;\n+   begin\n+      Name_Len := Pkg'Length;\n+      Name_Buffer (1 .. Name_Len) := Pkg;\n+      N := Name_Find;\n+\n+      --  Check if the package already exists\n+\n+      Pack := First_Package_Of (Project, Tree);\n+\n+      while Pack /= Empty_Node loop\n+         if Prj.Tree.Name_Of (Pack, Tree) = N then\n+            return Pack;\n+         end if;\n+\n+         Pack := Next_Package_In_Project (Pack, Tree);\n+      end loop;\n+\n+      --  Create the package and add it to the declarative item\n+\n+      Pack := Default_Project_Node (Tree, N_Package_Declaration);\n+      Set_Name_Of (Pack, Tree, N);\n+\n+      --  Find the correct package id to use\n+\n+      Set_Package_Id_Of (Pack, Tree, Package_Node_Id_Of (N));\n+\n+      --  Add it to the list of packages\n+      Set_Next_Package_In_Project\n+        (Pack, Tree, First_Package_Of (Project, Tree));\n+      Set_First_Package_Of (Project, Tree, Pack);\n+\n+      Add_At_End (Tree, Project_Declaration_Of (Project, Tree), Pack);\n+\n+      return Pack;\n+   end Create_Package;\n+\n+   -------------------\n+   -- Create_Attribute --\n+   ----------------------\n+\n+   function Create_Attribute\n+     (Tree       : Project_Node_Tree_Ref;\n+      Prj_Or_Pkg : Project_Node_Id;\n+      Name       : Name_Id;\n+      Index_Name : Name_Id := No_Name;\n+      Kind       : Variable_Kind := List;\n+      At_Index   : Integer := 0) return Project_Node_Id\n+   is\n+      Node : constant Project_Node_Id :=\n+        Default_Project_Node (Tree, N_Attribute_Declaration, Kind);\n+      Case_Insensitive : Boolean;\n+\n+      Pkg      : Package_Node_Id;\n+      Start_At : Attribute_Node_Id;\n+   begin\n+      Set_Name_Of (Node, Tree, Name);\n+\n+      if At_Index /= 0 then\n+         Set_Source_Index_Of (Node, Tree, To => Int (At_Index));\n+      end if;\n+\n+      if Index_Name /= No_Name then\n+         Set_Associative_Array_Index_Of (Node, Tree, Index_Name);\n+      end if;\n+\n+      if Prj_Or_Pkg /= Empty_Node then\n+         Add_At_End (Tree, Prj_Or_Pkg, Node);\n+      end if;\n+\n+      --  Find out the case sensitivity of the attribute\n+\n+      if Kind_Of (Prj_Or_Pkg, Tree) = N_Package_Declaration then\n+         Pkg      := Prj.Attr.Package_Node_Id_Of (Name_Of (Prj_Or_Pkg, Tree));\n+         Start_At := First_Attribute_Of (Pkg);\n+      else\n+         Start_At := Attribute_First;\n+      end if;\n+\n+      Start_At := Attribute_Node_Id_Of (Name, Start_At);\n+      Case_Insensitive :=\n+        Attribute_Kind_Of (Start_At) = Case_Insensitive_Associative_Array;\n+      Tree.Project_Nodes.Table (Node).Flag1 := Case_Insensitive;\n+\n+      return Node;\n+   end Create_Attribute;\n+\n end Prj.Tree;"}, {"sha": "ce449105cab7906b14086784503bf389bab65cb0", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -110,14 +110,6 @@ package Prj.Tree is\n    --  the other components have default nil values.\n    --  To create a node for a project itself, see Create_Project below instead\n \n-   function Create_Project\n-     (In_Tree        : Project_Node_Tree_Ref;\n-      Name           : Name_Id;\n-      Full_Path      : Path_Name_Type;\n-      Is_Config_File : Boolean := False) return Project_Node_Id;\n-   --  Create a new node for a project and register it in the tree so that it\n-   --  can be retrieved later on\n-\n    function Hash (N : Project_Node_Id) return Header_Num;\n    --  Used for hash tables where the key is a Project_Node_Id\n \n@@ -595,15 +587,84 @@ package Prj.Tree is\n       In_Tree : Project_Node_Tree_Ref) return Boolean;\n    --  Only valid for N_Attribute_Declaration and N_Attribute_Reference nodes\n \n+   -----------------------\n+   -- Create procedures --\n+   -----------------------\n+   --  The following procedures are used to edit a project file tree. They are\n+   --  slightly higher-level than the Set_* procedures below\n+\n+   function Create_Project\n+     (In_Tree        : Project_Node_Tree_Ref;\n+      Name           : Name_Id;\n+      Full_Path      : Path_Name_Type;\n+      Is_Config_File : Boolean := False) return Project_Node_Id;\n+   --  Create a new node for a project and register it in the tree so that it\n+   --  can be retrieved later on\n+\n+   function Create_Package\n+     (Tree    : Project_Node_Tree_Ref;\n+      Project : Project_Node_Id;\n+      Pkg     : String) return Project_Node_Id;\n+   --  Create a new package in Project. If the package already exists, it is\n+   --  returned.\n+   --  The name of the package *must* be lower-cases, or none of its attributes\n+   --  will be recognized.\n+\n+   function Create_Attribute\n+     (Tree       : Project_Node_Tree_Ref;\n+      Prj_Or_Pkg : Project_Node_Id;\n+      Name       : Name_Id;\n+      Index_Name : Name_Id := No_Name;\n+      Kind       : Variable_Kind := List;\n+      At_Index   : Integer := 0) return Project_Node_Id;\n+   --  Create a new attribute.\n+   --  The new declaration is added at the end of the declarative item list for\n+   --  Prj_Or_Pkg (a project or a package), but before any package\n+   --  declaration). No addition is done if Prj_Or_Pkg is Empty_Node.\n+   --  If Index_Name is not \"\", then if creates an attribute value for a\n+   --  specific index.\n+   --  At_Index is used for the \" at <idx>\" in the naming exceptions.\n+   --  Use Set_Expression_Of to set the value of the attribute (in which case\n+   --  Enclose_In_Expression might be useful)\n+\n+   function Create_Literal_String\n+     (Str  : Namet.Name_Id;\n+      Tree : Project_Node_Tree_Ref)\n+      return Project_Node_Id;\n+   --  Create a literal string whose value is Str\n+\n+   procedure Add_At_End\n+     (Tree                  : Project_Node_Tree_Ref;\n+      Parent                : Project_Node_Id;\n+      Expr                  : Project_Node_Id;\n+      Add_Before_First_Pkg  : Boolean := False;\n+      Add_Before_First_Case : Boolean := False);\n+   --  Add a new declarative item in the list in Parent.\n+   --  This new declarative item will contain Expr (unless Expr is already a\n+   --  declarative item, in which case it is added directly to the list). The\n+   --  new item is inserted at the end of the list, unless Add_Before_First_Pkg\n+   --  is True. In the latter case, it is added just before the first case\n+   --  construction is seen, or before the first package (this assumes that all\n+   --  packages are found at the end of the project, which isn't true in the\n+   --  general case unless you have normalized the project to match this\n+   --  description).\n+\n+   function Enclose_In_Expression\n+     (Node : Project_Node_Id;\n+      Tree : Project_Node_Tree_Ref) return Project_Node_Id;\n+   --  Enclose the Node inside a N_Expression node, and return this expression\n+\n    --------------------\n    -- Set Procedures --\n    --------------------\n \n    --  The following procedures are part of the abstract interface of the\n    --  Project File tree.\n-\n    --  Each Set_* procedure is valid only for the same Project_Node_Kind\n    --  nodes as the corresponding query function above.\n+   --  These are very low-level, and manipulate the tree itself directly. You\n+   --  should look at the Create_* procedure instead if you want to use higher\n+   --  level constructs\n \n    procedure Set_Name_Of\n      (Node    : Project_Node_Id;"}, {"sha": "897e7f01dbe540a12f89e177722b70ce33a8d7da", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 18, "deletions": 50, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -130,8 +130,6 @@ package body Prj.Util is\n                         In_Package              => Builder_Package,\n                         In_Tree                 => In_Tree);\n \n-      Executable_Suffix : Variable_Value := Nil_Variable_Value;\n-\n       Executable_Suffix_Name : Name_Id := No_Name;\n \n       Lang   : Language_Ptr;\n@@ -183,22 +181,7 @@ package body Prj.Util is\n       end if;\n \n       if Builder_Package /= No_Package then\n-         if Get_Mode = Multi_Language then\n-            Executable_Suffix_Name := Project.Config.Executable_Suffix;\n-\n-         else\n-            Executable_Suffix := Prj.Util.Value_Of\n-              (Variable_Name => Name_Executable_Suffix,\n-               In_Variables  => In_Tree.Packages.Table\n-                 (Builder_Package).Decl.Attributes,\n-               In_Tree       => In_Tree);\n-\n-            if Executable_Suffix /= Nil_Variable_Value\n-              and then not Executable_Suffix.Default\n-            then\n-               Executable_Suffix_Name := Executable_Suffix.Value;\n-            end if;\n-         end if;\n+         Executable_Suffix_Name := Project.Config.Executable_Suffix;\n \n          if Executable = Nil_Variable_Value and Ada_Main then\n             Get_Name_String (Main);\n@@ -251,7 +234,8 @@ package body Prj.Util is\n          --  possibly suffixed by the executable suffix.\n \n          if Executable /= Nil_Variable_Value\n-           and then Executable.Value /= Empty_Name\n+           and then Executable.Value /= No_Name\n+           and then Length_Of_Name (Executable.Value) /= 0\n          then\n             --  Get the executable name. If Executable_Suffix is defined,\n             --  make sure that it will be the extension of the executable.\n@@ -303,40 +287,24 @@ package body Prj.Util is\n          Get_Name_String (Strip_Suffix (Main));\n       end if;\n \n-      if Executable_Suffix /= Nil_Variable_Value\n-        and then not Executable_Suffix.Default\n-      then\n-         --  If attribute Executable_Suffix is specified, add this suffix\n+      --  Get the executable name. If Executable_Suffix is defined in the\n+      --  configuration, make sure that it will be the extension of the\n+      --  executable.\n \n-         declare\n-            Suffix : constant String :=\n-                       Get_Name_String (Executable_Suffix.Value);\n-         begin\n-            Name_Buffer (Name_Len + 1 .. Name_Len + Suffix'Length) := Suffix;\n-            Name_Len := Name_Len + Suffix'Length;\n-            return Name_Find;\n-         end;\n+      declare\n+         Saved_EEOT : constant Name_Id := Executable_Extension_On_Target;\n+         Result     : File_Name_Type;\n \n-      else\n-         --  Get the executable name. If Executable_Suffix is defined in the\n-         --  configuration, make sure that it will be the extension of the\n-         --  executable.\n-\n-         declare\n-            Saved_EEOT : constant Name_Id := Executable_Extension_On_Target;\n-            Result     : File_Name_Type;\n-\n-         begin\n-            if Project.Config.Executable_Suffix /= No_Name then\n-               Executable_Extension_On_Target :=\n-                 Project.Config.Executable_Suffix;\n-            end if;\n+      begin\n+         if Project.Config.Executable_Suffix /= No_Name then\n+            Executable_Extension_On_Target :=\n+              Project.Config.Executable_Suffix;\n+         end if;\n \n-            Result := Executable_Name (Name_Find);\n-            Executable_Extension_On_Target := Saved_EEOT;\n-            return Result;\n-         end;\n-      end if;\n+         Result := Executable_Name (Name_Find);\n+         Executable_Extension_On_Target := Saved_EEOT;\n+         return Result;\n+      end;\n    end Executable_Of;\n \n    --------------"}, {"sha": "c8f30ec5e7663aa9518227ef2d1873ee764e6522", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 92, "deletions": 139, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -28,10 +28,10 @@ with Ada.Unchecked_Deallocation;\n \n with Debug;\n with Osint;    use Osint;\n+with Output;   use Output;\n with Prj.Attr;\n with Prj.Err;  use Prj.Err;\n with Snames;   use Snames;\n-with Table;\n with Uintp;    use Uintp;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n@@ -47,22 +47,18 @@ package body Prj is\n    Initial_Buffer_Size : constant := 100;\n    --  Initial size for extensible buffer used in Add_To_Buffer\n \n-   Current_Mode : Mode := Ada_Only;\n-\n-   The_Empty_String : Name_Id;\n-\n-   Default_Ada_Spec_Suffix_Id : File_Name_Type;\n-   Default_Ada_Body_Suffix_Id : File_Name_Type;\n-   --  Initialized in Prj.Initialize, then never modified\n+   The_Empty_String : Name_Id := No_Name;\n \n    subtype Known_Casing is Casing_Type range All_Upper_Case .. Mixed_Case;\n \n-   The_Casing_Images : constant array (Known_Casing) of String_Access :=\n-     (All_Lower_Case => new String'(\"lowercase\"),\n-      All_Upper_Case => new String'(\"UPPERCASE\"),\n-      Mixed_Case     => new String'(\"MixedCase\"));\n-\n-   Initialized : Boolean := False;\n+   type Cst_String_Access is access constant String;\n+   All_Lower_Case_Image : aliased constant String := \"lowercase\";\n+   All_Upper_Case_Image : aliased constant String := \"UPPERCASE\";\n+   Mixed_Case_Image     : aliased constant String := \"MixedCase\";\n+   The_Casing_Images : constant array (Known_Casing) of Cst_String_Access :=\n+     (All_Lower_Case => All_Lower_Case_Image'Access,\n+      All_Upper_Case => All_Upper_Case_Image'Access,\n+      Mixed_Case     => Mixed_Case_Image'Access);\n \n    Project_Empty : constant Project_Data :=\n                      (Qualifier                      => Unspecified,\n@@ -114,16 +110,6 @@ package body Prj is\n                       Depth                          => 0,\n                       Unkept_Comments                => False);\n \n-   package Temp_Files is new Table.Table\n-     (Table_Component_Type => Path_Name_Type,\n-      Table_Index_Type     => Integer,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 20,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Makegpr.Temp_Files\");\n-   --  Table to store the path name of all the created temporary files, so that\n-   --  they can be deleted at the end, or when the program is interrupted.\n-\n    procedure Free (Project : in out Project_Id);\n    --  Free memory allocated for Project\n \n@@ -175,37 +161,76 @@ package body Prj is\n       Last := Last + S'Length;\n    end Add_To_Buffer;\n \n-   -----------------------------\n-   -- Default_Ada_Body_Suffix --\n-   -----------------------------\n+   ---------------------------\n+   -- Delete_Temporary_File --\n+   ---------------------------\n \n-   function Default_Ada_Body_Suffix return File_Name_Type is\n+   procedure Delete_Temporary_File\n+     (Tree : Project_Tree_Ref;\n+      Path : Path_Name_Type)\n+   is\n+      Dont_Care : Boolean;\n+      pragma Warnings (Off, Dont_Care);\n    begin\n-      return Default_Ada_Body_Suffix_Id;\n-   end Default_Ada_Body_Suffix;\n+      if not Debug.Debug_Flag_N then\n+         if Current_Verbosity = High then\n+            Write_Line (\"Removing temp file: \" & Get_Name_String (Path));\n+         end if;\n \n-   -----------------------------\n-   -- Default_Ada_Spec_Suffix --\n-   -----------------------------\n+         Delete_File (Get_Name_String (Path), Dont_Care);\n \n-   function Default_Ada_Spec_Suffix return File_Name_Type is\n-   begin\n-      return Default_Ada_Spec_Suffix_Id;\n-   end Default_Ada_Spec_Suffix;\n+         for Index in\n+           1 .. Temp_Files_Table.Last (Tree.Private_Part.Temp_Files)\n+         loop\n+            if Tree.Private_Part.Temp_Files.Table (Index) = Path then\n+               Tree.Private_Part.Temp_Files.Table (Index) := No_Path;\n+            end if;\n+         end loop;\n+      end if;\n+   end Delete_Temporary_File;\n \n    ---------------------------\n    -- Delete_All_Temp_Files --\n    ---------------------------\n \n-   procedure Delete_All_Temp_Files is\n+   procedure Delete_All_Temp_Files (Tree : Project_Tree_Ref) is\n       Dont_Care : Boolean;\n       pragma Warnings (Off, Dont_Care);\n+      Path : Path_Name_Type;\n    begin\n       if not Debug.Debug_Flag_N then\n-         for Index in 1 .. Temp_Files.Last loop\n-            Delete_File\n-              (Get_Name_String (Temp_Files.Table (Index)), Dont_Care);\n+         for Index in\n+           1 .. Temp_Files_Table.Last (Tree.Private_Part.Temp_Files)\n+         loop\n+            Path := Tree.Private_Part.Temp_Files.Table (Index);\n+\n+            if Path /= No_Path then\n+               if Current_Verbosity = High then\n+                  Write_Line (\"Removing temp file: \"\n+                              & Get_Name_String (Path));\n+               end if;\n+\n+               Delete_File (Get_Name_String (Path), Dont_Care);\n+            end if;\n          end loop;\n+\n+         Temp_Files_Table.Free (Tree.Private_Part.Temp_Files);\n+         Temp_Files_Table.Init (Tree.Private_Part.Temp_Files);\n+      end if;\n+\n+      --  If any of the environment variables ADA_PRJ_INCLUDE_FILE or\n+      --  ADA_PRJ_OBJECTS_FILE has been set, then reset their value to\n+      --  the empty string. On VMS, this has the effect of deassigning\n+      --  the logical names.\n+\n+      if Tree.Private_Part.Ada_Prj_Include_File_Set then\n+         Setenv (Project_Include_Path_File, \"\");\n+         Tree.Private_Part.Ada_Prj_Include_File_Set := False;\n+      end if;\n+\n+      if Tree.Private_Part.Ada_Prj_Objects_File_Set then\n+         Setenv (Project_Objects_Path_File, \"\");\n+         Tree.Private_Part.Ada_Prj_Objects_File_Set := False;\n       end if;\n    end Delete_All_Temp_Files;\n \n@@ -536,15 +561,6 @@ package body Prj is\n       return Result;\n    end Find_Source;\n \n-   --------------\n-   -- Get_Mode --\n-   --------------\n-\n-   function Get_Mode return Mode is\n-   begin\n-      return Current_Mode;\n-   end Get_Mode;\n-\n    ----------\n    -- Hash --\n    ----------\n@@ -585,25 +601,29 @@ package body Prj is\n       return The_Casing_Images (Casing).all;\n    end Image;\n \n+   -----------------------------\n+   -- Is_Standard_GNAT_Naming --\n+   -----------------------------\n+\n+   function Is_Standard_GNAT_Naming\n+     (Naming : Lang_Naming_Data) return Boolean\n+   is\n+   begin\n+      return Get_Name_String (Naming.Spec_Suffix) = \".ads\"\n+        and then Get_Name_String (Naming.Body_Suffix) = \".adb\"\n+        and then Get_Name_String (Naming.Dot_Replacement) = \"-\";\n+   end Is_Standard_GNAT_Naming;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n \n    procedure Initialize (Tree : Project_Tree_Ref) is\n    begin\n-      if not Initialized then\n-         Initialized := True;\n+      if The_Empty_String = No_Name then\n          Uintp.Initialize;\n          Name_Len := 0;\n          The_Empty_String := Name_Find;\n-         Empty_Name := The_Empty_String;\n-         Empty_File_Name := File_Name_Type (The_Empty_String);\n-         Name_Len := 4;\n-         Name_Buffer (1 .. 4) := \".ads\";\n-         Default_Ada_Spec_Suffix_Id := Name_Find;\n-         Name_Len := 4;\n-         Name_Buffer (1 .. 4) := \".adb\";\n-         Default_Ada_Body_Suffix_Id := Name_Find;\n \n          Prj.Attr.Initialize;\n          Set_Name_Table_Byte (Name_Project,  Token_Type'Pos (Tok_Project));\n@@ -616,18 +636,6 @@ package body Prj is\n       end if;\n    end Initialize;\n \n-   -------------------\n-   -- Is_A_Language --\n-   -------------------\n-\n-   function Is_A_Language\n-     (Project       : Project_Id;\n-      Language_Name : Name_Id) return Boolean is\n-   begin\n-      return Get_Language_From_Name\n-        (Project, Get_Name_String (Language_Name)) /= null;\n-   end Is_A_Language;\n-\n    ------------------\n    -- Is_Extending --\n    ------------------\n@@ -673,10 +681,11 @@ package body Prj is\n    -- Record_Temp_File --\n    ----------------------\n \n-   procedure Record_Temp_File (Path : Path_Name_Type) is\n+   procedure Record_Temp_File\n+     (Tree : Project_Tree_Ref;\n+      Path : Path_Name_Type) is\n    begin\n-      Temp_Files.Increment_Last;\n-      Temp_Files.Table (Temp_Files.Last) := Path;\n+      Temp_Files_Table.Append (Tree.Private_Part.Temp_Files, Path);\n    end Record_Temp_File;\n \n    ----------\n@@ -833,22 +842,13 @@ package body Prj is\n          Array_Table.Free (Tree.Arrays);\n          Package_Table.Free (Tree.Packages);\n          Source_Paths_Htable.Reset (Tree.Source_Paths_HT);\n-         Unit_Sources_Htable.Reset (Tree.Unit_Sources_HT);\n \n          Free_List (Tree.Projects, Free_Project => True);\n          Free_Units (Tree.Units_HT);\n \n          --  Private part\n \n-         Path_File_Table.Free   (Tree.Private_Part.Path_Files);\n-         Source_Path_Table.Free (Tree.Private_Part.Source_Paths);\n-         Object_Path_Table.Free (Tree.Private_Part.Object_Paths);\n-\n-         Free (Tree.Private_Part.Ada_Path_Buffer);\n-\n-         --  Naming data (nothing to free ???)\n-\n-         null;\n+         Temp_Files_Table.Free  (Tree.Private_Part.Temp_Files);\n \n          Unchecked_Free (Tree);\n       end if;\n@@ -869,45 +869,20 @@ package body Prj is\n       Array_Table.Init              (Tree.Arrays);\n       Package_Table.Init            (Tree.Packages);\n       Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n-      Unit_Sources_Htable.Reset     (Tree.Unit_Sources_HT);\n \n       Free_List (Tree.Projects, Free_Project => True);\n       Free_Units (Tree.Units_HT);\n \n       --  Private part table\n \n-      Path_File_Table.Init        (Tree.Private_Part.Path_Files);\n-      Source_Path_Table.Init      (Tree.Private_Part.Source_Paths);\n-      Object_Path_Table.Init      (Tree.Private_Part.Object_Paths);\n+      Temp_Files_Table.Init       (Tree.Private_Part.Temp_Files);\n \n-      if Current_Mode = Ada_Only then\n-         Tree.Private_Part.Current_Source_Path_File := No_Path;\n-         Tree.Private_Part.Current_Object_Path_File := No_Path;\n-         Tree.Private_Part.Ada_Path_Length := 0;\n-         Tree.Private_Part.Ada_Prj_Include_File_Set := False;\n-         Tree.Private_Part.Ada_Prj_Objects_File_Set := False;\n-         Tree.Private_Part.Fill_Mapping_File := True;\n-      end if;\n+      Tree.Private_Part.Current_Source_Path_File := No_Path;\n+      Tree.Private_Part.Current_Object_Path_File := No_Path;\n+      Tree.Private_Part.Ada_Prj_Include_File_Set := False;\n+      Tree.Private_Part.Ada_Prj_Objects_File_Set := False;\n    end Reset;\n \n-   --------------\n-   -- Set_Mode --\n-   --------------\n-\n-   procedure Set_Mode (New_Mode : Mode) is\n-   begin\n-      Current_Mode := New_Mode;\n-\n-      case New_Mode is\n-         when Ada_Only =>\n-            Default_Language_Is_Ada := True;\n-            Must_Check_Configuration := False;\n-         when Multi_Language =>\n-            Default_Language_Is_Ada := False;\n-            Must_Check_Configuration := True;\n-      end case;\n-   end Set_Mode;\n-\n    -------------------\n    -- Switches_Name --\n    -------------------\n@@ -953,29 +928,6 @@ package body Prj is\n       return False;\n    end Has_Ada_Sources;\n \n-   -------------------------\n-   -- Has_Foreign_Sources --\n-   -------------------------\n-\n-   function Has_Foreign_Sources (Data : Project_Id) return Boolean is\n-      Lang : Language_Ptr;\n-\n-   begin\n-      Lang := Data.Languages;\n-      while Lang /= No_Language_Index loop\n-         if Lang.Name /= Name_Ada\n-           and then\n-             (Current_Mode = Ada_Only or else Lang.First_Source /= No_Source)\n-         then\n-            return True;\n-         end if;\n-\n-         Lang := Lang.Next;\n-      end loop;\n-\n-      return False;\n-   end Has_Foreign_Sources;\n-\n    ------------------------\n    -- Contains_ALI_Files --\n    ------------------------\n@@ -1153,7 +1105,8 @@ package body Prj is\n \n    function Is_Compilable (Source : Source_Id) return Boolean is\n    begin\n-      return Source.Language.Config.Compiler_Driver /= Empty_File_Name\n+      return Source.Language.Config.Compiler_Driver /= No_File\n+        and then Length_Of_Name (Source.Language.Config.Compiler_Driver) /= 0\n         and then not Source.Locally_Removed;\n    end Is_Compilable;\n "}, {"sha": "b359515eaaeb013a47547c79b5b18569bdce7e6c", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 35, "deletions": 93, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bccff2426b3ed3c0400cf6610c61198779f797c/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=7bccff2426b3ed3c0400cf6610c61198779f797c", "patch": "@@ -59,10 +59,6 @@ package Prj is\n    type Yes_No_Unknown is (Yes, No, Unknown);\n    --  Tri-state to decide if -lgnarl is needed when linking\n \n-   type Mode is (Multi_Language, Ada_Only);\n-   --  Ada_Only: mode for gnatmake, gnatclean, gnatname, the GNAT driver\n-   --  Multi_Language: mode for gprbuild, gprclean\n-\n    type Project_Qualifier is\n      (Unspecified,\n       Standard,\n@@ -80,23 +76,6 @@ package Prj is\n    --    Aggregate_Library:    aggregate library project is ...\n    --    Configuration:        configuration project is ...\n \n-   function Get_Mode return Mode;\n-   pragma Inline (Get_Mode);\n-\n-   procedure Set_Mode (New_Mode : Mode);\n-   pragma Inline (Set_Mode);\n-\n-   Default_Language_Is_Ada : Boolean := True;\n-   --  If no language was defined in the project or the configuration file, it\n-   --  is an error, unless this variable is True, in which case it defaults to\n-   --  Ada. Calling Set_Mode will reset this variable, default is for Ada_Only.\n-\n-   Must_Check_Configuration : Boolean := False;\n-   --  True when the contents of the configuration file must be checked. This\n-   --  is in general only needed by gprbuild itself, since other applications\n-   --  can ignore such errors when they don't need to build directly. Calling\n-   --  Set_Mode will reset this variable, default is for Ada_Only.\n-\n    All_Packages : constant String_List_Access;\n    --  Default value of parameter Packages of procedures Parse, in Prj.Pars and\n    --  Prj.Part, indicating that all packages should be checked.\n@@ -111,16 +90,6 @@ package Prj is\n    procedure Free (Tree : in out Project_Tree_Ref);\n    --  Free memory associated with the tree\n \n-   function Default_Ada_Spec_Suffix return File_Name_Type;\n-   pragma Inline (Default_Ada_Spec_Suffix);\n-   --  The name for the standard GNAT suffix for Ada spec source file name\n-   --  \".ads\". Initialized by Prj.Initialize.\n-\n-   function Default_Ada_Body_Suffix return File_Name_Type;\n-   pragma Inline (Default_Ada_Body_Suffix);\n-   --  The name for the standard GNAT suffix for Ada body source file name\n-   --  \".adb\". Initialized by Prj.Initialize.\n-\n    Config_Project_File_Extension : String := \".cgpr\";\n    Project_File_Extension : String := \".gpr\";\n    --  The standard config and user project file name extensions. They are not\n@@ -392,6 +361,11 @@ package Prj is\n                             Spec_Suffix     => No_File,\n                             Body_Suffix     => No_File);\n \n+   function Is_Standard_GNAT_Naming (Naming : Lang_Naming_Data) return Boolean;\n+   --  True if the naming scheme is GNAT's default naming scheme. This\n+   --  is to take into account shortened names like \"Ada.\" (a-), \"System.\" (s-)\n+   --  and so on.\n+\n    type Source_Data;\n    type Source_Id is access all Source_Data;\n \n@@ -1244,18 +1218,9 @@ package Prj is\n       Extended  : Project_Id) return Boolean;\n    --  Return True if Extending is extending the Extended project\n \n-   function Is_A_Language\n-     (Project       : Project_Id;\n-      Language_Name : Name_Id) return Boolean;\n-   --  Return True when Language_Name (which must be lower case) is one of the\n-   --  languages used for the project.\n-\n    function Has_Ada_Sources (Data : Project_Id) return Boolean;\n    --  Return True if the project has Ada sources\n \n-   function Has_Foreign_Sources (Data : Project_Id) return Boolean;\n-   --  Return True if the project has foreign sources\n-\n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr\n \n@@ -1314,13 +1279,14 @@ package Prj is\n          Arrays            : Array_Table.Instance;\n          Packages          : Package_Table.Instance;\n          Projects          : Project_List;\n+\n          Units_HT          : Units_Htable.Instance;\n-         Source_Paths_HT   : Source_Paths_Htable.Instance;\n-         Unit_Sources_HT   : Unit_Sources_Htable.Instance;\n+         --  Unit name to Unit_Index (and from there so Source_Id)\n \n-         --  Private part\n+         Source_Paths_HT   : Source_Paths_Htable.Instance;\n+         --  Full path to Source_Id\n \n-         Private_Part : Private_Project_Tree_Data;\n+         Private_Part      : Private_Project_Tree_Data;\n       end record;\n    --  Data for a project tree\n \n@@ -1369,7 +1335,8 @@ package Prj is\n    --  If Require_Sources_Other_Lang is true, then all languages must have at\n    --  least one source file, or an error is reported via When_No_Sources. If\n    --  it is false, this is only required for Ada (and only if it is a language\n-   --  of the project).\n+   --  of the project). When this parameter is set to False, we do not check\n+   --  that a proper naming scheme is defined for languages other than Ada.\n    --\n    --  If Report_Error is null, use the standard error reporting mechanism\n    --  (Errout). Otherwise, report errors using Report_Error.\n@@ -1436,12 +1403,23 @@ package Prj is\n    -- Temp Files --\n    ----------------\n \n-   procedure Record_Temp_File (Path : Path_Name_Type);\n+   procedure Record_Temp_File\n+     (Tree : Project_Tree_Ref;\n+      Path : Path_Name_Type);\n    --  Record the path of a newly created temporary file, so that it can be\n    --  deleted later.\n \n-   procedure Delete_All_Temp_Files;\n-   --  Delete all recorded temporary files\n+   procedure Delete_All_Temp_Files (Tree : Project_Tree_Ref);\n+   --  Delete all recorded temporary files.\n+   --  Does nothing if Debug.Debug_Flag_N is set\n+\n+   procedure Delete_Temporary_File\n+     (Tree : Project_Tree_Ref;\n+      Path : Path_Name_Type);\n+   --  Delete a temporary file from the disk. The file is also removed from the\n+   --  list of temporary files to delete at the end of the program, in case\n+   --  another program running on the same machine has recreated it.\n+   --  Does nothing if Debug.Debug_Flag_N is set\n \n private\n \n@@ -1461,14 +1439,6 @@ private\n    --  The prefix for virtual extending projects. Because of the '$', which is\n    --  normally forbidden for project names, there cannot be any name clash.\n \n-   Empty_Name : Name_Id;\n-   --  Name_Id for an empty name (no characters). Initialized in procedure\n-   --  Initialize.\n-\n-   Empty_File_Name : File_Name_Type;\n-   --  Empty File_Name_Type (no characters). Initialized in procedure\n-   --  Initialize.\n-\n    type Source_Iterator is record\n       In_Tree : Project_Tree_Ref;\n \n@@ -1491,35 +1461,19 @@ private\n       Last : in out Natural);\n    --  Append a String to the Buffer\n \n-   package Path_File_Table is new GNAT.Dynamic_Tables\n+   package Temp_Files_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Path_Name_Type,\n-      Table_Index_Type     => Natural,\n+      Table_Index_Type     => Integer,\n       Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-   --  Table storing all the temp path file names.\n-   --  Used by Delete_All_Path_Files.\n-\n-   package Source_Path_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-   --  A table to store the source dirs before creating the source path file\n-\n-   package Object_Path_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Path_Name_Type,\n-      Table_Index_Type     => Natural,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 50,\n-      Table_Increment      => 100);\n-   --  A table to store the object dirs, before creating the object path file\n+      Table_Initial        => 10,\n+      Table_Increment      => 10);\n+   --  Table to store the path name of all the created temporary files, so that\n+   --  they can be deleted at the end, or when the program is interrupted.\n \n    type Private_Project_Tree_Data is record\n-      Path_Files     : Path_File_Table.Instance;\n-      Source_Paths   : Source_Path_Table.Instance;\n-      Object_Paths   : Object_Path_Table.Instance;\n+      Temp_Files   : Temp_Files_Table.Instance;\n+      --  Temporary files created as part of running tools (pragma files,\n+      --  mapping files,...)\n \n       Current_Source_Path_File : Path_Name_Type := No_Path;\n       --  Current value of project source path file env var. Used to avoid\n@@ -1531,15 +1485,6 @@ private\n       --  setting the env var to the same value.\n       --  gnatmake only\n \n-      Ada_Path_Buffer : String_Access := new String (1 .. 1024);\n-      --  A buffer where values for ADA_INCLUDE_PATH and ADA_OBJECTS_PATH are\n-      --  stored.\n-      --  gnatmake only\n-\n-      Ada_Path_Length : Natural := 0;\n-      --  Index of the last valid character in Ada_Path_Buffer\n-      --  gnatmake only\n-\n       Ada_Prj_Include_File_Set : Boolean := False;\n       Ada_Prj_Objects_File_Set : Boolean := False;\n       --  These flags are set to True when the corresponding environment\n@@ -1550,9 +1495,6 @@ private\n       --  caller.\n       --  gnatmake only\n \n-      Fill_Mapping_File : Boolean := True;\n-      --  gnatmake only\n-\n    end record;\n    --  Type to represent the part of a project tree which is private to the\n    --  Project Manager."}]}