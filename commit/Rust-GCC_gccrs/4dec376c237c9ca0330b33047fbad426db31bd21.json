{"sha": "4dec376c237c9ca0330b33047fbad426db31bd21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRlYzM3NmMyMzdjOWNhMDMzMGIzMzA0N2ZiYWQ0MjZkYjMxYmQyMQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-24T21:12:19Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-24T21:12:19Z"}, "message": "* config/i386/i386.md: Move some more patterns around.\n\nFrom-SVN: r242850", "tree": {"sha": "9cd6a404d0c97ce5aeac5f60e374469333f66a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cd6a404d0c97ce5aeac5f60e374469333f66a8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dec376c237c9ca0330b33047fbad426db31bd21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dec376c237c9ca0330b33047fbad426db31bd21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dec376c237c9ca0330b33047fbad426db31bd21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dec376c237c9ca0330b33047fbad426db31bd21/comments", "author": null, "committer": null, "parents": [{"sha": "3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f156a6ce05f9e2b8cd37d1226c98d8b2be478ad"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "5f4cdebfc234ee49b6b315493d1023c45a67ccfc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 106, "deletions": 106, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dec376c237c9ca0330b33047fbad426db31bd21/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dec376c237c9ca0330b33047fbad426db31bd21/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4dec376c237c9ca0330b33047fbad426db31bd21", "patch": "@@ -8217,6 +8217,18 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"SI,DI,DI,SI,DI\")])\n \n+;; Turn *anddi_1 into *andsi_1_zext if possible.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t(and:DI (subreg:DI (match_operand:SI 1 \"register_operand\") 0)\n+\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n+\n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n (define_insn \"*andsi_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8338,69 +8350,6 @@\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"kandn<mode>\"\n-  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,&r,!k\")\n-\t(and:SWI12\n-\t  (not:SWI12\n-\t    (match_operand:SWI12 1 \"register_operand\" \"r,0,k\"))\n-\t  (match_operand:SWI12 2 \"register_operand\" \"r,r,k\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512F\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"andn\\t{%k2, %k1, %k0|%k0, %k1, %k2}\";\n-    case 1:\n-      return \"#\";\n-    case 2:\n-      if (get_attr_mode (insn) == MODE_HI)\n-\treturn \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n-      else\n-\treturn \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"isa\" \"bmi,*,avx512f\")\n-   (set_attr \"type\" \"bitmanip,*,msklog\")\n-   (set_attr \"prefix\" \"*,*,vex\")\n-   (set_attr \"btver2_decode\" \"direct,*,*\")\n-   (set (attr \"mode\")\n-     (cond [(and (eq_attr \"alternative\" \"2\")\n-\t\t (and (match_test \"<MODE>mode == QImode\")\n-\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n-\t       (const_string \"HI\")\n-\t   ]\n-\t   (const_string \"<MODE>\")))])\n-\n-(define_split\n-  [(set (match_operand:SWI12 0 \"general_reg_operand\")\n-\t(and:SWI12\n-\t  (not:SWI12\n-\t    (match_dup 0))\n-\t  (match_operand:SWI12 1 \"general_reg_operand\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_AVX512F && !TARGET_BMI && reload_completed\"\n-  [(set (match_dup 0)\n-\t(not:SWI12 (match_dup 0)))\n-   (parallel [(set (match_dup 0)\n-\t\t   (and:SWI12 (match_dup 0)\n-\t\t\t      (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-;; Turn *anddi_1 into *andsi_1_zext if possible.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(and:DI (subreg:DI (match_operand:SI 1 \"register_operand\") 0)\n-\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_split\n   [(set (match_operand:SWI248 0 \"register_operand\")\n \t(and:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\")\n@@ -8716,6 +8665,100 @@\n   operands[1] = gen_lowpart (QImode, operands[1]);\n   operands[2] = gen_lowpart (QImode, operands[2]);\n })\n+\n+(define_insn \"kandn<mode>\"\n+  [(set (match_operand:SWI12 0 \"register_operand\" \"=r,&r,!k\")\n+\t(and:SWI12\n+\t  (not:SWI12\n+\t    (match_operand:SWI12 1 \"register_operand\" \"r,0,k\"))\n+\t  (match_operand:SWI12 2 \"register_operand\" \"r,r,k\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512F\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"andn\\t{%k2, %k1, %k0|%k0, %k1, %k2}\";\n+    case 1:\n+      return \"#\";\n+    case 2:\n+      if (get_attr_mode (insn) == MODE_HI)\n+\treturn \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n+      else\n+\treturn \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"isa\" \"bmi,*,avx512f\")\n+   (set_attr \"type\" \"bitmanip,*,msklog\")\n+   (set_attr \"prefix\" \"*,*,vex\")\n+   (set_attr \"btver2_decode\" \"direct,*,*\")\n+   (set (attr \"mode\")\n+     (cond [(and (eq_attr \"alternative\" \"2\")\n+\t\t (and (match_test \"<MODE>mode == QImode\")\n+\t\t      (not (match_test \"TARGET_AVX512DQ\"))))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n+(define_split\n+  [(set (match_operand:SWI12 0 \"general_reg_operand\")\n+\t(and:SWI12\n+\t  (not:SWI12\n+\t    (match_dup 0))\n+\t  (match_operand:SWI12 1 \"general_reg_operand\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512F && !TARGET_BMI && reload_completed\"\n+  [(set (match_dup 0)\n+\t(not:SWI12 (match_dup 0)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (and:SWI12 (match_dup 0)\n+\t\t\t      (match_dup 1)))\n+\t      (clobber (reg:CC FLAGS_REG))])])\n+\n+(define_insn_and_split \"*andndi3_doubleword\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t  (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t  (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_BMI && !TARGET_64BIT && TARGET_STV && TARGET_SSE\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (parallel [(set (match_dup 3)\n+\t\t   (and:SI (not:SI (match_dup 4)) (match_dup 5)))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\")\n+\n+(define_insn \"*bmi_andn_<mode>\"\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"=r,r\")\n+\t(and:SWI48\n+\t  (not:SWI48 (match_operand:SWI48 1 \"register_operand\" \"r,r\"))\n+\t  (match_operand:SWI48 2 \"nonimmediate_operand\" \"r,m\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_BMI\"\n+  \"andn\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"bitmanip\")\n+   (set_attr \"btver2_decode\" \"direct, double\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*bmi_andn_<mode>_ccno\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t  (and:SWI48\n+\t    (not:SWI48 (match_operand:SWI48 1 \"register_operand\" \"r,r\"))\n+\t    (match_operand:SWI48 2 \"nonimmediate_operand\" \"r,m\"))\n+\t  (const_int 0)))\n+   (clobber (match_scratch:SWI48 0 \"=r,r\"))]\n+  \"TARGET_BMI && ix86_match_ccmode (insn, CCNOmode)\"\n+  \"andn\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"bitmanip\")\n+   (set_attr \"btver2_decode\" \"direct, double\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \f\n ;; Logical inclusive and exclusive OR instructions\n \n@@ -13156,49 +13199,6 @@\n \n ;; BMI instructions.\n \n-(define_insn_and_split \"*andndi3_doubleword\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI\n-\t  (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:DI 2 \"nonimmediate_operand\" \"rm\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_BMI && !TARGET_64BIT && TARGET_STV && TARGET_SSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (match_dup 3)\n-\t\t   (and:SI (not:SI (match_dup 4)) (match_dup 5)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_double_mode (DImode, &operands[0], 3, &operands[0], &operands[3]);\")\n-\n-(define_insn \"*bmi_andn_<mode>\"\n-  [(set (match_operand:SWI48 0 \"register_operand\" \"=r,r\")\n-\t(and:SWI48\n-\t  (not:SWI48 (match_operand:SWI48 1 \"register_operand\" \"r,r\"))\n-\t  (match_operand:SWI48 2 \"nonimmediate_operand\" \"r,m\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_BMI\"\n-  \"andn\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"bitmanip\")\n-   (set_attr \"btver2_decode\" \"direct, double\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*bmi_andn_<mode>_ccno\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (and:SWI48\n-\t    (not:SWI48 (match_operand:SWI48 1 \"register_operand\" \"r,r\"))\n-\t    (match_operand:SWI48 2 \"nonimmediate_operand\" \"r,m\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SWI48 0 \"=r,r\"))]\n-  \"TARGET_BMI && ix86_match_ccmode (insn, CCNOmode)\"\n-  \"andn\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"bitmanip\")\n-   (set_attr \"btver2_decode\" \"direct, double\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"bmi_bextr_<mode>\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r,r\")\n \t(unspec:SWI48 [(match_operand:SWI48 1 \"nonimmediate_operand\" \"r,m\")"}]}