{"sha": "78d55cc86ecc681c975581dd3e7e20bb5315b83a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkNTVjYzg2ZWNjNjgxYzk3NTU4MWRkM2U3ZTIwYmI1MzE1YjgzYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-04-03T18:23:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-04-03T18:23:04Z"}, "message": "stor-layout.c (do_type_align): New fn, split out from...\n\n        * stor-layout.c (do_type_align): New fn, split out from...\n        (layout_decl): ...here.  Do all alignment calculations for\n        FIELD_DECLs here.\n        (update_alignment_for_field): Not here.\n        (start_record_layout, debug_rli): Remove unpadded_align.\n        * tree.h (struct record_layout_info_s): Remove unpadded_align.\n        * c-decl.c (finish_enum): Don't set DECL_SIZE, DECL_ALIGN\n        or DECL_MODE on the CONST_DECLs.\n        (finish_struct): Don't mess with DECL_ALIGN.\n        * cp/class.c (build_vtable): Set DECL_ALIGN here.\n        (get_vtable_decl): Not here.\n        (layout_vtable_decl): Or here.\n        (create_vtable_ptr): Or here.\n        (layout_class_type): Or here.\n        (check_bitfield_decl): Don't mess with field alignment.\n        * ada/misc.c (gnat_adjust_rli): #if 0.\n\nFrom-SVN: r65207", "tree": {"sha": "48bd2ec66587d328da6da0a95a49e3ec358b2fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48bd2ec66587d328da6da0a95a49e3ec358b2fea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78d55cc86ecc681c975581dd3e7e20bb5315b83a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d55cc86ecc681c975581dd3e7e20bb5315b83a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d55cc86ecc681c975581dd3e7e20bb5315b83a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d55cc86ecc681c975581dd3e7e20bb5315b83a/comments", "author": null, "committer": null, "parents": [{"sha": "d10f5ecf5c750f3107cd6d38fb9fd13837caedfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10f5ecf5c750f3107cd6d38fb9fd13837caedfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10f5ecf5c750f3107cd6d38fb9fd13837caedfc"}], "stats": {"total": 313, "additions": 147, "deletions": 166}, "files": [{"sha": "6e155ede022006b3de980d6315d4d402ce0efac9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -1,3 +1,15 @@\n+2003-04-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* stor-layout.c (do_type_align): New fn, split out from...\n+\t(layout_decl): ...here.  Do all alignment calculations for \n+\tFIELD_DECLs here.\n+\t(update_alignment_for_field): Not here.\n+\t(start_record_layout, debug_rli): Remove unpadded_align.\n+\t* tree.h (struct record_layout_info_s): Remove unpadded_align.\n+\t* c-decl.c (finish_enum): Don't set DECL_SIZE, DECL_ALIGN\n+\tor DECL_MODE on the CONST_DECLs.\n+\t(finish_struct): Don't mess with DECL_ALIGN.\n+\n Thu Apr  3 18:57:19 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (print_operand): Do not bypass output_addr_const at flag_pic."}, {"sha": "2b8bf05bb770efdf13edeebfd0271076a88650c7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -1,3 +1,7 @@\n+2003-04-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* misc.c (gnat_adjust_rli): #if 0.\n+\n 2003-03-31   Geert Bosch <bosch@gnat.com>\n \n \tPR ada/10020\n@@ -19,8 +23,8 @@\n 2003-03-05  Olivier Hainque  <hainque@gnat.com>\n \n \tada/9961\n-        * raise.c (__gnat_Unwind_RaiseException): Add prototype to avoid\n-        warning, and fix return type for the IN_RTS && !SJLJ case.\n+\t* raise.c (__gnat_Unwind_RaiseException): Add prototype to avoid\n+\twarning, and fix return type for the IN_RTS && !SJLJ case.\n \n 2003-03-04  Tom Tromey  <tromey@redhat.com>\n "}, {"sha": "1a5c9dbd2522bd2a52adaf6493114afe0ff8cc10", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -563,8 +563,11 @@ gnat_expand_expr (exp, target, tmode, modifier)\n \n static void\n gnat_adjust_rli (rli)\n-     record_layout_info rli;\n+     record_layout_info rli ATTRIBUTE_UNUSED;\n {\n+#if 0\n+  /* This code seems to have no actual effect; record_align should already\n+     reflect the largest alignment desired by a field.  jason 2003-04-01  */\n   unsigned int record_align = rli->unpadded_align;\n   tree field;\n \n@@ -576,6 +579,7 @@ gnat_adjust_rli (rli)\n \n   if (TYPE_PACKED (rli->t))\n     rli->record_align = record_align;\n+#endif\n }\n \n /* Make a TRANSFORM_EXPR to later expand GNAT_NODE into code.  */"}, {"sha": "200730801e76192125fe9a5f9e92b9b56b94415b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -5250,23 +5250,6 @@ finish_struct (t, fieldlist, attributes)\n \t      DECL_SIZE (x) = bitsize_int (width);\n \t      DECL_BIT_FIELD (x) = 1;\n \t      SET_DECL_C_BIT_FIELD (x);\n-\n-\t      if (width == 0\n-\t\t  && ! (* targetm.ms_bitfield_layout_p) (t))\n-\t\t{\n-\t\t  /* field size 0 => force desired amount of alignment.  */\n-#ifdef EMPTY_FIELD_BOUNDARY\n-\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n-#endif\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\t  if (PCC_BITFIELD_TYPE_MATTERS)\n-\t\t    {\n-\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t    TYPE_ALIGN (TREE_TYPE (x)));\n-\t\t      DECL_USER_ALIGN (x) |= TYPE_USER_ALIGN (TREE_TYPE (x));\n-\t\t    }\n-#endif\n-\t\t}\n \t    }\n \t}\n \n@@ -5564,11 +5547,6 @@ finish_enum (enumtype, values, attributes)\n \t  tree enu = TREE_PURPOSE (pair);\n \n \t  TREE_TYPE (enu) = enumtype;\n-\t  DECL_SIZE (enu) = TYPE_SIZE (enumtype);\n-\t  DECL_SIZE_UNIT (enu) = TYPE_SIZE_UNIT (enumtype);\n-\t  DECL_ALIGN (enu) = TYPE_ALIGN (enumtype);\n-\t  DECL_USER_ALIGN (enu) = TYPE_USER_ALIGN (enumtype);\n-\t  DECL_MODE (enu) = TYPE_MODE (enumtype);\n \n \t  /* The ISO C Standard mandates enumerators to have type int,\n \t     even though the underlying type of an enum type is"}, {"sha": "06109bfefad4458232ebe13910e3078d5d8a1672", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -1,3 +1,12 @@\n+2003-04-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* class.c (build_vtable): Set DECL_ALIGN here.\n+\t(get_vtable_decl): Not here.\n+\t(layout_vtable_decl): Or here.\n+\t(create_vtable_ptr): Or here.\n+\t(layout_class_type): Or here.\n+\t(check_bitfield_decl): Don't mess with field alignment.\n+\n 2003-04-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* operators.def (DEF_SIMPLE_OPERATOR, DEF_ASSN_OPERATOR,"}, {"sha": "e6fad0a11434eca6887f422263e5b0f3fb76d4a8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -531,6 +531,11 @@ build_vtable (tree class_type, tree name, tree vtable_type)\n   DECL_VIRTUAL_P (decl) = 1;\n   DECL_ALIGN (decl) = TARGET_VTABLE_ENTRY_ALIGN;\n \n+  /* At one time the vtable info was grabbed 2 words at a time.  This\n+     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n+  DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n+\t\t\t   DECL_ALIGN (decl));\n+\n   import_export_vtable (decl, class_type, 0);\n \n   return decl;\n@@ -553,11 +558,6 @@ get_vtable_decl (tree type, int complete)\n   decl = build_vtable (type, get_vtable_name (type), vtbl_type_node);\n   CLASSTYPE_VTABLES (type) = decl;\n \n-  /* At one time the vtable info was grabbed 2 words at a time.  This\n-     fails on sparc unless you have 8-byte alignment.  (tiemann) */\n-  DECL_ALIGN (decl) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t   DECL_ALIGN (decl));\n-\n   if (complete)\n     {\n       DECL_EXTERNAL (decl) = 1;\n@@ -2017,11 +2017,6 @@ layout_vtable_decl (tree binfo, int n)\n       TREE_TYPE (vtable) = atype;\n       DECL_SIZE (vtable) = DECL_SIZE_UNIT (vtable) = NULL_TREE;\n       layout_decl (vtable, 0);\n-\n-      /* At one time the vtable info was grabbed 2 words at a time.  This\n-\t fails on SPARC unless you have 8-byte alignment.  */\n-      DECL_ALIGN (vtable) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t\t DECL_ALIGN (vtable));\n     }\n }\n \n@@ -2952,31 +2947,12 @@ check_bitfield_decl (tree field)\n     {\n       DECL_SIZE (field) = convert (bitsizetype, w);\n       DECL_BIT_FIELD (field) = 1;\n-\n-      if (integer_zerop (w)\n-\t  && ! (* targetm.ms_bitfield_layout_p) (DECL_FIELD_CONTEXT (field)))\n-\t{\n-#ifdef EMPTY_FIELD_BOUNDARY\n-\t  DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n-\t\t\t\t    EMPTY_FIELD_BOUNDARY);\n-#endif\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t  if (PCC_BITFIELD_TYPE_MATTERS)\n-\t    {\n-\t      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n-\t\t\t\t\tTYPE_ALIGN (type));\n-\t      DECL_USER_ALIGN (field) |= TYPE_USER_ALIGN (type);\n-\t    }\n-#endif\n-\t}\n     }\n   else\n     {\n       /* Non-bit-fields are aligned for their type.  */\n       DECL_BIT_FIELD (field) = 0;\n       CLEAR_DECL_C_BIT_FIELD (field);\n-      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), TYPE_ALIGN (type));\n-      DECL_USER_ALIGN (field) |= TYPE_USER_ALIGN (type);\n     }\n }\n \n@@ -4428,8 +4404,6 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n       DECL_ARTIFICIAL (field) = 1;\n       DECL_FIELD_CONTEXT (field) = t;\n       DECL_FCONTEXT (field) = t;\n-      DECL_ALIGN (field) = TYPE_ALIGN (vtbl_ptr_type_node);\n-      DECL_USER_ALIGN (field) = TYPE_USER_ALIGN (vtbl_ptr_type_node);\n       \n       TYPE_VFIELD (t) = field;\n       \n@@ -4950,8 +4924,6 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t\t\t      char_type_node); \n \t  DECL_BIT_FIELD (padding_field) = 1;\n \t  DECL_SIZE (padding_field) = padding;\n-\t  DECL_ALIGN (padding_field) = 1;\n-\t  DECL_USER_ALIGN (padding_field) = 0;\n \t  layout_nonempty_base_or_field (rli, padding_field,\n \t\t\t\t\t NULL_TREE, \n \t\t\t\t\t empty_base_offsets);"}, {"sha": "9ff8040a7396e52d1f8b4e22104f5aeda231bbac", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -1160,8 +1160,7 @@ make it all fit in fewer cache lines.\n Alignment in bits to be given to a structure bit-field that follows an\n empty field such as @code{int : 0;}.\n \n-Note that @code{PCC_BITFIELD_TYPE_MATTERS} also affects the alignment\n-that results from an empty field.\n+If @code{PCC_BITFIELD_TYPE_MATTERS} is true, it overrides this macro.\n \n @findex STRUCTURE_SIZE_BOUNDARY\n @item STRUCTURE_SIZE_BOUNDARY"}, {"sha": "c840481ec4f94d61b7f77e271b7f547accf14e1b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 105, "deletions": 102, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -357,6 +357,19 @@ round_down (value, divisor)\n   return size_binop (MULT_EXPR, size_binop (FLOOR_DIV_EXPR, value, arg), arg);\n }\n \f\n+/* Subroutine of layout_decl: Force alignment required for the data type.\n+   But if the decl itself wants greater alignment, don't override that.  */\n+\n+static inline void\n+do_type_align (tree type, tree decl)\n+{\n+  if (TYPE_ALIGN (type) > DECL_ALIGN (decl))\n+    {\n+      DECL_ALIGN (decl) = TYPE_ALIGN (type);\n+      DECL_USER_ALIGN (decl) = TYPE_USER_ALIGN (type);\n+    }\n+}\n+\n /* Set the size, mode and alignment of a ..._DECL node.\n    TYPE_DECL does need this for C++.\n    Note that LABEL_DECL and CONST_DECL nodes do not need this,\n@@ -411,67 +424,96 @@ layout_decl (decl, known_align)\n       = convert (sizetype, size_binop (CEIL_DIV_EXPR, DECL_SIZE (decl),\n \t\t\t\t       bitsize_unit_node));\n \n-  /* Force alignment required for the data type.\n-     But if the decl itself wants greater alignment, don't override that.\n-     Likewise, if the decl is packed, don't override it.  */\n-  if (! (code == FIELD_DECL && DECL_BIT_FIELD (decl))\n-      && (DECL_ALIGN (decl) == 0\n-\t  || (! (code == FIELD_DECL && DECL_PACKED (decl))\n-\t      && TYPE_ALIGN (type) > DECL_ALIGN (decl))))\n+  if (code != FIELD_DECL)\n+    /* For non-fields, update the alignment from the type.  */\n+    do_type_align (type, decl);\n+  else\n+    /* For fields, it's a bit more complicated...  */\n     {\n-      DECL_ALIGN (decl) = TYPE_ALIGN (type);\n-      DECL_USER_ALIGN (decl) = 0;\n-    }\n+      if (DECL_BIT_FIELD (decl))\n+\t{\n+\t  DECL_BIT_FIELD_TYPE (decl) = type;\n \n-  /* For fields, set the bit field type and update the alignment.  */\n-  if (code == FIELD_DECL)\n-    {\n-      DECL_BIT_FIELD_TYPE (decl) = DECL_BIT_FIELD (decl) ? type : 0;\n-      if (maximum_field_alignment != 0)\n-\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);\n+\t  /* A zero-length bit-field affects the alignment of the next\n+\t     field.  */\n+\t  if (integer_zerop (DECL_SIZE (decl))\n+\t      && ! DECL_PACKED (decl)\n+\t      && ! (*targetm.ms_bitfield_layout_p) (DECL_FIELD_CONTEXT (decl)))\n+\t    {\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+\t      if (PCC_BITFIELD_TYPE_MATTERS)\n+\t\tdo_type_align (type, decl);\n+\t      else\n+#endif\n+#ifdef EMPTY_FIELD_BOUNDARY\n+\t\tif (EMPTY_FIELD_BOUNDARY > DECL_ALIGN (decl))\n+\t\t  {\n+\t\t    DECL_ALIGN (decl) = EMPTY_FIELD_BOUNDARY;\n+\t\t    DECL_USER_ALIGN (decl) = 0;\n+\t\t  }\n+#endif\n+\t    }\n+\n+\t  /* See if we can use an ordinary integer mode for a bit-field.\n+\t     Conditions are: a fixed size that is correct for another mode\n+\t     and occupying a complete byte or bytes on proper boundary.  */\n+\t  if (TYPE_SIZE (type) != 0\n+\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t      && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT)\n+\t    {\n+\t      enum machine_mode xmode\n+\t\t= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);\n+\n+\t      if (xmode != BLKmode && known_align >= GET_MODE_ALIGNMENT (xmode))\n+\t\t{\n+\t\t  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),\n+\t\t\t\t\t   DECL_ALIGN (decl));\n+\t\t  DECL_MODE (decl) = xmode;\n+\t\t  DECL_BIT_FIELD (decl) = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* Turn off DECL_BIT_FIELD if we won't need it set.  */\n+\t  if (TYPE_MODE (type) == BLKmode && DECL_MODE (decl) == BLKmode\n+\t      && known_align >= TYPE_ALIGN (type)\n+\t      && DECL_ALIGN (decl) >= TYPE_ALIGN (type))\n+\t    DECL_BIT_FIELD (decl) = 0;\n+\t}\n+      else if (DECL_PACKED (decl) && DECL_USER_ALIGN (decl))\n+\t/* Don't touch DECL_ALIGN.  For other packed fields, go ahead and\n+\t   round up; we'll reduce it again below.  */;\n+      else\n+\tdo_type_align (type, decl);\n \n       /* If the field is of variable size, we can't misalign it since we\n \t have no way to make a temporary to align the result.  But this\n \t isn't an issue if the decl is not addressable.  Likewise if it\n \t is of unknown size.  */\n-      else if (DECL_PACKED (decl)\n-\t       && (DECL_NONADDRESSABLE_P (decl)\n-\t\t   || DECL_SIZE_UNIT (decl) == 0\n-\t\t   || TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST))\n-\t{\n-\t  DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);\n-\t  DECL_USER_ALIGN (decl) = 0;\n-\t}\n-    }\n-\n-  /* See if we can use an ordinary integer mode for a bit-field.\n-     Conditions are: a fixed size that is correct for another mode\n-     and occupying a complete byte or bytes on proper boundary.  */\n-  if (code == FIELD_DECL && DECL_BIT_FIELD (decl)\n-      && TYPE_SIZE (type) != 0\n-      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-      && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT)\n-    {\n-      enum machine_mode xmode\n-\t= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);\n-\n-      if (xmode != BLKmode && known_align >= GET_MODE_ALIGNMENT (xmode))\n+      if (DECL_PACKED (decl)\n+\t  && !DECL_USER_ALIGN (decl)\n+\t  && (DECL_NONADDRESSABLE_P (decl)\n+\t      || DECL_SIZE_UNIT (decl) == 0\n+\t      || TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST))\n+\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);\n+\n+      /* Should this be controlled by DECL_USER_ALIGN, too?  */\n+      if (maximum_field_alignment != 0)\n+\tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);\n+      if (! DECL_USER_ALIGN (decl))\n \t{\n-\t  DECL_ALIGN (decl) = MAX (GET_MODE_ALIGNMENT (xmode),\n-\t\t\t\t   DECL_ALIGN (decl));\n-\t  DECL_MODE (decl) = xmode;\n-\t  DECL_BIT_FIELD (decl) = 0;\n+\t  /* Some targets (i.e. i386, VMS) limit struct field alignment\n+\t     to a lower boundary than alignment of variables unless\n+\t     it was overridden by attribute aligned.  */\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+\t  DECL_ALIGN (decl)\n+\t    = MIN (DECL_ALIGN (decl), (unsigned) BIGGEST_FIELD_ALIGNMENT);\n+#endif\n+#ifdef ADJUST_FIELD_ALIGN\n+\t  DECL_ALIGN (decl) = ADJUST_FIELD_ALIGN (decl, DECL_ALIGN (decl));\n+#endif\n \t}\n     }\n \n-  /* Turn off DECL_BIT_FIELD if we won't need it set.  */\n-  if (code == FIELD_DECL && DECL_BIT_FIELD (decl)\n-      && TYPE_MODE (type) == BLKmode && DECL_MODE (decl) == BLKmode\n-      && known_align >= TYPE_ALIGN (type)\n-      && DECL_ALIGN (decl) >= TYPE_ALIGN (type)\n-      && DECL_SIZE_UNIT (decl) != 0)\n-    DECL_BIT_FIELD (decl) = 0;\n-\n   /* Evaluate nonconstant size only once, either now or as soon as safe.  */\n   if (DECL_SIZE (decl) != 0 && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n     DECL_SIZE (decl) = variable_size (DECL_SIZE (decl));\n@@ -532,7 +574,7 @@ start_record_layout (t)\n      declaration, for example) use it -- otherwise, start with a\n      one-byte alignment.  */\n   rli->record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (t));\n-  rli->unpacked_align = rli->unpadded_align = rli->record_align;\n+  rli->unpacked_align = rli->record_align;\n   rli->offset_align = MAX (rli->record_align, BIGGEST_ALIGNMENT);\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n@@ -621,8 +663,8 @@ debug_rli (rli)\n   print_node_brief (stderr, \"\\noffset\", rli->offset, 0);\n   print_node_brief (stderr, \" bitpos\", rli->bitpos, 0);\n \n-  fprintf (stderr, \"\\naligns: rec = %u, unpack = %u, unpad = %u, off = %u\\n\",\n-\t   rli->record_align, rli->unpacked_align, rli->unpadded_align,\n+  fprintf (stderr, \"\\naligns: rec = %u, unpack = %u, off = %u\\n\",\n+\t   rli->record_align, rli->unpacked_align,\n \t   rli->offset_align);\n   if (rli->packed_maybe_necessary)\n     fprintf (stderr, \"packed may be necessary\\n\");\n@@ -679,40 +721,21 @@ update_alignment_for_field (rli, field, known_align)\n   tree type = TREE_TYPE (field);\n   /* True if the field was explicitly aligned by the user.  */\n   bool user_align;\n+  bool is_bitfield;\n \n-  /* Lay out the field so we know what alignment it needs.  For a\n-     packed field, use the alignment as specified, disregarding what\n-     the type would want.  */\n+  /* Lay out the field so we know what alignment it needs.  */\n+  layout_decl (field, known_align);\n   desired_align = DECL_ALIGN (field);\n   user_align = DECL_USER_ALIGN (field);\n-  layout_decl (field, known_align);\n-  if (! DECL_PACKED (field))\n-    {\n-      desired_align = DECL_ALIGN (field);\n-      user_align = DECL_USER_ALIGN (field);\n-    }\n-\n-  /* Some targets (i.e. i386, VMS) limit struct field alignment\n-     to a lower boundary than alignment of variables unless\n-     it was overridden by attribute aligned.  */\n-#ifdef BIGGEST_FIELD_ALIGNMENT\n-  if (!user_align)\n-    desired_align\n-      = MIN (desired_align, (unsigned) BIGGEST_FIELD_ALIGNMENT);\n-#endif\n \n-#ifdef ADJUST_FIELD_ALIGN\n-  if (!user_align)\n-    desired_align = ADJUST_FIELD_ALIGN (field, desired_align);\n-#endif\n+  is_bitfield = (type != error_mark_node\n+\t\t && DECL_BIT_FIELD_TYPE (field)\n+\t\t && ! integer_zerop (TYPE_SIZE (type)));\n \n   /* Record must have at least as much alignment as any field.\n      Otherwise, the alignment of the field within the record is\n      meaningless.  */\n-  if ((* targetm.ms_bitfield_layout_p) (rli->t)\n-      && type != error_mark_node\n-      && DECL_BIT_FIELD_TYPE (field)\n-      && ! integer_zerop (TYPE_SIZE (type)))\n+  if (is_bitfield && (* targetm.ms_bitfield_layout_p) (rli->t))\n     {\n       /* Here, the alignment of the underlying type of a bitfield can\n \t affect the alignment of a record; even a zero-sized field\n@@ -732,29 +755,11 @@ update_alignment_for_field (rli, field, known_align)\n \t    type_align = MIN (type_align, maximum_field_alignment);\n \t  rli->record_align = MAX (rli->record_align, type_align);\n \t  rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n-\t  rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n \t}\n-      else\n-\tdesired_align = 1;\n     }\n-  else\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n-  if (PCC_BITFIELD_TYPE_MATTERS && type != error_mark_node\n-      && ! (* targetm.ms_bitfield_layout_p) (rli->t)\n-      && DECL_BIT_FIELD_TYPE (field)\n-      && ! integer_zerop (TYPE_SIZE (type)))\n+  else if (is_bitfield && PCC_BITFIELD_TYPE_MATTERS)\n     {\n-      /* A zero-length bit-field affects the alignment of the next\n-\t field.  */\n-      if (!DECL_PACKED (field) && !user_align\n-\t  && integer_zerop (DECL_SIZE (field)))\n-\t{\n-\t  desired_align = TYPE_ALIGN (type);\n-#ifdef ADJUST_FIELD_ALIGN\n-\t  desired_align = ADJUST_FIELD_ALIGN (field, desired_align);\n-#endif\n-\t}\n-\n       /* Named bit-fields cause the entire structure to have the\n \t alignment implied by their type.  */\n       if (DECL_NAME (field) != 0)\n@@ -779,18 +784,16 @@ update_alignment_for_field (rli, field, known_align)\n \t  rli->record_align = MAX (rli->record_align, desired_align);\n \t  rli->record_align = MAX (rli->record_align, type_align);\n \n-\t  rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n \t  if (warn_packed)\n \t    rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n \t  user_align |= TYPE_USER_ALIGN (type);\n \t}\n     }\n-  else\n #endif\n+  else\n     {\n       rli->record_align = MAX (rli->record_align, desired_align);\n       rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n-      rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n     }\n \n   TYPE_USER_ALIGN (rli->t) |= user_align;\n@@ -905,7 +908,7 @@ place_field (rli, field)\n \n   if (warn_packed && DECL_PACKED (field))\n     {\n-      if (known_align > TYPE_ALIGN (type))\n+      if (known_align >= TYPE_ALIGN (type))\n \t{\n \t  if (TYPE_ALIGN (type) > desired_align)\n \t    {"}, {"sha": "12352d8112c3cfb641b19a79c72faf4a568de048", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d55cc86ecc681c975581dd3e7e20bb5315b83a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=78d55cc86ecc681c975581dd3e7e20bb5315b83a", "patch": "@@ -2452,18 +2452,18 @@ typedef struct record_layout_info_s\n   tree bitpos;\n   /* The alignment of the record so far, in bits.  */\n   unsigned int record_align;\n-  /* The alignment of the record so far, not including padding, in bits.  */\n+  /* The alignment of the record so far, ignoring #pragma pack and\n+     __attribute__ ((packed)), in bits.  */\n   unsigned int unpacked_align;\n-  /* The alignment of the record so far, allowing for the record to be\n-     padded only at the end, in bits.  */\n-  unsigned int unpadded_align;\n   /* The previous field layed out.  */\n   tree prev_field;\n   /* The static variables (i.e., class variables, as opposed to\n      instance variables) encountered in T.  */\n   tree pending_statics;\n   /* Bits remaining in the current alignment group */\n   int remaining_in_alignment;\n+  /* True if we've seen a packed field that didn't have normal\n+     alignment anyway.  */\n   int packed_maybe_necessary;\n } *record_layout_info;\n "}]}