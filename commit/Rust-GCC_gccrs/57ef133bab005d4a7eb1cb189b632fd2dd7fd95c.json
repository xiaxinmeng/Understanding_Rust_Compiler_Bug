{"sha": "57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlZjEzM2JhYjAwNWQ0YTdlYjFjYjE4OWI2MzJmZDJkZDdmZDk1Yw==", "commit": {"author": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2014-04-04T13:54:16Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2014-04-04T13:54:16Z"}, "message": "re PR fortran/60191 (test case gfortran.dg/dynamic_dispatch_1/3.f03 fail on ARMv7)\n\n2014-04-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR fortran/60191\n        * fortran/trans-types.c (gfc_get_function_type): In case of recursion\n        build a variadic function type with empty argument list instead of a\n        stdarg-like function type with incomplete argument list.\n\nFrom-SVN: r209091", "tree": {"sha": "28189e90068c27c5ac5c0e8779d684a26aaceab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28189e90068c27c5ac5c0e8779d684a26aaceab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c/comments", "author": null, "committer": null, "parents": [{"sha": "fc02bcca0124e5678f3f820d26e614cdfb231fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc02bcca0124e5678f3f820d26e614cdfb231fd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc02bcca0124e5678f3f820d26e614cdfb231fd7"}], "stats": {"total": 35, "additions": 16, "deletions": 19}, "files": [{"sha": "15419fe7fbb3cb1665811db7f71501965f01d86f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "patch": "@@ -1,6 +1,13 @@\n+2014-04-04  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR fortran/60191\n+\t* fortran/trans-types.c (gfc_get_function_type): In case of recursion\n+\tbuild a variadic function type with empty argument list instead of a\n+\tstdarg-like function type with incomplete argument list.\n+\n 2014-04-04  Jeff Law  <law@redhat.com>\n \n-        PR target/60657\n+\tPR target/60657\n \t* config/arm/predicates.md (const_int_I_operand): New predicate.\n \t(const_int_M_operand): Similarly.\n \t* config/arm/arm.md (insv_zero): Use const_int_M_operand instead of"}, {"sha": "59637f2d3cb730115ef1a99dc4b0091153cc47db", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ef133bab005d4a7eb1cb189b632fd2dd7fd95c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=57ef133bab005d4a7eb1cb189b632fd2dd7fd95c", "patch": "@@ -2714,11 +2714,11 @@ tree\n gfc_get_function_type (gfc_symbol * sym)\n {\n   tree type;\n-  vec<tree, va_gc> *typelist;\n+  vec<tree, va_gc> *typelist = NULL;\n   gfc_formal_arglist *f;\n   gfc_symbol *arg;\n-  int alternate_return;\n-  bool is_varargs = true, recursive_type = false;\n+  int alternate_return = 0;\n+  bool is_varargs = true;\n \n   /* Make sure this symbol is a function, a subroutine or the main\n      program.  */\n@@ -2730,15 +2730,12 @@ gfc_get_function_type (gfc_symbol * sym)\n   if (sym->backend_decl == NULL)\n     sym->backend_decl = error_mark_node;\n   else if (sym->backend_decl == error_mark_node)\n-    recursive_type = true;\n+    goto arg_type_list_done;\n   else if (sym->attr.proc_pointer)\n     return TREE_TYPE (TREE_TYPE (sym->backend_decl));\n   else\n     return TREE_TYPE (sym->backend_decl);\n \n-  alternate_return = 0;\n-  typelist = NULL;\n-\n   if (sym->attr.entry_master)\n     /* Additional parameter for selecting an entry point.  */\n     vec_safe_push (typelist, gfc_array_index_type);\n@@ -2786,13 +2783,6 @@ gfc_get_function_type (gfc_symbol * sym)\n \n \t  if (arg->attr.flavor == FL_PROCEDURE)\n \t    {\n-\t      /* We don't know in the general case which argument causes\n-\t\t recursion.  But we know that it is a procedure.  So we give up\n-\t\t creating the procedure argument type list at the first\n-\t\t procedure argument.  */\n-\t      if (recursive_type)\n-\t        goto arg_type_list_done;\n-\n \t      type = gfc_get_function_type (arg);\n \t      type = build_pointer_type (type);\n \t    }\n@@ -2846,11 +2836,11 @@ gfc_get_function_type (gfc_symbol * sym)\n       || sym->attr.if_source != IFSRC_UNKNOWN)\n     is_varargs = false;\n \n-arg_type_list_done:\n-\n-  if (!recursive_type && sym->backend_decl == error_mark_node)\n+  if (sym->backend_decl == error_mark_node)\n     sym->backend_decl = NULL_TREE;\n \n+arg_type_list_done:\n+\n   if (alternate_return)\n     type = integer_type_node;\n   else if (!sym->attr.function || gfc_return_by_reference (sym))\n@@ -2888,7 +2878,7 @@ gfc_get_function_type (gfc_symbol * sym)\n   else\n     type = gfc_sym_type (sym);\n \n-  if (is_varargs || recursive_type)\n+  if (is_varargs)\n     type = build_varargs_function_type_vec (type, typelist);\n   else\n     type = build_function_type_vec (type, typelist);"}]}