{"sha": "31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFhYjg5YzE0YWZjNTVjMjZjY2FhYmViY2ZmMGJjZmRkMmM4NzM2OQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-18T12:55:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-18T12:55:11Z"}, "message": "cp-tree.h (lookup_add): Swap args.\n\n\t* cp-tree.h (lookup_add): Swap args.\n\t(ovl_cons, build_overload): Delete.\n\t* name-lookup.c (add_function, push_overloaded_decl_1)\n\tdo_nonmember_using_decl, merge_functions, remove_hidden_names):\n\tUse lookup_add, ovl_insert.\n\t* pt.c (check_explicit_specialization): Use lookup_add.\n\t(do_class_deduction): Likewise. Refactor if.\n\t* tree.c (lookup_add): Swap args.\n\t(ovl_cons, build_overload): Delete.\n(--This line, and those below, will be ignored--\n\nM    cp/cp-tree.h\nM    cp/name-lookup.c\nM    cp/pt.c\nM    cp/ChangeLog\nM    cp/tree.c\n\nFrom-SVN: r248198", "tree": {"sha": "ff7e43e5e7f64802c6fe865992d5936778bd658e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7e43e5e7f64802c6fe865992d5936778bd658e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6574d78eeac0e1ecddb05c6df33fa1b77e712bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6574d78eeac0e1ecddb05c6df33fa1b77e712bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6574d78eeac0e1ecddb05c6df33fa1b77e712bf6"}], "stats": {"total": 125, "additions": 41, "deletions": 84}, "files": [{"sha": "8b5f8513a5a0832521518bd450c42a33613e34d5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "patch": "@@ -1,5 +1,15 @@\n 2017-05-18  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (lookup_add): Swap args.\n+\t(ovl_cons, build_overload): Delete.\n+\t* name-lookup.c (add_function, push_overloaded_decl_1,\n+\tdo_nonmember_using_decl, merge_functions, remove_hidden_names):\n+\tUse lookup_add, ovl_insert.\n+\t* pt.c (check_explicit_specialization): Use lookup_add.\n+\t(do_class_deduction): Likewise. Refactor if.\n+\t* tree.c (lookup_add): Swap args.\n+\t(ovl_cons, build_overload): Delete.\n+\n \t* name-lookup.c (find_local_binding): New, broken out of ...\n \t(lookup_name_innermost_nonclass_level_1): ... here.  Call it.\n \t(set_namespace_binding): Swap scope & name args."}, {"sha": "3e1cf306eb0b927f559b8e2a6349a15031043e54", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "patch": "@@ -6809,13 +6809,11 @@ extern tree ovl_make\t\t\t\t(tree fn,\n \t\t\t\t\t\t tree next = NULL_TREE);\n extern tree ovl_insert\t\t\t\t(tree fn, tree maybe_ovl,\n \t\t\t\t\t\t bool using_p = false);\n-extern tree lookup_add\t\t\t\t(tree lookup, tree ovl);\n+extern tree lookup_add\t\t\t\t(tree fns, tree lookup);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree dependent_name\t\t\t(tree);\n extern tree get_fns\t\t\t\t(tree) ATTRIBUTE_PURE;\n extern tree get_first_fn\t\t\t(tree) ATTRIBUTE_PURE;\n-extern tree ovl_cons\t\t\t\t(tree, tree);\n-extern tree build_overload\t\t\t(tree, tree);\n extern tree ovl_scope\t\t\t\t(tree);\n extern const char *cxx_printable_name\t\t(tree, int);\n extern const char *cxx_printable_name_translate\t(tree, int);"}, {"sha": "a4fe3d3ee2a7272f97946a0d578a913a8fc8d992", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "patch": "@@ -160,7 +160,7 @@ add_function (struct arg_lookup *k, tree fn)\n     ;\n   else\n     {\n-      k->functions = build_overload (fn, k->functions);\n+      k->functions = lookup_add (fn, k->functions);\n       if (TREE_CODE (k->functions) == OVERLOAD)\n \tOVL_ARG_DEPENDENT (k->functions) = true;\n     }\n@@ -2952,24 +2952,7 @@ push_overloaded_decl_1 (tree decl, int flags, bool is_friend)\n \t}\n     }\n \n-  if (old || TREE_CODE (decl) == TEMPLATE_DECL\n-      /* If it's a using declaration, we always need to build an OVERLOAD,\n-\t because it's the only way to remember that the declaration comes\n-\t from 'using', and have the lookup behave correctly.  */\n-      || (flags & PUSH_USING))\n-    {\n-      if (old && TREE_CODE (old) != OVERLOAD)\n-\t/* Wrap the existing single decl in an overload.  */\n-\tnew_binding = ovl_cons (old, NULL_TREE);\n-      else\n-\tnew_binding = old;\n-      new_binding = ovl_cons (decl, new_binding);\n-      if (flags & PUSH_USING)\n-\tOVL_USED (new_binding) = 1;\n-    }\n-  else\n-    /* NAME is not ambiguous.  */\n-    new_binding = decl;\n+  new_binding = ovl_insert (decl, old, flags & PUSH_USING);\n \n   if (doing_global)\n     set_namespace_binding (current_namespace, name, new_binding);\n@@ -3184,17 +3167,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t      if (*newval && TREE_CODE (*newval) == OVERLOAD)\n \t\tTREE_TYPE (*newval) = unknown_type_node;\n \t      /* Add this new function to the set.  */\n-\t      *newval = build_overload (OVL_CURRENT (tmp), *newval);\n-\t      /* If there is only one function, then we use its type.  (A\n-\t\t using-declaration naming a single function can be used in\n-\t\t contexts where overload resolution cannot be\n-\t\t performed.)  */\n-\t      if (TREE_CODE (*newval) != OVERLOAD)\n-\t\t{\n-\t\t  *newval = ovl_cons (*newval, NULL_TREE);\n-\t\t  TREE_TYPE (*newval) = TREE_TYPE (OVL_CURRENT (tmp));\n-\t\t}\n-\t      OVL_USED (*newval) = 1;\n+\t      *newval = ovl_insert (OVL_CURRENT (tmp), *newval, true);\n \t    }\n \t}\n       else\n@@ -4578,7 +4551,7 @@ merge_functions (tree s1, tree s2)\n \n       /* If we exhausted all of the functions in S1, FN2 is new.  */\n       if (!fns1)\n-\ts1 = build_overload (fn2, s1);\n+\ts1 = lookup_add (fn2, s1);\n     }\n   return s1;\n }\n@@ -4788,7 +4761,7 @@ remove_hidden_names (tree fns)\n \n \t  for (o = fns; o; o = OVL_NEXT (o))\n \t    if (!hidden_name_p (OVL_CURRENT (o)))\n-\t      n = build_overload (OVL_CURRENT (o), n);\n+\t      n = lookup_add (OVL_CURRENT (o), n);\n \t  fns = n;\n \t}\n     }"}, {"sha": "ed3f45ed84ed7ff63a7f0c7f1bf2b73a6abc4200", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "patch": "@@ -2931,7 +2931,7 @@ check_explicit_specialization (tree declarator,\n \t\t    /* Glue all these conversion functions together\n \t\t       with those we already have.  */\n \t\t    for (; ovl; ovl = OVL_NEXT (ovl))\n-\t\t      fns = ovl_cons (OVL_CURRENT (ovl), fns);\n+\t\t      fns = lookup_add (OVL_CURRENT (ovl), fns);\n \t\t  }\n \t    }\n \n@@ -25171,7 +25171,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n \t  tree pruned = NULL_TREE;\n \t  for (lkp_iterator iter (cands); iter; ++iter)\n \t    if (!DECL_NONCONVERTING_P (STRIP_TEMPLATE (*iter)))\n-\t      pruned = lookup_add (pruned, *iter);\n+\t      pruned = lookup_add (*iter, pruned);\n \n \t  cands = pruned;\n \t}\n@@ -25196,29 +25196,29 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n \t    && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n \t  elided = true;\n \telse\n-\t  cands = lookup_add (cands, guide);\n+\t  cands = lookup_add (guide, cands);\n \n \tsaw_ctor = true;\n       }\n \n-  if (!saw_ctor && args->length() == 0)\n+  if (args->length () < 2)\n     {\n-      tree guide = build_deduction_guide (type, outer_args, complain);\n-      if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n-\telided = true;\n-      else\n-\tcands = lookup_add (cands, guide);\n-    }\n-  if (args->length() == 1)\n-    {\n-      tree guide = build_deduction_guide (build_reference_type (type),\n-\t\t\t\t\t  outer_args, complain);\n-      if ((flags & LOOKUP_ONLYCONVERTING)\n-\t  && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n-\telided = true;\n-      else\n-\tcands = lookup_add (cands, guide);\n+      tree gtype = NULL_TREE;\n+\n+      if (args->length () == 1)\n+\tgtype = build_reference_type (type);\n+      else if (!saw_ctor)\n+\tgtype = type;\n+\n+      if (gtype)\n+\t{\n+\t  tree guide = build_deduction_guide (gtype, outer_args, complain);\n+\t  if ((flags & LOOKUP_ONLYCONVERTING)\n+\t      && DECL_NONCONVERTING_P (STRIP_TEMPLATE (guide)))\n+\t    elided = true;\n+\t  else\n+\t    cands = lookup_add (guide, cands);\n+\t}\n     }\n \n   if (elided && !cands)"}, {"sha": "4417f079212c0c588e8fab95dd6301ecd6093c1b", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31ab89c14afc55c26ccaabebcff0bcfdd2c87369/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=31ab89c14afc55c26ccaabebcff0bcfdd2c87369", "patch": "@@ -2183,18 +2183,18 @@ ovl_iterator::remove_node (tree overload, tree node)\n   return overload;\n }\n \n-/* Add a potential overload into a lookup set.  */\n+/* Add a set of new FNS into a lookup.  */\n \n tree\n-lookup_add (tree lookup, tree ovl)\n+lookup_add (tree fns, tree lookup)\n {\n-  if (lookup || TREE_CODE (ovl) == TEMPLATE_DECL)\n+  if (lookup || TREE_CODE (fns) == TEMPLATE_DECL)\n     {\n-      lookup = ovl_make (ovl, lookup);\n+      lookup = ovl_make (fns, lookup);\n       OVL_LOOKUP_P (lookup) = true;\n     }\n   else\n-    lookup = ovl;\n+    lookup = fns;\n \n   return lookup;\n }\n@@ -2277,30 +2277,6 @@ get_first_fn (tree from)\n   return OVL_FIRST (get_fns (from));\n }\n \n-/* Return a new OVL node, concatenating it with the old one.  */\n-\n-tree\n-ovl_cons (tree decl, tree chain)\n-{\n-  tree result = make_node (OVERLOAD);\n-  TREE_TYPE (result) = unknown_type_node;\n-  OVL_FUNCTION (result) = decl;\n-  TREE_CHAIN (result) = chain;\n-\n-  return result;\n-}\n-\n-/* Build a new overloaded function. If this is the first one,\n-   just return it; otherwise, ovl_cons the _DECLs */\n-\n-tree\n-build_overload (tree decl, tree chain)\n-{\n-  if (! chain && TREE_CODE (decl) != TEMPLATE_DECL)\n-    return decl;\n-  return ovl_cons (decl, chain);\n-}\n-\n /* Return the scope where the overloaded functions OVL were found.  */\n \n tree"}]}