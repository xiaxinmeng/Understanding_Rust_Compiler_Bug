{"sha": "3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyYTdhNmEyNjM5ODQ1Nzg3ZDNiNjhiN2VjZWI4MmJiMTdiYzU0ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-10-05T19:07:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-10-05T19:07:47Z"}, "message": "tree-inline.c (remap_type): New.\n\n        * tree-inline.c (remap_type): New.\n        (remap_decl): Use it.  Remap DECL_SIZE*.\n        (copy_body_r): Use it.\n        (walk_tree): Walk TREE_TYPE too.\n        (copy_tree_r): Don't walk subtrees of types.\n        * tree.c (variably_modified_type_p): Restructure.  Consider integer\n        types with non-const bounds variably modified.\n\nFrom-SVN: r72114", "tree": {"sha": "34e4f389e33a00021eeccf202312f4f5e5f221cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34e4f389e33a00021eeccf202312f4f5e5f221cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/comments", "author": null, "committer": null, "parents": [{"sha": "a2b172fb9c199753770b05e27af9d242706f8c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b172fb9c199753770b05e27af9d242706f8c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b172fb9c199753770b05e27af9d242706f8c26"}], "stats": {"total": 225, "additions": 179, "deletions": 46}, "files": [{"sha": "e8dfbb5a76d252340c87aa55cccc8ca6949b4a46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "patch": "@@ -1,3 +1,13 @@\n+2003-10-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-inline.c (remap_type): New.\n+\t(remap_decl): Use it.  Remap DECL_SIZE*.\n+\t(copy_body_r): Use it.\n+\t(walk_tree): Walk TREE_TYPE too.\n+\t(copy_tree_r): Don't walk subtrees of types.\n+\t* tree.c (variably_modified_type_p): Restructure.  Consider integer\n+\ttypes with non-const bounds variably modified.\n+\n 2003-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/invoke.texi: Fix typos."}, {"sha": "0696c4060a4cdaef1d1ed4427ab90aa77dd3b1db", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 129, "deletions": 19, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "patch": "@@ -121,6 +121,7 @@ static void expand_calls_inline (tree *, inline_data *);\n static bool inlinable_function_p (tree);\n static int limits_allow_inlining (tree, inline_data *);\n static tree remap_decl (tree, inline_data *);\n+static tree remap_type (tree, inline_data *);\n #ifndef INLINER_FOR_JAVA\n static tree initialize_inlined_parameters (inline_data *, tree, tree);\n static void remap_block (tree, tree, inline_data *);\n@@ -146,36 +147,34 @@ remap_decl (tree decl, inline_data *id)\n \n   /* See if we have remapped this declaration.  */\n   n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+\n   /* If we didn't already have an equivalent for this declaration,\n      create one now.  */\n   if (!n)\n     {\n       tree t;\n \n       /* Make a copy of the variable or label.  */\n-      t = copy_decl_for_inlining (decl, fn,\n-\t\t\t\t  VARRAY_TREE (id->fns, 0));\n-\n-      /* The decl T could be a dynamic array or other variable size type,\n-\t in which case some fields need to be remapped because they may\n-\t contain SAVE_EXPRs.  */\n-      if (TREE_TYPE (t) && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n-\t  && TYPE_DOMAIN (TREE_TYPE (t)))\n-\t{\n-\t  TREE_TYPE (t) = copy_node (TREE_TYPE (t));\n-\t  TYPE_DOMAIN (TREE_TYPE (t))\n-\t    = copy_node (TYPE_DOMAIN (TREE_TYPE (t)));\n-\t  walk_tree (&TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (t))),\n-\t\t     copy_body_r, id, NULL);\n-\t}\n+      t = copy_decl_for_inlining (decl, fn, VARRAY_TREE (id->fns, 0));\n+\n+      /* Remap types, if necessary.  */\n+      TREE_TYPE (t) = remap_type (TREE_TYPE (t), id);\n+      if (TREE_CODE (t) == TYPE_DECL)\n+        DECL_ORIGINAL_TYPE (t) = remap_type (DECL_ORIGINAL_TYPE (t), id);\n+      else if (TREE_CODE (t) == PARM_DECL)\n+        DECL_ARG_TYPE_AS_WRITTEN (t)\n+\t  = remap_type (DECL_ARG_TYPE_AS_WRITTEN (t), id);\n+\n+      /* Remap sizes as necessary.  */\n+      walk_tree (&DECL_SIZE (t), copy_body_r, id, NULL);\n+      walk_tree (&DECL_SIZE_UNIT (t), copy_body_r, id, NULL);\n \n #ifndef INLINER_FOR_JAVA\n       if (! DECL_NAME (t) && TREE_TYPE (t)\n \t  && (*lang_hooks.tree_inlining.anon_aggr_type_p) (TREE_TYPE (t)))\n \t{\n \t  /* For a VAR_DECL of anonymous type, we must also copy the\n-\t     member VAR_DECLS here and rechain the\n-\t     DECL_ANON_UNION_ELEMS.  */\n+\t     member VAR_DECLS here and rechain the DECL_ANON_UNION_ELEMS.  */\n \t  tree members = NULL;\n \t  tree src;\n \n@@ -202,6 +201,111 @@ remap_decl (tree decl, inline_data *id)\n   return (tree) n->value;\n }\n \n+static tree\n+remap_type (tree type, inline_data *id)\n+{\n+  splay_tree_node node;\n+  tree new, t;\n+\n+  if (type == NULL)\n+    return type;\n+\n+  /* See if we have remapped this type.  */\n+  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n+  if (node)\n+    return (tree) node->value;\n+\n+  /* The type only needs remapping if it's variably modified.  */\n+  if (! variably_modified_type_p (type))\n+    {\n+      splay_tree_insert (id->decl_map, (splay_tree_key) type,\n+\t\t\t (splay_tree_value) type);\n+      return type;\n+    }\n+  \n+  /* We do need a copy.  build and register it now.  */\n+  new = copy_node (type);\n+  splay_tree_insert (id->decl_map, (splay_tree_key) type,\n+\t\t     (splay_tree_value) new);\n+\n+  /* This is a new type, not a copy of an old type.  Need to reassociate\n+     variants.  We can handle everything except the main variant lazily.  */\n+  t = TYPE_MAIN_VARIANT (type);\n+  if (type != t)\n+    {\n+      t = remap_type (t, id);\n+      TYPE_MAIN_VARIANT (new) = t;\n+      TYPE_NEXT_VARIANT (new) = TYPE_MAIN_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (new) = new;\n+      TYPE_NEXT_VARIANT (new) = NULL;\n+    }\n+\n+  /* Lazily create pointer and reference types.  */\n+  TYPE_POINTER_TO (new) = NULL;\n+  TYPE_REFERENCE_TO (new) = NULL;\n+\n+  switch (TREE_CODE (new))\n+    {\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+      t = TYPE_MIN_VALUE (new);\n+      if (t && TREE_CODE (t) != INTEGER_CST)\n+        walk_tree (&TYPE_MIN_VALUE (new), copy_body_r, id, NULL);\n+      t = TYPE_MAX_VALUE (new);\n+      if (t && TREE_CODE (t) != INTEGER_CST)\n+        walk_tree (&TYPE_MAX_VALUE (new), copy_body_r, id, NULL);\n+      return new;\n+    \n+    case POINTER_TYPE:\n+      TREE_TYPE (new) = t = remap_type (TREE_TYPE (new), id);\n+      if (TYPE_MODE (new) == ptr_mode)\n+        TYPE_POINTER_TO (t) = new;\n+      return new;\n+\n+    case REFERENCE_TYPE:\n+      TREE_TYPE (new) = t = remap_type (TREE_TYPE (new), id);\n+      if (TYPE_MODE (new) == ptr_mode)\n+        TYPE_REFERENCE_TO (t) = new;\n+      return new;\n+\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+      TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n+      walk_tree (&TYPE_ARG_TYPES (new), copy_body_r, id, NULL);\n+      return new;\n+\n+    case ARRAY_TYPE:\n+      TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n+      TYPE_DOMAIN (new) = remap_type (TYPE_DOMAIN (new), id);\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      walk_tree (&TYPE_FIELDS (new), copy_body_r, id, NULL);\n+      break;\n+\n+    case FILE_TYPE:\n+    case SET_TYPE:\n+    case OFFSET_TYPE:\n+    default:\n+      /* Shouldn't have been thought variable sized.  */\n+      abort ();\n+    }\n+\n+  walk_tree (&TYPE_SIZE (new), copy_body_r, id, NULL);\n+  walk_tree (&TYPE_SIZE_UNIT (new), copy_body_r, id, NULL);\n+\n+  return new;\n+}\n+\n #ifndef INLINER_FOR_JAVA\n /* Copy the SCOPE_STMT_BLOCK associated with SCOPE_STMT to contain\n    remapped versions of the variables therein.  And hook the new block\n@@ -525,6 +629,10 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       TREE_OPERAND (*tp, 0) = (tree) n->value;\n     }\n #endif /* INLINER_FOR_JAVA */\n+  /* Types may need remapping as well.  */\n+  else if (TYPE_P (*tp))\n+    *tp = remap_type (*tp, id);\n+\n   /* Otherwise, just copy the node.  Note that copy_tree_r already\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n@@ -576,6 +684,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \n       copy_tree_r (tp, walk_subtrees, NULL);\n \n+      TREE_TYPE (*tp) = remap_type (TREE_TYPE (*tp), id);\n+\n       /* The copied TARGET_EXPR has never been expanded, even if the\n \t original node was expanded already.  */\n       if (TREE_CODE (*tp) == TARGET_EXPR && TREE_OPERAND (*tp, 3))\n@@ -1787,6 +1897,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n \t      WALK_SUBTREE (DECL_INITIAL (DECL_STMT_DECL (*tp)));\n \t      WALK_SUBTREE (DECL_SIZE (DECL_STMT_DECL (*tp)));\n \t      WALK_SUBTREE (DECL_SIZE_UNIT (DECL_STMT_DECL (*tp)));\n+\t      WALK_SUBTREE (TREE_TYPE (*tp));\n \t    }\n \n \t  /* This can be tail-recursion optimized if we write it this way.  */\n@@ -1968,8 +2079,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \tTREE_CHAIN (*tp) = chain;\n #endif /* INLINER_FOR_JAVA */\n     }\n-  else if (TREE_CODE_CLASS (code) == 't' && !variably_modified_type_p (*tp))\n-    /* Types only need to be copied if they are variably modified.  */\n+  else if (TREE_CODE_CLASS (code) == 't')\n     *walk_subtrees = 0;\n \n   return NULL_TREE;"}, {"sha": "896636a5e2b4fa9ae2d3d39adbeb4e900ac2391f", "filename": "gcc/tree.c", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c2a7a6a2639845787d3b68b7eceb82bb17bc54d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3c2a7a6a2639845787d3b68b7eceb82bb17bc54d", "patch": "@@ -4273,6 +4273,8 @@ int_fits_type_p (tree c, tree type)\n bool\n variably_modified_type_p (tree type)\n {\n+  tree t;\n+\n   if (type == error_mark_node)\n     return false;\n \n@@ -4281,39 +4283,50 @@ variably_modified_type_p (tree type)\n      We do not yet have a representation of the C99 '[*]' syntax.\n      When a representation is chosen, this function should be modified\n      to test for that case as well.  */\n-  if (TYPE_SIZE (type)\n-      && TYPE_SIZE (type) != error_mark_node\n-      && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+  t = TYPE_SIZE (type);\n+  if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n     return true;\n \n-  /* If TYPE is a pointer or reference, it is variably modified if\n-     the type pointed to is variably modified.  */\n-  if ((TREE_CODE (type) == POINTER_TYPE\n-       || TREE_CODE (type) == REFERENCE_TYPE)\n-      && variably_modified_type_p (TREE_TYPE (type)))\n-    return true;\n+  switch (TREE_CODE (type))\n+    {\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case ARRAY_TYPE:\n+      /* If TYPE is a pointer or reference, it is variably modified if\n+\t the type pointed to is variably modified.  Similarly for arrays;\n+\t note that VLAs are handled by the TYPE_SIZE check above.  */\n+      return variably_modified_type_p (TREE_TYPE (type));\n \n-  /* If TYPE is an array, it is variably modified if the array\n-     elements are.  (Note that the VLA case has already been checked\n-     above.)  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && variably_modified_type_p (TREE_TYPE (type)))\n-    return true;\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      /* If TYPE is a function type, it is variably modified if any of the\n+         parameters or the return type are variably modified.  */\n+      {\n+\ttree parm;\n \n-  /* If TYPE is a function type, it is variably modified if any of the\n-     parameters or the return type are variably modified.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE\n-      || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      tree parm;\n+\tif (variably_modified_type_p (TREE_TYPE (type)))\n+\t  return true;\n+\tfor (parm = TYPE_ARG_TYPES (type);\n+\t     parm && parm != void_list_node;\n+\t     parm = TREE_CHAIN (parm))\n+\t  if (variably_modified_type_p (TREE_VALUE (parm)))\n+\t    return true;\n+      }\n+      break;\n \n-      if (variably_modified_type_p (TREE_TYPE (type)))\n+    case INTEGER_TYPE:\n+      /* Scalar types are variably modified if their end points\n+\t aren't constant.  */\n+      t = TYPE_MIN_VALUE (type);\n+      if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n \treturn true;\n-      for (parm = TYPE_ARG_TYPES (type);\n-\t   parm && parm != void_list_node;\n-\t   parm = TREE_CHAIN (parm))\n-\tif (variably_modified_type_p (TREE_VALUE (parm)))\n-\t  return true;\n+      t = TYPE_MAX_VALUE (type);\n+      if (t && t != error_mark_node && TREE_CODE (t) != INTEGER_CST)\n+\treturn true;\n+      return false;\n+\n+    default:\n+      break;\n     }\n \n   /* The current language may have other cases to check, but in general,"}]}