{"sha": "17f6e37dc188165f634dbb606ecb23892bf2e125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdmNmUzN2RjMTg4MTY1ZjYzNGRiYjYwNmVjYjIzODkyYmYyZTEyNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-08-07T06:23:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-08-07T06:23:42Z"}, "message": "dwarf2out.c (output_fde): When doing hot/cold partitioning...\n\n\t* dwarf2out.c (output_fde): When doing hot/cold partitioning, use\n\tfde->dw_fde_begin as begin label instead of hot/cold label.\n\tUse LLSDAC label instead of LLSDA for second section lsda.\n\t(dwarf2out_do_cfi_startproc): Add SECOND argument.  Use LLSDAC\n\tlabel instead of LLSDA if it is true.\n\t(dwarf2out_begin_prologue, dwarf2out_switch_text_section): Adjust\n\tcallers.\n\t* except.c (add_call_site, dw2_size_of_call_site_table): Add\n\tSECTION argument.  Use it as index into crtl->eh.call_site_record\n\tarray.\n\t(dw2_output_call_site_table): Likewise.  Add CS_FORMAT argument,\n\tuse it to determine how to print table entries instead of using\n\t#ifdef HAVE_AS_LEB128.  For SECTION > 0 use hot resp. cold\n\tlabel instead of normal begin label as base.\n\t(sjlj_assign_call_site_values): Adjust add_call_site caller.\n\t(convert_to_eh_region_ranges): When doing hot/cold partitioning,\n\tensure no EH range spans between sections and that landing pads\n\tare always in the corresponding section.\n\t(sjlj_size_of_call_site_table, sjlj_output_call_site_table): Adjust\n\tfor crtl->eh.call_site_record being an array rather than scalar.\n\t(output_one_function_exception_table): New function, copied\n\tfrom output_function_exception_table.  Adjust\n\tdw2_size_of_call_site_table, dw2_output_call_site_table\n\tcallers.  For SECOND section use *C suffixed labels.\n\t(output_function_exception_table): Call\n\toutput_one_function_exception_table and, when doing hot/cold\n\tpartitioning, also another time for the second section.\n\t* opts.c: Include except.h.\n\t(decode_options): Allow -freorder-blocks-and-partition with\n\texceptions, unless SJLJ or TARGET_UNWIND_INFO.\n\t* Makefile.in (opts.o): Depend on $(EXCEPT_H).\n\t* function.h (struct rtl_eh): Change call_site_record from\n\tscalar into array of 2 elements.\n\n\t* g++.dg/tree-prof/partition1.C: New test.\n\nFrom-SVN: r150553", "tree": {"sha": "be903d41bba7e532d63c4989541b151675fc4f7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be903d41bba7e532d63c4989541b151675fc4f7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17f6e37dc188165f634dbb606ecb23892bf2e125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f6e37dc188165f634dbb606ecb23892bf2e125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f6e37dc188165f634dbb606ecb23892bf2e125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f6e37dc188165f634dbb606ecb23892bf2e125/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f84bf08c48ea4e037a74f1122c6420ce557518d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f84bf08c48ea4e037a74f1122c6420ce557518d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f84bf08c48ea4e037a74f1122c6420ce557518d"}], "stats": {"total": 456, "additions": 377, "deletions": 79}, "files": [{"sha": "1a76d9acef676ac6b82b14b38c0034a435fc2a10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -1,3 +1,39 @@\n+2009-08-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* dwarf2out.c (output_fde): When doing hot/cold partitioning, use\n+\tfde->dw_fde_begin as begin label instead of hot/cold label.\n+\tUse LLSDAC label instead of LLSDA for second section lsda.\n+\t(dwarf2out_do_cfi_startproc): Add SECOND argument.  Use LLSDAC\n+\tlabel instead of LLSDA if it is true.\n+\t(dwarf2out_begin_prologue, dwarf2out_switch_text_section): Adjust\n+\tcallers.\n+\t* except.c (add_call_site, dw2_size_of_call_site_table): Add\n+\tSECTION argument.  Use it as index into crtl->eh.call_site_record\n+\tarray.\n+\t(dw2_output_call_site_table): Likewise.  Add CS_FORMAT argument,\n+\tuse it to determine how to print table entries instead of using\n+\t#ifdef HAVE_AS_LEB128.  For SECTION > 0 use hot resp. cold\n+\tlabel instead of normal begin label as base.\n+\t(sjlj_assign_call_site_values): Adjust add_call_site caller.\n+\t(convert_to_eh_region_ranges): When doing hot/cold partitioning,\n+\tensure no EH range spans between sections and that landing pads\n+\tare always in the corresponding section.\n+\t(sjlj_size_of_call_site_table, sjlj_output_call_site_table): Adjust\n+\tfor crtl->eh.call_site_record being an array rather than scalar.\n+\t(output_one_function_exception_table): New function, copied\n+\tfrom output_function_exception_table.  Adjust\n+\tdw2_size_of_call_site_table, dw2_output_call_site_table\n+\tcallers.  For SECOND section use *C suffixed labels.\n+\t(output_function_exception_table): Call\n+\toutput_one_function_exception_table and, when doing hot/cold\n+\tpartitioning, also another time for the second section.\n+\t* opts.c: Include except.h.\n+\t(decode_options): Allow -freorder-blocks-and-partition with\n+\texceptions, unless SJLJ or TARGET_UNWIND_INFO.\n+\t* Makefile.in (opts.o): Depend on $(EXCEPT_H).\n+\t* function.h (struct rtl_eh): Change call_site_record from\n+\tscalar into array of 2 elements.\n+\n 2009-08-07  Martin Jambor  <mjambor@suse.cz>\n \n \t* ipa-prop.c (count_formal_params_1): New function."}, {"sha": "7951d29492f641bfbba5e2ebb1f24095a1a81ca0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -2595,7 +2595,7 @@ opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(EXPR_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n    $(FLAGS_H) $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H) debug.h varray.h \\\n-   $(PLUGIN_H)\n+   $(PLUGIN_H) $(EXCEPT_H)\n opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h intl.h\n targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\"}, {"sha": "af97bb0fee7dbca0ea896eb0fca40ba4151db03a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -3429,15 +3429,22 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n       begin = fde->dw_fde_begin;\n       end = fde->dw_fde_end;\n     }\n-  else if (second ^ fde->dw_fde_switched_cold_to_hot)\n-    {\n-      begin = fde->dw_fde_unlikely_section_label;\n-      end = fde->dw_fde_unlikely_section_end_label;\n-    }\n   else\n     {\n-      begin = fde->dw_fde_hot_section_label;\n-      end = fde->dw_fde_hot_section_end_label;\n+      /* For the first section, prefer dw_fde_begin over\n+\t dw_fde_{hot,cold}_section_label, as the latter\n+\t might be separated from the real start of the\n+\t function by alignment padding.  */\n+      if (!second)\n+\tbegin = fde->dw_fde_begin;\n+      else if (fde->dw_fde_switched_cold_to_hot)\n+\tbegin = fde->dw_fde_hot_section_label;\n+      else\n+\tbegin = fde->dw_fde_unlikely_section_label;\n+      if (second ^ fde->dw_fde_switched_cold_to_hot)\n+\tend = fde->dw_fde_unlikely_section_end_label;\n+      else\n+\tend = fde->dw_fde_hot_section_end_label;\n     }\n \n   if (for_eh)\n@@ -3477,7 +3484,8 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \n \t  if (fde->uses_eh_lsda)\n \t    {\n-\t      ASM_GENERATE_INTERNAL_LABEL (l1, \"LLSDA\", fde->funcdef_number);\n+\t      ASM_GENERATE_INTERNAL_LABEL (l1, second ? \"LLSDAC\" : \"LLSDA\",\n+\t\t\t\t\t   fde->funcdef_number);\n \t      dw2_asm_output_encoded_addr_rtx (lsda_encoding,\n \t\t\t\t\t       gen_rtx_SYMBOL_REF (Pmode, l1),\n \t\t\t\t\t       false,\n@@ -3781,7 +3789,7 @@ output_call_frame_info (int for_eh)\n /* Emit .cfi_startproc and .cfi_personality/.cfi_lsda if needed.  */\n \n static void\n-dwarf2out_do_cfi_startproc (void)\n+dwarf2out_do_cfi_startproc (bool second)\n {\n   int enc;\n   rtx ref;\n@@ -3810,7 +3818,7 @@ dwarf2out_do_cfi_startproc (void)\n       char lab[20];\n \n       enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n-      ASM_GENERATE_INTERNAL_LABEL (lab, \"LLSDA\",\n+      ASM_GENERATE_INTERNAL_LABEL (lab, second ? \"LLSDAC\" : \"LLSDA\",\n \t\t\t\t   current_function_funcdef_no);\n       ref = gen_rtx_SYMBOL_REF (Pmode, lab);\n       SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;\n@@ -3929,7 +3937,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n #endif\n \n   if (dwarf2out_do_cfi_asm ())\n-    dwarf2out_do_cfi_startproc ();\n+    dwarf2out_do_cfi_startproc (false);\n }\n \n /* Output a marker (i.e. a label) for the absolute end of the generated code\n@@ -4038,7 +4046,7 @@ dwarf2out_switch_text_section (void)\n \n   if (dwarf2out_do_cfi_asm ())\n     {\n-      dwarf2out_do_cfi_startproc ();\n+      dwarf2out_do_cfi_startproc (true);\n       /* As this is a different FDE, insert all current CFI instructions\n \t again.  */\n       output_cfis (fde->dw_fde_cfi, true, fde, true);"}, {"sha": "d72029cf94fa4483a2bb2300ed524e7770c76f6a", "filename": "gcc/except.c", "status": "modified", "additions": 240, "deletions": 60, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -169,15 +169,15 @@ static int action_record_eq (const void *, const void *);\n static hashval_t action_record_hash (const void *);\n static int add_action_record (htab_t, int, int);\n static int collect_one_action_chain (htab_t, struct eh_region_d *);\n-static int add_call_site (rtx, int);\n+static int add_call_site (rtx, int, int);\n \n static void push_uleb128 (varray_type *, unsigned int);\n static void push_sleb128 (varray_type *, int);\n #ifndef HAVE_AS_LEB128\n static int dw2_size_of_call_site_table (void);\n static int sjlj_size_of_call_site_table (void);\n #endif\n-static void dw2_output_call_site_table (void);\n+static void dw2_output_call_site_table (int, int);\n static void sjlj_output_call_site_table (void);\n \n \f\n@@ -2337,7 +2337,8 @@ sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n \t  index = -1;\n \t/* Otherwise, look it up in the table.  */\n \telse\n-\t  index = add_call_site (GEN_INT (lp_info[i].dispatch_index), action);\n+\t  index = add_call_site (GEN_INT (lp_info[i].dispatch_index),\n+\t\t\t\t action, 0);\n \n \tlp_info[i].call_site_index = index;\n       }\n@@ -3784,17 +3785,19 @@ collect_one_action_chain (htab_t ar_hash, struct eh_region_d *region)\n }\n \n static int\n-add_call_site (rtx landing_pad, int action)\n+add_call_site (rtx landing_pad, int action, int section)\n {\n   call_site_record record;\n   \n   record = GGC_NEW (struct call_site_record_d);\n   record->landing_pad = landing_pad;\n   record->action = action;\n \n-  VEC_safe_push (call_site_record, gc, crtl->eh.call_site_record, record);\n+  VEC_safe_push (call_site_record, gc,\n+\t\t crtl->eh.call_site_record[section], record);\n \n-  return call_site_base + VEC_length (call_site_record, crtl->eh.call_site_record) - 1;\n+  return call_site_base + VEC_length (call_site_record,\n+\t\t\t\t      crtl->eh.call_site_record[section]) - 1;\n }\n \n /* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.\n@@ -3811,6 +3814,14 @@ convert_to_eh_region_ranges (void)\n   rtx last_landing_pad = NULL_RTX;\n   rtx first_no_action_insn = NULL_RTX;\n   int call_site = 0;\n+  int cur_sec = 0;\n+  rtx section_switch_note = NULL_RTX;\n+  rtx first_no_action_insn_before_switch = NULL_RTX;\n+  rtx last_no_action_insn_before_switch = NULL_RTX;\n+  rtx *pad_map = NULL;\n+  sbitmap pad_loc = NULL;\n+  int min_labelno = 0, max_labelno = 0;\n+  int saved_call_site_base = call_site_base;\n \n   if (USING_SJLJ_EXCEPTIONS || cfun->eh->region_tree == NULL)\n     return 0;\n@@ -3885,9 +3896,27 @@ convert_to_eh_region_ranges (void)\n \t    if (last_action >= -1)\n \t      {\n \t\t/* If we delayed the creation of the begin, do it now.  */\n+\t\tif (first_no_action_insn_before_switch)\n+\t\t  {\n+\t\t    call_site = add_call_site (NULL_RTX, 0, 0);\n+\t\t    note\n+\t\t      = emit_note_before (NOTE_INSN_EH_REGION_BEG,\n+\t\t\t\t\t  first_no_action_insn_before_switch);\n+\t\t    NOTE_EH_HANDLER (note) = call_site;\n+\t\t    if (first_no_action_insn)\n+\t\t      {\n+\t\t\tnote\n+\t\t\t  = emit_note_after (NOTE_INSN_EH_REGION_END,\n+\t\t\t\t\t     last_no_action_insn_before_switch);\n+\t\t\tNOTE_EH_HANDLER (note) = call_site;\n+\t\t      }\n+\t\t    else\n+\t\t      gcc_assert (last_action_insn\n+\t\t\t\t  == last_no_action_insn_before_switch);\n+\t\t  }\n \t\tif (first_no_action_insn)\n \t\t  {\n-\t\t    call_site = add_call_site (NULL_RTX, 0);\n+\t\t    call_site = add_call_site (NULL_RTX, 0, cur_sec);\n \t\t    note = emit_note_before (NOTE_INSN_EH_REGION_BEG,\n \t\t\t\t\t     first_no_action_insn);\n \t\t    NOTE_EH_HANDLER (note) = call_site;\n@@ -3904,7 +3933,8 @@ convert_to_eh_region_ranges (void)\n \t    if (this_action >= -1)\n \t      {\n \t\tcall_site = add_call_site (this_landing_pad,\n-\t\t\t\t\t   this_action < 0 ? 0 : this_action);\n+\t\t\t\t\t   this_action < 0 ? 0 : this_action,\n+\t\t\t\t\t   cur_sec);\n \t\tnote = emit_note_before (NOTE_INSN_EH_REGION_BEG, iter);\n \t\tNOTE_EH_HANDLER (note) = call_site;\n \t      }\n@@ -3914,13 +3944,143 @@ convert_to_eh_region_ranges (void)\n \t  }\n \tlast_action_insn = iter;\n       }\n+    else if (NOTE_P (iter)\n+\t     && NOTE_KIND (iter) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+      {\n+\tgcc_assert (section_switch_note == NULL_RTX);\n+\tgcc_assert (flag_reorder_blocks_and_partition);\n+\tsection_switch_note = iter;\n+\tif (first_no_action_insn)\n+\t  {\n+\t    first_no_action_insn_before_switch = first_no_action_insn;\n+\t    last_no_action_insn_before_switch = last_action_insn;\n+\t    first_no_action_insn = NULL_RTX;\n+\t    gcc_assert (last_action == -1);\n+\t    last_action = -3;\n+\t  }\n+\t/* Force closing of current EH region before section switch and\n+\t   opening a new one afterwards.  */\n+\telse if (last_action != -3)\n+\t  last_landing_pad = pc_rtx;\n+\tcall_site_base += VEC_length (call_site_record,\n+\t\t\t\t      crtl->eh.call_site_record[cur_sec]);\n+\tcur_sec++;\n+\tgcc_assert (crtl->eh.call_site_record[cur_sec] == NULL);\n+\tcrtl->eh.call_site_record[cur_sec]\n+\t  = VEC_alloc (call_site_record, gc, 10);\n+\tmax_labelno = max_label_num ();\n+\tmin_labelno = get_first_label_num ();\n+\tpad_map = XCNEWVEC (rtx, max_labelno - min_labelno + 1);\n+\tpad_loc = sbitmap_alloc (max_labelno - min_labelno + 1);\n+      }\n+    else if (LABEL_P (iter) && pad_map)\n+      SET_BIT (pad_loc, CODE_LABEL_NUMBER (iter) - min_labelno);\n \n   if (last_action >= -1 && ! first_no_action_insn)\n     {\n       note = emit_note_after (NOTE_INSN_EH_REGION_END, last_action_insn);\n       NOTE_EH_HANDLER (note) = call_site;\n     }\n \n+  call_site_base = saved_call_site_base;\n+\n+  if (pad_map)\n+    {\n+      /* When doing hot/cold partitioning, ensure landing pads are\n+\t always in the same section as the EH region, .gcc_except_table\n+\t can't express it otherwise.  */\n+      for (cur_sec = 0; cur_sec < 2; cur_sec++)\n+\t{\n+\t  int i, idx;\n+\t  int n = VEC_length (call_site_record,\n+\t\t\t      crtl->eh.call_site_record[cur_sec]);\n+\t  basic_block prev_bb = NULL, padbb;\n+\n+\t  for (i = 0; i < n; ++i)\n+\t    {\n+\t      struct call_site_record_d *cs =\n+\t\tVEC_index (call_site_record,\n+\t\t\t   crtl->eh.call_site_record[cur_sec], i);\n+\t      rtx jump, note;\n+\n+\t      if (cs->landing_pad == NULL_RTX)\n+\t\tcontinue;\n+\t      idx = CODE_LABEL_NUMBER (cs->landing_pad) - min_labelno;\n+\t      /* If the landing pad is in the correct section, nothing\n+\t\t is needed.  */\n+\t      if (TEST_BIT (pad_loc, idx) ^ (cur_sec == 0))\n+\t\tcontinue;\n+\t      /* Otherwise, if we haven't seen this pad yet, we need to\n+\t\t add a new label and jump to the correct section.  */\n+\t      if (pad_map[idx] == NULL_RTX)\n+\t\t{\n+\t\t  pad_map[idx] = gen_label_rtx ();\n+\t\t  if (prev_bb == NULL)\n+\t\t    for (iter = section_switch_note;\n+\t\t\t iter; iter = PREV_INSN (iter))\n+\t\t      if (NOTE_INSN_BASIC_BLOCK_P (iter))\n+\t\t\t{\n+\t\t\t  prev_bb = NOTE_BASIC_BLOCK (iter);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t  if (cur_sec == 0)\n+\t\t    {\n+\t\t      note = emit_label_before (pad_map[idx],\n+\t\t\t\t\t\tsection_switch_note);\n+\t\t      jump = emit_jump_insn_before (gen_jump (cs->landing_pad),\n+\t\t\t\t\t\t    section_switch_note);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      jump = emit_jump_insn_after (gen_jump (cs->landing_pad),\n+\t\t\t\t\t\t   section_switch_note);\n+\t\t      note = emit_label_after (pad_map[idx],\n+\t\t\t\t\t       section_switch_note);\n+\t\t    }\n+\t\t  JUMP_LABEL (jump) = cs->landing_pad;\n+\t\t  add_reg_note (jump, REG_CROSSING_JUMP, NULL_RTX);\n+\t\t  iter = NEXT_INSN (cs->landing_pad);\n+\t\t  if (iter && NOTE_INSN_BASIC_BLOCK_P (iter))\n+\t\t    padbb = NOTE_BASIC_BLOCK (iter);\n+\t\t  else\n+\t\t    padbb = NULL;\n+\t\t  if (padbb && prev_bb\n+\t\t      && BB_PARTITION (padbb) != BB_UNPARTITIONED)\n+\t\t    {\n+\t\t      basic_block bb;\n+\t\t      int part\n+\t\t\t= BB_PARTITION (padbb) == BB_COLD_PARTITION\n+\t\t\t  ? BB_HOT_PARTITION : BB_COLD_PARTITION;\n+\t\t      edge_iterator ei;\n+\t\t      edge e;\n+\n+\t\t      bb = create_basic_block (note, jump, prev_bb);\n+\t\t      make_single_succ_edge (bb, padbb, EDGE_CROSSING);\n+\t\t      BB_SET_PARTITION (bb, part);\n+\t\t      for (ei = ei_start (padbb->preds);\n+\t\t\t   (e = ei_safe_edge (ei)); )\n+\t\t\t{\n+\t\t\t  if ((e->flags & (EDGE_EH|EDGE_CROSSING))\n+\t\t\t      == (EDGE_EH|EDGE_CROSSING))\n+\t\t\t    {\n+\t\t\t      redirect_edge_succ (e, bb);\n+\t\t\t      e->flags &= ~EDGE_CROSSING;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    ei_next (&ei);\n+\t\t\t}\n+\t\t      if (cur_sec == 0)\n+\t\t\tprev_bb = bb;\n+\t\t    }\n+\t\t}\n+\t      cs->landing_pad = pad_map[idx];\n+\t    }\n+\t}\n+\n+      sbitmap_free (pad_loc);\n+      XDELETEVEC (pad_map);\n+    }\n+\n   htab_delete (ar_hash);\n   return 0;\n }\n@@ -3981,16 +4141,16 @@ push_sleb128 (varray_type *data_area, int value)\n \f\n #ifndef HAVE_AS_LEB128\n static int\n-dw2_size_of_call_site_table (void)\n+dw2_size_of_call_site_table (int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record[section]);\n   int size = n * (4 + 4 + 4);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record[section], i);\n       size += size_of_uleb128 (cs->action);\n     }\n \n@@ -4000,14 +4160,14 @@ dw2_size_of_call_site_table (void)\n static int\n sjlj_size_of_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record[0]);\n   int size = 0;\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record[0], i);\n       size += size_of_uleb128 (INTVAL (cs->landing_pad));\n       size += size_of_uleb128 (cs->action);\n     }\n@@ -4017,15 +4177,23 @@ sjlj_size_of_call_site_table (void)\n #endif\n \n static void\n-dw2_output_call_site_table (void)\n+dw2_output_call_site_table (int cs_format, int section)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record[section]);\n   int i;\n+  const char *begin;\n+\n+  if (section == 0)\n+    begin = current_function_func_begin_label;\n+  else if (first_function_block_is_cold)\n+    begin = crtl->subsections.hot_section_label;\n+  else\n+    begin = crtl->subsections.cold_section_label;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record[section], i);\n       char reg_start_lab[32];\n       char reg_end_lab[32];\n       char landing_pad_lab[32];\n@@ -4041,30 +4209,29 @@ dw2_output_call_site_table (void)\n \t generic arithmetic.  */\n       /* ??? Perhaps use attr_length to choose data1 or data2 instead of\n \t data4 if the function is small enough.  */\n-#ifdef HAVE_AS_LEB128\n-      dw2_asm_output_delta_uleb128 (reg_start_lab,\n-\t\t\t\t    current_function_func_begin_label,\n-\t\t\t\t    \"region %d start\", i);\n-      dw2_asm_output_delta_uleb128 (reg_end_lab, reg_start_lab,\n-\t\t\t\t    \"length\");\n-      if (cs->landing_pad)\n-\tdw2_asm_output_delta_uleb128 (landing_pad_lab,\n-\t\t\t\t      current_function_func_begin_label,\n-\t\t\t\t      \"landing pad\");\n-      else\n-\tdw2_asm_output_data_uleb128 (0, \"landing pad\");\n-#else\n-      dw2_asm_output_delta (4, reg_start_lab,\n-\t\t\t    current_function_func_begin_label,\n-\t\t\t    \"region %d start\", i);\n-      dw2_asm_output_delta (4, reg_end_lab, reg_start_lab, \"length\");\n-      if (cs->landing_pad)\n-\tdw2_asm_output_delta (4, landing_pad_lab,\n-\t\t\t      current_function_func_begin_label,\n-\t\t\t      \"landing pad\");\n+      if (cs_format == DW_EH_PE_uleb128)\n+\t{\n+\t  dw2_asm_output_delta_uleb128 (reg_start_lab, begin,\n+\t\t\t\t\t\"region %d start\", i);\n+\t  dw2_asm_output_delta_uleb128 (reg_end_lab, reg_start_lab,\n+\t\t\t\t\t\"length\");\n+\t  if (cs->landing_pad)\n+\t    dw2_asm_output_delta_uleb128 (landing_pad_lab, begin,\n+\t\t\t\t\t  \"landing pad\");\n+\t  else\n+\t    dw2_asm_output_data_uleb128 (0, \"landing pad\");\n+\t}\n       else\n-\tdw2_asm_output_data (4, 0, \"landing pad\");\n-#endif\n+\t{\n+\t  dw2_asm_output_delta (4, reg_start_lab, begin,\n+\t\t\t\t\"region %d start\", i);\n+\t  dw2_asm_output_delta (4, reg_end_lab, reg_start_lab, \"length\");\n+\t  if (cs->landing_pad)\n+\t    dw2_asm_output_delta (4, landing_pad_lab, begin,\n+\t\t\t\t  \"landing pad\");\n+\t  else\n+\t    dw2_asm_output_data (4, 0, \"landing pad\");\n+\t}\n       dw2_asm_output_data_uleb128 (cs->action, \"action\");\n     }\n \n@@ -4074,13 +4241,13 @@ dw2_output_call_site_table (void)\n static void\n sjlj_output_call_site_table (void)\n {\n-  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record[0]);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n       struct call_site_record_d *cs =\n-\tVEC_index (call_site_record, crtl->eh.call_site_record, i);\n+\tVEC_index (call_site_record, crtl->eh.call_site_record[0], i);\n \n       dw2_asm_output_data_uleb128 (INTVAL (cs->landing_pad),\n \t\t\t\t   \"region %d landing pad\", i);\n@@ -4192,8 +4359,9 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     dw2_asm_output_encoded_addr_rtx (tt_format, value, is_public, NULL);\n }\n \n-void\n-output_function_exception_table (const char * ARG_UNUSED (fnname))\n+static void\n+output_one_function_exception_table (const char * ARG_UNUSED (fnname),\n+\t\t\t\t     int section)\n {\n   int tt_format, cs_format, lp_format, i, n;\n #ifdef HAVE_AS_LEB128\n@@ -4206,13 +4374,6 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n   int have_tt_data;\n   int tt_format_size = 0;\n \n-  /* Not all functions need anything.  */\n-  if (! crtl->uses_eh_lsda)\n-    return;\n-\n-  if (eh_personality_libfunc)\n-    assemble_external_libcall (eh_personality_libfunc);\n-\n #ifdef TARGET_UNWIND_INFO\n   /* TODO: Move this into target file.  */\n   fputs (\"\\t.personality\\t\", asm_out_file);\n@@ -4237,16 +4398,17 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n     {\n       tt_format = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/1);\n #ifdef HAVE_AS_LEB128\n-      ASM_GENERATE_INTERNAL_LABEL (ttype_label, \"LLSDATT\",\n+      ASM_GENERATE_INTERNAL_LABEL (ttype_label,\n+\t\t\t\t   section ? \"LLSDATTC\" : \"LLSDATT\",\n \t\t\t\t   current_function_funcdef_no);\n #endif\n       tt_format_size = size_of_encoded_value (tt_format);\n \n       assemble_align (tt_format_size * BITS_PER_UNIT);\n     }\n \n-  targetm.asm_out.internal_label (asm_out_file, \"LLSDA\",\n-\t\t\t     current_function_funcdef_no);\n+  targetm.asm_out.internal_label (asm_out_file, section ? \"LLSDAC\" : \"LLSDA\",\n+\t\t\t\t  current_function_funcdef_no);\n \n   /* The LSDA header.  */\n \n@@ -4269,15 +4431,16 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n   if (USING_SJLJ_EXCEPTIONS)\n     call_site_len = sjlj_size_of_call_site_table ();\n   else\n-    call_site_len = dw2_size_of_call_site_table ();\n+    call_site_len = dw2_size_of_call_site_table (section);\n #endif\n \n   /* A pc-relative 4-byte displacement to the @TType data.  */\n   if (have_tt_data)\n     {\n #ifdef HAVE_AS_LEB128\n       char ttype_after_disp_label[32];\n-      ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label, \"LLSDATTD\",\n+      ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label,\n+\t\t\t\t   section ? \"LLSDATTDC\" : \"LLSDATTD\",\n \t\t\t\t   current_function_funcdef_no);\n       dw2_asm_output_delta_uleb128 (ttype_label, ttype_after_disp_label,\n \t\t\t\t    \"@TType base offset\");\n@@ -4323,24 +4486,26 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n \t\t       eh_data_format_name (cs_format));\n \n #ifdef HAVE_AS_LEB128\n-  ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label, \"LLSDACSB\",\n+  ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label,\n+\t\t\t       section ? \"LLSDACSBC\" : \"LLSDACSB\",\n \t\t\t       current_function_funcdef_no);\n-  ASM_GENERATE_INTERNAL_LABEL (cs_end_label, \"LLSDACSE\",\n+  ASM_GENERATE_INTERNAL_LABEL (cs_end_label,\n+\t\t\t       section ? \"LLSDACSEC\" : \"LLSDACSE\",\n \t\t\t       current_function_funcdef_no);\n   dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,\n \t\t\t\t\"Call-site table length\");\n   ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);\n   if (USING_SJLJ_EXCEPTIONS)\n     sjlj_output_call_site_table ();\n   else\n-    dw2_output_call_site_table ();\n+    dw2_output_call_site_table (cs_format, section);\n   ASM_OUTPUT_LABEL (asm_out_file, cs_end_label);\n #else\n-  dw2_asm_output_data_uleb128 (call_site_len,\"Call-site table length\");\n+  dw2_asm_output_data_uleb128 (call_site_len, \"Call-site table length\");\n   if (USING_SJLJ_EXCEPTIONS)\n     sjlj_output_call_site_table ();\n   else\n-    dw2_output_call_site_table ();\n+    dw2_output_call_site_table (cs_format, section);\n #endif\n \n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n@@ -4377,6 +4542,21 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n \tdw2_asm_output_data (1, VARRAY_UCHAR (crtl->eh.ehspec_data, i),\n \t\t\t     (i ? NULL : \"Exception specification table\"));\n     }\n+}\n+\n+void\n+output_function_exception_table (const char * ARG_UNUSED (fnname))\n+{\n+  /* Not all functions need anything.  */\n+  if (! crtl->uses_eh_lsda)\n+    return;\n+\n+  if (eh_personality_libfunc)\n+    assemble_external_libcall (eh_personality_libfunc);\n+\n+  output_one_function_exception_table (fnname, 0);\n+  if (crtl->eh.call_site_record[1] != NULL)\n+    output_one_function_exception_table (fnname, 1);\n \n   switch_to_section (current_function_section ());\n }"}, {"sha": "ac3a17495491962748c9854048020c688eb50d2f", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -156,7 +156,7 @@ struct GTY(()) rtl_eh {\n   varray_type ehspec_data;\n   varray_type action_record_data;\n \n-  VEC(call_site_record,gc) *call_site_record;\n+  VEC(call_site_record,gc) *call_site_record[2];\n };\n \n #define pending_stack_adjust (crtl->expr.x_pending_stack_adjust)"}, {"sha": "59c24b67db130a9aea15e73ae0f38230b018973e", "filename": "gcc/opts.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"debug.h\"\n #include \"plugin.h\"\n+#include \"except.h\"\n \n /* Value of the -G xx switch, and whether it was passed or not.  */\n unsigned HOST_WIDE_INT g_switch_value;\n@@ -1036,10 +1037,15 @@ decode_options (unsigned int argc, const char **argv)\n      generating unwind info.  If flag_exceptions is turned on we need to\n      turn off the partitioning optimization.  */\n \n-  if (flag_exceptions && flag_reorder_blocks_and_partition)\n+  if (flag_exceptions && flag_reorder_blocks_and_partition\n+      && (USING_SJLJ_EXCEPTIONS\n+#ifdef TARGET_UNWIND_INFO\n+\t  || 1\n+#endif\n+\t ))\n     {\n       inform (input_location, \n-\t      \"-freorder-blocks-and-partition does not work with exceptions\");\n+\t      \"-freorder-blocks-and-partition does not work with exceptions on this architecture\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n@@ -1048,9 +1054,15 @@ decode_options (unsigned int argc, const char **argv)\n      optimization.  */\n \n   if (flag_unwind_tables && ! targetm.unwind_tables_default\n-      && flag_reorder_blocks_and_partition)\n+      && flag_reorder_blocks_and_partition\n+      && (USING_SJLJ_EXCEPTIONS\n+#ifdef TARGET_UNWIND_INFO\n+\t  || 1\n+#endif\n+\t ))\n     {\n-      inform (input_location, \"-freorder-blocks-and-partition does not support unwind info\");\n+      inform (input_location,\n+\t      \"-freorder-blocks-and-partition does not support unwind info on this architecture\");\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n@@ -1061,7 +1073,12 @@ decode_options (unsigned int argc, const char **argv)\n \n   if (flag_reorder_blocks_and_partition\n       && (!targetm.have_named_sections\n-\t  || (flag_unwind_tables && targetm.unwind_tables_default)))\n+\t  || (flag_unwind_tables && targetm.unwind_tables_default\n+\t      && (USING_SJLJ_EXCEPTIONS\n+#ifdef TARGET_UNWIND_INFO\n+\t\t  || 1\n+#endif\n+\t\t ))))\n     {\n       inform (input_location,\n \t      \"-freorder-blocks-and-partition does not work on this architecture\");"}, {"sha": "4d3f9b0077a0dbec1f6514241154e343be973071", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -1,3 +1,7 @@\n+2009-08-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/tree-prof/partition1.C: New test.\n+\n 2009-08-06  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* gcc.target/arm/abitest.h: Allow the test function to have a PCS"}, {"sha": "d0dcbc4524b9e4c46c241b9a900f313f4fa3bfc6", "filename": "gcc/testsuite/g++.dg/tree-prof/partition1.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f6e37dc188165f634dbb606ecb23892bf2e125/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fpartition1.C?ref=17f6e37dc188165f634dbb606ecb23892bf2e125", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition\" } */\n+\n+struct A { A () __attribute__((noinline)); ~A () __attribute__((noinline)); };\n+A::A () { asm volatile (\"\" : : : \"memory\"); }\n+A::~A () { asm volatile (\"\" : : : \"memory\"); }\n+\n+int bar () __attribute__((noinline));\n+void foo () __attribute__((noinline));\n+\n+volatile int k, l;\n+\n+int bar (int i)\n+{\n+  void *p = __builtin_alloca (i);\n+  asm volatile (\"\" : : \"r\" (i), \"r\" (p) : \"memory\");\n+  if (k) throw 6;\n+  return ++l;\n+}\n+\n+void foo ()\n+{\n+  A a;\n+  try {\n+    A b;\n+    int i = bar (5);\n+    try { throw 6; } catch (int) {}\n+    if (__builtin_expect (i < 4500, 0)) {\n+      bar (7);\n+      try { bar (8); } catch (long) {}\n+      bar (10);\n+      if (__builtin_expect (i < 0, 0)) {\n+\ttry { bar (12); } catch (...) {}\n+\tbar (16);\n+\tbar (122);\n+      } else {\n+\ttry { bar (bar (7)); } catch (int) {}\n+      }\n+    } else {\n+      try { bar (bar (bar (9))); } catch (...) {}\n+      bar (5);\n+    }\n+  } catch (...) {\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 10000; i++)\n+    foo ();\n+}"}]}