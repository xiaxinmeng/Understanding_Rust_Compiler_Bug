{"sha": "85b94003e1c2cd725f08c9765733d1e8827e213a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODViOTQwMDNlMWMyY2Q3MjVmMDhjOTc2NTczM2QxZTg4MjdlMjEzYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-05-19T21:16:51Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-19T21:16:51Z"}, "message": "jump.c (jump_optimize_1): Tidy.\n\n\t* jump.c (jump_optimize_1): Tidy.\n\t(mark_jump_label): When changing the label in a LABEL_REF, change\n\tupdate any REG_EQUAL notes as well.\n\nFrom-SVN: r42318", "tree": {"sha": "1d5170578c33c4c738aeb9f23af417efbc24492a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5170578c33c4c738aeb9f23af417efbc24492a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85b94003e1c2cd725f08c9765733d1e8827e213a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b94003e1c2cd725f08c9765733d1e8827e213a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b94003e1c2cd725f08c9765733d1e8827e213a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b94003e1c2cd725f08c9765733d1e8827e213a/comments", "author": null, "committer": null, "parents": [{"sha": "572051a27500971560b2898dc25a145582c28de0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/572051a27500971560b2898dc25a145582c28de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/572051a27500971560b2898dc25a145582c28de0"}], "stats": {"total": 1371, "additions": 1362, "deletions": 9}, "files": [{"sha": "3e2e2abaadac53811542b7afd6c7cb8294f56ee1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85b94003e1c2cd725f08c9765733d1e8827e213a", "patch": "@@ -1,3 +1,9 @@\n+2001-05-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* jump.c (jump_optimize_1): Tidy.\n+\t(mark_jump_label): When changing the label in a LABEL_REF, change\n+\tupdate any REG_EQUAL notes as well.\n+\n 2001-05-19  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-parse.in (parm_declarator): Split into"}, {"sha": "d171cbae39ddd70bf67d811a3933586a361d76b6", "filename": "gcc/jump.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=85b94003e1c2cd725f08c9765733d1e8827e213a", "patch": "@@ -236,14 +236,13 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n     if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n       LABEL_NUSES (XEXP (insn, 0))++;\n \n-  if (! mark_labels_only)\n-    delete_barrier_successors (f);\n-\n   /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL\n      notes and recompute LABEL_NUSES.  */\n   if (mark_labels_only)\n     goto end;\n \n+  delete_barrier_successors (f);\n+\n   last_insn = delete_unreferenced_labels (f);\n \n   if (noop_moves)\n@@ -2498,7 +2497,6 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n       {\n \trtx label = XEXP (x, 0);\n \trtx olabel = label;\n-\trtx note;\n \trtx next;\n \n \t/* Ignore remaining references to unreachable labels that\n@@ -2545,11 +2543,34 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t    if (GET_CODE (insn) == JUMP_INSN)\n \t      JUMP_LABEL (insn) = label;\n \n-\t    /* If we've changed OLABEL and we had a REG_LABEL note\n-\t       for it, update it as well.  */\n-\t    else if (label != olabel\n-\t\t     && (note = find_reg_note (insn, REG_LABEL, olabel)) != 0)\n-\t      XEXP (note, 0) = label;\n+\t    /* If we've changed the label, update notes accordingly.  */\n+\t    else if (label != olabel)\n+\t      {\n+\t\trtx note;\n+\n+\t\t/* We may have a REG_LABEL note to indicate that this\n+\t\t   instruction uses the label.  */\n+\t\tnote = find_reg_note (insn, REG_LABEL, olabel);\n+\t\tif (note)\n+\t\t  XEXP (note, 0) = label;\n+\n+\t\t/* We may also have a REG_EQUAL note to indicate that\n+\t\t   a register is being set to the address of the\n+\t\t   label.  We cannot use find_reg_note as above\n+\t\t   because the REG_EQUAL note will use a LABEL_REF,\n+\t\t   not the actual CODE_LABEL.  */\n+\t\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t\t  if (REG_NOTE_KIND (note) == REG_EQUAL)\n+\t\t    {\n+\t\t      if (GET_CODE (XEXP (note, 0)) == LABEL_REF\n+\t\t\t  && XEXP (XEXP (note, 0), 0) == olabel)\n+\t\t\tXEXP (XEXP (note, 0), 0) = label;\n+\t\t      /* There is only one REG_EQUAL note per\n+\t\t\t instruction, so we are done at this \n+\t\t\t point.  */\n+\t\t      break;\n+\t\t    }\n+\t      }\n \n \t    /* Otherwise, add a REG_LABEL note for LABEL unless there already\n \t       is one.  */"}, {"sha": "5690580f7517497302c0291ee1e076c944adf4a2", "filename": "gcc/testsuite/g77.f-torture/compile/20010519-1.f", "status": "added", "additions": 1326, "deletions": 0, "changes": 1326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20010519-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85b94003e1c2cd725f08c9765733d1e8827e213a/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20010519-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20010519-1.f?ref=85b94003e1c2cd725f08c9765733d1e8827e213a", "patch": "@@ -0,0 +1,1326 @@\n+CHARMM Element source/dimb/nmdimb.src 1.1\n+C.##IF DIMB\n+      SUBROUTINE NMDIMB(X,Y,Z,NAT3,BNBND,BIMAG,LNOMA,AMASS,DDS,DDSCR,\n+     1                 PARDDV,DDV,DDM,PARDDF,DDF,PARDDE,DDEV,DD1BLK,\n+     2                 DD1BLL,NADD,LRAISE,DD1CMP,INBCMP,JNBCMP,\n+     3                 NPAR,ATMPAR,ATMPAS,BLATOM,PARDIM,NFREG,NFRET,\n+     4                 PARFRQ,CUTF1,ITMX,TOLDIM,IUNMOD,IUNRMD,\n+     5                 LBIG,LSCI,ATMPAD,SAVF,NBOND,IB,JB,DDVALM)\n+C-----------------------------------------------------------------------\n+C     01-Jul-1992 David Perahia, Liliane Mouawad\n+C     15-Dec-1994 Herman van Vlijmen\n+C\n+C     This is the main routine for the mixed-basis diagonalization.\n+C     See: L.Mouawad and D.Perahia, Biopolymers (1993), 33, 599,\n+C     and: D.Perahia and L.Mouawad, Comput. Chem. (1995), 19, 241.\n+C     The method iteratively solves the diagonalization of the\n+C     Hessian matrix. To save memory space, it uses a compressed\n+C     form of the Hessian, which only contains the non-zero elements.\n+C     In the diagonalization process, approximate eigenvectors are\n+C     mixed with Cartesian coordinates to form a reduced basis. The\n+C     Hessian is then diagonalized in the reduced basis. By iterating\n+C     over different sets of Cartesian coordinates the method ultimately\n+C     converges to the exact eigenvalues and eigenvectors (up to the\n+C     requested accuracy).\n+C     If no existing basis set is read, an initial basis will be created\n+C     which consists of the low-frequency eigenvectors of diagonal blocks\n+C     of the Hessian.\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/impnon.fcm'\n+C..##IF VAX CONVEX IRIS HPUX IRIS GNU CSPP OS2 GWS CRAY ALPHA\n+      IMPLICIT NONE\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/stream.fcm'\n+      LOGICAL LOWER,QLONGL\n+      INTEGER MXSTRM,POUTU\n+      PARAMETER (MXSTRM=20,POUTU=6)\n+      INTEGER   NSTRM,ISTRM,JSTRM,OUTU,PRNLEV,WRNLEV,IOLEV\n+      COMMON /CASE/   LOWER, QLONGL\n+      COMMON /STREAM/ NSTRM,ISTRM,JSTRM(MXSTRM),OUTU,PRNLEV,WRNLEV,IOLEV\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/dimens.fcm'\n+      INTEGER LARGE,MEDIUM,SMALL,REDUCE\n+C..##IF QUANTA\n+C..##ELIF T3D\n+C..##ELSE\n+      PARAMETER (LARGE=60120, MEDIUM=25140, SMALL=6120)\n+C..##ENDIF\n+      PARAMETER (REDUCE=15000)\n+      INTEGER SIZE\n+C..##IF XLARGE\n+C..##ELIF XXLARGE\n+C..##ELIF LARGE\n+C..##ELIF MEDIUM\n+      PARAMETER (SIZE=MEDIUM)\n+C..##ELIF REDUCE\n+C..##ELIF SMALL\n+C..##ELIF XSMALL\n+C..##ENDIF\n+C..##IF MMFF\n+      integer MAXDEFI\n+      parameter(MAXDEFI=250)\n+      INTEGER NAME0,NAMEQ0,NRES0,KRES0\n+      PARAMETER (NAME0=4,NAMEQ0=10,NRES0=4,KRES0=4)\n+      integer MaxAtN\n+      parameter (MaxAtN=55)\n+      INTEGER MAXAUX\n+      PARAMETER (MAXAUX = 10)\n+C..##ENDIF\n+      INTEGER MAXCSP, MAXHSET\n+C..##IF HMCM\n+      PARAMETER (MAXHSET = 200)\n+C..##ELSE\n+C..##ENDIF\n+C..##IF REDUCE\n+C..##ELSE\n+      PARAMETER (MAXCSP = 500)\n+C..##ENDIF\n+C..##IF HMCM\n+      INTEGER MAXHCM,MAXPCM,MAXRCM\n+C...##IF REDUCE\n+C...##ELSE\n+      PARAMETER (MAXHCM=500)\n+      PARAMETER (MAXPCM=5000)\n+      PARAMETER (MAXRCM=2000)\n+C...##ENDIF\n+C..##ENDIF\n+      INTEGER MXCMSZ\n+C..##IF IBM IBMRS CRAY INTEL IBMSP T3D REDUCE\n+C..##ELSE\n+      PARAMETER (MXCMSZ = 5000)\n+C..##ENDIF\n+      INTEGER CHRSIZ\n+      PARAMETER (CHRSIZ = SIZE)\n+      INTEGER MAXATB\n+C..##IF REDUCE\n+C..##ELIF QUANTA\n+C..##ELSE\n+      PARAMETER (MAXATB = 200)\n+C..##ENDIF\n+      INTEGER MAXVEC\n+C..##IFN VECTOR PARVECT\n+      PARAMETER (MAXVEC = 10)\n+C..##ELIF LARGE XLARGE XXLARGE\n+C..##ELIF MEDIUM\n+C..##ELIF SMALL REDUCE\n+C..##ELIF XSMALL\n+C..##ELSE\n+C..##ENDIF\n+      INTEGER IATBMX\n+      PARAMETER (IATBMX = 8)\n+      INTEGER MAXHB\n+C..##IF LARGE XLARGE XXLARGE\n+C..##ELIF MEDIUM\n+      PARAMETER (MAXHB = 8000)\n+C..##ELIF SMALL\n+C..##ELIF REDUCE XSMALL\n+C..##ELSE\n+C..##ENDIF\n+      INTEGER MAXTRN,MAXSYM\n+C..##IFN NOIMAGES\n+      PARAMETER (MAXTRN = 5000)\n+      PARAMETER (MAXSYM = 192)\n+C..##ELSE\n+C..##ENDIF\n+C..##IF LONEPAIR (lonepair_max)\n+      INTEGER MAXLP,MAXLPH\n+C...##IF REDUCE\n+C...##ELSE\n+      PARAMETER (MAXLP  = 2000)\n+      PARAMETER (MAXLPH = 4000)\n+C...##ENDIF\n+C..##ENDIF (lonepair_max)\n+      INTEGER NOEMAX,NOEMX2\n+C..##IF REDUCE\n+C..##ELSE\n+      PARAMETER (NOEMAX = 2000)\n+      PARAMETER (NOEMX2 = 4000)\n+C..##ENDIF\n+      INTEGER MAXATC, MAXCB, MAXCH, MAXCI, MAXCP, MAXCT, MAXITC, MAXNBF\n+C..##IF REDUCE\n+C..##ELIF MMFF CFF\n+      PARAMETER (MAXATC = 500, MAXCB = 1500, MAXCH = 3200, MAXCI = 600,\n+     &           MAXCP  = 3000,MAXCT = 15500,MAXITC = 200, MAXNBF=1000)\n+C..##ELIF YAMMP\n+C..##ELIF LARGE\n+C..##ELSE\n+C..##ENDIF\n+      INTEGER MAXCN\n+      PARAMETER (MAXCN = MAXITC*(MAXITC+1)/2)\n+      INTEGER MAXA, MAXAIM, MAXB, MAXT, MAXP\n+      INTEGER MAXIMP, MAXNB, MAXPAD, MAXRES\n+      INTEGER MAXSEG, MAXGRP\n+C..##IF LARGE XLARGE XXLARGE\n+C..##ELIF MEDIUM\n+      PARAMETER (MAXA = SIZE, MAXB = SIZE, MAXT = SIZE,\n+     &           MAXP = 2*SIZE)\n+      PARAMETER (MAXIMP = 9200, MAXNB = 17200, MAXPAD = 8160,\n+     &           MAXRES = 14000)\n+C...##IF MCSS\n+C...##ELSE\n+      PARAMETER (MAXSEG = 1000)\n+C...##ENDIF\n+C..##ELIF SMALL\n+C..##ELIF XSMALL\n+C..##ELIF REDUCE\n+C..##ELSE\n+C..##ENDIF\n+C..##IF NOIMAGES\n+C..##ELSE\n+      PARAMETER (MAXAIM = 2*SIZE)\n+      PARAMETER (MAXGRP = 2*SIZE/3)\n+C..##ENDIF\n+      INTEGER REDMAX,REDMX2\n+C..##IF REDUCE\n+C..##ELSE\n+      PARAMETER (REDMAX = 20)\n+      PARAMETER (REDMX2 = 80)\n+C..##ENDIF\n+      INTEGER MXRTRS, MXRTA, MXRTB, MXRTT, MXRTP, MXRTI, MXRTX,\n+     &        MXRTHA, MXRTHD, MXRTBL, NICM\n+      PARAMETER (MXRTRS = 200, MXRTA = 5000, MXRTB = 5000,\n+     &           MXRTT = 5000, MXRTP = 5000, MXRTI = 2000,\n+C..##IF YAMMP\n+C..##ELSE\n+     &           MXRTX = 5000, MXRTHA = 300, MXRTHD = 300,\n+C..##ENDIF\n+     &           MXRTBL = 5000, NICM = 10)\n+      INTEGER NMFTAB,  NMCTAB,  NMCATM,  NSPLIN\n+C..##IF REDUCE\n+C..##ELSE\n+      PARAMETER (NMFTAB = 200, NMCTAB = 3, NMCATM = 12000, NSPLIN = 3)\n+C..##ENDIF\n+      INTEGER MAXSHK\n+C..##IF XSMALL\n+C..##ELIF REDUCE\n+C..##ELSE\n+      PARAMETER (MAXSHK = SIZE*3/4)\n+C..##ENDIF\n+      INTEGER SCRMAX\n+C..##IF IBM IBMRS CRAY INTEL IBMSP T3D REDUCE\n+C..##ELSE\n+      PARAMETER (SCRMAX = 5000)\n+C..##ENDIF\n+C..##IF TSM\n+      INTEGER MXPIGG\n+C...##IF REDUCE\n+C...##ELSE\n+      PARAMETER (MXPIGG=500)\n+C...##ENDIF\n+      INTEGER MXCOLO,MXPUMB\n+      PARAMETER (MXCOLO=20,MXPUMB=20)\n+C..##ENDIF\n+C..##IF ADUMB\n+      INTEGER MAXUMP, MAXEPA, MAXNUM\n+C...##IF REDUCE\n+C...##ELSE\n+      PARAMETER (MAXUMP = 10, MAXNUM = 4)\n+C...##ENDIF\n+C..##ENDIF\n+      INTEGER MAXING\n+      PARAMETER (MAXING=1000)\n+C..##IF MMFF\n+      integer MAX_RINGSIZE, MAX_EACH_SIZE\n+      parameter (MAX_RINGSIZE = 20, MAX_EACH_SIZE = 1000)\n+      integer MAXPATHS\n+      parameter (MAXPATHS = 8000)\n+      integer MAX_TO_SEARCH\n+      parameter (MAX_TO_SEARCH = 6)\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/number.fcm'\n+      REAL*8     ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX,\n+     &           SEVEN, EIGHT, NINE, TEN, ELEVEN, TWELVE, THIRTN,\n+     &           FIFTN, NINETN, TWENTY, THIRTY\n+C..##IF SINGLE\n+C..##ELSE\n+      PARAMETER (ZERO   =  0.D0, ONE    =  1.D0, TWO    =  2.D0,\n+     &           THREE  =  3.D0, FOUR   =  4.D0, FIVE   =  5.D0,\n+     &           SIX    =  6.D0, SEVEN  =  7.D0, EIGHT  =  8.D0,\n+     &           NINE   =  9.D0, TEN    = 10.D0, ELEVEN = 11.D0,\n+     &           TWELVE = 12.D0, THIRTN = 13.D0, FIFTN  = 15.D0,\n+     &           NINETN = 19.D0, TWENTY = 20.D0, THIRTY = 30.D0)\n+C..##ENDIF\n+      REAL*8     FIFTY, SIXTY, SVNTY2, EIGHTY, NINETY, HUNDRD,\n+     &           ONE2TY, ONE8TY, THRHUN, THR6TY, NINE99, FIFHUN, THOSND,\n+     &           FTHSND,MEGA\n+C..##IF SINGLE\n+C..##ELSE\n+      PARAMETER (FIFTY  = 50.D0,  SIXTY  =  60.D0,  SVNTY2 =   72.D0,\n+     &           EIGHTY = 80.D0,  NINETY =  90.D0,  HUNDRD =  100.D0,\n+     &           ONE2TY = 120.D0, ONE8TY = 180.D0,  THRHUN =  300.D0,\n+     &           THR6TY=360.D0,   NINE99 = 999.D0,  FIFHUN = 1500.D0,\n+     &           THOSND = 1000.D0,FTHSND = 5000.D0, MEGA   =   1.0D6)\n+C..##ENDIF\n+      REAL*8     MINONE, MINTWO, MINSIX\n+      PARAMETER (MINONE = -1.D0,  MINTWO = -2.D0,  MINSIX = -6.D0)\n+      REAL*8     TENM20,TENM14,TENM8,TENM5,PT0001,PT0005,PT001,PT005,\n+     &           PT01, PT02, PT05, PTONE, PT125, PT25, SIXTH, THIRD,\n+     &           PTFOUR, PTSIX, HALF, PT75, PT9999, ONEPT5, TWOPT4\n+C..##IF SINGLE\n+C..##ELSE\n+      PARAMETER (TENM20 = 1.0D-20,  TENM14 = 1.0D-14,  TENM8  = 1.0D-8,\n+     &           TENM5  = 1.0D-5,   PT0001 = 1.0D-4, PT0005 = 5.0D-4,\n+     &           PT001  = 1.0D-3,   PT005  = 5.0D-3, PT01   = 0.01D0,\n+     &           PT02   = 0.02D0,   PT05   = 0.05D0, PTONE  = 0.1D0,\n+     &           PT125  = 0.125D0,  SIXTH  = ONE/SIX,PT25   = 0.25D0,\n+     &           THIRD  = ONE/THREE,PTFOUR = 0.4D0,  HALF   = 0.5D0,\n+     &           PTSIX  = 0.6D0,    PT75   = 0.75D0, PT9999 = 0.9999D0,\n+     &           ONEPT5 = 1.5D0,    TWOPT4 = 2.4D0)\n+C..##ENDIF\n+      REAL*8 ANUM,FMARK\n+      REAL*8 RSMALL,RBIG\n+C..##IF SINGLE\n+C..##ELSE\n+      PARAMETER (ANUM=9999.0D0, FMARK=-999.0D0)\n+      PARAMETER (RSMALL=1.0D-10,RBIG=1.0D20)\n+C..##ENDIF\n+      REAL*8 RPRECI,RBIGST\n+C..##IF VAX DEC\n+C..##ELIF IBM\n+C..##ELIF CRAY\n+C..##ELIF ALPHA T3D T3E\n+C..##ELSE\n+C...##IF SINGLE\n+C...##ELSE\n+      PARAMETER (RPRECI = 2.22045D-16, RBIGST = 4.49423D+307)\n+C...##ENDIF\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/consta.fcm'\n+      REAL*8 PI,RADDEG,DEGRAD,TWOPI\n+      PARAMETER(PI=3.141592653589793D0,TWOPI=2.0D0*PI)\n+      PARAMETER (RADDEG=180.0D0/PI)\n+      PARAMETER (DEGRAD=PI/180.0D0)\n+      REAL*8 COSMAX\n+      PARAMETER (COSMAX=0.9999999999D0)\n+      REAL*8 TIMFAC\n+      PARAMETER (TIMFAC=4.88882129D-02)\n+      REAL*8 KBOLTZ\n+      PARAMETER (KBOLTZ=1.987191D-03)\n+      REAL*8 CCELEC\n+C..##IF AMBER\n+C..##ELIF DISCOVER\n+C..##ELSE\n+      PARAMETER (CCELEC=332.0716D0)\n+C..##ENDIF\n+      REAL*8 CNVFRQ\n+      PARAMETER (CNVFRQ=2045.5D0/(2.99793D0*6.28319D0))\n+      REAL*8 SPEEDL\n+      PARAMETER (SPEEDL=2.99793D-02)\n+      REAL*8 ATMOSP\n+      PARAMETER (ATMOSP=1.4584007D-05)\n+      REAL*8 PATMOS\n+      PARAMETER (PATMOS = 1.D0 / ATMOSP )\n+      REAL*8 BOHRR\n+      PARAMETER (BOHRR = 0.529177249D0 )\n+      REAL*8 TOKCAL\n+      PARAMETER (TOKCAL = 627.5095D0 )\n+C..##IF MMFF\n+      real*8 MDAKCAL\n+      parameter(MDAKCAL=143.9325D0)\n+C..##ENDIF\n+      REAL*8 DEBYEC\n+      PARAMETER ( DEBYEC = 2.541766D0 / BOHRR )\n+      REAL*8 ZEROC\n+      PARAMETER ( ZEROC = 298.15D0 )\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/exfunc.fcm'\n+C..##IF ACE\n+C..##ENDIF\n+C..##IF ADUMB\n+C..##ENDIF\n+      CHARACTER*4 GTRMA, NEXTA4, CURRA4\n+      CHARACTER*6 NEXTA6\n+      CHARACTER*8 NEXTA8\n+      CHARACTER*20 NEXT20\n+      INTEGER     ALLCHR, ALLSTK, ALLHP, DECODI, FIND52,\n+     *            GETATN, GETRES, GETRSN, GETSEG, GTRMI, I4VAL,\n+     *            ICHAR4, ICMP16, ILOGI4, INDX, INDXA, INDXAF,\n+     *            INDXRA, INTEG4, IREAL4, IREAL8, LOCDIF,\n+     *            LUNASS, MATOM, NEXTI, NINDX, NSELCT, NSELCTV, ATMSEL,\n+     *            PARNUM, PARINS,\n+     *            SRCHWD, SRCHWS, STRLNG, DSIZE, SSIZE\n+C..##IF ACE\n+     *           ,GETNNB\n+C..##ENDIF\n+      LOGICAL     CHKPTR, EQST, EQSTA, EQSTWC, EQWDWC, DOTRIM, CHECQUE,\n+     *            HYDROG, INITIA, LONE, LTSTEQ, ORDER, ORDER5,\n+     *            ORDERR, USEDDT, QTOKDEL, QDIGIT, QALPHA\n+      REAL*8      DECODF, DOTVEC, GTRMF, LENVEC, NEXTF, RANDOM, GTRR8,\n+     *            RANUMB, R8VAL, RETVAL8, SUMVEC\n+C..##IF ADUMB\n+     *           ,UMFI\n+C..##ENDIF\n+      EXTERNAL  GTRMA, NEXTA4, CURRA4, NEXTA6, NEXTA8,NEXT20,\n+     *          ALLCHR, ALLSTK, ALLHP, DECODI, FIND52,\n+     *          GETATN, GETRES, GETRSN, GETSEG, GTRMI, I4VAL,\n+     *          ICHAR4, ICMP16,  ILOGI4, INDX, INDXA, INDXAF,\n+     *          INDXRA, INTEG4, IREAL4, IREAL8, LOCDIF,\n+     *          LUNASS, MATOM, NEXTI, NINDX, NSELCT, NSELCTV, ATMSEL,\n+     *          PARNUM, PARINS,\n+     *          SRCHWD, SRCHWS, STRLNG, DSIZE, SSIZE,\n+     *          CHKPTR, EQST, EQSTA, EQSTWC, EQWDWC, DOTRIM, CHECQUE,\n+     *          HYDROG, INITIA, LONE, LTSTEQ, ORDER, ORDER5,\n+     *          ORDERR, USEDDT, QTOKDEL, QDIGIT, QALPHA,\n+     *          DECODF, DOTVEC, GTRMF, LENVEC, NEXTF, RANDOM, GTRR8,\n+     *          RANUMB, R8VAL, RETVAL8, SUMVEC\n+C..##IF ADUMB\n+     *           ,UMFI\n+C..##ENDIF\n+C..##IF ACE\n+     *           ,GETNNB\n+C..##ENDIF\n+C..##IFN NOIMAGES\n+      INTEGER IMATOM\n+      EXTERNAL IMATOM\n+C..##ENDIF\n+C..##IF MBOND\n+C..##ENDIF\n+C..##IF MMFF\n+      INTEGER LEN_TRIM\n+      EXTERNAL LEN_TRIM\n+      CHARACTER*4 AtName\n+      external AtName\n+      CHARACTER*8 ElementName\n+      external ElementName\n+      CHARACTER*10 QNAME\n+      external QNAME\n+      integer  IATTCH, IBORDR, CONN12, CONN13, CONN14\n+      integer  LEQUIV, LPATH\n+      integer  nbndx, nbnd2, nbnd3, NTERMA\n+      external IATTCH, IBORDR, CONN12, CONN13, CONN14\n+      external LEQUIV, LPATH\n+      external nbndx, nbnd2, nbnd3, NTERMA\n+      external find_loc\n+      real*8   vangle, OOPNGL, TORNGL, ElementMass\n+      external vangle, OOPNGL, TORNGL, ElementMass\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/stack.fcm'\n+      INTEGER STKSIZ\n+C..##IFN UNICOS\n+C...##IF LARGE XLARGE\n+C...##ELIF MEDIUM REDUCE\n+      PARAMETER (STKSIZ=4000000)\n+C...##ELIF SMALL\n+C...##ELIF XSMALL\n+C...##ELIF XXLARGE\n+C...##ELSE\n+C...##ENDIF\n+      INTEGER LSTUSD,MAXUSD,STACK\n+      COMMON /ISTACK/ LSTUSD,MAXUSD,STACK(STKSIZ)\n+C..##ELSE\n+C..##ENDIF\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/heap.fcm'\n+      INTEGER HEAPDM\n+C..##IFN UNICOS (unicos)\n+C...##IF XXLARGE (size)\n+C...##ELIF LARGE XLARGE (size)\n+C...##ELIF MEDIUM (size)\n+C....##IF T3D (t3d2)\n+C....##ELIF TERRA (t3d2)\n+C....##ELIF ALPHA (t3d2)\n+C....##ELIF T3E (t3d2)\n+C....##ELSE (t3d2)\n+      PARAMETER (HEAPDM=2048000)\n+C....##ENDIF (t3d2)\n+C...##ELIF SMALL (size)\n+C...##ELIF REDUCE (size)\n+C...##ELIF XSMALL (size)\n+C...##ELSE (size)\n+C...##ENDIF (size)\n+      INTEGER FREEHP,HEAPSZ,HEAP\n+      COMMON /HEAPST/ FREEHP,HEAPSZ,HEAP(HEAPDM)\n+      LOGICAL LHEAP(HEAPDM)\n+      EQUIVALENCE (LHEAP,HEAP)\n+C..##ELSE (unicos)\n+C..##ENDIF (unicos)\n+C..##IF SAVEFCM (save)\n+C..##ENDIF (save)\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/fast.fcm'\n+      INTEGER IACNB, NITCC, ICUSED, FASTER, LFAST, LMACH, OLMACH\n+      INTEGER ICCOUNT, LOWTP, IGCNB, NITCC2\n+      INTEGER ICCNBA, ICCNBB, ICCNBC, ICCNBD, LCCNBA, LCCNBD\n+      COMMON /FASTI/ FASTER, LFAST, LMACH, OLMACH, NITCC, NITCC2,\n+     &               ICUSED(MAXATC), ICCOUNT(MAXATC), LOWTP(MAXATC),\n+     &               IACNB(MAXAIM), IGCNB(MAXATC),\n+     &               ICCNBA, ICCNBB, ICCNBC, ICCNBD, LCCNBA, LCCNBD\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/deriv.fcm'\n+      REAL*8 DX,DY,DZ\n+      COMMON /DERIVR/ DX(MAXAIM),DY(MAXAIM),DZ(MAXAIM)\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/energy.fcm'\n+      INTEGER LENENP, LENENT, LENENV, LENENA\n+      PARAMETER (LENENP = 50, LENENT = 70, LENENV = 50,\n+     &           LENENA = LENENP + LENENT + LENENV )\n+      INTEGER TOTE, TOTKE, EPOT, TEMPS, GRMS, BPRESS, PJNK1, PJNK2,\n+     &        PJNK3, PJNK4, HFCTE, HFCKE, EHFC, EWORK, VOLUME, PRESSE,\n+     &        PRESSI, VIRI, VIRE, VIRKE, TEPR, PEPR, KEPR, KEPR2,\n+     &        DROFFA,\n+     &        XTLTE, XTLKE, XTLPE, XTLTEM, XTLPEP, XTLKEP, XTLKP2,\n+     &        TOT4, TOTK4, EPOT4, TEM4, MbMom, BodyT, PartT\n+C..##IF ACE\n+     &      , SELF, SCREEN, COUL ,SOLV, INTER\n+C..##ENDIF\n+C..##IF FLUCQ\n+     &       ,FQKIN\n+C..##ENDIF\n+      PARAMETER (TOTE   =  1, TOTKE  =  2, EPOT   =  3, TEMPS  =  4,\n+     &           GRMS   =  5, BPRESS =  6, PJNK1  =  7, PJNK2  =  8,\n+     &           PJNK3  =  9, PJNK4  = 10, HFCTE  = 11, HFCKE  = 12,\n+     &           EHFC   = 13, EWORK  = 11, VOLUME = 15, PRESSE = 16,\n+     &           PRESSI = 17, VIRI   = 18, VIRE   = 19, VIRKE  = 20,\n+     &           TEPR   = 21, PEPR   = 22, KEPR   = 23, KEPR2  = 24,\n+     &                        DROFFA = 26, XTLTE  = 27, XTLKE  = 28,\n+     &           XTLPE  = 29, XTLTEM = 30, XTLPEP = 31, XTLKEP = 32,\n+     &           XTLKP2 = 33,\n+     &           TOT4   = 37, TOTK4  = 38, EPOT4  = 39, TEM4   = 40,\n+     &           MbMom  = 41, BodyT  = 42, PartT  = 43\n+C..##IF ACE\n+     &         , SELF   = 45, SCREEN = 46, COUL   = 47,\n+     &           SOLV   = 48, INTER  = 49\n+C..##ENDIF\n+C..##IF FLUCQ\n+     &          ,FQKIN  = 50\n+C..##ENDIF\n+     &          )\n+C..##IF ACE\n+C..##ENDIF\n+C..##IF GRID\n+C..##ENDIF\n+C..##IF FLUCQ\n+C..##ENDIF\n+      INTEGER  BOND, ANGLE, UREYB, DIHE, IMDIHE, VDW, ELEC, HBOND,\n+     &         USER, CHARM, CDIHE, CINTCR, CQRT, NOE, SBNDRY,\n+     &         IMVDW, IMELEC, IMHBND, EWKSUM, EWSELF, EXTNDE, RXNFLD,\n+     &         ST2, IMST2, TSM, QMEL, QMVDW, ASP, EHARM, GEO, MDIP,\n+     &         PRMS, PANG, SSBP, BK4D, SHEL, RESD, SHAP,\n+     &         STRB, OOPL, PULL, POLAR, DMC, RGY, EWEXCL, EWQCOR,\n+     &         EWUTIL, PBELEC, PBNP, PINT, MbDefrm, MbElec, STRSTR,\n+     &         BNDBND, BNDTW, EBST, MBST, BBT, SST, GBEnr, GSBP\n+C..##IF HMCM\n+     &       , HMCM\n+C..##ENDIF\n+C..##IF ADUMB\n+     &       , ADUMB\n+C..##ENDIF\n+     &       , HYDR\n+C..##IF FLUCQ\n+     &       , FQPOL\n+C..##ENDIF\n+      PARAMETER (BOND   =  1, ANGLE  =  2, UREYB  =  3, DIHE   =  4,\n+     &           IMDIHE =  5, VDW    =  6, ELEC   =  7, HBOND  =  8,\n+     &           USER   =  9, CHARM  = 10, CDIHE  = 11, CINTCR = 12,\n+     &           CQRT   = 13, NOE    = 14, SBNDRY = 15, IMVDW  = 16,\n+     &           IMELEC = 17, IMHBND = 18, EWKSUM = 19, EWSELF = 20,\n+     &           EXTNDE = 21, RXNFLD = 22, ST2    = 23, IMST2  = 24,\n+     &           TSM    = 25, QMEL   = 26, QMVDW  = 27, ASP    = 28,\n+     &           EHARM  = 29, GEO    = 30, MDIP   = 31, PINT   = 32,\n+     &           PRMS   = 33, PANG   = 34, SSBP   = 35, BK4D   = 36,\n+     &           SHEL   = 37, RESD   = 38, SHAP   = 39, STRB   = 40,\n+     &           OOPL   = 41, PULL   = 42, POLAR  = 43, DMC    = 44,\n+     &           RGY    = 45, EWEXCL = 46, EWQCOR = 47, EWUTIL = 48,\n+     &           PBELEC = 49, PBNP   = 50, MbDefrm= 51, MbElec = 52,\n+     &           STRSTR = 53, BNDBND = 54, BNDTW  = 55, EBST   = 56,\n+     &           MBST   = 57, BBT    = 58, SST    = 59, GBEnr  = 60,\n+     &           GSBP   = 65\n+C..##IF HMCM\n+     &         , HMCM   = 61\n+C..##ENDIF\n+C..##IF ADUMB\n+     &         , ADUMB  = 62\n+C..##ENDIF\n+     &         , HYDR   = 63\n+C..##IF FLUCQ\n+     &         , FQPOL  = 65\n+C..##ENDIF\n+     &           )\n+      INTEGER  VEXX, VEXY, VEXZ, VEYX, VEYY, VEYZ, VEZX, VEZY, VEZZ,\n+     &         VIXX, VIXY, VIXZ, VIYX, VIYY, VIYZ, VIZX, VIZY, VIZZ,\n+     &         PEXX, PEXY, PEXZ, PEYX, PEYY, PEYZ, PEZX, PEZY, PEZZ,\n+     &         PIXX, PIXY, PIXZ, PIYX, PIYY, PIYZ, PIZX, PIZY, PIZZ\n+      PARAMETER ( VEXX =  1, VEXY =  2, VEXZ =  3, VEYX =  4,\n+     &            VEYY =  5, VEYZ =  6, VEZX =  7, VEZY =  8,\n+     &            VEZZ =  9,\n+     &            VIXX = 10, VIXY = 11, VIXZ = 12, VIYX = 13,\n+     &            VIYY = 14, VIYZ = 15, VIZX = 16, VIZY = 17,\n+     &            VIZZ = 18,\n+     &            PEXX = 19, PEXY = 20, PEXZ = 21, PEYX = 22,\n+     &            PEYY = 23, PEYZ = 24, PEZX = 25, PEZY = 26,\n+     &            PEZZ = 27,\n+     &            PIXX = 28, PIXY = 29, PIXZ = 30, PIYX = 31,\n+     &            PIYY = 32, PIYZ = 33, PIZX = 34, PIZY = 35,\n+     &            PIZZ = 36)\n+      CHARACTER*4  CEPROP, CETERM, CEPRSS\n+      COMMON /ANER/ CEPROP(LENENP), CETERM(LENENT), CEPRSS(LENENV)\n+      LOGICAL  QEPROP, QETERM, QEPRSS\n+      COMMON /QENER/ QEPROP(LENENP), QETERM(LENENT), QEPRSS(LENENV)\n+      REAL*8   EPROP, ETERM, EPRESS\n+      COMMON /ENER/ EPROP(LENENP), ETERM(LENENT), EPRESS(LENENV)\n+C..##IF SAVEFCM\n+C..##ENDIF\n+      REAL*8   EPRPA, EPRP2A, EPRPP, EPRP2P,\n+     &         ETRMA, ETRM2A, ETRMP, ETRM2P,\n+     &         EPRSA, EPRS2A, EPRSP, EPRS2P\n+      COMMON /ENACCM/ EPRPA(LENENP), ETRMA(LENENT), EPRSA(LENENV),\n+     &                EPRP2A(LENENP),ETRM2A(LENENT),EPRS2A(LENENV),\n+     &                EPRPP(LENENP), ETRMP(LENENT), EPRSP(LENENV),\n+     &                EPRP2P(LENENP),ETRM2P(LENENT),EPRS2P(LENENV)\n+C..##IF SAVEFCM\n+C..##ENDIF\n+      INTEGER  ECALLS, TOT1ST, TOT2ND\n+      COMMON /EMISCI/ ECALLS, TOT1ST, TOT2ND\n+      REAL*8   EOLD, FITA, DRIFTA, EAT0A, CORRA, FITP, DRIFTP,\n+     &         EAT0P, CORRP\n+      COMMON /EMISCR/ EOLD, FITA, DRIFTA, EAT0A, CORRA,\n+     &                     FITP, DRIFTP, EAT0P, CORRP\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C..##IF ACE\n+C..##ENDIF\n+C..##IF FLUCQ\n+C..##ENDIF\n+C..##IF ADUMB\n+C..##ENDIF\n+C..##IF GRID\n+C..##ENDIF\n+C..##IF FLUCQ\n+C..##ENDIF\n+C..##IF TSM\n+      REAL*8 TSMTRM(LENENT),TSMTMP(LENENT)\n+      COMMON /TSMENG/ TSMTRM,TSMTMP\n+C...##IF SAVEFCM\n+C...##ENDIF\n+C..##ENDIF\n+      REAL*8 EHQBM\n+      LOGICAL HQBM\n+      COMMON /HQBMVAR/HQBM\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/dimb.fcm'\n+C..##IF DIMB (dimbfcm)\n+      INTEGER NPARMX,MNBCMP,LENDSK\n+      PARAMETER (NPARMX=1000,MNBCMP=300,LENDSK=200000)\n+      INTEGER IJXXCM,IJXYCM,IJXZCM,IJYXCM,IJYYCM\n+      INTEGER IJYZCM,IJZXCM,IJZYCM,IJZZCM\n+      INTEGER IIXXCM,IIXYCM,IIXZCM,IIYYCM\n+      INTEGER IIYZCM,IIZZCM\n+      INTEGER JJXXCM,JJXYCM,JJXZCM,JJYYCM\n+      INTEGER JJYZCM,JJZZCM\n+      PARAMETER (IJXXCM=1,IJXYCM=2,IJXZCM=3,IJYXCM=4,IJYYCM=5)\n+      PARAMETER (IJYZCM=6,IJZXCM=7,IJZYCM=8,IJZZCM=9)\n+      PARAMETER (IIXXCM=1,IIXYCM=2,IIXZCM=3,IIYYCM=4)\n+      PARAMETER (IIYZCM=5,IIZZCM=6)\n+      PARAMETER (JJXXCM=1,JJXYCM=2,JJXZCM=3,JJYYCM=4)\n+      PARAMETER (JJYZCM=5,JJZZCM=6)\n+      INTEGER ITER,IPAR1,IPAR2,NFSAV,PINBCM,PJNBCM,PDD1CM,LENCMP\n+      LOGICAL QDISK,QDW,QCMPCT\n+      COMMON /DIMBI/ ITER,IPAR1,IPAR2,NFSAV,PINBCM,PJNBCM,LENCMP\n+      COMMON /DIMBL/ QDISK,QDW,QCMPCT\n+C...##IF SAVEFCM\n+C...##ENDIF\n+C..##ENDIF (dimbfcm)\n+C-----------------------------------------------------------------------\n+C-----------------------------------------------------------------------\n+C:::##INCLUDE '~/charmm_fcm/ctitla.fcm'\n+      INTEGER MAXTIT\n+      PARAMETER (MAXTIT=32)\n+      INTEGER NTITLA,NTITLB\n+      CHARACTER*80 TITLEA,TITLEB\n+      COMMON /NTITLA/ NTITLA,NTITLB\n+      COMMON /CTITLA/ TITLEA(MAXTIT),TITLEB(MAXTIT)\n+C..##IF SAVEFCM\n+C..##ENDIF\n+C-----------------------------------------------------------------------\n+C Passed variables\n+      INTEGER NAT3,NADD,NPAR,NFREG,NFRET,BLATOM\n+      INTEGER ATMPAR(2,*),ATMPAS(2,*),ATMPAD(2,*)\n+      INTEGER BNBND(*),BIMAG(*)\n+      INTEGER INBCMP(*),JNBCMP(*),PARDIM\n+      INTEGER ITMX,IUNMOD,IUNRMD,SAVF\n+      INTEGER NBOND,IB(*),JB(*)\n+      REAL*8 X(*),Y(*),Z(*),AMASS(*),DDSCR(*)\n+      REAL*8 DDV(NAT3,*),PARDDV(PARDIM,*),DDM(*),DDS(*)\n+      REAL*8 DDF(*),PARDDF(*),DDEV(*),PARDDE(*)\n+      REAL*8 DD1BLK(*),DD1BLL(*),DD1CMP(*)\n+      REAL*8 TOLDIM,DDVALM\n+      REAL*8 PARFRQ,CUTF1\n+      LOGICAL LNOMA,LRAISE,LSCI,LBIG\n+C Local variables\n+      INTEGER NATOM,NATP,NDIM,I,J,II,OLDFAS,OLDPRN,IUPD\n+      INTEGER NPARC,NPARD,NPARS,NFCUT1,NFREG2,NFREG6\n+      INTEGER IH1,IH2,IH3,IH4,IH5,IH6,IH7,IH8\n+      INTEGER IS1,IS2,IS3,IS4,JSPACE,JSP,DDSS,DD5\n+      INTEGER ISTRT,ISTOP,IPA1,IPA2,IRESF\n+      INTEGER ATMPAF,INIDS,TRAROT\n+      INTEGER SUBLIS,ATMCOR\n+      INTEGER NFRRES,DDVBAS\n+      INTEGER DDV2,DDVAL\n+      INTEGER LENCM,NTR,NFRE,NFC,N1,N2,NFCUT,NSUBP\n+      INTEGER SCIFV1,SCIFV2,SCIFV3,SCIFV4,SCIFV6\n+      INTEGER DRATQ,ERATQ,E2RATQ,BDRATQ,INRATQ\n+      INTEGER I620,I640,I660,I700,I720,I760,I800,I840,I880,I920\n+      REAL*8 CVGMX,TOLER\n+      LOGICAL LCARD,LAPPE,LPURG,LWDINI,QCALC,QMASWT,QMIX,QDIAG\n+C Begin\n+      QCALC=.TRUE.\n+      LWDINI=.FALSE.\n+      INIDS=0\n+      IS3=0\n+      IS4=0\n+      LPURG=.TRUE.\n+      ITER=0\n+      NADD=0\n+      NFSAV=0\n+      TOLER=TENM5\n+      QDIAG=.TRUE.\n+      CVGMX=HUNDRD\n+      QMIX=.FALSE.\n+      NATOM=NAT3/3\n+      NFREG6=(NFREG-6)/NPAR\n+      NFREG2=NFREG/2\n+      NFRRES=(NFREG+6)/2\n+      IF(NFREG.GT.PARDIM) CALL WRNDIE(-3,'<NMDIMB>',\n+     1     'NFREG IS LARGER THAN PARDIM*3')\n+C\n+C ALLOCATE-SPACE-FOR-TRANSROT-VECTORS\n+      ASSIGN 801 TO I800\n+      GOTO 800\n+ 801  CONTINUE\n+C ALLOCATE-SPACE-FOR-DIAGONALIZATION\n+      ASSIGN 721 TO I720\n+      GOTO 720\n+ 721  CONTINUE\n+C ALLOCATE-SPACE-FOR-REDUCED-BASIS\n+      ASSIGN 761 TO I760\n+      GOTO 760\n+ 761  CONTINUE\n+C ALLOCATE-SPACE-FOR-OTHER-ARRAYS\n+      ASSIGN 921 TO I920\n+      GOTO 920\n+ 921  CONTINUE\n+C\n+C Space allocation for working arrays of EISPACK\n+C diagonalization subroutines\n+      IF(LSCI) THEN\n+C ALLOCATE-SPACE-FOR-LSCI\n+         ASSIGN 841 TO I840\n+         GOTO 840\n+ 841     CONTINUE\n+      ELSE\n+C ALLOCATE-DUMMY-SPACE-FOR-LSCI\n+         ASSIGN 881 TO I880\n+         GOTO 880\n+ 881     CONTINUE\n+      ENDIF\n+      QMASWT=(.NOT.LNOMA)\n+      IF(.NOT. QDISK) THEN\n+         LENCM=INBCMP(NATOM-1)*9+NATOM*6\n+         DO I=1,LENCM\n+            DD1CMP(I)=0.0\n+         ENDDO\n+         OLDFAS=LFAST\n+         QCMPCT=.TRUE.\n+         LFAST = -1\n+         CALL ENERGY(X,Y,Z,DX,DY,DZ,BNBND,BIMAG,NAT3,DD1CMP,.TRUE.,1)\n+         LFAST=OLDFAS\n+         QCMPCT=.FALSE.\n+C\n+C Mass weight DD1CMP matrix\n+C\n+         CALL MASSDD(DD1CMP,DDM,INBCMP,JNBCMP,NATOM)\n+      ELSE\n+         CALL WRNDIE(-3,'<NMDIMB>','QDISK OPTION NOT SUPPORTED YET')\n+C         DO I=1,LENDSK\n+C            DD1CMP(I)=0.0\n+C         ENDDO\n+C         OLDFAS=LFAST\n+C         LFAST = -1\n+      ENDIF\n+C\n+C Fill DDV with six translation-rotation vectors\n+C\n+      CALL TRROT(X,Y,Z,DDV,NAT3,1,DDM)\n+      CALL CPARAY(HEAP(TRAROT),DDV,NAT3,1,6,1)\n+      NTR=6\n+      OLDPRN=PRNLEV\n+      PRNLEV=1\n+      CALL ORTHNM(1,6,NTR,HEAP(TRAROT),NAT3,.FALSE.,TOLER)\n+      PRNLEV=OLDPRN\n+      IF(IUNRMD .LT. 0) THEN\n+C\n+C If no previous basis is read\n+C\n+         IF(PRNLEV.GE.2) WRITE(OUTU,502) NPAR\n+ 502     FORMAT(/' NMDIMB: Calculating initial basis from block ',\n+     1           'diagonals'/' NMDIMB: The number of blocks is ',I5/)\n+         NFRET = 6\n+         DO I=1,NPAR\n+            IS1=ATMPAR(1,I)\n+            IS2=ATMPAR(2,I)\n+            NDIM=(IS2-IS1+1)*3\n+            NFRE=NDIM\n+            IF(NFRE.GT.NFREG6) NFRE=NFREG6\n+            IF(NFREG6.EQ.0) NFRE=1\n+            CALL FILUPT(HEAP(IUPD),NDIM)\n+            CALL MAKDDU(DD1BLK,DD1CMP,INBCMP,JNBCMP,HEAP(IUPD),\n+     1                  IS1,IS2,NATOM)\n+            IF(PRNLEV.GE.9) CALL PRINTE(OUTU,EPROP,ETERM,'VIBR',\n+     1          'ENR',.TRUE.,1,ZERO,ZERO)\n+C\n+C Generate the lower section of the matrix and diagonalize\n+C\n+C..##IF EISPACK\n+C..##ENDIF\n+               IH1=1\n+               NATP=NDIM+1\n+               IH2=IH1+NATP\n+               IH3=IH2+NATP\n+               IH4=IH3+NATP\n+               IH5=IH4+NATP\n+               IH6=IH5+NATP\n+               IH7=IH6+NATP\n+               IH8=IH7+NATP\n+               CALL DIAGQ(NDIM,NFRE,DD1BLK,PARDDV,DDS(IH2),DDS(IH3),\n+     1           DDS(IH4),DDS(IH5),DDS,DDS(IH6),DDS(IH7),DDS(IH8),NADD)\n+C..##IF EISPACK\n+C..##ENDIF\n+C\n+C Put the PARDDV vectors into DDV and replace the elements which do\n+C not belong to the considered partitioned region by zeros.\n+C\n+            CALL ADJNME(DDV,PARDDV,NAT3,NDIM,NFRE,NFRET,IS1,IS2)\n+            IF(LSCI) THEN\n+               DO J=1,NFRE\n+               PARDDF(J)=CNVFRQ*SQRT(ABS(PARDDE(J)))\n+               IF(PARDDE(J) .LT. 0.0) PARDDF(J)=-PARDDF(J)\n+               ENDDO\n+            ELSE\n+               DO J=1,NFRE\n+               PARDDE(J)=DDS(J)\n+               PARDDF(J)=CNVFRQ*SQRT(ABS(PARDDE(J)))\n+               IF(PARDDE(J) .LT. 0.0) PARDDF(J)=-PARDDF(J)\n+               ENDDO\n+            ENDIF\n+            IF(PRNLEV.GE.2) THEN\n+               WRITE(OUTU,512) I\n+               WRITE(OUTU,514)\n+               WRITE(OUTU,516) (J,PARDDF(J),J=1,NFRE)\n+            ENDIF\n+            NFRET=NFRET+NFRE\n+            IF(NFRET .GE. NFREG) GOTO 10\n+         ENDDO\n+ 512     FORMAT(/' NMDIMB: Diagonalization of part',I5,' completed')\n+ 514     FORMAT(' NMDIMB: Frequencies'/)\n+ 516     FORMAT(5(I4,F12.6))\n+   10    CONTINUE\n+C\n+C Orthonormalize the eigenvectors\n+C\n+         OLDPRN=PRNLEV\n+         PRNLEV=1\n+         CALL ORTHNM(1,NFRET,NFRET,DDV,NAT3,LPURG,TOLER)\n+         PRNLEV=OLDPRN\n+C\n+C Do reduced basis diagonalization using the DDV vectors\n+C and get eigenvectors of zero iteration\n+C\n+         IF(PRNLEV.GE.2) THEN\n+            WRITE(OUTU,521) ITER\n+            WRITE(OUTU,523) NFRET\n+         ENDIF\n+ 521     FORMAT(/' NMDIMB: Iteration number = ',I5)\n+ 523     FORMAT(' NMDIMB: Dimension of the reduced basis set = ',I5)\n+         IF(LBIG) THEN\n+            IF(PRNLEV.GE.2) WRITE(OUTU,585) NFRET,IUNMOD\n+ 525        FORMAT(' NMDIMB: ',I5,' basis vectors are saved in unit',I5)\n+            REWIND (UNIT=IUNMOD)\n+            LCARD=.FALSE.\n+            CALL WRTNMD(LCARD,1,NFRET,NAT3,DDV,DDSCR,DDEV,IUNMOD,AMASS)\n+            CALL SAVEIT(IUNMOD)\n+         ELSE\n+            CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFRET,1)\n+         ENDIF\n+         CALL RBDG(X,Y,Z,NAT3,NDIM,NFRET,DDV,DDF,DDEV,\n+     1     DDSCR,HEAP(DD5),HEAP(DDSS),HEAP(DDV2),NADD,\n+     2     INBCMP,JNBCMP,HEAP(DDVBAS),DD1CMP,QMIX,0,0,IS3,IS4,\n+     3     CUTF1,NFCUT1,NFREG,HEAP(IUPD),DD1BLL,HEAP(SCIFV1),\n+     4     HEAP(SCIFV2),HEAP(SCIFV3),HEAP(SCIFV4),HEAP(SCIFV6),\n+     5     HEAP(DRATQ),HEAP(ERATQ),HEAP(E2RATQ),\n+     6     HEAP(BDRATQ),HEAP(INRATQ),LSCI,LBIG,IUNMOD)\n+C\n+C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n+C\n+         ASSIGN 621 TO I620\n+         GOTO 620\n+ 621     CONTINUE\n+C SAVE-MODES\n+         ASSIGN 701 TO I700\n+         GOTO 700\n+ 701     CONTINUE\n+         IF(ITER.EQ.ITMX) THEN\n+            CALL CLEANHP(NAT3,NFREG,NPARD,NSUBP,PARDIM,DDV2,DDSS,DDVBAS,\n+     1                   DDVAL,JSPACE,TRAROT,\n+     2                   SCIFV1,SCIFV2,SCIFV3,SCIFV4,SCIFV6,\n+     3                   DRATQ,ERATQ,E2RATQ,BDRATQ,INRATQ,IUPD,ATMPAF,\n+     4                   ATMCOR,SUBLIS,LSCI,QDW,LBIG)\n+            RETURN\n+         ENDIF\n+      ELSE\n+C\n+C Read in existing basis\n+C\n+         IF(PRNLEV.GE.2) THEN\n+            WRITE(OUTU,531)\n+ 531        FORMAT(/' NMDIMB: Calculations restarted')\n+         ENDIF\n+C READ-MODES\n+         ISTRT=1\n+         ISTOP=99999999\n+         LCARD=.FALSE.\n+         LAPPE=.FALSE.\n+         CALL RDNMD(LCARD,NFRET,NFREG,NAT3,NDIM,\n+     1     DDV,DDSCR,DDF,DDEV,\n+     2     IUNRMD,LAPPE,ISTRT,ISTOP)\n+         NFRET=NDIM\n+         IF(NFRET.GT.NFREG) THEN\n+            NFRET=NFREG\n+            CALL WRNDIE(-1,'<NMDIMB>',\n+     1       'Not enough space to hold the basis. Increase NMODes')\n+         ENDIF\n+C PRINT-MODES\n+         IF(PRNLEV.GE.2) THEN\n+            WRITE(OUTU,533) NFRET,IUNRMD\n+            WRITE(OUTU,514)\n+            WRITE(OUTU,516) (J,DDF(J),J=1,NFRET)\n+         ENDIF\n+ 533     FORMAT(/' NMDIMB: ',I5,' restart modes read from unit ',I5)\n+         NFRRES=NFRET\n+      ENDIF\n+C\n+C -------------------------------------------------\n+C Here starts the mixed-basis diagonalization part.\n+C -------------------------------------------------\n+C\n+C\n+C Check cut-off frequency\n+C\n+      CALL SELNMD(DDF,NFRET,CUTF1,NFCUT1)\n+C TEST-NFCUT1\n+      IF(IUNRMD.LT.0) THEN\n+        IF(NFCUT1*2-6.GT.NFREG) THEN\n+           IF(PRNLEV.GE.2) WRITE(OUTU,537) DDF(NFRRES)\n+           NFCUT1=NFRRES\n+           CUTF1=DDF(NFRRES)\n+        ENDIF\n+      ELSE\n+        CUTF1=DDF(NFRRES)\n+      ENDIF\n+ 537  FORMAT(/' NMDIMB: Too many vectors for the given cutoff frequency'\n+     1       /'         Cutoff frequency is decreased to',F9.3)\n+C\n+C Compute the new partioning of the molecule\n+C\n+      CALL PARTIC(NAT3,NFREG,NFCUT1,NPARMX,NPARC,ATMPAR,NFRRES,\n+     1            PARDIM)\n+      NPARS=NPARC\n+      DO I=1,NPARC\n+         ATMPAS(1,I)=ATMPAR(1,I)\n+         ATMPAS(2,I)=ATMPAR(2,I)\n+      ENDDO\n+      IF(QDW) THEN\n+         IF(IPAR1.EQ.0.OR.IPAR2.EQ.0) LWDINI=.TRUE.\n+         IF(IPAR1.GE.IPAR2) LWDINI=.TRUE.\n+         IF(IABS(IPAR1).GT.NPARC*2) LWDINI=.TRUE.\n+         IF(IABS(IPAR2).GT.NPARC*2) LWDINI=.TRUE.\n+         IF(ITER.EQ.0) LWDINI=.TRUE.\n+      ENDIF\n+      ITMX=ITMX+ITER\n+      IF(PRNLEV.GE.2) THEN\n+         WRITE(OUTU,543) ITER,ITMX\n+         IF(QDW) WRITE(OUTU,545) IPAR1,IPAR2\n+      ENDIF\n+ 543  FORMAT(/' NMDIMB: Previous iteration number = ',I8/\n+     1        ' NMDIMB: Iteration number to reach = ',I8)\n+ 545  FORMAT(' NMDIMB: Previous sub-blocks = ',I5,2X,I5)\n+C\n+      IF(SAVF.LE.0) SAVF=NPARC\n+      IF(PRNLEV.GE.2) WRITE(OUTU,547) SAVF\n+ 547  FORMAT(' NMDIMB: Eigenvectors will be saved every',I5,\n+     1       ' iterations')\n+C\n+C If double windowing is defined, the original block sizes are divided\n+C in two.\n+C\n+      IF(QDW) THEN\n+         NSUBP=1\n+         CALL PARTID(NPARC,ATMPAR,NPARD,ATMPAD,NPARMX)\n+         ATMPAF=ALLHP(INTEG4(NPARD*NPARD))\n+         ATMCOR=ALLHP(INTEG4(NATOM))\n+         DDVAL=ALLHP(IREAL8(NPARD*NPARD))\n+         CALL CORARR(ATMPAD,NPARD,HEAP(ATMCOR),NATOM)\n+         CALL PARLIS(HEAP(ATMCOR),HEAP(ATMPAF),INBCMP,JNBCMP,NPARD,\n+     2         NSUBP,NATOM,X,Y,Z,NBOND,IB,JB,DD1CMP,HEAP(DDVAL),DDVALM)\n+         SUBLIS=ALLHP(INTEG4(NSUBP*2))\n+         CALL PARINT(HEAP(ATMPAF),NPARD,HEAP(SUBLIS),NSUBP)\n+         CALL INIPAF(HEAP(ATMPAF),NPARD)\n+C\n+C Find out with which block to continue (double window method only)\n+C\n+         IPA1=IPAR1\n+         IPA2=IPAR2\n+         IRESF=0\n+         IF(LWDINI) THEN\n+            ITER=0\n+            LWDINI=.FALSE.\n+            GOTO 500\n+         ENDIF\n+         DO II=1,NSUBP\n+            CALL IPART(HEAP(SUBLIS),II,IPAR1,IPAR2,HEAP(ATMPAF),\n+     1                 NPARD,QCALC)\n+            IF((IPAR1.EQ.IPA1).AND.(IPAR2.EQ.IPA2)) GOTO 500\n+         ENDDO\n+      ENDIF\n+ 500  CONTINUE\n+C\n+C Main loop.\n+C\n+      DO WHILE((CVGMX.GT.TOLDIM).AND.(ITER.LT.ITMX))\n+         IF(.NOT.QDW) THEN\n+            ITER=ITER+1\n+            IF(PRNLEV.GE.2) WRITE(OUTU,553) ITER\n+ 553  FORMAT(/' NMDIMB: Iteration number = ',I8)\n+            IF(INIDS.EQ.0) THEN\n+               INIDS=1\n+            ELSE\n+               INIDS=0\n+            ENDIF\n+            CALL PARTDS(NAT3,NPARC,ATMPAR,NPARS,ATMPAS,INIDS,NPARMX,\n+     1                  DDF,NFREG,CUTF1,PARDIM,NFCUT1)\n+C DO-THE-DIAGONALISATIONS\n+            ASSIGN 641 to I640\n+            GOTO 640\n+ 641        CONTINUE\n+            QDIAG=.FALSE.\n+C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n+            ASSIGN 622 TO I620\n+            GOTO 620\n+ 622        CONTINUE\n+            QDIAG=.TRUE.\n+C SAVE-MODES\n+            ASSIGN 702 TO I700\n+            GOTO 700\n+ 702        CONTINUE\n+C\n+         ELSE\n+            DO II=1,NSUBP\n+               CALL IPART(HEAP(SUBLIS),II,IPAR1,IPAR2,HEAP(ATMPAF),\n+     1                 NPARD,QCALC)\n+               IF(QCALC) THEN\n+                  IRESF=IRESF+1\n+                  ITER=ITER+1\n+                  IF(PRNLEV.GE.2) WRITE(OUTU,553) ITER\n+C DO-THE-DWIN-DIAGONALISATIONS\n+                  ASSIGN 661 TO I660\n+                  GOTO 660\n+ 661              CONTINUE\n+               ENDIF\n+               IF((IRESF.EQ.SAVF).OR.(ITER.EQ.ITMX)) THEN\n+                  IRESF=0\n+                  QDIAG=.FALSE.\n+C DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n+                  ASSIGN 623 TO I620\n+                  GOTO 620\n+ 623              CONTINUE\n+                  QDIAG=.TRUE.\n+                  IF((CVGMX.LE.TOLDIM).OR.(ITER.EQ.ITMX)) GOTO 600\n+C SAVE-MODES\n+                  ASSIGN 703 TO I700\n+                  GOTO 700\n+ 703              CONTINUE\n+               ENDIF\n+            ENDDO\n+         ENDIF\n+      ENDDO\n+ 600  CONTINUE\n+C\n+C SAVE-MODES\n+      ASSIGN 704 TO I700\n+      GOTO 700\n+ 704  CONTINUE\n+      CALL CLEANHP(NAT3,NFREG,NPARD,NSUBP,PARDIM,DDV2,DDSS,DDVBAS,\n+     1             DDVAL,JSPACE,TRAROT,\n+     2             SCIFV1,SCIFV2,SCIFV3,SCIFV4,SCIFV6,\n+     3             DRATQ,ERATQ,E2RATQ,BDRATQ,INRATQ,IUPD,ATMPAF,\n+     4             ATMCOR,SUBLIS,LSCI,QDW,LBIG)\n+      RETURN\n+C-----------------------------------------------------------------------\n+C INTERNAL PROCEDURES\n+C-----------------------------------------------------------------------\n+C TO DO-THE-DIAGONALISATIONS-WITH-RESIDUALS\n+ 620  CONTINUE\n+      IF(IUNRMD.LT.0) THEN\n+        CALL SELNMD(DDF,NFRET,CUTF1,NFC)\n+        N1=NFCUT1\n+        N2=(NFRET+6)/2\n+        NFCUT=MAX(N1,N2)\n+        IF(NFCUT*2-6 .GT. NFREG) THEN\n+           NFCUT=(NFREG+6)/2\n+           CUTF1=DDF(NFCUT)\n+           IF(PRNLEV.GE.2) THEN\n+             WRITE(OUTU,562) ITER\n+             WRITE(OUTU,564) CUTF1\n+           ENDIF\n+        ENDIF\n+      ELSE\n+        NFCUT=NFRET\n+        NFC=NFRET\n+      ENDIF\n+ 562  FORMAT(/' NMDIMB: Not enough space to hold the residual vectors'/\n+     1       '         into DDV array during iteration ',I5)\n+ 564  FORMAT('         Cutoff frequency is changed to ',F9.3)\n+C\n+C do reduced diagonalization with preceding eigenvectors plus\n+C residual vectors\n+C\n+      ISTRT=1\n+      ISTOP=NFCUT\n+      CALL CLETR(DDV,HEAP(TRAROT),NAT3,ISTRT,ISTOP,NFCUT,DDEV,DDF)\n+      CALL RNMTST(DDV,HEAP(DDVBAS),NAT3,DDSCR,DD1CMP,INBCMP,JNBCMP,\n+     2            7,NFCUT,CVGMX,NFCUT,NFC,QDIAG,LBIG,IUNMOD)\n+      NFSAV=NFCUT\n+      IF(QDIAG) THEN\n+         NFRET=NFCUT*2-6\n+         IF(PRNLEV.GE.2) WRITE(OUTU,566) NFRET\n+ 566     FORMAT(/' NMDIMB: Diagonalization with residual vectors. '/\n+     1          '          Dimension of the reduced basis set'/\n+     2          '             before orthonormalization = ',I5)\n+         NFCUT=NFRET\n+         OLDPRN=PRNLEV\n+         PRNLEV=1\n+         CALL ORTHNM(1,NFRET,NFCUT,DDV,NAT3,LPURG,TOLER)\n+         PRNLEV=OLDPRN\n+         NFRET=NFCUT\n+         IF(PRNLEV.GE.2) WRITE(OUTU,568) NFRET\n+ 568     FORMAT('             after orthonormalization  = ',I5)\n+         IF(LBIG) THEN\n+            IF(PRNLEV.GE.2) WRITE(OUTU,570) NFCUT,IUNMOD\n+ 570        FORMAT(' NMDIMB: ',I5,' basis vectors are saved in unit',I5)\n+            REWIND (UNIT=IUNMOD)\n+            LCARD=.FALSE.\n+            CALL WRTNMD(LCARD,1,NFCUT,NAT3,DDV,DDSCR,DDEV,IUNMOD,AMASS)\n+            CALL SAVEIT(IUNMOD)\n+         ELSE\n+            CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFCUT,1)\n+         ENDIF\n+         QMIX=.FALSE.\n+         CALL RBDG(X,Y,Z,NAT3,NDIM,NFRET,DDV,DDF,DDEV,\n+     1     DDSCR,HEAP(DD5),HEAP(DDSS),HEAP(DDV2),NADD,\n+     2     INBCMP,JNBCMP,HEAP(DDVBAS),DD1CMP,QMIX,0,0,IS3,IS4,\n+     3     CUTF1,NFCUT1,NFREG,HEAP(IUPD),DD1BLL,HEAP(SCIFV1),\n+     4     HEAP(SCIFV2),HEAP(SCIFV3),HEAP(SCIFV4),HEAP(SCIFV6),\n+     5     HEAP(DRATQ),HEAP(ERATQ),HEAP(E2RATQ),\n+     6     HEAP(BDRATQ),HEAP(INRATQ),LSCI,LBIG,IUNMOD)\n+         CALL SELNMD(DDF,NFRET,CUTF1,NFCUT1)\n+      ENDIF\n+      GOTO I620\n+C\n+C-----------------------------------------------------------------------\n+C TO DO-THE-DIAGONALISATIONS\n+ 640  CONTINUE\n+      DO I=1,NPARC\n+         NFCUT1=NFRRES\n+         IS1=ATMPAR(1,I)\n+         IS2=ATMPAR(2,I)\n+         NDIM=(IS2-IS1+1)*3\n+         IF(PRNLEV.GE.2) WRITE(OUTU,573) I,IS1,IS2\n+ 573     FORMAT(/' NMDIMB: Mixed diagonalization, part ',I5/\n+     1           ' NMDIMB: Block limits: ',I5,2X,I5)\n+         IF(NDIM+NFCUT1.GT.PARDIM) CALL WRNDIE(-3,'<NMDIMB>',\n+     1      'Error in dimension of block')\n+         NFRET=NFCUT1\n+         IF(NFRET.GT.NFREG) NFRET=NFREG\n+         CALL CLETR(DDV,HEAP(TRAROT),NAT3,1,NFCUT1,NFCUT,DDEV,DDF)\n+         NFCUT1=NFCUT\n+         CALL ADZER(DDV,1,NFCUT1,NAT3,IS1,IS2)\n+         NFSAV=NFCUT1\n+         OLDPRN=PRNLEV\n+         PRNLEV=1\n+         CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER)\n+         PRNLEV=OLDPRN\n+         CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFCUT,1)\n+         NFRET=NDIM+NFCUT\n+         QMIX=.TRUE.\n+         CALL RBDG(X,Y,Z,NAT3,NDIM,NFRET,DDV,DDF,DDEV,\n+     1        DDSCR,HEAP(DD5),HEAP(DDSS),HEAP(DDV2),NADD,\n+     2        INBCMP,JNBCMP,HEAP(DDVBAS),DD1CMP,QMIX,IS1,IS2,IS3,IS4,\n+     3        CUTF1,NFCUT,NFREG,HEAP(IUPD),DD1BLL,HEAP(SCIFV1),\n+     4        HEAP(SCIFV2),HEAP(SCIFV3),HEAP(SCIFV4),HEAP(SCIFV6),\n+     5        HEAP(DRATQ),HEAP(ERATQ),HEAP(E2RATQ),\n+     6        HEAP(BDRATQ),HEAP(INRATQ),LSCI,LBIG,IUNMOD)\n+         QMIX=.FALSE.\n+         IF(NFCUT.GT.NFRRES) NFCUT=NFRRES\n+         NFCUT1=NFCUT\n+         NFRET=NFCUT\n+      ENDDO\n+      GOTO I640\n+C\n+C-----------------------------------------------------------------------\n+C TO DO-THE-DWIN-DIAGONALISATIONS\n+ 660  CONTINUE\n+C\n+C Store the DDV vectors into DDVBAS\n+C\n+      NFCUT1=NFRRES\n+      IS1=ATMPAD(1,IPAR1)\n+      IS2=ATMPAD(2,IPAR1)\n+      IS3=ATMPAD(1,IPAR2)\n+      IS4=ATMPAD(2,IPAR2)\n+      NDIM=(IS2-IS1+IS4-IS3+2)*3\n+      IF(PRNLEV.GE.2) WRITE(OUTU,577) IPAR1,IPAR2,IS1,IS2,IS3,IS4\n+ 577  FORMAT(/' NMDIMB: Mixed double window diagonalization, parts ',\n+     1        2I5/\n+     2        ' NMDIMB: Block limits: ',I5,2X,I5,4X,I5,2X,I5)\n+      IF(NDIM+NFCUT1.GT.PARDIM) CALL WRNDIE(-3,'<NMDIMB>',\n+     1      'Error in dimension of block')\n+      NFRET=NFCUT1\n+      IF(NFRET.GT.NFREG) NFRET=NFREG\n+C\n+C Prepare the DDV vectors consisting of 6 translations-rotations\n+C + eigenvectors from 7 to NFCUT1 + cartesian displacements vectors\n+C spanning the atoms from IS1 to IS2\n+C\n+      CALL CLETR(DDV,HEAP(TRAROT),NAT3,1,NFCUT1,NFCUT,DDEV,DDF)\n+      NFCUT1=NFCUT\n+      NFSAV=NFCUT1\n+      CALL ADZERD(DDV,1,NFCUT1,NAT3,IS1,IS2,IS3,IS4)\n+      OLDPRN=PRNLEV\n+      PRNLEV=1\n+      CALL ORTHNM(1,NFCUT1,NFCUT,DDV,NAT3,LPURG,TOLER)\n+      PRNLEV=OLDPRN\n+      CALL CPARAY(HEAP(DDVBAS),DDV,NAT3,1,NFCUT,1)\n+C\n+      NFRET=NDIM+NFCUT\n+      QMIX=.TRUE.\n+      CALL RBDG(X,Y,Z,NAT3,NDIM,NFRET,DDV,DDF,DDEV,\n+     1     DDSCR,HEAP(DD5),HEAP(DDSS),HEAP(DDV2),NADD,\n+     2     INBCMP,JNBCMP,HEAP(DDVBAS),DD1CMP,QMIX,IS1,IS2,IS3,IS4,\n+     3     CUTF1,NFCUT,NFREG,HEAP(IUPD),DD1BLL,HEAP(SCIFV1),\n+     4     HEAP(SCIFV2),HEAP(SCIFV3),HEAP(SCIFV4),HEAP(SCIFV6),\n+     5     HEAP(DRATQ),HEAP(ERATQ),HEAP(E2RATQ),\n+     6     HEAP(BDRATQ),HEAP(INRATQ),LSCI,LBIG,IUNMOD)\n+      QMIX=.FALSE.\n+C\n+      IF(NFCUT.GT.NFRRES) NFCUT=NFRRES\n+      NFCUT1=NFCUT\n+      NFRET=NFCUT\n+      GOTO I660\n+C\n+C-----------------------------------------------------------------------\n+C TO SAVE-MODES\n+ 700  CONTINUE\n+      IF(PRNLEV.GE.2) WRITE(OUTU,583) IUNMOD\n+ 583  FORMAT(/' NMDIMB: Saving the eigenvalues and eigenvectors to unit'\n+     1       ,I4)\n+      REWIND (UNIT=IUNMOD)\n+      ISTRT=1\n+      ISTOP=NFSAV\n+      LCARD=.FALSE.\n+      IF(PRNLEV.GE.2) WRITE(OUTU,585) NFSAV,IUNMOD\n+ 585  FORMAT(' NMDIMB: ',I5,' modes are saved in unit',I5)\n+      CALL WRTNMD(LCARD,ISTRT,ISTOP,NAT3,DDV,DDSCR,DDEV,IUNMOD,\n+     1            AMASS)\n+      CALL SAVEIT(IUNMOD)\n+      GOTO I700\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-SPACE-FOR-DIAGONALIZATION\n+ 720  CONTINUE\n+      DDV2=ALLHP(IREAL8((PARDIM+3)*(PARDIM+3)))\n+      JSPACE=IREAL8((PARDIM+4))*8\n+      JSP=IREAL8(((PARDIM+3)*(PARDIM+4))/2)\n+      JSPACE=JSPACE+JSP\n+      DDSS=ALLHP(JSPACE)\n+      DD5=DDSS+JSPACE-JSP\n+      GOTO I720\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-SPACE-FOR-REDUCED-BASIS\n+ 760  CONTINUE\n+      IF(LBIG) THEN\n+         DDVBAS=ALLHP(IREAL8(NAT3))\n+      ELSE\n+         DDVBAS=ALLHP(IREAL8(NFREG*NAT3))\n+      ENDIF\n+      GOTO I760\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-SPACE-FOR-TRANSROT-VECTORS\n+ 800  CONTINUE\n+      TRAROT=ALLHP(IREAL8(6*NAT3))\n+      GOTO I800\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-SPACE-FOR-LSCI\n+ 840  CONTINUE\n+      SCIFV1=ALLHP(IREAL8(PARDIM+3))\n+      SCIFV2=ALLHP(IREAL8(PARDIM+3))\n+      SCIFV3=ALLHP(IREAL8(PARDIM+3))\n+      SCIFV4=ALLHP(IREAL8(PARDIM+3))\n+      SCIFV6=ALLHP(IREAL8(PARDIM+3))\n+      DRATQ=ALLHP(IREAL8(PARDIM+3))\n+      ERATQ=ALLHP(IREAL8(PARDIM+3))\n+      E2RATQ=ALLHP(IREAL8(PARDIM+3))\n+      BDRATQ=ALLHP(IREAL8(PARDIM+3))\n+      INRATQ=ALLHP(INTEG4(PARDIM+3))\n+      GOTO I840\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-DUMMY-SPACE-FOR-LSCI\n+ 880  CONTINUE\n+      SCIFV1=ALLHP(IREAL8(2))\n+      SCIFV2=ALLHP(IREAL8(2))\n+      SCIFV3=ALLHP(IREAL8(2))\n+      SCIFV4=ALLHP(IREAL8(2))\n+      SCIFV6=ALLHP(IREAL8(2))\n+      DRATQ=ALLHP(IREAL8(2))\n+      ERATQ=ALLHP(IREAL8(2))\n+      E2RATQ=ALLHP(IREAL8(2))\n+      BDRATQ=ALLHP(IREAL8(2))\n+      INRATQ=ALLHP(INTEG4(2))\n+      GOTO I880\n+C\n+C-----------------------------------------------------------------------\n+C TO ALLOCATE-SPACE-FOR-OTHER-ARRAYS\n+ 920  CONTINUE\n+      IUPD=ALLHP(INTEG4(PARDIM+3))\n+      GOTO I920\n+C.##ELSE\n+C.##ENDIF\n+      END"}]}