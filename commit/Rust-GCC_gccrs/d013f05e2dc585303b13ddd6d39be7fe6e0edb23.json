{"sha": "d013f05e2dc585303b13ddd6d39be7fe6e0edb23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAxM2YwNWUyZGM1ODUzMDNiMTNkZGQ2ZDM5YmU3ZmU2ZTBlZGIyMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-06-05T23:25:48Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1996-06-05T23:25:48Z"}, "message": "cpplib.h, cpplib.c: Remove support for !STATIC_BUFFERS.\n\n* cpplib.h, cpplib.c:  Remove support for !STATIC_BUFFERS.\n* cpplib.c (special_symbol, do_once, do_include, cpp_get_token):\nCompare cpp_buffer against CPP_NULL_BUFFER, not NULL.\n* cpplib.c (dump_special_to_buffer):  New function.\n(initialize_builtins):  Use it.\n\nFrom-SVN: r12170", "tree": {"sha": "aa9bece8b5d8f9d241403de6b7bd1c44d41442d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa9bece8b5d8f9d241403de6b7bd1c44d41442d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d013f05e2dc585303b13ddd6d39be7fe6e0edb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d013f05e2dc585303b13ddd6d39be7fe6e0edb23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d013f05e2dc585303b13ddd6d39be7fe6e0edb23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d013f05e2dc585303b13ddd6d39be7fe6e0edb23/comments", "author": null, "committer": null, "parents": [{"sha": "af453bb064882fc999cd65f979b950e5d71f9373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af453bb064882fc999cd65f979b950e5d71f9373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af453bb064882fc999cd65f979b950e5d71f9373"}], "stats": {"total": 126, "additions": 48, "deletions": 78}, "files": [{"sha": "53d87c812f78726185846e924dfe5b907bea73c2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 48, "deletions": 78, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d013f05e2dc585303b13ddd6d39be7fe6e0edb23/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d013f05e2dc585303b13ddd6d39be7fe6e0edb23/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d013f05e2dc585303b13ddd6d39be7fe6e0edb23", "patch": "@@ -523,7 +523,7 @@ quote_string (pfile, src)\n       }\n }\n \n-/* Make sure PFILE->token_buffer will hold at least N more chars. */\n+/* Re-allocates PFILE->token_buffer so it will hold at least N more chars. */\n \n void\n cpp_grow_buffer (pfile, n)\n@@ -1886,25 +1886,23 @@ struct argdata {\n };\n \n \n+/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.\n+   If BUFFER != NULL, then use the LENGTH characters in BUFFER\n+   as the new input buffer.\n+   Return the new buffer, or NULL on failure. */\n+\n cpp_buffer*\n cpp_push_buffer (pfile, buffer, length)\n      cpp_reader *pfile;\n      U_CHAR *buffer;\n      long length;\n {\n-#ifdef STATIC_BUFFERS\n   register cpp_buffer *buf = CPP_BUFFER (pfile);\n   if (buf == pfile->buffer_stack)\n     fatal (\"%s: macro or `#include' recursion too deep\", buf->fname);\n   buf--;\n   bzero ((char *) buf, sizeof (cpp_buffer));\n   CPP_BUFFER (pfile) = buf;\n-#else\n-  register cpp_buffer *buf = (cpp_buffer*) xmalloc (sizeof(cpp_buffer));\n-  bzero ((char *) buf, sizeof (cpp_buffer));\n-  CPP_PREV_BUFFER (buf) = CPP_BUFFER (pfile);\n-  CPP_BUFFER (pfile) = buf;\n-#endif\n   buf->if_stack = pfile->if_stack;\n   buf->cleanup = null_cleanup;\n   buf->underflow = null_underflow;\n@@ -1919,16 +1917,8 @@ cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buf = CPP_BUFFER (pfile);\n-#ifdef STATIC_BUFFERS\n   (*buf->cleanup) (buf, pfile);\n   return ++CPP_BUFFER (pfile);\n-#else\n-  cpp_buffer *next_buf = CPP_PREV_BUFFER (buf);\n-  (*buf->cleanup) (buf, pfile);\n-  CPP_BUFFER (pfile) = next_buf;\n-  free (buf);\n-  return next_buf;\n-#endif\n }\n \n /* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.\n@@ -2331,7 +2321,7 @@ special_symbol (hp, pfile)\n     \n   for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n     {\n-      if (ip == NULL)\n+      if (ip == CPP_NULL_BUFFER (pfile))\n \t{\n \t  cpp_error (pfile, \"cccp error: not in any file?!\");\n \t  return;\t\t\t/* the show must go on */\n@@ -2348,7 +2338,7 @@ special_symbol (hp, pfile)\n \tchar *string;\n \tif (hp->type == T_BASE_FILE)\n \t  {\n-\t    while (CPP_PREV_BUFFER (ip))\n+\t    while (CPP_PREV_BUFFER (ip) != CPP_NULL_BUFFER (pfile))\n \t      ip = CPP_PREV_BUFFER (ip);\n \t  }\n \tstring = ip->nominal_fname;\n@@ -2362,7 +2352,8 @@ special_symbol (hp, pfile)\n \n     case T_INCLUDE_LEVEL:\n       true_indepth = 0;\n-      for (ip = CPP_BUFFER (pfile);  ip != NULL; ip = CPP_PREV_BUFFER (ip))\n+      ip = CPP_BUFFER (pfile);\n+      for (;  ip != CPP_NULL_BUFFER (pfile); ip = CPP_PREV_BUFFER (ip))\n \tif (ip->fname != NULL)\n \t  true_indepth++;\n \n@@ -2496,6 +2487,25 @@ special_symbol (hp, pfile)\n   return;\n }\n \n+/* Write out a #define command for the special named MACRO_NAME\n+   to PFILE's token_buffer.  */\n+\n+static void\n+dump_special_to_buffer (pfile, macro_name)\n+     cpp_reader *pfile;\n+     char *macro_name;\n+{\n+  static char define_directive[] = \"#define \";\n+  int macro_name_length = strlen (macro_name);\n+  output_line_command (pfile, 0, same_file);\n+  CPP_RESERVE (pfile, sizeof(define_directive) + macro_name_length);\n+  CPP_PUTS_Q (pfile, define_directive, sizeof(define_directive)-1);\n+  CPP_PUTS_Q (pfile, macro_name, macro_name_length);\n+  CPP_PUTC_Q (pfile, ' ');\n+  cpp_expand_to_buffer (pfile, macro_name, macro_name_length);\n+  CPP_PUTC (pfile, '\\n');\n+}\n+\n /* Initialize the built-in macros.  */\n \n static void\n@@ -2528,63 +2538,21 @@ initialize_builtins (pfile)\n \n   if (CPP_OPTIONS (pfile)->debug_output)\n     {\n-      char directive[2048];\n-      register struct directive *dp = &directive_table[0];\n-      struct tm *timebuf = timestamp (pfile);\n-      cpp_buffer *pbuffer = CPP_BUFFER (pfile);\n-\n-      while (CPP_PREV_BUFFER (pbuffer))\n-\tpbuffer = CPP_PREV_BUFFER (pbuffer);\n-      sprintf (directive, \" __BASE_FILE__ \\\"%s\\\"\\n\",\n-\t       pbuffer->nominal_fname);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n-\n-      sprintf (directive, \" __VERSION__ \\\"%s\\\"\\n\", version_string);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n-\n+      dump_special_to_buffer (pfile, \"__BASE_FILE__\");\n+      dump_special_to_buffer (pfile, \"__VERSION__\");\n #ifndef NO_BUILTIN_SIZE_TYPE\n-      sprintf (directive, \" __SIZE_TYPE__ %s\\n\", SIZE_TYPE);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n+      dump_special_to_buffer (pfile, \"__SIZE_TYPE__\");\n #endif\n-\n #ifndef NO_BUILTIN_PTRDIFF_TYPE\n-      sprintf (directive, \" __PTRDIFF_TYPE__ %s\\n\", PTRDIFF_TYPE);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n+      dump_special_to_buffer (pfile, \"__PTRDIFF_TYPE__\");\n #endif\n-\n-      sprintf (directive, \" __WCHAR_TYPE__ %s\\n\", CPP_WCHAR_TYPE (pfile));\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n-\n-      sprintf (directive, \" __DATE__ \\\"%s %2d %4d\\\"\\n\",\n-\t       monthnames[timebuf->tm_mon],\n-\t       timebuf->tm_mday, timebuf->tm_year + 1900);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n-\n-      sprintf (directive, \" __TIME__ \\\"%02d:%02d:%02d\\\"\\n\",\n-\t       timebuf->tm_hour, timebuf->tm_min, timebuf->tm_sec);\n-      output_line_command (pfile, 0, same_file);\n-      pass_thru_directive (directive, &directive[strlen (directive)], pfile, dp);\n-\n+      dump_special_to_buffer (pfile, \"__WCHAR_TYPE__\");\n+      dump_special_to_buffer (pfile, \"__DATE__\");\n+      dump_special_to_buffer (pfile, \"__TIME__\");\n       if (!CPP_TRADITIONAL (pfile))\n-\t{\n-          sprintf (directive, \" __STDC__ 1\");\n-          output_line_command (pfile, 0, same_file);\n-          pass_thru_directive (directive, &directive[strlen (directive)],\n-\t\t\t       pfile, dp);\n-\t}\n+\tdump_special_to_buffer (pfile, \"__STDC__\");\n       if (CPP_OPTIONS (pfile)->objc)\n-\t{\n-          sprintf (directive, \" __OBJC__ 1\");\n-          output_line_command (pfile, 0, same_file);\n-          pass_thru_directive (directive, &directive[strlen (directive)],\n-\t\t\t       pfile, dp);\n-\t}\n+\tdump_special_to_buffer (pfile, \"__OBJC__\");\n     }\n }\n \f\n@@ -3188,11 +3156,11 @@ do_include (pfile, keyword, unused1, unused2)\n       /* If -I- was specified, don't search current dir, only spec'd ones. */\n       else if (! CPP_OPTIONS (pfile)->ignore_srcdir)\n \t{\n-\t  cpp_buffer *fp;\n+\t  cpp_buffer *fp = CPP_BUFFER (pfile);\n \t  /* We have \"filename\".  Figure out directory this source\n \t     file is coming from and put it on the front of the list. */\n \n-\t  for (fp = CPP_BUFFER (pfile); fp != NULL; fp = CPP_PREV_BUFFER (fp))\n+\t  for ( ; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n \t    {\n \t      int n;\n \t      char *ep,*nam;\n@@ -3271,8 +3239,8 @@ do_include (pfile, keyword, unused1, unused2)\n      past the dir in which the containing file was found.  */\n   if (skip_dirs)\n     {\n-      cpp_buffer *fp;\n-      for (fp = CPP_BUFFER (pfile); fp != NULL; fp = CPP_PREV_BUFFER (fp))\n+      cpp_buffer *fp = CPP_BUFFER (pfile);\n+      for (; fp != CPP_NULL_BUFFER (pfile); fp = CPP_PREV_BUFFER (fp))\n \tif (fp->fname != NULL)\n \t  {\n \t    /* fp->dir is null if the containing file was specified with\n@@ -3467,7 +3435,7 @@ do_include (pfile, keyword, unused1, unused2)\n     if (CPP_OPTIONS(pfile)->print_include_names)\n       {\n \tcpp_buffer *buf = CPP_BUFFER (pfile);\n-\twhile ((buf = CPP_PREV_BUFFER (buf)) != NULL)\n+\twhile ((buf = CPP_PREV_BUFFER (buf)) != CPP_NULL_BUFFER (pfile))\n \t  putc ('.', stderr);\n \tfprintf (stderr, \"%s\\n\", fname);\n       }\n@@ -3958,7 +3926,7 @@ do_once (pfile)\n \n   for (ip = CPP_BUFFER (pfile); ; ip = CPP_PREV_BUFFER (ip))\n     {\n-      if (ip == NULL)\n+      if (ip == CPP_NULL_BUFFER (pfile))\n \treturn 0;\n       if (ip->fname != NULL)\n \tbreak;\n@@ -4623,7 +4591,8 @@ cpp_get_token (pfile)\n \t  cpp_buffer *next_buf\n \t    = CPP_PREV_BUFFER (CPP_BUFFER (pfile));\n \t  CPP_BUFFER (pfile)->seen_eof = 1;\n-\t  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != 0)\n+\t  if (CPP_BUFFER (pfile)->nominal_fname\n+\t      && next_buf != CPP_NULL_BUFFER (pfile))\n \t    {\n \t      /* We're about to return from an #include file.\n \t\t Emit #line information now (as part of the CPP_POP) result.\n@@ -6750,7 +6719,8 @@ cpp_finish (pfile)\n     }\n }\n \n-/* Free resources used by PFILE. */\n+/* Free resources used by PFILE.\n+   This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology). */\n \n void\n cpp_cleanup (pfile)"}]}