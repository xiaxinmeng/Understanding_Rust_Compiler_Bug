{"sha": "026c3cfd5e92e7f358290921984b57e1b433e658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI2YzNjZmQ1ZTkyZTdmMzU4MjkwOTIxOTg0YjU3ZTFiNDMzZTY1OA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2015-07-13T04:46:34Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2015-07-13T04:46:34Z"}, "message": "Fix double word typos.\n\nFrom-SVN: r225726", "tree": {"sha": "b334918063791e89f97a111eb02e3d0c9f8a766e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b334918063791e89f97a111eb02e3d0c9f8a766e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/026c3cfd5e92e7f358290921984b57e1b433e658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026c3cfd5e92e7f358290921984b57e1b433e658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/026c3cfd5e92e7f358290921984b57e1b433e658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026c3cfd5e92e7f358290921984b57e1b433e658/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e8ce0f35920ca44b790a742ab1e5058034c7fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8ce0f35920ca44b790a742ab1e5058034c7fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8ce0f35920ca44b790a742ab1e5058034c7fc2"}], "stats": {"total": 447, "additions": 292, "deletions": 155}, "files": [{"sha": "5f466b3a9dec5433fd1e9f2a1732b3da16d4ad72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,86 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* bitmap.h: Fix double word typos.\n+\t* builtins.c: Same.\n+\t* calls.c: Same.\n+\t* cfgloopmanip.c: Same.\n+\t* cgraph.c: Same.\n+\t* cgraph.h: Same.\n+\t* cgraphclones.c: Same.\n+\t* combine.c: Same.\n+\t* config/aarch64/aarch64-protos.h: Same.\n+\t* config/aarch64/aarch64.c: Same.\n+\t* config/aarch64/aarch64.md: Same.\n+\t* config/arm/arm.md: Same.\n+\t* config/arm/arm1020e.md: Same.\n+\t* config/arm/arm1026ejs.md: Same.\n+\t* config/arm/arm926ejs.md: Same.\n+\t* config/arm/fa526.md: Same.\n+\t* config/arm/fa606te.md: Same.\n+\t* config/arm/fa626te.md: Same.\n+\t* config/arm/fa726te.md: Same.\n+\t* config/arm/fmp626.md: Same.\n+\t* config/darwin.c: Same.\n+\t* config/epiphany/epiphany.c: Same.\n+\t* config/frv/frv.c: Same.\n+\t* config/ft32/ft32.c: Same.\n+\t* config/gnu-user.h: Same.\n+\t* config/h8300/constraints.md: Same.\n+\t* config/i386/i386.c: Same.\n+\t* config/i386/i386.md: Same.\n+\t* config/iq2000/iq2000.md: Same.\n+\t* config/mips/mips.c: Same.\n+\t* config/mmix/mmix.md: Same.\n+\t* config/moxie/moxie.c: Same.\n+\t* config/nds32/nds32.md: Same.\n+\t* config/pa/pa.h: Same.\n+\t* config/rs6000/aix.h: Same.\n+\t* config/rs6000/rs6000.h: Same.\n+\t* config/sh/sh.c: Same.\n+\t* config/tilegx/tilegx.md: Same.\n+\t* config/tilepro/gen-mul-tables.cc: Same.\n+\t* cse.c: Same.\n+\t* dbxout.c: Same.\n+\t* doc/invoke.texi: Same.\n+\t* dse.c: Same.\n+\t* dwarf2out.c: Same.\n+\t* final.c: Same.\n+\t* gcc.c: Same.\n+\t* genmatch.c: Same.\n+\t* gimplify.c: Same.\n+\t* hash-table.h: Same.\n+\t* internal-fn.c: Same.\n+\t* ipa-cp.c: Same.\n+\t* ipa-devirt.c: Same.\n+\t* ipa-icf.c: Same.\n+\t* ipa-icf.h: Same.\n+\t* ipa-profile.c: Same.\n+\t* ipa-prop.c: Same.\n+\t* ipa-prop.h: Same.\n+\t* ira.c: Same.\n+\t* omp-low.c: Same.\n+\t* reg-stack.c: Same.\n+\t* regcprop.c: Same.\n+\t* reorg.c: Same.\n+\t* rtl.h: Same.\n+\t* sbitmap.h: Same.\n+\t* tree-eh.c: Same.\n+\t* tree-inline.c: Same.\n+\t* tree-sra.c: Same.\n+\t* tree-ssa-dom.c: Same.\n+\t* tree-ssa-loop-ivopts.c: Same.\n+\t* tree-ssa-structalias.c: Same.\n+\t* tree-ssa-tail-merge.c: Same.\n+\t* tree-ssa-ter.c: Same.\n+\t* tree-ssa-threadupdate.c: Same.\n+\t* tree-ssa-uninit.c: Same.\n+\t* tree-ssanames.c: Same.\n+\t* tree-vect-loop-manip.c: Same.\n+\t* tree-vrp.c: Same.\n+\t* tree.c: Same.\n+\t* valtrack.c: Same.\n+\t* vec.h: Same.\n+\n 2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \tPR middle-end/66726"}, {"sha": "73ec8dee67d66f71ca7ee70206484e181379cb88", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,17 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc-interface/utils.c: Fix double word typos.\n+\t* gnat_ugn.texi: Same.\n+\t* init.c: Same.\n+\t* par.adb: Same.\n+\t* projects.texi: Same.\n+\t* sem_ch4.adb: Same.\n+\t* sem_ch6.adb: Same.\n+\t* sem_dim.adb: Same.\n+\t* sem_eval.adb: Same.\n+\t* sem_prag.adb: Same.\n+\t* sem_warn.adb: Same.\n+\n 2015-07-07  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* gcc-interface/cuintp.c: Adjust includes."}, {"sha": "00328399c5bcb096a517154efff121b6979bb742", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4826,7 +4826,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n   if (etype == type)\n     return expr;\n \n-  /* If both types types are integral just do a normal conversion.\n+  /* If both types are integral just do a normal conversion.\n      Likewise for a conversion to an unconstrained array.  */\n   if (((INTEGRAL_TYPE_P (type)\n \t|| (POINTER_TYPE_P (type) && !TYPE_IS_THIN_POINTER_P (type))"}, {"sha": "21fd59ef66e310e6261000f76af1ad40b4321c4c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -9130,7 +9130,7 @@ messages showing\n where implicit @cite{pragma Elaborate} and @cite{pragma Elaborate_All}\n are generated. This is useful in diagnosing elaboration circularities\n caused by these implicit pragmas when using the static elaboration\n-model. See See the section in this guide on elaboration checking for\n+model. See the section in this guide on elaboration checking for\n further details. These messages are not generated by default, and are\n intended only for temporary use when debugging circularity problems.\n @end table\n@@ -21139,7 +21139,7 @@ in an executable.\n @item \n @strong{Run_Path_Origin}: single\n \n-Value is the the string that may replace the path name of the executable\n+Value is the string that may replace the path name of the executable\n directory in the run path options.\n \n @item \n@@ -21256,7 +21256,7 @@ the prefix is \"lib\".\n @item \n @strong{Shared_Library_Suffix}: single\n \n-Value is the the extension of the name of shared library files. When not\n+Value is the extension of the name of shared library files. When not\n declared, the extension is \".so\".\n \n @item "}, {"sha": "5754fae361979a3c54ae3585ca29a5b72967d16b", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1229,7 +1229,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \t                     unsigned int acmode);\n \n       /* If SS$_CONTROLC has been imported as an exception, it will take\n-\t priority over a a Ctrl/C handler.  See above.  SIGINT has a\n+\t priority over a Ctrl/C handler.  See above.  SIGINT has a\n \t different condition value due to it's DECCCRTL roots and it's\n \t the condition that gets raised for a \"kill -INT\".  */\n       if ((ctrlc_match || sigint_match) && __gnat_ctrl_c_handler)"}, {"sha": "a4658bf6939c3a1efc26a5b90e61a38f798a8b22", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -967,7 +967,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  to either a WITH keyword starting an aspect specification, or an\n       --  instance of what shpould be a terminator token. In the former case,\n       --  the aspect specifications are scanned out including the terminator\n-      --  token if it it is a semicolon, and the Has_Aspect_Specifications\n+      --  token if it is a semicolon, and the Has_Aspect_Specifications\n       --  flag is set in the given declaration node. A list of aspects\n       --  is built and stored for this declaration node using a call to\n       --  Set_Aspect_Specifications. If no WITH keyword is present, then this"}, {"sha": "2ca6babc55fbf71bd8af907f1512f5cddea8fa73", "filename": "gcc/ada/projects.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fprojects.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fprojects.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprojects.texi?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4088,7 +4088,7 @@ in an executable.\n \n @item @b{Run_Path_Origin}: single\n \n-Value is the the string that may replace the path name of the executable\n+Value is the string that may replace the path name of the executable\n directory in the run path options.\n \n @item @b{Separate_Run_Path_Options}: single\n@@ -4186,7 +4186,7 @@ the prefix is \"lib\".\n \n @item @b{Shared_Library_Suffix}: single\n \n-Value is the the extension of the name of shared library files. When not\n+Value is the extension of the name of shared library files. When not\n declared, the extension is \".so\".\n \n @item @b{Symbolic_Link_Supported}: single"}, {"sha": "473d65ef7256d71dd490a157f95b061f228dd6cc", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -6136,7 +6136,7 @@ package body Sem_Ch4 is\n          --  to be considered, we don't want the default inequality declared\n          --  in Standard to be chosen, and the \"/=\" will be rewritten as a\n          --  negation of \"=\" (see the end of Analyze_Equality_Op). This ensures\n-         --  that that rewriting happens during analysis rather than being\n+         --  that rewriting happens during analysis rather than being\n          --  delayed until expansion (this is needed for ASIS, which only sees\n          --  the unexpanded tree). Note that if the node is N_Op_Ne, but Op_Id\n          --  is Name_Op_Eq then we still proceed with the interpretation,"}, {"sha": "4f6038e2d30dc94139c121fe270114eb122948ad", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4402,7 +4402,7 @@ package body Sem_Ch6 is\n \n       --  Proceed with analysis. Do not emit a cross-reference entry if the\n       --  specification comes from an expression function, because it may be\n-      --  the completion of a previous declaration. It is is not, the cross-\n+      --  the completion of a previous declaration. It is not, the cross-\n       --  reference entry will be emitted for the new subprogram declaration.\n \n       if Nkind (Parent (N)) /= N_Expression_Function then"}, {"sha": "ebacba9f965780687d0800cbf7721f828702266a", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -322,7 +322,7 @@ package body Sem_Dim is\n    --  string of dimension symbols. If In_Error_Msg is True (i.e. the String_Id\n    --  will be used to issue an error message) then this routine has a special\n    --  handling for the insertion characters * or [ which must be preceded by\n-   --  a quote ' to to be placed literally into the message.\n+   --  a quote ' to be placed literally into the message.\n \n    function From_Dim_To_Str_Of_Unit_Symbols\n      (Dims   : Dimension_Type;"}, {"sha": "d8a4f3e4cca784f636c9779ae1d2308ab39204ca", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1093,7 +1093,7 @@ package body Sem_Eval is\n       elsif No (Ltyp) or else No (Rtyp) then\n          return Unknown;\n \n-      --  We do not attempt comparisons for packed arrays arrays represented as\n+      --  We do not attempt comparisons for packed arrays represented as\n       --  modular types, where the semantics of comparison is quite different.\n \n       elsif Is_Packed_Array_Impl_Type (Ltyp)"}, {"sha": "c3f7618bb9b9ec530b0c659ab20d24675af1f2c3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -6753,7 +6753,7 @@ package body Sem_Prag is\n                Generate_Reference (E, Id, 'i');\n             end if;\n \n-            --  If the pragma comes from from an aspect, it only applies to the\n+            --  If the pragma comes from an aspect, it only applies to the\n             --  given entity, not its homonyms.\n \n             if From_Aspect_Specification (N) then"}, {"sha": "9140a0899f6de888b46063c2344a451149b63491", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4366,7 +4366,7 @@ package body Sem_Warn is\n                      --  Otherwise we are at the outer level. An exception\n                      --  handler is significant only if it references the\n                      --  variable in question, or if the entity in question\n-                     --  is an OUT or IN OUT parameter, which which case\n+                     --  is an OUT or IN OUT parameter, in which case\n                      --  the caller can reference it after the exception\n                      --  handler completes.\n "}, {"sha": "3715855593010fe5345d10997fa9c335eb3e5080", "filename": "gcc/bitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -86,7 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n      * set_disjuction\t\t: bitmap_xor_comp / bitmap_xor_comp_into\n      * set_compare\t\t: bitmap_equal_p\n \n-   Some operations on 3 sets that occur frequently in in data flow problems\n+   Some operations on 3 sets that occur frequently in data flow problems\n    are also implemented:\n \n      * A | (B & C)\t\t: bitmap_ior_and_into"}, {"sha": "1750e25eddf4a32f870a520c7d250a4b9d7c2cc9", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -5690,7 +5690,7 @@ fold_builtin_atomic_always_lock_free (tree arg0, tree arg1)\n       type_align = TYPE_ALIGN (ttype);\n     }\n \n-  /* If the object has smaller alignment, the the lock free routines cannot\n+  /* If the object has smaller alignment, the lock free routines cannot\n      be used.  */\n   if (type_align < mode_align)\n     return boolean_false_node;"}, {"sha": "9f06dcd3e868c5bfe74e540f530a03be85f63d1c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,7 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* c-common.c: Fix double word typos.\n+\n 2015-07-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.h (cpp_operation): Revert latest change.\n@@ -8,7 +12,7 @@\n \n \t* c-common.h: Adjust includes for flags.h changes.\n \t* stub-objc.c: Likewise.\n-\t\n+\n 2015-07-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.h (cpp_operation): Add IS_CONSTEXPR."}, {"sha": "84e7242ec0a0450b43c2b2c7a3d5d63b066b7541", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -6690,7 +6690,7 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n \t\t    \"switch condition has boolean value\");\n     }\n \n-  /* From here on, we only care about about enumerated types.  */\n+  /* From here on, we only care about enumerated types.  */\n   if (!type || TREE_CODE (type) != ENUMERAL_TYPE)\n     return;\n \n@@ -11219,7 +11219,7 @@ atomic_size_supported_p (int n)\n    TRUE is returned if it is translated into the proper format for a call to the\n    external library, and NEW_RETURN is set the tree for that function.\n    FALSE is returned if processing for the _N variation is required, and \n-   NEW_RETURN is set to the the return value the result is copied into.  */\n+   NEW_RETURN is set to the return value the result is copied into.  */\n static bool\n resolve_overloaded_atomic_exchange (location_t loc, tree function, \n \t\t\t\t    vec<tree, va_gc> *params, tree *new_return)\n@@ -11359,7 +11359,7 @@ resolve_overloaded_atomic_compare_exchange (location_t loc, tree function,\n    TRUE is returned if it is translated into the proper format for a call to the\n    external library, and NEW_RETURN is set the tree for that function.\n    FALSE is returned if processing for the _N variation is required, and \n-   NEW_RETURN is set to the the return value the result is copied into.  */\n+   NEW_RETURN is set to the return value the result is copied into.  */\n \n static bool\n resolve_overloaded_atomic_load (location_t loc, tree function, \n@@ -11419,7 +11419,7 @@ resolve_overloaded_atomic_load (location_t loc, tree function,\n    TRUE is returned if it is translated into the proper format for a call to the\n    external library, and NEW_RETURN is set the tree for that function.\n    FALSE is returned if processing for the _N variation is required, and \n-   NEW_RETURN is set to the the return value the result is copied into.  */\n+   NEW_RETURN is set to the return value the result is copied into.  */\n \n static bool\n resolve_overloaded_atomic_store (location_t loc, tree function, "}, {"sha": "143e6125bd876b43ac1160667e957f890d763cee", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1170,7 +1170,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n    and may be modified by this routine.\n \n    OLD_PENDING_ADJ, MUST_PREALLOCATE and FLAGS are pointers to integer\n-   flags which may may be modified by this routine.\n+   flags which may be modified by this routine.\n \n    MAY_TAILCALL is cleared if we encounter an invisible pass-by-reference\n    that requires allocation of stack space."}, {"sha": "1f9a2b38fe7d2824e2fd406632d27cb2e42ebd31", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -164,7 +164,7 @@ fix_loop_placement (struct loop *loop, bool *irred_invalidated)\n }\n \n /* Fix placements of basic blocks inside loop hierarchy stored in loops; i.e.\n-   enforce condition condition stated in description of fix_bb_placement. We\n+   enforce condition stated in description of fix_bb_placement. We\n    start from basic block FROM that had some of its successors removed, so that\n    his placement no longer has to be correct, and iteratively fix placement of\n    its predecessors that may change if placement of FROM changed.  Also fix"}, {"sha": "22a98527819480418eca28ee40ac2f87d5e3287e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -677,7 +677,7 @@ cgraph_edge_hasher::hash (gimple call_stmt)\n   return (hashval_t) ((intptr_t)call_stmt >> 3);\n }\n \n-/* Return nonzero if the call_stmt of of cgraph_edge X is stmt *Y.  */\n+/* Return nonzero if the call_stmt of cgraph_edge X is stmt *Y.  */\n \n inline bool\n cgraph_edge_hasher::equal (cgraph_edge *x, gimple y)\n@@ -1739,8 +1739,8 @@ cgraph_node::release_body (bool keep_arguments)\n       if (!keep_arguments)\n \tDECL_ARGUMENTS (decl) = NULL;\n     }\n-  /* If the node is abstract and needed, then do not clear DECL_INITIAL\n-     of its associated function function declaration because it's\n+  /* If the node is abstract and needed, then do not clear\n+     DECL_INITIAL of its associated function declaration because it's\n      needed to emit debug info later.  */\n   if (!used_as_abstract_origin && DECL_INITIAL (decl))\n     DECL_INITIAL (decl) = error_mark_node;"}, {"sha": "9476896e759a38cd2b33202a7409dce98dd6b8e8", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -590,8 +590,8 @@ struct GTY(()) cgraph_thunk_info {\n    Available after function is analyzed.  */\n \n struct GTY(()) cgraph_local_info {\n-  /* Set when function function is visible in current compilation unit only\n-     and its address is never taken.  */\n+  /* Set when function is visible in current compilation unit only and\n+     its address is never taken.  */\n   unsigned local : 1;\n \n   /* False when there is something makes versioning impossible.  */\n@@ -712,7 +712,7 @@ struct GTY(()) cgraph_simd_clone {\n   /* Max hardware vector size in bits for floating point vectors.  */\n   unsigned int vecsize_float;\n \n-  /* The mangling character for a given vector size.  This is is used\n+  /* The mangling character for a given vector size.  This is used\n      to determine the ISA mangling bit as specified in the Intel\n      Vector ABI.  */\n   unsigned char vecsize_mangle;\n@@ -1905,7 +1905,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Once all functions from compilation unit are in memory, produce all clones\n      and update all calls.  We might also do this on demand if we don't want to\n      bring all functions to memory prior compilation, but current WHOPR\n-     implementation does that and it is is bit easier to keep everything right\n+     implementation does that and it is bit easier to keep everything right\n      in this order.  */\n   void materialize_all_clones (void);\n "}, {"sha": "9e9f1a0459e5d609d8b65a30af2491f88c2112aa", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1064,7 +1064,7 @@ cgraph_materialize_clone (cgraph_node *node)\n /* Once all functions from compilation unit are in memory, produce all clones\n    and update all calls.  We might also do this on demand if we don't want to\n    bring all functions to memory prior compilation, but current WHOPR\n-   implementation does that and it is is bit easier to keep everything right in\n+   implementation does that and it is a bit easier to keep everything right in\n    this order.  */\n \n void"}, {"sha": "574f874d2b19c9201d55778253d275d156e24163", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -31,7 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n    We also try to combine triplets of insns A, B and C when C has\n    a link back to B and B has a link back to A.  Likewise for a\n    small number of quadruplets of insns A, B, C and D for which\n-   there's high likelihood of of success.\n+   there's high likelihood of success.\n \n    LOG_LINKS does not have links for use of the CC0.  They don't\n    need to, because the insn that sets the CC0 is always immediately"}, {"sha": "e4f5b00fb0bcb133bcef8aaba0d1e72a5cb5c2be", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -73,7 +73,7 @@ enum aarch64_symbol_context\n    SYMBOL_SMALL_TLSDESC\n    SYMBOL_SMALL_GOTTPREL\n    SYMBOL_TLSLE\n-   Each of of these represents a thread-local symbol, and corresponds to the\n+   Each of these represents a thread-local symbol, and corresponds to the\n    thread local storage relocation operator for the symbol being referred to.\n \n    SYMBOL_TINY_ABSOLUTE"}, {"sha": "020f63c0dc1a7b47117a489384d8a38f3d766976", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -897,7 +897,7 @@ aarch64_load_symref_appropriately (rtx dest, rtx imm,\n \t   here before rtl expand.  Tree IVOPT will generate rtl pattern to\n \t   decide rtx costs, in which case pic_offset_table_rtx is not\n \t   initialized.  For that case no need to generate the first adrp\n-\t   instruction as the the final cost for global variable access is\n+\t   instruction as the final cost for global variable access is\n \t   one instruction.  */\n \tif (gp_rtx != NULL)\n \t  {"}, {"sha": "db51ef812fe8f212afcd018e3a03688d087f3f07", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -144,7 +144,7 @@\n ;; Instruction types and attributes\n ;; -------------------------------------------------------------------\n \n-; The \"type\" attribute is is included here from AArch32 backend to be able\n+; The \"type\" attribute is included here from AArch32 backend to be able\n ; to share pipeline descriptions.\n (include \"../arm/types.md\")\n "}, {"sha": "0be70a862d64a86cd1518286f266f549ee33c13d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4553,7 +4553,7 @@\n   \"TARGET_32BIT\"\n   \"#\" ; \"rsbs\\\\t%Q0, %1, #0\\;sbc\\\\t%R0,%R0,%R0\"\n       ;; Don't care what register is input to sbc,\n-      ;; since we just just need to propagate the carry.\n+      ;; since we just need to propagate the carry.\n   \"&& reload_completed\"\n   [(parallel [(set (reg:CC CC_REGNUM)\n                    (compare:CC (const_int 0) (match_dup 1)))"}, {"sha": "3c1bfb08795dd7b6e372acb1419683cee57bf69d", "filename": "gcc/config/arm/arm1020e.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm1020e.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm1020e.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm1020e.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -58,7 +58,7 @@\n \n ;; ALU instructions require three cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "54fbedd1089fbeb2f7083cefcb28b56090a84a63", "filename": "gcc/config/arm/arm1026ejs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm1026ejs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm1026ejs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm1026ejs.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -58,7 +58,7 @@\n \n ;; ALU instructions require three cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "27a8aba1a166c94f782ce1f8caa255c473e40a0d", "filename": "gcc/config/arm/arm926ejs.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm926ejs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Farm926ejs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm926ejs.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -50,7 +50,7 @@\n \n ;; ALU instructions require three cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "34eb0d39f50cfaccad5fe6d9f1ee6e3bee60ba82", "filename": "gcc/config/arm/fa526.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa526.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa526.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa526.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -54,7 +54,7 @@\n \n ;; ALU instructions require two cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "60662a7f1f4e5f3a753e7a1f06a3e32c39e573e0", "filename": "gcc/config/arm/fa606te.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa606te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa606te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa606te.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -54,7 +54,7 @@\n \n ;; ALU instructions require two cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "573e2c1e1486aac7d7c3310eab594eb789b1e4dc", "filename": "gcc/config/arm/fa626te.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa626te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa626te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa626te.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -60,7 +60,7 @@\n \n ;; ALU instructions require two cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "63459f24ee0745a542c414400af971c1b1973d96", "filename": "gcc/config/arm/fa726te.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa726te.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffa726te.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffa726te.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -70,7 +70,7 @@\n \n ;; ALU instructions require three cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "5d43bd1076402e70b319cedfc9178f1ea9149087", "filename": "gcc/config/arm/fmp626.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffmp626.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Farm%2Ffmp626.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ffmp626.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -55,7 +55,7 @@\n \n ;; ALU instructions require two cycles to execute, and use the ALU\n ;; pipeline in each of the three stages.  The results are available\n-;; after the execute stage stage has finished.\n+;; after the execute stage has finished.\n ;;\n ;; If the destination register is the PC, the pipelines are stalled\n ;; for several cycles.  That case is not modeled here."}, {"sha": "b6effec465a261075f175f5e162823c1bca087d6", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -463,7 +463,7 @@ typedef struct GTY ((for_user)) machopic_indirection\n   /* True iff this entry is for a stub (as opposed to a non-lazy\n      pointer).  */\n   bool stub_p;\n-  /* True iff this stub or pointer pointer has been referenced.  */\n+  /* True iff this stub or pointer has been referenced.  */\n   bool used;\n } machopic_indirection;\n "}, {"sha": "593c9a19124579d31b0ca196a8d24584c7992a3c", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -572,7 +572,7 @@ sfunc_symbol (const char *name)\n }\n \n /* X and Y are two things to compare using CODE in IN_MODE.\n-   Emit the compare insn, construct the the proper cc reg in the proper\n+   Emit the compare insn, construct the proper cc reg in the proper\n    mode, and return the rtx for the cc reg comparison in CMODE.  */\n \n rtx"}, {"sha": "15de223bae3e2c03c2d9bd1320ca6bcb5799e9d8", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1191,7 +1191,7 @@ frv_stack_info (void)\n \t}\n     }\n \n-  /* Set up the sizes of each each field in the frame body, making the sizes\n+  /* Set up the sizes of each field in the frame body, making the sizes\n      of each be divisible by the size of a dword if dword operations might\n      be used, or the size of a word otherwise.  */\n   alignment = (TARGET_DWORD? 2 * UNITS_PER_WORD : UNITS_PER_WORD);"}, {"sha": "f2e2677b2deb2925008693f0bb82ca684b9ec412", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -782,7 +782,7 @@ ft32_is_mem_pm (rtx o)\n \n /* Define this to return an RTX representing the place where a\n    function returns or receives a value of data type RET_TYPE, a tree\n-   node node representing a data type.  */\n+   node representing a data type.  */\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE ft32_function_value\n #undef TARGET_LIBCALL_VALUE"}, {"sha": "82a3e07b30bcaab24e98f7c404daa37e8fe01a5f", "filename": "gcc/config/gnu-user.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fgnu-user.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fgnu-user.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu-user.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -125,7 +125,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n /* Link -lasan early on the command line.  For -static-libasan, don't link\n    it for -shared link, the executable should be compiled with -static-libasan\n-   in that case, and for executable link link with --{,no-}whole-archive around\n+   in that case, and for executable link with --{,no-}whole-archive around\n    it to force everything into the executable.  And similarly for -ltsan\n    and -llsan.  */\n #if defined(HAVE_LD_STATIC_DYNAMIC)"}, {"sha": "94f850a86820e44679563da74eb703015da7548f", "filename": "gcc/config/h8300/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -45,7 +45,7 @@\n ;;     before reload so that register allocator will pick the second\n ;;     alternative.\n \n-;;   - we would like 'D' to be be NO_REGS when the frame pointer isn't\n+;;   - we would like 'D' to be NO_REGS when the frame pointer isn't\n ;;     live, but we the frame pointer may turn out to be needed after\n ;;     we start reload, and then we may have already decided we don't\n ;;     have a choice, so we can't do that.  Forcing the register"}, {"sha": "493e68672b906f83385b1056e5c17e6f7ac0a8e4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -5067,7 +5067,7 @@ ix86_valid_target_attribute_tree (tree args,\n \n   /* If the changed options are different from the default, rerun\n      ix86_option_override_internal, and then save the options away.\n-     The string options are are attribute options, and will be undone\n+     The string options are attribute options, and will be undone\n      when we copy the save structure.  */\n   if (opts->x_ix86_isa_flags != def->x_ix86_isa_flags\n       || opts->x_target_flags != def->x_target_flags"}, {"sha": "354532a6f0e0685736c5f4357699fb7f1c67f9bf", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4164,7 +4164,7 @@\n   [(set_attr \"type\" \"fmov\")\n    (set_attr \"mode\" \"<MODE>,XF\")])\n \n-;; %%% This seems bad bad news.\n+;; %%% This seems like bad news.\n ;; This cannot output into an f-reg because there is no way to be sure\n ;; of truncating in that case.  Otherwise this is just like a simple move\n ;; insn.  So we pretend we can output to a reg in order to get better"}, {"sha": "e87cb6802e3920c186042bc696cdea99d9735941", "filename": "gcc/config/iq2000/iq2000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fiq2000%2Fiq2000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -133,7 +133,7 @@\n ;; instruction takes a 28-bit value, but that value is not an offset.\n ;; Instead, it's bitwise-ored with the high-order four bits of the\n ;; instruction in the delay slot, which means it cannot be used to\n-;; cross a 256MB boundary.  We could fall back back on the jr,\n+;; cross a 256MB boundary.  We could fall back on the jr\n ;; instruction which allows full access to the entire address space,\n ;; but we do not do so at present.\n "}, {"sha": "26c2ba8d916239bc1f3f64aa10aa049d7824f797", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -3245,7 +3245,7 @@ mips_legitimize_tls_address (rtx loc)\n \n   model = SYMBOL_REF_TLS_MODEL (loc);\n   /* Only TARGET_ABICALLS code can have more than one module; other\n-     code must be be static and should not use a GOT.  All TLS models\n+     code must be static and should not use a GOT.  All TLS models\n      reduce to local exec in this situation.  */\n   if (!TARGET_ABICALLS)\n     model = TLS_MODEL_LOCAL_EXEC;"}, {"sha": "0b431e73ddc50869cd1db21fcdb495fb031ea937", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1131,7 +1131,7 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n \t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n   /* We need the frame-pointer to be live or the equivalent\n-     expression, so refer to in in the pattern.  We can't use a MEM\n+     expression, so refer to it in the pattern.  We can't use a MEM\n      (that may contain out-of-range offsets in the final expression)\n      for fear that middle-end will legitimize it or replace the address\n      using temporary registers (which are not revived at this point).  */"}, {"sha": "97e0093c603ffe63e3793d71c6a7443c6c273fc7", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -658,7 +658,7 @@ moxie_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n \n /* Define this to return an RTX representing the place where a\n    function returns or receives a value of data type RET_TYPE, a tree\n-   node node representing a data type.  */\n+   node representing a data type.  */\n #undef TARGET_FUNCTION_VALUE\n #define TARGET_FUNCTION_VALUE moxie_function_value\n #undef TARGET_LIBCALL_VALUE"}, {"sha": "3dc1ce8f9624aa3da183d9896a6126fb0c441a93", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1894,7 +1894,7 @@ create_template:\n \n ;; Subroutine call instruction returning no value.\n ;;   operands[0]: It should be a mem RTX whose address is\n-;;                the the address of the function.\n+;;                the address of the function.\n ;;   operands[1]: It is the number of bytes of arguments pushed as a const_int.\n ;;   operands[2]: It is the number of registers used as operands.\n "}, {"sha": "9fd036ff79fcbb6867e05232741e21352e775d27", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -572,7 +572,7 @@ extern rtx hppa_pic_save_rtx (void);\n    The INCOMING field tracks whether this is an \"incoming\" or\n    \"outgoing\" argument.\n    \n-   The INDIRECT field indicates whether this is is an indirect\n+   The INDIRECT field indicates whether this is an indirect\n    call or not.\n    \n    The NARGS_PROTOTYPE field indicates that an argument does not"}, {"sha": "dbcfb9579cbc23a4855c865feaaba8e250eeaf73", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -79,7 +79,7 @@\n #if HAVE_AS_REF\n /* Issue assembly directives that create a reference to the given DWARF table\n    identifier label from the current function section.  This is defined to\n-   ensure we drag frame frame tables associated with needed function bodies in\n+   ensure we drag frame tables associated with needed function bodies in\n    a link with garbage collection activated.  */\n #define ASM_OUTPUT_DWARF_TABLE_REF rs6000_aix_asm_output_dwarf_table_ref\n #endif"}, {"sha": "1518457ad9f1c689120db0cb58aaed3e22e4cff7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -666,7 +666,7 @@ extern int rs6000_vector_align[];\n #define TARGET_DF_SPE\t(TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\t\\\n \t\t\t && !TARGET_FPRS && TARGET_E500_DOUBLE)\n \n-/* Whether SF/DF operations are supported by by the normal floating point unit\n+/* Whether SF/DF operations are supported by the normal floating point unit\n    (or the vector/scalar unit).  */\n #define TARGET_SF_FPR\t(TARGET_HARD_FLOAT && TARGET_FPRS\t\t\\\n \t\t\t && TARGET_SINGLE_FLOAT)"}, {"sha": "19600bc70474529f1110515d9ad77dddc3c83886", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -9023,7 +9023,7 @@ sh_round_reg (const CUMULATIVE_ARGS& cum, machine_mode mode)\n     : cum.arg_count[(int) GET_SH_ARG_CLASS (mode)]);\n }\n \n-/* Return true if arg of the specified mode should be be passed in a register\n+/* Return true if arg of the specified mode should be passed in a register\n    or false otherwise.  */\n static bool\n sh_pass_in_reg_p (const CUMULATIVE_ARGS& cum, machine_mode mode,"}, {"sha": "75322e167219ad7427c5ce453e8b00eed82ee747", "filename": "gcc/config/tilegx/tilegx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ftilegx%2Ftilegx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.md?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -904,7 +904,7 @@\n ;; Addresses\n ;;\n \n-;; The next three patterns are used to to materialize a position\n+;; The next three patterns are used to materialize a position\n ;; independent address by adding the difference of two labels to a base\n ;; label in the text segment, assuming that the difference fits in 32\n ;; signed bits.\n@@ -964,7 +964,7 @@\n   \"%1 = . + 8\\n\\tlnk\\t%0\"\n   [(set_attr \"type\" \"Y1\")])\n \n-;; The next three patterns are used to to materialize a position\n+;; The next three patterns are used to materialize a position\n ;; independent address by adding the difference of two labels to a\n ;; base label in the text segment, assuming that the difference fits\n ;; in 32 signed bits.\n@@ -997,7 +997,7 @@\n   \"flag_pic\"\n   \"add<x>\\t%0, %r1, %r2\")\n \n-;; The next three patterns are used to to materialize a position\n+;; The next three patterns are used to materialize a position\n ;; independent 64-bit address by adding the difference of two labels to\n ;; a base label in the text segment, without any limitation on the size\n ;; of the difference."}, {"sha": "758aa08759c9591b7ddc2ccddcf88b8b3e4260ed", "filename": "gcc/config/tilepro/gen-mul-tables.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Fgen-mul-tables.cc?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -22,7 +22,7 @@\n    efficiently.\n \n    This program should be compiled by a c++ compiler.  If it's\n-   compiled with with -DTILEPRO, it generates the multiply table for\n+   compiled with -DTILEPRO, it generates the multiply table for\n    TILEPro; otherwise it generates the multiply table for TILE-Gx.\n    Running the program produces the table in stdout.\n "}, {"sha": "a33b649187639183f2a01775f570aa259d60e6eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,12 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* call.c: Fix double word typos.\n+\t* cp-array-notation.c: Same.\n+\t* cp-tree.h: Same.\n+\t* init.c: Same.\n+\t* name-lookup.c: Same.\n+\t* parser.c: Same.\n+\n 2015-07-10  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/30044"}, {"sha": "fce42da41269ef47ea8683e5ddcc35cfe197cd91", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1519,7 +1519,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n     tfrom = unlowered_expr_type (expr);\n \n   /* Figure out whether or not the types are reference-related and\n-     reference compatible.  We have do do this after stripping\n+     reference compatible.  We have to do this after stripping\n      references from FROM.  */\n   related_p = reference_related_p (to, tfrom);\n   /* If this is a C cast, first convert to an appropriately qualified\n@@ -5395,7 +5395,7 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n      only non-member functions that have type T1 or reference to\n      cv-qualified-opt T1 for the first argument, if the first argument\n      has an enumeration type, or T2 or reference to cv-qualified-opt\n-     T2 for the second argument, if the the second argument has an\n+     T2 for the second argument, if the second argument has an\n      enumeration type.  Filter out those that don't match.  */\n   else if (! arg2 || ! CLASS_TYPE_P (TREE_TYPE (arg2)))\n     {"}, {"sha": "2b7d4164379a64c83cf3ae68b779f9c01b99b6d0", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -196,7 +196,7 @@ replace_invariant_exprs (tree *node)\n \n /* Replace array notation's built-in function passed in AN_BUILTIN_FN with\n    the appropriate loop and computation (all stored in variable LOOP of type\n-   tree node).  The output of the function function is always a scalar and that\n+   tree node).  The output of the function is always a scalar and that\n    result is returned in *NEW_VAR.  *NEW_VAR is NULL_TREE if the function is\n    __sec_reduce_mutating.  */\n "}, {"sha": "63fd6e9fc7782cc21f4098da3b3c57310f65cdde", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -5042,7 +5042,7 @@ struct cp_parameter_declarator {\n   cp_declarator *declarator;\n   /* The default-argument expression, or NULL_TREE, if none.  */\n   tree default_argument;\n-  /* True iff this is is a template parameter pack.  */\n+  /* True iff this is a template parameter pack.  */\n   bool template_parameter_pack_p;\n };\n "}, {"sha": "01194d6d499f89a1f8aed8ff33dac5ede4f09e73", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -321,7 +321,7 @@ build_value_init (tree type, tsubst_flags_t complain)\n \n      - if T is a class type (clause 9) with either no default constructor\n        (12.1) or a default constructor that is user-provided or deleted,\n-       then then the object is default-initialized;\n+       then the object is default-initialized;\n \n      - if T is a (possibly cv-qualified) class type without a user-provided\n        or deleted default constructor, then the object is zero-initialized"}, {"sha": "a98788320c3c8de2c62e619e9ecc2e4b9dd83cdd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4158,7 +4158,7 @@ merge_functions (tree s1, tree s2)\n \t  /* If the function from S2 is already in S1, there is no\n \t     need to add it again.  For `extern \"C\"' functions, we\n \t     might have two FUNCTION_DECLs for the same function, in\n-\t     different namespaces, but let's leave them in in case\n+\t     different namespaces, but let's leave them in case\n \t     they have different default arguments.  */\n \t  if (fn1 == fn2)\n \t    break;"}, {"sha": "f4e1ee11c7b06a6e86905d205c994c02904373ab", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -18364,7 +18364,7 @@ parsing_nsdmi (void)\n \n    Returns the type indicated by the type-id.\n \n-   In addition to this this parses any queued up omp declare simd\n+   In addition to this, parse any queued up omp declare simd\n    clauses and Cilk Plus SIMD-enabled function's vector attributes.\n \n    QUALS is either a bitmask of cv_qualifiers or -1 for a non-member\n@@ -22426,8 +22426,7 @@ cp_parser_std_attribute (cp_parser *parser)\n   tree attribute, attr_ns = NULL_TREE, attr_id = NULL_TREE, arguments;\n   cp_token *token;\n \n-  /* First, parse name of the the attribute, a.k.a\n-     attribute-token.  */\n+  /* First, parse name of the attribute, a.k.a attribute-token.  */\n \n   token = cp_lexer_peek_token (parser->lexer);\n   if (token->type == CPP_NAME)"}, {"sha": "1c14d83eb89b5c643eb8f2b1730433c2ca163eed", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -3059,7 +3059,7 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n       if (x == 0)\n \tbreak;\n \n-      /* If we need to reverse the comparison, make sure that that is\n+      /* If we need to reverse the comparison, make sure that is\n \t possible -- we can't necessarily infer the value of GE from LT\n \t with floating-point operands.  */\n       if (reverse_code)\n@@ -4303,7 +4303,7 @@ find_sets_in_insn (rtx_insn *insn, struct set **psets)\n }\n \f\n /* Where possible, substitute every register reference in the N_SETS\n-   number of SETS in INSN with the the canonical register.\n+   number of SETS in INSN with the canonical register.\n \n    Register canonicalization propagatest the earliest register (i.e.\n    one that is set before INSN) with the same value.  This is a very"}, {"sha": "a55d1025f9c9a35ae97c7b0e31f28bbe5ce6ca41", "filename": "gcc/dbxout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -2409,8 +2409,8 @@ dbxout_type_name (tree type)\n   stabstr_I (t);\n }\n \n-/* Output leading leading struct or class names needed for qualifying\n-   type whose scope is limited to a struct or class.  */\n+/* Output leading struct or class names needed for qualifying type\n+   whose scope is limited to a struct or class.  */\n \n static void\n dbxout_class_name_qualifiers (tree decl)"}, {"sha": "22ab269d9bc0c2c13f442b1d00604b763094b82c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -14033,7 +14033,7 @@ If @var{device} is not a device but only a core architecture like\n The device / architecture belongs to the XMEGA family of devices.\n \n @item __AVR_HAVE_ELPM__\n-The device has the the @code{ELPM} instruction.\n+The device has the @code{ELPM} instruction.\n \n @item __AVR_HAVE_ELPMX__\n The device has the @code{ELPM R@var{n},Z} and @code{ELPM"}, {"sha": "339fb2df2736303158464c3f907ae953c805a77d", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -75,7 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n    frame_pointer.\n \n    * The third technique, (which is only done after register allocation)\n-   processes the spill spill slots.  This differs from the second\n+   processes the spill slots.  This differs from the second\n    technique because it takes advantage of the fact that spilling is\n    completely free from the effects of aliasing.\n "}, {"sha": "2834d571bb9c23132050cd253174ec9ecf928b81", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -25166,8 +25166,8 @@ dwarf2out_finish (const char *filename)\n   if (flag_eliminate_dwarf2_dups)\n     break_out_includes (comp_unit_die ());\n \n-  /* Traverse the DIE's and add add sibling attributes to those DIE's\n-     that have children.  */\n+  /* Traverse the DIE's and add sibling attributes to those DIE's that\n+     have children.  */\n   add_sibling_attributes (comp_unit_die ());\n   limbo_die_node *node;\n   for (node = limbo_die_list; node; node = node->next)\n@@ -25445,7 +25445,7 @@ dwarf2out_early_finish (void)\n       tree decl = node->created_for;\n       if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl)\n \t  /* A missing DECL_ASSEMBLER_NAME can be a constant DIE that\n-\t     ended up in in deferred_asm_name before we knew it was\n+\t     ended up in deferred_asm_name before we knew it was\n \t     constant and never written to disk.  */\n \t  && DECL_ASSEMBLER_NAME (decl))\n \t{"}, {"sha": "5d91609396dfbc839a769164c4594be4717d33e6", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4745,7 +4745,7 @@ make_pass_clean_state (gcc::context *ctxt)\n   return new pass_clean_state (ctxt);\n }\n \n-/* Return true if INSN is a call to the the current function.  */\n+/* Return true if INSN is a call to the current function.  */\n \n static bool\n self_recursive_call_p (rtx_insn *insn)"}, {"sha": "6fad33241df5598696aa602bc30c40c7d6836c24", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,7 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans-stmt.c: Fix double word typos.\n+\n 2015-07-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* arith.c: Adjust includes for flags.h changes."}, {"sha": "6409f7f96e7283ec182c23012c0cf16c2aad38cb", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1471,7 +1471,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t      tmp = gfc_class_len_get (target_expr);\n \t      /* Get the component-ref for the temp structure's _len comp.  */\n \t      charlen = gfc_class_len_get (se.expr);\n-\t      /* Add the assign to the beginning of the the block...  */\n+\t      /* Add the assign to the beginning of the block...  */\n \t      gfc_add_modify (&se.pre, charlen,\n \t\t\t      fold_convert (TREE_TYPE (charlen), tmp));\n \t      /* and the oposite way at the end of the block, to hand changes"}, {"sha": "858ff370103f42cade829f7401118989c701ee49", "filename": "gcc/gcc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -339,7 +339,7 @@ or with constant text in a single argument.\n         it is subsequently output with %*. SUFFIX is terminated by the next\n         space or %.\n  %d\tmarks the argument containing or following the %d as a\n-\ttemporary file name, so that that file will be deleted if GCC exits\n+\ttemporary file name, so that file will be deleted if GCC exits\n \tsuccessfully.  Unlike %g, this contributes no text to the argument.\n  %w\tmarks the argument containing or following the %w as the\n \t\"output file\" of this compilation.  This puts the argument\n@@ -3393,7 +3393,7 @@ driver_unknown_option_callback (const struct cl_decoded_option *decoded)\n     }\n   if (decoded->opt_index == OPT_SPECIAL_unknown)\n     {\n-      /* Give it a chance to define it a a spec file.  */\n+      /* Give it a chance to define it a spec file.  */\n       save_switch (decoded->canonical_option[0],\n \t\t   decoded->canonical_option_num_elements - 1,\n \t\t   &decoded->canonical_option[1], false, false);\n@@ -7466,7 +7466,7 @@ driver::maybe_print_and_exit () const\n     {\n       if (use_ld != NULL && ! strcmp (print_prog_name, \"ld\"))\n \t{\n-\t  /* Append USE_LD to to the default linker.  */\n+\t  /* Append USE_LD to the default linker.  */\n #ifdef DEFAULT_LINKER\n \t  char *ld;\n # ifdef HAVE_HOST_EXECUTABLE_SUFFIX"}, {"sha": "baa244cc676b0e95f0ca024d17b3278907e1ca9a", "filename": "gcc/genmatch.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1645,8 +1645,7 @@ capture_info::walk_result (operand *o, bool conditional_p)\n \t expression side-effect free.  */\n       if (info[c->where].expr_p)\n \tforce_no_side_effects |= info[c->where].toplevel_msk;\n-      /* Mark CSE capture capture uses as forced to have\n-         no side-effects. */\n+      /* Mark CSE capture uses as forced to have no side-effects. */\n       if (c->what\n \t  && is_a <expr *> (c->what))\n \t{\n@@ -3430,7 +3429,7 @@ parser::push_simplify (vec<simplify *>& simplifiers,\n \t\t       operand *match, source_location match_loc,\n \t\t       operand *result, source_location result_loc)\n {\n-  /* Build and push a temporary for for operator list uses in expressions.  */\n+  /* Build and push a temporary for operator list uses in expressions.  */\n   if (!oper_lists.is_empty ())\n     active_fors.safe_push (oper_lists);\n "}, {"sha": "b0b14455c8ad4dafd2665bd02959ded2b51bbd91", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4627,7 +4627,7 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n     return ret;\n \n   /* In case of va_arg internal fn wrappped in a WITH_SIZE_EXPR, add the type\n-     size as argument to the the call.  */\n+     size as argument to the call.  */\n   if (TREE_CODE (*from_p) == WITH_SIZE_EXPR)\n     {\n       tree call = TREE_OPERAND (*from_p, 0);"}, {"sha": "b95aeb3d5fe4a4f4c53918c5ffce03a226ce4710", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,9 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gofrontend/backend.h: Fix double word typos.\n+        * gofrontend/expressions.cc: Same.\n+\t* gospec.c: Same.\n+\n 2015-07-07  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* go-backend.c: Adjust includes."}, {"sha": "5593fcb47062e5e0fc4beb52d527bb41b35ecc7b", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -658,7 +658,7 @@ class Backend\n   \n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n-  // where the the label is defined.\n+  // where the label is defined.\n   virtual Blabel*\n   label(Bfunction*, const std::string& name, Location) = 0;\n "}, {"sha": "c9ba98844892e04371d2927f0cdf6a52249cc835", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -2475,7 +2475,7 @@ Complex_expression::do_get_backend(Translate_context* context)\n     }\n   else\n     {\n-      // If we still have an abstract type here, this this is being\n+      // If we still have an abstract type here, this is being\n       // used in a constant expression which didn't get reduced.  We\n       // just use complex128 and hope for the best.\n       resolved_type = Type::lookup_complex_type(\"complex128\");"}, {"sha": "9ccbe75df4453b08fcf8660d2824bb1d72fa6dac", "filename": "gcc/go/gospec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgospec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fgo%2Fgospec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgospec.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -386,7 +386,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n      relative ordering of -lpthread and -lgcc, we can't just mark\n      __real_pthread_create in libgcc as non-weak.  But we need to link in\n      pthread_create from pthread if we are statically linking, so we work-\n-     around by passing -u pthread_create to to the linker. */\n+     around by passing -u pthread_create to the linker. */\n   if (static_link)\n     {\n       generate_option (OPT_Wl_, \"-u,pthread_create\", 1, CL_DRIVER,"}, {"sha": "8e3c2caa6845f235fd546f27f6e06bbf73f7f719", "filename": "gcc/hash-table.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -163,7 +163,7 @@ along with GCC; see the file COPYING3.  If not see\n    There is no need to mention some_type directly, as the hash table will\n    obtain it using some_type_hasher::value_type.\n \n-   You can then used any of the functions in hash_table's public interface.\n+   You can then use any of the functions in hash_table's public interface.\n    See hash_table for details.  The interface is very similar to libiberty's\n    htab_t.\n "}, {"sha": "e7859460708b12a3835ca0e7062c651050244be7", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1402,7 +1402,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  emit_label (one_small_one_large);\n \n \t  /* lopart is the low part of the operand that is sign extended\n-\t     to mode, larger is the the other operand, hipart is the\n+\t     to mode, larger is the other operand, hipart is the\n \t     high part of larger and lopart0 and lopart1 are the low parts\n \t     of both operands.\n \t     We perform lopart0 * lopart1 and lopart * hipart widening"}, {"sha": "60a60ce268c342b9d620ac2eca13eba19e7484a2", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -250,7 +250,7 @@ class ipcp_param_lattices\n public:\n   /* Lattice describing the value of the parameter itself.  */\n   ipcp_lattice<tree> itself;\n-  /* Lattice describing the the polymorphic contexts of a parameter.  */\n+  /* Lattice describing the polymorphic contexts of a parameter.  */\n   ipcp_lattice<ipa_polymorphic_call_context> ctxlat;\n   /* Lattices describing aggregate parts.  */\n   ipcp_agg_lattice *aggs;\n@@ -1213,7 +1213,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n   if (values_count == PARAM_VALUE (PARAM_IPA_CP_VALUE_LIST_SIZE))\n     {\n       /* We can only free sources, not the values themselves, because sources\n-\t of other values in this this SCC might point to them.   */\n+\t of other values in this SCC might point to them.   */\n       for (val = values; val; val = val->next)\n \t{\n \t  while (val->sources)\n@@ -3959,7 +3959,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n /* Given an original NODE and a VAL for which we have already created a\n    specialized clone, look whether there are incoming edges that still lead\n    into the old node but now also bring the requested value and also conform to\n-   all other criteria such that they can be redirected the the special node.\n+   all other criteria such that they can be redirected the special node.\n    This function can therefore redirect the final edge in a SCC.  */\n \n template <typename valtype>"}, {"sha": "49cb65b0d19fbc98512225946f9b1ceafc0f81a6", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1005,7 +1005,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t\t  inform (DECL_SOURCE_LOCATION\n \t\t\t   (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t\t  \"the conflicting type defined in another translation \"\n-\t\t\t  \"unit has virtual table table with more entries\");\n+\t\t\t  \"unit has virtual table with more entries\");\n \t\t}\n \t    }\n \t  return;\n@@ -1037,7 +1037,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t    inform (DECL_SOURCE_LOCATION\n \t\t      (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t    \"the conflicting type defined in another translation \"\n-\t\t    \"unit has virtual table table with different contents\");\n+\t\t    \"unit has virtual table with different contents\");\n \t  return;\n \t}\n     }"}, {"sha": "13a93200f80c9fbd777779bd09298f176f1b73a4", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -2404,7 +2404,7 @@ sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n   lto_data_in_delete (data_in);\n }\n \n-/* Read IPA IPA ICF summary for symbols.  */\n+/* Read IPA ICF summary for symbols.  */\n \n void\n sem_item_optimizer::read_summary (void)"}, {"sha": "6428f25bea3ef5d588c3c80fe3a53bb85e2f67a3", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -484,7 +484,7 @@ class sem_item_optimizer\n   /* Write IPA ICF summary for symbols.  */\n   void write_summary (void);\n \n-  /* Read IPA IPA ICF summary for symbols.  */\n+  /* Read IPA ICF summary for symbols.  */\n   void read_summary (void);\n \n   /* Callgraph removal hook called for a NODE with a custom DATA.  */"}, {"sha": "82912669321839827bf8e31e8b3026406337535f", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n      of inliner. \n    - Finally we propagate the following flags: unlikely executed, executed\n      once, executed at startup and executed at exit.  These flags are used to\n-     control code size/performance threshold and and code placement (by producing\n+     control code size/performance threshold and code placement (by producing\n      .text.unlikely/.text.hot/.text.startup/.text.exit subsections).  */\n #include \"config.h\"\n #include \"system.h\""}, {"sha": "29178d4046f9dd57297684eb0353e43d835cc78b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -673,7 +673,7 @@ param_type_may_change_p (tree function, tree arg, gimple call)\n       /* Normal (non-THIS) argument.  */\n       if ((SSA_NAME_VAR (arg) != DECL_ARGUMENTS (function)\n \t   || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE)\n-\t  /* THIS pointer of an method - here we we want to watch constructors\n+\t  /* THIS pointer of an method - here we want to watch constructors\n \t     and destructors as those definitely may change the dynamic\n \t     type.  */\n \t  || (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE\n@@ -2330,7 +2330,7 @@ analysis_dom_walker::before_dom_children (basic_block bb)\n   ipa_compute_jump_functions_for_bb (m_fbi, bb);\n }\n \n-/* Initialize the array describing properties of of formal parameters\n+/* Initialize the array describing properties of formal parameters\n    of NODE, analyze their uses and compute jump functions associated\n    with actual arguments of calls from within NODE.  */\n "}, {"sha": "c4958948e8656e162cf949c48083ef98744aeea6", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n    IPA_JF_ANCESTOR is a special pass-through jump function, which means that\n    the result is an address of a part of the object pointed to by the formal\n    parameter to which the function refers.  It is mainly intended to represent\n-   getting addresses of of ancestor fields in C++\n+   getting addresses of ancestor fields in C++\n    (e.g. &this_1(D)->D.1766.D.1756).  Note that if the original pointer is\n    NULL, ancestor jump function must behave like a simple pass-through.\n "}, {"sha": "23ed1dbcd3992aa6fe4588744ced4b635780b360", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4360,7 +4360,7 @@ rtx_moveable_p (rtx *loc, enum op_type type)\n       return rtx_moveable_p (&SET_DEST (x), OP_OUT);\n \n     case UNSPEC_VOLATILE:\n-      /* It is a bad idea to consider insns with with such rtl\n+      /* It is a bad idea to consider insns with such rtl\n \t as moveable ones.  The insn scheduler also considers them as barrier\n \t for a reason.  */\n       return false;"}, {"sha": "c64d3c9e97b26d880a9a6a7eb75c1187db8fbb88", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,9 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* class.c: Fix double word typos.\n+\t* java-except.h: Same.\n+\t* jcf-reader.c: Same.\n+\n 2015-07-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* java-gimplify.c: Include cfghooks.h rather than predict.h."}, {"sha": "9e6b45c4467183d6b516ac0724761dbcdfdd52c3", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1045,7 +1045,7 @@ build_static_class_ref (tree type)\n       DECL_CONTEXT (decl) = type;\n \n       /* ??? We want to preserve the DECL_CONTEXT we set just above,\n-\t that that means not calling pushdecl_top_level.  */\n+\t that means not calling pushdecl_top_level.  */\n       IDENTIFIER_GLOBAL_VALUE (decl_name) = decl;\n     }\n "}, {"sha": "c471c1dc15eb8103b5073a7e728dde0943488f88", "filename": "gcc/java/java-except.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -36,7 +36,7 @@ struct eh_range\n     /* Surrounding handler, if any. */\n     struct eh_range *outer;\n \n-    /* The first child range.  It is is nested inside this range\n+    /* The first child range.  It is nested inside this range\n        (i.e. this.start_pc <= first_child.end_pc\n        && this.end_pc >= first_child.end_pc).\n        The children are linked together using next_sibling, and are sorted"}, {"sha": "f18161f840fe3878f783087dd9af7baf7ebff080", "filename": "gcc/java/jcf-reader.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fjcf-reader.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjava%2Fjcf-reader.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-reader.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -352,7 +352,7 @@ jcf_parse_constant_pool (JCF* jcf)\n        \n       /* Make sure at least 9 bytes are available.  This is enough\n \t for all fixed-sized constant pool entries (so we don't need many\n-\t more JCF_FILL calls below), but is is small enough that\n+\t more JCF_FILL calls below), but is small enough that\n \t we are guaranteed to not hit EOF (in a valid .class file). */\n       JCF_FILL (jcf, 9);\n       constant_kind = JCF_readu (jcf);"}, {"sha": "8d0c210a55636ce7a50d6980c1901fdf302cc608", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -2657,7 +2657,7 @@ location_comparator (const void *lhs, const void *rhs)\n    linemap API requires locations to be created in ascending order\n    as if we were tokenizing files.\n \n-   This hook sorts all of the the locations that have been created, and\n+   This hook sorts all of the locations that have been created, and\n    calls into the linemap API, creating linemap entries in sorted order\n    for our locations.  */\n "}, {"sha": "d888b0e52c89f41ba23961cb96fe3be084a30a0b", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -850,7 +850,7 @@ recording::context::new_function_ptr_type (recording::location *, /* unused loc\n \t\t\t param_types,\n \t\t\t is_variadic);\n \n-  /* Return a pointer-type to the the function type.  */\n+  /* Return a pointer-type to the function type.  */\n   return fn_type->get_pointer ();\n }\n "}, {"sha": "97f12f681cd70e12e19078009226c39cdd5aacd0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,7 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* lto-lang.c: Fix double word typos.\n+\n 2015-07-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* lto.c: Include cfghooks.h rather than predict.h."}, {"sha": "6d6a8538a8f70c83bec1c2334bd5454e028892b3", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1214,7 +1214,7 @@ lto_init (void)\n     main_identifier_node = get_identifier (\"main\");\n \n   /* In the C++ front-end, fileptr_type_node is defined as a variant\n-     copy of of ptr_type_node, rather than ptr_node itself.  The\n+     copy of ptr_type_node, rather than ptr_node itself.  The\n      distinction should only be relevant to the front-end, so we\n      always use the C definition here in lto1.  */\n   gcc_assert (fileptr_type_node == ptr_type_node);"}, {"sha": "62590fb5f39802a6fc1a44eea8cbe2e8cc75dc88", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,7 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objc-map.h: Fix double word typos.\n+\n 2015-07-07  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* objc-act.c: Adjust includes."}, {"sha": "76972a546aba5e4e3870698056ebc1ba4c7db624", "filename": "gcc/objc/objc-map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fobjc%2Fobjc-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fobjc%2Fobjc-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-map.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -73,7 +73,7 @@ struct GTY(()) objc_map_private {\n   /* These are the keys.  */\n   tree * GTY ((length (\"%h.number_of_slots\"))) slots;\n \n-  /* These are the values.  values[i] is the the value corresponding\n+  /* These are the values.  values[i] is the value corresponding\n      to slots[i].  */\n   tree * GTY ((length (\"%h.number_of_slots\"))) values;\n };"}, {"sha": "22848a0a324d0d414bb537142be07c84994f0be0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -10579,7 +10579,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   block = make_node (BLOCK);\n   new_stmt = gimple_build_bind (NULL, NULL, block);\n   /* Replace at gsi right away, so that 'stmt' is no member\n-     of a sequence anymore as we're going to add to to a different\n+     of a sequence anymore as we're going to add to a different\n      one below.  */\n   gsi_replace (gsi_p, new_stmt, true);\n "}, {"sha": "3944041d0df66b6f368532f0e5f9915ba9f07eca", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -2417,7 +2417,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \n   /* If the destination block's stack already has a specified layout\n      and contains two or more registers, use a more intelligent algorithm\n-     to pop registers that minimizes the number number of fxchs below.  */\n+     to pop registers that minimizes the number of fxchs below.  */\n   if (new_stack->top > 0)\n     {\n       bool slots[REG_STACK_SIZE];"}, {"sha": "627c630d05e7f8cae58011b31da619b54666023b", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -352,7 +352,7 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n      we must not do the same for the high part.\n      Note we can still get low parts for the same mode combination through\n      a two-step copy involving differently sized hard regs.\n-     Assume hard regs fr* are 32 bits bits each, while r* are 64 bits each:\n+     Assume hard regs fr* are 32 bits each, while r* are 64 bits each:\n      (set (reg:DI r0) (reg:DI fr0))\n      (set (reg:SI fr2) (reg:SI r0))\n      loads the low part of (reg:DI fr0) - i.e. fr1 - into fr2, while:"}, {"sha": "1c60e13167e74bd9bdf7988c2ed371a1df5acf57", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1397,12 +1397,12 @@ try_merge_delay_insns (rtx_insn *insn, rtx_insn *thread)\n \t  rtx_insn *dtrial = pat->insn (i);\n \n \t  CLEAR_RESOURCE (&modified);\n-\t  /* Account for resources set by the the insn following NEXT_TO_MATCH\n+\t  /* Account for resources set by the insn following NEXT_TO_MATCH\n \t     inside INSN's delay list. */\n \t  for (j = 1; slot_number + j < num_slots; j++)\n \t    mark_set_resources (XVECEXP (PATTERN (insn), 0, slot_number + j),\n \t\t\t\t&modified, 0, MARK_SRC_DEST_CALL);\n-\t  /* Account for resources set by the the insn before DTRIAL and inside\n+\t  /* Account for resources set by the insn before DTRIAL and inside\n \t     TRIAL's delay list. */\n \t  for (j = 1; j < i; j++)\n \t    mark_set_resources (XVECEXP (pat, 0, j),"}, {"sha": "68d0f2a5cf810b676f7f016207400f9162fa6c2e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -287,7 +287,7 @@ struct GTY((variable_size)) hwivec_def {\n /* RTL expression (\"rtx\").  */\n \n /* The GTY \"desc\" and \"tag\" options below are a kludge: we need a desc\n-   field for for gengtype to recognize that inheritance is occurring,\n+   field for gengtype to recognize that inheritance is occurring,\n    so that all subclasses are redirected to the traversal hook for the\n    base class.\n    However, all of the fields are in the base class, and special-casing"}, {"sha": "926bf5d72947511791c2032d5d3e5a6e8c018fdb", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -52,7 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n      * set_disjuction\t\t: (not implemented)\n      * set_compare\t\t: bitmap_equal_p\n \n-   Some operations on 3 sets that occur frequently in in data flow problems\n+   Some operations on 3 sets that occur frequently in data flow problems\n    are also implemented:\n \n       * A | (B & C)\t\t: bitmap_or_and"}, {"sha": "baf3c914101050a33b0c425ac0a0fc52bc791cdc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,3 +1,8 @@\n+2015-07-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc.dg/20020219-1.c: Fix double word typos.\n+\t* gcc.dg/20020919-1.c: Same.\n+\n 2015-07-12  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \t    Jeff Law  <law@redhat.com>\n "}, {"sha": "839011fc0440af47c9ef5f8962a710521eccec1a", "filename": "gcc/testsuite/gcc.dg/20020219-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2Fgcc.dg%2F20020219-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2Fgcc.dg%2F20020219-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020219-1.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1,6 +1,6 @@\n /* PR c/4389\n    This testcase failed because host_integerp (x, 0) was returning\n-   1 even for constants bigger than 2^31.  It fails under under hppa\n+   1 even for constants bigger than 2^31.  It fails under hppa\n    hpux without -mdisable-indexing because the pointer x - 1 is used\n    as the base address of an indexed load.  Because the struct A is not\n    actually allocated, x - 1 lies in the text segment and this causes"}, {"sha": "1dcf75e8ff6279aebee4ad0e150c1599dac1aa49", "filename": "gcc/testsuite/gcc.dg/20020919-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2Fgcc.dg%2F20020919-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftestsuite%2Fgcc.dg%2F20020919-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020919-1.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -14,7 +14,7 @@\n /* Constructed examples; input/output (same register), output, input, and\n    input and output (different registers).  */\n \n-/* The long longs are used to test overlap overlap for multi-register\n+/* The long longs are used to test overlap for multi-register\n    registers.  REG2 and REG4 must be the second halves (defined as\n    higher-numbered parts) of REG1 and REG3 respectively when two registers\n    are needed.  */"}, {"sha": "c1ca468fa252aa177a3af31b0425c86099f16e89", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -325,7 +325,7 @@ static gimple_seq eh_seq;\n    indexed by EH region number.  */\n static bitmap eh_region_may_contain_throw_map;\n \n-/* The GOTO_QUEUE is is an array of GIMPLE_GOTO and GIMPLE_RETURN\n+/* The GOTO_QUEUE is an array of GIMPLE_GOTO and GIMPLE_RETURN\n    statements that are seen to escape this GIMPLE_TRY_FINALLY node.\n    The idea is to record a gimple statement for everything except for\n    the conditionals, which get their labels recorded. Since labels are"}, {"sha": "374b2463b7398eb531e33a19ac7f94ff9c0e2fa4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4551,7 +4551,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n   id->call_stmt = stmt;\n \n-  /* If the the src function contains an IFN_VA_ARG, then so will the dst\n+  /* If the src function contains an IFN_VA_ARG, then so will the dst\n      function after inlining.  */\n   if ((id->src_cfun->curr_properties & PROP_gimple_lva) == 0)\n     {"}, {"sha": "7444c905a8d9a339b57f914ed73033c8d0167052", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1011,7 +1011,7 @@ completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset,\n }\n \n /* Create total_scalarization accesses for all scalar type fields in VAR and\n-   for VAR a a whole.  VAR must be of a RECORD_TYPE conforming to\n+   for VAR as a whole.  VAR must be of a RECORD_TYPE conforming to\n    type_consists_of_records_p.   */\n \n static void"}, {"sha": "b5ad2c488f91963d0ccf74053ad8d02453771a0f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -401,10 +401,10 @@ initialize_hash_element_from_expr (struct hashable_expr *expr,\n   element->stamp = element;\n }\n \n-/* Compare two hashable_expr structures for equivalence.\n-   They are considered equivalent when the the expressions\n-   they denote must necessarily be equal.  The logic is intended\n-   to follow that of operand_equal_p in fold-const.c  */\n+/* Compare two hashable_expr structures for equivalence.  They are\n+   considered equivalent when the expressions they denote must\n+   necessarily be equal.  The logic is intended to follow that of\n+   operand_equal_p in fold-const.c */\n \n static bool\n hashable_expr_equal_p (const struct hashable_expr *expr0,"}, {"sha": "67f24c48aa5300e7bffce7fc7888c6a95c258727", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -5096,7 +5096,7 @@ may_eliminate_iv (struct ivopts_data *data,\n }\n \n  /* Calculates the cost of BOUND, if it is a PARM_DECL.  A PARM_DECL must\n-    be copied, if is is used in the loop body and DATA->body_includes_call.  */\n+    be copied, if it is used in the loop body and DATA->body_includes_call.  */\n \n static int\n parm_decl_cost (struct ivopts_data *data, tree bound)"}, {"sha": "a19d938fb5317d77848486b016e9f456553bb68e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -4713,7 +4713,7 @@ find_func_aliases (struct function *fn, gimple origt)\n \t    }\n \t  else if (truth_value_p (code))\n \t    /* Truth value results are not pointer (parts).  Or at least\n-\t       very very unreasonable obfuscation of a part.  */\n+\t       very unreasonable obfuscation of a part.  */\n \t    ;\n \t  else\n \t    {\n@@ -5135,7 +5135,7 @@ first_vi_for_offset (varinfo_t start, unsigned HOST_WIDE_INT offset)\n   while (start)\n     {\n       /* We may not find a variable in the field list with the actual\n-\t offset when when we have glommed a structure to a variable.\n+\t offset when we have glommed a structure to a variable.\n \t In that case, however, offset should still be within the size\n \t of the variable. */\n       if (offset >= start->offset\n@@ -5162,7 +5162,7 @@ first_or_preceding_vi_for_offset (varinfo_t start,\n     start = get_varinfo (start->head);\n \n   /* We may not find a variable in the field list with the actual\n-     offset when when we have glommed a structure to a variable.\n+     offset when we have glommed a structure to a variable.\n      In that case, however, offset should still be within the size\n      of the variable.\n      If we got beyond the offset we look for return the field"}, {"sha": "88a30326dff7685df3ffc8b3ce14f57d8590a1f6", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1240,7 +1240,7 @@ find_duplicate (same_succ same_succ, basic_block bb1, basic_block bb2)\n       gimple stmt1 = gsi_stmt (gsi1);\n       gimple stmt2 = gsi_stmt (gsi2);\n \n-      /* What could be better than to this this here is to blacklist the bb\n+      /* What could be better than this here is to blacklist the bb\n \t containing the stmt, when encountering the stmt f.i. in\n \t same_succ_hash.  */\n       if (is_tm_ending (stmt1)"}, {"sha": "f7ca95bb5af3300c4f858ffb80e00f1c18ae8143", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -125,7 +125,7 @@ along with GCC; see the file COPYING3.  If not see\n    information, but the info in one is not easy to obtain from the other.\n \n    KILL_LIST is yet another bitmap array, this time it is indexed by partition\n-   number, and represents a list of active expressions which will will no\n+   number, and represents a list of active expressions which will no\n    longer be valid if a definition into this partition takes place.\n \n    PARTITION_IN_USE is simply a bitmap which is used to track which partitions"}, {"sha": "31ddf25582ffe44d6652f4b70d43444c7f776bcc", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1366,8 +1366,8 @@ ssa_redirect_edges (struct redirection_data **slot,\n   struct redirection_data *rd = *slot;\n   struct el *next, *el;\n \n-  /* Walk over all the incoming edges associated associated with this\n-     hash table entry.  */\n+  /* Walk over all the incoming edges associated with this hash table\n+     entry.  */\n   for (el = rd->incoming_edges; el; el = next)\n     {\n       edge e = el->e;"}, {"sha": "0ed05e172e9617b15359aa3ba427603d9cd4d023", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -257,7 +257,7 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n /* Checks if the operand OPND of PHI is defined by\n    another phi with one operand defined by this PHI,\n    but the rest operands are all defined. If yes,\n-   returns true to skip this this operand as being\n+   returns true to skip this operand as being\n    redundant. Can be enhanced to be more general.  */\n \n static bool"}, {"sha": "4dd881ae0c40bd5293e5b0c6160aff4f3bfe7e30", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -380,7 +380,7 @@ mark_ptr_info_alignment_unknown (struct ptr_info_def *pi)\n   pi->misalign = 0;\n }\n \n-/* Store the the power-of-two byte alignment and the deviation from that\n+/* Store the power-of-two byte alignment and the deviation from that\n    alignment of pointer described by PI to ALIOGN and MISALIGN\n    respectively.  */\n "}, {"sha": "e2ae17eed8a9f8014eb7efae7df16a2bce38b5a1", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -355,8 +355,8 @@ adjust_phi_and_debug_stmts (gimple update_phi, edge e, tree new_def)\n            next_bb\n \n      The SSA names defined in the original loop have a current\n-     reaching definition that that records the corresponding new\n-     ssa-name used in the new duplicated loop copy.\n+     reaching definition that records the corresponding new ssa-name\n+     used in the new duplicated loop copy.\n   */\n \n /* Function slpeel_update_phi_nodes_for_guard1"}, {"sha": "8b2235c0fa857aebbe701e4fb496e6860d9679e8", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -1136,7 +1136,7 @@ gimple_call_nonnegative_warnv_p (gimple stmt, bool *strict_overflow_p)\n \t\t\t\t\tstrict_overflow_p);\n }\n \n-/* Return true if STMT is know to to compute a non-negative value.\n+/* Return true if STMT is know to compute a non-negative value.\n    If the return value is based on the assumption that signed overflow is\n    undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.*/\n@@ -3437,7 +3437,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n \n /* Extract range information from a unary operation CODE based on\n    the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.\n-   The The resulting range is stored in *VR.  */\n+   The resulting range is stored in *VR.  */\n \n static void\n extract_range_from_unary_expr_1 (value_range_t *vr,\n@@ -8903,7 +8903,7 @@ vrp_visit_phi_node (gphi *phi)\n \t  && (cmp_min != 0 || cmp_max != 0))\n \tgoto varying;\n \n-      /* If the new minimum is larger than than the previous one\n+      /* If the new minimum is larger than the previous one\n \t retain the old value.  If the new minimum value is smaller\n \t than the previous one and not -INF go all the way to -INF + 1.\n \t In the first case, to avoid infinite bouncing between different"}, {"sha": "94263af9a15511fc6812ab28aada2b1f71dc1a6d", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -692,8 +692,8 @@ decl_section_name (const_tree node)\n   return snode->get_section ();\n }\n \n-/* Set section section name of NODE to VALUE (that is expected to\n-   be identifier node)  */\n+/* Set section name of NODE to VALUE (that is expected to be\n+   identifier node) */\n void\n set_decl_section_name (tree node, const char *value)\n {\n@@ -1330,7 +1330,7 @@ force_fit_type (tree type, const wide_int_ref &cst,\n /* These are the hash table functions for the hash table of INTEGER_CST\n    nodes of a sizetype.  */\n \n-/* Return the hash code code X, an INTEGER_CST.  */\n+/* Return the hash code X, an INTEGER_CST.  */\n \n hashval_t\n int_cst_hasher::hash (tree x)\n@@ -10326,7 +10326,7 @@ build_common_builtin_nodes (void)\n   ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   ecf_flags = ECF_PURE | ECF_NOTHROW | ECF_LEAF;\n-  /* Only use TM_PURE if we we have TM language support.  */\n+  /* Only use TM_PURE if we have TM language support.  */\n   if (builtin_decl_explicit_p (BUILT_IN_TM_LOAD_1))\n     ecf_flags |= ECF_TM_PURE;\n   local_define_builtin (\"__builtin_eh_pointer\", ftype, BUILT_IN_EH_POINTER,\n@@ -11723,7 +11723,7 @@ tree_nonartificial_location (tree exp)\n /* These are the hash table functions for the hash table of OPTIMIZATION_NODEq\n    nodes.  */\n \n-/* Return the hash code code X, an OPTIMIZATION_NODE or TARGET_OPTION code.  */\n+/* Return the hash code X, an OPTIMIZATION_NODE or TARGET_OPTION code.  */\n \n hashval_t\n cl_option_hasher::hash (tree x)"}, {"sha": "8236a78570ea215f51fc1765363c4cc1a7bddb9e", "filename": "gcc/valtrack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -277,7 +277,7 @@ dead_debug_global_insert (struct dead_debug_global *global, rtx reg, rtx dtemp)\n }\n \n /* If UREGNO, referenced by USE, is a pseudo marked as used in GLOBAL,\n-   replace it with with a USE of the debug temp recorded for it, and\n+   replace it with a USE of the debug temp recorded for it, and\n    return TRUE.  Otherwise, just return FALSE.\n \n    If PTO_RESCAN is given, instead of rescanning modified INSNs right"}, {"sha": "3e6e882b97046ddb28773fd359712eaa8f16c5a4", "filename": "gcc/vec.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/026c3cfd5e92e7f358290921984b57e1b433e658/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=026c3cfd5e92e7f358290921984b57e1b433e658", "patch": "@@ -269,7 +269,7 @@ struct va_heap\n /* Allocator for heap memory.  Ensure there are at least RESERVE free\n    slots in V.  If EXACT is true, grow exactly, else grow\n    exponentially.  As a special case, if the vector had not been\n-   allocated and and RESERVE is 0, no vector will be created.  */\n+   allocated and RESERVE is 0, no vector will be created.  */\n \n template<typename T>\n inline void\n@@ -344,7 +344,7 @@ va_gc::release (vec<T, A, vl_embed> *&v)\n /* Allocator for GC memory.  Ensure there are at least RESERVE free\n    slots in V.  If EXACT is true, grow exactly, else grow\n    exponentially.  As a special case, if the vector had not been\n-   allocated and and RESERVE is 0, no vector will be created.  */\n+   allocated and RESERVE is 0, no vector will be created.  */\n \n template<typename T, typename A>\n void"}]}