{"sha": "188538df24e0fb2129a05830b85f17d53d7a418f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg4NTM4ZGYyNGUwZmIyMTI5YTA1ODMwYjg1ZjE3ZDUzZDdhNDE4Zg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-04-10T22:36:23Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-04-10T22:36:23Z"}, "message": "Initial revision\n\nFrom-SVN: r724", "tree": {"sha": "e47d6f475fc4cd239758381a51926b5d36458a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e47d6f475fc4cd239758381a51926b5d36458a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/188538df24e0fb2129a05830b85f17d53d7a418f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/188538df24e0fb2129a05830b85f17d53d7a418f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/188538df24e0fb2129a05830b85f17d53d7a418f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/188538df24e0fb2129a05830b85f17d53d7a418f/comments", "author": null, "committer": null, "parents": [{"sha": "ebf9e246d18d01ac24d55fade4f199a7c43ade64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf9e246d18d01ac24d55fade4f199a7c43ade64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf9e246d18d01ac24d55fade4f199a7c43ade64"}], "stats": {"total": 2399, "additions": 2399, "deletions": 0}, "files": [{"sha": "e8d3224617879882cf13c656f2e1781e6c365e99", "filename": "gcc/config/pa/pa.c", "status": "added", "additions": 2399, "deletions": 0, "changes": 2399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/188538df24e0fb2129a05830b85f17d53d7a418f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/188538df24e0fb2129a05830b85f17d53d7a418f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=188538df24e0fb2129a05830b85f17d53d7a418f", "patch": "@@ -0,0 +1,2399 @@\n+/* Subroutines for insn-output.c for HPPA.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"expr.h\"\n+\n+/* Save the operands last given to a compare for use when we\n+   generate a scc or bcc insn.  */\n+\n+rtx hppa_compare_op0, hppa_compare_op1;\n+enum cmp_type hppa_branch_type;\n+\n+/* Set by the FUNCTION_PROFILER macro. */\n+int hp_profile_labelno;\n+\n+/* Global variables set by FUNCTION_PROLOGUE.  */\n+/* Size of frame.  Need to know this to emit return insns from\n+   leaf procedures.  */\n+int apparent_fsize;\n+int actual_fsize;\n+int local_fsize, save_fregs;\n+\n+/* Name of where we pretend to think the frame pointer points.\n+   Normally, this is \"4\", but if we are in a leaf procedure,\n+   this is \"something(30)\".  Will this work? */\n+char *frame_base_name;\n+\n+static rtx find_addr_reg ();\n+\n+/* Return non-zero only if OP is a register of mode MODE,\n+   or const0_rtx.  */\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (op == const0_rtx || register_operand (op, mode));\n+}\n+\n+int\n+call_operand_address (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (REG_P (op) || CONSTANT_P (op));\n+}\n+\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return truth value of statement that OP is a symbolic memory\n+   operand of mode MODE.  */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+  op = XEXP (op, 0);\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n+\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n+}\n+\n+/* Return 1 if the operand is either a register or a memory operand that is\n+   not symbolic.  */\n+\n+int\n+reg_or_nonsymb_mem_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+int\n+move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (op == CONST0_RTX (mode))\n+    return 1;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == LO_SUM)\n+    return (register_operand (XEXP (op, 0), Pmode)\n+\t    && CONSTANT_P (XEXP (op, 1)));\n+  return memory_address_p (mode, op);\n+}\n+\n+int\n+pic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return flag_pic && GET_CODE (op) == LABEL_REF;\n+}\n+\n+int\n+short_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      if (GET_CODE (XEXP (op, 0)) == REG)\n+\treturn 1;\n+      else if (GET_CODE (XEXP (op, 0)) == PLUS)\n+\t{\n+\t  rtx op1 = XEXP (XEXP (op, 0), 0);\n+\t  rtx op2 = XEXP (XEXP (op, 0), 1);\n+\n+\t  if (GET_CODE (op1) == REG)\n+\t    return (GET_CODE (op2) == CONST_INT && INT_5_BITS (op2));\n+\t  else if (GET_CODE (op2) == REG)\n+\t    return (GET_CODE (op1) == CONST_INT && INT_5_BITS (op1));\n+\t}\n+    }\n+  return 0;\n+}\n+\n+int\n+register_or_short_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return short_memory_operand (op, mode);\n+}\n+\n+int\n+fp_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return reg_renumber && FP_REG_P (op);\n+}\n+\f\n+extern int current_function_uses_pic_offset_table;\n+extern rtx force_reg (), validize_mem ();\n+\n+/* The rtx for the global offset table which is a special form\n+   that *is* a position independent symbolic constant.  */\n+rtx pic_pc_rtx;\n+\n+/* Ensure that we are not using patterns that are not OK with PIC.  */\n+\n+int\n+check_pic (i)\n+     int i;\n+{\n+  extern rtx recog_operand[];\n+  switch (flag_pic)\n+    {\n+    case 1:\n+      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n+\t  || (GET_CODE (recog_operand[i]) == CONST\n+\t      && ! rtx_equal_p (pic_pc_rtx, recog_operand[i])))\n+\tabort ();\n+    case 2:\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Return truth value of whether OP is EQ or NE.  */\n+\n+int\n+eq_or_neq (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n+\n+/* Return truth value of whether OP can be used as an operand in a\n+   three operand arithmetic insn that accepts registers of mode MODE\n+   or 14-bit signed integers.  */\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && INT_14_BITS (op)));\n+}\n+\n+/* Return truth value of whether OP can be used as an operand in a\n+   three operand arithmetic insn that accepts registers of mode MODE\n+   or 11-bit signed integers.  */\n+int\n+arith11_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && INT_11_BITS (op)));\n+}\n+\n+int\n+arith_double_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && GET_MODE (op) == mode\n+\t      && VAL_14_BITS_P (CONST_DOUBLE_LOW (op))\n+\t      && (CONST_DOUBLE_HIGH (op) >= 0\n+\t\t  == ((CONST_DOUBLE_LOW (op) & 0x1000) == 0))));\n+}\n+\n+/* Return truth value of whether OP is a integer which fits the\n+   range constraining immediate operands in three-address insns.  */\n+\n+int\n+int5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && INT_5_BITS (op));\n+}\n+\n+int\n+uint5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && INT_U5_BITS (op));\n+}\n+\n+  \n+int\n+int11_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+    return (GET_CODE (op) == CONST_INT && INT_11_BITS (op));\n+}\n+\n+int\n+arith5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return register_operand (op, mode) || int5_operand (op, mode);\n+}\n+\n+/* Return truth value of statement that OP is a call-clobbered register.  */\n+int\n+clobbered_register (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == REG && call_used_regs[REGNO (op)]);\n+}\n+\n+/* True iff OP can be the source of a move to a general register.  */\n+int\n+srcsi_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Not intended for other modes than SImode.  */\n+  if (mode != SImode)\n+    return 0;\n+\n+  /* Accept any register or memory reference.  */\n+  if (nonimmediate_operand (op, mode))\n+    return 1;\n+\n+  /* OK if ldo or ldil can be used.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INT_14_BITS (op) || (INTVAL (op) & 0x7ff) == 0));\n+}\n+\n+\f\n+/* Legitimize PIC addresses.  If the address is already\n+   position-independent, we return ORIG.  Newly generated\n+   position-independent addresses go to REG.  If we need more\n+   than one register, we lose.  */\n+\n+rtx\n+legitimize_pic_address (orig, mode, reg)\n+     rtx orig, reg;\n+     enum machine_mode mode;\n+{\n+  rtx pic_ref = orig;\n+\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      if (reg == 0)\n+\tabort ();\n+\n+      if (flag_pic == 2)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t      gen_rtx (HIGH, Pmode, orig)));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, reg,\n+\t\t\t      gen_rtx (LO_SUM, Pmode, reg, orig)));\n+\t  orig = reg;\n+\t}\n+      pic_ref = gen_rtx (MEM, Pmode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  pic_offset_table_rtx, orig));\n+      current_function_uses_pic_offset_table = 1;\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      emit_move_insn (reg, pic_ref);\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\tabort ();\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+\t  orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t\t base == reg ? 0 : reg);\n+\t}\n+      else abort ();\n+      if (GET_CODE (orig) == CONST_INT)\n+\t{\n+\t  if (SMALL_INT (orig))\n+\t    return plus_constant_for_output (base, INTVAL (orig));\n+\t  orig = force_reg (Pmode, orig);\n+\t}\n+      pic_ref = gen_rtx (PLUS, Pmode, base, orig);\n+      /* Likewise, should we set special REG_NOTEs here?  */\n+    }\n+  return pic_ref;\n+}\n+\n+/* Set up PIC-specific rtl.  This should not cause any insns\n+   to be emitted.  */\n+\n+void\n+initialize_pic ()\n+{\n+}\n+\n+/* Emit special PIC prologues and epilogues.  */\n+\n+void\n+finalize_pic ()\n+{\n+  /* The table we use to reference PIC data.  */\n+  rtx global_offset_table;\n+  /* Labels to get the PC in the prologue of this function.  */\n+  rtx l1, l2;\n+  rtx seq;\n+  int orig_flag_pic = flag_pic;\n+\n+  if (current_function_uses_pic_offset_table == 0)\n+    return;\n+\n+  if (! flag_pic)\n+    abort ();\n+\n+  flag_pic = 0;\n+  l1 = gen_label_rtx ();\n+  l2 = gen_label_rtx ();\n+\n+  start_sequence ();\n+\n+  emit_label (l1);\n+  /* Note that we pun calls and jumps here!  */\n+  emit_jump_insn (gen_rtx (PARALLEL, VOIDmode,\n+                         gen_rtvec (2,\n+                                    gen_rtx (SET, VOIDmode, pc_rtx, gen_rtx (LABEL_REF, VOIDmode, l2)),\n+                                    gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 15), gen_rtx (LABEL_REF, VOIDmode, l2)))));\n+  emit_label (l2);\n+\n+  /* Initialize every time through, since we can't easily\n+     know this to be permanent.  */\n+  global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"*__GLOBAL_OFFSET_TABLE_\");\n+  pic_pc_rtx = gen_rtx (CONST, Pmode,\n+\t\t\tgen_rtx (MINUS, Pmode,\n+\t\t\t\t global_offset_table,\n+\t\t\t\t gen_rtx (CONST, Pmode,\n+\t\t\t\t\t  gen_rtx (MINUS, Pmode,\n+\t\t\t\t\t\t   gen_rtx (LABEL_REF, VOIDmode, l1),\n+\t\t\t\t\t\t   pc_rtx))));\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, pic_offset_table_rtx,\n+\t\t      gen_rtx (HIGH, Pmode, pic_pc_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (LO_SUM, Pmode,\n+\t\t\t       pic_offset_table_rtx, pic_pc_rtx)));\n+  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t      pic_offset_table_rtx,\n+\t\t      gen_rtx (PLUS, SImode,\n+\t\t\t       pic_offset_table_rtx, gen_rtx (REG, SImode, 15))));\n+  /* emit_insn (gen_rtx (ASM_INPUT, VOIDmode, \"!#PROLOGUE# 1\")); */\n+  LABEL_PRESERVE_P (l1) = 1;\n+  LABEL_PRESERVE_P (l2) = 1;\n+  flag_pic = orig_flag_pic;\n+\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_after (seq, get_insns ());\n+\n+  /* Need to emit this whether or not we obey regdecls,\n+     since setjmp/longjmp can cause life info to screw up.  */\n+  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+}\n+\n+/* For the HPPA, REG and REG+CONST is cost 0\n+   and addresses involving symbolic constants are cost 2.\n+\n+   PIC addresses are very expensive.\n+\n+   It is no coincidence that this has the same structure\n+   as GO_IF_LEGITIMATE_ADDRESS.  */\n+int\n+hppa_address_cost (X)\n+     rtx X;\n+{\n+  if (GET_CODE (X) == PLUS)\n+      return 1;\n+  else if (GET_CODE (X) == LO_SUM)\n+    return 1;\n+  else if (GET_CODE (X) == HIGH)\n+    return 2;\n+  return 4;\n+}\n+\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.  */\n+\n+int\n+emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+\n+  /* Handle most common case first: storing into a register.  */\n+  if (register_operand (operand0, mode))\n+    {\n+      if (register_operand (operand1, mode)\n+\t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n+\t  || (GET_CODE (operand1) == HIGH\n+\t      && !symbolic_operand (XEXP (operand1, 0)))\n+\t  /* Only `general_operands' can come here, so MEM is ok.  */\n+\t  || GET_CODE (operand1) == MEM)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+    }\n+  else if (GET_CODE (operand0) == MEM)\n+    {\n+      if (register_operand (operand1, mode) || operand1 == const0_rtx)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+      if (! reload_in_progress)\n+\t{\n+\t  operands[0] = validize_mem (operand0);\n+\t  operands[1] = operand1 = force_reg (mode, operand1);\n+\t}\n+    }\n+\n+  /* Simplify the source if we need to.  */\n+#if 0\n+  if (GET_CODE (operand1) == HIGH\n+      && symbolic_operand (XEXP (operand1, 0), mode)\n+      && !read_only_operand (XEXP (operand1, 0)))\n+    {\n+      rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (mode);\n+      \n+      emit_insn (gen_rtx (SET, VOIDmode, temp, operand1));\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  operand0,\n+\t\t\t  gen_rtx (PLUS, mode,\n+\t\t\t\t   temp, gen_rtx (REG, mode, 27))));\n+      return 1;\n+    }\n+#endif\n+  if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n+    {\n+      if (symbolic_operand (operand1, mode))\n+\t{\n+\t  if (flag_pic)\n+\t    {\n+\t      rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (Pmode);\n+\t      operands[1] = legitimize_pic_address (operand1, mode, temp);\n+\t    }\n+\t  /* On the HPPA, references to data space are supposed to */\n+\t  /* use dp, register 27. */\n+\t  else if (read_only_operand (operand1))\n+\t    {\n+\t      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t  operand0,\n+\t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n+\t      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t  operand0,\n+\t\t\t\t  gen_rtx (LO_SUM, mode, operand0, operand1)));\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If reload_in_progress, we can't use addil and r1; we */\n+\t      /* have to use the more expensive ldil sequence. */\n+\t      if (reload_in_progress)\n+\t\t{\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      operand0,\n+\t\t\t\t      gen_rtx (HIGH, mode, operand1)));\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      operand0,\n+\t\t\t\t      gen_rtx (PLUS, mode,\n+\t\t\t\t\t       operand0,\n+\t\t\t\t\t       gen_rtx (REG, mode, 27))));\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      operand0,\n+\t\t\t\t      gen_rtx (LO_SUM, mode,\n+\t\t\t\t\t       operand0, operand1)));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx temp1 = gen_reg_rtx (mode), temp2 = gen_reg_rtx (mode);\n+\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      temp1, gen_rtx (HIGH, mode, operand1)));\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      temp2,\n+\t\t\t\t      gen_rtx (PLUS, mode,\n+\t\t\t\t\t       gen_rtx (REG, mode, 27),\n+\t\t\t\t\t       temp1)));\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t      operand0,\n+\t\t\t\t      gen_rtx (LO_SUM, mode,\n+\t\t\t\t\t       temp2, operand1)));\n+\t\t}\n+\t      return 1;\n+\t    }\n+\t}\n+      else if (GET_CODE (operand1) == CONST_INT\n+\t       ? (! SMALL_INT (operand1)\n+\t\t  && (INTVAL (operand1) & 0x7ff) != 0) : 1)\n+\t{\n+\t  rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx (SET, VOIDmode, temp,\n+\t\t\t      gen_rtx (HIGH, mode, operand1)));\n+\t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n+\t}\n+    }\n+  /* Now have insn-emit do whatever it normally does.  */\n+  return 0;\n+}\n+\n+/* Does operand (which is a symbolic_operand) live in text space? If\n+   so SYMBOL_REF_FLAG, which is set by ENCODE_SECTION_INFO, will be true.*/\n+\n+int\n+read_only_operand (operand)\n+     rtx operand;\n+{\n+  if (GET_CODE (operand) == CONST)\n+    operand = XEXP (XEXP (operand, 0), 0);\n+  if (GET_CODE (operand) == SYMBOL_REF)\n+    return SYMBOL_REF_FLAG (operand) || CONSTANT_POOL_ADDRESS_P (operand);\n+  return 1;\n+}\n+     \n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \"stw %r1,%0\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ldw %1,%0\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    if (INT_14_BITS (operands[1]))\n+      return (INTVAL (operands[1]) == 0 ? \"copy 0,%0\" : \"ldi %1,%0\");\n+    else\n+      return \"ldil L'%1,%0\\n\\tldo R'%1(%0),%0\";\n+  return \"copy %1,%0\";\n+}\n+\f\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 != REGOP && optype1 != REGOP)\n+    abort ();\n+\n+   /* Handle auto decrementing and incrementing loads and stores\n+     specifically, since the structure of the function doesn't work\n+     for them without major modification.  Do it better when we learn\n+     this port about the general inc/dec addressing of PA.\n+     (This was written by tege.  Chide him if it doesn't work.)  */\n+\n+  if (optype0 == MEMOP)\n+    {\n+      rtx addr = XEXP (operands[0], 0);\n+      if (GET_CODE (addr) == POST_INC || GET_CODE (addr) == POST_DEC\n+\t  || GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n+\t{\n+\t  operands[0] = gen_rtx (MEM, SImode, addr);\n+\t  return \"stw%M0 %1,%0\\n\\tstw%M0 %1,%0\";\n+\t}\n+    }\n+  if (optype1 == MEMOP)\n+    {\n+      /* We have to output the address syntax ourselves, since print_operand\n+\t doesn't deal with the addresses we want to use.  Fix this later.  */\n+\n+      rtx addr = XEXP (operands[1], 0);\n+      if (GET_CODE (addr) == POST_INC || GET_CODE (addr) == POST_DEC)\n+\t{\n+\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\n+\t  operands[1] = XEXP (addr, 0);\n+\t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n+\t    abort ();\n+\n+\t  if (!reg_overlap_mentioned_p (high_reg, addr))\n+\t    {\n+\t      /* No overlap between high target register and address\n+\t\t register.  (We do this in an non-obious way to\n+\t\t save a register file writeback)  */\n+\t      if (GET_CODE (addr) == POST_INC)\n+\t\treturn \"ldws,ma 8(0,%1),%0\\n\\tldw -4(0,%1),%R0\";\n+\t      return \"ldws,ma -8(0,%1),%0\\n\\tldw 12(0,%1),%R0\";\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is an undefined situation.  We should load into the\n+\t\t address register *and* update that register.  Probably\n+\t\t we don't need to handle this at all.  */\n+\t      if (GET_CODE (addr) == POST_INC)\n+\t\treturn \"ldw 4(0,%1),%R0\\n\\tldws,ma 8(0,%1),%0\";\n+\t      return \"ldw 4(0,%1),%R0\\n\\tldws,ma -8(0,%1),%0\";\n+\t    }\n+\t}\n+      else if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n+\t{\n+\t  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], 0);\n+\n+\t  operands[1] = XEXP (addr, 0);\n+\t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n+\t    abort ();\n+\n+\t  if (!reg_overlap_mentioned_p (high_reg, addr))\n+\t    {\n+\t      /* No overlap between high target register and address\n+\t\t register.  (We do this in an non-obious way to\n+\t\t save a register file writeback)  */\n+\t      if (GET_CODE (addr) == PRE_INC)\n+\t\treturn \"ldws,mb 8(0,%1),%0\\n\\tldw 4(0,%1),%R0\";\n+\t      return \"ldws,mb -8(0,%1),%0\\n\\tldw 4(0,%1),%R0\";\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is an undefined situation.  We should load into the\n+\t\t address register *and* update that register.  Probably\n+\t\t we don't need to handle this at all.  */\n+\t      if (GET_CODE (addr) == PRE_INC)\n+\t\treturn \"ldw 12(0,%1),%R0\\n\\tldws,mb 8(0,%1),%0\";\n+\t      return \"ldw -4(0,%1),%R0\\n\\tldws,mb -8(0,%1),%0\";\n+\t    }\n+\t}\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    split_double (operands[1], &operands[1], &latehalf[1]);\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.\n+\n+     RMS says \"This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.\"\n+\n+     but it happens on the HP-PA when loading parameter registers,\n+     so I am going to define that circumstance, and make it work\n+     as expected.  */\n+\n+  if (optype0 == REGOP && (optype1 == MEMOP || optype1 == OFFSOP)\n+\t   && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n+    {\n+      /* XXX THIS PROBABLY DOESN'T WORK.  */\n+      /* Do the late half first.  */\n+      if (addreg1)\n+\toutput_asm_insn (\"addi 4,%0\", &addreg1);\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+      if (addreg1)\n+\toutput_asm_insn (\"addi -4,%0\", &addreg1);\n+      /* Then clobber.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"addi 4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"addi 4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"addi -4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"addi -4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\f\n+char *\n+output_fp_move_double (operands)\n+     rtx *operands;\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\toutput_asm_insn (\"fcpy,dbl %1,%0\", operands);\n+      else if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  rtx xoperands[3];\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = operands[1];\n+\t  xoperands[2] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn\n+\t    (\"stw %1,-16(0,30)\\n\\tstw %2,-12(0,30)\\n\\tfldds -16(0,30),%0\",\n+\t\t\t   xoperands);\n+\t}\n+      else \n+\toutput_asm_insn (\"fldds%F1 %1,%0\", operands);\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  rtx xoperands[3];\n+\t  xoperands[2] = operands[1];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  xoperands[0] = operands[0];\n+\t  output_asm_insn\n+\t    (\"fstds %2,-16(0,30)\\n\\tldw -12(0,30),%1\\n\\tldw -16(0,30),%0\",\n+\t     xoperands);\n+\t}\n+      else\n+\toutput_asm_insn (\"fstds%F0 %1,%0\", operands);\n+    }\n+  else abort ();\n+  return \"\";\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\n+/* Load the address specified by OPERANDS[3] into the register\n+   specified by OPERANDS[0].\n+\n+   OPERANDS[3] may be the result of a sum, hence it could either be:\n+\n+   (1) CONST\n+   (2) REG\n+   (2) REG + CONST_INT\n+   (3) REG + REG + CONST_INT\n+   (4) REG + REG  (special case of 3).\n+\n+   Note that (3) is not a legitimate address.\n+   All cases are handled here.  */\n+\n+void\n+output_load_address (operands)\n+     rtx *operands;\n+{\n+  rtx base, offset;\n+\n+  if (CONSTANT_P (operands[3]))\n+    {\n+      output_asm_insn (\"ldi %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (REG_P (operands[3]))\n+    {\n+      if (REGNO (operands[0]) != REGNO (operands[3]))\n+\toutput_asm_insn (\"copy %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (GET_CODE (operands[3]) != PLUS)\n+    abort ();\n+\n+  base = XEXP (operands[3], 0);\n+  offset = XEXP (operands[3], 1);\n+\n+  if (GET_CODE (base) == CONST_INT)\n+    {\n+      rtx tmp = base;\n+      base = offset;\n+      offset = tmp;\n+    }\n+\n+  if (GET_CODE (offset) != CONST_INT)\n+    {\n+      /* Operand is (PLUS (REG) (REG)).  */\n+      base = operands[3];\n+      offset = const0_rtx;\n+    }\n+\n+  if (REG_P (base))\n+    {\n+      operands[6] = base;\n+      operands[7] = offset;\n+      if (INT_14_BITS (offset))\n+\toutput_asm_insn (\"ldo %7(%6),%0\", operands);\n+      else\n+\toutput_asm_insn (\"addil L'%7,%6\\n\\tldo R'%7(1),%0\", operands);\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      operands[6] = XEXP (base, 0);\n+      operands[7] = XEXP (base, 1);\n+      operands[8] = offset;\n+\n+      if (offset == const0_rtx)\n+\toutput_asm_insn (\"add %6,%7,%0\", operands);\n+      else if (INT_14_BITS (offset))\n+\toutput_asm_insn (\"add %6,%7,%0\\n\\taddi %8,%0\", operands);\n+      else\n+\toutput_asm_insn (\"addil L'%8,%6\\n\\tldo R'%8(1),%0\\n\\tadd %0,%7,%0\", operands);\n+    }\n+  else\n+    abort ();\n+}\n+\n+/* Emit code to perform a block move.\n+\n+   Restriction: If the length argument is non-constant, alignment\n+   must be 4.\n+\n+   OPERANDS[0] is the destination pointer as a REG, clobbered.\n+   OPERANDS[1] is the source pointer as a REG, clobbered.\n+   if SIZE_IS_CONSTANT\n+     OPERANDS[2] is a register for temporary storage.\n+     OPERANDS[4] is the size as a CONST_INT\n+   else\n+     OPERANDS[2] is a REG which will contain the size, clobbered.\n+   OPERANDS[3] is a register for temporary storage.\n+   OPERANDS[5] is the alignment safe to use, as a CONST_INT.  */\n+\n+char *\n+output_block_move (operands, size_is_constant)\n+     rtx *operands;\n+     int size_is_constant;\n+{\n+  int align = INTVAL (operands[5]);\n+  unsigned long n_bytes;\n+\n+  /* We can't move more than four bytes at a time because the PA\n+     has no longer integer move insns.  (Could use fp mem ops?)  */\n+  if (align > 4)\n+    align = 4;\n+\n+  if (size_is_constant)\n+    {\n+      unsigned long n_items;\n+      unsigned long offset;\n+      rtx temp;\n+\n+      n_bytes = INTVAL (operands[4]);\n+      if (n_bytes == 0)\n+\treturn \"\";\n+\n+      if (align >= 4)\n+\t{\n+\t  /* Don't unroll too large blocks.  */\n+\t  if (n_bytes > 64)\n+\t    goto copy_with_loop;\n+\n+\t  /* Read and store using two registers, and hide latency\n+\t     by defering the stores until three instructions after\n+\t     the corresponding load.  The last load insn will read\n+\t     the entire word were the last bytes are, possibly past\n+\t     the end of the source block, but since loads are aligned,\n+\t     this is harmless.  */\n+\n+\t  output_asm_insn (\"ldws,ma 4(0,%1),%2\", operands);\n+\n+\t  for (offset = 4; offset < n_bytes; offset += 4)\n+\t    {\n+\t      output_asm_insn (\"ldws,ma 4(0,%1),%3\", operands);\n+\t      output_asm_insn (\"stws,ma %2,4(0,%0)\", operands);\n+\n+\t      temp = operands[2];\n+\t      operands[2] = operands[3];\n+\t      operands[3] = temp;\n+\t    }\n+\t  if (n_bytes % 4 == 0)\n+\t    /* Store the last word.  */\n+\t    output_asm_insn (\"stw %2,0(0,%0)\", operands);\n+\t  else\n+\t    {\n+\t      /* Store the last, partial word.  */\n+\t      operands[4] = gen_rtx (CONST_INT, VOIDmode, n_bytes % 4);\n+\t      output_asm_insn (\"stbys,e %2,%4(0,%0)\", operands);\n+\t    }\n+\t  return \"\";\n+\t}\n+\n+      if (align >= 2 && n_bytes >= 2)\n+\t{\n+\t  output_asm_insn (\"ldhs,ma 2(0,%1),%2\", operands);\n+\n+\t  for (offset = 2; offset + 2 <= n_bytes; offset += 2)\n+\t    {\n+\t      output_asm_insn (\"ldhs,ma 2(0,%1),%3\", operands);\n+\t      output_asm_insn (\"sths,ma %2,2(0,%0)\", operands);\n+\n+\t      temp = operands[2];\n+\t      operands[2] = operands[3];\n+\t      operands[3] = temp;\n+\t    }\n+\t  if (n_bytes % 2 != 0)\n+\t    output_asm_insn (\"ldb 0(0,%1),%3\", operands);\n+\n+\t  output_asm_insn (\"sths,ma %2,2(0,%0)\", operands);\n+\n+\t  if (n_bytes % 2 != 0)\n+\t    output_asm_insn (\"stb %3,0(0,%0)\", operands);\n+\n+\t  return \"\";\n+\t}\n+\n+      output_asm_insn (\"ldbs,ma 1(0,%1),%2\", operands);\n+\n+      for (offset = 1; offset + 1 <= n_bytes; offset += 1)\n+\t{\n+\t  output_asm_insn (\"ldbs,ma 1(0,%1),%3\", operands);\n+\t  output_asm_insn (\"stbs,ma %2,1(0,%0)\", operands);\n+\n+\t  temp = operands[2];\n+\t  operands[2] = operands[3];\n+\t  operands[3] = temp;\n+\t}\n+      output_asm_insn (\"stb %2,0(0,%0)\", operands);\n+\n+      return \"\";\n+    }\n+\n+  if (align != 4)\n+    abort();\n+     \n+ copy_with_loop:\n+\n+  if (size_is_constant)\n+    {\n+      /* Size is an compile-time determined, and also not\n+\t very small (such small cases are handled above).  */\n+      operands[4] = gen_rtx (CONST_INT, VOIDmode, n_bytes - 4);\n+      output_asm_insn (\"ldo %4(0),%2\", operands);\n+    }\n+  else\n+    {\n+      /* Decrement counter by 4, and if it becomes negative, jump past the\n+\t word copying loop.  */\n+      output_asm_insn (\"addib,<,n -4,%2,.+16\", operands);\n+    }\n+\n+  /* Copying loop.  Note that the first load is in the anulled delay slot\n+     of addib.  Is it OK on PA to have a load in a delay slot, i.e. is a\n+     possible page fault stopped in time?  */\n+  output_asm_insn (\"ldws,ma 4(0,%1),%3\", operands);\n+  output_asm_insn (\"addib,>= -4,%2,.-4\", operands);\n+  output_asm_insn (\"stws,ma %3,4(0,%0)\", operands);\n+\n+  /* The counter is negative, >= -4.  The remaining number of bytes are\n+     determined by the two least significant bits.  */\n+\n+  if (size_is_constant)\n+    {\n+      if (n_bytes % 4 != 0)\n+\t{\n+\t  /* Read the entire word of the source block tail.  */\n+\t  output_asm_insn (\"ldw 0(0,%1),%3\", operands);\n+\t  operands[4] = gen_rtx (CONST_INT, VOIDmode, n_bytes % 4);\n+\t  output_asm_insn (\"stbys,e %3,%4(0,%0)\", operands);\n+\t}\n+    }\n+  else\n+    {\n+      /* Add 4 to counter.  If it becomes zero, we're done.  */\n+      output_asm_insn (\"addib,=,n 4,%2,.+16\", operands);\n+\n+      /* Read the entire word of the source block tail.  (Also this\n+\t load is in an anulled delay slot.)  */\n+      output_asm_insn (\"ldw 0(0,%1),%3\", operands);\n+\n+      /* Make %0 point at the first byte after the destination block.  */\n+      output_asm_insn (\"add %2,%0,%0\", operands);\n+      /* Store the leftmost bytes, up to, but not including, the address\n+\t in %0.  */\n+      output_asm_insn (\"stbys,e %3,0(0,%0)\", operands);\n+    }\n+  return \"\";\n+}\n+\f\n+\n+/* Output an ascii string.  */\n+output_ascii (file, p, size)\n+     FILE *file;\n+     unsigned char *p;\n+     int size;\n+{\n+  int i;\n+  int chars_output;\n+  unsigned char partial_output[16];\t/* Max space 4 chars can occupy.   */\n+\n+  /* The HP assembler can only take strings of 256 characters at one\n+     time.  This is a limitation on input line length, *not* the\n+     length of the string.  Sigh.  Even worse, it seems that the\n+     restriction is in number of input characters (see \\xnn &\n+     \\whatever).  So we have to do this very carefully.  */\n+\n+  fprintf (file, \"\\t.STRING \\\"\");\n+\n+  chars_output = 0;\n+  for (i = 0; i < size; i += 4)\n+    {\n+      int co = 0;\n+      int io = 0;\n+      for (io = 0, co = 0; io < MIN (4, size - i); io++)\n+\t{\n+\t  register unsigned int c = p[i + io];\n+\n+\t  if (c == '\\\"' || c == '\\\\')\n+\t    partial_output[co++] = '\\\\';\n+\t  if (c >= ' ' && c < 0177)\n+\t    partial_output[co++] = c;\n+\t  else\n+\t    {\n+\t      unsigned int hexd;\n+\t      partial_output[co++] = '\\\\';\n+\t      partial_output[co++] = 'x';\n+\t      hexd =  c  / 16 - 0 + '0';\n+\t      if (hexd > '9')\n+\t\thexd -= '9' - 'a' + 1;\n+\t      partial_output[co++] = hexd;\n+\t      hexd =  c % 16 - 0 + '0';\n+\t      if (hexd > '9')\n+\t\thexd -= '9' - 'a' + 1;\n+\t      partial_output[co++] = hexd;\n+\t    }\n+\t}\n+      if (chars_output + co > 243)\n+\t{\n+\t  fprintf (file, \"\\\"\\n\\t.STRING \\\"\");\n+\t  chars_output = 0;\n+\t}\n+      fwrite (partial_output, 1, co, file);\n+      chars_output += co;\n+      co = 0;\n+    }\n+  fprintf (file, \"\\\"\\n\");\n+}\n+\f\n+/* You may have trouble believing this, but this is the HP825 stack\n+   layout.  Wow.\n+\n+   Offset\t\tContents\n+\n+   Variable arguments\t(optional; any number may be allocated)\n+\n+   SP-(4*(N+9))\t\targ word N\n+   \t:\t\t    :\n+      SP-56\t\targ word 5\n+      SP-52\t\targ word 4\n+\n+   Fixed arguments\t(must be allocated; may remain unused)\n+\n+      SP-48\t\targ word 3\n+      SP-44\t\targ word 2\n+      SP-40\t\targ word 1\n+      SP-36\t\targ word 0\n+\n+   Frame Marker\n+\n+      SP-32\t\tExternal Data Pointer (DP)\n+      SP-28\t\tExternal sr4\n+      SP-24\t\tExternal/stub RP (RP')\n+      SP-20\t\tCurrent RP\n+      SP-16\t\tStatic Link\n+      SP-12\t\tClean up\n+      SP-8\t\tCalling Stub RP (RP'')\n+      SP-4\t\tPrevious SP\n+\n+   Top of Frame\n+\n+      SP-0\t\tStack Pointer (points to next available address)\n+\n+*/\n+\n+/* This function saves registers as follows.  Registers marked with ' are\n+   this function's registers (as opposed to the previous function's).\n+   If a frame_pointer isn't needed, r4 is saved as a general register;\n+   the space for the frame pointer is still allocated, though, to keep\n+   things simple.\n+\n+\n+   Top of Frame\n+\n+       SP (FP')\t\tPrevious FP\n+       SP + 4\t\tAlignment filler (sigh)\n+       SP + 8\t\tSpace for locals reserved here.\n+       .\n+       .\n+       .\n+       SP + n\t\tAll call saved register used.\n+       .\n+       .\n+       .\n+       SP + o\t\tAll call saved fp registers used.\n+       .\n+       .\n+       .\n+       SP + p (SP')\tpoints to next available address.\n+       \n+*/\n+\n+/* Helper functions */\n+void\n+print_stw (file, r, disp, base)\n+     FILE *file;\n+     int r, disp, base;\n+{\n+  if (VAL_14_BITS_P (disp))\n+    fprintf (file, \"\\tstw %d,%d(0,%d)\\n\", r, disp, base);\n+  else\n+    fprintf (file, \"\\taddil L'%d,%d\\n\\tstw %d,R'%d(0,1)\\n\", disp, base,\n+\t     r, disp);\n+}\n+\n+void\n+print_ldw (file, r, disp, base)\n+     FILE *file;\n+     int r, disp, base;\n+{\n+  if (VAL_14_BITS_P (disp))\n+    fprintf (file, \"\\tldw %d(0,%d),%d\\n\", disp, base, r);\n+  else\n+    fprintf (file, \"\\taddil L'%d,%d\\n\\tldw R'%d(0,1),%d\\n\", disp, base,\n+\t     disp, r);\n+}\n+\n+int\n+compute_frame_size (size, leaf_function)\n+     int size;\n+     int leaf_function;\n+{\n+  extern int current_function_outgoing_args_size;\n+  int i;\n+\n+  /* 8 is space for frame pointer + filler */\n+  local_fsize = actual_fsize = size + 8;\n+\n+  /* fp is stored in a special place. */\n+  for (i = 18; i >= 5; i--)\n+    if (regs_ever_live[i])\n+      actual_fsize += 4;\n+\n+  if (regs_ever_live[3])\n+    actual_fsize += 4;\n+  actual_fsize = (actual_fsize + 7) & ~7;\n+\n+  if (!TARGET_SNAKE)\n+    {\n+      for (i = 47; i >= 44; i--)\n+\tif (regs_ever_live[i])\n+\t  {\n+\t    actual_fsize += 8;  save_fregs++;\n+\t  }\n+    }\n+  else\n+    {\n+      for (i = 90; i >= 72; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    actual_fsize += 8;  save_fregs++;\n+\t  }\n+    }\n+  return actual_fsize + current_function_outgoing_args_size;\n+}\n+     \n+void\n+output_function_prologue (file, size, leaf_function)\n+     FILE *file;\n+     int size;\n+     int leaf_function;\n+{\n+  extern char call_used_regs[];\n+  extern int frame_pointer_needed;\n+  int i, offset;\n+\n+  actual_fsize = compute_frame_size (size, leaf_function) + 32;\n+  if (TARGET_SNAKE)\n+    actual_fsize = (actual_fsize + 63) & ~63;\n+\n+  /* Let's not try to bullshit more than we need to here. */\n+  /* This might be right a lot of the time */\n+  fprintf (file, \"\\t.PROC\\n\\t.CALLINFO FRAME=%d\", actual_fsize);\n+    if (regs_ever_live[2])\n+      fprintf (file, \",CALLS,SAVE_RP\\n\");\n+    else\n+      fprintf (file, \",NO_CALLS\\n\");\n+  fprintf (file, \"\\t.ENTRY\\n\");\n+\n+  /* Instead of taking one argument, the counter label, as most normal\n+     mcounts do, _mcount appears to behave differently on the HPPA. It\n+     takes the return address of the caller, the address of this\n+     routine, and the address of the label. Also, it isn't magic, so\n+     caller saves have to be preserved. We get around this by calling\n+     our own gcc_mcount, which takes arguments on the stack and saves\n+     argument registers. */\n+  \n+  if (profile_flag)\n+    {\n+      fprintf (file,\"\\tstw 2,-20(30)\\n\\tldo 48(30),30\\n\\\n+\\taddil L'LP$%04d-$global$,27\\n\\tldo R'LP$%04d-$global$(1),1\\n\\\n+\\tbl __gcc_mcount,2\\n\\tstw 1,-16(30)\\n\\tldo -48(30),30\\n\\tldw -20(30),2\\n\",\n+\t       hp_profile_labelno, hp_profile_labelno);\n+    }\n+  /* Some registers have places to go in the current stack\n+     structure.  */\n+\n+#if 0\n+  /* However, according to the hp docs, there's no need to save the\n+     sp.  */\n+  fprintf (file, \"\\tstw 30,-4(30)\\n\");\n+#endif\n+\n+  if (regs_ever_live[2])\n+    fprintf (file, \"\\tstw 2,-20(0,30)\\n\");\n+\n+  /* Reserve space for local variables.  */\n+  if (frame_pointer_needed)\n+    {\n+      if (VAL_14_BITS_P (actual_fsize))\n+\tfprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstwm 1,%d(0,30)\\n\",\n+\t\t actual_fsize);\n+      else\n+\t{\n+\t  fprintf (file, \"\\tcopy 4,1\\n\\tcopy 30,4\\n\\tstw 1,0(0,4)\\n\");\n+\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n+\t\t   actual_fsize, actual_fsize);\n+\t}\n+    }\n+  else\n+    /* Used to be abort ();  */\n+    {\n+      if (VAL_14_BITS_P (actual_fsize))\n+\tfprintf (file, \"\\tldo %d(30),30\\n\", actual_fsize);\n+      else\n+\tfprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),30\\n\",\n+\t\t actual_fsize, actual_fsize);\n+    }\n+  \n+  /* Normal register save. */\n+  if (frame_pointer_needed)\n+    {\n+      for (i = 18, offset = local_fsize; i >= 5; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    print_stw (file, i, offset, 4);  offset += 4;\n+\t  }\n+      if (regs_ever_live[3] && ! call_used_regs[3])\n+\t{\n+\t  print_stw (file, 3, offset, 4);  offset += 4;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 18, offset = local_fsize - actual_fsize; i >= 5; i--)\n+      \tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    print_stw (file, i, offset, 30);  offset += 4;\n+\t  }\n+      if (regs_ever_live[3] && ! call_used_regs[3])\n+\t{\n+\t  print_stw (file, 3, offset, 30);  offset += 4;\n+\t}\n+    }\n+      \n+  /* Align pointer properly (doubleword boundary).  */\n+  offset = (offset + 7) & ~7;\n+\n+  /* Floating point register store.  */\n+  if (save_fregs)\n+    if (frame_pointer_needed)\n+      {\n+\tif (VAL_14_BITS_P (offset))\n+\t  fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\telse\n+\t  fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\", offset, offset);\n+      }\n+    else\n+      {\n+\tif (VAL_14_BITS_P (offset))\n+\t  fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\telse\n+\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\", offset, offset);\n+      }\n+  if (!TARGET_SNAKE)\n+    {\n+      for (i = 47; i >= 44; i--)\n+\t{\n+\t  if (regs_ever_live[i])\n+\t    fprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 90; i >= 72; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    fprintf (file, \"\\tfstds,ma %s,8(0,1)\\n\", reg_names[i]);\n+\t  }\n+    }\n+}\n+\n+void\n+output_function_epilogue (file, size, leaf_function)\n+     FILE *file;\n+     int size;\n+     int leaf_function;\n+{\n+  extern char call_used_regs[];\n+  extern int frame_pointer_needed;\n+  int  i, offset;\n+\n+  if (frame_pointer_needed)\n+    {\n+      for (i = 18, offset = local_fsize; i >= 5; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    print_ldw (file, i, offset, 4);  offset += 4;\n+\t  }\n+      if (regs_ever_live[3] && ! call_used_regs[3])\n+\t{\n+\t  print_ldw (file, 3, offset, 4);  offset += 4;\t  \n+\t}\n+    }\n+  else\n+    {\n+      for (i = 18, offset = local_fsize - actual_fsize; i >= 5; i--)\n+      \tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    print_ldw (file, i, offset, 30);  offset += 4;\n+\t  }\n+      if (regs_ever_live[3] && ! call_used_regs[3])\n+\t{\n+\t  print_ldw (file, 3, offset, 30);  offset += 4;\n+\t}\n+    }\n+      \n+  /* Align pointer properly (doubleword boundary).  */\n+  offset = (offset + 7) & ~7;\n+\n+  /* Floating point register restore.  */\n+  if (save_fregs)\n+    if (frame_pointer_needed)\n+      {\n+\tif (VAL_14_BITS_P (offset))\n+\t  fprintf (file, \"\\tldo %d(4),1\\n\", offset);\n+\telse\n+\t  fprintf (file, \"\\taddil L'%d,4\\n\\tldo R'%d(1),1\\n\", offset, offset);\n+      }\n+    else\n+      {\n+\tif (VAL_14_BITS_P (offset))\n+\t  fprintf (file, \"\\tldo %d(30),1\\n\", offset);\n+\telse\n+\t  fprintf (file, \"\\taddil L'%d,30\\n\\tldo R'%d(1),1\\n\", offset, offset);\n+      }\n+  if (!TARGET_SNAKE)\n+    {\n+      for (i = 47; i >= 44; i--)\n+\t{\n+\t  if (regs_ever_live[i])\n+\t    fprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t}\n+    }\n+  else\n+    {\n+      for (i = 90; i >= 72; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    fprintf (file, \"\\tfldds,ma 8(0,1),%s\\n\", reg_names[i]);\n+\t  }\n+    }\n+  /* Reset stack pointer (and possibly frame pointer).  The stack */\n+  /* pointer is initially set to fp + 8 to avoid a race condition. */\n+  if (frame_pointer_needed)\n+    {\n+      fprintf (file, \"\\tldo 8(4),30\\n\");\n+      if (regs_ever_live[2])\n+\tfprintf (file, \"\\tldw -28(0,30),2\\n\");\n+      fprintf (file, \"\\tbv 0(2)\\n\\tldwm -8(30),4\\n\");\n+    }\n+  else if (actual_fsize)\n+    {\n+      if (regs_ever_live[2] && VAL_14_BITS_P (actual_fsize + 20))\n+\tfprintf (file, \"\\tldw %d(30),2\\n\\tbv 0(2)\\n\\tldo %d(30),30\\n\",\n+\t\t -(actual_fsize + 20), -actual_fsize);\n+      else if (regs_ever_live[2])\n+\tfprintf (file,\n+\t\t \"\\taddil L'%d,30\\n\\tldw %d(1),2\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\",\n+\t\t - actual_fsize,\n+\t\t - (actual_fsize + 20 + ((-actual_fsize) & ~0x7ff)),\n+\t\t /* - ((actual_fsize + 20) - (actual_fsize & ~0x7ff)), */\n+\t\t - actual_fsize);\n+      else if (VAL_14_BITS_P (actual_fsize))\n+\tfprintf (file, \"\\tbv 0(2)\\n\\tldo %d(30),30\\n\", - actual_fsize);\n+      else\n+\tfprintf (file, \"\\taddil L'%d,30\\n\\tbv 0(2)\\n\\tldo R'%d(1),30\\n\");\n+    }\n+  else if (current_function_epilogue_delay_list)\n+    {\n+      fprintf (file, \"\\tbv 0(2)\\n\");\n+      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n+\t\t       file, write_symbols, 1, 0, 1);\n+    }\n+  else\n+    fprintf (file, \"\\tbv,n 0(2)\\n\");\n+  fprintf (file, \"\\t.EXIT\\n\\t.PROCEND\\n\");\n+}\n+\n+rtx\n+gen_compare_reg (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode = SELECT_CC_MODE (code, x);\n+  rtx cc_reg = gen_rtx (REG, mode, 0);\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n+\t\t      gen_rtx (COMPARE, mode, x, y)));\n+\n+  return cc_reg;\n+}\n+\n+/* Return nonzero if TRIAL can go into the function epilogue's\n+   delay slot.  SLOT is the slot we are trying to fill.  */\n+\n+int\n+eligible_for_epilogue_delay (trial, slot)\n+     rtx trial;\n+     int slot;\n+{\n+  if (slot >= 1)\n+    return 0;\n+  if (GET_CODE (trial) != INSN\n+      || GET_CODE (PATTERN (trial)) != SET)\n+    return 0;\n+  if (get_attr_length (trial) != 1)\n+    return 0;\n+  return (leaf_function &&\n+\t  get_attr_in_branch_delay (trial) == IN_BRANCH_DELAY_TRUE);\n+}\n+\n+rtx\n+gen_scond_fp (code, operand0)\n+     enum rtx_code code;\n+     rtx operand0;\n+{\n+  return gen_rtx (SET, VOIDmode, operand0,\n+\t\t  gen_rtx (code, CCFPmode,\n+\t\t\t   gen_rtx (REG, CCFPmode, 0), const0_rtx));\n+}\n+\n+void\n+emit_bcond_fp (code, operand0)\n+     enum rtx_code code;\n+     rtx operand0;\n+{\n+  emit_jump_insn (gen_rtx (SET, VOIDmode, pc_rtx,\n+\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n+\t\t\t\t    gen_rtx (code, VOIDmode, \n+\t\t\t\t\t     gen_rtx (REG, CCFPmode, 0),\n+\t\t\t\t\t     const0_rtx),\n+\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, operand0),\n+\t\t\t\t    pc_rtx)));\n+\n+}\n+\n+rtx\n+gen_cmp_fp (code, operand0, operand1)\n+     enum rtx_code code;\n+     rtx operand0, operand1;\n+{\n+  return gen_rtx (SET, VOIDmode, gen_rtx (REG, CCFPmode, 0),\n+\t\t  gen_rtx (code, CCFPmode, operand0, operand1));\n+}\n+\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+\n+void\n+print_operand (file, x, code)\n+     FILE *file;\n+     rtx x;\n+     int code;\n+{\n+  switch (code)\n+    {\n+    case '#':\n+      /* Output a 'nop' if there's nothing for the delay slot.  */\n+      if (dbr_sequence_length () == 0)\n+\tfputs (\"\\n\\tnop\", file);\n+      return;\n+    case '*':\n+      /* Output an nullification completer if there's nothing for the */\n+      /* delay slot or nullification is requested.  */ \n+      if (dbr_sequence_length () == 0 ||\n+\t  (final_sequence &&\n+\t   INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))))\n+        fputs (\",n\", file);\n+      return;\n+    case 'R':\n+      /* Print out the second register name of a register pair.\n+\t I.e., R (6) => 7.  */\n+      fputs (reg_names[REGNO (x)+1], file);\n+      return;\n+    case 'r':\n+      /* A register or zero. */\n+      if (x == const0_rtx)\n+\t{\n+\t  fputs (\"0\", file);\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case 'O':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase PLUS:\n+\t  fprintf (file, \"add%s\",\n+\t\t   GET_CODE (XEXP (x, 1)) == CONST_INT ? \"i\" : \"\");  break;\n+\tcase MINUS:\n+\t  fprintf (file, \"sub%s\",\n+\t\t   GET_CODE (XEXP (x, 0)) == CONST_INT ? \"i\" : \"\");  break;\n+\tcase AND:\n+\t  fprintf (file, \"and%s\",\n+\t\t   GET_CODE (XEXP (x, 1)) == NOT ? \"cm\" : \"\");  break;\n+\tcase IOR:\n+\t  fprintf (file, \"or\");  break;\n+\tcase XOR:\n+\t  fprintf (file, \"xor\");  break;\n+\tcase ASHIFT:\n+\t  fprintf (file, \"sh%dadd\", INTVAL (XEXP (x, 1)));  break;\n+\t  /* Too lazy to handle bitfield conditions yet.  */\n+\tdefault:\n+\t  printf (\"Can't grok '%c' operator:\\n\", code);\n+\t  debug_rtx (x);\n+\t  abort ();\n+\t}\n+      return;\n+    case 'C':\n+    case 'X':\n+      switch (GET_CODE (x))\n+\t{\t\n+\tcase EQ:\n+\t  fprintf (file, \"=\");  break;\n+\tcase NE:\n+\t  if (code == 'C')\n+\t    fprintf (file, \"<>\");\n+\t  else\n+\t    fprintf (file, \"!=\");\n+\t  break;\n+\tcase GT:\n+\t  fprintf (file, \">\");  break;\n+\tcase GE:\n+\t  fprintf (file, \">=\");  break;\n+\tcase GEU:\n+\t  fprintf (file, \">>=\");  break;\n+\tcase GTU:\n+\t  fprintf (file, \">>\");  break;\n+\tcase LT:\n+\t  fprintf (file, \"<\");  break;\n+\tcase LE:\n+\t  fprintf (file, \"<=\");  break;\n+\tcase LEU:\n+\t  fprintf (file, \"<<=\");  break;\n+\tcase LTU:\n+\t  fprintf (file, \"<<\");  break;\n+\tdefault:\n+\t  printf (\"Can't grok '%c' operator:\\n\", code);\n+\t  debug_rtx (x);\n+\t  abort ();\n+\t}\n+      return;\n+    case 'N':\n+    case 'Y':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:\n+\t  if (code == 'N')\n+\t    fprintf (file, \"<>\");\n+\t  else\n+\t    fprintf (file, \"!=\");\n+\t  break;\n+\tcase NE:\n+\t  fprintf (file, \"=\");  break;\n+\tcase GT:\n+\t  fprintf (file, \"<=\");  break;\n+\tcase GE:\n+\t  fprintf (file, \"<\");  break;\n+\tcase GEU:\n+\t  fprintf (file, \"<<\");  break;\n+\tcase GTU:\n+\t  fprintf (file, \"<<=\");  break;\n+\tcase LT:\n+\t  fprintf (file, \">=\");  break;\n+\tcase LE:\n+\t  fprintf (file, \">\");  break;\n+\tcase LEU:\n+\t  fprintf (file, \">>\");  break;\n+\tcase LTU:\n+\t  fprintf (file, \">>=\");  break;\n+\tdefault:\n+\t  printf (\"Can't grok '%c' operator:\\n\", code);\n+\t  debug_rtx (x);\n+\t  abort ();\n+\t}\n+      return;\n+    case 'M':\n+      switch (GET_CODE (XEXP (x, 0)))\n+\t{\n+\tcase PRE_DEC:\n+\tcase PRE_INC:\n+\t  fprintf (file, \"s,mb\");\n+\t  break;\n+\tcase POST_DEC:\n+\tcase POST_INC:\n+\t  fprintf (file, \"s,ma\");\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      return;\n+    case 'F':\n+      switch (GET_CODE (XEXP (x, 0)))\n+\t{\n+\tcase PRE_DEC:\n+\tcase PRE_INC:\n+\t  fprintf (file, \",mb\");\n+\t  break;\n+\tcase POST_DEC:\n+\tcase POST_INC:\n+\t  fprintf (file, \",ma\");\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      return;\n+    case 'G':\n+      output_global_address (file, x);\n+      return;\n+    case 0:\t\t\t/* Don't do anything special */\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (GET_CODE (x) == REG)\n+    fprintf (file, \"%s\", reg_names [REGNO (x)]);\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      int size = GET_MODE_SIZE (GET_MODE (x));\n+      rtx base = XEXP (XEXP (x, 0), 0);\n+      switch (GET_CODE (XEXP (x, 0)))\n+\t{\n+\tcase PRE_DEC:\n+\tcase POST_DEC:\n+\t  fprintf (file, \"-%d(0,%s)\", size, reg_names [REGNO (base)]);\n+\t  break;\n+\tcase PRE_INC:\n+\tcase POST_INC:\n+\t  fprintf (file, \"%d(0,%s)\", size, reg_names [REGNO (base)]);\n+\t  break;\n+\tdefault:\n+\t  output_address (XEXP (x, 0));\n+\t  break;\n+\t}\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n+    {\n+      union { double d; int i[2]; } u;\n+      union { float f; int i; } u1;\n+      u.i[0] = XINT (x, 0); u.i[1] = XINT (x, 1);\n+      u1.f = u.d;\n+      if (code == 'f')\n+\tfprintf (file, \"0r%.9g\", u1.f);\n+      else\n+\tfprintf (file, \"0x%x\", u1.i);\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != DImode)\n+    {\n+      union { double d; int i[2]; } u;\n+      u.i[0] = XINT (x, 0); u.i[1] = XINT (x, 1);\n+      fprintf (file, \"0r%.20g\", u.d);\n+    }\n+  else\n+    output_addr_const (file, x);\n+}\n+\n+/* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF. */\n+\n+void\n+output_global_address (file, x)\n+     FILE *file;\n+     rtx x;\n+{\n+  if (GET_CODE (x) == SYMBOL_REF && read_only_operand (x))\n+    assemble_name (file, XSTR (x, 0));\n+  else if (GET_CODE (x) == SYMBOL_REF)\n+    {\n+      assemble_name (file, XSTR (x, 0));\n+      fprintf (file, \"-$global$\");\n+    }\n+  else if (GET_CODE (x) == CONST)\n+    {\n+      char *sep = \"\";\n+      int offset = 0;\t\t/* assembler wants -$global$ at end */\n+      rtx base;\n+\t  \n+      if (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)\n+\t{\n+\t  base = XEXP (XEXP (x, 0), 0);\n+\t  output_addr_const (file, base);\n+\t}\n+      else if (GET_CODE (XEXP (XEXP (x, 0), 0)) == CONST_INT)\n+\toffset = INTVAL (XEXP (XEXP (x, 0), 0));\n+      else abort ();\n+\n+      if (GET_CODE (XEXP (XEXP (x, 0), 1)) == SYMBOL_REF)\n+\t{\n+\t  base = XEXP (XEXP (x, 0), 1);\n+\t  output_addr_const (file, base);\n+\t}\n+      else if (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+\toffset = INTVAL (XEXP (XEXP (x, 0),1));\n+      else abort ();\n+\n+      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+\t{\n+\t  if (offset < 0)\n+\t    {\n+\t      offset = -offset;\n+\t      sep = \"-\";\n+\t    }\n+\t  else\n+\t    sep = \"+\";\n+\t}\n+      else if (GET_CODE (XEXP (x, 0)) == MINUS\n+\t       && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF))\n+\tsep = \"-\";\n+      else abort ();\n+\n+      if (!read_only_operand (base))\n+\tfprintf (file, \"-$global$\");\n+      fprintf (file, \"%s\", sep);\n+      if (offset) fprintf (file,\"%d\", offset);\n+    }\n+  else\n+    output_addr_const (file, x);\n+}\n+\n+/* MEM rtls here are never SYMBOL_REFs (I think), so fldws is safe. */\n+\n+char *\n+output_floatsisf2 (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"fldws %1,%0\\n\\tfcnvxf,sgl,sgl %0,%0\";\n+  else if (FP_REG_P (operands[1]))\n+    return \"fcnvxf,sgl,sgl %1,%0\";\n+  return \"stwm %r1,4(0,30)\\n\\tfldws,mb -4(0,30),%0\\n\\tfcnvxf,sgl,sgl %0,%0\";\n+}\n+\n+char *\n+output_floatsidf2 (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"fldws %1,%0\\n\\tfcnvxf,sgl,dbl %0,%0\";\n+  else if (FP_REG_P (operands[1]))\n+    return \"fcnvxf,sgl,dbl %1,%0\";\n+  return \"stwm %r1,4(0,30)\\n\\tfldws,mb -4(0,30),%0\\n\\tfcnvxf,sgl,dbl %0,%0\";\n+}\n+\n+enum rtx_code\n+reverse_relop (code)\n+     enum rtx_code code;\n+{\n+  switch (code)\n+    {\n+    case GT:\n+      return LT;\n+    case LT:\n+      return GT;\n+    case GE:\n+      return LE;\n+    case LE:\n+      return GE;\n+    case LTU:\n+      return GTU;\n+    case GTU:\n+      return LTU;\n+    case GEU:\n+      return LEU;\n+    case LEU:\n+      return GEU;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* HP's millicode routines mean something special to the assembler.\n+   Keep track of which ones we have used.  */\n+\n+enum millicodes { remI, remU, divI, divU, mulI, mulU, end1000 };\n+static char imported[(int)end1000];\n+static char *milli_names[] = {\"remI\", \"remU\", \"divI\", \"divU\", \"mulI\", \"mulU\"};\n+static char import_string[] = \".IMPORT $$....,MILLICODE\";\n+#define MILLI_START 10\n+\n+static int\n+import_milli (code)\n+     enum millicodes code;\n+{\n+  char str[sizeof (import_string)];\n+  \n+  if (!imported[(int)code])\n+    {\n+      imported[(int)code] = 1;\n+      strcpy (str, import_string);\n+      strncpy (str + MILLI_START, milli_names[(int)code], 4);\n+      output_asm_insn (str, 0);\n+    }\n+}\n+\n+/* The register constraints have put the operands and return value in \n+   the proper registers. */\n+\n+char *\n+output_mul_insn (unsignedp)\n+     int unsignedp;\n+{\n+  if (unsignedp)\n+    {\n+      import_milli (mulU);\n+      return \"bl $$mulU,31\\n\\tnop\";\n+    }\n+  else\n+    {\n+      import_milli (mulI);\n+      return \"bl $$mulI,31\\n\\tnop\";\n+    }\n+}\n+\n+/* If operands isn't NULL, then it's a CONST_INT with which we can do\n+   something */\n+\n+\n+/* Emit the rtl for doing a division by a constant. */\n+\n+ /* Do magic division millicodes exist for this value? */\n+\n+static int magic_milli[]= {0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0,\n+\t\t\t     1, 1};\n+\n+/* We'll use an array to keep track of the magic millicodes and \n+   whether or not we've used them already. [n][0] is signed, [n][1] is\n+   unsigned. */\n+\n+\n+static int div_milli[16][2];\n+\n+int\n+div_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (mode == SImode\n+\t  && ((GET_CODE (op) == REG && REGNO (op) == 25)\n+\t      || (GET_CODE (op) == CONST_INT && INTVAL (op) > 0\n+\t\t  && INTVAL (op) < 16 && magic_milli[INTVAL (op)])));\n+}\n+\n+int\n+emit_hpdiv_const (operands, unsignedp)\n+     rtx *operands;\n+     int unsignedp;\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) > 0\n+      && INTVAL (operands[2]) < 16\n+      && magic_milli[INTVAL (operands[2])])\n+    {\n+      emit_move_insn ( gen_rtx (REG, SImode, 26), operands[1]);\n+      emit\n+\t(gen_rtx\n+\t (PARALLEL, VOIDmode,\n+\t  gen_rtvec (5, gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 29),\n+\t\t\t\t gen_rtx (unsignedp ? UDIV : DIV, SImode,\n+\t\t\t\t\t  gen_rtx (REG, SImode, 26),\n+\t\t\t\t\t  operands[2])),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 26)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 25)),\n+\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 31)))));\n+      emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+char *\n+output_div_insn (operands, unsignedp)\n+     rtx *operands;\n+     int unsignedp;\n+{\n+  int divisor;\n+  \n+  /* If the divisor is a constant, try to use one of the special \n+     opcodes .*/\n+  if (GET_CODE (operands[0]) == CONST_INT)\n+    {\n+      divisor = INTVAL (operands[0]);\n+      if (!div_milli[divisor][unsignedp])\n+\t{\n+\t  if (unsignedp)\n+\t    output_asm_insn (\".IMPORT $$divU_%0,MILLICODE\", operands);\n+\t  else\n+\t    output_asm_insn (\".IMPORT $$divI_%0,MILLICODE\", operands);\n+\t  div_milli[divisor][unsignedp] = 1;\n+\t}\n+      if (unsignedp)\n+\treturn \"bl $$divU_%0,31%#\";\n+      return \"bl $$divI_%0,31%#\";\n+    }\n+  /* Divisor isn't a special constant. */\n+  else\n+    {\n+      if (unsignedp)\n+\t{\n+\t  import_milli (divU);\n+\t  return \"bl $$divU,31%#\";\n+\t}\n+      else\n+\t{\n+\t  import_milli (divI);\n+\t  return \"bl $$divI,31%#\";\n+\t}\n+    }\n+}\n+\n+/* Output a $$rem millicode to do mod. */\n+\n+char *\n+output_mod_insn (unsignedp)\n+     int unsignedp;\n+{\n+  if (unsignedp)\n+    {\n+      import_milli (remU);\n+      return \"bl $$remU,31%#\";\n+    }\n+  else\n+    {\n+      import_milli (remI);\n+      return \"bl $$remI,31%#\";\n+    }\n+}\n+\n+void\n+output_arg_descriptor (insn)\n+     rtx insn;\n+{\n+  char *arg_regs[4];\n+  enum machine_mode arg_mode;\n+  rtx prev_insn;\n+  int i, output_flag = 0;\n+  int regno;\n+  \n+  for (i = 0; i < 4; i++)\n+    arg_regs[i] = 0;\n+\n+  for (prev_insn = PREV_INSN (insn); GET_CODE (prev_insn) == INSN;\n+       prev_insn = PREV_INSN (prev_insn))\n+    {\n+      if (!(GET_CODE (PATTERN (prev_insn)) == USE &&\n+\t    GET_CODE (XEXP (PATTERN (prev_insn), 0)) == REG &&\n+\t    FUNCTION_ARG_REGNO_P (REGNO (XEXP (PATTERN (prev_insn), 0)))))\n+\tbreak;\n+      arg_mode = GET_MODE (XEXP (PATTERN (prev_insn), 0));\n+      regno = REGNO (XEXP (PATTERN (prev_insn), 0));\n+      if (regno >= 23 && regno <= 26)\n+\targ_regs[26 - regno] = \"GR\";\n+      else if (!TARGET_SNAKE)\t/* fp args */\n+\t{\n+\t  if (arg_mode == SFmode)\n+\t    arg_regs[regno - 36] = \"FR\";\n+\t  else\n+\t    {\n+#ifdef HP_FP_ARG_DESCRIPTOR_REVERSED\n+\t      arg_regs[regno - 37] = \"FR\";\n+\t      arg_regs[regno - 36] = \"FU\";\n+#else\n+\t      arg_regs[regno - 37] = \"FU\";\n+\t      arg_regs[regno - 36] = \"FR\";\n+#endif\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (arg_mode == SFmode)\n+\t    arg_regs[(regno - 56) / 2] = \"FR\";\n+\t  else\n+\t    {\n+#ifdef HP_FP_ARG_DESCRIPTOR_REVERSED\n+\t      arg_regs[(regno - 58) / 2] = \"FR\";\n+\t      arg_regs[(regno - 58) / 2 + 1] = \"FU\";\n+#else\n+\t      arg_regs[(regno - 58) / 2] = \"FU\";\n+\t      arg_regs[(regno - 58) / 2 + 1] = \"FR\";\n+#endif\n+\t    }\n+\t}\n+    }\n+  fputs (\"\\t.CALL \", asm_out_file);\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (arg_regs[i])\n+\t{\n+\t  if (output_flag++)\n+\t    fputc (',', asm_out_file);\n+\t  fprintf (asm_out_file, \"ARGW%d=%s\", i, arg_regs[i]);\n+\t}\n+    }\n+  fputc ('\\n', asm_out_file);\n+}\n+\f\n+/* Memory loads/stores to/from fp registers may need a scratch\n+   register in which to reload the address. */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = true_regnum (in);\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    regno = -1;\n+\n+  if (class == FP_REGS || class == SNAKE_FP_REGS || class == HI_SNAKE_FP_REGS)\n+    {\n+      if (regno == -1 || !REGNO_OK_FOR_FP_P (regno))\n+\treturn GENERAL_REGS;\n+    }\n+  return NO_REGS;\n+}\n+\n+enum direction\n+function_arg_padding (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  int size;\n+\n+  if (mode == BLKmode)\n+    {\n+      if (type && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+\tsize = int_size_in_bytes (type) * BITS_PER_UNIT;\n+      else\n+\treturn upward;\t\t/* Don't know if this is right, but */\n+\t\t\t\t/* same as old definition. */\n+    }\n+  else\n+    size = GET_MODE_BITSIZE (mode);\n+  if (size < PARM_BOUNDARY)\n+    return downward;\n+  else if (size % PARM_BOUNDARY)\n+    return upward;\n+  else\n+    return none;\n+}\n+\n+int\n+use_milli_regs (insn)\n+     rtx insn;\n+{\n+  return (reg_mentioned_p (gen_rtx (REG, SImode, 1), insn) ||\n+\t  reg_mentioned_p (gen_rtx (REG, SImode, 25), insn) ||\n+\t  reg_mentioned_p (gen_rtx (REG, SImode, 26), insn) ||\n+\t  reg_mentioned_p (gen_rtx (REG, SImode, 29), insn) ||\n+\t  reg_mentioned_p (gen_rtx (REG, SImode, 31), insn));\n+}\n+\f\n+/* Do what is necessary for `va_start'.  The argument is ignored;\n+   We look at the current function to determine if stdargs or varargs\n+   is used and fill in an initial va_list.  A pointer to this constructor\n+   is returned.  */\n+\n+struct rtx_def *\n+hppa_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  rtx block, float_addr, offset, float_mem;\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  int argadj = ((!(TYPE_ARG_TYPES (fntype) != 0\n+\t\t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t       != void_type_node)))\n+\t\t? UNITS_PER_WORD : 0);\n+\n+  if (argadj)\n+    offset = plus_constant (current_function_arg_offset_rtx, argadj);\n+  else\n+    offset = current_function_arg_offset_rtx;\n+  /* Allocate the va_list structure. */\n+  block = assign_stack_local (BLKmode, 4 * UNITS_PER_WORD, BITS_PER_UNIT);\n+  RTX_UNCHANGING_P (block) = 1;\n+  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+  /* \n+   * Store a pointer to where arguments should begin on the stack in \n+   * __va_stack_start. \n+   */\n+  emit_move_insn (change_address (block, Pmode, XEXP (block, 0)),\n+\t\t  copy_to_reg\n+\t\t  (plus_constant (current_function_internal_arg_pointer,\n+\t\t\t\t  -16)));\n+  /* Store where to start getting args from in the __va_int member. */\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t UNITS_PER_WORD)),\n+\t\t  copy_to_reg (expand_binop (Pmode, add_optab,\n+\t\t\t\t\t     current_function_internal_arg_pointer,\n+\t\t\t\t\t     offset,\n+\t\t\t\t\t     0, 0, OPTAB_LIB_WIDEN)));\n+  /* Store general registers on the stack. */\n+  move_block_from_reg (23,\n+\t\t       gen_rtx (MEM, BLKmode,\n+\t\t\t\tplus_constant\n+\t\t\t\t(current_function_internal_arg_pointer, -16)),\n+\t\t       4); \n+  /* \n+   * Allocate space for the float args, and store it in the \n+   * __va_float member.\n+   */\n+  float_addr = copy_to_reg (XEXP (float_mem =\n+\t\t\t\t  assign_stack_local (BLKmode,\n+\t\t\t\t\t\t      4 * UNITS_PER_WORD, -1),\n+\t\t\t\t  0));\n+  MEM_IN_STRUCT_P (float_mem) = 1;\n+  RTX_UNCHANGING_P (float_mem) = 1;\n+  RTX_UNCHANGING_P (XEXP (float_mem, 0)) = 1;\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t 2 * UNITS_PER_WORD)),\n+\t\t  copy_to_reg (expand_binop (Pmode, add_optab,\n+\t\t\t\t\t     float_addr,\n+\t\t\t\t\t     plus_constant (offset, 4 *\n+\t\t\t\t\t\t\t    UNITS_PER_WORD),\n+\t\t\t\t\t     0, 0, OPTAB_LIB_WIDEN)));\n+  /* Store fp registers. */\n+  emit_move_insn (gen_rtx (MEM, SFmode, float_addr),\n+\t\t  gen_rtx (REG, SFmode, TARGET_SNAKE ? 60 : 39));\n+  emit_move_insn (gen_rtx (MEM, SFmode, gen_rtx (PLUS, Pmode, float_addr,\n+\t\t\t\t\t\t gen_rtx (CONST_INT,\n+\t\t\t\t\t\t\t  Pmode, 4))),\n+\t\t  gen_rtx (REG, SFmode, TARGET_SNAKE ? 58 : 38));\n+  emit_move_insn (gen_rtx (MEM, SFmode, gen_rtx (PLUS, Pmode, float_addr,\n+\t\t\t\t\t\t gen_rtx (CONST_INT,\n+\t\t\t\t\t\t\t  Pmode, 8))),\n+\t\t  gen_rtx (REG, SFmode, TARGET_SNAKE ? 56 : 37));\n+  emit_move_insn (gen_rtx (MEM, SFmode, gen_rtx (PLUS, Pmode, float_addr,\n+\t\t\t\t\t\t gen_rtx (CONST_INT,\n+\t\t\t\t\t\t\t  Pmode, 12))),\n+\t\t  gen_rtx (REG, SFmode, TARGET_SNAKE ? 54 : 36));\n+  /* \n+   * Allocate space for the double args, and store it in the \n+   * __va_double member.\n+   */\n+  float_addr = copy_to_reg (XEXP (float_mem =\n+\t\t\t\t  assign_stack_local (BLKmode,\n+\t\t\t\t\t\t      4 * UNITS_PER_WORD, -1),\n+\t\t\t\t  0));\n+  MEM_IN_STRUCT_P (float_mem) = 1;\n+  RTX_UNCHANGING_P (float_mem) = 1;\n+  RTX_UNCHANGING_P (XEXP (float_mem, 0)) = 1;\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t 3 * UNITS_PER_WORD)),\n+\t\t  copy_to_reg (expand_binop (Pmode, add_optab,\n+\t\t\t\t\t     float_addr,\n+\t\t\t\t\t     plus_constant (offset, 4 *\n+\t\t\t\t\t\t\t    UNITS_PER_WORD),\n+\t\t\t\t\t     0, 0, OPTAB_LIB_WIDEN)));\n+  /* Store fp registers as doubles. */\n+\n+  emit_move_insn (gen_rtx (MEM, DFmode, float_addr),\n+\t\t  (gen_rtx (REG, DFmode, TARGET_SNAKE ? 60 : 39)));\n+  emit_move_insn (gen_rtx (MEM, DFmode, gen_rtx (PLUS, Pmode, float_addr,\n+\t\t\t\t\t\t gen_rtx (CONST_INT,\n+\t\t\t\t\t\t\t  Pmode, 8))),\n+\t\t  gen_rtx (REG, DFmode, TARGET_SNAKE ? 56 : 37));\n+  return copy_to_reg (XEXP (block, 0));\n+}"}]}