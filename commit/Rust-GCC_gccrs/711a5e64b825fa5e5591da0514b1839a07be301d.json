{"sha": "711a5e64b825fa5e5591da0514b1839a07be301d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExYTVlNjRiODI1ZmE1ZTU1OTFkYTA1MTRiMTgzOWEwN2JlMzAxZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-18T14:31:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-18T14:31:51Z"}, "message": "(expand_shift): Don't try extzv for lshr.\n\nFrom-SVN: r7514", "tree": {"sha": "75dcbfb200596e9df01b0175c4880575cadb2b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75dcbfb200596e9df01b0175c4880575cadb2b1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711a5e64b825fa5e5591da0514b1839a07be301d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711a5e64b825fa5e5591da0514b1839a07be301d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711a5e64b825fa5e5591da0514b1839a07be301d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711a5e64b825fa5e5591da0514b1839a07be301d/comments", "author": null, "committer": null, "parents": [{"sha": "572e10f482971d72bfe077c25063c26ece0c89b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/572e10f482971d72bfe077c25063c26ece0c89b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/572e10f482971d72bfe077c25063c26ece0c89b4"}], "stats": {"total": 97, "additions": 4, "deletions": 93}, "files": [{"sha": "9abd37250bd87e98b6979d763e6143959ad6aa45", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 93, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711a5e64b825fa5e5591da0514b1839a07be301d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711a5e64b825fa5e5591da0514b1839a07be301d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=711a5e64b825fa5e5591da0514b1839a07be301d", "patch": "@@ -1749,99 +1749,10 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \t\t\t       shifted, op1, target, unsignedp, methods1);\n \t}\n \n-#ifdef HAVE_extzv\n-      /* We can do a logical (unsigned) right shift with a bit-field\n-\t extract insn.  But first check if one of the above methods worked.  */\n-      if (temp != 0)\n-\treturn temp;\n-\n-      if (unsignedp && code == RSHIFT_EXPR && ! BITS_BIG_ENDIAN && HAVE_extzv)\n-\t{\n-\t  enum machine_mode output_mode\n-\t    = insn_operand_mode[(int) CODE_FOR_extzv][0];\n-\n-\t  if ((methods == OPTAB_DIRECT && mode == output_mode)\n-\t      || (methods == OPTAB_WIDEN\n-\t\t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (output_mode)))\n-\t    {\n-\t      rtx shifted1 = convert_modes (output_mode, mode,\n-\t\t\t\t\t    protect_from_queue (shifted, 0),\n-\t\t\t\t\t    1);\n-\t      enum machine_mode length_mode\n-\t\t= insn_operand_mode[(int) CODE_FOR_extzv][2];\n-\t      enum machine_mode pos_mode\n-\t\t= insn_operand_mode[(int) CODE_FOR_extzv][3];\n-\t      rtx target1 = 0;\n-\t      rtx last = get_last_insn ();\n-\t      rtx width;\n-\t      rtx xop1 = op1;\n-\t      rtx pat;\n-\n-\t      if (target != 0)\n-\t\ttarget1 = protect_from_queue (target, 1);\n-\n-\t      /* We define extract insns as having OUTPUT_MODE in a register\n-\t\t and the mode of operand 1 in memory.  Since we want\n-\t\t OUTPUT_MODE, we will always force the operand into a\n-\t\t register.  At some point we might want to support MEM\n-\t\t directly. */\n-\t      shifted1 = force_reg (output_mode, shifted1);\n-\n-\t      /* If we don't have or cannot use a suggested target,\n-\t\t make a place for the result, in the proper mode.  */\n-\t      if (methods == OPTAB_WIDEN || target1 == 0\n-\t\t  || ! ((*insn_operand_predicate[(int) CODE_FOR_extzv][0])\n-\t\t\t(target1, output_mode)))\n-\t\ttarget1 = gen_reg_rtx (output_mode);\n-\n-\t      xop1 = protect_from_queue (xop1, 0);\n-\t      xop1 = convert_modes (pos_mode, TYPE_MODE (TREE_TYPE (amount)),\n-\t\t\t\t    xop1, TREE_UNSIGNED (TREE_TYPE (amount)));\n-\n-\t      /* If this machine's extzv insists on a register for\n-\t\t operand 3 (position), arrange for that.  */\n-\t      if (! ((*insn_operand_predicate[(int) CODE_FOR_extzv][3])\n-\t\t     (xop1, pos_mode)))\n-\t\txop1 = force_reg (pos_mode, xop1);\n-\n-\t      /* WIDTH gets the width of the bit field to extract:\n-\t\t wordsize minus # bits to shift by.  */\n-\t      if (GET_CODE (xop1) == CONST_INT)\n-\t\twidth = GEN_INT (GET_MODE_BITSIZE (mode) - INTVAL (op1));\n-\t      else\n-\t\t{\n-\t\t  /* Now get the width in the proper mode.  */\n-\t\t  op1 = protect_from_queue (op1, 0);\n-\t\t  width = convert_to_mode (length_mode, op1,\n-\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (amount)));\n-\n-\t\t  width = expand_binop (length_mode, sub_optab,\n-\t\t\t\t\tGEN_INT (GET_MODE_BITSIZE (mode)),\n-\t\t\t\t\twidth, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t\t}\n-\n-\t      /* If this machine's extzv insists on a register for\n-\t\t operand 2 (length), arrange for that.  */\n-\t      if (! ((*insn_operand_predicate[(int) CODE_FOR_extzv][2])\n-\t\t     (width, length_mode)))\n-\t\twidth = force_reg (length_mode, width);\n-\n-\t      /* Now extract with WIDTH, omitting OP1 least sig bits.  */\n-\t      pat = gen_extzv (target1, shifted1, width, xop1);\n-\t      if (pat)\n-\t\t{\n-\t\t  emit_insn (pat);\n-\t\t  temp = convert_to_mode (mode, target1, 1);\n-\t\t}\n-\t      else\n-\t\tdelete_insns_since (last);\n-\t    }\n-\n-\t  /* Can also do logical shift with signed bit-field extract\n-\t     followed by inserting the bit-field at a different position.\n-\t     That strategy is not yet implemented.  */\n-\t}\n-#endif /* HAVE_extzv */\n+      /* We used to try extzv here for logical right shifts, but that was\n+\t only useful for one machine, the VAX, and caused poor code \n+\t generation there for lshrdi3, so the code was deleted and a\n+\t define_expand for lshrsi3 was added to vax.md.  */\n     }\n \n   if (temp == 0)"}]}