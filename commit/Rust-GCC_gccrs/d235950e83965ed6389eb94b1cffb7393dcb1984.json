{"sha": "d235950e83965ed6389eb94b1cffb7393dcb1984", "node_id": "C_kwDOANBUbNoAKGQyMzU5NTBlODM5NjVlZDYzODllYjk0YjFjZmZiNzM5M2RjYjE5ODQ", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2021-10-27T21:26:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-11-09T09:44:49Z"}, "message": "[Ada] Improve integration of strub with type systems\n\ngcc/ada/\n\n\t* strub.adb, strub.ads: New files.\n\t* exp_attr.adb (Access_Cases): Copy strub mode to subprogram type.\n\t* exp_disp.adb (Expand_Dispatching_Call): Likewise.\n\t* freeze.adb (Check_Inherited_Conditions): Check that strub modes\n\tmatch overridden subprograms and interfaces.\n\t(Freeze_All): Renaming declarations too.\n\t* sem_attr.adb (Resolve_Attribute): Reject 'Access to\n\tstrub-annotated data object.\n\t* sem_ch3.adb (Derive_Subprogram): Copy strub mode to\n\tinherited subprogram.\n\t* sem_prag.adb (Analyze_Pragma): Propagate Strub Machine_Attribute\n\tfrom access-to-subprogram to subprogram type when required,\n\tbut not from access-to-data to data type.  Mark the entity that\n\tgot the pragma as having a gigi rep item.\n\t* sem_res.adb (Resolve): Reject implicit conversions that\n\twould change strub modes.\n\t(Resolve_Type_Conversions): Reject checked conversions\n\tbetween incompatible strub modes.\n\t* doc/gnat_rm/security_hardening_features.rst: Update.\n\t* gnat_rm.texi: Regenerate.\n\t* libgnat/a-except.ads (Raise_Exception): Revert strub-callable\n\tannotation in public subprogram.\n\t* libgnat/s-arit128.ads (Multiply_With_Ovflo_Check128): Likewise.\n\t* libgnat/s-arit64.ads (Multiply_With_Ovflo_Check64): Likewise.\n\t* libgnat/s-secsta.ads (SS_Allocate): Likewise.\n\t(SS_Mark, SS_Release): Likewise.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add ada/strub.o.", "tree": {"sha": "086c8bb0bf8a599bff945db1d15a8c516b7de39a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/086c8bb0bf8a599bff945db1d15a8c516b7de39a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d235950e83965ed6389eb94b1cffb7393dcb1984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d235950e83965ed6389eb94b1cffb7393dcb1984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d235950e83965ed6389eb94b1cffb7393dcb1984", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d235950e83965ed6389eb94b1cffb7393dcb1984/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d52cbe59b19577fa215a4357c327e707890e9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d52cbe59b19577fa215a4357c327e707890e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d52cbe59b19577fa215a4357c327e707890e9b"}], "stats": {"total": 834, "additions": 747, "deletions": 87}, "files": [{"sha": "bdcfd99ad865405b03efac9e090cb08921d11406", "filename": "gcc/ada/doc/gnat_rm/security_hardening_features.rst", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fsecurity_hardening_features.rst?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -73,20 +73,52 @@ Note that Ada secondary stacks are not scrubbed.  The restriction\n ``No_Secondary_Stack`` avoids their use, and thus their accidental\n preservation of data that should be scrubbed.\n \n-Also note that the machine attribute is not integrated in the Ada type\n-system.  Though it may modify subprogram and variable interfaces, it\n-is not fully reflected in Ada types, ``Access`` attributes, renaming\n-and overriding.  Every access type, renaming, and overriding and\n-overridden dispatching operations that may refer to an entity with an\n-attribute-modified interface must be annotated with the same\n-interface-modifying attribute, or with an interface-compatible one.\n-\n-Even then, the pragma is currently only functional when applied to\n-subprograms and scalar variables; other uses, such as directly on\n-types and subtypes, may be silently ignored.  Specifically, it is not\n-currently recommended to rely on any effects this pragma might be\n-expected to have when calling subprograms through access-to-subprogram\n-variables.\n+Attributes ``Access`` and ``Unconstrained_Access`` of variables and\n+constants with ``strub`` enabled require types with ``strub`` enabled;\n+there is no way to express an access-to-strub type otherwise.\n+``Unchecked_Access`` bypasses this constraint, but the resulting\n+access type designates a non-strub type.\n+\n+.. code-block:: ada\n+\n+     VI : Integer;\n+     XsVI : access Integer := VI'Access; -- Error.\n+     UXsVI : access Integer := VI'Unchecked_Access; -- OK,\n+     -- UXsVI.all does not enable strub in the enclosing subprogram.\n+\n+     type Strub_Int is new Integer;\n+     pragma Machine_Attribute (Strub_Int, \"strub\");\n+     VSI : Strub_Int;\n+     XsVSI : access Strub_Int := VSI'Access; -- OK.\n+     -- XsVSI.all enables strub in the enclosing subprogram.\n+\n+\n+Every access-to-subprogram type, renaming, and overriding and\n+overridden dispatching operations that may refer to a subprogram with\n+an attribute-modified interface must be annotated with the same\n+interface-modifying attribute.  Access-to-subprogram types can be\n+explicitly converted to different strub modes, as long as they are\n+interface-compatible (i.e., adding or removing ``at-calls`` is not\n+allowed).  For example, a ``strub``-``disabled`` subprogram can be\n+turned ``callable`` through such an explicit conversion:\n+\n+.. code-block:: ada\n+\n+     type TBar is access procedure;\n+\n+     type TBar_Callable is access procedure;\n+     pragma Machine_Attribute (TBar_Callable, \"strub\", \"callable\");\n+\n+     Bar_Callable_Ptr : constant TBar_Callable\n+\t\t:= TBar_Callable (TBar'(Bar'Access));\n+\n+     procedure Bar_Callable renames Bar_Callable_Ptr.all;\n+     pragma Machine_Attribute (Bar_Callable, \"strub\", \"callable\");\n+\n+Note that the renaming declaration is expanded to a full subprogram\n+body, it won't be just an alias.  Only if it is inlined will it be as\n+efficient as a call by dereferencing the access-to-subprogram constant\n+Bar_Callable_Ptr.\n \n \n .. Hardened Conditionals:"}, {"sha": "33ac8bde63558176fb114703a2b1307019270aee", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -67,6 +67,7 @@ with Sinfo.Utils;    use Sinfo.Utils;\n with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with Tbuild;         use Tbuild;\n with Ttypes;         use Ttypes;\n with Uintp;          use Uintp;\n@@ -2162,6 +2163,7 @@ package body Exp_Attr is\n \n                   begin\n                      Subp_Typ := Create_Itype (E_Subprogram_Type, N);\n+                     Copy_Strub_Mode (Subp_Typ, Subp);\n                      Set_Etype (Subp_Typ, Etype (Subp));\n                      Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n "}, {"sha": "de2ba7a562b02c7a29e652758e3dfead82ceb398", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -66,6 +66,7 @@ with Sinfo.Utils;    use Sinfo.Utils;\n with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with SCIL_LL;        use SCIL_LL;\n with Tbuild;         use Tbuild;\n \n@@ -846,6 +847,7 @@ package body Exp_Disp is\n       end if;\n \n       Subp_Typ     := Create_Itype (E_Subprogram_Type, Call_Node);\n+      Copy_Strub_Mode (Subp_Typ, Subp);\n       Subp_Ptr_Typ := Create_Itype (E_Access_Subprogram_Type, Call_Node);\n       Set_Etype          (Subp_Typ, Res_Typ);\n       Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));"}, {"sha": "726e20073fc7d5f4beb8eef300c5b491ba8a491b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -69,6 +69,7 @@ with Sinfo.Utils;    use Sinfo.Utils;\n with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with Targparm;       use Targparm;\n with Tbuild;         use Tbuild;\n with Ttypes;         use Ttypes;\n@@ -1790,6 +1791,10 @@ package body Freeze is\n          return Result;\n       end Needs_Wrapper;\n \n+      Ifaces_List    : Elist_Id;\n+      Ifaces_Listed  : Boolean := False;\n+      --  Cache the list of interface operations inherited by R\n+\n    --  Start of processing for Check_Inherited_Conditions\n \n    begin\n@@ -1823,11 +1828,10 @@ package body Freeze is\n       while Present (Op_Node) loop\n          Prim := Node (Op_Node);\n \n-         if Present (Overridden_Operation (Prim))\n+         Par_Prim := Overridden_Operation (Prim);\n+         if Present (Par_Prim)\n            and then Comes_From_Source (Prim)\n          then\n-            Par_Prim := Overridden_Operation (Prim);\n-\n             --  When the primitive is an LSP wrapper we climb to the parent\n             --  primitive that has the inherited contract.\n \n@@ -1837,6 +1841,11 @@ package body Freeze is\n                Par_Prim := LSP_Subprogram (Par_Prim);\n             end if;\n \n+            --  Check that overrider and overridden operations have\n+            --  the same strub mode.\n+\n+            Check_Same_Strub_Mode (Prim, Par_Prim);\n+\n             --  Analyze the contract items of the overridden operation, before\n             --  they are rewritten as pragmas.\n \n@@ -1852,6 +1861,54 @@ package body Freeze is\n             end if;\n          end if;\n \n+         --  Go over operations inherited from interfaces and check\n+         --  them for strub mode compatibility as well.\n+\n+         if Has_Interfaces (R)\n+           and then Is_Dispatching_Operation (Prim)\n+           and then Find_Dispatching_Type (Prim) = R\n+         then\n+            declare\n+               Elmt        : Elmt_Id;\n+               Iface_Elmt  : Elmt_Id;\n+               Iface       : Entity_Id;\n+               Iface_Prim  : Entity_Id;\n+\n+            begin\n+               --  Collect the interfaces only once. We haven't\n+               --  finished freezing yet, so we can't use the faster\n+               --  search from Sem_Disp.Covered_Interface_Primitives.\n+\n+               if not Ifaces_Listed then\n+                  Collect_Interfaces (R, Ifaces_List);\n+                  Ifaces_Listed := True;\n+               end if;\n+\n+               Iface_Elmt := First_Elmt (Ifaces_List);\n+               while Present (Iface_Elmt) loop\n+                  Iface := Node (Iface_Elmt);\n+\n+                  Elmt := First_Elmt (Primitive_Operations (Iface));\n+                  while Present (Elmt) loop\n+                     Iface_Prim := Node (Elmt);\n+\n+                     if Iface_Prim /= Par_Prim\n+                       and then Chars (Iface_Prim) = Chars (Prim)\n+                       and then Comes_From_Source (Iface_Prim)\n+                       and then (Is_Interface_Conformant\n+                                   (R, Iface_Prim, Prim))\n+                     then\n+                        Check_Same_Strub_Mode (Prim, Iface_Prim);\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+\n          Next_Elmt (Op_Node);\n       end loop;\n \n@@ -2504,6 +2561,18 @@ package body Freeze is\n                Process_Default_Expressions (E, After);\n             end if;\n \n+            --  Check subprogram renamings for the same strub-mode.\n+            --  Avoid rechecking dispatching operations, that's taken\n+            --  care of in Check_Inherited_Conditions, that covers\n+            --  inherited interface operations.\n+\n+            Item := Alias (E);\n+            if Present (Item)\n+              and then not Is_Dispatching_Operation (E)\n+            then\n+               Check_Same_Strub_Mode (E, Item);\n+            end if;\n+\n             if not Has_Completion (E) then\n                Decl := Unit_Declaration_Node (E);\n "}, {"sha": "ae5158a54843e4c35185f226f069aeda4eccc992", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -440,6 +440,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/sprint.o\t\\\n  ada/stand.o\t\\\n  ada/stringt.o\t\\\n+ ada/strub.o\t\\\n  ada/style.o\t\\\n  ada/styleg.o\t\\\n  ada/stylesw.o\t\\"}, {"sha": "a8232f2361fae0f4ab764cd5227632bbff86b45f", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 116, "deletions": 41, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Oct 25, 2021\n+GNAT Reference Manual , Nov 08, 2021\n \n AdaCore\n \n@@ -883,6 +883,7 @@ Security Hardening Features\n \n * Register Scrubbing:: \n * Stack Scrubbing:: \n+* Hardened Conditionals:: \n \n Obsolescent Features\n \n@@ -28864,6 +28865,7 @@ are provided by GNAT.\n @menu\n * Register Scrubbing:: \n * Stack Scrubbing:: \n+* Hardened Conditionals:: \n \n @end menu\n \n@@ -28895,7 +28897,7 @@ For usage and more details on the command line option, and on the\n \n @c Stack Scrubbing:\n \n-@node Stack Scrubbing,,Register Scrubbing,Security Hardening Features\n+@node Stack Scrubbing,Hardened Conditionals,Register Scrubbing,Security Hardening Features\n @anchor{gnat_rm/security_hardening_features stack-scrubbing}@anchor{43e}\n @section Stack Scrubbing\n \n@@ -28930,23 +28932,96 @@ Note that Ada secondary stacks are not scrubbed.  The restriction\n @code{No_Secondary_Stack} avoids their use, and thus their accidental\n preservation of data that should be scrubbed.\n \n-Also note that the machine attribute is not integrated in the Ada type\n-system.  Though it may modify subprogram and variable interfaces, it\n-is not fully reflected in Ada types, @code{Access} attributes, renaming\n-and overriding.  Every access type, renaming, and overriding and\n-overridden dispatching operations that may refer to an entity with an\n-attribute-modified interface must be annotated with the same\n-interface-modifying attribute, or with an interface-compatible one.\n-\n-Even then, the pragma is currently only functional when applied to\n-subprograms and scalar variables; other uses, such as directly on\n-types and subtypes, may be silently ignored.  Specifically, it is not\n-currently recommended to rely on any effects this pragma might be\n-expected to have when calling subprograms through access-to-subprogram\n-variables.\n+Attributes @code{Access} and @code{Unconstrained_Access} of variables and\n+constants with @code{strub} enabled require types with @code{strub} enabled;\n+there is no way to express an access-to-strub type otherwise.\n+@code{Unchecked_Access} bypasses this constraint, but the resulting\n+access type designates a non-strub type.\n+\n+@example\n+VI : Integer;\n+XsVI : access Integer := VI'Access; -- Error.\n+UXsVI : access Integer := VI'Unchecked_Access; -- OK,\n+-- UXsVI.all does not enable strub in the enclosing subprogram.\n+\n+type Strub_Int is new Integer;\n+pragma Machine_Attribute (Strub_Int, \"strub\");\n+VSI : Strub_Int;\n+XsVSI : access Strub_Int := VSI'Access; -- OK.\n+-- XsVSI.all enables strub in the enclosing subprogram.\n+@end example\n+\n+Every access-to-subprogram type, renaming, and overriding and\n+overridden dispatching operations that may refer to a subprogram with\n+an attribute-modified interface must be annotated with the same\n+interface-modifying attribute.  Access-to-subprogram types can be\n+explicitly converted to different strub modes, as long as they are\n+interface-compatible (i.e., adding or removing @code{at-calls} is not\n+allowed).  For example, a @code{strub}-@code{disabled} subprogram can be\n+turned @code{callable} through such an explicit conversion:\n+\n+@example\n+type TBar is access procedure;\n+\n+type TBar_Callable is access procedure;\n+pragma Machine_Attribute (TBar_Callable, \"strub\", \"callable\");\n+\n+Bar_Callable_Ptr : constant TBar_Callable\n+           := TBar_Callable (TBar'(Bar'Access));\n+\n+procedure Bar_Callable renames Bar_Callable_Ptr.all;\n+pragma Machine_Attribute (Bar_Callable, \"strub\", \"callable\");\n+@end example\n+\n+Note that the renaming declaration is expanded to a full subprogram\n+body, it won\u2019t be just an alias.  Only if it is inlined will it be as\n+efficient as a call by dereferencing the access-to-subprogram constant\n+Bar_Callable_Ptr.\n+\n+@c Hardened Conditionals:\n+\n+@node Hardened Conditionals,,Stack Scrubbing,Security Hardening Features\n+@anchor{gnat_rm/security_hardening_features hardened-conditionals}@anchor{43f}\n+@section Hardened Conditionals\n+\n+\n+GNAT can harden conditionals to protect against control flow attacks.\n+\n+This is accomplished by two complementary transformations, each\n+activated by a separate command-line option.\n+\n+The option @emph{-fharden-compares} enables hardening of compares that\n+compute results stored in variables, adding verification that the\n+reversed compare yields the opposite result.\n+\n+The option @emph{-fharden-conditional-branches} enables hardening of\n+compares that guard conditional branches, adding verification of the\n+reversed compare to both execution paths.\n+\n+These transformations are introduced late in the compilation pipeline,\n+long after boolean expressions are decomposed into separate compares,\n+each one turned into either a conditional branch or a compare whose\n+result is stored in a boolean variable or temporary.  Compiler\n+optimizations, if enabled, may also turn conditional branches into\n+stored compares, and vice-versa, or into operations with implied\n+conditionals (e.g. MIN and MAX).  Conditionals may also be optimized\n+out entirely, if their value can be determined at compile time, and\n+occasionally multiple compares can be combined into one.\n+\n+It is thus difficult to predict which of these two options will affect\n+a specific compare operation expressed in source code.  Using both\n+options ensures that every compare that is neither optimized out nor\n+optimized into implied conditionals will be hardened.\n+\n+The addition of reversed compares can be observed by enabling the dump\n+files of the corresponding passes, through command line options\n+@emph{-fdump-tree-hardcmp} and @emph{-fdump-tree-hardcbr}, respectively.\n+\n+They are separate options, however, because of the significantly\n+different performance impact of the hardening transformations.\n \n @node Obsolescent Features,Compatibility and Porting Guide,Security Hardening Features,Top\n-@anchor{gnat_rm/obsolescent_features doc}@anchor{43f}@anchor{gnat_rm/obsolescent_features id1}@anchor{440}@anchor{gnat_rm/obsolescent_features obsolescent-features}@anchor{16}\n+@anchor{gnat_rm/obsolescent_features doc}@anchor{440}@anchor{gnat_rm/obsolescent_features id1}@anchor{441}@anchor{gnat_rm/obsolescent_features obsolescent-features}@anchor{16}\n @chapter Obsolescent Features\n \n \n@@ -28965,7 +29040,7 @@ compatibility purposes.\n @end menu\n \n @node pragma No_Run_Time,pragma Ravenscar,,Obsolescent Features\n-@anchor{gnat_rm/obsolescent_features id2}@anchor{441}@anchor{gnat_rm/obsolescent_features pragma-no-run-time}@anchor{442}\n+@anchor{gnat_rm/obsolescent_features id2}@anchor{442}@anchor{gnat_rm/obsolescent_features pragma-no-run-time}@anchor{443}\n @section pragma No_Run_Time\n \n \n@@ -28978,7 +29053,7 @@ preferred usage is to use an appropriately configured run-time that\n includes just those features that are to be made accessible.\n \n @node pragma Ravenscar,pragma Restricted_Run_Time,pragma No_Run_Time,Obsolescent Features\n-@anchor{gnat_rm/obsolescent_features id3}@anchor{443}@anchor{gnat_rm/obsolescent_features pragma-ravenscar}@anchor{444}\n+@anchor{gnat_rm/obsolescent_features id3}@anchor{444}@anchor{gnat_rm/obsolescent_features pragma-ravenscar}@anchor{445}\n @section pragma Ravenscar\n \n \n@@ -28987,7 +29062,7 @@ The pragma @code{Ravenscar} has exactly the same effect as pragma\n is part of the new Ada 2005 standard.\n \n @node pragma Restricted_Run_Time,pragma Task_Info,pragma Ravenscar,Obsolescent Features\n-@anchor{gnat_rm/obsolescent_features id4}@anchor{445}@anchor{gnat_rm/obsolescent_features pragma-restricted-run-time}@anchor{446}\n+@anchor{gnat_rm/obsolescent_features id4}@anchor{446}@anchor{gnat_rm/obsolescent_features pragma-restricted-run-time}@anchor{447}\n @section pragma Restricted_Run_Time\n \n \n@@ -28997,7 +29072,7 @@ preferred since the Ada 2005 pragma @code{Profile} is intended for\n this kind of implementation dependent addition.\n \n @node pragma Task_Info,package System Task_Info s-tasinf ads,pragma Restricted_Run_Time,Obsolescent Features\n-@anchor{gnat_rm/obsolescent_features id5}@anchor{447}@anchor{gnat_rm/obsolescent_features pragma-task-info}@anchor{448}\n+@anchor{gnat_rm/obsolescent_features id5}@anchor{448}@anchor{gnat_rm/obsolescent_features pragma-task-info}@anchor{449}\n @section pragma Task_Info\n \n \n@@ -29023,7 +29098,7 @@ in the spec of package System.Task_Info in the runtime\n library.\n \n @node package System Task_Info s-tasinf ads,,pragma Task_Info,Obsolescent Features\n-@anchor{gnat_rm/obsolescent_features package-system-task-info}@anchor{449}@anchor{gnat_rm/obsolescent_features package-system-task-info-s-tasinf-ads}@anchor{44a}\n+@anchor{gnat_rm/obsolescent_features package-system-task-info}@anchor{44a}@anchor{gnat_rm/obsolescent_features package-system-task-info-s-tasinf-ads}@anchor{44b}\n @section package System.Task_Info (@code{s-tasinf.ads})\n \n \n@@ -29033,7 +29108,7 @@ to support the @code{Task_Info} pragma. The predefined Ada package\n standard replacement for GNAT\u2019s @code{Task_Info} functionality.\n \n @node Compatibility and Porting Guide,GNU Free Documentation License,Obsolescent Features,Top\n-@anchor{gnat_rm/compatibility_and_porting_guide doc}@anchor{44b}@anchor{gnat_rm/compatibility_and_porting_guide compatibility-and-porting-guide}@anchor{17}@anchor{gnat_rm/compatibility_and_porting_guide id1}@anchor{44c}\n+@anchor{gnat_rm/compatibility_and_porting_guide doc}@anchor{44c}@anchor{gnat_rm/compatibility_and_porting_guide compatibility-and-porting-guide}@anchor{17}@anchor{gnat_rm/compatibility_and_porting_guide id1}@anchor{44d}\n @chapter Compatibility and Porting Guide\n \n \n@@ -29055,7 +29130,7 @@ applications developed in other Ada environments.\n @end menu\n \n @node Writing Portable Fixed-Point Declarations,Compatibility with Ada 83,,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide id2}@anchor{44d}@anchor{gnat_rm/compatibility_and_porting_guide writing-portable-fixed-point-declarations}@anchor{44e}\n+@anchor{gnat_rm/compatibility_and_porting_guide id2}@anchor{44e}@anchor{gnat_rm/compatibility_and_porting_guide writing-portable-fixed-point-declarations}@anchor{44f}\n @section Writing Portable Fixed-Point Declarations\n \n \n@@ -29177,7 +29252,7 @@ If you follow this scheme you will be guaranteed that your fixed-point\n types will be portable.\n \n @node Compatibility with Ada 83,Compatibility between Ada 95 and Ada 2005,Writing Portable Fixed-Point Declarations,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-ada-83}@anchor{44f}@anchor{gnat_rm/compatibility_and_porting_guide id3}@anchor{450}\n+@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-ada-83}@anchor{450}@anchor{gnat_rm/compatibility_and_porting_guide id3}@anchor{451}\n @section Compatibility with Ada 83\n \n \n@@ -29205,7 +29280,7 @@ following subsections treat the most likely issues to be encountered.\n @end menu\n \n @node Legal Ada 83 programs that are illegal in Ada 95,More deterministic semantics,,Compatibility with Ada 83\n-@anchor{gnat_rm/compatibility_and_porting_guide id4}@anchor{451}@anchor{gnat_rm/compatibility_and_porting_guide legal-ada-83-programs-that-are-illegal-in-ada-95}@anchor{452}\n+@anchor{gnat_rm/compatibility_and_porting_guide id4}@anchor{452}@anchor{gnat_rm/compatibility_and_porting_guide legal-ada-83-programs-that-are-illegal-in-ada-95}@anchor{453}\n @subsection Legal Ada 83 programs that are illegal in Ada 95\n \n \n@@ -29305,7 +29380,7 @@ the fix is usually simply to add the @code{(<>)} to the generic declaration.\n @end itemize\n \n @node More deterministic semantics,Changed semantics,Legal Ada 83 programs that are illegal in Ada 95,Compatibility with Ada 83\n-@anchor{gnat_rm/compatibility_and_porting_guide id5}@anchor{453}@anchor{gnat_rm/compatibility_and_porting_guide more-deterministic-semantics}@anchor{454}\n+@anchor{gnat_rm/compatibility_and_porting_guide id5}@anchor{454}@anchor{gnat_rm/compatibility_and_porting_guide more-deterministic-semantics}@anchor{455}\n @subsection More deterministic semantics\n \n \n@@ -29333,7 +29408,7 @@ which open select branches are executed.\n @end itemize\n \n @node Changed semantics,Other language compatibility issues,More deterministic semantics,Compatibility with Ada 83\n-@anchor{gnat_rm/compatibility_and_porting_guide changed-semantics}@anchor{455}@anchor{gnat_rm/compatibility_and_porting_guide id6}@anchor{456}\n+@anchor{gnat_rm/compatibility_and_porting_guide changed-semantics}@anchor{456}@anchor{gnat_rm/compatibility_and_porting_guide id6}@anchor{457}\n @subsection Changed semantics\n \n \n@@ -29375,7 +29450,7 @@ covers only the restricted range.\n @end itemize\n \n @node Other language compatibility issues,,Changed semantics,Compatibility with Ada 83\n-@anchor{gnat_rm/compatibility_and_porting_guide id7}@anchor{457}@anchor{gnat_rm/compatibility_and_porting_guide other-language-compatibility-issues}@anchor{458}\n+@anchor{gnat_rm/compatibility_and_porting_guide id7}@anchor{458}@anchor{gnat_rm/compatibility_and_porting_guide other-language-compatibility-issues}@anchor{459}\n @subsection Other language compatibility issues\n \n \n@@ -29408,7 +29483,7 @@ include @code{pragma Interface} and the floating point type attributes\n @end itemize\n \n @node Compatibility between Ada 95 and Ada 2005,Implementation-dependent characteristics,Compatibility with Ada 83,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide compatibility-between-ada-95-and-ada-2005}@anchor{459}@anchor{gnat_rm/compatibility_and_porting_guide id8}@anchor{45a}\n+@anchor{gnat_rm/compatibility_and_porting_guide compatibility-between-ada-95-and-ada-2005}@anchor{45a}@anchor{gnat_rm/compatibility_and_porting_guide id8}@anchor{45b}\n @section Compatibility between Ada 95 and Ada 2005\n \n \n@@ -29480,7 +29555,7 @@ can declare a function returning a value from an anonymous access type.\n @end itemize\n \n @node Implementation-dependent characteristics,Compatibility with Other Ada Systems,Compatibility between Ada 95 and Ada 2005,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide id9}@anchor{45b}@anchor{gnat_rm/compatibility_and_porting_guide implementation-dependent-characteristics}@anchor{45c}\n+@anchor{gnat_rm/compatibility_and_porting_guide id9}@anchor{45c}@anchor{gnat_rm/compatibility_and_porting_guide implementation-dependent-characteristics}@anchor{45d}\n @section Implementation-dependent characteristics\n \n \n@@ -29503,7 +29578,7 @@ transition from certain Ada 83 compilers.\n @end menu\n \n @node Implementation-defined pragmas,Implementation-defined attributes,,Implementation-dependent characteristics\n-@anchor{gnat_rm/compatibility_and_porting_guide id10}@anchor{45d}@anchor{gnat_rm/compatibility_and_porting_guide implementation-defined-pragmas}@anchor{45e}\n+@anchor{gnat_rm/compatibility_and_porting_guide id10}@anchor{45e}@anchor{gnat_rm/compatibility_and_porting_guide implementation-defined-pragmas}@anchor{45f}\n @subsection Implementation-defined pragmas\n \n \n@@ -29525,7 +29600,7 @@ avoiding compiler rejection of units that contain such pragmas; they are not\n relevant in a GNAT context and hence are not otherwise implemented.\n \n @node Implementation-defined attributes,Libraries,Implementation-defined pragmas,Implementation-dependent characteristics\n-@anchor{gnat_rm/compatibility_and_porting_guide id11}@anchor{45f}@anchor{gnat_rm/compatibility_and_porting_guide implementation-defined-attributes}@anchor{460}\n+@anchor{gnat_rm/compatibility_and_porting_guide id11}@anchor{460}@anchor{gnat_rm/compatibility_and_porting_guide implementation-defined-attributes}@anchor{461}\n @subsection Implementation-defined attributes\n \n \n@@ -29539,7 +29614,7 @@ Ada 83, GNAT supplies the attributes @code{Bit}, @code{Machine_Size} and\n @code{Type_Class}.\n \n @node Libraries,Elaboration order,Implementation-defined attributes,Implementation-dependent characteristics\n-@anchor{gnat_rm/compatibility_and_porting_guide id12}@anchor{461}@anchor{gnat_rm/compatibility_and_porting_guide libraries}@anchor{462}\n+@anchor{gnat_rm/compatibility_and_porting_guide id12}@anchor{462}@anchor{gnat_rm/compatibility_and_porting_guide libraries}@anchor{463}\n @subsection Libraries\n \n \n@@ -29568,7 +29643,7 @@ be preferable to retrofit the application using modular types.\n @end itemize\n \n @node Elaboration order,Target-specific aspects,Libraries,Implementation-dependent characteristics\n-@anchor{gnat_rm/compatibility_and_porting_guide elaboration-order}@anchor{463}@anchor{gnat_rm/compatibility_and_porting_guide id13}@anchor{464}\n+@anchor{gnat_rm/compatibility_and_porting_guide elaboration-order}@anchor{464}@anchor{gnat_rm/compatibility_and_porting_guide id13}@anchor{465}\n @subsection Elaboration order\n \n \n@@ -29604,7 +29679,7 @@ pragmas either globally (as an effect of the @emph{-gnatE} switch) or locally\n @end itemize\n \n @node Target-specific aspects,,Elaboration order,Implementation-dependent characteristics\n-@anchor{gnat_rm/compatibility_and_porting_guide id14}@anchor{465}@anchor{gnat_rm/compatibility_and_porting_guide target-specific-aspects}@anchor{466}\n+@anchor{gnat_rm/compatibility_and_porting_guide id14}@anchor{466}@anchor{gnat_rm/compatibility_and_porting_guide target-specific-aspects}@anchor{467}\n @subsection Target-specific aspects\n \n \n@@ -29617,10 +29692,10 @@ on the robustness of the original design.  Moreover, Ada 95 (and thus\n Ada 2005 and Ada 2012) are sometimes\n incompatible with typical Ada 83 compiler practices regarding implicit\n packing, the meaning of the Size attribute, and the size of access values.\n-GNAT\u2019s approach to these issues is described in @ref{467,,Representation Clauses}.\n+GNAT\u2019s approach to these issues is described in @ref{468,,Representation Clauses}.\n \n @node Compatibility with Other Ada Systems,Representation Clauses,Implementation-dependent characteristics,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-other-ada-systems}@anchor{468}@anchor{gnat_rm/compatibility_and_porting_guide id15}@anchor{469}\n+@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-other-ada-systems}@anchor{469}@anchor{gnat_rm/compatibility_and_porting_guide id15}@anchor{46a}\n @section Compatibility with Other Ada Systems\n \n \n@@ -29663,7 +29738,7 @@ far beyond this minimal set, as described in the next section.\n @end itemize\n \n @node Representation Clauses,Compatibility with HP Ada 83,Compatibility with Other Ada Systems,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide id16}@anchor{46a}@anchor{gnat_rm/compatibility_and_porting_guide representation-clauses}@anchor{467}\n+@anchor{gnat_rm/compatibility_and_porting_guide id16}@anchor{46b}@anchor{gnat_rm/compatibility_and_porting_guide representation-clauses}@anchor{468}\n @section Representation Clauses\n \n \n@@ -29756,7 +29831,7 @@ with thin pointers.\n @end itemize\n \n @node Compatibility with HP Ada 83,,Representation Clauses,Compatibility and Porting Guide\n-@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-hp-ada-83}@anchor{46b}@anchor{gnat_rm/compatibility_and_porting_guide id17}@anchor{46c}\n+@anchor{gnat_rm/compatibility_and_porting_guide compatibility-with-hp-ada-83}@anchor{46c}@anchor{gnat_rm/compatibility_and_porting_guide id17}@anchor{46d}\n @section Compatibility with HP Ada 83\n \n \n@@ -29786,7 +29861,7 @@ extension of package System.\n @end itemize\n \n @node GNU Free Documentation License,Index,Compatibility and Porting Guide,Top\n-@anchor{share/gnu_free_documentation_license doc}@anchor{46d}@anchor{share/gnu_free_documentation_license gnu-fdl}@anchor{1}@anchor{share/gnu_free_documentation_license gnu-free-documentation-license}@anchor{46e}\n+@anchor{share/gnu_free_documentation_license doc}@anchor{46e}@anchor{share/gnu_free_documentation_license gnu-fdl}@anchor{1}@anchor{share/gnu_free_documentation_license gnu-free-documentation-license}@anchor{46f}\n @chapter GNU Free Documentation License\n \n "}, {"sha": "b6c8bb579d4a3fcdf8714599bc6e249d8a15fbee", "filename": "gcc/ada/libgnat/a-except.ads", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-except.ads?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -184,14 +184,9 @@ private\n    --  Raise_Exception_Always if it can determine this is the case. The Export\n    --  allows this routine to be accessed from Pure units.\n \n-   --  Make these callable from strub contexts.\n    pragma Machine_Attribute (Raise_Exception_Always,\n                              \"strub\", \"callable\");\n-   pragma Machine_Attribute (Raise_Exception,\n-                             \"strub\", \"callable\");\n-   --  This property should arguably be visible to callers, but let's\n-   --  keep it private for now.  In practice, it doesn't matter, since\n-   --  it's only checked in the back end.\n+   --  Make it callable from strub contexts\n \n    procedure Raise_From_Controlled_Operation (X : Exception_Occurrence);\n    pragma No_Return (Raise_From_Controlled_Operation);"}, {"sha": "6213cfb569a24ba4d507f484e4daec5a0b4408c7", "filename": "gcc/ada/libgnat/s-arit128.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit128.ads?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -81,11 +81,4 @@ package System.Arith_128 is\n    --  then Q is the rounded quotient. The remainder R is not affected by the\n    --  setting of the Round flag.\n \n-private\n-   --  Make it callable from strub contexts.\n-   --  There is a matching setting in trans.c,\n-   --  for calls issued by Gigi.\n-   pragma Machine_Attribute (Multiply_With_Ovflo_Check128,\n-                             \"strub\", \"callable\");\n-\n end System.Arith_128;"}, {"sha": "c9141f5fe3e8966fadc298eb58b95eeeb84846c4", "filename": "gcc/ada/libgnat/s-arit64.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-arit64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit64.ads?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -93,11 +93,4 @@ package System.Arith_64 is\n       Round   : Boolean) renames Double_Divide64;\n    --  Renamed procedure to preserve compatibility with earlier versions\n \n-private\n-   --  Make it callable from strub contexts.\n-   --  There is a matching setting in trans.c,\n-   --  for calls issued by Gigi.\n-   pragma Machine_Attribute (Multiply_With_Ovflo_Check64,\n-                             \"strub\", \"callable\");\n-\n end System.Arith_64;"}, {"sha": "7d6b1b9a90eb0e61e1d1fbaeda9e8f129b030b5c", "filename": "gcc/ada/libgnat/s-secsta.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Flibgnat%2Fs-secsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-secsta.ads?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -440,9 +440,4 @@ private\n    function Get_Stack_Info (Stack : SS_Stack_Ptr) return Stack_Info;\n    --  Obtain the information attributes of secondary stack Stack\n \n-   pragma Machine_Attribute (SS_Allocate, \"strub\", \"callable\");\n-   pragma Machine_Attribute (SS_Mark, \"strub\", \"callable\");\n-   pragma Machine_Attribute (SS_Release, \"strub\", \"callable\");\n-   --  Enable these to be called from within strub contexts.\n-\n end System.Secondary_Stack;"}, {"sha": "2575ddfe86d710ee947f3aad303b7ec2ed31288a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -74,6 +74,7 @@ with Sinfo.Utils;    use Sinfo.Utils;\n with Sinput;         use Sinput;\n with System;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with Style;\n with Stylesw;        use Stylesw;\n with Targparm;       use Targparm;\n@@ -11294,6 +11295,27 @@ package body Sem_Attr is\n                Resolve (P);\n             end if;\n \n+            --  Refuse to compute access to variables and constants when that\n+            --  would drop the strub mode associated with them, unless they're\n+            --  unchecked conversions. We don't have to do this when the types\n+            --  of the data objects are annotated: then the access type\n+            --  designates the annotated type, and there's no loss. Only when\n+            --  the variable is annotated directly that the pragma gets\n+            --  attached to the variable, rather than to its type, and then,\n+            --  expressing an access-to-annotated-type type to hold the 'Access\n+            --  result is not possible without resorting to that very annotated\n+            --  type.\n+\n+            if Attr_Id /= Attribute_Unchecked_Access\n+              and then Comes_From_Source (N)\n+              and then Is_Entity_Name (P)\n+              and then Explicit_Strub_Mode (Entity (P)) = Enabled\n+              and then\n+                Explicit_Strub_Mode (Designated_Type (Btyp)) = Unspecified\n+            then\n+               Error_Msg_F (\"target access type drops `strub` mode from &\", P);\n+            end if;\n+\n             --  X'Access is illegal if X denotes a constant and the access type\n             --  is access-to-variable. Same for 'Unchecked_Access. The rule\n             --  does not apply to 'Unrestricted_Access. If the reference is a"}, {"sha": "e854bb3eee9f8d1954822a559558b2365dcc4bb1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -79,6 +79,7 @@ with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Sinput;         use Sinput;\n with Snames;         use Snames;\n+with Strub;          use Strub;\n with Targparm;       use Targparm;\n with Tbuild;         use Tbuild;\n with Ttypes;         use Ttypes;\n@@ -16065,6 +16066,8 @@ package body Sem_Ch3 is\n          Set_Alias (New_Subp, Actual_Subp);\n       end if;\n \n+      Copy_Strub_Mode (New_Subp, Alias (New_Subp));\n+\n       --  Derived subprograms of a tagged type must inherit the convention\n       --  of the parent subprogram (a requirement of AI-117). Derived\n       --  subprograms of untagged types simply get convention Ada by default."}, {"sha": "f50f440d3a8d4ab75dde4a4f85a46bdb4ef7e668", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -84,6 +84,7 @@ with Sinfo.Utils;    use Sinfo.Utils;\n with Sinfo.CN;       use Sinfo.CN;\n with Sinput;         use Sinput;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with Stylesw;        use Stylesw;\n with Table;\n with Targparm;       use Targparm;\n@@ -19446,7 +19447,29 @@ package body Sem_Prag is\n             Check_Arg_Is_OK_Static_Expression (Arg2, Standard_String);\n             Def_Id := Entity (Get_Pragma_Arg (Arg1));\n \n-            if Is_Access_Type (Def_Id) then\n+            --  Apply the pragma to the designated type, rather than to the\n+            --  access type, unless it's a strub annotation.  We wish to enable\n+            --  objects of access type, as well as access types themselves, to\n+            --  be annotated, so that reading the access objects (as oposed to\n+            --  the designated data) automatically enables stack\n+            --  scrubbing. That said, as in the attribute handler that\n+            --  processes the pragma turned into a compiler attribute, a strub\n+            --  annotation that must be associated with a subprogram type (for\n+            --  holding an explicit strub mode), when applied to an\n+            --  access-to-subprogram, gets promoted to the subprogram type. We\n+            --  might be tempted to leave it alone here, since the C attribute\n+            --  handler will adjust it, but then GNAT would convert the\n+            --  annotated subprogram types to naked ones before using them,\n+            --  cancelling out their intended effects.\n+\n+            if Is_Access_Type (Def_Id)\n+              and then (not Strub_Pragma_P (N)\n+                          or else\n+                          (Present (Arg3)\n+                             and then\n+                             Ekind (Designated_Type\n+                                      (Def_Id)) = E_Subprogram_Type))\n+            then\n                Def_Id := Designated_Type (Def_Id);\n             end if;\n \n@@ -19464,7 +19487,7 @@ package body Sem_Prag is\n             if Rep_Item_Too_Late (Def_Id, N) then\n                return;\n             else\n-               Set_Has_Gigi_Rep_Item (Entity (Get_Pragma_Arg (Arg1)));\n+               Set_Has_Gigi_Rep_Item (Def_Id);\n             end if;\n          end Machine_Attribute;\n "}, {"sha": "ac262facfec8426b745973ae52fa8170c035e1d8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -82,6 +82,7 @@ with Sinfo.CN;       use Sinfo.CN;\n with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n+with Strub;          use Strub;\n with Style;          use Style;\n with Targparm;       use Targparm;\n with Tbuild;         use Tbuild;\n@@ -3179,6 +3180,27 @@ package body Sem_Res is\n       --  Only one interpretation\n \n       else\n+         --  Prevent implicit conversions between access-to-subprogram types\n+         --  with different strub modes. Explicit conversions are acceptable in\n+         --  some circumstances. We don't have to be concerned about data or\n+         --  access-to-data types. Conversions between data types can safely\n+         --  drop or add strub attributes from types, because strub effects are\n+         --  associated with the locations rather than values. E.g., converting\n+         --  a hypothetical Strub_Integer variable to Integer would load the\n+         --  value from the variable, enabling stack scrabbing for the\n+         --  enclosing subprogram, and then convert the value to Integer. As\n+         --  for conversions between access-to-data types, that's no different\n+         --  from any other case of type punning.\n+\n+         if Is_Access_Type (Typ)\n+           and then Ekind (Designated_Type (Typ)) = E_Subprogram_Type\n+           and then Is_Access_Type (Expr_Type)\n+           and then Ekind (Designated_Type (Expr_Type)) = E_Subprogram_Type\n+         then\n+            Check_Same_Strub_Mode\n+              (Designated_Type (Typ), Designated_Type (Expr_Type));\n+         end if;\n+\n          --  In Ada 2005, if we have something like \"X : T := 2 + 2;\", where\n          --  the \"+\" on T is abstract, and the operands are of universal type,\n          --  the above code will have (incorrectly) resolved the \"+\" to the\n@@ -14154,7 +14176,15 @@ package body Sem_Res is\n             end;\n          end if;\n \n-         return True;\n+         --  Check that the strub modes are compatible.\n+         --  We wish to reject explicit conversions only for\n+         --  incompatible modes.\n+\n+         return Conversion_Check\n+                  (Compatible_Strub_Modes\n+                     (Designated_Type (Target_Type),\n+                      Designated_Type (Opnd_Type)),\n+                   \"incompatible `strub` modes\");\n \n       --  Remote access to subprogram types\n \n@@ -14180,7 +14210,16 @@ package body Sem_Res is\n               Designated_Type (Corresponding_Remote_Type (Opnd_Type)),\n             Err_Loc =>\n               N);\n-         return True;\n+\n+         --  Check that the strub modes are compatible.\n+         --  We wish to reject explicit conversions only for\n+         --  incompatible modes.\n+\n+         return Conversion_Check\n+                  (Compatible_Strub_Modes\n+                     (Designated_Type (Target_Type),\n+                      Designated_Type (Opnd_Type)),\n+                   \"incompatible `strub` modes\");\n \n       --  If it was legal in the generic, it's legal in the instance\n "}, {"sha": "84146580b02c400f820c1cc9db6eb394be6a1acb", "filename": "gcc/ada/strub.adb", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fstrub.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fstrub.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstrub.adb?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -0,0 +1,301 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                S T R U B                                 --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package containing utility procedures related to Stack Scrubbing\n+\n+with Atree;          use Atree;\n+with Einfo;          use Einfo;\n+with Einfo.Entities; use Einfo.Entities;\n+with Errout;         use Errout;\n+with Namet;          use Namet;\n+with Nlists;         use Nlists;\n+with Sem_Eval;       use Sem_Eval;\n+with Sinfo;          use Sinfo;\n+with Sinfo.Nodes;    use Sinfo.Nodes;\n+with Sinfo.Utils;    use Sinfo.Utils;\n+with Snames;         use Snames;\n+with Stringt;        use Stringt;\n+\n+package body Strub is\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Find_Explicit_Strub_Pragma (Id : Entity_Id) return Node_Id;\n+   --  Return a pragma Machine_Attribute (Id, \"strub\"[, \"mode\"]) node\n+   --  if Id has one.\n+\n+   function Strub_Pragma_Arg (Item : Node_Id) return Node_Id is\n+      (Get_Pragma_Arg\n+         (Next (Next (First (Pragma_Argument_Associations (Item))))));\n+   --  Return the pragma argument holding the strub mode associated\n+   --  with Item, a subprogram, variable, constant, or type. Bear in\n+   --  mind that strub pragmas with an explicit strub mode argument,\n+   --  naming access-to-subprogram types, are applied to the\n+   --  designated subprogram type.\n+\n+   function Strub_Pragma_Arg_To_String (Item : Node_Id) return String is\n+      (To_String (Strval (Expr_Value_S (Item))));\n+   --  Extract and return as a String the strub mode held in a node\n+   --  returned by Strub_Pragma_Arg.\n+\n+   function Strub_Pragma_Mode\n+     (Id   : Entity_Id;\n+      Item : Node_Id) return Strub_Mode;\n+   --  Return the strub mode associated with Item expressed in Id.\n+   --  Strub_Pragma_P (Id) must hold.\n+\n+   ---------------------------\n+   -- Check_Same_Strub_Mode --\n+   ---------------------------\n+\n+   procedure Check_Same_Strub_Mode\n+     (Dest, Src : Entity_Id;\n+      Report    : Boolean := True)\n+   is\n+      Src_Strub_Mode  : constant Strub_Mode := Explicit_Strub_Mode (Src);\n+      Dest_Strub_Mode : constant Strub_Mode := Explicit_Strub_Mode (Dest);\n+\n+   begin\n+      if Dest_Strub_Mode = Src_Strub_Mode then\n+         return;\n+      end if;\n+\n+      --  Internal is not part of the interface, it's an *internal*\n+      --  implementation detail, so consider it equivalent to unspecified here.\n+      --  ??? -fstrub=relaxed|strict makes them interface-equivalent to\n+      --  Callable or Disabled, respectively, but we don't look at that flag in\n+      --  the front-end, and it seems undesirable for that flag to affect\n+      --  whether specifications are conformant. Maybe there should be some\n+      --  means to specify Callable or Disabled along with Internal?\n+\n+      if Dest_Strub_Mode in Unspecified | Internal\n+        and then Src_Strub_Mode in Unspecified | Internal\n+      then\n+         return;\n+      end if;\n+\n+      if not Report then\n+         return;\n+      end if;\n+\n+      if Src_Strub_Mode /= Unspecified then\n+         Error_Msg_Sloc := Sloc (Find_Explicit_Strub_Pragma (Src));\n+      else\n+         Error_Msg_Sloc := Sloc (Src);\n+      end if;\n+      Error_Msg_Node_2 := Src;\n+      Error_Msg_NE (\"& requires the same `strub` mode as &#\",\n+                    (if Dest_Strub_Mode /= Unspecified\n+                       then Find_Explicit_Strub_Pragma (Dest)\n+                       else Dest),\n+                    Dest);\n+   end Check_Same_Strub_Mode;\n+\n+   ----------------------------\n+   -- Compatible_Strub_Modes --\n+   ----------------------------\n+\n+   function Compatible_Strub_Modes\n+     (Dest, Src : Entity_Id) return Boolean\n+   is\n+      Src_Strub_Mode : constant Strub_Mode := Explicit_Strub_Mode (Src);\n+      Dest_Strub_Mode : constant Strub_Mode := Explicit_Strub_Mode (Dest);\n+\n+   begin\n+      return Src_Strub_Mode = Dest_Strub_Mode\n+        or else At_Calls not in Src_Strub_Mode | Dest_Strub_Mode;\n+   end Compatible_Strub_Modes;\n+\n+   ---------------------\n+   -- Copy_Strub_Mode --\n+   ---------------------\n+\n+   procedure Copy_Strub_Mode (Dest, Src : Entity_Id) is\n+      Strub : Node_Id := Find_Explicit_Strub_Pragma (Src);\n+      Src_Strub_Mode : constant Strub_Mode := Strub_Pragma_Mode (Src, Strub);\n+\n+   begin\n+      pragma Assert (Explicit_Strub_Mode (Dest) = Unspecified);\n+\n+      --  Refrain from copying Internal to subprogram types.\n+      --  It affects code generation for the subprogram,\n+      --  but it has no effect on its type or interface.\n+\n+      if Src_Strub_Mode = Unspecified\n+        or else (Ekind (Dest) = E_Subprogram_Type\n+                   and then Src_Strub_Mode = Internal)\n+      then\n+         return;\n+      end if;\n+\n+      Strub := New_Copy (Strub);\n+      Set_Next_Rep_Item (Strub, First_Rep_Item (Dest));\n+      Set_First_Rep_Item (Dest, Strub);\n+      Set_Has_Gigi_Rep_Item (Dest);\n+   end Copy_Strub_Mode;\n+\n+   -------------------------\n+   -- Explicit_Strub_Mode --\n+   -------------------------\n+\n+   function Explicit_Strub_Mode (Id : Entity_Id) return Strub_Mode is\n+      Item : constant Node_Id := Find_Explicit_Strub_Pragma (Id);\n+\n+   begin\n+      return Strub_Pragma_Mode (Id, Item);\n+   end Explicit_Strub_Mode;\n+\n+   --------------------------------\n+   -- Find_Explicit_Strub_Pragma --\n+   --------------------------------\n+\n+   function Find_Explicit_Strub_Pragma (Id : Entity_Id) return Node_Id is\n+      Item : Node_Id;\n+\n+   begin\n+      if not Has_Gigi_Rep_Item (Id) then\n+         return Empty;\n+      end if;\n+\n+      Item := First_Rep_Item (Id);\n+      while Present (Item) loop\n+         if Strub_Pragma_P (Item) then\n+            return Item;\n+         end if;\n+         Item := Next_Rep_Item (Item);\n+      end loop;\n+\n+      return Empty;\n+   end Find_Explicit_Strub_Pragma;\n+\n+   -----------------------\n+   -- Strub_Pragma_Mode --\n+   -----------------------\n+\n+   function Strub_Pragma_Mode\n+     (Id   : Entity_Id;\n+      Item : Node_Id) return Strub_Mode\n+   is\n+      Arg : Node_Id := Empty;\n+\n+   begin\n+      --  ??? Enumeration literals, despite being conceptually functions, have\n+      --  neither bodies nor stack frames, and it's not clear whether it would\n+      --  make more sense to treat them as subprograms or as constants, but\n+      --  they can be renamed as functions.  Should we require all literals of\n+      --  a type to have the same strub mode?  Rule out their annotation?\n+\n+      if Ekind (Id) in E_Subprogram_Type\n+                     | Overloadable_Kind\n+                     | Generic_Subprogram_Kind\n+      then\n+         if Item = Empty then\n+            return Unspecified;\n+         end if;\n+\n+         Arg := Strub_Pragma_Arg (Item);\n+         if Arg = Empty then\n+            return At_Calls;\n+         end if;\n+\n+         declare\n+            Str : constant String := Strub_Pragma_Arg_To_String (Arg);\n+         begin\n+            if Str'Length /= 8 then\n+               return Unspecified;\n+            end if;\n+\n+            case Str (Str'First) is\n+               when 'a' =>\n+                  if Str = \"at-calls\" then\n+                     return At_Calls;\n+                  end if;\n+\n+               when 'i' =>\n+                  if Str = \"internal\" then\n+                     return Internal;\n+                  end if;\n+\n+               when 'c' =>\n+                  if Str = \"callable\" then\n+                     return Callable;\n+                  end if;\n+\n+               when 'd' =>\n+                  if Str = \"disabled\" then\n+                     return Disabled;\n+                  end if;\n+\n+               when others =>\n+                  null;\n+            end case;\n+            return Unspecified;\n+         end;\n+\n+      --  Access-to-subprogram types and variables can be treated just like\n+      --  other access types, because the pragma logic has already promoted to\n+      --  subprogram types any annotations applicable to them.\n+\n+      elsif Ekind (Id) in Type_Kind -- except E_Subprogram_Type, covered above\n+                        | Scalar_Kind\n+                        | Object_Kind\n+                        | Named_Kind\n+      then\n+         if Item = Empty then\n+            return Unspecified;\n+         end if;\n+\n+         Arg := Strub_Pragma_Arg (Item);\n+         if Arg /= Empty then\n+            --  A strub parameter is not applicable to variables,\n+            --  and will be ignored.\n+\n+            return Unspecified;\n+         end if;\n+\n+         return Enabled;\n+\n+      else\n+         pragma Assert (Item = Empty);\n+         return Not_Applicable;\n+      end if;\n+   end Strub_Pragma_Mode;\n+\n+   --------------------\n+   -- Strub_Pragma_P --\n+   --------------------\n+\n+   function Strub_Pragma_P\n+     (Item : Node_Id) return Boolean is\n+      (Nkind (Item) = N_Pragma\n+         and then Pragma_Name (Item) = Name_Machine_Attribute\n+         and then\n+           Strub_Pragma_Arg_To_String\n+             (Get_Pragma_Arg\n+                (Next (First (Pragma_Argument_Associations (Item)))))\n+             = \"strub\");\n+\n+end Strub;"}, {"sha": "2753dd0fa5bef18a0c528e8b2a3479bf9062d71c", "filename": "gcc/ada/strub.ads", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fstrub.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d235950e83965ed6389eb94b1cffb7393dcb1984/gcc%2Fada%2Fstrub.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstrub.ads?ref=d235950e83965ed6389eb94b1cffb7393dcb1984", "patch": "@@ -0,0 +1,115 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                S T R U B                                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2021, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package containing utility procedures related to Stack Scrubbing\n+\n+with Types; use Types;\n+\n+package Strub is\n+   type Strub_Mode is\n+     (Disabled,        --  Subprogram cannot be called from strub contexts\n+      At_Calls,        --  Subprogram strubbed by caller\n+      Internal,        --  Subprogram strubbed by wrapper\n+      Callable,        --  Subprogram safe to call despite no strub\n+      Unspecified,     --  Subprogram or data without strub annotation\n+      Enabled,         --  Data (variable or constant) that enables strub\n+      Not_Applicable); --  Entities that are not strub-capable\n+   --  This is the type that expresses decoded strub annotations\n+\n+   --  We compare strub modes in the following circumstances:\n+\n+   --  * subprogram definition vs specification\n+   --  * overriding vs overridden dispatch subprograms\n+   --  * implementation vs interface dispatch subprogram\n+   --  * renaming vs renamed subprogram\n+   --  * type resolution\n+   --  * explicit conversions\n+\n+   --  Explicit conversions can convert between strub modes other than\n+   --  at-calls (see Compatible_Strub_Modes), but for the other cases\n+   --  above, we insist on identity of the strub modes (see\n+   --  Check_Same_Strub_Mode). Anything else would be\n+   --  troublesome.\n+\n+   --  E.g., overriding a callable subprogram with a strub-disabled\n+   --  implementation would enable a subprogram that's unsafe to call\n+   --  in strub contexts to be called through a dispatching\n+   --  interface. An explicitly strub-disabled subprogram shall not be\n+   --  called from strub contexts, and a callable overriding\n+   --  subprogram would still seem not-callable, so accepting\n+   --  different modes would be surprising.\n+\n+   --  We could relax the requirement for overriders from equality to\n+   --  compatibility, with the understanding that the dispatching ABI\n+   --  is what prevails. For renaming, however, if we don't require\n+   --  equality, it would have to encompass an implicit conversion.\n+\n+   procedure Check_Same_Strub_Mode\n+     (Dest, Src : Entity_Id;\n+      Report    : Boolean := True);\n+   --  Check whether Dest and Src are subprograms or subprogram types\n+   --  annotated (or not) with the same strub mode. If Report is\n+   --  requested, and the strub modes are not equivalent, an error\n+   --  message is issued. Unspecified and Internal are considered\n+   --  equivalent, because Internal is an internal implementation\n+   --  detail. Unspecified decays to Disabled or Callable depending on\n+   --  -fstrub=(strict|relaxed), but this procedure does not take this\n+   --  decay into account, which avoids turning strub-equivalent\n+   --  declarations into incompatible ones at command-line changes.\n+\n+   function Compatible_Strub_Modes\n+     (Dest, Src : Entity_Id) return Boolean;\n+   --  Return True if Dest and Src are subprograms or subprogram types\n+   --  annotated (or not) with ABI-compatible strub modes. At-calls is\n+   --  incompatible to other strub modes, because the back end\n+   --  internally modifies the signature of such subprograms, adding\n+   --  hidden parameters. Calling a subprogram through an\n+   --  access-to-subprogram object converted between strub-at-calls\n+   --  and other strub modes should be deemed equivalent to\n+   --  dereferencing an uninitialized access-to-data object, though\n+   --  one-way conversions might seem to work in some circumstances.\n+   --\n+   --  Unspecified, Disabled, Internal and Callable\n+   --  (access-to-)subprograms, on the other hand, can be safely but\n+   --  explicitly converted to each other, because these strub modes\n+   --  do not require signature changes; so it is possible to alter\n+   --  the caller-side stack scrubbing semantics of the call (e.g. to\n+   --  call a subprogram that isn't strub-callable from within a strub\n+   --  context, or to prevent it from being called through an access\n+   --  object) without any incompatibilities.\n+\n+   procedure Copy_Strub_Mode (Dest, Src : Entity_Id);\n+   --  Copy the strub mode from Src to Dest, subprograms or subprogram\n+   --  types. Dest is required to not have a strub mode already set.\n+\n+   function Explicit_Strub_Mode (Id : Entity_Id) return Strub_Mode;\n+   --  Return the strub mode associated with Id, that should refer to\n+   --  a subprogram, a data object, or a type.\n+\n+   function Strub_Pragma_P (Item : Node_Id) return Boolean;\n+   --  Return True iff Item is a strub annotation, specifically, one\n+   --  introduced by pragma Machine_Attribute (Entity, \"strub\"[, \"mode\"]).\n+\n+end Strub;"}]}