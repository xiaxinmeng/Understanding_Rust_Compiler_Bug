{"sha": "03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNjYjIwMTlmZjE0ZTAzYjIyNTZiYzZkY2E4YTFiZDNlYzJiZWRlOQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-03T02:29:00Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-03T02:29:00Z"}, "message": "loop-unswitch.c (unswitch_loop): Pass probabilities to loopify.\n\n\t* loop-unswitch.c (unswitch_loop): Pass probabilities to loopify.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Pass probabilities\n\tto loop_version.\n\t* cfgloopmanip.c (scale_loop_frequencies): Export.\n\t(loopify): Scale the frequencies by prescribed coefficients.\n\t(set_zero_probability): New function.\n\t(duplicate_loop_to_header_edge): Improve updating of frequencies.\n\t(lv_adjust_loop_entry_edge, loop_version): Set probabilities\n\tand frequencies according to arguments.\n\t* tree-ssa-loop-manip.c (tree_unroll_loop): Set probabilities\n\tcorrectly.\n\t* cfg.c (scale_bbs_frequencies_int): Allow scaling the frequencies up.\n\t* modulo-sched.c (sms_schedule): Set probabilities for entering\n\tversioned loop correctly.\n\t* tree-vect-transform.c (vect_transform_loop): Ditto.\n\t* cfgloop.h (loopify, loop_version): Declaration changed.\n\t(scale_loop_frequencies): Declared.\n\n\t* gcc.dg/tree-ssa/update-unroll-1.c: New test.\n\t* gcc.dg/tree-ssa/update-unswitch-1.c: New test.\n\nFrom-SVN: r120378", "tree": {"sha": "65c401413cfba6d2049e2a002755074729d4e079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65c401413cfba6d2049e2a002755074729d4e079"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/comments", "author": null, "committer": null, "parents": [{"sha": "7a388ee4530a1924bd3e0100078e5179bf5ee18c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a388ee4530a1924bd3e0100078e5179bf5ee18c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a388ee4530a1924bd3e0100078e5179bf5ee18c"}], "stats": {"total": 347, "additions": 291, "deletions": 56}, "files": [{"sha": "3716690037e224214bac27a43234874c2e253083", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -1,3 +1,23 @@\n+2006-01-03  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* loop-unswitch.c (unswitch_loop): Pass probabilities to loopify.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Pass probabilities\n+\tto loop_version.\n+\t* cfgloopmanip.c (scale_loop_frequencies): Export.\n+\t(loopify): Scale the frequencies by prescribed coefficients.\n+\t(set_zero_probability): New function.\n+\t(duplicate_loop_to_header_edge): Improve updating of frequencies.\n+\t(lv_adjust_loop_entry_edge, loop_version): Set probabilities\n+\tand frequencies according to arguments.\n+\t* tree-ssa-loop-manip.c (tree_unroll_loop): Set probabilities\n+\tcorrectly.\n+\t* cfg.c (scale_bbs_frequencies_int): Allow scaling the frequencies up.\n+\t* modulo-sched.c (sms_schedule): Set probabilities for entering\n+\tversioned loop correctly.\n+\t* tree-vect-transform.c (vect_transform_loop): Ditto.\n+\t* cfgloop.h (loopify, loop_version): Declaration changed.\n+\t(scale_loop_frequencies): Declared.\n+\n 2007-01-02  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c: Include tree-flow.h\n@@ -41,12 +61,12 @@\n \n 2007-01-02  Jan Hubicka  <jh@suse.cz>\n \n-        * tree-mudflap.c (mf_decl_cache_locals, mf_build_check_statement_for):\n-        Do not add referenced vars.\n-        * tree-cfg.c (update_modified_stmts): Do not update when SSA operands\n-        are not active.\n-        * passes.c (init_optimization_passes): Put mudflap_2 after\n-        free_datastructures.\n+\t* tree-mudflap.c (mf_decl_cache_locals, mf_build_check_statement_for):\n+\tDo not add referenced vars.\n+\t* tree-cfg.c (update_modified_stmts): Do not update when SSA operands\n+\tare not active.\n+\t* passes.c (init_optimization_passes): Put mudflap_2 after\n+\tfree_datastructures.\n \n 2007-01-02  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "9f5da32bfe877bfb74e99436274f16e219594fdd", "filename": "gcc/cfg.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -949,15 +949,28 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n   edge e;\n   if (num < 0)\n     num = 0;\n-  if (num > den)\n+\n+  /* Scale NUM and DEN to avoid overflows.  Frequencies are in order of\n+     10^4, if we make DEN <= 10^3, we can afford to upscale by 100\n+     and still safely fit in int during calculations.  */\n+  if (den > 1000)\n+    {\n+      if (num > 1000000)\n+\treturn;\n+\n+      num = RDIV (1000 * num, den);\n+      den = 1000;\n+    }\n+  if (num > 100 * den)\n     return;\n-  /* Assume that the users are producing the fraction from frequencies\n-     that never grow far enough to risk arithmetic overflow.  */\n-  gcc_assert (num < 65536);\n+\n   for (i = 0; i < nbbs; i++)\n     {\n       edge_iterator ei;\n       bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);\n+      /* Make sure the frequencies do not grow over BB_FREQ_MAX.  */\n+      if (bbs[i]->frequency > BB_FREQ_MAX)\n+\tbbs[i]->frequency = BB_FREQ_MAX;\n       bbs[i]->count = RDIV (bbs[i]->count * num, den);\n       FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n \te->count = RDIV (e->count * num, den);"}, {"sha": "19fc93fcc664201d27bf3e3ab9c3de0ee8b6ea3c", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -254,10 +254,12 @@ extern bool duplicate_loop_to_header_edge (struct loop *, edge,\n \t\t\t\t\t   unsigned, sbitmap, edge,\n  \t\t\t\t\t   VEC (edge, heap) **, int);\n extern struct loop *loopify (edge, edge,\n-\t\t\t     basic_block, edge, edge, bool);\n+\t\t\t     basic_block, edge, edge, bool,\n+\t\t\t     unsigned, unsigned);\n struct loop * loop_version (struct loop *, void *,\n-\t\t\t    basic_block *, bool);\n+\t\t\t    basic_block *, unsigned, unsigned, unsigned, bool);\n extern bool remove_path (edge);\n+void scale_loop_frequencies (struct loop *, int, int);\n \n /* Induction variable analysis.  */\n "}, {"sha": "fd7597e9a124d1cf1041a3a341e302d078709d3c", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 114, "deletions": 25, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -44,7 +44,6 @@ static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *);\n static void place_new_loop (struct loop *);\n-static void scale_loop_frequencies (struct loop *, int, int);\n static basic_block create_preheader (struct loop *, int);\n static void unloop (struct loop *, bool *);\n \n@@ -396,7 +395,7 @@ add_loop (struct loop *loop, struct loop *outer)\n }\n \n /* Multiply all frequencies in LOOP by NUM/DEN.  */\n-static void\n+void\n scale_loop_frequencies (struct loop *loop, int num, int den)\n {\n   basic_block *bbs;\n@@ -413,12 +412,13 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n    LATCH_EDGE source.  HEADER_EDGE is redirected to basic block SWITCH_BB,\n    FALSE_EDGE of SWITCH_BB to original destination of HEADER_EDGE and\n    TRUE_EDGE of SWITCH_BB to original destination of LATCH_EDGE.\n-   Returns newly created loop.  */\n+   Returns the newly created loop.  Frequencies and counts in the new loop\n+   are scaled by FALSE_SCALE and in the old one by TRUE_SCALE.  */\n \n struct loop *\n loopify (edge latch_edge, edge header_edge,\n \t basic_block switch_bb, edge true_edge, edge false_edge,\n-\t bool redirect_all_edges)\n+\t bool redirect_all_edges, unsigned true_scale, unsigned false_scale)\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n@@ -427,7 +427,7 @@ loopify (edge latch_edge, edge header_edge,\n   sbitmap seen;\n   struct loop *loop = XCNEW (struct loop);\n   struct loop *outer = succ_bb->loop_father->outer;\n-  int freq, prob, tot_prob;\n+  int freq;\n   gcov_type cnt;\n   edge e;\n   edge_iterator ei;\n@@ -437,10 +437,6 @@ loopify (edge latch_edge, edge header_edge,\n \n   freq = EDGE_FREQUENCY (header_edge);\n   cnt = header_edge->count;\n-  prob = EDGE_SUCC (switch_bb, 0)->probability;\n-  tot_prob = prob + EDGE_SUCC (switch_bb, 1)->probability;\n-  if (tot_prob == 0)\n-    tot_prob = 1;\n \n   /* Redirect edges.  */\n   loop_redirect_edge (latch_edge, loop->header);\n@@ -469,12 +465,17 @@ loopify (edge latch_edge, edge header_edge,\n   add_bb_to_loop (switch_bb, outer);\n \n   /* Fix frequencies.  */\n-  switch_bb->frequency = freq;\n-  switch_bb->count = cnt;\n-  FOR_EACH_EDGE (e, ei, switch_bb->succs)\n-    e->count = (switch_bb->count * e->probability) / REG_BR_PROB_BASE;\n-  scale_loop_frequencies (loop, prob, tot_prob);\n-  scale_loop_frequencies (succ_bb->loop_father, tot_prob - prob, tot_prob);\n+  if (redirect_all_edges)\n+    {\n+      switch_bb->frequency = freq;\n+      switch_bb->count = cnt;\n+      FOR_EACH_EDGE (e, ei, switch_bb->succs)\n+\t{\n+\t  e->count = (switch_bb->count * e->probability) / REG_BR_PROB_BASE;\n+\t}\n+    }\n+  scale_loop_frequencies (loop, false_scale, REG_BR_PROB_BASE);\n+  scale_loop_frequencies (succ_bb->loop_father, true_scale, REG_BR_PROB_BASE);\n \n   /* Update dominators of blocks outside of LOOP.  */\n   dom_bbs = XCNEWVEC (basic_block, n_basic_blocks);\n@@ -804,6 +805,41 @@ update_single_exit_for_duplicated_loops (struct loop *orig_loops[], unsigned n)\n     update_single_exit_for_duplicated_loop (orig_loops[i]);\n }\n \n+/* Sets probability and count of edge E to zero.  The probability and count\n+   is redistributed evenly to the remaining edges coming from E->src.  */\n+\n+static void\n+set_zero_probability (edge e)\n+{\n+  basic_block bb = e->src;\n+  edge_iterator ei;\n+  edge ae, last = NULL;\n+  unsigned n = EDGE_COUNT (bb->succs);\n+  gcov_type cnt = e->count, cnt1;\n+  unsigned prob = e->probability, prob1;\n+\n+  gcc_assert (n > 1);\n+  cnt1 = cnt / (n - 1);\n+  prob1 = prob / (n - 1);\n+\n+  FOR_EACH_EDGE (ae, ei, bb->succs)\n+    {\n+      if (ae == e)\n+\tcontinue;\n+\n+      ae->probability += prob1;\n+      ae->count += cnt1;\n+      last = ae;\n+    }\n+\n+  /* Move the rest to one of the edges.  */\n+  last->probability += prob % (n - 1);\n+  last->count += cnt % (n - 1);\n+\n+  e->probability = 0;\n+  e->count = 0;\n+}\n+\n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n    loop structure and dominators.  E's destination must be LOOP header for\n    this to work, i.e. it must be entry or latch edge of this loop; these are\n@@ -834,10 +870,13 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   unsigned i, j, n;\n   int is_latch = (latch == e->src);\n   int scale_act = 0, *scale_step = NULL, scale_main = 0;\n+  int scale_after_exit = 0;\n   int p, freq_in, freq_le, freq_out_orig;\n   int prob_pass_thru, prob_pass_wont_exit, prob_pass_main;\n   int add_irreducible_flag;\n   basic_block place_after;\n+  bitmap bbs_to_scale = NULL;\n+  bitmap_iterator bi;\n \n   gcc_assert (e->dest == loop->header);\n   gcc_assert (ndupl > 0);\n@@ -887,10 +926,26 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       prob_pass_wont_exit =\n \t      RDIV (REG_BR_PROB_BASE * (freq_le + freq_out_orig), freq_in);\n \n+      if (orig\n+\t  && REG_BR_PROB_BASE - orig->probability != 0)\n+\t{\n+\t  /* The blocks that are dominated by a removed exit edge ORIG have\n+\t     frequencies scaled by this.  */\n+\t  scale_after_exit = RDIV (REG_BR_PROB_BASE * REG_BR_PROB_BASE,\n+\t\t\t\t   REG_BR_PROB_BASE - orig->probability);\n+\t  bbs_to_scale = BITMAP_ALLOC (NULL);\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      if (bbs[i] != orig->src\n+\t\t  && dominated_by_p (CDI_DOMINATORS, bbs[i], orig->src))\n+\t\tbitmap_set_bit (bbs_to_scale, i);\n+\t    }\n+\t}\n+\n       scale_step = XNEWVEC (int, ndupl);\n \n-\tfor (i = 1; i <= ndupl; i++)\n-\t  scale_step[i - 1] = TEST_BIT (wont_exit, i)\n+      for (i = 1; i <= ndupl; i++)\n+\tscale_step[i - 1] = TEST_BIT (wont_exit, i)\n \t\t\t\t? prob_pass_wont_exit\n \t\t\t\t: prob_pass_thru;\n \n@@ -1043,6 +1098,17 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t{\n \t  if (to_remove)\n \t    VEC_safe_push (edge, heap, *to_remove, new_spec_edges[SE_ORIG]);\n+\t  set_zero_probability (new_spec_edges[SE_ORIG]);\n+\n+\t  /* Scale the frequencies of the blocks dominated by the exit.  */\n+\t  if (bbs_to_scale)\n+\t    {\n+\t      EXECUTE_IF_SET_IN_BITMAP (bbs_to_scale, 0, i, bi)\n+\t\t{\n+\t\t  scale_bbs_frequencies_int (new_bbs + i, 1, scale_after_exit,\n+\t\t\t\t\t     REG_BR_PROB_BASE);\n+\t\t}\n+\t    }\n \t}\n \n       /* Record the first copy in the control flow order if it is not\n@@ -1068,6 +1134,17 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n     {\n       if (to_remove)\n \tVEC_safe_push (edge, heap, *to_remove, orig);\n+      set_zero_probability (orig);\n+\n+      /* Scale the frequencies of the blocks dominated by the exit.  */\n+      if (bbs_to_scale)\n+\t{\n+\t  EXECUTE_IF_SET_IN_BITMAP (bbs_to_scale, 0, i, bi)\n+\t    {\n+\t      scale_bbs_frequencies_int (bbs + i, 1, scale_after_exit,\n+\t\t\t\t\t REG_BR_PROB_BASE);\n+\t    }\n+\t}\n     }\n \n   /* Update the original loop.  */\n@@ -1103,6 +1180,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   free (first_active);\n \n   free (bbs);\n+  BITMAP_FREE (bbs_to_scale);\n \n   return true;\n }\n@@ -1239,13 +1317,12 @@ force_single_succ_latches (void)\n     --- edge e ---> [cond expr] ---> [first_head]\n \t\t\t|\n \t\t\t+---------> [second_head]\n-*/\n+\n+  THEN_PROB is the probability of then branch of the condition.  */\n \n static basic_block\n-lv_adjust_loop_entry_edge (basic_block first_head,\n-\t\t\t   basic_block second_head,\n-\t\t\t   edge e,\n-\t\t\t   void *cond_expr)\n+lv_adjust_loop_entry_edge (basic_block first_head, basic_block second_head,\n+\t\t\t   edge e, void *cond_expr, unsigned then_prob)\n {\n   basic_block new_head = NULL;\n   edge e1;\n@@ -1256,13 +1333,18 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n      insert conditional expr.  */\n   new_head = split_edge (e);\n \n-\n   lv_add_condition_to_bb (first_head, second_head, new_head,\n \t\t\t  cond_expr);\n \n   /* Don't set EDGE_TRUE_VALUE in RTL mode, as it's invalid there.  */\n+  e = single_succ_edge (new_head);\n   e1 = make_edge (new_head, first_head,\n \t\t  current_ir_type () == IR_GIMPLE ? EDGE_TRUE_VALUE : 0);\n+  e1->probability = then_prob;\n+  e->probability = REG_BR_PROB_BASE - then_prob;\n+  e1->count = RDIV (e->count * e1->probability, REG_BR_PROB_BASE);\n+  e->count = RDIV (e->count * e->probability, REG_BR_PROB_BASE);\n+\n   set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n   set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);\n \n@@ -1281,12 +1363,18 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n    may be a run time test for things that were not resolved by static\n    analysis (overlapping ranges (anti-aliasing), alignment, etc.).\n \n+   THEN_PROB is the probability of the then edge of the if.  THEN_SCALE\n+   is the ratio by that the frequencies in the original loop should\n+   be scaled.  ELSE_SCALE is the ratio by that the frequencies in the\n+   new loop should be scaled.\n+   \n    If PLACE_AFTER is true, we place the new loop after LOOP in the\n    instruction stream, otherwise it is placed before LOOP.  */\n \n struct loop *\n loop_version (struct loop *loop,\n \t      void *cond_expr, basic_block *condition_bb,\n+\t      unsigned then_prob, unsigned then_scale, unsigned else_scale,\n \t      bool place_after)\n {\n   basic_block first_head, second_head;\n@@ -1318,7 +1406,7 @@ loop_version (struct loop *loop,\n \n   /* Split loop entry edge and insert new block with cond expr.  */\n   cond_bb =  lv_adjust_loop_entry_edge (first_head, second_head,\n-\t\t\t\t\tentry, cond_expr);\n+\t\t\t\t\tentry, cond_expr, then_prob);\n   if (condition_bb)\n     *condition_bb = cond_bb;\n \n@@ -1334,7 +1422,8 @@ loop_version (struct loop *loop,\n   nloop = loopify (latch_edge,\n \t\t   single_pred_edge (get_bb_copy (loop->header)),\n \t\t   cond_bb, true_edge, false_edge,\n-\t\t   false /* Do not redirect all edges.  */);\n+\t\t   false /* Do not redirect all edges.  */,\n+\t\t   then_scale, else_scale);\n \n   exit = single_exit (loop);\n   if (exit)"}, {"sha": "b0e2aaa12be3feb4d1b28c0a52346d349f3a9a8c", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -451,7 +451,8 @@ unswitch_loop (struct loop *loop, basic_block unswitch_on, rtx cond, rtx cinsn)\n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n   nloop = loopify (latch_edge,\n \t\t   single_pred_edge (get_bb_copy (loop->header)), switch_bb,\n-\t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true);\n+\t\t   BRANCH_EDGE (switch_bb), FALLTHRU_EDGE (switch_bb), true,\n+\t\t   prob, REG_BR_PROB_BASE - prob);\n \n   /* Remove branches that are now unreachable in new loops.  */\n   remove_path (true_edge);"}, {"sha": "93f5b9a120bf28f4214701abfb91914de05e7c9e", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -868,6 +868,10 @@ canon_loop (struct loop *loop)\n     }\n }\n \n+/* Probability in % that the sms-ed loop rolls enough so that optimized\n+   version may be entered.  Just a guess.  */\n+#define PROB_SMS_ENOUGH_ITERATIONS 80\n+\n /* Main entry point, perform SMS scheduling on the loops of the function\n    that consist of single basic blocks.  */\n static void\n@@ -882,7 +886,7 @@ sms_schedule (void)\n   partial_schedule_ptr ps;\n   struct df *df;\n   basic_block bb = NULL;\n-  struct loop *loop, *nloop;\n+  struct loop *loop;\n   basic_block condition_bb = NULL;\n   edge latch_edge;\n   gcov_type trip_count = 0;\n@@ -1181,8 +1185,12 @@ sms_schedule (void)\n \t\t{\n \t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n \t\t\t\t\t\t GEN_INT(stage_count));\n+\t\t  unsigned prob = (PROB_SMS_ENOUGH_ITERATIONS\n+\t\t\t\t   * REG_BR_PROB_BASE) / 100;\n \n-\t\t  nloop = loop_version (loop, comp_rtx, &condition_bb, true);\n+\t\t  loop_version (loop, comp_rtx, &condition_bb,\n+\t\t\t\tprob, prob, REG_BR_PROB_BASE - prob,\n+\t\t\t\ttrue);\n \t\t}\n \n \t      /* Set new iteration count of loop kernel.  */"}, {"sha": "53683622321d2d4d40144b1062444eeeb0332a3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -1,3 +1,8 @@\n+2006-01-03  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/update-unroll-1.c: New test.\n+\t* gcc.dg/tree-ssa/update-unswitch-1.c: New test.\n+\n 2007-01-02  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/pr16194.c: We now output error on all three functions, not just"}, {"sha": "d911dd8e58b057b9f4943e41606b44b89fc69e15", "filename": "gcc/testsuite/gcc.dg/tree-ssa/update-unroll-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unroll-1.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O1 -fprefetch-loop-arrays -march=athlon -fdump-tree-aprefetch-blocks\" } */\n+\n+int a[10000];\n+\n+int foo(unsigned n)\n+{\n+  unsigned i, s = 0;\n+\n+  for (i = 0; i < n; i++)\n+    s += a[i];\n+\n+  return s;\n+}\n+\n+/* We used to make the probability that the body of the loop (unrolled\n+   to enable prefetching) is entered 0, which is not correct.  */\n+\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"aprefetch\"} } */\n+/* { dg-final { scan-tree-dump-not \"SUCC: 7 .100.0%\" \"aprefetch\"} } */\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "499b78b01376f585e1fddce56d0b3023db2fa73a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/update-unswitch-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unswitch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unswitch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-unswitch-1.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -funswitch-loops -fdump-tree-unswitch-blocks\" } */\n+\n+int bla(int p)\n+{\n+  unsigned i, s = 1;\n+\n+  for (i = 4; i < 100; i++)\n+    {\n+      if (p)\n+\ts += i/2;\n+      else\n+\ts *= i/2;\n+    }\n+\n+  return s;\n+}\n+\n+/* We used to make the probability that the first of the loops created\n+   by unswitching is entered 100%, which is not correct.  */\n+\n+/* { dg-final { scan-tree-dump-not \"Invalid sum\" \"unswitch\"} } */\n+/* { dg-final { scan-tree-dump-not \"SUCC: 3 .100.0%\" \"unswitch\"} } */\n+/* { dg-final { cleanup-tree-dump \"unswitch\" } } */"}, {"sha": "f224aa055b86a13eb7f119039efcb76bfc4c97d8", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -805,6 +805,9 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n        post;\n      } */\n \n+/* Probability in % that the unrolled loop is entered.  Just a guess.  */\n+#define PROB_UNROLLED_LOOP_ENTERED 90\n+\n void\n tree_unroll_loop (struct loop *loop, unsigned factor,\n \t\t  edge exit, struct tree_niter_desc *desc)\n@@ -816,11 +819,12 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n   struct loop *new_loop;\n   basic_block rest, exit_bb;\n   edge old_entry, new_entry, old_latch, precond_edge, new_exit;\n-  edge nonexit, new_nonexit;\n+  edge new_nonexit;\n   block_stmt_iterator bsi;\n   use_operand_p op;\n   bool ok;\n-  unsigned est_niter;\n+  unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;\n+  unsigned new_est_niter;\n   unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;\n   sbitmap wont_exit;\n \n@@ -829,22 +833,36 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n \t\t\t     &enter_main_cond, &exit_base, &exit_step,\n \t\t\t     &exit_cmp, &exit_bound);\n \n-  new_loop = loop_version (loop, enter_main_cond, NULL, true);\n+  /* Let us assume that the unrolled loop is quite likely to be entered.  */\n+  if (integer_nonzerop (enter_main_cond))\n+    prob_entry = REG_BR_PROB_BASE;\n+  else\n+    prob_entry = PROB_UNROLLED_LOOP_ENTERED * REG_BR_PROB_BASE / 100;\n+\n+  /* The values for scales should keep profile consistent, and somewhat close\n+     to correct.\n+\n+     TODO: The current value of SCALE_REST makes it appear that the loop that\n+     is created by splitting the remaining iterations of the unrolled loop is\n+     executed the same number of times as the original loop, and with the same\n+     frequencies, which is obviously wrong.  This does not appear to cause\n+     problems, so we do not bother with fixing it for now.  To make the profile\n+     correct, we would need to change the probability of the exit edge of the\n+     loop, and recompute the distribution of frequencies in its body because\n+     of this change (scale the frequencies of blocks before and after the exit\n+     by appropriate factors).  */\n+  scale_unrolled = prob_entry;\n+  scale_rest = REG_BR_PROB_BASE;\n+\n+  new_loop = loop_version (loop, enter_main_cond, NULL,\n+\t\t\t   prob_entry, scale_unrolled, scale_rest, true);\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n \n   /* Unroll the loop and remove the old exits.  */\n   dont_exit = ((exit->flags & EDGE_TRUE_VALUE)\n \t       ? boolean_false_node\n \t       : boolean_true_node);\n-  if (exit == EDGE_SUCC (exit->src, 0))\n-    nonexit = EDGE_SUCC (exit->src, 1);\n-  else\n-    nonexit = EDGE_SUCC (exit->src, 0);\n-  nonexit->probability = REG_BR_PROB_BASE;\n-  exit->probability = 0;\n-  nonexit->count += exit->count;\n-  exit->count = 0;\n   exit_if = last_stmt (exit->src);\n   COND_EXPR_COND (exit_if) = dont_exit;\n   update_stmt (exit_if);\n@@ -858,6 +876,29 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n   gcc_assert (ok);\n   update_ssa (TODO_update_ssa);\n \n+  /* Determine the probability of the exit edge.  */\n+  new_est_niter = est_niter / factor;\n+\n+  /* Without profile feedback, loops for that we do not know a better estimate\n+     are assumed to roll 10 times.  When we unroll such loop, it appears to\n+     roll too little, and it may even seem to be cold.  To avoid this, we\n+     ensure that the created loop appears to roll at least 5 times (but at\n+     most as many times as before unrolling).  */\n+  if (new_est_niter < 5)\n+    {\n+      if (est_niter < 5)\n+\tnew_est_niter = est_niter;\n+      else\n+\tnew_est_niter = 5;\n+    }\n+\n+  /* Ensure that the frequencies in the loop match the new estimated\n+     number of iterations.  */\n+  freq_h = loop->header->frequency;\n+  freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n+  if (freq_h != 0)\n+    scale_loop_frequencies (loop, freq_e * new_est_niter, freq_h);\n+\n   /* Prepare the cfg and update the phi nodes.  */\n   rest = loop_preheader_edge (new_loop)->src;\n   precond_edge = single_pred_edge (rest);\n@@ -866,12 +907,16 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n \n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n   new_exit->count = loop_preheader_edge (loop)->count;\n-  est_niter = est_niter / factor + 1;\n-  new_exit->probability = REG_BR_PROB_BASE / est_niter;\n+  new_exit->probability = REG_BR_PROB_BASE / new_est_niter;\n+\n+  rest->count += new_exit->count;\n+  rest->frequency += EDGE_FREQUENCY (new_exit);\n \n   new_nonexit = single_pred_edge (loop->latch);\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n   new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n+  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n+\t\t\t     REG_BR_PROB_BASE);\n \n   old_entry = loop_preheader_edge (loop);\n   new_entry = loop_preheader_edge (new_loop);"}, {"sha": "7a329c964878b782d892f7070aaf5b802c7d882a", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -269,13 +269,17 @@ static struct loop *\n tree_unswitch_loop (struct loop *loop,\n \t\t    basic_block unswitch_on, tree cond)\n {\n-  basic_block condition_bb;\n+  unsigned prob_true;\n+  edge edge_true, edge_false;\n \n   /* Some sanity checking.  */\n   gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n   gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n   gcc_assert (loop->inner == NULL);\n \n+  extract_true_false_edges_from_block (unswitch_on, &edge_true, &edge_false);\n+  prob_true = edge_true->probability;\n   return loop_version (loop, unshare_expr (cond), \n-\t\t       &condition_bb, false);\n+\t\t       NULL, prob_true, prob_true,\n+\t\t       REG_BR_PROB_BASE - prob_true, false);\n }"}, {"sha": "ec3f511e74eb030b630368375e40d1cc7f37acca", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=03cb2019ff14e03b2256bc6dca8a1bd3ec2bede9", "patch": "@@ -4699,11 +4699,13 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       basic_block new_exit_bb;\n       edge new_exit_e, e;\n       tree orig_phi, new_phi, arg;\n+      unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n \n       cond_expr = vect_create_cond_for_align_checks (loop_vinfo,\n                                                      &cond_expr_stmt_list);\n       initialize_original_copy_tables ();\n-      nloop = loop_version (loop, cond_expr, &condition_bb, true);\n+      nloop = loop_version (loop, cond_expr, &condition_bb,\n+\t\t\t    prob, prob, REG_BR_PROB_BASE - prob, true);\n       free_original_copy_tables();\n \n       /** Loop versioning violates an assumption we try to maintain during "}]}