{"sha": "340e0dd66466091ea2bbd160592c017eb67dc47d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwZTBkZDY2NDY2MDkxZWEyYmJkMTYwNTkyYzAxN2ViNjdkYzQ3ZA==", "commit": {"author": {"name": "Ilya Leoshkevich", "email": "iii@linux.ibm.com", "date": "2018-11-09T20:33:19Z"}, "committer": {"name": "Ilya Leoshkevich", "email": "iii@gcc.gnu.org", "date": "2018-11-09T20:33:19Z"}, "message": "S/390: Allow relative addressing of literal pool entries\n\nr265490 allowed the compiler to choose in a more flexible way whether to\nuse load or load-address-relative-long (LARL) instruction.  When it\nchose LARL for literal pool references, the latter ones were rewritten\nby pass_s390_early_mach to use UNSPEC_LTREF, which assumes base register\nusage, which in turn is not compatible with LARL.  The end result was an\nICE because of unrecognizable insn.\n\nUNSPEC_LTREF and friends are necessary in order to communicate the\ndependency on the base register to pass_sched2.  When relative\naddressing is used, no base register is necessary, so in such cases the\nrewrite must be avoided.\n\ngcc/ChangeLog:\n\n2018-11-09  Ilya Leoshkevich  <iii@linux.ibm.com>\n\n\tPR target/87762\n\t* config/s390/s390.c (s390_safe_relative_long_p): New function.\n\t(annotate_constant_pool_refs): Skip insns which support\n\trelative addressing.\n\t(annotate_constant_pool_refs_1): New helper function.\n\t(find_constant_pool_ref): Skip insns which support relative\n\taddression.\n\t(find_constant_pool_ref_1): New helper function.\n\t(replace_constant_pool_ref): Skip insns which support\n\trelative addressing.\n\t(replace_constant_pool_ref_1): New helper function.\n\t(s390_mainpool_start): Adapt to the new signature.\n\t(s390_mainpool_finish): Likewise.\n\t(s390_chunkify_start): Likewise.\n\t(s390_chunkify_finish): Likewise.\n\t(pass_s390_early_mach::execute): Likewise.\n\t(s390_prologue_plus_offset): Likewise.\n\t(s390_emit_prologue): Likewise.\n\t(s390_emit_epilogue): Likewise.\n\nFrom-SVN: r265991", "tree": {"sha": "d7d598af8c44850d0dca325c3f08006fc48c3d1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7d598af8c44850d0dca325c3f08006fc48c3d1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/340e0dd66466091ea2bbd160592c017eb67dc47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340e0dd66466091ea2bbd160592c017eb67dc47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/340e0dd66466091ea2bbd160592c017eb67dc47d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340e0dd66466091ea2bbd160592c017eb67dc47d/comments", "author": {"login": "iii-i", "id": 45998171, "node_id": "MDQ6VXNlcjQ1OTk4MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/45998171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iii-i", "html_url": "https://github.com/iii-i", "followers_url": "https://api.github.com/users/iii-i/followers", "following_url": "https://api.github.com/users/iii-i/following{/other_user}", "gists_url": "https://api.github.com/users/iii-i/gists{/gist_id}", "starred_url": "https://api.github.com/users/iii-i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iii-i/subscriptions", "organizations_url": "https://api.github.com/users/iii-i/orgs", "repos_url": "https://api.github.com/users/iii-i/repos", "events_url": "https://api.github.com/users/iii-i/events{/privacy}", "received_events_url": "https://api.github.com/users/iii-i/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81a227c6054a82118d80d3f4b2fffb44bc43aae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a227c6054a82118d80d3f4b2fffb44bc43aae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a227c6054a82118d80d3f4b2fffb44bc43aae2"}], "stats": {"total": 137, "additions": 102, "deletions": 35}, "files": [{"sha": "6d1b40d1e946a84380c2fc2b49c2e9185675115f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340e0dd66466091ea2bbd160592c017eb67dc47d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340e0dd66466091ea2bbd160592c017eb67dc47d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=340e0dd66466091ea2bbd160592c017eb67dc47d", "patch": "@@ -1,3 +1,25 @@\n+2018-11-09  Ilya Leoshkevich  <iii@linux.ibm.com>\n+\n+\tPR target/87762\n+\t* config/s390/s390.c (s390_safe_relative_long_p): New function.\n+\t(annotate_constant_pool_refs): Skip insns which support\n+\trelative addressing.\n+\t(annotate_constant_pool_refs_1): New helper function.\n+\t(find_constant_pool_ref): Skip insns which support relative\n+\taddression.\n+\t(find_constant_pool_ref_1): New helper function.\n+\t(replace_constant_pool_ref): Skip insns which support\n+\trelative addressing.\n+\t(replace_constant_pool_ref_1): New helper function.\n+\t(s390_mainpool_start): Adapt to the new signature.\n+\t(s390_mainpool_finish): Likewise.\n+\t(s390_chunkify_start): Likewise.\n+\t(s390_chunkify_finish): Likewise.\n+\t(pass_s390_early_mach::execute): Likewise.\n+\t(s390_prologue_plus_offset): Likewise.\n+\t(s390_emit_prologue): Likewise.\n+\t(s390_emit_epilogue): Likewise.\n+\n 2018-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (gimplify_scan_omp_clauses): Call sorry_at for valid"}, {"sha": "ab06ada0a16532c96d30bfd25b54b1255fb627eb", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 80, "deletions": 35, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340e0dd66466091ea2bbd160592c017eb67dc47d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340e0dd66466091ea2bbd160592c017eb67dc47d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=340e0dd66466091ea2bbd160592c017eb67dc47d", "patch": "@@ -2731,6 +2731,17 @@ s390_safe_attr_type (rtx_insn *insn)\n     return TYPE_NONE;\n }\n \n+/* Return attribute relative_long of insn.  */\n+\n+static bool\n+s390_safe_relative_long_p (rtx_insn *insn)\n+{\n+  if (recog_memoized (insn) >= 0)\n+    return get_attr_relative_long (insn) == RELATIVE_LONG_YES;\n+  else\n+    return false;\n+}\n+\n /* Return true if DISP is a valid short displacement.  */\n \n static bool\n@@ -8102,11 +8113,8 @@ s390_first_cycle_multipass_dfa_lookahead (void)\n   return 4;\n }\n \n-/* Annotate every literal pool reference in X by an UNSPEC_LTREF expression.\n-   Fix up MEMs as required.  */\n-\n static void\n-annotate_constant_pool_refs (rtx *x)\n+annotate_constant_pool_refs_1 (rtx *x)\n {\n   int i, j;\n   const char *fmt;\n@@ -8185,26 +8193,31 @@ annotate_constant_pool_refs (rtx *x)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  annotate_constant_pool_refs (&XEXP (*x, i));\n+\t  annotate_constant_pool_refs_1 (&XEXP (*x, i));\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  for (j = 0; j < XVECLEN (*x, i); j++)\n-\t    annotate_constant_pool_refs (&XVECEXP (*x, i, j));\n+\t    annotate_constant_pool_refs_1 (&XVECEXP (*x, i, j));\n \t}\n     }\n }\n \n-/* Find an annotated literal pool symbol referenced in RTX X,\n-   and store it at REF.  Will abort if X contains references to\n-   more than one such pool symbol; multiple references to the same\n-   symbol are allowed, however.\n+/* Annotate every literal pool reference in INSN by an UNSPEC_LTREF expression.\n+   Fix up MEMs as required.\n+   Skip insns which support relative addressing, because they do not use a base\n+   register.  */\n \n-   The rtx pointed to by REF must be initialized to NULL_RTX\n-   by the caller before calling this routine.  */\n+static void\n+annotate_constant_pool_refs (rtx_insn *insn)\n+{\n+  if (s390_safe_relative_long_p (insn))\n+    return;\n+  annotate_constant_pool_refs_1 (&PATTERN (insn));\n+}\n \n static void\n-find_constant_pool_ref (rtx x, rtx *ref)\n+find_constant_pool_ref_1 (rtx x, rtx *ref)\n {\n   int i, j;\n   const char *fmt;\n@@ -8236,21 +8249,37 @@ find_constant_pool_ref (rtx x, rtx *ref)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  find_constant_pool_ref (XEXP (x, i), ref);\n+\t  find_constant_pool_ref_1 (XEXP (x, i), ref);\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    find_constant_pool_ref (XVECEXP (x, i, j), ref);\n+\t    find_constant_pool_ref_1 (XVECEXP (x, i, j), ref);\n \t}\n     }\n }\n \n-/* Replace every reference to the annotated literal pool\n-   symbol REF in X by its base plus OFFSET.  */\n+/* Find an annotated literal pool symbol referenced in INSN,\n+   and store it at REF.  Will abort if INSN contains references to\n+   more than one such pool symbol; multiple references to the same\n+   symbol are allowed, however.\n+\n+   The rtx pointed to by REF must be initialized to NULL_RTX\n+   by the caller before calling this routine.\n+\n+   Skip insns which support relative addressing, because they do not use a base\n+   register.  */\n+\n+static void\n+find_constant_pool_ref (rtx_insn *insn, rtx *ref)\n+{\n+  if (s390_safe_relative_long_p (insn))\n+    return;\n+  find_constant_pool_ref_1 (PATTERN (insn), ref);\n+}\n \n static void\n-replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n+replace_constant_pool_ref_1 (rtx *x, rtx ref, rtx offset)\n {\n   int i, j;\n   const char *fmt;\n@@ -8281,16 +8310,29 @@ replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  replace_constant_pool_ref (&XEXP (*x, i), ref, offset);\n+\t  replace_constant_pool_ref_1 (&XEXP (*x, i), ref, offset);\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  for (j = 0; j < XVECLEN (*x, i); j++)\n-\t    replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, offset);\n+\t    replace_constant_pool_ref_1 (&XVECEXP (*x, i, j), ref, offset);\n \t}\n     }\n }\n \n+/* Replace every reference to the annotated literal pool\n+   symbol REF in INSN by its base plus OFFSET.\n+   Skip insns which support relative addressing, because they do not use a base\n+   register.  */\n+\n+static void\n+replace_constant_pool_ref (rtx_insn *insn, rtx ref, rtx offset)\n+{\n+  if (s390_safe_relative_long_p (insn))\n+    return;\n+  replace_constant_pool_ref_1 (&PATTERN (insn), ref, offset);\n+}\n+\n /* We keep a list of constants which we have to add to internal\n    constant tables in the middle of large functions.  */\n \n@@ -8691,7 +8733,7 @@ s390_mainpool_start (void)\n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n-\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  find_constant_pool_ref (insn, &pool_ref);\n \t  if (pool_ref)\n \t    {\n \t      rtx constant = get_pool_constant (pool_ref);\n@@ -8778,7 +8820,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx addr, pool_ref = NULL_RTX;\n-\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  find_constant_pool_ref (insn, &pool_ref);\n \t  if (pool_ref)\n \t    {\n \t      if (s390_execute_label (insn))\n@@ -8787,7 +8829,7 @@ s390_mainpool_finish (struct constant_pool *pool)\n \t\taddr = s390_find_constant (pool, get_pool_constant (pool_ref),\n \t\t\t\t\t\t get_pool_mode (pool_ref));\n \n-\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+\t      replace_constant_pool_ref (insn, pool_ref, addr);\n \t      INSN_CODE (insn) = -1;\n \t    }\n \t}\n@@ -8821,7 +8863,7 @@ s390_chunkify_start (void)\n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx pool_ref = NULL_RTX;\n-\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  find_constant_pool_ref (insn, &pool_ref);\n \t  if (pool_ref)\n \t    {\n \t      rtx constant = get_pool_constant (pool_ref);\n@@ -8978,7 +9020,7 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n \t{\n \t  rtx addr, pool_ref = NULL_RTX;\n-\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  find_constant_pool_ref (insn, &pool_ref);\n \t  if (pool_ref)\n \t    {\n \t      if (s390_execute_label (insn))\n@@ -8988,7 +9030,7 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n \t\t\t\t\t   get_pool_constant (pool_ref),\n \t\t\t\t\t   get_pool_mode (pool_ref));\n \n-\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+\t      replace_constant_pool_ref (insn, pool_ref, addr);\n \t      INSN_CODE (insn) = -1;\n \t    }\n \t}\n@@ -10581,7 +10623,7 @@ pass_s390_early_mach::execute (function *fun)\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       {\n-\tannotate_constant_pool_refs (&PATTERN (insn));\n+\tannotate_constant_pool_refs (insn);\n \tdf_insn_rescan (insn);\n       }\n   return 0;\n@@ -10602,7 +10644,7 @@ make_pass_s390_early_mach (gcc::context *ctxt)\n static rtx\n s390_prologue_plus_offset (rtx target, rtx reg, rtx offset, bool frame_related_p)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   rtx orig_offset = offset;\n \n   gcc_assert (REG_P (target));\n@@ -10636,7 +10678,7 @@ s390_prologue_plus_offset (rtx target, rtx reg, rtx offset, bool frame_related_p\n \n       if (!CONST_INT_P (offset))\n \t{\n-\t  annotate_constant_pool_refs (&PATTERN (insn));\n+\t  annotate_constant_pool_refs (insn);\n \n \t  if (frame_related_p)\n \t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n@@ -11076,7 +11118,7 @@ s390_emit_prologue (void)\n       rtx_insn *insns = s390_load_got ();\n \n       for (rtx_insn *insn = insns; insn; insn = NEXT_INSN (insn))\n-\tannotate_constant_pool_refs (&PATTERN (insn));\n+\tannotate_constant_pool_refs (insn);\n \n       emit_insn (insns);\n     }\n@@ -11140,7 +11182,8 @@ s390_emit_epilogue (bool sibcall)\n     }\n   else\n     {\n-      rtx insn, frame_off, cfa;\n+      rtx_insn *insn;\n+      rtx frame_off, cfa;\n \n       offset = area_bottom < 0 ? -area_bottom : 0;\n       frame_off = GEN_INT (cfun_frame_layout.frame_size - offset);\n@@ -11149,17 +11192,19 @@ s390_emit_epilogue (bool sibcall)\n \t\t\t gen_rtx_PLUS (Pmode, frame_pointer, frame_off));\n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{\n-\t  insn = gen_rtx_SET (frame_pointer,\n-\t\t\t      gen_rtx_PLUS (Pmode, frame_pointer, frame_off));\n-\t  insn = emit_insn (insn);\n+\t  rtx set;\n+\n+\t  set = gen_rtx_SET (frame_pointer,\n+\t\t\t     gen_rtx_PLUS (Pmode, frame_pointer, frame_off));\n+\t  insn = emit_insn (set);\n \t}\n       else\n \t{\n \t  if (!CONST_OK_FOR_K (INTVAL (frame_off)))\n \t    frame_off = force_const_mem (Pmode, frame_off);\n \n \t  insn = emit_insn (gen_add2_insn (frame_pointer, frame_off));\n-\t  annotate_constant_pool_refs (&PATTERN (insn));\n+\t  annotate_constant_pool_refs (insn);\n \t}\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, cfa);\n       RTX_FRAME_RELATED_P (insn) = 1;"}]}