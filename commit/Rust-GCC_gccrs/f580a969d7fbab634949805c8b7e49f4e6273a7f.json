{"sha": "f580a969d7fbab634949805c8b7e49f4e6273a7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU4MGE5NjlkN2ZiYWI2MzQ5NDk4MDVjOGI3ZTQ5ZjRlNjI3M2E3Zg==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@cavium.com", "date": "2017-06-29T18:20:14Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2017-06-29T18:20:14Z"}, "message": "ccmp.c (ccmp_tree_comparison_p): New function.\n\n2017-06-29  Steve Ellcey  <sellcey@cavium.com>\n\n\t* ccmp.c (ccmp_tree_comparison_p): New function.\n\t(ccmp_candidate_p): Update to use above function.\n\t(get_compare_parts): New function.\n\t(expand_ccmp_next): Update to use new functions.\n\t(expand_ccmp_expr_1): Take tree arg instead of gimple, update to use\n\tnew functions.\n\t(expand_ccmp_expr): Pass tree instead of gimple to expand_ccmp_expr_1,\n\ttake mode as argument.\n\t* ccmp.h (expand_ccmp_expr): Add mode as argument.\n\t* expr.c (expand_expr_real_1): Pass mode as argument.\n\nFrom-SVN: r249805", "tree": {"sha": "f02511316e7c5ca76d7116acd273831a4b4a1af2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f02511316e7c5ca76d7116acd273831a4b4a1af2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f580a969d7fbab634949805c8b7e49f4e6273a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f580a969d7fbab634949805c8b7e49f4e6273a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f580a969d7fbab634949805c8b7e49f4e6273a7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f580a969d7fbab634949805c8b7e49f4e6273a7f/comments", "author": {"login": "sellcey", "id": 25938520, "node_id": "MDQ6VXNlcjI1OTM4NTIw", "avatar_url": "https://avatars.githubusercontent.com/u/25938520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sellcey", "html_url": "https://github.com/sellcey", "followers_url": "https://api.github.com/users/sellcey/followers", "following_url": "https://api.github.com/users/sellcey/following{/other_user}", "gists_url": "https://api.github.com/users/sellcey/gists{/gist_id}", "starred_url": "https://api.github.com/users/sellcey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sellcey/subscriptions", "organizations_url": "https://api.github.com/users/sellcey/orgs", "repos_url": "https://api.github.com/users/sellcey/repos", "events_url": "https://api.github.com/users/sellcey/events{/privacy}", "received_events_url": "https://api.github.com/users/sellcey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be3b7dcf5c0f48ce72fe7a6f30db350e5c6872f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be3b7dcf5c0f48ce72fe7a6f30db350e5c6872f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be3b7dcf5c0f48ce72fe7a6f30db350e5c6872f3"}], "stats": {"total": 185, "additions": 111, "deletions": 74}, "files": [{"sha": "079c674a7ce674b22b44a01178ddd6332cea32f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f580a969d7fbab634949805c8b7e49f4e6273a7f", "patch": "@@ -1,3 +1,16 @@\n+2017-06-29  Steve Ellcey  <sellcey@cavium.com>\n+\n+\t* ccmp.c (ccmp_tree_comparison_p): New function.\n+\t(ccmp_candidate_p): Update to use above function.\n+\t(get_compare_parts): New function.\n+\t(expand_ccmp_next): Update to use new functions.\n+\t(expand_ccmp_expr_1): Take tree arg instead of gimple, update to use\n+\tnew functions.\n+\t(expand_ccmp_expr): Pass tree instead of gimple to expand_ccmp_expr_1,\n+\ttake mode as argument.\n+\t* ccmp.h (expand_ccmp_expr): Add mode as argument.\n+\t* expr.c (expand_expr_real_1): Pass mode as argument.\n+\n 2017-06-29  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* combine.c (combine_instructions): Print insns to dump_file, together"}, {"sha": "4fa3ebdc422b6e877532e030ed7d2169ab45f4e1", "filename": "gcc/ccmp.c", "status": "modified", "additions": 96, "deletions": 72, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fccmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fccmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.c?ref=f580a969d7fbab634949805c8b7e49f4e6273a7f", "patch": "@@ -38,6 +38,29 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ccmp.h\"\n #include \"predict.h\"\n \n+/* Check whether T is a simple boolean variable or a SSA name\n+   set by a comparison operator in the same basic block.  */\n+static bool\n+ccmp_tree_comparison_p (tree t, basic_block bb)\n+{\n+  gimple *g = get_gimple_for_ssa_name (t);\n+  tree_code tcode;\n+\n+  /* If we have a boolean variable allow it and generate a compare\n+     to zero reg when expanding.  */\n+  if (!g)\n+    return (TREE_CODE (TREE_TYPE (t)) == BOOLEAN_TYPE);\n+\n+  /* Check to see if SSA name is set by a comparison operator in\n+     the same basic block.  */ \n+  if (!is_gimple_assign (g))\n+    return false;\n+  if (bb != gimple_bb (g))\n+    return false;\n+  tcode = gimple_assign_rhs_code (g);\n+  return TREE_CODE_CLASS (tcode) == tcc_comparison;\n+}\n+\n /* The following functions expand conditional compare (CCMP) instructions.\n    Here is a short description about the over all algorithm:\n      * ccmp_candidate_p is used to identify the CCMP candidate\n@@ -71,70 +94,86 @@ along with GCC; see the file COPYING3.  If not see\n static bool\n ccmp_candidate_p (gimple *g)\n {\n-  tree rhs = gimple_assign_rhs_to_tree (g);\n+  tree rhs;\n   tree lhs, op0, op1;\n   gimple *gs0, *gs1;\n-  tree_code tcode, tcode0, tcode1;\n-  tcode = TREE_CODE (rhs);\n+  tree_code tcode;\n+  basic_block bb;\n+\n+  if (!g)\n+    return false;\n \n+  rhs = gimple_assign_rhs_to_tree (g);\n+  tcode = TREE_CODE (rhs);\n   if (tcode != BIT_AND_EXPR && tcode != BIT_IOR_EXPR)\n     return false;\n \n   lhs = gimple_assign_lhs (g);\n   op0 = TREE_OPERAND (rhs, 0);\n   op1 = TREE_OPERAND (rhs, 1);\n+  bb = gimple_bb (g);\n \n   if ((TREE_CODE (op0) != SSA_NAME) || (TREE_CODE (op1) != SSA_NAME)\n       || !has_single_use (lhs))\n     return false;\n \n-  gs0 = get_gimple_for_ssa_name (op0);\n-  gs1 = get_gimple_for_ssa_name (op1);\n-  if (!gs0 || !gs1 || !is_gimple_assign (gs0) || !is_gimple_assign (gs1)\n-      /* g, gs0 and gs1 must be in the same basic block, since current stage\n-\t is out-of-ssa.  We can not guarantee the correctness when forwording\n-\t the gs0 and gs1 into g whithout DATAFLOW analysis.  */\n-      || gimple_bb (gs0) != gimple_bb (gs1)\n-      || gimple_bb (gs0) != gimple_bb (g))\n-    return false;\n+  gs0 = get_gimple_for_ssa_name (op0); /* gs0 may be NULL */\n+  gs1 = get_gimple_for_ssa_name (op1); /* gs1 may be NULL */\n \n-  tcode0 = gimple_assign_rhs_code (gs0);\n-  tcode1 = gimple_assign_rhs_code (gs1);\n-  if (TREE_CODE_CLASS (tcode0) == tcc_comparison\n-      && TREE_CODE_CLASS (tcode1) == tcc_comparison)\n+  if (ccmp_tree_comparison_p (op0, bb) && ccmp_tree_comparison_p (op1, bb))\n     return true;\n-  if (TREE_CODE_CLASS (tcode0) == tcc_comparison\n-      && ccmp_candidate_p (gs1))\n+  if (ccmp_tree_comparison_p (op0, bb) && ccmp_candidate_p (gs1))\n     return true;\n-  else if (TREE_CODE_CLASS (tcode1) == tcc_comparison\n-\t   && ccmp_candidate_p (gs0))\n+  if (ccmp_tree_comparison_p (op1, bb) && ccmp_candidate_p (gs0))\n     return true;\n   /* We skip ccmp_candidate_p (gs1) && ccmp_candidate_p (gs0) since\n-     there is no way to set the CC flag.  */\n+     there is no way to set and maintain the CC flag on both sides of\n+     the logical operator at the same time.  */\n   return false;\n }\n \n+/* Extract the comparison we want to do from the tree.  */\n+void\n+get_compare_parts (tree t, int *up, rtx_code *rcode,\n+\t\t   tree *rhs1, tree *rhs2)\n+{\n+  tree_code code;\n+  gimple *g = get_gimple_for_ssa_name (t);\n+  if (g)\n+    {\n+      *up = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)));\n+      code = gimple_assign_rhs_code (g);\n+      *rcode = get_rtx_code (code, *up);\n+      *rhs1 = gimple_assign_rhs1 (g);\n+      *rhs2 = gimple_assign_rhs2 (g);\n+    }\n+  else\n+    {\n+      /* If g is not a comparison operator create a compare to zero.  */\n+      *up = 1;\n+      *rcode = NE;\n+      *rhs1 = t;\n+      *rhs2 = build_zero_cst (TREE_TYPE (t));\n+    }\n+}\n+\n /* PREV is a comparison with the CC register which represents the\n    result of the previous CMP or CCMP.  The function expands the\n    next compare based on G which is ANDed/ORed with the previous\n    compare depending on CODE.\n    PREP_SEQ returns all insns to prepare opearands for compare.\n    GEN_SEQ returns all compare insns.  */\n static rtx\n-expand_ccmp_next (gimple *g, tree_code code, rtx prev,\n+expand_ccmp_next (tree op, tree_code code, rtx prev,\n \t\t  rtx_insn **prep_seq, rtx_insn **gen_seq)\n {\n   rtx_code rcode;\n-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)));\n-\n-  gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n-\n-  rcode = get_rtx_code (gimple_assign_rhs_code (g), unsignedp);\n+  int unsignedp;\n+  tree rhs1, rhs2;\n \n+  get_compare_parts(op, &unsignedp, &rcode, &rhs1, &rhs2);\n   return targetm.gen_ccmp_next (prep_seq, gen_seq, prev, rcode,\n-\t\t\t\tgimple_assign_rhs1 (g),\n-\t\t\t\tgimple_assign_rhs2 (g),\n-\t\t\t\tget_rtx_code (code, 0));\n+\t\t\t\trhs1, rhs2, get_rtx_code (code, 0));\n }\n \n /* Expand conditional compare gimple G.  A typical CCMP sequence is like:\n@@ -153,39 +192,42 @@ expand_ccmp_expr_1 (gimple *g, rtx_insn **prep_seq, rtx_insn **gen_seq)\n {\n   tree exp = gimple_assign_rhs_to_tree (g);\n   tree_code code = TREE_CODE (exp);\n-  gimple *gs0 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 0));\n-  gimple *gs1 = get_gimple_for_ssa_name (TREE_OPERAND (exp, 1));\n+  basic_block bb = gimple_bb (g);\n+\n+  tree op0 = TREE_OPERAND (exp, 0);\n+  tree op1 = TREE_OPERAND (exp, 1);\n+  gimple *gs0 = get_gimple_for_ssa_name (op0);\n+  gimple *gs1 = get_gimple_for_ssa_name (op1);\n   rtx tmp;\n-  tree_code code0 = gimple_assign_rhs_code (gs0);\n-  tree_code code1 = gimple_assign_rhs_code (gs1);\n \n   gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);\n-  gcc_assert (gs0 && gs1 && is_gimple_assign (gs0) && is_gimple_assign (gs1));\n \n-  if (TREE_CODE_CLASS (code0) == tcc_comparison)\n+  if (ccmp_tree_comparison_p (op0, bb))\n     {\n-      if (TREE_CODE_CLASS (code1) == tcc_comparison)\n+      if (ccmp_tree_comparison_p (op1, bb))\n \t{\n \t  int unsignedp0, unsignedp1;\n \t  rtx_code rcode0, rcode1;\n+\t  tree logical_op0_rhs1, logical_op0_rhs2;\n+\t  tree logical_op1_rhs1, logical_op1_rhs2;\n \t  int speed_p = optimize_insn_for_speed_p ();\n+\n \t  rtx tmp2 = NULL_RTX, ret = NULL_RTX, ret2 = NULL_RTX;\n \t  unsigned cost1 = MAX_COST;\n \t  unsigned cost2 = MAX_COST;\n \n-\t  unsignedp0 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs0)));\n-\t  unsignedp1 = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (gs1)));\n-\t  rcode0 = get_rtx_code (code0, unsignedp0);\n-\t  rcode1 = get_rtx_code (code1, unsignedp1);\n+\t  get_compare_parts (op0, &unsignedp0, &rcode0,\n+\t\t\t     &logical_op0_rhs1, &logical_op0_rhs2);\n+\n+\t  get_compare_parts (op1, &unsignedp1, &rcode1,\n+\t\t\t     &logical_op1_rhs1, &logical_op1_rhs2);\n \n \t  rtx_insn *prep_seq_1, *gen_seq_1;\n \t  tmp = targetm.gen_ccmp_first (&prep_seq_1, &gen_seq_1, rcode0,\n-\t\t\t\t\tgimple_assign_rhs1 (gs0),\n-\t\t\t\t\tgimple_assign_rhs2 (gs0));\n-\n+\t\t\t\t\tlogical_op0_rhs1, logical_op0_rhs2);\n \t  if (tmp != NULL)\n \t    {\n-\t      ret = expand_ccmp_next (gs1, code, tmp, &prep_seq_1, &gen_seq_1);\n+\t      ret = expand_ccmp_next (op1, code, tmp, &prep_seq_1, &gen_seq_1);\n \t      cost1 = seq_cost (prep_seq_1, speed_p);\n \t      cost1 += seq_cost (gen_seq_1, speed_p);\n \t    }\n@@ -197,27 +239,22 @@ expand_ccmp_expr_1 (gimple *g, rtx_insn **prep_seq, rtx_insn **gen_seq)\n \t  rtx_insn *prep_seq_2, *gen_seq_2;\n \t  if (tmp == NULL || cost1 < COSTS_N_INSNS (25))\n \t    tmp2 = targetm.gen_ccmp_first (&prep_seq_2, &gen_seq_2, rcode1,\n-\t\t\t\t\t   gimple_assign_rhs1 (gs1),\n-\t\t\t\t\t   gimple_assign_rhs2 (gs1));\n-\n+\t\t\t\t\t   logical_op1_rhs1, logical_op1_rhs2);\n \t  if (!tmp && !tmp2)\n \t    return NULL_RTX;\n-\n \t  if (tmp2 != NULL)\n \t    {\n-\t      ret2 = expand_ccmp_next (gs0, code, tmp2, &prep_seq_2,\n+\t      ret2 = expand_ccmp_next (op0, code, tmp2, &prep_seq_2,\n \t\t\t\t       &gen_seq_2);\n \t      cost2 = seq_cost (prep_seq_2, speed_p);\n \t      cost2 += seq_cost (gen_seq_2, speed_p);\n \t    }\n-\n \t  if (cost2 < cost1)\n \t    {\n \t      *prep_seq = prep_seq_2;\n \t      *gen_seq = gen_seq_2;\n \t      return ret2;\n \t    }\n-\n \t  *prep_seq = prep_seq_1;\n \t  *gen_seq = gen_seq_1;\n \t  return ret;\n@@ -227,28 +264,18 @@ expand_ccmp_expr_1 (gimple *g, rtx_insn **prep_seq, rtx_insn **gen_seq)\n \t  tmp = expand_ccmp_expr_1 (gs1, prep_seq, gen_seq);\n \t  if (!tmp)\n \t    return NULL_RTX;\n-\n-\t  return expand_ccmp_next (gs0, code, tmp, prep_seq, gen_seq);\n+\t  return expand_ccmp_next (op0, code, tmp, prep_seq, gen_seq);\n \t}\n     }\n   else\n     {\n       gcc_assert (gimple_assign_rhs_code (gs0) == BIT_AND_EXPR\n                   || gimple_assign_rhs_code (gs0) == BIT_IOR_EXPR);\n-\n-      if (TREE_CODE_CLASS (gimple_assign_rhs_code (gs1)) == tcc_comparison)\n-\t{\n-\t  tmp = expand_ccmp_expr_1 (gs0, prep_seq, gen_seq);\n-\t  if (!tmp)\n-\t    return NULL_RTX;\n-\n-\t  return expand_ccmp_next (gs1, code, tmp, prep_seq, gen_seq);\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (gimple_assign_rhs_code (gs1) == BIT_AND_EXPR\n-\t\t      || gimple_assign_rhs_code (gs1) == BIT_IOR_EXPR);\n-\t}\n+      gcc_assert (ccmp_tree_comparison_p (op1, bb));\n+      tmp = expand_ccmp_expr_1 (gs0, prep_seq, gen_seq);\n+      if (!tmp)\n+\treturn NULL_RTX;\n+      return expand_ccmp_next (op1, code, tmp, prep_seq, gen_seq);\n     }\n \n   return NULL_RTX;\n@@ -258,7 +285,7 @@ expand_ccmp_expr_1 (gimple *g, rtx_insn **prep_seq, rtx_insn **gen_seq)\n    Return NULL_RTX if G is not a legal candidate or expand fail.\n    Otherwise return the target.  */\n rtx\n-expand_ccmp_expr (gimple *g)\n+expand_ccmp_expr (gimple *g, machine_mode mode)\n {\n   rtx_insn *last;\n   rtx tmp;\n@@ -275,7 +302,6 @@ expand_ccmp_expr (gimple *g)\n     {\n       insn_code icode;\n       machine_mode cc_mode = CCmode;\n-      tree lhs = gimple_assign_lhs (g);\n       rtx_code cmp_code = GET_CODE (tmp);\n \n #ifdef SELECT_CC_MODE\n@@ -284,7 +310,6 @@ expand_ccmp_expr (gimple *g)\n       icode = optab_handler (cstore_optab, cc_mode);\n       if (icode != CODE_FOR_nothing)\n \t{\n-\t  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n \t  rtx target = gen_reg_rtx (mode);\n \n \t  emit_insn (prep_seq);\n@@ -300,4 +325,3 @@ expand_ccmp_expr (gimple *g)\n   delete_insns_since (last);\n   return NULL_RTX;\n }\n-"}, {"sha": "93d10491eb9558e1e05e2897545fdc77bf60f013", "filename": "gcc/ccmp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fccmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fccmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fccmp.h?ref=f580a969d7fbab634949805c8b7e49f4e6273a7f", "patch": "@@ -20,6 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CCMP_H\n #define GCC_CCMP_H\n \n-extern rtx expand_ccmp_expr (gimple *);\n+extern rtx expand_ccmp_expr (gimple *, machine_mode);\n \n #endif  /* GCC_CCMP_H  */"}, {"sha": "0a52a3d7209bcceb705e226d77f13792ce417b01", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f580a969d7fbab634949805c8b7e49f4e6273a7f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f580a969d7fbab634949805c8b7e49f4e6273a7f", "patch": "@@ -9776,7 +9776,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t      if (targetm.gen_ccmp_first)\n \t\t{\n \t\t  gcc_checking_assert (targetm.gen_ccmp_next != NULL);\n-\t\t  r = expand_ccmp_expr (g);\n+\t\t  r = expand_ccmp_expr (g, mode);\n \t\t  if (r)\n \t\t    break;\n \t\t}"}]}