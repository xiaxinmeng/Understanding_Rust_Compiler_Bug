{"sha": "0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDExOWQ1YTIzYWJmMmY0NWY1ZWMzMzY1ODlkNGFkYWQ5ZGZjNWM3Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-01-07T08:51:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-01-07T08:51:59Z"}, "message": "re PR tree-optimization/88676 (missed opportunity in integer conditional)\n\n\tPR tree-optimization/88676\n\t* tree-ssa-phiopt.c (two_value_replacement): New function.\n\t(tree_ssa_phiopt_worker): Call it.\n\n\t* gcc.dg/tree-ssa/pr88676.c: New test.\n\t* gcc.dg/pr88676.c: New test.\n\t* gcc.dg/tree-ssa/pr15826.c: Just verify there is no goto,\n\tallow &.\n\nFrom-SVN: r267634", "tree": {"sha": "c60e949be5ed6200fcf221694c17006c1d2b3366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c60e949be5ed6200fcf221694c17006c1d2b3366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76192f9356f1fc5b5e4d251020625d46c48a8dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76192f9356f1fc5b5e4d251020625d46c48a8dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76192f9356f1fc5b5e4d251020625d46c48a8dd8"}], "stats": {"total": 338, "additions": 335, "deletions": 3}, "files": [{"sha": "44e9eb3a29105be7154c2f0d8e3f56873139f958", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -1,5 +1,9 @@\n 2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/88676\n+\t* tree-ssa-phiopt.c (two_value_replacement): New function.\n+\t(tree_ssa_phiopt_worker): Call it.\n+\n \tPR sanitizer/88619\n \t* cfgexpand.c (expand_stack_vars): Only align prev_offset to\n \tASAN_MIN_RED_ZONE_SIZE, not to maximum of that and alignb."}, {"sha": "5a01e0ca5c6370955748c1bc9ca7191a33b64e8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -1,5 +1,11 @@\n 2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/88676\n+\t* gcc.dg/tree-ssa/pr88676.c: New test.\n+\t* gcc.dg/pr88676.c: New test.\n+\t* gcc.dg/tree-ssa/pr15826.c: Just verify there is no goto,\n+\tallow &.\n+\n \tPR sanitizer/88619\n \t* c-c++-common/asan/pr88619.c: New test.\n "}, {"sha": "b5fdd9342b8ca76f2d6939494e951add9307ebf6", "filename": "gcc/testsuite/gcc.dg/pr88676.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr88676.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr88676.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr88676.c?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/88676 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"tree-ssa/pr88676.c\"\n+\n+__attribute__((noipa)) void\n+bar (int x, int y, int z)\n+{\n+  if (z != 115 && z != 116)\n+    __builtin_abort ();\n+  if (x == 98)\n+    {\n+      if (y != z)\n+\t__builtin_abort ();\n+    }\n+  else if (x != 99)\n+    __builtin_abort ();\n+  else if (z == 115)\n+    {\n+      if (y != 116)\n+\t__builtin_abort ();\n+    }\n+  else if (y != 115)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  if (f1 (0) != 1 || f1 (1) != 2)\n+    __builtin_abort ();\n+  int i;\n+  for (i = -12; i < 12; i++)\n+    {\n+      f2 (i);\n+      f3 (i);\n+      f4 (i);\n+      f5 (i);\n+      f6 (i);\n+      f7 (i);\n+      f8 (i);\n+      f9 (i);\n+      if (f10 (i) != ((i & 1) ? 84 : 85))\n+\t__builtin_abort ();\n+    }\n+  return 0;\n+}"}, {"sha": "f36c2098c34b1fe16300727c73f1eadfc6d12743", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr15826.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15826.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15826.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr15826.c?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -33,4 +33,4 @@ andrew (struct s *p)\n   return i;\n }\n \n-/* { dg-final { scan-tree-dump-times \" & | goto \" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \"goto \" \"optimized\" } } */"}, {"sha": "607ac6b8e9c750b93a5de100ff9f5ae8d2813d58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr88676.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88676.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88676.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr88676.c?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -0,0 +1,133 @@\n+/* PR tree-optimization/88676 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" = PHI <\" \"optimized\" } } */\n+\n+void bar (int, int, int);\n+\n+__attribute__((noipa)) int\n+f1 (unsigned x)\n+{\n+  int r;\n+  if (x >= 2)\n+    __builtin_unreachable ();\n+  switch (x)\n+    {\n+    case 0:\n+      r = 1;\n+      break;\n+    case 1:\n+      r = 2;\n+      break;\n+    default:\n+      r = 0;\n+      break;\n+    }\n+  return r;\n+}\n+\n+__attribute__((noipa)) void\n+f2 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x != 98)\n+    y = 115;\n+  else\n+    y = 116;\n+  bar (x, y, 116);\n+}\n+\n+__attribute__((noipa)) void\n+f3 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x == 98)\n+    y = 115;\n+  else\n+    y = 116;\n+  bar (x, y, 115);\n+}\n+\n+__attribute__((noipa)) void\n+f4 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x != 99)\n+    y = 115;\n+  else\n+    y = 116;\n+  bar (x, y, 115);\n+}\n+\n+__attribute__((noipa)) void\n+f5 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x == 99)\n+    y = 115;\n+  else\n+    y = 116;\n+  bar (x, y, 116);\n+}\n+\n+__attribute__((noipa)) void\n+f6 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x != 98)\n+    y = 116;\n+  else\n+    y = 115;\n+  bar (x, y, 115);\n+}\n+\n+__attribute__((noipa)) void\n+f7 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x == 98)\n+    y = 116;\n+  else\n+    y = 115;\n+  bar (x, y, 116);\n+}\n+\n+__attribute__((noipa)) void\n+f8 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x != 99)\n+    y = 116;\n+  else\n+    y = 115;\n+  bar (x, y, 116);\n+}\n+\n+__attribute__((noipa)) void\n+f9 (int x)\n+{\n+  int y;\n+  x = (x & 1) + 98;\n+  if (x == 99)\n+    y = 116;\n+  else\n+    y = 115;\n+  bar (x, y, 115);\n+}\n+\n+__attribute__((noipa)) int\n+f10 (int x)\n+{\n+  x = (x & 1) + 36;\n+  if (x == 36)\n+    return 85;\n+  else\n+    return 84;\n+}"}, {"sha": "025e403759684550d04db29794e89b4db5917e99", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 143, "deletions": 2, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0119d5a23abf2f45f5ec336589d4adad9dfc5c7f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=0119d5a23abf2f45f5ec336589d4adad9dfc5c7f", "patch": "@@ -48,6 +48,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n \n static unsigned int tree_ssa_phiopt_worker (bool, bool, bool);\n+static bool two_value_replacement (basic_block, basic_block, edge, gphi *,\n+\t\t\t\t   tree, tree);\n static bool conditional_replacement (basic_block, basic_block,\n \t\t\t\t     edge, edge, gphi *, tree, tree);\n static gphi *factor_out_conditional_conversion (edge, edge, gphi *, tree, tree,\n@@ -332,8 +334,11 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t    }\n \n \t  /* Do the replacement of conditional if it can be done.  */\n-\t  if (!early_p\n-\t      && conditional_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t  if (two_value_replacement (bb, bb1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n+\t  else if (!early_p\n+\t\t   && conditional_replacement (bb, bb1, e1, e2, phi,\n+\t\t\t\t\t       arg0, arg1))\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n@@ -572,6 +577,142 @@ factor_out_conditional_conversion (edge e0, edge e1, gphi *phi,\n   return newphi;\n }\n \n+/* Optimize\n+   # x_5 in range [cst1, cst2] where cst2 = cst1 + 1\n+   if (x_5 op cstN) # where op is == or != and N is 1 or 2\n+     goto bb3;\n+   else\n+     goto bb4;\n+   bb3:\n+   bb4:\n+   # r_6 = PHI<cst3(2), cst4(3)> # where cst3 == cst4 + 1 or cst4 == cst3 + 1\n+\n+   to r_6 = x_5 + (min (cst3, cst4) - cst1) or\n+   r_6 = (min (cst3, cst4) + cst1) - x_5 depending on op, N and which\n+   of cst3 and cst4 is smaller.  */\n+\n+static bool\n+two_value_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t       edge e1, gphi *phi, tree arg0, tree arg1)\n+{\n+  /* Only look for adjacent integer constants.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+      || TREE_CODE (arg0) != INTEGER_CST\n+      || TREE_CODE (arg1) != INTEGER_CST\n+      || (tree_int_cst_lt (arg0, arg1)\n+\t  ? wi::to_widest (arg0) + 1 != wi::to_widest (arg1)\n+\t  : wi::to_widest (arg1) + 1 != wi::to_widest (arg1)))\n+    return false;\n+\n+  if (!empty_block_p (middle_bb))\n+    return false;\n+\n+  gimple *stmt = last_stmt (cond_bb);\n+  tree lhs = gimple_cond_lhs (stmt);\n+  tree rhs = gimple_cond_rhs (stmt);\n+\n+  if (TREE_CODE (lhs) != SSA_NAME\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+      || TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE\n+      || TREE_CODE (rhs) != INTEGER_CST)\n+    return false;\n+\n+  switch (gimple_cond_code (stmt))\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  wide_int min, max;\n+  if (get_range_info (lhs, &min, &max) != VR_RANGE\n+      || min + 1 != max\n+      || (wi::to_wide (rhs) != min\n+\t  && wi::to_wide (rhs) != max))\n+    return false;\n+\n+  /* We need to know which is the true edge and which is the false\n+     edge so that we know when to invert the condition below.  */\n+  edge true_edge, false_edge;\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n+  if ((gimple_cond_code (stmt) == EQ_EXPR)\n+      ^ (wi::to_wide (rhs) == max)\n+      ^ (e1 == false_edge))\n+    std::swap (arg0, arg1);\n+\n+  tree type;\n+  if (TYPE_PRECISION (TREE_TYPE (lhs)) == TYPE_PRECISION (TREE_TYPE (arg0)))\n+    {\n+      /* Avoid performing the arithmetics in bool type which has different\n+\t semantics, otherwise prefer unsigned types from the two with\n+\t the same precision.  */\n+      if (TREE_CODE (TREE_TYPE (arg0)) == BOOLEAN_TYPE\n+\t  || !TYPE_UNSIGNED (TREE_TYPE (arg0)))\n+\ttype = TREE_TYPE (lhs);\n+      else\n+\ttype = TREE_TYPE (arg0);\n+    }\n+  else if (TYPE_PRECISION (TREE_TYPE (lhs)) > TYPE_PRECISION (TREE_TYPE (arg0)))\n+    type = TREE_TYPE (lhs);\n+  else\n+    type = TREE_TYPE (arg0);\n+\n+  min = wide_int::from (min, TYPE_PRECISION (type),\n+\t\t\tTYPE_SIGN (TREE_TYPE (lhs)));\n+  wide_int a = wide_int::from (wi::to_wide (arg0), TYPE_PRECISION (type),\n+\t\t\t       TYPE_SIGN (TREE_TYPE (arg0)));\n+  enum tree_code code;\n+  wi::overflow_type ovf;\n+  if (tree_int_cst_lt (arg0, arg1))\n+    {\n+      code = PLUS_EXPR;\n+      a -= min;\n+      if (!TYPE_UNSIGNED (type))\n+\t{\n+\t  /* lhs is known to be in range [min, min+1] and we want to add a\n+\t     to it.  Check if that operation can overflow for those 2 values\n+\t     and if yes, force unsigned type.  */\n+\t  wi::add (min + (wi::neg_p (a) ? 0 : 1), a, SIGNED, &ovf);\n+\t  if (ovf)\n+\t    type = unsigned_type_for (type);\n+\t}\n+    }\n+  else\n+    {\n+      code = MINUS_EXPR;\n+      a += min;\n+      if (!TYPE_UNSIGNED (type))\n+\t{\n+\t  /* lhs is known to be in range [min, min+1] and we want to subtract\n+\t     it from a.  Check if that operation can overflow for those 2\n+\t     values and if yes, force unsigned type.  */\n+\t  wi::sub (a, min + (wi::neg_p (min) ? 0 : 1), SIGNED, &ovf);\n+\t  if (ovf)\n+\t    type = unsigned_type_for (type);\n+\t}\n+    }\n+\n+  tree arg = wide_int_to_tree (type, a);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  if (!useless_type_conversion_p (type, TREE_TYPE (lhs)))\n+    lhs = gimplify_build1 (&gsi, NOP_EXPR, type, lhs);\n+  tree new_rhs;\n+  if (code == PLUS_EXPR)\n+    new_rhs = gimplify_build2 (&gsi, PLUS_EXPR, type, lhs, arg);\n+  else\n+    new_rhs = gimplify_build2 (&gsi, MINUS_EXPR, type, arg, lhs);\n+  if (!useless_type_conversion_p (TREE_TYPE (arg0), type))\n+    new_rhs = gimplify_build1 (&gsi, NOP_EXPR, TREE_TYPE (arg0), new_rhs);\n+\n+  replace_phi_edge_with_variable (cond_bb, e1, phi, new_rhs);\n+\n+  /* Note that we optimized this PHI.  */\n+  return true;\n+}\n+\n /*  The function conditional_replacement does the main work of doing the\n     conditional replacement.  Return true if the replacement is done.\n     Otherwise return false."}]}