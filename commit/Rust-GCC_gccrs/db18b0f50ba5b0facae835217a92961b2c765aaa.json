{"sha": "db18b0f50ba5b0facae835217a92961b2c765aaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxOGIwZjUwYmE1YjBmYWNhZTgzNTIxN2E5Mjk2MWIyYzc2NWFhYQ==", "commit": {"author": {"name": "Laurent Pautet", "email": "pautet@adacore.com", "date": "2008-07-30T17:38:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-30T17:38:55Z"}, "message": "g-pehage.adb: Remove a limitation on the length of the words handled by the minimal perfect...\n\n2008-07-30  Laurent Pautet  <pautet@adacore.com>\n\n\t* g-pehage.adb:\n\tRemove a limitation on the length of the words handled by the minimal\n\tperfect hash function generator.\n\n\t* g-pehage.ads:\n\tDetail the use of subprograms Insert, Initialize, Compute and Finalize.\n\tFix some typos.\n\nFrom-SVN: r138331", "tree": {"sha": "e4482530dfc1d72b336e69879666c8e2eb1fd1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4482530dfc1d72b336e69879666c8e2eb1fd1ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db18b0f50ba5b0facae835217a92961b2c765aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db18b0f50ba5b0facae835217a92961b2c765aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db18b0f50ba5b0facae835217a92961b2c765aaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db18b0f50ba5b0facae835217a92961b2c765aaa/comments", "author": null, "committer": null, "parents": [{"sha": "a7a0d4dd08eba93103b1f2c6173af8ae979e3ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a0d4dd08eba93103b1f2c6173af8ae979e3ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a0d4dd08eba93103b1f2c6173af8ae979e3ea3"}], "stats": {"total": 264, "additions": 176, "deletions": 88}, "files": [{"sha": "c779fac7ca7f6560ed3c70f778f04b3dd3ddb465", "filename": "gcc/ada/g-pehage.adb", "status": "modified", "additions": 155, "deletions": 73, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db18b0f50ba5b0facae835217a92961b2c765aaa/gcc%2Fada%2Fg-pehage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db18b0f50ba5b0facae835217a92961b2c765aaa/gcc%2Fada%2Fg-pehage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.adb?ref=db18b0f50ba5b0facae835217a92961b2c765aaa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2007, AdaCore                     --\n+--                     Copyright (C) 2002-2008, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,8 +51,8 @@ package body GNAT.Perfect_Hash_Generators is\n \n    --  where f1 and f2 are functions that map strings into integers, and g is a\n    --  function that maps integers into [0, m-1]. h can be order preserving.\n-   --  For instance, let W = {w_0, ..., w_i, ...,\n-   --  w_m-1}, h can be defined such that h (w_i) = i.\n+   --  For instance, let W = {w_0, ..., w_i, ..., w_m-1}, h can be defined\n+   --  such that h (w_i) = i.\n \n    --  This algorithm defines two possible constructions of f1 and f2. Method\n    --  b) stores the hash function in less memory space at the expense of\n@@ -82,10 +82,10 @@ package body GNAT.Perfect_Hash_Generators is\n    --  probability of generating an acyclic graph, n >= 2m. If it is not\n    --  acyclic, Tk have to be regenerated.\n \n-   --  In the assignment step, the algorithm builds function g. As is acyclic,\n-   --  there is a vertex v1 with only one neighbor v2. Let w_i be the word such\n-   --  that v1 = f1 (w_i) and v2 = f2 (w_i). Let g (v1) = 0 by construction and\n-   --  g (v2) = (i - g (v1)) mod n (or to be general, (h (i) - g (v1) mod n).\n+   --  In the assignment step, the algorithm builds function g. As G is\n+   --  acyclic, there is a vertex v1 with only one neighbor v2. Let w_i be\n+   --  the word such that v1 = f1 (w_i) and v2 = f2 (w_i). Let g (v1) = 0 by\n+   --  construction and g (v2) = (i - g (v1)) mod n (or h (i) - g (v1) mod n).\n    --  If word w_j is such that v2 = f1 (w_j) and v3 = f2 (w_j), g (v3) = (j -\n    --  g (v2)) mod (or to be general, (h (j) - g (v2)) mod n). If w_i has no\n    --  neighbor, then another vertex is selected. The algorithm traverses G to\n@@ -102,11 +102,12 @@ package body GNAT.Perfect_Hash_Generators is\n    No_Edge   : constant Edge_Id   := -1;\n    No_Table  : constant Table_Id  := -1;\n \n-   Max_Word_Length : constant := 32;\n-   subtype Word_Type is String (1 .. Max_Word_Length);\n-   Null_Word : constant Word_Type := (others => ASCII.NUL);\n-   --  Store keyword in a word. Note that the length of word is limited to 32\n-   --  characters.\n+   type Word_Type is new String_Access;\n+   procedure Free_Word (W : in out Word_Type);\n+   function New_Word (S : String) return Word_Type;\n+\n+   procedure Resize_Word (W : in out Word_Type; Len : Natural);\n+   --  Resize string W to have a length Len\n \n    type Key_Type is record\n       Edge : Edge_Id;\n@@ -130,8 +131,12 @@ package body GNAT.Perfect_Hash_Generators is\n \n    package WT is new GNAT.Table (Word_Type, Word_Id, 0, 32, 32);\n    package IT is new GNAT.Table (Integer, Integer, 0, 32, 32);\n-   --  The two main tables. IT is used to store several tables of components\n-   --  containing only integers.\n+   --  The two main tables. WT is used to store the words in their initial\n+   --  version and in their reduced version (that is words reduced to\n+   --  their significant characters). As an instance of GNAT.Table, WT does\n+   --  not initialize string pointers to null. This initialization has to be\n+   --  done manually when the table is allocated. IT is used to store several\n+   --  tables of components containing only integers.\n \n    function Image (Int : Integer; W : Natural := 0) return String;\n    function Image (Str : String;  W : Natural := 0) return String;\n@@ -298,9 +303,6 @@ package body GNAT.Perfect_Hash_Generators is\n    function Allocate (N : Natural; S : Natural := 1) return Table_Id;\n    --  Allocate N * S ints from IT table\n \n-   procedure Free_Tmp_Tables;\n-   --  Deallocate the tables used by the algorithm (but not the keys table)\n-\n    ----------\n    -- Keys --\n    ----------\n@@ -408,7 +410,7 @@ package body GNAT.Perfect_Hash_Generators is\n    --  Optimization mode (memory vs CPU)\n \n    Max_Key_Len : Natural := 0;\n-   Min_Key_Len : Natural := Max_Word_Length;\n+   Min_Key_Len : Natural := 0;\n    --  Maximum and minimum of all the word length\n \n    S : Natural;\n@@ -530,26 +532,27 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Apply_Position_Selection is\n    begin\n-      WT.Set_Last (2 * NK);\n       for J in 0 .. NK - 1 loop\n          declare\n-            I_Word : constant Word_Type := WT.Table (Initial (J));\n-            R_Word : Word_Type := Null_Word;\n-            Index  : Natural   := I_Word'First - 1;\n+            IW : constant String := WT.Table (Initial (J)).all;\n+            RW : String (1 .. IW'Length) := (others => ASCII.NUL);\n+            N  : Natural := IW'First - 1;\n \n          begin\n             --  Select the characters of Word included in the position\n             --  selection.\n \n             for C in 0 .. Char_Pos_Set_Len - 1 loop\n-               exit when I_Word (Get_Char_Pos (C)) = ASCII.NUL;\n-               Index := Index + 1;\n-               R_Word (Index) := I_Word (Get_Char_Pos (C));\n+               exit when IW (Get_Char_Pos (C)) = ASCII.NUL;\n+               N := N + 1;\n+               RW (N) := IW (Get_Char_Pos (C));\n             end loop;\n \n-            --  Build the new table with the reduced word\n+            --  Build the new table with the reduced word. Be careful\n+            --  to deallocate the old version to avoid memory leaks.\n \n-            WT.Table (Reduced (J)) := R_Word;\n+            Free_Word (WT.Table (Reduced (J)));\n+            WT.Table (Reduced (J)) := New_Word (RW);\n             Set_Key (J, (Edge => No_Edge));\n          end;\n       end loop;\n@@ -588,7 +591,7 @@ package body GNAT.Perfect_Hash_Generators is\n    --  Start of processing for Assign_Values_To_Vertices\n \n    begin\n-      --  Value -1 denotes an uninitialized value as it is supposed to\n+      --  Value -1 denotes an unitialized value as it is supposed to\n       --  be in the range 0 .. NK.\n \n       if G = No_Table then\n@@ -628,9 +631,9 @@ package body GNAT.Perfect_Hash_Generators is\n       Success : Boolean := False;\n \n    begin\n-      NV := Natural (K2V * Float (NK));\n-\n-      Keys := Allocate (NK);\n+      if NK = 0 then\n+         raise Program_Error with \"keywords set cannot be empty\";\n+      end if;\n \n       if Verbose then\n          Put_Initial_Keys (Output, \"Initial Key Table\");\n@@ -861,23 +864,16 @@ package body GNAT.Perfect_Hash_Generators is\n \n    procedure Finalize is\n    begin\n-      Free_Tmp_Tables;\n+      --  Deallocate all the WT components (both initial and reduced\n+      --  ones) to avoid memory leaks.\n \n+      for W in 0 .. WT.Last loop\n+         Free_Word (WT.Table (W));\n+      end loop;\n       WT.Release;\n       IT.Release;\n \n-      NK := 0;\n-      Max_Key_Len := 0;\n-      Min_Key_Len := Max_Word_Length;\n-   end Finalize;\n-\n-   ---------------------\n-   -- Free_Tmp_Tables --\n-   ---------------------\n-\n-   procedure Free_Tmp_Tables is\n-   begin\n-      IT.Init;\n+      --  Reset all variables for next usage\n \n       Keys := No_Table;\n \n@@ -901,7 +897,22 @@ package body GNAT.Perfect_Hash_Generators is\n \n       Vertices := No_Table;\n       NV       := 0;\n-   end Free_Tmp_Tables;\n+\n+      NK := 0;\n+      Max_Key_Len := 0;\n+      Min_Key_Len := 0;\n+   end Finalize;\n+\n+   ---------------\n+   -- Free_Word --\n+   ---------------\n+\n+   procedure Free_Word (W : in out Word_Type) is\n+   begin\n+      if W /= null then\n+         Free (W);\n+      end if;\n+   end Free_Word;\n \n    ----------------------------\n    -- Generate_Mapping_Table --\n@@ -1130,49 +1141,95 @@ package body GNAT.Perfect_Hash_Generators is\n       Tries  : Positive     := Default_Tries)\n    is\n    begin\n-      --  Free previous tables (the settings may have changed between two runs)\n+      --  Deallocated the part of the table concerning the reduced\n+      --  words. Initial words are already present in the table. We\n+      --  may have reduced words already there because a previous\n+      --  computation failed. We are currently retrying and the\n+      --  reduced words have to be deallocated.\n+\n+      for W in NK .. WT.Last loop\n+         Free_Word (WT.Table (W));\n+      end loop;\n+      IT.Init;\n \n-      Free_Tmp_Tables;\n+      --  Initialize of computation variables\n \n-      if K_To_V <= 2.0 then\n-         Put (Output, \"K to V ratio cannot be lower than 2.0\");\n-         New_Line (Output);\n-         raise Program_Error;\n-      end if;\n+      Keys := No_Table;\n+\n+      Char_Pos_Set     := No_Table;\n+      Char_Pos_Set_Len := 0;\n+\n+      Used_Char_Set     := No_Table;\n+      Used_Char_Set_Len := 0;\n+\n+      T1 := No_Table;\n+      T2 := No_Table;\n+\n+      T1_Len := 0;\n+      T2_Len := 0;\n+\n+      G     := No_Table;\n+      G_Len := 0;\n+\n+      Edges     := No_Table;\n+      Edges_Len := 0;\n+\n+      Vertices := No_Table;\n+      NV       := 0;\n \n       S    := Seed;\n       K2V  := K_To_V;\n       Opt  := Optim;\n       NT   := Tries;\n+\n+      if K2V <= 2.0 then\n+         raise Program_Error with \"K to V ratio cannot be lower than 2.0\";\n+      end if;\n+\n+      --  Do not accept a value of K2V too close to 2.0 such that once\n+      --  rounded up, NV = 2 * NK because the algorithm would not converge.\n+\n+      NV := Natural (Float (NK) * K2V);\n+      if NV <= 2 * NK then\n+         NV := 2 * NK + 1;\n+      end if;\n+\n+      Keys := Allocate (NK);\n+\n+      --  Resize initial words to have all of them at the same size\n+      --  (so the size of the largest one).\n+\n+      for K in 0 .. NK - 1 loop\n+         Resize_Word (WT.Table (Initial (K)), Max_Key_Len);\n+      end loop;\n+\n+      --  Allocated the table to store the reduced words. As WT is a\n+      --  GNAT.Table (using C memory management), pointers have to be\n+      --  explicitly initialized to null.\n+\n+      WT.Set_Last (Reduced (NK - 1));\n+      for W in 0 .. NK - 1 loop\n+         WT.Table (Reduced (W)) := null;\n+      end loop;\n    end Initialize;\n \n    ------------\n    -- Insert --\n    ------------\n \n    procedure Insert (Value : String) is\n-      Word : Word_Type := Null_Word;\n       Len  : constant Natural := Value'Length;\n \n    begin\n-      Word (1 .. Len) := Value (Value'First .. Value'First + Len - 1);\n       WT.Set_Last (NK);\n-      WT.Table (NK) := Word;\n+      WT.Table (NK) := New_Word (Value);\n       NK := NK + 1;\n-      NV := Natural (Float (NK) * K2V);\n-\n-      --  Do not accept a value of K2V too close to 2.0 such that once rounded\n-      --  up, NV = 2 * NK because the algorithm would not converge.\n-\n-      if NV <= 2 * NK then\n-         NV := 2 * NK + 1;\n-      end if;\n \n       if Max_Key_Len < Len then\n          Max_Key_Len := Len;\n       end if;\n \n-      if Len < Min_Key_Len then\n+      if Min_Key_Len = 0 or else Len < Min_Key_Len then\n          Min_Key_Len := Len;\n       end if;\n    end Insert;\n@@ -1188,6 +1245,15 @@ package body GNAT.Perfect_Hash_Generators is\n       end if;\n    end New_Line;\n \n+   --------------\n+   -- New_Word --\n+   --------------\n+\n+   function New_Word (S : String) return Word_Type is\n+   begin\n+      return new String'(S);\n+   end New_Word;\n+\n    ------------------------------\n    -- Parse_Position_Selection --\n    ------------------------------\n@@ -1761,7 +1827,7 @@ package body GNAT.Perfect_Hash_Generators is\n          K := Get_Key (J);\n          Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n          Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Initial (J)), F1, L1, J, 1, 3, 3);\n+         Put (File, WT.Table (Initial (J)).all, F1, L1, J, 1, 3, 3);\n       end loop;\n    end Put_Initial_Keys;\n \n@@ -1842,7 +1908,7 @@ package body GNAT.Perfect_Hash_Generators is\n          K := Get_Key (J);\n          Put (File, Image (J, M),           F1, L1, J, 1, 3, 1);\n          Put (File, Image (K.Edge, M),      F1, L1, J, 1, 3, 2);\n-         Put (File, WT.Table (Reduced (J)), F1, L1, J, 1, 3, 3);\n+         Put (File, WT.Table (Reduced (J)).all, F1, L1, J, 1, 3, 3);\n       end loop;\n    end Put_Reduced_Keys;\n \n@@ -1920,6 +1986,22 @@ package body GNAT.Perfect_Hash_Generators is\n       return K + NK + 1;\n    end Reduced;\n \n+   -----------------\n+   -- Resize_Word --\n+   -----------------\n+\n+   procedure Resize_Word (W : in out Word_Type; Len : Natural) is\n+      S1 : constant String := W.all;\n+      S2 : String (1 .. Len) := (others => ASCII.NUL);\n+      L  : constant Natural := S1'Length;\n+   begin\n+      if L /= Len then\n+         Free_Word (W);\n+         S2 (1 .. L) := S1;\n+         W := New_Word (S2);\n+      end if;\n+   end Resize_Word;\n+\n    --------------------------\n    -- Select_Char_Position --\n    --------------------------\n@@ -1985,11 +2067,11 @@ package body GNAT.Perfect_Hash_Generators is\n \n          begin\n             if L = 0 then\n-               Left  := Reduced (0) - 1;\n+               Left  := NK;\n                Right := Offset + R;\n             elsif R = 0 then\n                Left  := Offset + L;\n-               Right := Reduced (0) - 1;\n+               Right := NK;\n             else\n                Left  := Offset + L;\n                Right := Offset + R;\n@@ -2007,17 +2089,18 @@ package body GNAT.Perfect_Hash_Generators is\n \n          begin\n             if From = 0 then\n-               Source := Reduced (0) - 1;\n+               Source := NK;\n                Target := Offset + To;\n             elsif To = 0 then\n                Source := Offset + From;\n-               Target := Reduced (0) - 1;\n+               Target := NK;\n             else\n                Source := Offset + From;\n                Target := Offset + To;\n             end if;\n \n             WT.Table (Target) := WT.Table (Source);\n+            WT.Table (Source) := null;\n          end Move;\n \n          package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n@@ -2120,9 +2203,8 @@ package body GNAT.Perfect_Hash_Generators is\n    begin\n       --  Initialize the reduced words set\n \n-      WT.Set_Last (2 * NK);\n       for K in 0 .. NK - 1 loop\n-         WT.Table (Reduced (K)) := WT.Table (Initial (K));\n+         WT.Table (Reduced (K)) := New_Word (WT.Table (Initial (K)).all);\n       end loop;\n \n       declare\n@@ -2220,7 +2302,7 @@ package body GNAT.Perfect_Hash_Generators is\n                     Same_Keys_Sets_Table (J).First ..\n                     Same_Keys_Sets_Table (J).Last\n                   loop\n-                     Put (Output, WT.Table (Reduced (K)));\n+                     Put (Output, WT.Table (Reduced (K)).all);\n                      New_Line (Output);\n                   end loop;\n                   Put (Output, \"--\");"}, {"sha": "277a2a4580bf8cb752fc049f7de9784da56805a4", "filename": "gcc/ada/g-pehage.ads", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db18b0f50ba5b0facae835217a92961b2c765aaa/gcc%2Fada%2Fg-pehage.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db18b0f50ba5b0facae835217a92961b2c765aaa/gcc%2Fada%2Fg-pehage.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-pehage.ads?ref=db18b0f50ba5b0facae835217a92961b2c765aaa", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2005, AdaCore                     --\n+--                     Copyright (C) 2002-2008, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,7 +60,7 @@\n --    The hash table size corresponds to the exact size of W and *no larger*.\n --    This represents the \"minimal\" property.\n \n---  The functions generated by this package require the key set to be known in\n+--  The functions generated by this package require the words to be known in\n --  advance (they are \"static\" hash functions). The hash functions are also\n --  order preserving. If w2 is inserted after w1 in the generator, then (w1)\n --  < f (w2). These hashing functions are convenient for use with realtime\n@@ -99,27 +99,33 @@ package GNAT.Perfect_Hash_Generators is\n       K_To_V : Float        := Default_K_To_V;\n       Optim  : Optimization := CPU_Time;\n       Tries  : Positive     := Default_Tries);\n-   --  Initialize the generator and its internal structures. Set the ratio of\n-   --  vertices over keys in the random graphs. This value has to be greater\n-   --  than 2.0 in order for the algorithm to succeed. The key set is not\n-   --  modified (in particular when it is already set). For instance, it is\n-   --  possible to run several times the generator with different settings on\n-   --  the same key set.\n+   --  Initialize the generator and its internal structures. Set the\n+   --  ratio of vertices over keys in the random graphs. This value\n+   --  has to be greater than 2.0 in order for the algorithm to\n+   --  succeed. The word set is not modified (in particular when it is\n+   --  already set). For instance, it is possible to run several times\n+   --  the generator with different settings on the same words.\n+\n+   --  A classical way of doing is to Insert all the words and then to\n+   --  invoke Initialize and Compute. If Compute fails to find a\n+   --  perfect hash function, invoke Initialize another time with\n+   --  other configuration parameters (probably with a greater K_To_V\n+   --  ratio). Once successful, invoke Produce and Finalize.\n \n    procedure Finalize;\n-   --  Deallocate the internal structures and the key table\n+   --  Deallocate the internal structures and the words table\n \n    procedure Insert (Value : String);\n-   --  Insert a new key in the table\n+   --  Insert a new word in the table\n \n    Too_Many_Tries : exception;\n    --  Raised after Tries unsuccessful runs\n \n    procedure Compute (Position : String := Default_Position);\n    --  Compute the hash function. Position allows to define selection of\n-   --  character positions used in the keywords hash function. Positions can be\n+   --  character positions used in the word hash function. Positions can be\n    --  separated by commas and range like x-y may be used. Character '$'\n-   --  represents the final character of a key. With an empty position, the\n+   --  represents the final character of a word. With an empty position, the\n    --  generator automatically produces positions to reduce the memory usage.\n    --  Raise Too_Many_Tries in case that the algorithm does not succeed in less\n    --  than Tries attempts (see Initialize).\n@@ -144,15 +150,15 @@ package GNAT.Perfect_Hash_Generators is\n    --  F1 and F2 are two functions based on two function tables T1 and T2.\n    --  Their definition depends on the chosen optimization mode.\n \n-   --  Only some character positions are used in the keys because they are\n+   --  Only some character positions are used in the words because they are\n    --  significant. They are listed in a character position table (P in the\n    --  pseudo-code below). For instance, in {\"jan\", \"feb\", \"mar\", \"apr\", \"jun\",\n    --  \"jul\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\"}, only positions 2 and 3 are\n    --  significant (the first character can be ignored). In this example, P =\n    --  {2, 3}\n \n    --  When Optimization is CPU_Time, the first dimension of T1 and T2\n-   --  corresponds to the character position in the key and the second to the\n+   --  corresponds to the character position in the word and the second to the\n    --  character set. As all the character set is not used, we define a used\n    --  character table which associates a distinct index to each used character\n    --  (unused characters are mapped to zero). In this case, the second\n@@ -177,7 +183,7 @@ package GNAT.Perfect_Hash_Generators is\n    --    end Hash;\n \n    --  When Optimization is Memory_Space, the first dimension of T1 and T2\n-   --  corresponds to the character position in the key and the second\n+   --  corresponds to the character position in the word and the second\n    --  dimension is ignored. T1 and T2 are no longer matrices but vectors.\n    --  Therefore, the used character table is not available. The hash function\n    --  has the following form:"}]}