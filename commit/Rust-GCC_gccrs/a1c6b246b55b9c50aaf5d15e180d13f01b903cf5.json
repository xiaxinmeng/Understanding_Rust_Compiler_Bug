{"sha": "a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjNmIyNDZiNTViOWM1MGFhZjVkMTVlMTgwZDEzZjAxYjkwM2NmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-24T17:46:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-24T17:46:39Z"}, "message": "mips.h (MOVE_MAX): Use UNITS_PER_WORD and describe MIPS-specific implementation details.\n\ngcc/\n\t* config/mips/mips.h (MOVE_MAX): Use UNITS_PER_WORD and describe\n\tMIPS-specific implementation details.\n\t(MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER): New macro.\n\t(MIPS_MAX_MOVE_BYTES_STRAIGHT): Likewise.\n\t(MOVE_RATIO): Define to MIPS_MAX_MOVE_BYTES_STRAIGHT / UNITS_PER_WORD\n\tfor targets with movmemsi.\n\t(MOVE_BY_PIECES_P): Define.\n\t* config/mips/mips.c (MAX_MOVE_REGS, MAX_MOVE_BYTES): Delete.\n\t(mips_block_move_loop): Add a bytes_per_iter argument.\n\t(mips_expand_block_move): Use MIPS_MAX_MOVE_BYTES_STRAIGHT.\n\tUpdate call to mips_block_move_loop.\n\nFrom-SVN: r129605", "tree": {"sha": "a8ba7bae7f0a9ef3a148c5177da7c152b6e2e57c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8ba7bae7f0a9ef3a148c5177da7c152b6e2e57c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/comments", "author": null, "committer": null, "parents": [{"sha": "32e520abfcfb27d1d0949b1fe8fc8217678ecea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e520abfcfb27d1d0949b1fe8fc8217678ecea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e520abfcfb27d1d0949b1fe8fc8217678ecea3"}], "stats": {"total": 112, "additions": 77, "deletions": 35}, "files": [{"sha": "6522ce36cc9c93c846a1ef0aabd94ae11a3df8fd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "patch": "@@ -1,3 +1,17 @@\n+2007-10-24  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.h (MOVE_MAX): Use UNITS_PER_WORD and describe\n+\tMIPS-specific implementation details.\n+\t(MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER): New macro.\n+\t(MIPS_MAX_MOVE_BYTES_STRAIGHT): Likewise.\n+\t(MOVE_RATIO): Define to MIPS_MAX_MOVE_BYTES_STRAIGHT / UNITS_PER_WORD\n+\tfor targets with movmemsi.\n+\t(MOVE_BY_PIECES_P): Define.\n+\t* config/mips/mips.c (MAX_MOVE_REGS, MAX_MOVE_BYTES): Delete.\n+\t(mips_block_move_loop): Add a bytes_per_iter argument.\n+\t(mips_expand_block_move): Use MIPS_MAX_MOVE_BYTES_STRAIGHT.\n+\tUpdate call to mips_block_move_loop.\n+\n 2007-10-24  Michael Matz  <matz@suse.de>\n \n \tPR debug/33868"}, {"sha": "19fbbd40577eaeeac43702e63d43eabc26361aa4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "patch": "@@ -5622,9 +5622,6 @@ mips_expand_fcc_reload (rtx dest, rtx src, rtx scratch)\n   emit_insn (gen_slt_sf (dest, fp2, fp1));\n }\n \f\n-#define MAX_MOVE_REGS 4\n-#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)\n-\n /* Emit straight-line code to move LENGTH bytes from SRC to DEST.\n    Assume that the areas do not overlap.  */\n \n@@ -5710,22 +5707,23 @@ mips_adjust_block_mem (rtx mem, HOST_WIDE_INT length,\n   set_mem_align (*loop_mem, MIN (MEM_ALIGN (mem), length * BITS_PER_UNIT));\n }\n \n-/* Move LENGTH bytes from SRC to DEST using a loop that moves MAX_MOVE_BYTES\n-   per iteration.  LENGTH must be at least MAX_MOVE_BYTES.  Assume that the\n-   memory regions do not overlap.  */\n+/* Move LENGTH bytes from SRC to DEST using a loop that moves BYTES_PER_ITER\n+   bytes at a time.  LENGTH must be at least BYTES_PER_ITER.  Assume that\n+   the memory regions do not overlap.  */\n \n static void\n-mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n+mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length,\n+\t\t      HOST_WIDE_INT bytes_per_iter)\n {\n   rtx label, src_reg, dest_reg, final_src;\n   HOST_WIDE_INT leftover;\n \n-  leftover = length % MAX_MOVE_BYTES;\n+  leftover = length % bytes_per_iter;\n   length -= leftover;\n \n   /* Create registers and memory references for use within the loop.  */\n-  mips_adjust_block_mem (src, MAX_MOVE_BYTES, &src_reg, &src);\n-  mips_adjust_block_mem (dest, MAX_MOVE_BYTES, &dest_reg, &dest);\n+  mips_adjust_block_mem (src, bytes_per_iter, &src_reg, &src);\n+  mips_adjust_block_mem (dest, bytes_per_iter, &dest_reg, &dest);\n \n   /* Calculate the value that SRC_REG should have after the last iteration\n      of the loop.  */\n@@ -5737,11 +5735,11 @@ mips_block_move_loop (rtx dest, rtx src, HOST_WIDE_INT length)\n   emit_label (label);\n \n   /* Emit the loop body.  */\n-  mips_block_move_straight (dest, src, MAX_MOVE_BYTES);\n+  mips_block_move_straight (dest, src, bytes_per_iter);\n \n   /* Move on to the next block.  */\n-  mips_emit_move (src_reg, plus_constant (src_reg, MAX_MOVE_BYTES));\n-  mips_emit_move (dest_reg, plus_constant (dest_reg, MAX_MOVE_BYTES));\n+  mips_emit_move (src_reg, plus_constant (src_reg, bytes_per_iter));\n+  mips_emit_move (dest_reg, plus_constant (dest_reg, bytes_per_iter));\n \n   /* Emit the loop condition.  */\n   if (Pmode == DImode)\n@@ -5763,14 +5761,15 @@ mips_expand_block_move (rtx dest, rtx src, rtx length)\n {\n   if (GET_CODE (length) == CONST_INT)\n     {\n-      if (INTVAL (length) <= 2 * MAX_MOVE_BYTES)\n+      if (INTVAL (length) <= MIPS_MAX_MOVE_BYTES_STRAIGHT)\n \t{\n \t  mips_block_move_straight (dest, src, INTVAL (length));\n \t  return true;\n \t}\n       else if (optimize)\n \t{\n-\t  mips_block_move_loop (dest, src, INTVAL (length));\n+\t  mips_block_move_loop (dest, src, INTVAL (length),\n+\t\t\t\tMIPS_MAX_MOVE_BYTES_PER_LOOP_ITER);\n \t  return true;\n \t}\n     }"}, {"sha": "b4778a8577d66789293f34ee939a659b041e407e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6b246b55b9c50aaf5d15e180d13f01b903cf5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a1c6b246b55b9c50aaf5d15e180d13f01b903cf5", "patch": "@@ -2338,9 +2338,10 @@ typedef struct mips_args {\n #define DEFAULT_SIGNED_CHAR 1\n #endif\n \n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX (TARGET_64BIT ? 8 : 4)\n+/* Although LDC1 and SDC1 provide 64-bit moves on 32-bit targets,\n+   we generally don't want to use them for copying arbitrary data.\n+   A single N-word move is usually the same cost as N single-word moves.  */\n+#define MOVE_MAX UNITS_PER_WORD\n #define MAX_MOVE_MAX 8\n \n /* Define this macro as a C expression which is nonzero if\n@@ -2769,6 +2770,18 @@ while (0)\n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE (POINTER_SIZE == 64 ? \"long int\" : \"int\")\n \n+/* The maximum number of bytes that can be copied by one iteration of\n+   a movmemsi loop; see mips_block_move_loop.  */\n+#define MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER \\\n+  (UNITS_PER_WORD * 4)\n+\n+/* The maximum number of bytes that can be copied by a straight-line\n+   implementation of movmemsi; see mips_block_move_straight.  We want\n+   to make sure that any loop-based implementation will iterate at\n+   least twice.  */\n+#define MIPS_MAX_MOVE_BYTES_STRAIGHT \\\n+  (MIPS_MAX_MOVE_BYTES_PER_LOOP_ITER * 2)\n+\n /* The base cost of a memcpy call, for MOVE_RATIO and friends.  These\n    values were determined experimentally by benchmarking with CSiBE.\n    In theory, the call overhead is higher for TARGET_ABICALLS (especially\n@@ -2778,23 +2791,39 @@ while (0)\n \n #define MIPS_CALL_RATIO 8\n \n-/* Define MOVE_RATIO to encourage use of movmemsi when enabled,\n-   since it should always generate code at least as good as\n-   move_by_pieces().  But when inline movmemsi pattern is disabled\n-   (i.e., with -mips16 or -mmemcpy), instead use a value approximating\n-   the length of a memcpy call sequence, so that move_by_pieces will\n-   generate inline code if it is shorter than a function call.\n-   Since move_by_pieces_ninsns() counts memory-to-memory moves, but\n-   we'll have to generate a load/store pair for each, halve the value of \n-   MIPS_CALL_RATIO to take that into account.\n-   The default value for MOVE_RATIO when HAVE_movmemsi is true is 2.\n-   There is no point to setting it to less than this to try to disable\n-   move_by_pieces entirely, because that also disables some desirable \n-   tree-level optimizations, specifically related to optimizing a\n-   one-byte string copy into a simple move byte operation.  */\n-\n-#define MOVE_RATIO \\\n-  ((TARGET_MIPS16 || TARGET_MEMCPY) ? MIPS_CALL_RATIO / 2 : 2)\n+/* Any loop-based implementation of movmemsi will have at least\n+   MIPS_MAX_MOVE_BYTES_STRAIGHT / UNITS_PER_WORD memory-to-memory\n+   moves, so allow individual copies of fewer elements.\n+\n+   When movmemsi is not available, use a value approximating\n+   the length of a memcpy call sequence, so that move_by_pieces\n+   will generate inline code if it is shorter than a function call.\n+   Since move_by_pieces_ninsns counts memory-to-memory moves, but\n+   we'll have to generate a load/store pair for each, halve the\n+   value of MIPS_CALL_RATIO to take that into account.  */\n+\n+#define MOVE_RATIO\t\t\t\t\t\\\n+  (HAVE_movmemsi\t\t\t\t\t\\\n+   ? MIPS_MAX_MOVE_BYTES_STRAIGHT / MOVE_MAX\t\t\\\n+   : MIPS_CALL_RATIO / 2)\n+\n+/* movmemsi is meant to generate code that is at least as good as\n+   move_by_pieces.  However, movmemsi effectively uses a by-pieces\n+   implementation both for moves smaller than a word and for word-aligned\n+   moves of no more than MIPS_MAX_MOVE_BYTES_STRAIGHT bytes.  We should\n+   allow the tree-level optimisers to do such moves by pieces, as it\n+   often exposes other optimization opportunities.  We might as well\n+   continue to use movmemsi at the rtl level though, as it produces\n+   better code when scheduling is disabled (such as at -O).  */\n+\n+#define MOVE_BY_PIECES_P(SIZE, ALIGN)\t\t\t\t\\\n+  (HAVE_movmemsi\t\t\t\t\t\t\\\n+   ? (!currently_expanding_to_rtl\t\t\t\t\\\n+      && ((ALIGN) < BITS_PER_WORD\t\t\t\t\\\n+\t  ? (SIZE) < UNITS_PER_WORD\t\t\t\t\\\n+\t  : (SIZE) <= MIPS_MAX_MOVE_BYTES_STRAIGHT))\t\t\\\n+   : (move_by_pieces_ninsns (SIZE, ALIGN, MOVE_MAX_PIECES + 1)\t\\\n+      < (unsigned int) MOVE_RATIO))\n \n /* For CLEAR_RATIO, when optimizing for size, give a better estimate\n    of the length of a memset call, but use the default otherwise.  */"}]}