{"sha": "0e1c7fc777c69ec6b11e213ef5ba7143523f6c26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUxYzdmYzc3N2M2OWVjNmIxMWUyMTNlZjViYTcxNDM1MjNmNmMyNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-01T14:49:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-01T14:49:54Z"}, "message": "(make_range): Don't merge unsigned case with range containing upper bound;\n\ninstead merge just with zero and convert a range with no upper bound to\nopposite one with no lower bound.\n(merge_ranges): In (+,-) case, don't treat subset specially if the upper\nbounds are the same; fix typo in others case here.\n\nFrom-SVN: r13090", "tree": {"sha": "f868efe11411e435958741cb45f8f06e65047e16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f868efe11411e435958741cb45f8f06e65047e16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26/comments", "author": null, "committer": null, "parents": [{"sha": "3c00684e55149e43d4daa3a702668803fa6c8e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c00684e55149e43d4daa3a702668803fa6c8e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c00684e55149e43d4daa3a702668803fa6c8e15"}], "stats": {"total": 39, "additions": 24, "deletions": 15}, "files": [{"sha": "dabcf29b012292b2f19b21d00267f37703701aed", "filename": "gcc/fold-const.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1c7fc777c69ec6b11e213ef5ba7143523f6c26/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0e1c7fc777c69ec6b11e213ef5ba7143523f6c26", "patch": "@@ -2763,22 +2763,27 @@ make_range (exp, pin_p, plow, phigh)\n \t  exp = arg0;\n \n \t  /* If this is an unsigned comparison, we also know that EXP is\n-\t     greater than or equal to zero and less than the maximum value of\n-\t     the unsigned type.  We base the range tests we make on that fact,\n-\t     so we record it here so we can parse existing range tests.  */\n+\t     greater than or equal to zero.  We base the range tests we make\n+\t     on that fact, so we record it here so we can parse existing\n+\t     range tests.  */\n \t  if (TREE_UNSIGNED (type) && (low == 0 || high == 0))\n \t    {\n \t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n \t\t\t\t  1, convert (type, integer_zero_node),\n-\t\t\t\t  const_binop (MINUS_EXPR,\n-\t\t\t\t\t       convert (type,\n-\t\t\t\t\t\t\tinteger_zero_node),\n-\t\t\t\t\t       convert (type,\n-\t\t\t\t\t\t\tinteger_one_node),\n-\t\t\t\t\t       0)))\n+\t\t\t\t  NULL_TREE))\n \t\tbreak;\n \n \t      in_p = n_in_p, low = n_low, high = n_high;\n+\n+\t      /* If the high bound is missing, reverse the range so it\n+\t\t goes from zero to the low bound minus 1.  */\n+\t      if (high == 0)\n+\t\t{\n+\t\t  in_p = ! in_p;\n+\t\t  high = range_binop (MINUS_EXPR, NULL_TREE, low, 0,\n+\t\t\t\t      integer_one_node, 0);\n+\t\t  low = convert (type, integer_zero_node);\n+\t\t}\n \t    }\n \t  continue;\n \n@@ -2819,9 +2824,9 @@ make_range (exp, pin_p, plow, phigh)\n \t  if (n_low && n_high && tree_int_cst_lt (n_high, n_low))\n \t    {\n \t      low = range_binop (PLUS_EXPR, type, n_high, 0,\n-\t\t\t\t convert (type, integer_one_node), 0);\n+\t\t\t\t integer_one_node, 0);\n \t      high = range_binop (MINUS_EXPR, type, n_low, 0,\n-\t\t\t\t convert (type, integer_one_node), 0);\n+\t\t\t\t integer_one_node, 0);\n \t      in_p = ! in_p;\n \t    }\n \t  else\n@@ -2960,17 +2965,21 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n     {\n       /* If they don't overlap, the result is the first range.  If the\n \t second range is a subset of the first, we can't describe this as\n-\t a single range.  Otherwise, we go from the start of the first\n-\t range to just before the start of the second.  */\n+\t a single range unless both ranges end at the same place, in which\n+\t case we can ignore the fact that it's a subset.  Otherwise, we go\n+\t from the start of the first range to just before the start of the\n+\t second.  */\n       if (no_overlap)\n \tin_p = 1, low = low0, high = high0;\n-      else if (subset)\n+      else if (subset\n+\t       && integer_zerop (range_binop (EQ_EXPR, integer_type_node,\n+\t\t\t\t\t      high0, 1, high1, 0)))\n \treturn 0;\n       else\n \t{\n \t  in_p = 1, low = low0;\n \t  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,\n-\t\t\t      integer_zero_node, 0);\n+\t\t\t      integer_one_node, 0);\n \t}\n     }\n "}]}