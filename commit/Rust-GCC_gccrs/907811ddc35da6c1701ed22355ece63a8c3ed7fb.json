{"sha": "907811ddc35da6c1701ed22355ece63a8c3ed7fb", "node_id": "C_kwDOANBUbNoAKDkwNzgxMWRkYzM1ZGE2YzE3MDFlZDIyMzU1ZWNlNjNhOGMzZWQ3ZmI", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-03-13T21:22:55Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-03-19T20:16:37Z"}, "message": "fortran: Separate associate character lengths earlier [PR104570]\n\nThis change workarounds an ICE in the evaluation of the character length\nof an array expression referencing an associate variable; the code is\nnot prepared to see a non-scalar expression as it doesn\u2019t initialize the\nscalarizer.\n\nBefore this change, associate length symbols get a new gfc_charlen at\nresolution stage to unshare them from the associate expression, so that\nat translation stage it is a decl specific to the associate symbol that\nis initialized, not the decl of some other symbol.  This\nreinitialization of gfc_charlen happens after expressions referencing\nthe associate symbol have been parsed, so that those expressions retain\nthe original gfc_charlen they have copied from the symbol.\nAt translation stage, the gfc_charlen for the associate symbol is setup\nwith the decl holding the actual length value, but the expressions have\nretained the original gfc_charlen without any decl.  So they need to\nevaluate the character length, and this is where the ICE happens.\n\nThis change moves the reinitialization of gfc_charlen earlier at parsing\nstage, so that at resolution stage the gfc_charlen can be retained as\nit\u2019s already not shared with any other symbol, and the expressions which\nnow share their gfc_charlen with the symbol are automatically updated\nwhen the length decl is setup at translation stage.  There is no need\nany more to evaluate the character length as it has all the required\ninformation, and the ICE doesn\u2019t happen.\n\nThe first resolve.cc hunk is necessary to avoid regressing on the\nassociate_35.f90 testcase.\n\n\tPR fortran/104228\n\tPR fortran/104570\n\ngcc/fortran/ChangeLog:\n\n\t* parse.cc (parse_associate): Use a new distinct gfc_charlen if the\n\tcopied type has one whose length is not known to be constant.\n\t* resolve.cc (resolve_assoc_var): Reset charlen if it\u2019s shared with\n\tthe associate target regardless of the expression type.\n\tDon\u2019t reinitialize charlen if it\u2019s deferred.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/associate_58.f90: New test.", "tree": {"sha": "736d74938df30dbec55de8417f2fb677d833159a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/736d74938df30dbec55de8417f2fb677d833159a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/907811ddc35da6c1701ed22355ece63a8c3ed7fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907811ddc35da6c1701ed22355ece63a8c3ed7fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/907811ddc35da6c1701ed22355ece63a8c3ed7fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907811ddc35da6c1701ed22355ece63a8c3ed7fb/comments", "author": null, "committer": null, "parents": [{"sha": "638e630142b2cf691db890ab9eb6d77a65339c54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638e630142b2cf691db890ab9eb6d77a65339c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638e630142b2cf691db890ab9eb6d77a65339c54"}], "stats": {"total": 48, "additions": 45, "deletions": 3}, "files": [{"sha": "e6e915d2a5e5afb4030ad4f6bdcdde3ecf47d0ea", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=907811ddc35da6c1701ed22355ece63a8c3ed7fb", "patch": "@@ -4924,6 +4924,24 @@ parse_associate (void)\n \t in case of association to a derived-type.  */\n       sym->ts = a->target->ts;\n \n+      /* Don\u2019t share the character length information between associate\n+\t variable and target if the length is not a compile-time constant,\n+\t as we don\u2019t want to touch some other character length variable when\n+\t we try to initialize the associate variable\u2019s character length\n+\t variable.\n+\t We do it here rather than later so that expressions referencing the\n+\t associate variable will automatically have the correctly setup length\n+\t information.  If we did it at resolution stage the expressions would\n+\t use the original length information, and the variable a new different\n+\t one, but only the latter one would be correctly initialized at\n+\t translation stage, and the former one would need some additional setup\n+\t there.  */\n+      if (sym->ts.type == BT_CHARACTER\n+\t  && sym->ts.u.cl\n+\t  && !(sym->ts.u.cl->length\n+\t       && sym->ts.u.cl->length->expr_type == EXPR_CONSTANT))\n+\tsym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n+\n       /* Check if the target expression is array valued.  This cannot always\n \t be done by looking at target.rank, because that might not have been\n \t set yet.  Therefore traverse the chain of refs, looking for the last"}, {"sha": "5522be751992c76b79584b265187dc20ecfce075", "filename": "gcc/fortran/resolve.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ffortran%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ffortran%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.cc?ref=907811ddc35da6c1701ed22355ece63a8c3ed7fb", "patch": "@@ -9232,7 +9232,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       if (!sym->ts.u.cl)\n \tsym->ts.u.cl = target->ts.u.cl;\n \n-      if (sym->ts.deferred && target->expr_type == EXPR_VARIABLE\n+      if (sym->ts.deferred\n \t  && sym->ts.u.cl == target->ts.u.cl)\n \t{\n \t  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);\n@@ -9251,8 +9251,11 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n \t\t|| sym->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t\t&& target->expr_type != EXPR_VARIABLE)\n \t{\n-\t  sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);\n-\t  sym->ts.deferred = 1;\n+\t  if (!sym->ts.deferred)\n+\t    {\n+\t      sym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);\n+\t      sym->ts.deferred = 1;\n+\t    }\n \n \t  /* This is reset in trans-stmt.cc after the assignment\n \t     of the target expression to the associate name.  */"}, {"sha": "9c24f35c0d836882b4a8254924ea86b36175b36a", "filename": "gcc/testsuite/gfortran.dg/associate_58.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_58.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/907811ddc35da6c1701ed22355ece63a8c3ed7fb/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_58.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_58.f90?ref=907811ddc35da6c1701ed22355ece63a8c3ed7fb", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+!\n+! PR fortran/104570\n+! The following used to cause an ICE because the string length\n+! evaluation of the (y) expression was not prepared to handle\n+! a non-scalar expression.\n+\n+program p\n+   character(:), allocatable :: x(:)\n+   x = ['abc']\n+   call s\n+contains\n+   subroutine s\n+      associate (y => x)\n+         associate (z => (y))\n+            print *, z\n+         end associate\n+      end associate\n+   end\n+end\n+"}]}