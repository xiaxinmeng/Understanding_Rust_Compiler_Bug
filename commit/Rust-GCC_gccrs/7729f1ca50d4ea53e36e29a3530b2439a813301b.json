{"sha": "7729f1ca50d4ea53e36e29a3530b2439a813301b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcyOWYxY2E1MGQ0ZWE1M2UzNmUyOWEzNTMwYjI0MzlhODEzMzAxYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-16T06:48:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-06-16T06:48:10Z"}, "message": "(ltoe, ultoe, eifrac, euifrac): Handle 64-bit longs.\n\n(SFMODE_NAN, DFMODE_NAN, XFMODE_NAN, TFMODE_NAN): New macros\npermit definitions of NaN patterns to be overridden in tm.h.\n\nFrom-SVN: r4680", "tree": {"sha": "e0d3cb090f4896e311a5fb155fe6e00ca3750bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d3cb090f4896e311a5fb155fe6e00ca3750bf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7729f1ca50d4ea53e36e29a3530b2439a813301b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7729f1ca50d4ea53e36e29a3530b2439a813301b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7729f1ca50d4ea53e36e29a3530b2439a813301b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7729f1ca50d4ea53e36e29a3530b2439a813301b/comments", "author": null, "committer": null, "parents": [{"sha": "ffcf63937c553a446e3aaa316094f2dbc32e9b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffcf63937c553a446e3aaa316094f2dbc32e9b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffcf63937c553a446e3aaa316094f2dbc32e9b54"}], "stats": {"total": 158, "additions": 88, "deletions": 70}, "files": [{"sha": "1e4a4fae5c8bd58dd3ec44e73a9f4e20918a0dcd", "filename": "gcc/real.c", "status": "modified", "additions": 88, "deletions": 70, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7729f1ca50d4ea53e36e29a3530b2439a813301b/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7729f1ca50d4ea53e36e29a3530b2439a813301b/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=7729f1ca50d4ea53e36e29a3530b2439a813301b", "patch": "@@ -3297,10 +3297,18 @@ ltoe (lp, y)\n       ll = (unsigned long) (*lp);\n     }\n   /* move the long integer to yi significand area */\n+#if HOST_BITS_PER_LONG == 64\n+  yi[M] = (unsigned EMUSHORT) (ll >> 48);\n+  yi[M + 1] = (unsigned EMUSHORT) (ll >> 32);\n+  yi[M + 2] = (unsigned EMUSHORT) (ll >> 16);\n+  yi[M + 3] = (unsigned EMUSHORT) ll;\n+  yi[E] = EXONE + 47;\t\t/* exponent if normalize shift count were 0 */\n+#else\n   yi[M] = (unsigned EMUSHORT) (ll >> 16);\n   yi[M + 1] = (unsigned EMUSHORT) ll;\n-\n   yi[E] = EXONE + 15;\t\t/* exponent if normalize shift count were 0 */\n+#endif\n+\n   if ((k = enormlz (yi)) > NBITS)/* normalize the significand */\n     ecleaz (yi);\t\t/* it was zero */\n   else\n@@ -3329,10 +3337,18 @@ ultoe (lp, y)\n   ll = *lp;\n \n   /* move the long integer to ayi significand area */\n+#if HOST_BITS_PER_LONG == 64\n+  yi[M] = (unsigned EMUSHORT) (ll >> 48);\n+  yi[M + 1] = (unsigned EMUSHORT) (ll >> 32);\n+  yi[M + 2] = (unsigned EMUSHORT) (ll >> 16);\n+  yi[M + 3] = (unsigned EMUSHORT) ll;\n+  yi[E] = EXONE + 47;\t\t/* exponent if normalize shift count were 0 */\n+#else\n   yi[M] = (unsigned EMUSHORT) (ll >> 16);\n   yi[M + 1] = (unsigned EMUSHORT) ll;\n-\n   yi[E] = EXONE + 15;\t\t/* exponent if normalize shift count were 0 */\n+#endif\n+\n   if ((k = enormlz (yi)) > NBITS)/* normalize the significand */\n     ecleaz (yi);\t\t/* it was zero */\n   else\n@@ -3358,7 +3374,8 @@ eifrac (x, i, frac)\n      unsigned EMUSHORT *frac;\n {\n   unsigned EMUSHORT xi[NI];\n-  int k;\n+  int j, k;\n+  unsigned long ll;\n \n   emovi (x, xi);\n   k = (int) xi[E] - (EXONE - 1);\n@@ -3371,44 +3388,42 @@ eifrac (x, i, frac)\n     }\n   if (k > (HOST_BITS_PER_LONG - 1))\n     {\n-      /*\n-\t ;\tlong integer overflow: output large integer\n-\t ;\tand correct fraction\n-\t */\n+      /* long integer overflow: output large integer\n+\t and correct fraction  */\n       if (xi[0])\n \t*i = ((unsigned long) 1) << (HOST_BITS_PER_LONG - 1);\n       else\n \t*i = (((unsigned long) 1) << (HOST_BITS_PER_LONG - 1)) - 1;\n       eshift (xi, k);\n       if (extra_warnings)\n \twarning (\"overflow on truncation to integer\");\n-      goto lab11;\n     }\n-\n-  if (k > 16)\n+  else if (k > 16)\n     {\n-      /*\n-\t ; shift more than 16 bits: shift up k-16, output the integer,\n-\t ; then complete the shift to get the fraction.\n-\t */\n-      k -= 16;\n+      /* Shift more than 16 bits: first shift up k-16 mod 16,\n+\t then shift up by 16's.  */\n+      j = k - ((k >> 4) << 4);\n+      eshift (xi, j);\n+      ll = xi[M];\n+      k -= j;\n+      do\n+\t{\n+\t  eshup6 (xi);\n+\t  ll = (ll << 16) | xi[M];\n+\t}\n+      while ((k -= 16) > 0);\n+      *i = ll;\n+      if (xi[0])\n+\t*i = -(*i);\n+    }\n+  else\n+    {\n+      /* shift not more than 16 bits */\n       eshift (xi, k);\n-\n-      *i = (long) (((unsigned long) xi[M] << 16) | xi[M + 1]);\n-      eshup6 (xi);\n-      goto lab10;\n+      *i = (long) xi[M] & 0xffff;\n+      if (xi[0])\n+\t*i = -(*i);\n     }\n-\n-  /* shift not more than 16 bits */\n-  eshift (xi, k);\n-  *i = (long) xi[M] & 0xffff;\n-\n- lab10:\n-\n-  if (xi[0])\n-    *i = -(*i);\n- lab11:\n-\n   xi[0] = 0;\n   xi[E] = EXONE - 1;\n   xi[M] = 0;\n@@ -3421,24 +3436,19 @@ eifrac (x, i, frac)\n }\n \n \n-/*\n-;\tFind unsigned long integer and fractional parts\n-\n-;\tunsigned long i;\n-;\tunsigned EMUSHORT x[NE], frac[NE];\n-;\txifrac (x, &i, frac);\n+/* Find unsigned long integer and fractional parts.\n+   A negative e type input yields integer output = 0\n+   but correct fraction.  */\n \n-  A negative e type input yields integer output = 0\n-  but correct fraction.\n-*/\n void \n euifrac (x, i, frac)\n      unsigned EMUSHORT *x;\n-     long *i;\n+     unsigned long *i;\n      unsigned EMUSHORT *frac;\n {\n+  unsigned long ll;\n   unsigned EMUSHORT xi[NI];\n-  int k;\n+  int j, k;\n \n   emovi (x, xi);\n   k = (int) xi[E] - (EXONE - 1);\n@@ -3449,42 +3459,42 @@ euifrac (x, i, frac)\n       emovo (xi, frac);\n       return;\n     }\n-  if (k > 32)\n+  if (k > HOST_BITS_PER_LONG)\n     {\n-      /*\n-\t ;\tlong integer overflow: output large integer\n-\t ;\tand correct fraction\n-\t */\n+      /* Long integer overflow: output large integer\n+\t and correct fraction.\n+\t Note, the BSD microvax compiler says that ~(0UL)\n+\t is a syntax error.  */\n       *i = ~(0L);\n       eshift (xi, k);\n       if (extra_warnings)\n \twarning (\"overflow on truncation to unsigned integer\");\n-      goto lab10;\n     }\n-\n-  if (k > 16)\n+  else if (k > 16)\n     {\n-      /*\n-\t ; shift more than 16 bits: shift up k-16, output the integer,\n-\t ; then complete the shift to get the fraction.\n-\t */\n-      k -= 16;\n+      /* Shift more than 16 bits: first shift up k-16 mod 16,\n+\t then shift up by 16's.  */\n+      j = k - ((k >> 4) << 4);\n+      eshift (xi, j);\n+      ll = xi[M];\n+      k -= j;\n+      do\n+\t{\n+\t  eshup6 (xi);\n+\t  ll = (ll << 16) | xi[M];\n+\t}\n+      while ((k -= 16) > 0);\n+      *i = ll;\n+    }\n+  else\n+    {\n+      /* shift not more than 16 bits */\n       eshift (xi, k);\n-\n-      *i = (long) (((unsigned long) xi[M] << 16) | xi[M + 1]);\n-      eshup6 (xi);\n-      goto lab10;\n+      *i = (long) xi[M] & 0xffff;\n     }\n \n-  /* shift not more than 16 bits */\n-  eshift (xi, k);\n-  *i = (long) xi[M] & 0xffff;\n-\n- lab10:\n-\n-  if (xi[0])\n+  if (xi[0])  /* A negative value yields unsigned integer 0. */\n     *i = 0L;\n-\n   xi[0] = 0;\n   xi[E] = EXONE - 1;\n   xi[M] = 0;\n@@ -4900,7 +4910,9 @@ todec (x, y)\n /* If special NaN bit patterns are required, define them in tm.h\n    as arrays of unsigned 16-bit shorts.  Otherwise, use the default\n    patterns here. */\n-#ifndef TFMODE_NAN\n+#ifdef TFMODE_NAN\n+TFMODE_NAN;\n+#else\n #ifdef MIEEE\n unsigned EMUSHORT TFnan[8] =\n  {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n@@ -4910,7 +4922,9 @@ unsigned EMUSHORT TFnan[8] = {0, 0, 0, 0, 0, 0, 0x8000, 0xffff};\n #endif\n #endif\n \n-#ifndef XFMODE_NAN\n+#ifdef XFMODE_NAN\n+XFMODE_NAN;\n+#else\n #ifdef MIEEE\n unsigned EMUSHORT XFnan[6] = {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};\n #endif\n@@ -4919,7 +4933,9 @@ unsigned EMUSHORT XFnan[6] = {0, 0, 0, 0xc000, 0xffff, 0};\n #endif\n #endif\n \n-#ifndef DFMODE_NAN\n+#ifdef DFMODE_NAN\n+DFMODE_NAN;\n+#else\n #ifdef MIEEE\n unsigned EMUSHORT DFnan[4] = {0x7fff, 0xffff, 0xffff, 0xffff};\n #endif\n@@ -4928,7 +4944,9 @@ unsigned EMUSHORT DFnan[4] = {0, 0, 0, 0xfff8};\n #endif\n #endif\n \n-#ifndef SFMODE_NAN\n+#ifdef SFMODE_NAN\n+SFMODE_NAN;\n+#else\n #ifdef MIEEE\n unsigned EMUSHORT SFnan[2] = {0x7fff, 0xffff};\n #endif"}]}