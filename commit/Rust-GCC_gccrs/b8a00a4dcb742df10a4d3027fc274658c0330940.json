{"sha": "b8a00a4dcb742df10a4d3027fc274658c0330940", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhMDBhNGRjYjc0MmRmMTBhNGQzMDI3ZmMyNzQ2NThjMDMzMDk0MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-01-04T08:56:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-04T08:56:05Z"}, "message": "tree-inline.c (copy_bb): Insert new statements to statements_to_fold set.\n\n\t* tree-inline.c (copy_bb): Insert new statements to statements_to_fold\n\tset.\n\t(fold_marked_statements): New function.\n\t(optimize_inline_calls, tree_function_versioning): Fold new statements.\n\t* tree-inline.h (copy_body_data): Add statemetns_to_fold.\n\nFrom-SVN: r120430", "tree": {"sha": "cc1c513083616555771818561214fc727235e351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1c513083616555771818561214fc727235e351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8a00a4dcb742df10a4d3027fc274658c0330940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a00a4dcb742df10a4d3027fc274658c0330940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8a00a4dcb742df10a4d3027fc274658c0330940", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a00a4dcb742df10a4d3027fc274658c0330940/comments", "author": null, "committer": null, "parents": [{"sha": "fa9585134f6f58fa0d3da3ca4ad5493855aea2dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa9585134f6f58fa0d3da3ca4ad5493855aea2dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa9585134f6f58fa0d3da3ca4ad5493855aea2dc"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "80cff3465772c782a669333abb748554030e36c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8a00a4dcb742df10a4d3027fc274658c0330940", "patch": "@@ -1,3 +1,11 @@\n+2007-01-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-inline.c (copy_bb): Insert new statements to statements_to_fold\n+\tset.\n+\t(fold_marked_statements): New function.\n+\t(optimize_inline_calls, tree_function_versioning): Fold new statements.\n+\t* tree-inline.h (copy_body_data): Add statemetns_to_fold.\n+\n 2007-01-03  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* config.gcc: Mention libgcc/config.host."}, {"sha": "bcfdd91b421d54d44fe7ab15b2e1a77fa89a82cc", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b8a00a4dcb742df10a4d3027fc274658c0330940", "patch": "@@ -797,6 +797,20 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \t    {\n \t      stmt = bsi_stmt (copy_bsi);\n \t      call = get_call_expr_in (stmt);\n+\n+\t      /* Statements produced by inlining can be unfolded, especially\n+\t\t when we constant propagated some operands.  We can't fold\n+\t\t them right now for two reasons:\n+\t\t 1) folding require SSA_NAME_DEF_STMTs to be correct\n+\t\t 2) we can't change function calls to builtins.\n+\t\t So we just mark statement for later folding.  We mark\n+\t\t all new statements, instead just statements that has changed\n+\t\t by some nontrivial substitution so even statements made\n+\t\t foldable indirectly are updated.  If this turns out to be\n+\t\t expensive, copy_body can be told to watch for nontrivial\n+\t\t changes.  */\n+\t      if (id->statements_to_fold)\n+\t\tpointer_set_insert (id->statements_to_fold, stmt);\n \t      /* We're duplicating a CALL_EXPR.  Find any corresponding\n \t\t callgraph edges and update or duplicate them.  */\n \t      if (call && (decl = get_callee_fndecl (call)))\n@@ -2571,6 +2585,22 @@ gimple_expand_calls_inline (basic_block bb, copy_body_data *id)\n   return false;\n }\n \n+/* Walk all basic blocks created after FIRST and try to fold every statement\n+   in the STATEMENTS pointer set.  */\n+static void\n+fold_marked_statements (int first, struct pointer_set_t *statements)\n+{\n+  for (;first < n_basic_blocks;first++)\n+    if (BASIC_BLOCK (first))\n+      {\n+        block_stmt_iterator bsi;\n+\tfor (bsi = bsi_start (BASIC_BLOCK (first));\n+\t     !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  if (pointer_set_contains (statements, bsi_stmt (bsi)))\n+\t    fold_stmt (bsi_stmt_ptr (bsi));\n+      }\n+}\n+\n /* Expand calls to inline functions in the body of FN.  */\n \n void\n@@ -2579,6 +2609,7 @@ optimize_inline_calls (tree fn)\n   copy_body_data id;\n   tree prev_fn;\n   basic_block bb;\n+  int last = n_basic_blocks;\n   /* There is no point in performing inlining if errors have already\n      occurred -- and we might crash if we try to inline invalid\n      code.  */\n@@ -2603,6 +2634,7 @@ optimize_inline_calls (tree fn)\n   id.transform_new_cfg = false;\n   id.transform_return_to_modify = true;\n   id.transform_lang_insert_block = false;\n+  id.statements_to_fold = pointer_set_create ();\n \n   push_gimplify_context ();\n \n@@ -2636,6 +2668,9 @@ optimize_inline_calls (tree fn)\n      as inlining loops might increase the maximum.  */\n   if (ENTRY_BLOCK_PTR->count)\n     counts_to_freqs ();\n+\n+  fold_marked_statements (last, id.statements_to_fold);\n+  pointer_set_destroy (id.statements_to_fold);\n   if (gimple_in_ssa_p (cfun))\n     {\n       /* We make no attempts to keep dominance info up-to-date.  */\n@@ -3188,6 +3223,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   id.transform_new_cfg = true;\n   id.transform_return_to_modify = false;\n   id.transform_lang_insert_block = false;\n+  id.statements_to_fold = pointer_set_create ();\n \n   current_function_decl = new_decl;\n   old_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION\n@@ -3253,6 +3289,8 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n \n   /* Clean up.  */\n   splay_tree_delete (id.decl_map);\n+  fold_marked_statements (0, id.statements_to_fold);\n+  pointer_set_destroy (id.statements_to_fold);\n   fold_cond_expr_cond ();\n   if (gimple_in_ssa_p (cfun))\n     {"}, {"sha": "e75644780741c4ea8b0c1d4b35f6e526c7cc1af2", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8a00a4dcb742df10a4d3027fc274658c0330940/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=b8a00a4dcb742df10a4d3027fc274658c0330940", "patch": "@@ -88,6 +88,9 @@ typedef struct copy_body_data\n   /* True if lang_hooks.decls.insert_block should be invoked when\n      duplicating BLOCK nodes.  */\n   bool transform_lang_insert_block;\n+\n+  /* Statements that might be possibly folded.  */\n+  struct pointer_set_t *statements_to_fold;\n } copy_body_data;\n \n /* Function prototypes.  */"}]}