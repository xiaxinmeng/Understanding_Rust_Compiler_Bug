{"sha": "a39d31bc0c617e5bc7e57e513ba165e00ed46580", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM5ZDMxYmMwYzYxN2U1YmM3ZTU3ZTUxM2JhMTY1ZTAwZWQ0NjU4MA==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1994-06-30T16:18:55Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1994-06-30T16:18:55Z"}, "message": "This patch makes selectors in the Objective-C language be pointers to a struct { void *sel_id...\n\n        This patch makes selectors in the Objective-C language be pointers\n        to a struct { void *sel_id, char *sel_types }, where the sel_types\n        element is the type encoding of the method arguments.\n\nFrom-SVN: r7622", "tree": {"sha": "8fe61c212a5faefb5e2d0f5e09269f407fb13584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fe61c212a5faefb5e2d0f5e09269f407fb13584"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a39d31bc0c617e5bc7e57e513ba165e00ed46580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39d31bc0c617e5bc7e57e513ba165e00ed46580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a39d31bc0c617e5bc7e57e513ba165e00ed46580", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39d31bc0c617e5bc7e57e513ba165e00ed46580/comments", "author": null, "committer": null, "parents": [{"sha": "7a1dd323251ccfb83be3b6e5ae9e7ff31ec8a413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1dd323251ccfb83be3b6e5ae9e7ff31ec8a413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1dd323251ccfb83be3b6e5ae9e7ff31ec8a413"}], "stats": {"total": 1149, "additions": 729, "deletions": 420}, "files": [{"sha": "e2722dc18fb2bd2ef078a629d788eca54a446ae3", "filename": "gcc/objc/Object.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.h?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -1,5 +1,5 @@\n /* Interface for the Object class for Objective-C.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -93,8 +93,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n - perform:(SEL)aSel with:anObject1 with:anObject2;\n \n         /* Forwarding */\n-- forward:(SEL)aSel :(arglist_t)argFrame;\n-- performv:(SEL)aSel :(arglist_t)argFrame;\n+- (retval_t)forward:(SEL)aSel :(arglist_t)argFrame;\n+- (retval_t)performv:(SEL)aSel :(arglist_t)argFrame;\n \n         /* Posing */\n + poseAs:(Class*)aClassObject;\n@@ -112,14 +112,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n         /* Archiving */\n + (int)version;\n + setVersion:(int)aVersion;\n-\n-#ifndef __alpha__ /* TypedStream not supported on alpha yet.  */\n + (int)streamVersion: (TypedStream*)aStream;\n \n - read: (TypedStream*)aStream;\n - write: (TypedStream*)aStream;\n-#endif\n-\n - awake;\n \n @end"}, {"sha": "71cac4f39b2e569b2cba0e93a3de07c1bb0d8ff3", "filename": "gcc/objc/archive.c", "status": "modified", "additions": 311, "deletions": 218, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Farchive.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -24,14 +24,18 @@ You should have received a copy of the GNU General Public License along with\n    however invalidate any other reasons why the executable file might be\n    covered by the GNU General Public License.  */\n \n-/*\n-** Note: This version assumes that int and longs are both 32bit.\n-*/\n-\n-#ifndef __alpha__\n-\n #include \"runtime.h\"\n #include \"typedstream.h\"\n+#include \"encoding.h\"\n+\n+extern int fflush(FILE*);\n+\n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A);  \\\n+     __a*((__v+__a-1)/__a); })\n+\n+#define PTR2LONG(P) (((char*)(P))-(char*)0)\n+#define LONG2PTR(L) (((char*)0)+(L))\n \n #define __objc_fatal(format, args...) \\\n  { fprintf(stderr, \"archiving: \"); \\\n@@ -43,22 +47,20 @@ You should have received a copy of the GNU General Public License along with\n static int\n objc_read_class (struct objc_typed_stream* stream, Class** class);\n \n-static int\n-objc_sizeof_type(const char* type);\n+int objc_sizeof_type(const char* type);\n \n static int\n-objc_write_use_common (struct objc_typed_stream* stream, unsigned int key);\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned long key);\n \n static int\n objc_write_register_common (struct objc_typed_stream* stream,\n-\t\t\t    unsigned int key);\n+\t\t\t    unsigned long key);\n \n static int \n objc_write_class (struct objc_typed_stream* stream,\n \t\t\t struct objc_class* class);\n \n-static const char*\n-__objc_skip_type (const char* type);\n+const char* objc_skip_type (const char* type);\n \n static void __objc_finish_write_root_object(struct objc_typed_stream*);\n static void __objc_finish_read_root_object(struct objc_typed_stream*);\n@@ -112,15 +114,29 @@ objc_write_char (struct objc_typed_stream* stream, char value)\n static __inline__ int\n __objc_code_unsigned_short (unsigned char* buf, unsigned short val)\n {\n-  if (val <= 0xffU)\n-    return __objc_code_unsigned_char (buf, val);\n-\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n   else \n     {\n-      buf[0] = _B_NINT|0x02;\n-      buf[1] = val/0x100;\n-      buf[2] = val%0x100;\n-      return 3;\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(short); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n     }\n }\n \n@@ -135,18 +151,11 @@ objc_write_unsigned_short (struct objc_typed_stream* stream, unsigned short valu\n static __inline__ int\n __objc_code_short (unsigned char* buf, short val)\n {\n-  if (val > 0)\n-    return __objc_code_unsigned_short (buf, val);\n-\n-  if (val > -0x7f)\t\t/* val > -128 */\n-    return __objc_code_char (buf, val);\n-\n-  else \n-    {\n-      int len = __objc_code_unsigned_short (buf, -val);\n-      buf[0] |= _B_SIGN;\n-      return len;\n-    }\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_short (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n }\n \n int\n@@ -161,26 +170,29 @@ objc_write_short (struct objc_typed_stream* stream, short value)\n static __inline__ int\n __objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n {\n-  if (val < 0x10000)\n-    return __objc_code_unsigned_short (buf, val%0x10000);\n-\n-  else if (val < 0x1000000)\n+  if ((val&_B_VALUE) == val)\n     {\n-      buf[0] = _B_NINT|3;\n-      buf[1] = val/0x10000;\n-      buf[2] = (val%0x10000)/0x100;\n-      buf[3] = val%0x100;\n-      return 4;\n+      buf[0] = val|_B_SINT;\n+      return 1;\n     }\n-\n   else \n     {\n-      buf[0] = _B_NINT|4;\n-      buf[1] = val/0x1000000;\n-      buf[2] = (val%0x1000000)/0x10000;\n-      buf[3] = (val%0x10000)/0x100;\n-      buf[4] = val%0x100;\n-      return 5;\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(int); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n     }\n }\n \n@@ -195,28 +207,77 @@ objc_write_unsigned_int (struct objc_typed_stream* stream, unsigned int value)\n static __inline__ int\n __objc_code_int (unsigned char* buf, int val)\n {\n-  if (val >= 0)\n-    return __objc_code_unsigned_int (buf, val);\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_int (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n+}\n \n-  if (val > -0x7f)\n-    return __objc_code_char (buf, val);\n+int\n+objc_write_int (struct objc_typed_stream* stream, int value)\n+{\n+  unsigned char buf[sizeof(int)+1];\n+  int len = __objc_code_int (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n \n+static __inline__ int\n+__objc_code_unsigned_long (unsigned char* buf, unsigned long val)\n+{\n+  if ((val&_B_VALUE) == val)\n+    {\n+      buf[0] = val|_B_SINT;\n+      return 1;\n+    }\n   else \n     {\n-      int len = __objc_code_unsigned_int (buf, -val);\n-      buf[0] |= _B_SIGN;\n-      return len;\n+      int c, b;\n+\n+      buf[0] = _B_NINT;\n+\n+      for (c= sizeof(long); c != 0; c -= 1)\n+\tif (((val>>(8*(c-1)))%0x100) != 0)\n+\t  break;\n+\n+      buf[0] |= c;\n+\n+      for (b = 1; c != 0; c--, b++)\n+\t{\n+\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t}\n+\n+      return b;\n     }\n }\n \n int\n-objc_write_int (struct objc_typed_stream* stream, int value)\n+objc_write_unsigned_long (struct objc_typed_stream* stream, unsigned long value)\n {\n-  unsigned char buf[sizeof(int)+1];\n-  int len = __objc_code_int (buf, value);\n+  unsigned char buf[sizeof(unsigned long)+1];\n+  int len = __objc_code_unsigned_long (buf, value);\n   return (*stream->write)(stream->physical, buf, len);\n }\n \n+static __inline__ int\n+__objc_code_long (unsigned char* buf, long val)\n+{\n+  int sign = (val < 0);\n+  int size = __objc_code_unsigned_long (buf, sign ? -val : val);\n+  if (sign)\n+    buf[0] |= _B_SIGN;\n+  return size;\n+}\n+\n+int\n+objc_write_long (struct objc_typed_stream* stream, long value)\n+{\n+  unsigned char buf[sizeof(long)+1];\n+  int len = __objc_code_long (buf, value);\n+  return (*stream->write)(stream->physical, buf, len);\n+}\n+\n+\n int\n objc_write_string (struct objc_typed_stream* stream,\n \t\t   const unsigned char* string, unsigned int nbytes)\n@@ -240,24 +301,24 @@ int\n objc_write_string_atomic (struct objc_typed_stream* stream,\n \t\t\t  unsigned char* string, unsigned int nbytes)\n {\n-  unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, string)))\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, string))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, (void*)key=(unsigned int)string, string);\n+      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(string)), string);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn objc_write_string (stream, string, nbytes);\n       return length;\n     }\n }\n \n static int\n-objc_write_register_common (struct objc_typed_stream* stream, unsigned int key)\n+objc_write_register_common (struct objc_typed_stream* stream, unsigned long key)\n {\n-  unsigned char buf[sizeof (unsigned int)+2];\n-  int len = __objc_code_unsigned_int (buf+1, key);\n+  unsigned char buf[sizeof (unsigned long)+2];\n+  int len = __objc_code_unsigned_long (buf+1, key);\n   if (len == 1)\n     {\n       buf[0] = _B_RCOMM|0x01;\n@@ -272,10 +333,10 @@ objc_write_register_common (struct objc_typed_stream* stream, unsigned int key)\n }\n \n static int\n-objc_write_use_common (struct objc_typed_stream* stream, unsigned int key)\n+objc_write_use_common (struct objc_typed_stream* stream, unsigned long key)\n {\n-  unsigned char buf[sizeof (unsigned int)+2];\n-  int len = __objc_code_unsigned_int (buf+1, key);\n+  unsigned char buf[sizeof (unsigned long)+2];\n+  int len = __objc_code_unsigned_long (buf+1, key);\n   if (len == 1)\n     {\n       buf[0] = _B_UCOMM|0x01;\n@@ -305,7 +366,7 @@ __inline__ int\n __objc_write_object (struct objc_typed_stream* stream, id object)\n {\n   unsigned char buf = '\\0';\n-  SEL write_sel = sel_get_uid (\"write:\");\n+  SEL write_sel = sel_get_any_uid (\"write:\");\n   if (object)\n     {\n       __objc_write_extension (stream, _BX_OBJECT);\n@@ -320,12 +381,12 @@ __objc_write_object (struct objc_typed_stream* stream, id object)\n int \n objc_write_object_reference (struct objc_typed_stream* stream, id object)\n {\n-  unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->object_table, object)))\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n     return objc_write_use_common (stream, key);\n \n   __objc_write_extension (stream, _BX_OBJREF);\n-  return objc_write_unsigned_int (stream, (unsigned int)object);\n+  return objc_write_unsigned_long (stream, PTR2LONG (object));\n }\n \n int \n@@ -348,8 +409,8 @@ objc_write_root_object (struct objc_typed_stream* stream, id object)\n int \n objc_write_object (struct objc_typed_stream* stream, id object)\n {\n-  unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->object_table, object)))\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n     return objc_write_use_common (stream, key);\n \n   else if (object == nil)\n@@ -358,34 +419,40 @@ objc_write_object (struct objc_typed_stream* stream, id object)\n   else\n     {\n       int length;\n-      hash_add (&stream->object_table, (void*)key=(unsigned int)object, object);\n+      hash_add (&stream->object_table, LONG2PTR(key=PTR2LONG(object)), object);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_object (stream, object);\n       return length;\n     }\n }\n \n+#ifdef __alpha__\n+extern int atoi (const char*);\n+extern size_t strlen(const char*);\n+extern size_t strcpy(char*, const char*);\n+#endif\n+\n __inline__ int\n __objc_write_class (struct objc_typed_stream* stream, struct objc_class* class)\n {\n   __objc_write_extension (stream, _BX_CLASS);\n   objc_write_string_atomic(stream, (char*)class->name,\n \t\t\t   strlen((char*)class->name));\n-  return objc_write_unsigned_int (stream, CLS_GETNUMBER(class));\n+  return objc_write_unsigned_long (stream, CLS_GETNUMBER(class));\n }\n \n \n static int \n objc_write_class (struct objc_typed_stream* stream,\n \t\t\t struct objc_class* class)\n {\n-  unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, class)))\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, class))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, (void*)key=(unsigned int)class, class);\n+      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(class)), class);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_class (stream, class);\n       return length;\n@@ -405,13 +472,13 @@ int\n objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n {\n   const char* sel_name = sel_get_name (selector);\n-  unsigned int key;\n-  if ((key = (unsigned int)hash_value_for_key (stream->stream_table, sel_name)))\n+  unsigned long key;\n+  if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, sel_name))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, (void*)key=(unsigned int)sel_name, (char*)sel_name);\n+      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(sel_name)), (char*)sel_name);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_selector (stream, selector);\n       return length;\n@@ -551,6 +618,33 @@ objc_read_int (struct objc_typed_stream* stream, int* value)\n   return len;\n }\n \n+__inline__ int\n+objc_read_long (struct objc_typed_stream* stream, long* value)\n+{\n+  unsigned char buf[sizeof(long)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\t{\n+\t  int pos = 1;\n+\t  int nbytes = buf[0] & _B_NUMBER;\n+\t  if (nbytes > sizeof (long))\n+\t    __objc_fatal(\"expected long, got bigger\");\n+\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t  (*value) = 0;\n+\t  while (pos <= nbytes)\n+\t    (*value) = ((*value)*0x100) + buf[pos++];\n+\t  if (buf[0] & _B_SIGN)\n+\t    (*value) = -(*value);\n+\t}\n+    }\n+  return len;\n+}\n+\n __inline__ int\n __objc_read_nbyte_uint (struct objc_typed_stream* stream,\n \t\t       unsigned int nbytes, unsigned int* val)\n@@ -587,6 +681,42 @@ objc_read_unsigned_int (struct objc_typed_stream* stream,\n   return len;\n }\n \n+int\n+__objc_read_nbyte_ulong (struct objc_typed_stream* stream,\n+\t\t       unsigned int nbytes, unsigned long* val)\n+{\n+  int len, pos = 0;\n+  unsigned char buf[sizeof(unsigned long)+1];\n+\n+  if (nbytes > sizeof (long))\n+    __objc_fatal(\"expected long, got bigger\");\n+\n+  len = (*stream->read)(stream->physical, buf, nbytes);\n+  (*val) = 0;\n+  while (pos < nbytes)\n+    (*val) = ((*val)*0x100) + buf[pos++];\n+  return len;\n+}\n+  \n+\n+__inline__ int\n+objc_read_unsigned_long (struct objc_typed_stream* stream,\n+\t\t\tunsigned long* value)\n+{\n+  unsigned char buf[sizeof(unsigned long)+1];\n+  int len;\n+  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+    {\n+      if ((buf[0] & _B_CODE) == _B_SINT)\n+\t(*value) = (buf[0] & _B_VALUE);\n+\n+      else\n+\tlen = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), value);\n+\n+    }\n+  return len;\n+}\n+\n __inline__ int\n objc_read_string (struct objc_typed_stream* stream,\n \t\t  char** string)\n@@ -595,11 +725,11 @@ objc_read_string (struct objc_typed_stream* stream,\n   int len;\n   if ((len = (*stream->read)(stream->physical, buf, 1)))\n     {\n-      unsigned int key = 0;\n+      unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  len = (*stream->read)(stream->physical, buf, 1);\n \t}\n \n@@ -609,7 +739,7 @@ objc_read_string (struct objc_typed_stream* stream,\n \t  int length = buf[0]&_B_VALUE;\n \t  (*string) = (char*)__objc_xmalloc(length+1);\n \t  if (key)\n-\t    hash_add (&stream->stream_table, (void*)key, *string);\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), *string);\n \t  len = (*stream->read)(stream->physical, *string, length);\n \t  (*string)[length] = '\\0';\n \t}\n@@ -618,9 +748,9 @@ objc_read_string (struct objc_typed_stream* stream,\n       case _B_UCOMM:\n \t{\n \t  char *tmp;\n-\t  len = __objc_read_nbyte_uint (stream, (buf[0] & _B_VALUE), &key);\n-\t  tmp = hash_value_for_key (stream->stream_table, (void*)key);\n-\t  *string = __objc_xmalloc (strlen (tmp) + 1);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  tmp = hash_value_for_key (stream->stream_table, LONG2PTR (key));\n+\t  *string = __objc_xmalloc (strlen(tmp) + 1);\n \t  strcpy (*string, tmp);\n \t}\n \tbreak;\n@@ -632,7 +762,7 @@ objc_read_string (struct objc_typed_stream* stream,\n \t  if (len) {\n \t    (*string) = (char*)__objc_xmalloc(nbytes+1);\n \t    if (key)\n-\t      hash_add (&stream->stream_table, (void*)key, *string);\n+\t      hash_add (&stream->stream_table, LONG2PTR(key), *string);\n \t    len = (*stream->read)(stream->physical, *string, nbytes);\n \t    (*string)[nbytes] = '\\0';\n \t  }\n@@ -655,12 +785,12 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n   int len;\n   if ((len = (*stream->read)(stream->physical, buf, 1)))\n     {\n-      SEL read_sel = sel_get_uid (\"read:\");\n-      unsigned int key = 0;\n+      SEL read_sel = sel_get_any_uid (\"read:\");\n+      unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register common */\n \t{\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  len = (*stream->read)(stream->physical, buf, 1);\n \t}\n \n@@ -676,7 +806,7 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \n \t  /* register? */\n \t  if (key)\n-\t    hash_add (&stream->object_table, (void*)key, *object);\n+\t    hash_add (&stream->object_table, LONG2PTR(key), *object);\n \n \t  /* send -read: */\n \t  if (__objc_responds_to (*object, read_sel))\n@@ -692,16 +822,16 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \t{\n \t  if (key)\n \t    __objc_fatal(\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n-\t  (*object) = hash_value_for_key (stream->object_table, (void*)key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*object) = hash_value_for_key (stream->object_table, LONG2PTR(key));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n \t{\n \t  struct objc_list* other;\n-\t  len = objc_read_unsigned_int (stream, &key);\n-\t  other = (struct objc_list*)hash_value_for_key (stream->object_refs, (void*)key);\n-\t  hash_add (&stream->object_refs, (void*)key, (void*)list_cons(object, other));\n+\t  len = objc_read_unsigned_long (stream, &key);\n+\t  other = (struct objc_list*)hash_value_for_key (stream->object_refs, LONG2PTR(key));\n+\t  hash_add (&stream->object_refs, LONG2PTR(key), (void*)list_cons(object, other));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n@@ -725,18 +855,18 @@ objc_read_class (struct objc_typed_stream* stream, Class** class)\n   int len;\n   if ((len = (*stream->read)(stream->physical, buf, 1)))\n     {\n-      unsigned int key = 0;\n+      unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  len = (*stream->read)(stream->physical, buf, 1);\n \t}\n \n       if (buf[0] == (_B_EXT | _BX_CLASS))\n \t{\n \t  char* class_name;\n-\t  int version;\n+\t  unsigned long version;\n \n \t  /* get class */\n \t  len = objc_read_string (stream, &class_name);\n@@ -745,20 +875,20 @@ objc_read_class (struct objc_typed_stream* stream, Class** class)\n \n \t  /* register */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, (void*)key, *class);\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), *class);\n \n-\t  objc_read_unsigned_int(stream, &version);\n+\t  objc_read_unsigned_long(stream, &version);\n \t  hash_add (&stream->class_table, (*class)->name, (void*)version);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n \t    __objc_fatal(\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n-\t  (*class) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*class) = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n \t  if (!*class)\n-\t    __objc_fatal(\"cannot find class for key %x\", key);\n+\t    __objc_fatal(\"cannot find class for key %lu\", key);\n \t}\n \n       else\n@@ -774,11 +904,11 @@ objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n   int len;\n   if ((len = (*stream->read)(stream->physical, buf, 1)))\n     {\n-      unsigned int key = 0;\n+      unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n \t  len = (*stream->read)(stream->physical, buf, 1);\n \t}\n \n@@ -788,20 +918,20 @@ objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n \n \t  /* get selector */\n \t  len = objc_read_string (stream, &selector_name);\n-\t  (*selector) = sel_get_uid(selector_name);\n+\t  (*selector) = sel_get_any_uid(selector_name);\n \t  free (selector_name);\n \n \t  /* register */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, (void*)key, *selector);\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), (void*)*selector);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n \t    __objc_fatal(\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_uint(stream, (buf[0] & _B_VALUE), &key);\n-\t  (*selector) = hash_value_for_key (stream->stream_table, (void*)key);\n+\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  (*selector) = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n \t}\n \n       else\n@@ -810,96 +940,6 @@ objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n   return len;\n }\n \n-static int\n-objc_sizeof_type(const char* type)\n-{\n-  switch(*type) {\n-  case _C_ID: return sizeof(id);\n-    break;\n-\n-  case _C_CLASS:\n-    return sizeof(Class*);\n-    break;\n-\n-  case _C_SEL:\n-    return sizeof(SEL);\n-    break;\n-\n-  case _C_CHR:\n-    return sizeof(char);\n-    break;\n-    \n-  case _C_UCHR:\n-    return sizeof(unsigned char);\n-    break;\n-\n-  case _C_SHT:\n-    return sizeof(short);\n-    break;\n-\n-  case _C_USHT:\n-    return sizeof(unsigned short);\n-    break;\n-\n-  case _C_INT:\n-  case _C_LNG:\n-    return sizeof(int);\n-    break;\n-\n-  case _C_UINT:\n-  case _C_ULNG:\n-    return sizeof(unsigned int);\n-    break;\n-\n-  case _C_ATOM:\n-  case _C_CHARPTR:\n-    return sizeof(char*);\n-    break;\n-\n-  default:\n-    fprintf(stderr, \"objc_sizeof_type: cannot parse typespec: %s\\n\", type);\n-    abort();\n-  }\n-}\n-\n-\n-static const char*\n-__objc_skip_type (const char* type)\n-{\n-  switch (*type) {\n-  case _C_ID:\n-  case _C_CLASS:\n-  case _C_SEL:\n-  case _C_CHR:\n-  case _C_UCHR:\n-  case _C_CHARPTR:\n-  case _C_ATOM:\n-  case _C_SHT:\n-  case _C_USHT:\n-  case _C_INT:\n-  case _C_UINT:\n-  case _C_LNG:\n-  case _C_ULNG:\n-  case _C_FLT:\n-  case _C_DBL:\n-    return ++type;\n-    break;\n-\n-  case _C_ARY_B:\n-    while(isdigit(*++type));\n-    type = __objc_skip_type(type);\n-    if (*type == _C_ARY_E)\n-      return ++type;\n-    else\n-      __objc_fatal(\"cannot parse typespec: %s\", type);\n-    break;\n-\n-  default:\n-    fprintf(stderr, \"__objc_skip_type: cannot parse typespec: %s\\n\", type);\n-    abort();\n-  }\n-}\n-\n /*\n ** USER LEVEL FUNCTIONS\n */\n@@ -942,15 +982,21 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n     break;\n \n   case _C_INT:\n-  case _C_LNG:\n     return objc_write_int(stream, *(int*)data);\n     break;\n \n   case _C_UINT:\n-  case _C_ULNG:\n     return objc_write_unsigned_int(stream, *(unsigned int*)data);\n     break;\n \n+  case _C_LNG:\n+    return objc_write_long(stream, *(long*)data);\n+    break;\n+\n+  case _C_ULNG:\n+    return objc_write_unsigned_long(stream, *(unsigned long*)data);\n+    break;\n+\n   case _C_CHARPTR:\n     return objc_write_string (stream, *(char**)data, strlen(*(char**)data));\n     break;\n@@ -967,6 +1013,22 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n     }\n     break; \n \n+  case _C_STRUCT_B:\n+    {\n+      int acc_size = 0;\n+      int align;\n+      while (*type != _C_STRUCT_E && *type++ != '='); /* skip \"<name>=\" */\n+      while (*type != _C_STRUCT_E);\n+\t{\n+\t  align = objc_alignof_type (type);       /* padd to alignment */\n+\t  acc_size += ROUND (acc_size, align);\n+\t  objc_write_type (stream, type, ((char*)data)+acc_size);\n+\t  acc_size += objc_sizeof_type (type);   /* add component size */\n+\t  type = objc_skip_typespec (type);\t /* skip component */\n+\t}\n+      return 1;\n+    }\n+\n   default:\n     fprintf(stderr, \"objc_write_type: cannot parse typespec: %s\\n\", type);\n     abort();\n@@ -1014,15 +1076,21 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n     break;\n \n   case _C_INT:\n-  case _C_LNG:\n     return objc_read_int (stream, (int*)data);\n     break;\n \n   case _C_UINT:\n-  case _C_ULNG:\n     return objc_read_unsigned_int (stream, (unsigned int*)data);\n     break;\n \n+  case _C_LNG:\n+    return objc_read_long (stream, (long*)data);\n+    break;\n+\n+  case _C_ULNG:\n+    return objc_read_unsigned_long (stream, (unsigned long*)data);\n+    break;\n+\n   case _C_CHARPTR:\n   case _C_ATOM:\n     return objc_read_string (stream, (char**)data);\n@@ -1036,6 +1104,22 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n     }\n     break; \n \n+  case _C_STRUCT_B:\n+    {\n+      int acc_size = 0;\n+      int align;\n+      while (*type != _C_STRUCT_E && *type++ != '='); /* skip \"<name>=\" */\n+      while (*type != _C_STRUCT_E);\n+\t{\n+\t  align = objc_alignof_type (type);       /* padd to alignment */\n+\t  acc_size += ROUND (acc_size, align);\n+\t  objc_read_type (stream, type, ((char*)data)+acc_size);\n+\t  acc_size += objc_sizeof_type (type);   /* add component size */\n+\t  type = objc_skip_typespec (type);\t /* skip component */\n+\t}\n+      return 1;\n+    }\n+\n   default:\n     fprintf(stderr, \"objc_read_type: cannot parse typespec: %s\\n\", type);\n     abort();\n@@ -1061,7 +1145,7 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \n   va_start(args, type);\n \n-  for (c = type; *c; c = __objc_skip_type (c))\n+  for (c = type; *c; c = objc_skip_typespec (c))\n     {\n       switch(*c) {\n       case _C_ID:\n@@ -1095,15 +1179,21 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \tbreak;\n \n       case _C_INT:\n-      case _C_LNG:\n \tres = objc_write_int(stream, *va_arg(args, int*));\n \tbreak;\n \t\n       case _C_UINT:\n-      case _C_ULNG:\n \tres = objc_write_unsigned_int(stream, *va_arg(args, unsigned int*));\n \tbreak;\n \n+      case _C_LNG:\n+\tres = objc_write_long(stream, *va_arg(args, long*));\n+\tbreak;\n+\t\n+      case _C_ULNG:\n+\tres = objc_write_unsigned_long(stream, *va_arg(args, unsigned long*));\n+\tbreak;\n+\n       case _C_CHARPTR:\n \t{\n \t  char** str = va_arg(args, char**);\n@@ -1124,7 +1214,7 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \t  const char* t = c;\n \t  while (isdigit(*++t));\n \t  res = objc_write_array (stream, t, len, va_arg(args, void*));\n-\t  t = __objc_skip_type (t);\n+\t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n \t    __objc_fatal(\"expected `]', got: %s\", t);\n \t}\n@@ -1154,7 +1244,7 @@ objc_read_types(TypedStream* stream, const char* type, ...)\n \n   va_start(args, type);\n \n-  for (c = type; *c; c = __objc_skip_type(c))\n+  for (c = type; *c; c = objc_skip_typespec(c))\n     {\n       switch(*c) {\n       case _C_ID:\n@@ -1186,15 +1276,21 @@ objc_read_types(TypedStream* stream, const char* type, ...)\n \tbreak;\n \n       case _C_INT:\n-      case _C_LNG:\n \tres = objc_read_int(stream, va_arg(args, int*));\n \tbreak;\n \t\n       case _C_UINT:\n-      case _C_ULNG:\n \tres = objc_read_unsigned_int(stream, va_arg(args, unsigned int*));\n \tbreak;\n \n+      case _C_LNG:\n+\tres = objc_read_long(stream, va_arg(args, long*));\n+\tbreak;\n+\t\n+      case _C_ULNG:\n+\tres = objc_read_unsigned_long(stream, va_arg(args, unsigned long*));\n+\tbreak;\n+\n       case _C_CHARPTR:\n       case _C_ATOM:\n \t{\n@@ -1209,7 +1305,7 @@ objc_read_types(TypedStream* stream, const char* type, ...)\n \t  const char* t = c;\n \t  while (isdigit(*++t));\n \t  res = objc_read_array (stream, t, len, va_arg(args, void*));\n-\t  t = __objc_skip_type (t);\n+\t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n \t    __objc_fatal(\"expected `]', got: %s\", t);\n \t}\n@@ -1331,7 +1427,7 @@ static void __objc_finish_write_root_object(struct objc_typed_stream* stream)\n static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n {\n   node_ptr node;\n-  SEL awake_sel = sel_get_uid (\"awake\");\n+  SEL awake_sel = sel_get_any_uid (\"awake\");\n \n   /* resolve object forward references */\n   for (node = hash_next (stream->object_refs, NULL); node;\n@@ -1379,8 +1475,6 @@ static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n TypedStream* \n objc_open_typed_stream (FILE* physical, int mode)\n {\n-  int fflush(FILE*);\n-\n   TypedStream* s = (TypedStream*)__objc_xmalloc(sizeof(TypedStream));\n \n   s->mode = mode;\n@@ -1483,13 +1577,12 @@ objc_flush_typed_stream (TypedStream* stream)\n   (*stream->flush)(stream->physical);\n }\n \n-int \n+long\n objc_get_stream_class_version (TypedStream* stream, Class* class)\n {\n   if (stream->class_table)\n-    return (int) hash_value_for_key (stream->class_table, class->name);\n+    return PTR2LONG(hash_value_for_key (stream->class_table, class->name));\n   else\n     return class_get_version (class);\n }\n \n-#endif /* __alpha__ */"}, {"sha": "e5a3505112ad777b81771f8547863c40906dc2a9", "filename": "gcc/objc/class.c", "status": "modified", "additions": 53, "deletions": 63, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -132,6 +132,27 @@ objc_get_class (const char *name)\n   abort();\n }\n \n+/* This function provides a way to enumerate all the classes in the\n+   executable.  Pass *ENUM_STATE == NULL to start the enumeration.  The\n+   function will return 0 when there are no more classes.  \n+   For example: \n+       id class; \n+       void *es = NULL;\n+       while ((class = objc_next_class(&es)))\n+         ... do something with class; \n+*/\n+Class* \n+objc_next_class(void **enum_state)\n+{\n+  /* make sure the table is there */\n+  assert(__objc_class_hash);\n+\n+  *(node_ptr*)enum_state = \n+    hash_next(__objc_class_hash, *(node_ptr*)enum_state);\n+  if (*(node_ptr*)enum_state)\n+    return (*(node_ptr*)enum_state)->value;\n+  return (Class*)0;\n+}\n \n /* Resolve super/subclass links for all classes.  The only thing we \n    can be sure of is that the class_pointer for class objects point \n@@ -217,6 +238,9 @@ void __objc_resolve_class_links()\n Class*\n class_pose_as (Class* impostor, Class* super_class)\n {\n+  node_ptr node;\n+  Class* class1;\n+\n   if (!CLS_ISRESOLV (impostor))\n     __objc_resolve_class_links ();\n \n@@ -230,31 +254,32 @@ class_pose_as (Class* impostor, Class* super_class)\n \n   {\n     Class **subclass = &(super_class->subclass_list);\n-    BOOL super_is_base_class = NO;\n \n     /* move subclasses of super_class to impostor */\n     while (*subclass)\n       {\n \tClass *nextSub = (*subclass)->sibling_class;\n \n-\t/* this happens when super_class is a base class */\n-\tif (*subclass == CLASSOF (super_class))\n-\t  {\n-\t    super_is_base_class = YES;\n-\t  }\n-\telse if (*subclass != impostor)\n+\tif (*subclass != impostor)\n \t  {\n \t    Class *sub = *subclass;\n \n \t    /* classes */\n \t    sub->sibling_class = impostor->subclass_list;\n \t    sub->super_class = impostor;\n \t    impostor->subclass_list = sub;\n-\t    \n-\t    /* meta classes */\n-\t    CLASSOF (sub)->sibling_class = CLASSOF (impostor)->subclass_list;\n-\t    CLASSOF (sub)->super_class = CLASSOF (impostor);\n-\t    CLASSOF (impostor)->subclass_list = CLASSOF (sub);\n+\n+\t    /* It will happen that SUB is not a class object if it is \n+\t       the top of the meta class hierachy chain.  (root\n+\t       meta-class objects inherit theit class object)  If that is\n+\t       the case... dont mess with the meta-meta class. */ \n+\t    if (CLS_ISCLASS (sub))\n+\t      {\n+\t\t/* meta classes */\n+\t\tCLASSOF (sub)->sibling_class = CLASSOF (impostor)->subclass_list;\n+\t\tCLASSOF (sub)->super_class = CLASSOF (impostor);\n+\t\tCLASSOF (impostor)->subclass_list = CLASSOF (sub);\n+\t      }\n \t  }\n \n \t*subclass = nextSub;\n@@ -267,66 +292,31 @@ class_pose_as (Class* impostor, Class* super_class)\n     /* set impostor to have no sibling classes */\n     impostor->sibling_class = 0;\n     CLASSOF (impostor)->sibling_class = 0;\n-\n-    /* impostor has a sibling... */\n-    if (super_is_base_class)\n-      {\n-\tCLASSOF (super_class)->sibling_class = 0;\n-\timpostor->sibling_class = CLASSOF (super_class);\n-      }\n   }\n   \n-  /* check relationship of impostor and super_class */\n+  /* check relationship of impostor and super_class is kept. */\n   assert (impostor->super_class == super_class);\n   assert (CLASSOF (impostor)->super_class == CLASSOF (super_class));\n \n-  /* by now, the re-organization of the class hierachy \n-     is done.  We only need to update various tables. */\n-\n-  /* First, we change the names in the hash table.\n-     This will change the behavior of objc_get_class () */\n-  {\n-    char* buffer = (char*) __objc_xmalloc(strlen (super_class->name) + 2);\n-\n-    strcpy (buffer+1, super_class->name);\n-    buffer[0] = '*';\n+  /* This is how to update the lookup table. Regardless of\n+     what the keys of the hashtable is, change all values that are\n+     suprecalss into impostor. */\n \n-    /* keep on prepending '*' until the name is unique */\n-    while (hash_value_for_key (__objc_class_hash, buffer))\n-      {\n-\tchar *bbuffer = (char*) __objc_xmalloc (strlen (buffer)+2);\n-\n-\tstrcpy (bbuffer+1, buffer);\n-\tbbuffer[0] = '*';\n-\tfree (buffer);\n-\tbuffer = bbuffer;\n-      }\n-\n-    hash_remove (__objc_class_hash, super_class->name);\n-    hash_add (&__objc_class_hash, buffer, super_class);\n-    hash_add (&__objc_class_hash, super_class->name, impostor);\n-\n-    /* Note that -name and +name will still respond with\n-       the same strings as before.  This way any\n-       -isKindOfGivenName: will always work.         */\n-  }\n+  for (node = hash_next (__objc_class_hash, NULL); node;\n+       node = hash_next (__objc_class_hash, node))\n+    {\n+      class1 = (Class*)node->value;\n+      if (class1 == super_class)\n+\t{\n+\t  node->value = impostor; /* change hash table value */\n+\t}\n+    }      \n \n   /* next, we update the dispatch tables... */\n-  {\n-    Class *subclass;\n-\n-    for (subclass = impostor->subclass_list;\n-\t subclass; subclass = subclass->sibling_class)\n-      {\n-\t/* we use the opportunity to check what we did */\n-\tassert (subclass->super_class == impostor);\n-\tassert (CLASSOF (subclass)->super_class == CLASSOF (impostor));\n-\n-\t__objc_update_dispatch_table_for_class (CLASSOF (subclass));\n-\t__objc_update_dispatch_table_for_class (subclass);\n-      }\n-  }\n+  __objc_update_dispatch_table_for_class (CLASSOF (impostor));\n+  __objc_update_dispatch_table_for_class (impostor);\n \n   return impostor;\n }\n   \n+"}, {"sha": "479b4a1c6bfaebcadbb0e92dfb5f685afe7162e9", "filename": "gcc/objc/encoding.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -35,6 +35,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n   ({ typeof(X) __x = (X), __y = (Y); \\\n      (__x < __y ? __x : __y); })\n \n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n+     __a*((__v+__a-1)/__a); })\n+\n \n static inline int\n atoi (const char* str)\n@@ -121,8 +125,7 @@ objc_sizeof_type(const char* type)\n       while (*type != _C_STRUCT_E);\n \t{\n \t  align = objc_alignof_type (type);       /* padd to alignment */\n-\t  if ((acc_size % align) != 0)\n-\t    acc_size += align - (acc_size % align);\n+\t  acc_size += ROUND (acc_size, align);\n \t  acc_size += objc_sizeof_type (type);   /* add component size */\n \t  type = objc_skip_typespec (type);\t         /* skip component */\n \t}\n@@ -244,11 +247,7 @@ objc_aligned_size (const char* type)\n {\n   int size = objc_sizeof_type (type);\n   int align = objc_alignof_type (type);\n-\n-  if ((size % align) != 0)\n-    return size + align - (size % align);\n-  else\n-    return size;\n+  return ROUND (size, align);\n }\n \n /*\n@@ -262,10 +261,7 @@ objc_promoted_size (const char* type)\n   int size = objc_sizeof_type (type);\n   int wordsize = sizeof (void*);\n \n-  if ((size % wordsize) != 0)\n-    return size + wordsize - (size % wordsize);\n-  else\n-    return size;\n+  return ROUND (size, wordsize);\n }\n \n /*"}, {"sha": "e1d736abe39ac20260d5f00283da0120c2819992", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -39,6 +39,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define EXPANSION(cache) \\\n   ((cache)->size * 2)\n \n+void *__objc_xcalloc (size_t, size_t);\n+\n cache_ptr\n hash_new (unsigned int size, hash_func_type hash_func,\n \t  compare_func_type compare_func)"}, {"sha": "b41ce95ea6dc45f9f8dbd8529b0cf56c824c6c39", "filename": "gcc/objc/init.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -28,7 +28,7 @@ You should have received a copy of the GNU General Public License along with\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c) */\n-#define OBJC_VERSION 5\n+#define OBJC_VERSION 6\n #define PROTOCOL_VERSION 2\n \n /* This list contains all modules currently loaded into the runtime */\n@@ -49,6 +49,11 @@ static void __objc_class_add_protocols (Class*, struct objc_protocol_list*);\n /* Is all categories/classes resolved? */\n BOOL __objc_dangling_categories = NO;\n \n+extern SEL\n+__sel_register_typed_name (const char *name, const char *types, \n+\t\t\t   struct objc_selector *orig);\n+\n+\n /* This function is called by constructor functions generated for each\n    module compiled.  (_GLOBAL_$I$...) The purpose of this function is to\n    gather the module pointers so that they may be processed by the\n@@ -70,7 +75,7 @@ __objc_exec_class (Module_t module)\n   struct objc_list** cell;\n \n   /* The table of selector references for this module */\n-  SEL *selectors = symtab->refs; \n+  SEL selectors = symtab->refs; \n \n   /* dummy counter */\n   int i;\n@@ -91,6 +96,19 @@ __objc_exec_class (Module_t module)\n   /* Save the module pointer for later processing. (not currently used) */\n   __objc_module_list = list_cons(module, __objc_module_list);\n \n+  /* Replace referenced selectors from names to SEL's.  */\n+  if (selectors)\n+    {\n+      for (i = 0; selectors[i].sel_id; ++i)\n+\t{\n+\t  const char *name, *type;\n+\t  name = (char*)selectors[i].sel_id;\n+\t  type = (char*)selectors[i].sel_types;\n+\t  __sel_register_typed_name (name, type, \n+\t\t\t\t     (struct objc_selector*)&(selectors[i]));\n+\t}\n+    }\n+\n   /* Parse the classes in the load module and gather selector information.  */\n   DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n@@ -117,13 +135,6 @@ __objc_exec_class (Module_t module)\n \t__objc_init_protocols (class->protocols);\n    }\n \n-  /* Replace referenced selectors from names to SEL's.  */\n-  if (selectors)\n-    {\n-      for (i = 0; selectors[i]; ++i)\n-\tselectors[i] = sel_register_name ((const char *) selectors[i]);\n-    }\n-\n   /* Process category information from the module.  */\n   for (i = 0; i < symtab->cat_def_cnt; ++i)\n     {\n@@ -166,7 +177,7 @@ __objc_exec_class (Module_t module)\n      categories to objects.  */\n   for (cell = &unclaimed_categories;\n        *cell;\n-       *cell && ((cell = &(*cell)->tail)))\n+       ({ if (*cell) cell = &(*cell)->tail; }))\n     {\n       Category_t category = (*cell)->head;\n       Class* class = objc_lookup_class (category->class_name);\n@@ -209,7 +220,7 @@ static void init_check_module_version(Module_t module)\n   if ((module->version != OBJC_VERSION) || (module->size != sizeof (Module)))\n     {\n       fprintf (stderr, \"Module %s version %d doesn't match runtime %d\\n\",\n-\t       module->name, module->version, OBJC_VERSION);\n+\t       module->name, (int)module->version, OBJC_VERSION);\n       if(module->version > OBJC_VERSION)\n \tfprintf (stderr, \"Runtime (libobjc.a) is out of date\\n\");\n       else if (module->version < OBJC_VERSION)\n@@ -255,7 +266,7 @@ __objc_init_protocols (struct objc_protocol_list* protos)\n \t{\n \t  fprintf (stderr,\n \t\t   \"Version %d doesn't match runtime protocol version %d\\n\",\n-\t\t   ((size_t)protos->list[i]->class_pointer),\n+\t\t   (int)((char*)protos->list[i]->class_pointer-(char*)0),\n \t\t   PROTOCOL_VERSION);\n \t  abort ();\n \t}"}, {"sha": "7137fdacf32ab23fbc7b1ba79feee1c4ff03474a", "filename": "gcc/objc/misc.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -30,6 +30,12 @@ void objc_error(id object, const char* fmt, va_list);\n \n void (*_objc_error)(id, const char*, va_list) = objc_error;\n \n+#ifdef __alpha__\n+#include <stdlib.h>\n+extern int write (int, const char*, int);\n+extern size_t strlen (const char*);\n+#endif\n+\n void\n objc_error(id object, const char* fmt, va_list ap)\n {\n@@ -40,7 +46,7 @@ objc_error(id object, const char* fmt, va_list ap)\n volatile void\n objc_fatal(const char* msg)\n {\n-  write(2, msg, (size_t)strlen((char*)msg));\n+  write(2, msg, (int)strlen((const char*)msg));\n   abort();\n }\n \n@@ -65,8 +71,12 @@ __objc_xrealloc(void* mem, size_t size)\n void*\n __objc_xcalloc(size_t nelem, size_t size)\n {\n-  void* res = (void*)calloc(nelem, size);\n+#ifdef __alpha__\n+  extern bzero (void *, size_t);\n+#endif\n+  void* res = (void*)malloc(nelem * size);\n   if(!res)\n     objc_fatal(\"Virtual memory exhausted\\n\");\n+  bzero (res, nelem * size);\n   return res;\n }"}, {"sha": "f94f9654a6807a063e9bb88f4787d605c62cb0b3", "filename": "gcc/objc/objc-api.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -44,8 +44,6 @@ struct objc_method_description\n     char *types;\t\t/* type encoding */\n };\n \n-\n-\n /* Filer types used to describe Ivars and Methods.  */\n #define _C_ID       '@'\n #define _C_CLASS    '#'\n@@ -92,7 +90,7 @@ extern BOOL objc_trace;\n */\n typedef struct objc_symtab {\n   unsigned long sel_ref_cnt;                     /* Unknown. */\n-  SEL       *refs;                              /* Unknown. */\n+  SEL        refs;                              /* Unknown. */\n   unsigned short cls_def_cnt;                   /* Number of classes compiled\n                                                   (defined) in the module. */\n   unsigned short cat_def_cnt;                   /* Number of categories \n@@ -146,7 +144,7 @@ typedef struct objc_ivar_list {\n     const char* ivar_type;                      /* Description of the Ivar's\n                                                   type.  Useful for \n                                                   debuggers. */\n-    int         ivar_offset;                    /* Byte offset from the base \n+    int        ivar_offset;                    /* Byte offset from the base \n                                                   address of the instance \n                                                   structure to the variable. */\n \n@@ -169,7 +167,7 @@ typedef struct objc_method_list {\n   struct objc_method_list*  method_next;      /* This variable is used to link \n                                                 a method list to another.  It \n                                                 is a singly linked list. */\n-  int             method_count;               /* Number of methods defined in \n+  int            method_count;               /* Number of methods defined in \n                                                 this structure. */\n   struct objc_method {\n     SEL         method_name;                  /* This variable is the method's \n@@ -303,12 +301,23 @@ Class* objc_get_class(const char *name);\n \n Class* objc_lookup_class(const char *name);\n \n+Class* objc_next_class(void **enum_state);\n+\n const char *sel_get_name(SEL selector);\n \n+const char *sel_get_type(SEL selector);\n+\n SEL sel_get_uid(const char *name);\n \n+SEL sel_get_any_uid(const char *name);\n+\n+SEL sel_get_typed_uid(const char *name, const char*);\n+\n SEL sel_register_name(const char *name);\n \n+SEL sel_register_typed_name(const char *name, const char*type);\n+\n+\n BOOL sel_is_mapped (SEL aSel);\n \n extern id class_create_instance(Class* class);"}, {"sha": "85d05852d4593f81c364876efea8588cd031f752", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -40,12 +40,24 @@ typedef char  BOOL;\n #define NO    (BOOL)0\n \n /*\n-** Definition of a selector.  Selectors are really of type unsigned int.\n-** The runtime does this mapping from SEL's to names internally in the\n-** sel_... operations.  You should never use the fact that it is actually\n-** an integer, since other Objective-C implementations use other conventions.\n+** Definition of a selector.  Selectors themselves are not unique, but\n+** the sel_id is a unique identifier.\n */\n-typedef void* SEL;\n+typedef const struct objc_selector \n+{\n+  void *sel_id;\n+  const char *sel_types;\n+} *SEL;\n+\n+inline static BOOL\n+sel_eq (SEL s1, SEL s2)\n+{\n+  if (s1 == 0 || s2 == 0)\n+    return s1 == s2;\n+  else\n+    return s1->sel_id == s2->sel_id;\n+}\n+\n \n /*\n ** ObjC uses this typedef for untyped instances.\n@@ -131,36 +143,8 @@ typedef union {\n } *arglist_t;\t\t\t/* argument frame */\n \n \n-#if defined(__OBJC__) \n-#include \"objc/sarray.h\"\n-\n-/*\n-  This is the function called when messages are send to nil.  You may\n-  set a breakpoint in your debugger at this function to catch messages\n-  too nil.\n-*/\n-extern id nil_method(id rcv, SEL op, ...);\n-\n-/*\n-  The messager is inlined, thus it is defined here directly.  The\n-  inlining is quite time-consuming when optimizing.  This will be\n-  taken care of later by hand-coding the messager in the compiler.\n-*/\n-extern __inline__ IMP\n-objc_msg_lookup(id receiver, SEL op)\n-{\n-  if(receiver)\n-    return sarray_get(receiver->class_pointer->dtable, (size_t)(op));\n-  else\n-    return nil_method;\n-}\n-\n-#else\n-\n IMP objc_msg_lookup(id receiver, SEL op);\n \n-#endif\n-\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "aad1610e4ce52700d6b8019131563e0d605e59d6", "filename": "gcc/objc/objects.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjects.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -43,7 +43,7 @@ class_create_instance(Class* class)\n     new = (*_objc_object_alloc)(class);\n   if (new!=nil)\n     {\n-      bzero (new, class->instance_size);\n+      memchr (new, 0, class->instance_size);\n       new->class_pointer = class;\n     }\n   return new;"}, {"sha": "224c4490011104478c56ff9cdf2a109a289abae0", "filename": "gcc/objc/runtime.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fruntime.h?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -61,12 +61,14 @@ extern BOOL __objc_class_links_resolved;\n extern int __objc_selector_max_index;\n \n #ifdef DEBUG\n-#define DEBUG_PRINTF printf\n+#define DEBUG_PRINTF(format, args...) printf (format, ## args)\n #else\n-#define DEBUG_PRINTF\n+#define DEBUG_PRINTF(format, args...)\n #endif \n \n BOOL __objc_responds_to (id object, SEL sel); /* for internal use only! */\n+SEL  __sel_register_typed_name (const char*, const char*, \n+\t\t\t\tstruct objc_selector*);\n \n #endif /* not __objc_runtime_INCLUDE_GNU */\n "}, {"sha": "78f5339596a1aa86dcf294f7ed6a664d02bbd7cb", "filename": "gcc/objc/sarray.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -40,6 +40,11 @@ const char* __objc_sparse2_id = \"2 level sparse indices\";\n const char* __objc_sparse3_id = \"3 level sparse indices\";\n #endif\n \n+#ifdef __alpha__\n+const void *memcpy (void*, const void*, size_t);\n+void free (const void*);\n+#endif\n+\n void\n sarray_at_put(struct sarray* array, sidx index, void* element)\n {\n@@ -117,7 +122,7 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n     /* The bucket was previously empty (or something like that), */\n     /* allocate a new.  This is the effect of `lazy' allocation */  \n     *the_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n-    memcpy( *the_bucket,array->empty_bucket, sizeof(struct sbucket));\n+    memcpy((void *) *the_bucket, (const void*)array->empty_bucket, sizeof(struct sbucket));\n     (*the_bucket)->version = array->version;\n     nbuckets += 1;\n "}, {"sha": "284967b264065d261e4cd51c498d9eb43892e5df", "filename": "gcc/objc/selector.c", "status": "modified", "additions": 151, "deletions": 20, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -31,7 +31,8 @@ You should have received a copy of the GNU General Public License along with\n #define SELECTOR_HASH_SIZE 128\n \n /* Tables mapping selector names to uid and opposite */\n-static struct sarray* __objc_selector_array = 0; /* uid -> name */\n+static struct sarray* __objc_selector_array = 0; /* uid -> sel */\n+static struct sarray* __objc_selector_names = 0; /* uid -> name */\n static cache_ptr      __objc_selector_hash  = 0; /* name -> uid */\n \n static void register_selectors_from_list(MethodList_t);\n@@ -42,6 +43,7 @@ int __objc_selector_max_index = 0;\n void __objc_init_selector_tables()\n {\n   __objc_selector_array = sarray_new (SELECTOR_HASH_SIZE, 0);\n+  __objc_selector_names = sarray_new (SELECTOR_HASH_SIZE, 0);\n   __objc_selector_hash\n     = hash_new (SELECTOR_HASH_SIZE,\n \t\t(hash_func_type) hash_string,\n@@ -78,62 +80,191 @@ register_selectors_from_list (MethodList_t method_list)\n   while (i < method_list->method_count)\n     {\n       Method_t method = &method_list->method_list[i];\n-      method->method_name = sel_register_name ((char*)method->method_name);\n+      method->method_name \n+\t= sel_register_typed_name ((const char*)method->method_name, \n+\t\t\t\t     method->method_types);\n       i += 1;\n     }\n }\n \n+/* return selector representing name */\n+SEL\n+sel_get_typed_uid (const char *name, const char *types)\n+{\n+  struct objc_list *l;\n+  sidx i;\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (i == 0)\n+    return 0;\n+\n+  for (l = (struct objc_list*)sarray_get (__objc_selector_array, i);\n+       l; l = l->tail)\n+    {\n+      SEL s = (SEL)l->head;\n+      if (types == 0 || s->sel_types == 0)\n+\t{\n+\t  if (s->sel_types == types)\n+\t    {\n+\t      return s;\n+\t    }\n+\t}\n+      else if (! strcmp (s->sel_types, types))\n+\t{\n+\t  return s;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* return selector representing name */\n+SEL\n+sel_get_any_uid (const char *name)\n+{\n+  struct objc_list *l;\n+  sidx i;\n+\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (soffset_decode (i) == 0)\n+    return 0;\n+\n+  l = (struct objc_list*)sarray_get (__objc_selector_array, i);\n+  if (l == 0)\n+    return 0;\n+\n+  return (SEL)l->head;\n+}\n+\n /* return selector representing name */\n SEL\n sel_get_uid (const char *name)\n {\n-  return (SEL) hash_value_for_key (__objc_selector_hash, name);\n+  return sel_register_typed_name (name, 0);\n }\n \n /* Get name of selector.  If selector is unknown, the empty string \"\" \n    is returned */ \n const char*\n sel_get_name (SEL selector)\n {\n-  if ((soffset_decode((sidx)selector) > 0)\n-      && (soffset_decode((sidx)selector) <= __objc_selector_max_index))\n-    return sarray_get (__objc_selector_array, (sidx) selector);\n+  if ((soffset_decode((sidx)selector->sel_id) > 0)\n+      && (soffset_decode((sidx)selector->sel_id) <= __objc_selector_max_index))\n+    return sarray_get (__objc_selector_array, (sidx) selector->sel_id);\n   else\n-    return NULL;\n+    return 0;\n }\n \n BOOL\n sel_is_mapped (SEL selector)\n {\n-  unsigned int idx = soffset_decode ((sidx)selector);\n+  unsigned int idx = soffset_decode ((sidx)selector->sel_id);\n   return ((idx > 0) && (idx <= __objc_selector_max_index));\n }\n \n+\n+const char*\n+sel_get_type (SEL selector)\n+{\n+  if (selector)\n+    return selector->sel_types;\n+  else\n+    return 0;\n+}\n+\n /* The uninstalled dispatch table */\n extern struct sarray* __objc_uninstalled_dtable;\n \n /* Store the passed selector name in the selector record and return its\n    selector value (value returned by sel_get_uid). */\n SEL\n-sel_register_name (const char *sel)\n+__sel_register_typed_name (const char *name, const char *types, \n+\t\t\t   struct objc_selector *orig)\n {\n-  SEL j;\n+  struct objc_selector* j;\n   sidx i;\n+  struct objc_list *l;\n \n-  if ((j = sel_get_uid ((const char *) sel)))\n-    return j;\n-\n-  /* Save the selector name.  */\n-  __objc_selector_max_index += 1;\n-  i = soffset_encode(__objc_selector_max_index);\n+  i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n+  if (soffset_decode (i) != 0)\n+    {\n+      for (l = (struct objc_list*)sarray_get (__objc_selector_array, i);\n+\t   l; l = l->tail)\n+\t{\n+\t  SEL s = (SEL)l->head;\n+\t  if (types == 0 || s->sel_types == 0)\n+\t    {\n+\t      if (s->sel_types == types)\n+\t\t{\n+\t\t  if (orig)\n+\t\t    {\n+\t\t      orig->sel_id = (void*)i;\n+\t\t      return orig;\n+\t\t    }\n+\t\t  else\n+\t\t    return s;\n+\t\t}\n+\t    }\n+\t  else if (strcmp (s->sel_types, types))\n+\t    {\n+\t      if (orig)\n+\t\t{\n+\t\t  orig->sel_id = (void*)i;\n+\t\t  return orig;\n+\t\t}\n+\t      else\n+\t\treturn s;\n+\t    }\n+\t}\n+      if (orig)\n+\tj = orig;\n+      else\n+\tj = __objc_xmalloc (sizeof (struct objc_selector));\n \n-  DEBUG_PRINTF (\"Record selector %s as: %#x\\n\", sel, i);\n+      j->sel_id = (void*)i;\n+      j->sel_types = (const char*)types;\n+      l = (struct objc_list*)sarray_get (__objc_selector_array, i);\n+    }\n+  else\n+    {\n+      __objc_selector_max_index += 1;\n+      i = soffset_encode(__objc_selector_max_index);\n+      if (orig)\n+\tj = orig;\n+      else\n+\tj = __objc_xmalloc (sizeof (struct objc_selector));\n+\t\n+      j->sel_id = (void*)i;\n+      j->sel_types = (const char*)types;\n+      l = 0;\n+    }\n \n-  sarray_at_put_safe (__objc_selector_array, i, (void *) sel);\n-  hash_add (&__objc_selector_hash, (void *) sel, (void *) i);\n+  DEBUG_PRINTF (\"Record selector %s[%s] as: %ld\\n\", name, types, \n+\t\tsoffset_decode (i));\n+  \n+  {\n+    int is_new = (l == 0);\n+    l = list_cons ((void*)j, l);\n+    sarray_at_put_safe (__objc_selector_names, i, (void *) name);\n+    sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n+    if (is_new)\n+      hash_add (&__objc_selector_hash, (void *) name, (void *) i);\n+  }\n \n   sarray_realloc(__objc_uninstalled_dtable, __objc_selector_max_index+1);\n \n-  return (SEL) i;\n+  return (SEL) j;\n+}\n+\n+SEL\n+sel_register_name (const char *name)\n+{\n+  return __sel_register_typed_name (name, 0, 0);\n+}\n+\n+SEL\n+sel_register_typed_name (const char *name, const char *type)\n+{\n+  return __sel_register_typed_name (name, type, 0);\n }\n "}, {"sha": "442ea0fc5ebc728785101f195027df4834337a45", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 124, "deletions": 40, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -24,10 +24,21 @@ You should have received a copy of the GNU General Public License along with\n    however invalidate any other reasons why the executable file might be\n    covered by the GNU General Public License.  */\n \n+#include \"../tconfig.h\"\n #include \"runtime.h\"\n #include \"sarray.h\"\n #include \"encoding.h\"\n \n+/* this is how we hack STRUCT_VALUE to be 1 or 0 */\n+#define gen_rtx(args...) 1\n+#define rtx int\n+\n+#if STRUCT_VALUE == 0\n+#define INVISIBLE_STRUCT_RETURN 1\n+#else\n+#define INVISIBLE_STRUCT_RETURN 0\n+#endif\n+\n /* The uninstalled dispatch table */\n struct sarray* __objc_uninstalled_dtable = 0;\n \n@@ -38,7 +49,14 @@ static void __objc_install_dispatch_table_for_class (Class*);\n \n /* Forward declare some functions */\n static void __objc_init_install_dtable(id, SEL);\n-static id __objc_missing_method(id, SEL, ...);\n+static id __objc_word_forward(id, SEL, ...);\n+typedef struct { id many[8]; } __big;\n+#if INVISIBLE_STRUCT_RETURN \n+static __big \n+#else\n+static id\n+#endif\n+__objc_block_forward(id, SEL, ...);\n static Method_t search_for_method_in_hierarchy (Class* class, SEL sel);\n static Method_t search_for_method_in_list(MethodList_t list, SEL op);\n id nil_method(id, SEL, ...);\n@@ -53,16 +71,34 @@ nil_method(id receiver, SEL op, ...)\n __inline__ IMP\n get_imp (Class* class, SEL sel)\n {\n-  void* res = sarray_get (class->dtable, (size_t) sel);\n+  IMP impl;\n+  void* res = sarray_get (class->dtable, (size_t) sel->sel_id);\n   if(res == __objc_init_install_dtable)\n-    __objc_install_dispatch_table_for_class (class);\n-  return sarray_get (class->dtable, (size_t) sel);\n+    {\n+      __objc_install_dispatch_table_for_class (class);\n+      res = sarray_get (class->dtable, (size_t) sel->sel_id);\n+    }\n+  if (res == 0)\n+    {\n+      const char *t = sel->sel_types;\n+      if (t && (*t == '[' || *t == '(' || *t == '{'))\n+\tres = (IMP)__objc_block_forward;\n+      else\n+\tres = (IMP)__objc_word_forward;\n+    }\n+  return res;\n }\n \n __inline__ BOOL\n __objc_responds_to (id object, SEL sel)\n {\n-  return get_imp (object->class_pointer, sel) != __objc_missing_method;\n+  void* res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);\n+  if(res == __objc_init_install_dtable)\n+    {\n+      __objc_install_dispatch_table_for_class (object->class_pointer);\n+      res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);\n+    }\n+  return (res != 0);\n }\n \n /* This is the lookup function.  All entries in the table are either a \n@@ -72,8 +108,20 @@ __objc_responds_to (id object, SEL sel)\n __inline__ IMP\n objc_msg_lookup(id receiver, SEL op)\n {\n+  IMP result;\n   if(receiver)\n-    return sarray_get(receiver->class_pointer->dtable, (sidx)op);\n+    {\n+      result = sarray_get(receiver->class_pointer->dtable, (sidx)op->sel_id);\n+      if (result == 0)\n+\t{\n+\t  const char *t = op->sel_types;\n+\t  if (t && (*t == '[' || *t == '(' || *t == '{'))\n+\t    result = (IMP)__objc_block_forward;\n+\t  else\n+\t    result = (IMP)__objc_word_forward;\n+\t}\n+      return result;\n+    }\n   else\n     return nil_method;\n }\n@@ -87,6 +135,8 @@ objc_msg_lookup_super (Super_t super, SEL sel)\n     return nil_method;\n }\n \n+int method_get_sizeof_arguments (Method*);\n+\n retval_t\n objc_msg_sendv(id object, SEL op, arglist_t arg_frame)\n {\n@@ -141,8 +191,8 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n \n       /* Install real dtable for factory methods */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n-      \n-      if(op != sel_get_uid (\"initialize\"))\n+\n+      if (strcmp (sel_get_name (op), \"initialize\"))\n \t__objc_send_initialize((Class*)receiver);\n       else\n \tCLS_SETINITIALIZED((Class*)receiver);\n@@ -155,7 +205,10 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n \n   args = __builtin_apply_args();\n   result = __builtin_apply((apply_t)imp, args, 96);\n-  __builtin_return (result);\n+  if (result)\n+    __builtin_return (result);\n+  else\n+    return;\n   \n }\n \n@@ -170,8 +223,6 @@ void __objc_install_premature_dtable(Class* class)\n /* Send +initialize to class if not already done */\n static void __objc_send_initialize(Class* class)\n {\n-  Method_t m;\n-\n   /* This *must* be a class object */\n   assert(CLS_ISCLASS(class));\n   assert(!CLS_ISMETA(class));\n@@ -199,7 +250,7 @@ static void __objc_send_initialize(Class* class)\n \t\tMethod_t method = &method_list->method_list[i];\n \t\t\n \t\t\n-\t\tif (method->method_name == op)\n+\t\tif (method->method_name->sel_id == op->sel_id)\n \t\t  (*method->method_imp)((id) class, op);\n \t      }\n \n@@ -231,8 +282,7 @@ __objc_install_dispatch_table_for_class (Class* class)\n   /* Allocate dtable if nessecary */\n   if (super == 0)\n     {\n-      class->dtable = sarray_new (__objc_selector_max_index,\n-\t\t\t\t  __objc_missing_method);\n+      class->dtable = sarray_new (__objc_selector_max_index, 0);\n     }\n   else\n     class->dtable = sarray_lazy_copy (super->dtable);\n@@ -244,7 +294,7 @@ __objc_install_dispatch_table_for_class (Class* class)\n         {\n           Method_t method = &(mlist->method_list[counter]);\n \t  sarray_at_put_safe (class->dtable,\n-\t\t\t      (sidx) method->method_name,\n+\t\t\t      (sidx) method->method_name->sel_id,\n \t\t\t      method->method_imp);\n           counter -= 1;\n         }\n@@ -254,7 +304,6 @@ __objc_install_dispatch_table_for_class (Class* class)\n void __objc_update_dispatch_table_for_class (Class* class)\n {\n   Class* next;\n-  struct sarray* save;\n \n   /* not yet installed -- skip it */\n   if (class->dtable == __objc_uninstalled_dtable) \n@@ -297,10 +346,12 @@ class_add_method_list (Class* class, MethodList_t list)\n       if (method->method_name)  /* Sometimes these are NULL */\n \t{\n \t  /* This is where selector names are transmogriffed to SEL's */\n-\t  method->method_name = sel_register_name ((char*)method->method_name);\n+\t  method->method_name = \n+\t    sel_register_typed_name ((const char*)method->method_name,\n+\t\t\t\t     method->method_types);\n \n \t  if (search_for_method_in_list (class->methods, method->method_name)\n-\t      && method->method_name != initialize_sel)\n+\t      && method->method_name->sel_id != initialize_sel->sel_id)\n \t    {\n \t      /* Duplication. Print a error message an change the method name\n \t\t to NULL. */\n@@ -375,7 +426,7 @@ search_for_method_in_list (MethodList_t list, SEL op)\n           Method_t method = &method_list->method_list[i];\n \n           if (method->method_name)\n-            if (method->method_name == op)\n+            if (method->method_name->sel_id == op->sel_id)\n               return method;\n         }\n \n@@ -387,51 +438,84 @@ search_for_method_in_list (MethodList_t list, SEL op)\n   return NULL;\n }\n \n+static retval_t __objc_forward (id object, SEL sel, arglist_t args);\n+\n+static id\n+__objc_word_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  if (res)\n+    __builtin_return (res);\n+  else\n+    return res;\n+}\n+\n+#if INVISIBLE_STRUCT_RETURN\n+static __big\n+#else\n+static id\n+#endif\n+__objc_block_forward (id rcv, SEL op, ...)\n+{\n+  void *args, *res;\n+\n+  args = __builtin_apply_args ();\n+  res = __objc_forward (rcv, op, args);\n+  if (res)\n+    __builtin_return (res);\n+}\n+\n \n /* This fuction is installed in the dispatch table for all methods which are\n    not implemented.  Thus, it is called when a selector is not recognized. */\n-static id\n-__objc_missing_method (id object, SEL sel, ...)\n+static retval_t\n+__objc_forward (id object, SEL sel, arglist_t args)\n {\n   IMP imp;\n-  SEL frwd_sel;\n+  static SEL frwd_sel = 0;\n   SEL err_sel;\n \n   /* first try if the object understands forward:: */\n-  frwd_sel = sel_get_uid(\"forward::\");\n-  imp = get_imp(object->class_pointer, frwd_sel);\n-  if(imp != __objc_missing_method)\n+  if (!frwd_sel)\n+    frwd_sel = sel_get_any_uid(\"forward::\");\n+\n+  if (__objc_responds_to (object, frwd_sel))\n     {\n-      void *result, *args = __builtin_apply_args();\n-      result = (*imp)(object, frwd_sel, sel, args);\n-      __builtin_return(result);\n+      imp = get_imp(object->class_pointer, frwd_sel);\n+      return (*imp)(object, frwd_sel, sel, args);\n     }\n \n   /* If the object recognizes the doesNotRecognize: method then we're going\n      to send it. */\n-  err_sel = sel_get_uid (\"doesNotRecognize:\");\n-  imp = get_imp (object->class_pointer, err_sel);\n-  if (imp != __objc_missing_method)\n+  err_sel = sel_get_any_uid (\"doesNotRecognize:\");\n+  if (__objc_responds_to (object, err_sel))\n     {\n+      imp = get_imp (object->class_pointer, err_sel);\n       return (*imp) (object, err_sel, sel);\n     }\n   \n   /* The object doesn't recognize the method.  Check for responding to\n      error:.  If it does then sent it. */\n   {\n-    char msg[256 + strlen ((char*)sel_get_name (sel))\n-             + strlen ((char*)object->class_pointer->name)];\n+    size_t strlen (const char*);\n+    char msg[256 + strlen ((const char*)sel_get_name (sel))\n+             + strlen ((const char*)object->class_pointer->name)];\n \n     sprintf (msg, \"(%s) %s does not recognize %s\",\n \t     (CLS_ISMETA(object->class_pointer)\n \t      ? \"class\"\n \t      : \"instance\" ),\n              object->class_pointer->name, sel_get_name (sel));\n \n-    err_sel = sel_get_uid (\"error:\");\n-    imp = get_imp (object->class_pointer, err_sel);\n-    if (imp != __objc_missing_method)\n-      return (*imp) (object, sel_get_uid (\"error:\"), msg);\n+    err_sel = sel_get_any_uid (\"error:\");\n+    if (__objc_responds_to (object, err_sel))\n+      {\n+\timp = get_imp (object->class_pointer, err_sel);\n+\treturn (*imp) (object, sel_get_any_uid (\"error:\"), msg);\n+      }\n \n     /* The object doesn't respond to doesNotRecognize: or error:;  Therefore,\n        a default action is taken. */\n@@ -451,12 +535,12 @@ void __objc_print_dtable_stats()\n #endif\n \t );\n \n-  printf(\"arrays: %d = %d bytes\\n\", narrays, narrays*sizeof(struct sarray));\n+  printf(\"arrays: %d = %ld bytes\\n\", narrays, (int)narrays*sizeof(struct sarray));\n   total += narrays*sizeof(struct sarray);\n-  printf(\"buckets: %d = %d bytes\\n\", nbuckets, nbuckets*sizeof(struct sbucket));\n+  printf(\"buckets: %d = %ld bytes\\n\", nbuckets, (int)nbuckets*sizeof(struct sbucket));\n   total += nbuckets*sizeof(struct sbucket);\n \n-  printf(\"idxtables: %d = %d bytes\\n\", idxsize, idxsize*sizeof(void*));\n+  printf(\"idxtables: %d = %ld bytes\\n\", idxsize, (int)idxsize*sizeof(void*));\n   total += idxsize*sizeof(void*);\n   printf(\"-----------------------------------\\n\");\n   printf(\"total: %d bytes\\n\", total);"}, {"sha": "f3d7cd987cb9fbb5861082c2e972ce11f1e6ad4e", "filename": "gcc/objc/typedstream.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Ftypedstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39d31bc0c617e5bc7e57e513ba165e00ed46580/gcc%2Fobjc%2Ftypedstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Ftypedstream.h?ref=a39d31bc0c617e5bc7e57e513ba165e00ed46580", "patch": "@@ -30,8 +30,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"objc/hash.h\"\n #include <stdio.h>\n \n-#ifndef __alpha__\t\t/* alpha is currently not supported */\n-\n typedef int (*objc_typed_read_func)(void*, char*, int);\n typedef int (*objc_typed_write_func)(void*, const char*, int);\n typedef int (*objc_typed_flush_func)(void*);\n@@ -100,7 +98,7 @@ int objc_read_types (TypedStream* stream, const char* type, ...);\n int objc_write_object_reference (TypedStream* stream, id object);\n int objc_write_root_object (TypedStream* stream, id object);\n \n-int objc_get_stream_class_version (TypedStream* stream, Class* class);\n+long objc_get_stream_class_version (TypedStream* stream, Class* class);\n \n \n /*\n@@ -130,6 +128,4 @@ void objc_close_typed_stream (TypedStream* stream);\n BOOL objc_end_of_typed_stream (TypedStream* stream);\n void objc_flush_typed_stream (TypedStream* stream);\n \n-#endif /* __alpha__ */\n-\n #endif /* not __typedstream_INCLUDE_GNU */"}]}