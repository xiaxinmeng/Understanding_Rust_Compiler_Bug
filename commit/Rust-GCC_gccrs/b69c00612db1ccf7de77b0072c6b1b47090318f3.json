{"sha": "b69c00612db1ccf7de77b0072c6b1b47090318f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5YzAwNjEyZGIxY2NmN2RlNzdiMDA3MmM2YjFiNDcwOTAzMThmMw==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2020-09-16T14:43:31Z"}, "committer": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2020-10-22T14:46:23Z"}, "message": "[PATCH, rs6000] VSX load/store rightmost element operations\n\nHi,\n  This adds support for the VSX load/store rightmost element operations.\n  This includes the instructions lxvrbx, lxvrhx, lxvrwx, lxvrdx,\n  stxvrbx, stxvrhx, stxvrwx, stxvrdx; And the builtins\n  vec_xl_sext() /* vector load sign extend */\n  vec_xl_zext() /* vector load zero extend */\n  vec_xst_trunc() /* vector store truncate */.\n\n  Testcase results show that the instructions added with this patch show\n  up at low/no optimization (-O0), with a number of those being replaced\n  with other load and store instructions at higher optimization levels.\n  For consistency I've left the tests at -O0.\n\n  [v2] Refreshed per review comments.  Comments cleaned up, indentation\n  corrected.\n\n\ngcc/ChangeLog:\n\t* config/rs6000/altivec.h (vec_xl_zext, vec_xl_sext, vec_xst_trunc):\n\tNew defines.\n\t* config/rs6000/rs6000-builtin.def (BU_P10V_OVERLOAD_X): New builtin\n\tmacro.\n\t(BU_P10V_AV_X): New builtin macro.\n\t(se_lxvrhbx, se_lxrbhx, se_lxvrwx, se_lxvrdx): Define internal names\n\tfor load and sign extend vector element.\n\t(ze_lxvrbx, ze_lxvrhx, ze_lxvrwx, ze_lxvrdx): Define internal names\n\tfor load and zero extend vector element.\n\t(tr_stxvrbx, tr_stxvrhx, tr_stxvrwx, tr_stxvrdx): Define internal names\n\tfor truncate and store vector element.\n\t(se_lxvrx, ze_lxvrx, tr_stxvrx): Define internal names for overloaded\n\tload/store rightmost element.\n\t* config/rs6000/rs6000-call.c (altivec_builtin_types): Define the\n\tinternal monomorphs P10_BUILTIN_SE_LXVRBX, P10_BUILTIN_SE_LXVRHX,\n\tP10_BUILTIN_SE_LXVRWX, P10_BUILTIN_SE_LXVRDX,\n\tP10_BUILTIN_ZE_LXVRBX, P10_BUILTIN_ZE_LXVRHX, P10_BUILTIN_ZE_LXVRWX,\n\tP10_BUILTIN_ZE_LXVRDX,\n\tP10_BUILTIN_TR_STXVRBX, P10_BUILTIN_TR_STXVRHX, P10_BUILTIN_TR_STXVRWX,\n\tP10_BUILTIN_TR_STXVRDX,\n\t(altivec_expand_lxvr_builtin): New expansion for load element builtins.\n\t(altivec_expand_stv_builtin): Update to for truncate and store builtins.\n\t(altivec_expand_builtin): Add clases for load/store rightmost builtins.\n\t(altivec_init_builtins): Add def_builtin entries for\n\t__builtin_altivec_se_lxvrbx, __builtin_altivec_se_lxvrhx,\n\t__builtin_altivec_se_lxvrwx, __builtin_altivec_se_lxvrdx,\n\t__builtin_altivec_ze_lxvrbx, __builtin_altivec_ze_lxvrhx,\n\t__builtin_altivec_ze_lxvrwx, __builtin_altivec_ze_lxvrdx,\n\t__builtin_altivec_tr_stxvrbx, __builtin_altivec_tr_stxvrhx,\n\t__builtin_altivec_tr_stxvrwx, __builtin_altivec_tr_stxvrdx,\n\t__builtin_vec_se_lxvrx, __builtin_vec_ze_lxvrx, __builtin_vec_tr_stxvrx.\n\t* config/rs6000/vsx.md (vsx_lxvr<wd>x, vsx_stxvr<wd>x, vsx_stxvr<wd>x):\n\tNew define_insn entries.\n\t* doc/extend.texi:  Add documentation for vsx_xl_sext, vsx_xl_zext,\n\tand vec_xst_trunc.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.target/powerpc/vsx-load-element-extend-char.c: New test.\n\t* gcc.target/powerpc/vsx-load-element-extend-int.c: New test.\n\t* gcc.target/powerpc/vsx-load-element-extend-longlong.c: New test.\n\t* gcc.target/powerpc/vsx-load-element-extend-short.c: New test.\n\t* gcc.target/powerpc/vsx-store-element-truncate-char.c: New test.\n\t* gcc.target/powerpc/vsx-store-element-truncate-int.c: New test.\n\t* gcc.target/powerpc/vsx-store-element-truncate-longlong.c: New test.\n\t* gcc.target/powerpc/vsx-store-element-truncate-short.c: New test.", "tree": {"sha": "928b151aa655da239eff1df25927e17be0427654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/928b151aa655da239eff1df25927e17be0427654"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b69c00612db1ccf7de77b0072c6b1b47090318f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69c00612db1ccf7de77b0072c6b1b47090318f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69c00612db1ccf7de77b0072c6b1b47090318f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69c00612db1ccf7de77b0072c6b1b47090318f3/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8732511910e1dd23c56c01e876bbe235c360ac55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8732511910e1dd23c56c01e876bbe235c360ac55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8732511910e1dd23c56c01e876bbe235c360ac55"}], "stats": {"total": 1469, "additions": 1468, "deletions": 1}, "files": [{"sha": "df10a8c498dd5393d319a788c4a17c44534ced8e", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -236,6 +236,9 @@\n #define vec_lvebx __builtin_vec_lvebx\n #define vec_lvehx __builtin_vec_lvehx\n #define vec_lvewx __builtin_vec_lvewx\n+#define vec_xl_zext __builtin_vec_ze_lxvrx\n+#define vec_xl_sext __builtin_vec_se_lxvrx\n+#define vec_xst_trunc __builtin_vec_tr_stxvrx\n #define vec_neg __builtin_vec_neg\n #define vec_pmsum_be __builtin_vec_vpmsum\n #define vec_shasigma_be __builtin_crypto_vshasigma"}, {"sha": "5b05da87f4bf4ece3936c3766c8b63e3de4ed6f0", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -1145,6 +1145,14 @@\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n #endif\n \n+#define BU_P10V_OVERLOAD_X(ENUM, NAME)\t\t\t\t\\\n+  RS6000_BUILTIN_X (P10_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P10,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_OVERLOADED\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_SPECIAL),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n /* Power 10 Altivec builtins  */\n \n #define BU_P10V_AV_0(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n@@ -1179,6 +1187,15 @@\n \t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n+#define BU_P10V_AV_X(ENUM, NAME, ATTR)\t\t\t\t\t\\\n+  RS6000_BUILTIN_X (P10_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_altivec_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P10,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_SPECIAL),\t\t\t\t\\\n+\t\t    CODE_FOR_nothing)\t\t\t/* ICODE */\n+\n+\n \f\n /* Insure 0 is not a legitimate index.  */\n BU_SPECIAL_X (RS6000_BUILTIN_NONE, NULL, 0, RS6000_BTC_MISC)\n@@ -1474,6 +1491,18 @@ BU_ALTIVEC_X (LVSR,\t\t\"lvsr\",\t\t    PURE)\n BU_ALTIVEC_X (LVEBX,\t\t\"lvebx\",\t    PURE)\n BU_ALTIVEC_X (LVEHX,\t\t\"lvehx\",\t    PURE)\n BU_ALTIVEC_X (LVEWX,\t\t\"lvewx\",\t    PURE)\n+BU_P10V_AV_X (SE_LXVRBX,\t\"se_lxvrbx\",\t    PURE)\n+BU_P10V_AV_X (SE_LXVRHX,\t\"se_lxvrhx\",\t    PURE)\n+BU_P10V_AV_X (SE_LXVRWX,\t\"se_lxvrwx\",\t    PURE)\n+BU_P10V_AV_X (SE_LXVRDX,\t\"se_lxvrdx\",\t    PURE)\n+BU_P10V_AV_X (ZE_LXVRBX,\t\"ze_lxvrbx\",\t    PURE)\n+BU_P10V_AV_X (ZE_LXVRHX,\t\"ze_lxvrhx\",\t    PURE)\n+BU_P10V_AV_X (ZE_LXVRWX,\t\"ze_lxvrwx\",\t    PURE)\n+BU_P10V_AV_X (ZE_LXVRDX,\t\"ze_lxvrdx\",\t    PURE)\n+BU_P10V_AV_X (TR_STXVRBX,\t\"tr_stxvrbx\",\t    MEM)\n+BU_P10V_AV_X (TR_STXVRHX,\t\"tr_stxvrhx\",\t    MEM)\n+BU_P10V_AV_X (TR_STXVRWX,\t\"tr_stxvrwx\",\t    MEM)\n+BU_P10V_AV_X (TR_STXVRDX,\t\"tr_stxvrdx\",\t    MEM)\n BU_ALTIVEC_X (LVXL,\t\t\"lvxl\",\t\t    PURE)\n BU_ALTIVEC_X (LVXL_V2DF,\t\"lvxl_v2df\",\t    PURE)\n BU_ALTIVEC_X (LVXL_V2DI,\t\"lvxl_v2di\",\t    PURE)\n@@ -1740,6 +1769,9 @@ BU_ALTIVEC_OVERLOAD_X (LDL,\t   \"ldl\")\n BU_ALTIVEC_OVERLOAD_X (LVEBX,\t   \"lvebx\")\n BU_ALTIVEC_OVERLOAD_X (LVEHX,\t   \"lvehx\")\n BU_ALTIVEC_OVERLOAD_X (LVEWX,\t   \"lvewx\")\n+BU_P10V_OVERLOAD_X (SE_LXVRX,   \"se_lxvrx\")\n+BU_P10V_OVERLOAD_X (ZE_LXVRX,   \"ze_lxvrx\")\n+BU_P10V_OVERLOAD_X (TR_STXVRX,  \"tr_stxvrx\")\n BU_ALTIVEC_OVERLOAD_X (LVLX,\t   \"lvlx\")\n BU_ALTIVEC_OVERLOAD_X (LVLXL,\t   \"lvlxl\")\n BU_ALTIVEC_OVERLOAD_X (LVRX,\t   \"lvrx\")"}, {"sha": "b044778a7ae427b109f5cbc08282cb7ab2a0ecb6", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 207, "deletions": 1, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -1152,6 +1152,65 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { ALTIVEC_BUILTIN_VEC_LVEBX, ALTIVEC_BUILTIN_LVEBX,\n     RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },\n \n+  /* vector signed__int128 vec_xl_sext (signed long long, signed char *);\n+     vector signed__int128 vec_xl_sext (signed long long, signed short *);\n+     vector signed__int128 vec_xl_sext (signed long long, signed int *);\n+     vector signed__int128 vec_xl_sext (signed long long, signed longlong *); */\n+  { P10_BUILTIN_VEC_SE_LXVRX, P10_BUILTIN_SE_LXVRBX,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI, 0 },\n+  { P10_BUILTIN_VEC_SE_LXVRX, P10_BUILTIN_SE_LXVRHX,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI, 0 },\n+  { P10_BUILTIN_VEC_SE_LXVRX, P10_BUILTIN_SE_LXVRWX,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI, 0 },\n+  { P10_BUILTIN_VEC_SE_LXVRX, P10_BUILTIN_SE_LXVRDX,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTDI, 0 },\n+  { P10_BUILTIN_VEC_SE_LXVRX, P10_BUILTIN_SE_LXVRDX,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long, 0 },\n+\n+  /* vector unsigned__int128 vec_xl_zext (signed long long, unsigned char *);\n+     vector unsigned__int128 vec_xl_zext (signed long long, unsigned short *);\n+     vector unsigned__int128 vec_xl_zext (signed long long, unsigned int *);\n+     vector unsigned__int128 vec_xl_zext (signed long long, unsigned longlong *); */\n+  { P10_BUILTIN_VEC_ZE_LXVRX, P10_BUILTIN_ZE_LXVRBX,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI, 0 },\n+  { P10_BUILTIN_VEC_ZE_LXVRX, P10_BUILTIN_ZE_LXVRHX,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI, 0 },\n+  { P10_BUILTIN_VEC_ZE_LXVRX, P10_BUILTIN_ZE_LXVRWX,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI, 0 },\n+  { P10_BUILTIN_VEC_ZE_LXVRX, P10_BUILTIN_ZE_LXVRDX,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTDI, 0 },\n+  { P10_BUILTIN_VEC_ZE_LXVRX, P10_BUILTIN_ZE_LXVRDX,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_long_long, 0 },\n+\n+  /* void vec_xst_trunc (vector signed __int128, signed long long, signed char *);\n+     void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned char *);\n+     void vec_xst_trunc (vector signed __int128, signed long long, signed char *);\n+     void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned char *);\n+     void vec_xst_trunc (vector signed __int128, signed long long, signed char *);\n+     void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned char *);\n+     void vec_xst_trunc (vector signed __int128, signed long long, signed char *);\n+     void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned char *); */\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRBX, RS6000_BTI_void,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTQI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRBX, RS6000_BTI_void,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTQI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRHX, RS6000_BTI_void,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTHI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRHX, RS6000_BTI_void,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTHI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRWX, RS6000_BTI_void,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTSI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRWX, RS6000_BTI_void,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTSI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRDX, RS6000_BTI_void,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_long_long },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRDX, RS6000_BTI_void,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_unsigned_long_long },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRDX, RS6000_BTI_void,\n+    RS6000_BTI_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_INTDI },\n+  { P10_BUILTIN_VEC_TR_STXVRX, P10_BUILTIN_TR_STXVRDX, RS6000_BTI_void,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_INTSI, ~RS6000_BTI_UINTDI },\n+\n   /*     vector float vec_ldl (int, vector float *);\n          vector float vec_ldl (int, float *); */\n   { ALTIVEC_BUILTIN_VEC_LDL, ALTIVEC_BUILTIN_LVXL_V4SF,\n@@ -9574,6 +9633,85 @@ swap_endian_selector_for_mode (machine_mode mode)\n \t\t\t\t\t\t     gen_rtvec_v (16, perm)));\n }\n \n+/* For the load and sign extend rightmost elements; load and zero extend\n+ rightmost element builtins.  */\n+static rtx\n+altivec_expand_lxvr_builtin (enum insn_code icode, tree exp, rtx target, bool blk, bool sign_extend)\n+{\n+  rtx pat, addr;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  tree arg1 = CALL_EXPR_ARG (exp, 1);\n+  machine_mode tmode = insn_data[icode].operand[0].mode;\n+  machine_mode smode = insn_data[icode].operand[1].mode;\n+  machine_mode mode0 = Pmode;\n+  machine_mode mode1 = Pmode;\n+  rtx op0 = expand_normal (arg0);\n+  rtx op1 = expand_normal (arg1);\n+\n+  if (icode == CODE_FOR_nothing)\n+    /* Builtin not supported on this processor.  */\n+    return 0;\n+\n+  /* If we got invalid arguments bail out before generating bad rtl.  */\n+  if (arg0 == error_mark_node || arg1 == error_mark_node)\n+    return const0_rtx;\n+\n+  if (target == 0\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  op1 = copy_to_mode_reg (mode1, op1);\n+\n+  if (op0 == const0_rtx)\n+    addr = gen_rtx_MEM (blk ? BLKmode : tmode, op1);\n+  else\n+    {\n+      op0 = copy_to_mode_reg (mode0, op0);\n+      addr = gen_rtx_MEM (blk ? BLKmode : smode,\n+\t\t\t  gen_rtx_PLUS (Pmode, op1, op0));\n+    }\n+\n+  if (sign_extend)\n+    {\n+      rtx discratch = gen_reg_rtx (DImode);\n+      rtx tiscratch = gen_reg_rtx (TImode);\n+\n+      /* Emit the lxvr*x insn.  */\n+      pat = GEN_FCN (icode) (tiscratch, addr);\n+      if (!pat)\n+\treturn 0;\n+      emit_insn (pat);\n+\n+      /* Emit a sign extension from QI,HI,WI to double (DI).  */\n+      rtx scratch = gen_lowpart (smode, tiscratch);\n+      if (icode == CODE_FOR_vsx_lxvrbx)\n+\temit_insn (gen_extendqidi2 (discratch, scratch));\n+      else if (icode == CODE_FOR_vsx_lxvrhx)\n+\temit_insn (gen_extendhidi2 (discratch, scratch));\n+      else if (icode == CODE_FOR_vsx_lxvrwx)\n+\temit_insn (gen_extendsidi2 (discratch, scratch));\n+      /*  Assign discratch directly if scratch is already DI.  */\n+      if (icode == CODE_FOR_vsx_lxvrdx)\n+\tdiscratch = scratch;\n+\n+      /* Emit the sign extension from DI (double) to TI (quad).  */\n+      emit_insn (gen_extendditi2 (target, discratch));\n+\n+      return target;\n+    }\n+  else\n+    {\n+      /* Zero extend.  */\n+      pat = GEN_FCN (icode) (target, addr);\n+      if (!pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+    }\n+  return 0;\n+}\n+\n static rtx\n altivec_expand_lv_builtin (enum insn_code icode, tree exp, rtx target, bool blk)\n {\n@@ -9692,7 +9830,7 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n-  rtx pat, addr, rawaddr;\n+  rtx pat, addr, rawaddr, truncrtx;\n   machine_mode tmode = insn_data[icode].operand[0].mode;\n   machine_mode smode = insn_data[icode].operand[1].mode;\n   machine_mode mode1 = Pmode;\n@@ -9731,6 +9869,25 @@ altivec_expand_stv_builtin (enum insn_code icode, tree exp)\n \n       emit_insn (gen_rtx_SET (addr, op0));\n     }\n+  else if (icode == CODE_FOR_vsx_stxvrbx\n+\t   || icode == CODE_FOR_vsx_stxvrhx\n+\t   || icode == CODE_FOR_vsx_stxvrwx\n+\t   || icode == CODE_FOR_vsx_stxvrdx)\n+    {\n+      truncrtx = gen_rtx_TRUNCATE (tmode, op0);\n+      op0 = copy_to_mode_reg (E_TImode, truncrtx);\n+\n+      if (op1 == const0_rtx)\n+\taddr = gen_rtx_MEM (Pmode, op2);\n+      else\n+\t{\n+\t  op1 = copy_to_mode_reg (mode1, op1);\n+\t  addr = gen_rtx_MEM (tmode, gen_rtx_PLUS (Pmode, op2, op1));\n+\t}\n+      pat = GEN_FCN (icode) (addr, op0);\n+      if (pat)\n+\temit_insn (pat);\n+    }\n   else\n     {\n       if (! (*insn_data[icode].operand[1].predicate) (op0, smode))\n@@ -10750,6 +10907,16 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvehx, exp);\n     case ALTIVEC_BUILTIN_STVEWX:\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvewx, exp);\n+\n+    case P10_BUILTIN_TR_STXVRBX:\n+      return altivec_expand_stv_builtin (CODE_FOR_vsx_stxvrbx, exp);\n+    case P10_BUILTIN_TR_STXVRHX:\n+      return altivec_expand_stv_builtin (CODE_FOR_vsx_stxvrhx, exp);\n+    case P10_BUILTIN_TR_STXVRWX:\n+      return altivec_expand_stv_builtin (CODE_FOR_vsx_stxvrwx, exp);\n+    case P10_BUILTIN_TR_STXVRDX:\n+      return altivec_expand_stv_builtin (CODE_FOR_vsx_stxvrdx, exp);\n+\n     case ALTIVEC_BUILTIN_STVXL_V2DF:\n       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvxl_v2df, exp);\n     case ALTIVEC_BUILTIN_STVXL_V2DI:\n@@ -11012,6 +11179,30 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_LVEWX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvewx,\n \t\t\t\t\texp, target, false);\n+    case P10_BUILTIN_SE_LXVRBX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrbx,\n+\t\t\t\t\texp, target, false, true);\n+    case P10_BUILTIN_SE_LXVRHX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrhx,\n+\t\t\t\t\texp, target, false, true);\n+    case P10_BUILTIN_SE_LXVRWX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrwx,\n+\t\t\t\t\texp, target, false, true);\n+    case P10_BUILTIN_SE_LXVRDX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrdx,\n+\t\t\t\t\texp, target, false, true);\n+    case P10_BUILTIN_ZE_LXVRBX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrbx,\n+\t\t\t\t\texp, target, false, false);\n+    case P10_BUILTIN_ZE_LXVRHX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrhx,\n+\t\t\t\t\texp, target, false, false);\n+    case P10_BUILTIN_ZE_LXVRWX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrwx,\n+\t\t\t\t\texp, target, false, false);\n+    case P10_BUILTIN_ZE_LXVRDX:\n+      return altivec_expand_lxvr_builtin (CODE_FOR_vsx_lxvrdx,\n+\t\t\t\t\texp, target, false, false);\n     case ALTIVEC_BUILTIN_LVXL_V2DF:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v2df,\n \t\t\t\t\texp, target, false);\n@@ -13294,6 +13485,18 @@ altivec_init_builtins (void)\n   def_builtin (\"__builtin_altivec_lvebx\", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEBX);\n   def_builtin (\"__builtin_altivec_lvehx\", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEHX);\n   def_builtin (\"__builtin_altivec_lvewx\", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVEWX);\n+  def_builtin (\"__builtin_altivec_se_lxvrbx\", v16qi_ftype_long_pcvoid, P10_BUILTIN_SE_LXVRBX);\n+  def_builtin (\"__builtin_altivec_se_lxvrhx\", v8hi_ftype_long_pcvoid, P10_BUILTIN_SE_LXVRHX);\n+  def_builtin (\"__builtin_altivec_se_lxvrwx\", v4si_ftype_long_pcvoid, P10_BUILTIN_SE_LXVRWX);\n+  def_builtin (\"__builtin_altivec_se_lxvrdx\", v2di_ftype_long_pcvoid, P10_BUILTIN_SE_LXVRDX);\n+  def_builtin (\"__builtin_altivec_ze_lxvrbx\", v16qi_ftype_long_pcvoid, P10_BUILTIN_ZE_LXVRBX);\n+  def_builtin (\"__builtin_altivec_ze_lxvrhx\", v8hi_ftype_long_pcvoid, P10_BUILTIN_ZE_LXVRHX);\n+  def_builtin (\"__builtin_altivec_ze_lxvrwx\", v4si_ftype_long_pcvoid, P10_BUILTIN_ZE_LXVRWX);\n+  def_builtin (\"__builtin_altivec_ze_lxvrdx\", v2di_ftype_long_pcvoid, P10_BUILTIN_ZE_LXVRDX);\n+  def_builtin (\"__builtin_altivec_tr_stxvrbx\", void_ftype_v1ti_long_pvoid, P10_BUILTIN_TR_STXVRBX);\n+  def_builtin (\"__builtin_altivec_tr_stxvrhx\", void_ftype_v1ti_long_pvoid, P10_BUILTIN_TR_STXVRHX);\n+  def_builtin (\"__builtin_altivec_tr_stxvrwx\", void_ftype_v1ti_long_pvoid, P10_BUILTIN_TR_STXVRWX);\n+  def_builtin (\"__builtin_altivec_tr_stxvrdx\", void_ftype_v1ti_long_pvoid, P10_BUILTIN_TR_STXVRDX);\n   def_builtin (\"__builtin_altivec_lvxl\", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_LVXL);\n   def_builtin (\"__builtin_altivec_lvxl_v2df\", v2df_ftype_long_pcvoid,\n \t       ALTIVEC_BUILTIN_LVXL_V2DF);\n@@ -13359,6 +13562,9 @@ altivec_init_builtins (void)\n   def_builtin (\"__builtin_vec_lvebx\", v16qi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEBX);\n   def_builtin (\"__builtin_vec_lvehx\", v8hi_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEHX);\n   def_builtin (\"__builtin_vec_lvewx\", v4si_ftype_long_pcvoid, ALTIVEC_BUILTIN_VEC_LVEWX);\n+  def_builtin (\"__builtin_vec_se_lxvrx\", v1ti_ftype_long_pcvoid, P10_BUILTIN_VEC_SE_LXVRX);\n+  def_builtin (\"__builtin_vec_ze_lxvrx\", v1ti_ftype_long_pcvoid, P10_BUILTIN_VEC_ZE_LXVRX);\n+  def_builtin (\"__builtin_vec_tr_stxvrx\", void_ftype_opaque_long_pvoid, P10_BUILTIN_VEC_TR_STXVRX);\n   def_builtin (\"__builtin_vec_st\", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_ST);\n   def_builtin (\"__builtin_vec_ste\", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STE);\n   def_builtin (\"__builtin_vec_stl\", void_ftype_opaque_long_pvoid, ALTIVEC_BUILTIN_VEC_STL);"}, {"sha": "d6347dba14977394774c5b07105f11dd52c38d8f", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -1255,6 +1255,24 @@\n     }\n })\n \n+;; Load rightmost element from load_data\n+;; using lxvrbx, lxvrhx, lxvrwx, lxvrdx.\n+(define_insn \"vsx_lxvr<wd>x\"\n+  [(set (match_operand:TI 0 \"vsx_register_operand\" \"=wa\")\n+\t(zero_extend:TI (match_operand:INT_ISA3  1 \"memory_operand\" \"Z\")))]\n+  \"TARGET_POWER10\"\n+  \"lxvr<wd>x %x0,%y1\"\n+  [(set_attr \"type\" \"vecload\")])\n+\n+;; Store rightmost element into store_data\n+;; using stxvrbx, stxvrhx, strvxwx, strvxdx.\n+(define_insn \"vsx_stxvr<wd>x\"\n+  [(set (match_operand:INT_ISA3 0 \"memory_operand\" \"=Z\")\n+\t(truncate:INT_ISA3 (match_operand:TI 1 \"vsx_register_operand\" \"wa\")))]\n+  \"TARGET_POWER10\"\n+  \"stxvr<wd>x %x1,%y0\"\n+  [(set_attr \"type\" \"vecstore\")])\n+\n ;; Explicit load/store expanders for the builtin functions for lxvd2x, etc.,\n ;; when you really want their element-reversing behavior.\n (define_insn \"vsx_ld_elemrev_v2di\""}, {"sha": "5c2caf938e72518938f370b092805680ca26edfc", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -17664,6 +17664,37 @@ Perform a 64-bit parallel bits extract operation, as if implemented by the\n @code{pextd} instruction.\n @findex __builtin_pextd\n \n+@smallexample\n+@exdent vector signed __int128 vsx_xl_sext (signed long long, signed char *);\n+@exdent vector signed __int128 vsx_xl_sext (signed long long, signed short *);\n+@exdent vector signed __int128 vsx_xl_sext (signed long long, signed int *);\n+@exdent vector signed __int128 vsx_xl_sext (signed long long, signed long long *);\n+@exdent vector unsigned __int128 vsx_xl_zext (signed long long, unsigned char *);\n+@exdent vector unsigned __int128 vsx_xl_zext (signed long long, unsigned short *);\n+@exdent vector unsigned __int128 vsx_xl_zext (signed long long, unsigned int *);\n+@exdent vector unsigned __int128 vsx_xl_zext (signed long long, unsigned long long *);\n+@end smallexample\n+\n+Load (and sign extend) to an __int128 vector, as if implemented by the ISA 3.1\n+@code{lxvrbx} @code{lxvrhx} @code{lxvrwx} @code{lxvrdx} instructions.\n+@findex vsx_xl_sext\n+@findex vsx_xl_zext\n+\n+@smallexample\n+@exdent void vec_xst_trunc (vector signed __int128, signed long long, signed char *);\n+@exdent void vec_xst_trunc (vector signed __int128, signed long long, signed short *);\n+@exdent void vec_xst_trunc (vector signed __int128, signed long long, signed int *);\n+@exdent void vec_xst_trunc (vector signed __int128, signed long long, signed long long *);\n+@exdent void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned char *);\n+@exdent void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned short *);\n+@exdent void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned int *);\n+@exdent void vec_xst_trunc (vector unsigned __int128, signed long long, unsigned long long *);\n+@end smallexample\n+\n+Truncate and store the rightmost element of a vector, as if implemented by the\n+ISA 3.1 @code{stxvrbx} @code{stxvrhx} @code{stxvrwx} @code{stxvrdx} instructions.\n+@findex vec_xst_trunc\n+\n @node PowerPC AltiVec/VSX Built-in Functions\n @subsection PowerPC AltiVec/VSX Built-in Functions\n "}, {"sha": "0b8cfd610f88603a432de8ee94f02096c6f4ffa8", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-load-element-extend-char.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-char.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,170 @@\n+/*\n+   Test of vec_xl_sext and vec_xl_zext (load into rightmost\n+   vector element and zero/sign extend). */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O3\" } */\n+\n+/* At the time of writing, the number of lxvrbx instructions is\n+   double what we expect because we are generating a \n+   .constprop copy of the function.  */\n+/* { dg-final { scan-assembler-times {\\mlxvrbx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mlbx\\M} 0 } } */\n+\n+#define NUM_VEC_ELEMS 16\n+#define ITERS 16\n+\n+/*\n+Codegen at time of writing is a lxvrbx for both the\n+zero and sign extended tests.  The sign extension test\n+also uses mfvsr*d, extsb, mtvsrdd, vextsd2q.\n+\n+0000000010000c90 <test_sign_extended_load>:\n+    10000c90:\t1a 18 04 7c \tlxvrbx  vs0,r4,r3\n+    10000c94:\t66 00 0b 7c \tmfvsrd  r11,vs0\n+    10000c98:\t66 02 0a 7c \tmfvsrld r10,vs0\n+    10000c9c:\t74 07 4a 7d \textsb   r10,r10\n+    10000ca0:\t67 53 40 7c \tmtvsrdd vs34,0,r10\n+    10000ca4:\t02 16 5b 10 \tvextsd2q v2,v2\n+    10000ca8:\t20 00 80 4e \tblr\n+\n+0000000010000cc0 <test_zero_extended_unsigned_load>:\n+    10000cc0:\t1b 18 44 7c \tlxvrbx  vs34,r4,r3\n+    10000cc4:\t20 00 80 4e \tblr\n+*/\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+long long buffer[8];\n+unsigned long verbose=0;\n+\n+char initbuffer[64] = {\n+\t0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+\t\t\t0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80,\n+\t0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n+\t\t\t0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90,\n+\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xa0,\n+\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n+\t\t\t0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xb0\n+};\n+\n+vector signed __int128 signed_expected[16] = {\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000011},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000012},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000013},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000014},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000015},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000016},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000017},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000000018},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff89},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8a},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8b},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8c},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8d},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8e},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff8f},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffffff80}\n+};\n+\n+vector unsigned __int128 unsigned_expected[16] = {\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000011},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000012},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000013},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000014},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000015},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000016},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000017},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000018},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000089},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008a},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008b},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008c},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008d},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008e},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x000000000000008f},\n+\t{ (unsigned __int128) 0x0000000000000000 << 64 | (unsigned __int128) 0x0000000000000080}\n+};\n+\n+__attribute__ ((noinline))\n+vector signed __int128 test_sign_extended_load(int RA, signed char * RB) {\n+\treturn vec_xl_sext (RA, RB);\n+}\n+\n+__attribute__ ((noinline))\n+vector unsigned __int128 test_zero_extended_unsigned_load(int RA, unsigned char * RB) {\n+\treturn vec_xl_zext (RA, RB);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int iteration=0;\n+   int mismatch=0;\n+   vector signed __int128 signed_result_v;\n+   vector unsigned __int128 unsigned_result_v;\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+  memcpy(&buffer, &initbuffer, sizeof(buffer));\n+\n+   if (verbose) {\n+\t   printf(\"input buffer:\\n\");\n+\t   for (int k=0;k<64;k++) {\n+\t\t   printf(\"%x \",initbuffer[k]);\n+\t\t   if (k && (k+1)%16==0) printf(\"\\n\");\n+\t   }\n+\t   printf(\"signed_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+\t   printf(\"unsigned_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      signed_result_v = test_sign_extended_load (iteration, (signed char*)buffer);\n+      if (signed_result_v[0] != signed_expected[iteration][0] ) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from signed load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",signed_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      unsigned_result_v = test_zero_extended_unsigned_load (iteration, (unsigned char*)buffer);\n+      if (unsigned_result_v[0] != unsigned_expected[iteration][0]) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from unsigned load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",unsigned_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",unsigned_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "b10d3cb43d2f6d2560712960968bafc430018d35", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-load-element-extend-int.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-int.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,168 @@\n+/*\n+   Test of vec_xl_sext and vec_xl_zext (load into rightmost\n+   vector element and zero/sign extend). */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+\n+/* Deliberately set optization to zero for this test to confirm\n+   the lxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   load instructions. */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mlxvrwx\\M} 2 } } */\n+\n+#define NUM_VEC_ELEMS 4\n+#define ITERS 16\n+\n+/*\n+Codegen at time of writing is a single lxvrwx for the zero\n+extended test, and a lwax,mtvsrdd,vextsd2q for the sign\n+extended test.\n+\n+0000000010000c90 <test_sign_extended_load>:\n+    10000c90:\taa 1a 24 7d \tlwax    r9,r4,r3\n+    10000c94:\t67 4b 40 7c \tmtvsrdd vs34,0,r9\n+    10000c98:\t02 16 5b 10 \tvextsd2q v2,v2\n+    10000c9c:\t20 00 80 4e \tblr\n+\n+0000000010000cb0 <test_zero_extended_unsigned_load>:\n+    10000cb0:\t9b 18 44 7c \tlxvrwx  vs34,r4,r3\n+    10000cb4:\t20 00 80 4e \tblr\n+*/\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+long long buffer[8];\n+unsigned long verbose=0;\n+\n+char initbuffer[64] = {\n+\t0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+\t\t\t0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80,\n+\t0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n+\t\t\t0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90,\n+\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xa0,\n+\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n+\t\t\t0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xb0\n+};\n+\n+vector signed __int128 signed_expected[16] = {\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000014131211},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000015141312},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000016151413},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000017161514},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000018171615},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff89181716},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8a891817},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8b8a8918},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8c8b8a89},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8d8c8b8a},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8e8d8c8b},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff8f8e8d8c},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffff808f8e8d},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000021808f8e},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x000000002221808f},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000023222180}\n+};\n+\n+vector unsigned __int128 unsigned_expected[16] = {\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000014131211},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000015141312},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000016151413},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000017161514},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000018171615},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000089181716},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008a891817},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008b8a8918},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008c8b8a89},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008d8c8b8a},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008e8d8c8b},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000008f8e8d8c},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000808f8e8d},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000021808f8e},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x000000002221808f},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000023222180}\n+};\n+\n+__attribute__ ((noinline))\n+vector signed __int128 test_sign_extended_load(int RA, signed int * RB) {\n+\treturn vec_xl_sext (RA, RB);\n+}\n+\n+__attribute__ ((noinline))\n+vector unsigned __int128 test_zero_extended_unsigned_load(int RA, unsigned int * RB) {\n+\treturn vec_xl_zext (RA, RB);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int iteration=0;\n+   int mismatch=0;\n+   vector signed __int128 signed_result_v;\n+   vector unsigned __int128 unsigned_result_v;\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+  memcpy(&buffer, &initbuffer, sizeof(buffer));\n+\n+   if (verbose) {\n+\t   printf(\"input buffer:\\n\");\n+\t   for (int k=0;k<64;k++) {\n+\t\t   printf(\"%x \",initbuffer[k]);\n+\t\t   if (k && (k+1)%16==0) printf(\"\\n\");\n+\t   }\n+\t   printf(\"signed_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+\t   printf(\"unsigned_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      signed_result_v = test_sign_extended_load (iteration, (signed int*)buffer);\n+      if (signed_result_v[0] != signed_expected[iteration][0] ) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from signed load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",signed_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      unsigned_result_v = test_zero_extended_unsigned_load (iteration, (unsigned int*)buffer);\n+      if (unsigned_result_v[0] != unsigned_expected[iteration][0]) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from unsigned load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",unsigned_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",unsigned_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "52fcf2e572f1697a2b842775fbfdb6b72e121390", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-load-element-extend-longlong.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-longlong.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,169 @@\n+/*\n+   Test of vec_xl_sext and vec_xl_zext (load into rightmost\n+   vector element and zero/sign extend). */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O3\" } */\n+\n+/* At time of writing, we also geenerate a .constrprop copy\n+   of the function, so our instruction hit count is\n+   twice of what we would otherwise expect.  */\n+/* { dg-final { scan-assembler-times {\\mlxvrdx\\M} 4 } } */\n+/* { dg-final { scan-assembler-times {\\mlvdx\\M} 0 } } */\n+\n+#define NUM_VEC_ELEMS 2\n+#define ITERS 16\n+\n+/*\n+Codegen at time of writing uses lxvrdx for both sign and\n+zero extend tests. The sign extended test also uses\n+mfvsr*d, mtvsrdd, vextsd2q.\n+\n+0000000010000c90 <test_sign_extended_load>:\n+    10000c90:\tda 18 04 7c \tlxvrdx  vs0,r4,r3\n+    10000c94:\t66 00 0b 7c \tmfvsrd  r11,vs0\n+    10000c98:\t66 02 0a 7c \tmfvsrld r10,vs0\n+    10000c9c:\t67 53 40 7c \tmtvsrdd vs34,0,r10\n+    10000ca0:\t02 16 5b 10 \tvextsd2q v2,v2\n+    10000ca4:\t20 00 80 4e \tblr\n+\n+0000000010000cc0 <test_zero_extended_unsigned_load>:\n+    10000cc0:\tdb 18 44 7c \tlxvrdx  vs34,r4,r3\n+    10000cc4:\t20 00 80 4e \tblr\n+*/\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+long long buffer[8];\n+unsigned long verbose=0;\n+\n+char initbuffer[64] = {\n+\t0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+\t\t\t0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80,\n+\t0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n+\t\t\t0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90,\n+\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xa0,\n+\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n+\t\t\t0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xb0\n+};\n+\n+vector signed __int128 signed_expected[16] = {\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x1817161514131211},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8918171615141312},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8a89181716151413},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8b8a891817161514},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8c8b8a8918171615},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8d8c8b8a89181716},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8e8d8c8b8a891817},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x8f8e8d8c8b8a8918},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0x808f8e8d8c8b8a89},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x21808f8e8d8c8b8a},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x2221808f8e8d8c8b},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x232221808f8e8d8c},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x24232221808f8e8d},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x2524232221808f8e},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x262524232221808f},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x2726252423222180}\n+};\n+\n+vector unsigned __int128 unsigned_expected[16] = {\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x1817161514131211},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8918171615141312},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8a89181716151413},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8b8a891817161514},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8c8b8a8918171615},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8d8c8b8a89181716},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8e8d8c8b8a891817},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x8f8e8d8c8b8a8918},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x808f8e8d8c8b8a89},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x21808f8e8d8c8b8a},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x2221808f8e8d8c8b},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x232221808f8e8d8c},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x24232221808f8e8d},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x2524232221808f8e},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x262524232221808f},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x2726252423222180}\n+};\n+\n+__attribute__ ((noinline))\n+vector signed __int128 test_sign_extended_load(int RA, signed long long * RB) {\n+\treturn vec_xl_sext (RA, RB);\n+}\n+\n+__attribute__ ((noinline))\n+vector unsigned __int128 test_zero_extended_unsigned_load(int RA, unsigned long long * RB) {\n+\treturn vec_xl_zext (RA, RB);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int iteration=0;\n+   int mismatch=0;\n+   vector signed __int128 signed_result_v;\n+   vector unsigned __int128 unsigned_result_v;\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+  memcpy(&buffer, &initbuffer, sizeof(buffer));\n+\n+   if (verbose) {\n+\t   printf(\"input buffer:\\n\");\n+\t   for (int k=0;k<64;k++) {\n+\t\t   printf(\"%x \",initbuffer[k]);\n+\t\t   if (k && (k+1)%16==0) printf(\"\\n\");\n+\t   }\n+\t   printf(\"signed_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+\t   printf(\"unsigned_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      signed_result_v = test_sign_extended_load (iteration, (signed long long*)buffer);\n+      if (signed_result_v[0] != signed_expected[iteration][0] ) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from signed load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",signed_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      unsigned_result_v = test_zero_extended_unsigned_load (iteration, (unsigned long long*)buffer);\n+      if (unsigned_result_v[0] != unsigned_expected[iteration][0]) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from unsigned load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",unsigned_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",unsigned_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "8fc0cc66eb72bdb1ef1c649a39f62a938faf8b25", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-load-element-extend-short.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-load-element-extend-short.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,168 @@\n+/*\n+   Test of vec_xl_sext and vec_xl_zext (load into rightmost\n+   vector element and zero/sign extend). */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+\n+/* Deliberately set optization to zero for this test to confirm\n+   the lxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   load instructions.  */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mlxvrhx\\M} 2 } } */\n+\n+#define NUM_VEC_ELEMS 8\n+#define ITERS 16\n+\n+/*\n+Codegen at time of writing uses lxvrhx for the zero\n+extension test and lhax,mtvsrdd,vextsd2q for the\n+sign extended test.\n+\n+0000000010001810 <test_sign_extended_load>:\n+    10001810:\tae 1a 24 7d \tlhax    r9,r4,r3\n+    10001814:\t67 4b 40 7c \tmtvsrdd vs34,0,r9\n+    10001818:\t02 16 5b 10 \tvextsd2q v2,v2\n+    1000181c:\t20 00 80 4e \tblr\n+\n+0000000010001830 <test_zero_extended_unsigned_load>:\n+    10001830:\t5b 18 44 7c \tlxvrhx  vs34,r4,r3\n+    10001834:\t20 00 80 4e \tblr\n+*/\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+long long buffer[8];\n+unsigned long verbose=0;\n+\n+char initbuffer[64] = {\n+\t0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+\t\t\t0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x80,\n+\t0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n+\t\t\t0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0x90,\n+\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xa0,\n+\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n+\t\t\t0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xb0\n+};\n+\n+vector signed __int128 signed_expected[16] = {\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001211},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001312},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001413},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001514},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001615},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001716},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000001817},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8918},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8a89},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8b8a},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8c8b},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8d8c},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8e8d},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff8f8e},\n+\t{ (__int128) 0xffffffffffffffff << 64 | (__int128) 0xffffffffffff808f},\n+\t{ (__int128) 0x0000000000000000 << 64 | (__int128) 0x0000000000002180}\n+};\n+\n+vector unsigned __int128 unsigned_expected[16] = {\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001211},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001312},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001413},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001514},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001615},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001716},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000001817},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008918},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008a89},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008b8a},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008c8b},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008d8c},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008e8d},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000008f8e},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x0000000000000808f},\n+\t{ (unsigned __int128) 0x0000000000000000  << 64 | (unsigned __int128) 0x00000000000002180}\n+};\n+\n+__attribute__ ((noinline))\n+vector signed __int128 test_sign_extended_load(int RA, signed short * RB) {\n+\treturn vec_xl_sext (RA, RB);\n+}\n+\n+__attribute__ ((noinline))\n+vector unsigned __int128 test_zero_extended_unsigned_load(int RA, unsigned short * RB) {\n+\treturn vec_xl_zext (RA, RB);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int iteration=0;\n+   int mismatch=0;\n+   vector signed __int128 signed_result_v;\n+   vector unsigned __int128 unsigned_result_v;\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+  memcpy(&buffer, &initbuffer, sizeof(buffer));\n+\n+   if (verbose) {\n+\t   printf(\"input buffer:\\n\");\n+\t   for (int k=0;k<64;k++) {\n+\t\t   printf(\"%x \",initbuffer[k]);\n+\t\t   if (k && (k+1)%16==0) printf(\"\\n\");\n+\t   }\n+\t   printf(\"signed_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+\t   printf(\"unsigned_expected:\\n\");\n+\t   for (int k=0;k<ITERS;k++) {\n+\t\tprintf(\"%llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\t   printf(\"\\n\");\n+\t   }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      signed_result_v = test_sign_extended_load (iteration, (signed short*)buffer);\n+      if (signed_result_v[0] != signed_expected[iteration][0] ) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from signed load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",signed_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",signed_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",signed_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   for (iteration = 0; iteration < ITERS ; iteration++ ) {\n+      unsigned_result_v = test_zero_extended_unsigned_load (iteration, (unsigned short*)buffer);\n+      if (unsigned_result_v[0] != unsigned_expected[iteration][0]) {\n+\t\tmismatch++;\n+\t\tprintf(\"Unexpected results from unsigned load. i=%d \\n\", iteration);\n+\t\tprintf(\"got:      %llx \",unsigned_result_v[0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_result_v[0]&0xffffffffffffffff);\n+\t\tprintf(\"expected: %llx \",unsigned_expected[iteration][0]>>64);\n+\t\tprintf(\" %llx \\n\",unsigned_expected[iteration][0]&0xffffffffffffffff);\n+\t\tfflush(stdout);\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "99f3904983be022f91894ab34fe8799a95c406dc", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-store-element-truncate-char.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-char.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,125 @@\n+/*\n+   Test of vec_xst_trunc (truncate and store rightmost vector element) */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+/* Deliberately set optization to zero for this test to confirm\n+   the stxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   store instructions.  */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mstxvrbx\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstbx\\M} 0 } } */\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+vector signed __int128 store_this_s[4] = {\n+{ (__int128) 0x7000000000000000 << 64 | (__int128) 0x123456789abcdef8ULL},\n+{ (__int128) 0x8000000000000000 << 64 | (__int128) 0xfedcba9876543217ULL},\n+{ (__int128) 0x1000000000000000 << 64 | (__int128) 0xccccccccccccccccULL},\n+{ (__int128) 0xf000000000000000 << 64 | (__int128) 0xaaaaaaaaaaaaaaaaULL}\n+};\n+\n+vector unsigned __int128 store_this_us[4] = {\n+{ (unsigned __int128) 0x7000000000000000 << 64 | (unsigned __int128) 0x123456789abcdef8ULL},\n+{ (unsigned __int128) 0x8000000000000000 << 64 | (unsigned __int128) 0xfedcba9876543217ULL},\n+{ (unsigned __int128) 0x1000000000000000 << 64 | (unsigned __int128) 0xeeeeeeeeeeeeeeeeULL},\n+{ (unsigned __int128) 0xf000000000000000 << 64 | (unsigned __int128) 0x5555555555555555ULL}\n+};\n+\n+#define NUM_VEC_ELEMS 16\n+\n+vector signed char signed_expected[4] = {\n+\t{ 0xf8, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x17, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0xcc, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0xaa, 0x0, 0x0, 0x0}\n+};\n+vector unsigned char unsigned_expected[4] = {\n+\t{ 0xf8, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x17, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0xee, 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0},\n+\t{ 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x0 , 0x0, 0x0, 0x0, 0x55, 0x0, 0x0, 0x0}\n+};\n+\n+unsigned long long rawbuffer[32];\n+signed char * vsbuffer = (char *)rawbuffer;\n+unsigned char * vubuffer = (unsigned char *)rawbuffer;\n+\n+void reset_buffer() {\n+\tmemset (&rawbuffer,0,sizeof(rawbuffer));\n+}\n+\n+#define PRINT_VEC(V) \\\n+   for (int j=0;j<NUM_VEC_ELEMS;j++) {\tprintf (\"(0x%lx) \", V[j] ); }\n+\n+void test_signed_store(vector signed __int128 myvec, int offset, signed char * store_data ) {\n+\tvec_xst_trunc (myvec, offset, store_data );\n+}\n+\n+void test_unsigned_store(vector unsigned __int128 myvec, int offset, unsigned char * store_data )   {\n+\tvec_xst_trunc (myvec, offset, store_data );\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int i;\n+   int memcmpresult;\n+   int mismatch=0;\n+   int verbose=0;\n+\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+   if (verbose) {\n+      printf(\"expected results from signed tests:\\n\");\n+      for (i = 0; i < 4 ; i++ ) {\n+\t PRINT_VEC(signed_expected[i]);\n+\t printf(\"\\n\");\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_signed_store (store_this_s[i], 4*i, vsbuffer);\n+      memcmpresult = memcmp(rawbuffer,&signed_expected[i],sizeof(vector char));\n+      if (memcmpresult) {\n+\t printf(\"mismatch signed buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results: \");\n+\t    PRINT_VEC(vsbuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_unsigned_store (store_this_us[i], 4*i, vubuffer);\n+      memcmpresult = memcmp(rawbuffer,&unsigned_expected[i],sizeof(vector char));\n+      if (memcmpresult) {\n+\t printf(\"mismatch unsigned buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results :\");\n+\t    PRINT_VEC(vubuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "6e2acf83c38367086f0ba1d43ab83db574593bee", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-store-element-truncate-int.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-int.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,125 @@\n+/*\n+   Test of vec_xst_trunc (truncate and store rightmost vector element) */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+/* Deliberately set optization to zero for this test to confirm\n+   the stxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   store instructions.  */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+ \n+/* { dg-final { scan-assembler-times {\\mstxvrwx\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstwx\\M} 0 } } */\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+vector signed __int128 store_this_s[4] = {\n+{ (__int128) 0x7000000000000000 << 64 | (__int128) 0x123456789abcdef8ULL},\n+{ (__int128) 0x8000000000000000 << 64 | (__int128) 0xfedcba9876543217ULL},\n+{ (__int128) 0x1000000000000000 << 64 | (__int128) 0xccccccccccccccccULL},\n+{ (__int128) 0xf000000000000000 << 64 | (__int128) 0xaaaaaaaaaaaaaaaaULL}\n+};\n+\n+vector unsigned __int128 store_this_us[4] = {\n+{ (unsigned __int128) 0x7000000000000000 << 64 | (unsigned __int128) 0x123456789abcdef8ULL},\n+{ (unsigned __int128) 0x8000000000000000 << 64 | (unsigned __int128) 0xfedcba9876543217ULL},\n+{ (unsigned __int128) 0x1000000000000000 << 64 | (unsigned __int128) 0xeeeeeeeeeeeeeeeeULL},\n+{ (unsigned __int128) 0xf000000000000000 << 64 | (unsigned __int128) 0x5555555555555555ULL}\n+};\n+\n+#define NUM_VEC_ELEMS 4\n+\n+vector signed int signed_expected[4] = {\n+\t{0x9abcdef8, 0x0       , 0x0       , 0x0        },\n+\t{0x0       , 0x76543217, 0x0       , 0x0        },\n+\t{0x0       , 0x0       , 0xcccccccc, 0x0        },\n+\t{0x0       , 0x0       , 0x0       , 0xaaaaaaaa },\n+};\n+vector unsigned int unsigned_expected[4] = {\n+\t{0x9abcdef8, 0x0       , 0x0       , 0x0        },\n+\t{0x0       , 0x76543217, 0x0       , 0x0        },\n+\t{0x0       , 0x0       , 0xeeeeeeee, 0x0        },\n+\t{0x0       , 0x0       , 0x0       , 0x55555555 },\n+};\n+\n+unsigned long long rawbuffer[32];\n+signed int * vsbuffer = (int *)rawbuffer;\n+unsigned int * vubuffer = (unsigned int *)rawbuffer;\n+\n+void reset_buffer() {\n+\tmemset (&rawbuffer,0,sizeof(rawbuffer));\n+}\n+\n+#define PRINT_VEC(V) \\\n+   for (int j=0;j<NUM_VEC_ELEMS;j++) {\tprintf (\"(0x%lx) \", V[j] ); }\n+\n+void test_signed_store(vector signed __int128 myvec, int offset, signed int * store_data ) {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+void test_unsigned_store(vector unsigned __int128 myvec, int offset, unsigned int * store_data ) {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int i;\n+   int memcmpresult;\n+   int mismatch=0;\n+   int verbose=0;\n+\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+   if (verbose) {\n+      printf(\"expected results from signed tests:\\n\");\n+      for (i = 0; i < 4 ; i++ ) {\n+\t PRINT_VEC(signed_expected[i]);\n+\t printf(\"\\n\");\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_signed_store (store_this_s[i], 4*i, vsbuffer);\n+      memcmpresult = memcmp(rawbuffer,&signed_expected[i],sizeof(vector int));\n+      if (memcmpresult) {\n+\t printf(\"mismatch signed buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results: \");\n+\t    PRINT_VEC(vsbuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_unsigned_store (store_this_us[i], 4*i, vubuffer);\n+      memcmpresult = memcmp(rawbuffer,&unsigned_expected[i],sizeof(vector int));\n+      if (memcmpresult) {\n+\t printf(\"mismatch unsigned buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results :\");\n+\t    PRINT_VEC(vubuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "7fce6a44d4f5487660b84a0f85b0c1cfb57b7ec8", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-store-element-truncate-longlong.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-longlong.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,126 @@\n+/*\n+   Test of vec_xst_trunc (truncate and store rightmost vector element) */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+\n+/* Deliberately set optization to zero for this test to confirm\n+   the stxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   store instructions. */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mstxvrdx\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mstwx\\M} 0 } } */\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+vector signed __int128 store_this_s[4] = {\n+{ (__int128) 0x7000000000000000 << 64 | (__int128) 0x123456789abcdef8ULL},\n+{ (__int128) 0x8000000000000000 << 64 | (__int128) 0xfedcba9876543217ULL},\n+{ (__int128) 0x1000000000000000 << 64 | (__int128) 0xccccccccccccccccULL},\n+{ (__int128) 0xf000000000000000 << 64 | (__int128) 0xaaaaaaaaaaaaaaaaULL}\n+};\n+\n+vector unsigned __int128 store_this_us[4] = {\n+{ (unsigned __int128) 0x7000000000000000 << 64 | (unsigned __int128) 0x123456789abcdef8ULL},\n+{ (unsigned __int128) 0x8000000000000000 << 64 | (unsigned __int128) 0xfedcba9876543217ULL},\n+{ (unsigned __int128) 0x1000000000000000 << 64 | (unsigned __int128) 0xeeeeeeeeeeeeeeeeULL},\n+{ (unsigned __int128) 0xf000000000000000 << 64 | (unsigned __int128) 0x5555555555555555ULL}\n+};\n+\n+#define NUM_VEC_ELEMS 2\n+\n+vector signed long long signed_expected[5] = {\n+\t{ 0x123456789abcdef8,                0x0},\n+\t{ 0x7654321700000000,         0xfedcba98},\n+\t{ 0x0000000000000000, 0xcccccccccccccccc},\n+\t{ 0x0000000000000000, 0xaaaaaaaa00000000}  /*note that some data written into the next word */\n+};\n+vector unsigned long long unsigned_expected[5] = {\n+\t{ 0x123456789abcdef8,                0x0},\n+\t{ 0x7654321700000000,         0xfedcba98},\n+\t{ 0x0000000000000000, 0xeeeeeeeeeeeeeeee},\n+\t{ 0x0000000000000000, 0x5555555500000000}\n+};\n+\n+unsigned long long rawbuffer[32];\n+signed long long * vsbuffer = (long long *)rawbuffer;\n+unsigned long long * vubuffer = (unsigned long long *)rawbuffer;\n+\n+void reset_buffer() {\n+\tmemset (&rawbuffer,0,sizeof(rawbuffer));\n+}\n+\n+#define PRINT_VEC(V) \\\n+   for (int j=0;j<NUM_VEC_ELEMS;j++) {\tprintf (\"(0x%lx) \", V[j] ); }\n+\n+void test_signed_store(vector signed __int128 myvec, int offset, signed long long * store_data ) {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+void test_unsigned_store(vector unsigned __int128 myvec, int offset, unsigned long long * store_data )   {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int i;\n+   int memcmpresult;\n+   int mismatch=0;\n+   int verbose=0;\n+\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+   if (verbose) {\n+      printf(\"expected results from signed tests:\\n\");\n+      for (i = 0; i < 4 ; i++ ) {\n+\t PRINT_VEC(signed_expected[i]);\n+\t printf(\"\\n\");\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_signed_store (store_this_s[i], 4*i, vsbuffer);\n+      memcmpresult = memcmp(rawbuffer,&signed_expected[i],sizeof(vector long long));\n+      if (memcmpresult) {\n+\t printf(\"mismatch signed buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results: \");\n+\t    PRINT_VEC(vsbuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_unsigned_store (store_this_us[i], 4*i, vubuffer);\n+      memcmpresult = memcmp(rawbuffer,&unsigned_expected[i],sizeof(vector long long));\n+      if (memcmpresult) {\n+\t printf(\"mismatch unsigned buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results :\");\n+\t    PRINT_VEC(vubuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}, {"sha": "17925c87732ef643b3cfa6eac0bb647496475497", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-store-element-truncate-short.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-short.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b69c00612db1ccf7de77b0072c6b1b47090318f3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-short.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-store-element-truncate-short.c?ref=b69c00612db1ccf7de77b0072c6b1b47090318f3", "patch": "@@ -0,0 +1,126 @@\n+/*\n+   Test of vec_xst_trunc (truncate and store rightmost vector element) */\n+\n+/* { dg-do compile {target power10_ok} } */\n+/* { dg-do run {target power10_hw} } */\n+\n+/* Deliberately set optization to zero for this test to confirm\n+   the stxvr*x instruction is generated. At higher optimization levels\n+   the instruction we are looking for is sometimes replaced by other\n+   store instructions.  */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O0\" } */\n+\n+/* { dg-final { scan-assembler-times {\\mstxvrhx\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\msthx\\M} 0 } } */\n+\n+#include <altivec.h>\n+#include <stdio.h>\n+#include <inttypes.h>\n+#include <string.h>\n+#include <stdlib.h>\n+\n+vector signed __int128 store_this_s[4] = {\n+{ (__int128) 0x7000000000000000 << 64 | (__int128) 0x123456789abcdef8ULL},\n+{ (__int128) 0x8000000000000000 << 64 | (__int128) 0xfedcba9876543217ULL},\n+{ (__int128) 0x1000000000000000 << 64 | (__int128) 0xccccccccccccccccULL},\n+{ (__int128) 0xf000000000000000 << 64 | (__int128) 0xaaaaaaaaaaaaaaaaULL}\n+};\n+\n+vector unsigned __int128 store_this_us[4] = {\n+{ (unsigned __int128) 0x7000000000000000 << 64 | (unsigned __int128) 0x123456789abcdef8ULL},\n+{ (unsigned __int128) 0x8000000000000000 << 64 | (unsigned __int128) 0xfedcba9876543217ULL},\n+{ (unsigned __int128) 0x1000000000000000 << 64 | (unsigned __int128) 0xeeeeeeeeeeeeeeeeULL},\n+{ (unsigned __int128) 0xf000000000000000 << 64 | (unsigned __int128) 0x5555555555555555ULL}\n+};\n+\n+#define NUM_VEC_ELEMS 8\n+\n+vector signed short signed_expected[4] = {\n+\t{0xdef8, 0x0, 0x0   , 0x0, 0x0   , 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x3217, 0x0, 0x0   , 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x0   , 0x0, 0xcccc, 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x0   , 0x0, 0x0   , 0x0, 0xaaaa, 0x0}\n+\t};\n+vector unsigned short unsigned_expected[4] = {\n+\t{0xdef8, 0x0, 0x0   , 0x0, 0x0   , 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x3217, 0x0, 0x0   , 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x0   , 0x0, 0xeeee, 0x0, 0x0   , 0x0},\n+\t{0x0   , 0x0, 0x0   , 0x0, 0x0   , 0x0, 0x5555, 0x0}\n+};\n+\n+unsigned long long rawbuffer[32];\n+signed short * vsbuffer = (short *)rawbuffer;\n+unsigned short * vubuffer = (unsigned short *)rawbuffer;\n+\n+void reset_buffer() {\n+\tmemset (&rawbuffer,0,sizeof(rawbuffer));\n+}\n+\n+#define PRINT_VEC(V) \\\n+   for (int j=0;j<NUM_VEC_ELEMS;j++) {\tprintf (\"(0x%lx) \", V[j] ); }\n+\n+void test_signed_store(vector signed __int128 myvec, int offset, signed short * store_data ) {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+void test_unsigned_store(vector unsigned __int128 myvec, int offset, unsigned short * store_data )   {\n+\tvec_xst_trunc (myvec, offset, store_data);\n+}\n+\n+int main (int argc, char *argv [])\n+{\n+   int i;\n+   int memcmpresult;\n+   int mismatch=0;\n+   int verbose=0;\n+\n+#if VERBOSE\n+   verbose=1;\n+   printf(\"%s %s\\n\", __DATE__, __TIME__);\n+#endif\n+\n+   if (verbose) {\n+      printf(\"expected results from signed tests:\\n\");\n+      for (i = 0; i < 4 ; i++ ) {\n+\t PRINT_VEC(signed_expected[i]);\n+\t printf(\"\\n\");\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_signed_store (store_this_s[i], 4*i, vsbuffer);\n+      memcmpresult = memcmp(rawbuffer,&signed_expected[i],sizeof(vector short));\n+      if (memcmpresult) {\n+\t printf(\"mismatch signed buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results: \");\n+\t    PRINT_VEC(vsbuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   for (i = 0; i < 4 ; i++ ) {\n+      reset_buffer();\n+      test_unsigned_store (store_this_us[i], 4*i, vubuffer);\n+      memcmpresult = memcmp(rawbuffer,&unsigned_expected[i],sizeof(vector short));\n+      if (memcmpresult) {\n+\t printf(\"mismatch unsigned buffer, i %d (memcmpresult:%d) \\n\",i,memcmpresult);\n+\t mismatch++;\n+\t if (verbose) {\n+\t    printf(\"results :\");\n+\t    PRINT_VEC(vubuffer);\n+\t    printf(\"\\n\");\n+\t }\n+      }\n+   }\n+\n+   if (mismatch) {\n+      printf(\"%d mismatches. \\n\",mismatch);\n+      abort();\n+   }\n+   return 0;\n+}\n+"}]}