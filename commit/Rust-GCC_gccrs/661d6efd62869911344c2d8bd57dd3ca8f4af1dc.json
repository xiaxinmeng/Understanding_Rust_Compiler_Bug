{"sha": "661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxZDZlZmQ2Mjg2OTkxMTM0NGMyZDhiZDU3ZGQzY2E4ZjRhZjFkYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-08-17T11:51:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-08-17T11:51:51Z"}, "message": "re PR tree-optimization/76490 (when use -O2 -fcheck-founds compiler appears to hang and consumes all memory)\n\n2016-08-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/76490\n\t* tree-vrp.c (update_value_range): Preserve overflow infinities\n\twhen intersecting with ranges from get_range_info.\n\t(operand_less_p): Handle overflow infinities correctly.\n\t(value_range_constant_singleton): Use vrp_operand_equal_p\n\tto handle overflow max/min correctly.\n\t(vrp_valueize): Likewise.\n\t(union_ranges): Likewise.\n\t(intersect_ranges): Likewise.\n\t(vrp_visit_phi_node): Improve iteration limitation to only\n\tapply when we'll possibly re-visit the PHI via a changed argument\n\ton the backedge.\n\n\t* gfortran.fortran-torture/compile/pr76490.f90: New testcase.\n\t* gcc.dg/pr52904.c: XFAIL.\n\nFrom-SVN: r239529", "tree": {"sha": "29be5c0cfa9641497b251d5e5af7fc294a63579f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29be5c0cfa9641497b251d5e5af7fc294a63579f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03c9d8596f91e600383089ecabdea6bc206ab14c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03c9d8596f91e600383089ecabdea6bc206ab14c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03c9d8596f91e600383089ecabdea6bc206ab14c"}], "stats": {"total": 92, "additions": 75, "deletions": 17}, "files": [{"sha": "5142c920e8ee73bf795289174dc08c85aa8202e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "patch": "@@ -1,3 +1,18 @@\n+2016-08-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/76490\n+\t* tree-vrp.c (update_value_range): Preserve overflow infinities\n+\twhen intersecting with ranges from get_range_info.\n+\t(operand_less_p): Handle overflow infinities correctly.\n+\t(value_range_constant_singleton): Use vrp_operand_equal_p\n+\tto handle overflow max/min correctly.\n+\t(vrp_valueize): Likewise.\n+\t(union_ranges): Likewise.\n+\t(intersect_ranges): Likewise.\n+\t(vrp_visit_phi_node): Improve iteration limitation to only\n+\tapply when we'll possibly re-visit the PHI via a changed argument\n+\ton the backedge.\n+\n 2016-08-17  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/t-aprofile (MULTILIB_EXCEPTIONS): Rewrite into ..."}, {"sha": "ed2ce1c12b344d4fd42732a6918f0dbca3365ece", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "patch": "@@ -1,3 +1,9 @@\n+2016-08-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/76490\n+\t* gfortran.fortran-torture/compile/pr76490.f90: New testcase.\n+\t* gcc.dg/pr52904.c: XFAIL.\n+\n 2016-08-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/23855"}, {"sha": "2818c247b0aa26456e5b4f1812576727abf623ad", "filename": "gcc/testsuite/gcc.dg/pr52904.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52904.c?ref=661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "patch": "@@ -14,7 +14,7 @@ wait_reading_process_output (void)\n \tnfds++;\n     }\n \n-  if (nfds < 0) /* { dg-bogus \"assuming signed overflow does not occur\" } */\n+  if (nfds < 0) /* { dg-bogus \"assuming signed overflow does not occur\" \"\" { xfail *-*-* } } */\n     return 1;\n   return 0;\n }"}, {"sha": "aeb0717086d4e471c30a5cce5acc59c2d3365e07", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/pr76490.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr76490.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr76490.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fpr76490.f90?ref=661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "patch": "@@ -0,0 +1,23 @@\n+program membug\n+call bug1()\n+end program membug\n+subroutine unknown(x1,y1,ibig)\n+   write(*,*)x1,y1,ibig\n+end subroutine unknown\n+subroutine bug1()\n+real arrayq(3000)\n+   isize=0\n+   ibig=-1\n+   x2=0\n+10 continue\n+   isize=isize+1\n+   arrayq(isize)=x2\n+15 continue\n+   call unknown(x1,y1,ibig)\n+   if(ibig.eq.1)then\n+      goto 10\n+   elseif(ibig.eq.2)then\n+      isize=max(1,isize-1)\n+      goto 15\n+   endif\n+end subroutine bug1"}, {"sha": "a8810134b317211f64f722b70cb0a894401da06a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661d6efd62869911344c2d8bd57dd3ca8f4af1dc/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=661d6efd62869911344c2d8bd57dd3ca8f4af1dc", "patch": "@@ -774,8 +774,20 @@ update_value_range (const_tree var, value_range *new_vr)\n \t{\n \t  value_range nr;\n \t  nr.type = rtype;\n-\t  nr.min = wide_int_to_tree (TREE_TYPE (var), min);\n-\t  nr.max = wide_int_to_tree (TREE_TYPE (var), max);\n+\t  /* Range info on SSA names doesn't carry overflow information\n+\t     so make sure to preserve the overflow bit on the lattice.  */\n+\t  if (new_vr->type == VR_RANGE\n+\t      && is_negative_overflow_infinity (new_vr->min)\n+\t      && wi::eq_p (new_vr->min, min))\n+\t    nr.min = new_vr->min;\n+\t  else\n+\t    nr.min = wide_int_to_tree (TREE_TYPE (var), min);\n+\t  if (new_vr->type == VR_RANGE\n+\t      && is_positive_overflow_infinity (new_vr->max)\n+\t      && wi::eq_p (new_vr->max, max))\n+\t    nr.max = new_vr->max;\n+\t  else\n+\t    nr.max = wide_int_to_tree (TREE_TYPE (var), max);\n \t  nr.equiv = NULL;\n \t  vrp_intersect_ranges (new_vr, &nr);\n \t}\n@@ -1138,7 +1150,10 @@ operand_less_p (tree val, tree val2)\n {\n   /* LT is folded faster than GE and others.  Inline the common case.  */\n   if (TREE_CODE (val) == INTEGER_CST && TREE_CODE (val2) == INTEGER_CST)\n-    return tree_int_cst_lt (val, val2);\n+    {\n+      if (! is_positive_overflow_infinity (val2))\n+\treturn tree_int_cst_lt (val, val2);\n+    }\n   else\n     {\n       tree tcmp;\n@@ -1422,7 +1437,7 @@ static tree\n value_range_constant_singleton (value_range *vr)\n {\n   if (vr->type == VR_RANGE\n-      && operand_equal_p (vr->min, vr->max, 0)\n+      && vrp_operand_equal_p (vr->min, vr->max)\n       && is_gimple_min_invariant (vr->min))\n     return vr->min;\n \n@@ -7028,8 +7043,7 @@ vrp_valueize (tree name)\n     {\n       value_range *vr = get_value_range (name);\n       if (vr->type == VR_RANGE\n-\t  && (vr->min == vr->max\n-\t      || operand_equal_p (vr->min, vr->max, 0)))\n+\t  && vrp_operand_equal_p (vr->min, vr->max))\n \treturn vr->min;\n     }\n   return name;\n@@ -7995,8 +8009,8 @@ union_ranges (enum value_range_type *vr0type,\n \t      enum value_range_type vr1type,\n \t      tree vr1min, tree vr1max)\n {\n-  bool mineq = operand_equal_p (*vr0min, vr1min, 0);\n-  bool maxeq = operand_equal_p (*vr0max, vr1max, 0);\n+  bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n+  bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);\n \n   /* [] is vr0, () is vr1 in the following classification comments.  */\n   if (mineq && maxeq)\n@@ -8266,8 +8280,8 @@ intersect_ranges (enum value_range_type *vr0type,\n \t\t  enum value_range_type vr1type,\n \t\t  tree vr1min, tree vr1max)\n {\n-  bool mineq = operand_equal_p (*vr0min, vr1min, 0);\n-  bool maxeq = operand_equal_p (*vr0max, vr1max, 0);\n+  bool mineq = vrp_operand_equal_p (*vr0min, vr1min);\n+  bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);\n \n   /* [] is vr0, () is vr1 in the following classification comments.  */\n   if (mineq && maxeq)\n@@ -8725,7 +8739,7 @@ vrp_visit_phi_node (gphi *phi)\n       print_gimple_stmt (dump_file, phi, 0, dump_flags);\n     }\n \n-  bool may_simulate_again = false;\n+  bool may_simulate_backedge_again = false;\n   edges = 0;\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n@@ -8751,8 +8765,9 @@ vrp_visit_phi_node (gphi *phi)\n \t      /* See if we are eventually going to change one of the args.  */\n \t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (! gimple_nop_p (def_stmt)\n-\t\t  && prop_simulate_again_p (def_stmt))\n-\t\tmay_simulate_again = true;\n+\t\t  && prop_simulate_again_p (def_stmt)\n+\t\t  && e->flags & EDGE_DFS_BACK)\n+\t\tmay_simulate_backedge_again = true;\n \n \t      vr_arg = *(get_value_range (arg));\n \t      /* Do not allow equivalences or symbolic ranges to leak in from\n@@ -8830,13 +8845,12 @@ vrp_visit_phi_node (gphi *phi)\n      edge; this helps us avoid an overflow infinity for conditionals\n      which are not in a loop.  If the old value-range was VR_UNDEFINED\n      use the updated range and iterate one more time.  If we will not\n-     simulate this PHI again with the same number of edges then iterate\n-     one more time.  */\n+     simulate this PHI again via the backedge allow us to iterate.  */\n   if (edges > 0\n       && gimple_phi_num_args (phi) > 1\n       && edges == old_edges\n       && lhs_vr->type != VR_UNDEFINED\n-      && may_simulate_again)\n+      && may_simulate_backedge_again)\n     {\n       /* Compare old and new ranges, fall back to varying if the\n          values are not comparable.  */"}]}