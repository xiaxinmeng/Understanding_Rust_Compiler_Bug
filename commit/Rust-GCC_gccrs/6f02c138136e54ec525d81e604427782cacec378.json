{"sha": "6f02c138136e54ec525d81e604427782cacec378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYwMmMxMzgxMzZlNTRlYzUyNWQ4MWU2MDQ0Mjc3ODJjYWNlYzM3OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-09T13:31:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-09T13:31:49Z"}, "message": "runtime: align ucontext_t argument to 16 byte boundary\n    \n    Some systems, such as ia64 and PPC, require that a ucontext_t pointer\n    passed to getcontext and friends be aligned to a 16-byte boundary.\n    Currently the ucontext_t fields in the g structure are defined in Go,\n    and Go has no way to ensure a 16-byte alignment for a struct field.\n    The fields are currently represented by an array of unsafe.Pointer.\n    Enforce the alignment by making the array larger, and picking an offset\n    into the array that is 16-byte aligned.\n    \n    Reviewed-on: https://go-review.googlesource.com/28910\n\nFrom-SVN: r240044", "tree": {"sha": "d4fd6aada5043cfd7bff984cbe0d0a5ef059bfde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4fd6aada5043cfd7bff984cbe0d0a5ef059bfde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f02c138136e54ec525d81e604427782cacec378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f02c138136e54ec525d81e604427782cacec378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f02c138136e54ec525d81e604427782cacec378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f02c138136e54ec525d81e604427782cacec378/comments", "author": null, "committer": null, "parents": [{"sha": "0abcd6cc738c5afd131c232ddb6809e6ff8e8def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abcd6cc738c5afd131c232ddb6809e6ff8e8def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0abcd6cc738c5afd131c232ddb6809e6ff8e8def"}], "stats": {"total": 66, "additions": 44, "deletions": 22}, "files": [{"sha": "26f36ec68684fd584ddffdda5445e15fc43790d1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02c138136e54ec525d81e604427782cacec378/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02c138136e54ec525d81e604427782cacec378/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6f02c138136e54ec525d81e604427782cacec378", "patch": "@@ -1,4 +1,4 @@\n-c8cf90f2daf62428ca6aa0b5674572cd99f25fe3\n+4f033f29553655ad90493d55059a7bbc6cd63108\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "468d11e8e838c9ee410ec82ac6a5a503cf155d68", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02c138136e54ec525d81e604427782cacec378/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02c138136e54ec525d81e604427782cacec378/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=6f02c138136e54ec525d81e604427782cacec378", "patch": "@@ -805,7 +805,11 @@ var (\n \n // _ucontext_t is a Go version of the C ucontext_t type, used by getcontext.\n // _sizeof_ucontext_t is defined by the Makefile from <ucontext.h>.\n-type _ucontext_t [_sizeof_ucontext_t / unsafe.Sizeof(uintptr(0))]unsafe.Pointer\n+// On some systems getcontext and friends require a value that is\n+// aligned to a 16-byte boundary.  We implement this by increasing the\n+// required size and picking an appropriate offset when we use the\n+// array.\n+type _ucontext_t [(_sizeof_ucontext_t + 15) / unsafe.Sizeof(unsafe.Pointer(nil))]unsafe.Pointer\n \n // traceback is used to collect stack traces from other goroutines.\n type traceback struct {"}, {"sha": "59dfc09ec13d638a6db6d70f08e74440c499db89", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f02c138136e54ec525d81e604427782cacec378/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f02c138136e54ec525d81e604427782cacec378/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=6f02c138136e54ec525d81e604427782cacec378", "patch": "@@ -156,6 +156,20 @@ fixcontext(ucontext_t *c)\n \n #endif\n \n+// ucontext_arg returns a properly aligned ucontext_t value.  On some\n+// systems a ucontext_t value must be aligned to a 16-byte boundary.\n+// The g structure that has fields of type ucontext_t is defined in\n+// Go, and Go has no simple way to align a field to such a boundary.\n+// So we make the field larger in runtime2.go and pick an appropriate\n+// offset within the field here.\n+static ucontext_t*\n+ucontext_arg(void** go_ucontext)\n+{\n+\tuintptr_t p = (uintptr_t)go_ucontext;\n+\tp = (p + 15) &~ (uintptr_t)0xf;\n+\treturn (ucontext_t*)p;\n+}\n+\n // We can not always refer to the TLS variables directly.  The\n // compiler will call tls_get_addr to get the address of the variable,\n // and it may hold it in a register across a call to schedule.  When\n@@ -245,8 +259,8 @@ runtime_gogo(G* newg)\n #endif\n \tg = newg;\n \tnewg->fromgogo = true;\n-\tfixcontext((ucontext_t*)&newg->context[0]);\n-\tsetcontext((ucontext_t*)&newg->context[0]);\n+\tfixcontext(ucontext_arg(&newg->context[0]));\n+\tsetcontext(ucontext_arg(&newg->context[0]));\n \truntime_throw(\"gogo setcontext returned\");\n }\n \n@@ -278,7 +292,7 @@ runtime_mcall(void (*pfn)(G*))\n \t\tgp->gcnextsp = &pfn;\n #endif\n \t\tgp->fromgogo = false;\n-\t\tgetcontext((ucontext_t*)&gp->context[0]);\n+\t\tgetcontext(ucontext_arg(&gp->context[0]));\n \n \t\t// When we return from getcontext, we may be running\n \t\t// in a new thread.  That means that g may have\n@@ -305,8 +319,8 @@ runtime_mcall(void (*pfn)(G*))\n \t\t// the getcontext call just above.\n \t\tg = mp->g0;\n \n-\t\tfixcontext((ucontext_t*)&mp->g0->context[0]);\n-\t\tsetcontext((ucontext_t*)&mp->g0->context[0]);\n+\t\tfixcontext(ucontext_arg(&mp->g0->context[0]));\n+\t\tsetcontext(ucontext_arg(&mp->g0->context[0]));\n \t\truntime_throw(\"runtime: mcall function returned\");\n \t}\n }\n@@ -709,7 +723,7 @@ runtime_tracebackothers(G * volatile me)\n #ifdef USING_SPLIT_STACK\n \t\t__splitstack_getcontext(&me->stackcontext[0]);\n #endif\n-\t\tgetcontext((ucontext_t*)&me->context[0]);\n+\t\tgetcontext(ucontext_arg(&me->context[0]));\n \n \t\tif(gp->traceback != nil) {\n \t\t  runtime_gogo(gp);\n@@ -750,7 +764,7 @@ runtime_tracebackothers(G * volatile me)\n #ifdef USING_SPLIT_STACK\n \t\t\t__splitstack_getcontext(&me->stackcontext[0]);\n #endif\n-\t\t\tgetcontext((ucontext_t*)&me->context[0]);\n+\t\t\tgetcontext(ucontext_arg(&me->context[0]));\n \n \t\t\tif(gp->traceback != nil) {\n \t\t\t\truntime_gogo(gp);\n@@ -1063,7 +1077,7 @@ runtime_mstart(void* mp)\n \tg->gcstacksize = 0;\n \tg->gcnextsp = &mp;\n #endif\n-\tgetcontext((ucontext_t*)&g->context[0]);\n+\tgetcontext(ucontext_arg(&g->context[0]));\n \n \tif(g->entry != nil) {\n \t\t// Got here from mcall.\n@@ -1251,7 +1265,7 @@ runtime_needm(void)\n \tg->gcstacksize = 0;\n \tg->gcnextsp = &mp;\n #endif\n-\tgetcontext((ucontext_t*)&g->context[0]);\n+\tgetcontext(ucontext_arg(&g->context[0]));\n \n \tif(g->entry != nil) {\n \t\t// Got here from mcall.\n@@ -1282,6 +1296,7 @@ runtime_newextram(void)\n \tG *gp;\n \tbyte *g0_sp, *sp;\n \tuintptr g0_spsize, spsize;\n+\tucontext_t *uc;\n \n \t// Create extra goroutine locked to extra m.\n \t// The goroutine is the context in which the cgo callback will run.\n@@ -1302,10 +1317,11 @@ runtime_newextram(void)\n \n \t// The context for gp will be set up in runtime_needm.  But\n \t// here we need to set up the context for g0.\n-\tgetcontext((ucontext_t*)&mp->g0->context[0]);\n-\t((ucontext_t*)&mp->g0->context[0])->uc_stack.ss_sp = g0_sp;\n-\t((ucontext_t*)&mp->g0->context[0])->uc_stack.ss_size = (size_t)g0_spsize;\n-\tmakecontext((ucontext_t*)&mp->g0->context[0], kickoff, 0);\n+\tuc = ucontext_arg(&mp->g0->context[0]);\n+\tgetcontext(uc);\n+\tuc->uc_stack.ss_sp = g0_sp;\n+\tuc->uc_stack.ss_size = (size_t)g0_spsize;\n+\tmakecontext(uc, kickoff, 0);\n \n \t// Add m to the extra list.\n \tmnext = lockextra(true);\n@@ -2007,7 +2023,7 @@ runtime_entersyscall()\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n-\tgetcontext((ucontext_t*)&g->gcregs[0]);\n+\tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n \t// Do the work in a separate function, so that this function\n \t// doesn't save any registers on its own stack.  If this\n@@ -2086,7 +2102,7 @@ runtime_entersyscallblock(void)\n \n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n-\tgetcontext((ucontext_t*)&g->gcregs[0]);\n+\tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n \tg->atomicstatus = _Gsyscall;\n \n@@ -2375,14 +2391,16 @@ __go_go(void (*fn)(void*), void* arg)\n \t\tbyte * volatile vsp = sp;\n \t\tsize_t volatile vspsize = spsize;\n \t\tG * volatile vnewg = newg;\n+\t\tucontext_t * volatile uc;\n \n-\t\tgetcontext((ucontext_t*)&vnewg->context[0]);\n-\t\t((ucontext_t*)&vnewg->context[0])->uc_stack.ss_sp = vsp;\n+\t\tuc = ucontext_arg(&vnewg->context[0]);\n+\t\tgetcontext(uc);\n+\t\tuc->uc_stack.ss_sp = vsp;\n #ifdef MAKECONTEXT_STACK_TOP\n-\t\t((ucontext_t*)&vnewg->context[0])->uc_stack.ss_sp += vspsize;\n+\t\tuc->uc_stack.ss_sp += vspsize;\n #endif\n-\t\t((ucontext_t*)&vnewg->context[0])->uc_stack.ss_size = vspsize;\n-\t\tmakecontext((ucontext_t*)&vnewg->context[0], kickoff, 0);\n+\t\tuc->uc_stack.ss_size = vspsize;\n+\t\tmakecontext(uc, kickoff, 0);\n \n \t\trunqput(p, vnewg);\n "}]}