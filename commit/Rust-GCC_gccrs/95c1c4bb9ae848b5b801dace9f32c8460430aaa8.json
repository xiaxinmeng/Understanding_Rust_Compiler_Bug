{"sha": "95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjMWM0YmI5YWU4NDhiNWI4MDFkYWNlOWYzMmM4NDYwNDMwYWFhOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-09-29T10:54:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-09-29T10:54:12Z"}, "message": "decl.c (gnat_to_gnu_entity): Rewrite the handling of constrained discriminated record subtypes.\n\n\t* decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Rewrite the handling\n\tof constrained discriminated record subtypes.\n\t(components_to_record): Declare the type of the variants and of the\n\tqualified union.\n\t(build_subst_list): Move around.\n\t(compute_field_positions): Rename into...\n\t(build_position_list): ...this.  Return a TREE_VEC.\n\t(annotate_rep): Adjust for above renaming.\n\t(build_variant_list): New static function.\n\t(create_field_decl_from): Likewise.\n\t(get_rep_part): Likewise.\n\t(get_variant_part): Likewise.\n\t(create_variant_part_from): Likewise.\n\t(copy_and_substitute_in_size): Likewise.\n\nFrom-SVN: r152272", "tree": {"sha": "9918c7b18a8e3e2c5fd23096c54d62a01f7b8e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9918c7b18a8e3e2c5fd23096c54d62a01f7b8e95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c1c4bb9ae848b5b801dace9f32c8460430aaa8/comments", "author": null, "committer": null, "parents": [{"sha": "1dd61ee507f808d0fdffee0ed3c17377e424bdd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dd61ee507f808d0fdffee0ed3c17377e424bdd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dd61ee507f808d0fdffee0ed3c17377e424bdd7"}], "stats": {"total": 655, "additions": 496, "deletions": 159}, "files": [{"sha": "eecf1c736ec2bbbd8020e875aa09f0a3839a8f92", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c1c4bb9ae848b5b801dace9f32c8460430aaa8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c1c4bb9ae848b5b801dace9f32c8460430aaa8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "patch": "@@ -1,3 +1,20 @@\n+2009-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* decl.c (gnat_to_gnu_entity) <E_Record_Subtype>: Rewrite the handling\n+\tof constrained discriminated record subtypes.\n+\t(components_to_record): Declare the type of the variants and of the\n+\tqualified union.\n+\t(build_subst_list): Move around.\n+\t(compute_field_positions): Rename into...\n+\t(build_position_list): ...this.  Return a TREE_VEC.\n+\t(annotate_rep): Adjust for above renaming.\n+\t(build_variant_list): New static function.\n+\t(create_field_decl_from): Likewise.\n+\t(get_rep_part): Likewise.\n+\t(get_variant_part): Likewise.\n+\t(create_variant_part_from): Likewise.\n+\t(copy_and_substitute_in_size): Likewise.\n+\n 2009-09-28  Olivier Hainque  <hainque@adacore.com>\n \n \tPR ada/41100"}, {"sha": "179418e8a95f39b1a9557d999dcdeb4147dee3c4", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 479, "deletions": 159, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c1c4bb9ae848b5b801dace9f32c8460430aaa8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c1c4bb9ae848b5b801dace9f32c8460430aaa8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=95c1c4bb9ae848b5b801dace9f32c8460430aaa8", "patch": "@@ -122,7 +122,6 @@ enum alias_set_op\n \n static void relate_alias_sets (tree, tree, enum alias_set_op);\n \n-static tree build_subst_list (Entity_Id, Entity_Id, bool);\n static bool allocatable_size_p (tree, bool);\n static void prepend_one_attribute_to (struct attrib **,\n \t\t\t\t      enum attr_type, tree, tree, Node_Id);\n@@ -142,14 +141,21 @@ static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n \t\t\t\t  bool, bool, bool, bool, bool);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n-static tree compute_field_positions (tree, tree, tree, tree, unsigned int);\n+static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n+static tree build_subst_list (Entity_Id, Entity_Id, bool);\n+static tree build_variant_list (tree, tree, tree);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n-static int compatible_signatures_p (tree ftype1, tree ftype2);\n+static int compatible_signatures_p (tree, tree);\n+static tree create_field_decl_from (tree, tree, tree, tree, tree, tree);\n+static tree get_rep_part (tree);\n+static tree get_variant_part (tree);\n+static tree create_variant_part_from (tree, tree, tree, tree, tree);\n+static void copy_and_substitute_in_size (tree, tree, tree);\n static void rest_of_type_decl_compilation_no_defer (tree);\n \f\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n@@ -3085,9 +3091,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* When the subtype has discriminants and these discriminants affect\n-\t     the initial shape it has inherited, factor them in.  But for the\n-\t     of an Unchecked_Union (it must be an Itype), just return the type.\n-\n+\t     the initial shape it has inherited, factor them in.  But for an\n+\t     Unchecked_Union (it must be an Itype), just return the type.\n \t     We can't just test Is_Constrained because private subtypes without\n \t     discriminants of types with discriminants with default expressions\n \t     are Is_Constrained but aren't constrained!  */\n@@ -3101,54 +3106,76 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      tree gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n-\t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n-\t      tree gnu_unpad_base_type, t;\n+\t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part, t;\n+\t      tree gnu_variant_list, gnu_pos_list, gnu_field_list = NULL_TREE;\n+\t      bool selected_variant = false;\n \t      Entity_Id gnat_field;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n \n \t      /* Set the size, alignment and alias set of the new type to\n-\t\t match that of the old one, doing required substitutions.\n-\t\t We do it this early because we need the size of the new\n-\t\t type below to discard old fields if necessary.  */\n-\t      TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_base_type);\n-\t      TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_base_type);\n-\t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_ADA_SIZE (gnu_base_type));\n-\t      TYPE_ALIGN (gnu_type) = TYPE_ALIGN (gnu_base_type);\n-\t      relate_alias_sets (gnu_type, gnu_base_type, ALIAS_SET_COPY);\n-\n-\t      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n-\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n-\t\t  TYPE_SIZE (gnu_type)\n-\t\t    = substitute_in_expr (TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  TREE_PURPOSE (t),\n-\t\t\t\t\t  TREE_VALUE (t));\n-\n-\t      if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (gnu_type)))\n-\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n-\t\t  TYPE_SIZE_UNIT (gnu_type)\n-\t\t    = substitute_in_expr (TYPE_SIZE_UNIT (gnu_type),\n-\t\t\t\t\t  TREE_PURPOSE (t),\n-\t\t\t\t\t  TREE_VALUE (t));\n-\n-\t      if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (gnu_type)))\n-\t\tfor (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n-\t\t  SET_TYPE_ADA_SIZE\n-\t\t    (gnu_type, substitute_in_expr (TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t\t\t   TREE_PURPOSE (t),\n-\t\t\t\t\t\t   TREE_VALUE (t)));\n+\t\t match that of the old one, doing required substitutions.  */\n+\t      copy_and_substitute_in_size (gnu_type, gnu_base_type,\n+\t\t\t\t\t   gnu_subst_list);\n \n \t      if (TREE_CODE (gnu_base_type) == RECORD_TYPE\n \t\t  && TYPE_IS_PADDING_P (gnu_base_type))\n \t\tgnu_unpad_base_type = TREE_TYPE (TYPE_FIELDS (gnu_base_type));\n \t      else\n \t\tgnu_unpad_base_type = gnu_base_type;\n \n+\t      /* Look for a REP part in the base type.  */\n+\t      gnu_rep_part = get_rep_part (gnu_unpad_base_type);\n+\n+\t      /* Look for a variant part in the base type.  */\n+\t      gnu_variant_part = get_variant_part (gnu_unpad_base_type);\n+\n+\t      /* If there is a variant part, we must compute whether the\n+\t\t constraints statically select a particular variant.  If\n+\t\t so, we simply drop the qualified union and flatten the\n+\t\t list of fields.  Otherwise we'll build a new qualified\n+\t\t union for the variants that are still relevant.  */\n+\t      if (gnu_variant_part)\n+\t\t{\n+\t\t  gnu_variant_list\n+\t\t    = build_variant_list (TREE_TYPE (gnu_variant_part),\n+\t\t\t\t\t  gnu_subst_list, NULL_TREE);\n+\n+\t\t  /* If all the qualifiers are unconditionally true, the\n+\t\t     innermost variant is statically selected.  */\n+\t\t  selected_variant = true;\n+\t\t  for (t = gnu_variant_list; t; t = TREE_CHAIN (t))\n+\t\t    if (!integer_onep (TREE_VEC_ELT (TREE_VALUE (t), 1)))\n+\t\t      {\n+\t\t\tselected_variant = false;\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t  /* Otherwise, create the new variants.  */\n+\t\t  if (!selected_variant)\n+\t\t    for (t = gnu_variant_list; t; t = TREE_CHAIN (t))\n+\t\t      {\n+\t\t\ttree old_variant = TREE_PURPOSE (t);\n+\t\t\ttree new_variant = make_node (RECORD_TYPE);\n+\t\t\tTYPE_NAME (new_variant)\n+\t\t\t  = DECL_NAME (TYPE_NAME (old_variant));\n+\t\t\tcopy_and_substitute_in_size (new_variant, old_variant,\n+\t\t\t\t\t\t     gnu_subst_list);\n+\t\t\tTREE_VEC_ELT (TREE_VALUE (t), 2) = new_variant;\n+\t\t      }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gnu_variant_list = NULL_TREE;\n+\t\t  selected_variant = false;\n+\t\t}\n+\n \t      gnu_pos_list\n-\t\t= compute_field_positions (gnu_unpad_base_type, NULL_TREE,\n-\t\t\t\t\t   size_zero_node, bitsize_zero_node,\n-\t\t\t\t\t   BIGGEST_ALIGNMENT);\n+\t\t= build_position_list (gnu_unpad_base_type,\n+\t\t\t\t       gnu_variant_list && !selected_variant,\n+\t\t\t\t       size_zero_node, bitsize_zero_node,\n+\t\t\t\t       BIGGEST_ALIGNMENT, NULL_TREE);\n \n \t      for (gnat_field = First_Entity (gnat_entity);\n \t\t   Present (gnat_field);\n@@ -3166,16 +3193,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      = Original_Record_Component (gnat_field);\n \t\t    tree gnu_old_field\n \t\t      = gnat_to_gnu_field_decl (gnat_old_field);\n-\t\t    tree gnu_offset\n-\t\t      = TREE_VALUE\n-\t\t\t(purpose_member (gnu_old_field, gnu_pos_list));\n-\t\t    tree gnu_pos = TREE_PURPOSE (gnu_offset);\n-\t\t    tree gnu_bitpos = TREE_VALUE (TREE_VALUE (gnu_offset));\n-\t\t    tree gnu_field, gnu_field_type, gnu_size, gnu_new_pos;\n-\t\t    tree gnu_last = NULL_TREE;\n-\t\t    unsigned int offset_align\n-\t\t      = tree_low_cst\n-\t\t\t(TREE_PURPOSE (TREE_VALUE (gnu_offset)), 1);\n+\t\t    tree gnu_context = DECL_CONTEXT (gnu_old_field);\n+\t\t    tree gnu_field, gnu_field_type, gnu_size;\n+\t\t    tree gnu_cont_type, gnu_last = NULL_TREE;\n \n \t\t    /* If the type is the same, retrieve the GCC type from the\n \t\t       old field to take into account possible adjustments.  */\n@@ -3219,67 +3239,50 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    else\n \t\t      gnu_size = TYPE_SIZE (gnu_field_type);\n \n-\t\t    if (CONTAINS_PLACEHOLDER_P (gnu_pos))\n-\t\t      for (t = gnu_subst_list; t; t = TREE_CHAIN (t))\n-\t\t\tgnu_pos = substitute_in_expr (gnu_pos,\n-\t\t\t\t\t\t      TREE_PURPOSE (t),\n-\t\t\t\t\t\t      TREE_VALUE (t));\n-\n-\t\t    /* If the position is now a constant, we can set it as the\n-\t\t       position of the field when we make it.  Otherwise, we\n-\t\t       need to deal with it specially below.  */\n-\t\t    if (TREE_CONSTANT (gnu_pos))\n+\t\t    /* If the context of the old field is the base type or its\n+\t\t       REP part (if any), put the field directly in the new\n+\t\t       type; otherwise look up the context in the variant list\n+\t\t       and put the field either in the new type if there is a\n+\t\t       selected variant or in one of the new variants.  */\n+\t\t    if (gnu_context == gnu_unpad_base_type\n+\t\t        || (gnu_rep_part\n+\t\t\t    && gnu_context == TREE_TYPE (gnu_rep_part)))\n+\t\t      gnu_cont_type = gnu_type;\n+\t\t    else\n \t\t      {\n-\t\t        gnu_new_pos = bit_from_pos (gnu_pos, gnu_bitpos);\n-\n-\t\t\t/* Discard old fields that are outside the new type.\n-\t\t\t   This avoids confusing code scanning it to decide\n-\t\t\t   how to pass it to functions on some platforms.  */\n-\t\t\tif (TREE_CODE (gnu_new_pos) == INTEGER_CST\n-\t\t\t    && TREE_CODE (TYPE_SIZE (gnu_type)) == INTEGER_CST\n-\t\t\t    && !integer_zerop (gnu_size)\n-\t\t\t    && !tree_int_cst_lt (gnu_new_pos,\n-\t\t\t\t\t\t TYPE_SIZE (gnu_type)))\n+\t\t\tt = purpose_member (gnu_context, gnu_variant_list);\n+\t\t\tif (t)\n+\t\t\t  {\n+\t\t\t    if (selected_variant)\n+\t\t\t      gnu_cont_type = gnu_type;\n+\t\t\t    else\n+\t\t\t      gnu_cont_type = TREE_VEC_ELT (TREE_VALUE (t), 2);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  /* The front-end may pass us \"ghost\" components if\n+\t\t\t     it fails to recognize that a constrained subtype\n+\t\t\t     is statically constrained.  Discard them.  */\n \t\t\t  continue;\n \t\t      }\n-\t\t    else\n-\t\t      gnu_new_pos = NULL_TREE;\n \n+\t\t    /* Now create the new field modeled on the old one.  */\n \t\t    gnu_field\n-\t\t      = create_field_decl\n-\t\t\t(DECL_NAME (gnu_old_field), gnu_field_type, gnu_type,\n-\t\t\t DECL_PACKED (gnu_old_field), gnu_size, gnu_new_pos,\n-\t\t\t !DECL_NONADDRESSABLE_P (gnu_old_field));\n+\t\t      = create_field_decl_from (gnu_old_field, gnu_field_type,\n+\t\t\t\t\t\tgnu_cont_type, gnu_size,\n+\t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n \n-\t\t    if (!TREE_CONSTANT (gnu_pos))\n+\t\t    /* Put it in one of the new variants directly.  */\n+\t\t    if (gnu_cont_type != gnu_type)\n \t\t      {\n-\t\t\tnormalize_offset (&gnu_pos, &gnu_bitpos, offset_align);\n-\t\t\tDECL_FIELD_OFFSET (gnu_field) = gnu_pos;\n-\t\t\tDECL_FIELD_BIT_OFFSET (gnu_field) = gnu_bitpos;\n-\t\t\tSET_DECL_OFFSET_ALIGN (gnu_field, offset_align);\n-\t\t\tDECL_SIZE (gnu_field) = gnu_size;\n-\t\t\tDECL_SIZE_UNIT (gnu_field)\n-\t\t\t  = convert (sizetype,\n-\t\t\t\t     size_binop (CEIL_DIV_EXPR, gnu_size,\n-\t\t\t\t\t\t bitsize_unit_node));\n-\t\t\tlayout_decl (gnu_field, DECL_OFFSET_ALIGN (gnu_field));\n+\t\t\tTREE_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n+\t\t\tTYPE_FIELDS (gnu_cont_type) = gnu_field;\n \t\t      }\n \n-\t\t    DECL_INTERNAL_P (gnu_field)\n-\t\t      = DECL_INTERNAL_P (gnu_old_field);\n-\t\t    SET_DECL_ORIGINAL_FIELD\n-\t\t      (gnu_field, (DECL_ORIGINAL_FIELD (gnu_old_field)\n-\t\t\t\t   ? DECL_ORIGINAL_FIELD (gnu_old_field)\n-\t\t\t\t   : gnu_old_field));\n-\t\t    DECL_DISCRIMINANT_NUMBER (gnu_field)\n-\t\t      = DECL_DISCRIMINANT_NUMBER (gnu_old_field);\n-\t\t    TREE_THIS_VOLATILE (gnu_field)\n-\t\t      = TREE_THIS_VOLATILE (gnu_old_field);\n-\n \t\t    /* To match the layout crafted in components_to_record,\n \t\t       if this is the _Tag or _Parent field, put it before\n \t\t       any other fields.  */\n-\t\t    if (gnat_name == Name_uTag || gnat_name == Name_uParent)\n+\t\t    else if (gnat_name == Name_uTag\n+\t\t\t     || gnat_name == Name_uParent)\n \t\t      gnu_field_list = chainon (gnu_field_list, gnu_field);\n \n \t\t    /* Similarly, if this is the _Controller field, put\n@@ -3304,6 +3307,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    save_gnu_tree (gnat_field, gnu_field, false);\n \t\t  }\n \n+\t      /* If there is a variant list and no selected variant, we need\n+\t\t to create the nest of variant parts from the old nest.  */\n+\t      if (gnu_variant_list && !selected_variant)\n+\t\t{\n+\t\t  tree new_variant_part\n+\t\t    = create_variant_part_from (gnu_variant_part,\n+\t\t\t\t\t\tgnu_variant_list, gnu_type,\n+\t\t\t\t\t\tgnu_pos_list, gnu_subst_list);\n+\t\t  TREE_CHAIN (new_variant_part) = gnu_field_list;\n+\t\t  gnu_field_list = new_variant_part;\n+\t\t}\n+\n \t      /* Now go through the entities again looking for Itypes that\n \t\t we have not elaborated but should (e.g., Etypes of fields\n \t\t that have Original_Components).  */\n@@ -3318,11 +3333,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_field_list = nreverse (gnu_field_list);\n \t      finish_record_type (gnu_type, gnu_field_list, 2, true);\n \n-\t      /* Finalize size and mode.  */\n-\t      TYPE_SIZE (gnu_type) = variable_size (TYPE_SIZE (gnu_type));\n-\t      TYPE_SIZE_UNIT (gnu_type)\n-\t\t= variable_size (TYPE_SIZE_UNIT (gnu_type));\n-\n \t      /* See the E_Record_Type case for the rationale.  */\n \t      if (Is_Tagged_Type (gnat_entity)\n \t\t  || Is_Limited_Record (gnat_entity))\n@@ -5549,37 +5559,6 @@ relate_alias_sets (tree gnu_new_type, tree gnu_old_type, enum alias_set_op op)\n   record_component_aliases (gnu_new_type);\n }\n \f\n-/* Return a TREE_LIST describing the substitutions needed to reflect the\n-   discriminant substitutions from GNAT_TYPE to GNAT_SUBTYPE.  They can\n-   be in any order.  TREE_PURPOSE gives the tree for the discriminant and\n-   TREE_VALUE is the replacement value.  They are in the form of operands\n-   to substitute_in_expr.  DEFINITION is true if this is for a definition\n-   of GNAT_SUBTYPE.  */\n-\n-static tree\n-build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n-{\n-  tree gnu_list = NULL_TREE;\n-  Entity_Id gnat_discrim;\n-  Node_Id gnat_value;\n-\n-  for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n-       gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n-       Present (gnat_discrim);\n-       gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n-       gnat_value = Next_Elmt (gnat_value))\n-    /* Ignore access discriminants.  */\n-    if (!Is_Access_Type (Etype (Node (gnat_value))))\n-      gnu_list = tree_cons (gnat_to_gnu_field_decl (gnat_discrim),\n-\t\t\t    elaborate_expression\n-\t\t\t    (Node (gnat_value), gnat_subtype,\n-\t\t\t     get_entity_name (gnat_discrim), definition,\n-\t\t\t     true, false),\n-\t\t\t    gnu_list);\n-\n-  return gnu_list;\n-}\n-\f\n /* Return true if the size represented by GNU_SIZE can be handled by an\n    allocation.  If STATIC_P is true, consider only what can be done with a\n    static allocation.  */\n@@ -6959,6 +6938,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t otherwise, the union type definition will be lacking\n \t\t the fields associated with these empty variants.  */\n \t      rest_of_record_type_compilation (gnu_variant_type);\n+\t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n+\t\t\t\tNULL, true, debug_info_p, gnat_component_list);\n \n \t      gnu_field = create_field_decl (gnu_inner_name, gnu_variant_type,\n \t\t\t\t\t     gnu_union_type, field_packed,\n@@ -7005,6 +6986,9 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      return;\n \t    }\n \n+\t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type,\n+\t\t\t    NULL, true, debug_info_p, gnat_component_list);\n+\n \t  /* Deal with packedness like in gnat_to_gnu_field.  */\n \t  union_field_packed\n \t    = adjust_packed (gnu_union_type, gnu_record_type, packed);\n@@ -7310,8 +7294,9 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \n   /* We operate by first making a list of all fields and their position (we\n      can get the size easily) and then update all the sizes in the tree.  */\n-  gnu_list = compute_field_positions (gnu_type, NULL_TREE, size_zero_node,\n-\t\t\t\t      bitsize_zero_node, BIGGEST_ALIGNMENT);\n+  gnu_list\n+    = build_position_list (gnu_type, false, size_zero_node, bitsize_zero_node,\n+\t\t\t   BIGGEST_ALIGNMENT, NULL_TREE);\n \n   for (gnat_field = First_Entity (gnat_entity);\n        Present (gnat_field);\n@@ -7346,9 +7331,8 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n \t      (gnat_field,\n \t       annotate_value\n \t\t (size_binop (PLUS_EXPR,\n-\t\t\t      bit_from_pos (TREE_PURPOSE (TREE_VALUE (t)),\n-\t\t\t\t\t    TREE_VALUE (TREE_VALUE\n-\t\t\t\t\t\t\t(TREE_VALUE (t)))),\n+\t\t\t      bit_from_pos (TREE_VEC_ELT (TREE_VALUE (t), 0),\n+\t\t\t\t\t    TREE_VEC_ELT (TREE_VALUE (t), 2)),\n \t\t\t      parent_offset)));\n \n \t    Set_Esize (gnat_field,\n@@ -7368,17 +7352,17 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n       }\n }\n \f\n-/* Scan all fields in GNU_TYPE and build entries where TREE_PURPOSE is the\n-   FIELD_DECL and TREE_VALUE a TREE_LIST with TREE_PURPOSE being the byte\n-   position and TREE_VALUE being a TREE_LIST with TREE_PURPOSE the value to be\n-   placed into DECL_OFFSET_ALIGN and TREE_VALUE the bit position.  GNU_POS is\n-   to be added to the position, GNU_BITPOS to the bit position, OFFSET_ALIGN is\n-   the present value of DECL_OFFSET_ALIGN and GNU_LIST is a list of the entries\n-   so far.  */\n+/* Scan all fields in GNU_TYPE and return a TREE_LIST where TREE_PURPOSE is\n+   the FIELD_DECL and TREE_VALUE a TREE_VEC containing the byte position, the\n+   value to be placed into DECL_OFFSET_ALIGN and the bit position.  The list\n+   of fields is flattened, except for variant parts if DO_NOT_FLATTEN_VARIANT\n+   is set to true.  GNU_POS is to be added to the position, GNU_BITPOS to the\n+   bit position, OFFSET_ALIGN is the present offset alignment.  GNU_LIST is a\n+   pre-existing list to be chained to the newly created entries.  */\n \n static tree\n-compute_field_positions (tree gnu_type, tree gnu_list, tree gnu_pos,\n-\t\t\t tree gnu_bitpos, unsigned int offset_align)\n+build_position_list (tree gnu_type, bool do_not_flatten_variant, tree gnu_pos,\n+\t\t     tree gnu_bitpos, unsigned int offset_align, tree gnu_list)\n {\n   tree gnu_field;\n \n@@ -7392,20 +7376,109 @@ compute_field_positions (tree gnu_type, tree gnu_list, tree gnu_pos,\n \t\t\t\t\tDECL_FIELD_OFFSET (gnu_field));\n       unsigned int our_offset_align\n \t= MIN (offset_align, DECL_OFFSET_ALIGN (gnu_field));\n+      tree v = make_tree_vec (3);\n \n-      gnu_list\n-\t= tree_cons (gnu_field,\n-\t\t     tree_cons (gnu_our_offset,\n-\t\t\t\ttree_cons (size_int (our_offset_align),\n-\t\t\t\t\t   gnu_our_bitpos, NULL_TREE),\n-\t\t\t\tNULL_TREE),\n-\t\t     gnu_list);\n+      TREE_VEC_ELT (v, 0) = gnu_our_offset;\n+      TREE_VEC_ELT (v, 1) = size_int (our_offset_align);\n+      TREE_VEC_ELT (v, 2) = gnu_our_bitpos;\n+      gnu_list = tree_cons (gnu_field, v, gnu_list);\n \n+      /* Recurse on internal fields, flattening the nested fields except for\n+\t those in the variant part, if requested.  */\n       if (DECL_INTERNAL_P (gnu_field))\n-\tgnu_list\n-\t  = compute_field_positions (TREE_TYPE (gnu_field), gnu_list,\n+\t{\n+\t  tree gnu_field_type = TREE_TYPE (gnu_field);\n+\t  if (do_not_flatten_variant\n+\t      && TREE_CODE (gnu_field_type) == QUAL_UNION_TYPE)\n+\t    gnu_list\n+\t      = build_position_list (gnu_field_type, do_not_flatten_variant,\n+\t\t\t\t     size_zero_node, bitsize_zero_node,\n+\t\t\t\t     BIGGEST_ALIGNMENT, gnu_list);\n+\t  else\n+\t    gnu_list\n+\t      = build_position_list (gnu_field_type, do_not_flatten_variant,\n \t\t\t\t     gnu_our_offset, gnu_our_bitpos,\n-\t\t\t\t     our_offset_align);\n+\t\t\t\t     our_offset_align, gnu_list);\n+\t}\n+    }\n+\n+  return gnu_list;\n+}\n+\n+/* Return a TREE_LIST describing the substitutions needed to reflect the\n+   discriminant substitutions from GNAT_TYPE to GNAT_SUBTYPE.  They can\n+   be in any order.  TREE_PURPOSE gives the tree for the discriminant and\n+   TREE_VALUE is the replacement value.  They are in the form of operands\n+   to SUBSTITUTE_IN_EXPR.  DEFINITION is true if this is for a definition\n+   of GNAT_SUBTYPE.  */\n+\n+static tree\n+build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n+{\n+  tree gnu_list = NULL_TREE;\n+  Entity_Id gnat_discrim;\n+  Node_Id gnat_value;\n+\n+  for (gnat_discrim = First_Stored_Discriminant (gnat_type),\n+       gnat_value = First_Elmt (Stored_Constraint (gnat_subtype));\n+       Present (gnat_discrim);\n+       gnat_discrim = Next_Stored_Discriminant (gnat_discrim),\n+       gnat_value = Next_Elmt (gnat_value))\n+    /* Ignore access discriminants.  */\n+    if (!Is_Access_Type (Etype (Node (gnat_value))))\n+      gnu_list = tree_cons (gnat_to_gnu_field_decl (gnat_discrim),\n+\t\t\t    elaborate_expression\n+\t\t\t    (Node (gnat_value), gnat_subtype,\n+\t\t\t     get_entity_name (gnat_discrim), definition,\n+\t\t\t     true, false),\n+\t\t\t    gnu_list);\n+\n+  return gnu_list;\n+}\n+\n+/* Scan all fields in QUAL_UNION_TYPE and return a TREE_LIST describing the\n+   variants of QUAL_UNION_TYPE that are still relevant after applying the\n+   substitutions described in SUBST_LIST.  TREE_PURPOSE is the type of the\n+   variant and TREE_VALUE is a TREE_VEC containing the field, the new value\n+   of the qualifier and NULL_TREE respectively.  GNU_LIST is a pre-existing\n+   list to be chained to the newly created entries.  */\n+\n+static tree\n+build_variant_list (tree qual_union_type, tree subst_list, tree gnu_list)\n+{\n+  tree gnu_field;\n+\n+  for (gnu_field = TYPE_FIELDS (qual_union_type);\n+       gnu_field;\n+       gnu_field = TREE_CHAIN (gnu_field))\n+    {\n+      tree t, qual = DECL_QUALIFIER (gnu_field);\n+\n+      for (t = subst_list; t; t = TREE_CHAIN (t))\n+\tqual = SUBSTITUTE_IN_EXPR (qual, TREE_PURPOSE (t), TREE_VALUE (t));\n+\n+      /* If the new qualifier is not unconditionally false, its variant may\n+\t still be accessed.  */\n+      if (!integer_zerop (qual))\n+\t{\n+\t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n+\t  tree v = make_tree_vec (3);\n+\t  TREE_VEC_ELT (v, 0) = gnu_field;\n+\t  TREE_VEC_ELT (v, 1) = qual;\n+\t  TREE_VEC_ELT (v, 2) = NULL_TREE;\n+\t  gnu_list = tree_cons (variant_type, v, gnu_list);\n+\n+\t  /* Recurse on the variant subpart of the variant, if any.  */\n+\t  variant_subpart = get_variant_part (variant_type);\n+\t  if (variant_subpart)\n+\t    gnu_list = build_variant_list (TREE_TYPE (variant_subpart),\n+\t\t\t\t\t   subst_list, gnu_list);\n+\n+\t  /* If the new qualifier is unconditionally true, the subsequent\n+\t     variants cannot be accessed.  */\n+\t  if (integer_onep (qual))\n+\t    break;\n+\t}\n     }\n \n   return gnu_list;\n@@ -7916,6 +7989,253 @@ compatible_signatures_p (tree ftype1, tree ftype2)\n   return 1;\n }\n \f\n+/* Return a FIELD_DECL node modeled on OLD_FIELD.  FIELD_TYPE is its type\n+   and RECORD_TYPE is the type of the parent.  If SIZE is nonzero, it is the\n+   specified size for this field.  POS_LIST is a position list describing\n+   the layout of OLD_FIELD and SUBST_LIST a substitution list to be applied\n+   to this layout.  */\n+\n+static tree\n+create_field_decl_from (tree old_field, tree field_type, tree record_type,\n+\t\t\ttree size, tree pos_list, tree subst_list)\n+{\n+  tree t = TREE_VALUE (purpose_member (old_field, pos_list));\n+  tree pos = TREE_VEC_ELT (t, 0), bitpos = TREE_VEC_ELT (t, 2);\n+  unsigned int offset_align = tree_low_cst (TREE_VEC_ELT (t, 1), 1);\n+  tree new_pos, new_field;\n+\n+  if (CONTAINS_PLACEHOLDER_P (pos))\n+    for (t = subst_list; t; t = TREE_CHAIN (t))\n+      pos = SUBSTITUTE_IN_EXPR (pos, TREE_PURPOSE (t), TREE_VALUE (t));\n+\n+  /* If the position is now a constant, we can set it as the position of the\n+     field when we make it.  Otherwise, we need to deal with it specially.  */\n+  if (TREE_CONSTANT (pos))\n+    new_pos = bit_from_pos (pos, bitpos);\n+  else\n+    new_pos = NULL_TREE;\n+\n+  new_field\n+    = create_field_decl (DECL_NAME (old_field), field_type, record_type,\n+\t\t\t DECL_PACKED (old_field), size, new_pos,\n+\t\t\t !DECL_NONADDRESSABLE_P (old_field));\n+\n+  if (!new_pos)\n+    {\n+      normalize_offset (&pos, &bitpos, offset_align);\n+      DECL_FIELD_OFFSET (new_field) = pos;\n+      DECL_FIELD_BIT_OFFSET (new_field) = bitpos;\n+      SET_DECL_OFFSET_ALIGN (new_field, offset_align);\n+      DECL_SIZE (new_field) = size;\n+      DECL_SIZE_UNIT (new_field)\n+\t= convert (sizetype,\n+\t\t   size_binop (CEIL_DIV_EXPR, size, bitsize_unit_node));\n+      layout_decl (new_field, DECL_OFFSET_ALIGN (new_field));\n+    }\n+\n+  DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n+  t = DECL_ORIGINAL_FIELD (old_field);\n+  SET_DECL_ORIGINAL_FIELD (new_field, t ? t : old_field);\n+  DECL_DISCRIMINANT_NUMBER (new_field) = DECL_DISCRIMINANT_NUMBER (old_field);\n+  TREE_THIS_VOLATILE (new_field) = TREE_THIS_VOLATILE (old_field);\n+\n+  return new_field;\n+}\n+\n+/* Return the REP part of RECORD_TYPE, if any.  Otherwise return NULL.  */\n+\n+static tree\n+get_rep_part (tree record_type)\n+{\n+  tree field = TYPE_FIELDS (record_type);\n+\n+  /* The REP part is the first field, internal, another record, and its name\n+     doesn't start with an underscore (i.e. is not generated by the FE).  */\n+  if (DECL_INTERNAL_P (field)\n+      && TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n+      && IDENTIFIER_POINTER (DECL_NAME (field)) [0] != '_')\n+    return field;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return the variant part of RECORD_TYPE, if any.  Otherwise return NULL.  */\n+\n+static tree\n+get_variant_part (tree record_type)\n+{\n+  tree field;\n+\n+  /* The variant part is the only internal field that is a qualified union.  */\n+  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+    if (DECL_INTERNAL_P (field)\n+\t&& TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE)\n+      return field;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return a new variant part modeled on OLD_VARIANT_PART.  VARIANT_LIST is\n+   the list of variants to be used and RECORD_TYPE is the type of the parent.\n+   POS_LIST is a position list describing the layout of fields present in\n+   OLD_VARIANT_PART and SUBST_LIST a substitution list to be applied to this\n+   layout.  */\n+\n+static tree\n+create_variant_part_from (tree old_variant_part, tree variant_list,\n+\t\t\t  tree record_type, tree pos_list, tree subst_list)\n+{\n+  tree offset = DECL_FIELD_OFFSET (old_variant_part);\n+  tree bitpos = DECL_FIELD_BIT_OFFSET (old_variant_part);\n+  tree old_union_type = TREE_TYPE (old_variant_part);\n+  tree new_union_type, new_variant_part, t;\n+  tree union_field_list = NULL_TREE;\n+\n+  /* First create the type of the variant part from that of the old one.  */\n+  new_union_type = make_node (QUAL_UNION_TYPE);\n+  TYPE_NAME (new_union_type) = DECL_NAME (TYPE_NAME (old_union_type));\n+\n+  /* If the position of the variant part is constant, subtract it from the\n+     size of the type of the parent to get the new size.  This manual CSE\n+     reduces the code size when not optimizing.  */\n+  if (TREE_CODE (offset) == INTEGER_CST && TREE_CODE (bitpos) == INTEGER_CST)\n+    {\n+      tree first_bit = bit_from_pos (offset, bitpos);\n+      TYPE_SIZE (new_union_type)\n+\t= size_binop (MINUS_EXPR, TYPE_SIZE (record_type), first_bit);\n+      TYPE_SIZE_UNIT (new_union_type)\n+\t= size_binop (MINUS_EXPR, TYPE_SIZE_UNIT (record_type),\n+\t\t      byte_from_pos (offset, bitpos));\n+      SET_TYPE_ADA_SIZE (new_union_type,\n+\t\t\t size_binop (MINUS_EXPR, TYPE_ADA_SIZE (record_type),\n+ \t\t\t\t     first_bit));\n+      TYPE_ALIGN (new_union_type) = TYPE_ALIGN (old_union_type);\n+      relate_alias_sets (new_union_type, old_union_type, ALIAS_SET_COPY);\n+    }\n+  else\n+    copy_and_substitute_in_size (new_union_type, old_union_type, subst_list);\n+\n+  /* Now finish up the new variants and populate the union type.  */\n+  for (t = variant_list; t; t = TREE_CHAIN (t))\n+    {\n+      tree old_field = TREE_VEC_ELT (TREE_VALUE (t), 0), new_field;\n+      tree old_variant, old_variant_subpart, new_variant, field_list;\n+\n+      /* Skip variants that don't belong to this nesting level.  */\n+      if (DECL_CONTEXT (old_field) != old_union_type)\n+\tcontinue;\n+\n+      /* Retrieve the list of fields already added to the new variant.  */\n+      new_variant = TREE_VEC_ELT (TREE_VALUE (t), 2);\n+      field_list = TYPE_FIELDS (new_variant);\n+\n+      /* If the old variant had a variant subpart, we need to create a new\n+\t variant subpart and add it to the field list.  */\n+      old_variant = TREE_PURPOSE (t);\n+      old_variant_subpart = get_variant_part (old_variant);\n+      if (old_variant_subpart)\n+\t{\n+\t  tree new_variant_subpart\n+\t    = create_variant_part_from (old_variant_subpart, variant_list,\n+\t\t\t\t\tnew_variant, pos_list, subst_list);\n+\t  TREE_CHAIN (new_variant_subpart) = field_list;\n+\t  field_list = new_variant_subpart;\n+\t}\n+\n+      /* Finish up the new variant and create the field.  */\n+      finish_record_type (new_variant, nreverse (field_list), 2, true);\n+      compute_record_mode (new_variant);\n+      rest_of_record_type_compilation (new_variant);\n+\n+      /* No need for debug info thanks to the XVS type.  */\n+      create_type_decl (TYPE_NAME (new_variant), new_variant, NULL,\n+\t\t\ttrue, false, Empty);\n+\n+      new_field\n+\t= create_field_decl_from (old_field, new_variant, new_union_type,\n+\t\t\t\t  TYPE_SIZE (new_variant),\n+\t\t\t\t  pos_list, subst_list);\n+      DECL_QUALIFIER (new_field) = TREE_VEC_ELT (TREE_VALUE (t), 1);\n+      DECL_INTERNAL_P (new_field) = 1;\n+      TREE_CHAIN (new_field) = union_field_list;\n+      union_field_list = new_field;\n+    }\n+\n+  /* Finish up the union type and create the variant part.  */\n+  finish_record_type (new_union_type, union_field_list, 2, true);\n+  compute_record_mode (new_union_type);\n+  rest_of_record_type_compilation (new_union_type);\n+\n+  /* No need for debug info thanks to the XVS type.  */\n+  create_type_decl (TYPE_NAME (new_union_type), new_union_type, NULL,\n+\t\t    true, false, Empty);\n+\n+  new_variant_part\n+    = create_field_decl_from (old_variant_part, new_union_type, record_type,\n+\t\t\t      TYPE_SIZE (new_union_type),\n+\t\t\t      pos_list, subst_list);\n+  DECL_INTERNAL_P (new_variant_part) = 1;\n+\n+  /* With multiple discriminants it is possible for an inner variant to be\n+     statically selected while outer ones are not; in this case, the list\n+     of fields of the inner variant is not flattened and we end up with a\n+     qualified union with a single member.  Drop the useless container.  */\n+  if (!TREE_CHAIN (union_field_list))\n+    {\n+      DECL_CONTEXT (union_field_list) = record_type;\n+      DECL_FIELD_OFFSET (union_field_list)\n+\t= DECL_FIELD_OFFSET (new_variant_part);\n+      DECL_FIELD_BIT_OFFSET (union_field_list)\n+\t= DECL_FIELD_BIT_OFFSET (new_variant_part);\n+      SET_DECL_OFFSET_ALIGN (union_field_list,\n+\t\t\t     DECL_OFFSET_ALIGN (new_variant_part));\n+      new_variant_part = union_field_list;\n+    }\n+\n+  return new_variant_part;\n+}\n+\n+/* Copy the size (and alignment and alias set) from OLD_TYPE to NEW_TYPE,\n+   which are both RECORD_TYPE, after applying the substitutions described\n+   in SUBST_LIST.  */\n+\n+static void\n+copy_and_substitute_in_size (tree new_type, tree old_type, tree subst_list)\n+{\n+  tree t;\n+\n+  TYPE_SIZE (new_type) = TYPE_SIZE (old_type);\n+  TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (old_type);\n+  SET_TYPE_ADA_SIZE (new_type, TYPE_ADA_SIZE (old_type));\n+  TYPE_ALIGN (new_type) = TYPE_ALIGN (old_type);\n+  relate_alias_sets (new_type, old_type, ALIAS_SET_COPY);\n+\n+  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (new_type)))\n+    for (t = subst_list; t; t = TREE_CHAIN (t))\n+      TYPE_SIZE (new_type)\n+\t= SUBSTITUTE_IN_EXPR (TYPE_SIZE (new_type),\n+\t\t\t      TREE_PURPOSE (t),\n+\t\t\t      TREE_VALUE (t));\n+\n+  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (new_type)))\n+    for (t = subst_list; t; t = TREE_CHAIN (t))\n+      TYPE_SIZE_UNIT (new_type)\n+\t= SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (new_type),\n+\t\t\t      TREE_PURPOSE (t),\n+\t\t\t      TREE_VALUE (t));\n+\n+  if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (new_type)))\n+    for (t = subst_list; t; t = TREE_CHAIN (t))\n+      SET_TYPE_ADA_SIZE\n+\t(new_type, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (new_type),\n+\t\t\t\t       TREE_PURPOSE (t),\n+\t\t\t\t       TREE_VALUE (t)));\n+\n+  /* Finalize the size.  */\n+  TYPE_SIZE (new_type) = variable_size (TYPE_SIZE (new_type));\n+  TYPE_SIZE_UNIT (new_type) = variable_size (TYPE_SIZE_UNIT (new_type));\n+}\n+\f\n /* Given a type T, a FIELD_DECL F, and a replacement value R, return a\n    type with all size expressions that contain F in a PLACEHOLDER_EXPR\n    updated by replacing F with R."}]}