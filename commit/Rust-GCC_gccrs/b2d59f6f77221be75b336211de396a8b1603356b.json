{"sha": "b2d59f6f77221be75b336211de396a8b1603356b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJkNTlmNmY3NzIyMWJlNzViMzM2MjExZGUzOTZhOGIxNjAzMzU2Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T13:22:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-09T13:22:38Z"}, "message": "Makefile.in (gengtype): Use $(BUILD_ERRORS).\n\n\t* Makefile.in (gengtype): Use $(BUILD_ERRORS).\n\t(gengtype.o): Depend on errors.h.\n\t* genattrtab.c (strcmp_check): Use gcc_assert and gcc_unreachable.\n\t(attr_rtx_1, attr_printf, attr_copy_rtx, evaluate_eq_attr,\n\tattr_alt_subset_p, attr_alt_subset_of_compl_p,\n\tattr_alt_intersection, attr_alt_union, optimize_attrs, gen_insn,\n\twrite_test_expr, write_attr_value, write_eligible_delay,\n\tmake_internal_attr, make_numeric_value): Likewise.\n\t* genautomata.c (regexp_name, get_str_vect,\n\tgen_presence_absence_set, automaton_decl_hash,\n\tautomaton_decl_eq_p, insn_decl_hash, insn_decl_eq_p, decl_hash,\n\tdecl_eq_p, process_regexp, loop_in_regexp, check_loops_in_regexps,\n\tprocess_regexp_cycles, reserv_sets_cmp, set_unit_reserv,\n\ttest_unit_reserv, it_is_empty_reserv_sets,\n\treserv_sets_are_intersected, reserv_sets_shift, reserv_sets_or,\n\treserv_sets_and, output_cycle_reservs, get_free_state,\n\tintersected_state_reservs_p, states_union, remove_arc,\n\tcopy_insn_regexp, transform_1, transform_2, transform_3,\n\tregexp_transform_func, store_alt_unit_usage,\n\tcheck_regexp_units_distribution, process_seq_for_forming_states,\n\tprocess_alts_for_forming_states, make_automaton,\n\tform_arcs_marked_by_insn, create_composed_state,\n\tset_out_arc_insns_equiv_num, partition_equiv_class,\n\tprocess_insn_equiv_class, set_insn_equiv_classes,\n\tunits_to_automata_heuristic_distr, form_regexp,\n\tlongest_path_length, output_dfa_max_issue_rate, add_vect,\n\tout_state_arcs_num, add_vect_el, output_trans_table,\n\toutput_state_alts_table, output_dead_lock_vect,\n\toutput_max_insn_queue_index_def,\n\toutput_min_insn_conflict_delay_func,\n\toutput_internal_insn_latency_func, output_print_reservation_func,\n\toutput_cpu_unit_reservation_p, output_state_arcs,\n\tmake_insn_alts_attr, make_internal_dfa_insn_code_attr,\n\tmake_default_insn_latency_attr,\n\tform_important_insn_automata_lists): Likewise.\n\t* genemit.c (gen_exp, output_add_clobbers,\n\toutput_added_clobbers_hard_reg_p): Likewise.\n\t* genextract.c (print_path, main): Likewise.\n\t* genflags.c (gen_macro): Likewise.\n\t* gengenrtl.c: Include errors.h\n\t(type_from_format, accessor_from_format): Likewise.\n\t* gengtype.c (get_file_basename, output_mangled_typename,\n\twalk_type, write_types_process_field,\n\twrite_types_local_process_field): Likewise.\n\t* genmodes.c (complete_mode): Likewise.\n\t* genopinit.c (gen_insn): Likewise.\n\t* genoutput.c (output_insn_data, check_constraint_len,\n\tconstraint_len): Likewise.\n\t* genpreds.c (add_mode_tests):Likewise.\n\t* gen-protos.c (add_hash): Likewise.\n\t* genrecog.c (find_operand, find_matching_operand,\n\tvalidate_pattern, add_to_sequence, maybe_both_true,\n\tnodes_identical_1, merge_trees, write_switch, write_cond,\n\twrite_action, is_unconditional, make_insn_sequence,\n\tdebug_decision_2): Likewise.\n\t* gensupport.c (is_predicable, collect_insn_data,\n\talter_predicate_for_insn, maybe_eval_c_test): Likewise.\n\nFrom-SVN: r87236", "tree": {"sha": "6fd0a5929e9f5230882fb5d3500103a7daee956f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fd0a5929e9f5230882fb5d3500103a7daee956f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2d59f6f77221be75b336211de396a8b1603356b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d59f6f77221be75b336211de396a8b1603356b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2d59f6f77221be75b336211de396a8b1603356b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2d59f6f77221be75b336211de396a8b1603356b/comments", "author": null, "committer": null, "parents": [{"sha": "87022a6b0e909befbd0cf98339cd65eede6060f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87022a6b0e909befbd0cf98339cd65eede6060f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87022a6b0e909befbd0cf98339cd65eede6060f3"}], "stats": {"total": 1388, "additions": 744, "deletions": 644}, "files": [{"sha": "d54bd875308277ff300a7cfc53c8efbfc7b8bb73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -1,11 +1,73 @@\n+2004-09-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Makefile.in (gengtype): Use $(BUILD_ERRORS).\n+\t(gengtype.o): Depend on errors.h.\n+\t* genattrtab.c (strcmp_check): Use gcc_assert and gcc_unreachable.\n+\t(attr_rtx_1, attr_printf, attr_copy_rtx, evaluate_eq_attr,\n+\tattr_alt_subset_p, attr_alt_subset_of_compl_p,\n+\tattr_alt_intersection, attr_alt_union, optimize_attrs, gen_insn,\n+\twrite_test_expr, write_attr_value, write_eligible_delay,\n+\tmake_internal_attr, make_numeric_value): Likewise.\n+\t* genautomata.c (regexp_name, get_str_vect,\n+\tgen_presence_absence_set, automaton_decl_hash,\n+\tautomaton_decl_eq_p, insn_decl_hash, insn_decl_eq_p, decl_hash,\n+\tdecl_eq_p, process_regexp, loop_in_regexp, check_loops_in_regexps,\n+\tprocess_regexp_cycles, reserv_sets_cmp, set_unit_reserv,\n+\ttest_unit_reserv, it_is_empty_reserv_sets,\n+\treserv_sets_are_intersected, reserv_sets_shift, reserv_sets_or,\n+\treserv_sets_and, output_cycle_reservs, get_free_state,\n+\tintersected_state_reservs_p, states_union, remove_arc,\n+\tcopy_insn_regexp, transform_1, transform_2, transform_3,\n+\tregexp_transform_func, store_alt_unit_usage,\n+\tcheck_regexp_units_distribution, process_seq_for_forming_states,\n+\tprocess_alts_for_forming_states, make_automaton,\n+\tform_arcs_marked_by_insn, create_composed_state,\n+\tset_out_arc_insns_equiv_num, partition_equiv_class,\n+\tprocess_insn_equiv_class, set_insn_equiv_classes,\n+\tunits_to_automata_heuristic_distr, form_regexp,\n+\tlongest_path_length, output_dfa_max_issue_rate, add_vect,\n+\tout_state_arcs_num, add_vect_el, output_trans_table,\n+\toutput_state_alts_table, output_dead_lock_vect,\n+\toutput_max_insn_queue_index_def,\n+\toutput_min_insn_conflict_delay_func,\n+\toutput_internal_insn_latency_func, output_print_reservation_func,\n+\toutput_cpu_unit_reservation_p, output_state_arcs,\n+\tmake_insn_alts_attr, make_internal_dfa_insn_code_attr,\n+\tmake_default_insn_latency_attr,\n+\tform_important_insn_automata_lists): Likewise.\n+\t* genemit.c (gen_exp, output_add_clobbers,\n+\toutput_added_clobbers_hard_reg_p): Likewise.\n+\t* genextract.c (print_path, main): Likewise.\n+\t* genflags.c (gen_macro): Likewise.\n+\t* gengenrtl.c: Include errors.h\n+\t(type_from_format, accessor_from_format): Likewise.\n+\t* gengtype.c (get_file_basename, output_mangled_typename,\n+\twalk_type, write_types_process_field,\n+\twrite_types_local_process_field): Likewise.\n+\t* genmodes.c (complete_mode): Likewise.\n+\t* genopinit.c (gen_insn): Likewise.\n+\t* genoutput.c (output_insn_data, check_constraint_len,\n+\tconstraint_len): Likewise.\n+\t* genpreds.c (add_mode_tests):Likewise.\n+\t* gen-protos.c (add_hash): Likewise.\n+\t* genrecog.c (find_operand, find_matching_operand,\n+\tvalidate_pattern, add_to_sequence, maybe_both_true,\n+\tnodes_identical_1, merge_trees, write_switch, write_cond,\n+\twrite_action, is_unconditional, make_insn_sequence,\n+\tdebug_decision_2): Likewise.\n+\t* gensupport.c (is_predicable, collect_insn_data,\n+\talter_predicate_for_insn, maybe_eval_c_test): Likewise.\n+\n 2004-09-09  Jan Hubicka  <jh@suse.cz>\n \n \t* basic-block.h (guess_outgoing_edge_probabilities): Declare.\n-\t* cfgbuild.c (compute_outgoing_frequencies): When probability is missing,\n-\tguess it.\n-\t(find_many_sub_basic_blocks): Do update profile only when it is present.\n+\t* cfgbuild.c (compute_outgoing_frequencies): When probability is\n+\tmissing, guess it.\n+\t(find_many_sub_basic_blocks): Do update profile only when it is\n+\tpresent.\n \t* predict.c (set_even_probabilities): Break out from ...\n-\t(combine_predictions_for_insn): ... here; deal with !can_predict_insn_p insns.\n+\t(combine_predictions_for_insn): ... here; deal with\n+\t!can_predict_insn_p insns.\n \t(combine_predictions_for_bb): Use set_even_probabilities.\n \t(bb_estimate_probability_locally): Break out from ....\n \t(estimate_probability): ... here.\n@@ -6720,7 +6782,7 @@\n \t* config/i386/xmmintrin.h: Include <mm_malloc.h>.\n \n 2004-08-03  H.J. Lu  <hongjiu.lu@intel.com>\n-\t    Tanguy Fautr\ufffd  <tfautre@pandora.be>\n+\t    Tanguy Fautr\u00c3  <tfautre@pandora.be>\n \n \t* config/i386/pmm_malloc.h: New file.\n "}, {"sha": "89f0ca1cd7b16f77a7f044677a78711b3815507c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -2609,12 +2609,13 @@ genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(GTM_H) errors.h gensupport.h $(OBSTACK_H)\n \n gengtype$(build_exeext) : gengtype.o gengtype-lex.o gengtype-yacc.o \\\n-  $(BUILD_LIBDEPS)\n+  $(BUILD_LIBDEPS) $(BUILD_ERRORS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n-\t gengtype.o gengtype-lex.o gengtype-yacc.o $(BUILD_LIBS)\n+\t gengtype.o gengtype-lex.o gengtype-yacc.o $(BUILD_ERRORS) \\\n+\t $(BUILD_LIBS)\n \n gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) \\\n-  gengtype.h gtyp-gen.h rtl.def insn-notes.def\n+  gengtype.h gtyp-gen.h rtl.def insn-notes.def errors.h\n \n gengtype-lex.o : gengtype-lex.c gengtype.h gengtype-yacc.h \\\n   $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H) vec.h"}, {"sha": "453b729804619078c7ac608ce21d01add96b15fe", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -21,7 +21,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"scan.h\"\n-#undef abort\n \n int verbose = 0;\n const char *progname;\n@@ -48,8 +47,7 @@ add_hash (const char *fname)\n       for (;;)\n \t{\n \t  i = (i+1) % HASH_SIZE;\n-\t  if (i == i0)\n-\t    abort ();\n+\t  gcc_assert (i != i0);\n \t  if (hash_tab[i] == 0)\n \t    break;\n \t}"}, {"sha": "f3385caa7dc11241823a8dbef909bea8e33412b9", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -102,9 +102,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if 0\n #define strcmp_check(S1, S2) ((S1) == (S2)\t\t\\\n \t\t\t      ? 0\t\t\t\\\n-\t\t\t      : (strcmp ((S1), (S2))\t\\\n-\t\t\t\t ? 1\t\t\t\\\n-\t\t\t\t : (abort (), 0)))\n+\t\t\t      : (gcc_assert (strcmp ((S1), (S2))), 1))\n #else\n #define strcmp_check(S1, S2) ((S1) != (S2))\n #endif\n@@ -596,7 +594,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t}\n       return rt_val;\n@@ -633,8 +631,7 @@ attr_printf (unsigned int len, const char *fmt, ...)\n \n   va_start (p, fmt);\n \n-  if (len > sizeof str - 1) /* Leave room for \\0.  */\n-    abort ();\n+  gcc_assert (len < sizeof str); /* Leave room for \\0.  */\n \n   vsprintf (str, fmt, p);\n   va_end (p);\n@@ -777,7 +774,7 @@ attr_copy_rtx (rtx orig)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return copy;\n@@ -2002,45 +1999,46 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n   rtx newexp;\n   int i;\n \n-  if (GET_CODE (value) == CONST_STRING)\n+  switch (GET_CODE (value))\n     {\n+    case CONST_STRING:\n       if (! strcmp_check (XSTR (value, 0), XSTR (exp, 1)))\n \tnewexp = true_rtx;\n       else\n \tnewexp = false_rtx;\n-    }\n-  else if (GET_CODE (value) == SYMBOL_REF)\n-    {\n-      char *p;\n-      char string[256];\n-\n-      if (GET_CODE (exp) != EQ_ATTR)\n-\tabort ();\n-\n-      if (strlen (XSTR (exp, 0)) + strlen (XSTR (exp, 1)) + 2 > 256)\n-\tabort ();\n-\n-      strcpy (string, XSTR (exp, 0));\n-      strcat (string, \"_\");\n-      strcat (string, XSTR (exp, 1));\n-      for (p = string; *p; p++)\n-\t*p = TOUPPER (*p);\n-\n-      newexp = attr_rtx (EQ, value,\n-\t\t\t attr_rtx (SYMBOL_REF,\n-\t\t\t\t   DEF_ATTR_STRING (string)));\n-    }\n-  else if (GET_CODE (value) == COND)\n-    {\n-      /* We construct an IOR of all the cases for which the requested attribute\n-\t value is present.  Since we start with FALSE, if it is not present,\n-\t FALSE will be returned.\n+      break;\n+      \n+    case SYMBOL_REF:\n+      {\n+\tchar *p;\n+\tchar string[256];\n+\t\n+\tgcc_assert (GET_CODE (exp) == EQ_ATTR);\n+\tgcc_assert (strlen (XSTR (exp, 0)) + strlen (XSTR (exp, 1)) + 2\n+\t\t    <= 256);\n+\t\n+\tstrcpy (string, XSTR (exp, 0));\n+\tstrcat (string, \"_\");\n+\tstrcat (string, XSTR (exp, 1));\n+\tfor (p = string; *p; p++)\n+\t  *p = TOUPPER (*p);\n+\t\n+\tnewexp = attr_rtx (EQ, value,\n+\t\t\t   attr_rtx (SYMBOL_REF,\n+\t\t\t\t     DEF_ATTR_STRING (string)));\n+\tbreak;\n+      }\n \n+    case COND:\n+      /* We construct an IOR of all the cases for which the\n+\t requested attribute value is present.  Since we start with\n+\t FALSE, if it is not present, FALSE will be returned.\n+\t  \n \t Each case is the AND of the NOT's of the previous conditions with the\n \t current condition; in the default case the current condition is TRUE.\n-\n+\t  \n \t For each possible COND value, call ourselves recursively.\n-\n+\t  \n \t The extra TRUE and FALSE expressions will be eliminated by another\n \t call to the simplification routine.  */\n \n@@ -2080,9 +2078,11 @@ evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n \t\t\t\t\t\t   insn_code, insn_index),\n \t\t\t\t insn_code, insn_index);\n       newexp = insert_right_side (IOR, orexp, right, insn_code, insn_index);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   /* If uses an address, must return original expression.  But set the\n      ATTR_IND_SIMPLIFIED_P bit so we don't try to simplify it again.  */\n@@ -2401,13 +2401,14 @@ attr_alt_subset_p (rtx s1, rtx s2)\n       return !(XINT (s2, 0) &~ XINT (s1, 0));\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n /* Returns true if S1 is a subset of complement of S2.  */\n \n-static bool attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n+static bool\n+attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n {\n   switch ((XINT (s1, 1) << 1) | XINT (s2, 1))\n     {\n@@ -2424,7 +2425,7 @@ static bool attr_alt_subset_of_compl_p (rtx s1, rtx s2)\n       return false;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2450,7 +2451,7 @@ attr_alt_intersection (rtx s1, rtx s2)\n       XINT (result, 0) = XINT (s1, 0) | XINT (s2, 0);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   XINT (result, 1) = XINT (s1, 1) & XINT (s2, 1);\n \n@@ -2479,7 +2480,7 @@ attr_alt_union (rtx s1, rtx s2)\n       XINT (result, 0) = XINT (s1, 0) & XINT (s2, 0);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   XINT (result, 1) = XINT (s1, 1) | XINT (s2, 1);\n@@ -2898,8 +2899,7 @@ optimize_attrs (void)\n \t  }\n \n   /* Sanity check on num_insn_ents.  */\n-  if (iv != ivbuf + num_insn_ents)\n-    abort ();\n+  gcc_assert (iv == ivbuf + num_insn_ents);\n \n   /* Process one insn code at a time.  */\n   for (i = -2; i < insn_code_number; i++)\n@@ -3210,7 +3210,7 @@ gen_insn (rtx exp, int lineno)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3354,7 +3354,7 @@ write_test_expr (rtx exp, int flags)\n \t  printf (\" >> \");\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       write_test_expr (XEXP (exp, 1), flags | comparison_operator);\n@@ -3388,7 +3388,7 @@ write_test_expr (rtx exp, int flags)\n \t  printf (\"-\");\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       write_test_expr (XEXP (exp, 0), flags);\n@@ -3454,8 +3454,7 @@ write_test_expr (rtx exp, int flags)\n \t}\n \n       attr = find_attr (&XSTR (exp, 0), 0);\n-      if (! attr)\n-\tabort ();\n+      gcc_assert (attr);\n \n       /* Now is the time to expand the value of a constant attribute.  */\n       if (attr->is_const)\n@@ -4062,7 +4061,7 @@ write_attr_value (struct attr_desc *attr, rtx value)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -4126,8 +4125,7 @@ write_eligible_delay (const char *kind)\n   printf (\"{\\n\");\n   printf (\"  rtx insn;\\n\");\n   printf (\"\\n\");\n-  printf (\"  if (slot >= %d)\\n\", max_slots);\n-  printf (\"    abort ();\\n\");\n+  printf (\"  gcc_assert (slot < %d)\\n\", max_slots);\n   printf (\"\\n\");\n   /* Allow dbr_schedule to pass labels, etc.  This can happen if try_split\n      converts a compound instruction into a loop.  */\n@@ -4140,8 +4138,7 @@ write_eligible_delay (const char *kind)\n   if (num_delays > 1)\n     {\n       attr = find_attr (&delay_type_str, 0);\n-      if (! attr)\n-\tabort ();\n+      gcc_assert (attr);\n       common_av = find_most_used (attr);\n \n       printf (\"  insn = delay_insn;\\n\");\n@@ -4157,8 +4154,7 @@ write_eligible_delay (const char *kind)\n       printf (\"    }\\n\\n\");\n \n       /* Ensure matched.  Otherwise, shouldn't have been called.  */\n-      printf (\"  if (slot < %d)\\n\", max_slots);\n-      printf (\"    abort ();\\n\\n\");\n+      printf (\"  gcc_assert (slot >= %d);\\n\\n\", max_slots);\n     }\n \n   /* If just one type of delay slot, write simple switch.  */\n@@ -4169,8 +4165,7 @@ write_eligible_delay (const char *kind)\n       printf (\"    {\\n\");\n \n       attr = find_attr (&delay_1_0_str, 0);\n-      if (! attr)\n-\tabort ();\n+      gcc_assert (attr);\n       common_av = find_most_used (attr);\n \n       for (av = attr->first_value; av; av = av->next)\n@@ -4200,8 +4195,7 @@ write_eligible_delay (const char *kind)\n \t    sprintf (str, \"*%s_%d_%d\", kind, delay->num, i / 3);\n \t    pstr = str;\n \t    attr = find_attr (&pstr, 0);\n-\t    if (! attr)\n-\t      abort ();\n+\t    gcc_assert (attr);\n \t    common_av = find_most_used (attr);\n \n \t    for (av = attr->first_value; av; av = av->next)\n@@ -4213,7 +4207,7 @@ write_eligible_delay (const char *kind)\n \t  }\n \n       printf (\"    default:\\n\");\n-      printf (\"      abort ();\\n\");\n+      printf (\"      gcc_unreachable ();\\n\");\n       printf (\"    }\\n\");\n     }\n \n@@ -4292,8 +4286,7 @@ make_internal_attr (const char *name, rtx value, int special)\n   struct attr_desc *attr;\n \n   attr = find_attr (&name, 1);\n-  if (attr->default_val)\n-    abort ();\n+  gcc_assert (!attr->default_val);\n \n   attr->is_numeric = 1;\n   attr->is_const = 0;\n@@ -4332,8 +4325,7 @@ make_numeric_value (int n)\n   rtx exp;\n   char *p;\n \n-  if (n < 0)\n-    abort ();\n+  gcc_assert (n >= 0);\n \n   if (n < 20 && int_values[n])\n     return int_values[n];"}, {"sha": "64dde93ed8e9f3464fb50417f12f9e960dd1233f", "filename": "gcc/genautomata.c", "status": "modified", "additions": 494, "deletions": 446, "changes": 940, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -1451,25 +1451,25 @@ static void regexp_mode_check_failed (enum regexp_mode, const char *,\n static const char *\n regexp_name (enum regexp_mode mode)\n {\n-  static char str [100];\n-\n-  if (mode == rm_unit)\n-    return \"rm_unit\";\n-  else if (mode == rm_reserv)\n-    return \"rm_reserv\";\n-  else if (mode == rm_nothing)\n-    return \"rm_nothing\";\n-  else if (mode == rm_sequence)\n-    return \"rm_sequence\";\n-  else if (mode == rm_repeat)\n-    return \"rm_repeat\";\n-  else if (mode == rm_allof)\n-    return \"rm_allof\";\n-  else if (mode == rm_oneof)\n-    return \"rm_oneof\";\n-  else\n-    sprintf (str, \"unknown (%d)\", (int) mode);\n-  return str;\n+  switch (mode)\n+    {\n+    case rm_unit:\n+      return \"rm_unit\";\n+    case rm_reserv:\n+      return \"rm_reserv\";\n+    case rm_nothing:\n+      return \"rm_nothing\";\n+    case rm_sequence:\n+      return \"rm_sequence\";\n+    case rm_repeat:\n+      return \"rm_repeat\";\n+    case rm_allof:\n+      return \"rm_allof\";\n+    case rm_oneof:\n+      return \"rm_oneof\";\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* The function prints message about unexpected regexp and finish the\n@@ -1629,6 +1629,7 @@ get_str_vect (char *str, int *els_num, int sep, int paren_p)\n   int i;\n   char **vect;\n   char **pstr;\n+  char *trail;\n \n   *els_num = n_sep_els (str, sep, paren_p);\n   if (*els_num <= 0)\n@@ -1639,8 +1640,8 @@ get_str_vect (char *str, int *els_num, int sep, int paren_p)\n   pstr = &str;\n   for (i = 0; i < *els_num; i++)\n     vect [i] = next_sep_el (pstr, sep, paren_p);\n-  if (next_sep_el (pstr, sep, paren_p) != NULL)\n-    abort ();\n+  trail = next_sep_el (pstr, sep, paren_p);\n+  gcc_assert (!trail);\n   vect [i] = NULL;\n   return vect;\n }\n@@ -1822,8 +1823,7 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n     {\n       str_patterns [i] = get_str_vect ((char *) str_patterns [i], &length, ' ',\n \t\t\t\t       FALSE);\n-      if (str_patterns [i] == NULL)\n-\tabort ();\n+      gcc_assert (str_patterns [i]);\n     }\n   decl = create_node (sizeof (struct decl));\n   decl->pos = 0;\n@@ -2167,8 +2167,8 @@ automaton_decl_hash (const void *automaton_decl)\n {\n   const decl_t decl = (decl_t) automaton_decl;\n \n-  if (decl->mode == dm_automaton && DECL_AUTOMATON (decl)->name == NULL)\n-    abort ();\n+  gcc_assert (decl->mode != dm_automaton\n+\t      || DECL_AUTOMATON (decl)->name);\n   return string_hash (DECL_AUTOMATON (decl)->name);\n }\n \n@@ -2183,9 +2183,10 @@ automaton_decl_eq_p (const void* automaton_decl_1,\n   const decl_t decl1 = (decl_t) automaton_decl_1;\n   const decl_t decl2 = (decl_t) automaton_decl_2;\n \n-  if (decl1->mode != dm_automaton || DECL_AUTOMATON (decl1)->name == NULL\n-      || decl2->mode != dm_automaton || DECL_AUTOMATON (decl2)->name == NULL)\n-    abort ();\n+  gcc_assert (decl1->mode == dm_automaton\n+\t      && DECL_AUTOMATON (decl1)->name\n+\t      && decl2->mode == dm_automaton\n+\t      && DECL_AUTOMATON (decl2)->name);\n   return strcmp (DECL_AUTOMATON (decl1)->name,\n \t\t DECL_AUTOMATON (decl2)->name) == 0;\n }\n@@ -2267,8 +2268,8 @@ insn_decl_hash (const void *insn_decl)\n {\n   const decl_t decl = (decl_t) insn_decl;\n \n-  if (decl->mode != dm_insn_reserv || DECL_INSN_RESERV (decl)->name == NULL)\n-    abort ();\n+  gcc_assert (decl->mode == dm_insn_reserv\n+\t      && DECL_INSN_RESERV (decl)->name);\n   return string_hash (DECL_INSN_RESERV (decl)->name);\n }\n \n@@ -2281,10 +2282,10 @@ insn_decl_eq_p (const void *insn_decl_1, const void *insn_decl_2)\n   const decl_t decl1 = (decl_t) insn_decl_1;\n   const decl_t decl2 = (decl_t) insn_decl_2;\n \n-  if (decl1->mode != dm_insn_reserv || DECL_INSN_RESERV (decl1)->name == NULL\n-      || decl2->mode != dm_insn_reserv\n-      || DECL_INSN_RESERV (decl2)->name == NULL)\n-    abort ();\n+  gcc_assert (decl1->mode == dm_insn_reserv\n+\t      && DECL_INSN_RESERV (decl1)->name\n+\t      && decl2->mode == dm_insn_reserv\n+\t      && DECL_INSN_RESERV (decl2)->name);\n   return strcmp (DECL_INSN_RESERV (decl1)->name,\n                  DECL_INSN_RESERV (decl2)->name) == 0;\n }\n@@ -2365,27 +2366,25 @@ decl_hash (const void *decl)\n {\n   const decl_t d = (const decl_t) decl;\n \n-  if ((d->mode != dm_unit || DECL_UNIT (d)->name == NULL)\n-      && (d->mode != dm_reserv || DECL_RESERV (d)->name == NULL))\n-    abort ();\n+  gcc_assert ((d->mode == dm_unit && DECL_UNIT (d)->name)\n+\t      || (d->mode == dm_reserv && DECL_RESERV (d)->name));\n   return string_hash (d->mode == dm_unit\n \t\t      ? DECL_UNIT (d)->name : DECL_RESERV (d)->name);\n }\n \n /* The function tests declarations on equality of their keys.  The\n-   function is used by abstract data `hashtab'.  The function\n+   function is used by abstract data 'hashtab'.  The function\n    returns 1 if the declarations have the same key, 0 otherwise.  */\n static int\n decl_eq_p (const void *decl_1, const void *decl_2)\n {\n   const decl_t d1 = (const decl_t) decl_1;\n   const decl_t d2 = (const decl_t) decl_2;\n \n-  if (((d1->mode != dm_unit || DECL_UNIT (d1)->name == NULL)\n-       && (d1->mode != dm_reserv || DECL_RESERV (d1)->name == NULL))\n-      || ((d2->mode != dm_unit || DECL_UNIT (d2)->name == NULL)\n-\t  && (d2->mode != dm_reserv || DECL_RESERV (d2)->name == NULL)))\n-    abort ();\n+  gcc_assert ((d1->mode == dm_unit && DECL_UNIT (d1)->name)\n+\t      || (d1->mode == dm_reserv && DECL_RESERV (d1)->name));\n+  gcc_assert ((d2->mode == dm_unit && DECL_UNIT (d2)->name)\n+\t      || (d2->mode == dm_reserv && DECL_RESERV (d2)->name));\n   return strcmp ((d1->mode == dm_unit\n                   ? DECL_UNIT (d1)->name : DECL_RESERV (d1)->name),\n                  (d2->mode == dm_unit\n@@ -3074,48 +3073,60 @@ process_regexp (regexp_t regexp)\n   regexp_t new_regexp;\n   int i;\n \n-  if (regexp->mode == rm_unit)\n+  switch (regexp->mode)\n     {\n+    case rm_unit:\n       decl_in_table = find_decl (REGEXP_UNIT (regexp)->name);\n       if (decl_in_table == NULL)\n         error (\"undeclared unit or reservation `%s'\",\n \t       REGEXP_UNIT (regexp)->name);\n-      else if (decl_in_table->mode == dm_unit)\n-\t{\n-\t  DECL_UNIT (decl_in_table)->unit_is_used = 1;\n-\t  REGEXP_UNIT (regexp)->unit_decl = DECL_UNIT (decl_in_table);\n-\t}\n-      else if (decl_in_table->mode == dm_reserv)\n-\t{\n-\t  DECL_RESERV (decl_in_table)->reserv_is_used = 1;\n-\t  new_regexp = create_node (sizeof (struct regexp));\n-\t  new_regexp->mode = rm_reserv;\n-\t  new_regexp->pos = regexp->pos;\n-\t  REGEXP_RESERV (new_regexp)->name = REGEXP_UNIT (regexp)->name;\n-\t  REGEXP_RESERV (new_regexp)->reserv_decl\n-\t    = DECL_RESERV (decl_in_table);\n-\t  regexp = new_regexp;\n-\t}\n       else\n-\tabort ();\n+\tswitch (decl_in_table->mode)\n+\t  {\n+\t  case dm_unit:\n+\t    DECL_UNIT (decl_in_table)->unit_is_used = 1;\n+\t    REGEXP_UNIT (regexp)->unit_decl = DECL_UNIT (decl_in_table);\n+\t    break;\n+\n+\t  case dm_reserv:\n+\t    DECL_RESERV (decl_in_table)->reserv_is_used = 1;\n+\t    new_regexp = create_node (sizeof (struct regexp));\n+\t    new_regexp->mode = rm_reserv;\n+\t    new_regexp->pos = regexp->pos;\n+\t    REGEXP_RESERV (new_regexp)->name = REGEXP_UNIT (regexp)->name;\n+\t    REGEXP_RESERV (new_regexp)->reserv_decl\n+\t      = DECL_RESERV (decl_in_table);\n+\t    regexp = new_regexp;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+      break;\n+    case rm_sequence:\n+      for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tREGEXP_SEQUENCE (regexp)->regexps [i]\n+\t  = process_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n+      break;\n+    case rm_allof:\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tREGEXP_ALLOF (regexp)->regexps [i]\n+\t  = process_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n+      break;\n+    case rm_oneof:\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\tREGEXP_ONEOF (regexp)->regexps [i]\n+\t  = process_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n+      break;\n+    case rm_repeat:\n+      REGEXP_REPEAT (regexp)->regexp\n+\t= process_regexp (REGEXP_REPEAT (regexp)->regexp);\n+      break;\n+    case rm_nothing:\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else if (regexp->mode == rm_sequence)\n-    for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n-     REGEXP_SEQUENCE (regexp)->regexps [i]\n-\t= process_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n-  else if (regexp->mode == rm_allof)\n-    for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n-      REGEXP_ALLOF (regexp)->regexps [i]\n-        = process_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n-  else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n-      REGEXP_ONEOF (regexp)->regexps [i]\n-\t= process_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n-  else if (regexp->mode == rm_repeat)\n-    REGEXP_REPEAT (regexp)->regexp\n-      = process_regexp (REGEXP_REPEAT (regexp)->regexp);\n-  else if (regexp->mode != rm_nothing)\n-    abort ();\n   return regexp;\n }\n \n@@ -3184,10 +3195,12 @@ loop_in_regexp (regexp_t regexp, decl_t start_decl)\n \n   if (regexp == NULL)\n     return 0;\n-  if (regexp->mode == rm_unit)\n-    return 0;\n-  else if (regexp->mode == rm_reserv)\n+  switch (regexp->mode)\n     {\n+      case rm_unit:\n+\treturn 0;\n+\n+    case rm_reserv:\n       if (start_decl->mode == dm_reserv\n           && REGEXP_RESERV (regexp)->reserv_decl == DECL_RESERV (start_decl))\n         return 1;\n@@ -3202,35 +3215,33 @@ loop_in_regexp (regexp_t regexp, decl_t start_decl)\n           return loop_in_regexp (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n                                  start_decl);\n         }\n-    }\n-  else if (regexp->mode == rm_sequence)\n-    {\n+\n+    case rm_sequence:\n       for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tif (loop_in_regexp (REGEXP_SEQUENCE (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n-    }\n-  else if (regexp->mode == rm_allof)\n-    {\n+\n+    case rm_allof:\n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \tif (loop_in_regexp (REGEXP_ALLOF (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n-    }\n-  else if (regexp->mode == rm_oneof)\n-    {\n+\n+    case rm_oneof:\n       for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \tif (loop_in_regexp (REGEXP_ONEOF (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n-    }\n-  else if (regexp->mode == rm_repeat)\n-    return loop_in_regexp (REGEXP_REPEAT (regexp)->regexp, start_decl);\n-  else\n-    {\n-      if (regexp->mode != rm_nothing)\n-\tabort ();\n+\n+    case rm_repeat:\n+      return loop_in_regexp (REGEXP_REPEAT (regexp)->regexp, start_decl);\n+\n+    case rm_nothing:\n       return 0;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3258,8 +3269,7 @@ check_loops_in_regexps (void)\n \t    DECL_RESERV (decl)->loop_pass_num = curr_loop_pass_num;\n \t    if (loop_in_regexp (DECL_RESERV (decl)->regexp, decl))\n \t      {\n-\t\tif (DECL_RESERV (decl)->regexp == NULL)\n-\t\t  abort ();\n+\t\tgcc_assert (DECL_RESERV (decl)->regexp);\n \t\terror (\"cycle in definition of reservation `%s'\",\n \t\t       DECL_RESERV (decl)->name);\n \t      }\n@@ -3276,22 +3286,25 @@ process_regexp_cycles (regexp_t regexp, int max_start_cycle,\n {\n   int i;\n \n-  if (regexp->mode == rm_unit)\n+  switch (regexp->mode)\n     {\n+    case rm_unit:\n       if (REGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num < max_start_cycle)\n \tREGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num = max_start_cycle;\n       if (REGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num > min_start_cycle\n \t  || REGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num == -1)\n \tREGEXP_UNIT (regexp)->unit_decl->min_occ_cycle_num = min_start_cycle;\n       *max_finish_cycle = max_start_cycle;\n       *min_finish_cycle = min_start_cycle;\n-    }\n-  else if (regexp->mode == rm_reserv)\n-   process_regexp_cycles (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n-\t\t\t  max_start_cycle, min_start_cycle,\n-\t\t\t  max_finish_cycle, min_finish_cycle);\n-  else if (regexp->mode == rm_repeat)\n-    {\n+      break;\n+\n+    case rm_reserv:\n+      process_regexp_cycles (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n+\t\t\t     max_start_cycle, min_start_cycle,\n+\t\t\t     max_finish_cycle, min_finish_cycle);\n+      break;\n+\n+    case rm_repeat:\n       for (i = 0; i < REGEXP_REPEAT (regexp)->repeat_num; i++)\n \t{\n \t  process_regexp_cycles (REGEXP_REPEAT (regexp)->regexp,\n@@ -3300,9 +3313,9 @@ process_regexp_cycles (regexp_t regexp, int max_start_cycle,\n \t  max_start_cycle = *max_finish_cycle + 1;\n \t  min_start_cycle = *min_finish_cycle + 1;\n \t}\n-    }\n-  else if (regexp->mode == rm_sequence)\n-    {\n+      break;\n+\n+    case rm_sequence:\n       for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \t{\n \t  process_regexp_cycles (REGEXP_SEQUENCE (regexp)->regexps [i],\n@@ -3311,49 +3324,55 @@ process_regexp_cycles (regexp_t regexp, int max_start_cycle,\n \t  max_start_cycle = *max_finish_cycle + 1;\n \t  min_start_cycle = *min_finish_cycle + 1;\n \t}\n-    }\n-  else if (regexp->mode == rm_allof)\n-    {\n-      int max_cycle = 0;\n-      int min_cycle = 0;\n+      break;\n \n-      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n-\t{\n-\t  process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n-\t\t\t\t max_start_cycle, min_start_cycle,\n-\t\t\t\t max_finish_cycle, min_finish_cycle);\n-\t  if (max_cycle < *max_finish_cycle)\n-\t    max_cycle = *max_finish_cycle;\n-\t  if (i == 0 || min_cycle > *min_finish_cycle)\n-\t    min_cycle = *min_finish_cycle;\n-\t}\n-      *max_finish_cycle = max_cycle;\n-      *min_finish_cycle = min_cycle;\n-    }\n-  else if (regexp->mode == rm_oneof)\n-    {\n-      int max_cycle = 0;\n-      int min_cycle = 0;\n+    case rm_allof:\n+      {\n+\tint max_cycle = 0;\n+\tint min_cycle = 0;\n+\t\n+\tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\t  {\n+\t    process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n+\t\t\t\t   max_start_cycle, min_start_cycle,\n+\t\t\t\t   max_finish_cycle, min_finish_cycle);\n+\t    if (max_cycle < *max_finish_cycle)\n+\t      max_cycle = *max_finish_cycle;\n+\t    if (i == 0 || min_cycle > *min_finish_cycle)\n+\t      min_cycle = *min_finish_cycle;\n+\t  }\n+\t*max_finish_cycle = max_cycle;\n+\t*min_finish_cycle = min_cycle;\n+      }\n+      break;\n \n-      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n-\t{\n-\t  process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n-\t\t\t\t max_start_cycle, min_start_cycle,\n-\t\t\t\t max_finish_cycle, min_finish_cycle);\n-\t  if (max_cycle < *max_finish_cycle)\n-\t    max_cycle = *max_finish_cycle;\n-\t  if (i == 0 || min_cycle > *min_finish_cycle)\n-\t    min_cycle = *min_finish_cycle;\n-\t}\n-      *max_finish_cycle = max_cycle;\n-      *min_finish_cycle = min_cycle;\n-    }\n-  else\n-    {\n-      if (regexp->mode != rm_nothing)\n-\tabort ();\n+    case rm_oneof:\n+      {\n+\tint max_cycle = 0;\n+\tint min_cycle = 0;\n+\t\n+\tfor (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\t  {\n+\t    process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n+\t\t\t\t   max_start_cycle, min_start_cycle,\n+\t\t\t\t   max_finish_cycle, min_finish_cycle);\n+\t    if (max_cycle < *max_finish_cycle)\n+\t      max_cycle = *max_finish_cycle;\n+\t    if (i == 0 || min_cycle > *min_finish_cycle)\n+\t      min_cycle = *min_finish_cycle;\n+\t  }\n+\t*max_finish_cycle = max_cycle;\n+\t*min_finish_cycle = min_cycle;\n+      }\n+      break;\n+\n+    case rm_nothing:\n       *max_finish_cycle = max_start_cycle;\n       *min_finish_cycle = min_start_cycle;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -3795,8 +3814,7 @@ reserv_sets_cmp (reserv_sets_t reservs_1, reserv_sets_t reservs_2)\n   set_el_t *reserv_ptr_1;\n   set_el_t *reserv_ptr_2;\n \n-  if (reservs_1 == NULL || reservs_2 == NULL)\n-    abort ();\n+  gcc_assert (reservs_1 && reservs_2);\n   reservs_num = els_in_reservs;\n   reserv_ptr_1 = reservs_1;\n   reserv_ptr_2 = reservs_2;\n@@ -3826,8 +3844,7 @@ reserv_sets_eq (reserv_sets_t reservs_1, reserv_sets_t reservs_2)\n static void\n set_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n {\n-  if (cycle_num >= max_cycles_num)\n-    abort ();\n+  gcc_assert (cycle_num < max_cycles_num);\n   SET_BIT (reservs, cycle_num * els_in_cycle_reserv\n            * sizeof (set_el_t) * CHAR_BIT + unit_num);\n }\n@@ -3837,8 +3854,7 @@ set_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n static int\n test_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n {\n-  if (cycle_num >= max_cycles_num)\n-    abort ();\n+  gcc_assert (cycle_num < max_cycles_num);\n   return TEST_BIT (reservs, cycle_num * els_in_cycle_reserv\n \t\t   * sizeof (set_el_t) * CHAR_BIT + unit_num);\n }\n@@ -3851,8 +3867,7 @@ it_is_empty_reserv_sets (reserv_sets_t operand)\n   set_el_t *reserv_ptr;\n   int reservs_num;\n \n-  if (operand == NULL)\n-    abort ();\n+  gcc_assert (operand);\n   for (reservs_num = els_in_reservs, reserv_ptr = operand;\n        reservs_num != 0;\n        reserv_ptr++, reservs_num--)\n@@ -3873,8 +3888,7 @@ reserv_sets_are_intersected (reserv_sets_t operand_1,\n   set_el_t *cycle_ptr_1;\n   set_el_t *cycle_ptr_2;\n \n-  if (operand_1 == NULL || operand_2 == NULL)\n-    abort ();\n+  gcc_assert (operand_1 && operand_2);\n   for (el_ptr_1 = operand_1, el_ptr_2 = operand_2;\n        el_ptr_1 < operand_1 + els_in_reservs;\n        el_ptr_1++, el_ptr_2++)\n@@ -3913,8 +3927,7 @@ reserv_sets_shift (reserv_sets_t result, reserv_sets_t operand)\n {\n   int i;\n \n-  if (result == NULL || operand == NULL || result == operand)\n-    abort ();\n+  gcc_assert (result && operand && result != operand);\n   for (i = els_in_cycle_reserv; i < els_in_reservs; i++)\n     result [i - els_in_cycle_reserv] = operand [i];\n }\n@@ -3928,8 +3941,7 @@ reserv_sets_or (reserv_sets_t result, reserv_sets_t operand_1,\n   set_el_t *el_ptr_2;\n   set_el_t *result_set_el_ptr;\n \n-  if (result == NULL || operand_1 == NULL || operand_2 == NULL)\n-    abort ();\n+  gcc_assert (result && operand_1 && operand_2);\n   for (el_ptr_1 = operand_1, el_ptr_2 = operand_2, result_set_el_ptr = result;\n        el_ptr_1 < operand_1 + els_in_reservs;\n        el_ptr_1++, el_ptr_2++, result_set_el_ptr++)\n@@ -3945,8 +3957,7 @@ reserv_sets_and (reserv_sets_t result, reserv_sets_t operand_1,\n   set_el_t *el_ptr_2;\n   set_el_t *result_set_el_ptr;\n \n-  if (result == NULL || operand_1 == NULL || operand_2 == NULL)\n-    abort ();\n+  gcc_assert (result && operand_1 && operand_2);\n   for (el_ptr_1 = operand_1, el_ptr_2 = operand_2, result_set_el_ptr = result;\n        el_ptr_1 < operand_1 + els_in_reservs;\n        el_ptr_1++, el_ptr_2++, result_set_el_ptr++)\n@@ -3968,8 +3979,7 @@ output_cycle_reservs (FILE *f, reserv_sets_t reservs, int start_cycle,\n     if (TEST_BIT (reservs, start_cycle * els_in_cycle_reserv\n                   * sizeof (set_el_t) * CHAR_BIT + unit_num))\n       reserved_units_num++;\n-  if (repetition_num <= 0)\n-    abort ();\n+  gcc_assert (repetition_num > 0);\n   if (repetition_num != 1 && reserved_units_num > 1)\n     fprintf (f, \"(\");\n   reserved_units_num = 0;\n@@ -3986,8 +3996,7 @@ output_cycle_reservs (FILE *f, reserv_sets_t reservs, int start_cycle,\n       }\n   if (reserved_units_num == 0)\n     fprintf (f, NOTHING_NAME);\n-  if (repetition_num <= 0)\n-    abort ();\n+  gcc_assert (repetition_num > 0);\n   if (repetition_num != 1 && reserved_units_num > 1)\n     fprintf (f, \")\");\n   if (repetition_num != 1)\n@@ -4041,8 +4050,7 @@ get_free_state (int with_reservs, automaton_t automaton)\n {\n   state_t result;\n \n-  if (max_cycles_num <= 0 || automaton == NULL)\n-    abort ();\n+  gcc_assert (max_cycles_num > 0 && automaton);\n   if (VLA_PTR_LENGTH (free_states) != 0)\n     {\n       result = VLA_PTR (free_states, VLA_PTR_LENGTH (free_states) - 1);\n@@ -4168,8 +4176,7 @@ set_state_reserv (state_t state, int cycle_num, int unit_num)\n static int\n intersected_state_reservs_p (state_t state1, state_t state2)\n {\n-  if (state1->automaton != state2->automaton)\n-    abort ();\n+  gcc_assert (state1->automaton == state2->automaton);\n   return reserv_sets_are_intersected (state1->reservs, state2->reservs);\n }\n \n@@ -4182,8 +4189,7 @@ states_union (state_t state1, state_t state2, reserv_sets_t reservs)\n   state_t result;\n   state_t state_in_table;\n \n-  if (state1->automaton != state2->automaton)\n-    abort ();\n+  gcc_assert (state1->automaton == state2->automaton);\n   result = get_free_state (1, state1->automaton);\n   reserv_sets_or (result->reservs, state1->reservs, state2->reservs);\n   reserv_sets_and (result->reservs, result->reservs, reservs);\n@@ -4284,15 +4290,13 @@ remove_arc (state_t from_state, arc_t arc)\n   arc_t prev_arc;\n   arc_t curr_arc;\n \n-  if (arc == NULL)\n-    abort ();\n+  gcc_assert (arc);\n   for (prev_arc = NULL, curr_arc = from_state->first_out_arc;\n        curr_arc != NULL;\n        prev_arc = curr_arc, curr_arc = curr_arc->next_out_arc)\n     if (curr_arc == arc)\n       break;\n-  if (curr_arc == NULL)\n-    abort ();\n+  gcc_assert (curr_arc);\n   if (prev_arc == NULL)\n     from_state->first_out_arc = arc->next_out_arc;\n   else\n@@ -4795,48 +4799,55 @@ copy_insn_regexp (regexp_t regexp)\n   regexp_t  result;\n   int i;\n \n-  if (regexp->mode == rm_reserv)\n-    result = copy_insn_regexp (REGEXP_RESERV (regexp)->reserv_decl->regexp);\n-  else if (regexp->mode == rm_unit)\n-    result = copy_node (regexp, sizeof (struct regexp));\n-  else if (regexp->mode == rm_repeat)\n+  switch (regexp->mode)\n     {\n+    case rm_reserv:\n+      result = copy_insn_regexp (REGEXP_RESERV (regexp)->reserv_decl->regexp);\n+      break;\n+\n+    case rm_unit:\n+      result = copy_node (regexp, sizeof (struct regexp));\n+      break;\n+\n+    case rm_repeat:\n       result = copy_node (regexp, sizeof (struct regexp));\n       REGEXP_REPEAT (result)->regexp\n         = copy_insn_regexp (REGEXP_REPEAT (regexp)->regexp);\n-    }\n-  else if (regexp->mode == rm_sequence)\n-    {\n+      break;\n+\n+    case rm_sequence:\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n \t\t\t  * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n       for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tREGEXP_SEQUENCE (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n-    }\n-  else if (regexp->mode == rm_allof)\n-    {\n+      break;\n+\n+    case rm_allof:\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n \t\t\t  * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \tREGEXP_ALLOF (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n-    }\n-  else if (regexp->mode == rm_oneof)\n-    {\n+      break;\n+\n+    case rm_oneof:\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n \t\t\t  * (REGEXP_ONEOF (regexp)->regexps_num - 1));\n       for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \tREGEXP_ONEOF (result)->regexps [i]\n \t  = copy_insn_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n-    }\n-  else\n-    {\n-      if (regexp->mode != rm_nothing)\n-\tabort ();\n+      break;\n+\n+    case rm_nothing:\n       result = copy_node (regexp, sizeof (struct regexp));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n   return result;\n }\n@@ -4858,8 +4869,7 @@ transform_1 (regexp_t regexp)\n   if (regexp->mode == rm_repeat)\n     {\n       repeat_num = REGEXP_REPEAT (regexp)->repeat_num;\n-      if (repeat_num <= 1)\n-\tabort ();\n+      gcc_assert (repeat_num > 1);\n       operand = REGEXP_REPEAT (regexp)->regexp;\n       pos = regexp->mode;\n       regexp = create_node (sizeof (struct regexp) + sizeof (regexp_t)\n@@ -4897,9 +4907,8 @@ transform_2 (regexp_t regexp)\n \t  }\n       if (i < REGEXP_SEQUENCE (regexp)->regexps_num)\n \t{\n-\t  if ( REGEXP_SEQUENCE (sequence)->regexps_num <= 1\n-\t      || REGEXP_SEQUENCE (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (REGEXP_SEQUENCE (sequence)->regexps_num > 1\n+\t\t      && REGEXP_SEQUENCE (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n                                 + sizeof (regexp_t)\n \t\t\t\t* (REGEXP_SEQUENCE (regexp)->regexps_num\n@@ -4942,9 +4951,8 @@ transform_2 (regexp_t regexp)\n \t  }\n       if (i < REGEXP_ALLOF (regexp)->regexps_num)\n \t{\n-\t  if (REGEXP_ALLOF (allof)->regexps_num <= 1\n-\t      || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (REGEXP_ALLOF (allof)->regexps_num > 1\n+\t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n                                 + sizeof (regexp_t)\n \t\t\t\t* (REGEXP_ALLOF (regexp)->regexps_num\n@@ -4986,9 +4994,8 @@ transform_2 (regexp_t regexp)\n \t  }\n       if (i < REGEXP_ONEOF (regexp)->regexps_num)\n \t{\n-\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n-\t      || REGEXP_ONEOF (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n+\t\t      && REGEXP_ONEOF (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n \t\t\t\t* (REGEXP_ONEOF (regexp)->regexps_num\n@@ -5042,9 +5049,8 @@ transform_3 (regexp_t regexp)\n \t  }\n       if (i < REGEXP_SEQUENCE (regexp)->regexps_num)\n \t{\n-\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n-\t      || REGEXP_SEQUENCE (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n+\t\t      && REGEXP_SEQUENCE (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n \t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n@@ -5095,9 +5101,8 @@ transform_3 (regexp_t regexp)\n \t  }\n       if (i < REGEXP_ALLOF (regexp)->regexps_num)\n \t{\n-\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n-\t      || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (REGEXP_ONEOF (oneof)->regexps_num > 1\n+\t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n \t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n@@ -5131,23 +5136,28 @@ transform_3 (regexp_t regexp)\n       if (regexp->mode == rm_allof)\n \tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t  {\n-\t    if (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_sequence)\n+\t    switch (REGEXP_ALLOF (regexp)->regexps [i]->mode)\n \t      {\n+\t      case rm_sequence:\n \t\tseq = REGEXP_ALLOF (regexp)->regexps [i];\n \t\tif (max_seq_length < REGEXP_SEQUENCE (seq)->regexps_num)\n \t\t  max_seq_length = REGEXP_SEQUENCE (seq)->regexps_num;\n-\t      }\n-\t    else if (REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_unit\n-\t\t     && REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_nothing)\n-\t      {\n-\t\tmax_seq_length = 0;\n \t\tbreak;\n+\n+\t      case rm_unit:\n+\t      case rm_nothing:\n+\t\tbreak;\n+\n+\t      default:\n+\t\tmax_seq_length = 0;\n+\t\tgoto break_for;\n \t      }\n \t  }\n+    break_for:\n       if (max_seq_length != 0)\n \t{\n-\t  if (max_seq_length == 1 || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n-\t    abort ();\n+\t  gcc_assert (max_seq_length != 1\n+\t\t      && REGEXP_ALLOF (regexp)->regexps_num > 1);\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t) * (max_seq_length - 1));\n \t  result->mode = rm_sequence;\n@@ -5157,24 +5167,31 @@ transform_3 (regexp_t regexp)\n \t    {\n \t      allof_length = 0;\n \t      for (j = 0; j < REGEXP_ALLOF (regexp)->regexps_num; j++)\n-\t\tif (REGEXP_ALLOF (regexp)->regexps [j]->mode == rm_sequence\n-\t\t    && (i < (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n-\t\t\t\t\t      ->regexps [j])->regexps_num)))\n-\t\t  {\n-\t\t    allof_op\n-\t\t      = (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)->regexps [j])\n-\t\t\t ->regexps [i]);\n-\t\t    allof_length++;\n-\t\t  }\n-\t\telse if (i == 0\n-\t\t\t && (REGEXP_ALLOF (regexp)->regexps [j]->mode\n-\t\t\t     == rm_unit\n-\t\t\t     || (REGEXP_ALLOF (regexp)->regexps [j]->mode\n-\t\t\t\t == rm_nothing)))\n+\t\tswitch (REGEXP_ALLOF (regexp)->regexps [j]->mode)\n \t\t  {\n-\t\t    allof_op = REGEXP_ALLOF (regexp)->regexps [j];\n-\t\t    allof_length++;\n+\t\t  case rm_sequence:\n+\t\t    if (i < (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t      ->regexps [j])->regexps_num))\n+\t\t      {\n+\t\t\tallof_op\n+\t\t\t  = (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t      ->regexps [j])\n+\t\t\t     ->regexps [i]);\n+\t\t\tallof_length++;\n+\t\t      }\n+\t\t    break;\n+\t\t  case rm_unit:\n+\t\t  case rm_nothing:\n+\t\t    if (i == 0)\n+\t\t      {\n+\t\t\tallof_op = REGEXP_ALLOF (regexp)->regexps [j];\n+\t\t\tallof_length++;\n+\t\t      }\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n \t\t  }\n+\t      \n \t      if (allof_length == 1)\n \t\tREGEXP_SEQUENCE (result)->regexps [i] = allof_op;\n \t      else\n@@ -5227,23 +5244,39 @@ regexp_transform_func (regexp_t regexp, regexp_t (*func) (regexp_t regexp))\n {\n   int i;\n \n-  if (regexp->mode == rm_sequence)\n-    for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n-      REGEXP_SEQUENCE (regexp)->regexps [i]\n-\t= regexp_transform_func (REGEXP_SEQUENCE (regexp)->regexps [i], func);\n-  else if (regexp->mode == rm_allof)\n-    for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n-      REGEXP_ALLOF (regexp)->regexps [i]\n-\t= regexp_transform_func (REGEXP_ALLOF (regexp)->regexps [i], func);\n-  else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n-      REGEXP_ONEOF (regexp)->regexps [i]\n-\t= regexp_transform_func (REGEXP_ONEOF (regexp)->regexps [i], func);\n-  else if (regexp->mode == rm_repeat)\n-    REGEXP_REPEAT (regexp)->regexp\n-      = regexp_transform_func (REGEXP_REPEAT (regexp)->regexp, func);\n-  else if (regexp->mode != rm_nothing && regexp->mode != rm_unit)\n-    abort ();\n+  switch (regexp->mode)\n+    {\n+    case rm_sequence:\n+      for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tREGEXP_SEQUENCE (regexp)->regexps [i]\n+\t  = regexp_transform_func (REGEXP_SEQUENCE (regexp)->regexps [i],\n+\t\t\t\t   func);\n+      break;\n+\n+    case rm_allof:\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tREGEXP_ALLOF (regexp)->regexps [i]\n+\t  = regexp_transform_func (REGEXP_ALLOF (regexp)->regexps [i], func);\n+      break;\n+\n+    case rm_oneof:\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\tREGEXP_ONEOF (regexp)->regexps [i]\n+\t  = regexp_transform_func (REGEXP_ONEOF (regexp)->regexps [i], func);\n+      break;\n+\n+    case rm_repeat:\n+      REGEXP_REPEAT (regexp)->regexp\n+\t= regexp_transform_func (REGEXP_REPEAT (regexp)->regexp, func);\n+      break;\n+\n+    case rm_nothing:\n+    case rm_unit:\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n   return (*func) (regexp);\n }\n \n@@ -5326,9 +5359,8 @@ store_alt_unit_usage (regexp_t regexp, regexp_t unit, int cycle,\n   struct unit_usage *unit_usage_ptr;\n   int index;\n \n-  if (regexp == NULL || regexp->mode != rm_oneof\n-      || alt_num >= REGEXP_ONEOF (regexp)->regexps_num)\n-    abort ();\n+  gcc_assert (regexp && regexp->mode == rm_oneof\n+\t      && alt_num < REGEXP_ONEOF (regexp)->regexps_num);\n   unit_decl = REGEXP_UNIT (unit)->unit_decl;\n   old_length = VLA_PTR_LENGTH (cycle_alt_unit_usages);\n   length = (cycle + 1) * REGEXP_ONEOF (regexp)->regexps_num;\n@@ -5366,37 +5398,67 @@ check_regexp_units_distribution (const char *insn_reserv_name,\n   for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n       seq = REGEXP_ONEOF (regexp)->regexps [i];\n-      if (seq->mode == rm_sequence)\n-\tfor (j = 0; j < REGEXP_SEQUENCE (seq)->regexps_num; j++)\n-\t  {\n-\t    allof = REGEXP_SEQUENCE (seq)->regexps [j];\n-\t    if (allof->mode == rm_allof)\n-\t      for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n+      switch (seq->mode)\n+\t{\n+\tcase rm_sequence:\n+\t  for (j = 0; j < REGEXP_SEQUENCE (seq)->regexps_num; j++)\n+\t    {\n+\t      allof = REGEXP_SEQUENCE (seq)->regexps [j];\n+\t      switch (allof->mode)\n \t\t{\n-\t\t  unit = REGEXP_ALLOF (allof)->regexps [k];\n-\t\t  if (unit->mode == rm_unit)\n-\t\t    store_alt_unit_usage (regexp, unit, j, i);\n-\t\t  else if (unit->mode != rm_nothing)\n-\t\t    abort ();\n+\t\tcase rm_allof:\n+\t\t  for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n+\t\t    {\n+\t\t      unit = REGEXP_ALLOF (allof)->regexps [k];\n+\t\t      if (unit->mode == rm_unit)\n+\t\t\tstore_alt_unit_usage (regexp, unit, j, i);\n+\t\t      else\n+\t\t\tgcc_assert (unit->mode == rm_nothing);\n+\t\t    }\n+\t\t  break;\n+\t\t  \n+\t\tcase rm_unit:\n+\t\t  store_alt_unit_usage (regexp, allof, j, i);\n+\t\t  break;\n+\t\t  \n+\t\tcase rm_nothing:\n+\t\t  break;\n+\t\t  \n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n \t\t}\n-\t    else if (allof->mode == rm_unit)\n-\t      store_alt_unit_usage (regexp, allof, j, i);\n-\t    else if (allof->mode != rm_nothing)\n-\t      abort ();\n-\t  }\n-      else if (seq->mode == rm_allof)\n-\tfor (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n-\t  {\n-\t    unit = REGEXP_ALLOF (seq)->regexps [k];\n-\t    if (unit->mode == rm_unit)\n-\t      store_alt_unit_usage (regexp, unit, 0, i);\n-\t    else if (unit->mode != rm_nothing)\n-\t      abort ();\n-\t  }\n-      else if (seq->mode == rm_unit)\n-\tstore_alt_unit_usage (regexp, seq, 0, i);\n-      else if (seq->mode != rm_nothing)\n-\tabort ();\n+\t    }\n+\t  break;\n+\n+\tcase rm_allof:\n+\t  for (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n+\t    {\n+\t      unit = REGEXP_ALLOF (seq)->regexps [k];\n+\t      switch (unit->mode)\n+\t\t{\n+\t\tcase rm_unit:\n+\t\t  store_alt_unit_usage (regexp, unit, 0, i);\n+\t\t  break;\n+\t\t  \n+\t\tcase rm_nothing:\n+\t\t  break;\n+\t\t  \n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase rm_unit:\n+\t  store_alt_unit_usage (regexp, seq, 0, i);\n+\t  break;\n+\n+\tcase rm_nothing:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   /* Check distribution:  */\n   for (i = 0; i < (int) VLA_PTR_LENGTH (cycle_alt_unit_usages); i++)\n@@ -5489,42 +5551,44 @@ process_seq_for_forming_states (regexp_t regexp, automaton_t automaton,\n \n   if (regexp == NULL)\n     return curr_cycle;\n-  else if (regexp->mode == rm_unit)\n+\n+  switch (regexp->mode)\n     {\n+    case rm_unit:\n       if (REGEXP_UNIT (regexp)->unit_decl->corresponding_automaton_num\n           == automaton->automaton_order_num)\n         set_state_reserv (state_being_formed, curr_cycle,\n                           REGEXP_UNIT (regexp)->unit_decl->unit_num);\n       return curr_cycle;\n-    }\n-  else if (regexp->mode == rm_sequence)\n-    {\n+      \n+    case rm_sequence:\n       for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tcurr_cycle\n \t  = process_seq_for_forming_states\n \t    (REGEXP_SEQUENCE (regexp)->regexps [i], automaton, curr_cycle) + 1;\n       return curr_cycle;\n-    }\n-  else if (regexp->mode == rm_allof)\n-    {\n-      int finish_cycle = 0;\n-      int cycle;\n \n-      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n-\t{\n-\t  cycle = process_seq_for_forming_states (REGEXP_ALLOF (regexp)\n-\t\t\t\t\t\t  ->regexps [i],\n-\t\t\t\t\t\t  automaton, curr_cycle);\n-\t  if (finish_cycle < cycle)\n-\t    finish_cycle = cycle;\n-\t}\n-      return finish_cycle;\n-    }\n-  else\n-    {\n-      if (regexp->mode != rm_nothing)\n-\tabort ();\n+    case rm_allof:\n+      {\n+\tint finish_cycle = 0;\n+\tint cycle;\n+\t\n+\tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\t  {\n+\t    cycle = process_seq_for_forming_states (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t\t    ->regexps [i],\n+\t\t\t\t\t\t    automaton, curr_cycle);\n+\t    if (finish_cycle < cycle)\n+\t      finish_cycle = cycle;\n+\t  }\n+\treturn finish_cycle;\n+      }\n+\n+    case rm_nothing:\n       return curr_cycle;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \n@@ -5574,8 +5638,7 @@ process_alts_for_forming_states (regexp_t regexp, automaton_t automaton,\n     }\n   else\n     {\n-      if (inside_oneof_p)\n-\tabort ();\n+      gcc_assert (!inside_oneof_p);\n       /* We processes it in reverse order to get list with the same\n \t order as in the description.  See also the previous\n \t commentary.  */\n@@ -5776,8 +5839,7 @@ make_automaton (automaton_t automaton)\n \t  if (progress_flag && states_n % 100 == 0)\n \t    fprintf (stderr, \".\");\n         }\n-      if (advance_cycle_ainsn == NULL)\n-\tabort ();\n+      gcc_assert (advance_cycle_ainsn);\n       add_arc (state, state2, advance_cycle_ainsn, 1);\n     }\n   VLA_PTR_DELETE (state_stack);\n@@ -5799,8 +5861,7 @@ form_arcs_marked_by_insn (state_t state)\n     }\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n-      if (arc->insn == NULL)\n-\tabort ();\n+      gcc_assert (arc->insn);\n       arc->next_arc_marked_by_insn\n \t= arc->insn->insn_reserv_decl->arcs_marked_by_insn;\n       arc->insn->insn_reserv_decl->arcs_marked_by_insn = arc;\n@@ -5832,8 +5893,7 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n     state = arcs_marked_by_insn->to_state;\n   else\n     {\n-      if (!ndfa_flag)\n-\tabort ();\n+      gcc_assert (ndfa_flag);\n       /* Create composed state.  */\n       state = get_free_state (0, arcs_marked_by_insn->to_state->automaton);\n       curr_alt_state = NULL;\n@@ -5855,8 +5915,7 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n \t      new_alt_state = get_free_alt_state ();\n \t      new_alt_state->next_alt_state = curr_alt_state;\n \t      new_alt_state->state = alt_state->state;\n-\t      if (alt_state->state->component_states != NULL)\n-\t\tabort ();\n+\t      gcc_assert (!alt_state->state->component_states);\n \t      curr_alt_state = new_alt_state;\n \t    }\n       /* There are not identical sets in the alt state list.  */\n@@ -5873,15 +5932,14 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n           state_in_table = insert_state (state);\n           if (state_in_table != state)\n             {\n-              if (!state_in_table->it_was_placed_in_stack_for_DFA_forming)\n-\t\tabort ();\n+              gcc_assert\n+\t\t(state_in_table->it_was_placed_in_stack_for_DFA_forming);\n               free_state (state);\n               state = state_in_table;\n             }\n           else\n             {\n-              if (state->it_was_placed_in_stack_for_DFA_forming)\n-\t\tabort ();\n+              gcc_assert (!state->it_was_placed_in_stack_for_DFA_forming);\n \t      new_state_p = 1;\n               for (curr_alt_state = state->component_states;\n                    curr_alt_state != NULL;\n@@ -6014,18 +6072,16 @@ set_out_arc_insns_equiv_num (state_t state, int odd_iteration_flag)\n   state_out_arcs_num = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n-      if (arc->insn->insn_reserv_decl->equiv_class_num != 0\n-\t  || arc->insn->insn_reserv_decl->state_alts != 0)\n-\tabort ();\n+      gcc_assert (!arc->insn->insn_reserv_decl->equiv_class_num\n+\t\t  && !arc->insn->insn_reserv_decl->state_alts);\n       state_out_arcs_num++;\n       arc->insn->insn_reserv_decl->equiv_class_num\n \t= (odd_iteration_flag\n            ? arc->to_state->equiv_class_num_1\n \t   : arc->to_state->equiv_class_num_2);\n       arc->insn->insn_reserv_decl->state_alts = arc->state_alts;\n-      if (arc->insn->insn_reserv_decl->equiv_class_num == 0\n-\t  || arc->insn->insn_reserv_decl->state_alts <= 0)\n-\tabort ();\n+      gcc_assert (arc->insn->insn_reserv_decl->equiv_class_num\n+\t\t  && arc->insn->insn_reserv_decl->state_alts > 0);\n     }\n   return state_out_arcs_num;\n }\n@@ -6152,8 +6208,7 @@ partition_equiv_class (state_t *equiv_class_ptr, int odd_iteration_flag,\n   int out_arcs_num;\n \n   partition_p = 0;\n-  if (*equiv_class_ptr == NULL)\n-    abort ();\n+  gcc_assert (*equiv_class_ptr);\n   for (first_state = *equiv_class_ptr;\n        first_state != NULL;\n        first_state = new_equiv_class)\n@@ -6536,8 +6591,7 @@ process_insn_equiv_class (ainsn_t ainsn, arc_t *insn_arcs_array)\n   ainsn_t cyclic_insn_list;\n   arc_t arc;\n \n-  if (insn_arcs_array [ainsn->insn_reserv_decl->insn_num] == NULL)\n-    abort ();\n+  gcc_assert (insn_arcs_array [ainsn->insn_reserv_decl->insn_num]);\n   curr_insn = ainsn;\n   /* New class of ainsns which are not equivalent to given ainsn.  */\n   cyclic_insn_list = NULL;\n@@ -6608,8 +6662,7 @@ set_insn_equiv_classes (automaton_t automaton)\n     if (ainsn->insn_equiv_class_num < 0)\n       {\n         first_insn = ainsn;\n-        if (!first_insn->first_insn_with_same_reservs)\n-\t  abort ();\n+        gcc_assert (first_insn->first_insn_with_same_reservs);\n         first_insn->first_ainsn_with_given_equivalence_num = 1;\n         curr_insn = first_insn;\n         do\n@@ -6720,8 +6773,7 @@ units_to_automata_heuristic_distr (void)\n     {\n       rest_units_num\n \t= ((decl_t *) VLA_PTR_LAST (unit_decls) - unit_decl_ptr + 1);\n-      if (automata_num - automaton_num - 1 > rest_units_num)\n-\tabort ();\n+      gcc_assert (automata_num - automaton_num - 1 <= rest_units_num);\n       if (automaton_num < automata_num - 1\n           && ((automata_num - automaton_num - 1 == rest_units_num)\n               || (bound_value\n@@ -6735,8 +6787,7 @@ units_to_automata_heuristic_distr (void)\n         bound_value *= DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n       DECL_UNIT (*unit_decl_ptr)->corresponding_automaton_num = automaton_num;\n     }\n-  if (automaton_num != automata_num - 1)\n-    abort ();\n+  gcc_assert (automaton_num == automata_num - 1);\n   VLA_PTR_DELETE (unit_decls);\n }\n \n@@ -6909,23 +6960,28 @@ form_regexp (regexp_t regexp)\n {\n   int i;\n \n-  if (regexp->mode == rm_unit || regexp->mode == rm_reserv)\n+  switch (regexp->mode)\n     {\n-      const char *name = (regexp->mode == rm_unit\n-                          ? REGEXP_UNIT (regexp)->name\n-\t\t\t  : REGEXP_RESERV (regexp)->name);\n-\n-      obstack_grow (&irp, name, strlen (name));\n-    }\n-  else if (regexp->mode == rm_sequence)\n-    for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+    case rm_unit: case rm_reserv:\n       {\n-\tif (i != 0)\n-          obstack_1grow (&irp, ',');\n-\tform_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n+\tconst char *name = (regexp->mode == rm_unit\n+\t\t\t    ? REGEXP_UNIT (regexp)->name\n+\t\t\t    : REGEXP_RESERV (regexp)->name);\n+\t\n+\tobstack_grow (&irp, name, strlen (name));\n+\tbreak;\n       }\n-  else if (regexp->mode == rm_allof)\n-    {\n+      \n+    case rm_sequence:\n+      for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\t{\n+\t  if (i != 0)\n+\t    obstack_1grow (&irp, ',');\n+\t  form_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n+\t}\n+      break;\n+\n+    case rm_allof:\n       obstack_1grow (&irp, '(');\n       for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t{\n@@ -6940,38 +6996,46 @@ form_regexp (regexp_t regexp)\n             obstack_1grow (&irp, ')');\n         }\n       obstack_1grow (&irp, ')');\n-    }\n-  else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n-      {\n-\tif (i != 0)\n-          obstack_1grow (&irp, '|');\n-\tif (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n-          obstack_1grow (&irp, '(');\n-        form_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n-\tif (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n+      break;\n+      \n+    case rm_oneof:\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\t{\n+\t  if (i != 0)\n+\t    obstack_1grow (&irp, '|');\n+\t  if (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n+\t    obstack_1grow (&irp, '(');\n+\t  form_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n+\t  if (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n           obstack_1grow (&irp, ')');\n+\t}\n+      break;\n+      \n+    case rm_repeat:\n+      {\n+\tchar digits [30];\n+\t\n+\tif (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n+\t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n+\t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n+\t  obstack_1grow (&irp, '(');\n+\tform_regexp (REGEXP_REPEAT (regexp)->regexp);\n+\tif (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n+\t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n+\t    || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n+\t  obstack_1grow (&irp, ')');\n+\tsprintf (digits, \"*%d\", REGEXP_REPEAT (regexp)->repeat_num);\n+\tobstack_grow (&irp, digits, strlen (digits));\n+\tbreak;\n       }\n-  else if (regexp->mode == rm_repeat)\n-    {\n-      char digits [30];\n-\n-      if (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n-\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n-\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n-        obstack_1grow (&irp, '(');\n-      form_regexp (REGEXP_REPEAT (regexp)->regexp);\n-      if (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n-\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n-\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n-        obstack_1grow (&irp, ')');\n-      sprintf (digits, \"*%d\", REGEXP_REPEAT (regexp)->repeat_num);\n-      obstack_grow (&irp, digits, strlen (digits));\n-    }\n-  else if (regexp->mode == rm_nothing)\n-    obstack_grow (&irp, NOTHING_NAME, strlen (NOTHING_NAME));\n-  else\n-    abort ();\n+\n+    case rm_nothing:\n+      obstack_grow (&irp, NOTHING_NAME, strlen (NOTHING_NAME));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* The function returns string representation of REGEXP on IR\n@@ -7037,14 +7101,16 @@ longest_path_length (state_t state)\n   arc_t arc;\n   int length, result;\n \n-  if (state->longest_path_length == ON_THE_PATH)\n-    /* We don't expect the path cycle here.  Our graph may contain\n-       only cycles with one state on the path not containing `cycle\n-       advance' arcs -- see comment below.  */\n-    abort ();\n-  else if (state->longest_path_length != UNDEFINED_LONGEST_PATH_LENGTH)\n-    /* We already visited the state.  */\n-    return state->longest_path_length;\n+  if (state->longest_path_length != UNDEFINED_LONGEST_PATH_LENGTH)\n+    {\n+      /* We don't expect the path cycle here.  Our graph may contain\n+      \t only cycles with one state on the path not containing `cycle\n+      \t advance' arcs -- see comment below.  */\n+      gcc_assert (state->longest_path_length != ON_THE_PATH);\n+      \n+      /* We already visited the state.  */\n+      return state->longest_path_length;\n+    }\n \n   result = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n@@ -7092,8 +7158,7 @@ output_dfa_max_issue_rate (void)\n {\n   automaton_t automaton;\n \n-  if (UNDEFINED_LONGEST_PATH_LENGTH == ON_THE_PATH || ON_THE_PATH >= 0)\n-    abort ();\n+  gcc_assert (UNDEFINED_LONGEST_PATH_LENGTH != ON_THE_PATH && ON_THE_PATH < 0);\n   max_dfa_issue_rate = 0;\n   for (automaton = description->first_automaton;\n        automaton != NULL;\n@@ -7580,19 +7645,17 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n   int i;\n   unsigned long vect_mask, comb_vect_mask;\n \n-  if (vect_length == 0)\n-    abort ();\n+  gcc_assert (vect_length);\n   real_vect_length = tab->automaton->insn_equiv_classes_num;\n-  if (vect [vect_length - 1] == undefined_vect_el_value)\n-    abort ();\n+  gcc_assert (vect [vect_length - 1] != undefined_vect_el_value);\n   /* Form full vector in the table: */\n   for (i = 0; i < vect_length; i++)\n     VLA_HWINT (tab->full_vect,\n                i + tab->automaton->insn_equiv_classes_num * vect_num)\n       = vect [i];\n   /* Form comb vector in the table: */\n-  if (VLA_HWINT_LENGTH (tab->comb_vect) != VLA_HWINT_LENGTH (tab->check_vect))\n-    abort ();\n+  gcc_assert (VLA_HWINT_LENGTH (tab->comb_vect)\n+\t      == VLA_HWINT_LENGTH (tab->check_vect));\n   comb_vect_start = VLA_HWINT_BEGIN (tab->comb_vect);\n   comb_vect_els_num = VLA_HWINT_LENGTH (tab->comb_vect);\n   for (first_unempty_vect_index = 0;\n@@ -7670,7 +7733,7 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n \tgoto found;\n     }\n \n-found:\n+ found:\n   /* Slot was found.  */\n   additional_els_num = comb_vect_index + real_vect_length - comb_vect_els_num;\n   if (additional_els_num < 0)\n@@ -7686,19 +7749,16 @@ add_vect (state_ainsn_table_t tab, int vect_num, vect_el_t *vect,\n     }\n   comb_vect_start = VLA_HWINT_BEGIN (tab->comb_vect);\n   check_vect_start = VLA_HWINT_BEGIN (tab->check_vect);\n-  if (VLA_HWINT_LENGTH (tab->comb_vect)\n-      < (size_t) (comb_vect_index + real_vect_length))\n-    abort ();\n+  gcc_assert (VLA_HWINT_LENGTH (tab->comb_vect)\n+\t      >= (size_t) (comb_vect_index + real_vect_length));\n   /* Fill comb and check vectors.  */\n   for (vect_index = 0; vect_index < vect_length; vect_index++)\n     if (vect [vect_index] != undefined_vect_el_value)\n       {\n-        if (comb_vect_start [comb_vect_index + vect_index]\n-\t    != undefined_vect_el_value)\n-\t  abort ();\n+        gcc_assert (comb_vect_start [comb_vect_index + vect_index]\n+\t\t    == undefined_vect_el_value);\n         comb_vect_start [comb_vect_index + vect_index] = vect [vect_index];\n-        if (vect [vect_index] < 0)\n-\t  abort ();\n+        gcc_assert (vect [vect_index] >= 0);\n         if (tab->max_comb_vect_el_value < vect [vect_index])\n           tab->max_comb_vect_el_value = vect [vect_index];\n         if (tab->min_comb_vect_el_value > vect [vect_index])\n@@ -7726,8 +7786,7 @@ out_state_arcs_num (state_t state)\n   result = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n-      if (arc->insn == NULL)\n-\tabort ();\n+      gcc_assert (arc->insn);\n       if (arc->insn->first_ainsn_with_given_equivalence_num)\n         result++;\n     }\n@@ -7760,8 +7819,7 @@ add_vect_el (vla_hwint_t *vect, ainsn_t ainsn, int el_value)\n   int equiv_class_num;\n   int vect_index;\n \n-  if (ainsn == NULL)\n-    abort ();\n+  gcc_assert (ainsn);\n   equiv_class_num = ainsn->insn_equiv_class_num;\n   for (vect_index = VLA_HWINT_LENGTH (*vect);\n        vect_index <= equiv_class_num;\n@@ -7809,8 +7867,7 @@ output_trans_table (automaton_t automaton)\n \t   arc != NULL;\n \t   arc = next_out_arc (arc))\n         {\n-          if (arc->insn == NULL)\n-\t    abort ();\n+          gcc_assert (arc->insn);\n           if (arc->insn->first_ainsn_with_given_equivalence_num)\n             add_vect_el (&transition_vect, arc->insn,\n                          arc->to_state->order_state_num);\n@@ -7858,8 +7915,7 @@ output_state_alts_table (automaton_t automaton)\n \t   arc != NULL;\n \t   arc = next_out_arc (arc))\n         {\n-          if (arc->insn == NULL)\n-\t    abort ();\n+          gcc_assert (arc->insn);\n           if (arc->insn->first_ainsn_with_given_equivalence_num)\n             add_vect_el (&state_alts_vect, arc->insn, arc->state_alts);\n         }\n@@ -8056,8 +8112,7 @@ output_dead_lock_vect (automaton_t automaton)\n        state_ptr++)\n     {\n       arc = first_out_arc (*state_ptr);\n-      if (arc == NULL)\n-\tabort ();\n+      gcc_assert (arc);\n       VLA_HWINT (dead_lock_vect, (*state_ptr)->order_state_num)\n         = (next_out_arc (arc) == NULL\n            && (arc->insn->insn_reserv_decl\n@@ -8187,8 +8242,7 @@ output_max_insn_queue_index_def (void)\n     }\n   for (i = 0; (1 << i) <= max; i++)\n     ;\n-  if (i < 0)\n-    abort ();\n+  gcc_assert (i >= 0);\n   fprintf (output_file, \"\\nint max_insn_queue_index = %d;\\n\\n\", (1 << i) - 1);\n }\n \n@@ -8687,7 +8741,7 @@ output_min_insn_conflict_delay_func (void)\n \t   \"int\\n%s (%s %s, rtx %s, rtx %s)\\n\",\n \t   MIN_INSN_CONFLICT_DELAY_FUNC_NAME, STATE_TYPE_NAME,\n \t   STATE_NAME, INSN_PARAMETER_NAME, INSN2_PARAMETER_NAME);\n-  fprintf (output_file, \"{\\n  struct %s %s;\\n  int %s, %s;\\n\",\n+  fprintf (output_file, \"{\\n  struct %s %s;\\n  int %s, %s, transition;\\n\",\n \t   CHIP_NAME, CHIP_NAME, INTERNAL_INSN_CODE_NAME,\n \t   INTERNAL_INSN2_CODE_NAME);\n   output_internal_insn_code_evaluation (INSN_PARAMETER_NAME,\n@@ -8697,8 +8751,9 @@ output_min_insn_conflict_delay_func (void)\n   fprintf (output_file, \"  memcpy (&%s, %s, sizeof (%s));\\n\",\n \t   CHIP_NAME, STATE_NAME, CHIP_NAME);\n   fprintf (output_file, \"  %s (&%s);\\n\", INTERNAL_RESET_FUNC_NAME, CHIP_NAME);\n-  fprintf (output_file, \"  if (%s (%s, &%s) > 0)\\n    abort ();\\n\",\n+  fprintf (output_file, \"  transition = %s (%s, &%s);\\n\",\n \t   INTERNAL_TRANSITION_FUNC_NAME, INTERNAL_INSN_CODE_NAME, CHIP_NAME);\n+  fprintf (output_file, \"  gcc_assert (transition <= 0);\\n\");\n   fprintf (output_file, \"  return %s (%s, &%s);\\n\",\n \t   INTERNAL_MIN_ISSUE_DELAY_FUNC_NAME, INTERNAL_INSN2_CODE_NAME,\n \t   CHIP_NAME);\n@@ -8749,13 +8804,11 @@ output_internal_insn_latency_func (void)\n \tif ((col = (col+1) % 8) == 0)\n \t  fputs (\"\\n     \", output_file);\n \tdecl = description->decls[i];\n-\tif (j++ != DECL_INSN_RESERV (decl)->insn_num)\n-\t  abort ();\n+\tgcc_assert (j++ == DECL_INSN_RESERV (decl)->insn_num);\n \tfprintf (output_file, \"% 4d,\",\n \t\t DECL_INSN_RESERV (decl)->default_latency);\n       }\n-  if (j != DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num)\n-    abort ();\n+  gcc_assert (j == DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num);\n   fputs (\"\\n    };\\n\", output_file);\n \n   fprintf (output_file, \"  if (%s >= %s || %s >= %s)\\n    return 0;\\n\",\n@@ -8776,9 +8829,9 @@ output_internal_insn_latency_func (void)\n \t     bypass != NULL;\n \t     bypass = bypass->next)\n \t  {\n-\t    if (bypass->in_insn_reserv->insn_num\n-\t\t== DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num)\n-\t      abort ();\n+\t    gcc_assert (bypass->in_insn_reserv->insn_num\n+\t\t\t!= (DECL_INSN_RESERV\n+\t\t\t    (advance_cycle_insn_decl)->insn_num));\n \t    fprintf (output_file, \"        case %d:\\n\",\n \t\t     bypass->in_insn_reserv->insn_num);\n \t    if (bypass->bypass_guard_name == NULL)\n@@ -8848,15 +8901,15 @@ output_print_reservation_func (void)\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n \t{\n-\t  if (j++ != DECL_INSN_RESERV (decl)->insn_num)\n-\t    abort ();\n+\t  gcc_assert (j == DECL_INSN_RESERV (decl)->insn_num);\n+\t  j++;\n+\t  \n \t  fprintf (output_file, \"\\n      \\\"%s\\\",\",\n \t\t   regexp_representation (DECL_INSN_RESERV (decl)->regexp));\n \t  finish_regexp_representation ();\n \t}\n     }\n-  if (j != DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num)\n-    abort ();\n+  gcc_assert (j == DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num);\n \n   fprintf (output_file, \"\\n      \\\"%s\\\"\\n    };\\n  int %s;\\n\\n\",\n \t   NOTHING_NAME, INTERNAL_INSN_CODE_NAME);\n@@ -8969,7 +9022,7 @@ output_cpu_unit_reservation_p (void)\n \t   CPU_UNIT_RESERVATION_P_FUNC_NAME, STATE_NAME,\n \t   CPU_CODE_PARAMETER_NAME, STATE_TYPE_NAME, STATE_NAME,\n \t   CPU_CODE_PARAMETER_NAME);\n-  fprintf (output_file, \"{\\n  if (%s < 0 || %s >= %d)\\n    abort ();\\n\",\n+  fprintf (output_file, \"{\\n  gcc_assert (%s >= 0 && %s < %d);\\n\",\n \t   CPU_CODE_PARAMETER_NAME, CPU_CODE_PARAMETER_NAME,\n \t   description->query_units_num);\n   for (automaton = description->first_automaton;\n@@ -9239,8 +9292,7 @@ output_state_arcs (state_t state)\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n       ainsn = arc->insn;\n-      if (!ainsn->first_insn_with_same_reservs)\n-\tabort ();\n+      gcc_assert (ainsn->first_insn_with_same_reservs);\n       fprintf (output_description_file, \"    \");\n       curr_line_length = 7;\n       fprintf (output_description_file, \"%2d: \", ainsn->insn_equiv_class_num);\n@@ -9514,8 +9566,7 @@ make_insn_alts_attr (void)\n           insn_num++;\n         }\n     }\n-  if (description->insns_num != insn_num + 1)\n-    abort ();\n+  gcc_assert (description->insns_num == insn_num + 1);\n   make_internal_attr (attr_printf (sizeof (\"*\")\n \t\t\t\t   + strlen (INSN_ALTS_FUNC_NAME) + 1,\n \t\t\t\t   \"*%s\", INSN_ALTS_FUNC_NAME),\n@@ -9550,8 +9601,7 @@ make_internal_dfa_insn_code_attr (void)\n           insn_num++;\n         }\n     }\n-  if (description->insns_num != insn_num + 1)\n-    abort ();\n+  gcc_assert (description->insns_num == insn_num + 1);\n   make_internal_attr\n     (attr_printf (sizeof (\"*\")\n \t\t  + strlen (INTERNAL_DFA_INSN_CODE_FUNC_NAME) + 1,\n@@ -9585,8 +9635,7 @@ make_default_insn_latency_attr (void)\n           insn_num++;\n         }\n     }\n-  if (description->insns_num != insn_num + 1)\n-    abort ();\n+  gcc_assert (description->insns_num == insn_num + 1);\n   make_internal_attr (attr_printf (sizeof (\"*\")\n \t\t\t\t   + strlen (INSN_DEFAULT_LATENCY_FUNC_NAME)\n \t\t\t\t   + 1, \"*%s\", INSN_DEFAULT_LATENCY_FUNC_NAME),\n@@ -9824,8 +9873,7 @@ form_important_insn_automata_lists (void)\n \t       arc = next_out_arc (arc))\n \t    if (arc->to_state != *state_ptr)\n \t      {\n-\t\tif (!arc->insn->first_insn_with_same_reservs)\n-\t\t  abort ();\n+\t\tgcc_assert (arc->insn->first_insn_with_same_reservs);\n \t\tfor (ainsn = arc->insn;\n \t\t     ainsn != NULL;\n \t\t     ainsn = ainsn->next_same_reservs_insn)"}, {"sha": "84d1e10420b8bf826572b9d540702dd2dd9c3411", "filename": "gcc/genemit.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -260,7 +260,7 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n     case CONST_DOUBLE:\n       /* These shouldn't be written in MD files.  Instead, the appropriate\n \t routines in varasm.c should be called.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       break;\n@@ -277,25 +277,36 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n       if (fmt[i] == '0')\n \tbreak;\n       printf (\",\\n\\t\");\n-      if (fmt[i] == 'e' || fmt[i] == 'u')\n-\tgen_exp (XEXP (x, i), subroutine_type, used);\n-      else if (fmt[i] == 'i')\n-\tprintf (\"%u\", XINT (x, i));\n-      else if (fmt[i] == 's')\n-\tprintf (\"\\\"%s\\\"\", XSTR (x, i));\n-      else if (fmt[i] == 'E')\n+      switch (fmt[i])\n \t{\n-\t  int j;\n-\t  printf (\"gen_rtvec (%d\", XVECLEN (x, i));\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    {\n-\t      printf (\",\\n\\t\\t\");\n-\t      gen_exp (XVECEXP (x, i, j), subroutine_type, used);\n-\t    }\n-\t  printf (\")\");\n+\tcase 'e': case 'u':\n+\t  gen_exp (XEXP (x, i), subroutine_type, used);\n+\t  break;\n+\n+\tcase 'i':\n+\t  printf (\"%u\", XINT (x, i));\n+\t  break;\n+\n+\tcase 's':\n+\t  printf (\"\\\"%s\\\"\", XSTR (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  {\n+\t    int j;\n+\t    printf (\"gen_rtvec (%d\", XVECLEN (x, i));\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      {\n+\t\tprintf (\",\\n\\t\\t\");\n+\t\tgen_exp (XVECEXP (x, i, j), subroutine_type, used);\n+\t      }\n+\t    printf (\")\");\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n   printf (\")\");\n }\n@@ -707,7 +718,7 @@ output_add_clobbers (void)\n     }\n \n   printf (\"    default:\\n\");\n-  printf (\"      abort ();\\n\");\n+  printf (\"      gcc_unreachable ();\\n\");\n   printf (\"    }\\n\");\n   printf (\"}\\n\");\n }\n@@ -745,7 +756,7 @@ output_added_clobbers_hard_reg_p (void)\n     }\n \n   printf (\"    default:\\n\");\n-  printf (\"      abort ();\\n\");\n+  printf (\"      gcc_unreachable ();\\n\");\n   printf (\"    }\\n\");\n   printf (\"}\\n\");\n }"}, {"sha": "b600605240307c8e5141a9db25a4d4879cfb9dd5", "filename": "gcc/genextract.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -326,7 +326,7 @@ print_path (const char *path)\n       else if (ISDIGIT(path[i]))\n \tprintf (\"XEXP (\");\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   printf (\"pat\");\n@@ -338,7 +338,7 @@ print_path (const char *path)\n       else if (ISDIGIT(path[i]))\n \tprintf (\", %d)\", path[i] - '0');\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n }\n \f\n@@ -478,7 +478,7 @@ from the machine description file `md'.  */\\n\\n\");\n   /* This should never be reached.  Note that we would also reach this abort\n    if we tried to extract something whose INSN_CODE was a DEFINE_EXPAND or\n    DEFINE_SPLIT, but that is correct.  */\n-  printf (\"    default:\\n      abort ();\\n\");\n+  printf (\"    default:\\n      gcc_unreachable ();\\n\");\n \n   printf (\"    }\\n}\\n\");\n "}, {"sha": "a52e18a9deffbded49366edbd9655fca2eab60c9", "filename": "gcc/genflags.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -102,10 +102,8 @@ gen_macro (const char *name, int real, int expect)\n {\n   int i;\n \n-  if (real > expect)\n-    abort ();\n-  if (real == 0)\n-    abort ();\n+  gcc_assert (real <= expect);\n+  gcc_assert (real);\n \n   /* #define GEN_CALL(A, B, C, D) gen_call((A), (B)) */\n   fputs (\"#define GEN_\", stdout);"}, {"sha": "e74dc415762951456dc378c86f60e3cf96a30fe7", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -84,7 +84,7 @@ type_from_format (int c)\n     case 'B':\n       return \"struct basic_block_def *\";  /* basic block - typedef not available */\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -120,7 +120,7 @@ accessor_from_format (int c)\n       return \"XBBDEF\";\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n "}, {"sha": "01040cc82b2884228d76200dd7ac3d013277e1b4", "filename": "gcc/gengtype.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -24,7 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"gengtype.h\"\n #include \"gtyp-gen.h\"\n-#undef abort\n+#include \"errors.h\"\n \n /* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n@@ -1128,7 +1128,7 @@ get_file_basename (const char *f)\n         {\n           basename -= l2 + 1;\n           if ((basename - f - 1) != srcdir_len)\n-            abort (); /* Match is wrong - should be preceded by $srcdir.  */\n+\t    fatal (\"filename `%s' should be preceded by $srcdir\", f);\n           break;\n         }\n     }\n@@ -1442,7 +1442,7 @@ output_mangled_typename (outf_p of, type_p t)\n       }\n       break;\n     case TYPE_ARRAY:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1608,7 +1608,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \tif (maybe_undef_p\n \t    && t->u.p->u.s.line.file == NULL)\n \t  {\n-\t    oprintf (d->of, \"%*sif (%s) abort();\\n\", d->indent, \"\", d->val);\n+\t    oprintf (d->of, \"%*sgcc_assert (!%s);\\n\", d->indent, \"\", d->val);\n \t    break;\n \t  }\n \n@@ -1844,7 +1844,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->used_length = false;\n \n \t    if (union_p && use_param_p && d->param == NULL)\n-\t      oprintf (d->of, \"%*sabort();\\n\", d->indent, \"\");\n+\t      oprintf (d->of, \"%*sgcc_unreachable ();\\n\", d->indent, \"\");\n \t    else\n \t      walk_type (f->type, d);\n \n@@ -1900,7 +1900,7 @@ walk_type (type_p t, struct walk_type_data *d)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1957,7 +1957,7 @@ write_types_process_field (type_p f, const struct walk_type_data *d)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2227,7 +2227,7 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n "}, {"sha": "383e6cf4f9e6469e5804f26324e48e09ed6f0591", "filename": "gcc/genmodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -364,7 +364,7 @@ complete_mode (struct mode_data *m)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If not already specified, the mode alignment defaults to the largest"}, {"sha": "273a5fbb5a0b5e94163010545e8d37a8aab63e56", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -281,7 +281,7 @@ gen_insn (rtx insn)\n \t\tbreak;\n \n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t}\n "}, {"sha": "a62c677c806f644ca1d49d4ff591f15810fef1c0", "filename": "gcc/genoutput.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -379,7 +379,7 @@ output_insn_data (void)\n \t  printf (\"#endif\\n\");\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (d->name && d->name[0] != '*')\n@@ -1076,17 +1076,15 @@ check_constraint_len (void)\n \n   for (p = \",#*+=&%!1234567890\"; *p; p++)\n     for (d = -9; d < 9; d++)\n-      if (constraint_len (p, d) != d)\n-\tabort ();\n+      gcc_assert (constraint_len (p, d) == d);\n }\n \n static int\n constraint_len (const char *p, int genoutput_default_constraint_len)\n {\n   /* Check that we still match defaults.h .  First we do a generation-time\n      check that fails if the value is not the expected one...  */\n-  if (DEFAULT_CONSTRAINT_LEN (*p, p) != 1)\n-    abort ();\n+  gcc_assert (DEFAULT_CONSTRAINT_LEN (*p, p) == 1);\n   /* And now a compile-time check that should give a diagnostic if the\n      definition doesn't exactly match.  */\n #define DEFAULT_CONSTRAINT_LEN(C,STR) 1"}, {"sha": "b090ba4e1d0206865c2428aacffb255cc8c2a389", "filename": "gcc/genpreds.c", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -259,38 +259,47 @@ add_mode_tests (struct pred_data *p)\n   for (;;)\n     {\n       rtx subexp = *pos;\n-      if (GET_CODE (subexp) == IOR)\n-\t{\n-\t  if (NO_MODE_TEST (XEXP (subexp, 0))\n-\t      && NO_MODE_TEST (XEXP (subexp, 1)))\n-\t    break;\n-\t  else if (NO_MODE_TEST (XEXP (subexp, 0)))\n-\t    pos = &XEXP (subexp, 0);\n-\t  else if (NO_MODE_TEST (XEXP (subexp, 1)))\n-\t    pos = &XEXP (subexp, 1);\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (subexp) == IF_THEN_ELSE)\n+\n+      switch (GET_CODE (subexp))\n \t{\n-\t  if (NO_MODE_TEST (XEXP (subexp, 0))\n-\t      && NO_MODE_TEST (XEXP (subexp, 1))\n-\t      && NO_MODE_TEST (XEXP (subexp, 2)))\n-\t    break;\n-\t  else if (NO_MODE_TEST (XEXP (subexp, 0))\n-\t\t   && NO_MODE_TEST (XEXP (subexp, 1)))\n-\t    /* Must put it on the dependent clause, not the controlling\n-\t       expression, or we change the meaning of the test. */\n-\t    pos = &XEXP (subexp, 1);\n-\t  else if (NO_MODE_TEST (XEXP (subexp, 2)))\n-\t    pos = &XEXP (subexp, 2);\n-\t  else\n-\t    abort ();\n+\tcase IOR:\n+\t  {\n+\t    int test0 = NO_MODE_TEST (XEXP (subexp, 0));\n+\t    int test1 = NO_MODE_TEST (XEXP (subexp, 1));\n+\t    \n+\t    gcc_assert (test0 || test1);\n+\t    \n+\t    if (test0 && test1)\n+\t      goto break_loop;\n+\t    pos = test0 ? &XEXP (subexp, 0) : &XEXP (subexp, 1);\n+\t  }\n+\t  break;\n+\t  \n+\tcase IF_THEN_ELSE:\n+\t  {\n+\t    int test0 = NO_MODE_TEST (XEXP (subexp, 0));\n+\t    int test1 = NO_MODE_TEST (XEXP (subexp, 1));\n+\t    int test2 = NO_MODE_TEST (XEXP (subexp, 2));\n+\t    \n+\t    gcc_assert ((test0 && test1) || test2);\n+\t    \n+\t    if (test0 && test1 && test2)\n+\t      goto break_loop;\n+\t    if (test0 && test1)\n+\t      /* Must put it on the dependent clause, not the\n+\t      \t controlling expression, or we change the meaning of\n+\t      \t the test. */\n+\t      pos = &XEXP (subexp, 1);\n+\t    else\n+\t      pos = &XEXP (subexp, 2);\n+\t  }\n+\t  break;\n+\t  \n+\tdefault:\n+\t  goto break_loop;\n \t}\n-      else\n-\tbreak;\n     }\n-\n+ break_loop:\n   XEXP (and_exp, 0) = *pos;\n   *pos = and_exp;\n }"}, {"sha": "241c08007ed6e30a64c2e2465d52346a60c5427e", "filename": "gcc/genrecog.c", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -547,7 +547,7 @@ find_operand (rtx pattern, int n, rtx stop)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -598,7 +598,7 @@ find_matching_operand (rtx pattern, int n)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -851,7 +851,7 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -1050,18 +1050,18 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n     {\n       if (fmt[i] == 'i')\n \t{\n-\t  if (i == 0)\n+\t  gcc_assert (i < 2);\n+\t  \n+\t  if (!i)\n \t    {\n \t      test = new_decision_test (DT_elt_zero_int, &place);\n \t      test->u.intval = XINT (pattern, i);\n \t    }\n-\t  else if (i == 1)\n+\t  else\n \t    {\n \t      test = new_decision_test (DT_elt_one_int, &place);\n \t      test->u.intval = XINT (pattern, i);\n \t    }\n-\t  else\n-\t    abort ();\n \t}\n       else if (fmt[i] == 'w')\n \t{\n@@ -1071,16 +1071,14 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \t    = ((int) XWINT (pattern, i) == XWINT (pattern, i))\n \t      ? DT_elt_zero_wide_safe : DT_elt_zero_wide;\n \n-\t  if (i != 0)\n-\t    abort ();\n+\t  gcc_assert (!i);\n \n \t  test = new_decision_test (type, &place);\n \t  test->u.intval = XWINT (pattern, i);\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  if (i != 0)\n-\t    abort ();\n+\t  gcc_assert (!i);\n \n \t  test = new_decision_test (DT_veclen, &place);\n \t  test->u.veclen = XVECLEN (pattern, i);\n@@ -1117,7 +1115,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -1139,8 +1137,7 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n     }\n \n   /* If we didn't insert any tests or accept nodes, hork.  */\n-  if (this->tests == NULL)\n-    abort ();\n+  gcc_assert (this->tests);\n \n  ret:\n   free (subpos);\n@@ -1311,8 +1308,7 @@ maybe_both_true (struct decision *d1, struct decision *d2,\n   cmp = strcmp (d1->position, d2->position);\n   if (cmp != 0)\n     {\n-      if (toplevel)\n-\tabort ();\n+      gcc_assert (!toplevel);\n \n       /* If the d2->position was lexically lower, swap.  */\n       if (cmp > 0)\n@@ -1390,7 +1386,7 @@ nodes_identical_1 (struct decision_test *d1, struct decision_test *d2)\n       return 1;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1492,8 +1488,7 @@ merge_trees (struct decision_head *oldh, struct decision_head *addh)\n     }\n \n   /* Trying to merge bits at different positions isn't possible.  */\n-  if (strcmp (oldh->first->position, addh->first->position))\n-    abort ();\n+  gcc_assert (!strcmp (oldh->first->position, addh->first->position));\n \n   for (add = addh->first; add ; add = next)\n     {\n@@ -1989,7 +1984,7 @@ write_switch (struct decision *start, int depth)\n \t  printf (\"(int) XWINT (x%d, 0)\", depth);\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       printf (\")\\n%s    {\\n\", indent);\n \n@@ -2022,7 +2017,7 @@ write_switch (struct decision *start, int depth)\n \t      print_host_wide_int (p->tests->u.intval);\n \t      break;\n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  printf (\":\\n%s      goto L%d;\\n\", indent, p->success.first->number);\n \t  p->success.first->need_label = 1;\n@@ -2102,21 +2097,13 @@ write_cond (struct decision_test *p, int depth,\n       break;\n \n     case DT_accept_insn:\n-      switch (subroutine_type)\n-\t{\n-\tcase RECOG:\n-\t  if (p->u.insn.num_clobbers_to_add == 0)\n-\t    abort ();\n-\t  printf (\"pnum_clobbers != NULL\");\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      gcc_assert (subroutine_type == RECOG);\n+      gcc_assert (p->u.insn.num_clobbers_to_add);\n+      printf (\"pnum_clobbers != NULL\");\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2151,14 +2138,12 @@ write_action (struct decision *p, struct decision_test *test,\n       if (test->next)\n \t{\n \t  test = test->next;\n-\t  if (test->type != DT_accept_insn)\n-\t    abort ();\n+\t  gcc_assert (test->type == DT_accept_insn);\n \t}\n     }\n \n   /* Sanity check that we're now at the end of the list of tests.  */\n-  if (test->next)\n-    abort ();\n+  gcc_assert (!test->next);\n \n   if (test->type == DT_accept_insn)\n     {\n@@ -2196,7 +2181,7 @@ write_action (struct decision *p, struct decision_test *test,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -2231,7 +2216,7 @@ is_unconditional (struct decision_test *t, enum routine_type subroutine_type)\n \tcase PEEPHOLE2:\n \t  return -1;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -2527,8 +2512,7 @@ make_insn_sequence (rtx insn, enum routine_type type)\n   char c_test_pos[2];\n \n   /* We should never see an insn whose C test is false at compile time.  */\n-  if (truth == 0)\n-    abort ();\n+  gcc_assert (truth);\n \n   record_insn_name (next_insn_code, (type == RECOG ? XSTR (insn, 0) : NULL));\n \n@@ -2874,7 +2858,7 @@ debug_decision_2 (struct decision_test *test)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n "}, {"sha": "1fb45c0835f165439cebe4618cae1702ca169cb0", "filename": "gcc/gensupport.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2d59f6f77221be75b336211de396a8b1603356b/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=b2d59f6f77221be75b336211de396a8b1603356b", "patch": "@@ -392,7 +392,7 @@ is_predicable (struct queue_elem *elem)\n \t  return 0;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -559,7 +559,7 @@ collect_insn_data (rtx pattern, int *palt, int *pmax)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -645,7 +645,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op, int lineno)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -1119,8 +1119,7 @@ maybe_eval_c_test (const char *expr)\n \n   dummy.expr = expr;\n   test = (const struct c_test *)htab_find (condition_table, &dummy);\n-  if (!test)\n-    abort ();\n+  gcc_assert (test);\n \n   return test->value;\n }"}]}