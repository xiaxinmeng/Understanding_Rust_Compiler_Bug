{"sha": "c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlMzk2MDI4NGNlMDM1YWM0M2FmMjUyNWY4ZWUzZmVkMTVhYjliMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-05-06T09:18:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-05-06T09:18:46Z"}, "message": "Make-lang.in (treelang/tree1.o): Depends on input.h\n\ntreelang:\n\t* Make-lang.in (treelang/tree1.o): Depends on input.h\n\t(treelang/treetree.o, treelang/parse.o, treelang/lex.o): Likewise.\n\t* treelang.h: #include input.h.\n\t(in_fname): Remove.\n\t(struct token_part): Remove lineno, add location.\n\t* lex.l (next_tree_lineno): Remove.\n\t(update_lineno_charno): Adjust.\n\t(dump_lex_value): Adjust.\n\t* parse.y (variable_def, function_prototype, function, statement,\n\tif_statement, return, function_invocation, variable_ref): Adjust.\n\t(print_token, yyerror, ensure_not_void): Adjust.\n\ttree1.c (in_fname): Remove.\n\t(treelang_init): Setup input_location.\n\t(lookup_tree_name): Adjust.\n\t(insert_tree_name): Adjust.\n\t* treetree.c (tree_code_if_start): Replace filename and lineno\n\tparms with loc. Adjust.\n\t(tree_code_if_else, tree_code_if_end,\n\ttree_code_create_function_prototype,\n\ttree_code_create_function_initial,\n\ttree_code_create_function_wrapup, tree_code_create_variable,\n\ttree_code_output_expression_statement): Likewise.\n\t* treetree.h (tree_code_if_start): Replace filename and lineno\n\tparms with loc.\n\t(tree_code_if_else, tree_code_if_end,\n\ttree_code_create_function_prototype,\n\ttree_code_create_function_initial,\n\ttree_code_create_function_wrapup, tree_code_create_variable,\n\ttree_code_output_expression_statement): Likewise.\n\nFrom-SVN: r66519", "tree": {"sha": "40b598b4edfdb0e0256b7acc704bac61ff58f9e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40b598b4edfdb0e0256b7acc704bac61ff58f9e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/comments", "author": null, "committer": null, "parents": [{"sha": "e8b84d3d39380e5cf08dcf567367b95485ed7e72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b84d3d39380e5cf08dcf567367b95485ed7e72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8b84d3d39380e5cf08dcf567367b95485ed7e72"}], "stats": {"total": 266, "additions": 147, "deletions": 119}, "files": [{"sha": "cd2c9c4b863bf4dbf6d13eb792dfaf1f55d02f55", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -1,3 +1,35 @@\n+2003-05-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* Make-lang.in (treelang/tree1.o): Depends on input.h\n+\t(treelang/treetree.o, treelang/parse.o, treelang/lex.o): Likewise.\n+\t* treelang.h: #include input.h.\n+\t(in_fname): Remove.\n+\t(struct token_part): Remove lineno, add location.\n+\t* lex.l (next_tree_lineno): Remove.\n+\t(update_lineno_charno): Adjust.\n+\t(dump_lex_value): Adjust.\n+\t* parse.y (variable_def, function_prototype, function, statement,\n+\tif_statement, return, function_invocation, variable_ref): Adjust.\n+\t(print_token, yyerror, ensure_not_void): Adjust.\n+\ttree1.c (in_fname): Remove.\n+\t(treelang_init): Setup input_location.\n+\t(lookup_tree_name): Adjust.\n+\t(insert_tree_name): Adjust.\n+\t* treetree.c (tree_code_if_start): Replace filename and lineno\n+\tparms with loc. Adjust.\n+\t(tree_code_if_else, tree_code_if_end,\n+\ttree_code_create_function_prototype,\n+\ttree_code_create_function_initial,\n+\ttree_code_create_function_wrapup, tree_code_create_variable,\n+\ttree_code_output_expression_statement): Likewise.\n+\t* treetree.h (tree_code_if_start): Replace filename and lineno\n+\tparms with loc.\n+\t(tree_code_if_else, tree_code_if_end,\n+\ttree_code_create_function_prototype,\n+\ttree_code_create_function_initial,\n+\ttree_code_create_function_wrapup, tree_code_create_variable,\n+\ttree_code_output_expression_statement): Likewise.\n+\n 2003-05-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree1.c (treelang_init): Rename lineno to input_line."}, {"sha": "2e31fac8c73bc8db159c6f52564601253913dbb8", "filename": "gcc/treelang/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FMake-lang.in?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -96,19 +96,19 @@ tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/par\n \n treelang/tree1.o: treelang/tree1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   flags.h toplev.h $(GGC_H) $(TREE_H) diagnostic.h treelang/treelang.h \\\n-  treelang/treetree.h \\\n+  input.h treelang/treetree.h \\\n   treelang/treetree.h gt-treelang-tree1.h gtype-treelang.h\n \n treelang/treetree.o: treelang/treetree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(TM_H) $(TREE_H) flags.h output.h $(C_TREE_H) $(RTL_H) $(GGC_H) toplev.h \\\n-  varray.h $(LANGHOOKS_DEF_H) langhooks.h treelang/treelang.h \\\n+  varray.h $(LANGHOOKS_DEF_H) langhooks.h treelang/treelang.h input.h \\\n   treelang/treetree.h treelang/parse.h\n \n treelang/parse.o: treelang/parse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) diagnostic.h treelang/treelang.h treelang/treetree.h\n+  $(TM_H) diagnostic.h treelang/treelang.h input.h treelang/treetree.h\n \n treelang/lex.o: treelang/lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) diagnostic.h $(TREE_H) treelang/treelang.h treelang/parse.h\n+  $(TM_H) diagnostic.h $(TREE_H) treelang/treelang.h input.h treelang/parse.h\n \n # generated files the files from lex and yacc are put into the source\n # directory in case someone wants to build but does not have"}, {"sha": "364bf0208d499bf3218ea8f6ed556d668fe4c718", "filename": "gcc/treelang/lex.l", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -51,7 +51,6 @@ extern int option_lexer_trace;\n int yylex (void);\n void update_yylval (int a); \n \n-static int next_tree_lineno=1;\n static int next_tree_charno=1;\n  \n static void update_lineno_charno (void);\n@@ -75,7 +74,7 @@ static void dump_lex_value (int lexret);\n  { \n    /* Should really allocate only what we need. lll;.  */\n    yylval = my_malloc (sizeof (struct prod_token_parm_item));\n-   ((struct prod_token_parm_item *)yylval)->tp.tok.lineno = next_tree_lineno;\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.location = input_location;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n  }\n \n@@ -213,9 +212,10 @@ static void dump_lex_value (int lexret);\n   \n [^\\n]  {\n   update_lineno_charno ();\n-  fprintf (stderr, \"%s:%i:%i: Unrecognized character %c\\n\", in_fname, \n-           ((struct prod_token_parm_item *)yylval)->tp.tok.lineno, \n-           ((struct prod_token_parm_item *)yylval)->tp.tok.charno, yytext[0]);\n+  fprintf (stderr, \"%s:%i:%i: Unrecognized character %c\\n\",\n+\t   ((struct prod_token_parm_item *)yylval)->tp.tok.location.file, \n+           ((struct prod_token_parm_item *)yylval)->tp.tok.location.line, \n+\t   ((struct prod_token_parm_item *)yylval)->tp.tok.charno, yytext[0]);\n   errorcount++;\n }\n \n@@ -231,13 +231,13 @@ update_lineno_charno (void)\n    /* Update the values we send to caller in case we sometimes don't\n       tell them about all the 'tokens' eg comments etc.  */\n    int yyl;\n-   ((struct prod_token_parm_item *)yylval)->tp.tok.lineno = next_tree_lineno;\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.location = input_location;\n    ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n    for ( yyl = 0; yyl < yyleng; ++yyl ) \n       {\n          if ( yytext[yyl] == '\\n' ) \n             {\n-               ++next_tree_lineno;\n+\t      ++input_line;\n                next_tree_charno = 1;\n             } \n          else \n@@ -269,7 +269,7 @@ dump_lex_value (int lexret)\n {\n   int ix;\n   fprintf (stderr, \" %d l:%d c:%d ln:%d text=\", lexret,\n-         ((struct prod_token_parm_item *) yylval)->tp.tok.lineno,\n+         ((struct prod_token_parm_item *) yylval)->tp.tok.location.line,\n          ((struct prod_token_parm_item *) yylval)->tp.tok.charno,\n          ((struct prod_token_parm_item *) yylval)->tp.tok.length);\n   for (ix = 0; ix < yyleng; ix++) "}, {"sha": "bb530f9e8372b8d446ec7ef177a9d73a17449923", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -203,8 +203,9 @@ storage typename NAME init_opt SEMICOLON {\n         abort ();\n     if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n       {\n-        fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\", in_fname, \n-                tok->tp.tok.lineno, tok->tp.tok.charno);\n+        fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\",\n+\t\t tok->tp.tok.location.file,\n+\t\t tok->tp.tok.location.line, tok->tp.tok.charno);\n         print_token (stderr, 0, tok);\n         errorcount++;\n         YYERROR;\n@@ -216,8 +217,7 @@ storage typename NAME init_opt SEMICOLON {\n      ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.length,\n      NUMERIC_TYPE (prod),\n      VAR_INIT (prod)? ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code:NULL,\n-     in_fname,\n-     tok->tp.tok.lineno);\n+     tok->tp.tok.location);\n   if (!prod->tp.pro.code) \n     abort ();\n }\n@@ -277,8 +277,9 @@ storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n       break;\n       \n     case AUTOMATIC_STORAGE:\n-      fprintf (stderr, \"%s:%i:%i: A function cannot be automatic\\n\", in_fname, \n-              tok->tp.tok.lineno, tok->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: A function cannot be automatic\\n\",\n+\t       tok->tp.tok.location.file,\n+\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -323,8 +324,7 @@ storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n \n   prod->tp.pro.code = tree_code_create_function_prototype\n     (tok->tp.tok.chars, STORAGE_CLASS (prod), NUMERIC_TYPE (type),\n-     first_parms, in_fname, tok->tp.tok.lineno);\n-\n+     first_parms, tok->tp.tok.location);\n }\n ;\n \n@@ -340,16 +340,17 @@ NAME LEFT_BRACE {\n   current_function = proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n-              tok->tp.tok.lineno, tok->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\",\n+\t       tok->tp.tok.location.file,\n+\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n     }\n   if (!proto->tp.pro.code)\n     abort ();\n   tree_code_create_function_initial\n-    (proto->tp.pro.code, in_fname, tok->tp.tok.lineno,\n+    (proto->tp.pro.code, tok->tp.tok.location,\n      FIRST_PARMS (current_function));\n \n   /* Check all the parameters have code.  */\n@@ -366,7 +367,7 @@ NAME LEFT_BRACE {\n variable_defs_opt statements_opt RIGHT_BRACE {\n   struct prod_token_parm_item* tok;\n   tok = $1;\n-  tree_code_create_function_wrapup (in_fname, tok->tp.tok.lineno);\n+  tree_code_create_function_wrapup (tok->tp.tok.location);\n   current_function = NULL;\n }\n ;\n@@ -472,7 +473,8 @@ statement:\n expression SEMICOLON {\n   struct prod_token_parm_item *exp;\n   exp = $1;\n-  tree_code_output_expression_statement (exp->tp.pro.code, in_fname, exp->tp.pro.main_token->tp.tok.lineno);\n+  tree_code_output_expression_statement (exp->tp.pro.code,\n+\t\t\t\t\t exp->tp.pro.main_token->tp.tok.location);\n }\n |return SEMICOLON {\n   /* Nothing to do.  */\n@@ -489,20 +491,20 @@ IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {\n   tok = $1;\n   exp = $3;\n   ensure_not_void (NUMERIC_TYPE (exp), exp->tp.pro.main_token);\n-  tree_code_if_start (exp->tp.pro.code, in_fname, tok->tp.tok.lineno);\n+  tree_code_if_start (exp->tp.pro.code, tok->tp.tok.location);\n }\n LEFT_BRACE statements_opt RIGHT_BRACE {\n   /* Just let the statements flow.  */\n }\n ELSE {\n   struct prod_token_parm_item* tok;\n   tok = $1;\n-  tree_code_if_else (in_fname, tok->tp.tok.lineno);\n+  tree_code_if_else (tok->tp.tok.location);\n }\n LEFT_BRACE statements_opt RIGHT_BRACE {\n   struct prod_token_parm_item* tok;\n   tok = $12;\n-  tree_code_if_end (in_fname, tok->tp.tok.lineno);\n+  tree_code_if_end (tok->tp.tok.location);\n }\n ;\n \n@@ -518,17 +520,19 @@ tl_RETURN expression_opt {\n       tree_code_generate_return (type_prod->tp.pro.code, NULL);\n     else\n       {\n-        fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\", in_fname, \n-                ret_tok->tp.tok.lineno, ret_tok->tp.tok.charno);\n+        fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\",\n+\t\t ret_tok->tp.tok.location.file,\n+\t\t ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno);\n         print_token (stderr, 0, ret_tok);\n         errorcount++;\n         tree_code_generate_return (type_prod->tp.pro.code, NULL);\n       }\n   else\n     if ($2 == NULL)\n       {\n-        fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\", in_fname, \n-                ret_tok->tp.tok.lineno, ret_tok->tp.tok.charno); \n+        fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\",\n+\t\t ret_tok->tp.tok.location.file,\n+\t\t ret_tok->tp.tok.location.line, ret_tok->tp.tok.charno); \n         print_token (stderr, 0, ret_tok);\n         errorcount++;\n       }\n@@ -636,8 +640,9 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n   proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n-              tok->tp.tok.lineno, tok->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\",\n+\t       tok->tp.tok.location.file,\n+\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -654,8 +659,9 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n \n   if (exp_count !=  exp_proto_count)\n     {\n-      fprintf (stderr, \"%s:%i:%i: expression count mismatch with prototype\\n\", in_fname, \n-              tok->tp.tok.lineno, tok->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: expression count mismatch with prototype\\n\",\n+\t       tok->tp.tok.location.file,\n+\t       tok->tp.tok.location.line, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -715,8 +721,9 @@ NAME {\n   symbol_table_entry = lookup_tree_name (&search_prod);\n   if (!symbol_table_entry)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Variable referred to but not defined\\n\", in_fname, \n-              tok->tp.tok.lineno, tok->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: Variable referred to but not defined\\n\",\n+              tok->tp.tok.location.file,\n+              tok->tp.tok.location.line, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -766,7 +773,7 @@ print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value)\n   unsigned int  ix;\n \n   tok  =  value;\n-  fprintf (file, \"%d \\\"\", tok->tp.tok.lineno);\n+  fprintf (file, \"%d \\\"\", tok->tp.tok.location.line);\n   for (ix  =  0; ix < tok->tp.tok.length; ix++)\n     fprintf (file, \"%c\", tok->tp.tok.chars[ix]);\n   fprintf (file, \"\\\"\");\n@@ -781,7 +788,8 @@ yyerror (const char *error_message)\n   tok = yylval;\n   if (tok)\n     {\n-      fprintf (stderr, \"%s:%i:%i: %s\\n\", in_fname, tok->tp.tok.lineno, tok->tp.tok.charno, error_message);\n+      fprintf (stderr, \"%s:%i:%i: %s\\n\", tok->tp.tok.location.file,\n+\t       tok->tp.tok.location.line, tok->tp.tok.charno, error_message);\n       print_token (stderr, 0, tok);\n     }\n   else\n@@ -823,8 +831,9 @@ ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n {\n   if (type == VOID)\n     {\n-      fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\", in_fname, \n-              name->tp.tok.lineno, name->tp.tok.charno);\n+      fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\",\n+\t       name->tp.tok.location.file,\n+\t       name->tp.tok.location.line, name->tp.tok.charno);\n       print_token (stderr, 0, name);\n       errorcount++;\n     }"}, {"sha": "3a6681a9b0f6f20d39ea65e886c80e7d2692dae4", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -78,8 +78,6 @@ unsigned int option_lexer_trace = 0;\n \n /* Local variables.  */\n \n-const char *in_fname;\t/* Input file name.  */\n-\n /* This is 1 if we have output the version string.  */\n \n static int version_done = 0;\n@@ -187,9 +185,7 @@ treelang_decode_option (num_options_left, first_option_left)\n bool\n treelang_init ()\n {\n-  in_fname = main_input_filename;\n-\n-  /* Set up the declarations needed for this front end.  */\n+  input_filename = main_input_filename;\n   input_line = 0;\n \n   /* Init decls etc.  */\n@@ -198,7 +194,7 @@ treelang_init ()\n \n   /* This error will not happen from GCC as it will always create a\n      fake input file.  */\n-  if (!in_fname || in_fname[0] == ' ' || !in_fname[0]) \n+  if (!input_filename || input_filename[0] == ' ' || !input_filename[0]) \n     {\n       if (!version_done)\n         {\n@@ -209,10 +205,10 @@ treelang_init ()\n       return false;\n     }\n \n-  yyin = fopen (in_fname, \"r\");\n+  yyin = fopen (input_filename, \"r\");\n   if (!yyin)\n     {\n-      fprintf (stderr, \"Unable to open input file %s\\n\", in_fname);\n+      fprintf (stderr, \"Unable to open input file %s\\n\", input_filename);\n       exit (1);\n     }\n \n@@ -279,13 +275,16 @@ lookup_tree_name (struct prod_token_parm_item *prod)\n       if (memcmp (tok->tp.tok.chars, this_tok->tp.tok.chars, this_tok->tp.tok.length))\n         continue;\n       if (option_parser_trace)\n-        fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\", tok->tp.tok.chars, \n-                tok->tp.tok.lineno, tok->tp.tok.charno, NUMERIC_TYPE (this));\n+        fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\",\n+\t\t tok->tp.tok.chars, \n+\t\t tok->tp.tok.location.line, tok->tp.tok.charno,\n+\t\t NUMERIC_TYPE (this));\n       return this;\n     }\n   if (option_parser_trace)\n-    fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\", tok->tp.tok.chars, \n-            tok->tp.tok.lineno, tok->tp.tok.charno, tok->type);\n+    fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\",\n+\t     tok->tp.tok.chars, \n+\t     tok->tp.tok.location.line, tok->tp.tok.charno, tok->type);\n   return NULL;\n }\n \n@@ -299,7 +298,8 @@ insert_tree_name (struct prod_token_parm_item *prod)\n   sanity_check (prod);\n   if (lookup_tree_name (prod))\n     {\n-      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\", in_fname, tok->tp.tok.lineno, \n+      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\",\n+\t       tok->tp.tok.location.file, tok->tp.tok.location.line, \n                tok->tp.tok.charno, tok->tp.tok.chars);\n       errorcount++;\n       return 1;"}, {"sha": "abeeb1e9409270a411c31add805ee407c91621ad", "filename": "gcc/treelang/treelang.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreelang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreelang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreelang.h?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -30,6 +30,8 @@\n \n */\n \n+#include \"input.h\"\n+\n /* Parse structure type.  */\n enum category_enum \n { /* These values less likely to be there by chance unlike 0/1,\n@@ -39,8 +41,7 @@ enum category_enum\n   parameter_category = 333\n };\n \n-/* Input file name and FILE.  */\n-extern const char* in_fname;\n+/* Input file FILE.  */\n extern FILE* yyin;\n \n /* Forward references to satisfy mutually recursive definitions.  */\n@@ -53,7 +54,7 @@ typedef struct GTY(()) prod_token_parm_item item;\n \n struct token_part GTY(())\n {\n-  unsigned int lineno;\n+  location_t location;\n   unsigned int charno;\n   unsigned int length; /* The value.  */\n   unsigned char* chars;"}, {"sha": "4ff2c2fa450fca77490d62ff6e0e006ca0f09db3", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -178,34 +178,34 @@ tree_code_get_type (int type_num)\n    LINENO in file FILENAME.  */\n \n void\n-tree_code_if_start (tree exp, const char* filename, int lineno)\n+tree_code_if_start (tree exp, location_t loc)\n {\n   tree cond_exp;\n   cond_exp = build (NE_EXPR,\n                  TREE_TYPE (exp),\n                  exp,\n                  build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node));\n-  emit_line_note (filename, lineno); /* Output the line number information.  */\n+  emit_line_note (loc.file, loc.line); /* Output the line number information.  */\n   expand_start_cond (cond_exp, /* Exit-able if nonzero.  */ 0);\n }\n \n /* Output the code for the else of an if statement.  The else occurred\n    at line LINENO in file FILENAME.  */\n \n void\n-tree_code_if_else (const char* filename, int lineno)\n+tree_code_if_else (location_t loc)\n {\n-  emit_line_note (filename, lineno); /* Output the line number information.  */\n+  emit_line_note (loc.file, loc.line); /* Output the line number information.  */\n   expand_start_else ();\n }\n \n /* Output the code for the end_if an if statement.  The end_if (final brace) occurred\n    at line LINENO in file FILENAME.  */\n \n void\n-tree_code_if_end (const char* filename, int lineno)\n+tree_code_if_end (location_t loc)\n {\n-  emit_line_note (filename, lineno); /* Output the line number information.  */\n+  emit_line_note (loc.file, loc.line); /* Output the line number information.  */\n   expand_end_cond ();\n }\n \n@@ -215,11 +215,10 @@ tree_code_if_end (const char* filename, int lineno)\n \n tree\n tree_code_create_function_prototype (unsigned char* chars,\n-                                    unsigned int storage_class,\n-                                    unsigned int ret_type,\n-                                    struct prod_token_parm_item* parms,\n-                                    const char* filename,\n-                                    int lineno)\n+\t\t\t\t     unsigned int storage_class,\n+\t\t\t\t     unsigned int ret_type,\n+\t\t\t\t     struct prod_token_parm_item* parms,\n+\t\t\t\t     location_t loc)\n {\n \n   tree id;\n@@ -251,13 +250,7 @@ tree_code_create_function_prototype (unsigned char* chars,\n   fn_decl = build_decl (FUNCTION_DECL, id, fn_type);\n \n   DECL_CONTEXT (fn_decl) = NULL_TREE; /* Nested functions not supported here.  */\n-  DECL_SOURCE_FILE (fn_decl) = filename;\n- /*  if (lineno > 1000000)\n-    ; */ /* Probably the line # is rubbish because someone forgot to set\n-    the line number - and unfortunately impossible line #s are used as\n-    magic flags at various times. The longest known function for\n-    example is about 550,000 lines (it was written in COBOL).  */\n-  DECL_SOURCE_LINE (fn_decl) = lineno;\n+  DECL_SOURCE_LOCATION (fn_decl) = loc;\n \n   TREE_USED (fn_decl) = 1;\n \n@@ -303,9 +296,8 @@ tree_code_create_function_prototype (unsigned char* chars,\n     parameter details are in the lists PARMS. Returns nothing.  */\n void\n tree_code_create_function_initial (tree prev_saved,\n-                                  const char* filename,\n-                                  int lineno,\n-                                  struct prod_token_parm_item* parms)\n+\t\t\t\t   location_t loc,\n+\t\t\t\t   struct prod_token_parm_item* parms)\n {\n   tree fn_decl;\n   tree param_decl;\n@@ -331,15 +323,14 @@ tree_code_create_function_initial (tree prev_saved,\n   current_function_decl = fn_decl;\n   DECL_INITIAL (fn_decl) = error_mark_node;\n \n-  DECL_SOURCE_FILE (fn_decl) = filename;\n-  DECL_SOURCE_LINE (fn_decl) = lineno;\n+  DECL_SOURCE_LOCATION (fn_decl) = loc;\n \n   /* Prepare creation of rtl for a new function.  */\n \n   resultdecl = DECL_RESULT (fn_decl) = build_decl (RESULT_DECL, NULL_TREE, TREE_TYPE (TREE_TYPE (fn_decl)));\n   DECL_CONTEXT (DECL_RESULT (fn_decl)) = fn_decl;\n-  DECL_SOURCE_FILE (resultdecl) = filename;\n-  DECL_SOURCE_LINE (resultdecl) = lineno;\n+  DECL_SOURCE_LOCATION (resultdecl) = loc;\n+\n   /* Work out the size. ??? is this needed.  */\n   layout_decl (DECL_RESULT (fn_decl), 0);\n \n@@ -358,8 +349,7 @@ tree_code_create_function_initial (tree prev_saved,\n       if (!fn_decl)\n         abort ();\n       DECL_CONTEXT (parm_decl) = fn_decl;\n-      DECL_SOURCE_FILE (parm_decl) = filename;\n-      DECL_SOURCE_LINE (parm_decl) = lineno;\n+      DECL_SOURCE_LOCATION (parm_decl) = loc;\n       parm_list = chainon (parm_decl, parm_list);\n     }\n \n@@ -388,7 +378,7 @@ tree_code_create_function_initial (tree prev_saved,\n   make_decl_rtl (fn_decl, NULL);\n \n   /* Use filename/lineno from above.  */\n-  init_function_start (fn_decl, filename, lineno);\n+  init_function_start (fn_decl, loc.file, loc.line);\n \n   /* Create rtl for startup code of function, such as saving registers.  */\n \n@@ -434,20 +424,19 @@ tree_code_create_function_initial (tree prev_saved,\n \n   expand_start_bindings (0);\n \n-  emit_line_note (filename, lineno); /* Output the line number information.  */\n+  emit_line_note (loc.file, loc.line); /* Output the line number information.  */\n }\n \n /* Wrapup a function contained in file FILENAME, ending at line LINENO.  */\n void\n-tree_code_create_function_wrapup (const char* filename,\n-                                 int lineno)\n+tree_code_create_function_wrapup (location_t loc)\n {\n   tree block;\n   tree fn_decl;\n \n   fn_decl = current_function_decl;\n \n-  emit_line_note (filename, lineno); /* Output the line number information.  */\n+  emit_line_note (loc.file, loc.line); /* Output the line number information.  */\n \n   /* Get completely built level from debugger symbol table.  */\n \n@@ -459,7 +448,7 @@ tree_code_create_function_wrapup (const char* filename,\n \n   /* Emit rtl for end of function.  */\n \n-  expand_function_end (filename, lineno, 0);\n+  expand_function_end (loc.file, loc.line, 0);\n \n   /* Pop the level.  */\n \n@@ -493,12 +482,11 @@ tree_code_create_function_wrapup (const char* filename,\n \n tree\n tree_code_create_variable (unsigned int storage_class,\n-                               unsigned char* chars,\n-                               unsigned int length,\n-                               unsigned int expression_type,\n-                               tree init,\n-                               const char* filename,\n-                               int lineno)\n+\t\t\t   unsigned char* chars,\n+\t\t\t   unsigned int length,\n+\t\t\t   unsigned int expression_type,\n+\t\t\t   tree init,\n+\t\t\t   location_t loc)\n {\n   tree var_type;\n   tree var_id;\n@@ -530,8 +518,7 @@ tree_code_create_variable (unsigned int storage_class,\n \n   DECL_CONTEXT (var_decl) = current_function_decl;\n \n-  DECL_SOURCE_FILE (var_decl) = filename;\n-  DECL_SOURCE_LINE (var_decl) = lineno;\n+  DECL_SOURCE_LOCATION (var_decl) = loc;\n \n   /* Set the storage mode and whether only visible in the same file.  */\n   switch (storage_class)\n@@ -612,10 +599,10 @@ tree_code_generate_return (tree type, tree exp)\n \n void\n tree_code_output_expression_statement (tree code,\n-                                       const char* filename, int lineno)\n+                                       location_t loc)\n {\n   /* Output the line number information.  */\n-  emit_line_note (filename, lineno);\n+  emit_line_note (loc.file, loc.line);\n   TREE_USED (code) = 1;\n   TREE_SIDE_EFFECTS (code) = 1;\n   expand_expr_stmt (code);"}, {"sha": "f2d6e30957fd425f6faa90f2d09317957fc83bb7", "filename": "gcc/treelang/treetree.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreetree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3960284ce035ac43af2525f8ee3fed15ab9b3/gcc%2Ftreelang%2Ftreetree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.h?ref=c2e3960284ce035ac43af2525f8ee3fed15ab9b3", "patch": "@@ -39,27 +39,26 @@ void tree_ggc_storage_always_used  (void *m);\n tree tree_code_get_expression (unsigned int exp_type, tree type, tree op1, tree op2, tree op3);\n tree tree_code_get_numeric_type (unsigned int size1, unsigned int sign1);\n void tree_code_create_function_initial (tree prev_saved,\n-                                       const char* filename, int lineno,\n-                                       struct prod_token_parm_item* parms);\n-void tree_code_create_function_wrapup (const char* filename, int lineno);\n+\t\t\t\t\tlocation_t loc,\n+\t\t\t\t\tstruct prod_token_parm_item* parms);\n+void tree_code_create_function_wrapup (location_t loc);\n tree tree_code_create_function_prototype (unsigned char* chars,\n-                                         unsigned int storage_class,\n-                                         unsigned int ret_type,\n-                                         struct prod_token_parm_item* parms,                                 \n-                                         const char* filename,\n-                                         int lineno);\n+\t\t\t\t\t  unsigned int storage_class,\n+\t\t\t\t\t  unsigned int ret_type,\n+\t\t\t\t\t  struct prod_token_parm_item* parms,                                 \n+                                         location_t loc);\n tree tree_code_create_variable (unsigned int storage_class,\n-                               unsigned char* chars,\n-                               unsigned int length,\n-                               unsigned int expression_type,\n-                               tree init,\n-                               const char* filename,\n-                               int lineno);\n-void tree_code_output_expression_statement (tree code, const char* filename, int lineno);\n+\t\t\t\tunsigned char* chars,\n+\t\t\t\tunsigned int length,\n+\t\t\t\tunsigned int expression_type,\n+\t\t\t\ttree init,\n+\t\t\t\tlocation_t loc);\n+void tree_code_output_expression_statement (tree code,\n+\t\t\t\t\t    location_t loc);\n tree get_type_for_numeric_type (unsigned int numeric_type);\n-void tree_code_if_start (tree exp, const char* filename, int lineno);\n-void tree_code_if_else (const char* filename, int lineno);\n-void tree_code_if_end (const char* filename, int lineno);\n+void tree_code_if_start (tree exp, location_t loc);\n+void tree_code_if_else (location_t loc);\n+void tree_code_if_end (location_t loc);\n tree tree_code_get_type (int type_num);\n void treelang_init_decl_processing (void);\n void treelang_finish (void);"}]}