{"sha": "87022a6b0e909befbd0cf98339cd65eede6060f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcwMjJhNmIwZTkwOWJlZmJkMGNmOTgzMzljZDY1ZWVkZTYwNjBmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-09T12:20:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-09T12:20:40Z"}, "message": "basic-block.h (guess_outgoing_edge_probabilities): Declare.\n\n\n\t* basic-block.h (guess_outgoing_edge_probabilities): Declare.\n\t* cfgbuild.c (compute_outgoing_frequencies): When probability is missing,\n\tguess it.\n\t(find_many_sub_basic_blocks): Do update profile only when it is present.\n\t* predict.c (set_even_probabilities): Break out from ...\n\t(combine_predictions_for_insn): ... here; deal with !can_predict_insn_p insns.\n\t(combine_predictions_for_bb): Use set_even_probabilities.\n\t(bb_estimate_probability_locally): Break out from ....\n\t(estimate_probability): ... here.\n\t(guess_outgoing_edge_probabilities): New entry point.\n\nFrom-SVN: r87234", "tree": {"sha": "d0a7e707ffda1026a1023f45c18e9c7f465037ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0a7e707ffda1026a1023f45c18e9c7f465037ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87022a6b0e909befbd0cf98339cd65eede6060f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87022a6b0e909befbd0cf98339cd65eede6060f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87022a6b0e909befbd0cf98339cd65eede6060f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87022a6b0e909befbd0cf98339cd65eede6060f3/comments", "author": null, "committer": null, "parents": [{"sha": "3b5edfeecb64767d26a9cff4b99abe720746ce45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5edfeecb64767d26a9cff4b99abe720746ce45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5edfeecb64767d26a9cff4b99abe720746ce45"}], "stats": {"total": 321, "additions": 194, "deletions": 127}, "files": [{"sha": "e7ad26d087d65aec4069df9ab1a340b8545b2163", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87022a6b0e909befbd0cf98339cd65eede6060f3", "patch": "@@ -1,3 +1,16 @@\n+2004-09-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (guess_outgoing_edge_probabilities): Declare.\n+\t* cfgbuild.c (compute_outgoing_frequencies): When probability is missing,\n+\tguess it.\n+\t(find_many_sub_basic_blocks): Do update profile only when it is present.\n+\t* predict.c (set_even_probabilities): Break out from ...\n+\t(combine_predictions_for_insn): ... here; deal with !can_predict_insn_p insns.\n+\t(combine_predictions_for_bb): Use set_even_probabilities.\n+\t(bb_estimate_probability_locally): Break out from ....\n+\t(estimate_probability): ... here.\n+\t(guess_outgoing_edge_probabilities): New entry point.\n+\n 2004-09-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcc.c (add_sysrooted_prefix, execute, do_self_spec, do_spec_1,"}, {"sha": "34c58d91d855d0bae285ab2aac709b4eb31588a8", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=87022a6b0e909befbd0cf98339cd65eede6060f3", "patch": "@@ -622,6 +622,7 @@ extern bool rtl_predicted_by_p (basic_block, enum br_predictor);\n extern void tree_predict_edge (edge, enum br_predictor, int);\n extern void rtl_predict_edge (edge, enum br_predictor, int);\n extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n+extern void guess_outgoing_edge_probabilities (basic_block);\n \n /* In flow.c */\n extern void init_flow (void);"}, {"sha": "453e65cf49537e0ae162fe61ba3ee51fdcd815b8", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=87022a6b0e909befbd0cf98339cd65eede6060f3", "patch": "@@ -646,25 +646,32 @@ compute_outgoing_frequencies (basic_block b)\n       rtx note = find_reg_note (BB_END (b), REG_BR_PROB, NULL);\n       int probability;\n \n-      if (!note)\n-\treturn;\n-\n-      probability = INTVAL (XEXP (note, 0));\n-      e = BRANCH_EDGE (b);\n-      e->probability = probability;\n-      e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n-\t\t  / REG_BR_PROB_BASE);\n-      f = FALLTHRU_EDGE (b);\n-      f->probability = REG_BR_PROB_BASE - probability;\n-      f->count = b->count - e->count;\n+      if (note)\n+\t{\n+\t  probability = INTVAL (XEXP (note, 0));\n+\t  e = BRANCH_EDGE (b);\n+\t  e->probability = probability;\n+\t  e->count = ((b->count * probability + REG_BR_PROB_BASE / 2)\n+\t\t      / REG_BR_PROB_BASE);\n+\t  f = FALLTHRU_EDGE (b);\n+\t  f->probability = REG_BR_PROB_BASE - probability;\n+\t  f->count = b->count - e->count;\n+\t  return;\n+\t}\n     }\n \n   if (b->succ && !b->succ->succ_next)\n     {\n       e = b->succ;\n       e->probability = REG_BR_PROB_BASE;\n       e->count = b->count;\n+      return;\n     }\n+  guess_outgoing_edge_probabilities (b);\n+  if (b->count)\n+    for (e = b->succ; e; e = e->succ_next)\n+      e->count = ((b->count * e->probability + REG_BR_PROB_BASE / 2)\n+\t\t  / REG_BR_PROB_BASE);\n }\n \n /* Assume that someone emitted code with control flow instructions to the\n@@ -698,25 +705,26 @@ find_many_sub_basic_blocks (sbitmap blocks)\n \n   /* Update branch probabilities.  Expect only (un)conditional jumps\n      to be created with only the forward edges.  */\n-  FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n-    {\n-      edge e;\n-\n-      if (STATE (bb) == BLOCK_ORIGINAL)\n-\tcontinue;\n-      if (STATE (bb) == BLOCK_NEW)\n-\t{\n-\t  bb->count = 0;\n-\t  bb->frequency = 0;\n-\t  for (e = bb->pred; e; e = e->pred_next)\n-\t    {\n-\t      bb->count += e->count;\n-\t      bb->frequency += EDGE_FREQUENCY (e);\n-\t    }\n-\t}\n+  if (profile_status != PROFILE_ABSENT)\n+    FOR_BB_BETWEEN (bb, min, max->next_bb, next_bb)\n+      {\n+\tedge e;\n+\n+\tif (STATE (bb) == BLOCK_ORIGINAL)\n+\t  continue;\n+\tif (STATE (bb) == BLOCK_NEW)\n+\t  {\n+\t    bb->count = 0;\n+\t    bb->frequency = 0;\n+\t    for (e = bb->pred; e; e = e->pred_next)\n+\t      {\n+\t\tbb->count += e->count;\n+\t\tbb->frequency += EDGE_FREQUENCY (e);\n+\t      }\n+\t  }\n \n-      compute_outgoing_frequencies (bb);\n-    }\n+\tcompute_outgoing_frequencies (bb);\n+      }\n \n   FOR_EACH_BB (bb)\n     SET_STATE (bb, 0);"}, {"sha": "99dac1c138651073ded5fcf1462b8ddb752db14d", "filename": "gcc/predict.c", "status": "modified", "additions": 143, "deletions": 98, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87022a6b0e909befbd0cf98339cd65eede6060f3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=87022a6b0e909befbd0cf98339cd65eede6060f3", "patch": "@@ -313,14 +313,32 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n   fprintf (file, \"\\n\");\n }\n \n+/* We can not predict the probabilities of ougtoing edges of bb.  Set them\n+   evenly and hope for the best.  */\n+static void\n+set_even_probabilities (basic_block bb)\n+{\n+  int nedges = 0;\n+  edge e;\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+      nedges ++;\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n+      e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n+    else\n+      e->probability = 0;\n+}\n+\n /* Combine all REG_BR_PRED notes into single probability and attach REG_BR_PROB\n    note if not already present.  Remove now useless REG_BR_PRED notes.  */\n \n static void\n combine_predictions_for_insn (rtx insn, basic_block bb)\n {\n-  rtx prob_note = find_reg_note (insn, REG_BR_PROB, 0);\n-  rtx *pnote = &REG_NOTES (insn);\n+  rtx prob_note;\n+  rtx *pnote;\n   rtx note;\n   int best_probability = PROB_EVEN;\n   int best_predictor = END_PREDICTORS;\n@@ -329,6 +347,14 @@ combine_predictions_for_insn (rtx insn, basic_block bb)\n   bool first_match = false;\n   bool found = false;\n \n+  if (!can_predict_insn_p (insn))\n+    {\n+      set_even_probabilities (bb);\n+      return;\n+    }\n+\n+  prob_note = find_reg_note (insn, REG_BR_PROB, 0);\n+  pnote = &REG_NOTES (insn);\n   if (dump_file)\n     fprintf (dump_file, \"Predictions for insn %i bb %i\\n\", INSN_UID (insn),\n \t     bb->index);\n@@ -446,11 +472,8 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n      this later.  */\n   if (nedges != 2)\n     {\n-      for (e = bb->succ; e; e = e->succ_next)\n-\tif (!(e->flags & (EDGE_EH | EDGE_FAKE)))\n-\t  e->probability = (REG_BR_PROB_BASE + nedges / 2) / nedges;\n-\telse\n-\t  e->probability = 0;\n+      if (!bb->count)\n+\tset_even_probabilities (bb);\n       bb_ann (bb)->predictions = NULL;\n       if (file)\n \tfprintf (file, \"%i edges in bb %i predicted to even probabilities\\n\",\n@@ -521,8 +544,11 @@ combine_predictions_for_bb (FILE *file, basic_block bb)\n     }\n   bb_ann (bb)->predictions = NULL;\n \n-  first->probability = combined_probability;\n-  second->probability = REG_BR_PROB_BASE - combined_probability;\n+  if (!bb->count)\n+    {\n+      first->probability = combined_probability;\n+      second->probability = REG_BR_PROB_BASE - combined_probability;\n+    }\n }\n \n /* Predict edge probabilities by exploiting loop structure.\n@@ -615,6 +641,105 @@ predict_loops (struct loops *loops_info, bool simpleloops)\n     }\n }\n \n+/* Attempt to predict probabilities of BB outgoing edges using local\n+   properties.  */\n+static void\n+bb_estimate_probability_locally (basic_block bb)\n+{\n+  rtx last_insn = BB_END (bb);\n+  rtx cond;\n+\n+  if (! can_predict_insn_p (last_insn))\n+    return;\n+  cond = get_condition (last_insn, NULL, false, false);\n+  if (! cond)\n+    return;\n+\n+  /* Try \"pointer heuristic.\"\n+     A comparison ptr == 0 is predicted as false.\n+     Similarly, a comparison ptr1 == ptr2 is predicted as false.  */\n+  if (COMPARISON_P (cond)\n+      && ((REG_P (XEXP (cond, 0)) && REG_POINTER (XEXP (cond, 0)))\n+\t  || (REG_P (XEXP (cond, 1)) && REG_POINTER (XEXP (cond, 1)))))\n+    {\n+      if (GET_CODE (cond) == EQ)\n+\tpredict_insn_def (last_insn, PRED_POINTER, NOT_TAKEN);\n+      else if (GET_CODE (cond) == NE)\n+\tpredict_insn_def (last_insn, PRED_POINTER, TAKEN);\n+    }\n+  else\n+\n+  /* Try \"opcode heuristic.\"\n+     EQ tests are usually false and NE tests are usually true. Also,\n+     most quantities are positive, so we can make the appropriate guesses\n+     about signed comparisons against zero.  */\n+    switch (GET_CODE (cond))\n+      {\n+      case CONST_INT:\n+\t/* Unconditional branch.  */\n+\tpredict_insn_def (last_insn, PRED_UNCONDITIONAL,\n+\t\t\t  cond == const0_rtx ? NOT_TAKEN : TAKEN);\n+\tbreak;\n+\n+      case EQ:\n+      case UNEQ:\n+\t/* Floating point comparisons appears to behave in a very\n+\t   unpredictable way because of special role of = tests in\n+\t   FP code.  */\n+\tif (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n+\t  ;\n+\t/* Comparisons with 0 are often used for booleans and there is\n+\t   nothing useful to predict about them.  */\n+\telse if (XEXP (cond, 1) == const0_rtx\n+\t\t || XEXP (cond, 0) == const0_rtx)\n+\t  ;\n+\telse\n+\t  predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, NOT_TAKEN);\n+\tbreak;\n+\n+      case NE:\n+      case LTGT:\n+\t/* Floating point comparisons appears to behave in a very\n+\t   unpredictable way because of special role of = tests in\n+\t   FP code.  */\n+\tif (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n+\t  ;\n+\t/* Comparisons with 0 are often used for booleans and there is\n+\t   nothing useful to predict about them.  */\n+\telse if (XEXP (cond, 1) == const0_rtx\n+\t\t || XEXP (cond, 0) == const0_rtx)\n+\t  ;\n+\telse\n+\t  predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, TAKEN);\n+\tbreak;\n+\n+      case ORDERED:\n+\tpredict_insn_def (last_insn, PRED_FPOPCODE, TAKEN);\n+\tbreak;\n+\n+      case UNORDERED:\n+\tpredict_insn_def (last_insn, PRED_FPOPCODE, NOT_TAKEN);\n+\tbreak;\n+\n+      case LE:\n+      case LT:\n+\tif (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n+\t    || XEXP (cond, 1) == constm1_rtx)\n+\t  predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, NOT_TAKEN);\n+\tbreak;\n+\n+      case GE:\n+      case GT:\n+\tif (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n+\t    || XEXP (cond, 1) == constm1_rtx)\n+\t  predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, TAKEN);\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n+}\n+\n /* Statically estimate the probability that a branch will be taken and produce\n    estimated profile.  When profile feedback is present never executed portions\n    of function gets estimated.  */\n@@ -636,7 +761,6 @@ estimate_probability (struct loops *loops_info)\n   FOR_EACH_BB (bb)\n     {\n       rtx last_insn = BB_END (bb);\n-      rtx cond;\n       edge e;\n \n       if (! can_predict_insn_p (last_insn))\n@@ -680,94 +804,7 @@ estimate_probability (struct loops *loops_info)\n \t\t  }\n \t    }\n \t}\n-\n-      cond = get_condition (last_insn, NULL, false, false);\n-      if (! cond)\n-\tcontinue;\n-\n-      /* Try \"pointer heuristic.\"\n-\t A comparison ptr == 0 is predicted as false.\n-\t Similarly, a comparison ptr1 == ptr2 is predicted as false.  */\n-      if (COMPARISON_P (cond)\n-\t  && ((REG_P (XEXP (cond, 0)) && REG_POINTER (XEXP (cond, 0)))\n-\t      || (REG_P (XEXP (cond, 1)) && REG_POINTER (XEXP (cond, 1)))))\n-\t{\n-\t  if (GET_CODE (cond) == EQ)\n-\t    predict_insn_def (last_insn, PRED_POINTER, NOT_TAKEN);\n-\t  else if (GET_CODE (cond) == NE)\n-\t    predict_insn_def (last_insn, PRED_POINTER, TAKEN);\n-\t}\n-      else\n-\n-      /* Try \"opcode heuristic.\"\n-\t EQ tests are usually false and NE tests are usually true. Also,\n-\t most quantities are positive, so we can make the appropriate guesses\n-\t about signed comparisons against zero.  */\n-\tswitch (GET_CODE (cond))\n-\t  {\n-\t  case CONST_INT:\n-\t    /* Unconditional branch.  */\n-\t    predict_insn_def (last_insn, PRED_UNCONDITIONAL,\n-\t\t\t      cond == const0_rtx ? NOT_TAKEN : TAKEN);\n-\t    break;\n-\n-\t  case EQ:\n-\t  case UNEQ:\n-\t    /* Floating point comparisons appears to behave in a very\n-\t       unpredictable way because of special role of = tests in\n-\t       FP code.  */\n-\t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n-\t      ;\n-\t    /* Comparisons with 0 are often used for booleans and there is\n-\t       nothing useful to predict about them.  */\n-\t    else if (XEXP (cond, 1) == const0_rtx\n-\t\t     || XEXP (cond, 0) == const0_rtx)\n-\t      ;\n-\t    else\n-\t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, NOT_TAKEN);\n-\t    break;\n-\n-\t  case NE:\n-\t  case LTGT:\n-\t    /* Floating point comparisons appears to behave in a very\n-\t       unpredictable way because of special role of = tests in\n-\t       FP code.  */\n-\t    if (FLOAT_MODE_P (GET_MODE (XEXP (cond, 0))))\n-\t      ;\n-\t    /* Comparisons with 0 are often used for booleans and there is\n-\t       nothing useful to predict about them.  */\n-\t    else if (XEXP (cond, 1) == const0_rtx\n-\t\t     || XEXP (cond, 0) == const0_rtx)\n-\t      ;\n-\t    else\n-\t      predict_insn_def (last_insn, PRED_OPCODE_NONEQUAL, TAKEN);\n-\t    break;\n-\n-\t  case ORDERED:\n-\t    predict_insn_def (last_insn, PRED_FPOPCODE, TAKEN);\n-\t    break;\n-\n-\t  case UNORDERED:\n-\t    predict_insn_def (last_insn, PRED_FPOPCODE, NOT_TAKEN);\n-\t    break;\n-\n-\t  case LE:\n-\t  case LT:\n-\t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n-\t\t|| XEXP (cond, 1) == constm1_rtx)\n-\t      predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, NOT_TAKEN);\n-\t    break;\n-\n-\t  case GE:\n-\t  case GT:\n-\t    if (XEXP (cond, 1) == const0_rtx || XEXP (cond, 1) == const1_rtx\n-\t\t|| XEXP (cond, 1) == constm1_rtx)\n-\t      predict_insn_def (last_insn, PRED_OPCODE_POSITIVE, TAKEN);\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n+      bb_estimate_probability_locally (bb);\n     }\n \n   /* Attach the combined probability to each conditional jump.  */\n@@ -808,6 +845,14 @@ estimate_probability (struct loops *loops_info)\n   if (profile_status == PROFILE_ABSENT)\n     profile_status = PROFILE_GUESSED;\n }\n+\n+/* Set edge->probability for each succestor edge of BB.  */\n+void\n+guess_outgoing_edge_probabilities (basic_block bb)\n+{\n+  bb_estimate_probability_locally (bb);\n+  combine_predictions_for_insn (BB_END (bb), bb);\n+}\n \f\n \n /* Predict using opcode of the last statement in basic block.  */"}]}