{"sha": "723dc4421ede9b84ee5a1c45c04b7b019833933e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIzZGM0NDIxZWRlOWI4NGVlNWExYzQ1YzA0YjdiMDE5ODMzOTMzZQ==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-08-26T22:16:57Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-08-26T22:16:57Z"}, "message": "New test\n\nFrom-SVN: r28907", "tree": {"sha": "2fed3dbfd18f9624fe24fef3f2066feec5d498a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fed3dbfd18f9624fe24fef3f2066feec5d498a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/723dc4421ede9b84ee5a1c45c04b7b019833933e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/723dc4421ede9b84ee5a1c45c04b7b019833933e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/723dc4421ede9b84ee5a1c45c04b7b019833933e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/723dc4421ede9b84ee5a1c45c04b7b019833933e/comments", "author": null, "committer": null, "parents": [{"sha": "4ef8e8f542b6d898f59cbddd7f52b98164fa3b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef8e8f542b6d898f59cbddd7f52b98164fa3b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef8e8f542b6d898f59cbddd7f52b98164fa3b9c"}], "stats": {"total": 650, "additions": 650, "deletions": 0}, "files": [{"sha": "3e2daac5e99f50294aaad99e4c70fd7bf79340b5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/723dc4421ede9b84ee5a1c45c04b7b019833933e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/723dc4421ede9b84ee5a1c45c04b7b019833933e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=723dc4421ede9b84ee5a1c45c04b7b019833933e", "patch": "@@ -1,5 +1,7 @@\n 1999-08-26  Craig Burley  <craig@jcb-sc.com>\n \n+\t* g77.f-torture/noncompile/19990826-4.f: New test.\n+\n \t* g77.f-torture/compile/19990826-3.f: New test.\n \n \t* g77.f-torture/execute/19990826-2.f: New test."}, {"sha": "c8a01ce4de056533d10cceb194cbc805a37f06c5", "filename": "gcc/testsuite/g77.f-torture/noncompile/19990826-4.f", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/723dc4421ede9b84ee5a1c45c04b7b019833933e/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/723dc4421ede9b84ee5a1c45c04b7b019833933e/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fnoncompile%2F19990826-4.f?ref=723dc4421ede9b84ee5a1c45c04b7b019833933e", "patch": "@@ -0,0 +1,648 @@\n+* Date: Mon, 26 May 1997 13:00:19 +0200 (GMT+0200)\n+* From: \"D. O'Donoghue\" <dod@da.saao.ac.za>\n+* To: Craig Burley <burley@gnu.ai.mit.edu>\n+* Cc: fortran@gnu.ai.mit.edu\n+* Subject: Re: g77 problems\n+\n+* Culled from 970528-1.f in Burley's g77 test suite.  Copyright\n+* status not clear.  Feel free to chop down if the bug is still\n+* reproducible (see end of test case for how bug shows up in gdb\n+* run of f771).  No particular reason it should be a noncompile\n+* case, other than that I didn't want to spend time \"fixing\" it\n+* to compile cleanly (with -O0, which works) while making sure the\n+* ICE remained reproducible.  -- burley 1999-08-26\n+\n+\tprogram dophot\n+\tparameter (napple = 4)\n+        common /window/nwindo,ixwin(50),iywin(50),iboxwin(50),itype(50)\n+        common/io/luout,ludebg\n+\tcommon/search/nstot,thresh\n+\tcommon /fitparms / acc(npmax),alim(npmax),mit,mpar,mfit1,\n+     +                     mfit2,ind(npmax)\n+\tcommon /starlist/ starpar(npmax,nsmax), imtype(nsmax),\n+\t1shadow(npmax,nsmax),shaderr(npmax,nsmax),idstr(nsmax)\n+\tcommon /aperlist/ apple(napple ,nsmax)\n+\tcommon /parpred / ava(npmax)\n+\tcommon /unitize / ufactor\n+\tcommon /undergnd/ nfast, nslow\n+\tcommon/bzero/ scale,zero\n+\tcommon /ctimes / chiimp, apertime, filltime, addtime\n+\tcommon / drfake / needit \n+\tcommon /mfit/ psfpar(npmax),starx(nfmax),stary(nfmax),xlim,ylim\n+\tcommon /vers/ version\n+ \tlogical needit,screen,isub,loop,comd,burn,wrtres,fixedxy\n+\tlogical fixed,piped,debug,ex,clinfo\n+\tcharacter header*5760,rhead*2880\n+\tcharacter yn*1,version*40,ccd*4,infile*20\n+\tcharacter*30 numf,odir,record*80\n+\tinteger*2 instr(8)\n+\tcharacter*800 line\n+\texternal pseud0d, pseud2d, pseud4d, pseudmd, shape\n+C\n+C\tInitialization\n+\tdata burn,   fixedxy,fixed,  piped \n+     +     /.false.,.false.,.false.,.false./\n+\tdata needit,screen,comd,isub\n+     + /.true.,.false.,.true.,.false. /\n+\tdata acc / .01, -.03, -.03, .01, .03, .1, .03 /\n+\tdata alim / -1.0e8, 2*-1.0e3, -1.0e8, 3*-1.0e3 /\n+C\n+\tversion = 'DoPHOT Version 1.0 LINUX May 97 '\n+        debug=.false.\n+        clinfo=.false.\n+\tline(1:800) = ' '\n+\todir = ' '\n+C\n+C\n+C\tRead default tuneable parameters \n+\tcall tuneup ( nccd, ccd, piped, debug )\n+\tversion(33:36) = ccd(1:4)\n+C\n+      \n+        ludebg=6\n+        if(piped)then\n+          yn='n'\n+        else\n+\t  write(*,'(''****************************************'')')\n+\t  write(*,1000) version\n+\t  write(*,'(''****************************************''//)')           \n+C                                                             \n+          write(*,'(''Screen output (y/[n])? '',$)')             \n+\t  read(*,1000) yn\n+        end if\n+\tif(yn.eq.'y'.or.yn.eq.'Y') then\n+          screen=.true.                \n+          luout=6\n+        else\n+          luout=2\n+        end if\n+C\n+        if(piped)then\n+          yn='y'\n+        else\n+          write(*,'(''Batch mode ([y]/n)? '',$)')\n+          read(*,1000) yn\n+        end if\n+\tif(yn.eq.'n'.or.yn.eq.'N') comd = .false.\n+C                                          \n+\tif(.not.comd) then                                     \n+          write(*,\n+     *         '(''Do you want windowing ([y]/n)? '',$)')\n+          read(*,1000)yn\n+          iwindo=1\n+          if(yn.eq.'n'.or.yn.eq.'N')then\n+            nwindo=0\n+            iwindo=0\n+          end if\n+C\n+          write(*,\n+     *       '(''Star classification info (y/[n]) ?'',$)')\n+          read(*,1000)yn\n+          clinfo=.false.\n+          if(yn.eq.'y'.or.yn.eq.'Y')clinfo=.true.\n+C\n+\t  write(*,\n+     *        '(''Create a star-subtracted frame (y/[n])? '',$)')\n+\t  read(*,1000) yn                                     \n+ \t  if(yn.eq.'y'.or.yn.eq.'Y') isub = .true.\n+C               \n+\t  write(*,'(''Apply after-burner (y/[n])? '',$)')\n+\t  read(*,1000) yn\n+\t  if ( yn.eq.'y'.or.yn.eq.'Y' ) burn = .true.\n+\t  wrtres = burn\n+C\n+\t  write(*,'(''Read from fixed (X,Y) list (y/[n])? '',$)')\n+\t  read(*,1000) yn\n+\t  if ( yn.eq.'y'.or.yn.eq.'Y' ) then\n+\t    fixedxy = .true.\n+\t    fixed = .true.\n+\t    burn = .true.\n+\t    wrtres = .true.\n+\t  endif\n+\tendif         \n+        iopen=0\n+C\n+C       This is the start of the loop over the input files\n+c\n+        iframe=0\n+        open(10,file='timing',status='unknown',access='append')\n+\n+1\tifit = 0\n+\tiapr = 0\n+\titmn = 0\n+\tmodel = 1\n+\txc = 0.0\n+\tyc = 0.0\n+\trc = 0.0\n+\tibr = 0\n+\tixy = 0\n+C\t\n+        iframe=iframe+1\n+        tgetpar=0.0\n+        tsearch=0.0\n+        tshape=0.0\n+        timprove=0.0\n+C\n+C\tBatch mode ...\n+\n+\tif ( comd ) then\n+          if(iopen.eq.0)then\n+            iopen=1\n+            open(11,file='dophot.bat',status='old',err=995)\n+          end if\n+          read(11,1000,end=999)infile\n+c         now read in the parameter instructions. these are:\n+c         instr(1) : if 1, specifies uncrowded field, otherwise crowded \n+c         instr(2) : if 1, specifies sequential frames of same field\n+c                          with a window around the stars of interest -\n+c                          all other objects are ignored\n+c         instr(3) : if 0, takes cmin from dophot.inp (via tuneup)\n+c                    if>0, sets cmin=instr(3)\n+c         instr(4) : if 0, does nothing\n+c                    if 1, then opens a file called classifications\n+c                    sets clinfo to .true. and writes out the star\n+c                    typing info to this file\n+c         instr(5) : Delete the shd.nnnnnnn file\n+c         instr(6) : Delete the out.nnnnnnn file\n+c         instr(7) : Delete the input frame\n+c         instr(8) : Create a star-subtracted frame \n+          read(11,*)instr\n+          read(11,*)ifit,iapr,tmn,model,xc,yc,rc,ibr,ixy\n+          nocrwd = instr(1)\n+          iwindo=instr(2)\n+          if(iwindo.eq.0)nwindo=0\n+          itmn=tmn\n+          if ( instr(3).gt.0 ) cmin=instr(3)\n+          clinfo=.false.\n+          if ( instr(4).gt.0 )then\n+            clinfo=.true.\n+            open(12,file='classifications',status='unknown')\n+            ludebg=12\n+          end if\n+ \t  if ( instr(8).ne.0 ) then\n+\t    isub = .true.            \n+\t  else\n+\t    isub = .false.\n+\t  endif\n+C\n+\t  if(ibr.ne.0) burn = .true.\n+\t  if(ixy.ne.0) then\n+\t    fixedxy = .true.\n+\t    fixed = .true.\n+\t    burn = .true.\n+\t    goto 20\n+          endif\n+          if(iwindo.eq.0)then\n+            write(6,10)iframe,infile(1:15)\n+   10       format('  ***** DoPHOT-ing frame ',i4,': ',a)\n+            if(ludebg.eq.12)write(ludebg,11)iframe,infile(1:15)\n+   11       format(////'  ',62('*')/\n+     *                 '  *     DoPHOT-ing frame ',i4,': ',a,\n+     *                 '                 *'/'  ',62('*'))\n+          end if\n+          if(iwindo.eq.1)then\n+            write(6,12)iframe,infile(1:15)\n+   12       format('  ***** DoPHOT-ing frame ',i4,': ',a,\n+     *             '   - Windowed *****')\n+            if(ludebg.eq.12)write(ludebg,13)iframe,infile(1:15)\n+   13       format(////'  ',62('*')/\n+     *                 '  *     DoPHOT-ing frame ',i4,': ',a,\n+     *                 '   - Windowed    *'/2x,62('*'))\n+          end if\n+C\n+C\tInteractive...\n+\telse\n+\t  write(*,'(''Image name: '',$)')\n+\t  read(*,1000) infile\n+\t  if(infile(1:1).eq.' ') goto 999                     \n+1000\t  format(a)                          \n+          write(*,'(''Crowded field mode ([y]/n) ? '',$)')\n+          read(*,1000)yn\n+          nocrwd=0\n+          if(yn.eq.'n'.or.yn.eq.'N')nocrwd=1\n+\t  if(.not.fixed) then\n+\t    write(*,1001)\n+1001        format('Sky model ([1]=Plane, 2=Power, 3=Hubble)? ',$)\n+            read(*,1000)record\n+            if(record.ne.' ')then\n+\t      read(record,*) model\n+            else\n+              model=1\n+            end if\n+\t  else         \n+\t    burn=.true.\n+\t    goto 20           \n+\t  endif\n+\tendif\n+C\n+C       if windowing, open the file and read the window\n+        if(iwindo.eq.1)then\n+          inquire(file='windows',exist=ex)\n+          if(.not.ex)go to 997\n+          if(iframe.eq.1)open(9,file='windows',status='old')\n+          nwindo=0\n+    2     read(9,*,end=3)intype,inx,iny,inbox\n+          nwindo=nwindo+1\n+          if(nwindo.gt.50)then\n+            print *,'too many windows - max = 50'\n+            stop\n+          end if\n+          ixwin(nwindo)=inx\n+          iywin(nwindo)=iny\n+          iboxwin(nwindo)=inbox\n+          itype(nwindo)=intype\n+          go to 2\n+\n+    3     rewind 9\n+          if(screen)print 4,(itype(j),ixwin(j),iywin(j),iboxwin(j),\n+     *                       j=1,nwindo)\n+    4     format(' Windows: Type   X    Y   Size'/\n+     *           (I13,i6,i5,i5))\n+        end if\n+\n+\tt1 = cputime(0.0)\n+C\n+C\tRead FITS frame.\n+\tcall getfits(1,infile,header,nhead,nfast,nslow,numf,nc,line,ccd)\n+C\n+C\tIgnore frame if not the correct chip\n+\tif(nc.lt.0) goto 900\n+C                     \n+C\tEstimate starting PSF parameters.\n+   15   call getparams(nfast,nslow,gxwid,gywid,skyval,tmin,tmax,\n+     *                 iframe)\n+        tgetpar = cputime(t1) + tgetpar\n+        if(debug)write(ludebg,16)iframe,skyval,gxwid,gywid,tmin,tmax\n+   16   format(' Getparams on frame ',i4,'  sky ',f6.1,'  gxwid ',f5.1,\n+     *         '  gywid ',f5.1,'  tmin ',f5.1,'  tmax ',f5.1)\n+C\n+C\tInitialize\n+\tdo j=1,nsmax\n+\t  imtype(j) = 0\n+\t  do i=1,npmax  \n+\t    shadow(i,j)=0.                               \n+\t    shaderr(i,j)=0.\n+\t  enddo\n+\tenddo\n+C              \n+\tskyguess=skyval\n+\ttfac = 1.0            \n+C\tUse 4.5 X SD as fitting width       \n+\tfitr=fitfac*(gxwid*asprat*gywid)**0.25 + 0.5                      \n+\ti=fitr\n+\tirect(1)=i\n+\tirect(2)=fitr/asprat \n+C\tUse 4/3 X FitFac X SD as aperture width\n+\tgmax = asprat*gywid\n+ \tif(gxwid.gt.gmax) gmax=gxwid\n+\taprw = 1.33*fitfac*sqrt(gmax) + 0.5\n+\ti = aprw\n+\tarect(1) = i\n+\ti = aprw/asprat + 0.1\n+\tarect(2) = i          \n+C                                     \n+\tif(irect(1).gt.50) irect(1)=50\n+\tif(irect(2).gt.50) irect(2)=50  \n+\tif(arect(1).gt.45.) arect(1)=45.\n+\tif(arect(2).gt.45.) arect(2)=45.\n+C\n+\tif (screen) call htype(line,skyval,.false.,fitr,ngr,ncon)\n+C\n+C       Prompt for further information         \n+\tif ( .not.comd ) then\n+          write(*,1002)\n+ 1002     format(/'The above are the inital parameters DoPHOT'/\n+     *            'has found. You can change them now or accept'/\n+     *            'the values in [ ] by pressing enter'/)\n+\n+          write(*,1004)tmin\n+ 1004     format('Enter Tmin: threshold for star detection',\n+     *           ' [',f5.1,']  ',$)\n+          read(*,1000)record\n+          if(record.ne.' ')read(record,*)tmin\n+\n+          write(*,1005)cmin\n+ 1005     format('Enter Cmin: threshold for PSF stars',\n+     *           '      [',f5.1,']  ',$)\n+          read(*,1000)record\n+          if(record.ne.' ')read(record,*)cmin\n+\n+          write(*,1006)\n+ 1006     format('Do you want to fix the aperture mag size ?',\n+     *           ' (y/[n]) ')\n+          read(*,1000)record\n+          if(record.eq.'y'.or.record.eq.'Y')then\n+            write(*,1007)\n+ 1007       format('Enter the size in pixels: ',$)\n+            read(*,*)iapr\n+ \t    if(iapr.gt.0) then          \n+              arect(1)=iapr\n+              i = iapr/asprat + 0.1\n+              arect(2)=i\n+            end if\n+\t  endif                     \n+C\n+\t  write(*,1008)\n+ 1008     format('Satisfied with other input parameters ? ([y]/n)?',$)\n+\t  read(*,1000) yn        \n+          if(yn.eq.'n'.or.yn.eq.'N')then\n+            yn='n'\n+          else\n+            yn='y'\n+          end if\n+\t  if(.not.(yn.eq.'y'.or.yn.eq.'Y') ) call input\n+\telse\n+\t  if ( ifit.ne.0 ) then\n+\t    irect(1)=ifit\n+\t    irect(2)=(ifit/asprat + 0.1)\n+\t  endif              \n+\t  if ( iapr.ne.0 ) then\n+\t    arect(1)=iapr\n+\t    i = iapr/asprat + 0.1\n+\t    arect(2)=i\n+\t  endif                                       \n+\t  if ( itmn.ne.0 ) tmin = itmn\n+ \t  if ( .not.(xc.eq.0.0.and.yc.eq.0.0) ) then\n+\t    xcen = xc\n+ \t    ycen = yc\n+          endif\n+\tendif          \n+C\n+C--------------------------------\n+C\n+C\n+\tcall setup ( numf,nc,screen,line,skyval,fitr,ngr,ncon,\n+     +nfast, nslow )\n+C\n+C       if the uncrowded field option has been chosen, jump\n+C       straight to the minimum threshold\n+C\n+        if(nocrwd.eq.1)tmax=tmin\n+C             \n+C\tAdjust tfac so that thresh ends precisely on Tmin.\n+\tif(tmin/tmax .gt. 0.999) then\n+\t  thresh = tmin\n+\t  tfac = 1.          \n+\telse                                                     \n+\t  thresh = tmax\n+\t  xnum = alog10(tmax/tmin)/alog10(2.**tfac)\n+\t  if(xnum.gt.1.5) then\n+\t    xnum = float(nint(xnum))\n+\t  else if(xnum.ge.1) then               \n+\t    xnum = 2.0\n+\t  else             \n+\t    xnum = 1.0             \n+\t  endif                                         \n+\t  tfac = alog10(tmax/tmin)/alog10(2.)/xnum                   \n+\tendif\n+C                       \n+C------------------------------------------------------------------------\n+C                            \n+C         This is the BIG LOOP which searches the frame for stars\n+C               with intensities > thresh.                \n+C        \n+C-----------------------------------------------------------------------\n+C                           \n+\tloop = .true.\n+\tnstot = 0\n+\tdo while ( loop )   \n+\t  loop = thresh/tmin .ge. 1.01\n+\t  write(luout,1050) thresh\n+1050\t  format(/20('-')/'THRESHOLD: ', f10.3)\n+\t  if(ludebg.eq.12)write(ludebg,1050) thresh\n+C\n+C         Fit given model to sky values.\n+C\n+          call varipar(nstot, nfast, nslow )            \n+\t  t1 = cputime(0.0)\n+C               \n+C         Identifies potential objects in cleaned array IMG\n+ \t  nstar = isearch( pseud2d, nfast, nslow , clinfo)\n+\t  tsearch = cputime(t1) + tsearch\n+C                                                                   \n+    \t  if ( (nstar .ne. 0).or.(xnum.lt.1.5) ) then\n+C                                           \n+C           Performs 7-parameter PSF fit and determines nature of object.\n+\t    t1 = cputime(0.0)\n+\t    call shape(pseud2d,pseud4d,nfast,nslow,clinfo)\n+\t    tshape = cputime(t1) + tshape\n+C                           \n+C           Computes average sky values etc from star list\n+ \t    call paravg\n+  \t    t1 = cputime(0.0)\n+C                                                          \n+C           Computes 4-parameter fits for all stellar objects using \n+C           new average shape parameters.  \n+  \t    call improve(pseud2d,nfast,nslow,clinfo)\n+\t    timprove = cputime(t1) + timprove\n+\t  end if                         \n+C\n+C         Calculate aperture photometry on last pass.\n+\t  if(.not.loop) call aper ( pseud2d, nstot, nfast, nslow )\n+C             \n+ \t  totaltime = (tgetpar+tsearch+tshape+timprove)\n+\t  write(3,1060) totaltime\n+ \t  write(4,1060) totaltime\n+\t  write(luout,1060) totaltime\n+1060\t  format('Total CPU time consumed:',F10.2,' seconds.')\n+          write(10,1070)infile,tgetpar,tsearch,tshape,timprove,\n+     *                  totaltime\n+1070      format(a20,'   T(getp/f)',f5.1,'  T(search)',f5.1,\n+     *               '  T(shape)',f5.1,'  T(improve)',f5.1,\n+     *               '  Total',f6.1)\n+\t  call title (line,skyval,.false.,fitr,ngr,ncon,strint,ztot,nums)\n+\t  rewind(2)          \n+ \t  rewind(3)                              \n+  \t  rewind(4)\n+C\n+\t  call output ( line )\n+C\n+C         Now reduce the threshold and loop back\n+C\n+\t  thresh = thresh/2.**tfac\n+  \tend do                   \n+C                              \n+C--------- END OF BIG LOOP ---------------------------------------\n+C                      \n+C\tIf after-burner required, residuals from analytic PSF are computed\n+C\tand stored in RES.\n+C\t\n+20\tif ( burn ) then\n+C \t\n+C\tIf using a fixed (X,Y) coordinate list, read it.\n+\t if (fixed) then\n+C\t Read the image frame\n+ \t  call getfits(1,infile,header,nhead,nfast,nslow,numf,nc,line)\n+C\n+C\t Initialize arrays, open files etc.\n+\t  call setup ( numf,nc,screen,line,skyval,fitr,ngr,ncon,\n+     +nfast, nslow )\n+C\n+C\t Read the XY list                                 \n+\t  write(luout,'(''Reading XY list ...'')')\n+\t  call xylist(numf, nc, ios )\n+\t  if(ios.ne.0) then\n+\t   fixed = .false.\n+\t   write(luout,'(''SXY file absent or incorrect...'')')\n+\t   goto 15\n+\t  endif\n+C\n+\t  call htype(line,skyval,.false.,fitr,ngr,ncon)\n+C\n+C\t Remove good stars\n+\t  write(luout,'(''Cleaning frame of stars: '',i8)') nstot\n+\t  call clean ( pseud2d, nstot, nfast, nslow, -1)\n+C             \n+C\tCalculate aperture photometry\n+C\t  call aper ( pseud2d, nstot, nfast, nslow )\n+\t else            \n+\t   rewind(3)\n+\t   rewind(4)         \n+\t endif \n+C             \n+C-----------------------\n+C\tFlag all stars close together in groups.  Keep making the distance\n+C\tcriterion FITR smaller until the maximum number in a group is less\n+C\tthan NFMAX         \n+C                      \n+\t fitr = amax1(arect(1),arect(2))\n+\t fitr = fitr + 2.0      \n+\t nmax = 10000 \n+\t write(*,'(''Regrouping ...'')')\n+C              \n+\t do while ( nmax.gt.nfmax )\n+  \t  fitr = fitr - 1.0       \n+\t  write(luout,'(''Min distance ='',f8.1)') fitr\n+\t  call regroup( fitr, ngr, nmax )     \n+\t enddo\n+C\n+\t xlim = irect(1)/2 \n+\t ylim = irect(2)/2\n+C\n+C\tCalculate normalized PSF residual from PSEUD2D\n+\t call getres (pseud0d,pseud2d,strint,rmn,rmx,nfast,nslow,irect,\n+     +arect,ztot,nums)\n+\t if(nums.eq.0) then\n+\t  write(luout,'(''No suitable PSF stars!'')')\n+\t  goto 30\n+\t endif\n+C\n+\t write(luout,'(/''AFTERBURNER tuned ON!'')')\n+C\n+C\tFit multiple stars in a group with enhanced PSF using box size IRECT.\n+\t call mulfit( pseud2d,pseudmd,ngr,ncon,nfast,nslow,irect )        \n+C\n+C\tRe-calculate aperture photometry\n+\t call aperm ( pseudmd, nstot, nfast, nslow )\n+C\n+\t call skyadj ( nstot )\n+C\n+ \t call title (line,skyval,.true.,fitr,ngr,ncon,strint,ztot,nums)\n+\t call output ( line )\n+\tendif \n+C---------------------                                                \n+C\n+C-----  This section skipped if PSF residual not written out ------\n+C                     \n+30\tif( isub ) then\n+C\n+C\tWrite final Cleaned array.\n+ \t infile = 'x'//numf(1:nc)//'.fits'\n+\t call putfits(2,infile,header,nhead,nfast,nslow)\n+\t close(2)                 \n+C             \n+C\tIf afterburner used, then residual array also written out.\n+C\tFind suitable scale for writing residual PSF to FITS \"R\" file.\n+C\n+ \t if ( wrtres ) then\n+\t  scale=20000.0/(rmx-rmn)\n+\t  zero=-scale*rmn   \n+\t  do j=-nres,nres\n+  \t   jj=nres+j+1   \n+\t   do i=-nres,nres\n+  \t    ii=nres+i+1                                  \n+\t    big(ii,jj)=scale*res(i,j)+zero\n+\t   enddo\n+\t  enddo\n+\t  nx=2*nres+1  \n+C\n+\t  infile = 'r'//numf(1:nc)//'.fits'\n+  \t  zer=-zero/scale\n+ \t  scl=1.0/scale            \n+C                                           \n+C\tCreate a FITS header for the normalized PSF residual image    \n+\t  call sethead(rhead,numf,nx,nx,zer,scl)\n+ \t  scale=1.0             \n+\t  zero=0.0    \n+C\tWrite the normalized PSF residual image\n+\t  call putfits(2,infile,rhead,1,nx,nx)\n+\t  close(2)\n+\t endif\n+C                        \n+\tend if\n+C                     \n+C                     \n+900\tclose(1)\n+\tclose(3)                                 \n+ \tclose(4)\n+\tif ( .not.screen ) close(luout)\n+\tif(comd) then\n+          if(instr(5).eq.1)call system('rm shd.'//numf(1:nc))\n+          if(instr(6).eq.1)call system('rm out.'//numf(1:nc))\n+          n=1\n+          do while(infile(n:n).ne.' ')\n+            n=n+1\n+          end do\n+          if(instr(7).eq.1)call system('rm '//infile(1:n-1))\n+        end if\n+\tfixed = fixedxy\n+\tgoto 1\n+C\n+995     print 996\n+996     format(/'*** Fatal error ***'/\n+     *          'You asked for batch processing but'/\n+     *          'I cant open the \"dophot.bat\" file.'/\n+     *          'Please make one (using batchdophot)'/\n+     *          'and restart DoPHOT'/)\n+        go to 999\n+\n+C\n+997     print 998\n+998     format(/'*** Fatal error ***'/\n+     *          'You asked for \"windowed\" processing'/\n+     *          'but I cant open the \"windows\" file.'/\n+     *          'Please make one and restart DoPHOT'/)\n+\n+999\tcall exit(0)\n+\tend\n+\n+* (gdb) r\n+* Starting program: /home3/craig/gnu/f77-e/gcc/f771 -quiet < ../../play/19990826-4.f -O\n+* [...]\n+* Breakpoint 2, fancy_abort (\n+*     file=0x8285220 \"../../g77-e/gcc/config/i386/i386.c\", line=4399,\n+*     function=0x82860df \"output_fp_cc0_set\") at ../../g77-e/gcc/rtl.c:1010\n+* (gdb) up\n+* #1  0x8222fab in output_fp_cc0_set (insn=0x8382324)\n+*     at ../../g77-e/gcc/config/i386/i386.c:4399\n+* (gdb) p insn\n+* $1 = 0x3a\n+* (gdb) up\n+* #2  0x8222b81 in output_float_compare (insn=0x8382324, operands=0x82acc60)\n+*     at ../../g77-e/gcc/config/i386/i386.c:4205\n+* (gdb) p insn\n+* $2 = 0x8382324\n+* (gdb) whatis insn\n+* type = rtx\n+* (gdb) pr\n+* (insn 2181 2180 2191 (parallel[\n+*             (set (cc0)\n+*                 (compare (reg:SF 8 %st(0))\n+*                     (mem:SF (plus:SI (reg:SI 6 %ebp)\n+*                             (const_int -9948 [0xffffd924])) 0)))\n+*             (clobber (reg:HI 0 %ax))\n+*         ] ) 29 {*cmpsf_cc_1} (insn_list 2173 (insn_list 2173 (nil)))\n+*     (expr_list:REG_DEAD (reg:DF 8 %st(0))\n+*         (expr_list:REG_UNUSED (reg:HI 0 %ax)\n+*             (nil))))\n+* (gdb)"}]}