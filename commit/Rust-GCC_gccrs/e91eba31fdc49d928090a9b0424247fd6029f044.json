{"sha": "e91eba31fdc49d928090a9b0424247fd6029f044", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxZWJhMzFmZGM0OWQ5MjgwOTBhOWIwNDI0MjQ3ZmQ2MDI5ZjA0NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2018-04-20T13:46:07Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2018-04-20T13:46:07Z"}, "message": "[nvptx] Fix calls to vector and worker routines\n\n2018-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/85445\n\t* config/nvptx/nvptx.c (nvptx_emit_forking, nvptx_emit_joining):\n\tEmit insns for calls too.\n\t(nvptx_find_par): Always look for worker-level predecessor insn.\n\t(nvptx_propagate): Add is_call parm, return bool.  Copy frame for\n\tcalls.\n\t(nvptx_vpropagate, nvptx_wpropagate): Adjust.\n\t(nvptx_process_pars): Propagate frames for calls.\n\n\t* testsuite/libgomp.oacc-c++/ref-1.C: New.\n\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r259523", "tree": {"sha": "442311f1f77e1d77058c9d89ab23705cf3760f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/442311f1f77e1d77058c9d89ab23705cf3760f54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e91eba31fdc49d928090a9b0424247fd6029f044", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e91eba31fdc49d928090a9b0424247fd6029f044", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e91eba31fdc49d928090a9b0424247fd6029f044", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e91eba31fdc49d928090a9b0424247fd6029f044/comments", "author": null, "committer": null, "parents": [{"sha": "e95dda951fdf2349d669a6811cdc07f72846e5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95dda951fdf2349d669a6811cdc07f72846e5b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95dda951fdf2349d669a6811cdc07f72846e5b3"}], "stats": {"total": 202, "additions": 156, "deletions": 46}, "files": [{"sha": "7152a1942a7aa66e0cad6c6cdc488aa629e9d152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91eba31fdc49d928090a9b0424247fd6029f044/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91eba31fdc49d928090a9b0424247fd6029f044/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e91eba31fdc49d928090a9b0424247fd6029f044", "patch": "@@ -1,3 +1,15 @@\n+2018-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/85445\n+\t* config/nvptx/nvptx.c (nvptx_emit_forking, nvptx_emit_joining):\n+\tEmit insns for calls too.\n+\t(nvptx_find_par): Always look for worker-level predecessor insn.\n+\t(nvptx_propagate): Add is_call parm, return bool.  Copy frame for\n+\tcalls.\n+\t(nvptx_vpropagate, nvptx_wpropagate): Adjust.\n+\t(nvptx_process_pars): Propagate frames for calls.\n+\n 2018-04-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85469"}, {"sha": "ca3fea3002db2656f8a4fe49370127502282e48b", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91eba31fdc49d928090a9b0424247fd6029f044/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91eba31fdc49d928090a9b0424247fd6029f044/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=e91eba31fdc49d928090a9b0424247fd6029f044", "patch": "@@ -399,8 +399,7 @@ nvptx_emit_forking (unsigned mask, bool is_call)\n \t it creates a block with a single successor before entering a\n \t partitooned region.  That is a good candidate for the end of\n \t an SESE region.  */\n-      if (!is_call)\n-\temit_insn (gen_nvptx_fork (op));\n+      emit_insn (gen_nvptx_fork (op));\n       emit_insn (gen_nvptx_forked (op));\n     }\n }\n@@ -419,8 +418,7 @@ nvptx_emit_joining (unsigned mask, bool is_call)\n       /* Emit joining for all non-call pars to ensure there's a single\n \t predecessor for the block the join insn ends up in.  This is\n \t needed for skipping entire loops.  */\n-      if (!is_call)\n-\temit_insn (gen_nvptx_joining (op));\n+      emit_insn (gen_nvptx_joining (op));\n       emit_insn (gen_nvptx_join (op));\n     }\n }\n@@ -3086,8 +3084,7 @@ nvptx_find_par (bb_insn_map_t *map, parallel *par, basic_block block)\n \t    par = new parallel (par, mask);\n \t    par->forked_block = block;\n \t    par->forked_insn = end;\n-\t    if (!(mask & GOMP_DIM_MASK (GOMP_DIM_MAX))\n-\t\t&& (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)))\n+\t    if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n \t      par->fork_insn\n \t\t= nvptx_discover_pre (block, CODE_FOR_nvptx_fork);\n \t  }\n@@ -3102,8 +3099,7 @@ nvptx_find_par (bb_insn_map_t *map, parallel *par, basic_block block)\n \t    gcc_assert (par->mask == mask);\n \t    par->join_block = block;\n \t    par->join_insn = end;\n-\t    if (!(mask & GOMP_DIM_MASK (GOMP_DIM_MAX))\n-\t\t&& (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)))\n+\t    if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n \t      par->joining_insn\n \t\t= nvptx_discover_pre (block, CODE_FOR_nvptx_joining);\n \t    par = par->parent;\n@@ -3782,29 +3778,34 @@ nvptx_find_sese (auto_vec<basic_block> &blocks, bb_pair_vec_t &regions)\n #undef BB_SET_SESE\n #undef BB_GET_SESE\n \n-/* Propagate live state at the start of a partitioned region.  BLOCK\n-   provides the live register information, and might not contain\n-   INSN. Propagation is inserted just after INSN. RW indicates whether\n-   we are reading and/or writing state.  This\n+/* Propagate live state at the start of a partitioned region.  IS_CALL\n+   indicates whether the propagation is for a (partitioned) call\n+   instruction.  BLOCK provides the live register information, and\n+   might not contain INSN. Propagation is inserted just after INSN. RW\n+   indicates whether we are reading and/or writing state.  This\n    separation is needed for worker-level proppagation where we\n    essentially do a spill & fill.  FN is the underlying worker\n    function to generate the propagation instructions for single\n    register.  DATA is user data.\n \n-   We propagate the live register set and the entire frame.  We could\n-   do better by (a) propagating just the live set that is used within\n-   the partitioned regions and (b) only propagating stack entries that\n-   are used.  The latter might be quite hard to determine.  */\n+   Returns true if we didn't emit any instructions.\n+\n+   We propagate the live register set for non-calls and the entire\n+   frame for calls and non-calls.  We could do better by (a)\n+   propagating just the live set that is used within the partitioned\n+   regions and (b) only propagating stack entries that are used.  The\n+   latter might be quite hard to determine.  */\n \n typedef rtx (*propagator_fn) (rtx, propagate_mask, unsigned, void *);\n \n-static void\n-nvptx_propagate (basic_block block, rtx_insn *insn, propagate_mask rw,\n-\t\t propagator_fn fn, void *data)\n+static bool\n+nvptx_propagate (bool is_call, basic_block block, rtx_insn *insn,\n+\t\t propagate_mask rw, propagator_fn fn, void *data)\n {\n   bitmap live = DF_LIVE_IN (block);\n   bitmap_iterator iterator;\n   unsigned ix;\n+  bool empty = true;\n \n   /* Copy the frame array.  */\n   HOST_WIDE_INT fs = get_frame_size ();\n@@ -3816,6 +3817,7 @@ nvptx_propagate (basic_block block, rtx_insn *insn, propagate_mask rw,\n       rtx pred = NULL_RTX;\n       rtx_code_label *label = NULL;\n \n+      empty = false;\n       /* The frame size might not be DImode compatible, but the frame\n \t array's declaration will be.  So it's ok to round up here.  */\n       fs = (fs + GET_MODE_SIZE (DImode) - 1) / GET_MODE_SIZE (DImode);\n@@ -3862,18 +3864,21 @@ nvptx_propagate (basic_block block, rtx_insn *insn, propagate_mask rw,\n       insn = emit_insn_after (cpy, insn);\n     }\n \n-  /* Copy live registers.  */\n-  EXECUTE_IF_SET_IN_BITMAP (live, 0, ix, iterator)\n-    {\n-      rtx reg = regno_reg_rtx[ix];\n+  if (!is_call)\n+    /* Copy live registers.  */\n+    EXECUTE_IF_SET_IN_BITMAP (live, 0, ix, iterator)\n+      {\n+\trtx reg = regno_reg_rtx[ix];\n \n-      if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  rtx bcast = fn (reg, rw, 0, data);\n+\tif (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+\t  {\n+\t    rtx bcast = fn (reg, rw, 0, data);\n \n-\t  insn = emit_insn_after (bcast, insn);\n-\t}\n-    }\n+\t    insn = emit_insn_after (bcast, insn);\n+\t    empty = false;\n+\t  }\n+      }\n+  return empty;\n }\n \n /* Worker for nvptx_vpropagate.  */\n@@ -3889,12 +3894,13 @@ vprop_gen (rtx reg, propagate_mask pm,\n }\n \n /* Propagate state that is live at start of BLOCK across the vectors\n-   of a single warp.  Propagation is inserted just after INSN.   */\n+   of a single warp.  Propagation is inserted just after INSN.\n+   IS_CALL and return as for nvptx_propagate.  */\n \n-static void\n-nvptx_vpropagate (basic_block block, rtx_insn *insn)\n+static bool\n+nvptx_vpropagate (bool is_call, basic_block block, rtx_insn *insn)\n {\n-  nvptx_propagate (block, insn, PM_read_write, vprop_gen, 0);\n+  return nvptx_propagate (is_call, block, insn, PM_read_write, vprop_gen, 0);\n }\n \n /* Worker for nvptx_wpropagate.  */\n@@ -3930,18 +3936,20 @@ wprop_gen (rtx reg, propagate_mask pm, unsigned rep, void *data_)\n /* Spill or fill live state that is live at start of BLOCK.  PRE_P\n    indicates if this is just before partitioned mode (do spill), or\n    just after it starts (do fill). Sequence is inserted just after\n-   INSN.  */\n+   INSN.  IS_CALL and return as for nvptx_propagate.  */\n \n-static void\n-nvptx_wpropagate (bool pre_p, basic_block block, rtx_insn *insn)\n+static bool\n+nvptx_wpropagate (bool pre_p, bool is_call, basic_block block, rtx_insn *insn)\n {\n   wcast_data_t data;\n \n   data.base = gen_reg_rtx (Pmode);\n   data.offset = 0;\n   data.ptr = NULL_RTX;\n \n-  nvptx_propagate (block, insn, pre_p ? PM_read : PM_write, wprop_gen, &data);\n+  bool empty = nvptx_propagate (is_call, block, insn,\n+\t\t\t\tpre_p ? PM_read : PM_write, wprop_gen, &data);\n+  gcc_assert (empty == !data.offset);\n   if (data.offset)\n     {\n       /* Stuff was emitted, initialize the base pointer now.  */\n@@ -3951,6 +3959,7 @@ nvptx_wpropagate (bool pre_p, basic_block block, rtx_insn *insn)\n       if (worker_bcast_size < data.offset)\n \tworker_bcast_size = data.offset;\n     }\n+  return empty;\n }\n \n /* Emit a worker-level synchronization barrier.  We use different\n@@ -4311,18 +4320,23 @@ nvptx_process_pars (parallel *par)\n       inner_mask |= par->inner_mask;\n     }\n \n-  if (par->mask & GOMP_DIM_MASK (GOMP_DIM_MAX))\n-    /* No propagation needed for a call.  */;\n-  else if (par->mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+  bool is_call = (par->mask & GOMP_DIM_MASK (GOMP_DIM_MAX)) != 0;\n+\n+  if (par->mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n     {\n-      nvptx_wpropagate (false, par->forked_block, par->forked_insn);\n-      nvptx_wpropagate (true, par->forked_block, par->fork_insn);\n-      /* Insert begin and end synchronizations.  */\n-      emit_insn_before (nvptx_wsync (false), par->forked_insn);\n-      emit_insn_before (nvptx_wsync (true), par->join_insn);\n+      nvptx_wpropagate (false, is_call, par->forked_block, par->forked_insn);\n+      bool empty = nvptx_wpropagate (true, is_call,\n+\t\t\t\t     par->forked_block, par->fork_insn);\n+\n+      if (!empty || !is_call)\n+\t{\n+\t  /* Insert begin and end synchronizations.  */\n+\t  emit_insn_before (nvptx_wsync (false), par->forked_insn);\n+\t  emit_insn_before (nvptx_wsync (true), par->join_insn);\n+\t}\n     }\n   else if (par->mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR))\n-    nvptx_vpropagate (par->forked_block, par->forked_insn);\n+    nvptx_vpropagate (is_call, par->forked_block, par->forked_insn);\n \n   /* Now do siblings.  */\n   if (par->next)"}, {"sha": "1c9fa4405646fd18a1bbfea5091c195aa1b6afab", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91eba31fdc49d928090a9b0424247fd6029f044/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91eba31fdc49d928090a9b0424247fd6029f044/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=e91eba31fdc49d928090a9b0424247fd6029f044", "patch": "@@ -1,3 +1,9 @@\n+2018-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/85445\n+\t* testsuite/libgomp.oacc-c++/ref-1.C: New.\n+\n 2018-04-19  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR libgomp/85463"}, {"sha": "b3aaf0ff5fb9b5f2af60d5e1683dc037d9e1676f", "filename": "libgomp/testsuite/libgomp.oacc-c++/ref-1.C", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e91eba31fdc49d928090a9b0424247fd6029f044/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fref-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e91eba31fdc49d928090a9b0424247fd6029f044/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fref-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fref-1.C?ref=e91eba31fdc49d928090a9b0424247fd6029f044", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+\n+#include <stdio.h>\n+\n+#pragma acc routine vector\n+void __attribute__((noinline, noclone))\n+Vector (int *ptr, int n, const int &inc)\n+{\n+#pragma acc loop vector\n+  for (unsigned ix = 0; ix < n; ix++)\n+    ptr[ix] += inc;\n+}\n+\n+#pragma acc routine worker\n+void __attribute__((noinline, noclone))\n+Worker (int *ptr, int m, int n, const int &inc)\n+{\n+#pragma acc loop worker\n+  for (unsigned ix = 0; ix < m; ix++)\n+    Vector(ptr + ix * n, n, inc);\n+}\n+\n+int\n+main (void)\n+{\n+  const int n = 32, m = 32;\n+\n+  int ary[m][n];\n+  unsigned ix,  iy;\n+\n+  for (ix = m; ix--;)\n+    for (iy = n; iy--;)\n+      ary[ix][iy] = (ix << 8) + iy;\n+\n+#pragma acc parallel copy(ary)\n+  {\n+    Worker (&ary[0][0], m, n, 1 << 16);\n+  }\n+\n+  int err = 0;\n+\n+  for (ix = m; ix--;)\n+    for (iy = n; iy--;)\n+      if (ary[ix][iy] != ((1 << 16) + (ix << 8) + iy))\n+\t{\n+\t  printf (\"ary[%u][%u] = %x expected %x\\n\",\n+\t\t  ix, iy, ary[ix][iy], ((1 << 16) + (ix << 8) + iy));\n+\t  err++;\n+\t}\n+\n+  if (err)\n+    {\n+      printf (\"%d failed\\n\", err);\n+      return 1;\n+    }\n+\n+#pragma acc parallel copy(ary)\n+  {\n+    Vector (&ary[0][0], m * n, (1 << 24) - (1 << 16));\n+  }\n+\n+  for (ix = m; ix--;)\n+    for (iy = n; iy--;)\n+      if (ary[ix][iy] != ((1 << 24) + (ix << 8) + iy))\n+\t{\n+\t  printf (\"ary[%u][%u] = %x expected %x\\n\",\n+\t\t  ix, iy, ary[ix][iy], ((1 << 24) + (ix << 8) + iy));\n+\t  err++;\n+\t}\n+\n+  if (err)\n+    {\n+      printf (\"%d failed\\n\", err);\n+      return 1;\n+    }\n+\n+  return 0;\n+}"}]}