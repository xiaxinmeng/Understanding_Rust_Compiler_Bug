{"sha": "168d3732aa67159489982b879ce29147ed94a4ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY4ZDM3MzJhYTY3MTU5NDg5OTgyYjg3OWNlMjkxNDdlZDk0YTRhYw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-14T06:34:11Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-14T06:34:11Z"}, "message": "cppfiles.c: Include mkdeps.h.\n\n\t* cppfiles.c: Include mkdeps.h.\n\t(find_include_file, read_include_file): Remove _cpp_ prefix\n\tfrom name, make static.\n\t(_cpp_execute_include): New function, broken out of\n\tdo_include.\n\n\t* cpplib.c: Don't include mkdeps.h.\n\t(struct directive): Remove type field. Reorder entries.  The\n\tfunction takes only one argument.\n\t(struct if_stack): Make type field an int.\n\t(directive_table): Rename to dtable.  Generate it, the\n\tprototypes of the directive handlers, and the enum for the\n\tdirective numbers, from a template macro.\n\t(do_ifndef, do_include_next, do_import): New functions.\n\t(do_define, do_include, do_endif, do_ifdef, do_if, do_else,\n\tdo_undef, do_line, do_elif, do_error, do_pragma, do_warning,\n\tdo_ident, do_assert, do_unassert, do_sccs): Take only one\n\targument.\n\t(do_sccs): Define always, but alter behavior based on\n\tSCCS_DIRECTIVE.\n\t(_cpp_handle_directive, consider_directive_while_skipping):\n\tRestructure for new directive table layout.\n\n\t(pass_thru_directive): Take a directive number, not a pointer\n\tto a struct directive.\n\t(parse_include): New function, broken out of do_include.\n\t(do_include, do_import, do_include_next): Use parse_include\n\tand _cpp_execute_include.\n\t(do_elif, do_else): Test for T_ELSE specifically when checking\n\tfor #elif/#else after #else.\n\t(parse_ifdef): New function, broken out of do_ifdef.\n\t(validate_else): Expect a name arg without a leading #.\n\t(if_directive_name): Delete.\n\t(cpp_define, cpp_assert, cpp_undef, cpp_unassert): Call\n\tdirective handlers with only one argument.\n\n\t* cpphash.h: Update prototypes.\n\t(enum node_type): Remove entries for directives.\n\t* Makefile.in: Update dependencies.\n\nFrom-SVN: r32519", "tree": {"sha": "193e65c2271a732229c4e6fa06aba75d25b7e835", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/193e65c2271a732229c4e6fa06aba75d25b7e835"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/168d3732aa67159489982b879ce29147ed94a4ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168d3732aa67159489982b879ce29147ed94a4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/168d3732aa67159489982b879ce29147ed94a4ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168d3732aa67159489982b879ce29147ed94a4ac/comments", "author": null, "committer": null, "parents": [{"sha": "194ae3f644daec5af81b93bbf627275756852728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/194ae3f644daec5af81b93bbf627275756852728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/194ae3f644daec5af81b93bbf627275756852728"}], "stats": {"total": 899, "additions": 471, "deletions": 428}, "files": [{"sha": "2559e36c5f42b3efb7fea6dbddd0b159bdef386f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=168d3732aa67159489982b879ce29147ed94a4ac", "patch": "@@ -1,5 +1,45 @@\n 2000-03-13  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cppfiles.c: Include mkdeps.h.\n+\t(find_include_file, read_include_file): Remove _cpp_ prefix\n+\tfrom name, make static.\n+\t(_cpp_execute_include): New function, broken out of\n+\tdo_include.\n+\n+\t* cpplib.c: Don't include mkdeps.h.\n+\t(struct directive): Remove type field. Reorder entries.  The\n+\tfunction takes only one argument.\n+\t(struct if_stack): Make type field an int.\n+\t(directive_table): Rename to dtable.  Generate it, the\n+\tprototypes of the directive handlers, and the enum for the\n+\tdirective numbers, from a template macro.\n+\t(do_ifndef, do_include_next, do_import): New functions.\n+\t(do_define, do_include, do_endif, do_ifdef, do_if, do_else,\n+\tdo_undef, do_line, do_elif, do_error, do_pragma, do_warning,\n+\tdo_ident, do_assert, do_unassert, do_sccs): Take only one\n+\targument.\n+\t(do_sccs): Define always, but alter behavior based on\n+\tSCCS_DIRECTIVE.\n+\t(_cpp_handle_directive, consider_directive_while_skipping):\n+\tRestructure for new directive table layout.\n+\n+\t(pass_thru_directive): Take a directive number, not a pointer\n+\tto a struct directive.\n+\t(parse_include): New function, broken out of do_include.\n+\t(do_include, do_import, do_include_next): Use parse_include\n+\tand _cpp_execute_include.\n+\t(do_elif, do_else): Test for T_ELSE specifically when checking\n+\tfor #elif/#else after #else.\n+\t(parse_ifdef): New function, broken out of do_ifdef.\n+\t(validate_else): Expect a name arg without a leading #.\n+\t(if_directive_name): Delete.\n+\t(cpp_define, cpp_assert, cpp_undef, cpp_unassert): Call\n+\tdirective handlers with only one argument.\n+\n+\t* cpphash.h: Update prototypes.\n+\t(enum node_type): Remove entries for directives.\n+\t* Makefile.in: Update dependencies.\n+\n \t* cpphash.c (dump_hash_helper): Only dump nodes of type\n \tT_MACRO.  Emit a newline after each definition.\n "}, {"sha": "59b792aedc202866519c932ddfa4f931f47033cb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=168d3732aa67159489982b879ce29147ed94a4ac", "patch": "@@ -2050,9 +2050,9 @@ cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n-cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n+cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H)\n-cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h\n+cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h\n \n cppinit.o:  cppinit.c  $(CONFIG_H) $(LIBCPP_DEPS) $(HASHTAB_H) mkdeps.h \\\n \t\tprefix.h output.h Makefile version.h"}, {"sha": "cff8cd2ea5fbfc44a281339bac9b4c489b26a322", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 126, "deletions": 8, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=168d3732aa67159489982b879ce29147ed94a4ac", "patch": "@@ -30,6 +30,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"hashtab.h\"\n #include \"intl.h\"\n+#include \"mkdeps.h\"\n \n static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n \t\t\t\t\t   struct file_name_list *));\n@@ -40,11 +41,14 @@ static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t struct file_name_list *));\n static struct file_name_list *actual_directory\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n-\n static unsigned int hash_IHASH\tPARAMS ((const void *));\n static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n-\n static int file_cleanup\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n+static int find_include_file\tPARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\tstruct file_name_list *,\n+\t\t\t\t\tIHASH **, int *));\n+static int read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -58,7 +62,7 @@ static void hack_vms_include_specification PARAMS ((char *));\n #endif\n \n /* Open files in nonblocking mode, so we don't get stuck if someone\n-   clever has asked cpp to process /dev/rmt0.  _cpp_read_include_file\n+   clever has asked cpp to process /dev/rmt0.  read_include_file\n    will check that we have a real file to work with.  Also take care\n    not to acquire a controlling terminal by mistake (this can't happen\n    on sane systems, but paranoia is a virtue).  */\n@@ -185,8 +189,8 @@ file_cleanup (pbuf, pfile)\n    *IHASH is set to point to the include hash entry for this file, and\n    *BEFORE is set to 1 if the file was included before (but needs to be read\n    again). */\n-int\n-_cpp_find_include_file (pfile, fname, search_start, ihash, before)\n+static int\n+find_include_file (pfile, fname, search_start, ihash, before)\n      cpp_reader *pfile;\n      const char *fname;\n      struct file_name_list *search_start;\n@@ -465,6 +469,120 @@ remap_filename (pfile, name, loc)\n   return name;\n }\n \n+\n+void\n+_cpp_execute_include (pfile, fname, len, no_reinclude, search_start)\n+     cpp_reader *pfile;\n+     char *fname;\n+     unsigned int len;\n+     int no_reinclude;\n+     struct file_name_list *search_start;\n+{\n+  IHASH *ihash;\n+  int fd;\n+  int angle_brackets = fname[0] == '<';\n+  int before;\n+\n+  if (!search_start)\n+    {\n+      if (angle_brackets)\n+\tsearch_start = CPP_OPTIONS (pfile)->bracket_include;\n+      else if (CPP_OPTIONS (pfile)->ignore_srcdir)\n+\tsearch_start = CPP_OPTIONS (pfile)->quote_include;\n+      else\n+\tsearch_start = CPP_BUFFER (pfile)->actual_dir;\n+    }\n+\n+  if (!search_start)\n+    {\n+      cpp_error (pfile, \"No include path in which to find %s\", fname);\n+      return;\n+    }\n+\n+  /* Remove quote marks.  */\n+  fname++;\n+  len -= 2;\n+  fname[len] = '\\0';\n+\n+  fd = find_include_file (pfile, fname, search_start, &ihash, &before);\n+\n+  if (fd == -2)\n+    return;\n+  \n+  if (fd == -1)\n+    {\n+      if (CPP_OPTIONS (pfile)->print_deps_missing_files\n+\t  && CPP_PRINT_DEPS (pfile) > (angle_brackets ||\n+\t\t\t\t       (pfile->system_include_depth > 0)))\n+        {\n+\t  if (!angle_brackets)\n+\t    deps_add_dep (pfile->deps, fname);\n+\t  else\n+\t    {\n+\t      char *p;\n+\t      struct file_name_list *ptr;\n+\t      /* If requested as a system header, assume it belongs in\n+\t\t the first system header directory. */\n+\t      if (CPP_OPTIONS (pfile)->bracket_include)\n+\t        ptr = CPP_OPTIONS (pfile)->bracket_include;\n+\t      else\n+\t        ptr = CPP_OPTIONS (pfile)->quote_include;\n+\n+\t      p = (char *) alloca (strlen (ptr->name)\n+\t\t\t\t   + strlen (fname) + 2);\n+\t      if (*ptr->name != '\\0')\n+\t        {\n+\t\t  strcpy (p, ptr->name);\n+\t\t  strcat (p, \"/\");\n+\t        }\n+\t      strcat (p, fname);\n+\t      deps_add_dep (pfile->deps, p);\n+\t    }\n+\t}\n+      /* If -M was specified, and this header file won't be added to\n+\t the dependency list, then don't count this as an error,\n+\t because we can still produce correct output.  Otherwise, we\n+\t can't produce correct output, because there may be\n+\t dependencies we need inside the missing file, and we don't\n+\t know what directory this missing file exists in. */\n+      else if (CPP_PRINT_DEPS (pfile)\n+\t       && (CPP_PRINT_DEPS (pfile)\n+\t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n+\tcpp_warning (pfile, \"No include path in which to find %s\", fname);\n+      else\n+\tcpp_error_from_errno (pfile, fname);\n+\n+      return;\n+    }\n+\n+  /* For -M, add the file to the dependencies on its first inclusion. */\n+  if (!before && (CPP_PRINT_DEPS (pfile)\n+\t\t  > (angle_brackets || (pfile->system_include_depth > 0))))\n+    deps_add_dep (pfile->deps, ihash->name);\n+\n+  /* Handle -H option.  */\n+  if (CPP_OPTIONS(pfile)->print_include_names)\n+    {\n+      cpp_buffer *fp = CPP_BUFFER (pfile);\n+      while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n+\tputc ('.', stderr);\n+      fprintf (stderr, \" %s\\n\", ihash->name);\n+    }\n+\n+  /* Actually process the file */\n+\n+  if (no_reinclude)\n+    ihash->control_macro = (const U_CHAR *) \"\";\n+  \n+  if (read_include_file (pfile, fd, ihash))\n+    {\n+      _cpp_output_line_command (pfile, enter_file);\n+      if (angle_brackets)\n+\tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n+    }\n+}\n+\n+\n /* Push an input buffer and load it up with the contents of FNAME.\n    If FNAME is \"\" or NULL, read standard input.  */\n int\n@@ -506,7 +624,7 @@ cpp_read_file (pfile, fname)\n   else\n     f = open (fname, OMODES);\n \n-  return _cpp_read_include_file (pfile, f, ih);\n+  return read_include_file (pfile, f, ih);\n }\n \n /* Read the contents of FD into the buffer on the top of PFILE's stack.\n@@ -515,8 +633,8 @@ cpp_read_file (pfile, fname)\n \n    The caller is responsible for the cpp_push_buffer.  */\n \n-int\n-_cpp_read_include_file (pfile, fd, ihash)\n+static int\n+read_include_file (pfile, fd, ihash)\n      cpp_reader *pfile;\n      int fd;\n      IHASH *ihash;"}, {"sha": "704cab47d873ceece0c5bc210f0a98588ab8bf6f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=168d3732aa67159489982b879ce29147ed94a4ac", "patch": "@@ -83,28 +83,9 @@ struct definition\n    It does not contain control words like \"#define\", which are recognized\n    by a separate piece of code. */\n \n-/* different flavors of hash nodes --- also used in keyword table */\n+/* different flavors of hash nodes */\n enum node_type\n {\n-  T_DEFINE = 1,\t   /* `#define' */\n-  T_INCLUDE,\t   /* `#include' */\n-  T_INCLUDE_NEXT,  /* `#include_next' */\n-  T_IMPORT,        /* `#import' */\n-  T_IFDEF,\t   /* `#ifdef' */\n-  T_IFNDEF,\t   /* `#ifndef' */\n-  T_IF,\t\t   /* `#if' */\n-  T_ELSE,\t   /* `#else' */\n-  T_PRAGMA,\t   /* `#pragma' */\n-  T_ELIF,\t   /* `#elif' */\n-  T_UNDEF,\t   /* `#undef' */\n-  T_LINE,\t   /* `#line' */\n-  T_ERROR,\t   /* `#error' */\n-  T_WARNING,\t   /* `#warning' */\n-  T_ENDIF,\t   /* `#endif' */\n-  T_SCCS,\t   /* `#sccs' */\n-  T_IDENT,\t   /* `#ident' */\n-  T_ASSERT,\t   /* `#assert' */\n-  T_UNASSERT,\t   /* `#unassert', */\n   T_SPECLINE,\t   /* `__LINE__' */\n   T_DATE,\t   /* `__DATE__' */\n   T_FILE,\t   /* `__FILE__' */\n@@ -292,10 +273,9 @@ extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n-extern int _cpp_find_include_file\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t\tstruct file_name_list *,\n-\t\t\t\t\t\tIHASH **, int *));\n-extern int _cpp_read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+extern void _cpp_execute_include\tPARAMS ((cpp_reader *, char *,\n+\t\t\t\t\t\t unsigned int, int,\n+\t\t\t\t\t\t struct file_name_list *));\n extern void _cpp_init_include_hash\tPARAMS ((cpp_reader *));\n \n /* In cppexp.c */"}, {"sha": "dac186d9904e547e7a96f24ad2ac6641308bd89a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 299, "deletions": 394, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/168d3732aa67159489982b879ce29147ed94a4ac/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=168d3732aa67159489982b879ce29147ed94a4ac", "patch": "@@ -26,7 +26,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpphash.h\"\n #include \"hashtab.h\"\n #include \"intl.h\"\n-#include \"mkdeps.h\"\n \n #define PEEKN(N) (CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur >= (N) \\\n \t\t  ? CPP_BUFFER (pfile)->cur[N] : EOF)\n@@ -38,11 +37,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n struct directive\n {\n-  int length;\t\t\t/* Length of name */\n-  int (*func)\t\t\t/* Function to handle directive */\n-    PARAMS ((cpp_reader *, const struct directive *));\n+  unsigned int length;\t\t/* Length of name */\n   const char *name;\t\t/* Name of directive */\n-  enum node_type type;\t\t/* Code which describes which directive.  */\n+  int (*func)\t\t\t/* Function to handle directive */\n+    PARAMS ((cpp_reader *));\n };\n \n /* Stack of conditionals currently in progress\n@@ -54,84 +52,83 @@ struct if_stack\n   int lineno;\t\t\t/* line number where condition started */\n   int if_succeeded;\t\t/* truth of last condition in this group */\n   const U_CHAR *control_macro;\t/* macro name for #ifndef around entire file */\n-  enum node_type type;\t\t/* type of last directive seen in this group */\n+  int type;\t\t\t/* type of last directive seen in this group */\n };\n typedef struct if_stack IF_STACK;\n \n-\n-/* These functions are declared to return int instead of void since they\n-   are going to be placed in a table and some old compilers have trouble with\n-   pointers to functions returning void.  */\n-\n-static int do_define PARAMS ((cpp_reader *, const struct directive *));\n-static int do_line PARAMS ((cpp_reader *, const struct directive *));\n-static int do_include PARAMS ((cpp_reader *, const struct directive *));\n-static int do_undef PARAMS ((cpp_reader *, const struct directive *));\n-static int do_error PARAMS ((cpp_reader *, const struct directive *));\n-static int do_pragma PARAMS ((cpp_reader *, const struct directive *));\n-static int do_ident PARAMS ((cpp_reader *, const struct directive *));\n-static int do_if PARAMS ((cpp_reader *, const struct directive *));\n-static int do_ifdef PARAMS ((cpp_reader *, const struct directive *));\n-static int do_else PARAMS ((cpp_reader *, const struct directive *));\n-static int do_elif PARAMS ((cpp_reader *, const struct directive *));\n-static int do_endif PARAMS ((cpp_reader *, const struct directive *));\n-#ifdef SCCS_DIRECTIVE\n-static int do_sccs PARAMS ((cpp_reader *, const struct directive *));\n-#endif\n-static int do_assert PARAMS ((cpp_reader *, const struct directive *));\n-static int do_unassert PARAMS ((cpp_reader *, const struct directive *));\n-static int do_warning PARAMS ((cpp_reader *, const struct directive *));\n-\n /* Forward declarations.  */\n \n static void validate_else\t\tPARAMS ((cpp_reader *, const char *));\n-static void conditional_skip\t\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t\tenum node_type, U_CHAR *));\n+static int parse_ifdef\t\t\tPARAMS ((cpp_reader *, const char *));\n+static unsigned int parse_include\tPARAMS ((cpp_reader *, const char *));\n+static void conditional_skip\t\tPARAMS ((cpp_reader *, int, int,\n+\t\t\t\t\t\t U_CHAR *));\n static void skip_if_group\t\tPARAMS ((cpp_reader *));\n static void pass_thru_directive\t\tPARAMS ((const U_CHAR *, size_t,\n-\t\t\t\t\t\t cpp_reader *,\n-\t\t\t\t\t\t const struct directive *));\n+\t\t\t\t\t\t cpp_reader *, int));\n static int read_line_number\t\tPARAMS ((cpp_reader *, int *));\n static U_CHAR *detect_if_not_defined\tPARAMS ((cpp_reader *));\n static int consider_directive_while_skipping\n \t\t\t\t\tPARAMS ((cpp_reader *, IF_STACK *));\n static int get_macro_name\t\tPARAMS ((cpp_reader *));\n-static const char *if_directive_name\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct if_stack *));\n-\n-/* Here is the actual list of #-directives.\n-   This table is ordered by frequency of occurrence; the numbers\n-   at the end are directive counts from all the source code I have\n-   lying around (egcs and libc CVS as of 1999-05-18, plus grub-0.5.91,\n-   linux-2.2.9, and pcmcia-cs-3.0.9).  */\n-\n-static const struct directive directive_table[] = {\n-  /* In C89 */\n-  {  6, do_define,   \"define\",       T_DEFINE },\t/* 270554 */\n-  {  7, do_include,  \"include\",      T_INCLUDE },\t/*  52262 */\n-  {  5, do_endif,    \"endif\",        T_ENDIF },\t\t/*  45855 */\n-  {  5, do_ifdef,   \"ifdef\",        T_IFDEF },\t\t/*  22000 */\n-  {  2, do_if,       \"if\",           T_IF },\t\t/*  18162 */\n-  {  4, do_else,     \"else\",         T_ELSE },\t\t/*   9863 */\n-  {  6, do_ifdef,   \"ifndef\",       T_IFNDEF },\t/*   9675 */\n-  {  5, do_undef,    \"undef\",        T_UNDEF },\t\t/*   4837 */\n-  {  4, do_line,     \"line\",         T_LINE },\t\t/*   2465 */\n-  {  4, do_elif,     \"elif\",         T_ELIF },\t\t/*    610 */\n-  {  5, do_error,    \"error\",        T_ERROR },\t\t/*    475 */\n-  {  6, do_pragma,   \"pragma\",       T_PRAGMA },\t/*    195 */\n-\n-  /* Extensions.  All deprecated except #warning and #include_next.  */\n-  {  7, do_warning,  \"warning\",      T_WARNING },\t/*     22 - GNU   */\n-  { 12, do_include,  \"include_next\", T_INCLUDE_NEXT },\t/*     19 - GNU   */\n-  {  5, do_ident,    \"ident\",        T_IDENT },\t\t/*     11 - SVR4  */\n-  {  6, do_include,  \"import\",       T_IMPORT },\t/*      0 - ObjC  */\n-  {  6, do_assert,   \"assert\",       T_ASSERT },\t/*      0 - SVR4  */\n-  {  8, do_unassert, \"unassert\",     T_UNASSERT },\t/*      0 - SVR4  */\n-#ifdef SCCS_DIRECTIVE\n-  {  4, do_sccs,     \"sccs\",         T_SCCS },\t\t/*      0 - SVR2? */\n-#endif\n-  {  -1, 0, \"\", T_UNUSED }\n+\n+/* This is the table of directive handlers.  It is ordered by\n+   frequency of occurrence; the numbers at the end are directive\n+   counts from all the source code I have lying around (egcs and libc\n+   CVS as of 1999-05-18, plus grub-0.5.91, linux-2.2.9, and\n+   pcmcia-cs-3.0.9).\n+\n+   The entries with a dash and a name after the count are extensions,\n+   of which all but #warning and #include_next are deprecated.  The name\n+   is where the extension appears to have come from.  */\n+\n+#define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n+D(\"define\",\t  do_define,\t   T_DEFINE)\t\t/* 270554 */\t\\\n+D(\"include\",\t  do_include,\t   T_INCLUDE)\t\t/*  52262 */\t\\\n+D(\"endif\",\t  do_endif,\t   T_ENDIF)\t\t/*  45855 */\t\\\n+D(\"ifdef\",\t  do_ifdef,\t   T_IFDEF)\t\t/*  22000 */\t\\\n+D(\"if\",\t\t  do_if,\t   T_IF)\t\t/*  18162 */\t\\\n+D(\"else\",\t  do_else,\t   T_ELSE)\t\t/*   9863 */\t\\\n+D(\"ifndef\",\t  do_ifndef,\t   T_IFNDEF)\t\t/*   9675 */\t\\\n+D(\"undef\",\t  do_undef,\t   T_UNDEF)\t\t/*   4837 */\t\\\n+D(\"line\",\t  do_line,\t   T_LINE)\t\t/*   2465 */\t\\\n+D(\"elif\",\t  do_elif,\t   T_ELIF)\t\t/*    610 */\t\\\n+D(\"error\",\t  do_error,\t   T_ERROR)\t\t/*    475 */\t\\\n+D(\"pragma\",\t  do_pragma,\t   T_PRAGMA)\t\t/*    195 */\t\\\n+D(\"warning\",\t  do_warning,\t   T_WARNING)\t\t/*     22 - GNU   */ \\\n+D(\"include_next\", do_include_next, T_INCLUDE_NEXT)\t/*     19 - GNU   */ \\\n+D(\"ident\",\t  do_ident,\t   T_IDENT)\t\t/*     11 - SVR4  */ \\\n+D(\"import\",\t  do_import,\t   T_IMPORT)\t\t/*      0 - ObjC  */ \\\n+D(\"assert\",\t  do_assert,\t   T_ASSERT)\t\t/*      0 - SVR4  */ \\\n+D(\"unassert\",\t  do_unassert,\t   T_UNASSERT)\t\t/*      0 - SVR4  */ \\\n+D(\"sccs\",\t  do_sccs,\t   T_SCCS)\t\t/*      0 - SVR2? */\n+\n+/* Use the table to generate a series of prototypes, an enum for the\n+   directive names, and an array of directive handlers.  */\n+\n+/* The directive-processing functions are declared to return int\n+   instead of void, because some old compilers have trouble with\n+   pointers to functions returning void.  */\n+\n+#define D(name, fun, tag) static int fun PARAMS ((cpp_reader *));\n+DIRECTIVE_TABLE\n+#undef D\n+\n+#define D(name, fun, tag) tag,\n+enum\n+{\n+  DIRECTIVE_TABLE\n+  N_DIRECTIVES\n };\n+#undef D\n+\n+#define D(name, fun, tag) { sizeof name - 1, name, fun },\n+static const struct directive dtable[] =\n+{\n+DIRECTIVE_TABLE\n+};\n+#undef D\n+#undef DIRECTIVE_TABLE\n \n /* Handle a possible # directive.\n    '#' has already been read.  */\n@@ -140,9 +137,8 @@ int\n _cpp_handle_directive (pfile)\n      cpp_reader *pfile;\n {\n-  int c;\n-  register const struct directive *kt;\n-  int ident_length;\n+  int c, i;\n+  unsigned int len;\n   U_CHAR *ident;\n   long old_written = CPP_WRITTEN (pfile);\n \n@@ -168,7 +164,7 @@ _cpp_handle_directive (pfile)\n \t  && ! CPP_OPTIONS (pfile)->preprocessed\n \t  && ! CPP_BUFFER (pfile)->manual_pop)\n \tcpp_pedwarn (pfile, \"`#' followed by integer\");\n-      do_line (pfile, NULL);\n+      do_line (pfile);\n       return 1;\n     }\n \n@@ -181,8 +177,8 @@ _cpp_handle_directive (pfile)\n   CPP_PUTC (pfile, '#');\n   _cpp_parse_name (pfile, GETC());\n   ident = pfile->token_buffer + old_written + 1;\n-  ident_length = CPP_PWRITTEN (pfile) - ident;\n-  if (ident_length == 0)\n+  len = CPP_PWRITTEN (pfile) - ident;\n+  if (len == 0)\n     {\n       /* A line of just `#' becomes blank.  A line with something\n \t other than an identifier after the # is reparsed as a non-\n@@ -192,27 +188,27 @@ _cpp_handle_directive (pfile)\n     }\n \n   /* Decode the keyword and call the appropriate expansion routine.  */\n-  for (kt = directive_table; ; kt++)\n+  for (i = 0; i < N_DIRECTIVES; i++)\n     {\n-      if (kt->length <= 0)\n-\t/* # identifier, but not a legit directive.  Pass onward as a\n-\t   CPP_DIRECTIVE token anyway - let the consumer worry about it.  */\n-\treturn 1;\n-      if (kt->length == ident_length\n-\t  && !strncmp (kt->name, ident, ident_length)) \n+      if (dtable[i].length == len\n+\t  && !strncmp (dtable[i].name, ident, len)) \n \tbreak;\n     }\n+  if (i == N_DIRECTIVES)\n+    /* # identifier, but not a legit directive.  Pass onward as a\n+       CPP_DIRECTIVE token anyway - let the consumer worry about it.  */\n+    return 1;\n \n   CPP_SET_WRITTEN (pfile, old_written);\n \n   if (pfile->no_directives)\n     {\n       cpp_error (pfile, \"`#%s' may not be used inside a macro argument\",\n-\t\t kt->name);\n+\t\t dtable[i].name);\n       _cpp_skip_rest_of_line (pfile);\n     }\n   else\n-    (*kt->func) (pfile, kt);\n+    (*dtable[i].func) (pfile);\n \n   return 1;\n }\n@@ -227,13 +223,14 @@ pass_thru_directive (buf, len, pfile, keyword)\n      const U_CHAR *buf;\n      size_t len;\n      cpp_reader *pfile;\n-     const struct directive *keyword;\n+     int keyword;\n {\n-  register unsigned keyword_length = keyword->length;\n+  const struct directive *kt = &dtable[keyword];\n+  register unsigned klen = kt->length;\n \n-  CPP_RESERVE (pfile, 1 + keyword_length + len);\n+  CPP_RESERVE (pfile, 1 + klen + len);\n   CPP_PUTC_Q (pfile, '#');\n-  CPP_PUTS_Q (pfile, keyword->name, keyword_length);\n+  CPP_PUTS_Q (pfile, kt->name, klen);\n   if (len != 0 && buf[0] != ' ')\n     CPP_PUTC_Q (pfile, ' ');\n   CPP_PUTS_Q (pfile, buf, len);\n@@ -272,14 +269,11 @@ get_macro_name (pfile)\n   return 0;\n }\n \n-/* Process a #define command.\n-   KEYWORD is the keyword-table entry for #define,\n-   or NULL for a \"predefined\" macro.  */\n+/* Process a #define command.  */\n \n static int\n-do_define (pfile, keyword)\n+do_define (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   HASHNODE **slot;\n   DEFINITION *def;\n@@ -364,7 +358,7 @@ do_define (pfile, keyword)\n       || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n     _cpp_dump_definition (pfile, sym, len, def);\n   else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n-    pass_thru_directive (sym, len, pfile, keyword);\n+    pass_thru_directive (sym, len, pfile, T_DEFINE);\n \n   return 0;\n }\n@@ -446,227 +440,145 @@ _cpp_output_line_command (pfile, file_change)\n \n /* Handle #include and #import.  */\n \n-static int\n-do_include (pfile, keyword)\n+static unsigned int\n+parse_include (pfile, name)\n      cpp_reader *pfile;\n-     const struct directive *keyword;\n+     const char *name;\n {\n-  int importing = (keyword->type == T_IMPORT);\n-  int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n-  int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n-  int before;  /* included before? */\n-  long flen;\n-  unsigned char *ftok;\n-  cpp_buffer *fp;\n-\n-  enum cpp_token token;\n-\n-  /* Chain of dirs to search */\n-  IHASH *ihash;\n-  struct file_name_list *search_start;\n-  \n   long old_written = CPP_WRITTEN (pfile);\n-\n-  int fd;\n-\n-  if (CPP_PEDANTIC (pfile))\n-    {\n-      if (importing)\n-\tcpp_pedwarn (pfile, \"ANSI C does not allow `#import'\");\n-      if (skip_dirs)\n-\tcpp_pedwarn (pfile, \"ANSI C does not allow `#include_next'\");\n-    }\n-\n-  if (importing && CPP_OPTIONS (pfile)->warn_import\n-      && !CPP_OPTIONS (pfile)->inhibit_warnings\n-      && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n-    {\n-      pfile->import_warning = 1;\n-      cpp_warning (pfile,\n-\t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n-    }\n+  enum cpp_token token;\n+  int len;\n \n   pfile->parsing_include_directive++;\n   token = _cpp_get_directive_token (pfile);\n   pfile->parsing_include_directive--;\n \n+  len = CPP_WRITTEN (pfile) - old_written;\n+\n   if (token == CPP_STRING)\n-    {\n-      if (pfile->token_buffer[old_written] == '<')\n-\tangle_brackets = 1;\n-    }\n+    ; /* No special treatment required.  */\n #ifdef VMS\n   else if (token == CPP_NAME)\n     {\n       /* Support '#include xyz' like VAX-C.  It is taken as\n          '#include <xyz.h>' and generates a warning.  */\n-      cpp_warning (pfile,\n-\t       \"`#include filename' is obsolete, use `#include <filename.h>'\");\n-      angle_brackets = 1;\n-\n-      /* Append the missing `.h' to the name. */\n-      CPP_PUTS (pfile, \".h\", 2);\n+      cpp_warning (pfile, \"#%s filename is obsolete, use #%s <filename.h>\",\n+\t\t   name, name);\n+\n+      /* Rewrite the token to <xyz.h>.  */\n+      CPP_RESERVE (pfile, 4);\n+      len += 4;\n+      memmove (pfile->token_buffer + old_written + 1,\n+\t       pfile->token_buffer + old_written,\n+\t       CPP_WRITTEN (pfile) - old_written);\n+      pfile->token_buffer[old_written] = '<';\n+      CPP_PUTS_Q (pfile, \".h>\", 2);\n     }\n #endif\n   else\n     {\n-      cpp_error (pfile,\n-\t\t \"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", keyword->name);\n+      cpp_error (pfile, \"`#%s' expects \\\"FILENAME\\\" or <FILENAME>\", name);\n       CPP_SET_WRITTEN (pfile, old_written);\n       _cpp_skip_rest_of_line (pfile);\n       return 0;\n     }\n \n-  flen = CPP_WRITTEN (pfile) - old_written;\n-  ftok = (unsigned char *) alloca (flen + 1);\n-  memcpy (ftok, pfile->token_buffer + old_written, flen);\n-  ftok[flen] = '\\0';\n+  CPP_NUL_TERMINATE (pfile);\n+  CPP_ADJUST_WRITTEN (pfile, 1);\n \n   if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n-      cpp_error (pfile, \"junk at end of `#include'\");\n+      cpp_error (pfile, \"junk at end of `#%s'\", name);\n       _cpp_skip_rest_of_line (pfile);\n     }\n \n   CPP_SET_WRITTEN (pfile, old_written);\n \n-  if (flen == 0)\n-    {\n-      cpp_error (pfile, \"empty file name in `#%s'\", keyword->name);\n-      return 0;\n-    }\n+  if (len == 0)\n+    cpp_error (pfile, \"empty file name in `#%s'\", name);\n \n-  if (CPP_OPTIONS (pfile)->dump_includes)\n-    pass_thru_directive (ftok,\n-\t\t\t flen\n-#ifdef VMS\n-\t  - ((token == CPP_NAME) ? 2 : 0)\n-#endif\n-\t\t\t , pfile, keyword);\n+  return len;\n+}\n \n-#ifdef VMS\n-  if (token == CPP_STRING)\n-#endif\n-    {\n-      ftok++;\n-      flen -= 2;\n-      ftok[flen] = '\\0';\n-    }\n+static int\n+do_include (pfile)\n+     cpp_reader *pfile;\n+{\n+  unsigned int len;\n+  char *token;\n \n-  search_start = 0;\n+  len = parse_include (pfile, dtable[T_INCLUDE].name);\n+  token = alloca (len + 1);\n+  strcpy (token, CPP_PWRITTEN (pfile));\n+  \n+  if (CPP_OPTIONS (pfile)->dump_includes)\n+    pass_thru_directive (token, len, pfile, T_INCLUDE);\n \n-  fp = cpp_file_buffer (pfile);\n+  _cpp_execute_include (pfile, token, len, 0, 0);\n+  return 0;\n+}\n \n-  /* For #include_next, skip in the search path past the dir in which the\n-     containing file was found.  Treat files specified using an absolute path\n-     as if there are no more directories to search.  Treat the primary source\n-     file like any other included source, but generate a warning.  */\n-  if (skip_dirs && CPP_PREV_BUFFER (fp))\n-    {\n-      if (fp->ihash->foundhere != ABSOLUTE_PATH)\n-\tsearch_start = fp->ihash->foundhere->next;\n-    }\n-  else\n-    {\n-      if (skip_dirs)\n-\tcpp_warning (pfile, \"#include_next in primary source file\");\n-      \n-      if (angle_brackets)\n-\tsearch_start = CPP_OPTIONS (pfile)->bracket_include;\n-      else\n-        {\n-\t  if (!CPP_OPTIONS (pfile)->ignore_srcdir)\n-\t    {\n-\t      if (fp)\n-\t\tsearch_start = fp->actual_dir;\n-\t    }\n-\t  else\n-\t    search_start = CPP_OPTIONS (pfile)->quote_include;\n-\t}\n-    }\n+static int\n+do_import (pfile)\n+     cpp_reader *pfile;\n+{\n+  unsigned int len;\n+  char *token;\n+\n+  if (CPP_PEDANTIC (pfile))\n+    cpp_pedwarn (pfile, \"ANSI C does not allow `#import'\");\n \n-  if (!search_start)\n+  if (CPP_OPTIONS (pfile)->warn_import\n+      && !CPP_BUFFER (pfile)->system_header_p && !pfile->import_warning)\n     {\n-      cpp_error (pfile, \"No include path in which to find %s\", ftok);\n-      return 0;\n+      pfile->import_warning = 1;\n+      cpp_warning (pfile,\n+\t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n-  fd = _cpp_find_include_file (pfile, ftok, search_start, &ihash, &before);\n-\n-  if (fd == -2)\n-    return 0;\n+  len = parse_include (pfile, dtable[T_IMPORT].name);\n+  token = alloca (len + 1);\n+  strcpy (token, CPP_PWRITTEN (pfile));\n   \n-  if (fd == -1)\n-    {\n-      if (CPP_OPTIONS (pfile)->print_deps_missing_files\n-\t  && CPP_PRINT_DEPS (pfile) > (angle_brackets ||\n-\t\t\t\t       (pfile->system_include_depth > 0)))\n-        {\n-\t  if (!angle_brackets)\n-\t    deps_add_dep (pfile->deps, ftok);\n-\t  else\n-\t    {\n-\t      char *p;\n-\t      struct file_name_list *ptr;\n-\t      /* If requested as a system header, assume it belongs in\n-\t\t the first system header directory. */\n-\t      if (CPP_OPTIONS (pfile)->bracket_include)\n-\t        ptr = CPP_OPTIONS (pfile)->bracket_include;\n-\t      else\n-\t        ptr = CPP_OPTIONS (pfile)->quote_include;\n-\n-\t      p = (char *) alloca (strlen (ptr->name)\n-\t\t\t\t   + strlen (ftok) + 2);\n-\t      if (*ptr->name != '\\0')\n-\t        {\n-\t\t  strcpy (p, ptr->name);\n-\t\t  strcat (p, \"/\");\n-\t        }\n-\t      strcat (p, ftok);\n-\t      deps_add_dep (pfile->deps, p);\n-\t    }\n-\t}\n-      /* If -M was specified, and this header file won't be added to\n-\t the dependency list, then don't count this as an error,\n-\t because we can still produce correct output.  Otherwise, we\n-\t can't produce correct output, because there may be\n-\t dependencies we need inside the missing file, and we don't\n-\t know what directory this missing file exists in. */\n-      else if (CPP_PRINT_DEPS (pfile)\n-\t       && (CPP_PRINT_DEPS (pfile)\n-\t\t   <= (angle_brackets || (pfile->system_include_depth > 0))))\n-\tcpp_warning (pfile, \"No include path in which to find %s\", ftok);\n-      else\n-\tcpp_error_from_errno (pfile, ftok);\n-\n-      return 0;\n-    }\n+  if (CPP_OPTIONS (pfile)->dump_includes)\n+    pass_thru_directive (token, len, pfile, T_IMPORT);\n \n-  /* For -M, add the file to the dependencies on its first inclusion. */\n-  if (!before && (CPP_PRINT_DEPS (pfile)\n-\t\t  > (angle_brackets || (pfile->system_include_depth > 0))))\n-    deps_add_dep (pfile->deps, ihash->name);\n+  _cpp_execute_include (pfile, token, len, 1, 0);\n+  return 0;\n+}\n \n-  /* Handle -H option.  */\n-  if (CPP_OPTIONS(pfile)->print_include_names)\n-    {\n-      fp = CPP_BUFFER (pfile);\n-      while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n-\tputc ('.', stderr);\n-      fprintf (stderr, \" %s\\n\", ihash->name);\n-    }\n+static int\n+do_include_next (pfile)\n+     cpp_reader *pfile;\n+{\n+  unsigned int len;\n+  char *token;\n+  struct file_name_list *search_start = 0;\n \n-  /* Actually process the file */\n+  if (CPP_PEDANTIC (pfile))\n+    cpp_pedwarn (pfile, \"ANSI C does not allow `#include_next'\");\n+  \n+  len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name);\n \n-  if (importing)\n-    ihash->control_macro = (const U_CHAR *) \"\";\n+  token = alloca (len + 1);\n+  strcpy (token, CPP_PWRITTEN (pfile));\n   \n-  if (_cpp_read_include_file (pfile, fd, ihash))\n+  if (CPP_OPTIONS (pfile)->dump_includes)\n+    pass_thru_directive (token, len, pfile, T_INCLUDE_NEXT);\n+\n+  /* For #include_next, skip in the search path past the dir in which the\n+     containing file was found.  Treat files specified using an absolute path\n+     as if there are no more directories to search.  Treat the primary source\n+     file like any other included source, but generate a warning.  */\n+  if (CPP_PREV_BUFFER (CPP_BUFFER (pfile)))\n     {\n-      _cpp_output_line_command (pfile, enter_file);\n-      if (angle_brackets)\n-\tpfile->system_include_depth++;   /* Decremented in file_cleanup. */\n+      if (CPP_BUFFER (pfile)->ihash->foundhere != ABSOLUTE_PATH)\n+\tsearch_start = CPP_BUFFER (pfile)->ihash->foundhere->next;\n     }\n+  else\n+    cpp_warning (pfile, \"#include_next in primary source file\");\n+\n+  _cpp_execute_include (pfile, token, len, 0, search_start);\n   return 0;\n }\n \n@@ -704,9 +616,8 @@ read_line_number (pfile, num)\n    include filename.  That means no escape handling.  */\n \n static int\n-do_line (pfile, keyword)\n+do_line (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   int new_lineno;\n@@ -823,9 +734,8 @@ do_line (pfile, keyword)\n    According to the C standard, it is not an error to undef\n    something that has no definitions. */\n static int\n-do_undef (pfile, keyword)\n+do_undef (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword;\n {\n   int len;\n   HASHNODE **slot;\n@@ -867,8 +777,8 @@ do_undef (pfile, keyword)\n       HASHNODE *hp = *slot;\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n-      if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (name, len, pfile, keyword);\n+      if (CPP_OPTIONS (pfile)->debug_output)\n+\tpass_thru_directive (name, len, pfile, T_UNDEF);\n       if (hp->type == T_POISON)\n \tcpp_error (pfile, \"cannot undefine poisoned `%s'\", hp->name);\n       else \n@@ -890,9 +800,8 @@ do_undef (pfile, keyword)\n  */\n \n static int\n-do_error (pfile, keyword)\n+do_error (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   const U_CHAR *text, *limit;\n \n@@ -911,9 +820,8 @@ do_error (pfile, keyword)\n  */\n \n static int\n-do_warning (pfile, keyword)\n+do_warning (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   const U_CHAR *text, *limit;\n \n@@ -932,9 +840,8 @@ do_warning (pfile, keyword)\n /* Report program identification.  */\n \n static int\n-do_ident (pfile, keyword)\n+do_ident (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   long old_written = CPP_WRITTEN (pfile);\n \n@@ -977,9 +884,8 @@ static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n static int do_pragma_default\t\tPARAMS ((cpp_reader *));\n \n static int\n-do_pragma (pfile, keyword)\n+do_pragma (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   long here, key;\n   U_CHAR *buf;\n@@ -1154,20 +1060,21 @@ do_pragma_poison (pfile)\n   return !writeit;\n }\n  \n-#ifdef SCCS_DIRECTIVE\n /* Just ignore #sccs, on systems where we define it at all.  */\n-\n static int\n-do_sccs (pfile, keyword)\n+do_sccs (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n+#ifdef SCCS_DIRECTIVE\n   if (CPP_PEDANTIC (pfile))\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#sccs'\");\n+#else\n+  cpp_error (pfile, \"undefined or invalid # directive `sccs'\");\n+#endif\n   _cpp_skip_rest_of_line (pfile);\n   return 0;\n }\n-#endif\n+\n \n /* We've found an `#if' directive.  If the only thing before it in\n    this file is white space, and if it is of the form\n@@ -1249,9 +1156,8 @@ detect_if_not_defined (pfile)\n  */\n \n static int\n-do_if (pfile, keyword)\n+do_if (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *control_macro = detect_if_not_defined (pfile);\n   int value = _cpp_parse_expr (pfile);\n@@ -1265,9 +1171,8 @@ do_if (pfile, keyword)\n  */\n \n static int\n-do_elif (pfile, keyword)\n+do_elif (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n     {\n@@ -1276,7 +1181,7 @@ do_elif (pfile, keyword)\n     }\n   else\n     {\n-      if (pfile->if_stack->type != T_IF && pfile->if_stack->type != T_ELIF)\n+      if (pfile->if_stack->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"`#elif' after `#else'\");\n \t  cpp_error_with_line (pfile, pfile->if_stack->lineno, -1,\n@@ -1300,72 +1205,90 @@ do_elif (pfile, keyword)\n   return 0;\n }\n \n-/*\n- * routine to handle ifdef/ifndef.  Try to look up the symbol,\n- * then do or don't skip to the #endif/#else/#elif depending\n- * on what directive is actually being processed.\n- */\n+/* Parse an #ifdef or #ifndef directive.  Returns 1 for defined, 0 for\n+   not defined; the macro tested is left in the token buffer (but\n+   popped).  */\n \n static int\n-do_ifdef (pfile, keyword)\n+parse_ifdef (pfile, name)\n      cpp_reader *pfile;\n-     const struct directive *keyword;\n+     const char *name;\n {\n-  int skip;\n   U_CHAR *ident;\n-  int ident_length;\n+  unsigned int len;\n   enum cpp_token token;\n-  int start_of_file = 0;\n-  U_CHAR *control_macro = 0;\n-  int old_written = CPP_WRITTEN (pfile);\n-\n-  /* Detect a #ifndef at start of file (not counting comments).  */\n-  if (keyword->type == T_IFNDEF)\n-    start_of_file = pfile->only_seen_white == 2;\n+  long old_written = CPP_WRITTEN (pfile);\n+  int defined;\n \n   pfile->no_macro_expand++;\n   token = _cpp_get_directive_token (pfile);\n   pfile->no_macro_expand--;\n \n   ident = pfile->token_buffer + old_written;\n-  ident_length = CPP_WRITTEN (pfile) - old_written;\n-  CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n+  len = CPP_WRITTEN (pfile) - old_written;\n \n-  if (token == CPP_VSPACE || token == CPP_POP || token == CPP_EOF)\n+  if (token == CPP_VSPACE)\n     {\n-      skip = (keyword->type == T_IFDEF);\n       if (! CPP_TRADITIONAL (pfile))\n-\tcpp_pedwarn (pfile, \"`#%s' with no argument\", keyword->name);\n+\tcpp_pedwarn (pfile, \"`#%s' with no argument\", name);\n+      defined = 0;\n+      goto done;\n     }\n   else if (token == CPP_NAME)\n     {\n-      skip = cpp_defined (pfile, ident, ident_length);\n-      if (keyword->type == T_IFDEF)\n-\tskip = !skip;\n-\n-      if (start_of_file && !skip)\n-\t{\n-\t  control_macro = (U_CHAR *) xmalloc (ident_length + 1);\n-\t  memcpy (control_macro, ident, ident_length + 1);\n-\t}\n+      defined = cpp_defined (pfile, ident, len);\n+      CPP_NUL_TERMINATE (pfile);\n+      CPP_ADJUST_WRITTEN (pfile, 1);\n     }\n   else\n     {\n-      skip = (keyword->type == T_IFDEF);\n+      defined = 0;\n       if (! CPP_TRADITIONAL (pfile))\n-\tcpp_error (pfile, \"`#%s' with invalid argument\", keyword->name);\n+\tcpp_error (pfile, \"`#%s' with invalid argument\", name);\n     }\n \n   if (!CPP_TRADITIONAL (pfile))\n-    { int c;\n-      _cpp_skip_hspace (pfile);\n-      c = PEEKC ();\n-      if (c != EOF && c != '\\n')\n-\tcpp_pedwarn (pfile, \"garbage at end of `#%s' argument\", keyword->name);\n+    {\n+      if (_cpp_get_directive_token (pfile) == CPP_VSPACE)\n+\tgoto done;\n+      \n+      cpp_pedwarn (pfile, \"garbage at end of `#%s' argument\", name);\n     }\n   _cpp_skip_rest_of_line (pfile);\n+  \n+ done:\n+  CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n+  return defined;\n+}\n \n-  conditional_skip (pfile, skip, T_IF, control_macro);\n+/* #ifdef is dead simple.  */\n+\n+static int\n+do_ifdef (pfile)\n+     cpp_reader *pfile;\n+{\n+  int skip = ! parse_ifdef (pfile, dtable[T_IFDEF].name);\n+  conditional_skip (pfile, skip, T_IFDEF, 0);\n+  return 0;\n+}\n+\n+/* #ifndef is a tad more complex, because we need to check for a\n+   no-reinclusion wrapper.  */\n+\n+static int\n+do_ifndef (pfile)\n+     cpp_reader *pfile;\n+{\n+  int start_of_file, skip;\n+  U_CHAR *control_macro = 0;\n+\n+  start_of_file = pfile->only_seen_white == 2;\n+  skip = parse_ifdef (pfile, dtable[T_IFNDEF].name);\n+\n+  if (start_of_file && !skip)\n+    control_macro = xstrdup (CPP_PWRITTEN (pfile));\n+\n+  conditional_skip (pfile, skip, T_IFNDEF, control_macro);\n   return 0;\n }\n \n@@ -1378,7 +1301,7 @@ static void\n conditional_skip (pfile, skip, type, control_macro)\n      cpp_reader *pfile;\n      int skip;\n-     enum node_type type;\n+     int type;\n      U_CHAR *control_macro;\n {\n   IF_STACK *temp;\n@@ -1410,60 +1333,65 @@ consider_directive_while_skipping (pfile, stack)\n     cpp_reader *pfile;\n     IF_STACK *stack; \n {\n-  long ident_len, ident;\n+  long ident;\n   const struct directive *kt;\n+  int i;\n+  unsigned int len;\n   IF_STACK *temp;\n     \n   _cpp_skip_hspace (pfile);\n \n   ident = CPP_WRITTEN (pfile);\n   _cpp_parse_name (pfile, GETC());\n-  ident_len = CPP_WRITTEN (pfile) - ident;\n+  len = CPP_WRITTEN (pfile) - ident;\n \n   CPP_SET_WRITTEN (pfile, ident);\n \n-  for (kt = directive_table; kt->length >= 0; kt++)\n-    if (kt->length == ident_len\n-\t&& strncmp (pfile->token_buffer + ident, kt->name, kt->length) == 0)\n-      switch (kt->type)\n-\t{\n-\tcase T_IF:\n-\tcase T_IFDEF:\n-\tcase T_IFNDEF:\n+  for (i = 0; i < N_DIRECTIVES; i++)\n+    {\n+      kt = &dtable[i];\n+      if (kt->length == len\n+\t  && strncmp (pfile->token_buffer + ident, kt->name, kt->length) == 0)\n+\tswitch (i)\n+\t  {\n+\t  case T_IF:\n+\t  case T_IFDEF:\n+\t  case T_IFNDEF:\n \t    temp = (IF_STACK *) xmalloc (sizeof (IF_STACK));\n \t    temp->next = pfile->if_stack;\n \t    pfile->if_stack = temp;\n-\t    temp->type = kt->type;\n+\t    temp->type = i;\n \t    return 0;\n \n-\tcase T_ELSE:\n+\t  case T_ELSE:\n \t    if (pfile->if_stack != stack)\n-\t      validate_else (pfile, \"#else\");\n+\t      validate_else (pfile, dtable[i].name);\n \t    /* fall through */\n-\tcase T_ELIF:\n+\t  case T_ELIF:\n \t    if (pfile->if_stack == stack)\n \t      return 1;\n \t    else\n \t      {\n-\t\tpfile->if_stack->type = kt->type;\n+\t\tpfile->if_stack->type = i;\n \t\treturn 0;\n \t      }\n \n-\t    case T_ENDIF:\n-\t\tif (pfile->if_stack != stack)\n-\t\t  validate_else (pfile, \"#endif\");\n+\t  case T_ENDIF:\n+\t    if (pfile->if_stack != stack)\n+\t      validate_else (pfile, dtable[i].name);\n \n-\t\tif (pfile->if_stack == stack)\n-\t\t  return 1;\n+\t    if (pfile->if_stack == stack)\n+\t      return 1;\n \t\t    \n-\t\ttemp = pfile->if_stack;\n-\t\tpfile->if_stack = temp->next;\n-\t\tfree (temp);\n-\t\treturn 0;\n+\t    temp = pfile->if_stack;\n+\t    pfile->if_stack = temp->next;\n+\t    free (temp);\n+\t    return 0;\n \n-\t    default:\n-\t\treturn 0;\n-\t    }\n+\t  default:\n+\t    return 0;\n+\t  }\n+    }\n \n     /* Don't let erroneous code go by.\t*/\n     if (!CPP_OPTIONS (pfile)->lang_asm && CPP_PEDANTIC (pfile))\n@@ -1529,11 +1457,10 @@ skip_if_group (pfile)\n  */\n \n static int\n-do_else (pfile, keyword)\n+do_else (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  validate_else (pfile, \"#else\");\n+  validate_else (pfile, dtable[T_ELSE].name);\n   _cpp_skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n@@ -1547,7 +1474,7 @@ do_else (pfile, keyword)\n \t if it has a #else clause.  */\n       pfile->if_stack->control_macro = 0;\n \n-      if (pfile->if_stack->type != T_IF && pfile->if_stack->type != T_ELIF)\n+      if (pfile->if_stack->type == T_ELSE)\n \t{\n \t  cpp_error (pfile, \"`#else' after `#else'\");\n \t  cpp_error_with_line (pfile, pfile->if_stack->lineno, -1,\n@@ -1571,11 +1498,10 @@ do_else (pfile, keyword)\n  */\n \n static int\n-do_endif (pfile, keyword)\n+do_endif (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  validate_else (pfile, \"#endif\");\n+  validate_else (pfile, dtable[T_ENDIF].name);\n   _cpp_skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n@@ -1631,26 +1557,7 @@ validate_else (pfile, directive)\n   _cpp_skip_hspace (pfile);\n   if (PEEKC () != '\\n')\n     cpp_pedwarn (pfile,\n-\t\t \"text following `%s' violates ANSI standard\", directive);\n-}\n-\n-/* Convert T_IF, etc. to a string.   Used in error messages.  */\n-static const char *\n-if_directive_name (pfile, ifs)\n-     cpp_reader *pfile;\n-     struct if_stack *ifs;\n-{\n-  switch (ifs->type)\n-    {\n-    case T_IF:\t    return \"#if\";\n-    case T_IFDEF:   return \"#ifdef\";\n-    case T_IFNDEF:  return \"#ifndef\";\n-    case T_ELIF:    return \"#elif\";\n-    case T_ELSE:    return \"#else\";\n-    default:\n-      cpp_ice (pfile, \"impossible if_stack->type value %d\", ifs->type);\n-      return \"unknown\";\n-    }\n+\t\t \"text following `#%s' violates ANSI standard\", directive);\n }\n \n void\n@@ -1666,8 +1573,8 @@ _cpp_handle_eof (pfile)\n        ifs = nifs)\n     {\n       cpp_error_with_line (pfile, ifs->lineno, -1,\n-\t\t\t   \"unterminated `%s' conditional\",\n-\t\t\t   if_directive_name (pfile, ifs));\n+\t\t\t   \"unterminated `#%s' conditional\",\n+\t\t\t   dtable[ifs->type].name);\n \n       nifs = ifs->next;\n       free (ifs);\n@@ -1690,9 +1597,8 @@ _cpp_handle_eof (pfile)\n }\n \n static int\n-do_assert (pfile, keyword)\n+do_assert (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   U_CHAR *sym;\n   int ret, c;\n@@ -1759,9 +1665,8 @@ do_assert (pfile, keyword)\n }\n \n static int\n-do_unassert (pfile, keyword)\n+do_unassert (pfile)\n      cpp_reader *pfile;\n-     const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n   int c, ret;\n   U_CHAR *sym;\n@@ -1866,7 +1771,7 @@ cpp_define (pfile, str)\n \n   if (cpp_push_buffer (pfile, buf, count - 1) != NULL)\n     {\n-      do_define (pfile, NULL);\n+      do_define (pfile);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1885,7 +1790,7 @@ cpp_undef (pfile, macro)\n   buf[len + 1] = '\\0';\n   if (cpp_push_buffer (pfile, buf, len + 1))\n     {\n-      do_undef (pfile, NULL);\n+      do_undef (pfile);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1898,7 +1803,7 @@ cpp_assert (pfile, str)\n {\n   if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n     {\n-      do_assert (pfile, NULL);\n+      do_assert (pfile);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -1911,7 +1816,7 @@ cpp_unassert (pfile, str)\n {\n   if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n     {\n-      do_unassert (pfile, NULL);\n+      do_unassert (pfile);\n       cpp_pop_buffer (pfile);\n     }\n }  "}]}