{"sha": "91063b51383fe008c4509822a66761f6fc7cf334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwNjNiNTEzODNmZTAwOGM0NTA5ODIyYTY2NzYxZjZmYzdjZjMzNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-23T14:53:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-23T14:53:28Z"}, "message": "cplus-dem.c (work_stuff): Replace const_type and volatile_type with type_quals.\n\n\t* cplus-dem.c (work_stuff): Replace const_type and volatile_type\n\twith type_quals.\n\t(TYPE_UNQUALIFIED): New macro.\n\t(TYPE_QUAL_CONST): Likewise.\n\t(TYPE_QUAL_VOLATILE): Likewise.\n\t(TYPE_QUAL_RESTRICT): Likewise.\n\t(code_for_qualifier): New function.\n\t(qualifier_string): Likewise.\n\t(demangle_qualifier): Likewise.\n\t(internal_cplus_demangle): Use them.\n\t(demangle_signature): Likewise.\n\t(demangle_template_value_parm): Likewise.\n\t(do_type): Likewise.\n\t(demangle_fund_type)): Likewise.\n\t* Makefile.in (hash.h): Run gperf when necessary.\n\t* cp-tree.h (CP_TYPE_READONLY): Remove.\n\t(CP_TYPE_VOLATILE): Likewise.\n\t(CP_TYPE_QUALS): New macro.\n\t(CP_TYPE_CONST_P): Likewise.\n\t(CP_TYPE_VOLATILE_P): Likewise.\n\t(CP_TYPE_RESTRICT_P): Likewise.\n\t(CP_TYPE_CONST_NON_VOLATILE_P): Likewise.\n\t(cp_build_type_variant): Rename to ...\n\t(cp_build_qualified_type): New function.\n\t(c_apply_type_quals_to_decl): Declare.\n\t(SIGNATURE_POINTER_NAME_FORMAT): Modify to allow `restrict'.\n\t(SIGNATURE_REFERENCE_NAME_FORMAT): Likewise.\n\t(cp_type_qual_from_rid): New function.\n\t(compparms): Remove unused parameter.  All callers changed.\n\t(cp_type_quals): New function.\n\t(at_least_as_qualified_p): Likewise.\n\t(more_qualified_p): Likewise.\n\t* call.c (standard_conversion): Replace calls to\n\tcp_build_type_variant with cp_build_qualified_type.  Use\n\tCP_TYPE_QUALS to get qualifiers and at_least_as_qualified_p to\n\tcompare them.  Use CP_TYPE_* macros to check qualifiers.\n\t(reference_binding): Likewise.\n\t(implicit_conversion): Likewise.\n\t(add_builtin_candidates): Likewise.\n\t(build_over_call): Likewise.\n\t* class.c (overrides): Compare all qualifiers, not just `const',\n\ton method declarations.\n\t* cvt.c (convert_to_reference): More CP_TYPE_QUALS conversion, etc.\n\t(convert_pointer_to_real): Likewise.\n\t(type_promotes_to): Likewise.\n\t* decl.c (check_for_uninitialized_const_var): New function.\n\t(init_decl_processing): More CP_TYPE_QUALS conversion, etc.\n\t(cp_finish_decl): Use check_for_uninitialized_const_var.\n\t(grokdeclarator): More CP_TYPE_QUALS conversion, etc.  Update to\n\thandle `restrict'.\n\t(grok_ctor_properties): Likewise.\n\t(grok_op_properties): Likewise.\n\t(start_function): Likewise.\n\t(rever_static_member_fn): Likewise.\n\t* decl2.c (grok_method_quals): Likewise.\n\t(grokfield): Likewise.\n\t* error.c (dump_readonly_or_volatile): Rename to ...\n\t(dump_qualifiers): New function.  Handle `restrict'.\n\t(dump_type_real): Use it.\n\t(dump_aggr_type): Likewise.\n\t(dump_type_prefix): Likewise.\n\t(dump_type_suffix): Likewise.\n\t(dump_function_decl): Likewise.\n\t(cv_as_string): Likewise.\n\t* gxx.gperf: Add __restrict and __restrict__.\n\t* gxxint.texi: Document `u' as used for `__restrict', and a few\n\tother previously undocumented codes.\n\t* hash.h: Regenerated.\n\t* init.c (expand_aggr_init): More CP_TYPE_QUALS conversion, etc.\n\t(build_member_call): Likewise.\n\t(build_new_1): Likewise.\n\t* lex.c (init_parse): Add entry for RID_RESTRICT.\n\t(cons_up_default_function): More CP_TYPE_QUALS conversion, etc.\n\t(cp_type_qual_from_rid): Define.\n\t* lex.h (enum rid): Add RID_RESTRICT.\n\t* method.c (process_modifiers): Deal with `restrict'.\n\t* parse.y (primary): More CP_TYPE_QUALS conversion, etc.\n\t* parse.c: Regenerated.\n\t* pt.c (convert_nontype_argument): More CP_TYPE_QUALS conversion, etc.\n\t(tsubst_aggr_type): Likewise.\n\t(tsubst): Likewise.\n\t(check_cv_quals_for_unify): Likewise.\n\t(unify): Likewise.\n\t* rtti.c (init_rtti_processing): Likewise.\n\t(build_headof): Likewise.\n\t(get_tinfo_var): Likewise.\n\t(buidl_dynamic_cast_1): Likewise.  Fix `volatile' handling.\n\t(expand_class_desc): Likewise.\n\t(expand_attr_desc): Likewise.\n\t(synthesize_tinfo_fn): Likewise.\n\t* search.c (covariant_return_p): Likewise.  Fix `volatile' handling.\n\t(get_matching_virtual): Likewise.\n\t(expand_upcast_fixups): Likewise.\n\t* sig.c (build_signature_pointer_or_reference_name): Take\n\ttype_quals, not constp and volatilep.\n\t(build_signature_pointer_or_reference_type): Likewise.\n\t(match_method_types): More CP_TYPE_QUALS conversion, etc.\n\t(build_signature_pointer_constructor): Likewise.\n\t(build_signature_method_call): Likewise.\n\t* tree.c (build_cplus_array_type): Likewise.\n\t(cp_build_type_variant): Rename to ...\n\t(cp_build_qualified_type): New function.  Deal with `__restrict'.\n\t(canonical_type_variant): More CP_TYPE_QUALS conversion, etc.\n\t(build_exception_variant): Likewise.\n\t(mapcar): Likewise.\n\t* typeck.c (qualif_type): Likewise.\n\t(common_type): Likewise.\n\t(comptypes): Likewise.\n\t(comp_cv_target_types): Likewise.\n\t(at_least_as_qualified_p): Define.\n\t(more_qualified_p): Likewise.\n\t(comp_cv_qualification): More CP_TYPE_QUALS conversion, etc.\n\t(compparms): Likewise.\n\t(inline_conversion): Likewise.\n\t(string_conv_p): Likewise.\n\t(build_component_ref): Likewise.\n\t(build_indirect_ref): Likewise.\n\t(build_array_ref): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_conditional_expr): Likewise.\n\t(build_static_cast): Likewise.\n\t(build_c_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\t(convert_For_assignment): Likewise.\n\t(comp_ptr_ttypes_real): Likewise.\n\t(cp_type_quals): New function.\n\nFrom-SVN: r23258", "tree": {"sha": "59ab8d0c532ee1fb3d757a3a6e888863d46c9e6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59ab8d0c532ee1fb3d757a3a6e888863d46c9e6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91063b51383fe008c4509822a66761f6fc7cf334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91063b51383fe008c4509822a66761f6fc7cf334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91063b51383fe008c4509822a66761f6fc7cf334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91063b51383fe008c4509822a66761f6fc7cf334/comments", "author": null, "committer": null, "parents": [{"sha": "7b16da78b147daa91116668c6e03b111685f8c1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b16da78b147daa91116668c6e03b111685f8c1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b16da78b147daa91116668c6e03b111685f8c1f"}], "stats": {"total": 9015, "additions": 4638, "deletions": 4377}, "files": [{"sha": "e5e8def2c4fa1b0b260238d194a57d26c59568c5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1,3 +1,120 @@\n+1998-10-23  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* Makefile.in (hash.h): Run gperf when necessary.\n+\n+\t* cp-tree.h (CP_TYPE_READONLY): Remove.\n+\t(CP_TYPE_VOLATILE): Likewise.\n+\t(CP_TYPE_QUALS): New macro.\n+\t(CP_TYPE_CONST_P): Likewise.\n+\t(CP_TYPE_VOLATILE_P): Likewise.\n+\t(CP_TYPE_RESTRICT_P): Likewise.\n+\t(CP_TYPE_CONST_NON_VOLATILE_P): Likewise.\n+\t(cp_build_type_variant): Rename to ...\n+\t(cp_build_qualified_type): New function.\n+\t(c_apply_type_quals_to_decl): Declare.\n+\t(SIGNATURE_POINTER_NAME_FORMAT): Modify to allow `restrict'.\n+\t(SIGNATURE_REFERENCE_NAME_FORMAT): Likewise.\n+\t(cp_type_qual_from_rid): New function.\n+\t(compparms): Remove unused parameter.  All callers changed.\n+\t(cp_type_quals): New function.\n+\t(at_least_as_qualified_p): Likewise.\n+\t(more_qualified_p): Likewise.\n+\t\n+\t* call.c (standard_conversion): Replace calls to\n+\tcp_build_type_variant with cp_build_qualified_type.  Use\n+\tCP_TYPE_QUALS to get qualifiers and at_least_as_qualified_p to\n+\tcompare them.  Use CP_TYPE_* macros to check qualifiers.\n+\t(reference_binding): Likewise.\n+\t(implicit_conversion): Likewise.\n+\t(add_builtin_candidates): Likewise.\n+\t(build_over_call): Likewise.\n+\t* class.c (overrides): Compare all qualifiers, not just `const',\n+\ton method declarations.\n+\t* cvt.c (convert_to_reference): More CP_TYPE_QUALS conversion, etc.\n+\t(convert_pointer_to_real): Likewise.\n+\t(type_promotes_to): Likewise.\n+\t* decl.c (check_for_uninitialized_const_var): New function.\n+\t(init_decl_processing): More CP_TYPE_QUALS conversion, etc.\n+\t(cp_finish_decl): Use check_for_uninitialized_const_var.\n+\t(grokdeclarator): More CP_TYPE_QUALS conversion, etc.  Update to\n+\thandle `restrict'.\n+\t(grok_ctor_properties): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t(start_function): Likewise.\n+\t(rever_static_member_fn): Likewise.\n+\t* decl2.c (grok_method_quals): Likewise.\n+\t(grokfield): Likewise.\n+\t* error.c (dump_readonly_or_volatile): Rename to ...\n+\t(dump_qualifiers): New function.  Handle `restrict'.\n+\t(dump_type_real): Use it.\n+\t(dump_aggr_type): Likewise.\n+\t(dump_type_prefix): Likewise.\n+\t(dump_type_suffix): Likewise.\n+\t(dump_function_decl): Likewise.\n+\t(cv_as_string): Likewise.\n+\t* gxx.gperf: Add __restrict and __restrict__.\n+\t* gxxint.texi: Document `u' as used for `__restrict', and a few\n+\tother previously undocumented codes.\n+\t* hash.h: Regenerated.\n+\t* init.c (expand_aggr_init): More CP_TYPE_QUALS conversion, etc.\n+\t(build_member_call): Likewise.\n+\t(build_new_1): Likewise.\n+\t* lex.c (init_parse): Add entry for RID_RESTRICT.\n+\t(cons_up_default_function): More CP_TYPE_QUALS conversion, etc.\n+\t(cp_type_qual_from_rid): Define.\n+\t* lex.h (enum rid): Add RID_RESTRICT.\n+\t* method.c (process_modifiers): Deal with `restrict'.\n+\t* parse.y (primary): More CP_TYPE_QUALS conversion, etc.\n+\t* parse.c: Regenerated.\n+\t* pt.c (convert_nontype_argument): More CP_TYPE_QUALS conversion, etc.\n+\t(tsubst_aggr_type): Likewise.\n+\t(tsubst): Likewise.\n+\t(check_cv_quals_for_unify): Likewise.\n+\t(unify): Likewise.\n+\t* rtti.c (init_rtti_processing): Likewise.\n+\t(build_headof): Likewise.\n+\t(get_tinfo_var): Likewise.\n+\t(buidl_dynamic_cast_1): Likewise.  Fix `volatile' handling.\n+\t(expand_class_desc): Likewise.\n+\t(expand_attr_desc): Likewise.\n+\t(synthesize_tinfo_fn): Likewise.\n+\t* search.c (covariant_return_p): Likewise.  Fix `volatile' handling. \n+\t(get_matching_virtual): Likewise.\n+\t(expand_upcast_fixups): Likewise.\n+\t* sig.c (build_signature_pointer_or_reference_name): Take\n+\ttype_quals, not constp and volatilep.\n+\t(build_signature_pointer_or_reference_type): Likewise.\n+\t(match_method_types): More CP_TYPE_QUALS conversion, etc.\n+\t(build_signature_pointer_constructor): Likewise.\n+\t(build_signature_method_call): Likewise.\n+\t* tree.c (build_cplus_array_type): Likewise.\n+\t(cp_build_type_variant): Rename to ...\n+\t(cp_build_qualified_type): New function.  Deal with `__restrict'.\n+\t(canonical_type_variant): More CP_TYPE_QUALS conversion, etc.\n+\t(build_exception_variant): Likewise.\n+\t(mapcar): Likewise.\n+\t* typeck.c (qualif_type): Likewise.\n+\t(common_type): Likewise.\n+\t(comptypes): Likewise.\n+\t(comp_cv_target_types): Likewise.\n+\t(at_least_as_qualified_p): Define.\n+\t(more_qualified_p): Likewise.\n+\t(comp_cv_qualification): More CP_TYPE_QUALS conversion, etc.\n+\t(compparms): Likewise.\n+\t(inline_conversion): Likewise.\n+\t(string_conv_p): Likewise.\n+\t(build_component_ref): Likewise.\n+\t(build_indirect_ref): Likewise.\n+\t(build_array_ref): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_conditional_expr): Likewise.\n+\t(build_static_cast): Likewise.\n+\t(build_c_cast): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(convert_For_assignment): Likewise.\n+\t(comp_ptr_ttypes_real): Likewise.\n+\t(cp_type_quals): New function.\n+\t\n 1998-10-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cp-tree.h (CP_TYPE_READONLY): New macro to handle arrays."}, {"sha": "425bedd3dd2261b1eb975e37dc31503ae45c0a46", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -235,11 +235,10 @@ $(PARSE_C) : $(srcdir)/parse.y\n #\tcp $(PARSE_C) y.tab.c\n #\ttouch stamp-parse\n \n-# hash.h really depends on $(srcdir)/gxx.gperf.\n-# But this would screw things for people that don't have gperf,\n-# if gxx.gpref got touched, say.\n-# Thus you have to remove hash.h to force it to be re-made.\n-$(srcdir)/hash.h:\n+# We used to try to protect people from having to rerun gperf.  But,\n+# the C front-end already requires this if c-parse.gperf is changed,\n+# so we should be consistent.\n+$(srcdir)/hash.h: $(srcdir)/gxx.gperf\n \tgperf -L KR-C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word \\\n \t\t'-k1,4,7,$$' $(srcdir)/gxx.gperf >$(srcdir)/hash.h\n "}, {"sha": "94f62985b74a636ad7afb0f6af33e27c2012b855", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -843,9 +843,8 @@ standard_conversion (to, from, expr)\n \t       && ufcode != FUNCTION_TYPE)\n \t{\n \t  from = build_pointer_type\n-\t    (cp_build_type_variant (void_type_node,\n-\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n-\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from))));\n+\t    (cp_build_qualified_type (void_type_node, \n+\t\t\t\t      CP_TYPE_QUALS (TREE_TYPE (from))));\n \t  conv = build_conv (PTR_CONV, from, conv);\n \t}\n       else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n@@ -868,9 +867,9 @@ standard_conversion (to, from, expr)\n \t{\n \t  if (DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n \t    {\n-\t      from = cp_build_type_variant (TREE_TYPE (to),\n-\t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n-\t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n+\t      from = \n+\t\tcp_build_qualified_type (TREE_TYPE (to),\n+\t\t\t\t\t CP_TYPE_QUALS (TREE_TYPE (from)));\n \t      from = build_pointer_type (from);\n \t      conv = build_conv (PTR_CONV, from, conv);\n \t    }\n@@ -903,13 +902,11 @@ standard_conversion (to, from, expr)\n       if (! DERIVED_FROM_P (fbase, tbase)\n \t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n \t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n-\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)), 1)\n-\t  || TYPE_READONLY (fbase) != TYPE_READONLY (tbase)\n-\t  || TYPE_VOLATILE (fbase) != TYPE_VOLATILE (tbase))\n+\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)))\n+\t  || CP_TYPE_QUALS (fbase) != CP_TYPE_QUALS (tbase))\n \treturn 0;\n \n-      from = cp_build_type_variant (tbase, TYPE_READONLY (fbase),\n-\t\t\t\t    TYPE_VOLATILE (fbase));\n+      from = cp_build_qualified_type (tbase, CP_TYPE_QUALS (fbase));\n       from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n \t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n       from = build_ptrmemfunc_type (build_pointer_type (from));\n@@ -981,9 +978,7 @@ reference_binding (rto, rfrom, expr, flags)\n \t     || (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t\t && DERIVED_FROM_P (to, from)));\n \n-  if (lvalue && related\n-      && TYPE_READONLY (to) >= TYPE_READONLY (from)\n-      && TYPE_VOLATILE (to) >= TYPE_VOLATILE (from))\n+  if (lvalue && related && at_least_as_qualified_p (to, from))\n     {\n       conv = build1 (IDENTITY_CONV, from, expr);\n \n@@ -1012,14 +1007,12 @@ reference_binding (rto, rfrom, expr, flags)\n \t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n \t}\n       if (conv\n-\t  && ((! (TYPE_READONLY (to) && ! TYPE_VOLATILE (to)\n+\t  && ((! (CP_TYPE_CONST_NON_VOLATILE_P (to)\n \t\t  && (flags & LOOKUP_NO_TEMP_BIND) == 0))\n \t      /* If T1 is reference-related to T2, cv1 must be the same\n \t\t cv-qualification as, or greater cv-qualification than,\n \t\t cv2; otherwise, the program is ill-formed.  */\n-\t      || (related\n-\t\t  && (TYPE_READONLY (to) < TYPE_READONLY (from)\n-\t\t      || TYPE_VOLATILE (to) < TYPE_VOLATILE (from)))))\n+\t      || (related && !at_least_as_qualified_p (to, from))))\n \tICS_BAD_FLAG (conv) = 1;\n     }\n \n@@ -1071,8 +1064,7 @@ implicit_conversion (to, from, expr, flags)\n \t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n \t  if (cand)\n \t    {\n-\t      if (! TYPE_READONLY (TREE_TYPE (to))\n-\t\t  || TYPE_VOLATILE (TREE_TYPE (to)))\n+\t      if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (to)))\n \t\tICS_BAD_FLAG (cand->second_conv) = 1;\n \t      if (!conv || (ICS_BAD_FLAG (conv)\n \t\t\t    > ICS_BAD_FLAG (cand->second_conv)))\n@@ -1823,7 +1815,7 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \n \t      if (i == 0 && ref1\n \t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n-\t\t      || TYPE_READONLY (TREE_TYPE (type))))\n+\t\t      || CP_TYPE_CONST_P (TREE_TYPE (type))))\n \t\tcontinue;\n \n \t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n@@ -3223,17 +3215,9 @@ build_over_call (cand, args, flags)\n       tree argtype = TREE_TYPE (TREE_VALUE (arg));\n       tree t;\n       if (ICS_BAD_FLAG (TREE_VEC_ELT (convs, i)))\n-\t{\n-\t  int dv = (TYPE_VOLATILE (TREE_TYPE (parmtype))\n-\t\t    < TYPE_VOLATILE (TREE_TYPE (argtype)));\n-\t  int dc = (TYPE_READONLY (TREE_TYPE (parmtype))\n-\t\t    < TYPE_READONLY (TREE_TYPE (argtype)));\n-\t  char *p = (dv && dc ? \"const and volatile\"\n-\t\t              : dc ? \"const\" : dv ? \"volatile\" : \"\");\n-\n-\t  cp_error (\"passing `%T' as `this' argument of `%#D' discards %s\",\n-\t\t    TREE_TYPE (argtype), fn, p);\n-\t}\n+\tcp_error (\"passing `%T' as `this' argument of `%#D' discards qualifiers\",\n+\t\t  TREE_TYPE (argtype), fn);\n+\n       /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n \t X is called for an object that is not of type X, or of a type\n \t derived from X, the behavior is undefined."}, {"sha": "8141db183419375ff721cf4b573c261998f3919a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -2387,9 +2387,9 @@ overrides (fndecl, base_fndecl)\n #endif\n       types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n       base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n-      if ((TYPE_READONLY (TREE_TYPE (TREE_VALUE (base_types)))\n-\t   == TYPE_READONLY (TREE_TYPE (TREE_VALUE (types))))\n-\t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types), 3))\n+      if ((TYPE_QUALS (TREE_TYPE (TREE_VALUE (base_types)))\n+\t   == TYPE_QUALS (TREE_TYPE (TREE_VALUE (types))))\n+\t  && compparms (TREE_CHAIN (base_types), TREE_CHAIN (types)))\n \treturn 1;\n     }\n   return 0;"}, {"sha": "7ef0477f5b84640b188924cb3540c3fdf42d8940", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -514,15 +514,6 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* The _DECL for this _TYPE.  */\n #define TYPE_MAIN_DECL(NODE) (TYPE_STUB_DECL (TYPE_MAIN_VARIANT (NODE)))\n \n-#define CP_TYPE_READONLY(NODE)\t\t\t\\\n-  (TREE_CODE (NODE) == ARRAY_TYPE\t\t\\\n-   ? TYPE_READONLY (TREE_TYPE (NODE))\t\t\\\n-   : TYPE_READONLY (NODE))\n-#define CP_TYPE_VOLATILE(NODE)\t\t\t\\\n-  (TREE_CODE (NODE) == ARRAY_TYPE\t\t\\\n-   ? TYPE_VOLATILE (TREE_TYPE (NODE))\t\t\\\n-   : TYPE_VOLATILE (NODE))\n-\n /* Nonzero if T is a class (or struct or union) type.  Also nonzero\n    for template type parameters and typename types.  Despite its name,\n    this macro has nothing to do with the definition of aggregate given\n@@ -547,6 +538,33 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* True if this a \"Java\" type, defined in 'extern \"Java\"'. */\n #define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3(NODE)\n \n+/* The type qualifiers for this type, including the qualifiers on the\n+   elements for an array type.  */\n+#define CP_TYPE_QUALS(NODE)\t\t\t\\\n+  ((TREE_CODE (NODE) != ARRAY_TYPE) \t\t\\\n+   ? TYPE_QUALS (NODE) : cp_type_quals (NODE))\n+\n+/* Nonzero if this type is const-qualified.  */\n+#define CP_TYPE_CONST_P(NODE)\t\t\t\t\\\n+  (CP_TYPE_QUALS (NODE) & TYPE_QUAL_CONST)\n+\n+/* Nonzero if this type is volatile-qualified.  */\n+#define CP_TYPE_VOLATILE_P(NODE)\t\t\t\\\n+  (CP_TYPE_QUALS (NODE) & TYPE_QUAL_VOLATILE)\n+\n+/* Nonzero if this type is restrict-qualified.  \n+   FIXME: Does this make sense?  */\n+#define CP_TYPE_RESTRICT_P(NODE)\t\t\t\\\n+  (CP_TYPE_QUALS (NODE) & TYPE_QUAL_RESTRICT)\n+\n+/* Nonzero if this type is const-qualified, but not\n+   volatile-qualified.  Other qualifiers are ignored.  This macro is\n+   used to test whether or not it is OK to bind an rvalue to a\n+   reference.  */\n+#define CP_TYPE_CONST_NON_VOLATILE_P(NODE)\t\t\t\t\\\n+  ((CP_TYPE_QUALS (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))\t\\\n+   == TYPE_QUAL_CONST)\n+\n #define DELTA_FROM_VTABLE_ENTRY(ENTRY) \\\n   (!flag_vtable_thunks ? \\\n      TREE_VALUE (CONSTRUCTOR_ELTS (ENTRY)) \\\n@@ -1882,7 +1900,7 @@ extern void check_function_format\t\tPROTO((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n-extern tree cp_build_type_variant                PROTO((tree, int, int));\n+extern tree cp_build_qualified_type             PROTO((tree, int));\n extern tree canonical_type_variant              PROTO((tree));\n extern void c_expand_expr_stmt                  PROTO((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n@@ -1893,6 +1911,7 @@ extern void constant_expression_warning         PROTO((tree));\n extern tree convert_and_check\t\t\tPROTO((tree, tree));\n extern void overflow_warning\t\t\tPROTO((tree));\n extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n+extern void c_apply_type_quals_to_decl          PROTO((int, tree));\n \n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB\n@@ -2161,9 +2180,9 @@ extern int current_function_parms_stored;\n #define SIGNATURE_OPTR_NAME\t\"__optr\"\n #define SIGNATURE_SPTR_NAME\t\"__sptr\"\n #define SIGNATURE_POINTER_NAME\t\"__sp_\"\n-#define SIGNATURE_POINTER_NAME_FORMAT \"__%s%ssp_%s\"\n+#define SIGNATURE_POINTER_NAME_FORMAT \"__%s%s%ssp_%s\"\n #define SIGNATURE_REFERENCE_NAME \"__sr_\"\n-#define SIGNATURE_REFERENCE_NAME_FORMAT \"__%s%ssr_%s\"\n+#define SIGNATURE_REFERENCE_NAME_FORMAT \"__%s%s%ssr_%s\"\n \n #define SIGTABLE_PTR_TYPE\t\"__sigtbl_ptr_type\"\n #define SIGTABLE_NAME_FORMAT\t\"__st_%s_%s\"\n@@ -2815,6 +2834,7 @@ extern void add_defarg_fn\t\t\tPROTO((tree));\n extern void do_pending_defargs\t\t\tPROTO((void));\n extern int identifier_type\t\t\tPROTO((tree));\n extern void yyhook\t\t\t\tPROTO((int));\n+extern int cp_type_qual_from_rid                PROTO((tree));\n \n /* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n@@ -3122,7 +3142,7 @@ extern tree common_type\t\t\t\tPROTO((tree, tree));\n extern int compexcepttypes\t\t\tPROTO((tree, tree));\n extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n-extern int compparms\t\t\t\tPROTO((tree, tree, int));\n+extern int compparms\t\t\t\tPROTO((tree, tree));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern int comp_cv_qualification                PROTO((tree, tree));\n extern int comp_cv_qual_signature               PROTO((tree, tree));\n@@ -3176,6 +3196,9 @@ extern tree c_expand_start_case\t\t\tPROTO((tree));\n extern int comp_ptr_ttypes\t\t\tPROTO((tree, tree));\n extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n+extern int cp_type_quals                        PROTO((tree));\n+extern int at_least_as_qualified_p              PROTO((tree, tree));\n+extern int more_qualified_p                     PROTO((tree, tree));\n \n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));"}, {"sha": "105c4e7ac4b611ba7083d420ff257c6b2900d3c6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -444,13 +444,13 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t     initialize a reference, then the reference must be to a\n \t     non-volatile const type.  */\n \t  if (! real_lvalue_p (expr)\n-\t      && (!TYPE_READONLY (ttl) || TYPE_VOLATILE (ttl)))\n+\t      && !CP_TYPE_CONST_NON_VOLATILE_P (ttl))\n \t    {\n \t      char* msg;\n \n-\t      if (TYPE_VOLATILE (ttl) && decl)\n+\t      if (CP_TYPE_VOLATILE_P (ttl) && decl)\n \t\tmsg = \"initialization of volatile reference type `%#T'\";\n-\t      else if (TYPE_VOLATILE (ttl))\n+\t      else if (CP_TYPE_VOLATILE_P (ttl))\n \t\tmsg = \"conversion to volatile reference type `%#T'\";\n \t      else if (decl)\n \t\tmsg = \"initialization of non-const reference type `%#T'\";\n@@ -460,15 +460,10 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t      cp_error (msg, reftype);\n \t      cp_error (\"from rvalue of type `%T'\", intype);\n \t    }\n-\t  else if (! (convtype & CONV_CONST))\n-\t    {\n-\t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n-\t\tcp_error (\"conversion from `%T' to `%T' discards const\",\n-\t\t\t  ttr, reftype);\n-\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\tcp_error (\"conversion from `%T' to `%T' discards volatile\",\n-\t\t\t  ttr, reftype);\n-\t    }\n+\t  else if (! (convtype & CONV_CONST)\n+\t\t   && !at_least_as_qualified_p (ttl, ttr))\n+\t    cp_error (\"conversion from `%T' to `%T' discards qualifiers\",\n+\t\t      ttr, reftype);\n \t}\n \n       return build_up_reference (reftype, expr, flags);\n@@ -502,7 +497,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \treturn error_mark_node;\n       rval = build_up_reference (reftype, rval, flags);\n \n-      if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n+      if (rval && ! CP_TYPE_CONST_P (TREE_TYPE (reftype)))\n \tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n \t\t    reftype, intype);\n     }\n@@ -570,8 +565,8 @@ convert_pointer_to_real (binfo, expr)\n       binfo = NULL_TREE;\n     }\n \n-  ptr_type = cp_build_type_variant (type, TYPE_READONLY (TREE_TYPE (intype)),\n-\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (intype)));\n+  ptr_type = cp_build_qualified_type (type,\n+\t\t\t\t      CP_TYPE_QUALS (TREE_TYPE (intype)));\n   ptr_type = build_pointer_type (ptr_type);\n   if (ptr_type == TYPE_MAIN_VARIANT (intype))\n     return expr;\n@@ -1059,13 +1054,12 @@ tree\n type_promotes_to (type)\n      tree type;\n {\n-  int constp, volatilep;\n+  int type_quals;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  constp = TYPE_READONLY (type);\n-  volatilep = TYPE_VOLATILE (type);\n+  type_quals = CP_TYPE_QUALS (type);\n   type = TYPE_MAIN_VARIANT (type);\n \n   /* bool always promotes to int (not unsigned), even if it's the same\n@@ -1099,7 +1093,7 @@ type_promotes_to (type)\n   else if (type == float_type_node)\n     type = double_type_node;\n \n-  return cp_build_type_variant (type, constp, volatilep);\n+  return cp_build_qualified_type (type, type_quals);\n }\n \n /* The routines below this point are carefully written to conform to"}, {"sha": "448290bc707c12825084f88768bdb1f1a4069da4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 103, "deletions": 86, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -177,6 +177,7 @@ static void bad_specifiers PROTO((tree, char *, int, int, int, int,\n \t\t\t\t  int));\n static void lang_print_error_function PROTO((char *));\n static tree maybe_process_template_type_declaration PROTO((tree, int, struct binding_level*));\n+static void check_for_uninitialized_const_var PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -2567,7 +2568,7 @@ decls_match (newdecl, olddecl)\n \t      TREE_TYPE (newdecl) = TREE_TYPE (olddecl);\n \t    }\n \t  else\n-\t    types_match = compparms (p1, p2, 3);\n+\t    types_match = compparms (p1, p2);\n \t}\n       else\n \ttypes_match = 0;\n@@ -2769,7 +2770,7 @@ duplicate_decls (newdecl, olddecl)\n \t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n \t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n \t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),\n-\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))), 3)\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))\n \t\t   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n \t\t\t\t\t   DECL_TEMPLATE_PARMS (olddecl)))\n \t    {\n@@ -2788,7 +2789,7 @@ duplicate_decls (newdecl, olddecl)\n \t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 3))\n+\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n \t      cp_error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n@@ -5840,7 +5841,8 @@ init_decl_processing ()\n \n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n-    = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n+    = build_pointer_type (build_qualified_type (char_type_node, \n+\t\t\t\t\t\tTYPE_QUAL_CONST));\n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n #endif\n@@ -5870,7 +5872,8 @@ init_decl_processing ()\n \n   ptr_type_node = build_pointer_type (void_type_node);\n   const_ptr_type_node\n-    = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+    = build_pointer_type (build_qualified_type (void_type_node,\n+\t\t\t\t\t\tTYPE_QUAL_CONST)); \n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);\n #endif\n@@ -6199,14 +6202,15 @@ init_decl_processing ()\n       DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n       TREE_UNSIGNED (fields[3]) = 0;\n       TREE_CHAIN (fields[2]) = fields[3];\n-      vtable_entry_type = build_type_variant (vtable_entry_type, 1, 0);\n+      vtable_entry_type = build_qualified_type (vtable_entry_type,\n+\t\t\t\t\t\tTYPE_QUAL_CONST);\n     }\n   record_builtin_type (RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n \n   vtbl_type_node\n     = build_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n-  vtbl_type_node = cp_build_type_variant (vtbl_type_node, 1, 0);\n+  vtbl_type_node = build_qualified_type (vtbl_type_node, TYPE_QUAL_CONST);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_type_node);\n   vtbl_ptr_type_node = build_pointer_type (vtable_entry_type);\n   layout_type (vtbl_ptr_type_node);\n@@ -6245,7 +6249,8 @@ init_decl_processing ()\n       TREE_UNSIGNED (fields[5]) = 0;\n       TREE_CHAIN (fields[4]) = fields[5];\n \n-      sigtable_entry_type = build_type_variant (sigtable_entry_type, 1, 0);\n+      sigtable_entry_type = build_qualified_type (sigtable_entry_type, \n+\t\t\t\t\t\t  TYPE_QUAL_CONST);\n       record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n     }\n \n@@ -7000,6 +7005,25 @@ obscure_complex_init (decl, init)\n   return init;\n }\n \n+/* Issue an error message if DECL is an uninitialized const variable.  */\n+\n+static void\n+check_for_uninitialized_const_var (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  /* ``Unless explicitly declared extern, a const object does not have\n+     external linkage and must be initialized. ($8.4; $12.1)'' ARM\n+     7.1.6 */\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && TREE_CODE (type) != REFERENCE_TYPE\n+      && CP_TYPE_CONST_P (type)\n+      && !TYPE_NEEDS_CONSTRUCTING (type)\n+      && !DECL_INITIAL (decl))\n+    cp_error (\"uninitialized const `%D'\", decl);\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -7241,32 +7265,16 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t      decl);\n \t}\n \n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && !DECL_INITIAL (decl)\n-\t  && !TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && (TYPE_READONLY (type) || TREE_READONLY (decl)))\n-\tcp_error (\"uninitialized const `%D'\", decl);\n+      check_for_uninitialized_const_var (decl);\n \n       if (TYPE_SIZE (type) != NULL_TREE\n \t  && TYPE_NEEDS_CONSTRUCTING (type))\n \tinit = obscure_complex_init (decl, NULL_TREE);\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_CODE (type) != REFERENCE_TYPE\n-\t   && (TYPE_READONLY (type) || TREE_READONLY (decl)))\n-    {\n-      /* ``Unless explicitly declared extern, a const object does not have\n-\t external linkage and must be initialized. ($8.4; $12.1)'' ARM 7.1.6\n-\t However, if it's `const int foo = 1; const int foo;', don't complain\n-\t about the second decl, since it does have an initializer before.\n-\t We deliberately don't complain about arrays, because they're\n-\t supposed to be initialized by a constructor.  */\n-      if (! DECL_INITIAL (decl)\n-\t  && TREE_CODE (type) != ARRAY_TYPE\n-\t  && (!pedantic || !current_class_type))\n-\tcp_error (\"uninitialized const `%#D'\", decl);\n-    }\n \n+    }\n+  else\n+    check_for_uninitialized_const_var (decl);\n+  \n   /* For top-level declaration, the initial value was read in\n      the temporary obstack.  MAXINDEX, rtl, etc. to be made below\n      must go in the permanent obstack; but don't discard the\n@@ -8503,7 +8511,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   tree type = NULL_TREE;\n   int longlong = 0;\n   int constp;\n+  int restrictp;\n   int volatilep;\n+  int type_quals;\n   int virtualp, explicitp, friendp, inlinep, staticp;\n   int explicit_int = 0;\n   int explicit_char = 0;\n@@ -9065,8 +9075,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n       RIDBIT_RESET (RID_LONG, specbits);\n-      type = build_type_variant (long_double_type_node, TYPE_READONLY (type),\n-\t\t\t\t TYPE_VOLATILE (type));\n+      type = build_qualified_type (long_double_type_node, \n+\t\t\t\t   CP_TYPE_QUALS (type));\n     }\n \n   /* Check all other uses of type modifiers.  */\n@@ -9188,17 +9198,24 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (return_type == return_conversion \n       && (RIDBIT_SETP (RID_CONST, specbits)\n-\t  || RIDBIT_SETP (RID_VOLATILE, specbits)))\n-    cp_error (\"`operator %T' cannot be cv-qualified\",\n+\t  || RIDBIT_SETP (RID_VOLATILE, specbits)\n+\t  || RIDBIT_SETP (RID_RESTRICT, specbits)))\n+    cp_error (\"qualifiers are not allowed on declaration of `operator %T'\",\n \t      ctor_return_type);\n \n   /* Set CONSTP if this declaration is `const', whether by\n      explicit specification or via a typedef.\n      Likewise for VOLATILEP.  */\n \n-  constp = !!RIDBIT_SETP (RID_CONST, specbits) + CP_TYPE_READONLY (type);\n-  volatilep = !!RIDBIT_SETP (RID_VOLATILE, specbits) + CP_TYPE_VOLATILE (type);\n-  type = cp_build_type_variant (type, constp, volatilep);\n+  constp = !! RIDBIT_SETP (RID_CONST, specbits) + CP_TYPE_CONST_P (type);\n+  restrictp = \n+    !! RIDBIT_SETP (RID_RESTRICT, specbits) + CP_TYPE_RESTRICT_P (type);\n+  volatilep = \n+    !! RIDBIT_SETP (RID_VOLATILE, specbits) + CP_TYPE_VOLATILE_P (type);\n+  type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t| (volatilep ? TYPE_QUAL_VOLATILE : 0));\n+  type = cp_build_qualified_type (type, type_quals);\n   staticp = 0;\n   inlinep = !! RIDBIT_SETP (RID_INLINE, specbits);\n   virtualp = RIDBIT_SETP (RID_VIRTUAL, specbits);\n@@ -9275,16 +9292,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && IS_SIGNATURE (current_class_type)\n       && RIDBIT_NOTSETP (RID_TYPEDEF, specbits))\n     {\n-      if (constp)\n+      if (type_quals != TYPE_UNQUALIFIED)\n \t{\n-\t  error (\"`const' specified for signature member function `%s'\", name);\n-\t  constp = 0;\n-\t}\n-      if (volatilep)\n-\t{\n-\t  error (\"`volatile' specified for signature member function `%s'\",\n-\t\t name);\n-\t  volatilep = 0;\n+\t  error (\"type qualifiers specified for signature member function `%s'\", name);\n+\t  type_quals = TYPE_UNQUALIFIED;\n \t}\n       if (inlinep)\n \t{\n@@ -9634,9 +9645,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* Declaring a function type.\n \t       Make sure we have a valid type for the function to return.  */\n \n-\t    /* We now know that constp and volatilep don't apply to the\n+\t    /* We now know that the TYPE_QUALS don't apply to the\n                decl, but to its return type.  */\n-\t    constp = volatilep = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n \n \t    /* Warn about some types functions can't return.  */\n \n@@ -9844,9 +9855,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  /* Merge any constancy or volatility into the target type\n \t     for the pointer.  */\n \n-\t  /* We now know that constp and volatilep don't apply to the\n-\t     decl, but to the target of the pointer.  */\n-\t  constp = volatilep = 0;\n+\t  /* We now know that the TYPE_QUALS don't apply to the decl,\n+\t     but to the target of the pointer.  */\n+\t  type_quals = TYPE_UNQUALIFIED;\n \n \t  if (IS_SIGNATURE (type))\n \t    {\n@@ -9871,8 +9882,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t\ttype);\n \t\t  type = build_signature_pointer_type (type);\n \t\t}\n-\t      constp = 0;\n-\t      volatilep = 0;\n \t    }\n \t  else if (TREE_CODE (declarator) == ADDR_EXPR)\n \t    {\n@@ -9895,35 +9904,47 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    {\n \t      register tree typemodlist;\n \t      int erred = 0;\n+\n+\t      constp = 0;\n+\t      volatilep = 0;\n+\t      restrictp = 0;\n \t      for (typemodlist = TREE_TYPE (declarator); typemodlist;\n \t\t   typemodlist = TREE_CHAIN (typemodlist))\n \t\t{\n-\t\t  if (TREE_VALUE (typemodlist) == ridpointers[(int) RID_CONST])\n+\t\t  tree qualifier = TREE_VALUE (typemodlist);\n+\n+\t\t  if (qualifier == ridpointers[(int) RID_CONST])\n \t\t    constp++;\n-\t\t  else if (TREE_VALUE (typemodlist) == ridpointers[(int) RID_VOLATILE])\n+\t\t  else if (qualifier == ridpointers[(int) RID_VOLATILE])\n \t\t    volatilep++;\n+\t\t  else if (qualifier == ridpointers[(int) RID_RESTRICT])\n+\t\t    restrictp++;\n \t\t  else if (!erred)\n \t\t    {\n \t\t      erred = 1;\n-\t\t      error (\"invalid type modifier within %s declarator\",\n-\t\t\t     TREE_CODE (declarator) == ADDR_EXPR\n-\t\t\t     ? \"reference\" : \"pointer\");\n+\t\t      error (\"invalid type modifier within pointer declarator\");\n \t\t    }\n \t\t}\n \t      if (constp > 1)\n \t\tpedwarn (\"duplicate `const'\");\n \t      if (volatilep > 1)\n \t\tpedwarn (\"duplicate `volatile'\");\n+\t      if (restrictp > 1)\n+\t\tpedwarn (\"duplicate `restrict'\");\n+\n+\t      type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n+\t\t\t    | (restrictp ? TYPE_QUAL_RESTRICT : 0)\n+\t\t\t    | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n \t      if (TREE_CODE (declarator) == ADDR_EXPR\n \t\t  && (constp || volatilep))\n \t\t{\n \t\t  if (constp)\n \t\t    pedwarn (\"discarding `const' applied to a reference\");\n \t\t  if (volatilep)\n \t\t    pedwarn (\"discarding `volatile' applied to a reference\");\n-\t\t  constp = volatilep = 0;\n+\t\t  type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n \t\t}\n-\t      type = cp_build_type_variant (type, constp, volatilep);\n+\t      type = cp_build_qualified_type (type, type_quals);\n \t    }\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  ctype = NULL_TREE;\n@@ -10131,7 +10152,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (RIDBIT_SETP (RID_MUTABLE, specbits))\n     {\n-      if (constp)\n+      if (type_quals & TYPE_QUAL_CONST)\n \t{\n \t  error (\"const `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n@@ -10268,19 +10289,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     {\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters.  */\n-      if (constp || volatilep)\n+      if (type_quals != TYPE_UNQUALIFIED)\n \t{\n \t  if (IS_SIGNATURE (type))\n-\t    error (\"`const' or `volatile' specified with signature type\");\n+\t    error (\"type qualifiers specified for signature type\");\n+\t  type_quals = TYPE_UNQUALIFIED;\n \t}\n \n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n \t{\n-\t  if (volatilep)\n+\t  if (type_quals != TYPE_UNQUALIFIED)\n \t    {\n-\t      cp_error (\"`volatile' specified for friend class declaration\");\n-\t      volatilep = 0;\n+\t      cp_error (\"type qualifiers specified for friend class declaration\");\n+\t      type_quals = TYPE_UNQUALIFIED;\n \t    }\n \t  if (inlinep)\n \t    {\n@@ -10360,7 +10382,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t{\n \t  /* Transfer const-ness of array into that of type pointed to.  */\n \t  type = build_pointer_type (TREE_TYPE (type));\n-\t  volatilep = constp = 0;\n+\t  type_quals = TYPE_UNQUALIFIED;\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n \ttype = build_pointer_type (type);\n@@ -10788,14 +10810,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       DECL_THIS_STATIC (decl) = 1;\n \n     /* Record constancy and volatility.  */\n-\n-    if (constp)\n-      TREE_READONLY (decl) = TREE_CODE (type) != REFERENCE_TYPE;\n-    if (volatilep)\n-      {\n-\tTREE_SIDE_EFFECTS (decl) = 1;\n-\tTREE_THIS_VOLATILE (decl) = 1;\n-      }\n+    /* FIXME: Disallow `restrict' pointer-to-member declarations.  */\n+    c_apply_type_quals_to_decl (type_quals, decl);\n \n     return decl;\n   }\n@@ -11214,7 +11230,7 @@ grok_ctor_properties (ctype, decl)\n \t  || TREE_PURPOSE (TREE_CHAIN (parmtypes))))\n     {\n       TYPE_HAS_INIT_REF (ctype) = 1;\n-      if (TYPE_READONLY (TREE_TYPE (parmtype)))\n+      if (CP_TYPE_CONST_P (TREE_TYPE (parmtype)))\n \tTYPE_HAS_CONST_INIT_REF (ctype) = 1;\n     }\n   else if (TYPE_MAIN_VARIANT (parmtype) == ctype\n@@ -11419,7 +11435,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    {\n \t      TYPE_HAS_ASSIGN_REF (current_class_type) = 1;\n \t      if (TREE_CODE (parmtype) != REFERENCE_TYPE\n-\t\t  || TYPE_READONLY (TREE_TYPE (parmtype)))\n+\t\t  || CP_TYPE_CONST_P (TREE_TYPE (parmtype)))\n \t\tTYPE_HAS_CONST_ASSIGN_REF (current_class_type) = 1;\n \t    }\n \t}\n@@ -12436,8 +12452,10 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t\t\t\t     TYPE_ARG_TYPES (TREE_TYPE (decl1)));\n \t  DECL_RESULT (decl1)\n \t    = build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (fntype)));\n-\t  TREE_READONLY (DECL_RESULT (decl1)) = TYPE_READONLY (TREE_TYPE (fntype));\n-\t  TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = TYPE_VOLATILE (TREE_TYPE (fntype));\n+\t  TREE_READONLY (DECL_RESULT (decl1))\n+\t    = CP_TYPE_CONST_P (TREE_TYPE (fntype));\n+\t  TREE_THIS_VOLATILE (DECL_RESULT (decl1))\n+\t    = CP_TYPE_VOLATILE_P (TREE_TYPE (fntype));\n \t}\n \n       if (TYPE_LANG_SPECIFIC (TREE_TYPE (fntype))\n@@ -12621,8 +12639,8 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     {\n       DECL_RESULT (decl1)\n \t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (restype));\n-      TREE_READONLY (DECL_RESULT (decl1)) = TYPE_READONLY (restype);\n-      TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = TYPE_VOLATILE (restype);\n+      TREE_READONLY (DECL_RESULT (decl1)) = CP_TYPE_CONST_P (restype);\n+      TREE_THIS_VOLATILE (DECL_RESULT (decl1)) = CP_TYPE_VOLATILE_P (restype);\n     }\n \n   /* Allocate further tree nodes temporarily during compilation\n@@ -13864,15 +13882,14 @@ revert_static_member_fn (decl, fn, argtypes)\n   tree function = fn ? *fn : TREE_TYPE (*decl);\n   tree args = argtypes ? *argtypes : TYPE_ARG_TYPES (function);\n \n-  if (TYPE_READONLY (TREE_TYPE (TREE_VALUE (args))))\n-    cp_error (\"static member function `%#D' declared const\", *decl);\n-  if (TYPE_VOLATILE (TREE_TYPE (TREE_VALUE (args))))\n-    cp_error (\"static member function `%#D' declared volatile\", *decl);\n+  if (CP_TYPE_QUALS (TREE_TYPE (TREE_VALUE (args))) \n+      != TYPE_UNQUALIFIED)\n+    cp_error (\"static member function `%#D' declared with type qualifiers\", \n+\t      *decl);\n \n   args = TREE_CHAIN (args);\n   tmp = build_function_type (TREE_TYPE (function), args);\n-  tmp = build_type_variant (tmp, TYPE_READONLY (function),\n-\t\t\t    TYPE_VOLATILE (function));\n+  tmp = build_qualified_type (tmp, CP_TYPE_QUALS (function));\n   tmp = build_exception_variant (tmp,\n \t\t\t\t TYPE_RAISES_EXCEPTIONS (function));\n   TREE_TYPE (*decl) = tmp;"}, {"sha": "6ef3099332db25f0dbc7ccd168413623b204f0d2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -784,36 +784,27 @@ grok_method_quals (ctype, function, quals)\n {\n   tree fntype = TREE_TYPE (function);\n   tree raises = TYPE_RAISES_EXCEPTIONS (fntype);\n+  int type_quals = TYPE_UNQUALIFIED;\n+  int dup_quals = TYPE_UNQUALIFIED;\n \n   do\n     {\n-      extern tree ridpointers[];\n-\n-      if (TREE_VALUE (quals) == ridpointers[(int)RID_CONST])\n-\t{\n-\t  if (TYPE_READONLY (ctype))\n-\t    error (\"duplicate `%s' %s\",\n-\t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n-\t\t   (TREE_CODE (function) == FUNCTION_DECL\n-\t\t    ? \"for member function\" : \"in type declaration\"));\n-\t  ctype = build_type_variant (ctype, 1, TYPE_VOLATILE (ctype));\n-\t  build_pointer_type (ctype);\n-\t}\n-      else if (TREE_VALUE (quals) == ridpointers[(int)RID_VOLATILE])\n-\t{\n-\t  if (TYPE_VOLATILE (ctype))\n-\t    error (\"duplicate `%s' %s\",\n-\t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n-\t\t   (TREE_CODE (function) == FUNCTION_DECL\n-\t\t    ? \"for member function\" : \"in type declaration\"));\n-\t  ctype = build_type_variant (ctype, TYPE_READONLY (ctype), 1);\n-\t  build_pointer_type (ctype);\n-\t}\n+      int tq = cp_type_qual_from_rid (TREE_VALUE (quals));\n+      \n+      if (type_quals & tq)\n+\tdup_quals |= tq;\n       else\n-\tmy_friendly_abort (20);\n+\ttype_quals |= tq;\n       quals = TREE_CHAIN (quals);\n-    }\n+    } \n   while (quals);\n+\n+  if (dup_quals != TYPE_UNQUALIFIED)\n+    cp_error (\"duplicate type qualifiers in %s declaration\",\n+\t      TREE_CODE (function) == FUNCTION_DECL \n+\t      ? \"member function\" : \"type\");\n+\n+  ctype = cp_build_qualified_type (ctype, type_quals);\n   fntype = build_cplus_method_type (ctype, TREE_TYPE (fntype),\n \t\t\t\t    (TREE_CODE (fntype) == METHOD_TYPE\n \t\t\t\t     ? TREE_CHAIN (TYPE_ARG_TYPES (fntype))\n@@ -1417,7 +1408,7 @@ check_classfn (ctype, function)\n \n \t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n-\t\t\t  && compparms (p1, p2, 3)\n+\t\t\t  && compparms (p1, p2)\n \t\t\t  && (DECL_TEMPLATE_SPECIALIZATION (function)\n \t\t\t      == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n \t\t\t  && (!DECL_TEMPLATE_SPECIALIZATION (function)\n@@ -1702,7 +1693,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t}\n       /* Force the compiler to know when an uninitialized static\n \t const member is being used.  */\n-      if (TYPE_READONLY (value) && init == 0)\n+      if (CP_TYPE_CONST_P (TREE_TYPE (value)) && init == 0)\n \tTREE_USED (value) = 1;\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;"}, {"sha": "ba3517ef6f32121b8dc7735a95f394964200a17a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -102,7 +102,7 @@ static void dump_type_suffix PROTO((tree, int, int));\n static void dump_function_name PROTO((tree));\n static void dump_expr_list PROTO((tree));\n static void dump_global_iord PROTO((tree));\n-static void dump_readonly_or_volatile PROTO((tree, enum pad));\n+static void dump_qualifiers PROTO((tree, enum pad));\n static void dump_char PROTO((int));\n static char *aggr_variety PROTO((tree));\n static tree ident_fndecl PROTO((tree));\n@@ -115,19 +115,46 @@ init_error ()\n }\n \n static void\n-dump_readonly_or_volatile (t, p)\n+dump_qualifiers (t, p)\n      tree t;\n      enum pad p;\n {\n-  if (TYPE_READONLY (t) || TYPE_VOLATILE (t))\n+  if (TYPE_QUALS (t))\n     {\n       if (p == before) OB_PUTC (' ');\n-      if (TYPE_READONLY (t))\n-\tOB_PUTS (\"const\");\n-      if (TYPE_READONLY (t) && TYPE_VOLATILE (t))\n-\tOB_PUTC (' ');\n-      if (TYPE_VOLATILE (t))\n-\tOB_PUTS (\"volatile\");\n+      switch (TYPE_QUALS (t))\n+\t{\n+\tcase TYPE_QUAL_CONST:\n+\t  OB_PUTS (\"const\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_VOLATILE:\n+\t  OB_PUTS (\"volatile\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_RESTRICT:\n+\t  OB_PUTS (\"__restrict\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:\n+\t  OB_PUTS (\"const volatile\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:\n+\t  OB_PUTS (\"const __restrict\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n+\t  OB_PUTS (\"volatile __restrict\");\n+\t  break;\n+\n+\tcase TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n+\t  OB_PUTS (\"const volatile __restrict\");\n+\t  break;\n+\n+\tdefault:\n+\t  my_friendly_abort (0);\n+\t}\n       if (p == after) OB_PUTC (' ');\n     }\n }\n@@ -197,8 +224,7 @@ dump_type_real (t, v, canonical_name)\n       if (TYPE_LANG_SPECIFIC (t)\n \t  && (IS_SIGNATURE_POINTER (t) || IS_SIGNATURE_REFERENCE (t)))\n \t{\n-\t  if (TYPE_READONLY (t) | TYPE_VOLATILE (t))\n-\t    dump_readonly_or_volatile (t, after);\n+\t  dump_qualifiers (t, after);\n \t  dump_type_real (SIGNATURE_TYPE (t), v, canonical_name);\n \t  if (IS_SIGNATURE_POINTER (t))\n \t    OB_PUTC ('*');\n@@ -232,7 +258,7 @@ dump_type_real (t, v, canonical_name)\n     case BOOLEAN_TYPE:\n       {\n \ttree type;\n-\tdump_readonly_or_volatile (t, after);\n+\tdump_qualifiers (t, after);\n \ttype = canonical_name ? TYPE_MAIN_VARIANT (t) : t;\n \tif (TYPE_NAME (type) && TYPE_IDENTIFIER (type))\n \t  OB_PUTID (TYPE_IDENTIFIER (type));\n@@ -275,7 +301,7 @@ dump_type_real (t, v, canonical_name)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      dump_readonly_or_volatile (t, after);\n+      dump_qualifiers (t, after);\n       if (TYPE_IDENTIFIER (t))\n \tOB_PUTID (TYPE_IDENTIFIER (t));\n       else\n@@ -343,7 +369,7 @@ dump_aggr_type (t, v, canonical_name)\n   tree name;\n   char *variety = aggr_variety (t);\n \n-  dump_readonly_or_volatile (t, after);\n+  dump_qualifiers (t, after);\n \n   if (v > 0)\n     {\n@@ -404,13 +430,14 @@ dump_type_prefix (t, v, canonical_name)\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n       {\n \ttree sub = TREE_TYPE (t);\n \t\n \tdump_type_prefix (sub, v, canonical_name);\n \t/* A tree for a member pointer looks like pointer to offset,\n \t   so let the OFFSET_TYPE case handle it.  */\n-\tif (TREE_CODE (sub) != OFFSET_TYPE)\n+\tif (!TYPE_PTRMEM_P (t))\n \t  {\n \t    switch (TREE_CODE (sub))\n \t      {\n@@ -425,42 +452,20 @@ dump_type_prefix (t, v, canonical_name)\n \n \t      case POINTER_TYPE:\n \t\t/* We don't want \"char * *\" */\n-\t\tif (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n+\t\tif (TYPE_QUALS (sub) == TYPE_UNQUALIFIED)\n \t\t  break;\n \t\t/* But we do want \"char *const *\" */\n \t\t\n \t      default:\n \t\tOB_PUTC (' ');\n \t      }\n-\t    OB_PUTC ('*');\n-\t    dump_readonly_or_volatile (t, none);\n-\t  }\n-      }\n-      break;\n-\n-    case REFERENCE_TYPE:\n-      {\n-\ttree sub = TREE_TYPE (t);\n-\tdump_type_prefix (sub, v, canonical_name);\n-\n-\tswitch (TREE_CODE (sub))\n-\t  {\n-\t  case ARRAY_TYPE:\n-\t    OB_PUTC2 (' ', '(');\n-\t    break;\n-\n-\t  case POINTER_TYPE:\n-\t    /* We don't want \"char * &\" */\n-\t    if (! (TYPE_READONLY (sub) || TYPE_VOLATILE (sub)))\n-\t      break;\n-\t    /* But we do want \"char *const &\" */\n-\n-\t  default:\n-\t    OB_PUTC (' ');\n+\t    if (TREE_CODE (t) == POINTER_TYPE)\n+\t      OB_PUTC ('*');\n+\t    else\n+\t      OB_PUTC ('&');\n+\t    dump_qualifiers (t, none);\n \t  }\n       }\n-      OB_PUTC ('&');\n-      dump_readonly_or_volatile (t, none);\n       break;\n \n     case OFFSET_TYPE:\n@@ -473,7 +478,7 @@ dump_type_prefix (t, v, canonical_name)\n \t  OB_PUTC2 (':', ':');\n \t}\n       OB_PUTC ('*');\n-      dump_readonly_or_volatile (t, none);\n+      dump_qualifiers (t, none);\n       break;\n \n       /* Can only be reached through function pointer -- this would not be\n@@ -555,7 +560,7 @@ dump_type_suffix (t, v, canonical_name)\n \t  OB_PUTS (\"...\");\n \tOB_PUTC (')');\n \tif (TREE_CODE (t) == METHOD_TYPE)\n-\t  dump_readonly_or_volatile\n+\t  dump_qualifiers\n \t    (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), before);\n \tdump_type_suffix (TREE_TYPE (t), v, canonical_name);\n \tbreak;\n@@ -1000,10 +1005,10 @@ dump_function_decl (t, v)\n     {\n       if (IS_SIGNATURE (cname))\n \t/* We look at the type pointed to by the `optr' field of `this.'  */\n-\tdump_readonly_or_volatile\n+\tdump_qualifiers\n \t  (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_VALUE (TYPE_ARG_TYPES (fntype))))), before);\n       else\n-\tdump_readonly_or_volatile\n+\tdump_qualifiers\n \t  (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))), before);\n     }\n }\n@@ -1951,7 +1956,7 @@ cv_as_string (p, v)\n {\n   OB_INIT ();\n \n-  dump_readonly_or_volatile (p, before);\n+  dump_qualifiers (p, before);\n \n   OB_FINISH ();\n "}, {"sha": "5632f7f34a5460e70fd6b140cb896d58770a152a", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -22,6 +22,8 @@ __label__, LABEL, NORID\n __null, CONSTANT, RID_NULL\n __real, REALPART, NORID\n __real__, REALPART, NORID\n+__restrict, CV_QUALIFIER, RID_RESTRICT\n+__restrict__, CV_QUALIFIER, RID_RESTRICT\n __signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED"}, {"sha": "f23b85d351400780d6a67ee1913d9a2fa02c15a0", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1783,6 +1783,12 @@ Used by squangling to compress qualified names.\n @item l\n Encodes the C++ @code{long} type.\n \n+@item n\n+Used with squangling.\n+\n+@item N \n+Namespaces.\n+\n @item P\n Indicates a pointer type.  Followed by the type pointed to.\n \n@@ -1817,11 +1823,14 @@ A modifier that indicates that the following integer type is unsigned.\n Also used to indicate that the following class or namespace name\n is encoded using Unicode-mangling.\n \n+@item u\n+The @code{restrict} type qualifier.\n+\n @item v\n Encodes the C++ and Java @code{void} types.\n \n @item V\n-A modified for a @code{const} type or method.\n+A modifier for a @code{volatile} type or method.\n \n @item w\n Encodes the C++ @code{wchar_t} type, and the Java @code{char} types."}, {"sha": "71c2f317ffef98bebb1a281649985a4ac74929b0", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 125, "deletions": 135, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1,14 +1,14 @@\n /* KR-C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L KR-C -F , 0, 0 -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ./gxx.gperf  */\n+/* Command-line: gperf -L KR-C -F , 0, 0 -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../gcc/cp/gxx.gperf  */\n /* Command-line: gperf -L KR-C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 104\n+#define TOTAL_KEYWORDS 106\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 261\n-/* maximum key range = 258, duplicates = 0 */\n+#define MAX_HASH_VALUE 250\n+/* maximum key range = 247, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -18,34 +18,34 @@ hash (str, len)\n      register char *str;\n      register unsigned int len;\n {\n-  static unsigned short asso_values[] =\n+  static unsigned char asso_values[] =\n     {\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262,   0, 262,  87,  25,  96,\n-       60,   0,  55,   7,   4,  41, 262,   2,  15,  49,\n-       14,  63,  32,  29,   3,  23,   6,   8,   2,   2,\n-        0,   7, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262, 262, 262, 262, 262,\n-      262, 262, 262, 262, 262, 262\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251,   0, 251,  64,  93,   3,\n+        0,   0,  74,  35,   0,  26, 251,   2,  31,  65,\n+       23,  76,   7,  19,  45,  37,   6,  64,  12,  38,\n+       14,   4, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251, 251, 251, 251, 251,\n+      251, 251, 251, 251, 251, 251\n     };\n   register int hval = len;\n \n@@ -80,155 +80,145 @@ is_reserved_word (str, len)\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"else\", ELSE, NORID,},\n       {\"\", 0, 0},\n-      {\"xor\", '^', NORID,},\n-      {\"\", 0, 0},\n+      {\"delete\", DELETE, NORID,},\n+      {\"case\", CASE, NORID,},\n       {\"__real__\", REALPART, NORID},\n       {\"\", 0, 0},\n       {\"true\", CXX_TRUE, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"catch\", CATCH, NORID,},\n+      {\"typeid\", TYPEID, NORID,},\n       {\"try\", TRY, NORID,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"new\", NEW, NORID,},\n+      {\"void\", TYPESPEC, RID_VOID,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"private\", VISSPEC, RID_PRIVATE,},\n+      {\"template\", TEMPLATE, RID_TEMPLATE,},\n+      {\"protected\", VISSPEC, RID_PROTECTED,},\n       {\"extern\", SCSPEC, RID_EXTERN,},\n-      {\"__real\", REALPART, NORID},\n-      {\"while\", WHILE, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n       {\"not\", '!', NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__extension__\", EXTENSION, NORID},\n       {\"\", 0, 0},\n-      {\"__null\", CONSTANT, RID_NULL},\n-      {\"__asm__\", ASM_KEYWORD, NORID},\n-      {\"return\", RETURN, NORID,},\n+      {\"__signed\", TYPESPEC, RID_SIGNED},\n+      {\"int\", TYPESPEC, RID_INT,},\n+      {\"__signed__\", TYPESPEC, RID_SIGNED},\n+      {\"__real\", REALPART, NORID},\n       {\"\", 0, 0},\n-      {\"long\", TYPESPEC, RID_LONG,},\n-      {\"using\", USING, NORID,},\n       {\"xor_eq\", ASSIGN, NORID,},\n-      {\"__inline\", SCSPEC, RID_INLINE},\n-      {\"short\", TYPESPEC, RID_SHORT,},\n-      {\"__inline__\", SCSPEC, RID_INLINE},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"__attribute\", ATTRIBUTE, NORID},\n+      {\"__asm__\", ASM_KEYWORD, NORID},\n+      {\"__attribute__\", ATTRIBUTE, NORID},\n+      {\"compl\", '~', NORID,},\n+      {\"public\", VISSPEC, RID_PUBLIC,},\n+      {\"not_eq\", EQCOMPARE, NORID,},\n       {\"switch\", SWITCH, NORID,},\n-      {\"__alignof__\", ALIGNOF, NORID},\n-      {\"private\", VISSPEC, RID_PRIVATE,},\n-      {\"reinterpret_cast\", REINTERPRET_CAST, NORID,},\n-      {\"struct\", AGGR, RID_RECORD,},\n+      {\"__extension__\", EXTENSION, NORID},\n+      {\"const\", CV_QUALIFIER, RID_CONST,},\n+      {\"static\", SCSPEC, RID_STATIC,},\n       {\"\", 0, 0},\n-      {\"virtual\", SCSPEC, RID_VIRTUAL,},\n+      {\"__inline\", SCSPEC, RID_INLINE},\n+      {\"\", 0, 0},\n+      {\"__inline__\", SCSPEC, RID_INLINE},\n+      {\"__restrict__\", CV_QUALIFIER, RID_RESTRICT},\n+      {\"inline\", SCSPEC, RID_INLINE,},\n+      {\"const_cast\", CONST_CAST, NORID,},\n       {\"static_cast\", STATIC_CAST, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"not_eq\", EQCOMPARE, NORID,},\n-      {\"int\", TYPESPEC, RID_INT,},\n-      {\"__signed__\", TYPESPEC, RID_SIGNED},\n-      {\"template\", TEMPLATE, RID_TEMPLATE,},\n+      {\"__restrict\", CV_QUALIFIER, RID_RESTRICT},\n+      {\"xor\", '^', NORID,},\n+      {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"new\", NEW, NORID,},\n+      {\"__alignof__\", ALIGNOF, NORID},\n+      {\"signed\", TYPESPEC, RID_SIGNED,},\n+      {\"and\", ANDAND, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"explicit\", SCSPEC, RID_EXPLICIT,},\n       {\"\", 0, 0},\n-      {\"signature\", AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"register\", SCSPEC, RID_REGISTER,},\n-      {\"this\", THIS, NORID,},\n       {\"__imag__\", IMAGPART, NORID},\n-      {\"__attribute\", ATTRIBUTE, NORID},\n-      {\"bool\", TYPESPEC, RID_BOOL,},\n-      {\"__attribute__\", ATTRIBUTE, NORID},\n-      {\"for\", FOR, NORID,},\n-      {\"__imag\", IMAGPART, NORID},\n+      {\"while\", WHILE, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"do\", DO, NORID,},\n       {\"typename\", TYPENAME_KEYWORD, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"delete\", DELETE, NORID,},\n+      {\"friend\", SCSPEC, RID_FRIEND,},\n+      {\"continue\", CONTINUE, NORID,},\n+      {\"class\", AGGR, RID_CLASS,},\n+      {\"default\", DEFAULT, NORID,},\n+      {\"this\", THIS, NORID,},\n+      {\"dynamic_cast\", DYNAMIC_CAST, NORID,},\n       {\"typeof\", TYPEOF, NORID,},\n-      {\"or\", OROR, NORID,},\n-      {\"\", 0, 0},\n-      {\"explicit\", SCSPEC, RID_EXPLICIT,},\n-      {\"\", 0, 0},\n-      {\"typeid\", TYPEID, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"virtual\", SCSPEC, RID_VIRTUAL,},\n       {\"export\", SCSPEC, RID_EXPORT,},\n-      {\"throw\", THROW, NORID,},\n-      {\"__asm\", ASM_KEYWORD, NORID},\n+      {\"and_eq\", ASSIGN, NORID,},\n+      {\"__typeof__\", TYPEOF, NORID},\n       {\"__const__\", CV_QUALIFIER, RID_CONST},\n       {\"__volatile\", CV_QUALIFIER, RID_VOLATILE},\n-      {\"__typeof__\", TYPEOF, NORID},\n+      {\"short\", TYPESPEC, RID_SHORT,},\n       {\"__volatile__\", CV_QUALIFIER, RID_VOLATILE},\n       {\"__const\", CV_QUALIFIER, RID_CONST},\n-      {\"false\", CXX_FALSE, NORID,},\n-      {\"sizeof\", SIZEOF, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__complex\", TYPESPEC, RID_COMPLEX},\n-      {\"inline\", SCSPEC, RID_INLINE,},\n-      {\"__complex__\", TYPESPEC, RID_COMPLEX},\n-      {\"union\", AGGR, RID_UNION,},\n+      {\"namespace\", NAMESPACE, NORID,},\n+      {\"char\", TYPESPEC, RID_CHAR,},\n+      {\"unsigned\", TYPESPEC, RID_UNSIGNED,},\n       {\"double\", TYPESPEC, RID_DOUBLE,},\n-      {\"\", 0, 0},\n-      {\"__alignof\", ALIGNOF, NORID},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"bitor\", '|', NORID,},\n       {\"or_eq\", ASSIGN, NORID,},\n+      {\"__null\", CONSTANT, RID_NULL},\n       {\"if\", IF, NORID,},\n-      {\"\", 0, 0},\n-      {\"case\", CASE, NORID,},\n-      {\"\", 0, 0},\n-      {\"enum\", ENUM, NORID,},\n-      {\"signed\", TYPESPEC, RID_SIGNED,},\n-      {\"\", 0, 0},\n-      {\"__sigof__\", SIGOF, NORID\t\t/* Extension */,},\n-      {\"char\", TYPESPEC, RID_CHAR,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__signed\", TYPESPEC, RID_SIGNED},\n-      {\"namespace\", NAMESPACE, NORID,},\n+      {\"__signature__\", AGGR, RID_SIGNATURE\t/* Extension */,},\n       {\"__label__\", LABEL, NORID},\n-      {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n-      {\"protected\", VISSPEC, RID_PROTECTED,},\n-      {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"unsigned\", TYPESPEC, RID_UNSIGNED,},\n-      {\"continue\", CONTINUE, NORID,},\n-      {\"break\", BREAK, NORID,},\n-      {\"\", 0, 0},\n-      {\"friend\", SCSPEC, RID_FRIEND,},\n-      {\"and_eq\", ASSIGN, NORID,},\n-      {\"typedef\", SCSPEC, RID_TYPEDEF,},\n+      {\"long\", TYPESPEC, RID_LONG,},\n+      {\"__imag\", IMAGPART, NORID},\n+      {\"__asm\", ASM_KEYWORD, NORID},\n       {\"\", 0, 0},\n-      {\"do\", DO, NORID,},\n-      {\"void\", TYPESPEC, RID_VOID,},\n+      {\"__sigof__\", SIGOF, NORID\t\t/* Extension */,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"const\", CV_QUALIFIER, RID_CONST,},\n-      {\"static\", SCSPEC, RID_STATIC,},\n+      {\"struct\", AGGR, RID_RECORD,},\n       {\"\", 0, 0},\n-      {\"__typeof\", TYPEOF, NORID},\n+      {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n+      {\"false\", CXX_FALSE, NORID,},\n+      {\"sizeof\", SIZEOF, NORID,},\n+      {\"__complex__\", TYPESPEC, RID_COMPLEX},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"goto\", GOTO, NORID,},\n+      {\"for\", FOR, NORID,},\n+      {\"or\", OROR, NORID,},\n+      {\"register\", SCSPEC, RID_REGISTER,},\n+      {\"throw\", THROW, NORID,},\n       {\"\", 0, 0},\n-      {\"asm\", ASM_KEYWORD, NORID,},\n-      {\"operator\", OPERATOR, NORID,},\n-      {\"__signature__\", AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"using\", USING, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"__complex\", TYPESPEC, RID_COMPLEX},\n       {\"\", 0, 0},\n+      {\"asm\", ASM_KEYWORD, NORID,},\n+      {\"signature\", AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"enum\", ENUM, NORID,},\n+      {\"reinterpret_cast\", REINTERPRET_CAST, NORID,},\n       {\"mutable\", SCSPEC, RID_MUTABLE,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"sigof\", SIGOF, NORID\t\t/* Extension */,},\n-      {\"class\", AGGR, RID_CLASS,},\n-      {\"compl\", '~', NORID,},\n-      {\"public\", VISSPEC, RID_PUBLIC,},\n-      {\"and\", ANDAND, NORID,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"float\", TYPESPEC, RID_FLOAT,},\n+      {\"__alignof\", ALIGNOF, NORID},\n+      {\"return\", RETURN, NORID,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"default\", DEFAULT, NORID,},\n+      {\"\", 0, 0},\n+      {\"float\", TYPESPEC, RID_FLOAT,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"bool\", TYPESPEC, RID_BOOL,},\n+      {\"\", 0, 0},\n+      {\"typedef\", SCSPEC, RID_TYPEDEF,},\n+      {\"__typeof\", TYPEOF, NORID},\n       {\"bitand\", '&', NORID,},\n+      {\"break\", BREAK, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"union\", AGGR, RID_UNION,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"catch\", CATCH, NORID,},\n+      {\"goto\", GOTO, NORID,},\n+      {\"sigof\", SIGOF, NORID\t\t/* Extension */,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"auto\", SCSPEC, RID_AUTO,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"const_cast\", CONST_CAST, NORID,},\n+      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n+      {\"bitor\", '|', NORID,},\n+      {\"auto\", SCSPEC, RID_AUTO,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"dynamic_cast\", DYNAMIC_CAST, NORID,}\n+      {\"operator\", OPERATOR, NORID,}\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "82e616f76cdc69a4f55720c148d2d4cfee464c26", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1057,7 +1057,7 @@ expand_aggr_init (exp, init, flags)\n       /* Must arrange to initialize each element of EXP\n \t from elements of INIT.  */\n       tree itype = init ? TREE_TYPE (init) : NULL_TREE;\n-      if (TYPE_READONLY (TREE_TYPE (type)) || TYPE_VOLATILE (TREE_TYPE (type)))\n+      if (CP_TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n \t{\n \t  TREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n \t  if (init)\n@@ -1424,8 +1424,7 @@ build_member_call (type, name, parmlist)\n       tree oldtype = TREE_TYPE (TREE_TYPE (olddecl));\n       if (oldtype != type)\n \t{\n-\t  tree newtype = build_type_variant (type, TYPE_READONLY (oldtype),\n-\t\t\t\t\t     TYPE_VOLATILE (oldtype));\n+\t  tree newtype = build_qualified_type (type, TYPE_QUALS (oldtype));\n \t  decl = convert_force (build_pointer_type (newtype), olddecl, 0);\n \t  decl = build_indirect_ref (decl, NULL_PTR);\n \t}\n@@ -2143,7 +2142,7 @@ build_new_1 (exp)\n     }\n   true_type = type;\n \n-  if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n+  if (CP_TYPE_QUALS (type))\n     type = TYPE_MAIN_VARIANT (type);\n \n   /* If our base type is an array, then make sure we know how many elements\n@@ -2345,11 +2344,11 @@ build_new_1 (exp)\n \t     allow the expression to be non-const while we do the\n \t     initialization.  */\n \t  deref_type = TREE_TYPE (deref);\n-\t  if (TYPE_READONLY (deref_type))\n+\t  if (CP_TYPE_CONST_P (deref_type))\n \t    TREE_TYPE (deref) \n-\t      = cp_build_type_variant (deref_type,\n-\t\t\t\t       /*constp=*/0,\n-\t\t\t\t       TYPE_VOLATILE (deref_type));\n+\t      = cp_build_qualified_type (deref_type,\n+\t\t\t\t\t CP_TYPE_QUALS (deref_type) \n+\t\t\t\t\t & ~TYPE_QUAL_CONST);\n \t  TREE_READONLY (deref) = 0;\n \n \t  if (TREE_CHAIN (init) != NULL_TREE)\n@@ -2469,7 +2468,7 @@ build_new_1 (exp)\n \t    }\n \t}\n     }\n-  else if (TYPE_READONLY (true_type))\n+  else if (CP_TYPE_CONST_P (true_type))\n     cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n \n  done:"}, {"sha": "e08166331850a65f9b0a0d3dfb66942c3632daba", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -702,6 +702,9 @@ init_parse (filename)\n   ridpointers[(int) RID_VOLATILE] = get_identifier (\"volatile\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_VOLATILE],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_VOLATILE]));\n+  ridpointers[(int) RID_RESTRICT] = get_identifier (\"__restrict\");\n+  SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_RESTRICT],\n+\t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_RESTRICT]));\n   ridpointers[(int) RID_AUTO] = get_identifier (\"auto\");\n   SET_IDENTIFIER_AS_LIST (ridpointers[(int) RID_AUTO],\n \t\t\t  build_tree_list (NULL_TREE, ridpointers[(int) RID_AUTO]));\n@@ -1984,7 +1987,7 @@ cons_up_default_function (type, full_name, kind)\n       break;\n \n     case 3:\n-      type = build_type_variant (type, 1, 0);\n+      type = build_qualified_type (type, TYPE_QUAL_CONST);\n       /* Fall through...  */\n     case 4:\n       /* According to ARM $12.8, the default copy ctor will be declared, but\n@@ -2002,7 +2005,7 @@ cons_up_default_function (type, full_name, kind)\n       declspecs = build_decl_list (NULL_TREE, type);\n \n       if (kind == 5)\n-\ttype = build_type_variant (type, 1, 0);\n+\ttype = build_qualified_type (type, TYPE_QUAL_CONST);\n \n       name = ansi_opname [(int) MODIFY_EXPR];\n \n@@ -4934,6 +4937,25 @@ handle_cp_pragma (pname)\n \n   return 0;\n }\n+\n+/* Return the type-qualifier corresponding to the identifier given by\n+   RID.  */\n+\n+int\n+cp_type_qual_from_rid (rid)\n+     tree rid;\n+{\n+  if (rid == ridpointers[(int) RID_CONST])\n+    return TYPE_QUAL_CONST;\n+  else if (rid == ridpointers[(int) RID_VOLATILE])\n+    return TYPE_QUAL_VOLATILE;\n+  else if (rid == ridpointers[(int) RID_RESTRICT])\n+    return TYPE_QUAL_RESTRICT;\n+\n+  my_friendly_abort (0);\n+  return TYPE_UNQUALIFIED;\n+}\n+\n \f\n #ifdef HANDLE_GENERIC_PRAGMAS\n "}, {"sha": "ec08f39f69e3d724d8e15749cbdd18eb8ef382e0", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -64,6 +64,7 @@ enum rid\n   RID_AUTO,\n   RID_MUTABLE,\n   RID_COMPLEX,\n+  RID_RESTRICT,\n \n   /* This is where grokdeclarator ends its search when setting the\n      specbits.  */"}, {"sha": "f738124117fe5f914c50729b639e4bc68e5fd769", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1163,7 +1163,10 @@ void\n process_modifiers (parmtype) \n      tree parmtype;\n {\n-  if (TREE_READONLY (parmtype))\n+  /* Note that here we do not use CP_TYPE_CONST_P and friends because\n+     we describe types recursively; we will get the `const' in \n+     `const int ()[10]' when processing the `const int' part.  */\n+  if (TYPE_READONLY (parmtype))\n     OB_PUTC ('C');\n   if (TREE_CODE (parmtype) == INTEGER_TYPE\n       && (TYPE_MAIN_VARIANT (parmtype)\n@@ -1172,6 +1175,10 @@ process_modifiers (parmtype)\n     OB_PUTC ('U');\n   if (TYPE_VOLATILE (parmtype))\n     OB_PUTC ('V');\n+  /* It would be better to use `R' for `restrict', but that's already\n+     used for reference types.  And `r' is used for `long double'.  */\n+  if (TYPE_RESTRICT (parmtype))\n+    OB_PUTC ('u');\n }\n \n /* Check to see if TYPE has been entered into the Bcode typelist.  If"}, {"sha": "fb1d896578de497797a1f08b1b9a5f7d8c744845", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3658, "deletions": 3663, "changes": 7321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=91063b51383fe008c4509822a66761f6fc7cf334"}, {"sha": "025b81327af933479b220e197401eb1ed7e28cea", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1433,47 +1433,20 @@ primary:\n \t\t{ $$ = finish_this_expr (); }\n \t| CV_QUALIFIER '(' nonnull_exprlist ')'\n \t\t{\n-\t\t  tree type = NULL_TREE;\n-\t\t  tree id = $$;\n+\t\t  /* This is a C cast in C++'s `functional' notation\n+\t\t     using the \"implicit int\" extension so that:\n+\t\t     `const (3)' is equivalent to `const int (3)'.  */\n+\t\t  tree type;\n \n-\t\t  /* This is a C cast in C++'s `functional' notation.  */\n \t\t  if ($3 == error_mark_node)\n \t\t    {\n \t\t      $$ = error_mark_node;\n \t\t      break;\n \t\t    }\n-#if 0\n-\t\t  if ($3 == NULL_TREE)\n-\t\t    {\n-\t\t      error (\"cannot cast null list to type `%s'\",\n-\t\t             IDENTIFIER_POINTER (TYPE_NAME (id)));\n-\t\t      $$ = error_mark_node;\n-\t\t      break;\n-\t\t    }\n-#endif\n-#if 0\n-\t\t  /* type is not set! (mrs) */\n-\t\t  if (type == error_mark_node)\n-\t\t    $$ = error_mark_node;\n-\t\t  else\n-#endif\n-\t\t    {\n-\t\t      if (id == ridpointers[(int) RID_CONST])\n-\t\t        type = build_type_variant (integer_type_node, 1, 0);\n-\t\t      else if (id == ridpointers[(int) RID_VOLATILE])\n-\t\t        type = build_type_variant (integer_type_node, 0, 1);\n-#if 0\n-\t\t      /* should not be able to get here (mrs) */\n-\t\t      else if (id == ridpointers[(int) RID_FRIEND])\n-\t\t        {\n-\t\t          error (\"cannot cast expression to `friend' type\");\n-\t\t          $$ = error_mark_node;\n-\t\t          break;\n-\t\t        }\n-#endif\n-\t\t      else my_friendly_abort (79);\n-\t\t      $$ = build_c_cast (type, build_compound_expr ($3));\n-\t\t    }\n+\n+\t\t  type = cp_build_qualified_type (integer_type_node,\n+\t\t\t\t\t\t  cp_type_qual_from_rid ($1));\n+\t\t  $$ = build_c_cast (type, build_compound_expr ($3));\n \t\t}\n \t| functional_cast\n \t| DYNAMIC_CAST '<' type_id '>' '(' expr ')'"}, {"sha": "ec1b5af46d60c362acdef045f9263ec80559b261", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -2598,10 +2598,8 @@ convert_nontype_argument (type, expr)\n \t       template-argument, which must be an lvalue.  */\n \t    if (!comptypes (TYPE_MAIN_VARIANT (expr_type),\n \t\t\t    TYPE_MAIN_VARIANT (type), 1)\n-\t\t|| (TYPE_READONLY (expr_type) >\n-\t\t    TYPE_READONLY (type_referred_to))\n-\t\t|| (TYPE_VOLATILE (expr_type) >\n-\t\t    TYPE_VOLATILE (type_referred_to))\n+\t\t|| !at_least_as_qualified_p (type_referred_to,\n+\t\t\t\t\t     expr_type)\n \t\t|| !real_lvalue_p (expr))\n \t      return error_mark_node;\n \t    else\n@@ -4872,8 +4870,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n \t{\n \t  tree r = build_ptrmemfunc_type\n \t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, in_decl));\n-\t  return cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\t\tTYPE_VOLATILE (t));\n+\t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n \t}\n \n       /* else fall through */\n@@ -4907,8 +4904,7 @@ tsubst_aggr_type (t, args, in_decl, entering_scope)\n   \t  r = lookup_template_class (t, argvec, in_decl, context,\n \t\t\t\t     entering_scope);\n \n-\t  return cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\t\tTYPE_VOLATILE (t));\n+\t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n \t}\n       else \n \t/* This is not a template type, so there's nothing to do.  */\n@@ -5559,9 +5555,8 @@ tsubst (t, args, in_decl)\n \t\t  {\n \t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n \t\t\t\t\t== 't', 0);\n-\t\t    return cp_build_type_variant\n-\t\t      (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n-\t\t       TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\t    return cp_build_qualified_type\n+\t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t));\n \t\t  }\n \t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n@@ -5585,8 +5580,7 @@ tsubst (t, args, in_decl)\n \t\t\t\t\t\t   argvec, in_decl, \n \t\t\t\t\t\t   DECL_CONTEXT (arg),\n \t\t\t\t\t\t   /*entering_scope=*/0);\n-\t\t\treturn cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\t\t\t      TYPE_VOLATILE (t));\n+\t\t\treturn cp_build_qualified_type (r, TYPE_QUALS (t));\n \t\t      }\n \t\t    else\n \t\t      /* We are processing a template argument list.  */ \n@@ -5736,7 +5730,7 @@ tsubst (t, args, in_decl)\n \t  r = build_pointer_type (type);\n \telse\n \t  r = build_reference_type (type);\n-\tr = cp_build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+\tr = cp_build_qualified_type (r, TYPE_QUALS (t));\n \n \t/* Will this ever be needed for TYPE_..._TO values?  */\n \tlayout_type (r);\n@@ -5766,10 +5760,7 @@ tsubst (t, args, in_decl)\n \t    = build_cplus_method_type (TREE_TYPE (TREE_VALUE (arg_types)),\n \t\t\t\t       type,\n \t\t\t\t       TREE_CHAIN (arg_types));\n-\n-\tfntype = build_type_variant (fntype,\n-\t\t\t\t     TYPE_READONLY (t),\n-\t\t\t\t     TYPE_VOLATILE (t));\n+\tfntype = build_qualified_type (fntype, TYPE_QUALS (t));\n \n \t/* Substitue the exception specification. */\n \traises = TYPE_RAISES_EXCEPTIONS (t);\n@@ -5820,9 +5811,9 @@ tsubst (t, args, in_decl)\n \t  return error_mark_node;\n \n \tf = make_typename_type (ctx, f);\n-\treturn cp_build_type_variant\n-\t  (f, TYPE_READONLY (f) || TYPE_READONLY (t),\n-\t   TYPE_VOLATILE (f) || TYPE_VOLATILE (t));\n+\treturn cp_build_qualified_type (f, \n+\t\t\t\t\tCP_TYPE_QUALS (f) \n+\t\t\t\t\t| CP_TYPE_QUALS (t));\n       }\n \n     case INDIRECT_REF:\n@@ -7085,11 +7076,9 @@ check_cv_quals_for_unify (strict, arg, parm)\n      tree parm;\n {\n   return !((!(strict & UNIFY_ALLOW_MORE_CV_QUAL)\n-\t    && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n-\t\t|| TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+\t    && !at_least_as_qualified_p (arg, parm))\n \t   || (!(strict & UNIFY_ALLOW_LESS_CV_QUAL)\n-\t       && (TYPE_READONLY (arg) > TYPE_READONLY (parm)\n-\t\t   || TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm))));\n+\t       && (!at_least_as_qualified_p (parm, arg))));\n }\n \n /* Takes parameters as for type_unification.  Returns 0 if the\n@@ -7249,9 +7238,9 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t  /* Consider the case where ARG is `const volatile int' and\n \t     PARM is `const T'.  Then, T should be `volatile int'.  */\n \t  arg = \n-\t    cp_build_type_variant (arg, \n-\t\t\t\t   TYPE_READONLY (arg) > TYPE_READONLY (parm),\n-\t\t\t\t   TYPE_VOLATILE (arg) > TYPE_VOLATILE (parm));\n+\t    cp_build_qualified_type (arg,\n+\t\t\t\t     CP_TYPE_QUALS (arg) \n+\t\t\t\t     & ~CP_TYPE_QUALS (parm));\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */"}, {"sha": "b9c949802181da400b21414dbccf77d632eebf4d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -65,7 +65,8 @@ init_rtti_processing ()\n     pop_namespace ();\n   tinfo_fn_id = get_identifier (\"__tf\");\n   tinfo_fn_type = build_function_type\n-    (build_reference_type (build_type_variant (type_info_type_node, 1, 0)),\n+    (build_reference_type (build_qualified_type (type_info_type_node, \n+\t\t\t\t\t\t TYPE_QUAL_CONST)),\n      void_list_node);\n }\n \n@@ -123,8 +124,8 @@ build_headof (exp)\n   else\n     offset = build_component_ref (aref, delta_identifier, NULL_TREE, 0);\n \n-  type = build_type_variant (ptr_type_node, TREE_READONLY (exp),\n-\t\t\t     TREE_THIS_VOLATILE (exp));\n+  type = build_qualified_type (ptr_type_node, \n+\t\t\t       CP_TYPE_QUALS (TREE_TYPE (exp)));\n   return build (PLUS_EXPR, type, exp,\n \t\tcp_convert (ptrdiff_type_node, offset));\n }\n@@ -302,7 +303,7 @@ get_tinfo_var (type)\n   /* Figure out how much space we need to allocate for the type_info object.\n      If our struct layout or the type_info classes are changed, this will\n      need to be modified.  */\n-  if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n+  if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n     size = 3 * POINTER_SIZE + INT_TYPE_SIZE;\n   else if (TREE_CODE (type) == POINTER_TYPE\n \t   && ! (TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n@@ -467,8 +468,8 @@ build_dynamic_cast_1 (type, expr)\n \tgoto fail;\n       if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n \tgoto fail;\n-      if (TREE_READONLY (TREE_TYPE (exprtype))\n-\t  && ! TYPE_READONLY (TREE_TYPE (type)))\n+      if (!at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\t    TREE_TYPE (exprtype)))\n \tgoto fail;\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n \tbreak;\n@@ -487,8 +488,6 @@ build_dynamic_cast_1 (type, expr)\n   /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n   if (ec == RECORD_TYPE)\n     {\n-      exprtype = build_type_variant (exprtype, TREE_READONLY (expr),\n-\t\t\t\t     TREE_THIS_VOLATILE (expr));\n       exprtype = build_reference_type (exprtype);\n       expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n \t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n@@ -503,8 +502,8 @@ build_dynamic_cast_1 (type, expr)\n \tgoto fail;\n       if (TYPE_SIZE (complete_type (TREE_TYPE (exprtype))) == NULL_TREE)\n \tgoto fail;\n-      if (TREE_READONLY (TREE_TYPE (exprtype))\n-\t  && ! TYPE_READONLY (TREE_TYPE (type)))\n+      if (!at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\t    TREE_TYPE (exprtype)))\n \tgoto fail;\n     }\n \n@@ -766,7 +765,9 @@ expand_class_desc (tdecl, type)\n       /* Actually const __user_type_info * */\n       fields [0] = build_lang_field_decl\n \t(FIELD_DECL, NULL_TREE,\n-\t build_pointer_type (build_type_variant (type_info_type_node, 1, 0)));\n+\t build_pointer_type (build_qualified_type\n+\t\t\t     (type_info_type_node,\n+\t\t\t      TYPE_QUAL_CONST)));\n       fields [1] = build_lang_field_decl\n \t(FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n       DECL_BIT_FIELD (fields[1]) = 1;\n@@ -967,8 +968,7 @@ expand_attr_desc (tdecl, type)\n   tree elems, t, fn;\n   char *name = build_overload_name (type, 1, 1);\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n-  tree attrval = build_int_2\n-    (TYPE_READONLY (type) | TYPE_VOLATILE (type) * 2, 0);\n+  tree attrval = build_int_2 (TYPE_QUALS (type), 0);\n \n   expand_expr_stmt (get_typeid_1 (TYPE_MAIN_VARIANT (type)));\n   t = decay_conversion (get_tinfo_var (TYPE_MAIN_VARIANT (type)));\n@@ -1091,7 +1091,7 @@ synthesize_tinfo_fn (fndecl)\n     expand_generic_desc (tdecl, type, \"__rtti_func\");\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     expand_generic_desc (tdecl, type, \"__rtti_array\");\n-  else if (TYPE_VOLATILE (type) || TYPE_READONLY (type))\n+  else if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n     expand_attr_desc (tdecl, type);\n   else if (TREE_CODE (type) == POINTER_TYPE)\n     {"}, {"sha": "5af1c7d67c4e3900ed03457addda011b14446bc4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -1752,8 +1752,7 @@ covariant_return_p (brettype, drettype)\n   if (! (TREE_CODE (brettype) == TREE_CODE (drettype)\n \t && (TREE_CODE (brettype) == POINTER_TYPE\n \t     || TREE_CODE (brettype) == REFERENCE_TYPE)\n-\t && TYPE_READONLY (brettype) == TYPE_READONLY (drettype)\n-\t && TYPE_VOLATILE (brettype) == TYPE_VOLATILE (drettype)))\n+\t && TYPE_QUALS (brettype) == TYPE_QUALS (drettype)))\n     return 0;\n \n   if (! can_convert (brettype, drettype))\n@@ -1849,15 +1848,19 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \t      btypes = TYPE_ARG_TYPES (TREE_TYPE (tmp));\n \t      if (instptr_type == NULL_TREE)\n \t\t{\n-\t\t  if (compparms (TREE_CHAIN (btypes), dtypes, 3))\n+\t\t  if (compparms (TREE_CHAIN (btypes), dtypes))\n \t\t    /* Caller knows to give error in this case.  */\n \t\t    return tmp;\n \t\t  return NULL_TREE;\n \t\t}\n \n-\t      if ((TYPE_READONLY (TREE_TYPE (TREE_VALUE (btypes)))\n-\t\t   == TYPE_READONLY (instptr_type))\n-\t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes), 3))\n+\t      if (/* The first parameter is the `this' parameter,\n+\t\t     which has POINTER_TYPE, and we can therefore\n+\t\t     safely use TYPE_QUALS, rather than\n+\t\t     CP_TYPE_QUALS.  */\n+\t\t  (TYPE_QUALS (TREE_TYPE (TREE_VALUE (btypes)))\n+\t\t   == TYPE_QUALS (instptr_type))\n+\t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n \t\t{\n \t\t  tree brettype = TREE_TYPE (TREE_TYPE (tmp));\n \t\t  if (comptypes (brettype, drettype, 1))\n@@ -2603,8 +2606,9 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \n \t  TREE_READONLY (new_delta) = 0;\n \t  TREE_TYPE (new_delta) = \n-\t    cp_build_type_variant (TREE_TYPE (new_delta), /*constp=*/0,\n-\t\t\t\t   TYPE_VOLATILE (TREE_TYPE (new_delta)));\n+\t    cp_build_qualified_type (TREE_TYPE (new_delta),\n+\t\t\t\t     CP_TYPE_QUALS (TREE_TYPE (new_delta))\n+\t\t\t\t     & ~TYPE_QUAL_CONST);\n \t  expand_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n \t\t\t\t\t       old_delta));\n \t}"}, {"sha": "9a7b57f1ddd988c059347fc0d77b1ccccd7a5612", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -40,11 +40,11 @@ static tree build_sptr_ref PROTO((tree));\n static tree build_member_function_pointer PROTO((tree));\n static void undo_casts PROTO((tree));\n static tree build_signature_pointer_or_reference_name\n-\tPROTO((tree, int, int, int));\n+\tPROTO((tree, int, int));\n static void build_signature_pointer_or_reference_decl\n \tPROTO((tree, tree));\n static tree build_signature_pointer_or_reference_type \n-\tPROTO((tree, int, int, int));\n+\tPROTO((tree, int, int));\n static tree get_sigtable_name PROTO((tree, tree));\n static tree build_signature_table_constructor PROTO((tree, tree));\n static int match_method_types PROTO((tree, tree));\n@@ -58,25 +58,31 @@ static int global_sigtable_name_counter;\n    can use it's name in function name mangling.  */\n \n static tree\n-build_signature_pointer_or_reference_name (to_type, constp, volatilep, refp)\n+build_signature_pointer_or_reference_name (to_type, type_quals, refp)\n      tree to_type;\n-     int constp, volatilep, refp;\n+     int type_quals;\n+     int refp;\n {\n   char * sig_name = TYPE_NAME_STRING (to_type);\n-  int name_len = TYPE_NAME_LENGTH (to_type) + constp + volatilep;\n+  int name_len = TYPE_NAME_LENGTH (to_type) + 3 /* Enough room for\n+\t\t\t\t\t\t   C,V,R.  */;\n   char * name;\n \n+  char *const_rep = (type_quals & TYPE_QUAL_CONST) ? \"C\" : \"\";\n+  char *restrict_rep = (type_quals & TYPE_QUAL_RESTRICT) ? \"R\" : \"\"; \n+  char *volatile_rep = (type_quals & TYPE_QUAL_VOLATILE) ? \"C\" : \"\";\n+\n   if (refp)\n     {\n       name = (char *) alloca (name_len + sizeof (SIGNATURE_REFERENCE_NAME) +2);\n       sprintf (name, SIGNATURE_REFERENCE_NAME_FORMAT,\n-\t       constp ? \"C\" : \"\", volatilep ? \"V\": \"\", sig_name);\n+\t       const_rep, volatile_rep, restrict_rep, sig_name);\n     }\n   else\n     {\n       name = (char *) alloca (name_len + sizeof (SIGNATURE_POINTER_NAME) + 2);\n       sprintf (name, SIGNATURE_POINTER_NAME_FORMAT,\n-\t       constp ? \"C\" : \"\", volatilep ? \"V\": \"\", sig_name);\n+\t       const_rep, volatile_rep, restrict_rep, sig_name);\n     }\n   return get_identifier (name);\n }\n@@ -98,21 +104,22 @@ build_signature_pointer_or_reference_decl (type, name)\n   TREE_CHAIN (type) = decl;\n }\n \n-/* Construct, lay out and return the type of pointers or references\n-   to signature TO_TYPE.  If such a type has already been constructed,\n-   reuse it. If CONSTP or VOLATILEP is specified, make the `optr' const\n-   or volatile, respectively.   If we are constructing a const/volatile\n-   type variant and the main type variant doesn't exist yet, it is built\n-   as well.  If REFP is 1, we construct a signature reference, otherwise\n-   a signature pointer is constructed.\n+/* Construct, lay out and return the type of pointers or references to\n+   signature TO_TYPE.  If such a type has already been constructed,\n+   reuse it. If TYPE_QUALS are specified, qualify the `optr'.  If we\n+   are constructing a const/volatile type variant and the main type\n+   variant doesn't exist yet, it is built as well.  If REFP is 1, we\n+   construct a signature reference, otherwise a signature pointer is\n+   constructed.\n \n    This function is a subroutine of `build_signature_pointer_type' and\n    `build_signature_reference_type'.  */\n \n static tree\n-build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n+build_signature_pointer_or_reference_type (to_type, type_quals, refp)\n      tree to_type;\n-     int constp, volatilep, refp;\n+     int type_quals;\n+     int refp;\n {\n   register tree t, m;\n   register struct obstack *ambient_obstack = current_obstack;\n@@ -121,13 +128,11 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n   m = refp ? SIGNATURE_REFERENCE_TO (to_type) : SIGNATURE_POINTER_TO (to_type);\n \n   /* If we don't have the main variant yet, construct it.  */\n-  if (m == NULL_TREE\n-      && (constp || volatilep))\n-    m = build_signature_pointer_or_reference_type (to_type, 0, 0, refp);\n+  if (m == NULL_TREE && type_quals != TYPE_UNQUALIFIED)\n+    m = build_signature_pointer_or_reference_type (to_type, \n+\t\t\t\t\t\t   TYPE_UNQUALIFIED, refp);\n \n   /* Treat any nonzero argument as 1.  */\n-  constp = !!constp;\n-  volatilep = !!volatilep;\n   refp = !!refp;\n \n   /* If not generating auxiliary info, search the chain of variants to see\n@@ -141,8 +146,8 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n \n   if (m && !flag_gen_aux_info)\n     for (t = m; t; t = TYPE_NEXT_VARIANT (t))\n-      if (constp == TYPE_READONLY (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t))))\n-\t  && volatilep == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (t)))))\n+      if (type_quals == CP_TYPE_QUALS (TREE_TYPE (TREE_TYPE\n+\t\t\t\t\t\t  (TYPE_FIELDS (t)))))\n         return t;\n \n   /* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */\n@@ -170,7 +175,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n \n   t = make_lang_type (RECORD_TYPE);\n   {\n-    tree obj_type = build_type_variant (void_type_node, constp, volatilep);\n+    tree obj_type = build_qualified_type (void_type_node, type_quals);\n     tree optr_type = build_pointer_type (obj_type);\n     tree optr, sptr;\n \n@@ -185,7 +190,8 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n       sptr = TREE_CHAIN (TYPE_FIELDS (m));\n     else\n       {\n-\ttree sig_tbl_type = cp_build_type_variant (to_type, 1, 0);\n+\ttree sig_tbl_type = \n+\t  cp_build_qualified_type (to_type, TYPE_QUAL_CONST);\n \t\n \tsptr = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),\n@@ -207,8 +213,9 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n   }\n \n   {\n-    tree name = build_signature_pointer_or_reference_name (to_type, constp,\n-\t\t\t\t\t\t\t   volatilep, refp);\n+    tree name = build_signature_pointer_or_reference_name (to_type, \n+\t\t\t\t\t\t\t   type_quals,\n+\t\t\t\t\t\t\t   refp);\n \n     /* Build a DECL node for this type, so the debugger has access to it.  */\n     build_signature_pointer_or_reference_decl (t, name);\n@@ -255,8 +262,7 @@ build_signature_pointer_type (to_type)\n {\n   return\n     build_signature_pointer_or_reference_type (TYPE_MAIN_VARIANT (to_type),\n-\t\t\t\t\t       TYPE_READONLY (to_type),\n-\t\t\t\t\t       TYPE_VOLATILE (to_type), 0);\n+\t\t\t\t\t       CP_TYPE_QUALS (to_type), 0);\n }\n \n /* Construct, lay out and return the type of pointers to signature TO_TYPE.  */\n@@ -267,8 +273,7 @@ build_signature_reference_type (to_type)\n {\n   return\n     build_signature_pointer_or_reference_type (TYPE_MAIN_VARIANT (to_type),\n-\t\t\t\t\t       TYPE_READONLY (to_type),\n-\t\t\t\t\t       TYPE_VOLATILE (to_type), 1);\n+\t\t\t\t\t       CP_TYPE_QUALS (to_type), 1);\n }\n \n /* Return the name of the signature table (as an IDENTIFIER_NODE)\n@@ -420,16 +425,15 @@ match_method_types (sig_mtype, class_mtype)\n \n     /* If a signature method's `this' is const or volatile, so has to be\n        the corresponding class method's `this.'  */\n-    if ((TYPE_READONLY (sig_this) && ! TYPE_READONLY (class_this))\n-\t|| (TYPE_VOLATILE (sig_this) && ! TYPE_VOLATILE (class_this)))\n+    if (!at_least_as_qualified_p (class_this, sig_this))\n       return 0;\n   }\n \n   sig_arg_types = TREE_CHAIN (sig_arg_types);\n   class_arg_types = TREE_CHAIN (class_arg_types);\n \n   /* The number of arguments and the argument types have to be the same.  */\n-  return compparms (sig_arg_types, class_arg_types, 3);\n+  return compparms (sig_arg_types, class_arg_types);\n }\n \n /* Undo casts of opaque type variables to the RHS types.  */\n@@ -884,7 +888,7 @@ build_signature_pointer_constructor (lhs, rhs)\n     }\n   else\n     {\n-      if (TREE_READONLY (lhs) || TYPE_READONLY (lhstype))\n+      if (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype))\n \t  readonly_error (lhs, \"assignment\", 0);\n \n       optr_expr = build_modify_expr (build_optr_ref (lhs), NOP_EXPR,\n@@ -978,9 +982,8 @@ build_signature_method_call (function, parms)\n     tree old_this = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))));\n \n     TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))))\n-      = build_type_variant (build_pointer_type (basetype),\n-\t\t\t    TYPE_READONLY (old_this),\n-\t\t\t    TYPE_VOLATILE (old_this));\n+      = build_qualified_type (build_pointer_type (basetype),\n+\t\t\t      TYPE_QUALS (old_this));\n \n     direct_call = build_function_call (pfn, new_parms);\n "}, {"sha": "db9f139b387b420f0c3c6bcf495e10294b9cab68", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -442,14 +442,14 @@ build_cplus_array_type (elt_type, index_type)\n      tree index_type;\n {\n   tree t;\n-  int constp = TYPE_READONLY (elt_type);\n-  int volatilep = TYPE_VOLATILE (elt_type);\n+  int type_quals = CP_TYPE_QUALS (elt_type);\n+\n   elt_type = TYPE_MAIN_VARIANT (elt_type);\n \n   t = build_cplus_array_type_1 (elt_type, index_type);\n \n-  if (constp || volatilep)\n-    t = cp_build_type_variant (t, constp, volatilep);\n+  if (type_quals != TYPE_UNQUALIFIED)\n+    t = cp_build_qualified_type (t, type_quals);\n \n   return t;\n }\n@@ -458,21 +458,32 @@ build_cplus_array_type (elt_type, index_type)\n    down to the element type of an array.  */\n \n tree\n-cp_build_type_variant (type, constp, volatilep)\n+cp_build_qualified_type (type, type_quals)\n      tree type;\n-     int constp, volatilep;\n+     int type_quals;\n {\n   if (type == error_mark_node)\n     return type;\n   \n+  /* A restrict-qualified pointer type must be a pointer (or reference)\n+     to object or incomplete type.  */\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && (!POINTER_TYPE_P (type)\n+\t  || TYPE_PTRMEM_P (type)\n+\t  || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n+    {\n+      cp_error (\"`%T' cannot be `restrict'-qualified\", type);\n+      type_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree real_main_variant = TYPE_MAIN_VARIANT (type);\n \n       push_obstacks (TYPE_OBSTACK (real_main_variant),\n \t\t     TYPE_OBSTACK (real_main_variant));\n-      type = build_cplus_array_type_1 (cp_build_type_variant\n-\t\t\t\t       (TREE_TYPE (type), constp, volatilep),\n+      type = build_cplus_array_type_1 (cp_build_qualified_type \n+\t\t\t\t       (TREE_TYPE (type), type_quals),\n \t\t\t\t       TYPE_DOMAIN (type));\n \n       /* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not,\n@@ -489,7 +500,7 @@ cp_build_type_variant (type, constp, volatilep)\n       pop_obstacks ();\n       return type;\n     }\n-  return build_type_variant (type, constp, volatilep);\n+  return build_qualified_type (type, type_quals);\n }\n \n /* Returns the canonical version of TYPE.  In other words, if TYPE is\n@@ -501,8 +512,7 @@ tree\n canonical_type_variant (t)\n      tree t;\n {\n-  return cp_build_type_variant (TYPE_MAIN_VARIANT (t), CP_TYPE_READONLY (t),\n-\t\t\t\tCP_TYPE_VOLATILE (t));\n+  return cp_build_qualified_type (TYPE_MAIN_VARIANT (t), CP_TYPE_QUALS (t));\n }\n \f\n /* Add OFFSET to all base types of T.\n@@ -1448,13 +1458,11 @@ build_exception_variant (type, raises)\n      tree raises;\n {\n   tree v = TYPE_MAIN_VARIANT (type);\n-  int constp = TYPE_READONLY (type);\n-  int volatilep = TYPE_VOLATILE (type);\n+  int type_quals = TYPE_QUALS (type);\n \n   for (; v; v = TYPE_NEXT_VARIANT (v))\n     {\n-      if (TYPE_READONLY (v) != constp\n-\t  || TYPE_VOLATILE (v) != volatilep)\n+      if (TYPE_QUALS (v) != type_quals)\n \tcontinue;\n \n       /* @@ This should do set equality, not exact match.  */\n@@ -1931,31 +1939,31 @@ mapcar (t, func)\n \n     case POINTER_TYPE:\n       tmp = build_pointer_type (mapcar (TREE_TYPE (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n     case REFERENCE_TYPE:\n       tmp = build_reference_type (mapcar (TREE_TYPE (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n     case FUNCTION_TYPE:\n       tmp = build_function_type (mapcar (TREE_TYPE (t), func),\n \t\t\t\t mapcar (TYPE_ARG_TYPES (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n     case ARRAY_TYPE:\n       tmp = build_cplus_array_type (mapcar (TREE_TYPE (t), func),\n \t\t\t\t    mapcar (TYPE_DOMAIN (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, CP_TYPE_QUALS (t));\n     case INTEGER_TYPE:\n       tmp = build_index_type (mapcar (TYPE_MAX_VALUE (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n     case OFFSET_TYPE:\n       tmp = build_offset_type (mapcar (TYPE_OFFSET_BASETYPE (t), func),\n \t\t\t       mapcar (TREE_TYPE (t), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n     case METHOD_TYPE:\n       tmp = build_cplus_method_type\n \t(mapcar (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))), func),\n \t mapcar (TREE_TYPE (t), func),\n \t mapcar (TREE_CHAIN (TYPE_ARG_TYPES (t)), func));\n-      return cp_build_type_variant (tmp, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+      return cp_build_qualified_type (tmp, TYPE_QUALS (t));\n \n     case COMPLEX_CST:\n       t = copy_node (t);"}, {"sha": "254bc394d3def86867f574893f50d73bf7135fbc", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 115, "deletions": 133, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -239,10 +239,9 @@ static tree\n qualify_type (type, like)\n      tree type, like;\n {\n-  int constflag = TYPE_READONLY (type) || TYPE_READONLY (like);\n-  int volflag = TYPE_VOLATILE (type) || TYPE_VOLATILE (like);\n   /* @@ Must do member pointers here.  */\n-  return cp_build_type_variant (type, constflag, volflag);\n+  return cp_build_qualified_type (type, (CP_TYPE_QUALS (type) \n+\t\t\t\t\t | CP_TYPE_QUALS (like)));\n }\n \f\n /* Return the common type of two parameter lists.\n@@ -498,10 +497,8 @@ common_type (t1, t2)\n       {\n \ttree tt1 = TYPE_MAIN_VARIANT (TREE_TYPE (t1));\n \ttree tt2 = TYPE_MAIN_VARIANT (TREE_TYPE (t2));\n-\tint constp\n-\t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n-\tint volatilep\n-\t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n+\tint type_quals = (CP_TYPE_QUALS (TREE_TYPE (t1)) \n+\t\t\t  | CP_TYPE_QUALS (TREE_TYPE (t2)));\n \ttree target;\n \n \tif (tt1 == tt2)\n@@ -515,7 +512,7 @@ common_type (t1, t2)\n \telse\n \t  target = common_type (tt1, tt2);\n \n-\ttarget = cp_build_type_variant (target, constp, volatilep);\n+\ttarget = cp_build_qualified_type (target, type_quals);\n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n \telse\n@@ -776,9 +773,7 @@ comptypes (type1, type2, strict)\n \n   /* Qualifiers must match.  */\n \n-  if (TYPE_READONLY (t1) != TYPE_READONLY (t2))\n-    return 0;\n-  if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))\n+  if (CP_TYPE_QUALS (t1) != CP_TYPE_QUALS (t2))\n     return 0;\n   if (strict > 0 && TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n     return 0;\n@@ -845,8 +840,7 @@ comptypes (type1, type2, strict)\n \t but not vice-versa!  */\n \n       val = (comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict)\n-\t     && compparms (TYPE_ARG_TYPES (t1),\n-\t\t\t   TYPE_ARG_TYPES (t2), strict));\n+\t     && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)));\n       break;\n \n     case POINTER_TYPE:\n@@ -888,7 +882,7 @@ comptypes (type1, type2, strict)\n \n       val = ((TREE_TYPE (t1) == TREE_TYPE (t2)\n \t      || comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n-\t     && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2), strict));\n+\t     && compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)));\n       break;\n \n     case ARRAY_TYPE:\n@@ -920,17 +914,18 @@ comp_cv_target_types (ttl, ttr, nptrs)\n      int nptrs;\n {\n   int t;\n-  int c = TYPE_READONLY (ttl) - TYPE_READONLY (ttr);\n-  int v = TYPE_VOLATILE (ttl) - TYPE_VOLATILE (ttr);\n \n-  if ((c > 0 && v < 0) || (c < 0 && v > 0))\n+  if (!at_least_as_qualified_p (ttl, ttr)\n+      && !at_least_as_qualified_p (ttr, ttl))\n+    /* The qualifications are incomparable.  */\n     return 0;\n \n   if (TYPE_MAIN_VARIANT (ttl) == TYPE_MAIN_VARIANT (ttr))\n-    return (c + v < 0) ? -1 : 1;\n+    return more_qualified_p (ttr, ttl) ? -1 : 1;\n \n   t = comp_target_types (ttl, ttr, nptrs);\n-  if ((t == 1 && c + v >= 0) || (t == -1 && c + v <= 0))\n+  if ((t == 1 && at_least_as_qualified_p (ttl, ttr)) \n+      || (t == -1 && at_least_as_qualified_p (ttr, ttl)))\n     return t;\n \n   return 0;\n@@ -1115,6 +1110,29 @@ comp_target_types (ttl, ttr, nptrs)\n   return 0;\n }\n \n+/* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n+\n+int\n+at_least_as_qualified_p (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  /* All qualifiers for TYPE2 must also appear in TYPE1.  */\n+  return ((CP_TYPE_QUALS (type1) & CP_TYPE_QUALS (type2))\n+\t  == CP_TYPE_QUALS (type2));\n+}\n+\n+/* Returns 1 if TYPE1 is more qualified than TYPE2.  */\n+\n+int\n+more_qualified_p (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  return (CP_TYPE_QUALS (type1) != CP_TYPE_QUALS (type2)\n+\t  && at_least_as_qualified_p (type1, type2));\n+}\n+\n /* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is\n    more cv-qualified that TYPE1, and 0 otherwise.  */\n \n@@ -1123,16 +1141,13 @@ comp_cv_qualification (type1, type2)\n      tree type1;\n      tree type2;\n {\n-  if (TYPE_READONLY (type1) == TYPE_READONLY (type2)\n-      && TYPE_VOLATILE (type1) == TYPE_VOLATILE (type2))\n+  if (CP_TYPE_QUALS (type1) == CP_TYPE_QUALS (type2))\n     return 0;\n \n-  if (TYPE_READONLY (type1) >= TYPE_READONLY (type2)\n-      && TYPE_VOLATILE (type1) >= TYPE_VOLATILE (type2))\n+  if (at_least_as_qualified_p (type1, type2))\n     return 1;\n \n-  if (TYPE_READONLY (type2) >= TYPE_READONLY (type1)\n-      && TYPE_VOLATILE (type2) >= TYPE_VOLATILE (type1))\n+  else if (at_least_as_qualified_p (type2, type1))\n     return -1;\n \n   return 0;\n@@ -1220,9 +1235,8 @@ common_base_type (tt1, tt2)\n    STRICT is no longer used.  */\n \n int\n-compparms (parms1, parms2, strict)\n+compparms (parms1, parms2)\n      tree parms1, parms2;\n-     int strict ATTRIBUTE_UNUSED;\n {\n   register tree t1 = parms1, t2 = parms2;\n \n@@ -1774,11 +1788,8 @@ inline_conversion (exp)\n      tree exp;\n {\n   if (TREE_CODE (exp) == FUNCTION_DECL)\n-    {\n-      tree type = build_type_variant\n-\t(TREE_TYPE (exp), TREE_READONLY (exp), TREE_THIS_VOLATILE (exp));\n-      exp = build1 (ADDR_EXPR, build_pointer_type (type), exp);\n-    }\n+    exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n+\n   return exp;\n }\n \n@@ -1802,7 +1813,7 @@ string_conv_p (totype, exp, warn)\n \n   if (TREE_CODE (exp) != STRING_CST)\n     {\n-      t = build_pointer_type (build_type_variant (t, 1, 0));\n+      t = build_pointer_type (build_qualified_type (t, TYPE_QUAL_CONST));\n       if (! comptypes (TREE_TYPE (exp), t, 1))\n \treturn 0;\n       STRIP_NOPS (exp);\n@@ -1947,8 +1958,7 @@ build_component_ref (datum, component, basetype_path, protect)\n   register tree field = NULL;\n   register tree ref;\n   tree field_type;\n-  int constp;\n-  int volatilep;\n+  int type_quals;\n \n   if (processing_template_decl)\n     return build_min_nt (COMPONENT_REF, datum, component);\n@@ -2167,8 +2177,7 @@ build_component_ref (datum, component, basetype_path, protect)\n     }\n \n   /* Compute the type of the field, as described in [expr.ref].  */\n-  constp = 0;\n-  volatilep = 0;\n+  type_quals = TYPE_UNQUALIFIED;\n   field_type = TREE_TYPE (field);\n   if (TREE_CODE (field_type) == REFERENCE_TYPE)\n     /* The standard says that the type of the result should be the\n@@ -2177,17 +2186,16 @@ build_component_ref (datum, component, basetype_path, protect)\n     ;\n   else\n     {\n+      type_quals = (CP_TYPE_QUALS (field_type)  \n+\t\t    | CP_TYPE_QUALS (TREE_TYPE (datum)));\n+\n       /* A field is const (volatile) if the enclosing object, or the\n \t field itself, is const (volatile).  But, a mutable field is\n \t not const, even within a const object.  */\n-      constp = (!(DECL_LANG_SPECIFIC (field) \n-\t\t  && DECL_MUTABLE_P (field))\n-\t\t&& (TYPE_READONLY (field_type)\n-\t\t    || TYPE_READONLY (TREE_TYPE (datum))));\n-      volatilep = (TYPE_VOLATILE (field_type)\n-\t\t   || TYPE_VOLATILE (TREE_TYPE (datum)));\n+      if (DECL_LANG_SPECIFIC (field) && DECL_MUTABLE_P (field))\n+\ttype_quals &= ~TYPE_QUAL_CONST;\n       if (!IS_SIGNATURE (field_type))\n-\tfield_type = cp_build_type_variant (field_type, constp, volatilep);\n+\tfield_type = cp_build_qualified_type (field_type, type_quals);\n     }\n \n   ref = fold (build (COMPONENT_REF, field_type,\n@@ -2196,9 +2204,9 @@ build_component_ref (datum, component, basetype_path, protect)\n   /* Mark the expression const or volatile, as appropriate.  Even\n      though we've dealt with the type above, we still have to mark the\n      expression itself.  */\n-  if (constp)\n+  if (type_quals & TYPE_QUAL_CONST)\n     TREE_READONLY (ref) = 1;\n-  else if (volatilep)\n+  else if (type_quals & TYPE_QUAL_VOLATILE)\n     TREE_THIS_VOLATILE (ref) = 1;\n \n   return ref;\n@@ -2286,8 +2294,8 @@ build_indirect_ref (ptr, errorstring)\n \t  /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n \t     so that we get the proper error message if the result is used\n \t     to assign to.  Also, &* is supposed to be a no-op.  */\n-\t  TREE_READONLY (ref) = TYPE_READONLY (t);\n-\t  TREE_THIS_VOLATILE (ref) = TYPE_VOLATILE (t);\n+\t  TREE_READONLY (ref) = CP_TYPE_CONST_P (t);\n+\t  TREE_THIS_VOLATILE (ref) = CP_TYPE_VOLATILE_P (t);\n \t  TREE_SIDE_EFFECTS (ref)\n \t    = (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (pointer)\n \t       || flag_volatile);\n@@ -2406,11 +2414,11 @@ build_array_ref (array, idx)\n       /* Array ref is const/volatile if the array elements are\n \t or if the array is..  */\n       TREE_READONLY (rval)\n-\t|= (TYPE_READONLY (type) | TREE_READONLY (array));\n+\t|= (CP_TYPE_CONST_P (type) | TREE_READONLY (array));\n       TREE_SIDE_EFFECTS (rval)\n-\t|= (TYPE_VOLATILE (type) | TREE_SIDE_EFFECTS (array));\n+\t|= (CP_TYPE_VOLATILE_P (type) | TREE_SIDE_EFFECTS (array));\n       TREE_THIS_VOLATILE (rval)\n-\t|= (TYPE_VOLATILE (type) | TREE_THIS_VOLATILE (array));\n+\t|= (CP_TYPE_VOLATILE_P (type) | TREE_THIS_VOLATILE (array));\n       return require_complete_type (fold (rval));\n     }\n \n@@ -4449,7 +4457,7 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Report something read-only.  */\n \n-      if (TYPE_READONLY (TREE_TYPE (arg))\n+      if (CP_TYPE_CONST_P (TREE_TYPE (arg))\n \t  || TREE_READONLY (arg))\n \treadonly_error (arg, ((code == PREINCREMENT_EXPR\n \t\t\t       || code == POSTINCREMENT_EXPR)\n@@ -5075,10 +5083,9 @@ build_conditional_expr (ifexp, op1, op2)\n       else if (TREE_READONLY_DECL_P (op2))\n \top2 = decl_constant_value (op2);\n       if (type1 != type2)\n-\ttype1 = cp_build_type_variant\n-\t\t\t(type1,\n-\t\t\t TYPE_READONLY (op1) || TYPE_READONLY (op2),\n-\t\t\t TYPE_VOLATILE (op1) || TYPE_VOLATILE (op2));\n+\ttype1 = cp_build_qualified_type\n+\t  (type1, (CP_TYPE_QUALS (TREE_TYPE (op1)) \n+\t\t   | CP_TYPE_QUALS (TREE_TYPE (op2))));\n       /* ??? This is a kludge to deal with the fact that\n \t we don't sort out integers and enums properly, yet.  */\n       result = fold (build (COND_EXPR, type1, ifexp, op1, op2));\n@@ -5151,10 +5158,10 @@ build_conditional_expr (ifexp, op1, op2)\n       if (type1 == type2)\n \tresult_type = type1;\n       else\n-\tresult_type = cp_build_type_variant\n-\t\t\t(type1,\n-\t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n-\t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n+\tresult_type = \n+\t  cp_build_qualified_type (type1,\n+\t\t\t\t   CP_TYPE_QUALS (TREE_TYPE (op1))\n+\t\t\t\t   | CP_TYPE_QUALS (TREE_TYPE (op2)));\n     }\n   else if ((code1 == INTEGER_TYPE || code1 == REAL_TYPE)\n            && (code2 == INTEGER_TYPE || code2 == REAL_TYPE))\n@@ -5247,7 +5254,10 @@ build_conditional_expr (ifexp, op1, op2)\n \t  tree tmp;\n \t  if (code2 == POINTER_TYPE)\n \t      tmp = build_pointer_type\n-\t\t(build_type_variant (TREE_TYPE (type2), 1, 1));\n+\t\t(cp_build_qualified_type (TREE_TYPE (type2), \n+\t\t\t\t\t  TYPE_QUAL_CONST \n+\t\t\t\t\t  | TYPE_QUAL_VOLATILE\n+\t\t\t\t\t  | TYPE_QUAL_RESTRICT));\n \t  else\n \t    tmp = type2;\n \t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op1, 0);\n@@ -5269,7 +5279,10 @@ build_conditional_expr (ifexp, op1, op2)\n \t  tree tmp;\n \t  if (code1 == POINTER_TYPE)\n \t    tmp = build_pointer_type\n-\t      (build_type_variant (TREE_TYPE (type1), 1, 1));\n+\t      (cp_build_qualified_type (TREE_TYPE (type1), \n+\t\t\t\t\tTYPE_QUAL_CONST \n+\t\t\t\t\t| TYPE_QUAL_VOLATILE\n+\t\t\t\t\t| TYPE_QUAL_RESTRICT));\n \t  else\n \t    tmp = type1;\n \n@@ -5454,10 +5467,8 @@ build_static_cast (type, expr)\n     {\n       tree binfo;\n       if (IS_AGGR_TYPE (TREE_TYPE (type)) && IS_AGGR_TYPE (TREE_TYPE (intype))\n-\t  && (TYPE_READONLY (TREE_TYPE (type))\n-\t      >= TYPE_READONLY (TREE_TYPE (intype)))\n-\t  && (TYPE_VOLATILE (TREE_TYPE (type))\n-\t      >= TYPE_VOLATILE (TREE_TYPE (intype)))\n+\t  && at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\t      TREE_TYPE (intype))\n \t  && (binfo = get_binfo (TREE_TYPE (intype), TREE_TYPE (type), 0))\n \t  && ! TREE_VIA_VIRTUAL (binfo))\n \tok = 1;\n@@ -5466,10 +5477,8 @@ build_static_cast (type, expr)\n     {\n       if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type))),\n \t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (intype))), 1)\n-\t  && (TYPE_READONLY (TREE_TYPE (TREE_TYPE (type)))\n-\t      >= TYPE_READONLY (TREE_TYPE (TREE_TYPE (intype))))\n-\t  && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (type)))\n-\t      >= TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (intype))))\n+\t  && at_least_as_qualified_p (TREE_TYPE (TREE_TYPE (type)),\n+\t\t\t\t      TREE_TYPE (TREE_TYPE (intype)))\n \t  && (binfo = get_binfo (TYPE_OFFSET_BASETYPE (TREE_TYPE (type)),\n \t\t\t\t TYPE_OFFSET_BASETYPE (TREE_TYPE (intype)), 0))\n \t  && ! TREE_VIA_VIRTUAL (binfo))\n@@ -5770,17 +5779,10 @@ build_c_cast (type, expr)\n \n       if (warn_cast_qual\n \t  && TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (otype) == POINTER_TYPE)\n-\t{\n-\t  /* For C++ we make these regular warnings, rather than\n-\t     softening them into pedwarns.  */\n-\t  if (TYPE_VOLATILE (TREE_TYPE (otype))\n-\t      && ! TYPE_VOLATILE (TREE_TYPE (type)))\n-\t    warning (\"cast discards `volatile' from pointer target type\");\n-\t  if (TYPE_READONLY (TREE_TYPE (otype))\n-\t      && ! TYPE_READONLY (TREE_TYPE (type)))\n-\t    warning (\"cast discards `const' from pointer target type\");\n-\t}\n+\t  && TREE_CODE (otype) == POINTER_TYPE\n+\t  && !at_least_as_qualified_p (TREE_TYPE (type),\n+\t\t\t\t       TREE_TYPE (otype)))\n+\tcp_warning (\"cast discards qualifiers from pointer target type\");\n \n       /* Warn about possible alignment problems.  */\n       if (STRICT_ALIGNMENT && warn_cast_align\n@@ -6067,15 +6069,15 @@ build_modify_expr (lhs, modifycode, rhs)\n       && ! (TREE_CODE (lhs) == COMPONENT_REF\n \t    && (IS_SIGNATURE_POINTER (TREE_TYPE (TREE_OPERAND (lhs, 0)))\n \t\t|| IS_SIGNATURE_REFERENCE (TREE_TYPE (TREE_OPERAND (lhs, 0)))))\n-      && (TREE_READONLY (lhs) || TYPE_READONLY (lhstype)\n+      && (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype)\n \t  /* Functions are not modifiable, even though they are\n \t     lvalues.  */\n \t  || TREE_CODE (TREE_TYPE (lhs)) == FUNCTION_TYPE\n \t  || ((TREE_CODE (lhstype) == RECORD_TYPE\n \t       || TREE_CODE (lhstype) == UNION_TYPE)\n \t      && C_TYPE_FIELDS_READONLY (lhstype))\n \t  || (TREE_CODE (lhstype) == REFERENCE_TYPE\n-\t      && TYPE_READONLY (TREE_TYPE (lhstype)))))\n+\t      && CP_TYPE_CONST_P (TREE_TYPE (lhstype)))))\n     readonly_error (lhs, \"assignment\", 0);\n \n   /* If storing into a structure or union member,\n@@ -6751,22 +6753,13 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (binfo == 0)\n \t    return error_not_base_type (ttl, ttr);\n \n-\t  if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t  if (!at_least_as_qualified_p (ttl, ttr))\n \t    {\n \t      if (fndecl)\n-\t\tcp_error (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\tcp_error (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n \t\t\t  rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_error (\"%s to `%T' from `%T' discards const\",\n-\t\t\t  errtype, type, rhstype);\n-\t    }\n-\t  if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t    {\n-\t      if (fndecl)\n-\t\tcp_error (\"passing `%T' as argument %P of `%D' discards volatile\",\n-\t\t\t  rhstype, parmnum, fndecl);\n-\t      else\n-\t\tcp_error (\"%s to `%T' from `%T' discards volatile\",\n+\t\tcp_error (\"%s to `%T' from `%T' discards qualifiers\",\n \t\t\t  errtype, type, rhstype);\n \t    }\n \t}\n@@ -6815,24 +6808,15 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t  error (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n \t\t  return error_mark_node;\n \t\t}\n-\t      else if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t      else if (!at_least_as_qualified_p (ttl, ttr))\n \t\t{\n \t\t  if (string_conv_p (type, rhs, 1))\n \t\t    /* converting from string constant to char *, OK.  */;\n \t\t  else if (fndecl)\n-\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n \t\t\t      rhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_error (\"%s to `%T' from `%T' discards const\",\n-\t\t\t\terrtype, type, rhstype);\n-\t\t}\n-\t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards volatile\",\n-\t\t\t\trhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_error (\"%s to `%T' from `%T' discards volatile\",\n+\t\t    cp_error (\"%s to `%T' from `%T' discards qualifiers\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      else if (TREE_CODE (ttl) == TREE_CODE (ttr)\n@@ -6849,7 +6833,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t}\n       else\n \t{\n-\t  int add_quals = 0, const_parity = 0, volatile_parity = 0;\n+\t  int add_quals = 0;\n+\t  int drops_quals = 0;\n \t  int left_const = 1;\n \t  int unsigned_parity;\n \t  int nptrs = 0;\n@@ -6858,12 +6843,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  for (; ; ttl = TREE_TYPE (ttl), ttr = TREE_TYPE (ttr))\n \t    {\n \t      nptrs -= 1;\n-\t      const_parity |= (TYPE_READONLY (ttl) < TYPE_READONLY (ttr));\n-\t      volatile_parity |= (TYPE_VOLATILE (ttl) < TYPE_VOLATILE (ttr));\n+\t      drops_quals |= !at_least_as_qualified_p (ttl, ttr);\n \n \t      if (! left_const\n-\t\t  && (TYPE_READONLY (ttl) > TYPE_READONLY (ttr)\n-\t\t      || TYPE_VOLATILE (ttl) > TYPE_VOLATILE (ttr)))\n+\t\t  && !at_least_as_qualified_p (ttr, ttl))\n \t\tadd_quals = 1;\n \t      left_const &= TYPE_READONLY (ttl);\n \n@@ -6891,24 +6874,15 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t    cp_pedwarn (\"%s to `%T' from `%T' adds cv-quals without intervening `const'\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n-\t      if (const_parity)\n+\t      if (drops_quals)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards const\",\n+\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards qualifiers\",\n \t\t\t      rhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_error (\"%s to `%T' from `%T' discards const\",\n+\t\t    cp_error (\"%s to `%T' from `%T' discards qualifiers\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n-\t      if (volatile_parity)\n-\t\t{\n-\t\t  if (fndecl)\n-\t\t    cp_error (\"passing `%T' as argument %P of `%D' discards volatile\",\n-\t\t\t      rhstype, parmnum, fndecl);\n-\t\t  else\n-\t\t    cp_error (\"%s to `%T' from `%T' discards volatile\",\n-\t\t\t      errtype, type, rhstype);\n-\t\t}\n \t      if (unsigned_parity > 0)\n \t\t{\n \t\t  if (fndecl)\n@@ -7215,7 +7189,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       else\n \t{\n \t  tree type = TREE_TYPE (o[i]);\n-\t  if (TYPE_READONLY (type)\n+\t  if (CP_TYPE_CONST_P (type)\n \t      || ((TREE_CODE (type) == RECORD_TYPE\n \t\t   || TREE_CODE (type) == UNION_TYPE)\n \t\t  && C_TYPE_FIELDS_READONLY (type)))\n@@ -7532,12 +7506,10 @@ comp_ptr_ttypes_real (to, from, constp)\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n \t{\n-\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n-\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\t  if (!at_least_as_qualified_p (to, from))\n \t    return 0;\n \n-\t  if (TYPE_READONLY (to) > TYPE_READONLY (from)\n-\t      || TYPE_VOLATILE (to) > TYPE_VOLATILE (from))\n+\t  if (!at_least_as_qualified_p (from, to))\n \t    {\n \t      if (constp == 0)\n \t\treturn 0;\n@@ -7633,13 +7605,11 @@ comp_ptr_ttypes_reinterpret (to, from)\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n \t{\n-\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n-\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\t  if (!at_least_as_qualified_p (to, from))\n \t    return 0;\n \n \t  if (! constp\n-\t      && (TYPE_READONLY (to) > TYPE_READONLY (from)\n-\t\t  || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n+\t      && !at_least_as_qualified_p (from, to))\n \t    return 0;\n \t  constp &= TYPE_READONLY (to);\n \t}\n@@ -7648,3 +7618,15 @@ comp_ptr_ttypes_reinterpret (to, from)\n \treturn 1;\n     }\n }\n+\n+/* Returns the type-qualifier set corresponding to TYPE.  */\n+\n+int\n+cp_type_quals (type)\n+     tree type;\n+{\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  return TYPE_QUALS (type);\n+}"}, {"sha": "7c26da1aea3ca0a67d485eec9c6c865ae129259d", "filename": "gcc/testsuite/g++.old-deja/g++.other/const1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fconst1.C?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -0,0 +1,9 @@\n+// Build don't link:\n+\n+struct S\n+{\n+  void f()\n+    {\n+      const int i; // ERROR - uninitialized const\n+    }\n+};"}, {"sha": "d9dd6575aec02ca0e2ce20b0fb9f74b6a2dbc612", "filename": "gcc/testsuite/g++.old-deja/g++.other/dcast1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdcast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdcast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdcast1.C?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+\n+class C {\n+public:\n+  virtual void f();\n+};\n+\n+extern volatile C* cp;\n+extern volatile C& cr;\n+\n+void f ()\n+{\n+  dynamic_cast<void*>(cp); // ERROR - cannot dynamic_cast\n+  dynamic_cast<C&>(cr); // ERROR - cannot dynamic_cast\n+}"}, {"sha": "80df498e6e164b30753e2a05c73871d184e6b38f", "filename": "gcc/testsuite/g++.old-deja/g++.other/init8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finit8.C?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -7,5 +7,5 @@\n void\n f()\n {\n-  const int var [ 10 ]; // ERROR - missing initializer - XFAIL *-*-*\n+  const int var [ 10 ]; // ERROR - missing initializer \n }"}, {"sha": "a3ebbcd40e17d71a31229c628a58b993149ab255", "filename": "gcc/testsuite/g++.old-deja/g++.other/virtual2.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual2.C?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -0,0 +1,19 @@\n+struct B\n+{\n+  virtual int f() volatile\n+    { return 0; }\n+};\n+\n+\n+struct D : public B \n+{\n+  virtual int f()\n+    { return 1; }\n+};\n+\n+int main()\n+{\n+  volatile D d;\n+  volatile B& b = d;\n+  return b.f();\n+}"}, {"sha": "b9a771910309766365f728501efedc05ac1627db", "filename": "gcc/testsuite/g++.old-deja/g++.other/virtual3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual3.C?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -0,0 +1,24 @@\n+struct B\n+{\n+  virtual int f() volatile\n+    { return 1; }\n+};\n+\n+struct D : public B \n+{\n+  int f() \n+    { return 0; }\n+};\n+\n+struct D2 : public D\n+{\n+  int f()\n+    { return 2; } \n+};\n+\n+int main()\n+{\n+  D2 d2;\n+  D& d = d2;\n+  return d.f();\n+}"}, {"sha": "4a4a12965e5575be4ef1abafa0b7cde8feed262d", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 135, "deletions": 55, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91063b51383fe008c4509822a66761f6fc7cf334/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91063b51383fe008c4509822a66761f6fc7cf334/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=91063b51383fe008c4509822a66761f6fc7cf334", "patch": "@@ -126,8 +126,7 @@ struct work_stuff\n   int constructor;\n   int destructor;\n   int static_type;\t/* A static member function */\n-  int const_type;\t/* A const member function */\n-  int volatile_type;    /* A volatile member function */\n+  int type_quals;       /* The type qualifiers.  */\n   int dllimported;\t/* Symbol imported from a PE DLL */\n   char **tmpl_argvec;   /* Template function arguments. */\n   int ntmpl_args;       /* The number of template function arguments. */\n@@ -392,6 +391,24 @@ static int\n demangle_template_value_parm PARAMS ((struct work_stuff*, const char**, \n \t\t\t\t      string*, type_kind_t));\n \n+/* There is a TYPE_QUAL value for each type qualifier.  They can be\n+   combined by bitwise-or to form the complete set of qualifiers for a\n+   type.  */\n+\n+#define TYPE_UNQUALIFIED   0x0\n+#define TYPE_QUAL_CONST    0x1\n+#define TYPE_QUAL_VOLATILE 0x2\n+#define TYPE_QUAL_RESTRICT 0x4\n+\n+static int \n+code_for_qualifier PARAMS ((char));\n+\n+static const char*\n+qualifier_string PARAMS ((int));\n+\n+static const char*\n+demangle_qualifier PARAMS ((char));\n+\n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n     Trying to consume something that isn't a count results in\n@@ -448,6 +465,84 @@ consume_count_with_underscores (mangled)\n   return idx;\n }\n \n+/* C is the code for a type-qualifier.  Return the TYPE_QUAL\n+   corresponding to this qualifier.  */\n+\n+static int\n+code_for_qualifier (c)\n+     char c;\n+{\n+  switch (c) \n+    {\n+    case 'C':\n+      return TYPE_QUAL_CONST;\n+\n+    case 'V':\n+      return TYPE_QUAL_VOLATILE;\n+      \n+    case 'u':\n+      return TYPE_QUAL_RESTRICT;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* C was an invalid qualifier.  */\n+  abort ();\n+}\n+\n+/* Return the string corresponding to the qualifiers given by\n+   TYPE_QUALS.  */\n+\n+static const char*\n+qualifier_string (type_quals)\n+     int type_quals;\n+{\n+  switch (type_quals)\n+    {\n+    case TYPE_UNQUALIFIED:\n+      return \"\";\n+\n+    case TYPE_QUAL_CONST:\n+      return \"const\";\n+\n+    case TYPE_QUAL_VOLATILE:\n+      return \"volatile\";\n+\n+    case TYPE_QUAL_RESTRICT:\n+      return \"__restrict\";\n+\n+    case TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE:\n+      return \"const volatile\";\n+\n+    case TYPE_QUAL_CONST | TYPE_QUAL_RESTRICT:\n+      return \"const __restrict\";\n+\n+    case TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n+      return \"volatile __restrict\";\n+\n+    case TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT:\n+      return \"const volatile __restrict\";\n+\n+    default:\n+      break;\n+    }\n+\n+  /* TYPE_QUALS was an invalid qualifier set.  */\n+  abort ();\n+}\n+\n+/* C is the code for a type-qualifier.  Return the string\n+   corresponding to this qualifier.  This function should only be\n+   called with a valid qualifier code.  */\n+\n+static const char*\n+demangle_qualifier (c)\n+     char c;\n+{\n+  return qualifier_string (code_for_qualifier (c));\n+}\n+\n int\n cplus_demangle_opname (opname, result, options)\n      const char *opname;\n@@ -664,15 +759,12 @@ internal_cplus_demangle (work, mangled)\n   int success = 0;\n   char *demangled = NULL;\n   int s1,s2,s3,s4;\n-  int saved_volatile_type;\n   s1 = work->constructor;\n   s2 = work->destructor;\n   s3 = work->static_type;\n-  s4 = work->const_type;\n-  saved_volatile_type = work->volatile_type;\n+  s4 = work->type_quals;\n   work->constructor = work->destructor = 0;\n-  work->static_type = work->const_type = 0;\n-  work->volatile_type = 0;\n+  work->type_quals = TYPE_UNQUALIFIED;\n   work->dllimported = 0;\n \n   if ((mangled != NULL) && (*mangled != '\\0'))\n@@ -718,8 +810,7 @@ internal_cplus_demangle (work, mangled)\n   work->constructor = s1;\n   work->destructor = s2;\n   work->static_type = s3;\n-  work->const_type = s4;\n-  work->volatile_type = saved_volatile_type;\n+  work->type_quals = s4;\n   return (demangled);\n }\n \n@@ -871,10 +962,8 @@ demangle_signature (work, mangled, declp)\n \n \tcase 'C':\n \tcase 'V':\n-\t  if (**mangled == 'C')\n-\t    work -> const_type = 1;\n-\t  else\n-\t    work->volatile_type = 1;\n+\tcase 'u':\n+\t  work->type_quals |= code_for_qualifier (**mangled);\n \n \t  /* a qualified member function */\n \t  if (oldmangled == NULL)\n@@ -1056,12 +1145,16 @@ demangle_signature (work, mangled, declp)\n \t  success = demangle_args (work, mangled, declp);\n \t}\n     }\n-  if (success && work -> static_type && PRINT_ARG_TYPES)\n-    string_append (declp, \" static\");\n-  if (success && work -> const_type && PRINT_ARG_TYPES)\n-    string_append (declp, \" const\");\n-  else if (success && work->volatile_type && PRINT_ARG_TYPES)\n-    string_append (declp, \" volatile\");\n+  if (success && PRINT_ARG_TYPES)\n+    {\n+      if (work->static_type)\n+\tstring_append (declp, \" static\");\n+      if (work->type_quals != TYPE_UNQUALIFIED)\n+\t{\n+\t  APPEND_BLANK (declp);\n+\t  string_append (declp, qualifier_string (work->type_quals));\n+\t}\n+    }\n \n   return (success);\n }\n@@ -1345,6 +1438,8 @@ demangle_template_value_parm (work, mangled, s, tk)\n \t  p [symbol_len] = '\\0';\n \t  q = internal_cplus_demangle (work, p);\n \t  string_appendn (s, \"&\", 1);\n+\t  /* FIXME: Pointer-to-member constants should get a\n+\t            qualifying class name here.  */\n \t  if (q)\n \t    {\n \t      string_append (s, q);\n@@ -2481,8 +2576,7 @@ do_type (work, mangled, result)\n   int success;\n   string decl;\n   const char *remembered_type;\n-  int constp;\n-  int volatilep;\n+  int type_quals;\n   string btype;\n   type_kind_t tk = tk_none;\n \n@@ -2574,8 +2668,7 @@ do_type (work, mangled, result)\n \tcase 'M':\n \tcase 'O':\n \t  {\n-\t    constp = 0;\n-\t    volatilep = 0;\n+\t    type_quals = TYPE_UNQUALIFIED;\n \n \t    member = **mangled == 'M';\n \t    (*mangled)++;\n@@ -2615,16 +2708,19 @@ do_type (work, mangled, result)\n \t    string_prepend (&decl, \"(\");\n \t    if (member)\n \t      {\n-\t\tif (**mangled == 'C')\n-\t\t  {\n-\t\t    (*mangled)++;\n-\t\t    constp = 1;\n-\t\t  }\n-\t\tif (**mangled == 'V')\n+\t\tswitch (**mangled)\n \t\t  {\n+\t\t  case 'C':\n+\t\t  case 'V':\n+\t\t  case 'u':\n+\t\t    type_quals |= code_for_qualifier (**mangled);\n \t\t    (*mangled)++;\n-\t\t    volatilep = 1;\n+\t\t    break;\n+\n+\t\t  default:\n+\t\t    break;\n \t\t  }\n+\n \t\tif (*(*mangled)++ != 'F')\n \t\t  {\n \t\t    success = 0;\n@@ -2642,15 +2738,10 @@ do_type (work, mangled, result)\n \t      {\n \t\tbreak;\n \t      }\n-\t    if (constp)\n+\t    if (type_quals != TYPE_UNQUALIFIED)\n \t      {\n \t\tAPPEND_BLANK (&decl);\n-\t\tstring_append (&decl, \"const\");\n-\t      }\n-\t    if (volatilep)\n-\t      {\n-\t\tAPPEND_BLANK (&decl);\n-\t\tstring_append (&decl, \"volatile\");\n+\t\tstring_append (&decl, qualifier_string (type_quals));\n \t      }\n \t    break;\n \t  }\n@@ -2660,18 +2751,13 @@ do_type (work, mangled, result)\n \n \tcase 'C':\n \tcase 'V':\n-\t  /*\n-\t    if ((*mangled)[1] == 'P')\n-\t    {\n-\t    */\n+\tcase 'u':\n \t  if (PRINT_ANSI_QUALIFIERS)\n \t    {\n \t      if (!STRING_EMPTY (&decl))\n-\t\t{\n-\t\t  string_prepend (&decl, \" \");\n-\t\t}\n-\t      string_prepend (&decl, \n-\t\t\t      (**mangled) == 'C' ? \"const\" : \"volatile\");\n+\t\tstring_prepend (&decl, \" \");\n+\n+\t      string_prepend (&decl, demangle_qualifier (**mangled));\n \t    }\n \t  (*mangled)++;\n \t  break;\n@@ -2794,11 +2880,13 @@ demangle_fund_type (work, mangled, result)\n       switch (**mangled)\n \t{\n \tcase 'C':\n+\tcase 'V':\n+\tcase 'u':\n \t  (*mangled)++;\n \t  if (PRINT_ANSI_QUALIFIERS)\n \t    {\n \t      APPEND_BLANK (result);\n-\t      string_append (result, \"const\");\n+\t      string_append (result, demangle_qualifier (**mangled));\n \t    }\n \t  break;\n \tcase 'U':\n@@ -2811,14 +2899,6 @@ demangle_fund_type (work, mangled, result)\n \t  APPEND_BLANK (result);\n \t  string_append (result, \"signed\");\n \t  break;\n-\tcase 'V':\n-\t  (*mangled)++;\n-\t  if (PRINT_ANSI_QUALIFIERS)\n-\t    {\n-\t      APPEND_BLANK (result);\n-\t      string_append (result, \"volatile\");\n-\t    }\n-\t  break;\n \tcase 'J':\n \t  (*mangled)++;\n \t  APPEND_BLANK (result);"}]}