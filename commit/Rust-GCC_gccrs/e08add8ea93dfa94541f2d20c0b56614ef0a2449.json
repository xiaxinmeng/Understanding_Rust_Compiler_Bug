{"sha": "e08add8ea93dfa94541f2d20c0b56614ef0a2449", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA4YWRkOGVhOTNkZmE5NDU0MWYyZDIwYzBiNTY2MTRlZjBhMjQ0OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T09:55:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T09:55:31Z"}, "message": "[multiple changes]\n\n2014-08-01  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Remove VMS specific rules for pragma Ident.\n\t* Makefile.rtl, adaint.c, gnat_rm.texi, s-asthan.adb, s-asthan.ads,\n\ts-filofl.ads, s-fishfl.ads, s-fvadfl.ads, s-fvaffl.ads, s-fvagfl.ads,\n\ts-po32gl.adb, s-po32gl.ads, s-vaflop.adb, s-vaflop.ads, s-vmexta.adb,\n\ts-vmexta.ads, sem_vfpt.adb, sem_vfpt.ads, socket.c: Remove VMS specific\n\tcode.\n\t* gcc-interface/decl.c, gcc-interface/Makefile.in,\n\tgcc-interface/Make-lang.in: Ditto. Also remove refs to rTX.\n\n2014-08-01  Pascal Obry  <obry@adacore.com>\n\n\t* s-os_lib.ads: Rename File_Size to Large_File_Size.\n\nFrom-SVN: r213438", "tree": {"sha": "cfb5ed0ca60c0acf412567b89fe656268827d52f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb5ed0ca60c0acf412567b89fe656268827d52f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e08add8ea93dfa94541f2d20c0b56614ef0a2449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08add8ea93dfa94541f2d20c0b56614ef0a2449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08add8ea93dfa94541f2d20c0b56614ef0a2449", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08add8ea93dfa94541f2d20c0b56614ef0a2449/comments", "author": null, "committer": null, "parents": [{"sha": "21c51f53f0145dd812b2231e03116f49fadcd004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21c51f53f0145dd812b2231e03116f49fadcd004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21c51f53f0145dd812b2231e03116f49fadcd004"}], "stats": {"total": 2932, "additions": 86, "deletions": 2846}, "files": [{"sha": "08dc0bc956fae1e66a385071bf966abacb129c7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -1,3 +1,18 @@\n+2014-08-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Remove VMS specific rules for pragma Ident.\n+\t* Makefile.rtl, adaint.c, gnat_rm.texi, s-asthan.adb, s-asthan.ads,\n+\ts-filofl.ads, s-fishfl.ads, s-fvadfl.ads, s-fvaffl.ads, s-fvagfl.ads,\n+\ts-po32gl.adb, s-po32gl.ads, s-vaflop.adb, s-vaflop.ads, s-vmexta.adb,\n+\ts-vmexta.ads, sem_vfpt.adb, sem_vfpt.ads, socket.c: Remove VMS specific\n+\tcode.\n+\t* gcc-interface/decl.c, gcc-interface/Makefile.in,\n+\tgcc-interface/Make-lang.in: Ditto. Also remove refs to rTX.\n+\n+2014-08-01  Pascal Obry  <obry@adacore.com>\n+\n+\t* s-os_lib.ads: Rename File_Size to Large_File_Size.\n+\n 2014-08-01  Robert Dewar  <dewar@adacore.com>\n \n \t* a-numaux-vxworks.ads, a-numaux-x86.adb, a-numaux-x86.ads,"}, {"sha": "cfab8cf350a2511f933d1fc370a8a722440fec78", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -44,7 +44,6 @@ GNATRTL_TASKING_OBJS= \\\n   g-signal$(objext) \\\n   g-tastus$(objext) \\\n   g-thread$(objext) \\\n-  s-asthan$(objext) \\\n   s-inmaop$(objext) \\\n   s-interr$(objext) \\\n   s-intman$(objext) \\\n@@ -540,15 +539,10 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-ficobl$(objext) \\\n   s-filatt$(objext) \\\n   s-fileio$(objext) \\\n-  s-filofl$(objext) \\\n   s-finmas$(objext) \\\n   s-finroo$(objext) \\\n-  s-fishfl$(objext) \\\n   s-flocon$(objext) \\\n   s-fore$(objext)   \\\n-  s-fvadfl$(objext) \\\n-  s-fvaffl$(objext) \\\n-  s-fvagfl$(objext) \\\n   s-gearop$(objext) \\\n   s-geveop$(objext) \\\n   s-gloloc$(objext) \\\n@@ -674,7 +668,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-traent$(objext) \\\n   s-unstyp$(objext) \\\n   s-utf_32$(objext) \\\n-  s-vaflop$(objext) \\\n   s-valboo$(objext) \\\n   s-valcha$(objext) \\\n   s-valdec$(objext) \\\n@@ -690,7 +683,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-veboop$(objext) \\\n   s-vector$(objext) \\\n   s-vercon$(objext) \\\n-  s-vmexta$(objext) \\\n   s-wchcnv$(objext) \\\n   s-wchcon$(objext) \\\n   s-wchjis$(objext) \\"}, {"sha": "44839eab5a967e8274209bdeb656575a18278907", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 26, "deletions": 971, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -71,12 +71,6 @@\n #include <sys/pstat.h>\n #endif\n \n-#ifdef VMS\n-#define _POSIX_EXIT 1\n-#define HOST_EXECUTABLE_SUFFIX \".exe\"\n-#define HOST_OBJECT_SUFFIX \".obj\"\n-#endif\n-\n #ifdef __PikeOS__\n #define __BSD_VISIBLE 1\n #endif\n@@ -87,9 +81,6 @@\n #include <sys/stat.h>\n #include <fcntl.h>\n #include <time.h>\n-#ifdef VMS\n-#include <unixio.h>\n-#endif\n \n #if defined (__vxworks) || defined (__ANDROID__)\n /* S_IREAD and S_IWRITE are not defined in VxWorks or Android */\n@@ -147,7 +138,7 @@ UINT CurrentCCSEncoding;\n #include <utime.h>\n #undef VMOS_DEV\n \n-#elif !defined (VMS)\n+#else\n #include <utime.h>\n #endif\n \n@@ -174,75 +165,17 @@ UINT CurrentCCSEncoding;\n #endif\n \n #if defined (_WIN32)\n-#elif defined (VMS)\n-\n-/* Header files and definitions for __gnat_set_file_time_name.  */\n-\n-#define __NEW_STARLET 1\n-#include <vms/rms.h>\n-#include <vms/atrdef.h>\n-#include <vms/fibdef.h>\n-#include <vms/stsdef.h>\n-#include <vms/iodef.h>\n-#include <errno.h>\n-#include <vms/descrip.h>\n-#include <string.h>\n-#include <unixlib.h>\n-\n-/* Use native 64-bit arithmetic.  */\n-#define unix_time_to_vms(X,Y) \\\n-  {                                                 \\\n-    unsigned long long reftime, tmptime = (X);      \\\n-    $DESCRIPTOR (unixtime,\"1-JAN-1970 0:00:00.00\"); \\\n-    SYS$BINTIM (&unixtime, &reftime);               \\\n-    Y = tmptime * 10000000 + reftime;               \\\n-  }\n-\n-/* descrip.h doesn't have everything ... */\n-typedef struct fibdef* __fibdef_ptr32 __attribute__ (( mode (SI) ));\n-struct dsc$descriptor_fib\n-{\n-  unsigned int fib$l_len;\n-  __fibdef_ptr32 fib$l_addr;\n-};\n-\n-/* I/O Status Block.  */\n-struct IOSB\n-{\n-  unsigned short status, count;\n-  unsigned int devdep;\n-};\n-\n-static char *tryfile;\n \n-/* Variable length string.  */\n-struct vstring\n-{\n-  short length;\n-  char string[NAM$C_MAXRSS+1];\n-};\n-\n-#define SYI$_ACTIVECPU_CNT 0x111e\n-extern int LIB$GETSYI (int *, unsigned int *);\n-extern unsigned int LIB$CALLG_64 (unsigned long long argument_list [],\n-\t\t\t\t  int (*user_procedure)(void));\n-\n-#else\n-#include <utime.h>\n-#endif\n-\n-#if defined (_WIN32)\n #include <process.h>\n-#endif\n-\n-#if defined (_WIN32)\n-\n #include <dir.h>\n #include <windows.h>\n #include <accctrl.h>\n #include <aclapi.h>\n #undef DIR_SEPARATOR\n #define DIR_SEPARATOR '\\\\'\n+\n+#else\n+#include <utime.h>\n #endif\n \n #include \"adaint.h\"\n@@ -315,27 +248,12 @@ char __gnat_path_separator = PATH_SEPARATOR;\n        as well. This is only a temporary work-around for 3.11b.  */\n \n #ifndef GNAT_LIBRARY_TEMPLATE\n-#if defined (VMS)\n-#define GNAT_LIBRARY_TEMPLATE \"*.olb\"\n-#else\n #define GNAT_LIBRARY_TEMPLATE \"lib*.a\"\n #endif\n-#endif\n \n const char *__gnat_library_template = GNAT_LIBRARY_TEMPLATE;\n \n-/* This variable is used in hostparm.ads to say whether the host is a VMS\n-   system.  */\n-#ifdef VMS\n-int __gnat_vmsp = 1;\n-#else\n-int __gnat_vmsp = 0;\n-#endif\n-\n-#if defined (VMS)\n-#define GNAT_MAX_PATH_LEN 256 /* PATH_MAX */\n-\n-#elif defined (__vxworks) || defined (__OPENNT) || defined(__nucleus__)\n+#if defined (__vxworks) || defined (__OPENNT) || defined(__nucleus__)\n #define GNAT_MAX_PATH_LEN PATH_MAX\n \n #else\n@@ -382,37 +300,7 @@ int __gnat_use_acl = 1;\n    system provides the routine readdir_r.  */\n #undef HAVE_READDIR_R\n \f\n-#if defined(VMS) && defined (__LONG_POINTERS)\n-\n-/* Return a 32 bit pointer to an array of 32 bit pointers\n-   given a 64 bit pointer to an array of 64 bit pointers */\n-\n-typedef __char_ptr32 *__char_ptr_char_ptr32 __attribute__ ((mode (SI)));\n-\n-static __char_ptr_char_ptr32\n-to_ptr32 (char **ptr64)\n-{\n-  int argc;\n-  __char_ptr_char_ptr32 short_argv;\n-\n-  for (argc = 0; ptr64[argc]; argc++)\n-    ;\n-\n-  /* Reallocate argv with 32 bit pointers.  */\n-  short_argv = (__char_ptr_char_ptr32) decc$malloc\n-    (sizeof (__char_ptr32) * (argc + 1));\n-\n-  for (argc = 0; ptr64[argc]; argc++)\n-    short_argv[argc] = (__char_ptr32) decc$strdup (ptr64[argc]);\n-\n-  short_argv[argc] = (__char_ptr32) 0;\n-  return short_argv;\n-\n-}\n-#define MAYBE_TO_PTR32(argv) to_ptr32 (argv)\n-#else\n #define MAYBE_TO_PTR32(argv) argv\n-#endif\n \n static const char ATTR_UNSET = 127;\n \n@@ -485,12 +373,7 @@ __gnat_to_gm_time (OS_Time *p_time, int *p_year, int *p_month, int *p_day,\n     time++;\n #endif\n \n-#ifdef VMS\n-  res = localtime (&time);\n-#else\n   res = gmtime (&time);\n-#endif\n-\n   if (res)\n     {\n       *p_year = res->tm_year;\n@@ -533,7 +416,7 @@ __gnat_readlink (char *path ATTRIBUTE_UNUSED,\n \t\t char *buf ATTRIBUTE_UNUSED,\n \t\t size_t bufsiz ATTRIBUTE_UNUSED)\n {\n-#if defined (_WIN32) || defined (VMS) \\\n+#if defined (_WIN32) \\\n   || defined(__vxworks) || defined (__nucleus__) || defined (__PikeOS__)\n   return -1;\n #else\n@@ -549,7 +432,7 @@ int\n __gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,\n \t\tchar *newpath ATTRIBUTE_UNUSED)\n {\n-#if defined (_WIN32) || defined (VMS) \\\n+#if defined (_WIN32) \\\n   || defined(__vxworks) || defined (__nucleus__) || defined (__PikeOS__)\n   return -1;\n #else\n@@ -560,7 +443,7 @@ __gnat_symlink (char *oldpath ATTRIBUTE_UNUSED,\n /* Try to lock a file, return 1 if success.  */\n \n #if defined (__vxworks) || defined (__nucleus__) \\\n-  || defined (_WIN32) || defined (VMS) || defined (__PikeOS__)\n+  || defined (_WIN32) || defined (__PikeOS__)\n \n /* Version that does not use link. */\n \n@@ -632,14 +515,7 @@ __gnat_try_lock (char *dir, char *file)\n int\n __gnat_get_maximum_file_name_length (void)\n {\n-#if defined (VMS)\n-  if (getenv (\"GNAT$EXTENDED_FILE_SPECIFICATIONS\"))\n-    return -1;\n-  else\n-    return 39;\n-#else\n   return -1;\n-#endif\n }\n \n /* Return nonzero if file names are case sensitive.  */\n@@ -658,7 +534,7 @@ __gnat_get_file_names_case_sensitive (void)\n           && sensitive[1] == '\\0')\n         file_names_case_sensitive_cache = sensitive[0] - '0';\n       else\n-#if defined (VMS) || defined (WINNT) || defined (__APPLE__)\n+#if defined (WINNT) || defined (__APPLE__)\n         file_names_case_sensitive_cache = 0;\n #else\n         file_names_case_sensitive_cache = 1;\n@@ -672,7 +548,7 @@ __gnat_get_file_names_case_sensitive (void)\n int\n __gnat_get_env_vars_case_sensitive (void)\n {\n-#if defined (VMS) || defined (WINNT)\n+#if defined (WINNT)\n  return 0;\n #else\n  return 1;\n@@ -697,9 +573,6 @@ __gnat_get_current_dir (char *dir, int *length)\n \n   WS2SC (dir, wdir, GNAT_MAX_PATH_LEN);\n \n-#elif defined (VMS)\n-   /* Force Unix style, which is what GNAT uses internally.  */\n-   getcwd (dir, *length, 0);\n #else\n    getcwd (dir, *length);\n #endif\n@@ -888,38 +761,7 @@ __gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED,\n     S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n \n   return _tfopen (wpath, wmode);\n-#elif defined (VMS)\n-  if (vms_form == 0)\n-    return decc$fopen (path, mode);\n-  else\n-    {\n-       char *local_form = (char *) alloca (strlen (vms_form) + 1);\n-       /* Allocate an argument list of guaranteed ample length.  */\n-       unsigned long long *arg_list =\n-        (unsigned long long *) alloca (strlen (vms_form) + 3);\n-       char *ptrb, *ptre;\n-       int i;\n-\n-       arg_list [1] = (unsigned long long) path;\n-       arg_list [2] = (unsigned long long) mode;\n-       strcpy (local_form, vms_form);\n-\n-       /* Given a string such as \"\\\"rfm=udf\\\",\\\"rat=cr\\\"\"\n-          Split it into an argument list as \"rfm=udf\",\"rat=cr\".  */\n-       ptrb = local_form;\n-       for (i = 0; *ptrb; i++)\n-         {\n-            ptrb = strchr (ptrb, '\"');\n-            ptre = strchr (ptrb + 1, '\"');\n-            *ptre = 0;\n-            arg_list [i + 3] = (unsigned long long) (ptrb + 1);\n-            ptrb = ptre + 1;\n-         }\n-       arg_list [0] = i + 2;\n-       /* CALLG_64 returns int , fortunately (FILE *) on VMS is a\n-          always a 32bit pointer.   */\n-       return LIB$CALLG_64 (arg_list, &decc$fopen);\n-    }\n+\n #else\n   return GNAT_FOPEN (path, mode);\n #endif\n@@ -946,39 +788,6 @@ __gnat_freopen (char *path,\n     S2WS (wpath, path, GNAT_MAX_PATH_LEN);\n \n   return _tfreopen (wpath, wmode, stream);\n-#elif defined (VMS)\n-  if (vms_form == 0)\n-    return decc$freopen (path, mode, stream);\n-  else\n-    {\n-       char *local_form = (char *) alloca (strlen (vms_form) + 1);\n-       /* Allocate an argument list of guaranteed ample length.  */\n-       unsigned long long *arg_list =\n-        (unsigned long long *) alloca (strlen (vms_form) + 4);\n-       char *ptrb, *ptre;\n-       int i;\n-\n-       arg_list [1] = (unsigned long long) path;\n-       arg_list [2] = (unsigned long long) mode;\n-       arg_list [3] = (unsigned long long) stream;\n-       strcpy (local_form, vms_form);\n-\n-       /* Given a string such as \"\\\"rfm=udf\\\",\\\"rat=cr\\\"\"\n-          Split it into an argument list as \"rfm=udf\",\"rat=cr\".  */\n-       ptrb = local_form;\n-       for (i = 0; *ptrb; i++)\n-         {\n-            ptrb = strchr (ptrb, '\"');\n-            ptre = strchr (ptrb + 1, '\"');\n-            *ptre = 0;\n-            arg_list [i + 4] = (unsigned long long) (ptrb + 1);\n-            ptrb = ptre + 1;\n-         }\n-       arg_list [0] = i + 3;\n-       /* CALLG_64 returns int , fortunately (FILE *) on VMS is a\n-          always a 32bit pointer.   */\n-       return LIB$CALLG_64 (arg_list, &decc$freopen);\n-    }\n #else\n   return freopen (path, mode, stream);\n #endif\n@@ -993,11 +802,7 @@ __gnat_open_read (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  /* Optional arguments mbc,deq,fop increase read performance.  */\n-  fd = open (path, O_RDONLY | o_fmode, 0444,\n-             \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__vxworks)\n+#if defined (__vxworks)\n   fd = open (path, O_RDONLY | o_fmode, 0444);\n #elif defined (__MINGW32__)\n  {\n@@ -1015,15 +820,6 @@ __gnat_open_read (char *path, int fmode)\n \n #if defined (__MINGW32__)\n #define PERM (S_IREAD | S_IWRITE)\n-#elif defined (VMS)\n-/* Excerpt from DECC C RTL Reference Manual:\n-   To create files with OpenVMS RMS default protections using the UNIX\n-   system-call functions umask, mkdir, creat, and open, call mkdir, creat,\n-   and open with a file-protection mode argument of 0777 in a program\n-   that never specifically calls umask. These default protections include\n-   correctly establishing protections based on ACLs, previous versions of\n-   files, and so on. */\n-#define PERM 0777\n #else\n #define PERM (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)\n #endif\n@@ -1037,10 +833,7 @@ __gnat_open_rw (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  fd = open (path, O_RDWR | o_fmode, PERM,\n-             \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1063,10 +856,7 @@ __gnat_open_create (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | o_fmode, PERM,\n-             \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1084,11 +874,7 @@ int\n __gnat_create_output_file (char *path)\n {\n   int fd;\n-#if defined (VMS)\n-  fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT, PERM,\n-             \"rfm=stmlf\", \"ctx=rec\", \"rat=none\", \"rop=nlk\",\n-             \"shr=del,get,put,upd\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1106,11 +892,7 @@ int\n __gnat_create_output_file_new (char *path)\n {\n   int fd;\n-#if defined (VMS)\n-  fd = open (path, O_WRONLY | O_CREAT | O_TRUNC | O_TEXT | O_EXCL, PERM,\n-             \"rfm=stmlf\", \"ctx=rec\", \"rat=none\", \"rop=nlk\",\n-             \"shr=del,get,put,upd\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1133,10 +915,7 @@ __gnat_open_append (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  fd = open (path, O_WRONLY | O_CREAT | O_APPEND | o_fmode, PERM,\n-             \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1161,10 +940,7 @@ __gnat_open_new (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  fd = open (path, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM,\n-             \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1178,9 +954,7 @@ __gnat_open_new (char *path, int fmode)\n   return fd < 0 ? -1 : fd;\n }\n \n-/* Open a new temp file.  Return error (-1) if the file already exists.\n-   Special options for VMS allow the file to be shared between parent and child\n-   processes, however they really slow down output.  Used in gnatchop.  */\n+/* Open a new temp file.  Return error (-1) if the file already exists.  */\n \n int\n __gnat_open_new_temp (char *path, int fmode)\n@@ -1205,17 +979,7 @@ __gnat_open_new_temp (char *path, int fmode)\n   if (fmode)\n     o_fmode = O_TEXT;\n \n-#if defined (VMS)\n-  /* Passing rfm=stmlf for binary files seems questionable since it results\n-     in having an extraneous line feed added after every call to CRTL write,\n-     so pass rfm=udf (aka undefined) instead.  */\n-  fd = open (path, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM,\n-             fmode ? \"rfm=stmlf\" : \"rfm=udf\", \"ctx=rec\", \"rat=none\",\n-             \"shr=del,get,put,upd\", \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#else\n   fd = GNAT_OPEN (path, O_WRONLY | O_CREAT | O_EXCL | o_fmode, PERM);\n-#endif\n-\n   return fd < 0 ? -1 : fd;\n }\n \n@@ -1224,9 +988,7 @@ __gnat_open (char *path, int fmode)\n {\n   int fd;\n \n-#if defined (VMS)\n-  fd = open (path, fmode, PERM, \"mbc=16\", \"deq=64\", \"fop=tef\");\n-#elif defined (__MINGW32__)\n+#if defined (__MINGW32__)\n   {\n     TCHAR wpath[GNAT_MAX_PATH_LEN];\n \n@@ -1295,12 +1057,7 @@ __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n   if (ret != 0) {\n      attr->timestamp = (OS_Time)-1;\n   } else {\n-#ifdef VMS\n-     /* VMS has file versioning.  */\n-     attr->timestamp = (OS_Time)statbuf.st_ctime;\n-#else\n      attr->timestamp = (OS_Time)statbuf.st_mtime;\n-#endif\n   }\n }\n \n@@ -1660,168 +1417,6 @@ __gnat_set_file_time_name (char *name, time_t time_stamp)\n   CloseHandle (h);\n   return;\n \n-#elif defined (VMS)\n-  struct FAB fab;\n-  struct NAM nam;\n-\n-  struct\n-    {\n-      unsigned long long backup, create, expire, revise;\n-      unsigned int uic;\n-      union\n-\t{\n-\t  unsigned short value;\n-\t  struct\n-\t    {\n-\t      unsigned system : 4;\n-\t      unsigned owner  : 4;\n-\t      unsigned group  : 4;\n-\t      unsigned world  : 4;\n-\t    } bits;\n-\t} prot;\n-    } Fat = { 0, 0, 0, 0, 0, { 0 }};\n-\n-  ATRDEF atrlst[]\n-    = {\n-      { ATR$S_CREDATE,  ATR$C_CREDATE,  &Fat.create },\n-      { ATR$S_REVDATE,  ATR$C_REVDATE,  &Fat.revise },\n-      { ATR$S_EXPDATE,  ATR$C_EXPDATE,  &Fat.expire },\n-      { ATR$S_BAKDATE,  ATR$C_BAKDATE,  &Fat.backup },\n-      { ATR$S_FPRO,     ATR$C_FPRO,     &Fat.prot },\n-      { ATR$S_UIC,      ATR$C_UIC,      &Fat.uic },\n-      { 0, 0, 0}\n-    };\n-\n-  FIBDEF fib;\n-  struct dsc$descriptor_fib fibdsc = {sizeof (fib), (void *) &fib};\n-\n-  struct IOSB iosb;\n-\n-  unsigned long long newtime;\n-  unsigned long long revtime;\n-  long status;\n-  short chan;\n-\n-  struct vstring file;\n-  struct dsc$descriptor_s filedsc\n-    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) file.string};\n-  struct vstring device;\n-  struct dsc$descriptor_s devicedsc\n-    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) device.string};\n-  struct vstring timev;\n-  struct dsc$descriptor_s timedsc\n-    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) timev.string};\n-  struct vstring result;\n-  struct dsc$descriptor_s resultdsc\n-    = {NAM$C_MAXRSS, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, (void *) result.string};\n-\n-  /* Convert parameter name (a file spec) to host file form. Note that this\n-     is needed on VMS to prepare for subsequent calls to VMS RMS library\n-     routines. Note that it would not work to call __gnat_to_host_dir_spec\n-     as was done in a previous version, since this fails silently unless\n-     the feature logical DECC$EFS_CHARSET is enabled, in which case a DNF\n-     (directory not found) condition is signalled.  */\n-  tryfile = (char *) __gnat_to_host_file_spec (name);\n-\n-  /* Allocate and initialize a FAB and NAM structures.  */\n-  fab = cc$rms_fab;\n-  nam = cc$rms_nam;\n-\n-  nam.nam$l_esa = file.string;\n-  nam.nam$b_ess = NAM$C_MAXRSS;\n-  nam.nam$l_rsa = result.string;\n-  nam.nam$b_rss = NAM$C_MAXRSS;\n-  fab.fab$l_fna = tryfile;\n-  fab.fab$b_fns = strlen (tryfile);\n-  fab.fab$l_nam = &nam;\n-\n-  /* Validate filespec syntax and device existence.  */\n-  status = SYS$PARSE (&fab, 0, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-\n-  file.string[nam.nam$b_esl] = 0;\n-\n-  /* Find matching filespec.  */\n-  status = SYS$SEARCH (&fab, 0, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-\n-  file.string[nam.nam$b_esl] = 0;\n-  result.string[result.length=nam.nam$b_rsl] = 0;\n-\n-  /* Get the device name and assign an IO channel.  */\n-  strncpy (device.string, nam.nam$l_dev, nam.nam$b_dev);\n-  devicedsc.dsc$w_length  = nam.nam$b_dev;\n-  chan = 0;\n-  status = SYS$ASSIGN (&devicedsc, &chan, 0, 0, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-\n-  /* Initialize the FIB and fill in the directory id field.  */\n-  memset (&fib, 0, sizeof (fib));\n-  fib.fib$w_did[0]  = nam.nam$w_did[0];\n-  fib.fib$w_did[1]  = nam.nam$w_did[1];\n-  fib.fib$w_did[2]  = nam.nam$w_did[2];\n-  fib.fib$l_acctl = 0;\n-  fib.fib$l_wcc = 0;\n-  strcpy (file.string, (strrchr (result.string, ']') + 1));\n-  filedsc.dsc$w_length = strlen (file.string);\n-  result.string[result.length = 0] = 0;\n-\n-  /* Open and close the file to fill in the attributes.  */\n-  status\n-    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,\n-\t\t&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-  if ((iosb.status & 1) != 1)\n-    LIB$SIGNAL (iosb.status);\n-\n-  result.string[result.length] = 0;\n-  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0, &fibdsc, 0, 0, 0,\n-\t\t     &atrlst, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-  if ((iosb.status & 1) != 1)\n-    LIB$SIGNAL (iosb.status);\n-\n-  {\n-    time_t t;\n-\n-    /* Set creation time to requested time.  */\n-    unix_time_to_vms (time_stamp, newtime);\n-\n-    t = time ((time_t) 0);\n-\n-    /* Set revision time to now in local time.  */\n-    unix_time_to_vms (t, revtime);\n-  }\n-\n-  /* Reopen the file, modify the times and then close.  */\n-  fib.fib$l_acctl = FIB$M_WRITE;\n-  status\n-    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,\n-\t\t&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-  if ((iosb.status & 1) != 1)\n-    LIB$SIGNAL (iosb.status);\n-\n-  Fat.create = newtime;\n-  Fat.revise = revtime;\n-\n-  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0,\n-                     &fibdsc, 0, 0, 0, &atrlst, 0);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n-  if ((iosb.status & 1) != 1)\n-    LIB$SIGNAL (iosb.status);\n-\n-  /* Deassign the channel and exit.  */\n-  status = SYS$DASSGN (chan);\n-  if ((status & 1) != 1)\n-    LIB$SIGNAL (status);\n #else\n   struct utimbuf utimbuf;\n   time_t t;\n@@ -2605,11 +2200,7 @@ __gnat_portable_spawn (char *args[] ATTRIBUTE_UNUSED)\n     {\n       /* The child. */\n       if (execv (args[0], MAYBE_TO_PTR32 (args)) != 0)\n-#if defined (VMS)\n-\treturn -1; /* execv is in parent context on VMS.  */\n-#else\n \t_exit (1);\n-#endif\n     }\n \n   /* The parent.  */\n@@ -2683,15 +2274,6 @@ __gnat_number_of_cpus (void)\n   GetSystemInfo (&sysinfo);\n   cores = (int) sysinfo.dwNumberOfProcessors;\n \n-#elif defined (VMS)\n-  int code = SYI$_ACTIVECPU_CNT;\n-  unsigned int res;\n-  int status;\n-\n-  status = LIB$GETSYI (&code, &res);\n-  if ((status & 1) != 0)\n-    cores = res;\n-\n #elif defined (_WRS_CONFIG_SMP)\n   unsigned int vxCpuConfiguredGet (void);\n \n@@ -2934,11 +2516,7 @@ __gnat_portable_no_block_spawn (char *args[] ATTRIBUTE_UNUSED)\n     {\n       /* The child.  */\n       if (execv (args[0], MAYBE_TO_PTR32 (args)) != 0)\n-#if defined (VMS)\n-\treturn -1; /* execv is in parent context on VMS. */\n-#else\n \t_exit (1);\n-#endif\n     }\n \n   return pid;\n@@ -3154,506 +2732,18 @@ __gnat_locate_exec_on_path (char *exec_name)\n   WS2SC (apath_val, wapath_val, EXPAND_BUFFER_SIZE);\n   return __gnat_locate_exec (exec_name, apath_val);\n \n-#else\n-\n-#ifdef VMS\n-  char *path_val = \"/VAXC$PATH\";\n #else\n   char *path_val = getenv (\"PATH\");\n-#endif\n+\n   if (path_val == NULL) return NULL;\n   apath_val = (char *) alloca (strlen (path_val) + 1);\n   strcpy (apath_val, path_val);\n   return __gnat_locate_exec (exec_name, apath_val);\n #endif\n }\n \n-#ifdef VMS\n-\n-/* These functions are used to translate to and from VMS and Unix syntax\n-   file, directory and path specifications.  */\n-\n-#define MAXPATH  256\n-#define MAXNAMES 256\n-#define NEW_CANONICAL_FILELIST_INCREMENT 64\n-\n-static char new_canonical_dirspec [MAXPATH];\n-static char new_canonical_filespec [MAXPATH];\n-static char new_canonical_pathspec [MAXNAMES*MAXPATH];\n-static unsigned new_canonical_filelist_index;\n-static unsigned new_canonical_filelist_in_use;\n-static unsigned new_canonical_filelist_allocated;\n-static char **new_canonical_filelist;\n-static char new_host_pathspec [MAXNAMES*MAXPATH];\n-static char new_host_dirspec [MAXPATH];\n-static char new_host_filespec [MAXPATH];\n-\n-/* Routine is called repeatedly by decc$from_vms via\n-   __gnat_to_canonical_file_list_init until it returns 0 or the expansion\n-   runs out. */\n-\n-static int\n-wildcard_translate_unix (char *name)\n-{\n-  char *ver;\n-  char buff [MAXPATH];\n-\n-  strncpy (buff, name, MAXPATH);\n-  buff [MAXPATH - 1] = (char) 0;\n-  ver = strrchr (buff, '.');\n-\n-  /* Chop off the version.  */\n-  if (ver)\n-    *ver = 0;\n-\n-  /* Dynamically extend the allocation by the increment.  */\n-  if (new_canonical_filelist_in_use == new_canonical_filelist_allocated)\n-    {\n-      new_canonical_filelist_allocated += NEW_CANONICAL_FILELIST_INCREMENT;\n-      new_canonical_filelist = (char **) xrealloc\n-\t(new_canonical_filelist,\n-\t new_canonical_filelist_allocated * sizeof (char *));\n-    }\n-\n-  new_canonical_filelist[new_canonical_filelist_in_use++] = xstrdup (buff);\n-\n-  return 1;\n-}\n-\n-/* Translate a wildcard VMS file spec into a list of Unix file specs. First do\n-   full translation and copy the results into a list (_init), then return them\n-   one at a time (_next). If onlydirs set, only expand directory files.  */\n-\n-int\n-__gnat_to_canonical_file_list_init (char *filespec, int onlydirs)\n-{\n-  int len;\n-  char buff [MAXPATH];\n-\n-  len = strlen (filespec);\n-  strncpy (buff, filespec, MAXPATH);\n-\n-  /* Only look for directories */\n-  if (onlydirs && !strstr (&buff [len-5], \"*.dir\"))\n-    strncat (buff, \"*.dir\", MAXPATH);\n-\n-  buff [MAXPATH - 1] = (char) 0;\n-\n-  decc$from_vms (buff, wildcard_translate_unix, 1);\n-\n-  /* Remove the .dir extension.  */\n-  if (onlydirs)\n-    {\n-      int i;\n-      char *ext;\n-\n-      for (i = 0; i < new_canonical_filelist_in_use; i++)\n-\t{\n-\t  ext = strstr (new_canonical_filelist[i], \".dir\");\n-\t  if (ext)\n-\t    *ext = 0;\n-\t}\n-    }\n-\n-  return new_canonical_filelist_in_use;\n-}\n-\n-/* Return the next filespec in the list.  */\n-\n-char *\n-__gnat_to_canonical_file_list_next (void)\n-{\n-  return new_canonical_filelist[new_canonical_filelist_index++];\n-}\n-\n-/* Free storage used in the wildcard expansion.  */\n-\n-void\n-__gnat_to_canonical_file_list_free (void)\n-{\n-  int i;\n-\n-   for (i = 0; i < new_canonical_filelist_in_use; i++)\n-     free (new_canonical_filelist[i]);\n-\n-  free (new_canonical_filelist);\n-\n-  new_canonical_filelist_in_use = 0;\n-  new_canonical_filelist_allocated = 0;\n-  new_canonical_filelist_index = 0;\n-  new_canonical_filelist = 0;\n-}\n-\n-/* The functional equivalent of decc$translate_vms routine.\n-   Designed to produce the same output, but is protected against\n-   malformed paths (original version ACCVIOs in this case) and\n-   does not require VMS-specific DECC RTL.  */\n-\n-#define NAM$C_MAXRSS 1024\n-\n-char *\n-__gnat_translate_vms (char *src)\n-{\n-  static char retbuf [NAM$C_MAXRSS + 1];\n-  char *srcendpos, *pos1, *pos2, *retpos;\n-  int disp, path_present = 0;\n-\n-  if (!src)\n-    return NULL;\n-\n-  srcendpos = strchr (src, '\\0');\n-  retpos = retbuf;\n-\n-  /* Look for the node and/or device in front of the path.  */\n-  pos1 = src;\n-  pos2 = strchr (pos1, ':');\n-\n-  if (pos2 && (pos2 < srcendpos) && (*(pos2 + 1) == ':'))\n-    {\n-      /* There is a node name. \"node_name::\" becomes \"node_name!\".  */\n-      disp = pos2 - pos1;\n-      strncpy (retbuf, pos1, disp);\n-      retpos [disp] = '!';\n-      retpos = retpos + disp + 1;\n-      pos1 = pos2 + 2;\n-      pos2 = strchr (pos1, ':');\n-    }\n-\n-  if (pos2)\n-    {\n-      /* There is a device name. \"dev_name:\" becomes \"/dev_name/\".  */\n-      *(retpos++) = '/';\n-      disp = pos2 - pos1;\n-      strncpy (retpos, pos1, disp);\n-      retpos = retpos + disp;\n-      pos1 = pos2 + 1;\n-      *(retpos++) = '/';\n-    }\n-  else\n-    /* No explicit device; we must look ahead and prepend /sys$disk/ if\n-       the path is absolute.  */\n-    if ((*pos1 == '[' || *pos1 == '<') && (pos1 < srcendpos)\n-        && !strchr (\".-]>\", *(pos1 + 1)))\n-      {\n-        strncpy (retpos, \"/sys$disk/\", 10);\n-        retpos += 10;\n-      }\n-\n-  /* Process the path part.  */\n-  while (*pos1 == '[' || *pos1 == '<')\n-    {\n-      path_present++;\n-      pos1++;\n-      if (*pos1 == ']' || *pos1 == '>')\n-        {\n-          /* Special case, [] translates to '.'.  */\n-          *(retpos++) = '.';\n-          pos1++;\n-        }\n-      else\n-        {\n-          /* '[000000' means root dir. It can be present in the middle of\n-             the path due to expansion of logical devices, in which case\n-             we skip it.  */\n-          if (!strncmp (pos1, \"000000\", 6) && path_present > 1 &&\n-              (*(pos1 + 6) == ']' || *(pos1 + 6) == '>' || *(pos1 + 6) == '.'))\n-            {\n-              pos1 += 6;\n-              if (*pos1 == '.') pos1++;\n-            }\n-          else if (*pos1 == '.')\n-            {\n-              /* Relative path.  */\n-              *(retpos++) = '.';\n-            }\n-\n-          /* There is a qualified path.  */\n-          while (*pos1 && *pos1 != ']' && *pos1 != '>')\n-            {\n-              switch (*pos1)\n-                {\n-                case '.':\n-                  /* '.' is used to separate directories. Replace it with '/'\n-\t\t     but only if there isn't already '/' just before.  */\n-                  if (*(retpos - 1) != '/')\n-                    *(retpos++) = '/';\n-                  pos1++;\n-                  if (pos1 + 1 < srcendpos\n-\t\t      && *pos1 == '.'\n-\t\t      && *(pos1 + 1) == '.')\n-                    {\n-                      /* Ellipsis refers to entire subtree; replace\n-\t\t\t with '**'.  */\n-                      *(retpos++) = '*';\n-                      *(retpos++) = '*';\n-                      *(retpos++) = '/';\n-                      pos1 += 2;\n-                    }\n-                  break;\n-                case '-' :\n-                  /* When after '.' '[' '<' is equivalent to Unix \"..\" but\n-\t\t     there may be several in a row.  */\n-                  if (*(pos1 - 1) == '.' || *(pos1 - 1) == '[' ||\n-                      *(pos1 - 1) == '<')\n-                    {\n-                      while (*pos1 == '-')\n-                        {\n-                          pos1++;\n-                          *(retpos++) = '.';\n-                          *(retpos++) = '.';\n-                          *(retpos++) = '/';\n-                        }\n-                      retpos--;\n-                      break;\n-                    }\n-                  /* Otherwise fall through to default.  */\n-                default:\n-                  *(retpos++) = *(pos1++);\n-                }\n-            }\n-          pos1++;\n-        }\n-    }\n-\n-  if (pos1 < srcendpos)\n-    {\n-      /* Now add the actual file name, until the version suffix if any */\n-      if (path_present)\n-        *(retpos++) = '/';\n-      pos2 = strchr (pos1, ';');\n-      disp = pos2? (pos2 - pos1) : (srcendpos - pos1);\n-      strncpy (retpos, pos1, disp);\n-      retpos += disp;\n-      if (pos2 && pos2 < srcendpos)\n-        {\n-          /* There is a non-empty version suffix. \";<ver>\" becomes \".<ver>\" */\n-          *retpos++ = '.';\n-          disp = srcendpos - pos2 - 1;\n-          strncpy (retpos, pos2 + 1, disp);\n-          retpos += disp;\n-        }\n-    }\n-\n-  *retpos = '\\0';\n-\n-  return retbuf;\n-}\n-\n-/* Translate a VMS syntax directory specification in to Unix syntax.  If\n-   PREFIXFLAG is set, append an underscore \"/\". If no indicators of VMS syntax\n-   found, return input string. Also translate a dirname that contains no\n-   slashes, in case it's a logical name.  */\n-\n-char *\n-__gnat_to_canonical_dir_spec (char *dirspec, int prefixflag)\n-{\n-  int len;\n-\n-  strcpy (new_canonical_dirspec, \"\");\n-  if (strlen (dirspec))\n-    {\n-      char *dirspec1;\n-\n-      if (strchr (dirspec, ']') || strchr (dirspec, ':'))\n-\t{\n-\t  strncpy (new_canonical_dirspec,\n-\t\t   __gnat_translate_vms (dirspec),\n-\t\t   MAXPATH);\n-\t}\n-      else if (!strchr (dirspec, '/') && (dirspec1 = getenv (dirspec)) != 0)\n-\t{\n-\t  strncpy (new_canonical_dirspec,\n-\t\t  __gnat_translate_vms (dirspec1),\n-\t\t  MAXPATH);\n-\t}\n-      else\n-\t{\n-\t  strncpy (new_canonical_dirspec, dirspec, MAXPATH);\n-\t}\n-    }\n-\n-  len = strlen (new_canonical_dirspec);\n-  if (prefixflag && new_canonical_dirspec [len-1] != '/')\n-    strncat (new_canonical_dirspec, \"/\", MAXPATH);\n-\n-  new_canonical_dirspec [MAXPATH - 1] = (char) 0;\n-\n-  return new_canonical_dirspec;\n-\n-}\n-\n-/* Translate a VMS syntax file specification into Unix syntax.\n-   If no indicators of VMS syntax found, check if it's an uppercase\n-   alphanumeric_ name and if so try it out as an environment\n-   variable (logical name). If all else fails return the\n-   input string.  */\n-\n-char *\n-__gnat_to_canonical_file_spec (char *filespec)\n-{\n-  char *filespec1;\n-\n-  strncpy (new_canonical_filespec, \"\", MAXPATH);\n-\n-  if (strchr (filespec, ']') || strchr (filespec, ':'))\n-    {\n-      char *tspec = (char *) __gnat_translate_vms (filespec);\n-\n-      if (tspec != (char *) -1)\n-\tstrncpy (new_canonical_filespec, tspec, MAXPATH);\n-    }\n-  else if ((strlen (filespec) == strspn (filespec,\n-\t    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\"))\n-\t&& (filespec1 = getenv (filespec)))\n-    {\n-      char *tspec = (char *) __gnat_translate_vms (filespec1);\n-\n-      if (tspec != (char *) -1)\n-\tstrncpy (new_canonical_filespec, tspec, MAXPATH);\n-    }\n-  else\n-    {\n-      strncpy (new_canonical_filespec, filespec, MAXPATH);\n-    }\n-\n-  new_canonical_filespec [MAXPATH - 1] = (char) 0;\n-\n-  return new_canonical_filespec;\n-}\n-\n-/* Translate a VMS syntax path specification into Unix syntax.\n-   If no indicators of VMS syntax found, return input string.  */\n-\n-char *\n-__gnat_to_canonical_path_spec (char *pathspec)\n-{\n-  char *curr, *next, buff [MAXPATH];\n-\n-  if (pathspec == 0)\n-    return pathspec;\n-\n-  /* If there are /'s, assume it's a Unix path spec and return.  */\n-  if (strchr (pathspec, '/'))\n-    return pathspec;\n-\n-  new_canonical_pathspec[0] = 0;\n-  curr = pathspec;\n-\n-  for (;;)\n-    {\n-      next = strchr (curr, ',');\n-      if (next == 0)\n-        next = strchr (curr, 0);\n-\n-      strncpy (buff, curr, next - curr);\n-      buff[next - curr] = 0;\n-\n-      /* Check for wildcards and expand if present.  */\n-      if (strchr (buff, '*') || strchr (buff, '%') || strstr (buff, \"...\"))\n-        {\n-          int i, dirs;\n-\n-          dirs = __gnat_to_canonical_file_list_init (buff, 1);\n-          for (i = 0; i < dirs; i++)\n-            {\n-              char *next_dir;\n-\n-              next_dir = __gnat_to_canonical_file_list_next ();\n-              strncat (new_canonical_pathspec, next_dir, MAXPATH);\n-\n-              /* Don't append the separator after the last expansion.  */\n-              if (i+1 < dirs)\n-                strncat (new_canonical_pathspec, \":\", MAXPATH);\n-            }\n-\n-\t  __gnat_to_canonical_file_list_free ();\n-        }\n-      else\n-\tstrncat (new_canonical_pathspec,\n-\t\t__gnat_to_canonical_dir_spec (buff, 0), MAXPATH);\n-\n-      if (*next == 0)\n-        break;\n-\n-      strncat (new_canonical_pathspec, \":\", MAXPATH);\n-      curr = next + 1;\n-    }\n-\n-  new_canonical_pathspec [MAXPATH - 1] = (char) 0;\n-\n-  return new_canonical_pathspec;\n-}\n-\n-static char filename_buff [MAXPATH];\n-\n-static int\n-translate_unix (char *name, int type ATTRIBUTE_UNUSED)\n-{\n-  strncpy (filename_buff, name, MAXPATH);\n-  filename_buff [MAXPATH - 1] = (char) 0;\n-  return 0;\n-}\n-\n-/* Translate a Unix syntax directory specification into VMS syntax.  The\n-   PREFIXFLAG has no effect, but is kept for symmetry with\n-   to_canonical_dir_spec.  If indicators of VMS syntax found, return input\n-   string. */\n-\n-char *\n-__gnat_to_host_dir_spec (char *dirspec, int prefixflag ATTRIBUTE_UNUSED)\n-{\n-  int len = strlen (dirspec);\n-\n-  strncpy (new_host_dirspec, dirspec, MAXPATH);\n-  new_host_dirspec [MAXPATH - 1] = (char) 0;\n-\n-  if (strchr (new_host_dirspec, ']') || strchr (new_host_dirspec, ':'))\n-    return new_host_dirspec;\n-\n-  while (len > 1 && new_host_dirspec[len - 1] == '/')\n-    {\n-      new_host_dirspec[len - 1] = 0;\n-      len--;\n-    }\n-\n-  decc$to_vms (new_host_dirspec, translate_unix, 1, 2);\n-  strncpy (new_host_dirspec, filename_buff, MAXPATH);\n-  new_host_dirspec [MAXPATH - 1] = (char) 0;\n-\n-  return new_host_dirspec;\n-}\n-\n-/* Translate a Unix syntax file specification into VMS syntax.\n-   If indicators of VMS syntax found, return input string.  */\n-\n-char *\n-__gnat_to_host_file_spec (char *filespec)\n-{\n-  strncpy (new_host_filespec, \"\", MAXPATH);\n-  if (strchr (filespec, ']') || strchr (filespec, ':'))\n-    {\n-      strncpy (new_host_filespec, filespec, MAXPATH);\n-    }\n-  else\n-    {\n-      decc$to_vms (filespec, translate_unix, 1, 1);\n-      strncpy (new_host_filespec, filename_buff, MAXPATH);\n-    }\n-\n-  new_host_filespec [MAXPATH - 1] = (char) 0;\n-\n-  return new_host_filespec;\n-}\n-\n-void\n-__gnat_adjust_os_resource_limits (void)\n-{\n-  SYS$ADJWSL (131072, 0);\n-}\n-\n-#else /* VMS */\n-\n-/* Dummy functions for Osint import for non-VMS systems.  */\n+/* Dummy functions for Osint import for non-VMS systems.\n+   ??? To be removed.  */\n \n int\n __gnat_to_canonical_file_list_init (char *dirspec ATTRIBUTE_UNUSED,\n@@ -3709,8 +2799,6 @@ __gnat_adjust_os_resource_limits (void)\n {\n }\n \n-#endif\n-\n #if defined (__mips_vxworks)\n int\n _flush_cache (void)\n@@ -3719,35 +2807,6 @@ _flush_cache (void)\n }\n #endif\n \n-#if defined (IS_CROSS)  \\\n-  || (! ((defined (sparc) || defined (i386)) && defined (sun) \\\n-      && defined (__SVR4)) \\\n-      && ! (defined (linux) && (defined (i386) || defined (__x86_64__))) \\\n-      && ! (defined (linux) && defined (__ia64__)) \\\n-      && ! (defined (linux) && defined (powerpc)) \\\n-      && ! defined (__FreeBSD__) \\\n-      && ! defined (__Lynx__) \\\n-      && ! defined (__hpux__) \\\n-      && ! defined (__APPLE__) \\\n-      && ! defined (_AIX) \\\n-      && ! defined (VMS) \\\n-      && ! defined (__MINGW32__))\n-\n-/* Dummy function to satisfy g-trasym.o. See the preprocessor conditional\n-   just above for a list of native platforms that provide a non-dummy\n-   version of this procedure in libaddr2line.a.  */\n-\n-void\n-convert_addresses (const char *file_name ATTRIBUTE_UNUSED,\n-\t\t   void *addrs ATTRIBUTE_UNUSED,\n-\t\t   int n_addr ATTRIBUTE_UNUSED,\n-\t\t   void *buf ATTRIBUTE_UNUSED,\n-\t\t   int *len ATTRIBUTE_UNUSED)\n-{\n-  *len = 0;\n-}\n-#endif\n-\n #if defined (_WIN32)\n int __gnat_argument_needs_quote = 1;\n #else\n@@ -3788,7 +2847,7 @@ int\n __gnat_copy_attribs (char *from ATTRIBUTE_UNUSED, char *to ATTRIBUTE_UNUSED,\n                      int mode ATTRIBUTE_UNUSED)\n {\n-#if defined (VMS) || (defined (__vxworks) && _WRS_VXWORKS_MAJOR < 6) || \\\n+#if (defined (__vxworks) && _WRS_VXWORKS_MAJOR < 6) || \\\n   defined (__nucleus__)\n   return -1;\n \n@@ -3931,19 +2990,15 @@ __gnat_set_close_on_exec (int fd ATTRIBUTE_UNUSED,\n int\n __gnat_binder_supports_auto_init (void)\n {\n-#ifdef VMS\n-   return 0;\n-#else\n-   return 1;\n-#endif\n+  return 1;\n }\n \n /* Indicates that Stand-Alone Libraries are automatically initialized through\n    the constructor mechanism */\n int\n __gnat_sals_init_using_constructors (void)\n {\n-#if defined (__vxworks) || defined (__Lynx__) || defined (VMS)\n+#if defined (__vxworks) || defined (__Lynx__)\n    return 0;\n #else\n    return 1;"}, {"sha": "fd44eb8c691026d4df1c53679f8dd2c4b1d86679", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -414,7 +414,6 @@ GNAT_ADA_OBJS =\t\\\n  ada/sem_smem.o\t\\\n  ada/sem_type.o\t\\\n  ada/sem_util.o\t\\\n- ada/sem_vfpt.o\t\\\n  ada/sem_warn.o\t\\\n  ada/set_targ.o \\\n  ada/sinfo-cn.o\t\\"}, {"sha": "dddbf757c032236bf1f61f8296dc489452fe3db4", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -1643,28 +1643,32 @@ ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(target_os))),)\n   g-soliop.ads<g-soliop-mingw.ads \\\n   $(ATOMICS_TARGET_PAIRS)\n \n-  ifeq ($(strip $(filter-out rtx_w32 rtx_rtss,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-intman.adb<s-intman-dummy.adb \\\n-    s-osinte.ads<s-osinte-rtx.ads \\\n-    s-osprim.adb<s-osprim-rtx.adb \\\n-    s-taprop.adb<s-taprop-rtx.adb \\\n-    $(X86_TARGET_PAIRS)\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS = s-win32.o\n-\n-    ifeq ($(strip $(filter-out rtx_w32,$(THREAD_KIND))),)\n-       LIBGNAT_TARGET_PAIRS += system.ads<system-rtx.ads\n+  LIBGNAT_TARGET_PAIRS += \\\n+  a-exetim.adb<a-exetim-mingw.adb \\\n+  a-exetim.ads<a-exetim-mingw.ads \\\n+  a-intnam.ads<a-intnam-mingw.ads \\\n+  g-sercom.adb<g-sercom-mingw.adb \\\n+  s-trasym.adb<s-trasym-dwarf.adb \\\n+  s-tsmona.adb<s-tsmona-mingw.adb \\\n+  s-interr.adb<s-interr-sigaction.adb \\\n+  s-intman.adb<s-intman-mingw.adb \\\n+  s-mudido.adb<s-mudido-affinity.adb \\\n+  s-osinte.ads<s-osinte-mingw.ads \\\n+  s-osprim.adb<s-osprim-mingw.adb \\\n+  s-taprop.adb<s-taprop-mingw.adb\n \n-       EH_MECHANISM=-gcc\n+  ifeq ($(strip $(filter-out x86_64%,$(target_cpu))),)\n+    ifeq ($(strip $(MULTISUBDIR)),/32)\n+      LIBGNAT_TARGET_PAIRS += \\\n+        $(X86_TARGET_PAIRS) \\\n+        system.ads<system-mingw.ads\n+      SO_OPTS= -m32 -Wl,-soname,\n     else\n-       LIBGNAT_TARGET_PAIRS += \\\n-       system.ads<system-rtx-rtss.ads \\\n-       s-parame.adb<s-parame-vxworks.adb\n-\n-       EH_MECHANISM=\n+      LIBGNAT_TARGET_PAIRS += \\\n+        $(X86_64_TARGET_PAIRS) \\\n+        system.ads<system-mingw-x86_64.ads\n+      SO_OPTS = -m64 -Wl,-soname,\n     endif\n-\n   else\n     LIBGNAT_TARGET_PAIRS += \\\n     a-exetim.adb<a-exetim-mingw.adb \\\n@@ -1691,31 +1695,24 @@ ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(target_os))),)\n \tSO_OPTS = -m64 -Wl,-soname,\n       endif\n     else\n-      ifeq ($(strip $(MULTISUBDIR)),/64)\n-\tLIBGNAT_TARGET_PAIRS += \\\n-\t  $(X86_64_TARGET_PAIRS) \\\n-\t  system.ads<system-mingw-x86_64.ads\n-\tSO_OPTS = -m64 -Wl,-soname,\n-      else\n-\tLIBGNAT_TARGET_PAIRS += \\\n-\t  $(X86_TARGET_PAIRS) \\\n-\t  system.ads<system-mingw.ads\n-\tSO_OPTS = -m32 -Wl,-soname,\n-      endif\n+      LIBGNAT_TARGET_PAIRS += \\\n+        $(X86_TARGET_PAIRS) \\\n+        system.ads<system-mingw.ads\n+      SO_OPTS = -m32 -Wl,-soname,\n     endif\n+  endif\n \n-    EXTRA_GNATRTL_NONTASKING_OBJS = \\\n-\ts-win32.o s-winext.o g-regist.o g-sse.o g-ssvety.o\n-    EXTRA_GNATRTL_TASKING_OBJS = a-exetim.o\n-    EXTRA_LIBGNAT_SRCS+=mingw32.h\n-    MISCLIB = -lws2_32\n+  EXTRA_GNATRTL_NONTASKING_OBJS = \\\n+    s-win32.o s-winext.o g-regist.o g-sse.o g-ssvety.o\n+  EXTRA_GNATRTL_TASKING_OBJS = a-exetim.o\n+  EXTRA_LIBGNAT_SRCS+=mingw32.h\n+  MISCLIB = -lws2_32\n \n-    # ??? This will be replaced by gnatlib-shared-dual-win32 when GNAT\n-    # auto-import support for array/record will be done.\n-    GNATLIB_SHARED = gnatlib-shared-win32\n+  # ??? This will be replaced by gnatlib-shared-dual-win32 when GNAT\n+  # auto-import support for array/record will be done.\n+  GNATLIB_SHARED = gnatlib-shared-win32\n \n-    EH_MECHANISM=-gcc\n-  endif\n+  EH_MECHANISM=-gcc\n \n   TOOLS_TARGET_PAIRS= \\\n   mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \\\n@@ -2426,7 +2423,6 @@ ADA_EXCLUDE_SRCS =\\\n   s-bbthre.ads s-bbtiev.adb s-bbtiev.ads s-bbtime.adb s-bbtime.ads \\\n   s-bcprmu.adb s-bcprmu.ads s-btstch.adb s-btstch.ads \\\n   s-init.ads s-init.adb \\\n-  s-po32gl.adb s-po32gl.ads \\\n   s-stache.adb s-stache.ads \\\n   s-thread.ads \\\n   s-vxwext.adb s-vxwext.ads \\\n@@ -2977,14 +2973,6 @@ s-tasdeb.o  : s-tasdeb.adb s-tasdeb.ads\n \t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 $(ADA_INCLUDES) \\\n \t      $< $(OUTPUT_OPTION)\n \n-# force debugging information on s-vaflop.o so that it is always\n-# possible to call the VAX float debug print routines.\n-# force at least -O so that the inline assembly works.\n-\n-s-vaflop.o  : s-vaflop.adb s-vaflop.ads\n-\t$(CC) -c -O $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) $(ADA_INCLUDES) \\\n-\t      $< $(OUTPUT_OPTION)\n-\n # force no function reordering on a-except.o because of the exclusion bounds\n # mechanism (see the source file for more detailed information).\n # force debugging information on a-except.o so that it is always"}, {"sha": "859838d56537f78a75f50be086210d03da417056", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -1921,18 +1921,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Floating_Point_Type:\n-      /* If this is a VAX floating-point type, use an integer of the proper\n-\t size.  All the operations will be handled with ASM statements.  */\n-      if (Vax_Float (gnat_entity))\n-\t{\n-\t  gnu_type = make_signed_type (esize);\n-\t  TYPE_VAX_FLOATING_POINT_P (gnu_type) = 1;\n-\t  SET_TYPE_DIGITS_VALUE (gnu_type,\n-\t\t\t\t UI_To_gnu (Digits_Value (gnat_entity),\n-\t\t\t\t\t    sizetype));\n-\t  break;\n-\t}\n-\n       /* The type of the Low and High bounds can be our type if this is\n \t a type from Standard, so set them at the end of the function.  */\n       gnu_type = make_node (REAL_TYPE);\n@@ -1941,12 +1929,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       break;\n \n     case E_Floating_Point_Subtype:\n-      if (Vax_Float (gnat_entity))\n-\t{\n-\t  gnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n-\t  break;\n-\t}\n-\n       /* See the E_Signed_Integer_Subtype case for the rationale.  */\n       if (!definition\n \t  && Present (Ancestor_Subtype (gnat_entity))\n@@ -5296,7 +5278,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* If this is an enumeration or floating-point type, we were not able to set\n      the bounds since they refer to the type.  These are always static.  */\n   if ((kind == E_Enumeration_Type && Present (First_Literal (gnat_entity)))\n-      || (kind == E_Floating_Point_Type && !Vax_Float (gnat_entity)))\n+      || (kind == E_Floating_Point_Type))\n     {\n       tree gnu_scalar_type = gnu_type;\n       tree gnu_low_bound, gnu_high_bound;"}, {"sha": "89132364edda713dc7e395ee01daf597c7e04e34", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -3387,17 +3387,8 @@ pragma Ident (static_string_EXPRESSION);\n @end smallexample\n \n @noindent\n-This pragma provides a string identification in the generated object file,\n-if the system supports the concept of this kind of identification string.\n-This pragma is allowed only in the outermost declarative part or\n-declarative items of a compilation unit. If more than one @code{Ident}\n-pragma is given, only the last one processed is effective.\n-@cindex OpenVMS\n-On OpenVMS systems, the effect of the pragma is identical to the effect of\n-the DEC Ada 83 pragma of the same name. Note that in DEC Ada 83, the\n-maximum allowed length is 31 characters, so if it is important to\n-maintain compatibility with this compiler, you should obey this length\n-limit.\n+This pragma is identical in effect to pragma @code{Comment}. It is provided\n+for compatibility with other Ada compilers providing this pragma.\n \n @node Pragma Implementation_Defined\n @unnumberedsec Pragma Implementation_Defined"}, {"sha": "5cce4103f99fb4dfac0df25768e5e30d86e7e6ad", "filename": "gcc/ada/s-asthan.adb", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-asthan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-asthan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan.adb?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,58 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUNT-TIME COMPONENTS                        --\n---                                                                          --\n---                  S Y S T E M . A S T _ H A N D L I N G                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1996-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the dummy version used on non-VMS systems\n-\n-package body System.AST_Handling is\n-\n-   ------------------------\n-   -- Create_AST_Handler --\n-   ------------------------\n-\n-   function Create_AST_Handler\n-     (Taskid  : Ada.Task_Identification.Task_Id;\n-      Entryno : Natural) return System.Aux_DEC.AST_Handler\n-   is\n-   begin\n-      raise Program_Error with \"AST is implemented only on VMS systems\";\n-      return System.Aux_DEC.No_AST_Handler;\n-   end Create_AST_Handler;\n-\n-   procedure Expand_AST_Packet_Pool\n-     (Requested_Packets : Natural;\n-      Actual_Number     : out Natural;\n-      Total_Number      : out Natural)\n-   is\n-   begin\n-      raise Program_Error with \"AST is implemented only on VMS systems\";\n-   end Expand_AST_Packet_Pool;\n-\n-end System.AST_Handling;"}, {"sha": "6ee2228df4dd3f6a6ee76e857262de390d4c8575", "filename": "gcc/ada/s-asthan.ads", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-asthan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-asthan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,57 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                  S Y S T E M . A S T _ H A N D L I N G                   --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1996-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Runtime support for Handling of AST's (Used on VMS implementations only)\n-\n-with Ada.Task_Identification;\n-with System;\n-with System.Aux_DEC;\n-\n-package System.AST_Handling is\n-\n-   function Create_AST_Handler\n-     (Taskid  : Ada.Task_Identification.Task_Id;\n-      Entryno : Natural) return System.Aux_DEC.AST_Handler;\n-   --  This function implements the appropriate semantics for a use of the\n-   --  AST_Entry pragma. See body for details of implementation approach.\n-   --  The parameters are the Task_Id for the task containing the entry\n-   --  and the entry Index for the specified entry.\n-\n-   procedure Expand_AST_Packet_Pool\n-     (Requested_Packets : Natural;\n-      Actual_Number     : out Natural;\n-      Total_Number      : out Natural);\n-   --  This function takes a request for zero or more extra AST packets and\n-   --  returns the number actually added to the pool and the total number\n-   --  now available or in use.\n-   --  This function is not yet fully implemented.\n-\n-end System.AST_Handling;"}, {"sha": "3f40af8996db025b4d4f9013505dc35f28d6bad9", "filename": "gcc/ada/s-filofl.ads", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-filofl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-filofl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-filofl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,53 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---            S Y S T E M . F A T _ I E E E _ L O N G _ F L O A T           --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains an instantiation of the floating-point attribute\n---  runtime routines for IEEE long float. This is used on VMS targets where\n---  we can't just use Long_Float, since this may have been mapped to Vax_Float\n---  using a Float_Representation configuration pragma.\n-\n---  TO BE RMOVED ???\n-\n-with System.Fat_Gen;\n-\n-package System.Fat_IEEE_Long_Float is\n-   pragma Pure;\n-\n-   type Fat_IEEE_Long is digits 15;\n-\n-   --  Note the only entity from this package that is accessed by Rtsfind\n-   --  is the name of the package instantiation. Entities within this package\n-   --  (i.e. the individual floating-point attribute routines) are accessed\n-   --  by name using selected notation.\n-\n-   package Attr_IEEE_Long is new System.Fat_Gen (Fat_IEEE_Long);\n-\n-end System.Fat_IEEE_Long_Float;"}, {"sha": "c5f1bac3a7fea0b423b3f1c30de3cbb3b44090e0", "filename": "gcc/ada/s-fishfl.ads", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fishfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fishfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fishfl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,53 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . F A T _ I E E E _ S H O R T _ F L O A T          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---           Copyright (C) 1992-2014, Free Software Foundation, Inc.        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains an instantiation of the floating-point attribute\n---  runtime routines for IEEE short float. This is used on VMS targets where\n---  we can't just use Float, since this may have been mapped to Vax_Float\n---  using a Float_Representation configuration pragma.\n-\n---  TO BE REMOVED ???\n-\n-with System.Fat_Gen;\n-\n-package System.Fat_IEEE_Short_Float is\n-   pragma Pure;\n-\n-   type Fat_IEEE_Short is digits 6;\n-\n-   --  Note the only entity from this package that is accessed by Rtsfind\n-   --  is the name of the package instantiation. Entities within this package\n-   --  (i.e. the individual floating-point attribute routines) are accessed\n-   --  by name using selected notation.\n-\n-   package Attr_IEEE_Short is new System.Fat_Gen (Fat_IEEE_Short);\n-\n-end System.Fat_IEEE_Short_Float;"}, {"sha": "c5fedafb37c462b419684394577ab222c5202cb9", "filename": "gcc/ada/s-fvadfl.ads", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvadfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvadfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvadfl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,51 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               S Y S T E M . F A T _ V A X _ D _ F L O A T                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---            Copyright (C) 1992-2014, Free Software Foundation, Inc.       --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains an instantiation of the floating-point attribute\n---  runtime routines for VAX D-float for use on VMS targets.\n-\n---  TO BE REMOVED ???\n-\n-with System.Fat_Gen;\n-\n-package System.Fat_VAX_D_Float is\n-   pragma Pure;\n-\n-   type Fat_VAX_D is digits 9;\n-\n-   --  Note the only entity from this package that is accessed by Rtsfind\n-   --  is the name of the package instantiation. Entities within this package\n-   --  (i.e. the individual floating-point attribute routines) are accessed\n-   --  by name using selected notation.\n-\n-   package Attr_VAX_D_Float is new System.Fat_Gen (Fat_VAX_D);\n-\n-end System.Fat_VAX_D_Float;"}, {"sha": "fddcb6429536acf9acd897dda052c775e55a7a52", "filename": "gcc/ada/s-fvaffl.ads", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvaffl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvaffl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvaffl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,51 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               S Y S T E M . F A T _ V A X _ F _ F L O A T                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains an instantiation of the floating-point attribute\n---  runtime routines for VAX F-float for use on VMS targets.\n-\n---  TO BE REMOVED ???\n-\n-with System.Fat_Gen;\n-\n-package System.Fat_VAX_F_Float is\n-   pragma Pure;\n-\n-   type Fat_VAX_F is digits 6;\n-\n-   --  Note the only entity from this package that is accessed by Rtsfind\n-   --  is the name of the package instantiation. Entities within this package\n-   --  (i.e. the individual floating-point attribute routines) are accessed\n-   --  by name using selected notation.\n-\n-   package Attr_VAX_F_Float is new System.Fat_Gen (Fat_VAX_F);\n-\n-end System.Fat_VAX_F_Float;"}, {"sha": "15bbc56f3b0c657b1586351c90fcc15b21c8ba3e", "filename": "gcc/ada/s-fvagfl.ads", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvagfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-fvagfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fvagfl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,51 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---               S Y S T E M . F A T _ V A X _ G _ F L O A T                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains an instantiation of the floating-point attribute\n---  runtime routines for VAX F-float for use on VMS targets.\n-\n---  TO BE REMOVED ???\n-\n-with System.Fat_Gen;\n-\n-package System.Fat_VAX_G_Float is\n-   pragma Pure;\n-\n-   type Fat_VAX_G is digits 15;\n-\n-   --  Note the only entity from this package that is accessed by Rtsfind\n-   --  is the name of the package instantiation. Entities within this package\n-   --  (i.e. the individual floating-point attribute routines) are accessed\n-   --  by name using selected notation.\n-\n-   package Attr_VAX_G_Float is new System.Fat_Gen (Fat_VAX_G);\n-\n-end System.Fat_VAX_G_Float;"}, {"sha": "92314037411bfa6d479035bc71aefbf6841c0b83", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -426,12 +426,12 @@ package System.OS_Lib is\n    --  to the current position (origin = SEEK_CUR), end of file (origin =\n    --  SEEK_END), or start of file (origin = SEEK_SET).\n \n-   type File_Size is range -(2 ** 63) .. (2 ** 63) - 1;\n+   type Large_File_Size is range -(2 ** 63) .. (2 ** 63) - 1;\n \n    function File_Length (FD : File_Descriptor) return Long_Integer;\n    pragma Import (C, File_Length, \"__gnat_file_length_long\");\n \n-   function File_Length64 (FD : File_Descriptor) return File_Size;\n+   function File_Length64 (FD : File_Descriptor) return Large_File_Size;\n    pragma Import (C, File_Length64, \"__gnat_file_length\");\n    --  Get length of file from file descriptor FD\n "}, {"sha": "54acf26bc65a85a8429e47f76333e8ad41a84743", "filename": "gcc/ada/s-po32gl.adb", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-po32gl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-po32gl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-po32gl.adb?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,98 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                 S Y S T E M . P O O L _ 3 2 _ G L O B A L                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.Storage_Pools; use System.Storage_Pools;\n-with System.Memory;\n-\n-package body System.Pool_32_Global is\n-\n-   package SSE renames System.Storage_Elements;\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   overriding procedure Allocate\n-     (Pool         : in out Unbounded_No_Reclaim_Pool_32;\n-      Address      : out System.Address;\n-      Storage_Size : SSE.Storage_Count;\n-      Alignment    : SSE.Storage_Count)\n-   is\n-      pragma Warnings (Off, Pool);\n-      pragma Warnings (Off, Alignment);\n-\n-   begin\n-      Address := Memory.Alloc32 (Memory.size_t (Storage_Size));\n-\n-      --  The call to Alloc returns an address whose alignment is compatible\n-      --  with the worst case alignment requirement for the machine; thus the\n-      --  Alignment argument can be safely ignored.\n-\n-      if Address = Null_Address then\n-         raise Storage_Error;\n-      end if;\n-   end Allocate;\n-\n-   ----------------\n-   -- Deallocate --\n-   ----------------\n-\n-   overriding procedure Deallocate\n-     (Pool         : in out Unbounded_No_Reclaim_Pool_32;\n-      Address      : System.Address;\n-      Storage_Size : SSE.Storage_Count;\n-      Alignment    : SSE.Storage_Count)\n-   is\n-      pragma Warnings (Off, Pool);\n-      pragma Warnings (Off, Storage_Size);\n-      pragma Warnings (Off, Alignment);\n-\n-   begin\n-      Memory.Free (Address);\n-   end Deallocate;\n-\n-   ------------------\n-   -- Storage_Size --\n-   ------------------\n-\n-   overriding function Storage_Size\n-     (Pool  : Unbounded_No_Reclaim_Pool_32)\n-      return  SSE.Storage_Count\n-   is\n-      pragma Warnings (Off, Pool);\n-\n-   begin\n-      --  The 32 bit heap is limited to 2 GB of memory\n-\n-      return SSE.Storage_Count (2 ** 31);\n-   end Storage_Size;\n-\n-end System.Pool_32_Global;"}, {"sha": "578fbec8942c7d07fd6cc9dc9160135992522006", "filename": "gcc/ada/s-po32gl.ads", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-po32gl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-po32gl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-po32gl.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,80 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                 S Y S T E M . P O O L _ 3 2 _ G L O B A L                --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Storage pool corresponding to default global storage pool used for types\n---  designated by a 32 bits access type for which no storage pool is specified.\n---  This is specific to VMS.\n-\n-with System;\n-with System.Storage_Pools;\n-with System.Storage_Elements;\n-\n-package System.Pool_32_Global is\n-   pragma Elaborate_Body;\n-   --  Needed to ensure that library routines can execute allocators\n-\n-   --  Allocation strategy:\n-\n-   --    Call to malloc/free for each Allocate/Deallocate\n-   --    No user specifiable size\n-   --    No automatic reclaim\n-   --    Minimal overhead\n-\n-   --  Pool simulating the allocation/deallocation strategy used by the\n-   --  compiler for access types globally declared.\n-\n-   type Unbounded_No_Reclaim_Pool_32 is new\n-     System.Storage_Pools.Root_Storage_Pool with null record;\n-\n-   overriding function Storage_Size\n-     (Pool : Unbounded_No_Reclaim_Pool_32)\n-      return System.Storage_Elements.Storage_Count;\n-\n-   overriding procedure Allocate\n-     (Pool         : in out Unbounded_No_Reclaim_Pool_32;\n-      Address      : out System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count);\n-\n-   overriding procedure Deallocate\n-     (Pool         : in out Unbounded_No_Reclaim_Pool_32;\n-      Address      : System.Address;\n-      Storage_Size : System.Storage_Elements.Storage_Count;\n-      Alignment    : System.Storage_Elements.Storage_Count);\n-\n-   --  Pool object used by the compiler when implicit Storage Pool objects are\n-   --  explicitly referred to. For instance when writing something like:\n-   --     for T'Storage_Pool use Q'Storage_Pool;\n-   --  and Q'Storage_Pool hasn't been defined explicitly.\n-\n-   Global_Pool_32_Object : Unbounded_No_Reclaim_Pool_32;\n-\n-end System.Pool_32_Global;"}, {"sha": "e36c356fc2ad23938c624c34e56c2dd3f2c67de4", "filename": "gcc/ada/s-vaflop.adb", "status": "removed", "additions": 0, "deletions": 505, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vaflop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vaflop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop.adb?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,505 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . V A X _ F L O A T _ O P E R A T I O N S          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a dummy body for use on non-Alpha systems so that the library\n---  can compile. This dummy version uses ordinary conversions and other\n---  arithmetic operations. It is used only for testing purposes in the\n---  case where the -gnatdm switch is used to force testing of VMS features\n---  on non-VMS systems.\n-\n-with System.IO;\n-\n-package body System.Vax_Float_Operations is\n-   pragma Warnings (Off);\n-   --  Warnings about infinite recursion when the -gnatdm switch is used\n-\n-   -----------\n-   -- Abs_F --\n-   -----------\n-\n-   function Abs_F (X : F) return F is\n-   begin\n-      return abs X;\n-   end Abs_F;\n-\n-   -----------\n-   -- Abs_G --\n-   -----------\n-\n-   function Abs_G (X : G) return G is\n-   begin\n-      return abs X;\n-   end Abs_G;\n-\n-   -----------\n-   -- Add_F --\n-   -----------\n-\n-   function Add_F (X, Y : F) return F is\n-   begin\n-      return X + Y;\n-   end Add_F;\n-\n-   -----------\n-   -- Add_G --\n-   -----------\n-\n-   function Add_G (X, Y : G) return G is\n-   begin\n-      return X + Y;\n-   end Add_G;\n-\n-   ------------\n-   -- D_To_G --\n-   ------------\n-\n-   function D_To_G (X : D) return G is\n-   begin\n-      return G (X);\n-   end D_To_G;\n-\n-   --------------------\n-   -- Debug_Output_D --\n-   --------------------\n-\n-   procedure Debug_Output_D (Arg : D) is\n-   begin\n-      System.IO.Put (D'Image (Arg));\n-   end Debug_Output_D;\n-\n-   --------------------\n-   -- Debug_Output_F --\n-   --------------------\n-\n-   procedure Debug_Output_F (Arg : F) is\n-   begin\n-      System.IO.Put (F'Image (Arg));\n-   end Debug_Output_F;\n-\n-   --------------------\n-   -- Debug_Output_G --\n-   --------------------\n-\n-   procedure Debug_Output_G (Arg : G) is\n-   begin\n-      System.IO.Put (G'Image (Arg));\n-   end Debug_Output_G;\n-\n-   --------------------\n-   -- Debug_String_D --\n-   --------------------\n-\n-   Debug_String_Buffer : String (1 .. 32);\n-   --  Buffer used by all Debug_String_x routines for returning result\n-\n-   function Debug_String_D (Arg : D) return System.Address is\n-      Image_String : constant String := D'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_D;\n-\n-   --------------------\n-   -- Debug_String_F --\n-   --------------------\n-\n-   function Debug_String_F (Arg : F) return System.Address is\n-      Image_String : constant String := F'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_F;\n-\n-   --------------------\n-   -- Debug_String_G --\n-   --------------------\n-\n-   function Debug_String_G (Arg : G) return System.Address is\n-      Image_String : constant String := G'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_G;\n-\n-   -----------\n-   -- Div_F --\n-   -----------\n-\n-   function Div_F (X, Y : F) return F is\n-   begin\n-      return X / Y;\n-   end Div_F;\n-\n-   -----------\n-   -- Div_G --\n-   -----------\n-\n-   function Div_G (X, Y : G) return G is\n-   begin\n-      return X / Y;\n-   end Div_G;\n-\n-   ----------\n-   -- Eq_F --\n-   ----------\n-\n-   function Eq_F (X, Y : F) return Boolean is\n-   begin\n-      return X = Y;\n-   end Eq_F;\n-\n-   ----------\n-   -- Eq_G --\n-   ----------\n-\n-   function Eq_G (X, Y : G) return Boolean is\n-   begin\n-      return X = Y;\n-   end Eq_G;\n-\n-   ------------\n-   -- F_To_G --\n-   ------------\n-\n-   function F_To_G (X : F) return G is\n-   begin\n-      return G (X);\n-   end F_To_G;\n-\n-   ------------\n-   -- F_To_Q --\n-   ------------\n-\n-   function F_To_Q (X : F) return Q is\n-   begin\n-      return Q (X);\n-   end F_To_Q;\n-\n-   ------------\n-   -- F_To_S --\n-   ------------\n-\n-   function F_To_S (X : F) return S is\n-   begin\n-      return S (X);\n-   end F_To_S;\n-\n-   ------------\n-   -- G_To_D --\n-   ------------\n-\n-   function G_To_D (X : G) return D is\n-   begin\n-      return D (X);\n-   end G_To_D;\n-\n-   ------------\n-   -- G_To_F --\n-   ------------\n-\n-   function G_To_F (X : G) return F is\n-   begin\n-      return F (X);\n-   end G_To_F;\n-\n-   ------------\n-   -- G_To_Q --\n-   ------------\n-\n-   function G_To_Q (X : G) return Q is\n-   begin\n-      return Q (X);\n-   end G_To_Q;\n-\n-   ------------\n-   -- G_To_T --\n-   ------------\n-\n-   function G_To_T (X : G) return T is\n-   begin\n-      return T (X);\n-   end G_To_T;\n-\n-   ----------\n-   -- Le_F --\n-   ----------\n-\n-   function Le_F (X, Y : F) return Boolean is\n-   begin\n-      return X <= Y;\n-   end Le_F;\n-\n-   ----------\n-   -- Le_G --\n-   ----------\n-\n-   function Le_G (X, Y : G) return Boolean is\n-   begin\n-      return X <= Y;\n-   end Le_G;\n-\n-   ----------\n-   -- Lt_F --\n-   ----------\n-\n-   function Lt_F (X, Y : F) return Boolean is\n-   begin\n-      return X < Y;\n-   end Lt_F;\n-\n-   ----------\n-   -- Lt_G --\n-   ----------\n-\n-   function Lt_G (X, Y : G) return Boolean is\n-   begin\n-      return X < Y;\n-   end Lt_G;\n-\n-   -----------\n-   -- Mul_F --\n-   -----------\n-\n-   function Mul_F (X, Y : F) return F is\n-   begin\n-      return X * Y;\n-   end Mul_F;\n-\n-   -----------\n-   -- Mul_G --\n-   -----------\n-\n-   function Mul_G (X, Y : G) return G is\n-   begin\n-      return X * Y;\n-   end Mul_G;\n-\n-   ----------\n-   -- Ne_F --\n-   ----------\n-\n-   function Ne_F (X, Y : F) return Boolean is\n-   begin\n-      return X /= Y;\n-   end Ne_F;\n-\n-   ----------\n-   -- Ne_G --\n-   ----------\n-\n-   function Ne_G (X, Y : G) return Boolean is\n-   begin\n-      return X /= Y;\n-   end Ne_G;\n-\n-   -----------\n-   -- Neg_F --\n-   -----------\n-\n-   function Neg_F (X : F) return F is\n-   begin\n-      return -X;\n-   end Neg_F;\n-\n-   -----------\n-   -- Neg_G --\n-   -----------\n-\n-   function Neg_G (X : G) return G is\n-   begin\n-      return -X;\n-   end Neg_G;\n-\n-   --------\n-   -- pd --\n-   --------\n-\n-   procedure pd (Arg : D) is\n-   begin\n-      System.IO.Put_Line (D'Image (Arg));\n-   end pd;\n-\n-   --------\n-   -- pf --\n-   --------\n-\n-   procedure pf (Arg : F) is\n-   begin\n-      System.IO.Put_Line (F'Image (Arg));\n-   end pf;\n-\n-   --------\n-   -- pg --\n-   --------\n-\n-   procedure pg (Arg : G) is\n-   begin\n-      System.IO.Put_Line (G'Image (Arg));\n-   end pg;\n-\n-   ------------\n-   -- Q_To_F --\n-   ------------\n-\n-   function Q_To_F (X : Q) return F is\n-   begin\n-      return F (X);\n-   end Q_To_F;\n-\n-   ------------\n-   -- Q_To_G --\n-   ------------\n-\n-   function Q_To_G (X : Q) return G is\n-   begin\n-      return G (X);\n-   end Q_To_G;\n-\n-   ------------\n-   -- S_To_F --\n-   ------------\n-\n-   function S_To_F (X : S) return F is\n-   begin\n-      return F (X);\n-   end S_To_F;\n-\n-   --------------\n-   -- Return_D --\n-   --------------\n-\n-   function Return_D (X : D) return D is\n-   begin\n-      return X;\n-   end Return_D;\n-\n-   --------------\n-   -- Return_F --\n-   --------------\n-\n-   function Return_F (X : F) return F is\n-   begin\n-      return X;\n-   end Return_F;\n-\n-   --------------\n-   -- Return_G --\n-   --------------\n-\n-   function Return_G (X : G) return G is\n-   begin\n-      return X;\n-   end Return_G;\n-\n-   -----------\n-   -- Sub_F --\n-   -----------\n-\n-   function Sub_F (X, Y : F) return F is\n-   begin\n-      return X - Y;\n-   end Sub_F;\n-\n-   -----------\n-   -- Sub_G --\n-   -----------\n-\n-   function Sub_G (X, Y : G) return G is\n-   begin\n-      return X - Y;\n-   end Sub_G;\n-\n-   ------------\n-   -- T_To_G --\n-   ------------\n-\n-   --  This function must be located before T_To_D for frontend inlining\n-\n-   function T_To_G (X : T) return G is\n-   begin\n-      return G (X);\n-   end T_To_G;\n-\n-   ------------\n-   -- T_To_D --\n-   ------------\n-\n-   function T_To_D (X : T) return D is\n-   begin\n-      return G_To_D (T_To_G (X));\n-   end T_To_D;\n-\n-   -------------\n-   -- Valid_D --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_D (Arg : D) return Boolean is\n-      Val : constant T := G_To_T (D_To_G (Arg));\n-   begin\n-      return Val'Valid;\n-   end Valid_D;\n-\n-   -------------\n-   -- Valid_F --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_F (Arg : F) return Boolean is\n-      Val : constant S := F_To_S (Arg);\n-   begin\n-      return Val'Valid;\n-   end Valid_F;\n-\n-   -------------\n-   -- Valid_G --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_G (Arg : G) return Boolean is\n-      Val : constant T := G_To_T (Arg);\n-   begin\n-      return Val'Valid;\n-   end Valid_G;\n-\n-end System.Vax_Float_Operations;"}, {"sha": "1cb077e2b49017a9614e42674eac87e6a317ecde", "filename": "gcc/ada/s-vaflop.ads", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vaflop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vaflop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,230 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . V A X _ F L O A T _ O P E R A T I O N S          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains runtime routines for handling the non-IEEE\n---  floating-point formats used on the Vax.\n-\n---  TO BE REMOVED ???\n-\n-package System.Vax_Float_Operations is\n-\n-   type D is digits 9;\n-   type G is digits 15;\n-   type F is digits 6;\n-   type S is digits 6;\n-   type T is digits 15;\n-\n-   type Q is range -2 ** 63 .. +(2 ** 63 - 1);\n-   --  64-bit signed integer\n-\n-   --------------------------\n-   -- Conversion Functions --\n-   --------------------------\n-\n-   function D_To_G (X : D) return G;\n-   function G_To_D (X : G) return D;\n-   --  Conversions between D float and G float\n-\n-   function G_To_F (X : G) return F;\n-   function F_To_G (X : F) return G;\n-   --  Conversions between F float and G float\n-\n-   function F_To_S (X : F) return S;\n-   function S_To_F (X : S) return F;\n-   --  Conversions between F float and IEEE short\n-\n-   function G_To_T (X : G) return T;\n-   function T_To_G (X : T) return G;\n-   --  Conversions between G float and IEEE long\n-\n-   function F_To_Q (X : F) return Q;\n-   function Q_To_F (X : Q) return F;\n-   --  Conversions between F float and 64-bit integer\n-\n-   function G_To_Q (X : G) return Q;\n-   function Q_To_G (X : Q) return G;\n-   --  Conversions between G float and 64-bit integer\n-\n-   function T_To_D (X : T) return D;\n-   --  Conversion from IEEE long to D_Float (used for literals)\n-\n-   --------------------------\n-   -- Arithmetic Functions --\n-   --------------------------\n-\n-   function Abs_F (X : F) return F;\n-   function Abs_G (X : G) return G;\n-   --  Absolute value of F/G float\n-\n-   function Add_F (X, Y : F) return F;\n-   function Add_G (X, Y : G) return G;\n-   --  Addition of F/G float\n-\n-   function Div_F (X, Y : F) return F;\n-   function Div_G (X, Y : G) return G;\n-   --  Division of F/G float\n-\n-   function Mul_F (X, Y : F) return F;\n-   function Mul_G (X, Y : G) return G;\n-   --  Multiplication of F/G float\n-\n-   function Neg_F (X : F) return F;\n-   function Neg_G (X : G) return G;\n-   --  Negation of F/G float\n-\n-   function Sub_F (X, Y : F) return F;\n-   function Sub_G (X, Y : G) return G;\n-   --  Subtraction of F/G float\n-\n-   --------------------------\n-   -- Comparison Functions --\n-   --------------------------\n-\n-   function Eq_F (X, Y : F) return Boolean;\n-   function Eq_G (X, Y : G) return Boolean;\n-   --  Compares for X = Y\n-\n-   function Le_F (X, Y : F) return Boolean;\n-   function Le_G (X, Y : G) return Boolean;\n-   --  Compares for X <= Y\n-\n-   function Lt_F (X, Y : F) return Boolean;\n-   function Lt_G (X, Y : G) return Boolean;\n-   --  Compares for X < Y\n-\n-   function Ne_F (X, Y : F) return Boolean;\n-   function Ne_G (X, Y : G) return Boolean;\n-   --  Compares for X /= Y\n-\n-   ----------------------\n-   -- Return Functions --\n-   ----------------------\n-\n-   function Return_D (X : D) return D;\n-   function Return_F (X : F) return F;\n-   function Return_G (X : G) return G;\n-   --  Deal with returned value for an imported function where the function\n-   --  result is of VAX Float type. Usually nothing needs to be done, and these\n-   --  functions return their argument unchanged. But for the case of VMS Alpha\n-   --  the return value is already in $f0, so we need to trick the compiler\n-   --  into thinking that we are moving X to $f0. See bodies for this case\n-   --  for the Asm sequence generated to achieve this.\n-\n-   ----------------------------------\n-   -- Routines for Valid Attribute --\n-   ----------------------------------\n-\n-   function Valid_D (Arg : D) return Boolean;\n-   function Valid_F (Arg : F) return Boolean;\n-   function Valid_G (Arg : G) return Boolean;\n-   --  Test whether Arg has a valid representation\n-\n-   ----------------------\n-   -- Debug Procedures --\n-   ----------------------\n-\n-   procedure Debug_Output_D (Arg : D);\n-   procedure Debug_Output_F (Arg : F);\n-   procedure Debug_Output_G (Arg : G);\n-   pragma Export (Ada, Debug_Output_D);\n-   pragma Export (Ada, Debug_Output_F);\n-   pragma Export (Ada, Debug_Output_G);\n-   --  These routines output their argument in decimal string form, with\n-   --  no terminating line return. They are provided for implicit use by\n-   --  the pre gnat-3.12w GDB, and are retained for backwards compatibility.\n-\n-   function Debug_String_D (Arg : D) return System.Address;\n-   function Debug_String_F (Arg : F) return System.Address;\n-   function Debug_String_G (Arg : G) return System.Address;\n-   pragma Export (Ada, Debug_String_D);\n-   pragma Export (Ada, Debug_String_F);\n-   pragma Export (Ada, Debug_String_G);\n-   --  These routines return a decimal C string image of their argument.\n-   --  They are provided for implicit use by the debugger, in response to\n-   --  the special encoding used for Vax floating-point types (see Exp_Dbug\n-   --  for details). They supersede the above Debug_Output_D/F/G routines\n-   --  which didn't work properly with GDBTK.\n-\n-   procedure pd (Arg : D);\n-   procedure pf (Arg : F);\n-   procedure pg (Arg : G);\n-   pragma Export (Ada, pd);\n-   pragma Export (Ada, pf);\n-   pragma Export (Ada, pg);\n-   --  These are like the Debug_Output_D/F/G procedures except that they\n-   --  output a line return after the output. They were originally present\n-   --  for direct use in GDB before GDB recognized Vax floating-point\n-   --  types, and are retained for backwards compatibility.\n-\n-private\n-   pragma Inline_Always (D_To_G);\n-   pragma Inline_Always (F_To_G);\n-   pragma Inline_Always (F_To_Q);\n-   pragma Inline_Always (F_To_S);\n-   pragma Inline_Always (G_To_D);\n-   pragma Inline_Always (G_To_F);\n-   pragma Inline_Always (G_To_Q);\n-   pragma Inline_Always (G_To_T);\n-   pragma Inline_Always (Q_To_F);\n-   pragma Inline_Always (Q_To_G);\n-   pragma Inline_Always (S_To_F);\n-   pragma Inline_Always (T_To_G);\n-\n-   pragma Inline_Always (Abs_F);\n-   pragma Inline_Always (Abs_G);\n-   pragma Inline_Always (Add_F);\n-   pragma Inline_Always (Add_G);\n-   pragma Inline_Always (Div_G);\n-   pragma Inline_Always (Div_F);\n-   pragma Inline_Always (Mul_F);\n-   pragma Inline_Always (Mul_G);\n-   pragma Inline_Always (Neg_G);\n-   pragma Inline_Always (Neg_F);\n-   pragma Inline_Always (Return_D);\n-   pragma Inline_Always (Return_F);\n-   pragma Inline_Always (Return_G);\n-   pragma Inline_Always (Sub_F);\n-   pragma Inline_Always (Sub_G);\n-\n-   pragma Inline_Always (Eq_F);\n-   pragma Inline_Always (Eq_G);\n-   pragma Inline_Always (Le_F);\n-   pragma Inline_Always (Le_G);\n-   pragma Inline_Always (Lt_F);\n-   pragma Inline_Always (Lt_G);\n-   pragma Inline_Always (Ne_F);\n-   pragma Inline_Always (Ne_G);\n-\n-   pragma Inline_Always (Valid_D);\n-   pragma Inline_Always (Valid_F);\n-   pragma Inline_Always (Valid_G);\n-\n-end System.Vax_Float_Operations;"}, {"sha": "1164ff8994f10fecb2fe20000a87663cc554a5e8", "filename": "gcc/ada/s-vmexta.adb", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vmexta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vmexta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vmexta.adb?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,187 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . V M S _ E X C E P T I O N _ T A B L E            --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an Alpha/VMS package\n-\n-with System.HTable;\n-pragma Elaborate_All (System.HTable);\n-with System.Storage_Elements; use System.Storage_Elements;\n-\n-package body System.VMS_Exception_Table is\n-\n-   type HTable_Headers is range 1 .. 37;\n-\n-   type Exception_Code_Data;\n-   type Exception_Code_Data_Ptr is access all Exception_Code_Data;\n-\n-   --  The following record maps an imported VMS condition to an\n-   --  Ada exception.\n-\n-   type Exception_Code_Data is record\n-      Code       : Exception_Code;\n-      Except     : SSL.Exception_Data_Ptr;\n-      HTable_Ptr : Exception_Code_Data_Ptr;\n-   end record;\n-\n-   procedure Set_HT_Link\n-     (T    : Exception_Code_Data_Ptr;\n-      Next : Exception_Code_Data_Ptr);\n-\n-   function Get_HT_Link (T : Exception_Code_Data_Ptr)\n-     return Exception_Code_Data_Ptr;\n-\n-   function Hash (F : Exception_Code) return HTable_Headers;\n-   function Get_Key (T : Exception_Code_Data_Ptr) return Exception_Code;\n-\n-   package Exception_Code_HTable is new System.HTable.Static_HTable (\n-     Header_Num => HTable_Headers,\n-     Element    => Exception_Code_Data,\n-     Elmt_Ptr   => Exception_Code_Data_Ptr,\n-     Null_Ptr   => null,\n-     Set_Next   => Set_HT_Link,\n-     Next       => Get_HT_Link,\n-     Key        => Exception_Code,\n-     Get_Key    => Get_Key,\n-     Hash       => Hash,\n-     Equal      => \"=\");\n-\n-   ------------------\n-   -- Base_Code_In --\n-   ------------------\n-\n-   function Base_Code_In\n-     (Code : Exception_Code) return Exception_Code\n-   is\n-   begin\n-      return To_Address (To_Integer (Code) and not 2#0111#);\n-   end Base_Code_In;\n-\n-   ---------------------\n-   -- Coded_Exception --\n-   ---------------------\n-\n-   function Coded_Exception\n-     (X : Exception_Code) return SSL.Exception_Data_Ptr\n-   is\n-      Res : Exception_Code_Data_Ptr;\n-\n-   begin\n-      Res := Exception_Code_HTable.Get (X);\n-\n-      if Res /= null  then\n-         return Res.Except;\n-      else\n-         return null;\n-      end if;\n-\n-   end Coded_Exception;\n-\n-   -----------------\n-   -- Get_HT_Link --\n-   -----------------\n-\n-   function Get_HT_Link\n-     (T : Exception_Code_Data_Ptr) return Exception_Code_Data_Ptr\n-   is\n-   begin\n-      return T.HTable_Ptr;\n-   end Get_HT_Link;\n-\n-   -------------\n-   -- Get_Key --\n-   -------------\n-\n-   function Get_Key (T : Exception_Code_Data_Ptr)\n-     return Exception_Code\n-   is\n-   begin\n-      return T.Code;\n-   end Get_Key;\n-\n-   ----------\n-   -- Hash --\n-   ----------\n-\n-   function Hash\n-     (F : Exception_Code) return HTable_Headers\n-   is\n-      Headers_Magnitude : constant Exception_Code :=\n-        Exception_Code (HTable_Headers'Last - HTable_Headers'First + 1);\n-\n-   begin\n-      return HTable_Headers\n-        (To_Address ((To_Integer (F) mod To_Integer (Headers_Magnitude)) + 1));\n-   end Hash;\n-\n-   ----------------------------\n-   -- Register_VMS_Exception --\n-   ----------------------------\n-\n-   procedure Register_VMS_Exception\n-     (Code : Exception_Code;\n-      E    : SSL.Exception_Data_Ptr)\n-   is\n-      --  We bind the exception data with the base code found in the\n-      --  input value, that is with the severity bits masked off.\n-\n-      Excode : constant Exception_Code := Base_Code_In (Code);\n-\n-   begin\n-      --  The exception data registered here is mostly filled prior to this\n-      --  call and by __gnat_error_handler when the exception is raised. We\n-      --  still need to fill a couple of components for exceptions that will\n-      --  be used as propagation filters (exception data pointer registered\n-      --  as choices in the unwind tables): in some import/export cases, the\n-      --  exception pointers for the choice and the propagated occurrence may\n-      --  indeed be different for a single import code, and the personality\n-      --  routine attempts to match the import codes in this case.\n-\n-      E.Lang := 'V';\n-      E.Foreign_Data := Excode;\n-\n-      if Exception_Code_HTable.Get (Excode) = null then\n-         Exception_Code_HTable.Set (new Exception_Code_Data'(Excode, E, null));\n-      end if;\n-   end Register_VMS_Exception;\n-\n-   -----------------\n-   -- Set_HT_Link --\n-   -----------------\n-\n-   procedure Set_HT_Link\n-     (T    : Exception_Code_Data_Ptr;\n-      Next : Exception_Code_Data_Ptr)\n-   is\n-   begin\n-      T.HTable_Ptr := Next;\n-   end Set_HT_Link;\n-\n-end System.VMS_Exception_Table;"}, {"sha": "5ad3f3cd373d23e5c400f42cb610085eed014f7a", "filename": "gcc/ada/s-vmexta.ads", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vmexta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fs-vmexta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vmexta.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,67 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---            S Y S T E M . V M S _ E X C E P T I O N _ T A B L E           --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1997-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is usually used only on OpenVMS systems in the case\n---  where there is at least one Import/Export exception present.\n-\n-with System.Standard_Library;\n-\n-package System.VMS_Exception_Table is\n-\n-   package SSL renames System.Standard_Library;\n-\n-   subtype Exception_Code is System.Address;\n-\n-   procedure Register_VMS_Exception\n-     (Code : Exception_Code;\n-      E    : SSL.Exception_Data_Ptr);\n-   --  Register an exception in hash table mapping with a VMS condition code.\n-   --\n-   --  The table is used by exception code (the personnality routine) to detect\n-   --  wether a VMS exception (aka condition) is known by the Ada code. In\n-   --  that case, the identity of the imported or exported exception is used\n-   --  to create the occurrence.\n-\n-   --  LOTS more comments needed here regarding the entire scheme ???\n-\n-private\n-\n-   --  The following functions are directly called (without import/export) in\n-   --  init.c by __gnat_handle_vms_condition.\n-\n-   function Base_Code_In (Code : Exception_Code) return Exception_Code;\n-   --  Value of Code with the severity bits masked off\n-\n-   function Coded_Exception (X : Exception_Code)\n-     return SSL.Exception_Data_Ptr;\n-   --  Given a VMS condition, find and return its allocated Ada exception\n-\n-end System.VMS_Exception_Table;"}, {"sha": "b2e495a0edab072159d24c873867a90a85dec94d", "filename": "gcc/ada/sem_vfpt.adb", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fsem_vfpt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fsem_vfpt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_vfpt.adb?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,140 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             S E M _ V F P T                              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with CStand; use CStand;\n-with Einfo;  use Einfo;\n-with Stand;  use Stand;\n-\n-package body Sem_VFpt is\n-\n-   -----------------\n-   -- Set_D_Float --\n-   -----------------\n-\n-   procedure Set_D_Float (E : Entity_Id) is\n-      VAXDF_Digits : constant := 9;\n-\n-   begin\n-      Init_Size         (Base_Type (E), 64);\n-      Init_Alignment    (Base_Type (E));\n-      Init_Digits_Value (Base_Type (E), VAXDF_Digits);\n-      Set_Float_Bounds  (Base_Type (E));\n-\n-      Init_Size         (E, 64);\n-      Init_Alignment    (E);\n-      Init_Digits_Value (E, VAXDF_Digits);\n-      Set_Scalar_Range  (E, Scalar_Range (Base_Type (E)));\n-   end Set_D_Float;\n-\n-   -----------------\n-   -- Set_F_Float --\n-   -----------------\n-\n-   procedure Set_F_Float (E : Entity_Id) is\n-      VAXFF_Digits : constant := 6;\n-\n-   begin\n-      Init_Size         (Base_Type (E), 32);\n-      Init_Alignment    (Base_Type (E));\n-      Init_Digits_Value (Base_Type (E), VAXFF_Digits);\n-      Set_Float_Bounds  (Base_Type (E));\n-\n-      Init_Size         (E, 32);\n-      Init_Alignment    (E);\n-      Init_Digits_Value (E, VAXFF_Digits);\n-      Set_Scalar_Range  (E, Scalar_Range (Base_Type (E)));\n-   end Set_F_Float;\n-\n-   -----------------\n-   -- Set_G_Float --\n-   -----------------\n-\n-   procedure Set_G_Float (E : Entity_Id) is\n-      VAXGF_Digits : constant := 15;\n-\n-   begin\n-      Init_Size         (Base_Type (E), 64);\n-      Init_Alignment    (Base_Type (E));\n-      Init_Digits_Value (Base_Type (E), VAXGF_Digits);\n-      Set_Float_Bounds  (Base_Type (E));\n-\n-      Init_Size         (E, 64);\n-      Init_Alignment    (E);\n-      Init_Digits_Value (E, VAXGF_Digits);\n-      Set_Scalar_Range  (E, Scalar_Range (Base_Type (E)));\n-   end Set_G_Float;\n-\n-   -------------------\n-   -- Set_IEEE_Long --\n-   -------------------\n-\n-   procedure Set_IEEE_Long (E : Entity_Id) is\n-      IEEEL_Digits : constant := 15;\n-\n-   begin\n-      Init_Size         (Base_Type (E), 64);\n-      Init_Alignment    (Base_Type (E));\n-      Init_Digits_Value (Base_Type (E), IEEEL_Digits);\n-      Set_Float_Rep     (Base_Type (E), IEEE_Binary);\n-      Set_Float_Bounds  (Base_Type (E));\n-\n-      Init_Size         (E, 64);\n-      Init_Alignment    (E);\n-      Init_Digits_Value (E, IEEEL_Digits);\n-      Set_Scalar_Range  (E, Scalar_Range (Base_Type (E)));\n-   end Set_IEEE_Long;\n-\n-   --------------------\n-   -- Set_IEEE_Short --\n-   --------------------\n-\n-   procedure Set_IEEE_Short (E : Entity_Id) is\n-      IEEES_Digits : constant := 6;\n-\n-   begin\n-      Init_Size         (Base_Type (E), 32);\n-      Init_Alignment    (Base_Type (E));\n-      Init_Digits_Value (Base_Type (E), IEEES_Digits);\n-      Set_Float_Rep     (Base_Type (E), IEEE_Binary);\n-      Set_Float_Bounds  (Base_Type (E));\n-\n-      Init_Size         (E, 32);\n-      Init_Alignment    (E);\n-      Init_Digits_Value (E, IEEES_Digits);\n-      Set_Scalar_Range  (E, Scalar_Range (Base_Type (E)));\n-   end Set_IEEE_Short;\n-\n-   ------------------------------\n-   -- Set_Standard_Fpt_Formats --\n-   ------------------------------\n-\n-   procedure Set_Standard_Fpt_Formats is\n-   begin\n-      Set_IEEE_Short (Standard_Float);\n-      Set_IEEE_Long  (Standard_Long_Float);\n-      Set_IEEE_Long  (Standard_Long_Long_Float);\n-   end Set_Standard_Fpt_Formats;\n-\n-end Sem_VFpt;"}, {"sha": "1c9486612d752774898161084a1a87b0e3a4e3ca", "filename": "gcc/ada/sem_vfpt.ads", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fsem_vfpt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21c51f53f0145dd812b2231e03116f49fadcd004/gcc%2Fada%2Fsem_vfpt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_vfpt.ads?ref=21c51f53f0145dd812b2231e03116f49fadcd004", "patch": "@@ -1,55 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                             S E M _ V F P T                              --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1997-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains specialized routines for handling the Alpha\n---  floating point formats. It is used only in Alpha implementations.\n---  Note that this means that the caller can assume that we are on an\n---  Alpha implementation, and that Vax floating-point formats are valid.\n-\n-with Types; use Types;\n-\n-package Sem_VFpt is\n-\n-   procedure Set_D_Float (E : Entity_Id);\n-   --  Sets the given floating-point entity to have Vax D_Float format\n-\n-   procedure Set_F_Float (E : Entity_Id);\n-   --  Sets the given floating-point entity to have Vax F_Float format\n-\n-   procedure Set_G_Float (E : Entity_Id);\n-   --  Sets the given floating-point entity to have Vax G_Float format\n-\n-   procedure Set_IEEE_Short (E : Entity_Id);\n-   --  Sets the given floating-point entity to have IEEE Short format\n-\n-   procedure Set_IEEE_Long (E : Entity_Id);\n-   --  Sets the given floating-point entity to have IEEE Long format\n-\n-   procedure Set_Standard_Fpt_Formats;\n-   --  This procedure sets the appropriate formats for the standard\n-   --  floating-point types in Standard, based on the setting of\n-   --  the flags Opt.Float_Format and Opt.Float_Format_Long\n-\n-end Sem_VFpt;"}, {"sha": "4a9e6ad7b446cbac3c33ed097df940ae85acac6e", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08add8ea93dfa94541f2d20c0b56614ef0a2449/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=e08add8ea93dfa94541f2d20c0b56614ef0a2449", "patch": "@@ -37,39 +37,7 @@\n \n #include \"gsocket.h\"\n \n-#if defined(VMS)\n-/*\n- * For VMS, gsocket.h can't include sockets-related DEC C header files\n- * when building the runtime (because these files are in a DEC C text library\n- * (DECC$RTLDEF.TLB) not accessible to GCC). So, we generate a separate header\n- * file along with s-oscons.ads and include it here.\n- */\n-# include \"s-oscons.h\"\n-\n-/*\n- * We also need the declaration of struct hostent/servent, which s-oscons\n- * can't provide, so we copy it manually here. This needs to be kept in synch\n- * with the definition of that structure in the DEC C headers, which\n- * hopefully won't change frequently.\n- */\n-typedef char *__netdb_char_ptr __attribute__ (( mode (SI) ));\n-typedef __netdb_char_ptr *__netdb_char_ptr_ptr __attribute__ (( mode (SI) ));\n-\n-struct hostent {\n-  __netdb_char_ptr     h_name;\n-  __netdb_char_ptr_ptr h_aliases;\n-  int                  h_addrtype;\n-  int                  h_length;\n-  __netdb_char_ptr_ptr h_addr_list;\n-};\n-\n-struct servent {\n-  __netdb_char_ptr     s_name;\n-  __netdb_char_ptr_ptr s_aliases;\n-  int                  s_port;\n-  __netdb_char_ptr     s_proto;\n-};\n-#elif defined(__FreeBSD__)\n+#if defined(__FreeBSD__)\n typedef unsigned int IOCTL_Req_T;\n #else\n typedef int IOCTL_Req_T;\n@@ -142,7 +110,7 @@ __gnat_disable_all_sigpipes (void)\n #endif\n }\n \f\n-#if defined (_WIN32) || defined (__vxworks) || defined (VMS)\n+#if defined (_WIN32) || defined (__vxworks)\n /*\n  * Signalling FDs operations are implemented in Ada for these platforms\n  * (see subunit GNAT.Sockets.Thin.Signalling_Fds).\n@@ -509,15 +477,6 @@ __gnat_get_h_errno (void) {\n       return -1;\n   }\n \n-#elif defined (VMS)\n-  /* h_errno is defined as follows in OpenVMS' version of <netdb.h>.\n-   * However this header file is not available when building the GNAT\n-   * runtime library using GCC, so we are hardcoding the definition\n-   * directly. Note that the returned address is thread-specific.\n-   */\n-  extern int *decc$h_errno_get_addr ();\n-  return *decc$h_errno_get_addr ();\n-\n #elif defined (__rtems__)\n   /* At this stage in the tool build, no networking .h files are available.\n    * Newlib does not provide networking .h files and RTEMS is not built yet.\n@@ -550,11 +509,6 @@ __gnat_socket_ioctl (int fd, IOCTL_Req_T req, int *arg) {\n \n #ifndef HAVE_INET_PTON\n \n-#ifdef VMS\n-# define in_addr_t int\n-# define inet_addr decc$inet_addr\n-#endif\n-\n int\n __gnat_inet_pton (int af, const char *src, void *dst) {\n   switch (af) {\n@@ -592,7 +546,7 @@ __gnat_inet_pton (int af, const char *src, void *dst) {\n   }\n   return (rc == 0);\n \n-#elif defined (__hpux__) || defined (VMS)\n+#elif defined (__hpux__)\n   in_addr_t addr;\n   int rc = -1;\n "}]}