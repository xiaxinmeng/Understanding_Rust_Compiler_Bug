{"sha": "d476655d1d50448593b4099d0d6e7a4124ab6984", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ3NjY1NWQxZDUwNDQ4NTkzYjQwOTlkMGQ2ZTdhNDEyNGFiNjk4NA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2012-11-08T15:46:07Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2012-11-08T15:46:07Z"}, "message": "re PR fortran/51727 (Changing module files)\n\nPR fortran/51727\n* module.c (sorted_pointer_info): New.\n(gfc_get_sorted_pointer_info): New.\n(free_sorted_pointer_info_tree): New.\n(compare_sorted_pointer_info): New.\n(find_symbols_to_write): New.\n(write_symbol1_recursion): New.\n(write_symbol1): Collect symbols that need writing, output in order.\n(write_generic): Traverse tree in order.\n\nFrom-SVN: r193329", "tree": {"sha": "3ec961cbce5d8193453e4806801c712407a00d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec961cbce5d8193453e4806801c712407a00d1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d476655d1d50448593b4099d0d6e7a4124ab6984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d476655d1d50448593b4099d0d6e7a4124ab6984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d476655d1d50448593b4099d0d6e7a4124ab6984", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d476655d1d50448593b4099d0d6e7a4124ab6984/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "271a8a16512f3cd9eaac3df04b87f8c59baa5fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271a8a16512f3cd9eaac3df04b87f8c59baa5fec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271a8a16512f3cd9eaac3df04b87f8c59baa5fec"}], "stats": {"total": 153, "additions": 127, "deletions": 26}, "files": [{"sha": "00c46f15c17a5cf0a1f97b6c8ead911f3dd3ba1d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d476655d1d50448593b4099d0d6e7a4124ab6984/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d476655d1d50448593b4099d0d6e7a4124ab6984/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d476655d1d50448593b4099d0d6e7a4124ab6984", "patch": "@@ -1,3 +1,15 @@\n+2012-11-07  Tobias Schl\u00fcter  <tobi@gcc.gnu.org>\n+\n+\tPR fortran/51727\n+\t* module.c (sorted_pointer_info): New.\n+\t(gfc_get_sorted_pointer_info): New.\n+\t(free_sorted_pointer_info_tree): New.\n+\t(compare_sorted_pointer_info): New.\n+\t(find_symbols_to_write): New.\n+\t(write_symbol1_recursion): New.\n+\t(write_symbol1): Collect symbols that need writing, output in order.\n+\t(write_generic): Traverse tree in order.\n+\n 2012-11-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/53063"}, {"sha": "4cfcae4f3b9267d59677be8a01454684a9481409", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 115, "deletions": 26, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d476655d1d50448593b4099d0d6e7a4124ab6984/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d476655d1d50448593b4099d0d6e7a4124ab6984/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=d476655d1d50448593b4099d0d6e7a4124ab6984", "patch": "@@ -5150,32 +5150,122 @@ write_symbol0 (gfc_symtree *st)\n }\n \n \n-/* Recursive traversal function to write the secondary set of symbols\n-   to the module file.  These are symbols that were not public yet are\n-   needed by the public symbols or another dependent symbol.  The act\n-   of writing a symbol can modify the pointer_info tree, so we cease\n-   traversal if we find a symbol to write.  We return nonzero if a\n-   symbol was written and pass that information upwards.  */\n+/* Type for the temporary tree used when writing secondary symbols.  */\n+\n+struct sorted_pointer_info\n+{\n+  BBT_HEADER (sorted_pointer_info);\n+\n+  pointer_info *p;\n+};\n+\n+#define gfc_get_sorted_pointer_info() XCNEW (sorted_pointer_info)\n+\n+/* Recursively traverse the temporary tree, free its contents.  */\n+\n+static void\n+free_sorted_pointer_info_tree (sorted_pointer_info *p)\n+{\n+  if (!p)\n+    return;\n+\n+  free_sorted_pointer_info_tree (p->left);\n+  free_sorted_pointer_info_tree (p->right);\n+\n+  free (p);\n+}\n+\n+/* Comparison function for the temporary tree.  */\n \n static int\n-write_symbol1 (pointer_info *p)\n+compare_sorted_pointer_info (void *_spi1, void *_spi2)\n {\n-  int result;\n+  sorted_pointer_info *spi1, *spi2;\n+  spi1 = (sorted_pointer_info *)_spi1;\n+  spi2 = (sorted_pointer_info *)_spi2;\n \n+  if (spi1->p->integer < spi2->p->integer)\n+    return -1;\n+  if (spi1->p->integer > spi2->p->integer)\n+    return 1;\n+  return 0;\n+}\n+\n+\n+/* Finds the symbols that need to be written and collects them in the\n+   sorted_pi tree so that they can be traversed in an order\n+   independent of memory addresses.  */\n+\n+static void\n+find_symbols_to_write(sorted_pointer_info **tree, pointer_info *p)\n+{\n+  if (!p)\n+    return;\n+\n+  if (p->type == P_SYMBOL && p->u.wsym.state == NEEDS_WRITE)\n+    {\n+      sorted_pointer_info *sp = gfc_get_sorted_pointer_info();\n+      sp->p = p; \n+ \n+      gfc_insert_bbt (tree, sp, compare_sorted_pointer_info);\n+   }\n+\n+  find_symbols_to_write (tree, p->left);\n+  find_symbols_to_write (tree, p->right);\n+}\n+\n+\n+/* Recursive function that traverses the tree of symbols that need to be\n+   written and writes them in order.  */\n+\n+static void\n+write_symbol1_recursion (sorted_pointer_info *sp)\n+{\n+  if (!sp)\n+    return;\n+\n+  write_symbol1_recursion (sp->left);\n+\n+  pointer_info *p1 = sp->p;\n+  gcc_assert (p1->type == P_SYMBOL && p1->u.wsym.state == NEEDS_WRITE);\n+\n+  p1->u.wsym.state = WRITTEN;\n+  write_symbol (p1->integer, p1->u.wsym.sym);\n+ \n+  write_symbol1_recursion (sp->right);\n+}\n+\n+\n+/* Write the secondary set of symbols to the module file.  These are\n+   symbols that were not public yet are needed by the public symbols\n+   or another dependent symbol.  The act of writing a symbol can add\n+   symbols to the pointer_info tree, so we return nonzero if a symbol\n+   was written and pass that information upwards.  The caller will\n+   then call this function again until nothing was written.  It uses\n+   the utility functions and a temporary tree to ensure a reproducible\n+   ordering of the symbol output and thus the module file.  */\n+\n+static int\n+write_symbol1 (pointer_info *p)\n+{\n   if (!p)\n     return 0;\n \n-  result = write_symbol1 (p->left);\n+  /* Put symbols that need to be written into a tree sorted on the\n+     integer field.  */\n \n-  if (!(p->type != P_SYMBOL || p->u.wsym.state != NEEDS_WRITE))\n-    {\n-      p->u.wsym.state = WRITTEN;\n-      write_symbol (p->integer, p->u.wsym.sym);\n-      result = 1;\n-    }\n+  sorted_pointer_info *spi_root = NULL;\n+  find_symbols_to_write (&spi_root, p);\n+\n+  /* No symbols to write, return.  */\n+  if (!spi_root)\n+    return 0;\n+\n+  /* Otherwise, write and free the tree again.  */\n+  write_symbol1_recursion (spi_root);\n+  free_sorted_pointer_info_tree (spi_root);\n \n-  result |= write_symbol1 (p->right);\n-  return result;\n+  return 1;\n }\n \n \n@@ -5205,19 +5295,18 @@ write_generic (gfc_symtree *st)\n     return;\n \n   write_generic (st->left);\n-  write_generic (st->right);\n \n   sym = st->n.sym;\n-  if (!sym || check_unique_name (st->name))\n-    return;\n-\n-  if (sym->generic == NULL || !gfc_check_symbol_access (sym))\n-    return;\n+  if (sym && !check_unique_name (st->name)\n+      && sym->generic && gfc_check_symbol_access (sym))\n+    {\n+      if (!sym->module)\n+\tsym->module = module_name;\n \n-  if (sym->module == NULL)\n-    sym->module = module_name;\n+      mio_symbol_interface (&st->name, &sym->module, &sym->generic);\n+    }\n \n-  mio_symbol_interface (&st->name, &sym->module, &sym->generic);\n+  write_generic (st->right);\n }\n \n "}]}