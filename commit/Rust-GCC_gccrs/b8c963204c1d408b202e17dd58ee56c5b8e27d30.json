{"sha": "b8c963204c1d408b202e17dd58ee56c5b8e27d30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjOTYzMjA0YzFkNDA4YjIwMmUxN2RkNThlZTU2YzViOGUyN2QzMA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2007-11-06T16:52:17Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2007-11-06T16:52:17Z"}, "message": "m68k.c (sched-int.h, [...]): New includes.\n\n\t* config/m68k/m68k.c (sched-int.h, insn-codes.h): New includes.\n\t(TARGET_SCHED_ADJUST_COST, TARGET_SCHED_VARIABLE_ISSUE,\n\tTARGET_SCHED_INIT_GLOBAL, TARGET_SCHED_FINISH_GLOBAL,\n\tTARGET_SCHED_INIT, TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE,\n\tTARGET_SCHED_DFA_POST_ADVANCE_CYCLE): Redefine.\n\t(m68k_sched_attr_type2): New function.\n\t(sched_adjust_cost_state): New static variable.\n\t(m68k_sched_adjust_cost): New static function implementing\n\tscheduler hook.\n\t(sched_ib_size, sched_ib_filled, sched_ib_insn, sched_mem_unit_code):\n\tNew static variables.\n\t(m68k_sched_variable_issue): New static function implementing\n\tscheduler hook.\n\t(sched_dump_class_def, sched_dump_class_func_t): New typedefs.\n\t(sched_dump_split_class): New static function.\n\t(sched_dump_dfa_guess_unit_code, sched_dump_dfa_state): New static\n\tvariables.\n\t(sched_dump_dfa_class, m68k_sched_dump): New static function.\n\t(m68k_sched_md_init_global, m68k_sched_md_finish_global,\n\tm68k_sched_md_init, m68k_sched_dfa_pre_advance_cycle,\n\tm68k_sched_dfa_post_advance_cycle): New static functions implementing\n\tscheduler hooks.\n\n\t* config/m68k/m68k.h (m68k_sched_attr_type2): Declare.\n\t(CPU_UNITS_QUERY): Define.\n\n\t* config/m68k/cf.md: New file.\n\t* config/m68k/m68.md (cf.md): New include.\n\nFrom-SVN: r129938", "tree": {"sha": "44ea9fcd381891e1ec3eb3d30c838056ea8895c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44ea9fcd381891e1ec3eb3d30c838056ea8895c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8c963204c1d408b202e17dd58ee56c5b8e27d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c963204c1d408b202e17dd58ee56c5b8e27d30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c963204c1d408b202e17dd58ee56c5b8e27d30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c963204c1d408b202e17dd58ee56c5b8e27d30/comments", "author": null, "committer": null, "parents": [{"sha": "38d346765a731bd88dcda419cc2a247485f49507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d346765a731bd88dcda419cc2a247485f49507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d346765a731bd88dcda419cc2a247485f49507"}], "stats": {"total": 1194, "additions": 1194, "deletions": 0}, "files": [{"sha": "96f7129af90141b8fc5840ac44381155115e89a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -1,3 +1,34 @@\n+2007-11-06  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* config/m68k/m68k.c (sched-int.h, insn-codes.h): New includes.\n+\t(TARGET_SCHED_ADJUST_COST, TARGET_SCHED_VARIABLE_ISSUE,\n+\tTARGET_SCHED_INIT_GLOBAL, TARGET_SCHED_FINISH_GLOBAL,\n+\tTARGET_SCHED_INIT, TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE,\n+\tTARGET_SCHED_DFA_POST_ADVANCE_CYCLE): Redefine.\n+\t(m68k_sched_attr_type2): New function.\n+\t(sched_adjust_cost_state): New static variable.\n+\t(m68k_sched_adjust_cost): New static function implementing\n+\tscheduler hook.\n+\t(sched_ib_size, sched_ib_filled, sched_ib_insn, sched_mem_unit_code):\n+\tNew static variables.\n+\t(m68k_sched_variable_issue): New static function implementing\n+\tscheduler hook.\n+\t(sched_dump_class_def, sched_dump_class_func_t): New typedefs.\n+\t(sched_dump_split_class): New static function.\n+\t(sched_dump_dfa_guess_unit_code, sched_dump_dfa_state): New static\n+\tvariables.\n+\t(sched_dump_dfa_class, m68k_sched_dump): New static function.\n+\t(m68k_sched_md_init_global, m68k_sched_md_finish_global,\n+\tm68k_sched_md_init, m68k_sched_dfa_pre_advance_cycle,\n+\tm68k_sched_dfa_post_advance_cycle): New static functions implementing\n+\tscheduler hooks.\n+\n+\t* config/m68k/m68k.h (m68k_sched_attr_type2): Declare.\n+\t(CPU_UNITS_QUERY): Define.\n+\n+\t* config/m68k/cf.md: New file.\n+\t* config/m68k/m68.md (cf.md): New include.\n+\n 2007-11-06  Tom Tromey  <tromey@redhat.com>\n \n \tPR c++/32256, PR c++/32368:"}, {"sha": "b9c135c99015534550430ce756b31cadacd1af1b", "filename": "gcc/config/m68k/cf.md", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fcf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fcf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcf.md?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -0,0 +1,679 @@\n+;; ColdFire V2 DFA description.\n+;; Copyright (C) 2007 Free Software Foundation, Inc.\n+;; Contributed by CodeSourcery Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; ??? To let genattrtab live, implement this attribute in C.\n+(define_attr \"type2\"\n+  \"alu, alu_l, bcc, bra, call, jmp, lea, move, move_l, mul, pea, rts, unlk,\n+   unknown\"\n+  (symbol_ref \"m68k_sched_attr_type2 (insn)\"))\n+\n+;; Instruction Buffer\n+(define_automaton \"cf_v2_ib\")\n+\n+;; If one of these cpu units is occupied, that means that corresponding\n+;; word in the buffer is empty.\n+(define_cpu_unit \"cf_v2_ib_w0, cf_v2_ib_w1, cf_v2_ib_w2, cf_v2_ib_w3, cf_v2_ib_w4, cf_v2_ib_w5\" \"cf_v2_ib\")\n+\n+(final_presence_set \"cf_v2_ib_w1, cf_v2_ib_w2, cf_v2_ib_w3, cf_v2_ib_w4, cf_v2_ib_w5\" \"cf_v2_ib_w0\")\n+(final_presence_set \"cf_v2_ib_w2, cf_v2_ib_w3, cf_v2_ib_w4, cf_v2_ib_w5\" \"cf_v2_ib_w1\")\n+(final_presence_set \"cf_v2_ib_w3, cf_v2_ib_w4, cf_v2_ib_w5\" \"cf_v2_ib_w2\")\n+(final_presence_set \"cf_v2_ib_w4, cf_v2_ib_w5\" \"cf_v2_ib_w3\")\n+(final_presence_set \"cf_v2_ib_w5\" \"cf_v2_ib_w4\")\n+\n+;; Occupy 1 word.\n+(define_reservation \"cf_v2_ib1\" \"cf_v2_ib_w0|cf_v2_ib_w1|cf_v2_ib_w2|cf_v2_ib_w3|cf_v2_ib_w4|cf_v2_ib_w5\")\n+\n+;; Occupy 2 words.\n+(define_reservation \"cf_v2_ib2\" \"(cf_v2_ib_w0+cf_v2_ib_w1)|(cf_v2_ib_w1+cf_v2_ib_w2)|(cf_v2_ib_w2+cf_v2_ib_w3)|(cf_v2_ib_w3+cf_v2_ib_w4)|(cf_v2_ib_w4+cf_v2_ib_w5)\")\n+\n+;; Occupy 3 words.\n+(define_reservation \"cf_v2_ib3\" \"(cf_v2_ib_w0+cf_v2_ib_w1+cf_v2_ib_w2)|(cf_v2_ib_w1+cf_v2_ib_w2+cf_v2_ib_w3)|(cf_v2_ib_w2+cf_v2_ib_w3+cf_v2_ib_w4)|(cf_v2_ib_w3+cf_v2_ib_w4+cf_v2_ib_w5)\")\n+\n+;; Reservation to subscribe 1 word in the instruction buffer.  If a given\n+;; word in the instruction buffer is subscribed, that means it is empty.\n+;; This reservation is used at the start of each cycle to setup the number\n+;; of prefetched instruction words in the instruction buffer.\n+;; At each cycle, given that memory bus is available (i.e. there is no\n+;; pending memory operation), IFP prefetches two instruction words into IB.\n+(define_insn_reservation \"cf_v2_ib\" 0\n+  (and (eq_attr \"cpu\" \"cf_v2\")\n+       (eq_attr \"type\" \"ib\"))\n+  \"cf_v2_ib1\")\n+\n+;; Operand Execution Pipeline\n+(define_automaton \"cf_v2_oep\")\n+\n+(define_cpu_unit \"cf_v2_dsoc, cf_v2_agex\" \"cf_v2_oep\")\n+\n+;; A memory unit that is reffered to as 'certain hardware resources' in\n+;; ColdFire reference manuals.  This unit remains occupied for two cycles\n+;; after last dsoc cycle of a store - hence there is a 2 cycle delay between\n+;; two consecutive stores.\n+(define_automaton \"cf_v2_chr\")\n+\n+(define_cpu_unit \"cf_v2_chr\" \"cf_v2_chr\")\n+\n+;; Memory bus\n+(define_automaton \"cf_v2_mem\")\n+\n+;; When memory bus is subscribed, that implies that instruction buffer won't\n+;; get its portion this cycle.  To model that we query if cf_v2_mem unit is\n+;; subscribed and adjust number of prefetched instruction words accordingly.\n+;; \n+(define_query_cpu_unit \"cf_v2_mem\" \"cf_v2_mem\")\n+\n+;; Register to register move.\n+;; Takes 1 cycle.\n+(define_reservation \"cf_v2_move_00\"\n+  \"cf_v2_dsoc+cf_v2_agex\")\n+\n+;; Load from a memory location.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_move_10\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex\")\n+\n+;; Long load from a memory location.\n+;; Takes 2 cycles.\n+(define_reservation \"cf_v2_move_l_10\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex\")\n+\n+;; Load from an indexed location.\n+;; Takes 4 cycles.\n+(define_reservation \"cf_v2_move_i0\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex\")\n+\n+;; Long load from an indexed location.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_move_l_i0\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex\")\n+\n+;; Store to a memory location.\n+;; Takes 1 cycle.\n+(define_reservation \"cf_v2_move_01\"\n+  \"cf_v2_dsoc+cf_v2_agex+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Store to an indexed location.\n+;; Takes 2 cycle.\n+(define_reservation \"cf_v2_move_0i\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Load from a memory location and store to a memory location.\n+;; Takes 3 cycles\n+(define_reservation \"cf_v2_move_11\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Long load from a memory location and store to a memory location.\n+;; Takes 2 cycles.\n+(define_reservation \"cf_v2_move_l_11\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Load from an indexed location and store to a memory location.\n+;; Takes 4 cycles.\n+(define_reservation \"cf_v2_move_i1\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Long load from an indexed location and store to a memory location.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_move_l_i1\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Load from a memory location and store to an indexed location.\n+;; Takes 4 cycles.\n+(define_reservation \"cf_v2_move_1i\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem,cf_v2_agex,cf_v2_mem\")\n+\n+;; Long load from a memory location and store to an indexed location.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_move_l_1i\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_dsoc+cf_v2_agex+cf_v2_mem,cf_v2_agex,cf_v2_mem\")\n+\n+;; Lea operation for a memory location.\n+;; Takes 1 cycle.\n+(define_reservation \"cf_v2_lea_10\"\n+  \"cf_v2_dsoc+cf_v2_agex\")\n+\n+;; Lea operation for an indexed location.\n+;; Takes 2 cycles.\n+(define_reservation \"cf_v2_lea_i0\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex\")\n+\n+;; Pea operation for a memory location.\n+;; Takes 2 cycle.\n+(define_reservation \"cf_v2_pea_11\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+;; Pea operation for an indexed location.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_pea_i1\"\n+  \"cf_v2_dsoc+cf_v2_agex,cf_v2_agex,cf_v2_agex+cf_v2_chr,cf_v2_mem+cf_v2_chr,cf_v2_chr\")\n+\n+(define_automaton \"cf_v2_emac\")\n+\n+(define_cpu_unit \"cf_v2_emac1,cf_v2_emac2,cf_v2_emac3,cf_v2_emac4\"\n+  \"cf_v2_emac\")\n+\n+;; Mul operation with register operands.\n+;; Takes 4 cycles.\n+(define_reservation \"cf_v2_mul_00\"\n+  \"cf_v2_dsoc,cf_v2_agex+cf_v2_emac1,cf_v2_emac2,cf_v2_emac3,cf_v2_emac4\")\n+\n+;; Mul operation with implicit load from a memory location.\n+;; Takes 6 cycles.\n+(define_reservation \"cf_v2_mul_10\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex+cf_v2_emac1,cf_v2_emac2,cf_v2_emac3,cf_v2_emac4\")\n+\n+;; Mul operation with implicit load from an indexed location.\n+;; Takes 7 cycles.\n+(define_reservation \"cf_v2_mul_i0\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_agex,cf_v2_dsoc+cf_v2_mem,cf_v2_agex+cf_v2_emac1,cf_v2_emac2,cf_v2_emac3,cf_v2_emac4\")\n+\n+;; Instruction reservations.\n+\n+;; Below reservations are simple derivation from the above reservations.\n+;; Each reservation from the above expands into 3 reservations below - one\n+;; for each instruction size.\n+;; A number in the end of reservation's name is the size of the instruction.\n+\n+(define_insn_reservation \"cf_v2_move_00_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu,alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib1+cf_v2_move_00\")\n+\n+(define_insn_reservation \"cf_v2_move_00_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu,alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib2+cf_v2_move_00\")\n+\n+(define_insn_reservation \"cf_v2_move_00_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu,alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib3+cf_v2_move_00\")\n+\n+(define_insn_reservation \"cf_v2_move_10_1\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib1+cf_v2_move_10\")\n+\n+(define_insn_reservation \"cf_v2_move_10_2\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib2+cf_v2_move_10\")\n+\n+(define_insn_reservation \"cf_v2_move_10_3\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib3+cf_v2_move_10\")\n+\n+(define_insn_reservation \"cf_v2_move_l_10_1\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib1+cf_v2_move_l_10\")\n+\n+(define_insn_reservation \"cf_v2_move_l_10_2\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib2+cf_v2_move_l_10\")\n+\n+(define_insn_reservation \"cf_v2_move_l_10_3\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib3+cf_v2_move_l_10\")\n+\n+(define_insn_reservation \"cf_v2_move_i0_2\" 5\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib2+cf_v2_move_i0\")\n+\n+(define_insn_reservation \"cf_v2_move_i0_3\" 5\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib3+cf_v2_move_i0\")\n+\n+(define_insn_reservation \"cf_v2_move_l_i0_2\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib2+cf_v2_move_l_i0\")\n+\n+(define_insn_reservation \"cf_v2_move_l_i0_3\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib3+cf_v2_move_l_i0\")\n+\n+(define_insn_reservation \"cf_v2_move_01_1\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"01\"))\n+  \"cf_v2_ib1+cf_v2_move_01\")\n+\n+(define_insn_reservation \"cf_v2_move_01_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"01\"))\n+  \"cf_v2_ib2+cf_v2_move_01\")\n+\n+(define_insn_reservation \"cf_v2_move_01_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"01\"))\n+  \"cf_v2_ib3+cf_v2_move_01\")\n+\n+(define_insn_reservation \"cf_v2_move_0i_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"0i\"))\n+  \"cf_v2_ib2+cf_v2_move_0i\")\n+\n+(define_insn_reservation \"cf_v2_move_0i_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move,move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"0i\"))\n+  \"cf_v2_ib3+cf_v2_move_0i\")\n+\n+(define_insn_reservation \"cf_v2_move_11_1\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib1+cf_v2_move_11\")\n+\n+(define_insn_reservation \"cf_v2_move_11_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib2+cf_v2_move_11\")\n+\n+(define_insn_reservation \"cf_v2_move_11_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib3+cf_v2_move_11\")\n+\n+(define_insn_reservation \"cf_v2_move_l_11_1\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib1+cf_v2_move_l_11\")\n+\n+(define_insn_reservation \"cf_v2_move_l_11_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib2+cf_v2_move_l_11\")\n+\n+(define_insn_reservation \"cf_v2_move_l_11_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib3+cf_v2_move_l_11\")\n+\n+(define_insn_reservation \"cf_v2_move_i1_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib2+cf_v2_move_i1\")\n+\n+(define_insn_reservation \"cf_v2_move_i1_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib3+cf_v2_move_i1\")\n+\n+(define_insn_reservation \"cf_v2_move_l_i1_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib2+cf_v2_move_l_i1\")\n+\n+(define_insn_reservation \"cf_v2_move_l_i1_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib3+cf_v2_move_l_i1\")\n+\n+(define_insn_reservation \"cf_v2_move_1i_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"1i\"))\n+  \"cf_v2_ib2+cf_v2_move_1i\")\n+\n+(define_insn_reservation \"cf_v2_move_1i_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"alu_l,move\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"1i\"))\n+  \"cf_v2_ib3+cf_v2_move_1i\")\n+\n+(define_insn_reservation \"cf_v2_move_l_1i_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"1i\"))\n+  \"cf_v2_ib2+cf_v2_move_l_1i\")\n+\n+(define_insn_reservation \"cf_v2_move_l_1i_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"move_l\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"1i\"))\n+  \"cf_v2_ib3+cf_v2_move_l_1i\")\n+\n+(define_insn_reservation \"cf_v2_lea_10_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"lea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib1+cf_v2_lea_10\")\n+\n+(define_insn_reservation \"cf_v2_lea_10_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"lea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib2+cf_v2_lea_10\")\n+\n+(define_insn_reservation \"cf_v2_lea_10_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"lea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib3+cf_v2_lea_10\")\n+\n+(define_insn_reservation \"cf_v2_lea_i0_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"lea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib2+cf_v2_lea_i0\")\n+\n+(define_insn_reservation \"cf_v2_lea_i0_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"lea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib3+cf_v2_lea_i0\")\n+\n+(define_insn_reservation \"cf_v2_pea_11_1\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"pea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib1+cf_v2_pea_11\")\n+\n+(define_insn_reservation \"cf_v2_pea_11_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"pea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib2+cf_v2_pea_11\")\n+\n+(define_insn_reservation \"cf_v2_pea_11_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"pea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cf_v2_ib3+cf_v2_pea_11\")\n+\n+(define_insn_reservation \"cf_v2_pea_i1_2\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"pea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib2+cf_v2_pea_i1\")\n+\n+(define_insn_reservation \"cf_v2_pea_i1_3\" 0\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"pea\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cf_v2_ib3+cf_v2_pea_i1\")\n+\n+(define_insn_reservation \"cf_v2_mul_00_1\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib1+cf_v2_mul_00\")\n+\n+(define_insn_reservation \"cf_v2_mul_00_2\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib2+cf_v2_mul_00\")\n+\n+(define_insn_reservation \"cf_v2_mul_00_3\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cf_v2_ib3+cf_v2_mul_00\")\n+\n+(define_insn_reservation \"cf_v2_mul_10_1\" 6\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib1+cf_v2_mul_10\")\n+\n+(define_insn_reservation \"cf_v2_mul_10_2\" 6\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib2+cf_v2_mul_10\")\n+\n+(define_insn_reservation \"cf_v2_mul_10_3\" 6\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cf_v2_ib3+cf_v2_mul_10\")\n+\n+(define_insn_reservation \"cf_v2_mul_i0_2\" 7\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib2+cf_v2_mul_i0\")\n+\n+(define_insn_reservation \"cf_v2_mul_i0_3\" 7\n+  (and (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t\t (eq_attr \"type2\" \"mul\"))\n+\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cf_v2_ib3+cf_v2_mul_i0\")\n+\n+;; ??? As return reads target address from stack, use a mem-read reservation\n+;; for it.\n+(define_reservation \"cf_v2_rts\" \"cf_v2_move_10\")\n+\n+;; ??? It's not clear what the core does during these 5 cycles.\n+;; Luckily, we don't care that much about an insn that won't be moved.\n+(define_insn_reservation \"cf_v2_rts_1\" 5\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"rts\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_rts\")\n+\n+;; Call instructions reservations.\n+\n+;; ??? It's not clear what reservation is best to use for calls.\n+;; For now we use mem-write + return reservations to reflect the fact of\n+;; pushing and poping return address to and from the stack.\n+\n+(define_insn_reservation \"cf_v2_call_1\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"call\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_move_10,cf_v2_rts\")\n+\n+(define_insn_reservation \"cf_v2_call_2\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"call\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+  \"cf_v2_ib2+cf_v2_move_10,cf_v2_rts\")\n+\n+(define_insn_reservation \"cf_v2_call_3\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"call\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+  \"cf_v2_ib3+cf_v2_move_10,cf_v2_rts\")\n+\n+;; Branch reservations.\n+\n+;; ??? Branch reservations are unclear to me so far.  Luckily, we don't care\n+;; ??? that much about branches.\n+(define_reservation \"cf_v2_bcc\" \"cf_v2_move_00\")\n+\n+(define_insn_reservation \"cf_v2_bcc_1\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bcc\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_bcc\")\n+\n+(define_insn_reservation \"cf_v2_bcc_2\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bcc\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+  \"cf_v2_ib2+cf_v2_bcc\")\n+\n+(define_insn_reservation \"cf_v2_bcc_3\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bcc\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+  \"cf_v2_ib3+cf_v2_bcc\")\n+\n+(define_reservation \"cf_v2_bra\" \"cf_v2_move_01\")\n+\n+(define_insn_reservation \"cf_v2_bra_1\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bra\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_bra\")\n+\n+(define_insn_reservation \"cf_v2_bra_2\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bra\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+  \"cf_v2_ib2+cf_v2_bra\")\n+\n+(define_insn_reservation \"cf_v2_bra_3\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"bra\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+  \"cf_v2_ib3+cf_v2_bra\")\n+\n+;; Computed jump.\n+;; Takes 3 cycles.\n+(define_reservation \"cf_v2_jmp\"\n+  \"cf_v2_dsoc,cf_v2_agex,cf_v2_dsoc,cf_v2_agex\")\n+\n+(define_insn_reservation \"cf_v2_jmp_1\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"jmp\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_jmp\")\n+\n+(define_insn_reservation \"cf_v2_jmp_2\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"jmp\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+  \"cf_v2_ib2+cf_v2_jmp\")\n+\n+(define_insn_reservation \"cf_v2_jmp_3\" 3\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"jmp\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+  \"cf_v2_ib3+cf_v2_jmp\")\n+\n+;; Misc reservations.\n+\n+(define_insn_reservation \"cf_v2_unlk_1\" 2\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"type2\" \"unlk\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_move_l_10\")\n+\n+;; This automaton is used to gather statistics on insns that need reservations.\n+(define_automaton \"cf_v2_guess\")\n+\n+(define_query_cpu_unit \"cf_v2_guess\" \"cf_v2_guess\")\n+\n+;; Dummy reservation for instructions that are not handled yet.\n+\n+(define_insn_reservation \"cf_v2_guess_1\" 1\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"guess\" \"yes\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+  \"cf_v2_ib1+cf_v2_guess+cf_v2_dsoc+cf_v2_agex\")\n+\n+(define_insn_reservation \"cf_v2_guess_2\" 1\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"guess\" \"yes\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+  \"cf_v2_ib2+cf_v2_guess+cf_v2_dsoc+cf_v2_agex\")\n+\n+(define_insn_reservation \"cf_v2_guess_3\" 1\n+  (and (and (eq_attr \"cpu\" \"cf_v2\")\n+\t    (eq_attr \"guess\" \"yes\"))\n+       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+  \"cf_v2_ib3+cf_v2_guess+cf_v2_dsoc+cf_v2_agex\")"}, {"sha": "bd039077b7ddb644d6b09e3b4125720cdf07e850", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -73,6 +73,7 @@ extern enum attr_opy_type m68k_sched_attr_opy_type (rtx, int);\n extern int m68k_sched_attr_size (rtx);\n extern enum attr_op_mem m68k_sched_attr_op_mem (rtx);\n extern enum attr_type m68k_sched_branch_type (rtx);\n+extern enum attr_type2 m68k_sched_attr_type2 (rtx);\n #endif /* HAVE_ATTR_cpu */\n \n #endif /* RTX_CODE */"}, {"sha": "142c8aa959e5537880aa51e78681fea8ac8a05f1", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -43,6 +43,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"flags.h\"\n #include \"df.h\"\n+/* ??? Need to add a dependency between m68k.o and sched-int.h.  */\n+#include \"sched-int.h\"\n+#include \"insn-codes.h\"\n \n enum reg_class regno_reg_class[] =\n {\n@@ -118,6 +121,14 @@ struct m68k_address {\n   int scale;\n };\n \n+static int m68k_sched_adjust_cost (rtx, rtx, rtx, int);\n+static int m68k_sched_variable_issue (FILE *, int, rtx, int);\n+static void m68k_sched_md_init_global (FILE *, int, int);\n+static void m68k_sched_md_finish_global (FILE *, int);\n+static void m68k_sched_md_init (FILE *, int, int);\n+static void m68k_sched_dfa_pre_advance_cycle (void);\n+static void m68k_sched_dfa_post_advance_cycle (void);\n+\n static bool m68k_handle_option (size_t, const char *, int);\n static rtx find_addr_reg (rtx);\n static const char *singlemove_string (rtx *);\n@@ -185,6 +196,27 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_ASM_FILE_START_APP_OFF\n #define TARGET_ASM_FILE_START_APP_OFF true\n \n+#undef TARGET_SCHED_ADJUST_COST\n+#define TARGET_SCHED_ADJUST_COST m68k_sched_adjust_cost\n+\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE m68k_sched_variable_issue\n+\n+#undef TARGET_SCHED_INIT_GLOBAL\n+#define TARGET_SCHED_INIT_GLOBAL m68k_sched_md_init_global\n+\n+#undef TARGET_SCHED_FINISH_GLOBAL\n+#define TARGET_SCHED_FINISH_GLOBAL m68k_sched_md_finish_global\n+\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT m68k_sched_md_init\n+\n+#undef TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE\n+#define TARGET_SCHED_DFA_PRE_ADVANCE_CYCLE m68k_sched_dfa_pre_advance_cycle\n+\n+#undef TARGET_SCHED_DFA_POST_ADVANCE_CYCLE\n+#define TARGET_SCHED_DFA_POST_ADVANCE_CYCLE m68k_sched_dfa_post_advance_cycle\n+\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION m68k_handle_option\n \n@@ -4971,3 +5003,451 @@ m68k_sched_branch_type (rtx insn)\n \n   return type;\n }\n+\n+/* Implement type2 attribute.  */\n+enum attr_type2\n+m68k_sched_attr_type2 (rtx insn)\n+{\n+  switch (get_attr_type1 (insn))\n+    {\n+    case TYPE1_ALU_REG1:\n+    case TYPE1_ALU_REGX:\n+      return TYPE2_ALU;\n+\n+    case TYPE1_ALU_L:\n+    case TYPE1_ALUQ_L:\n+    case TYPE1_CMP_L:\n+      return TYPE2_ALU_L;\n+\n+    case TYPE1_BCC:\n+      return TYPE2_BCC;\n+\n+    case TYPE1_BRA:\n+      return TYPE2_BRA;\n+\n+    case TYPE1_BSR:\n+    case TYPE1_JSR:\n+      return TYPE2_CALL;\n+\n+    case TYPE1_JMP:\n+      return TYPE2_JMP;\n+\n+    case TYPE1_LEA:\n+      return TYPE2_LEA;\n+\n+    case TYPE1_CLR:\n+    case TYPE1_MOV3Q_L:\n+    case TYPE1_MOVE:\n+    case TYPE1_MOVEQ_L:\n+    case TYPE1_TST:\n+      return TYPE2_MOVE;\n+\n+    case TYPE1_MOVE_L:\n+    case TYPE1_TST_L:\n+      return TYPE2_MOVE_L;\n+\n+    case TYPE1_MUL_W:\n+    case TYPE1_MUL_L:\n+      return TYPE2_MUL;\n+\n+    case TYPE1_PEA:\n+      return TYPE2_PEA;\n+\n+    case TYPE1_RTS:\n+      return TYPE2_RTS;\n+\n+    case TYPE1_UNLK:\n+      return TYPE2_UNLK;\n+\n+    default:\n+      gcc_assert (get_attr_guess (insn) == GUESS_YES);\n+      return TYPE2_UNKNOWN;\n+    }\n+}\n+\n+/* An empty state that is used in m68k_sched_adjust_cost.  */\n+static state_t sched_adjust_cost_state;\n+\n+/* Implement adjust_cost scheduler hook.\n+   Return adjusted COST of dependency LINK between DEF_INSN and INSN.  */\n+static int\n+m68k_sched_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx def_insn,\n+\t\t\tint cost)\n+{\n+  int delay;\n+\n+  if (recog_memoized (def_insn) < 0\n+      || recog_memoized (insn) < 0)\n+    return cost;\n+\n+  /* Don't try to issue INSN earlier than DFA permits.\n+     This is especially useful for instructions that write to memory,\n+     as their true dependence (default) latency is better to be set to 0\n+     to workaround alias analysis limitations.\n+     This is, in fact, a machine independent tweak, so, probably,\n+     it should be moved to haifa-sched.c: insn_cost ().  */\n+\n+  delay = min_insn_conflict_delay (sched_adjust_cost_state, def_insn, insn);\n+  if (delay > cost)\n+    cost = delay;\n+\n+  return cost;\n+}\n+\n+/* Size of the instruction buffer in words.  */\n+static int sched_ib_size;\n+\n+/* Number of filled words in the instruction buffer.  */\n+static int sched_ib_filled;\n+\n+/* An insn that reserves (marks empty) one word in the instruction buffer.  */\n+static rtx sched_ib_insn;\n+\n+/* ID of memory unit.  */\n+static int sched_mem_unit_code;\n+\n+/* Implementation of the targetm.sched.variable_issue () hook.\n+   It is called after INSN was issued.  It returns the number of insns\n+   that can possibly get scheduled on the current cycle.\n+   It is used here to determine the effect of INSN on the instruction\n+   buffer.  */\n+static int\n+m68k_sched_variable_issue (FILE *sched_dump ATTRIBUTE_UNUSED,\n+\t\t\t   int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t\t   rtx insn, int can_issue_more)\n+{\n+  int insn_size;\n+\n+  if (recog_memoized (insn) >= 0)\n+    {\n+      insn_size = get_attr_size (insn);\n+\n+      gcc_assert (insn_size <= sched_ib_filled);\n+\n+      --can_issue_more;\n+    }\n+  else if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t   || asm_noperands (PATTERN (insn)) >= 0)\n+    insn_size = sched_ib_filled;\n+  else\n+    insn_size = 0;\n+\n+  sched_ib_filled -= insn_size;\n+\n+  return can_issue_more;\n+}\n+\n+/* Statistics gatherer.  */\n+\n+typedef enum\n+  {\n+    /* Something needs to be done for this insn.  */\n+    SCHED_DUMP_TODO,\n+\n+    /* Support for this insn is complete.  */\n+    SCHED_DUMP_DONE,\n+\n+    /* This insn didn't require much effort to support it.  */\n+    SCHED_DUMP_NOTHING\n+  } sched_dump_class_def;\n+\n+/* Pointer to functions that classifies insns into 3 above classes.  */\n+typedef sched_dump_class_def (*sched_dump_class_func_t) (rtx);\n+\n+/* Return statistical type of INSN regarding splits.  */\n+static sched_dump_class_def\n+sched_dump_split_class (rtx insn)\n+{\n+  int i;\n+\n+  i = recog_memoized (insn);\n+  gcc_assert (i >= 0);\n+\n+  switch (get_attr_split (insn))\n+    {\n+    case SPLIT_TODO:\n+      return SCHED_DUMP_TODO;\n+\n+    case SPLIT_DONE:\n+      return SCHED_DUMP_DONE;\n+\n+    case SPLIT_NOTHING:\n+      return SCHED_DUMP_NOTHING;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* ID of the guess unit.  */\n+static int sched_dump_dfa_guess_unit_code;\n+\n+/* DFA state for use in sched_dump_dfa_class ().  */\n+static state_t sched_dump_dfa_state;\n+\n+/* Return statistical type of INSN regarding DFA reservations.  */\n+static sched_dump_class_def\n+sched_dump_dfa_class (rtx insn)\n+{\n+  int i;\n+\n+  i = recog_memoized (insn);\n+  gcc_assert (i >= 0 && insn_has_dfa_reservation_p (insn));\n+\n+  if (sched_dump_split_class (insn) == SCHED_DUMP_TODO)\n+    /* Insn is not yet ready for reservations.  */\n+    return SCHED_DUMP_NOTHING;\n+\n+  state_reset (sched_dump_dfa_state);\n+\n+  if (state_transition (sched_dump_dfa_state, insn) >= 0)\n+    gcc_unreachable ();\n+\n+  if (cpu_unit_reservation_p (sched_dump_dfa_state,\n+\t\t\t      sched_dump_dfa_guess_unit_code))\n+    return SCHED_DUMP_TODO;\n+\n+  return SCHED_DUMP_DONE;\n+}\n+\n+/* Dump statistics on current function into file DUMP_FILENAME and prefix\n+   each entry with PREFIX.\n+   Instructions are classified with DUMP_CLASS.  */\n+static void\n+m68k_sched_dump (sched_dump_class_func_t dump_class,\n+\t\t const char *prefix, FILE *dump)\n+{\n+  sbitmap present;\n+  int *todos;\n+  int *dones;\n+  int *nothings;\n+  rtx insn;\n+\n+  gcc_assert (dump != NULL);\n+\n+  present = sbitmap_alloc (CODE_FOR_nothing);\n+  sbitmap_zero (present);\n+\n+  todos = xcalloc (CODE_FOR_nothing, sizeof (*todos));\n+  dones = xcalloc (CODE_FOR_nothing, sizeof (*dones));\n+  nothings = xcalloc (CODE_FOR_nothing, sizeof (*nothings));\n+\n+  /* Gather statistics.  */\n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn) && recog_memoized (insn) >= 0)\n+\t{\n+\t  enum insn_code code;\n+\n+\t  code = INSN_CODE (insn);\n+\t  gcc_assert (code < CODE_FOR_nothing);\n+\n+\t  SET_BIT (present, code);\n+\n+\t  switch (dump_class (insn))\n+\t    {\n+\t    case SCHED_DUMP_TODO:\n+\t      ++todos[code];\n+\t      break;\n+\n+\t    case SCHED_DUMP_DONE:\n+\t      ++dones[code];\n+\t      break;\n+\n+\t    case SCHED_DUMP_NOTHING:\n+\t      ++nothings[code];\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* Print statisctics.  */\n+  {\n+    unsigned int i;\n+    sbitmap_iterator si;\n+    int total_todo;\n+    int total_done;\n+    int total_nothing;\n+\n+    total_todo = 0;\n+    total_done = 0;\n+    total_nothing = 0;\n+\n+    EXECUTE_IF_SET_IN_SBITMAP (present, 0, i, si)\n+      {\n+\tint todo;\n+\tint done;\n+\tint nothing;\n+\tenum insn_code code;\n+\n+\tcode = (enum insn_code) i;\n+\n+\ttodo = todos[code];\n+\tdone = dones[code];\n+\tnothing = nothings[code];\n+\n+\ttotal_todo += todo;\n+\ttotal_done += done;\n+\ttotal_nothing += nothing;\n+\n+\tif (todo != 0)\n+\t  {\n+\t    fprintf (dump,\n+\t\t     \"%s: %3d: %d / %d / %d ;\",\n+\t\t     prefix, code, todo, done, nothing);\n+\n+\t    {\n+\t      const char *name;\n+\n+\t      name = get_insn_name (code);\n+\n+\t      if (name != NULL)\n+\t\tfprintf (dump, \" {%s}\\n\", name);\n+\t      else\n+\t\tfprintf (dump, \" {unknown}\\n\");\n+\t    }\n+\t  }\n+      }\n+\n+    gcc_assert (CODE_FOR_nothing < 999);\n+\n+    fprintf (dump,\n+\t     \"%s: 999: %d / %d / %d ; {total}\\n\",\n+\t     prefix, total_todo, total_done, total_nothing);\n+  }\n+\n+  free (nothings);\n+  nothings = NULL;\n+  free (dones);\n+  dones = NULL;\n+  free (todos);\n+  todos = NULL;\n+\n+  sbitmap_free (present);\n+  present = NULL;\n+}\n+\n+/* Implementation of targetm.sched.md_init_global () hook.\n+   It is invoked once per scheduling pass and is used here\n+   to initialize scheduler constants.  */\n+static void\n+m68k_sched_md_init_global (FILE *sched_dump ATTRIBUTE_UNUSED,\n+\t\t\t   int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t\t   int n_insns ATTRIBUTE_UNUSED)\n+{\n+  /* Init branch types.  */\n+  {\n+    rtx insn;\n+\n+    sched_branch_type = xcalloc (get_max_uid () + 1,\n+\t\t\t\t sizeof (*sched_branch_type));\n+\n+    for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+      {\n+\tif (JUMP_P (insn))\n+\t  /* !!! FIXME: Implement real scan here.  */\n+\t  sched_branch_type[INSN_UID (insn)] = TYPE_BCC;\n+      }\n+  }\n+\n+  if (reload_completed && sched_verbose >= 8)\n+    /* Dump statistics.  */\n+    {\n+      m68k_sched_dump (sched_dump_split_class, \"m68k_sched_split\",\n+\t\t       sched_dump);\n+\n+      sched_dump_dfa_guess_unit_code = get_cpu_unit_code (\"cf_v2_guess\");\n+      sched_dump_dfa_state = alloca (state_size ());\n+\n+      m68k_sched_dump (sched_dump_dfa_class, \"m68k_sched_dfa\",\n+\t\t       sched_dump);\n+\n+      sched_dump_dfa_state = NULL;\n+      sched_dump_dfa_guess_unit_code = 0;\n+    }\n+\n+  /* Setup target cpu.  */\n+  switch (m68k_sched_cpu)\n+    {\n+    case CPU_CF_V2:\n+      sched_ib_size = 6;\n+      sched_mem_unit_code = get_cpu_unit_code (\"cf_v2_mem\");\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  sched_adjust_cost_state = xmalloc (state_size ());\n+  state_reset (sched_adjust_cost_state);\n+\n+  start_sequence ();\n+  emit_insn (gen_ib ());\n+  sched_ib_insn = get_insns ();\n+  end_sequence ();\n+}\n+\n+/* Scheduling pass is now finished.  Free/reset static variables.  */\n+static void\n+m68k_sched_md_finish_global (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t\t     int verbose ATTRIBUTE_UNUSED)\n+{\n+  sched_ib_insn = NULL;\n+\n+  free (sched_adjust_cost_state);\n+  sched_adjust_cost_state = NULL;\n+\n+  sched_mem_unit_code = 0;\n+  sched_ib_size = 0;\n+\n+  free (sched_branch_type);\n+  sched_branch_type = NULL;\n+}\n+\n+/* Implementation of targetm.sched.md_init () hook.\n+   It is invoked each time scheduler starts on the new block (basic block or\n+   extended basic block).  */\n+static void\n+m68k_sched_md_init (FILE *sched_dump ATTRIBUTE_UNUSED,\n+\t\t    int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t    int n_insns ATTRIBUTE_UNUSED)\n+{\n+  /* haifa-sched.c: schedule_block () calls advance_cycle () just before\n+     the first cycle.  Workaround that.  */\n+  sched_ib_filled = -2;\n+}\n+\n+/* Implementation of targetm.sched.dfa_pre_advance_cycle () hook.\n+   It is invoked just before current cycle finishes and is used here\n+   to track if instruction buffer got its two words this cycle.  */\n+static void\n+m68k_sched_dfa_pre_advance_cycle (void)\n+{\n+  if (!cpu_unit_reservation_p (curr_state, sched_mem_unit_code))\n+    {\n+      sched_ib_filled += 2;\n+\n+      if (sched_ib_filled > sched_ib_size)\n+\tsched_ib_filled = sched_ib_size;\n+    }\n+}\n+\n+/* Implementation of targetm.sched.dfa_post_advance_cycle () hook.\n+   It is invoked just after new cycle begins and is used here\n+   to setup number of filled words in the instruction buffer so that\n+   instructions which won't have all their words prefetched would be\n+   stalled for a cycle.  */\n+static void\n+m68k_sched_dfa_post_advance_cycle (void)\n+{\n+  int i;\n+  int n;\n+\n+  /* Setup number of prefetched instruction words in the instruction\n+     buffer.  */\n+  for (i = sched_ib_filled, n = sched_ib_size; i < n; ++i)\n+    {\n+      if (state_transition (curr_state, sched_ib_insn) >= 0)\n+\tgcc_unreachable ();\n+    }\n+}"}, {"sha": "d8e1d3aa82941badfd4b864b99094e84ee922e08", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -1148,3 +1148,4 @@ extern M68K_CONST_METHOD m68k_const_method (HOST_WIDE_INT);\n \n extern void m68k_emit_move_double (rtx [2]);\n \n+#define CPU_UNITS_QUERY 1"}, {"sha": "c3f3138bf5ee3bb4e9064b3e4898207544d207fc", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c963204c1d408b202e17dd58ee56c5b8e27d30/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=b8c963204c1d408b202e17dd58ee56c5b8e27d30", "patch": "@@ -7729,3 +7729,5 @@\n   \"\"\n   \"#\"\n   [(set_attr \"type\" \"ib\")])\n+\n+(include \"cf.md\")"}]}