{"sha": "6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYwNGU2ZjM4ZDk5ZTJlMzhmOTk3ZDNkZGI1NmE4ZmVmMDY4MThiMg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-05T21:31:30Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-05T21:31:30Z"}, "message": "re PR preprocessor/3824 (With -traditional, CPP 0xffffffff > 0 but C 0xffffffff < 0)\n\n\tPR preprocessor/3824\n\t* line-map.c: Update comments.\n\t* line-map.h: Update comments.\n\t* tradcif.y: Don't consider large numbers unsigned.\n\t* gcc.dg/cpp/tr-sign.c: New testcase.\n\nFrom-SVN: r44651", "tree": {"sha": "ba4516faab4daa3b5f2b20d3f9b83a34c0baede5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba4516faab4daa3b5f2b20d3f9b83a34c0baede5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/comments", "author": null, "committer": null, "parents": [{"sha": "67821e3a9e007c34a85bbc3b934031b57eafc903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67821e3a9e007c34a85bbc3b934031b57eafc903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67821e3a9e007c34a85bbc3b934031b57eafc903"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "4cdd33c822f1dc34d595ab70c2fbd9d556edc0e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -1,3 +1,10 @@\n+2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\tPR preprocessor/3824\n+\t* line-map.c: Update comments.\n+\t* line-map.h: Update comments.\n+\t* tradcif.y: Don't consider large numbers unsigned.\n+\n 2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \tPR preprocessor/3081"}, {"sha": "27bcf2f94cdd0c34bb966d209e80aa003962d2e4", "filename": "gcc/line-map.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -93,7 +93,10 @@ add_line_map (set, reason, from_line, to_file, to_line)\n   return map;\n }\n \n-/* Translate a logical line number into a (source file, line) pair.  */\n+/* Given a logical line, returns the map from which the corresponding\n+   (source file, line) pair can be deduced.  Since the set is built\n+   chronologically, the logical lines are monotonic increasing, and so\n+   the list is sorted and we can use a binary search.  */\n \n struct line_map *\n lookup_line (set, line)"}, {"sha": "bbc6caacd5a813a1d1e5aaff1ac498e345fb0a40", "filename": "gcc/line-map.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -44,7 +44,11 @@ struct line_maps\n   unsigned int used;\n };\n \n-/* Reason for adding a line change with add_line_map ().  */\n+/* Reason for adding a line change with add_line_map ().  LC_ENTER is\n+   when including a new file, e.g. a #include directive in C.\n+   LC_LEAVE is when reaching a file's end.  LC_RENAME is when a file\n+   name or line number changes for neither of the above reasons\n+   (e.g. a #line directive in C).  */\n enum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n \n /* Initialize a line map set.  */\n@@ -56,7 +60,7 @@ extern void free_line_maps\n   PARAMS ((struct line_maps *));\n \n /* Add a mapping of logical source line to physical source file and\n-   line number.  Ther text pointed to by TO_FILE must have a lifetime\n+   line number.  The text pointed to by TO_FILE must have a lifetime\n    at least as long as the final call to lookup_line ().\n \n    FROM_LINE should be monotonic increasing across calls to this\n@@ -80,7 +84,8 @@ extern struct line_map *lookup_line\n /* Non-zero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n \n-/* The current line map.  */\n+/* The current line map.  Saves a call to lookup_line if the caller is\n+   sure he is in the scope of the current map.  */\n #define CURRENT_LINE_MAP(MAPS) ((MAPS)->maps + (MAPS)->used - 1)\n \n #endif /* !GCC_LINE_MAP_H  */"}, {"sha": "9e3c8c89b167977cf926afac02470f1b9306d758", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -1,3 +1,7 @@\n+2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/tr-sign.c: New testcase.\n+\n 2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* gcc.dg/cpp/19951025-1.c: Revert."}, {"sha": "e48e8ccadd86e25024920c442921d10819774aa6", "filename": "gcc/testsuite/gcc.dg/cpp/tr-sign.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftr-sign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftr-sign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftr-sign.c?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -0,0 +1,18 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess { target i?86-*-* } } */\n+\n+/* { dg-options \"-traditional\" } */\n+\n+/* Tests that traditional numbers are signed, unless otherwise\n+   specified.  This test assumes a 32 bit target.\n+\n+   Neil Booth, 5 Aug 2001.  Inspired by PR 3824.  */\n+\n+#if 0xffffffff >= 0\n+# error\t0xffffffff\t/* { dg-bogus \"0xffffffff\" \"0xffffffff positive\" } */\n+#endif\n+\n+#if 0xffffffffU <= 0\n+# error\t0xffffffffU\t/* { dg-bogus \"0xffffffffU\" \"0xffffffffU negative\" } */\n+#endif"}, {"sha": "771f9d2e25efa5f59b416cb887ddeb953f664d73", "filename": "gcc/tradcif.y", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftradcif.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6604e6f38d99e2e38f997d3ddb56a8fef06818b2/gcc%2Ftradcif.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.y?ref=6604e6f38d99e2e38f997d3ddb56a8fef06818b2", "patch": "@@ -231,6 +231,8 @@ parse_number (olen)\n       return ERROR;\n     }\n \n+  /* Traditionally, all numbers are signed.  However, we make it\n+     unsigned if requested with a suffix.  */\n   yylval.integer.unsignedp = 0;\n \n   if (len >= 3 && (!strncmp (p, \"0x\", 2) || !strncmp (p, \"0X\", 2))) {\n@@ -277,10 +279,6 @@ parse_number (olen)\n     return ERROR;\n   }\n \n-  /* If too big to be signed, consider it unsigned.  */\n-  if (n < 0)\n-    yylval.integer.unsignedp = 1;\n-\n   lexptr = p;\n   yylval.integer.value = n;\n   return INT;"}]}