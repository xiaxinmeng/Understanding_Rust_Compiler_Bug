{"sha": "932f48ac85f5111b1f3666b2c15718db2d10bcbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyZjQ4YWM4NWY1MTExYjFmMzY2NmIyYzE1NzE4ZGIyZDEwYmNiZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-25T16:55:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-25T16:55:43Z"}, "message": "Reimplement unqualified namespace lookup.\n\n\tgcc/cp/\n\tReimplement unqualified namespace lookup.\n\t* name-lookup.c (name_lookup::using_pair)\n\tname_lookup::using_queue): New typedefs.\n\t(name_lookup::queue_namespace, name_lookup::do_queue_usings,\n\tname_lookup::queue_usings): New.\n\t(name_lookup::search_unqualified): New.\n\t(merge_functions, same_entity_p, ambiguous_decl)\n\tunqualified_namespace_lookup_1, unqualified_namespace_lookup,\n\tlookup_using_namespace): Delete.\n\t(lookup_name_real_1): Adjust.\n\n\tgcc/testsuite/\n\t* g++.dg/lookup/using17.C: Adjust diagnostics.\n\nFrom-SVN: r248465", "tree": {"sha": "6c8b2293e19b89bf33b24a7836cdfa0180986c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c8b2293e19b89bf33b24a7836cdfa0180986c36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/932f48ac85f5111b1f3666b2c15718db2d10bcbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932f48ac85f5111b1f3666b2c15718db2d10bcbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/932f48ac85f5111b1f3666b2c15718db2d10bcbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/932f48ac85f5111b1f3666b2c15718db2d10bcbf/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a10f9a2eaaeb9acb9ffa89fa12e248745f7fce86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a10f9a2eaaeb9acb9ffa89fa12e248745f7fce86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a10f9a2eaaeb9acb9ffa89fa12e248745f7fce86"}], "stats": {"total": 377, "additions": 135, "deletions": 242}, "files": [{"sha": "f2df2b62611b4c511e2aca7e9a75245d5bdab782", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=932f48ac85f5111b1f3666b2c15718db2d10bcbf", "patch": "@@ -1,5 +1,16 @@\n 2017-05-25  Nathan Sidwell  <nathan@acm.org>\n \n+\tReimplement unqualified namespace lookup.\n+\t* name-lookup.c (name_lookup::using_pair,\n+\tname_lookup::using_queue): New typedefs.\n+\t(name_lookup::queue_namespace, name_lookup::do_queue_usings,\n+\tname_lookup::queue_usings): New.\n+\t(name_lookup::search_unqualified): New.\n+\t(merge_functions, same_entity_p, ambiguous_decl,\n+\tunqualified_namespace_lookup_1, unqualified_namespace_lookup,\n+\tlookup_using_namespace): Delete.\n+\t(lookup_name_real_1): Adjust.\n+\n \tReimplement qualified namespace lookup.\n \t* name-lookup.c (name_lookup::flags): New member.  Adjust ctor.\n \t(name_lookup::ambiguous, name_lookup::add_value,"}, {"sha": "d2c413ba1f8b05120bf8316aa52f0b8f38a2616f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 118, "deletions": 240, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=932f48ac85f5111b1f3666b2c15718db2d10bcbf", "patch": "@@ -150,6 +150,10 @@ find_local_binding (cp_binding_level *b, tree name)\n \n struct name_lookup\n {\n+public:\n+  typedef std::pair<tree, tree> using_pair;\n+  typedef vec<using_pair, va_heap, vl_embed> using_queue;\n+\n public:\n   tree name;\t/* The identifier being looked for.  */\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n@@ -226,6 +230,16 @@ struct name_lookup\n      qualified lookup rules.  */\n   bool search_usings (tree scope);\n \n+private:\n+  using_queue *queue_namespace (using_queue *queue, int depth, tree scope);\n+  using_queue *do_queue_usings (using_queue *queue, int depth, tree usings);\n+  using_queue *queue_usings (using_queue *queue, int depth, tree usings)\n+  {\n+    if (usings)\n+      queue = do_queue_usings (queue, depth, usings);\n+    return queue;\n+  }\n+\n private:\n   void add_fns (tree);\n \n@@ -242,6 +256,9 @@ struct name_lookup\n   /* Search namespace + inlines + maybe usings as qualified lookup.  */\n   bool search_qualified (tree scope, bool usings = true);\n \n+  /* Search namespace + inlines + usings as unqualified lookup.  */\n+  bool search_unqualified (tree scope, cp_binding_level *);\n+\n   /* ADL lookup of ARGS.  */\n   tree search_adl (tree fns, vec<tree, va_gc> *args);\n };\n@@ -557,6 +574,101 @@ name_lookup::search_qualified (tree scope, bool usings)\n   return found;\n }\n \n+/* Add SCOPE to the unqualified search queue, recursively add its\n+   inlines and those via using directives.  */\n+\n+name_lookup::using_queue *\n+name_lookup::queue_namespace (using_queue *queue, int depth, tree scope)\n+{\n+  if (see_and_mark (scope))\n+    return queue;\n+\n+  /* Record it.  */\n+  tree common = scope;\n+  while (SCOPE_DEPTH (common) > depth)\n+    common = CP_DECL_CONTEXT (common);\n+  vec_safe_push (queue, using_pair (common, scope));\n+\n+  /* Queue its inline children.  */\n+  for (tree inner = NAMESPACE_LEVEL (scope)->namespaces;\n+       inner; inner = TREE_CHAIN (inner))\n+    if (DECL_NAMESPACE_INLINE_P (inner))\n+      queue = queue_namespace (queue, depth, inner);\n+\n+  /* Queue its using targets.  */\n+  queue = queue_usings (queue, depth, DECL_NAMESPACE_USING (scope));\n+\n+  return queue;\n+}\n+\n+/* Add the namespaces in USINGS to the unqualified search queue.  */\n+\n+name_lookup::using_queue *\n+name_lookup::do_queue_usings (using_queue *queue, int depth, tree usings)\n+{\n+  for (; usings; usings = TREE_CHAIN (usings))\n+    if (!TREE_INDIRECT_USING (usings))\n+      queue = queue_namespace (queue, depth, TREE_PURPOSE (usings));\n+\n+  return queue;\n+}\n+\n+/* Unqualified namespace lookup in SCOPE.\n+   1) add scope+inlins to worklist.\n+   2) recursively add target of every using directive\n+   3) for each worklist item where SCOPE is common ancestor, search it\n+   4) if nothing find, scope=parent, goto 1.  */\n+\n+bool\n+name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n+{\n+  /* Make static to avoid continual reallocation.  We're not\n+     recursive.  */\n+  static using_queue *queue = NULL;\n+  bool found = false;\n+  int length = vec_safe_length (queue);\n+\n+  /* Queue local using-directives.  */\n+  for (; level->kind != sk_namespace; level = level->level_chain)\n+    queue = queue_usings (queue, SCOPE_DEPTH (scope), level->using_directives);\n+\n+  for (; !found; scope = CP_DECL_CONTEXT (scope))\n+    {\n+      gcc_assert (!DECL_NAMESPACE_ALIAS (scope));\n+      int depth = SCOPE_DEPTH (scope);\n+\n+      /* Queue namespaces reachable from SCOPE. */\n+      queue = queue_namespace (queue, depth, scope);\n+\n+      /* Search every queued namespace where SCOPE is the common\n+\t ancestor.  Adjust the others.  */\n+      unsigned ix = length;\n+      do\n+\t{\n+\t  using_pair &pair = (*queue)[ix];\n+\t  while (pair.first == scope)\n+\t    {\n+\t      found |= search_namespace_only (pair.second);\n+\t      pair = queue->pop ();\n+\t      if (ix == queue->length ())\n+\t\tgoto done;\n+\t    }\n+\t  /* The depth is the same as SCOPE, find the parent scope.  */\n+\t  if (SCOPE_DEPTH (pair.first) == depth)\n+\t    pair.first = CP_DECL_CONTEXT (pair.first);\n+\t  ix++;\n+\t}\n+      while (ix < queue->length ());\n+    done:;\n+      if (scope == global_namespace)\n+\tbreak;\n+    }\n+\n+  vec_safe_truncate (queue, length);\n+\n+  return found;\n+}\n+\n /* FNS is a value binding.  If it is a (set of overloaded) functions,\n    add them into the current value.  */\n \n@@ -901,8 +1013,6 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n   return fns;\n }\n \n-static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n-\t\t\t\t    tree, int);\n static bool qualified_namespace_lookup (tree, name_lookup *);\n static void consider_binding_level (tree name,\n \t\t\t\t    best_match <tree, const char *> &bm,\n@@ -4549,153 +4659,6 @@ finish_local_using_decl (tree decl, tree scope, tree name)\n     cp_emit_debug_info_for_using (orig_decl, current_scope ());\n }\n \n-/* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n-   duplicates.  The first list becomes the tail of the result.\n-\n-   The algorithm is O(n^2).  We could get this down to O(n log n) by\n-   doing a sort on the addresses of the functions, if that becomes\n-   necessary.  */\n-\n-static tree\n-merge_functions (tree s1, tree s2)\n-{\n-  for (; s2; s2 = OVL_NEXT (s2))\n-    {\n-      tree fn2 = OVL_CURRENT (s2);\n-      tree fns1;\n-\n-      for (fns1 = s1; fns1; fns1 = OVL_NEXT (fns1))\n-\t{\n-\t  tree fn1 = OVL_CURRENT (fns1);\n-\n-\t  /* If the function from S2 is already in S1, there is no\n-\t     need to add it again.  For `extern \"C\"' functions, we\n-\t     might have two FUNCTION_DECLs for the same function, in\n-\t     different namespaces, but let's leave them in case\n-\t     they have different default arguments.  */\n-\t  if (fn1 == fn2)\n-\t    break;\n-\t}\n-\n-      /* If we exhausted all of the functions in S1, FN2 is new.  */\n-      if (!fns1)\n-\ts1 = lookup_add (fn2, s1);\n-    }\n-  return s1;\n-}\n-\n-/* Returns TRUE iff OLD and NEW are the same entity.\n-\n-   3 [basic]/3: An entity is a value, object, reference, function,\n-   enumerator, type, class member, template, template specialization,\n-   namespace, parameter pack, or this.\n-\n-   7.3.4 [namespace.udir]/4: If name lookup finds a declaration for a name\n-   in two different namespaces, and the declarations do not declare the\n-   same entity and do not declare functions, the use of the name is\n-   ill-formed.  */\n-\n-static bool\n-same_entity_p (tree one, tree two)\n-{\n-  if (one == two)\n-    return true;\n-  if (!one || !two)\n-    return false;\n-  if (TREE_CODE (one) == TYPE_DECL\n-      && TREE_CODE (two) == TYPE_DECL\n-      && same_type_p (TREE_TYPE (one), TREE_TYPE (two)))\n-    return true;\n-  return false;\n-}\n-\n-/* This should return an error not all definitions define functions.\n-   It is not an error if we find two functions with exactly the\n-   same signature, only if these are selected in overload resolution.\n-   old is the current set of bindings, new_binding the freshly-found binding.\n-   XXX Do we want to give *all* candidates in case of ambiguity?\n-   XXX In what way should I treat extern declarations?\n-   XXX I don't want to repeat the entire duplicate_decls here */\n-\n-static void\n-ambiguous_decl (struct scope_binding *old, cxx_binding *new_binding, int flags)\n-{\n-  tree val, type;\n-  gcc_assert (old != NULL);\n-\n-  /* Copy the type.  */\n-  type = new_binding->type;\n-  if (LOOKUP_NAMESPACES_ONLY (flags)\n-      || (type && !(flags & LOOKUP_HIDDEN) && DECL_HIDDEN_P (type)))\n-    type = NULL_TREE;\n-\n-  /* Copy the value.  */\n-  val = new_binding->value;\n-  if (val)\n-    {\n-      if (!(flags & LOOKUP_HIDDEN))\n-\tval = ovl_skip_hidden (val);\n-      if (val)\n-\tswitch (TREE_CODE (val))\n-\t  {\n-\t  case TEMPLATE_DECL:\n-\t    /* If we expect types or namespaces, and not templates,\n-\t       or this is not a template class.  */\n-\t    if ((LOOKUP_QUALIFIERS_ONLY (flags)\n-\t\t && !DECL_TYPE_TEMPLATE_P (val)))\n-\t      val = NULL_TREE;\n-\t    break;\n-\t  case TYPE_DECL:\n-\t    if (LOOKUP_NAMESPACES_ONLY (flags)\n-\t\t|| (type && (flags & LOOKUP_PREFER_TYPES)))\n-\t      val = NULL_TREE;\n-\t    break;\n-\t  case NAMESPACE_DECL:\n-\t    if (LOOKUP_TYPES_ONLY (flags))\n-\t      val = NULL_TREE;\n-\t    break;\n-\t  case FUNCTION_DECL:\n-\t    /* Ignore built-in functions that are still anticipated.  */\n-\t    if (LOOKUP_QUALIFIERS_ONLY (flags))\n-\t      val = NULL_TREE;\n-\t    break;\n-\t  default:\n-\t    if (LOOKUP_QUALIFIERS_ONLY (flags))\n-\t      val = NULL_TREE;\n-\t  }\n-    }\n-\n-  /* If val is hidden, shift down any class or enumeration name.  */\n-  if (!val)\n-    {\n-      val = type;\n-      type = NULL_TREE;\n-    }\n-\n-  if (!old->value)\n-    old->value = val;\n-  else if (val && !same_entity_p (val, old->value))\n-    {\n-      if (is_overloaded_fn (old->value) && is_overloaded_fn (val))\n-\told->value = merge_functions (old->value, val);\n-      else\n-\t{\n-\t  old->value = tree_cons (NULL_TREE, old->value,\n-\t\t\t\t  build_tree_list (NULL_TREE, val));\n-\t  TREE_TYPE (old->value) = error_mark_node;\n-\t}\n-    }\n-\n-  if (!old->type)\n-    old->type = type;\n-  else if (type && old->type != type)\n-    {\n-      old->type = tree_cons (NULL_TREE, old->type,\n-\t\t\t     build_tree_list (NULL_TREE, type));\n-      TREE_TYPE (old->type) = error_mark_node;\n-    }\n-}\n-\n /* Return the declarations that are members of the namespace NS.  */\n \n tree\n@@ -4961,68 +4924,6 @@ suggest_alternative_in_explicit_scope (location_t location, tree name,\n   return false;\n }\n \n-/* Unscoped lookup of a global: iterate over current namespaces,\n-   considering using-directives.  */\n-\n-static tree\n-unqualified_namespace_lookup_1 (tree name, int flags)\n-{\n-  tree initial = current_decl_namespace ();\n-  tree scope = initial;\n-  tree siter;\n-  cp_binding_level *level;\n-  tree val = NULL_TREE;\n-\n-  for (; !val; scope = CP_DECL_CONTEXT (scope))\n-    {\n-      struct scope_binding binding = EMPTY_SCOPE_BINDING;\n-      cxx_binding *b = find_namespace_binding (scope, name);\n-\n-      if (b)\n-\tambiguous_decl (&binding, b, flags);\n-\n-      /* Add all _DECLs seen through local using-directives.  */\n-      for (level = current_binding_level;\n-\t   level->kind != sk_namespace;\n-\t   level = level->level_chain)\n-\tif (!lookup_using_namespace (name, &binding, level->using_directives,\n-\t\t\t\t     scope, flags))\n-\t  /* Give up because of error.  */\n-\t  return error_mark_node;\n-\n-      /* Add all _DECLs seen through global using-directives.  */\n-      /* XXX local and global using lists should work equally.  */\n-      siter = initial;\n-      while (1)\n-\t{\n-\t  if (!lookup_using_namespace (name, &binding,\n-\t\t\t\t       DECL_NAMESPACE_USING (siter),\n-\t\t\t\t       scope, flags))\n-\t    /* Give up because of error.  */\n-\t    return error_mark_node;\n-\t  if (siter == scope) break;\n-\t  siter = CP_DECL_CONTEXT (siter);\n-\t}\n-\n-      val = binding.value;\n-      if (scope == global_namespace)\n-\tbreak;\n-    }\n-  return val;\n-}\n-\n-/* Wrapper for unqualified_namespace_lookup_1.  */\n-\n-static tree\n-unqualified_namespace_lookup (tree name, int flags)\n-{\n-  tree ret;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = unqualified_namespace_lookup_1 (name, flags);\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n-}\n-\n /* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n    or a class TYPE).\n \n@@ -5060,34 +4961,6 @@ lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n   return t;\n }\n \n-/* Subroutine of unqualified_namespace_lookup:\n-   Add the bindings of NAME in used namespaces to VAL.\n-   We are currently looking for names in namespace SCOPE, so we\n-   look through USINGS for using-directives of namespaces\n-   which have SCOPE as a common ancestor with the current scope.\n-   Returns false on errors.  */\n-\n-static bool\n-lookup_using_namespace (tree name, struct scope_binding *val,\n-\t\t\ttree usings, tree scope, int flags)\n-{\n-  tree iter;\n-  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  /* Iterate over all used namespaces in current, searching for using\n-     directives of scope.  */\n-  for (iter = usings; iter; iter = TREE_CHAIN (iter))\n-    if (TREE_VALUE (iter) == scope)\n-      {\n-\ttree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n-\tcxx_binding *val1 = find_namespace_binding (used, name);\n-\t/* Resolve ambiguities.  */\n-\tif (val1)\n-\t  ambiguous_decl (val, val1, flags);\n-      }\n-  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return val->value != error_mark_node;\n-}\n-\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the cxx_binding *RESULT,\n@@ -5479,7 +5352,12 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n \n   /* Now lookup in namespace scopes.  */\n   if (!val)\n-    val = unqualified_namespace_lookup (name, flags);\n+    {\n+      name_lookup lookup (name, flags);\n+      if (lookup.search_unqualified\n+\t  (current_decl_namespace (), current_binding_level))\n+\tval = lookup.value;\n+    }\n \n   /* If we have a single function from a using decl, pull it out.  */\n   if (val && TREE_CODE (val) == OVERLOAD && !really_overloaded_fn (val))"}, {"sha": "33b1cc47f8c778ba96099d5d7c9cf1a2f1249ea6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=932f48ac85f5111b1f3666b2c15718db2d10bcbf", "patch": "@@ -1,3 +1,7 @@\n+2017-05-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/lookup/using17.C: Adjust diagnostics.\n+\n 2017-05-25  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc.dg/overflow-warn-9.c: Adjust expected warnings to avoid false"}, {"sha": "55875fe9af978894ba2f9c40b9e00c61351b1575", "filename": "gcc/testsuite/g++.dg/lookup/using17.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/932f48ac85f5111b1f3666b2c15718db2d10bcbf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing17.C?ref=932f48ac85f5111b1f3666b2c15718db2d10bcbf", "patch": "@@ -3,11 +3,11 @@\n // { dg-do compile }\n \n namespace M {\n-  struct S {}; // { dg-message \".struct M::S.\" \"candidate 2\" }\n+  struct S {}; // { dg-message \"candidates are: .struct M::S.\" \"candidate 1\" }\n }\n \n int S;\n-struct S {}; // { dg-message \"candidates are: .struct S.\" \"candidate 1\" }\n+struct S {}; // { dg-message \".struct S.\" \"candidate 2\" }\n \n using namespace M;\n "}]}