{"sha": "90e8523311e9616c99a9fc9cfa2454f753eb9f13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBlODUyMzMxMWU5NjE2Yzk5YTlmYzljZmEyNDU0Zjc1M2ViOWYxMw==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2012-03-15T08:48:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-15T08:48:36Z"}, "message": "aspects.adb, [...] (Aspect_Id): New GNAT aspect Aspect_Contract_Case.\n\n2012-03-15  Yannick Moy  <moy@adacore.com>\n\n\t* aspects.adb, aspects.ads (Aspect_Id): New GNAT aspect\n\tAspect_Contract_Case.\n\t* gnat_rm.texi Document the new pragma/aspect\n\tContract_Case. Correct the documentation of the existing\n\tpragma/aspect Test_Case with the new semantics.\n\t* sem_attr.adb (Analyze_Attribute): Allow use of 'Result in the\n\tEnsures component of a Contract_Case pragma.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Check new aspect\n\tand translate it into a pragma.\n\t(Check_Aspect_At_Freeze_Point): Take into account the new aspect.\n\t* sem_ch3.adb, sinfo.adb, sinfo.ads Renaming of TC (for test case)\n\tinto CTC (for contract and test case).\n\t* sem_ch6.adb (Process_PPCs): Generate Check pragmas from\n\tContract_Case pragmas, similarly to what is done already for\n\tpostconditions.\n\t* sem_prag.adb, sem_prag.ads (Check_Contract_Or_Test_Case):\n\tRenaming of Check_Test_Case.\n\t(Analyze_Pragma, Sig_Flags): Take into account the new pragma.\n\t* sem_util.adb, sem_util.ads Renaming to take into account the\n\tnew pragma, so that functions which applied only to Test_Case\n\tnow apply to both Test_Case and Contract_Case.\n\t* par-prag.adb, sem_warn.adb, snames.ads-tmpl Take into account\n\tthe new pragma.\n\nFrom-SVN: r185415", "tree": {"sha": "0821136e1cc465c7f9676ef3b181713492d1cf50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0821136e1cc465c7f9676ef3b181713492d1cf50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90e8523311e9616c99a9fc9cfa2454f753eb9f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e8523311e9616c99a9fc9cfa2454f753eb9f13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e8523311e9616c99a9fc9cfa2454f753eb9f13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e8523311e9616c99a9fc9cfa2454f753eb9f13/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51a1aacf86538c0966fb3c34f0bf26c24515eb8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a1aacf86538c0966fb3c34f0bf26c24515eb8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a1aacf86538c0966fb3c34f0bf26c24515eb8f"}], "stats": {"total": 692, "additions": 496, "deletions": 196}, "files": [{"sha": "f5b141e18644f16607317352628eb5e3d7932ff4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -1,3 +1,29 @@\n+2012-03-15  Yannick Moy  <moy@adacore.com>\n+\n+\t* aspects.adb, aspects.ads (Aspect_Id): New GNAT aspect\n+\tAspect_Contract_Case.\n+\t* gnat_rm.texi Document the new pragma/aspect\n+\tContract_Case. Correct the documentation of the existing\n+\tpragma/aspect Test_Case with the new semantics.\n+\t* sem_attr.adb (Analyze_Attribute): Allow use of 'Result in the\n+\tEnsures component of a Contract_Case pragma.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Check new aspect\n+\tand translate it into a pragma.\n+\t(Check_Aspect_At_Freeze_Point): Take into account the new aspect.\n+\t* sem_ch3.adb, sinfo.adb, sinfo.ads Renaming of TC (for test case)\n+\tinto CTC (for contract and test case).\n+\t* sem_ch6.adb (Process_PPCs): Generate Check pragmas from\n+\tContract_Case pragmas, similarly to what is done already for\n+\tpostconditions.\n+\t* sem_prag.adb, sem_prag.ads (Check_Contract_Or_Test_Case):\n+\tRenaming of Check_Test_Case.\n+\t(Analyze_Pragma, Sig_Flags): Take into account the new pragma.\n+\t* sem_util.adb, sem_util.ads Renaming to take into account the\n+\tnew pragma, so that functions which applied only to Test_Case\n+\tnow apply to both Test_Case and Contract_Case.\n+\t* par-prag.adb, sem_warn.adb, snames.ads-tmpl Take into account\n+\tthe new pragma.\n+\n 2012-03-15  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch6.ads: Minor comment updates."}, {"sha": "b155a08714f32459ec04254e2b79ace8e4d4ec2a", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -249,6 +249,7 @@ package body Aspects is\n     Aspect_Bit_Order                    => Aspect_Bit_Order,\n     Aspect_Component_Size               => Aspect_Component_Size,\n     Aspect_Constant_Indexing            => Aspect_Constant_Indexing,\n+    Aspect_Contract_Case                => Aspect_Contract_Case,\n     Aspect_CPU                          => Aspect_CPU,\n     Aspect_Default_Component_Value      => Aspect_Default_Component_Value,\n     Aspect_Default_Iterator             => Aspect_Default_Iterator,"}, {"sha": "781651feeb97782a34509bd717689af42a53b41e", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -50,6 +50,7 @@ package Aspects is\n       Aspect_Bit_Order,\n       Aspect_Component_Size,\n       Aspect_Constant_Indexing,\n+      Aspect_Contract_Case,                 -- GNAT\n       Aspect_CPU,\n       Aspect_Default_Component_Value,\n       Aspect_Default_Iterator,\n@@ -176,6 +177,7 @@ package Aspects is\n                             (Aspect_Ada_2005                 => True,\n                              Aspect_Ada_2012                 => True,\n                              Aspect_Compiler_Unit            => True,\n+                             Aspect_Contract_Case            => True,\n                              Aspect_Dimension                => True,\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n@@ -206,8 +208,9 @@ package Aspects is\n    --  the same aspect attached to the same declaration are allowed.\n \n    No_Duplicates_Allowed : constant array (Aspect_Id) of Boolean :=\n-                             (Aspect_Test_Case => False,\n-                              others           => True);\n+                             (Aspect_Contract_Case => False,\n+                              Aspect_Test_Case     => False,\n+                              others               => True);\n \n    --  The following array indicates type aspects that are inherited and apply\n    --  to the class-wide type as well.\n@@ -259,6 +262,7 @@ package Aspects is\n                         Aspect_Bit_Order               => Expression,\n                         Aspect_Component_Size          => Expression,\n                         Aspect_Constant_Indexing       => Name,\n+                        Aspect_Contract_Case           => Expression,\n                         Aspect_CPU                     => Expression,\n                         Aspect_Default_Component_Value => Expression,\n                         Aspect_Default_Iterator        => Name,\n@@ -325,6 +329,7 @@ package Aspects is\n      Aspect_Compiler_Unit                => Name_Compiler_Unit,\n      Aspect_Component_Size               => Name_Component_Size,\n      Aspect_Constant_Indexing            => Name_Constant_Indexing,\n+     Aspect_Contract_Case                => Name_Contract_Case,\n      Aspect_CPU                          => Name_CPU,\n      Aspect_Default_Iterator             => Name_Default_Iterator,\n      Aspect_Default_Value                => Name_Default_Value,"}, {"sha": "e0ab56f4c2c26080d5b889d8e77526913b90988b", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 118, "deletions": 10, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -120,6 +120,7 @@ Implementation Defined Pragmas\n * Pragma Complete_Representation::\n * Pragma Complex_Representation::\n * Pragma Component_Alignment::\n+* Pragma Contract_Case::\n * Pragma Convention_Identifier::\n * Pragma CPP_Class::\n * Pragma CPP_Constructor::\n@@ -855,6 +856,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Complete_Representation::\n * Pragma Complex_Representation::\n * Pragma Component_Alignment::\n+* Pragma Contract_Case::\n * Pragma Convention_Identifier::\n * Pragma CPP_Class::\n * Pragma CPP_Constructor::\n@@ -1704,6 +1706,108 @@ If the alignment for a record or array type is not specified (using\n pragma @code{Pack}, pragma @code{Component_Alignment}, or a record rep\n clause), the GNAT uses the default alignment as described previously.\n \n+@node Pragma Contract_Case\n+@unnumberedsec Pragma Contract_Case\n+@cindex Contract cases\n+@findex Contract_Case\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Contract_Case (\n+   [Name     =>] static_string_Expression\n+  ,[Mode     =>] (Nominal | Robustness)\n+ [, Requires =>  Boolean_Expression]\n+ [, Ensures  =>  Boolean_Expression]);\n+@end smallexample\n+\n+@noindent\n+The @code{Contract_Case} pragma allows defining fine-grain specifications\n+that can complement or replace the contract given by a precondition and a\n+postcondition. Additionally, the @code{Contract_Case} pragma can be used\n+by testing and formal verification tools. The compiler checks its validity and,\n+depending on the assertion policy at the point of declaration of the pragma,\n+it may insert a check in the executable. For code generation, the contract\n+case\n+\n+@smallexample @c ada\n+pragma Contract_Case (\n+   Name     => ...\n+   Mode     => ...\n+   Requires => R,\n+   Ensures  => E);\n+@end smallexample\n+\n+@noindent\n+is equivalent to\n+\n+@smallexample @c ada\n+pragma Postcondition (not R'Old or else E);\n+@end smallexample\n+\n+@noindent\n+which is also equivalent to (in Ada 2012)\n+\n+@smallexample @c ada\n+pragma Postcondition (if R'Old then E);\n+@end smallexample\n+\n+@noindent\n+expressing that, whenever condition @code{R} is satisfied on entry to the\n+subprogram, condition @code{E} should be fulfilled on exit to the subprogram.\n+\n+A precondition @code{P} and postcondition @code{Q} can also be\n+expressed as contract cases:\n+\n+@smallexample @c ada\n+pragma Contract_Case (\n+   Name     => \"Replace precondition\",\n+   Mode     => Nominal,\n+   Requires => not P,\n+   Ensures  => False);\n+pragma Contract_Case (\n+   Name     => \"Replace postcondition\",\n+   Mode     => Nominal,\n+   Requires => P,\n+   Ensures  => Q);\n+@end smallexample\n+\n+@code{Contract_Case} pragmas may only appear immediately following the\n+(separate) declaration of a subprogram in a package declaration, inside\n+a package spec unit. Only other pragmas may intervene (that is appear\n+between the subprogram declaration and a contract case).\n+\n+The compiler checks that boolean expressions given in @code{Requires} and\n+@code{Ensures} are valid, where the rules for @code{Requires} are the\n+same as the rule for an expression in @code{Precondition} and the rules\n+for @code{Ensures} are the same as the rule for an expression in\n+@code{Postcondition}. In particular, attributes @code{'Old} and\n+@code{'Result} can only be used within the @code{Ensures}\n+expression. The following is an example of use within a package spec:\n+\n+@smallexample @c ada\n+package Math_Functions is\n+   ...\n+   function Sqrt (Arg : Float) return Float;\n+   pragma Contract_Case (Name     => \"Small argument\",\n+                         Mode     => Nominal,\n+                         Requires => Arg < 100,\n+                         Ensures  => Sqrt'Result < 10);\n+   ...\n+end Math_Functions;\n+@end smallexample\n+\n+@noindent\n+The meaning of a contract case is that, whenever the associated subprogram is\n+executed in a context where @code{Requires} holds, then @code{Ensures}\n+should hold when the subprogram returns. Mode @code{Nominal} indicates\n+that the input context should also satisfy the precondition of the\n+subprogram, and the output context should also satisfy its\n+postcondition. More @code{Robustness} indicates that the precondition and\n+postcondition of the subprogram should be ignored for this contract case,\n+which is mostly useful when testing such a contract using a testing tool\n+that understands contract cases.\n+\n @node Pragma Convention_Identifier\n @unnumberedsec Pragma Convention_Identifier\n @findex Convention_Identifier\n@@ -5238,9 +5342,12 @@ pragma Test_Case (\n \n @noindent\n The @code{Test_Case} pragma allows defining fine-grain specifications\n-for use by testing and verification tools. The compiler checks its\n-validity but the presence of pragma @code{Test_Case} does not lead to\n-any modification of the code generated by the compiler.\n+for use by testing tools. Its syntax is similar to the syntax of the\n+@code{Contract_Case} pragma, which is used for both testing and\n+formal verification.\n+The compiler checks the validity of the @code{Test_Case} pragma, but its\n+presence does not lead to any modification of the code generated by the\n+compiler, contrary to the treatment of the @code{Contract_Case} pragma.\n \n @code{Test_Case} pragmas may only appear immediately following the\n (separate) declaration of a subprogram in a package declaration, inside\n@@ -5261,19 +5368,19 @@ package Math_Functions is\n    function Sqrt (Arg : Float) return Float;\n    pragma Test_Case (Name     => \"Test 1\",\n                      Mode     => Nominal,\n-                     Requires => Arg < 100,\n+                     Requires => Arg < 10000,\n                      Ensures  => Sqrt'Result < 10);\n    ...\n end Math_Functions;\n @end smallexample\n \n @noindent\n-The meaning of a test case is that, if the associated subprogram is\n-executed in a context where @code{Requires} holds, then @code{Ensures}\n-should hold when the subprogram returns. Mode @code{Nominal} indicates\n-that the input context should satisfy the precondition of the\n-subprogram, and the output context should then satisfy its\n-postcondition. More @code{Robustness} indicates that the pre- and\n+The meaning of a test case is that there is at least one context where\n+@code{Requires} holds such that, if the associated subprogram is executed in\n+that context, then @code{Ensures} holds when the subprogram returns.\n+Mode @code{Nominal} indicates that the input context should also satisfy the\n+precondition of the subprogram, and the output context should also satisfy its\n+postcondition. More @code{Robustness} indicates that the precondition and\n postcondition of the subprogram should be ignored for this test case.\n \n @node Pragma Thread_Local_Storage\n@@ -17375,6 +17482,7 @@ A complete description of the AIs may be found in\n @item @code{Atomic_Components} @tab\n @item @code{Bit_Order} @tab\n @item @code{Component_Size} @tab\n+@item @code{Contract_Case} @tab                 -- GNAT\n @item @code{Discard_Names} @tab\n @item @code{External_Tag} @tab\n @item @code{Favor_Top_Level} @tab               -- GNAT"}, {"sha": "5a1f469e078bd89fa49bbbf5eb86b4845bf28b74", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -1109,6 +1109,7 @@ begin\n            Pragma_Compile_Time_Error             |\n            Pragma_Compile_Time_Warning           |\n            Pragma_Compiler_Unit                  |\n+           Pragma_Contract_Case                  |\n            Pragma_Convention_Identifier          |\n            Pragma_CPP_Class                      |\n            Pragma_CPP_Constructor                |"}, {"sha": "c5ad305a4079634ae002bd94a8383e09150b5c63", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -4256,10 +4256,12 @@ package body Sem_Attr is\n                  (\"% attribute can only appear in postcondition of function\",\n                   P);\n \n-            elsif Get_Pragma_Id (Prag) = Pragma_Test_Case then\n+            elsif Get_Pragma_Id (Prag) = Pragma_Contract_Case\n+              or else Get_Pragma_Id (Prag) = Pragma_Test_Case\n+            then\n                declare\n                   Arg_Ens : constant Node_Id :=\n-                              Get_Ensures_From_Test_Case_Pragma (Prag);\n+                              Get_Ensures_From_Case_Pragma (Prag);\n                   Arg     : Node_Id;\n \n                begin\n@@ -4269,7 +4271,13 @@ package body Sem_Attr is\n                   end loop;\n \n                   if Arg /= Arg_Ens then\n-                     Error_Attr (\"% attribute misplaced inside Test_Case\", P);\n+                     if Get_Pragma_Id (Prag) = Pragma_Contract_Case then\n+                        Error_Attr\n+                          (\"% attribute misplaced inside contract case\", P);\n+                     else\n+                        Error_Attr\n+                          (\"% attribute misplaced inside test case\", P);\n+                     end if;\n                   end if;\n                end;\n "}, {"sha": "52f05453dd7f7eaad588fec142713e6ae7271987", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 75, "deletions": 65, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -1450,83 +1450,87 @@ package body Sem_Ch13 is\n                   Set_Is_Delayed_Aspect (Aspect);\n                   Delay_Required := True;\n \n-               when Aspect_Test_Case => declare\n-                  Args      : List_Id;\n-                  Comp_Expr : Node_Id;\n-                  Comp_Assn : Node_Id;\n-                  New_Expr  : Node_Id;\n-\n-               begin\n-                  Args := New_List;\n-\n-                  if Nkind (Parent (N)) = N_Compilation_Unit then\n-                     Error_Msg_N\n-                       (\"incorrect placement of aspect `Test_Case`\", E);\n-                     goto Continue;\n-                  end if;\n+               when Aspect_Contract_Case |\n+                    Aspect_Test_Case     =>\n+                  declare\n+                     Args      : List_Id;\n+                     Comp_Expr : Node_Id;\n+                     Comp_Assn : Node_Id;\n+                     New_Expr  : Node_Id;\n \n-                  if Nkind (Expr) /= N_Aggregate then\n-                     Error_Msg_NE\n-                       (\"wrong syntax for aspect `Test_Case` for &\", Id, E);\n-                     goto Continue;\n-                  end if;\n+                  begin\n+                     Args := New_List;\n \n-                  --  Make pragma expressions refer to the original aspect\n-                  --  expressions through the Original_Node link. This is used\n-                  --  in semantic analysis for ASIS mode, so that the original\n-                  --  expression also gets analyzed.\n-\n-                  Comp_Expr := First (Expressions (Expr));\n-                  while Present (Comp_Expr) loop\n-                     New_Expr := Relocate_Node (Comp_Expr);\n-                     Set_Original_Node (New_Expr, Comp_Expr);\n-                     Append\n-                       (Make_Pragma_Argument_Association (Sloc (Comp_Expr),\n-                          Expression => New_Expr),\n-                       Args);\n-                     Next (Comp_Expr);\n-                  end loop;\n+                     if Nkind (Parent (N)) = N_Compilation_Unit then\n+                        Error_Msg_Name_1 := Nam;\n+                        Error_Msg_N (\"incorrect placement of aspect `%`\", E);\n+                        goto Continue;\n+                     end if;\n \n-                  Comp_Assn := First (Component_Associations (Expr));\n-                  while Present (Comp_Assn) loop\n-                     if List_Length (Choices (Comp_Assn)) /= 1\n-                       or else\n-                         Nkind (First (Choices (Comp_Assn))) /= N_Identifier\n-                     then\n+                     if Nkind (Expr) /= N_Aggregate then\n+                        Error_Msg_Name_1 := Nam;\n                         Error_Msg_NE\n-                          (\"wrong syntax for aspect `Test_Case` for &\", Id, E);\n+                          (\"wrong syntax for aspect `%` for &\", Id, E);\n                         goto Continue;\n                      end if;\n \n-                     New_Expr := Relocate_Node (Expression (Comp_Assn));\n-                     Set_Original_Node (New_Expr, Expression (Comp_Assn));\n-                     Append (Make_Pragma_Argument_Association (\n-                       Sloc       => Sloc (Comp_Assn),\n-                       Chars      => Chars (First (Choices (Comp_Assn))),\n-                       Expression => New_Expr),\n-                       Args);\n-                     Next (Comp_Assn);\n-                  end loop;\n+                     --  Make pragma expressions refer to the original aspect\n+                     --  expressions through the Original_Node link. This is\n+                     --  used in semantic analysis for ASIS mode, so that the\n+                     --  original expression also gets analyzed.\n+\n+                     Comp_Expr := First (Expressions (Expr));\n+                     while Present (Comp_Expr) loop\n+                        New_Expr := Relocate_Node (Comp_Expr);\n+                        Set_Original_Node (New_Expr, Comp_Expr);\n+                        Append\n+                          (Make_Pragma_Argument_Association (Sloc (Comp_Expr),\n+                           Expression => New_Expr),\n+                           Args);\n+                        Next (Comp_Expr);\n+                     end loop;\n \n-                  --  Build the test-case pragma\n+                     Comp_Assn := First (Component_Associations (Expr));\n+                     while Present (Comp_Assn) loop\n+                        if List_Length (Choices (Comp_Assn)) /= 1\n+                          or else\n+                            Nkind (First (Choices (Comp_Assn))) /= N_Identifier\n+                        then\n+                           Error_Msg_Name_1 := Nam;\n+                           Error_Msg_NE\n+                             (\"wrong syntax for aspect `%` for &\", Id, E);\n+                           goto Continue;\n+                        end if;\n \n-                  Aitem :=\n-                    Make_Pragma (Loc,\n-                      Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Test_Case),\n-                      Pragma_Argument_Associations =>\n-                        Args);\n+                        New_Expr := Relocate_Node (Expression (Comp_Assn));\n+                        Set_Original_Node (New_Expr, Expression (Comp_Assn));\n+                        Append (Make_Pragma_Argument_Association (\n+                          Sloc       => Sloc (Comp_Assn),\n+                          Chars      => Chars (First (Choices (Comp_Assn))),\n+                          Expression => New_Expr),\n+                          Args);\n+                        Next (Comp_Assn);\n+                     end loop;\n \n-                  Set_From_Aspect_Specification (Aitem, True);\n-                  Set_Corresponding_Aspect (Aitem, Aspect);\n-                  Set_Is_Delayed_Aspect (Aspect);\n+                     --  Build the contract-case or test-case pragma\n \n-                  --  Insert immediately after the entity declaration\n+                     Aitem :=\n+                       Make_Pragma (Loc,\n+                                    Pragma_Identifier            =>\n+                                      Make_Identifier (Sloc (Id), Nam),\n+                                    Pragma_Argument_Associations =>\n+                                      Args);\n \n-                  Insert_After (N, Aitem);\n+                     Set_From_Aspect_Specification (Aitem, True);\n+                     Set_Corresponding_Aspect (Aitem, Aspect);\n+                     Set_Is_Delayed_Aspect (Aspect);\n \n-                  goto Continue;\n-               end;\n+                     --  Insert immediately after the entity declaration\n+\n+                     Insert_After (N, Aitem);\n+\n+                     goto Continue;\n+                  end;\n \n                when Aspect_Dimension =>\n                   Analyze_Aspect_Dimension (N, Id, Expr);\n@@ -6158,7 +6162,13 @@ package body Sem_Ch13 is\n          when Boolean_Aspects =>\n             raise Program_Error;\n \n-         --  Test_Case aspect applies to entries and subprograms, hence should\n+         --  Contract_Case aspects apply to subprograms, hence should never be\n+         --  delayed.\n+\n+         when Aspect_Contract_Case =>\n+            raise Program_Error;\n+\n+         --  Test_Case aspects apply to entries and subprograms, hence should\n          --  never be delayed.\n \n          when Aspect_Test_Case =>"}, {"sha": "9d6688490a47d643513227cad347aef5d8c95f4d", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -2204,9 +2204,9 @@ package body Sem_Ch3 is\n \n                Check_Subprogram_Contract (Sent);\n \n-               Prag := Spec_TC_List (Contract (Sent));\n+               Prag := Spec_CTC_List (Contract (Sent));\n                while Present (Prag) loop\n-                  Analyze_TC_In_Decl_Part (Prag, Sent);\n+                  Analyze_CTC_In_Decl_Part (Prag, Sent);\n                   Prag := Next_Pragma (Prag);\n                end loop;\n             end if;"}, {"sha": "6adcaa3766511e9d67eb44cbc886e9228a9ab72d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -10932,6 +10932,11 @@ package body Sem_Ch6 is\n       Plist : List_Id := No_List;\n       --  List of generated postconditions\n \n+      function Grab_CC return Node_Id;\n+      --  Prag contains an analyzed contract case pragma. This function copies\n+      --  relevant components of the pragma, creates the corresponding Check\n+      --  pragma and returns the Check pragma as the result.\n+\n       function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n       --  Prag contains an analyzed precondition or postcondition pragma. This\n       --  function copies the pragma, changes it to the corresponding Check\n@@ -10954,6 +10959,87 @@ package body Sem_Ch6 is\n       --  that an invariant check is required (for an IN OUT parameter, or\n       --  the returned value of a function.\n \n+      -------------\n+      -- Grab_CC --\n+      -------------\n+\n+      function Grab_CC return Node_Id is\n+         CP   : Node_Id;\n+         Req  : Node_Id;\n+         Ens  : Node_Id;\n+         Post : Node_Id;\n+         Loc  : constant Source_Ptr := Sloc (Prag);\n+\n+         --  Similarly to postcondition, the string is \"failed xx from yy\"\n+         --  where xx is in all lower case. The reason for this different\n+         --  wording compared to other Check cases is that the failure is not\n+         --  at the point of occurrence of the pragma, unlike the other Check\n+         --  cases.\n+\n+         Msg  : constant String :=\n+                  \"failed contract case from \" & Build_Location_String (Loc);\n+\n+      begin\n+         --  Copy the Requires and Ensures expressions\n+\n+         Req  := New_Copy_Tree (\n+                   Expression (Get_Requires_From_Case_Pragma (Prag)),\n+                   New_Scope => Current_Scope);\n+\n+         Ens  := New_Copy_Tree (\n+                   Expression (Get_Ensures_From_Case_Pragma (Prag)),\n+                   New_Scope => Current_Scope);\n+\n+         --  Build the postcondition (not Requires'Old or else Ensures)\n+\n+         Post := Make_Or_Else (Loc,\n+                   Left_Opnd  => Make_Op_Not (Loc,\n+                                   Make_Attribute_Reference (Loc,\n+                                     Prefix         => Req,\n+                                     Attribute_Name => Name_Old)),\n+                   Right_Opnd => Ens);\n+\n+         --  For a contract case pragma within a generic, generate a\n+         --  postcondition pragma for later expansion. This is also used\n+         --  when an error was detected, thus setting Expander_Active to False.\n+\n+         if not Expander_Active then\n+            CP := Make_Pragma (Loc,\n+                    Chars => Name_Postcondition,\n+                    Pragma_Argument_Associations => New_List (\n+                      Make_Pragma_Argument_Association (Loc,\n+                        Chars      => Name_Check,\n+                        Expression => Post),\n+\n+                      Make_Pragma_Argument_Association (Loc,\n+                        Chars      => Name_Message,\n+                        Expression => Make_String_Literal (Loc, Msg))));\n+\n+         --  Otherwise, create the Check pragma\n+\n+         else\n+            CP := Make_Pragma (Loc,\n+                    Chars => Name_Check,\n+                    Pragma_Argument_Associations => New_List (\n+                      Make_Pragma_Argument_Association (Loc,\n+                        Chars      => Name_Name,\n+                        Expression =>\n+                          Make_Identifier (Loc, Name_Postcondition)),\n+\n+                      Make_Pragma_Argument_Association (Loc,\n+                        Chars      => Name_Check,\n+                        Expression => Post),\n+\n+                      Make_Pragma_Argument_Association (Loc,\n+                        Chars      => Name_Message,\n+                        Expression => Make_String_Literal (Loc, Msg))));\n+         end if;\n+\n+         --  Return the Postcondition or Check pragma\n+\n+         return CP;\n+      end Grab_CC;\n+\n       --------------\n       -- Grab_PPC --\n       --------------\n@@ -11005,7 +11091,8 @@ package body Sem_Ch6 is\n          Set_Comes_From_Source (CP, False);\n \n          --  For a postcondition pragma within a generic, preserve the pragma\n-         --  for later expansion.\n+         --  for later expansion. This is also used when an error was detected,\n+         --  thus setting Expander_Active to False.\n \n          if Nam = Name_Postcondition\n            and then not Expander_Active\n@@ -11328,6 +11415,11 @@ package body Sem_Ch6 is\n \n       if Present (Spec_Id) then\n          Spec_Postconditions : declare\n+            procedure Process_Contract_Cases (Spec : Node_Id);\n+            --  This processes the Spec_CTC_List from Spec, processing any\n+            --  contract-case from the list. The caller has checked that\n+            --  Spec_CTC_List is non-Empty.\n+\n             procedure Process_Post_Conditions\n               (Spec  : Node_Id;\n                Class : Boolean);\n@@ -11336,6 +11428,34 @@ package body Sem_Ch6 is\n             --  postconditions marked with Class_Present are considered.\n             --  The caller has checked that Spec_PPC_List is non-Empty.\n \n+            ----------------------------\n+            -- Process_Contract_Cases --\n+            ----------------------------\n+\n+            procedure Process_Contract_Cases (Spec : Node_Id) is\n+            begin\n+               --  Loop through Contract_Case pragmas from spec\n+\n+               Prag := Spec_CTC_List (Contract (Spec));\n+               loop\n+                  if Pragma_Name (Prag) = Name_Contract_Case then\n+                     if Plist = No_List then\n+                        Plist := Empty_List;\n+                     end if;\n+\n+                     if not Expander_Active then\n+                        Prepend (Grab_CC, Declarations (N));\n+                     else\n+                        Append (Grab_CC, Plist);\n+                     end if;\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+                  exit when No (Prag);\n+               end loop;\n+\n+            end Process_Contract_Cases;\n+\n             -----------------------------\n             -- Process_Post_Conditions --\n             -----------------------------\n@@ -11380,6 +11500,14 @@ package body Sem_Ch6 is\n          --  Start of processing for Spec_Postconditions\n \n          begin\n+            --  Process postconditions expressed as contract-cases\n+\n+            if Present (Spec_CTC_List (Contract (Spec_Id))) then\n+               Process_Contract_Cases (Spec_Id);\n+            end if;\n+\n+            --  Process spec postconditions\n+\n             if Present (Spec_PPC_List (Contract (Spec_Id))) then\n                Process_Post_Conditions (Spec_Id, Class => False);\n             end if;"}, {"sha": "aa574eea1503ab1061d4fe853574f6e3d7d6a08a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -181,10 +181,10 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n-   procedure Preanalyze_TC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n+   procedure Preanalyze_CTC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n    --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n-   --  of a Test_Case pragma if present (possibly Empty). We treat these as\n-   --  spec expressions (i.e. similar to a default expression).\n+   --  of a Contract_Case or Test_Case pragma if present (possibly Empty). We\n+   --  treat these as spec expressions (i.e. similar to a default expression).\n \n    procedure rv;\n    --  This is a dummy function called by the processing for pragma Reviewable.\n@@ -637,15 +637,16 @@ package body Sem_Prag is\n       --  that the constraint is static as required by the restrictions for\n       --  Unchecked_Union.\n \n-      procedure Check_Test_Case;\n-      --  Called to process a test-case pragma. The treatment is similar to the\n-      --  one for pre- and postcondition in Check_Precondition_Postcondition,\n-      --  except the placement rules for the test-case pragma are stricter.\n-      --  This pragma may only occur after a subprogram spec declared directly\n-      --  in a package spec unit. In this case, the pragma is chained to the\n-      --  subprogram in question (using Spec_TC_List and Next_Pragma) and\n-      --  analysis of the pragma is delayed till the end of the spec. In\n-      --  all other cases, an error message for bad placement is given.\n+      procedure Check_Contract_Or_Test_Case;\n+      --  Called to process a contract-case or test-case pragma. The\n+      --  treatment is similar to the one for pre- and postcondition in\n+      --  Check_Precondition_Postcondition, except the placement rules for the\n+      --  contract-case and test-case pragmas are stricter. These pragmas may\n+      --  only occur after a subprogram spec declared directly in a package\n+      --  spec unit. In this case, the pragma is chained to the subprogram in\n+      --  question (using Spec_CTC_List and Next_Pragma) and analysis of the\n+      --  pragma is delayed till the end of the spec. In all other cases, an\n+      --  error message for bad placement is given.\n \n       procedure Check_Valid_Configuration_Pragma;\n       --  Legality checks for placement of a configuration pragma\n@@ -2113,24 +2114,25 @@ package body Sem_Prag is\n          end case;\n       end Check_Static_Constraint;\n \n-      ---------------------\n-      -- Check_Test_Case --\n-      ---------------------\n+      ---------------------------------\n+      -- Check_Contract_Or_Test_Case --\n+      ---------------------------------\n \n-      procedure Check_Test_Case is\n+      procedure Check_Contract_Or_Test_Case is\n          P  : Node_Id;\n          PO : Node_Id;\n \n-         procedure Chain_TC (PO : Node_Id);\n+         procedure Chain_CTC (PO : Node_Id);\n          --  If PO is a [generic] subprogram declaration node, then the\n-         --  test-case applies to this subprogram and the processing for the\n-         --  pragma is completed. Otherwise the pragma is misplaced.\n+         --  contract-case or test-case applies to this subprogram and the\n+         --  processing for the pragma is completed. Otherwise the pragma\n+         --  is misplaced.\n \n-         --------------\n-         -- Chain_TC --\n-         --------------\n+         ---------------\n+         -- Chain_CTC --\n+         ---------------\n \n-         procedure Chain_TC (PO : Node_Id) is\n+         procedure Chain_CTC (PO : Node_Id) is\n             S   : Entity_Id;\n \n          begin\n@@ -2166,21 +2168,21 @@ package body Sem_Prag is\n             --  in this analysis, allowing forward references. The analysis\n             --  happens at the end of Analyze_Declarations.\n \n-            --  There should not be another test case with the same name\n-            --  associated to this subprogram.\n+            --  There should not be another contract-case or test-case with the\n+            --  same name associated to this subprogram.\n \n             declare\n-               Name : constant String_Id := Get_Name_From_Test_Case_Pragma (N);\n-               TC   : Node_Id;\n+               Name : constant String_Id := Get_Name_From_Case_Pragma (N);\n+               CTC   : Node_Id;\n \n             begin\n-               TC := Spec_TC_List (Contract (S));\n-               while Present (TC) loop\n+               CTC := Spec_CTC_List (Contract (S));\n+               while Present (CTC) loop\n \n                   if String_Equal\n-                    (Name, Get_Name_From_Test_Case_Pragma (TC))\n+                    (Name, Get_Name_From_Case_Pragma (CTC))\n                   then\n-                     Error_Msg_Sloc := Sloc (TC);\n+                     Error_Msg_Sloc := Sloc (CTC);\n \n                      if From_Aspect_Specification (N) then\n                         Error_Pragma (\"name for aspect% is already used#\");\n@@ -2189,24 +2191,24 @@ package body Sem_Prag is\n                      end if;\n                   end if;\n \n-                  TC := Next_Pragma (TC);\n+                  CTC := Next_Pragma (CTC);\n                end loop;\n             end;\n \n-            --  Chain spec TC pragma to list for subprogram\n+            --  Chain spec CTC pragma to list for subprogram\n \n-            Set_Next_Pragma (N, Spec_TC_List (Contract (S)));\n-            Set_Spec_TC_List (Contract (S), N);\n-         end Chain_TC;\n+            Set_Next_Pragma (N, Spec_CTC_List (Contract (S)));\n+            Set_Spec_CTC_List (Contract (S), N);\n+         end Chain_CTC;\n \n-      --  Start of processing for Check_Test_Case\n+      --  Start of processing for Check_Contract_Or_Test_Case\n \n       begin\n          if not Is_List_Member (N) then\n             Pragma_Misplaced;\n          end if;\n \n-         --  Test cases should only appear in package spec unit\n+         --  Contract-case or test-case should only appear in package spec unit\n \n          if Get_Source_Unit (N) = No_Unit\n            or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n@@ -2224,9 +2226,9 @@ package body Sem_Prag is\n \n             --  If the previous node is a generic subprogram, do not go to to\n             --  the original node, which is the unanalyzed tree: we need to\n-            --  attach the test-case to the analyzed version at this point.\n-            --  They get propagated to the original tree when analyzing the\n-            --  corresponding body.\n+            --  attach the contract-case or test-case to the analyzed version\n+            --  at this point. They get propagated to the original tree when\n+            --  analyzing the corresponding body.\n \n             if Nkind (P) not in N_Generic_Declaration then\n                PO := Original_Node (P);\n@@ -2258,15 +2260,15 @@ package body Sem_Prag is\n                Pragma_Misplaced;\n \n             else\n-               Chain_TC (PO);\n+               Chain_CTC (PO);\n                return;\n             end if;\n          end loop;\n \n          --  If we fall through, pragma was misplaced\n \n          Pragma_Misplaced;\n-      end Check_Test_Case;\n+      end Check_Contract_Or_Test_Case;\n \n       --------------------------------------\n       -- Check_Valid_Configuration_Pragma --\n@@ -13904,18 +13906,21 @@ package body Sem_Prag is\n             end if;\n          end Task_Storage;\n \n-         ---------------\n-         -- Test_Case --\n-         ---------------\n+         -------------------------------\n+         -- Contract_Case | Test_Case --\n+         -------------------------------\n \n-         --  pragma Test_Case ([Name     =>] Static_String_EXPRESSION\n+         --  pragma (Contract_Case | Test_Case)\n+         --                   ([Name     =>] Static_String_EXPRESSION\n          --                   ,[Mode     =>] MODE_TYPE\n          --                  [, Requires =>  Boolean_EXPRESSION]\n          --                  [, Ensures  =>  Boolean_EXPRESSION]);\n \n          --  MODE_TYPE ::= Nominal | Robustness\n \n-         when Pragma_Test_Case => Test_Case : declare\n+         when Pragma_Contract_Case |\n+              Pragma_Test_Case =>\n+         Contract_Or_Test_Case : declare\n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n@@ -13947,8 +13952,8 @@ package body Sem_Prag is\n                Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n             end if;\n \n-            Check_Test_Case;\n-         end Test_Case;\n+            Check_Contract_Or_Test_Case;\n+         end Contract_Or_Test_Case;\n \n          --------------------------\n          -- Thread_Local_Storage --\n@@ -14819,11 +14824,11 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n-   -----------------------------\n-   -- Analyze_TC_In_Decl_Part --\n-   -----------------------------\n+   ------------------------------\n+   -- Analyze_CTC_In_Decl_Part --\n+   ------------------------------\n \n-   procedure Analyze_TC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n    begin\n       --  Install formals and push subprogram spec onto scope stack so that we\n       --  can see the formals from the pragma.\n@@ -14834,15 +14839,15 @@ package body Sem_Prag is\n       --  Preanalyze the boolean expressions, we treat these as spec\n       --  expressions (i.e. similar to a default expression).\n \n-      Preanalyze_TC_Args (N,\n-                          Get_Requires_From_Test_Case_Pragma (N),\n-                          Get_Ensures_From_Test_Case_Pragma (N));\n+      Preanalyze_CTC_Args (N,\n+                           Get_Requires_From_Case_Pragma (N),\n+                           Get_Ensures_From_Case_Pragma (N));\n \n       --  Remove the subprogram from the scope stack now that the pre-analysis\n-      --  of the expressions in the test-case is done.\n+      --  of the expressions in the contract-case or test-case is done.\n \n       End_Scope;\n-   end Analyze_TC_In_Decl_Part;\n+   end Analyze_CTC_In_Decl_Part;\n \n    --------------------\n    -- Check_Disabled --\n@@ -15077,6 +15082,7 @@ package body Sem_Prag is\n       Pragma_Complete_Representation        =>  0,\n       Pragma_Complex_Representation         =>  0,\n       Pragma_Component_Alignment            => -1,\n+      Pragma_Contract_Case                  => -1,\n       Pragma_Controlled                     =>  0,\n       Pragma_Convention                     =>  0,\n       Pragma_Convention_Identifier          =>  0,\n@@ -15431,11 +15437,11 @@ package body Sem_Prag is\n       end if;\n    end Make_Aspect_For_PPC_In_Gen_Sub_Decl;\n \n-   ------------------------\n-   -- Preanalyze_TC_Args --\n-   ------------------------\n+   -------------------------\n+   -- Preanalyze_CTC_Args --\n+   -------------------------\n \n-   procedure Preanalyze_TC_Args (N, Arg_Req, Arg_Ens : Node_Id) is\n+   procedure Preanalyze_CTC_Args (N, Arg_Req, Arg_Ens : Node_Id) is\n    begin\n       --  Preanalyze the boolean expressions, we treat these as spec\n       --  expressions (i.e. similar to a default expression).\n@@ -15465,7 +15471,7 @@ package body Sem_Prag is\n               (Original_Node (Get_Pragma_Arg (Arg_Ens)), Standard_Boolean);\n          end if;\n       end if;\n-   end Preanalyze_TC_Args;\n+   end Preanalyze_CTC_Args;\n \n    --------------------------------------\n    -- Process_Compilation_Unit_Pragmas --"}, {"sha": "23a23d306483680a32bf936b3a92fff36131636b", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -46,13 +46,13 @@ package Sem_Prag is\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n-   procedure Analyze_TC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Special analyze routine for test-case pragma that appears within a\n-   --  declarative part where the pragma is associated with a subprogram\n-   --  specification. N is the pragma node, and S is the entity for the related\n-   --  subprogram. This procedure does a preanalysis of the expressions in the\n-   --  pragma as \"spec expressions\" (see section in Sem \"Handling of Default\n-   --  and Per-Object Expressions...\").\n+   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n+   --  Special analyze routine for contract-case and test-case pragmas that\n+   --  appears within a declarative part where the pragma is associated with\n+   --  a subprogram specification. N is the pragma node, and S is the entity\n+   --  for the related subprogram. This procedure does a preanalysis of the\n+   --  expressions in the pragma as \"spec expressions\" (see section in Sem\n+   --  \"Handling of Default and Per-Object Expressions...\").\n \n    function Check_Disabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,"}, {"sha": "1d600307ecaf388f421dc391ea86e327eecc8a2c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -4490,11 +4490,11 @@ package body Sem_Util is\n       end if;\n    end Get_Enum_Lit_From_Pos;\n \n-   ---------------------------------------\n-   -- Get_Ensures_From_Test_Case_Pragma --\n-   ---------------------------------------\n+   ----------------------------------\n+   -- Get_Ensures_From_Case_Pragma --\n+   ----------------------------------\n \n-   function Get_Ensures_From_Test_Case_Pragma (N : Node_Id) return Node_Id is\n+   function Get_Ensures_From_Case_Pragma (N : Node_Id) return Node_Id is\n       Args : constant List_Id := Pragma_Argument_Associations (N);\n       Res  : Node_Id;\n \n@@ -4514,7 +4514,7 @@ package body Sem_Util is\n       end if;\n \n       return Res;\n-   end Get_Ensures_From_Test_Case_Pragma;\n+   end Get_Ensures_From_Case_Pragma;\n \n    ------------------------\n    -- Get_Generic_Entity --\n@@ -4602,16 +4602,16 @@ package body Sem_Util is\n       return Entity_Id (Get_Name_Table_Info (Id));\n    end Get_Name_Entity_Id;\n \n-   ------------------------------------\n-   -- Get_Name_From_Test_Case_Pragma --\n-   ------------------------------------\n+   -------------------------------\n+   -- Get_Name_From_Case_Pragma --\n+   -------------------------------\n \n-   function Get_Name_From_Test_Case_Pragma (N : Node_Id) return String_Id is\n+   function Get_Name_From_Case_Pragma (N : Node_Id) return String_Id is\n       Arg : constant Node_Id :=\n               Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n    begin\n       return Strval (Expr_Value_S (Arg));\n-   end Get_Name_From_Test_Case_Pragma;\n+   end Get_Name_From_Case_Pragma;\n \n    -------------------\n    -- Get_Pragma_Id --\n@@ -4656,11 +4656,11 @@ package body Sem_Util is\n       return R;\n    end Get_Renamed_Entity;\n \n-   ----------------------------------------\n-   -- Get_Requires_From_Test_Case_Pragma --\n-   ----------------------------------------\n+   -----------------------------------\n+   -- Get_Requires_From_Case_Pragma --\n+   -----------------------------------\n \n-   function Get_Requires_From_Test_Case_Pragma (N : Node_Id) return Node_Id is\n+   function Get_Requires_From_Case_Pragma (N : Node_Id) return Node_Id is\n       Args : constant List_Id := Pragma_Argument_Associations (N);\n       Res  : Node_Id;\n \n@@ -4677,7 +4677,7 @@ package body Sem_Util is\n       end if;\n \n       return Res;\n-   end Get_Requires_From_Test_Case_Pragma;\n+   end Get_Requires_From_Case_Pragma;\n \n    -------------------------\n    -- Get_Subprogram_Body --"}, {"sha": "93f855ff4790e29c4e7a8802aaf36c26c79c83a7", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -538,8 +538,9 @@ package Sem_Util is\n    --  If expression N references a part of an object, return this object.\n    --  Otherwise return Empty. Expression N should have been resolved already.\n \n-   function Get_Ensures_From_Test_Case_Pragma (N : Node_Id) return Node_Id;\n-   --  Return the Ensures component of Test_Case pragma N, or Empty otherwise\n+   function Get_Ensures_From_Case_Pragma (N : Node_Id) return Node_Id;\n+   --  Return the Ensures component of Contract_Case or Test_Case pragma N, or\n+   --  Empty otherwise.\n \n    function Get_Generic_Entity (N : Node_Id) return Entity_Id;\n    --  Returns the true generic entity in an instantiation. If the name in the\n@@ -572,8 +573,8 @@ package Sem_Util is\n    --  is the innermost visible entity with the given name. See the body of\n    --  Sem_Ch8 for further details on handling of entity visibility.\n \n-   function Get_Name_From_Test_Case_Pragma (N : Node_Id) return String_Id;\n-   --  Return the Name component of Test_Case pragma N\n+   function Get_Name_From_Case_Pragma (N : Node_Id) return String_Id;\n+   --  Return the Name component of Contract_Case or Test_Case pragma N\n \n    function Get_Pragma_Id (N : Node_Id) return Pragma_Id;\n    pragma Inline (Get_Pragma_Id);\n@@ -590,8 +591,9 @@ package Sem_Util is\n    --  not a renamed entity, returns its argument. It is an error to call this\n    --  with any other kind of entity.\n \n-   function Get_Requires_From_Test_Case_Pragma (N : Node_Id) return Node_Id;\n-   --  Return the Requires component of Test_Case pragma N, or Empty otherwise\n+   function Get_Requires_From_Case_Pragma (N : Node_Id) return Node_Id;\n+   --  Return the Requires component of Contract_Case or Test_Case pragma N, or\n+   --  Empty otherwise.\n \n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or an"}, {"sha": "f4e70922c702d1ad9019a58186bc698726245518", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1749,7 +1749,7 @@ package body Sem_Warn is\n \n                      function Within_Postcondition return Boolean;\n                      --  Returns True iff N is within a Postcondition or\n-                     --  Ensures component in a Test_Case.\n+                     --  Ensures component in a Contract_Case or Test_Case.\n \n                      --------------------------\n                      -- Within_Postcondition --\n@@ -1770,9 +1770,11 @@ package body Sem_Warn is\n                               P := Parent (Nod);\n \n                               if Nkind (P) = N_Pragma\n-                                and then Pragma_Name (P) = Name_Test_Case\n                                 and then\n-                                  Nod = Get_Ensures_From_Test_Case_Pragma (P)\n+                                  (Pragma_Name (P) = Name_Contract_Case\n+                                     or else Pragma_Name (P) = Name_Test_Case)\n+                                and then\n+                                  Nod = Get_Ensures_From_Case_Pragma (P)\n                               then\n                                  return True;\n                               end if;"}, {"sha": "a8388b19344d5115b7e4b4974f08553ed0332e29", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2812,13 +2812,13 @@ package body Sinfo is\n       return Node1 (N);\n    end Spec_PPC_List;\n \n-   function Spec_TC_List\n+   function Spec_CTC_List\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Contract);\n       return Node2 (N);\n-   end Spec_TC_List;\n+   end Spec_CTC_List;\n \n    function Specification\n       (N : Node_Id) return Node_Id is\n@@ -5892,13 +5892,13 @@ package body Sinfo is\n       Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_Spec_PPC_List;\n \n-   procedure Set_Spec_TC_List\n+   procedure Set_Spec_CTC_List\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Contract);\n       Set_Node2 (N, Val); -- semantic field, no parent set\n-   end Set_Spec_TC_List;\n+   end Set_Spec_CTC_List;\n \n    procedure Set_Specification\n       (N : Node_Id; Val : Node_Id) is"}, {"sha": "0972d9c1603b821ced34f7482914e17e8aa06d8d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -6969,7 +6969,7 @@ package Sinfo is\n       --  N_Contract\n       --  Sloc points to the subprogram's name\n       --  Spec_PPC_List (Node1) (set to Empty if none)\n-      --  Spec_TC_List (Node2) (set to Empty if none)\n+      --  Spec_CTC_List (Node2) (set to Empty if none)\n \n       --  Spec_PPC_List points to a list of Precondition and Postcondition\n       --  pragma nodes for preconditions and postconditions declared in the\n@@ -6978,11 +6978,12 @@ package Sinfo is\n       --  Note that this includes precondition/postcondition pragmas generated\n       --  to correspond to Pre/Post aspects.\n \n-      --  Spec_TC_List points to a list of Test_Case pragma nodes for\n-      --  test-cases declared in the spec of the entry/subprogram. The last\n-      --  pragma encountered is at the head of this list, so it is in reverse\n-      --  order of textual appearance. Note that this includes test-case\n-      --  pragmas generated to correspond to Test_Case aspects.\n+      --  Spec_CTC_List points to a list of Contract_Case and Test_Case pragma\n+      --  nodes for contract-cases and test-cases declared in the spec of the\n+      --  entry/subprogram. The last pragma encountered is at the head of this\n+      --  list, so it is in reverse order of textual appearance. Note that\n+      --  this includes contract-case and test-case pragmas generated from\n+      --  Contract_Case and Test_Case aspects.\n \n       -------------------\n       -- Expanded_Name --\n@@ -8963,7 +8964,7 @@ package Sinfo is\n    function Spec_PPC_List\n      (N : Node_Id) return Node_Id;    -- Node1\n \n-   function Spec_TC_List\n+   function Spec_CTC_List\n      (N : Node_Id) return Node_Id;    -- Node2\n \n    function Specification\n@@ -9944,7 +9945,7 @@ package Sinfo is\n    procedure Set_Spec_PPC_List\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n-   procedure Set_Spec_TC_List\n+   procedure Set_Spec_CTC_List\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n    procedure Set_Specification\n@@ -11590,7 +11591,7 @@ package Sinfo is\n \n      N_Contract =>\n        (1 => False,   --  Spec_PPC_List (Node1)\n-        2 => False,   --  Spec_TC_List (Node2)\n+        2 => False,   --  Spec_CTC_List (Node2)\n         3 => False,   --  unused\n         4 => False,   --  unused\n         5 => False),  --  unused\n@@ -12084,7 +12085,7 @@ package Sinfo is\n    pragma Inline (Shift_Count_OK);\n    pragma Inline (Source_Type);\n    pragma Inline (Spec_PPC_List);\n-   pragma Inline (Spec_TC_List);\n+   pragma Inline (Spec_CTC_List);\n    pragma Inline (Specification);\n    pragma Inline (Split_PPC);\n    pragma Inline (Statements);\n@@ -12407,7 +12408,7 @@ package Sinfo is\n    pragma Inline (Set_Shift_Count_OK);\n    pragma Inline (Set_Source_Type);\n    pragma Inline (Set_Spec_PPC_List);\n-   pragma Inline (Set_Spec_TC_List);\n+   pragma Inline (Set_Spec_CTC_List);\n    pragma Inline (Set_Specification);\n    pragma Inline (Set_Split_PPC);\n    pragma Inline (Set_Statements);"}, {"sha": "fd8acc86fcccd22ba1b18329f9cdef20334466ec", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90e8523311e9616c99a9fc9cfa2454f753eb9f13/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=90e8523311e9616c99a9fc9cfa2454f753eb9f13", "patch": "@@ -448,6 +448,7 @@ package Snames is\n    Name_Common_Object                  : constant Name_Id := N + $; -- GNAT\n    Name_Complete_Representation        : constant Name_Id := N + $; -- GNAT\n    Name_Complex_Representation         : constant Name_Id := N + $; -- GNAT\n+   Name_Contract_Case                  : constant Name_Id := N + $; -- GNAT\n    Name_Controlled                     : constant Name_Id := N + $;\n    Name_Convention                     : constant Name_Id := N + $;\n    Name_CPP_Class                      : constant Name_Id := N + $; -- GNAT\n@@ -1623,6 +1624,7 @@ package Snames is\n       Pragma_Common_Object,\n       Pragma_Complete_Representation,\n       Pragma_Complex_Representation,\n+      Pragma_Contract_Case,\n       Pragma_Controlled,\n       Pragma_Convention,\n       Pragma_CPP_Class,"}]}