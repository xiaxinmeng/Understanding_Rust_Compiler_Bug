{"sha": "0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczMmY3NWZjZTBmYjI0YTQ5ODliNTEwZDU3ZWJkMmIwNWMxYTY3Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-12T01:17:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-12T01:17:51Z"}, "message": "[PATCH] Refactoring FSM bits into their own file\n\n[PATCH] Refactoring FSM bits into their own file\n\t* tree-ssa-threadedge.c (fsm_find_thread_path): Moved from here into\n\ttree-ssa-threadbackward.c.\n\t(fsm_find_control_statement_thread_paths): Likewise.\n\t(thread_through_normal_block): Break out FSM bits and move them\n\tinto a new function in tree-ssa-threadbackward.c.  Call new function\n\tinstead.\n\tMinimize header file usage.\n\t* tree-ssa-threadbackward.h: New file.\n\t* tree-ssa-threadbackward.c: Likewise.\n\t* Makefile.in (OBJS): Add tree-ssa-threadbackward.o\n\nFrom-SVN: r228700", "tree": {"sha": "86e6f50206bca4e720230f106668d3606296f1e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86e6f50206bca4e720230f106668d3606296f1e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/comments", "author": null, "committer": null, "parents": [{"sha": "f29dc665c7db077b8748fec1eae8fbe39d1b57b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29dc665c7db077b8748fec1eae8fbe39d1b57b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29dc665c7db077b8748fec1eae8fbe39d1b57b7"}], "stats": {"total": 657, "additions": 366, "deletions": 291}, "files": [{"sha": "eff9eeaea0493ade06718d85af1af6167d2a9c8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "patch": "@@ -1,3 +1,16 @@\n+2015-10-11  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (fsm_find_thread_path): Moved from here into\n+\ttree-ssa-threadbackward.c.\n+\t(fsm_find_control_statement_thread_paths): Likewise.\n+\t(thread_through_normal_block): Break out FSM bits and move them\n+\tinto a new function in tree-ssa-threadbackward.c.  Call new function\n+\tinstead.\n+\tMinimize header file usage.\n+\t* tree-ssa-threadbackward.h: New file.\n+\t* tree-ssa-threadbackward.c: Likewise.\n+\t* Makefile.in (OBJS): Add tree-ssa-threadbackward.o\n+\n 2015-10-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/alpha/alpha.h (ALPHA_ROUND): Implement using ROUND_UP macro."}, {"sha": "7e3aefac3fc2328e99c3f557ca20d1d7b701d053", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "patch": "@@ -1478,6 +1478,7 @@ OBJS = \\\n \ttree-ssa-structalias.o \\\n \ttree-ssa-tail-merge.o \\\n \ttree-ssa-ter.o \\\n+\ttree-ssa-threadbackward.o \\\n \ttree-ssa-threadedge.o \\\n \ttree-ssa-threadupdate.o \\\n \ttree-ssa-uncprop.o \\"}, {"sha": "0012aa39180b55206b099b2eaefbcb1de1a929fb", "filename": "gcc/tree-ssa-threadbackward.c", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "patch": "@@ -0,0 +1,325 @@\n+/* SSA Jump Threading\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"predict.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"fold-const.h\"\n+#include \"cfgloop.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa-threadupdate.h\"\n+#include \"params.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"cfganal.h\"\n+#include \"tree-pass.h\"\n+\n+static int max_threaded_paths;\n+\n+/* Return true if the CFG contains at least one path from START_BB to END_BB.\n+   When a path is found, record in PATH the blocks from END_BB to START_BB.\n+   VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n+   the recursion to basic blocks belonging to LOOP.  */\n+\n+static bool\n+fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n+\t\t      vec<basic_block, va_gc> *&path,\n+\t\t      hash_set<basic_block> *visited_bbs, loop_p loop)\n+{\n+  if (loop != start_bb->loop_father)\n+    return false;\n+\n+  if (start_bb == end_bb)\n+    {\n+      vec_safe_push (path, start_bb);\n+      return true;\n+    }\n+\n+  if (!visited_bbs->add (start_bb))\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, start_bb->succs)\n+\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n+\t  {\n+\t    vec_safe_push (path, start_bb);\n+\t    return true;\n+\t  }\n+    }\n+\n+  return false;\n+}\n+\n+/* We trace the value of the variable EXPR back through any phi nodes looking\n+   for places where it gets a constant value and save the path.  Stop after\n+   having recorded MAX_PATHS jump threading paths.  */\n+\n+static void\n+fsm_find_control_statement_thread_paths (tree expr,\n+\t\t\t\t\t hash_set<basic_block> *visited_bbs,\n+\t\t\t\t\t vec<basic_block, va_gc> *&path,\n+\t\t\t\t\t bool seen_loop_phi)\n+{\n+  tree var = SSA_NAME_VAR (expr);\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n+  basic_block var_bb = gimple_bb (def_stmt);\n+\n+  if (var == NULL || var_bb == NULL)\n+    return;\n+\n+  /* For the moment we assume that an SSA chain only contains phi nodes, and\n+     eventually one of the phi arguments will be an integer constant.  In the\n+     future, this could be extended to also handle simple assignments of\n+     arithmetic operations.  */\n+  if (gimple_code (def_stmt) != GIMPLE_PHI)\n+    return;\n+\n+  /* Avoid infinite recursion.  */\n+  if (visited_bbs->add (var_bb))\n+    return;\n+\n+  gphi *phi = as_a <gphi *> (def_stmt);\n+  int next_path_length = 0;\n+  basic_block last_bb_in_path = path->last ();\n+\n+  if (loop_containing_stmt (phi)->header == gimple_bb (phi))\n+    {\n+      /* Do not walk through more than one loop PHI node.  */\n+      if (seen_loop_phi)\n+\treturn;\n+      seen_loop_phi = true;\n+    }\n+\n+  /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n+     LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n+     different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n+  if (var_bb != last_bb_in_path)\n+    {\n+      edge e;\n+      int e_count = 0;\n+      edge_iterator ei;\n+      vec<basic_block, va_gc> *next_path;\n+      vec_alloc (next_path, n_basic_blocks_for_fn (cfun));\n+\n+      FOR_EACH_EDGE (e, ei, last_bb_in_path->preds)\n+\t{\n+\t  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+\n+\t  if (fsm_find_thread_path (var_bb, e->src, next_path, visited_bbs,\n+\t\t\t\t    e->src->loop_father))\n+\t    ++e_count;\n+\n+\t  delete visited_bbs;\n+\n+\t  /* If there is more than one path, stop.  */\n+\t  if (e_count > 1)\n+\t    {\n+\t      vec_free (next_path);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Stop if we have not found a path: this could occur when the recursion\n+\t is stopped by one of the bounds.  */\n+      if (e_count == 0)\n+\t{\n+\t  vec_free (next_path);\n+\t  return;\n+\t}\n+\n+      /* Make sure we haven't already visited any of the nodes in\n+\t NEXT_PATH.  Don't add them here to avoid pollution.  */\n+      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+\t{\n+\t  if (visited_bbs->contains ((*next_path)[i]))\n+\t    {\n+\t      vec_free (next_path);\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Now add the nodes to VISISTED_BBS.  */\n+      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+\tvisited_bbs->add ((*next_path)[i]);\n+\n+      /* Append all the nodes from NEXT_PATH to PATH.  */\n+      vec_safe_splice (path, next_path);\n+      next_path_length = next_path->length ();\n+      vec_free (next_path);\n+    }\n+\n+  gcc_assert (path->last () == var_bb);\n+\n+  /* Iterate over the arguments of PHI.  */\n+  unsigned int i;\n+  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n+\n+      /* Skip edges pointing outside the current loop.  */\n+      if (!arg || var_bb->loop_father != bbi->loop_father)\n+\tcontinue;\n+\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  vec_safe_push (path, bbi);\n+\t  /* Recursively follow SSA_NAMEs looking for a constant definition.  */\n+\t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n+\t\t\t\t\t\t   seen_loop_phi);\n+\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\tcontinue;\n+\n+      int path_length = path->length ();\n+      /* A path with less than 2 basic blocks should not be jump-threaded.  */\n+      if (path_length < 2)\n+\tcontinue;\n+\n+      if (path_length > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of basic blocks on the path \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n+\t  continue;\n+\t}\n+\n+      if (max_threaded_paths <= 0)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of previously recorded FSM paths to thread \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n+\t  continue;\n+\t}\n+\n+      /* Add BBI to the path.  */\n+      vec_safe_push (path, bbi);\n+      ++path_length;\n+\n+      int n_insns = 0;\n+      gimple_stmt_iterator gsi;\n+      int j;\n+      loop_p loop = (*path)[0]->loop_father;\n+      bool path_crosses_loops = false;\n+\n+      /* Count the number of instructions on the path: as these instructions\n+\t will have to be duplicated, we will not record the path if there are\n+\t too many instructions on the path.  Also check that all the blocks in\n+\t the path belong to a single loop.  */\n+      for (j = 1; j < path_length - 1; j++)\n+\t{\n+\t  basic_block bb = (*path)[j];\n+\n+\t  if (bb->loop_father != loop)\n+\t    {\n+\t      path_crosses_loops = true;\n+\t      break;\n+\t    }\n+\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      /* Do not count empty statements and labels.  */\n+\t      if (gimple_code (stmt) != GIMPLE_NOP\n+\t\t  && gimple_code (stmt) != GIMPLE_LABEL\n+\t\t  && !is_gimple_debug (stmt))\n+\t\t++n_insns;\n+\t    }\n+\t}\n+\n+      if (path_crosses_loops)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the path crosses loops.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t\t     \"the number of instructions on the path \"\n+\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      vec<jump_thread_edge *> *jump_thread_path\n+\t= new vec<jump_thread_edge *> ();\n+\n+      /* Record the edges between the blocks in PATH.  */\n+      for (j = 0; j < path_length - 1; j++)\n+\t{\n+\t  edge e = find_edge ((*path)[path_length - j - 1],\n+\t\t\t      (*path)[path_length - j - 2]);\n+\t  gcc_assert (e);\n+\t  jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+\t  jump_thread_path->safe_push (x);\n+\t}\n+\n+      /* Add the edge taken when the control variable has value ARG.  */\n+      edge taken_edge = find_taken_edge ((*path)[0], arg);\n+      jump_thread_edge *x\n+\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+      jump_thread_path->safe_push (x);\n+\n+      register_jump_thread (jump_thread_path);\n+      --max_threaded_paths;\n+\n+      /* Remove BBI from the path.  */\n+      path->pop ();\n+    }\n+\n+  /* Remove all the nodes that we added from NEXT_PATH.  */\n+  if (next_path_length)\n+    vec_safe_truncate (path, (path->length () - next_path_length));\n+}\n+\n+/* Search backwards from BB looking for paths where NAME (an SSA_NAME)\n+   is a constant.  Record such paths for jump threading.\n+\n+   It is assumed that BB ends with a control statement and that by\n+   finding a path where NAME is a constant, we can thread the path.  */\n+\n+void  \n+find_jump_threads_backwards (tree name, basic_block bb)\n+{     \n+  vec<basic_block, va_gc> *bb_path;\n+  vec_alloc (bb_path, n_basic_blocks_for_fn (cfun));\n+  vec_safe_push (bb_path, bb);           \n+  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+\n+  max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n+  fsm_find_control_statement_thread_paths (name, visited_bbs, bb_path, false);\n+\n+  delete visited_bbs;\n+  vec_free (bb_path);\n+}         "}, {"sha": "f055f432dd73c4c7e3fd66a781cdd2297414b387", "filename": "gcc/tree-ssa-threadbackward.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadbackward.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadbackward.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.h?ref=0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "patch": "@@ -0,0 +1,25 @@\n+/* Header file for SSA dominator optimizations.\n+   Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_THREADFSM_H\n+#define GCC_TREE_SSA_THREADFSM_H\n+\n+extern void find_jump_threads_backwards (tree, basic_block);\n+\n+#endif /* GCC_TREE_SSA_THREADFSM_H */"}, {"sha": "5ca945864e7036eedaba352043c9cf3726e5a5c7", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 291, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0732f75fce0fb24a4989b510d57ebd2b05c1a67f/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=0732f75fce0fb24a4989b510d57ebd2b05c1a67f", "patch": "@@ -25,28 +25,18 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n-#include \"hard-reg-set.h\"\n #include \"ssa.h\"\n-#include \"alias.h\"\n #include \"fold-const.h\"\n-#include \"flags.h\"\n-#include \"tm_p.h\"\n #include \"cfgloop.h\"\n-#include \"timevar.h\"\n-#include \"dumpfile.h\"\n-#include \"internal-fn.h\"\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n-#include \"tree-ssa-propagate.h\"\n #include \"tree-ssa-threadupdate.h\"\n-#include \"langhooks.h\"\n #include \"params.h\"\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n-#include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-threadbackward.h\"\n #include \"tree-ssa-dom.h\"\n #include \"builtins.h\"\n-#include \"cfganal.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -894,275 +884,6 @@ thread_around_empty_blocks (edge taken_edge,\n   return false;\n }\n \n-/* Return true if the CFG contains at least one path from START_BB to END_BB.\n-   When a path is found, record in PATH the blocks from END_BB to START_BB.\n-   VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n-   the recursion to basic blocks belonging to LOOP.  */\n-\n-static bool\n-fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n-\t\t      vec<basic_block, va_gc> *&path,\n-\t\t      hash_set<basic_block> *visited_bbs, loop_p loop)\n-{\n-  if (loop != start_bb->loop_father)\n-    return false;\n-\n-  if (start_bb == end_bb)\n-    {\n-      vec_safe_push (path, start_bb);\n-      return true;\n-    }\n-\n-  if (!visited_bbs->add (start_bb))\n-    {\n-      edge e;\n-      edge_iterator ei;\n-      FOR_EACH_EDGE (e, ei, start_bb->succs)\n-\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n-\t  {\n-\t    vec_safe_push (path, start_bb);\n-\t    return true;\n-\t  }\n-    }\n-\n-  return false;\n-}\n-\n-static int max_threaded_paths;\n-\n-/* We trace the value of the variable EXPR back through any phi nodes looking\n-   for places where it gets a constant value and save the path.  Stop after\n-   having recorded MAX_PATHS jump threading paths.  */\n-\n-static void\n-fsm_find_control_statement_thread_paths (tree expr,\n-\t\t\t\t\t hash_set<basic_block> *visited_bbs,\n-\t\t\t\t\t vec<basic_block, va_gc> *&path,\n-\t\t\t\t\t bool seen_loop_phi)\n-{\n-  tree var = SSA_NAME_VAR (expr);\n-  gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n-  basic_block var_bb = gimple_bb (def_stmt);\n-\n-  if (var == NULL || var_bb == NULL)\n-    return;\n-\n-  /* For the moment we assume that an SSA chain only contains phi nodes, and\n-     eventually one of the phi arguments will be an integer constant.  In the\n-     future, this could be extended to also handle simple assignments of\n-     arithmetic operations.  */\n-  if (gimple_code (def_stmt) != GIMPLE_PHI)\n-    return;\n-\n-  /* Avoid infinite recursion.  */\n-  if (visited_bbs->add (var_bb))\n-    return;\n-\n-  gphi *phi = as_a <gphi *> (def_stmt);\n-  int next_path_length = 0;\n-  basic_block last_bb_in_path = path->last ();\n-\n-  if (loop_containing_stmt (phi)->header == gimple_bb (phi))\n-    {\n-      /* Do not walk through more than one loop PHI node.  */\n-      if (seen_loop_phi)\n-\treturn;\n-      seen_loop_phi = true;\n-    }\n-\n-  /* Following the chain of SSA_NAME definitions, we jumped from a definition in\n-     LAST_BB_IN_PATH to a definition in VAR_BB.  When these basic blocks are\n-     different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n-  if (var_bb != last_bb_in_path)\n-    {\n-      edge e;\n-      int e_count = 0;\n-      edge_iterator ei;\n-      vec<basic_block, va_gc> *next_path;\n-      vec_alloc (next_path, n_basic_blocks_for_fn (cfun));\n-\n-      FOR_EACH_EDGE (e, ei, last_bb_in_path->preds)\n-\t{\n-\t  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n-\n-\t  if (fsm_find_thread_path (var_bb, e->src, next_path, visited_bbs,\n-\t\t\t\t    e->src->loop_father))\n-\t    ++e_count;\n-\n-\t  delete visited_bbs;\n-\n-\t  /* If there is more than one path, stop.  */\n-\t  if (e_count > 1)\n-\t    {\n-\t      vec_free (next_path);\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Stop if we have not found a path: this could occur when the recursion\n-\t is stopped by one of the bounds.  */\n-      if (e_count == 0)\n-\t{\n-\t  vec_free (next_path);\n-\t  return;\n-\t}\n-\n-      /* Make sure we haven't already visited any of the nodes in\n-\t NEXT_PATH.  Don't add them here to avoid pollution.  */\n-      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n-\t{\n-\t  if (visited_bbs->contains ((*next_path)[i]))\n-\t    {\n-\t      vec_free (next_path);\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Now add the nodes to VISISTED_BBS.  */\n-      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n-\tvisited_bbs->add ((*next_path)[i]);\n-\n-      /* Append all the nodes from NEXT_PATH to PATH.  */\n-      vec_safe_splice (path, next_path);\n-      next_path_length = next_path->length ();\n-      vec_free (next_path);\n-    }\n-\n-  gcc_assert (path->last () == var_bb);\n-\n-  /* Iterate over the arguments of PHI.  */\n-  unsigned int i;\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree arg = gimple_phi_arg_def (phi, i);\n-      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n-\n-      /* Skip edges pointing outside the current loop.  */\n-      if (!arg || var_bb->loop_father != bbi->loop_father)\n-\tcontinue;\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  vec_safe_push (path, bbi);\n-\t  /* Recursively follow SSA_NAMEs looking for a constant definition.  */\n-\t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n-\t\t\t\t\t\t   seen_loop_phi);\n-\n-\t  path->pop ();\n-\t  continue;\n-\t}\n-\n-      if (TREE_CODE (arg) != INTEGER_CST)\n-\tcontinue;\n-\n-      int path_length = path->length ();\n-      /* A path with less than 2 basic blocks should not be jump-threaded.  */\n-      if (path_length < 2)\n-\tcontinue;\n-\n-      if (path_length > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of basic blocks on the path \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n-\t  continue;\n-\t}\n-\n-      if (max_threaded_paths <= 0)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of previously recorded FSM paths to thread \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n-\t  continue;\n-\t}\n-\n-      /* Add BBI to the path.  */\n-      vec_safe_push (path, bbi);\n-      ++path_length;\n-\n-      int n_insns = 0;\n-      gimple_stmt_iterator gsi;\n-      int j;\n-      loop_p loop = (*path)[0]->loop_father;\n-      bool path_crosses_loops = false;\n-\n-      /* Count the number of instructions on the path: as these instructions\n-\t will have to be duplicated, we will not record the path if there are\n-\t too many instructions on the path.  Also check that all the blocks in\n-\t the path belong to a single loop.  */\n-      for (j = 1; j < path_length - 1; j++)\n-\t{\n-\t  basic_block bb = (*path)[j];\n-\n-\t  if (bb->loop_father != loop)\n-\t    {\n-\t      path_crosses_loops = true;\n-\t      break;\n-\t    }\n-\n-\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (gsi);\n-\t      /* Do not count empty statements and labels.  */\n-\t      if (gimple_code (stmt) != GIMPLE_NOP\n-\t\t  && gimple_code (stmt) != GIMPLE_LABEL\n-\t\t  && !is_gimple_debug (stmt))\n-\t\t++n_insns;\n-\t    }\n-\t}\n-\n-      if (path_crosses_loops)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the path crosses loops.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n-\n-      if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t     \"the number of instructions on the path \"\n-\t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t  path->pop ();\n-\t  continue;\n-\t}\n-\n-      vec<jump_thread_edge *> *jump_thread_path\n-\t= new vec<jump_thread_edge *> ();\n-\n-      /* Record the edges between the blocks in PATH.  */\n-      for (j = 0; j < path_length - 1; j++)\n-\t{\n-\t  edge e = find_edge ((*path)[path_length - j - 1],\n-\t\t\t      (*path)[path_length - j - 2]);\n-\t  gcc_assert (e);\n-\t  jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n-\t  jump_thread_path->safe_push (x);\n-\t}\n-\n-      /* Add the edge taken when the control variable has value ARG.  */\n-      edge taken_edge = find_taken_edge ((*path)[0], arg);\n-      jump_thread_edge *x\n-\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-      jump_thread_path->safe_push (x);\n-\n-      register_jump_thread (jump_thread_path);\n-      --max_threaded_paths;\n-\n-      /* Remove BBI from the path.  */\n-      path->pop ();\n-    }\n-\n-  /* Remove all the nodes that we added from NEXT_PATH.  */\n-  if (next_path_length)\n-    vec_safe_truncate (path, (path->length () - next_path_length));\n-}\n-\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n@@ -1333,17 +1054,7 @@ thread_through_normal_block (edge e,\n       /* When COND cannot be simplified, try to find paths from a control\n \t statement back through the PHI nodes which would affect that control\n \t statement.  */\n-      vec<basic_block, va_gc> *bb_path;\n-      vec_alloc (bb_path, n_basic_blocks_for_fn (cfun));\n-      vec_safe_push (bb_path, e->dest);\n-      hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n-\n-      max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n-      fsm_find_control_statement_thread_paths (cond, visited_bbs, bb_path,\n-\t\t\t\t\t       false);\n-\n-      delete visited_bbs;\n-      vec_free (bb_path);\n+      find_jump_threads_backwards (cond, e->dest);\n     }\n   return 0;\n }"}]}