{"sha": "7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmY2Y1ZDYxMTc0ZGRhMWYzOWE2MjNlMTVmN2U1ZDZiOThiYmFmYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-08-20T19:59:00Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-08-20T19:59:00Z"}, "message": "configure: Also check C++11 (flags) for ${build} compiler not only for ${host}\n\nconfig/ChangeLog:\n\n\tPR bootstrap/96612\n\t* ax_cxx_compile_stdcxx.m4: Add fourth argument to check also\n\tthe CXX_FOR_BUILD compiler.\n\nChangeLog:\n\n\tPR bootstrap/96612\n\t* configure.ac: Run AX_CXX_COMPILE_STDCXX also for ${build} compiler,\n\tif not the same as ${host}.\n\t* configure: Regenerate.", "tree": {"sha": "5a4040f6ed10dc25d825c090cf2de953b80bd7be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a4040f6ed10dc25d825c090cf2de953b80bd7be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9ad288eb6fb366142b166e7985d16727b398e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9ad288eb6fb366142b166e7985d16727b398e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e9ad288eb6fb366142b166e7985d16727b398e1"}], "stats": {"total": 1050, "additions": 1039, "deletions": 11}, "files": [{"sha": "8c55ebd20442381c7307ce99d4c0ce7a79af73f7", "filename": "config/ax_cxx_compile_stdcxx.m4", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/config%2Fax_cxx_compile_stdcxx.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/config%2Fax_cxx_compile_stdcxx.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fax_cxx_compile_stdcxx.m4?ref=7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "patch": "@@ -25,6 +25,10 @@\n #   regardless, after defining HAVE_CXX${VERSION} if and only if a\n #   supporting mode is found.\n #\n+#   If the fourth argument is an optional CXX/CXXFLAG/CPPFLAG suffix, e.g.\n+#   \"_FOR_BUILD\" or \"_FOR_TARGET\".\n+#\n+#\n # LICENSE\n #\n #   Copyright (c) 2008 Benjamin Kosnik <bkoz@redhat.com>\n@@ -62,22 +66,28 @@ AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n         [m4_fatal([invalid third argument `$3' to AX_CXX_COMPILE_STDCXX])])\n   AC_LANG_PUSH([C++])dnl\n   ac_success=no\n-\n+  m4_ifnblank([$4], [dnl\n+    ax_cv_cxx_compile_cxx$1_orig_cxx=\"$CXX\"\n+    ax_cv_cxx_compile_cxx$1_orig_cxxflags=\"$CXXFLAGS\"\n+    ax_cv_cxx_compile_cxx$1_orig_cppflags=\"$CPPFLAGS\"\n+    CXX=\"$CXX$4\"\n+    CXXFLAGS=\"$CXXFLAGS$4\"\n+    CPPFLAGS=\"$CPPFLAGS$4\"])\n   m4_if([$2], [], [dnl\n     AC_CACHE_CHECK(whether $CXX supports C++$1 features by default,\n-\t\t   ax_cv_cxx_compile_cxx$1,\n+\t\t   ax_cv_cxx_compile_cxx$1$4,\n       [AC_COMPILE_IFELSE([AC_LANG_SOURCE([_AX_CXX_COMPILE_STDCXX_testbody_$1])],\n-        [ax_cv_cxx_compile_cxx$1=yes],\n-        [ax_cv_cxx_compile_cxx$1=no])])\n-    if test x$ax_cv_cxx_compile_cxx$1 = xyes; then\n+        [ax_cv_cxx_compile_cxx$1$4=yes],\n+        [ax_cv_cxx_compile_cxx$1$4=no])])\n+    if test x$ax_cv_cxx_compile_cxx$1$4 = xyes; then\n       ac_success=yes\n     fi])\n \n   m4_if([$2], [noext], [], [dnl\n   if test x$ac_success = xno; then\n     for alternative in ${ax_cxx_compile_alternatives}; do\n       switch=\"-std=gnu++${alternative}\"\n-      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+      cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1$4_$switch])\n       AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n                      $cachevar,\n         [ac_save_CXX=\"$CXX\"\n@@ -104,7 +114,7 @@ AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n     dnl Cray's crayCC needs \"-h std=c++11\"\n     for alternative in ${ax_cxx_compile_alternatives}; do\n       for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n-        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1_$switch])\n+        cachevar=AS_TR_SH([ax_cv_cxx_compile_cxx$1$4_$switch])\n         AC_CACHE_CHECK(whether $CXX supports C++$1 features with $switch,\n                        $cachevar,\n           [ac_save_CXX=\"$CXX\"\n@@ -127,21 +137,28 @@ AC_DEFUN([AX_CXX_COMPILE_STDCXX], [dnl\n       fi\n     done\n   fi])\n+  m4_ifnblank([$4], [dnl\n+    CXX$4=\"$CXX\"\n+    CXXFLAGS$4=\"$CXXFLAGS\"\n+    CPPFLAGS$4=\"$CPPFLAGS\"\n+    CXX=\"$ax_cv_cxx_compile_cxx$1_orig_cxx\"\n+    CXXFLAGS=\"$ax_cv_cxx_compile_cxx$1_orig_cxxflags\"\n+    CPPFLAGS=\"$ax_cv_cxx_compile_cxx$1_orig_cppflags\"])\n   AC_LANG_POP([C++])\n   if test x$ax_cxx_compile_cxx$1_required = xtrue; then\n     if test x$ac_success = xno; then\n       AC_MSG_ERROR([*** A compiler with support for C++$1 language features is required.])\n     fi\n   fi\n   if test x$ac_success = xno; then\n-    HAVE_CXX$1=0\n+    HAVE_CXX$1$4=0\n     AC_MSG_NOTICE([No compiler with C++$1 support was found])\n   else\n-    HAVE_CXX$1=1\n-    AC_DEFINE(HAVE_CXX$1,1,\n+    HAVE_CXX$1$4=1\n+    AC_DEFINE(HAVE_CXX$1$4,1,\n               [define if the compiler supports basic C++$1 syntax])\n   fi\n-  AC_SUBST(HAVE_CXX$1)\n+  AC_SUBST(HAVE_CXX$1$4)\n ])\n \n "}, {"sha": "057b88966e42edc5a3cc34fc2015fc0cb7de1a8a", "filename": "configure", "status": "modified", "additions": 1007, "deletions": 0, "changes": 1007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "patch": "@@ -694,6 +694,7 @@ extra_mpc_gmp_configure_flags\n extra_mpfr_configure_flags\n gmpinc\n gmplibs\n+HAVE_CXX11_FOR_BUILD\n HAVE_CXX11\n do_compare\n GNATMAKE\n@@ -6498,6 +6499,7 @@ $as_echo \"$ac_res\" >&6; }\n       fi\n     done\n   fi\n+\n   ac_ext=c\n ac_cpp='$CPP $CPPFLAGS'\n ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n@@ -6521,6 +6523,1011 @@ $as_echo \"#define HAVE_CXX11 1\" >>confdefs.h\n   fi\n \n \n+\n+  if test \"${build}\" != \"${host}\"; then\n+      ax_cxx_compile_alternatives=\"11 0x\"    ax_cxx_compile_cxx11_required=true\n+  ac_ext=cpp\n+ac_cpp='$CXXCPP $CPPFLAGS'\n+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n+  ac_success=no\n+      ax_cv_cxx_compile_cxx11_orig_cxx=\"$CXX\"\n+    ax_cv_cxx_compile_cxx11_orig_cxxflags=\"$CXXFLAGS\"\n+    ax_cv_cxx_compile_cxx11_orig_cppflags=\"$CPPFLAGS\"\n+    CXX=\"$CXX_FOR_BUILD\"\n+    CXXFLAGS=\"$CXXFLAGS_FOR_BUILD\"\n+    CPPFLAGS=\"$CPPFLAGS_FOR_BUILD\"\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features by default\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features by default... \" >&6; }\n+if ${ax_cv_cxx_compile_cxx11_FOR_BUILD+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  ax_cv_cxx_compile_cxx11_FOR_BUILD=yes\n+else\n+  ax_cv_cxx_compile_cxx11_FOR_BUILD=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_cxx_compile_cxx11_FOR_BUILD\" >&5\n+$as_echo \"$ax_cv_cxx_compile_cxx11_FOR_BUILD\" >&6; }\n+    if test x$ax_cv_cxx_compile_cxx11_FOR_BUILD = xyes; then\n+      ac_success=yes\n+    fi\n+\n+    if test x$ac_success = xno; then\n+    for alternative in ${ax_cxx_compile_alternatives}; do\n+      switch=\"-std=gnu++${alternative}\"\n+      cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_FOR_BUILD_$switch\" | $as_tr_sh`\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+         CXX=\"$CXX $switch\"\n+         cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+         CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+      if eval test x\\$$cachevar = xyes; then\n+        CXX=\"$CXX $switch\"\n+        if test -n \"$CXXCPP\" ; then\n+          CXXCPP=\"$CXXCPP $switch\"\n+        fi\n+        ac_success=yes\n+        break\n+      fi\n+    done\n+  fi\n+\n+    if test x$ac_success = xno; then\n+                for alternative in ${ax_cxx_compile_alternatives}; do\n+      for switch in -std=c++${alternative} +std=c++${alternative} \"-h std=c++${alternative}\"; do\n+        cachevar=`$as_echo \"ax_cv_cxx_compile_cxx11_FOR_BUILD_$switch\" | $as_tr_sh`\n+        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CXX supports C++11 features with $switch\" >&5\n+$as_echo_n \"checking whether $CXX supports C++11 features with $switch... \" >&6; }\n+if eval \\${$cachevar+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_save_CXX=\"$CXX\"\n+           CXX=\"$CXX $switch\"\n+           cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+\n+// If the compiler admits that it is not ready for C++11, why torture it?\n+// Hopefully, this will speed up the test.\n+\n+#ifndef __cplusplus\n+\n+#error \"This is not a C++ compiler\"\n+\n+#elif __cplusplus < 201103L\n+\n+#error \"This is not a C++11 compiler\"\n+\n+#else\n+\n+namespace cxx11\n+{\n+\n+  namespace test_static_assert\n+  {\n+\n+    template <typename T>\n+    struct check\n+    {\n+      static_assert(sizeof(int) <= sizeof(T), \"not big enough\");\n+    };\n+\n+  }\n+\n+  namespace test_final_override\n+  {\n+\n+    struct Base\n+    {\n+      virtual ~Base() {}\n+      virtual void f() {}\n+    };\n+\n+    struct Derived : public Base\n+    {\n+      virtual ~Derived() override {}\n+      virtual void f() override {}\n+    };\n+\n+  }\n+\n+  namespace test_double_right_angle_brackets\n+  {\n+\n+    template < typename T >\n+    struct check {};\n+\n+    typedef check<void> single_type;\n+    typedef check<check<void>> double_type;\n+    typedef check<check<check<void>>> triple_type;\n+    typedef check<check<check<check<void>>>> quadruple_type;\n+\n+  }\n+\n+  namespace test_decltype\n+  {\n+\n+    int\n+    f()\n+    {\n+      int a = 1;\n+      decltype(a) b = 2;\n+      return a + b;\n+    }\n+\n+  }\n+\n+  namespace test_type_deduction\n+  {\n+\n+    template < typename T1, typename T2 >\n+    struct is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+    template < typename T >\n+    struct is_same<T, T>\n+    {\n+      static const bool value = true;\n+    };\n+\n+    template < typename T1, typename T2 >\n+    auto\n+    add(T1 a1, T2 a2) -> decltype(a1 + a2)\n+    {\n+      return a1 + a2;\n+    }\n+\n+    int\n+    test(const int c, volatile int v)\n+    {\n+      static_assert(is_same<int, decltype(0)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(c)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(v)>::value == false, \"\");\n+      auto ac = c;\n+      auto av = v;\n+      auto sumi = ac + av + 'x';\n+      auto sumf = ac + av + 1.0;\n+      static_assert(is_same<int, decltype(ac)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(av)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumi)>::value == true, \"\");\n+      static_assert(is_same<int, decltype(sumf)>::value == false, \"\");\n+      static_assert(is_same<int, decltype(add(c, v))>::value == true, \"\");\n+      return (sumf > 0.0) ? sumi : add(c, v);\n+    }\n+\n+  }\n+\n+  namespace test_noexcept\n+  {\n+\n+    int f() { return 0; }\n+    int g() noexcept { return 0; }\n+\n+    static_assert(noexcept(f()) == false, \"\");\n+    static_assert(noexcept(g()) == true, \"\");\n+\n+  }\n+\n+  namespace test_constexpr\n+  {\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c_r(const CharT *const s, const unsigned long acc) noexcept\n+    {\n+      return *s ? strlen_c_r(s + 1, acc + 1) : acc;\n+    }\n+\n+    template < typename CharT >\n+    unsigned long constexpr\n+    strlen_c(const CharT *const s) noexcept\n+    {\n+      return strlen_c_r(s, 0UL);\n+    }\n+\n+    static_assert(strlen_c(\"\") == 0UL, \"\");\n+    static_assert(strlen_c(\"1\") == 1UL, \"\");\n+    static_assert(strlen_c(\"example\") == 7UL, \"\");\n+    static_assert(strlen_c(\"another\\0example\") == 7UL, \"\");\n+\n+  }\n+\n+  namespace test_rvalue_references\n+  {\n+\n+    template < int N >\n+    struct answer\n+    {\n+      static constexpr int value = N;\n+    };\n+\n+    answer<1> f(int&)       { return answer<1>(); }\n+    answer<2> f(const int&) { return answer<2>(); }\n+    answer<3> f(int&&)      { return answer<3>(); }\n+\n+    void\n+    test()\n+    {\n+      int i = 0;\n+      const int c = 0;\n+      static_assert(decltype(f(i))::value == 1, \"\");\n+      static_assert(decltype(f(c))::value == 2, \"\");\n+      static_assert(decltype(f(0))::value == 3, \"\");\n+    }\n+\n+  }\n+\n+  namespace test_uniform_initialization\n+  {\n+\n+    struct test\n+    {\n+      static const int zero {};\n+      static const int one {1};\n+    };\n+\n+    static_assert(test::zero == 0, \"\");\n+    static_assert(test::one == 1, \"\");\n+\n+  }\n+\n+  namespace test_lambdas\n+  {\n+\n+    void\n+    test1()\n+    {\n+      auto lambda1 = [](){};\n+      auto lambda2 = lambda1;\n+      lambda1();\n+      lambda2();\n+    }\n+\n+    int\n+    test2()\n+    {\n+      auto a = [](int i, int j){ return i + j; }(1, 2);\n+      auto b = []() -> int { return '0'; }();\n+      auto c = [=](){ return a + b; }();\n+      auto d = [&](){ return c; }();\n+      auto e = [a, &b](int x) mutable {\n+        const auto identity = [](int y){ return y; };\n+        for (auto i = 0; i < a; ++i)\n+          a += b--;\n+        return x + identity(a + b);\n+      }(0);\n+      return a + b + c + d + e;\n+    }\n+\n+    int\n+    test3()\n+    {\n+      const auto nullary = [](){ return 0; };\n+      const auto unary = [](int x){ return x; };\n+      using nullary_t = decltype(nullary);\n+      using unary_t = decltype(unary);\n+      const auto higher1st = [](nullary_t f){ return f(); };\n+      const auto higher2nd = [unary](nullary_t f1){\n+        return [unary, f1](unary_t f2){ return f2(unary(f1())); };\n+      };\n+      return higher1st(nullary) + higher2nd(nullary)(unary);\n+    }\n+\n+  }\n+\n+  namespace test_variadic_templates\n+  {\n+\n+    template <int...>\n+    struct sum;\n+\n+    template <int N0, int... N1toN>\n+    struct sum<N0, N1toN...>\n+    {\n+      static constexpr auto value = N0 + sum<N1toN...>::value;\n+    };\n+\n+    template <>\n+    struct sum<>\n+    {\n+      static constexpr auto value = 0;\n+    };\n+\n+    static_assert(sum<>::value == 0, \"\");\n+    static_assert(sum<1>::value == 1, \"\");\n+    static_assert(sum<23>::value == 23, \"\");\n+    static_assert(sum<1, 2>::value == 3, \"\");\n+    static_assert(sum<5, 5, 11>::value == 21, \"\");\n+    static_assert(sum<2, 3, 5, 7, 11, 13>::value == 41, \"\");\n+\n+  }\n+\n+  // http://stackoverflow.com/questions/13728184/template-aliases-and-sfinae\n+  // Clang 3.1 fails with headers of libstd++ 4.8.3 when using std::function\n+  // because of this.\n+  namespace test_template_alias_sfinae\n+  {\n+\n+    struct foo {};\n+\n+    template<typename T>\n+    using member = typename T::member_type;\n+\n+    template<typename T>\n+    void func(...) {}\n+\n+    template<typename T>\n+    void func(member<T>*) {}\n+\n+    void test();\n+\n+    void test() { func<foo>(0); }\n+\n+  }\n+\n+}  // namespace cxx11\n+\n+#endif  // __cplusplus >= 201103L\n+\n+\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  eval $cachevar=yes\n+else\n+  eval $cachevar=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+           CXX=\"$ac_save_CXX\"\n+fi\n+eval ac_res=\\$$cachevar\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+        if eval test x\\$$cachevar = xyes; then\n+          CXX=\"$CXX $switch\"\n+          if test -n \"$CXXCPP\" ; then\n+            CXXCPP=\"$CXXCPP $switch\"\n+          fi\n+          ac_success=yes\n+          break\n+        fi\n+      done\n+      if test x$ac_success = xyes; then\n+        break\n+      fi\n+    done\n+  fi\n+      CXX_FOR_BUILD=\"$CXX\"\n+    CXXFLAGS_FOR_BUILD=\"$CXXFLAGS\"\n+    CPPFLAGS_FOR_BUILD=\"$CPPFLAGS\"\n+    CXX=\"$ax_cv_cxx_compile_cxx11_orig_cxx\"\n+    CXXFLAGS=\"$ax_cv_cxx_compile_cxx11_orig_cxxflags\"\n+    CPPFLAGS=\"$ax_cv_cxx_compile_cxx11_orig_cppflags\"\n+  ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n+  if test x$ax_cxx_compile_cxx11_required = xtrue; then\n+    if test x$ac_success = xno; then\n+      as_fn_error $? \"*** A compiler with support for C++11 language features is required.\" \"$LINENO\" 5\n+    fi\n+  fi\n+  if test x$ac_success = xno; then\n+    HAVE_CXX11_FOR_BUILD=0\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: No compiler with C++11 support was found\" >&5\n+$as_echo \"$as_me: No compiler with C++11 support was found\" >&6;}\n+  else\n+    HAVE_CXX11_FOR_BUILD=1\n+\n+$as_echo \"#define HAVE_CXX11_FOR_BUILD 1\" >>confdefs.h\n+\n+  fi\n+\n+\n+  fi\n fi\n \n # Used for setting $lt_cv_objdir"}, {"sha": "392389fb2fb8097d08815259455ff2dc58b4daf3", "filename": "configure.ac", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=7ffcf5d61174dda1f39a623e15f7e5d6b98bbafc", "patch": "@@ -1470,6 +1470,10 @@ if test \"$enable_bootstrap:$GXX\" = \"yes:yes\"; then\n   CXX=\"$CXX -std=c++11\"\n elif test \"$have_compiler\" = yes; then\n   AX_CXX_COMPILE_STDCXX(11)\n+\n+  if test \"${build}\" != \"${host}\"; then\n+    AX_CXX_COMPILE_STDCXX(11, [], [], [_FOR_BUILD])\n+  fi\n fi\n \n # Used for setting $lt_cv_objdir"}]}