{"sha": "b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjN2EyNzhmNGRhY2U2ZDIzZWUwMjg1YmUxNmE4ZDQ2ZDc3ODliOQ==", "commit": {"author": {"name": "Konrad Trifunovic", "email": "konrad.trifunovic@gmail.com", "date": "2009-11-25T05:04:53Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T05:04:53Z"}, "message": "graphite-interchange.c (build_linearized_memory_access): Pass an offset as parameter.\n\n2009-10-14  Konrad Trifunovic  <konrad.trifunovic@gmail.com>\n\t    Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-interchange.c (build_linearized_memory_access): Pass an\n\toffset as parameter.\n\t(memory_stride_in_loop): Include transform scattering in the\n\taccess functions to be able to querry the strides in the\n\ttransformed loops.\n\t(pbb_interchange_loop_depths): Interchange the psct_dynamic_dim,\n\tnot the psct_iterator_dim.\n\nCo-Authored-By: Sebastian Pop <sebastian.pop@amd.com>\n\nFrom-SVN: r154583", "tree": {"sha": "a40ef1320d5259210425fb78ade3478ac8a8909c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a40ef1320d5259210425fb78ade3478ac8a8909c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c7a278f4dace6d23ee0285be16a8d46d7789b9/comments", "author": {"login": "ktrifuno", "id": 76754948, "node_id": "MDQ6VXNlcjc2NzU0OTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/76754948?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktrifuno", "html_url": "https://github.com/ktrifuno", "followers_url": "https://api.github.com/users/ktrifuno/followers", "following_url": "https://api.github.com/users/ktrifuno/following{/other_user}", "gists_url": "https://api.github.com/users/ktrifuno/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktrifuno/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktrifuno/subscriptions", "organizations_url": "https://api.github.com/users/ktrifuno/orgs", "repos_url": "https://api.github.com/users/ktrifuno/repos", "events_url": "https://api.github.com/users/ktrifuno/events{/privacy}", "received_events_url": "https://api.github.com/users/ktrifuno/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13ae6f9118afcaac53ff1ae97a37845a91b0203b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13ae6f9118afcaac53ff1ae97a37845a91b0203b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13ae6f9118afcaac53ff1ae97a37845a91b0203b"}], "stats": {"total": 246, "additions": 183, "deletions": 63}, "files": [{"sha": "6ec72e0df7455f3fe4a9c1d28de2f72f300b6cbb", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c7a278f4dace6d23ee0285be16a8d46d7789b9/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c7a278f4dace6d23ee0285be16a8d46d7789b9/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "patch": "@@ -1,3 +1,14 @@\n+2009-10-14  Konrad Trifunovic  <konrad.trifunovic@gmail.com>\n+\t    Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-interchange.c (build_linearized_memory_access): Pass an\n+\toffset as parameter.\n+\t(memory_stride_in_loop): Include transform scattering in the\n+\taccess functions to be able to querry the strides in the\n+\ttransformed loops.\n+\t(pbb_interchange_loop_depths): Interchange the psct_dynamic_dim,\n+\tnot the psct_iterator_dim.\n+\n 2009-10-14  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-blocking.c (pbb_do_strip_mine): Removed."}, {"sha": "cb703f27bdf76413e116c699645036e7c6ae5b22", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 172, "deletions": 63, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c7a278f4dace6d23ee0285be16a8d46d7789b9/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c7a278f4dace6d23ee0285be16a8d46d7789b9/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=b0c7a278f4dace6d23ee0285be16a8d46d7789b9", "patch": "@@ -60,18 +60,26 @@ along with GCC; see the file COPYING3.  If not see\n \n    For an array A[10][20] with two subscript locations s0 and s1, the\n    linear memory access is 20 * s0 + s1: a stride of 1 in subscript s0\n-   corresponds to a memory stride of 20.  */\n+   corresponds to a memory stride of 20.\n+\n+   OFFSET is a number of dimensions to prepend before the\n+   subscript dimensions: s_0, s_1, ..., s_n.\n+\n+   Thus, the final linear expression has the following format:\n+   0 .. 0_{offset} | 0 .. 0_{nit} | 0 .. 0_{gd} | 0 | c_0 c_1 ... c_n\n+   where the expression itself is:\n+   c_0 * s_0 + c_1 * s_1 + ... c_n * s_n.  */\n \n static ppl_Linear_Expression_t\n-build_linearized_memory_access (poly_dr_p pdr)\n+build_linearized_memory_access (ppl_dimension_type offset, poly_dr_p pdr)\n {\n   ppl_Linear_Expression_t res;\n   ppl_Linear_Expression_t le;\n   ppl_dimension_type i;\n   ppl_dimension_type first = pdr_subscript_dim (pdr, 0);\n   ppl_dimension_type last = pdr_subscript_dim (pdr, PDR_NB_SUBSCRIPTS (pdr));\n   Value size, sub_size;\n-  graphite_dim_t dim = pdr_dim (pdr);\n+  graphite_dim_t dim = offset + pdr_dim (pdr);\n \n   ppl_new_Linear_Expression_with_dimension (&res, dim);\n \n@@ -82,9 +90,9 @@ build_linearized_memory_access (poly_dr_p pdr)\n \n   for (i = last - 1; i >= first; i--)\n     {\n-      ppl_set_coef_gmp (res, i, size);\n+      ppl_set_coef_gmp (res, i + offset, size);\n \n-      ppl_new_Linear_Expression_with_dimension (&le, dim);\n+      ppl_new_Linear_Expression_with_dimension (&le, dim - offset);\n       ppl_set_coef (le, i, 1);\n       ppl_max_for_le_pointset (PDR_ACCESSES (pdr), le, sub_size);\n       value_multiply (size, size, sub_size);\n@@ -97,72 +105,169 @@ build_linearized_memory_access (poly_dr_p pdr)\n }\n \n /* Set STRIDE to the stride of PDR in memory by advancing by one in\n-   loop DEPTH.  */\n+   time dimension DEPTH.  */\n \n static void\n memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n {\n   ppl_Linear_Expression_t le, lma;\n   ppl_Constraint_t new_cstr;\n-  ppl_Pointset_Powerset_C_Polyhedron_t p1, p2;\n-  graphite_dim_t nb_subscripts = PDR_NB_SUBSCRIPTS (pdr);\n   ppl_dimension_type i, *map;\n-  ppl_dimension_type dim = pdr_dim (pdr);\n-  ppl_dimension_type dim_i = pdr_iterator_dim (pdr, depth);\n-  ppl_dimension_type dim_k = dim;\n-  ppl_dimension_type dim_L1 = dim + nb_subscripts + 1;\n-  ppl_dimension_type dim_L2 = dim + nb_subscripts + 2;\n-  ppl_dimension_type new_dim = dim + nb_subscripts + 3;\n-\n-  /* Add new dimensions to the polyhedron corresponding to\n-     k, s0', s1',..., L1, and L2.  These new variables are at\n-     dimensions dim, dim + 1,... of the polyhedron P1 respectively.  */\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&p1, PDR_ACCESSES (pdr));\n-  ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n-    (p1, nb_subscripts + 3);\n-\n-  lma = build_linearized_memory_access (pdr);\n-  ppl_set_coef (lma, dim_L1, -1);\n-  ppl_new_Constraint (&new_cstr, lma, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p1, new_cstr);\n-\n-  /* Build P2.  */\n-  ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n-    (&p2, p1);\n-  map = ppl_new_id_map (new_dim);\n-  ppl_interchange (map, dim_L1, dim_L2);\n-  ppl_interchange (map, dim_i, dim_k);\n-  for (i = 0; i < PDR_NB_SUBSCRIPTS (pdr); i++)\n-    ppl_interchange (map, pdr_subscript_dim (pdr, i), dim + i + 1);\n-  ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (p2, map, new_dim);\n-  free (map);\n-\n-  /* Add constraint k = i + 1.  */\n-  ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n-  ppl_set_coef (le, dim_i, 1);\n-  ppl_set_coef (le, dim_k, -1);\n-  ppl_set_inhomogeneous (le, 1);\n-  ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n-  ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n-  ppl_delete_Linear_Expression (le);\n-  ppl_delete_Constraint (new_cstr);\n+  ppl_Pointset_Powerset_C_Polyhedron_t p1, p2, sctr;\n+  graphite_dim_t nb_subscripts = PDR_NB_SUBSCRIPTS (pdr) + 1;\n+  poly_bb_p pbb = PDR_PBB (pdr);\n+  ppl_dimension_type offset = pbb_nb_scattering_transform (pbb)\n+                              + pbb_nb_local_vars (pbb)\n+                              + pbb_dim_iter_domain (pbb);\n+  ppl_dimension_type offsetg = offset + pbb_nb_params (pbb);\n+  ppl_dimension_type dim_sctr = pbb_nb_scattering_transform (pbb)\n+                                + pbb_nb_local_vars (pbb);\n+  ppl_dimension_type dim_L1 = offset + offsetg + 2 * nb_subscripts;\n+  ppl_dimension_type dim_L2 = offset + offsetg + 2 * nb_subscripts + 1;\n+  ppl_dimension_type new_dim = offset + offsetg + 2 * nb_subscripts + 2;\n+\n+  /* The resulting polyhedron should have the following format:\n+     T|I|T'|I'|G|S|S'|l1|l2\n+     where:\n+     | T = t_1..t_{dim_sctr}\n+     | I = i_1..i_{dim_iter_domain}\n+     | T'= t'_1..t'_{dim_sctr}\n+     | I'= i'_1..i'_{dim_iter_domain}\n+     | G = g_1..g_{nb_params}\n+     | S = s_1..s_{nb_subscripts}\n+     | S'= s'_1..s'_{nb_subscripts}\n+     | l1 and l2 are scalars.\n+\n+     Some invariants:\n+     offset = dim_sctr + dim_iter_domain + nb_local_vars\n+     offsetg = dim_sctr + dim_iter_domain + nb_local_vars + nb_params.  */\n+\n+  /* Construct the T|I|0|0|G|0|0|0|0 part.  */\n+  {\n+    ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron\n+      (&sctr, PBB_TRANSFORMED_SCATTERING (pbb));\n+    ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n+      (sctr, 2 * nb_subscripts + 2);\n+    ppl_insert_dimensions_pointset (sctr, offset, offset);\n+  }\n+\n+  /* Construct the 0|I|0|0|G|S|0|0|0 part.  */\n+  {\n+    ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+      (&p1, PDR_ACCESSES (pdr));\n+    ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed\n+      (p1, nb_subscripts + 2);\n+    ppl_insert_dimensions_pointset (p1, 0, dim_sctr);\n+    ppl_insert_dimensions_pointset (p1, offset, offset);\n+  }\n+\n+  /* Construct the 0|0|0|0|0|S|0|l1|0 part.  */\n+  {\n+    lma = build_linearized_memory_access (offset + dim_sctr, pdr);\n+    ppl_set_coef (lma, dim_L1, -1);\n+    ppl_new_Constraint (&new_cstr, lma, PPL_CONSTRAINT_TYPE_EQUAL);\n+    ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p1, new_cstr);\n+  }\n+\n+  /* Now intersect all the parts to get:\n+     T|I|0|0|G|0|0|0 |0\n+     0|I|0|0|G|S|0|0 |0\n+     0|0|0|0|0|S|0|l1|0\n+     ------------------\n+     T|I|0|0|G|S|0|l1|0.  */\n+\n+  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, sctr);\n+  ppl_delete_Pointset_Powerset_C_Polyhedron (sctr);\n+\n+  /* Build P2, which would have the following form:\n+     0|0|T'|I'|G|0|S'|0|l2\n+\n+     P2 is built, by remapping the P1 polyhedron:\n+     T|I|0|0|G|S|0|l1|0\n+\n+     using the following mapping:\n+     T->T'\n+     I->I'\n+     S->S'\n+     l1->l2.  */\n+  {\n+    ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron\n+      (&p2, p1);\n+\n+    map = ppl_new_id_map (new_dim);\n+\n+    /* T->T' and I->I'.  */\n+    for (i = 0; i < offset; i++)\n+      ppl_interchange (map, i, i + offset);\n+\n+    /* l1->l2.  */\n+    ppl_interchange (map, dim_L1, dim_L2);\n+\n+    /* S->S'.  */\n+    for (i = 0; i < nb_subscripts; i++)\n+      ppl_interchange (map, offset + offsetg + i,\n+\t\t       offset + offsetg + nb_subscripts + i);\n+\n+    ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (p2, map, new_dim);\n+    free (map);\n+  }\n+\n+  /* Add equalities:\n+     | t1 = t1'\n+     | ...\n+     | t_{depth-1} = t'_{depth-1}\n+     | t_{depth+1} = t'_{depth+1}\n+     | ...\n+     | t_{dim_sctr} = t'_{dim_sctr}\n+\n+     This means that all the time dimensions are equal except for\n+     depth, where we will add t_{depth} = t'_{depth} + 1 in the next\n+     step.  */\n+  for (i = 0; i < dim_sctr; i++)\n+    if (i != depth)\n+      {\n+        ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n+        ppl_set_coef (le, i, 1);\n+        ppl_set_coef (le, i + offset, -1);\n+        ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n+        ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n+        ppl_delete_Linear_Expression (le);\n+        ppl_delete_Constraint (new_cstr);\n+      }\n+\n+  /* Add equality : t_{depth} = t'_{depth} + 1.\n+     This is the core part of this alogrithm, since this\n+     constraint asks for the memory access stride (difference)\n+     between two consecutive points in time dimensions.  */\n+  {\n+    ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n+    ppl_set_coef (le, depth, 1);\n+    ppl_set_coef (le, depth + offset, -1);\n+    ppl_set_inhomogeneous (le, 1);\n+    ppl_new_Constraint (&new_cstr, le, PPL_CONSTRAINT_TYPE_EQUAL);\n+    ppl_Pointset_Powerset_C_Polyhedron_add_constraint (p2, new_cstr);\n+    ppl_delete_Linear_Expression (le);\n+    ppl_delete_Constraint (new_cstr);\n+  }\n \n   /* P1 = P1 inter P2.  */\n-  ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, p2);\n-  ppl_delete_Pointset_Powerset_C_Polyhedron (p2);\n+  {\n+    ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (p1, p2);\n+    ppl_delete_Pointset_Powerset_C_Polyhedron (p2);\n+  }\n \n   /* Maximise the expression L2 - L1.  */\n-  ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n-  ppl_set_coef (le, dim_L2, 1);\n-  ppl_set_coef (le, dim_L1, -1);\n-  ppl_max_for_le_pointset (p1, le, stride);\n-  ppl_delete_Linear_Expression (le);\n+  {\n+    ppl_new_Linear_Expression_with_dimension (&le, new_dim);\n+    ppl_set_coef (le, dim_L2, 1);\n+    ppl_set_coef (le, dim_L1, -1);\n+    ppl_max_for_le_pointset (p1, le, stride);\n+    ppl_delete_Linear_Expression (le);\n+  }\n }\n \n-\n-/* Returns true when it is profitable to interchange loop at DEPTH1\n-   and loop at DEPTH2 with DEPTH1 < DEPTH2 for PBB.\n+/* Returns true when it is profitable to interchange time dimensions DEPTH1\n+   and DEPTH2 with DEPTH1 < DEPTH2 for PBB.\n \n    Example:\n \n@@ -197,6 +302,9 @@ memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n    | i   j   N   a  s0  s1   1\n    | 0   0   0   0 100   1   0\n \n+   TODO: the shown format is not valid as it does not show the fact\n+   that the iteration domain \"i j\" is transformed using the scattering.\n+\n    Next, to measure the impact of iterating once in loop \"i\", we build\n    a maximization problem: first, we add to DR accesses the dimensions\n    k, s2, s3, L1 = 100 * s0 + s1, L2, and D1: polyhedron P1.\n@@ -212,7 +320,7 @@ memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n    | 0   0   0   0 100   1   0   0   0  -1   0   0   0    = 0  L1 = 100 * s0 + s1\n \n    Then, we generate the polyhedron P2 by interchanging the dimensions\n-   (s0, s2), (s1, s3), (L1, L2), (i0, i)\n+   (s0, s2), (s1, s3), (L1, L2), (k, i)\n \n    | i   j   N   a  s0  s1   k  s2  s3  L1  L2  D1   1\n    | 0   0   0   1   0   0   0   0   0   0   0   0  -5    = 0  alias = 5\n@@ -230,7 +338,7 @@ memory_stride_in_loop (Value stride, graphite_dim_t depth, poly_dr_p pdr)\n \n    and finally we maximize the expression \"D1 = max (P1 inter P2, L2 - L1)\".\n \n-   For determining the impact of one iteration on loop \"j\", we\n+   Similarly, to determine the impact of one iteration on loop \"j\", we\n    interchange (k, j), we add \"k = j + 1\", and we compute D2 the\n    maximal value of the difference.\n \n@@ -284,13 +392,14 @@ pbb_interchange_profitable_p (graphite_dim_t depth1, graphite_dim_t depth2,\n    scattering.  */\n \n static void\n-pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2, poly_bb_p pbb)\n+pbb_interchange_loop_depths (graphite_dim_t depth1, graphite_dim_t depth2,\n+\t\t\t     poly_bb_p pbb)\n {\n   ppl_dimension_type i, dim;\n   ppl_dimension_type *map;\n   ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-  ppl_dimension_type dim1 = psct_iterator_dim (pbb, depth1);\n-  ppl_dimension_type dim2 = psct_iterator_dim (pbb, depth2);\n+  ppl_dimension_type dim1 = psct_dynamic_dim (pbb, depth1);\n+  ppl_dimension_type dim2 = psct_dynamic_dim (pbb, depth2);\n \n   ppl_Polyhedron_space_dimension (poly, &dim);\n   map = (ppl_dimension_type *) XNEWVEC (ppl_dimension_type, dim);"}]}