{"sha": "e00560c2909f3f93686202e7fb11b77e2b868ca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAwNTYwYzI5MDlmM2Y5MzY4NjIwMmU3ZmIxMWI3N2UyYjg2OGNhMw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2011-10-17T22:50:29Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2011-10-17T22:50:29Z"}, "message": "Segregate sparc's handling of vector vs. non-vector modes.\n\ngcc/\n\t* config/sparc/sparc-modes.def: Add single entry vector modes for\n\tDImode and SImode.\n\t* config/sparc/sparc/sparc.md (V32, V32I, V64, V64I, V64N8): Delete\n\tmode iterators.\n\t(mov<V32:mode>): Revert back to plain SFmode pattern.\n\t(*movsf_insn): Likewise.\n\t(mov<V64:mode>): Revert back to plain DFmode pattern.\n\t(*movdf_insn_sp32): Likewise.\n\t(*movdf_insn_sp32_v9): Likewise.\n\t(*movdf_insn_sp64): Likewise.\n\t(V64 mode splitters) Likewise.\n\t(addsi3): Remove VIS alternatives.\n\t(subsi3): Likewise.\n\t(and<V64I:mode>3): Revert to DImode only pattern.\n\t(and<V64I:mode>3_sp32): Likewise.\n\t(*and<V64I:mode>3_sp64): Likewise.\n\t(and<V32I:mode>3): Likewise.\n\t(*and_not_<V64I:mode>_sp32): Likewise.\n\t(*and_not_<V64I:mode>_sp64): Likewise.\n\t(*and_not_<V32I:mode>): Likewise.\n\t(ior<V64I:mode>3): Likewise.\n\t(*ior<V64I:mode>3_sp32): Likewise.\n\t(*ior<V64I:mode>3_sp64): Likewise.\n\t(ior<V32I:mode>3): Likewise.\n\t(*or_not_<V64I:mode>_sp32): Likewise.\n\t(*or_not_<V64I:mode>_sp64): Likewise.\n\t(*or_not_<V32I:mode>): Likewise.\n\t(xor<V64I:mode>3): Likewise.\n\t(*xor<V64I:mode>3_sp32): Likewise.\n\t(*xor<V64I:mode>3_sp64): Likewise.\n\t(xor<V32I:mode>3): Likewise.\n\t(V64I mode splitters): Likewise.\n\t(*xor_not_<V64I:mode>_sp32): Likewise.\n\t(*xor_not_<V64I:mode>_sp64): Likewise.\n\t(*xor_not_<V32I:mode>): Likewise.\n\t(one_cmpl<V64I:mode>2): Likewise.\n\t(*one_cmpl<V64I:mode>2_sp32): Likewise.\n\t(*one_cmpl<V64I:mode>2_sp64): Likewise.\n\t(one_cmpl<V32I:mode>2): Likewise.\n\t(VM32, VM64, VMALL): New mode iterators.\n\t(vbits, vconstr, vfptype): New mode attributes.\n\t(mov<VMALL:mode>): New expander.\n\t(*mov<VM32:mode>_insn): New insn.\n\t(*mov<VM64:mode>_insn_sp64): New insn.\n\t(*mov<VM64:mode>_insn_sp32): New insn, and associated splitter\n\tspecifically for the register to memory case.\n\t(vec_init<mode>): New expander.\n\t(VADDSUB): New mode iterator.\n\t(<plusminus_insn>v2si3, <plusminus_insn>v2hi3): Remove and replace\n\twith...\n\t(<plusminus_insn><mode>3): New consolidated pattern.\n\t(VL): New mode iterator for logical operations.\n\t(vlsuf): New more attribute.\n\t(vlop): New code iterator.\n\t(vlinsn, vlninsn): New code attributes.\n\t(<code><mode>3): New insn to non-negated vector logical ops.\n\t(*not_<code><mode>3): Likewise for negated variants.\n\t(*nand<mode>_vis): New insn.\n\t(vlnotop): New code iterator.\n\t(*<code>_not1<mode>_vis, *<code>_not2<mode>_vis): New insns.\n\t(one_cmpl<mode>2): New insn.\n\t(faligndata<V64I:mode>_vis): Rewrite to use VM64 iterator.\n\t(bshuffle<VM64:mode>_vis): Likewise.\n\t(v<vis3_shift_patname><mode>3): Use GCM mode iterator.\n\t(fp<plusminus_insn>64_vis): Use V1DI mode.\n\t(VASS mode iterator): Use V1SI not SI mode.\n\t* config/sparc/sparc.c (sparc_vis_init_builtins): Account for\n\tsingle-entry vector mode changes.\n\t(sparc_expand_builtin): Likewise.\n\t(sparc_expand_vector_init): New function.\n\t* config/sparc/sparc-protos.h (sparc_expand_vector_init): Declare.\n\ngcc/testsuite/\n\n\t* gcc.target/sparc/fand.c: Remove __LP64__ ifdefs and expect\n\tall operations to emit VIS instructions.\n\t* gcc.target/sparc/fandnot.c: Likewise.\n\t* gcc.target/sparc/fnot.c: Likewise.\n\t* gcc.target/sparc/for.c: Likewise.\n\t* gcc.target/sparc/fornot.c: Likewise.\n\t* gcc.target/sparc/fxnor.c: Likewise.\n\t* gcc.target/sparc/fxor.c: Likewise.\n\t* gcc.target/sparc/combined-1.c: Revert change to use -O2, no longer\n\tneeded.\n\nFrom-SVN: r180112", "tree": {"sha": "935537253ce7934eced21eb18e0ede8798f478cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/935537253ce7934eced21eb18e0ede8798f478cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e00560c2909f3f93686202e7fb11b77e2b868ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e00560c2909f3f93686202e7fb11b77e2b868ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e00560c2909f3f93686202e7fb11b77e2b868ca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e00560c2909f3f93686202e7fb11b77e2b868ca3/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2c4e3157f1e6468a747758e75b0ed090536e1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c4e3157f1e6468a747758e75b0ed090536e1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c4e3157f1e6468a747758e75b0ed090536e1d0"}], "stats": {"total": 1032, "additions": 533, "deletions": 499}, "files": [{"sha": "1da0f369702821828b57b29f442de85ed770b20f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -1,3 +1,77 @@\n+2011-10-17  David S. Miller  <davem@davemloft.net>\n+\n+\t* config/sparc/sparc-modes.def: Add single entry vector modes for\n+\tDImode and SImode.\n+\t* config/sparc/sparc/sparc.md (V32, V32I, V64, V64I, V64N8): Delete\n+\tmode iterators.\n+\t(mov<V32:mode>): Revert back to plain SFmode pattern.\n+\t(*movsf_insn): Likewise.\n+\t(mov<V64:mode>): Revert back to plain DFmode pattern.\n+\t(*movdf_insn_sp32): Likewise.\n+\t(*movdf_insn_sp32_v9): Likewise.\n+\t(*movdf_insn_sp64): Likewise.\n+\t(V64 mode splitters) Likewise.\n+\t(addsi3): Remove VIS alternatives.\n+\t(subsi3): Likewise.\n+\t(and<V64I:mode>3): Revert to DImode only pattern.\n+\t(and<V64I:mode>3_sp32): Likewise.\n+\t(*and<V64I:mode>3_sp64): Likewise.\n+\t(and<V32I:mode>3): Likewise.\n+\t(*and_not_<V64I:mode>_sp32): Likewise.\n+\t(*and_not_<V64I:mode>_sp64): Likewise.\n+\t(*and_not_<V32I:mode>): Likewise.\n+\t(ior<V64I:mode>3): Likewise.\n+\t(*ior<V64I:mode>3_sp32): Likewise.\n+\t(*ior<V64I:mode>3_sp64): Likewise.\n+\t(ior<V32I:mode>3): Likewise.\n+\t(*or_not_<V64I:mode>_sp32): Likewise.\n+\t(*or_not_<V64I:mode>_sp64): Likewise.\n+\t(*or_not_<V32I:mode>): Likewise.\n+\t(xor<V64I:mode>3): Likewise.\n+\t(*xor<V64I:mode>3_sp32): Likewise.\n+\t(*xor<V64I:mode>3_sp64): Likewise.\n+\t(xor<V32I:mode>3): Likewise.\n+\t(V64I mode splitters): Likewise.\n+\t(*xor_not_<V64I:mode>_sp32): Likewise.\n+\t(*xor_not_<V64I:mode>_sp64): Likewise.\n+\t(*xor_not_<V32I:mode>): Likewise.\n+\t(one_cmpl<V64I:mode>2): Likewise.\n+\t(*one_cmpl<V64I:mode>2_sp32): Likewise.\n+\t(*one_cmpl<V64I:mode>2_sp64): Likewise.\n+\t(one_cmpl<V32I:mode>2): Likewise.\n+\t(VM32, VM64, VMALL): New mode iterators.\n+\t(vbits, vconstr, vfptype): New mode attributes.\n+\t(mov<VMALL:mode>): New expander.\n+\t(*mov<VM32:mode>_insn): New insn.\n+\t(*mov<VM64:mode>_insn_sp64): New insn.\n+\t(*mov<VM64:mode>_insn_sp32): New insn, and associated splitter\n+\tspecifically for the register to memory case.\n+\t(vec_init<mode>): New expander.\n+\t(VADDSUB): New mode iterator.\n+\t(<plusminus_insn>v2si3, <plusminus_insn>v2hi3): Remove and replace\n+\twith...\n+\t(<plusminus_insn><mode>3): New consolidated pattern.\n+\t(VL): New mode iterator for logical operations.\n+\t(vlsuf): New more attribute.\n+\t(vlop): New code iterator.\n+\t(vlinsn, vlninsn): New code attributes.\n+\t(<code><mode>3): New insn to non-negated vector logical ops.\n+\t(*not_<code><mode>3): Likewise for negated variants.\n+\t(*nand<mode>_vis): New insn.\n+\t(vlnotop): New code iterator.\n+\t(*<code>_not1<mode>_vis, *<code>_not2<mode>_vis): New insns.\n+\t(one_cmpl<mode>2): New insn.\n+\t(faligndata<V64I:mode>_vis): Rewrite to use VM64 iterator.\n+\t(bshuffle<VM64:mode>_vis): Likewise.\n+\t(v<vis3_shift_patname><mode>3): Use GCM mode iterator.\n+\t(fp<plusminus_insn>64_vis): Use V1DI mode.\n+\t(VASS mode iterator): Use V1SI not SI mode.\n+\t* config/sparc/sparc.c (sparc_vis_init_builtins): Account for\n+\tsingle-entry vector mode changes.\n+\t(sparc_expand_builtin): Likewise.\n+\t(sparc_expand_vector_init): New function.\n+\t* config/sparc/sparc-protos.h (sparc_expand_vector_init): Declare.\n+\n 2011-10-17  Kai Tietz  <ktietz@redhat.com>\n \n \t* fold-const.c (simple_operand_p_2): New function."}, {"sha": "a5849c984b14e2415c0b562b4934cb3ac39bbf25", "filename": "gcc/config/sparc/sparc-modes.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-modes.def?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -45,4 +45,6 @@ CC_MODE (CCFPE);\n /* Vector modes.  */\n VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n-VECTOR_MODES (INT, 4);        /*       V4QI V2HI */\n+VECTOR_MODES (INT, 4);        /*       V4QI V2HI      */\n+VECTOR_MODE (INT, DI, 1);     /*                 V1DI */\n+VECTOR_MODE (INT, SI, 1);     /*                 V1SI */"}, {"sha": "744747a34d29c19ceae4ea8a9189f3f4a75b386e", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -106,6 +106,7 @@ extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n+extern void sparc_expand_vector_init (rtx, rtx);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "b495690b0e6d2fa5fd342210acd075458085949c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -9403,7 +9403,7 @@ sparc_vis_init_builtins (void)\n \t       v8qi_ftype_v8qi_v8qi);\n   def_builtin (\"__builtin_vis_faligndatav2si\", CODE_FOR_faligndatav2si_vis,\n \t       v2si_ftype_v2si_v2si);\n-  def_builtin (\"__builtin_vis_faligndatadi\", CODE_FOR_faligndatadi_vis,\n+  def_builtin (\"__builtin_vis_faligndatadi\", CODE_FOR_faligndatav1di_vis,\n \t       di_ftype_di_di);\n \n   def_builtin (\"__builtin_vis_write_gsr\", CODE_FOR_wrgsr_vis,\n@@ -9539,15 +9539,15 @@ sparc_vis_init_builtins (void)\n \t\t     v2hi_ftype_v2hi_v2hi);\n   def_builtin_const (\"__builtin_vis_fpadd32\", CODE_FOR_addv2si3,\n \t\t     v2si_ftype_v2si_v2si);\n-  def_builtin_const (\"__builtin_vis_fpadd32s\", CODE_FOR_addsi3,\n+  def_builtin_const (\"__builtin_vis_fpadd32s\", CODE_FOR_addv1si3,\n \t\t     v1si_ftype_v1si_v1si);\n   def_builtin_const (\"__builtin_vis_fpsub16\", CODE_FOR_subv4hi3,\n \t\t     v4hi_ftype_v4hi_v4hi);\n   def_builtin_const (\"__builtin_vis_fpsub16s\", CODE_FOR_subv2hi3,\n \t\t     v2hi_ftype_v2hi_v2hi);\n   def_builtin_const (\"__builtin_vis_fpsub32\", CODE_FOR_subv2si3,\n \t\t     v2si_ftype_v2si_v2si);\n-  def_builtin_const (\"__builtin_vis_fpsub32s\", CODE_FOR_subsi3,\n+  def_builtin_const (\"__builtin_vis_fpsub32s\", CODE_FOR_subv1si3,\n \t\t     v1si_ftype_v1si_v1si);\n \n   /* Three-dimensional array addressing.  */\n@@ -9585,7 +9585,7 @@ sparc_vis_init_builtins (void)\n \t\t   v8qi_ftype_v8qi_v8qi);\n       def_builtin (\"__builtin_vis_bshufflev2si\", CODE_FOR_bshufflev2si_vis,\n \t\t   v2si_ftype_v2si_v2si);\n-      def_builtin (\"__builtin_vis_bshuffledi\", CODE_FOR_bshuffledi_vis,\n+      def_builtin (\"__builtin_vis_bshuffledi\", CODE_FOR_bshufflev1di_vis,\n \t\t   di_ftype_di_di);\n     }\n \n@@ -9654,11 +9654,11 @@ sparc_vis_init_builtins (void)\n \t\t\t v2hi_ftype_v2hi_v2hi);\n       def_builtin_const (\"__builtin_vis_fpadds32\", CODE_FOR_ssaddv2si3,\n \t\t\t v2si_ftype_v2si_v2si);\n-      def_builtin_const (\"__builtin_vis_fpadds32s\", CODE_FOR_ssaddsi3,\n+      def_builtin_const (\"__builtin_vis_fpadds32s\", CODE_FOR_ssaddv1si3,\n \t\t\t v1si_ftype_v1si_v1si);\n       def_builtin_const (\"__builtin_vis_fpsubs32\", CODE_FOR_sssubv2si3,\n \t\t\t v2si_ftype_v2si_v2si);\n-      def_builtin_const (\"__builtin_vis_fpsubs32s\", CODE_FOR_sssubsi3,\n+      def_builtin_const (\"__builtin_vis_fpsubs32s\", CODE_FOR_sssubv1si3,\n \t\t\t v1si_ftype_v1si_v1si);\n \n       if (TARGET_ARCH64)\n@@ -9748,6 +9748,13 @@ sparc_expand_builtin (tree exp, rtx target,\n       insn_op = &insn_data[icode].operand[idx];\n       op[arg_count] = expand_normal (arg);\n \n+      if (insn_op->mode == V1DImode\n+\t  && GET_MODE (op[arg_count]) == DImode)\n+\top[arg_count] = gen_lowpart (V1DImode, op[arg_count]);\n+      else if (insn_op->mode == V1SImode\n+\t  && GET_MODE (op[arg_count]) == SImode)\n+\top[arg_count] = gen_lowpart (V1SImode, op[arg_count]);\n+\n       if (! (*insn_data[icode].operand[idx].predicate) (op[arg_count],\n \t\t\t\t\t\t\tinsn_op->mode))\n \top[arg_count] = copy_to_mode_reg (insn_op->mode, op[arg_count]);\n@@ -11060,4 +11067,34 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n     }\n }\n \n+void\n+sparc_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode mode = GET_MODE (target);\n+  enum machine_mode inner_mode = GET_MODE_INNER (mode);\n+  int n_elts = GET_MODE_NUNITS (mode);\n+  int i, n_var = 0;\n+  rtx mem;\n+\n+  for (i = 0; i < n_elts; i++)\n+    {\n+      rtx x = XVECEXP (vals, 0, i);\n+      if (!CONSTANT_P (x))\n+\tn_var++;\n+    }\n+\n+  if (n_var == 0)\n+    {\n+      emit_move_insn (target, gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0)));\n+      return;\n+    }\n+\n+  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n+  for (i = 0; i < n_elts; i++)\n+    emit_move_insn (adjust_address_nv (mem, inner_mode,\n+\t\t\t\t    i * GET_MODE_SIZE (inner_mode)),\n+\t\t    XVECEXP (vals, 0, i));\n+  emit_move_insn (target, mem);\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "200245f6a40bde95bf69c6def91e33e1a914254f", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 391, "deletions": 393, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -200,24 +200,12 @@\n (define_mode_iterator I [QI HI SI DI])\n (define_mode_iterator F [SF DF TF])\n \n-;; We don't define V1SI because SI should work just fine.\n-(define_mode_iterator V32 [SF V2HI V4QI])\n-(define_mode_iterator V32I [SI V2HI V4QI])\n-\n-(define_mode_iterator V64 [DF V2SI V4HI V8QI])\n-(define_mode_iterator V64I [DI V2SI V4HI V8QI])\n-\n-(define_mode_iterator V64N8 [V2SI V4HI])\n-\n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n ;; a second register class, EXTRA_FP_REGS, exists for the v9 chip.  The name\n ;; is a bit of a misnomer as it covers all 64 fp regs.  The corresponding\n ;; constraint letter is 'e'.  To avoid any confusion, 'e' is used instead of\n ;; 'f' for all DF/TFmode values, including those that are specific to the v8.\n \n-(define_mode_attr vbits [(V2SI \"32\") (V4HI \"16\") (SI \"32s\") (V2HI \"16s\")])\n-(define_mode_attr vconstr [(V2SI \"e\") (V4HI \"e\") (SI \"f\") (V2HI \"f\")])\n-\n ;; Attribute for cpu type.\n ;; These must match the values for enum processor_type in sparc.h.\n (define_attr \"cpu\"\n@@ -1929,24 +1917,23 @@\n })\n \n \n-;; Floating point and vector move instructions\n+;; Floating point move instructions\n \n-;; Yes, you guessed it right, the former movsf expander.\n-(define_expand \"mov<V32:mode>\"\n-  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:V32 1 \"general_operand\" \"\"))]\n-  \"<V32:MODE>mode == SFmode || TARGET_VIS\"\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n {\n-  if (sparc_expand_move (<V32:MODE>mode, operands))\n+  if (sparc_expand_move (SFmode, operands))\n     DONE;\n })\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:V32 0 \"nonimmediate_operand\" \"=d,d,f,*r,*r,*r,f,*r,m,m\")\n-\t(match_operand:V32 1 \"input_operand\"        \"GY,ZC,f,*rRY,Q,S,m,m,f,*rGY\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=d, d,f,  *r,*r,*r,f,*r,m,   m\")\n+\t(match_operand:SF 1 \"input_operand\"        \"GY,ZC,f,*rRY, Q, S,m, m,f,*rGY\"))]\n   \"TARGET_FPU\n-   && (register_operand (operands[0], <V32:MODE>mode)\n-       || register_or_zero_or_all_ones_operand (operands[1], <V32:MODE>mode))\"\n+   && (register_operand (operands[0], SFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], SFmode))\"\n {\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       && (which_alternative == 3\n@@ -2067,20 +2054,19 @@\n   [(set (match_dup 0) (high:SF (match_dup 1)))\n    (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n \n-;; Yes, you again guessed it right, the former movdf expander.\n-(define_expand \"mov<V64:mode>\"\n-  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:V64 1 \"general_operand\" \"\"))]\n-  \"<V64:MODE>mode == DFmode || TARGET_VIS\"\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n {\n-  if (sparc_expand_move (<V64:MODE>mode, operands))\n+  if (sparc_expand_move (DFmode, operands))\n     DONE;\n })\n \n ;; Be careful, fmovd does not exist when !v9.\n (define_insn \"*movdf_insn_sp32\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,W,U,T,o,e,*r,o,e,o\")\n-\t(match_operand:DF 1 \"input_operand\"    \"W#F,e,T,U,G,e,*rFo,*r,o#F,e\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,W,U,T,o,e,  *r, o,  e,o\")\n+\t(match_operand:DF 1 \"input_operand\"       \"W#F,e,T,U,G,e,*rFo,*r,o#F,e\"))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n    && (register_operand (operands[0], DFmode)\n@@ -2117,13 +2103,13 @@\n \n ;; We have available v9 double floats but not 64-bit integer registers.\n (define_insn \"*movdf_insn_sp32_v9\"\n-  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,b,e,e,T,W,U,T,f,*r,o\")\n-        (match_operand:V64 1 \"input_operand\" \"GY,ZC,e,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,  e, T,W,U,T,  f,     *r,    o\")\n+        (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e,W#F,GY,e,T,U,o#F,*roGYDF,*rGYf\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n    && ! TARGET_ARCH64\n-   && (register_operand (operands[0], <V64:MODE>mode)\n-       || register_or_zero_or_all_ones_operand (operands[1], <V64:MODE>mode))\"\n+   && (register_operand (operands[0], DFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n   \"@\n   fzero\\t%0\n   fone\\t%0\n@@ -2159,12 +2145,12 @@\n \n ;; We have available both v9 double floats and 64-bit integer registers.\n (define_insn \"*movdf_insn_sp64\"\n-  [(set (match_operand:V64 0 \"nonimmediate_operand\" \"=b,b,e,e,W,*r,*r,m,*r\")\n-        (match_operand:V64 1 \"input_operand\"    \"GY,ZC,e,W#F,e,*rGY,m,*rGY,DF\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=b, b,e,  e,W,  *r,*r,   m,*r\")\n+        (match_operand:DF 1 \"input_operand\"        \"GY,ZC,e,W#F,e,*rGY, m,*rGY,DF\"))]\n   \"TARGET_FPU\n    && TARGET_ARCH64\n-   && (register_operand (operands[0], <V64:MODE>mode)\n-       || register_or_zero_or_all_ones_operand (operands[1], <V64:MODE>mode))\"\n+   && (register_operand (operands[0], DFmode)\n+       || register_or_zero_or_all_ones_operand (operands[1], DFmode))\"\n   \"@\n   fzero\\t%0\n   fone\\t%0\n@@ -2192,10 +2178,10 @@\n   stx\\t%r1, %0\"\n   [(set_attr \"type\" \"*,load,store\")])\n \n-;; This pattern builds V64mode constants in integer registers.\n+;; This pattern builds DFmode constants in integer registers.\n (define_split\n-  [(set (match_operand:V64 0 \"register_operand\" \"\")\n-        (match_operand:V64 1 \"const_double_or_vector_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_FPU\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\n@@ -2249,8 +2235,8 @@\n ;; careful when V9 but not ARCH64 because the integer\n ;; register DFmode cases must be handled.\n (define_split\n-  [(set (match_operand:V64 0 \"register_operand\" \"\")\n-        (match_operand:V64 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"register_operand\" \"\"))]\n   \"(! TARGET_V9\n     || (! TARGET_ARCH64\n         && ((GET_CODE (operands[0]) == REG\n@@ -2265,18 +2251,11 @@\n   rtx set_src = operands[1];\n   rtx dest1, dest2;\n   rtx src1, src2;\n-  enum machine_mode half_mode;\n \n-  /* We can be expanded for DFmode or integral vector modes.  */\n-  if (<V64:MODE>mode == DFmode)\n-    half_mode = SFmode;\n-  else\n-    half_mode = SImode;\n-  \n-  dest1 = gen_highpart (half_mode, set_dest);\n-  dest2 = gen_lowpart (half_mode, set_dest);\n-  src1 = gen_highpart (half_mode, set_src);\n-  src2 = gen_lowpart (half_mode, set_src);\n+  dest1 = gen_highpart (SFmode, set_dest);\n+  dest2 = gen_lowpart (SFmode, set_dest);\n+  src1 = gen_highpart (SFmode, set_src);\n+  src2 = gen_lowpart (SFmode, set_src);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n@@ -2294,97 +2273,76 @@\n })\n \n (define_split\n-  [(set (match_operand:V64 0 \"register_operand\" \"\")\n-\t(match_operand:V64 1 \"memory_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"memory_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && (((REGNO (operands[0]) % 2) != 0)\n        || ! mem_min_alignment (operands[1], 8))\n    && offsettable_memref_p (operands[1])\"\n   [(clobber (const_int 0))]\n {\n-  enum machine_mode half_mode;\n   rtx word0, word1;\n \n-  /* We can be expanded for DFmode or integral vector modes.  */\n-  if (<V64:MODE>mode == DFmode)\n-    half_mode = SFmode;\n-  else\n-    half_mode = SImode;\n-\n-  word0 = adjust_address (operands[1], half_mode, 0);\n-  word1 = adjust_address (operands[1], half_mode, 4);\n+  word0 = adjust_address (operands[1], SFmode, 0);\n+  word1 = adjust_address (operands[1], SFmode, 4);\n \n-  if (reg_overlap_mentioned_p (gen_highpart (half_mode, operands[0]), word1))\n+  if (reg_overlap_mentioned_p (gen_highpart (SFmode, operands[0]), word1))\n     {\n-      emit_move_insn_1 (gen_lowpart (half_mode, operands[0]), word1);\n-      emit_move_insn_1 (gen_highpart (half_mode, operands[0]), word0);\n+      emit_move_insn_1 (gen_lowpart (SFmode, operands[0]), word1);\n+      emit_move_insn_1 (gen_highpart (SFmode, operands[0]), word0);\n     }\n   else\n     {\n-      emit_move_insn_1 (gen_highpart (half_mode, operands[0]), word0);\n-      emit_move_insn_1 (gen_lowpart (half_mode, operands[0]), word1);\n+      emit_move_insn_1 (gen_highpart (SFmode, operands[0]), word0);\n+      emit_move_insn_1 (gen_lowpart (SFmode, operands[0]), word1);\n     }\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:V64 0 \"memory_operand\" \"\")\n-\t(match_operand:V64 1 \"register_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && (((REGNO (operands[1]) % 2) != 0)\n        || ! mem_min_alignment (operands[0], 8))\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  enum machine_mode half_mode;\n   rtx word0, word1;\n \n-  /* We can be expanded for DFmode or integral vector modes.  */\n-  if (<V64:MODE>mode == DFmode)\n-    half_mode = SFmode;\n-  else\n-    half_mode = SImode;\n-\n-  word0 = adjust_address (operands[0], half_mode, 0);\n-  word1 = adjust_address (operands[0], half_mode, 4);\n+  word0 = adjust_address (operands[0], SFmode, 0);\n+  word1 = adjust_address (operands[0], SFmode, 4);\n \n-  emit_move_insn_1 (word0, gen_highpart (half_mode, operands[1]));\n-  emit_move_insn_1 (word1, gen_lowpart (half_mode, operands[1]));\n+  emit_move_insn_1 (word0, gen_highpart (SFmode, operands[1]));\n+  emit_move_insn_1 (word1, gen_lowpart (SFmode, operands[1]));\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:V64 0 \"memory_operand\" \"\")\n-        (match_operand:V64 1 \"const_zero_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+        (match_operand:DF 1 \"const_zero_operand\" \"\"))]\n   \"reload_completed\n    && (! TARGET_V9\n        || (! TARGET_ARCH64\n \t   && ! mem_min_alignment (operands[0], 8)))\n    && offsettable_memref_p (operands[0])\"\n   [(clobber (const_int 0))]\n {\n-  enum machine_mode half_mode;\n   rtx dest1, dest2;\n \n-  /* We can be expanded for DFmode or integral vector modes.  */\n-  if (<V64:MODE>mode == DFmode)\n-    half_mode = SFmode;\n-  else\n-    half_mode = SImode;\n+  dest1 = adjust_address (operands[0], SFmode, 0);\n+  dest2 = adjust_address (operands[0], SFmode, 4);\n \n-  dest1 = adjust_address (operands[0], half_mode, 0);\n-  dest2 = adjust_address (operands[0], half_mode, 4);\n-\n-  emit_move_insn_1 (dest1, CONST0_RTX (half_mode));\n-  emit_move_insn_1 (dest2, CONST0_RTX (half_mode));\n+  emit_move_insn_1 (dest1, CONST0_RTX (SFmode));\n+  emit_move_insn_1 (dest2, CONST0_RTX (SFmode));\n   DONE;\n })\n \n (define_split\n-  [(set (match_operand:V64 0 \"register_operand\" \"\")\n-        (match_operand:V64 1 \"const_zero_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+        (match_operand:DF 1 \"const_zero_operand\" \"\"))]\n   \"reload_completed\n    && ! TARGET_ARCH64\n    && ((GET_CODE (operands[0]) == REG\n@@ -2394,20 +2352,13 @@\n \t   && REGNO (SUBREG_REG (operands[0])) < 32))\"\n   [(clobber (const_int 0))]\n {\n-  enum machine_mode half_mode;\n   rtx set_dest = operands[0];\n   rtx dest1, dest2;\n \n-  /* We can be expanded for DFmode or integral vector modes.  */\n-  if (<V64:MODE>mode == DFmode)\n-    half_mode = SFmode;\n-  else\n-    half_mode = SImode;\n-\n-  dest1 = gen_highpart (half_mode, set_dest);\n-  dest2 = gen_lowpart (half_mode, set_dest);\n-  emit_move_insn_1 (dest1, CONST0_RTX (half_mode));\n-  emit_move_insn_1 (dest2, CONST0_RTX (half_mode));\n+  dest1 = gen_highpart (SFmode, set_dest);\n+  dest2 = gen_lowpart (SFmode, set_dest);\n+  emit_move_insn_1 (dest1, CONST0_RTX (SFmode));\n+  emit_move_insn_1 (dest2, CONST0_RTX (SFmode));\n   DONE;\n })\n \n@@ -3751,16 +3702,15 @@\n    sub\\t%1, -%2, %0\")\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,d\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r,d\")\n-\t\t (match_operand:SI 2 \"arith_add_operand\" \"rI,O,d\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:SI 2 \"arith_add_operand\" \"rI,O\")))]\n   \"\"\n   \"@\n    add\\t%1, %2, %0\n-   sub\\t%1, -%2, %0\n-   fpadd32s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,*,fga\")\n-   (set_attr \"fptype\" \"*,*,single\")])\n+   sub\\t%1, -%2, %0\"\n+  [(set_attr \"type\" \"*,*\")\n+   (set_attr \"fptype\" \"*,*\")])\n \n (define_insn \"*cmp_cc_plus\"\n   [(set (reg:CC_NOOV CC_REG)\n@@ -3923,16 +3873,15 @@\n    add\\t%1, -%2, %0\")\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,d\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,r,d\")\n-\t\t  (match_operand:SI 2 \"arith_add_operand\" \"rI,O,d\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t  (match_operand:SI 2 \"arith_add_operand\" \"rI,O\")))]\n   \"\"\n   \"@\n    sub\\t%1, %2, %0\n-   add\\t%1, -%2, %0\n-   fpsub32s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,*,fga\")\n-   (set_attr \"fptype\" \"*,*,single\")])\n+   add\\t%1, -%2, %0\"\n+  [(set_attr \"type\" \"*,*\")\n+   (set_attr \"fptype\" \"*,*\")])\n \n (define_insn \"*cmp_minus_cc\"\n   [(set (reg:CC_NOOV CC_REG)\n@@ -4657,46 +4606,33 @@\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n-(define_expand \"and<V64I:mode>3\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n+(define_expand \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*and<V64I:mode>3_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(and:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*anddi3_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-  #\n-  fand\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*and<V64I:mode>3_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(and:V64I (match_operand:V64I 1 \"arith_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n+  \"#\")\n+\n+(define_insn \"*anddi3_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-   and\\t%1, %2, %0\n-   fand\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"and\\t%1, %2, %0\")\n \n-(define_insn \"and<V32I:mode>3\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(and:V32I (match_operand:V32I 1 \"arith_operand\" \"%r,d\")\n-\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"@\n-   and\\t%1, %2, %0\n-   fands\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"and\\t%1, %2, %0\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4710,14 +4646,12 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n-(define_insn_and_split \"*and_not_<V64I:mode>_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(and:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"%r,b\"))\n-\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*and_not_di_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-   #\n-   fandnot1\\t%1, %2, %0\"\n+  \"#\"\n   \"&& reload_completed\n    && ((GET_CODE (operands[0]) == REG\n         && REGNO (operands[0]) < 32)\n@@ -4732,72 +4666,50 @@\n    operands[6] = gen_lowpart (SImode, operands[0]);\n    operands[7] = gen_lowpart (SImode, operands[1]);\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*and_not_<V64I:mode>_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(and:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"%r,b\"))\n-\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*and_not_di_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-   andn\\t%2, %1, %0\n-   fandnot1\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"andn\\t%2, %1, %0\")\n \n-(define_insn \"*and_not_<V32I:mode>\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(and:V32I (not:V32I (match_operand:V32I 1 \"register_operand\" \"%r,d\"))\n-\t\t  (match_operand:V32I 2 \"register_operand\" \"r,d\")))]\n+(define_insn \"*and_not_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"%r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"@\n-   andn\\t%2, %1, %0\n-   fandnot1s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"andn\\t%2, %1, %0\")\n \n-(define_expand \"ior<V64I:mode>3\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n+(define_expand \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*ior<V64I:mode>3_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(ior:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*iordi3_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-  #\n-  for\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*ior<V64I:mode>3_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(ior:V64I (match_operand:V64I 1 \"arith_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n+  \"#\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*iordi3_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-  or\\t%1, %2, %0\n-  for\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"or\\t%1, %2, %0\")\n \n-(define_insn \"ior<V32I:mode>3\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(ior:V32I (match_operand:V32I 1 \"arith_operand\" \"%r,d\")\n-\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"@\n-   or\\t%1, %2, %0\n-   fors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"or\\t%1, %2, %0\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4811,14 +4723,12 @@\n   operands[4] = GEN_INT (~INTVAL (operands[2]));\n })\n \n-(define_insn_and_split \"*or_not_<V64I:mode>_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(ior:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\"))\n-\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*or_not_di_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-   #\n-   fornot1\\t%1, %2, %0\"\n+  \"#\"\n   \"&& reload_completed\n    && ((GET_CODE (operands[0]) == REG\n         && REGNO (operands[0]) < 32)\n@@ -4833,72 +4743,50 @@\n    operands[6] = gen_lowpart (SImode, operands[0]);\n    operands[7] = gen_lowpart (SImode, operands[1]);\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*or_not_<V64I:mode>_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(ior:V64I (not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\"))\n-\t\t  (match_operand:V64I 2 \"register_operand\" \"r,b\")))]\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*or_not_di_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-  orn\\t%2, %1, %0\n-  fornot1\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"orn\\t%2, %1, %0\")\n \n-(define_insn \"*or_not_<V32I:mode>\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(ior:V32I (not:V32I (match_operand:V32I 1 \"register_operand\" \"r,d\"))\n-\t\t  (match_operand:V32I 2 \"register_operand\" \"r,d\")))]\n+(define_insn \"*or_not_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"@\n-   orn\\t%2, %1, %0\n-   fornot1s\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"orn\\t%2, %1, %0\")\n \n-(define_expand \"xor<V64I:mode>3\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"\")))]\n+(define_expand \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*xor<V64I:mode>3_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(xor:V64I (match_operand:V64I 1 \"arith_double_operand\" \"%r,b\")\n-\t\t  (match_operand:V64I 2 \"arith_double_operand\" \"rHI,b\")))]\n+(define_insn \"*xordi3_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-  #\n-  fxor\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*xor<V64I:mode>3_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(xor:V64I (match_operand:V64I 1 \"arith_operand\" \"%rJ,b\")\n-\t\t  (match_operand:V64I 2 \"arith_operand\" \"rI,b\")))]\n+  \"#\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*xordi3_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"arith_operand\" \"%rJ\")\n+\t\t(match_operand:DI 2 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-  xor\\t%r1, %2, %0\n-  fxor\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"xor\\t%r1, %2, %0\")\n \n-(define_insn \"xor<V32I:mode>3\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(xor:V32I (match_operand:V32I 1 \"arith_operand\" \"%rJ,d\")\n-\t\t  (match_operand:V32I 2 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%rJ\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"@\n-   xor\\t%r1, %2, %0\n-   fxors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"xor\\t%r1, %2, %0\")\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4926,10 +4814,10 @@\n \n ;; Split DImode logical operations requiring two instructions.\n (define_split\n-  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(match_operator:V64I 1 \"cc_arith_operator\"\t; AND, IOR, XOR\n-\t\t\t   [(match_operand:V64I 2 \"register_operand\" \"\")\n-\t\t\t    (match_operand:V64I 3 \"arith_double_operand\" \"\")]))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operator:DI 1 \"cc_arith_operator\"\t; AND, IOR, XOR\n+\t\t\t   [(match_operand:DI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:DI 3 \"arith_double_operand\" \"\")]))]\n   \"! TARGET_ARCH64\n    && reload_completed\n    && ((GET_CODE (operands[0]) == REG\n@@ -4945,7 +4833,7 @@\n   operands[6] = gen_highpart (SImode, operands[2]);\n   operands[7] = gen_lowpart (SImode, operands[2]);\n #if HOST_BITS_PER_WIDE_INT == 32\n-  if (GET_CODE (operands[3]) == CONST_INT && <V64I:MODE>mode == DImode)\n+  if (GET_CODE (operands[3]) == CONST_INT)\n     {\n       if (INTVAL (operands[3]) < 0)\n \toperands[8] = constm1_rtx;\n@@ -4954,20 +4842,18 @@\n     }\n   else\n #endif\n-    operands[8] = gen_highpart_mode (SImode, <V64I:MODE>mode, operands[3]);\n+    operands[8] = gen_highpart_mode (SImode, DImode, operands[3]);\n   operands[9] = gen_lowpart (SImode, operands[3]);\n })\n \n ;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n ;; Combine now canonicalizes to the rightmost expression.\n-(define_insn_and_split \"*xor_not_<V64I:mode>_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (xor:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\")\n-\t\t\t    (match_operand:V64I 2 \"register_operand\" \"r,b\"))))]\n+(define_insn_and_split \"*xor_not_di_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t(match_operand:DI 2 \"register_operand\" \"r\"))))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-   #\n-   fxnor\\t%1, %2, %0\"\n+  \"#\"\n   \"&& reload_completed\n    && ((GET_CODE (operands[0]) == REG\n         && REGNO (operands[0]) < 32)\n@@ -4982,31 +4868,21 @@\n    operands[6] = gen_lowpart (SImode, operands[0]);\n    operands[7] = gen_lowpart (SImode, operands[1]);\n    operands[8] = gen_lowpart (SImode, operands[2]);\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n-\n-(define_insn \"*xor_not_<V64I:mode>_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (xor:V64I (match_operand:V64I 1 \"register_or_zero_operand\" \"rJ,b\")\n-\t\t\t    (match_operand:V64I 2 \"arith_operand\" \"rI,b\"))))]\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"*xor_not_di_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t(match_operand:DI 2 \"arith_operand\" \"rI\"))))]\n   \"TARGET_ARCH64\"\n-  \"@\n-  xnor\\t%r1, %2, %0\n-  fxnor\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"xnor\\t%r1, %2, %0\")\n \n-(define_insn \"*xor_not_<V32I:mode>\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(not:V32I (xor:V32I (match_operand:V32I 1 \"register_or_zero_operand\" \"rJ,d\")\n-\t\t\t    (match_operand:V32I 2 \"arith_operand\" \"rI,d\"))))]\n+(define_insn \"*xor_not_si\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"register_or_zero_operand\" \"rJ\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n   \"\"\n-  \"@\n-   xnor\\t%r1, %2, %0\n-   fxnors\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"xnor\\t%r1, %2, %0\")\n \n ;; These correspond to the above in the case where we also (or only)\n ;; want to set the condition code.  \n@@ -5244,19 +5120,17 @@\n \n ;; We cannot use the \"not\" pseudo insn because the Sun assembler\n ;; does not know how to make it work for constants.\n-(define_expand \"one_cmpl<V64I:mode>2\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"\")\n-\t(not:V64I (match_operand:V64I 1 \"register_operand\" \"\")))]\n+(define_expand \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn_and_split \"*one_cmpl<V64I:mode>2_sp32\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (match_operand:V64I 1 \"register_operand\" \"r,b\")))]\n+(define_insn_and_split \"*one_cmpldi2_sp32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"! TARGET_ARCH64\"\n-  \"@\n-   #\n-   fnot1\\t%1, %0\"\n+  \"#\"\n   \"&& reload_completed\n    && ((GET_CODE (operands[0]) == REG\n         && REGNO (operands[0]) < 32)\n@@ -5269,29 +5143,19 @@\n    operands[3] = gen_highpart (SImode, operands[1]);\n    operands[4] = gen_lowpart (SImode, operands[0]);\n    operands[5] = gen_lowpart (SImode, operands[1]);\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"length\" \"2,*\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  [(set_attr \"length\" \"2\")])\n \n-(define_insn \"*one_cmpl<V64I:mode>2_sp64\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=r,b\")\n-\t(not:V64I (match_operand:V64I 1 \"arith_operand\" \"rI,b\")))]\n+(define_insn \"*one_cmpldi2_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"arith_operand\" \"rI\")))]\n   \"TARGET_ARCH64\"\n-  \"@\n-   xnor\\t%%g0, %1, %0\n-   fnot1\\t%1, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,double\")])\n+  \"xnor\\t%%g0, %1, %0\")\n \n-(define_insn \"one_cmpl<V32I:mode>2\"\n-  [(set (match_operand:V32I 0 \"register_operand\" \"=r,d\")\n-\t(not:V32I (match_operand:V32I 1 \"arith_operand\" \"rI,d\")))]\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"@\n-  xnor\\t%%g0, %1, %0\n-  fnot1s\\t%1, %0\"\n-  [(set_attr \"type\" \"*,fga\")\n-   (set_attr \"fptype\" \"*,single\")])\n+  \"xnor\\t%%g0, %1, %0\")\n \n (define_insn \"*cmp_cc_not\"\n   [(set (reg:CC CC_REG)\n@@ -7883,59 +7747,193 @@\n \n ;; Vector instructions.\n \n+(define_mode_iterator VM32 [V1SI V2HI V4QI])\n+(define_mode_iterator VM64 [V1DI V2SI V4HI V8QI])\n+(define_mode_iterator VMALL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])\n+\n+(define_mode_attr vbits [(V2SI \"32\") (V4HI \"16\") (V1SI \"32s\") (V2HI \"16s\")])\n+(define_mode_attr vconstr [(V1SI \"f\") (V2HI \"f\") (V4QI \"f\")\n+\t\t\t   (V1DI \"e\") (V2SI \"e\") (V4HI \"e\") (V8QI \"e\")])\n+(define_mode_attr vfptype [(V1SI \"single\") (V2HI \"single\") (V4QI \"single\")\n+\t\t\t   (V1DI \"double\") (V2SI \"double\") (V4HI \"double\")\n+\t\t\t   (V8QI \"double\")])\n+\n+(define_expand \"mov<VMALL:mode>\"\n+  [(set (match_operand:VMALL 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:VMALL 1 \"general_operand\" \"\"))]\n+  \"TARGET_VIS\"\n+{\n+  if (sparc_expand_move (<VMALL:MODE>mode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*mov<VM32:mode>_insn\"\n+  [(set (match_operand:VM32 0 \"nonimmediate_operand\" \"=f, f,f,f,m, m,r,m, r, r\")\n+\t(match_operand:VM32 1 \"input_operand\"        \"GY,ZC,f,m,f,GY,m,r,GY,ZC\"))]\n+  \"TARGET_VIS\n+   && (register_operand (operands[0], <VM32:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM32:MODE>mode))\"\n+  \"@\n+  fzeros\\t%0\n+  fones\\t%0\n+  fsrc1s\\t%1, %0\n+  ld\\t%1, %0\n+  st\\t%1, %0\n+  st\\t%r1, %0\n+  ld\\t%1, %0\n+  st\\t%1, %0\n+  mov\\t0, %0\n+  mov\\t-1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*\")])\n+\n+(define_insn \"*mov<VM64:mode>_insn_sp64\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,r,m, r, r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,m,r,GY,ZC\"))]\n+  \"TARGET_VIS\n+   && TARGET_ARCH64\n+   && (register_operand (operands[0], <VM64:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fsrc1\\t%1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  stx\\t%r1, %0\n+  ldx\\t%1, %0\n+  stx\\t%1, %0\n+  mov\\t0, %0\n+  mov\\t-1, %0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*\")])\n+\n+(define_insn \"*mov<VM64:mode>_insn_sp32\"\n+  [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e, e,e,e,m, m,U,T,o, r, r\")\n+\t(match_operand:VM64 1 \"input_operand\"        \"GY,ZC,e,m,e,GY,T,U,r,GY,ZC\"))]\n+  \"TARGET_VIS\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], <VM64:MODE>mode)\n+       || register_or_zero_or_all_ones_operand (operands[1], <VM64:MODE>mode))\"\n+  \"@\n+  fzero\\t%0\n+  fone\\t%0\n+  fsrc1\\t%1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  stx\\t%r1, %0\n+  ldd\\t%1, %0\n+  std\\t%1, %0\n+  #\n+  mov 0, %L0; mov 0, %H0\n+  mov -1, %L0; mov -1, %H0\"\n+  [(set_attr \"type\" \"fga,fga,fga,fpload,fpstore,store,load,store,*,*,*\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,2,2,2\")])\n+\n+(define_split\n+  [(set (match_operand:VM64 0 \"memory_operand\" \"\")\n+        (match_operand:VM64 1 \"register_operand\" \"\"))]\n+  \"reload_completed\n+   && TARGET_VIS\n+   && ! TARGET_ARCH64\n+   && (((REGNO (operands[1]) % 2) != 0)\n+       || ! mem_min_alignment (operands[0], 8))\n+   && offsettable_memref_p (operands[0])\"\n+  [(clobber (const_int 0))]\n+{\n+  rtx word0, word1;\n+\n+  word0 = adjust_address (operands[0], SImode, 0);\n+  word1 = adjust_address (operands[0], SImode, 4);\n+\n+  emit_move_insn_1 (word0, gen_highpart (SImode, operands[1]));\n+  emit_move_insn_1 (word1, gen_lowpart (SImode, operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"vec_init<mode>\"\n+  [(match_operand:VMALL 0 \"register_operand\" \"\")\n+   (match_operand:VMALL 1 \"\" \"\")]\n+  \"TARGET_VIS\"\n+{\n+  sparc_expand_vector_init (operands[0], operands[1]);\n+  DONE;\n+})\n+\n (define_code_iterator plusminus [plus minus])\n (define_code_attr plusminus_insn [(plus \"add\") (minus \"sub\")])\n \n-;; fp{add,sub}32s are emitted by the {add,sub}si3 patterns.\n-(define_insn \"<plusminus_insn>v2si3\"\n-  [(set (match_operand:V2SI 0 \"register_operand\" \"=e\")\n-\t(plusminus:V2SI (match_operand:V2SI 1 \"register_operand\" \"e\")\n-\t\t\t(match_operand:V2SI 2 \"register_operand\" \"e\")))]\n+(define_mode_iterator VADDSUB [V1SI V2SI V2HI V4HI])\n+\n+(define_insn \"<plusminus_insn><mode>3\"\n+  [(set (match_operand:VADDSUB 0 \"register_operand\" \"=<vconstr>\")\n+\t(plusminus:VADDSUB (match_operand:VADDSUB 1 \"register_operand\" \"<vconstr>\")\n+\t\t\t   (match_operand:VADDSUB 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS\"\n-  \"fp<plusminus_insn>32\\t%1, %2, %0\"\n+  \"fp<plusminus_insn><vbits>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n+\n+(define_mode_iterator VL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])\n+(define_mode_attr vlsuf [(V1SI \"s\") (V2HI \"s\") (V4QI \"s\")\n+\t\t\t (V1DI  \"\") (V2SI  \"\") (V4HI  \"\") (V8QI \"\")])\n+(define_code_iterator vlop [ior and xor])\n+(define_code_attr vlinsn [(ior \"or\") (and \"and\") (xor \"xor\")])\n+(define_code_attr vlninsn [(ior \"nor\") (and \"nand\") (xor \"xnor\")])\n+\n+(define_insn \"<code><mode>3\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+\t(vlop:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\")\n+\t\t (match_operand:VL 2 \"register_operand\" \"<vconstr>\")))]\n+  \"TARGET_VIS\"\n+  \"f<vlinsn><vlsuf>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n-(define_insn \"<plusminus_insn>v4hi3\"\n-  [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n-\t(plusminus:V4HI (match_operand:V4HI 1 \"register_operand\" \"e\")\n-\t\t\t(match_operand:V4HI 2 \"register_operand\" \"e\")))]\n+(define_insn \"*not_<code><mode>3\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+        (not:VL (vlop:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\")\n+\t\t\t (match_operand:VL 2 \"register_operand\" \"<vconstr>\"))))]\n   \"TARGET_VIS\"\n-  \"fp<plusminus_insn>16\\t%1, %2, %0\"\n+  \"f<vlninsn><vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n-(define_insn \"<plusminus_insn>v2hi3\"\n-  [(set (match_operand:V2HI 0 \"register_operand\" \"=f\")\n-\t(plusminus:V2HI (match_operand:V2HI 1 \"register_operand\" \"f\")\n-\t\t\t(match_operand:V2HI 2 \"register_operand\" \"f\")))]\n+;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.\n+(define_insn \"*nand<mode>_vis\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+\t(ior:VL (not:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\"))\n+\t\t(not:VL (match_operand:VL 2 \"register_operand\" \"<vconstr>\"))))]\n   \"TARGET_VIS\"\n-  \"fp<plusminus_insn>16s\\t%1, %2, %0\"\n+  \"fnand<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"single\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n-;; All other logical instructions have integer equivalents so they\n-;; are defined together.\n+(define_code_iterator vlnotop [ior and])\n \n-;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.\n+(define_insn \"*<code>_not1<mode>_vis\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+\t(vlnotop:VL (not:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\"))\n+\t\t    (match_operand:VL 2 \"register_operand\" \"<vconstr>\")))]\n+  \"TARGET_VIS\"\n+  \"f<vlinsn>not1<vlsuf>\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n-(define_insn \"*nand<V64:mode>_vis\"\n-  [(set (match_operand:V64 0 \"register_operand\" \"=e\")\n-\t(ior:V64 (not:V64 (match_operand:V64 1 \"register_operand\" \"e\"))\n-\t\t (not:V64 (match_operand:V64 2 \"register_operand\" \"e\"))))]\n+(define_insn \"*<code>_not2<mode>_vis\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+\t(vlnotop:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\")\n+\t\t    (not:VL (match_operand:VL 2 \"register_operand\" \"<vconstr>\"))))]\n   \"TARGET_VIS\"\n-  \"fnand\\t%1, %2, %0\"\n+  \"f<vlinsn>not2<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n-(define_insn \"*nand<V32:mode>_vis\"\n-  [(set (match_operand:V32 0 \"register_operand\" \"=f\")\n-\t (ior:V32 (not:V32 (match_operand:V32 1 \"register_operand\" \"f\"))\n-\t\t  (not:V32 (match_operand:V32 2 \"register_operand\" \"f\"))))]\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n+\t(not:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS\"\n-  \"fnands\\t%1, %2, %0\"\n+  \"fnot1<vlsuf>\\t%1, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"single\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n ;; Hard to generate VIS instructions.  We have builtins for these.\n \n@@ -8152,10 +8150,10 @@\n ;; Using faligndata only makes sense after an alignaddr since the choice of\n ;; bytes to take out of each operand is dependent on the results of the last\n ;; alignaddr.\n-(define_insn \"faligndata<V64I:mode>_vis\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=e\")\n-        (unspec:V64I [(match_operand:V64I 1 \"register_operand\" \"e\")\n-                      (match_operand:V64I 2 \"register_operand\" \"e\")\n+(define_insn \"faligndata<VM64:mode>_vis\"\n+  [(set (match_operand:VM64 0 \"register_operand\" \"=e\")\n+        (unspec:VM64 [(match_operand:VM64 1 \"register_operand\" \"e\")\n+                      (match_operand:VM64 2 \"register_operand\" \"e\")\n                       (reg:DI GSR_REG)]\n          UNSPEC_ALIGNDATA))]\n   \"TARGET_VIS\"\n@@ -8341,10 +8339,10 @@\n   \"bmask\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"array\")])\n \n-(define_insn \"bshuffle<V64I:mode>_vis\"\n-  [(set (match_operand:V64I 0 \"register_operand\" \"=e\")\n-        (unspec:V64I [(match_operand:V64I 1 \"register_operand\" \"e\")\n-\t              (match_operand:V64I 2 \"register_operand\" \"e\")\n+(define_insn \"bshuffle<VM64:mode>_vis\"\n+  [(set (match_operand:VM64 0 \"register_operand\" \"=e\")\n+        (unspec:VM64 [(match_operand:VM64 1 \"register_operand\" \"e\")\n+\t              (match_operand:VM64 2 \"register_operand\" \"e\")\n \t\t      (reg:DI GSR_REG)]\n                      UNSPEC_BSHUFFLE))]\n   \"TARGET_VIS2\"\n@@ -8447,9 +8445,9 @@\n   [(ashift \"ashl\") (ss_ashift \"ssashl\") (lshiftrt \"lshr\") (ashiftrt \"ashr\")])\n    \n (define_insn \"v<vis3_shift_patname><mode>3\"\n-  [(set (match_operand:V64N8 0 \"register_operand\" \"=<vconstr>\")\n-        (vis3_shift:V64N8 (match_operand:V64N8 1 \"register_operand\" \"<vconstr>\")\n-                          (match_operand:V64N8 2 \"register_operand\" \"<vconstr>\")))]\n+  [(set (match_operand:GCM 0 \"register_operand\" \"=<vconstr>\")\n+\t(vis3_shift:GCM (match_operand:GCM 1 \"register_operand\" \"<vconstr>\")\n+\t\t\t(match_operand:GCM 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS3\"\n   \"<vis3_shift_insn><vbits>\\t%1, %2, %0\")\n \n@@ -8478,13 +8476,13 @@\n   \"fmean16\\t%1, %2, %0\")\n \n (define_insn \"fp<plusminus_insn>64_vis\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n-\t(plusminus:DI (match_operand:DI 1 \"register_operand\" \"e\")\n-\t\t      (match_operand:DI 2 \"register_operand\" \"e\")))]\n+  [(set (match_operand:V1DI 0 \"register_operand\" \"=e\")\n+\t(plusminus:V1DI (match_operand:V1DI 1 \"register_operand\" \"e\")\n+\t\t\t(match_operand:V1DI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS3\"\n   \"fp<plusminus_insn>64\\t%1, %2, %0\")\n \n-(define_mode_iterator VASS [V4HI V2SI V2HI SI])\n+(define_mode_iterator VASS [V4HI V2SI V2HI V1SI])\n (define_code_iterator vis3_addsub_ss [ss_plus ss_minus])\n (define_code_attr vis3_addsub_ss_insn\n   [(ss_plus \"fpadds\") (ss_minus \"fpsubs\")])"}, {"sha": "500c14264981e4d9024b887cb85deec64f8f40ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -1,3 +1,16 @@\n+2011-10-17  David S. Miller  <davem@davemloft.net>\n+\n+\t* gcc.target/sparc/fand.c: Remove __LP64__ ifdefs and expect\n+\tall operations to emit VIS instructions.\n+\t* gcc.target/sparc/fandnot.c: Likewise.\n+\t* gcc.target/sparc/fnot.c: Likewise.\n+\t* gcc.target/sparc/for.c: Likewise.\n+\t* gcc.target/sparc/fornot.c: Likewise.\n+\t* gcc.target/sparc/fxnor.c: Likewise.\n+\t* gcc.target/sparc/fxor.c: Likewise.\n+\t* gcc.target/sparc/combined-1.c: Revert change to use -O2, no longer\n+\tneeded.\n+\n 2011-10-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/vshuf-v16hi.c: New test."}, {"sha": "5f19db3b0b4915bdf3b0c25205773363cba26cdb", "filename": "gcc/testsuite/gcc.target/sparc/combined-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fcombined-1.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -mcpu=ultrasparc -mvis\" } */\n+/* { dg-options \"-O -mcpu=ultrasparc -mvis\" } */\n typedef short vec16 __attribute__((vector_size(8)));\n typedef int vec32 __attribute__((vector_size(8)));\n "}, {"sha": "b0589bdbb3c7aaa3f1f70e1f0d1f6e46a708851e", "filename": "gcc/testsuite/gcc.target/sparc/fand.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffand.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return foo1_8 () & foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return a & b;\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return foo1_16 () & foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return a & b;\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,12 +38,9 @@ vec32 fun32(void)\n   return foo1_32 () & foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return a & b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fand\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fand\\t%\" 6 } } */"}, {"sha": "005486385fad5a9b6f314b7c575905173fe456ac", "filename": "gcc/testsuite/gcc.target/sparc/fandnot.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffandnot.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return ~foo1_8 () & foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return ~a & b;\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return ~foo1_16 () & foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return ~a & b;\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,13 +38,10 @@ vec32 fun32(void)\n   return ~foo1_32 () & foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return ~a & b;\n }\n-#endif\n \n \n /* This should be transformed into ~b & a.  */\n@@ -59,38 +50,29 @@ vec8 fun8b(void)\n   return foo1_8 () & ~foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2b(vec8 a, vec8 b)\n {\n   return a & ~b;\n }\n-#endif\n \n vec16 fun16b(void)\n {\n   return foo1_16 () & ~foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2b(vec16 a, vec16 b)\n {\n   return a & ~b;\n }\n-#endif\n \n vec32 fun32b(void)\n {\n   return foo1_32 () & ~foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2b(vec32 a, vec32 b)\n {\n   return a & ~b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fandnot1\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-times \"fandnot1\\t%\" 12 } } */"}, {"sha": "c0ddc931fbb889315c0e98b0fbc70061c6746589", "filename": "gcc/testsuite/gcc.target/sparc/fnot.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffnot.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return ~foo1_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a)\n {\n   foo2_8 (~a);\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern void foo2_16(vec16);\n@@ -29,13 +26,10 @@ vec16 fun16(void)\n   return ~foo1_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a)\n {\n   foo2_16 (~a);\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern void foo2_32(vec32);\n@@ -45,12 +39,9 @@ vec32 fun32(void)\n   return ~foo1_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a)\n {\n   foo2_32 (~a);\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fnot1\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fnot1\\t%\" 6 } } */"}, {"sha": "3da4bc23771c3a443df928f63f3cddcb204f8c2b", "filename": "gcc/testsuite/gcc.target/sparc/for.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffor.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return foo1_8 () | foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return a | b;\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return foo1_16 () | foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return a | b;\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,12 +38,9 @@ vec32 fun32(void)\n   return foo1_32 () | foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return a | b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"for\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"for\\t%\" 6 } } */"}, {"sha": "2daa96e0a0972bbe8ed539d8850b0635ba272d49", "filename": "gcc/testsuite/gcc.target/sparc/fornot.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffornot.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return ~foo1_8 () | foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return ~a | b;\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return ~foo1_16 () | foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return ~a | b;\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,53 +38,40 @@ vec32 fun32(void)\n   return ~foo1_32 () | foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return ~a | b;\n }\n-#endif\n-\n \n /* This should be transformed into ~b | a.  */\n vec8 fun8b(void)\n {\n   return foo1_8 () | ~foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2b(vec8 a, vec8 b)\n {\n   return a | ~b;\n }\n-#endif\n \n vec16 fun16b(void)\n {\n   return foo1_16 () | ~foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2b(vec16 a, vec16 b)\n {\n   return a | ~b;\n }\n-#endif\n \n vec32 fun32b(void)\n {\n   return foo1_32 () | ~foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2b(vec32 a, vec32 b)\n {\n   return a | ~b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fornot1\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-times \"fornot1\\t%\" 12 } } */"}, {"sha": "e635d65fdc47ac5cf940ec77e4a30d31b62085ef", "filename": "gcc/testsuite/gcc.target/sparc/fxnor.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxnor.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return ~(foo1_8 () ^ foo2_8 ());\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return ~(a ^ b);\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return ~(foo1_16 () ^ foo2_16 ());\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return ~(a ^ b);\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,13 +38,10 @@ vec32 fun32(void)\n   return ~(foo1_32 () ^ foo2_32 ());\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return ~(a ^ b);\n }\n-#endif\n \n \n /* This should be transformed into ~(b ^ a).  */\n@@ -59,38 +50,29 @@ vec8 fun8b(void)\n   return foo1_8 () ^ ~foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2b(vec8 a, vec8 b)\n {\n   return a ^ ~b;\n }\n-#endif\n \n vec16 fun16b(void)\n {\n   return foo1_16 () ^ ~foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2b(vec16 a, vec16 b)\n {\n   return a ^ ~b;\n }\n-#endif\n \n vec32 fun32b(void)\n {\n   return foo1_32 () ^ ~foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2b(vec32 a, vec32 b)\n {\n   return a ^ ~b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fxnor\\t%\" 6 } } */\n+/* { dg-final { scan-assembler-times \"fxnor\\t%\" 12 } } */"}, {"sha": "6ca2f76a1eb93dd0f0f11ad71b981ccf5e291cfb", "filename": "gcc/testsuite/gcc.target/sparc/fxor.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e00560c2909f3f93686202e7fb11b77e2b868ca3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffxor.c?ref=e00560c2909f3f93686202e7fb11b77e2b868ca3", "patch": "@@ -12,13 +12,10 @@ vec8 fun8(void)\n   return foo1_8 () ^ foo2_8 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec8 fun8_2(vec8 a, vec8 b)\n {\n   return a ^ b;\n }\n-#endif\n \n extern vec16 foo1_16(void);\n extern vec16 foo2_16(void);\n@@ -28,13 +25,10 @@ vec16 fun16(void)\n   return foo1_16 () ^ foo2_16 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec16 fun16_2(vec16 a, vec16 b)\n {\n   return a ^ b;\n }\n-#endif\n \n extern vec32 foo1_32(void);\n extern vec32 foo2_32(void);\n@@ -44,12 +38,9 @@ vec32 fun32(void)\n   return foo1_32 () ^ foo2_32 ();\n }\n \n-#ifndef __LP64__\n-/* Test the 32-bit splitter. */\n vec32 fun32_2(vec32 a, vec32 b)\n {\n   return a ^ b;\n }\n-#endif\n \n-/* { dg-final { scan-assembler-times \"fxor\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"fxor\\t%\" 6 } } */"}]}