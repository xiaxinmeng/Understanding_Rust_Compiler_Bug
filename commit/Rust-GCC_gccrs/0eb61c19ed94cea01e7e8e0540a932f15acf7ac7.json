{"sha": "0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGViNjFjMTllZDk0Y2VhMDFlN2U4ZTA1NDBhOTMyZjE1YWNmN2FjNw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-07-28T16:39:07Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-07-28T16:39:07Z"}, "message": "expmed.c (store_split_bitfield): Fix handling of bitfields that cross word boundaries...\n\n* expmed.c (store_split_bitfield): Fix handling of bitfields that\n cross word boundaries, can only handle a word at a time.\n (extract_split_bitfield): Likewise.\n\nFrom-SVN: r5012", "tree": {"sha": "cfb77f12f945f5f3a3527c454e8ce0f681ddbf6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfb77f12f945f5f3a3527c454e8ce0f681ddbf6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7/comments", "author": null, "committer": null, "parents": [{"sha": "3ffeb92223535793cc6c7cca9ec9e5ba6534f79e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ffeb92223535793cc6c7cca9ec9e5ba6534f79e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ffeb92223535793cc6c7cca9ec9e5ba6534f79e"}], "stats": {"total": 32, "additions": 25, "deletions": 7}, "files": [{"sha": "ebbce4c9090aa114b1f6febf4a2d0283c7c013eb", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eb61c19ed94cea01e7e8e0540a932f15acf7ac7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0eb61c19ed94cea01e7e8e0540a932f15acf7ac7", "patch": "@@ -678,7 +678,9 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n      rtx value;\n      int align;\n {\n-  int unit = align * BITS_PER_UNIT;\n+  /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n+     much at a time.  */\n+  int unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n   rtx word;\n   int bitsdone = 0;\n \n@@ -699,7 +701,11 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n       offset = (bitpos + bitsdone) / unit;\n       thispos = (bitpos + bitsdone) % unit;\n \n-      thissize = unit - offset * BITS_PER_UNIT % unit;\n+      /* THISSIZE must not overrun a word boundary.  Otherwise,\n+\t store_fixed_bit_field will call us again, and we will mutually\n+\t recurse forever.  */\n+      thissize = MIN (bitsize - bitsdone, BITS_PER_WORD);\n+      thissize = MIN (thissize, unit - thispos);\n \n #if BYTES_BIG_ENDIAN\n       /* Fetch successively less significant portions.  */\n@@ -736,7 +742,10 @@ store_split_bit_field (op0, bitsize, bitpos, value, align)\n       if (word == 0)\n \tabort ();\n \n-      store_fixed_bit_field (word, offset, thissize, thispos, part, align);\n+      /* OFFSET is in UNITs, and UNIT is in bits.\n+         store_fixed_bit_field wants offset in bytes.  */\n+      store_fixed_bit_field (word, offset * unit / BITS_PER_UNIT,\n+\t\t\t     thissize, thispos, part, align);\n       bitsdone += thissize;\n     }\n }\n@@ -1434,7 +1443,9 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n      rtx op0;\n      int bitsize, bitpos, unsignedp, align;\n {\n-  int unit = align * BITS_PER_UNIT;\n+  /* Make sure UNIT isn't larger than BITS_PER_WORD, we can only handle that\n+     much at a time.  */\n+  int unit = MIN (align * BITS_PER_UNIT, BITS_PER_WORD);\n   int bitsdone = 0;\n   rtx result;\n   int first = 1;\n@@ -1449,7 +1460,11 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n       offset = (bitpos + bitsdone) / unit;\n       thispos = (bitpos + bitsdone) % unit;\n \n-      thissize = unit - offset * BITS_PER_UNIT % unit;\n+      /* THISSIZE must not overrun a word boundary.  Otherwise,\n+\t extract_fixed_bit_field will call us again, and we will mutually\n+\t recurse forever.  */\n+      thissize = MIN (bitsize - bitsdone, BITS_PER_WORD);\n+      thissize = MIN (thissize, unit - thispos);\n \n       /* If OP0 is a register, then handle OFFSET here.\n \t In the register case, UNIT must be a whole word.  */\n@@ -1465,8 +1480,11 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp, align)\n \tabort ();\n \n       /* Extract the parts in bit-counting order,\n-\t whose meaning is determined by BYTES_PER_UNIT.  */\n-      part = extract_fixed_bit_field (word_mode, word, offset,\n+\t whose meaning is determined by BYTES_PER_UNIT.\n+\t OFFSET is in UNITs, and UNIT is in bits.\n+\t extract_fixed_bit_field wants offset in bytes.  */\n+      part = extract_fixed_bit_field (word_mode, word,\n+\t\t\t\t      offset * unit / BITS_PER_UNIT,\n \t\t\t\t      thissize, thispos, 0, 1, align);\n       bitsdone += thissize;\n "}]}