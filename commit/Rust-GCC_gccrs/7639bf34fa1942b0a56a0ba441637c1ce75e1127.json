{"sha": "7639bf34fa1942b0a56a0ba441637c1ce75e1127", "node_id": "C_kwDOANBUbNoAKDc2MzliZjM0ZmExOTQyYjBhNTZhMGJhNDQxNjM3YzFjZTc1ZTExMjc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-14T14:31:44Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2023-04-14T14:31:44Z"}, "message": "libstdc++: Implement ranges::fold_* from P2322R6\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h: Include <optional> for C++23.\n\t(__cpp_lib_fold): Define for C++23.\n\t(in_value_result): Likewise.\n\t(__detail::__flipped): Likewise.\n\t(__detail::__indirectly_binary_left_foldable_impl): Likewise.\n\t(__detail::__indirectly_binary_left_foldable): Likewise.\n\t(___detail:__indirectly_binary_right_foldable): Likewise.\n\t(fold_left_with_iter_result): Likewise.\n\t(__fold_left_with_iter_fn, fold_left_with_iter): Likewise.\n\t(__fold_left_fn, fold_left): Likewise.\n\t(__fold_left_first_with_iter_fn, fold_left_first_with_iter):\n\tLikewise.\n\t(__fold_left_first_fn, fold_left_first): Likewise.\n\t(__fold_right_fn, fold_right): Likewise.\n\t(__fold_right_last_fn, fold_right_last): Likewise.\n\t* include/std/version (__cpp_lib_fold): Likewise.\n\t* testsuite/25_algorithms/fold_left/1.cc: New test.\n\t* testsuite/25_algorithms/fold_right/1.cc: New test.", "tree": {"sha": "446525a4386988796861386d82cb415ef532354d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/446525a4386988796861386d82cb415ef532354d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7639bf34fa1942b0a56a0ba441637c1ce75e1127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7639bf34fa1942b0a56a0ba441637c1ce75e1127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7639bf34fa1942b0a56a0ba441637c1ce75e1127", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7639bf34fa1942b0a56a0ba441637c1ce75e1127/comments", "author": null, "committer": null, "parents": [{"sha": "a87d95def0dcaad7a447e365d2f4a8edd9e00b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a87d95def0dcaad7a447e365d2f4a8edd9e00b02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a87d95def0dcaad7a447e365d2f4a8edd9e00b02"}], "stats": {"total": 370, "additions": 370, "deletions": 0}, "files": [{"sha": "f041ff16b0e4aec364b7dd7dd79ea0127fa6f876", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=7639bf34fa1942b0a56a0ba441637c1ce75e1127", "patch": "@@ -32,6 +32,9 @@\n \n #if __cplusplus > 201703L\n \n+#if __cplusplus > 202002L\n+#include <optional>\n+#endif\n #include <bits/ranges_algobase.h>\n #include <bits/ranges_util.h>\n #include <bits/uniform_int_dist.h> // concept uniform_random_bit_generator\n@@ -3691,6 +3694,254 @@ namespace ranges\n   };\n \n   inline constexpr __find_last_if_not_fn find_last_if_not{};\n+\n+#define __cpp_lib_fold 202207L\n+\n+  template<typename _Iter, typename _Tp>\n+    struct in_value_result\n+    {\n+      [[no_unique_address]] _Iter in;\n+      [[no_unique_address]] _Tp value;\n+\n+      template<typename _Iter2, typename _Tp2>\n+\trequires convertible_to<const _Iter&, _Iter2>\n+\t  && convertible_to<const _Tp&, _Tp2>\n+      constexpr\n+      operator in_value_result<_Iter2, _Tp2>() const &\n+      { return {in, value}; }\n+\n+      template<typename _Iter2, typename _Tp2>\n+\trequires convertible_to<_Iter, _Iter2>\n+\t  && convertible_to<_Tp, _Tp2>\n+      constexpr\n+      operator in_value_result<_Iter2, _Tp2>() &&\n+      { return {std::move(in), std::move(value)}; }\n+    };\n+\n+  namespace __detail\n+  {\n+    template<typename _Fp>\n+      class __flipped\n+      {\n+\t_Fp _M_f;\n+\n+      public:\n+\ttemplate<typename _Tp, typename _Up>\n+\t  requires invocable<_Fp&, _Up, _Tp>\n+\tinvoke_result_t<_Fp&, _Up, _Tp>\n+\toperator()(_Tp&&, _Up&&); // not defined\n+      };\n+\n+      template<typename _Fp, typename _Tp, typename _Iter, typename _Up>\n+      concept __indirectly_binary_left_foldable_impl = movable<_Tp> && movable<_Up>\n+\t&& convertible_to<_Tp, _Up>\n+\t&& invocable<_Fp&, _Up, iter_reference_t<_Iter>>\n+\t&& assignable_from<_Up&, invoke_result_t<_Fp&, _Up, iter_reference_t<_Iter>>>;\n+\n+      template<typename _Fp, typename _Tp, typename _Iter>\n+      concept __indirectly_binary_left_foldable = copy_constructible<_Fp>\n+\t&& indirectly_readable<_Iter>\n+\t&& invocable<_Fp&, _Tp, iter_reference_t<_Iter>>\n+\t&& convertible_to<invoke_result_t<_Fp&, _Tp, iter_reference_t<_Iter>>,\n+\t\t\t  decay_t<invoke_result_t<_Fp&, _Tp, iter_reference_t<_Iter>>>>\n+\t&& __indirectly_binary_left_foldable_impl\n+\t    <_Fp, _Tp, _Iter, decay_t<invoke_result_t<_Fp&, _Tp, iter_reference_t<_Iter>>>>;\n+\n+      template <typename _Fp, typename _Tp, typename _Iter>\n+      concept __indirectly_binary_right_foldable\n+\t= __indirectly_binary_left_foldable<__flipped<_Fp>, _Tp, _Iter>;\n+  } // namespace __detail\n+\n+  template<typename _Iter, typename _Tp>\n+    using fold_left_with_iter_result = in_value_result<_Iter, _Tp>;\n+\n+  struct __fold_left_with_iter_fn\n+  {\n+    template<typename _Ret_iter,\n+\t     typename _Iter, typename _Sent, typename _Tp, typename _Fp>\n+      static constexpr auto\n+      _S_impl(_Iter __first, _Sent __last, _Tp __init, _Fp __f)\n+      {\n+\tusing _Up = decay_t<invoke_result_t<_Fp&, _Tp, iter_reference_t<_Iter>>>;\n+\tusing _Ret = fold_left_with_iter_result<_Ret_iter, _Up>;\n+\n+\tif (__first == __last)\n+\t  return _Ret{std::move(__first), _Up(std::move(__init))};\n+\n+\t_Up __accum = std::__invoke(__f, std::move(__init), *__first);\n+\tfor (++__first; __first != __last; ++__first)\n+\t  __accum = std::__invoke(__f, std::move(__accum), *__first);\n+\treturn _Ret{std::move(__first), std::move(__accum)};\n+      }\n+\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n+\t     __detail::__indirectly_binary_left_foldable<_Tp, _Iter> _Fp>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Tp __init, _Fp __f) const\n+      {\n+\tusing _Ret_iter = _Iter;\n+\treturn _S_impl<_Ret_iter>(std::move(__first), __last,\n+\t\t\t\t  std::move(__init), std::move(__f));\n+      }\n+\n+    template<input_range _Range, typename _Tp,\n+\t     __detail::__indirectly_binary_left_foldable<_Tp, iterator_t<_Range>> _Fp>\n+      constexpr auto\n+      operator()(_Range&& __r, _Tp __init, _Fp __f) const\n+      {\n+\tusing _Ret_iter = borrowed_iterator_t<_Range>;\n+\treturn _S_impl<_Ret_iter>(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t  std::move(__init), std::move(__f));\n+      }\n+  };\n+\n+  inline constexpr __fold_left_with_iter_fn fold_left_with_iter{};\n+\n+  struct __fold_left_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n+\t     __detail::__indirectly_binary_left_foldable<_Tp, _Iter> _Fp>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Tp __init, _Fp __f) const\n+      {\n+\treturn ranges::fold_left_with_iter(std::move(__first), __last,\n+\t\t\t\t\t   std::move(__init), std::move(__f)).value;\n+      }\n+\n+    template<input_range _Range, typename _Tp,\n+\t     __detail::__indirectly_binary_left_foldable<_Tp, iterator_t<_Range>> _Fp>\n+      constexpr auto\n+      operator()(_Range&& __r, _Tp __init, _Fp __f) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__init), std::move(__f)); }\n+  };\n+\n+  inline constexpr __fold_left_fn fold_left{};\n+\n+  template<typename _Iter, typename _Tp>\n+    using fold_left_first_with_iter_result = in_value_result<_Iter, _Tp>;\n+\n+  struct __fold_left_first_with_iter_fn\n+  {\n+    template<typename _Ret_iter, typename _Iter, typename _Sent, typename _Fp>\n+      static constexpr auto\n+      _S_impl(_Iter __first, _Sent __last, _Fp __f)\n+      {\n+\tusing _Up = decltype(ranges::fold_left(std::move(__first), __last,\n+\t\t\t\t\t       iter_value_t<_Iter>(*__first), __f));\n+\tusing _Ret = fold_left_first_with_iter_result<_Ret_iter, optional<_Up>>;\n+\n+\tif (__first == __last)\n+\t  return _Ret{std::move(__first), optional<_Up>()};\n+\n+\toptional<_Up> __init(in_place, *__first);\n+\tfor (++__first; __first != __last; ++__first)\n+\t  *__init = std::__invoke(__f, std::move(*__init), *__first);\n+\treturn _Ret{std::move(__first), std::move(__init)};\n+      }\n+\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     __detail::__indirectly_binary_left_foldable<iter_value_t<_Iter>, _Iter> _Fp>\n+      requires constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Fp __f) const\n+      {\n+\tusing _Ret_iter = _Iter;\n+\treturn _S_impl<_Ret_iter>(std::move(__first), __last, std::move(__f));\n+      }\n+\n+    template<input_range _Range,\n+\t     __detail::__indirectly_binary_left_foldable<range_value_t<_Range>, iterator_t<_Range>> _Fp>\n+      requires constructible_from<range_value_t<_Range>, range_reference_t<_Range>>\n+      constexpr auto\n+      operator()(_Range&& __r, _Fp __f) const\n+      {\n+\tusing _Ret_iter = borrowed_iterator_t<_Range>;\n+\treturn _S_impl<_Ret_iter>(ranges::begin(__r), ranges::end(__r), std::move(__f));\n+      }\n+  };\n+\n+  inline constexpr __fold_left_first_with_iter_fn fold_left_first_with_iter{};\n+\n+  struct __fold_left_first_fn\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     __detail::__indirectly_binary_left_foldable<iter_value_t<_Iter>, _Iter> _Fp>\n+      requires constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Fp __f) const\n+      {\n+\treturn ranges::fold_left_first_with_iter(std::move(__first), __last,\n+\t\t\t\t\t\t std::move(__f)).value;\n+      }\n+\n+    template<input_range _Range,\n+\t     __detail::__indirectly_binary_left_foldable<range_value_t<_Range>, iterator_t<_Range>> _Fp>\n+      requires constructible_from<range_value_t<_Range>, range_reference_t<_Range>>\n+      constexpr auto\n+      operator()(_Range&& __r, _Fp __f) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__f)); }\n+  };\n+\n+  inline constexpr __fold_left_first_fn fold_left_first{};\n+\n+  struct __fold_right_fn\n+  {\n+    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,\n+\t     __detail::__indirectly_binary_right_foldable<_Tp, _Iter> _Fp>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Tp __init, _Fp __f) const\n+      {\n+\tusing _Up = decay_t<invoke_result_t<_Fp&, iter_reference_t<_Iter>, _Tp>>;\n+\n+\tif (__first == __last)\n+\t  return _Up(std::move(__init));\n+\n+\t_Iter __tail = ranges::next(__first, __last);\n+\t_Up __accum = std::__invoke(__f, *--__tail, std::move(__init));\n+\twhile (__first != __tail)\n+\t  __accum = std::__invoke(__f, *--__tail, std::move(__accum));\n+\treturn __accum;\n+      }\n+\n+    template<bidirectional_range _Range, typename _Tp,\n+\t     __detail::__indirectly_binary_right_foldable<_Tp, iterator_t<_Range>> _Fp>\n+      constexpr auto\n+      operator()(_Range&& __r, _Tp __init, _Fp __f) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__init), std::move(__f)); }\n+  };\n+\n+  inline constexpr __fold_right_fn fold_right{};\n+\n+  struct __fold_right_last_fn\n+  {\n+    template<bidirectional_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     __detail::__indirectly_binary_right_foldable<iter_value_t<_Iter>, _Iter> _Fp>\n+      requires constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>\n+      constexpr auto\n+      operator()(_Iter __first, _Sent __last, _Fp __f) const\n+      {\n+\tusing _Up = decltype(ranges::fold_right(__first, __last,\n+\t\t\t\t\t\titer_value_t<_Iter>(*__first), __f));\n+\n+\tif (__first == __last)\n+\t  return optional<_Up>();\n+\n+\t_Iter __tail = ranges::prev(ranges::next(__first, std::move(__last)));\n+\treturn optional<_Up>(in_place,\n+\t\t\t     ranges::fold_right(std::move(__first), __tail,\n+\t\t\t\t\t\titer_value_t<_Iter>(*__tail),\n+\t\t\t\t\t\tstd::move(__f)));\n+      }\n+\n+    template<bidirectional_range _Range,\n+\t     __detail::__indirectly_binary_right_foldable<range_value_t<_Range>, iterator_t<_Range>> _Fp>\n+      requires constructible_from<range_value_t<_Range>, range_reference_t<_Range>>\n+      constexpr auto\n+      operator()(_Range&& __r, _Fp __f) const\n+      { return (*this)(ranges::begin(__r), ranges::end(__r), std::move(__f)); }\n+  };\n+\n+  inline constexpr __fold_right_last_fn fold_right_last{};\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "d233b037d1a8044b907485cb8f135bdb862011b8", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=7639bf34fa1942b0a56a0ba441637c1ce75e1127", "patch": "@@ -340,6 +340,7 @@\n #define __cpp_lib_ranges_cartesian_product 202207L\n #define __cpp_lib_ranges_as_rvalue 202207L\n #define __cpp_lib_ranges_enumerate 202302L\n+#define __cpp_lib_fold 202207L\n #if __cpp_constexpr_dynamic_alloc\n # if _GLIBCXX_HOSTED\n #  define __cpp_lib_constexpr_bitset 202202L"}, {"sha": "5cc91b67d27dbb523692d9a9bc861b7551ebe0f6", "filename": "libstdc++-v3/testsuite/25_algorithms/fold_left/1.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_left%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_left%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_left%2F1.cc?ref=7639bf34fa1942b0a56a0ba441637c1ce75e1127", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_iterators.h>\n+\n+#if __cpp_lib_fold != 202207L\n+# error \"Feature-test macro __cpp_lib_fold has wrong value in <algorithm>\"\n+#endif\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  auto f = [](int&& acc, int& x) {\n+    return 2 * acc + x;\n+  };\n+  VERIFY( ranges::fold_left(x, 0, f) == 57 );\n+  VERIFY( ranges::fold_left(x, 1, f) == 89 );\n+  VERIFY( ranges::fold_left(x+0, x+0, 1, f) == 1 );\n+\n+  VERIFY( ranges::fold_left_first(x, f).value() == 57 );\n+  VERIFY( !ranges::fold_left_first(x+0, x+0, f).has_value() );\n+\n+  return true;\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  auto f = [](int&& acc, int& x) {\n+    return 2 * acc + x;\n+  };\n+\n+  __gnu_test::test_input_range<int> rx(x);\n+  ranges::in_value_result ivr = ranges::fold_left_with_iter(rx, 0, f);\n+  VERIFY( ivr.in == rx.end() );\n+  VERIFY( ivr.value == 57 );\n+\n+  rx.bounds.first = x;\n+  ranges::in_value_result ivr2 = ranges::fold_left_first_with_iter(rx, f);\n+  VERIFY( ivr2.in == rx.end() );\n+  VERIFY( ivr2.value.value() == 57 );\n+\n+  rx.bounds.first = x;\n+  auto v = rx | views::take(0);\n+  ranges::in_value_result ivr3 = ranges::fold_left_first_with_iter(v, f);\n+  VERIFY( ivr3.in == v.end() );\n+  VERIFY( !ivr3.value.has_value() );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  double x[] = {0.5, 0.25, 0.125, 0.125};\n+  VERIFY( ranges::fold_left(x, 0, std::plus{}) == 1.0 );\n+  VERIFY( ranges::fold_left_with_iter(x, 0, std::plus{}).value == 1.0 );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  test02();\n+  static_assert(test03());\n+}"}, {"sha": "b08b57c6364a0f7d96fa8911659d57091f0c3235", "filename": "libstdc++-v3/testsuite/25_algorithms/fold_right/1.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_right%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7639bf34fa1942b0a56a0ba441637c1ce75e1127/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_right%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffold_right%2F1.cc?ref=7639bf34fa1942b0a56a0ba441637c1ce75e1127", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  int x[] = {1, 2, 3, 4, 5};\n+  auto v = x | views::filter([](int) { return true; });\n+  static_assert( ranges::bidirectional_range<decltype(v)>\n+\t\t && !ranges::random_access_range<decltype(v)> );\n+  auto f = [](int& x, int&& acc) {\n+    return 2 * acc + x;\n+  };\n+  VERIFY( ranges::fold_right(v, 0, f) == 129 );\n+  VERIFY( ranges::fold_right(v, 1, f) == 161 );\n+  VERIFY( ranges::fold_right(v.begin(), v.begin(), 1, f) == 1 );\n+\n+  VERIFY( ranges::fold_right_last(v, f).value() == 129 );\n+  VERIFY( !ranges::fold_right_last(v.begin(), v.begin(), f).has_value() );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  double x[] = {0.5, 0.25, 0.125, 0.125};\n+  VERIFY( ranges::fold_right(x, 0, std::plus{}) == 1.0 );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+}"}]}