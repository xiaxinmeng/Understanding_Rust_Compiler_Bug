{"sha": "751312371e66c05a8d3b1cda949ec26aa9f1e548", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUxMzEyMzcxZTY2YzA1YThkM2IxY2RhOTQ5ZWMyNmFhOWYxZTU0OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-03-26T16:46:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-03-26T16:46:27Z"}, "message": "expmed.c (extract_bit_field): Ensure BITS_PER_WORD is signed in MAX.\n\n\t* expmed.c (extract_bit_field): Ensure BITS_PER_WORD is signed in MAX.\n\t* config/arm/pe.c (arm_pe_return_in_memory): Use host_integerp and\n\tint_bit_position.\n\t* config/mips/mips.c (function_arg): Likewise; also remove cast\n\tand make variables unsigned or HOST_WIDE_INT and use tree_low_cst.\n\t(mips_function_value): Use int_byte_position and make HOST_WIDE_INT.\n\t* config/mips/abi64.h (SETUP_INCOMING_VARARGS): Offsets are unsigned.\n\t* config/mips/mips.h (BITS_PER_WORD, UNITS_PER_WORD): Cast to unsigned.\n\t(UNITS_PER_FPREG, INT_TYPE_SIZE, LONG_TYPE_SIZE): Likewise.\n\t(POINTER_SIZE, POINTER_BOUNDARY,PARM_BOUNDARY): Likewise.\n\t(GP_REG_P, FP_REG_P, MD_REG_P, ST_REG_P): Ensure subtraction signed.\n\t(struct mips_arg): arg_number, arg_words, fp_arg_words, and\n\tnum_adjusts now unsigned.\n\t(FUNCTION_ARG_BOUNDARY): Remove unneeded cast.\n\t* config/sparc/sparc.c (struct function_arg_record_value_parms):\n\tNREGS now unsigned.\n\t(function_arg_record_value_1): STARTBITPOS arg now HOST_WIDE_INT\n\tas is BITPOS variable; use host_integerp and int_bit_position.\n\t(function_arg_record_value_2): Likewise.\n\t(function_arg_record_value_3): Arg BITPOS now HOST_WIDE_INT.\n\tVariable REGNO now unsigned.\n\t(function_arg_record_value): NREGS now unsigned.\n\nFrom-SVN: r32748", "tree": {"sha": "2840a32c312eb3ff24662683de802199984108de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2840a32c312eb3ff24662683de802199984108de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/751312371e66c05a8d3b1cda949ec26aa9f1e548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/751312371e66c05a8d3b1cda949ec26aa9f1e548", "html_url": "https://github.com/Rust-GCC/gccrs/commit/751312371e66c05a8d3b1cda949ec26aa9f1e548", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/751312371e66c05a8d3b1cda949ec26aa9f1e548/comments", "author": null, "committer": null, "parents": [{"sha": "210ee0dd95258398bfaefb33d320afd5f5e5c7ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210ee0dd95258398bfaefb33d320afd5f5e5c7ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210ee0dd95258398bfaefb33d320afd5f5e5c7ee"}], "stats": {"total": 182, "additions": 108, "deletions": 74}, "files": [{"sha": "e7331e7b87773a0ef6b7cb8f0527cbed56b140f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -1,7 +1,33 @@\n+Sun Mar 26 11:37:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expmed.c (extract_bit_field): Ensure BITS_PER_WORD is signed in MAX.\n+\t* config/arm/pe.c (arm_pe_return_in_memory): Use host_integerp and\n+\tint_bit_position.\n+\t* config/mips/mips.c (function_arg): Likewise; also remove cast\n+\tand make variables unsigned or HOST_WIDE_INT and use tree_low_cst.\n+\t(mips_function_value): Use int_byte_position and make HOST_WIDE_INT.\n+\t* config/mips/abi64.h (SETUP_INCOMING_VARARGS): Offsets are unsigned.\n+\t* config/mips/mips.h (BITS_PER_WORD, UNITS_PER_WORD): Cast to unsigned.\n+\t(UNITS_PER_FPREG, INT_TYPE_SIZE, LONG_TYPE_SIZE): Likewise.\n+\t(POINTER_SIZE, POINTER_BOUNDARY,PARM_BOUNDARY): Likewise.\n+\t(GP_REG_P, FP_REG_P, MD_REG_P, ST_REG_P): Ensure subtraction signed.\n+\t(struct mips_arg): arg_number, arg_words, fp_arg_words, and\n+\tnum_adjusts now unsigned.\n+\t(FUNCTION_ARG_BOUNDARY): Remove unneeded cast.\n+\t* config/sparc/sparc.c (struct function_arg_record_value_parms):\n+\tNREGS now unsigned.\n+\t(function_arg_record_value_1): STARTBITPOS arg now HOST_WIDE_INT\n+\tas is BITPOS variable; use host_integerp and int_bit_position.\n+\t(function_arg_record_value_2): Likewise.\n+\t(function_arg_record_value_3): Arg BITPOS now HOST_WIDE_INT.\n+\tVariable REGNO now unsigned.\n+\t(function_arg_record_value): NREGS now unsigned.\n+\n 2000-03-26  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* jump.c (mark_all_labels): Handle CALL_PLACEHOLDERs.\n \n+\n Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* Rework fields used to describe positions of bitfields and"}, {"sha": "80fdd048b31e59c1a99aab3f2ed03f689a5bbe1b", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -474,8 +474,10 @@ arm_pe_return_in_memory (type)\n \t  if (TREE_CODE (field) == FIELD_DECL\n \t      && ! TREE_STATIC (field)\n \t      && (! DECL_BIT_FIELD_TYPE (field)\n-\t\t  || (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n-\t\t      + TREE_INT_CST_LOW (DECL_SIZE (field))) > 32))\n+\t\t  || (host_integerp (DECL_SIZE (field), 1)\n+\t\t      && host_integerp (bit_position (field), 1)\n+\t\t      && 32 < (int_bit_position (field)\n+\t\t\t       + tree_low_cst (DECL_SIZE (field), 1)))))\n \t    return 1;\n \t}\n       return 0;"}, {"sha": "a8833466380bdafd6bc2035c0c5f973869b87467", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -105,19 +105,21 @@ extern struct rtx_def *mips_function_value PARAMS ((union tree_node *, union tre\n    For stdarg, we do not need to save the current argument, because it\n    is a real argument.  */\n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{ int mips_off = (! current_function_varargs) && (! (CUM).last_arg_fp);\t\\\n-  int mips_fp_off = (! current_function_varargs) && ((CUM).last_arg_fp); \\\n+{ unsigned int mips_off\t\t\t\t\t\t\t\\\n+    = (! current_function_varargs) && (! (CUM).last_arg_fp);\t\t\\\n+    unsigned int mips_fp_off\t\t\t\t\t\t\\\n+    = (! current_function_varargs) && ((CUM).last_arg_fp); \t\t\\\n   if (((mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t\\\n        && (CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\t\\\n       || (mips_abi == ABI_EABI\t\t\t\t\t\t\\\n \t  && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n \t  && (CUM).fp_arg_words < MAX_ARGS_IN_REGISTERS - mips_fp_off))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      int mips_save_gp_regs =\t\t\t\t\t\t\\\n-        MAX_ARGS_IN_REGISTERS - (CUM).arg_words - mips_off;\t\t\\\n-      int mips_save_fp_regs =\t\t\t\t\t\t\\\n-        (mips_abi != ABI_EABI ? 0\t\t\t\t\t\\\n-\t : MAX_ARGS_IN_REGISTERS - (CUM).fp_arg_words - mips_fp_off);\t\\\n+      int mips_save_gp_regs\t\t\t\t\t\t\\\n+        = MAX_ARGS_IN_REGISTERS - (CUM).arg_words - mips_off;\t\t\\\n+      int mips_save_fp_regs\t\t\t\t\t\t\\\n+        = (mips_abi != ABI_EABI ? 0\t\t\t\t\t\\\n+\t   : MAX_ARGS_IN_REGISTERS - (CUM).fp_arg_words - mips_fp_off);\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (mips_save_gp_regs < 0)\t\t\t\t\t\\\n \tmips_save_gp_regs = 0;\t\t\t\t\t\t\\"}, {"sha": "95f7f23fbbc4d5163f7b1f620c722cf983f6eb4f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -3801,7 +3801,7 @@ function_arg (cum, mode, type, named)\n \n       /* Drops through.  */\n     case BLKmode:\n-      if (type != (tree)0 && TYPE_ALIGN (type) > (unsigned) BITS_PER_WORD\n+      if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD\n \t  && ! TARGET_64BIT && mips_abi != ABI_EABI)\n \tcum->arg_words += (cum->arg_words & 1);\n       regbase = GP_ARG_FIRST;\n@@ -3833,7 +3833,8 @@ function_arg (cum, mode, type, named)\n \tabort ();\n \n       if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n-\t  || mips_abi == ABI_EABI || mips_abi == ABI_O64 || ! named)\n+\t  || mips_abi == ABI_EABI || mips_abi == ABI_O64 || ! named\n+\t  || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n \tret = gen_rtx_REG (mode, regbase + *arg_words + bias);\n       else\n \t{\n@@ -3847,8 +3848,8 @@ function_arg (cum, mode, type, named)\n \t    if (TREE_CODE (field) == FIELD_DECL\n \t\t&& TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t&& TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD\n-\t\t&& (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n-\t\t    % BITS_PER_WORD == 0))\n+\t\t&& host_integerp (bit_position (field), 0)\n+\t\t&& int_bit_position (field) % BITS_PER_WORD == 0)\n \t      break;\n \n \t  /* If the whole struct fits a DFmode register,\n@@ -3859,15 +3860,16 @@ function_arg (cum, mode, type, named)\n \t    {\n \t      /* Now handle the special case by returning a PARALLEL\n \t\t indicating where each 64 bit chunk goes.  */\n-\t      int chunks;\n-\t      int bitpos;\n-\t      int regno;\n+\t      unsigned int chunks;\n+\t      HOST_WIDE_INT bitpos;\n+\t      unsigned int regno;\n \t      int i;\n \n \t      /* ??? If this is a packed structure, then the last hunk won't\n \t\t be 64 bits.  */\n \n-\t      chunks = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_WORD;\n+\t      chunks\n+\t\t= tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n \t      if (chunks + *arg_words + bias > MAX_ARGS_IN_REGISTERS)\n \t\tchunks = MAX_ARGS_IN_REGISTERS - *arg_words - bias;\n \n@@ -3884,12 +3886,11 @@ function_arg (cum, mode, type, named)\n \n \t\t  for (; field; field = TREE_CHAIN (field))\n \t\t    if (TREE_CODE (field) == FIELD_DECL\n-\t\t\t&& (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field))\n-\t\t\t    >= bitpos))\n+\t\t\t&& int_bit_position (field) >= bitpos)\n \t\t      break;\n \n \t\t  if (field\n-\t\t      && TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)) == bitpos\n+\t\t      && int_bit_position (field) == bitpos\n \t\t      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t\t      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n \t\t    reg = gen_rtx_REG (DFmode,\n@@ -7417,24 +7418,20 @@ mips_function_value (valtype, func)\n \t\t= TYPE_MODE (TREE_TYPE (fields[0]));\n \t      enum machine_mode second_mode\n \t\t= TYPE_MODE (TREE_TYPE (fields[1]));\n-\t      int first_offset\n-\t\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (fields[0]));\n-\t      int second_offset\n-\t\t= TREE_INT_CST_LOW (DECL_FIELD_BITPOS (fields[1]));\n+\t      HOST_WIDE_INT first_offset = int_byte_position (fields[0]);\n+\t      HOST_WIDE_INT second_offset = int_byte_position (fields[1]);\n \n \t      return gen_rtx_PARALLEL\n \t\t(mode,\n \t\t gen_rtvec (2,\n \t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t       gen_rtx_REG (first_mode,\n \t\t\t\t\t\t\t    FP_RETURN),\n-\t\t\t\t\t       GEN_INT (first_offset\n-\t\t\t\t\t\t\t/ BITS_PER_UNIT)),\n+\t\t\t\t\t       GEN_INT (first_offset)),\n \t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t       gen_rtx_REG (second_mode,\n \t\t\t\t\t\t\t    FP_RETURN + 2),\n-\t\t\t\t\t       GEN_INT (second_offset\n-\t\t\t\t\t\t\t/ BITS_PER_UNIT))));\n+\t\t\t\t\t       GEN_INT (second_offset))));\n \t    }\n \t}\n     }"}, {"sha": "5e7039dc9924d1ff7e9cb3473114307c10f0bef5", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -1295,20 +1295,20 @@ do {\t\t\t\t\t\t\t\\\n    Note that this is not necessarily the width of data type `int';\n    if using 16-bit ints on a 68000, this would still be 32.\n    But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD (TARGET_64BIT ? 64 : 32)\n+#define BITS_PER_WORD ((unsigned int) (TARGET_64BIT ? 64 : 32))\n #define MAX_BITS_PER_WORD 64\n \n /* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD (TARGET_64BIT ? 8 : 4)\n+#define UNITS_PER_WORD ((unsigned int) (TARGET_64BIT ? 8 : 4))\n #define MIN_UNITS_PER_WORD 4\n \n /* For MIPS, width of a floating point register.  */\n-#define UNITS_PER_FPREG (TARGET_FLOAT64 ? 8 : 4)\n+#define UNITS_PER_FPREG ((unsigned int) (TARGET_FLOAT64 ? 8 : 4))\n \n /* A C expression for the size in bits of the type `int' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define INT_TYPE_SIZE (TARGET_INT64 ? 64 : 32)\n+#define INT_TYPE_SIZE ((unsigned int) (TARGET_INT64 ? 64 : 32))\n #define MAX_INT_TYPE_SIZE 64\n \n /* Tell the preprocessor the maximum size of wchar_t.  */\n@@ -1327,7 +1327,7 @@ do {\t\t\t\t\t\t\t\\\n /* A C expression for the size in bits of the type `long' on the\n    target machine.  If you don't define this, the default is one\n    word.  */\n-#define LONG_TYPE_SIZE (TARGET_LONG64 ? 64 : 32)\n+#define LONG_TYPE_SIZE ((unsigned int) (TARGET_LONG64 ? 64 : 32))\n #define MAX_LONG_TYPE_SIZE 64\n \n /* A C expression for the size in bits of the type `long long' on the\n@@ -1359,14 +1359,14 @@ do {\t\t\t\t\t\t\t\\\n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n #ifndef POINTER_SIZE\n-#define POINTER_SIZE (Pmode == DImode ? 64 : 32)\n+#define POINTER_SIZE ((unsigned int) (Pmode == DImode ? 64 : 32))\n #endif\n \n /* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY (Pmode == DImode ? 64 : 32)\n+#define POINTER_BOUNDARY ((unsigned int) (Pmode == DImode ? 64 : 32))\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY (TARGET_64BIT ? 64 : 32)\n+#define PARM_BOUNDARY ((unsigned int) (TARGET_64BIT ? 64 : 32))\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n@@ -1421,9 +1421,7 @@ do {\t\t\t\t\t\t\t\\\n \n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n   ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)\t\\\n-   && (ALIGN) < BITS_PER_WORD\t\t\t\t\t\t\\\n-\t? BITS_PER_WORD\t\t\t\t\t\t\t\\\n-\t: (ALIGN))\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n \n /* If defined, a C expression to compute the alignment for a static\n    variable.  TYPE is the data type, and ALIGN is the alignment that\n@@ -1582,12 +1580,16 @@ do {\t\t\t\t\t\t\t\\\n    should be used instead.  */\n #define FPSW_REGNUM\tST_REG_FIRST\n \n-#define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define GP_REG_P(REGNO)\t\\\n+  ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n #define M16_REG_P(REGNO) \\\n   (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 16 || (REGNO) == 17)\n-#define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n-#define MD_REG_P(REGNO) ((unsigned) ((REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n-#define ST_REG_P(REGNO) ((unsigned) ((REGNO) - ST_REG_FIRST) < ST_REG_NUM)\n+#define FP_REG_P(REGNO)  \\\n+  ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n+#define MD_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - MD_REG_FIRST) < MD_REG_NUM)\n+#define ST_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - ST_REG_FIRST) < ST_REG_NUM)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -2453,12 +2455,12 @@ extern struct mips_frame_info current_frame_info;\n \n typedef struct mips_args {\n   int gp_reg_found;\t\t/* whether a gp register was found yet */\n-  int arg_number;\t\t/* argument number */\n-  int arg_words;\t\t/* # total words the arguments take */\n-  int fp_arg_words;\t\t/* # words for FP args (MIPS_EABI only) */\n+  unsigned int arg_number;\t/* argument number */\n+  unsigned int arg_words;\t/* # total words the arguments take */\n+  unsigned int fp_arg_words;\t/* # words for FP args (MIPS_EABI only) */\n   int last_arg_fp;\t\t/* nonzero if last arg was FP (EABI only) */\n   int fp_code;\t\t\t/* Mode of FP arguments (mips16) */\n-  int num_adjusts;\t\t/* number of adjustments made */\n+  unsigned int num_adjusts;\t/* number of adjustments made */\n \t\t\t\t/* Adjustments made to args pass in regs.  */\n \t\t\t\t/* ??? The size is doubled to work around a \n \t\t\t\t   bug in the code that sets the adjustments\n@@ -2511,7 +2513,7 @@ typedef struct mips_args {\n \n #define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n   (((TYPE) != 0)\t\t\t\t\t\t\t\\\n-\t? ((TYPE_ALIGN(TYPE) <= (unsigned)PARM_BOUNDARY)\t\t\\\n+\t? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n \t\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n \t\t: TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n \t: ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\t\\"}, {"sha": "85a3d70f38e372dfb603caf359b342e36e8a086c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -4057,22 +4057,25 @@ struct function_arg_record_value_parms\n {\n   rtx ret;\n   int slotno, named, regbase;\n-  int nregs, intoffset;\n+  unsigned int nregs;\n+  int intoffset;\n };\n \n static void function_arg_record_value_3\n-\tPARAMS ((int, struct function_arg_record_value_parms *));\n+\tPARAMS ((HOST_WIDE_INT, struct function_arg_record_value_parms *));\n static void function_arg_record_value_2\n-\tPARAMS ((tree, int, struct function_arg_record_value_parms *));\n+\tPARAMS ((tree, HOST_WIDE_INT,\n+\t\t struct function_arg_record_value_parms *));\n static void function_arg_record_value_1\n-        PARAMS ((tree, int, struct function_arg_record_value_parms *));\n+        PARAMS ((tree, HOST_WIDE_INT,\n+\t\t struct function_arg_record_value_parms *));\n static rtx function_arg_record_value\n \tPARAMS ((tree, enum machine_mode, int, int, int));\n \n static void\n function_arg_record_value_1 (type, startbitpos, parms)\n      tree type;\n-     int startbitpos;\n+     HOST_WIDE_INT startbitpos;\n      struct function_arg_record_value_parms *parms;\n {\n   tree field;\n@@ -4100,15 +4103,16 @@ function_arg_record_value_1 (type, startbitpos, parms)\n     {\n       if (TREE_CODE (field) == FIELD_DECL)\n \t{\n-\t  int bitpos = startbitpos;\n-\t  if (DECL_FIELD_BITPOS (field))\n-\t    bitpos += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  HOST_WIDE_INT bitpos = startbitpos;\n+\n+\t  if (DECL_SIZE (field) != 0\n+\t      && host_integerp (bit_position (field), 1))\n+\t    bitpos += int_bit_position (field);\n+\n \t  /* ??? FIXME: else assume zero offset.  */\n \n \t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    {\n-\t      function_arg_record_value_1 (TREE_TYPE (field), bitpos, parms);\n-\t    }\n+\t    function_arg_record_value_1 (TREE_TYPE (field), bitpos, parms);\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t           && TARGET_FPU\n \t           && ! packed_p\n@@ -4146,15 +4150,17 @@ function_arg_record_value_1 (type, startbitpos, parms)\n \n static void \n function_arg_record_value_3 (bitpos, parms)\n-     int bitpos;\n+     HOST_WIDE_INT bitpos;\n      struct function_arg_record_value_parms *parms;\n {\n   enum machine_mode mode;\n-  int regno, this_slotno, intslots, intoffset;\n+  unsigned int regno;\n+  int this_slotno, intslots, intoffset;\n   rtx reg;\n \n   if (parms->intoffset == -1)\n     return;\n+\n   intoffset = parms->intoffset;\n   parms->intoffset = -1;\n \n@@ -4171,10 +4177,8 @@ function_arg_record_value_3 (bitpos, parms)\n      at the moment but may wish to revisit.  */\n \n   if (intoffset % BITS_PER_WORD != 0)\n-    {\n-      mode = mode_for_size (BITS_PER_WORD - intoffset%BITS_PER_WORD,\n-\t\t\t    MODE_INT, 0);\n-    }\n+    mode = mode_for_size (BITS_PER_WORD - intoffset % BITS_PER_WORD,\n+\t\t\t  MODE_INT, 0);\n   else\n     mode = word_mode;\n \n@@ -4197,7 +4201,7 @@ function_arg_record_value_3 (bitpos, parms)\n static void\n function_arg_record_value_2 (type, startbitpos, parms)\n      tree type;\n-     int startbitpos;\n+     HOST_WIDE_INT startbitpos;\n      struct function_arg_record_value_parms *parms;\n {\n   tree field;\n@@ -4216,15 +4220,16 @@ function_arg_record_value_2 (type, startbitpos, parms)\n     {\n       if (TREE_CODE (field) == FIELD_DECL)\n \t{\n-\t  int bitpos = startbitpos;\n-\t  if (DECL_FIELD_BITPOS (field))\n-\t    bitpos += TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field));\n+\t  HOST_WIDE_INT bitpos = startbitpos;\n+\n+\t  if (DECL_SIZE (field) != 0\n+\t      && host_integerp (bit_position (field), 1))\n+\t    bitpos += int_bit_position (field);\n+\n \t  /* ??? FIXME: else assume zero offset.  */\n \n \t  if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)\n-\t    {\n-\t      function_arg_record_value_2 (TREE_TYPE (field), bitpos, parms);\n-\t    }\n+\t    function_arg_record_value_2 (TREE_TYPE (field), bitpos, parms);\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n \t           && TARGET_FPU\n \t           && ! packed_p\n@@ -4261,7 +4266,7 @@ function_arg_record_value (type, mode, slotno, named, regbase)\n {\n   HOST_WIDE_INT typesize = int_size_in_bytes (type);\n   struct function_arg_record_value_parms parms;\n-  int nregs;\n+  unsigned int nregs;\n \n   parms.ret = NULL_RTX;\n   parms.slotno = slotno;"}, {"sha": "25f19581c2dccabde7a94080392aecb2d352a254", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/751312371e66c05a8d3b1cda949ec26aa9f1e548/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=751312371e66c05a8d3b1cda949ec26aa9f1e548", "patch": "@@ -1138,7 +1138,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  /* Offset from start of field in OP0.  */\n \t  unsigned int bit_offset = (WORDS_BIG_ENDIAN\n \t\t\t\t     ? MAX (0, ((int) bitsize - ((int) i + 1)\n-\t\t\t\t\t\t* BITS_PER_WORD))\n+\t\t\t\t\t\t* (int) BITS_PER_WORD))\n \t\t\t\t     : (int) i * BITS_PER_WORD);\n \t  rtx target_part = operand_subword (target, wordnum, 1, VOIDmode);\n \t  rtx result_part"}]}