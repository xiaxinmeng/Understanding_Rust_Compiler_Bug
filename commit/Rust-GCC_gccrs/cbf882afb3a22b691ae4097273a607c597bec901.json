{"sha": "cbf882afb3a22b691ae4097273a607c597bec901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmODgyYWZiM2EyMmI2OTFhZTQwOTcyNzNhNjA3YzU5N2JlYzkwMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-10T15:05:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-12-10T15:05:29Z"}, "message": "(start_enum): Use push_obstacks, not end_temporary_allocation.\n\n(finish_enum): Call pop_obstacks.\n\nFrom-SVN: r24243", "tree": {"sha": "034ebabd8c62d37fd81fbbd0960bf8432859a05c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/034ebabd8c62d37fd81fbbd0960bf8432859a05c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbf882afb3a22b691ae4097273a607c597bec901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf882afb3a22b691ae4097273a607c597bec901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf882afb3a22b691ae4097273a607c597bec901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf882afb3a22b691ae4097273a607c597bec901/comments", "author": null, "committer": null, "parents": [{"sha": "513e9d13b4619d6ee88fce6f59d24962951e6f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513e9d13b4619d6ee88fce6f59d24962951e6f71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/513e9d13b4619d6ee88fce6f59d24962951e6f71"}], "stats": {"total": 97, "additions": 45, "deletions": 52}, "files": [{"sha": "c278875d8c71fe6145e22392cce1b9d0e432901c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 45, "deletions": 52, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf882afb3a22b691ae4097273a607c597bec901/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf882afb3a22b691ae4097273a607c597bec901/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cbf882afb3a22b691ae4097273a607c597bec901", "patch": "@@ -12205,11 +12205,7 @@ start_enum (name)\n \n   /* We are wasting space here and putting these on the permanent_obstack so\n      that typeid(local enum) will work correctly. */\n-#if 0\n-  if (processing_template_decl && current_function_decl)\n-#endif\n-   \n-  end_temporary_allocation ();\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n@@ -12311,61 +12307,58 @@ finish_enum (enumtype)\n     {\n       tree scope = current_scope ();\n       if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-\t{\n-\t  add_tree (build_min (TAG_DEFN, enumtype));\n-\t  resume_temporary_allocation ();\n-\t}\n-      return enumtype;\n+\tadd_tree (build_min (TAG_DEFN, enumtype));\n     }\n+  else\n+    {\n+      int unsignedp = tree_int_cst_sgn (minnode) >= 0;\n+      int lowprec = min_precision (minnode, unsignedp);\n+      int highprec = min_precision (maxnode, unsignedp);\n+      int precision = MAX (lowprec, highprec);\n+      tree tem;\n \n-  {\n-    int unsignedp = tree_int_cst_sgn (minnode) >= 0;\n-    int lowprec = min_precision (minnode, unsignedp);\n-    int highprec = min_precision (maxnode, unsignedp);\n-    int precision = MAX (lowprec, highprec);\n-\n-    TYPE_SIZE (enumtype) = NULL_TREE;\n-\n-    /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */\n+      TYPE_SIZE (enumtype) = NULL_TREE;\n \n-    TYPE_PRECISION (enumtype) = precision;\n-    if (unsignedp)\n-      fixup_unsigned_type (enumtype);\n-    else\n-      fixup_signed_type (enumtype);\n+      /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */\n \n-    if (flag_short_enums || (precision > TYPE_PRECISION (integer_type_node)))\n-      /* Use the width of the narrowest normal C type which is wide enough.  */\n-      TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n-\t\t\t\t\t\t  (precision, 1));\n-    else\n-      TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n+      TYPE_PRECISION (enumtype) = precision;\n+      if (unsignedp)\n+\tfixup_unsigned_type (enumtype);\n+      else\n+\tfixup_signed_type (enumtype);\n \n-    TYPE_SIZE (enumtype) = 0;\n-    layout_type (enumtype);\n-  }\n+      if (flag_short_enums || (precision > TYPE_PRECISION (integer_type_node)))\n+\t/* Use the width of the narrowest normal C type which is wide\n+\t   enough.  */ \n+\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n+\t\t\t\t\t\t    (precision, 1));\n+      else\n+\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n \n-  {\n-    register tree tem;\n+      TYPE_SIZE (enumtype) = 0;\n+      layout_type (enumtype);\n     \n-    /* Fix up all variant types of this enum type.  */\n-    for (tem = TYPE_MAIN_VARIANT (enumtype); tem;\n-\t tem = TYPE_NEXT_VARIANT (tem))\n-      {\n-\tTYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n-\tTYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n-\tTYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n-\tTYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n-\tTYPE_SIZE_UNIT (tem) = TYPE_SIZE_UNIT (enumtype);\n-\tTYPE_MODE (tem) = TYPE_MODE (enumtype);\n-\tTYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n-\tTYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n-\tTREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n-      }\n-  }\n+      /* Fix up all variant types of this enum type.  */\n+      for (tem = TYPE_MAIN_VARIANT (enumtype); tem;\n+\t   tem = TYPE_NEXT_VARIANT (tem))\n+\t{\n+\t  TYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n+\t  TYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n+\t  TYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n+\t  TYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n+\t  TYPE_SIZE_UNIT (tem) = TYPE_SIZE_UNIT (enumtype);\n+\t  TYPE_MODE (tem) = TYPE_MODE (enumtype);\n+\t  TYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n+\t  TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n+\t  TREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n+\t}\n \n-  /* Finish debugging output for this type.  */\n-  rest_of_type_compilation (enumtype, namespace_bindings_p ());\n+      /* Finish debugging output for this type.  */\n+      rest_of_type_compilation (enumtype, namespace_bindings_p ());\n+    }\n+\n+  /* In start_enum we pushed obstacks.  Here, we must pop them.  */\n+  pop_obstacks ();\n \n   return enumtype;\n }"}]}