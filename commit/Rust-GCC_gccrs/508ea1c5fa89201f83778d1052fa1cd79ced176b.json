{"sha": "508ea1c5fa89201f83778d1052fa1cd79ced176b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4ZWExYzVmYTg5MjAxZjgzNzc4ZDEwNTJmYTFjZDc5Y2VkMTc2Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-29T02:28:59Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-29T02:28:59Z"}, "message": "* config/sh/sh.c: Convert to ISO-C.\n\nFrom-SVN: r78645", "tree": {"sha": "0b7a4c9f5dd69a490152ebfdc2f4f167318eb80e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b7a4c9f5dd69a490152ebfdc2f4f167318eb80e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/508ea1c5fa89201f83778d1052fa1cd79ced176b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508ea1c5fa89201f83778d1052fa1cd79ced176b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508ea1c5fa89201f83778d1052fa1cd79ced176b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508ea1c5fa89201f83778d1052fa1cd79ced176b/comments", "author": null, "committer": null, "parents": [{"sha": "4217f24bf857264c42a094df711cf03bd054ce4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4217f24bf857264c42a094df711cf03bd054ce4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4217f24bf857264c42a094df711cf03bd054ce4a"}], "stats": {"total": 98, "additions": 40, "deletions": 58}, "files": [{"sha": "a490e7d616dca8fdcb736f8707d45783f9d9b751", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508ea1c5fa89201f83778d1052fa1cd79ced176b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508ea1c5fa89201f83778d1052fa1cd79ced176b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=508ea1c5fa89201f83778d1052fa1cd79ced176b", "patch": "@@ -1,3 +1,7 @@\n+2004-02-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/sh/sh.c: Convert to ISO-C.\n+\n 2004-02-28  Andrew Pinski  <pinskia@physics.uc.edu>\n \t\n \t* c-typeck.c (tagged_types_tu_compatible_p): Fix pasto in"}, {"sha": "644f45ca83adac346e62cc1d6fd7d2ea84fd2784", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 36, "deletions": 58, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/508ea1c5fa89201f83778d1052fa1cd79ced176b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/508ea1c5fa89201f83778d1052fa1cd79ced176b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=508ea1c5fa89201f83778d1052fa1cd79ced176b", "patch": "@@ -8361,9 +8361,7 @@ sh_issue_rate(void)\n \n /* Get weight for mode for a set x.  */\n static short\n-find_set_regmode_weight (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+find_set_regmode_weight (rtx x, enum machine_mode mode)\n {\n   if (GET_CODE (x) == CLOBBER && register_operand (SET_DEST (x), mode))\n     return 1;\n@@ -8383,9 +8381,7 @@ find_set_regmode_weight (x, mode)\n \n /* Get regmode weight for insn.  */\n static short\n-find_insn_regmode_weight (insn, mode)\n-     rtx insn;\n-     enum machine_mode mode;\n+find_insn_regmode_weight (rtx insn, enum machine_mode mode)\n {\n   short reg_weight = 0;\n   rtx x;\n@@ -8417,9 +8413,7 @@ find_insn_regmode_weight (insn, mode)\n \n /* Calculate regmode weights for all insns of a basic block.  */\n static void\n-find_regmode_weight (b, mode)\n-     int b;\n-     enum machine_mode mode;\n+find_regmode_weight (int b, enum machine_mode mode)\n {\n   rtx insn, next_tail, head, tail;\n \n@@ -8443,9 +8437,7 @@ find_regmode_weight (b, mode)\n \n /* Comparison function for ready queue sorting.  */\n static int\n-rank_for_reorder (x, y)\n-     const void *x;\n-     const void *y;\n+rank_for_reorder (const void *x, const void *y)\n {\n   rtx tmp = *(const rtx *) y;\n   rtx tmp2 = *(const rtx *) x;\n@@ -8462,9 +8454,7 @@ rank_for_reorder (x, y)\n \n /* Resort the array A in which only element at index N may be out of order.  */\n static void\n-swap_reorder (a, n)\n-     rtx *a;\n-     int n;\n+swap_reorder (rtx *a, int n)\n {\n   rtx insn = a[n - 1];\n   int i = n - 2;\n@@ -8487,19 +8477,16 @@ while (0)\n /* Sort the ready list READY by ascending priority, using the SCHED_REORDER\n    macro.  */\n static void\n-ready_reorder (ready, nready)\n-     rtx *ready;\n-     int nready;\n+ready_reorder (rtx *ready, int nready)\n {\n   SCHED_REORDER (ready, nready);\n }\n \n /* Calculate regmode weights for all insns of all basic block.  */\n static void\n-sh_md_init_global (dump, verbose, old_max_uid)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int verbose ATTRIBUTE_UNUSED;\n-     int old_max_uid;\n+sh_md_init_global (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t   int verbose ATTRIBUTE_UNUSED,\n+\t\t   int old_max_uid)\n {\n   basic_block b;\n \n@@ -8519,9 +8506,8 @@ sh_md_init_global (dump, verbose, old_max_uid)\n \n /* Cleanup.  */\n static void\n-sh_md_finish_global (dump, verbose)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int verbose ATTRIBUTE_UNUSED;\n+sh_md_finish_global (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t     int verbose ATTRIBUTE_UNUSED)\n {\n   if (regmode_weight[0])\n     {\n@@ -8538,11 +8524,10 @@ sh_md_finish_global (dump, verbose)\n /* Cache the can_issue_more so that we can return it from reorder2. Also,\n    keep count of register pressures on SImode and SFmode. */\n static int\n-sh_variable_issue (dump, sched_verbose, insn, can_issue_more)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     int can_issue_more;\n+sh_variable_issue (FILE *dump ATTRIBUTE_UNUSED,\n+\t\t   int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t   rtx insn,\n+\t\t   int can_issue_more)\n {\n   if (GET_CODE (PATTERN (insn)) != USE\n       && GET_CODE (PATTERN (insn)) != CLOBBER)\n@@ -8560,10 +8545,9 @@ sh_variable_issue (dump, sched_verbose, insn, can_issue_more)\n }\n \n static void\n-sh_md_init (dump, verbose, veclen)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int verbose ATTRIBUTE_UNUSED;\n-     int veclen ATTRIBUTE_UNUSED;\n+sh_md_init (FILE *dump ATTRIBUTE_UNUSED,\n+\t    int verbose ATTRIBUTE_UNUSED,\n+\t    int veclen ATTRIBUTE_UNUSED)\n {\n   CURR_REGMODE_PRESSURE (SImode) = 0;\n   CURR_REGMODE_PRESSURE (SFmode) = 0;\n@@ -8580,8 +8564,7 @@ sh_md_init (dump, verbose, veclen)\n \n /* Return true if the pressure is high for MODE.  */\n static short\n-high_pressure (mode)\n-     enum machine_mode mode;\n+high_pressure (enum machine_mode mode)\n {\n   /* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n      functions that already have high pressure on r0. */\n@@ -8597,12 +8580,11 @@ high_pressure (mode)\n \n /* Reorder ready queue if register pressure is high.  */\n static int\n-sh_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx *ready;\n-     int *n_readyp;\n-     int clock_var ATTRIBUTE_UNUSED;\n+sh_reorder (FILE *dump ATTRIBUTE_UNUSED,\n+\t    int sched_verbose ATTRIBUTE_UNUSED,\n+\t    rtx *ready,\n+\t    int *n_readyp,\n+\t    int clock_var ATTRIBUTE_UNUSED)\n {\n   if (reload_completed)\n     return sh_issue_rate ();\n@@ -8617,12 +8599,11 @@ sh_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n \n /* Skip cycles if the current register pressure is high.  */\n static int \n-sh_reorder2 (dump, sched_verbose, ready, n_readyp, clock_var)\n-     FILE *dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx *ready ATTRIBUTE_UNUSED;\n-     int *n_readyp ATTRIBUTE_UNUSED;\n-     int clock_var ATTRIBUTE_UNUSED;\n+sh_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n+\t     int sched_verbose ATTRIBUTE_UNUSED,\n+\t     rtx *ready ATTRIBUTE_UNUSED,\n+\t     int *n_readyp ATTRIBUTE_UNUSED,\n+\t     int clock_var ATTRIBUTE_UNUSED)\n {\n   if (reload_completed)\n     return cached_can_issue_more;\n@@ -8642,14 +8623,12 @@ sh_reorder2 (dump, sched_verbose, ready, n_readyp, clock_var)\n #define MAX_SKIPS 8 \n \n static int\n-sh_dfa_new_cycle (sched_dump, sched_verbose, insn, last_clock_var, \n-\t\tclock_var, sort_p)\n-     FILE *sched_dump ATTRIBUTE_UNUSED;\n-     int sched_verbose ATTRIBUTE_UNUSED;\n-     rtx insn ATTRIBUTE_UNUSED;\n-     int last_clock_var;\n-     int clock_var;\n-     int *sort_p;\n+sh_dfa_new_cycle (FILE *sched_dump ATTRIBUTE_UNUSED,\n+\t\t  int sched_verbose ATTRIBUTE_UNUSED,\n+\t\t  rtx insn ATTRIBUTE_UNUSED,\n+\t\t  int last_clock_var,\n+\t\t  int clock_var,\n+\t\t  int *sort_p)\n {\n   if (reload_completed)\n \t  return 0;\n@@ -8696,8 +8675,7 @@ sh_optimize_target_register_callee_saved (bool after_prologue_epilogue_gen)\n }\n \n static bool\n-sh_ms_bitfield_layout_p (record_type)\n-     tree record_type ATTRIBUTE_UNUSED;\n+sh_ms_bitfield_layout_p (tree record_type ATTRIBUTE_UNUSED)\n {\n   return (TARGET_SH5 || TARGET_HITACHI || sh_attr_renesas_p (record_type));\n }"}]}