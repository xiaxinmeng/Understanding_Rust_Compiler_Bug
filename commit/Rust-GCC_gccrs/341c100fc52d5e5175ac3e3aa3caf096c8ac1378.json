{"sha": "341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQxYzEwMGZjNTJkNWU1MTc1YWMzZTNhYTNjYWYwOTZjOGFjMTM3OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-07T15:46:53Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-07T15:46:53Z"}, "message": "cfganal.c (flow_depth_first_order_compute, [...]): Use gcc_assert or gcc_unreachable.\n\n\t* cfganal.c (flow_depth_first_order_compute, dfs_enumerate_from,\n\tcfgbuild.c, inside_basic_block_p, control_flow_insn_p,\n\tmake_label_edge, make_edges, find_basic_blocks_1): Use gcc_assert\n\tor gcc_unreachable.\n\t* cfg.c (clear_edges, initialize_bb_rbi, compact_blocks,\n\tremove_edge, alloc_aux_for_blocks, free_aux_for_blocks,\n\talloc_aux_for_edges, free_aux_for_edges): Likewise.\n\t* cfgcleanup.c (try_forward_edges,\n\tmerge_blocks_move_predecessor_nojumps,\n\tmerge_blocks_move_successor_nojumps): Likewise.\n\t* cfgexpand.c (expand_gimple_cond_expr,\n\texpand_gimple_tailcall): Likewise.\n\t* cfghooks.c (duplicate_block): Likewise.\n\t* cfglayout.c (record_effective_endpoints,\n\tinsn_locators_initialize, change_scope, fixup_reorder_chain,\n\tverify_insn_chain, fixup_fallthru_exit_predecessor,\n\tduplicate_insn_chain, cfg_layout_finalize): Likewise.\n\t* cfgloopanal.c (check_irred): Likewise.\n\t* cfgloop.c (superloop_at_depth, flow_loops_free,\n\tflow_loop_entry_edges_find, flow_loops_find,\n\tflow_loop_outside_edge_p, get_loop_body,\n\tget_loop_body_in_dom_order, get_loop_body_in_bfs_order,\n\tget_loop_exit_edges, num_loop_branches, cancel_loop,\n\tverify_loop_structure): Likewise.\n\tcfgloopmanip.c (find_path, remove_path, loop_delete_branch_edge,\n\tduplicate_loop_to_header_edge, create_preheader,\n\tcreate_loop_notes): Likewise.\n\t* cfgrtl.c (delete_insn, try_redirect_by_replacing_jump,\n\tedirect_branch_edge, force_nonfallthru_and_redirect,\n\trtl_split_edge, insert_insn_on_edge, commit_one_edge_insertion,\n\tcommit_edge_insertions, commit_edge_insertions_watch_calls,\n\tpurge_dead_edges, cfg_layout_redirect_edge_and_branch,\n\tcfg_layout_redirect_edge_and_branch_force,\n\tcfg_layout_merge_blocks, rtl_flow_call_edges_add): Likewise.\n\t* cgraph.c (cgraph_node, cgraph_create_edge, cgraph_remove_edge,\n\tcgraph_redirect_edge_callee, cgraph_global_info, cgraph_rtl_info,\n\tcgraph_varpool_node): Likewise.\n\t* cgraphunit.c (cgraph_finalize_function,\n\tcgraph_finalize_compilation_unit, cgraph_mark_functions_to_output,\n\tcgraph_expand_function, cgraph_remove_unreachable_nodes,\n\tcgraph_clone_inlined_nodes, cgraph_mark_inline_edge,\n\tcgraph_mark_inline, cgraph_expand_all_functions,\n\tcgraph_build_static_cdtor): Likewise.\n\t* combine.c  (do_SUBST, try_combine, subst, combine_simplify_rtx,\n\tsimplify_logical, distribute_notes, insn_cuid): Likewise.\n\t* conflict.c (conflict_graph_add, print_conflict): Likewise.\n\t* coverage.c (rtl_coverage_counter_ref, tree_coverage_counter_ref,\n\tcoverage_checksum_string): Likewise.\n\t* cse.c (make_new_qty, make_regs_eqv, insert, invalidate,\n\thash_rtx, exp_equiv_p, cse_basic_block, count_reg_usage,\n\tcse_cc_succs, cse_condition_code_reg): Likewise.\n\t* cselib.c (entry_and_rtx_equal_p, remove_useless_values,\n\trtx_equal_for_cselib_p, wrap_constant, cselib_hash_rtx,\n\tnew_cselib_val, cselib_subst_to_values, cselib_invalidate_regno,\n\tcselib_record_set): Likewise.\n\nFrom-SVN: r87145", "tree": {"sha": "ce9be778c6fd5bbc5eb633ed0344673882ecdabe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce9be778c6fd5bbc5eb633ed0344673882ecdabe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/comments", "author": null, "committer": null, "parents": [{"sha": "6b094f38d7561422c087a31d26a8d36b58d7a549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b094f38d7561422c087a31d26a8d36b58d7a549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b094f38d7561422c087a31d26a8d36b58d7a549"}], "stats": {"total": 950, "additions": 452, "deletions": 498}, "files": [{"sha": "07a807988ac143a9d6e8f14d3147cf198d8066d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -1,3 +1,61 @@\n+2004-09-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cfganal.c (flow_depth_first_order_compute, dfs_enumerate_from,\n+\tcfgbuild.c, inside_basic_block_p, control_flow_insn_p,\n+\tmake_label_edge, make_edges, find_basic_blocks_1): Use gcc_assert\n+\tor gcc_unreachable.\n+\t* cfg.c (clear_edges, initialize_bb_rbi, compact_blocks,\n+\tremove_edge, alloc_aux_for_blocks, free_aux_for_blocks,\n+\talloc_aux_for_edges, free_aux_for_edges): Likewise.\n+\t* cfgcleanup.c (try_forward_edges,\n+\tmerge_blocks_move_predecessor_nojumps,\n+\tmerge_blocks_move_successor_nojumps): Likewise.\n+\t* cfgexpand.c (expand_gimple_cond_expr,\n+\texpand_gimple_tailcall): Likewise.\n+\t* cfghooks.c (duplicate_block): Likewise.\n+\t* cfglayout.c (record_effective_endpoints,\n+\tinsn_locators_initialize, change_scope, fixup_reorder_chain,\n+\tverify_insn_chain, fixup_fallthru_exit_predecessor,\n+\tduplicate_insn_chain, cfg_layout_finalize): Likewise.\n+\t* cfgloopanal.c (check_irred): Likewise.\n+\t* cfgloop.c (superloop_at_depth, flow_loops_free,\n+\tflow_loop_entry_edges_find, flow_loops_find,\n+\tflow_loop_outside_edge_p, get_loop_body,\n+\tget_loop_body_in_dom_order, get_loop_body_in_bfs_order,\n+\tget_loop_exit_edges, num_loop_branches, cancel_loop,\n+\tverify_loop_structure): Likewise.\n+\tcfgloopmanip.c (find_path, remove_path, loop_delete_branch_edge,\n+\tduplicate_loop_to_header_edge, create_preheader,\n+\tcreate_loop_notes): Likewise.\n+\t* cfgrtl.c (delete_insn, try_redirect_by_replacing_jump,\n+\tedirect_branch_edge, force_nonfallthru_and_redirect,\n+\trtl_split_edge, insert_insn_on_edge, commit_one_edge_insertion,\n+\tcommit_edge_insertions, commit_edge_insertions_watch_calls,\n+\tpurge_dead_edges, cfg_layout_redirect_edge_and_branch,\n+\tcfg_layout_redirect_edge_and_branch_force,\n+\tcfg_layout_merge_blocks, rtl_flow_call_edges_add): Likewise.\n+\t* cgraph.c (cgraph_node, cgraph_create_edge, cgraph_remove_edge,\n+\tcgraph_redirect_edge_callee, cgraph_global_info, cgraph_rtl_info,\n+\tcgraph_varpool_node): Likewise.\n+\t* cgraphunit.c (cgraph_finalize_function,\n+\tcgraph_finalize_compilation_unit, cgraph_mark_functions_to_output,\n+\tcgraph_expand_function, cgraph_remove_unreachable_nodes,\n+\tcgraph_clone_inlined_nodes, cgraph_mark_inline_edge,\n+\tcgraph_mark_inline, cgraph_expand_all_functions,\n+\tcgraph_build_static_cdtor): Likewise.\n+\t* combine.c  (do_SUBST, try_combine, subst, combine_simplify_rtx,\n+\tsimplify_logical, distribute_notes, insn_cuid): Likewise.\n+\t* conflict.c (conflict_graph_add, print_conflict): Likewise.\n+\t* coverage.c (rtl_coverage_counter_ref, tree_coverage_counter_ref,\n+\tcoverage_checksum_string): Likewise.\n+\t* cse.c (make_new_qty, make_regs_eqv, insert, invalidate,\n+\thash_rtx, exp_equiv_p, cse_basic_block, count_reg_usage,\n+\tcse_cc_succs, cse_condition_code_reg): Likewise.\n+\t* cselib.c (entry_and_rtx_equal_p, remove_useless_values,\n+\trtx_equal_for_cselib_p, wrap_constant, cselib_hash_rtx,\n+\tnew_cselib_val, cselib_subst_to_values, cselib_invalidate_regno,\n+\tcselib_record_set): Likewise.\n+\n 2004-09-07  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-loop-ivopts.c (iv_value): Avoid invalid sharing on niter."}, {"sha": "3164ba0d06c8bcf05d456a8fbe4cd74c8469e290", "filename": "gcc/cfg.c", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -173,8 +173,7 @@ clear_edges (void)\n   EXIT_BLOCK_PTR->pred = NULL;\n   ENTRY_BLOCK_PTR->succ = NULL;\n \n-  if (n_edges)\n-    abort ();\n+  gcc_assert (!n_edges);\n }\n \f\n /* Allocate memory for basic_block.  */\n@@ -211,8 +210,7 @@ free_rbi_pool (void)\n void\n initialize_bb_rbi (basic_block bb)\n {\n-  if (bb->rbi)\n-    abort ();\n+  gcc_assert (!bb->rbi);\n   bb->rbi = pool_alloc (rbi_pool);\n   memset (bb->rbi, 0, sizeof (struct reorder_block_def));\n }\n@@ -252,8 +250,7 @@ compact_blocks (void)\n       i++;\n     }\n \n-  if (i != n_basic_blocks)\n-    abort ();\n+  gcc_assert (i == n_basic_blocks);\n \n   for (; i < last_basic_block; i++)\n     BASIC_BLOCK (i) = NULL;\n@@ -377,8 +374,7 @@ remove_edge (edge e)\n   for (tmp = src->succ; tmp && tmp != e; tmp = tmp->succ_next)\n     last_succ = tmp;\n \n-  if (!tmp)\n-    abort ();\n+  gcc_assert (tmp);\n   if (last_succ)\n     last_succ->succ_next = e->succ_next;\n   else\n@@ -387,8 +383,7 @@ remove_edge (edge e)\n   for (tmp = dest->pred; tmp && tmp != e; tmp = tmp->pred_next)\n     last_pred = tmp;\n \n-  if (!tmp)\n-    abort ();\n+  gcc_assert (tmp);\n   if (last_pred)\n     last_pred->pred_next = e->pred_next;\n   else\n@@ -696,8 +691,7 @@ inline void\n alloc_aux_for_block (basic_block bb, int size)\n {\n   /* Verify that aux field is clear.  */\n-  if (bb->aux || !first_block_aux_obj)\n-    abort ();\n+  gcc_assert (!bb->aux && first_block_aux_obj);\n   bb->aux = obstack_alloc (&block_aux_obstack, size);\n   memset (bb->aux, 0, size);\n }\n@@ -715,10 +709,10 @@ alloc_aux_for_blocks (int size)\n       gcc_obstack_init (&block_aux_obstack);\n       initialized = 1;\n     }\n-\n-  /* Check whether AUX data are still allocated.  */\n-  else if (first_block_aux_obj)\n-    abort ();\n+  else\n+    /* Check whether AUX data are still allocated.  */\n+    gcc_assert (!first_block_aux_obj);\n+  \n   first_block_aux_obj = obstack_alloc (&block_aux_obstack, 0);\n   if (size)\n     {\n@@ -746,8 +740,7 @@ clear_aux_for_blocks (void)\n void\n free_aux_for_blocks (void)\n {\n-  if (!first_block_aux_obj)\n-    abort ();\n+  gcc_assert (first_block_aux_obj);\n   obstack_free (&block_aux_obstack, first_block_aux_obj);\n   first_block_aux_obj = NULL;\n \n@@ -761,8 +754,7 @@ inline void\n alloc_aux_for_edge (edge e, int size)\n {\n   /* Verify that aux field is clear.  */\n-  if (e->aux || !first_edge_aux_obj)\n-    abort ();\n+  gcc_assert (!e->aux && first_edge_aux_obj);\n   e->aux = obstack_alloc (&edge_aux_obstack, size);\n   memset (e->aux, 0, size);\n }\n@@ -780,10 +772,9 @@ alloc_aux_for_edges (int size)\n       gcc_obstack_init (&edge_aux_obstack);\n       initialized = 1;\n     }\n-\n-  /* Check whether AUX data are still allocated.  */\n-  else if (first_edge_aux_obj)\n-    abort ();\n+  else\n+    /* Check whether AUX data are still allocated.  */\n+    gcc_assert (!first_edge_aux_obj);\n \n   first_edge_aux_obj = obstack_alloc (&edge_aux_obstack, 0);\n   if (size)\n@@ -821,8 +812,7 @@ clear_aux_for_edges (void)\n void\n free_aux_for_edges (void)\n {\n-  if (!first_edge_aux_obj)\n-    abort ();\n+  gcc_assert (first_edge_aux_obj);\n   obstack_free (&edge_aux_obstack, first_edge_aux_obj);\n   first_edge_aux_obj = NULL;\n "}, {"sha": "cec33eceb59305387b7e5f69ded2b8ef5d03264b", "filename": "gcc/cfganal.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -762,14 +762,8 @@ flow_depth_first_order_compute (int *dfs_order, int *rc_order)\n   free (stack);\n   sbitmap_free (visited);\n \n-  /* The number of nodes visited should not be greater than\n-     n_basic_blocks.  */\n-  if (dfsnum > n_basic_blocks)\n-    abort ();\n-\n-  /* There are some nodes left in the CFG that are unreachable.  */\n-  if (dfsnum < n_basic_blocks)\n-    abort ();\n+  /* The number of nodes visited should be the number of blocks.  */\n+  gcc_assert (dfsnum == n_basic_blocks);\n \n   return dfsnum;\n }\n@@ -1019,8 +1013,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n           for (e = lbb->pred; e; e = e->pred_next)\n \t    if (!(e->src->flags & BB_VISITED) && predicate (e->src, data))\n \t      {\n-\t        if (tv == rslt_max)\n-\t          abort ();\n+\t        gcc_assert (tv != rslt_max);\n \t        rslt[tv++] = st[sp++] = e->src;\n \t        e->src->flags |= BB_VISITED;\n \t      }\n@@ -1030,8 +1023,7 @@ dfs_enumerate_from (basic_block bb, int reverse,\n           for (e = lbb->succ; e; e = e->succ_next)\n \t    if (!(e->dest->flags & BB_VISITED) && predicate (e->dest, data))\n \t      {\n-\t        if (tv == rslt_max)\n-\t          abort ();\n+\t        gcc_assert (tv != rslt_max);\n \t        rslt[tv++] = st[sp++] = e->dest;\n \t        e->dest->flags |= BB_VISITED;\n \t      }"}, {"sha": "2f59d7e982cf23c75c01ed57ab283dd1f8e68e6d", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -83,7 +83,7 @@ inside_basic_block_p (rtx insn)\n       return false;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -131,7 +131,7 @@ control_flow_insn_p (rtx insn)\n       return false;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -183,8 +183,7 @@ count_basic_blocks (rtx f)\n static void\n make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n {\n-  if (!LABEL_P (label))\n-    abort ();\n+  gcc_assert (LABEL_P (label));\n \n   /* If the label was never emitted, this insn is junk, but avoid a\n      crash trying to refer to BLOCK_FOR_INSN (label).  This can happen\n@@ -345,8 +344,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t  /* Otherwise, we have a plain conditional or unconditional jump.  */\n \t  else\n \t    {\n-\t      if (! JUMP_LABEL (insn))\n-\t\tabort ();\n+\t      gcc_assert (JUMP_LABEL (insn));\n \t      make_label_edge (edge_cache, bb, JUMP_LABEL (insn), 0);\n \t    }\n \t}\n@@ -490,7 +488,7 @@ find_basic_blocks_1 (rtx f)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -499,8 +497,7 @@ find_basic_blocks_1 (rtx f)\n   else if (bb_note)\n     delete_insn (bb_note);\n \n-  if (last_basic_block != n_basic_blocks)\n-    abort ();\n+  gcc_assert (last_basic_block == n_basic_blocks);\n \n   clear_aux_for_blocks ();\n }"}, {"sha": "08714f6d652063df6284a89f4154cab7e76b144c", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -519,8 +519,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t  if (t->dest == b)\n \t\t    break;\n \n-\t\t  if (nthreaded_edges >= n_basic_blocks)\n-\t\t    abort ();\n+\t\t  gcc_assert (nthreaded_edges < n_basic_blocks);\n \t\t  threaded_edges[nthreaded_edges++] = t;\n \n \t\t  new_target = t->dest;\n@@ -625,11 +624,10 @@ try_forward_edges (int mode, basic_block b)\n \t\t{\n \t\t  edge e;\n \t\t  int prob;\n-\t\t  if (n >= nthreaded_edges)\n-\t\t    abort ();\n+\t\t  \n+\t\t  gcc_assert (n < nthreaded_edges);\n \t\t  t = threaded_edges [n++];\n-\t\t  if (t->src != first)\n-\t\t    abort ();\n+\t\t  gcc_assert (t->src == first);\n \t\t  if (first->frequency)\n \t\t    prob = edge_frequency * REG_BR_PROB_BASE / first->frequency;\n \t\t  else\n@@ -686,6 +684,7 @@ static void\n merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier;\n+  bool only_notes;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -703,8 +702,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n     return;\n \n   barrier = next_nonnote_insn (BB_END (a));\n-  if (!BARRIER_P (barrier))\n-    abort ();\n+  gcc_assert (BARRIER_P (barrier));\n   delete_insn (barrier);\n \n   /* Move block and loop notes out of the chain so that we do not\n@@ -714,8 +712,8 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n      and adjust the block trees appropriately.   Even better would be to have\n      a tighter connection between block trees and rtl so that this is not\n      necessary.  */\n-  if (squeeze_notes (&BB_HEAD (a), &BB_END (a)))\n-    abort ();\n+  only_notes = squeeze_notes (&BB_HEAD (a), &BB_END (a));\n+  gcc_assert (!only_notes);\n \n   /* Scramble the insn chain.  */\n   if (BB_END (a) != PREV_INSN (BB_HEAD (b)))\n@@ -744,6 +742,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier, real_b_end;\n   rtx label, table;\n+  bool only_notes;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -782,8 +781,9 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n      and adjust the block trees appropriately.   Even better would be to have\n      a tighter connection between block trees and rtl so that this is not\n      necessary.  */\n-  if (squeeze_notes (&BB_HEAD (b), &BB_END (b)))\n-    abort ();\n+  only_notes = squeeze_notes (&BB_HEAD (b), &BB_END (b));\n+  gcc_assert (!only_notes);\n+  \n \n   /* Scramble the insn chain.  */\n   reorder_insns_nobb (BB_HEAD (b), BB_END (b), BB_END (a));"}, {"sha": "b73445d0b184adc744cad9fe6a2b9ba8a05c34ad", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -833,8 +833,8 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n       jumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n       return NULL;\n     }\n-  if (TREE_CODE (then_exp) != GOTO_EXPR || TREE_CODE (else_exp) != GOTO_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (then_exp) == GOTO_EXPR\n+\t      && TREE_CODE (else_exp) == GOTO_EXPR);\n \n   jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n   last = get_last_insn ();\n@@ -936,8 +936,7 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n      after the sibcall (to perform the function return).  These confuse the\n      find_sub_basic_blocks code, so we need to get rid of these.  */\n   last = NEXT_INSN (last);\n-  if (!BARRIER_P (last))\n-    abort ();\n+  gcc_assert (BARRIER_P (last));\n \n   *can_fallthru = false;\n   while (NEXT_INSN (last))"}, {"sha": "970dcbedda610d90f57bcb402d2a95899700bddf", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -678,11 +678,9 @@ duplicate_block (basic_block bb, edge e)\n \n   if (bb->count < new_count)\n     new_count = bb->count;\n-  if (!bb->pred)\n-    abort ();\n+  gcc_assert (bb->pred);\n #ifdef ENABLE_CHECKING\n-  if (!can_duplicate_block_p (bb))\n-    abort ();\n+  gcc_assert (can_duplicate_block_p (bb));\n #endif\n \n   new_bb = cfg_hooks->duplicate_block (bb);"}, {"sha": "bc7cec93f0ae1d8474015d000aa81022e3938a61", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 43, "deletions": 61, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -199,8 +199,9 @@ record_effective_endpoints (void)\n        && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n        insn = NEXT_INSN (insn))\n     continue;\n-  if (!insn)\n-    abort ();  /* No basic blocks at all?  */\n+  /* No basic blocks at all?  */\n+  gcc_assert (insn);\n+  \n   if (PREV_INSN (insn))\n     cfg_layout_function_header =\n \t    unlink_insn_chain (get_insns (), PREV_INSN (insn));\n@@ -273,21 +274,14 @@ insn_locators_initialize (void)\n \n       if (NOTE_P (insn))\n \t{\n-\t  switch (NOTE_LINE_NUMBER (insn))\n+\t  gcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_BEG\n+\t\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END);\n+\t  if (NOTE_LINE_NUMBER (insn) > 0)\n \t    {\n-\t    case NOTE_INSN_BLOCK_BEG:\n-\t    case NOTE_INSN_BLOCK_END:\n-\t      abort ();\n-\t      \n-\t    default:\n-\t      if (NOTE_LINE_NUMBER (insn) > 0)\n-\t\t{\n-\t\t  expanded_location xloc;\n-\t\t  NOTE_EXPANDED_LOCATION (xloc, insn);\n-\t\t  line_number = xloc.line;\n-\t\t  file_name = xloc.file;\n-\t\t}\n-\t      break;\n+\t      expanded_location xloc;\n+\t      NOTE_EXPANDED_LOCATION (xloc, insn);\n+\t      line_number = xloc.line;\n+\t      file_name = xloc.file;\n \t    }\n \t}\n       else\n@@ -377,8 +371,7 @@ change_scope (rtx orig_insn, tree s1, tree s2)\n \n   while (ts1 != ts2)\n     {\n-      if (ts1 == NULL || ts2 == NULL)\n-\tabort ();\n+      gcc_assert (ts1 && ts2);\n       if (BLOCK_NUMBER (ts1) > BLOCK_NUMBER (ts2))\n \tts1 = BLOCK_SUPERCONTEXT (ts1);\n       else if (BLOCK_NUMBER (ts1) < BLOCK_NUMBER (ts2))\n@@ -615,8 +608,7 @@ fixup_reorder_chain (void)\n \t}\n     }\n \n-  if (index != n_basic_blocks)\n-    abort ();\n+  gcc_assert (index == n_basic_blocks);\n \n   NEXT_INSN (insn) = cfg_layout_function_footer;\n   if (cfg_layout_function_footer)\n@@ -675,11 +667,14 @@ fixup_reorder_chain (void)\n \t\t{\n \t\t  rtx note;\n \t\t  edge e_fake;\n+\t\t  bool redirected;\n \n \t\t  e_fake = unchecked_make_edge (bb, e_fall->dest, 0);\n \n-\t\t  if (!redirect_jump (BB_END (bb), block_label (bb), 0))\n-\t\t    abort ();\n+\t\t  redirected = redirect_jump (BB_END (bb),\n+\t\t\t\t\t      block_label (bb), 0);\n+\t\t  gcc_assert (redirected);\n+\t\t  \n \t\t  note = find_reg_note (BB_END (bb), REG_BR_PROB, NULL_RTX);\n \t\t  if (note)\n \t\t    {\n@@ -712,8 +707,8 @@ fixup_reorder_chain (void)\n \t\t    {\n \t\t      e_fall->flags &= ~EDGE_FALLTHRU;\n #ifdef ENABLE_CHECKING\n-\t\t      if (!could_fall_through (e_taken->src, e_taken->dest))\n-\t\t\tabort ();\n+\t\t      gcc_assert (could_fall_through\n+\t\t\t\t  (e_taken->src, e_taken->dest));\n #endif\n \t\t      e_taken->flags |= EDGE_FALLTHRU;\n \t\t      update_br_prob_note (bb);\n@@ -736,31 +731,30 @@ fixup_reorder_chain (void)\n \t\t{\n \t\t  e_fall->flags &= ~EDGE_FALLTHRU;\n #ifdef ENABLE_CHECKING\n-\t\t  if (!could_fall_through (e_taken->src, e_taken->dest))\n-\t\t    abort ();\n+\t\t  gcc_assert (could_fall_through\n+\t\t\t      (e_taken->src, e_taken->dest));\n #endif\n \t\t  e_taken->flags |= EDGE_FALLTHRU;\n \t\t  update_br_prob_note (bb);\n \t\t  continue;\n \t\t}\n \t    }\n-\t  else if (returnjump_p (bb_end_insn))\n-\t    continue;\n \t  else\n \t    {\n-\t      /* Otherwise we have some switch or computed jump.  In the\n-\t\t 99% case, there should not have been a fallthru edge.  */\n-\t      if (! e_fall)\n+#ifndef CASE_DROPS_THROUGH\n+\t      /* Otherwise we have some return, switch or computed\n+\t\t jump.  In the 99% case, there should not have been a\n+\t\t fallthru edge.  */\n+\t      gcc_assert (returnjump_p (bb_end_insn) || !e_fall);\n+\t      continue;\n+#else\n+\t      if (returnjump_p (bb_end_insn) || !e_fall)\n \t\tcontinue;\n-\n-#ifdef CASE_DROPS_THROUGH\n \t      /* Except for VAX.  Since we didn't have predication for the\n \t\t tablejump, the fallthru block should not have moved.  */\n \t      if (bb->rbi->next == e_fall->dest)\n \t\tcontinue;\n \t      bb_end_insn = skip_insns_after_block (bb);\n-#else\n-\t      abort ();\n #endif\n \t    }\n \t}\n@@ -903,20 +897,16 @@ verify_insn_chain (void)\n   for (prevx = NULL, insn_cnt1 = 1, x = get_insns ();\n        x != 0;\n        prevx = x, insn_cnt1++, x = NEXT_INSN (x))\n-    if (PREV_INSN (x) != prevx)\n-      abort ();\n+    gcc_assert (PREV_INSN (x) == prevx);\n \n-  if (prevx != get_last_insn ())\n-    abort ();\n+  gcc_assert (prevx == get_last_insn ());\n \n   for (nextx = NULL, insn_cnt2 = 1, x = get_last_insn ();\n        x != 0;\n        nextx = x, insn_cnt2++, x = PREV_INSN (x))\n-    if (NEXT_INSN (x) != nextx)\n-      abort ();\n+    gcc_assert (NEXT_INSN (x) == nextx);\n \n-  if (insn_cnt1 != insn_cnt2)\n-    abort ();\n+  gcc_assert (insn_cnt1 == insn_cnt2);\n }\n \f\n /* If we have assembler epilogues, the block falling through to exit must\n@@ -928,10 +918,10 @@ fixup_fallthru_exit_predecessor (void)\n   edge e;\n   basic_block bb = NULL;\n \n-  /* This transformation is not valid before reload, because we might separate\n-     a call from the instruction that copies the return value.  */\n-  if (! reload_completed)\n-    abort ();\n+  /* This transformation is not valid before reload, because we might\n+     separate a call from the instruction that copies the return\n+     value.  */\n+  gcc_assert (reload_completed);\n \n   for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     if (e->flags & EDGE_FALLTHRU)\n@@ -1058,31 +1048,23 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    case NOTE_INSN_BASIC_BLOCK:\n \t      break;\n \n-\t      /* There is no purpose to duplicate prologue.  */\n-\t    case NOTE_INSN_BLOCK_BEG:\n-\t    case NOTE_INSN_BLOCK_END:\n-\t      /* The BLOCK_BEG/BLOCK_END notes should be eliminated when BB\n-\t         reordering is in the progress.  */\n-\t    case NOTE_INSN_EH_REGION_BEG:\n-\t    case NOTE_INSN_EH_REGION_END:\n-\t      /* Should never exist at BB duplication time.  */\n-\t      abort ();\n-\t      break;\n \t    case NOTE_INSN_REPEATED_LINE_NUMBER:\n \t    case NOTE_INSN_UNLIKELY_EXECUTED_CODE:\n \t      emit_note_copy (insn);\n \t      break;\n \n \t    default:\n-\t      if (NOTE_LINE_NUMBER (insn) < 0)\n-\t\tabort ();\n+\t      /* All other notes should have already been eliminated.\n+\t       */\n+\t      gcc_assert (NOTE_LINE_NUMBER (insn) >= 0);\n+\t      \n \t      /* It is possible that no_line_number is set and the note\n \t         won't be emitted.  */\n \t      emit_note_copy (insn);\n \t    }\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   insn = NEXT_INSN (last);\n@@ -1217,7 +1199,7 @@ cfg_layout_finalize (void)\n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n #endif\n-\n+  \n   free_rbi_pool ();\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     bb->rbi = NULL;"}, {"sha": "01b9a4612de7ce1e2ff0b7313c6ecd4e88323c35", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 20, "deletions": 41, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -107,8 +107,7 @@ flow_loop_nested_p (const struct loop *outer, const struct loop *loop)\n struct loop *\n superloop_at_depth (struct loop *loop, unsigned depth)\n {\n-  if (depth > (unsigned) loop->depth)\n-    abort ();\n+  gcc_assert (depth <= (unsigned) loop->depth);\n \n   if (depth == (unsigned) loop->depth)\n     return loop;\n@@ -213,8 +212,7 @@ flow_loops_free (struct loops *loops)\n     {\n       unsigned i;\n \n-      if (! loops->num)\n-\tabort ();\n+      gcc_assert (loops->num);\n \n       /* Free the loop descriptors.  */\n       for (i = 0; i < loops->num; i++)\n@@ -253,8 +251,7 @@ flow_loop_entry_edges_find (struct loop *loop)\n \tnum_entries++;\n     }\n \n-  if (! num_entries)\n-    abort ();\n+  gcc_assert (num_entries);\n \n   loop->entry_edges = xmalloc (num_entries * sizeof (edge *));\n \n@@ -794,8 +791,7 @@ flow_loops_find (struct loops *loops, int flags)\n   /* This function cannot be repeatedly called with different\n      flags to build up the loop information.  The loop tree\n      must always be built if this function is called.  */\n-  if (! (flags & LOOP_TREE))\n-    abort ();\n+  gcc_assert (flags & LOOP_TREE);\n \n   memset (loops, 0, sizeof *loops);\n \n@@ -837,8 +833,7 @@ flow_loops_find (struct loops *loops, int flags)\n \t{\n \t  basic_block latch = e->src;\n \n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    abort ();\n+\t  gcc_assert (!(e->flags & EDGE_ABNORMAL));\n \n \t  /* Look for back edges where a predecessor is dominated\n \t     by this block.  A natural loop has a single entry\n@@ -849,8 +844,7 @@ flow_loops_find (struct loops *loops, int flags)\n \t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t    {\n \t      /* Shared headers should be eliminated by now.  */\n-\t      if (more_latches)\n-\t\tabort ();\n+\t      gcc_assert (!more_latches);\n \t      more_latches = 1;\n \t      SET_BIT (headers, header->index);\n \t      num_loops++;\n@@ -984,8 +978,7 @@ flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n bool\n flow_loop_outside_edge_p (const struct loop *loop, edge e)\n {\n-  if (e->dest != loop->header)\n-    abort ();\n+  gcc_assert (e->dest == loop->header);\n   return !flow_bb_inside_loop_p (loop, e->src);\n }\n \n@@ -1005,17 +998,15 @@ get_loop_body (const struct loop *loop)\n   basic_block *tovisit, bb;\n   unsigned tv = 0;\n \n-  if (!loop->num_nodes)\n-    abort ();\n+  gcc_assert (loop->num_nodes);\n \n   tovisit = xcalloc (loop->num_nodes, sizeof (basic_block));\n   tovisit[tv++] = loop->header;\n \n   if (loop->latch == EXIT_BLOCK_PTR)\n     {\n       /* There may be blocks unreachable from EXIT_BLOCK.  */\n-      if (loop->num_nodes != (unsigned) n_basic_blocks + 2)\n-\tabort ();\n+      gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks + 2);\n       FOR_EACH_BB (bb)\n \ttovisit[tv++] = bb;\n       tovisit[tv++] = EXIT_BLOCK_PTR;\n@@ -1027,8 +1018,7 @@ get_loop_body (const struct loop *loop)\n \t\t\t       loop->header) + 1;\n     }\n \n-  if (tv != loop->num_nodes)\n-    abort ();\n+  gcc_assert (tv == loop->num_nodes);\n   return tovisit;\n }\n \n@@ -1071,19 +1061,16 @@ get_loop_body_in_dom_order (const struct loop *loop)\n   basic_block *tovisit;\n   int tv;\n \n-  if (!loop->num_nodes)\n-    abort ();\n+  gcc_assert (loop->num_nodes);\n \n   tovisit = xcalloc (loop->num_nodes, sizeof (basic_block));\n \n-  if (loop->latch == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   tv = 0;\n   fill_sons_in_loop (loop, loop->header, tovisit, &tv);\n \n-  if (tv != (int) loop->num_nodes)\n-    abort ();\n+  gcc_assert (tv == (int) loop->num_nodes);\n \n   return tovisit;\n }\n@@ -1099,11 +1086,8 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n   unsigned int i = 0;\n   unsigned int vc = 1;\n \n-  if (!loop->num_nodes)\n-    abort ();\n-\n-  if (loop->latch == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (loop->num_nodes);\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   blocks = xcalloc (loop->num_nodes, sizeof (basic_block));\n   visited = BITMAP_XMALLOC ();\n@@ -1132,8 +1116,7 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n             }\n         }\n       \n-      if (i < vc)\n-        abort ();\n+      gcc_assert (i >= vc);\n       \n       bb = blocks[vc++];\n     }\n@@ -1150,8 +1133,7 @@ get_loop_exit_edges (const struct loop *loop, unsigned int *n_edges)\n   unsigned i, n;\n   basic_block * body;\n \n-  if (loop->latch == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   body = get_loop_body (loop);\n   n = 0;\n@@ -1179,8 +1161,7 @@ num_loop_branches (const struct loop *loop)\n   unsigned i, n;\n   basic_block * body;\n \n-  if (loop->latch == EXIT_BLOCK_PTR)\n-    abort ();\n+  gcc_assert (loop->latch != EXIT_BLOCK_PTR);\n \n   body = get_loop_body (loop);\n   n = 0;\n@@ -1246,8 +1227,7 @@ cancel_loop (struct loops *loops, struct loop *loop)\n   basic_block *bbs;\n   unsigned i;\n \n-  if (loop->inner)\n-    abort ();\n+  gcc_assert (!loop->inner);\n \n   /* Move blocks up one level (they should be removed as soon as possible).  */\n   bbs = get_loop_body (loop);\n@@ -1492,8 +1472,7 @@ verify_loop_structure (struct loops *loops)\n \t}\n     }\n \n-  if (err)\n-    abort ();\n+  gcc_assert (!err);\n \n   free (sizes);\n }"}, {"sha": "4c50bbe959c9763c7b86c3efe6f012fc98d94eba", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -208,8 +208,7 @@ check_irred (struct graph *g, struct edge *e)\n \n   /* All edges should lead from a component with higher number to the\n      one with lower one.  */\n-  if (g->vertices[e->src].component < g->vertices[e->dest].component)\n-    abort ();\n+  gcc_assert (g->vertices[e->src].component >= g->vertices[e->dest].component);\n \n   if (g->vertices[e->src].component != g->vertices[e->dest].component)\n     return;"}, {"sha": "62fb9d24e94c1e8ec6d62335b23acb0f1d3c2b3e", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 40, "deletions": 60, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -98,8 +98,7 @@ remove_bbs (basic_block *bbs, int nbbs)\n static int\n find_path (edge e, basic_block **bbs)\n {\n-  if (e->dest->pred->pred_next)\n-    abort ();\n+  gcc_assert (!e->dest->pred->pred_next);\n \n   /* Find bbs in the path.  */\n   *bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n@@ -323,6 +322,7 @@ remove_path (struct loops *loops, edge e)\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n   int i, nrem, n_bord_bbs, n_dom_bbs;\n   sbitmap seen;\n+  bool deleted;\n \n   if (!loop_delete_branch_edge (e, 0))\n     return false;\n@@ -367,8 +367,8 @@ remove_path (struct loops *loops, edge e)\n \n   /* Remove the path.  */\n   from = e->src;\n-  if (!loop_delete_branch_edge (e, 1))\n-    abort ();\n+  deleted = loop_delete_branch_edge (e, 1);\n+  gcc_assert (deleted);\n   dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n \n   /* Cancel loops contained in the path.  */\n@@ -765,47 +765,37 @@ static bool\n loop_delete_branch_edge (edge e, int really_delete)\n {\n   basic_block src = e->src;\n+  basic_block newdest;\n   int irr;\n   edge snd;\n \n-  if (src->succ->succ_next)\n-    {\n-      basic_block newdest;\n-\n-      /* Cannot handle more than two exit edges.  */\n-      if (src->succ->succ_next->succ_next)\n-\treturn false;\n-      /* And it must be just a simple branch.  */\n-      if (!any_condjump_p (BB_END (src)))\n-\treturn false;\n-\n-      snd = e == src->succ ? src->succ->succ_next : src->succ;\n-      newdest = snd->dest;\n-      if (newdest == EXIT_BLOCK_PTR)\n-\treturn false;\n-\n-      /* Hopefully the above conditions should suffice.  */\n-      if (!really_delete)\n-\treturn true;\n+  gcc_assert (src->succ->succ_next);\n+  \n+  /* Cannot handle more than two exit edges.  */\n+  if (src->succ->succ_next->succ_next)\n+    return false;\n+  /* And it must be just a simple branch.  */\n+  if (!any_condjump_p (BB_END (src)))\n+    return false;\n \n-      /* Redirecting behaves wrongly wrto this flag.  */\n-      irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n+  snd = e == src->succ ? src->succ->succ_next : src->succ;\n+  newdest = snd->dest;\n+  if (newdest == EXIT_BLOCK_PTR)\n+    return false;\n \n-      if (!redirect_edge_and_branch (e, newdest))\n-\treturn false;\n-      src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-      src->succ->flags |= irr;\n+  /* Hopefully the above conditions should suffice.  */\n+  if (!really_delete)\n+    return true;\n \n-      return true;\n-    }\n-  else\n-    {\n-      /* Cannot happen -- we are using this only to remove an edge\n-\t from branch.  */\n-      abort ();\n-    }\n+  /* Redirecting behaves wrongly wrto this flag.  */\n+  irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n \n-  return false;  /* To avoid warning, cannot get here.  */\n+  if (!redirect_edge_and_branch (e, newdest))\n+    return false;\n+  src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  src->succ->flags |= irr;\n+  \n+  return true;\n }\n \n /* Check whether LOOP's body can be duplicated.  */\n@@ -880,18 +870,14 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   int prob_pass_thru, prob_pass_wont_exit, prob_pass_main;\n   int add_irreducible_flag;\n \n-  if (e->dest != loop->header)\n-    abort ();\n-  if (ndupl <= 0)\n-    abort ();\n+  gcc_assert (e->dest == loop->header);\n+  gcc_assert (ndupl > 0);\n \n   if (orig)\n     {\n       /* Orig must be edge out of the loop.  */\n-      if (!flow_bb_inside_loop_p (loop, orig->src))\n-\tabort ();\n-      if (flow_bb_inside_loop_p (loop, orig->dest))\n-\tabort ();\n+      gcc_assert (flow_bb_inside_loop_p (loop, orig->src));\n+      gcc_assert (!flow_bb_inside_loop_p (loop, orig->dest));\n     }\n \n   bbs = get_loop_body (loop);\n@@ -907,8 +893,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   /* In case we are doing loop peeling and the loop is in the middle of\n      irreducible region, the peeled copies will be inside it too.  */\n   add_irreducible_flag = e->flags & EDGE_IRREDUCIBLE_LOOP;\n-  if (is_latch && add_irreducible_flag)\n-    abort ();\n+  gcc_assert (!is_latch || !add_irreducible_flag);\n \n   /* Find edge from latch.  */\n   latch_edge = loop_latch_edge (loop);\n@@ -960,11 +945,9 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t  scale_act = REG_BR_PROB_BASE - prob_pass_thru;\n \t}\n       for (i = 0; i < ndupl; i++)\n-\tif (scale_step[i] < 0 || scale_step[i] > REG_BR_PROB_BASE)\n-\t  abort ();\n-      if (scale_main < 0 || scale_main > REG_BR_PROB_BASE\n-\t  || scale_act < 0  || scale_act > REG_BR_PROB_BASE)\n-\tabort ();\n+\tgcc_assert (scale_step[i] >= 0 && scale_step[i] <= REG_BR_PROB_BASE);\n+      gcc_assert (scale_main >= 0 && scale_main <= REG_BR_PROB_BASE\n+\t\t  && scale_act >= 0  && scale_act <= REG_BR_PROB_BASE);\n     }\n \n   /* Loop the new bbs will belong to.  */\n@@ -1154,8 +1137,7 @@ create_preheader (struct loop *loop, int flags)\n       irred |= (e->flags & EDGE_IRREDUCIBLE_LOOP) != 0;\n       nentry++;\n     }\n-  if (!nentry)\n-    abort ();\n+  gcc_assert (nentry);\n   if (nentry == 1)\n     {\n       for (e = loop->header->pred; e->src == loop->latch; e = e->pred_next);\n@@ -1285,9 +1267,8 @@ create_loop_notes (void)\n #ifdef ENABLE_CHECKING\n   /* Verify that there really are no loop notes.  */\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (NOTE_P (insn)\n-\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-      abort ();\n+    gcc_assert (!NOTE_P (insn) ||\n+\t\tNOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG);\n #endif\n \n   flow_loops_find (&loops, LOOP_TREE);\n@@ -1335,8 +1316,7 @@ create_loop_notes (void)\n \t\t      && onlyjump_p (insn))\n \t\t    {\n \t\t      pbb = BLOCK_FOR_INSN (insn);\n-\t\t      if (!pbb || !pbb->succ || pbb->succ->succ_next)\n-\t\t\tabort ();\n+\t\t      gcc_assert (pbb && pbb->succ && !pbb->succ->succ_next);\n \n \t\t      if (!flow_bb_inside_loop_p (loop, pbb->succ->dest))\n \t\t\tinsn = BB_HEAD (first[loop->num]);"}, {"sha": "ce676a64f12e07fd8ef90e46c1768e470ed52077", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 65, "deletions": 75, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -139,8 +139,7 @@ delete_insn (rtx insn)\n   if (really_delete)\n     {\n       /* If this insn has already been deleted, something is very wrong.  */\n-      if (INSN_DELETED_P (insn))\n-\tabort ();\n+      gcc_assert (!INSN_DELETED_P (insn));\n       remove_insn (insn);\n       INSN_DELETED_P (insn) = 1;\n     }\n@@ -754,9 +753,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t INSN_UID (insn), e->dest->index, target->index);\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n-\t  if (target == EXIT_BLOCK_PTR)\n-\t    return NULL;\n-\t  abort ();\n+\t  gcc_assert (target == EXIT_BLOCK_PTR);\n+\t  return NULL;\n \t}\n     }\n \n@@ -923,17 +921,15 @@ redirect_branch_edge (edge e, basic_block target)\n \treturn NULL;\n \n       /* If the insn doesn't go where we think, we're confused.  */\n-      if (JUMP_LABEL (insn) != old_label)\n-\tabort ();\n+      gcc_assert (JUMP_LABEL (insn) == old_label);\n \n       /* If the substitution doesn't succeed, die.  This can happen\n \t if the back end emitted unrecognizable instructions or if\n \t target is exit block on some arches.  */\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n-\t  if (target == EXIT_BLOCK_PTR)\n-\t    return NULL;\n-\t  abort ();\n+\t  gcc_assert (target == EXIT_BLOCK_PTR);\n+\t  return NULL;\n \t}\n     }\n \n@@ -1006,9 +1002,11 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n     {\n       rtx note;\n       edge b = unchecked_make_edge (e->src, target, 0);\n+      bool redirected;\n \n-      if (!redirect_jump (BB_END (e->src), block_label (target), 0))\n-\tabort ();\n+      redirected = redirect_jump (BB_END (e->src), block_label (target), 0);\n+      gcc_assert (redirected);\n+      \n       note = find_reg_note (BB_END (e->src), REG_BR_PROB, NULL_RTX);\n       if (note)\n \t{\n@@ -1032,32 +1030,35 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t We can't redirect abnormal edge, but we still can split the fallthru\n \t one and create separate abnormal edge to original destination.\n \t This allows bb-reorder to make such edge non-fallthru.  */\n-      if (e->dest != target)\n-\tabort ();\n+      gcc_assert (e->dest == target);\n       abnormal_edge_flags = e->flags & ~(EDGE_FALLTHRU | EDGE_CAN_FALLTHRU);\n       e->flags &= EDGE_FALLTHRU | EDGE_CAN_FALLTHRU;\n     }\n-  else if (!(e->flags & EDGE_FALLTHRU))\n-    abort ();\n-  else if (e->src == ENTRY_BLOCK_PTR)\n+  else\n     {\n-      /* We can't redirect the entry block.  Create an empty block at the\n-         start of the function which we use to add the new jump.  */\n-      edge *pe1;\n-      basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n-\n-      /* Change the existing edge's source to be the new block, and add\n-\t a new edge from the entry block to the new block.  */\n-      e->src = bb;\n-      for (pe1 = &ENTRY_BLOCK_PTR->succ; *pe1; pe1 = &(*pe1)->succ_next)\n-\tif (*pe1 == e)\n-\t  {\n-\t    *pe1 = e->succ_next;\n-\t    break;\n-\t  }\n-      e->succ_next = 0;\n-      bb->succ = e;\n-      make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n+      gcc_assert (e->flags & EDGE_FALLTHRU);\n+      if (e->src == ENTRY_BLOCK_PTR)\n+\t{\n+\t  /* We can't redirect the entry block.  Create an empty block\n+             at the start of the function which we use to add the new\n+             jump.  */\n+\t  edge *pe1;\n+\t  basic_block bb\n+\t    = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n+\n+\t  /* Change the existing edge's source to be the new block, and add\n+\t     a new edge from the entry block to the new block.  */\n+\t  e->src = bb;\n+\t  for (pe1 = &ENTRY_BLOCK_PTR->succ; *pe1; pe1 = &(*pe1)->succ_next)\n+\t    if (*pe1 == e)\n+\t      {\n+\t\t*pe1 = e->succ_next;\n+\t\tbreak;\n+\t      }\n+\t  e->succ_next = 0;\n+\t  bb->succ = e;\n+\t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n+\t}\n     }\n \n   if (e->src->succ->succ_next || abnormal_edge_flags)\n@@ -1138,7 +1139,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n #ifdef HAVE_return\n \temit_jump_insn_after (gen_return (), BB_END (jump_block));\n #else\n-\tabort ();\n+\tgcc_unreachable ();\n #endif\n     }\n   else\n@@ -1295,8 +1296,7 @@ rtl_split_edge (edge edge_in)\n   rtx before;\n \n   /* Abnormal edges cannot be split.  */\n-  if ((edge_in->flags & EDGE_ABNORMAL) != 0)\n-    abort ();\n+  gcc_assert (!(edge_in->flags & EDGE_ABNORMAL));\n \n   /* We are going to place the new block in front of edge destination.\n      Avoid existence of fallthru predecessors.  */\n@@ -1378,8 +1378,8 @@ rtl_split_edge (edge edge_in)\n      jump instruction to target our new block.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n-      if (!redirect_edge_and_branch (edge_in, bb))\n-\tabort ();\n+      edge redirected = redirect_edge_and_branch (edge_in, bb);\n+      gcc_assert (redirected);\n     }\n   else\n     redirect_edge_succ (edge_in, bb);\n@@ -1396,8 +1396,7 @@ insert_insn_on_edge (rtx pattern, edge e)\n {\n   /* We cannot insert instructions on an abnormal critical edge.\n      It will be easier to find the culprit if we die now.  */\n-  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n-    abort ();\n+  gcc_assert (!((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e)));\n \n   if (e->insns.r == NULL_RTX)\n     start_sequence ();\n@@ -1584,9 +1583,9 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t      ;\n \t  else\n \t    {\n-\t      /* We'd better be fallthru, or we've lost track of what's what.  */\n-\t      if ((e->flags & EDGE_FALLTHRU) == 0)\n-\t\tabort ();\n+\t      /* We'd better be fallthru, or we've lost track of\n+\t\t what's what.  */\n+\t      gcc_assert (e->flags & EDGE_FALLTHRU);\n \n \t      after = BB_END (bb);\n \t    }\n@@ -1647,18 +1646,17 @@ commit_one_edge_insertion (edge e, int watch_calls)\n          to EXIT.  */\n \n       e = bb->succ;\n-      if (e->dest != EXIT_BLOCK_PTR\n-\t  || e->succ_next != NULL || (e->flags & EDGE_FALLTHRU) == 0)\n-\tabort ();\n+      gcc_assert (e->dest == EXIT_BLOCK_PTR\n+\t\t  && !e->succ_next && (e->flags & EDGE_FALLTHRU));\n \n       e->flags &= ~EDGE_FALLTHRU;\n       emit_barrier_after (last);\n \n       if (before)\n \tdelete_insn (before);\n     }\n-  else if (JUMP_P (last))\n-    abort ();\n+  else\n+    gcc_assert (!JUMP_P (last));\n \n   /* Mark the basic block for find_sub_basic_blocks.  */\n   bb->aux = &bb->aux;\n@@ -1703,8 +1701,7 @@ commit_edge_insertions (void)\n         SET_BIT (blocks, bb->index);\n \t/* Check for forgotten bb->aux values before commit_edge_insertions\n \t   call.  */\n-\tif (bb->aux != &bb->aux)\n-\t  abort ();\n+\tgcc_assert (bb->aux == &bb->aux);\n \tbb->aux = NULL;\n       }\n   find_many_sub_basic_blocks (blocks);\n@@ -1751,8 +1748,7 @@ commit_edge_insertions_watch_calls (void)\n         SET_BIT (blocks, bb->index);\n \t/* Check for forgotten bb->aux values before commit_edge_insertions\n \t   call.  */\n-\tif (bb->aux != &bb->aux)\n-\t  abort ();\n+\tgcc_assert (bb->aux == &bb->aux);\n \tbb->aux = NULL;\n       }\n   find_many_sub_basic_blocks (blocks);\n@@ -2397,10 +2393,8 @@ purge_dead_edges (basic_block bb)\n \t from non-local gotos and the like.  If there were, we shouldn't\n \t have created the sibcall in the first place.  Second, there\n \t should of course never have been a fallthru edge.  */\n-      if (!bb->succ || bb->succ->succ_next)\n-\tabort ();\n-      if (bb->succ->flags != (EDGE_SIBCALL | EDGE_ABNORMAL))\n-\tabort ();\n+      gcc_assert (bb->succ && !bb->succ->succ_next);\n+      gcc_assert (bb->succ->flags == (EDGE_SIBCALL | EDGE_ABNORMAL));\n \n       return 0;\n     }\n@@ -2428,8 +2422,7 @@ purge_dead_edges (basic_block bb)\n \t}\n     }\n \n-  if (!bb->succ || bb->succ->succ_next)\n-    abort ();\n+  gcc_assert (bb->succ && !bb->succ->succ_next);\n \n   bb->succ->probability = REG_BR_PROB_BASE;\n   bb->succ->count = bb->count;\n@@ -2533,13 +2526,15 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t  && label_is_jump_target_p (BB_HEAD (e->dest),\n \t\t\t\t     BB_END (src)))\n \t{\n+\t  edge redirected;\n+\t  \n \t  if (dump_file)\n \t    fprintf (dump_file, \"Fallthru edge unified with branch \"\n \t\t     \"%i->%i redirected to %i\\n\",\n \t\t     e->src->index, e->dest->index, dest->index);\n \t  e->flags &= ~EDGE_FALLTHRU;\n-\t  if (!redirect_branch_edge (e, dest))\n-\t    abort ();\n+\t  redirected = redirect_branch_edge (e, dest);\n+\t  gcc_assert (redirected);\n \t  e->flags |= EDGE_FALLTHRU;\n           e->src->flags |= BB_DIRTY;\n \t  return e;\n@@ -2564,8 +2559,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n     ret = redirect_branch_edge (e, dest);\n \n   /* We don't want simplejumps in the insn stream during cfglayout.  */\n-  if (simplejump_p (BB_END (src)))\n-    abort ();\n+  gcc_assert (!simplejump_p (BB_END (src)));\n \n   src->flags |= BB_DIRTY;\n   return ret;\n@@ -2575,8 +2569,9 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n static basic_block\n cfg_layout_redirect_edge_and_branch_force (edge e, basic_block dest)\n {\n-  if (!cfg_layout_redirect_edge_and_branch (e, dest))\n-    abort ();\n+  edge redirected = cfg_layout_redirect_edge_and_branch (e, dest);\n+\n+  gcc_assert (redirected);\n   return NULL;\n }\n \n@@ -2700,8 +2695,7 @@ static void\n cfg_layout_merge_blocks (basic_block a, basic_block b)\n {\n #ifdef ENABLE_CHECKING\n-  if (!cfg_layout_can_merge_blocks_p (a, b))\n-    abort ();\n+  gcc_assert (cfg_layout_can_merge_blocks_p (a, b));\n #endif\n \n   /* If there was a CODE_LABEL beginning B, delete it.  */\n@@ -2712,8 +2706,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n      it cleaned up.  */\n   if (JUMP_P (BB_END (a)))\n     try_redirect_by_replacing_jump (a->succ, b, true);\n-  if (JUMP_P (BB_END (a)))\n-    abort ();\n+  gcc_assert (!JUMP_P (BB_END (a)));\n \n   /* Possible line number notes should appear in between.  */\n   if (b->rbi->header)\n@@ -2734,8 +2727,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (first))\n \tfirst = NEXT_INSN (first);\n-      if (!NOTE_INSN_BASIC_BLOCK_P (first))\n-\tabort ();\n+      gcc_assert (NOTE_INSN_BASIC_BLOCK_P (first));\n       BB_HEAD (b) = NULL;\n       delete_insn (first);\n     }\n@@ -2752,8 +2744,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       /* Skip possible DELETED_LABEL insn.  */\n       if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n \tinsn = NEXT_INSN (insn);\n-      if (!NOTE_INSN_BASIC_BLOCK_P (insn))\n-\tabort ();\n+      gcc_assert (NOTE_INSN_BASIC_BLOCK_P (insn));\n       BB_HEAD (b) = NULL;\n       BB_END (a) = BB_END (b);\n       delete_insn (insn);\n@@ -2963,8 +2954,7 @@ rtl_flow_call_edges_add (sbitmap blocks)\n #ifdef ENABLE_CHECKING\n \t      if (split_at_insn == BB_END (bb))\n \t\tfor (e = bb->succ; e; e = e->succ_next)\n-\t\t  if (e->dest == EXIT_BLOCK_PTR)\n-\t\t    abort ();\n+\t\t  gcc_assert (e->dest != EXIT_BLOCK_PTR);\n #endif\n \n \t      /* Note that the following may create a new basic block"}, {"sha": "a2cb174d76707fd67d5da216b2ca5cca7d49b466", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -170,8 +170,7 @@ cgraph_node (tree decl)\n {\n   struct cgraph_node key, *node, **slot;\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   if (!cgraph_hash)\n     cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n@@ -223,12 +222,10 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   struct cgraph_edge *e;\n \n   for (e = caller->callees; e; e = e->next_callee)\n-    if (e->call_expr == call_expr)\n-      abort ();\n+    gcc_assert (e->call_expr != call_expr);\n #endif\n \n-  if (TREE_CODE (call_expr) != CALL_EXPR)\n-    abort ();\n+  gcc_assert (TREE_CODE (call_expr) == CALL_EXPR);\n \n   if (!DECL_SAVED_TREE (callee->decl))\n     edge->inline_failed = N_(\"function body not available\");\n@@ -262,14 +259,12 @@ cgraph_remove_edge (struct cgraph_edge *e)\n   for (edge = &e->callee->callers; *edge && *edge != e;\n        edge = &((*edge)->next_caller))\n     continue;\n-  if (!*edge)\n-    abort ();\n+  gcc_assert (*edge);\n   *edge = (*edge)->next_caller;\n   for (edge2 = &e->caller->callees; *edge2 && *edge2 != e;\n        edge2 = &(*edge2)->next_callee)\n     continue;\n-  if (!*edge2)\n-    abort ();\n+  gcc_assert (*edge2);\n   *edge2 = (*edge2)->next_callee;\n }\n \n@@ -284,8 +279,7 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n   for (edge = &e->callee->callers; *edge && *edge != e;\n        edge = &((*edge)->next_caller))\n     continue;\n-  if (!*edge)\n-    abort ();\n+  gcc_assert (*edge);\n   *edge = (*edge)->next_caller;\n   e->callee = n;\n   e->next_caller = n->callers;\n@@ -412,8 +406,8 @@ struct cgraph_local_info *\n cgraph_local_info (tree decl)\n {\n   struct cgraph_node *node;\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    abort ();\n+  \n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   node = cgraph_node (decl);\n   return &node->local;\n }\n@@ -424,8 +418,8 @@ struct cgraph_global_info *\n cgraph_global_info (tree decl)\n {\n   struct cgraph_node *node;\n-  if (TREE_CODE (decl) != FUNCTION_DECL || !cgraph_global_info_ready)\n-    abort ();\n+  \n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL && cgraph_global_info_ready);\n   node = cgraph_node (decl);\n   return &node->global;\n }\n@@ -436,8 +430,8 @@ struct cgraph_rtl_info *\n cgraph_rtl_info (tree decl)\n {\n   struct cgraph_node *node;\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    abort ();\n+  \n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   node = cgraph_node (decl);\n   if (decl != current_function_decl\n       && !TREE_ASM_WRITTEN (node->decl))\n@@ -542,8 +536,7 @@ cgraph_varpool_node (tree decl)\n {\n   struct cgraph_varpool_node key, *node, **slot;\n \n-  if (!DECL_P (decl) || TREE_CODE (decl) == FUNCTION_DECL)\n-    abort ();\n+  gcc_assert (DECL_P (decl) && TREE_CODE (decl) != FUNCTION_DECL);\n \n   if (!cgraph_varpool_hash)\n     cgraph_varpool_hash = htab_create_ggc (10, hash_varpool_node,"}, {"sha": "a045457e21bd31cb796e02a593e12136cb26350d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -329,8 +329,7 @@ cgraph_finalize_function (tree decl, bool nested)\n \t case can be sort-of legitimately seen with real function \n \t redefinition errors.  I would argue that the front end should\n \t never present us with such a case, but don't enforce that for now.  */\n-      if (node->output)\n-\tabort ();\n+      gcc_assert (!node->output);\n \n       /* Reset our data structures so we can analyze the function again.  */\n       memset (&node->local, 0, sizeof (node->local));\n@@ -697,8 +696,8 @@ cgraph_finalize_compilation_unit (void)\n       if (!DECL_SAVED_TREE (decl))\n \tcontinue;\n \n-      if (node->analyzed || !node->reachable || !DECL_SAVED_TREE (decl))\n-\tabort ();\n+      gcc_assert (!node->analyzed && node->reachable);\n+      gcc_assert (DECL_SAVED_TREE (decl));\n \n       cgraph_analyze_function (node);\n \n@@ -756,8 +755,8 @@ cgraph_mark_functions_to_output (void)\n     {\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n-      if (node->output)\n-\tabort ();\n+      \n+      gcc_assert (!node->output);\n \n       for (e = node->callers; e; e = e->next_caller)\n \tif (e->inline_failed)\n@@ -773,13 +772,10 @@ cgraph_mark_functions_to_output (void)\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n-      /* We should've reclaimed all functions that are not needed.  */\n-      else if (!node->global.inlined_to && DECL_SAVED_TREE (decl)\n-\t       && !DECL_EXTERNAL (decl))\n-\t{\n-\t  dump_cgraph_node (stderr, node);\n-\t  abort ();\n-\t}\n+      else\n+\t/* We should've reclaimed all functions that are not needed.  */\n+\tgcc_assert (node->global.inlined_to || !DECL_SAVED_TREE (decl)\n+\t\t    || DECL_EXTERNAL (decl));\n     }\n }\n \n@@ -791,8 +787,7 @@ cgraph_expand_function (struct cgraph_node *node)\n   tree decl = node->decl;\n \n   /* We ought to not compile any inline clones.  */\n-  if (node->global.inlined_to)\n-    abort ();\n+  gcc_assert (!node->global.inlined_to);\n \n   if (flag_unit_at_a_time)\n     announce_function (decl);\n@@ -802,8 +797,7 @@ cgraph_expand_function (struct cgraph_node *node)\n \n   /* Make sure that BE didn't give up on compiling.  */\n   /* ??? Can happen with nested function of extern inline.  */\n-  if (!TREE_ASM_WRITTEN (node->decl))\n-    abort ();\n+  gcc_assert (TREE_ASM_WRITTEN (node->decl));\n \n   current_function_decl = NULL;\n   if (DECL_SAVED_TREE (node->decl)\n@@ -895,8 +889,7 @@ cgraph_remove_unreachable_nodes (void)\n     fprintf (cgraph_dump_file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->aux)\n-      abort ();\n+    gcc_assert (!node->aux);\n #endif\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->needed && !node->global.inlined_to\n@@ -905,8 +898,8 @@ cgraph_remove_unreachable_nodes (void)\n \tnode->aux = first;\n \tfirst = node;\n       }\n-    else if (node->aux)\n-      abort ();\n+    else\n+      gcc_assert (!node->aux);\n \n   /* Perform reachability analysis.  As a special case do not consider\n      extern inline functions not inlined as live because we won't output\n@@ -1040,8 +1033,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n       && duplicate\n       && flag_unit_at_a_time)\n     {\n-      if (e->callee->global.inlined_to)\n-\tabort ();\n+      gcc_assert (!e->callee->global.inlined_to);\n       if (!DECL_EXTERNAL (e->callee->decl))\n         overall_insns -= e->callee->global.insns, nfunctions_inlined++;\n       duplicate = 0;\n@@ -1071,8 +1063,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n   int old_insns = 0, new_insns = 0;\n   struct cgraph_node *to = NULL, *what;\n \n-  if (!e->inline_failed)\n-    abort ();\n+  gcc_assert (e->inline_failed);\n   e->inline_failed = NULL;\n \n   if (!e->callee->global.inlined && flag_unit_at_a_time)\n@@ -1089,13 +1080,11 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n       old_insns = e->caller->global.insns;\n       new_insns = cgraph_estimate_size_after_inlining (1, e->caller,\n \t\t\t\t\t\t       what);\n-      if (new_insns < 0)\n-\tabort ();\n+      gcc_assert (new_insns >= 0);\n       to = e->caller;\n       to->global.insns = new_insns;\n     }\n-  if (what->global.inlined_to != to)\n-    abort ();\n+  gcc_assert (what->global.inlined_to == to);\n   overall_insns += new_insns - old_insns;\n   ncalls_inlined++;\n }\n@@ -1122,11 +1111,10 @@ cgraph_mark_inline (struct cgraph_edge *edge)\n           cgraph_mark_inline_edge (e);\n \t  if (e == edge)\n \t    edge = next;\n-\t  times ++;\n+\t  times++;\n \t}\n     }\n-  if (!times)\n-    abort ();\n+  gcc_assert (times);\n   return edge;\n }\n \n@@ -1653,8 +1641,7 @@ cgraph_expand_all_functions (void)\n   cgraph_mark_functions_to_output ();\n \n   order_pos = cgraph_postorder (order);\n-  if (order_pos != cgraph_n_nodes)\n-    abort ();\n+  gcc_assert (order_pos == cgraph_n_nodes);\n \n   /* Garbage collector may remove inline clones we eliminate during\n      optimization.  So we must be sure to not reference them.  */\n@@ -1667,8 +1654,7 @@ cgraph_expand_all_functions (void)\n       node = order[i];\n       if (node->output)\n \t{\n-\t  if (!node->reachable)\n-\t    abort ();\n+\t  gcc_assert (node->reachable);\n \t  node->output = 0;\n \t  cgraph_expand_function (node);\n \t}\n@@ -1831,12 +1817,17 @@ cgraph_build_static_cdtor (char which, tree body, int priority)\n   DECL_SOURCE_LOCATION (decl) = input_location;\n   cfun->function_end_locus = input_location;\n \n-  if (which == 'I')\n-    DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-  else if (which == 'D')\n-    DECL_STATIC_DESTRUCTOR (decl) = 1;\n-  else\n-    abort ();\n+  switch (which)\n+    {\n+    case 'I':\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      break;\n+    case 'D':\n+      DECL_STATIC_DESTRUCTOR (decl) = 1;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   gimplify_function_tree (decl);\n "}, {"sha": "6f1ce6c27599358a970dc66a53979ba57184e9f6", "filename": "gcc/combine.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -455,21 +455,19 @@ do_SUBST (rtx *into, rtx newval)\n     {\n       /* Sanity check that we're replacing oldval with a CONST_INT\n \t that is a valid sign-extension for the original mode.  */\n-      if (INTVAL (newval) != trunc_int_for_mode (INTVAL (newval),\n-\t\t\t\t\t\t GET_MODE (oldval)))\n-\tabort ();\n+      gcc_assert (INTVAL (newval)\n+\t\t  == trunc_int_for_mode (INTVAL (newval), GET_MODE (oldval)));\n \n       /* Replacing the operand of a SUBREG or a ZERO_EXTEND with a\n \t CONST_INT is not valid, because after the replacement, the\n \t original mode would be gone.  Unfortunately, we can't tell\n \t when do_SUBST is called to replace the operand thereof, so we\n \t perform this test on oldval instead, checking whether an\n \t invalid replacement took place before we got here.  */\n-      if ((GET_CODE (oldval) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (oldval)) == CONST_INT)\n-\t  || (GET_CODE (oldval) == ZERO_EXTEND\n-\t      && GET_CODE (XEXP (oldval, 0)) == CONST_INT))\n-\tabort ();\n+      gcc_assert (!(GET_CODE (oldval) == SUBREG\n+\t\t    && GET_CODE (SUBREG_REG (oldval)) == CONST_INT));\n+      gcc_assert (!(GET_CODE (oldval) == ZERO_EXTEND\n+\t\t    && GET_CODE (XEXP (oldval, 0)) == CONST_INT));\n     }\n \n   if (undobuf.frees)\n@@ -1746,8 +1744,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t{\n \t  /* We don't handle the case of the target word being wider\n \t     than a host wide int.  */\n-\t  if (HOST_BITS_PER_WIDE_INT < BITS_PER_WORD)\n-\t    abort ();\n+\t  gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD);\n \n \t  lo &= ~(UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1);\n \t  lo |= (INTVAL (SET_SRC (PATTERN (i3)))\n@@ -1770,7 +1767,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       else\n \t/* We don't handle the case of the higher word not fitting\n \t   entirely in either hi or lo.  */\n-\tabort ();\n+\tgcc_unreachable ();\n \n       combine_merges++;\n       subst_insn = i3;\n@@ -3639,8 +3636,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t{\n \t\t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n-\t\t  if (! x)\n-\t\t    abort ();\n+\t\t  gcc_assert (x);\n \t\t}\n \t      else\n \t\tSUBST (XEXP (x, i), new);\n@@ -4693,8 +4689,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \trtx op1 = XEXP (x, 1);\n \tint len;\n \n-\tif (GET_CODE (op1) != PARALLEL)\n-\t  abort ();\n+\tgcc_assert (GET_CODE (op1) == PARALLEL);\n \tlen = XVECLEN (op1, 0);\n \tif (len == 1\n \t    && GET_CODE (XVECEXP (op1, 0, 0)) == CONST_INT\n@@ -5699,7 +5694,7 @@ simplify_logical (rtx x)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return x;\n@@ -11705,10 +11700,11 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \tcase REG_NON_LOCAL_GOTO:\n \t  if (JUMP_P (i3))\n \t    place = i3;\n-\t  else if (i2 && JUMP_P (i2))\n-\t    place = i2;\n \t  else\n-\t    abort ();\n+\t    {\n+\t      gcc_assert (i2 && JUMP_P (i2));\n+\t      place = i2;\n+\t    }\n \t  break;\n \n \tcase REG_EH_REGION:\n@@ -11717,8 +11713,9 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t    place = i3;\n \t  else if (i2 && CALL_P (i2))\n \t    place = i2;\n-\t  else if (flag_non_call_exceptions)\n+\t  else\n \t    {\n+\t      gcc_assert (flag_non_call_exceptions);\n \t      if (may_trap_p (i3))\n \t\tplace = i3;\n \t      else if (i2 && may_trap_p (i2))\n@@ -11727,8 +11724,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t can now prove that the instructions can't trap.  Drop the\n \t\t note in this case.  */\n \t    }\n-\t  else\n-\t    abort ();\n \t  break;\n \n \tcase REG_ALWAYS_RETURN:\n@@ -11738,10 +11733,11 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t     possible for both I2 and I3 to be a call.  */\n \t  if (CALL_P (i3))\n \t    place = i3;\n-\t  else if (i2 && CALL_P (i2))\n-\t    place = i2;\n \t  else\n-\t    abort ();\n+\t    {\n+\t      gcc_assert (i2 && CALL_P (i2));\n+\t      place = i2;\n+\t    }\n \t  break;\n \n \tcase REG_UNUSED:\n@@ -11848,22 +11844,30 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t     a JUMP_LABEL instead or decrement LABEL_NUSES.  */\n \t  if (place && JUMP_P (place))\n \t    {\n-\t      if (!JUMP_LABEL (place))\n+\t      rtx label = JUMP_LABEL (place);\n+\t      \n+\t      if (!label)\n \t\tJUMP_LABEL (place) = XEXP (note, 0);\n-\t      else if (JUMP_LABEL (place) != XEXP (note, 0))\n-\t\tabort ();\n-\t      else if (LABEL_P (JUMP_LABEL (place)))\n-\t\tLABEL_NUSES (JUMP_LABEL (place))--;\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (label == XEXP (note, 0));\n+\t\t  if (LABEL_P (label))\n+\t\t    LABEL_NUSES (label)--;\n+\t\t}\n \t      place = 0;\n \t    }\n \t  if (place2 && JUMP_P (place2))\n \t    {\n-\t      if (!JUMP_LABEL (place2))\n+\t      rtx label = JUMP_LABEL (place2);\n+\t      \n+\t      if (!label)\n \t\tJUMP_LABEL (place2) = XEXP (note, 0);\n-\t      else if (JUMP_LABEL (place2) != XEXP (note, 0))\n-\t\tabort ();\n-\t      else if (LABEL_P (JUMP_LABEL (place2)))\n-\t\tLABEL_NUSES (JUMP_LABEL (place2))--;\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (label == XEXP (note, 0));\n+\t\t  if (LABEL_P (label))\n+\t\t    LABEL_NUSES (label)--;\n+\t\t}\n \t      place2 = 0;\n \t    }\n \t  break;\n@@ -12192,7 +12196,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \tdefault:\n \t  /* Any other notes should not be present at this point in the\n \t     compilation.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (place)\n@@ -12348,8 +12352,7 @@ insn_cuid (rtx insn)\n \t && NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE)\n     insn = NEXT_INSN (insn);\n \n-  if (INSN_UID (insn) > max_uid_cuid)\n-    abort ();\n+  gcc_assert (INSN_UID (insn) <= max_uid_cuid);\n \n   return INSN_CUID (insn);\n }"}, {"sha": "31886fa764b51c02e4ef8f0d726bce040a2e38b7", "filename": "gcc/conflict.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -190,8 +190,7 @@ conflict_graph_add (conflict_graph graph, int reg1, int reg2)\n   void **slot;\n \n   /* A reg cannot conflict with itself.  */\n-  if (reg1 == reg2)\n-    abort ();\n+  gcc_assert (reg1 != reg2);\n \n   dummy.smaller = smaller;\n   dummy.larger = larger;\n@@ -324,10 +323,11 @@ print_conflict (int reg1, int reg2, void *contextp)\n      is the interesting one.  */\n   if (reg1 == context->reg)\n     reg = reg2;\n-  else if (reg2 == context->reg)\n-    reg = reg1;\n   else\n-    abort ();\n+    {\n+      gcc_assert (reg2 == context->reg);\n+      reg = reg1;\n+    }\n \n   /* Print the conflict.  */\n   fprintf (context->fp, \" %d\", reg);"}, {"sha": "ac2c48020091be93999ef412886f25868980836b", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -403,8 +403,7 @@ rtl_coverage_counter_ref (unsigned counter, unsigned no)\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n   rtx ref;\n \n-  if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n-    abort ();\n+  gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n   if (!ctr_labels[counter])\n       {\n@@ -428,8 +427,7 @@ tree_coverage_counter_ref (unsigned counter, unsigned no)\n {\n   tree domain_type = TYPE_DOMAIN (TREE_TYPE (tree_ctr_tables[counter]));\n \n-  if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n-    abort ();\n+  gcc_assert (no < fn_n_ctrs[counter] - fn_b_ctrs[counter]);\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n \n   /* \"no\" here is an array index, scaled to bytes later.  */\n@@ -462,6 +460,7 @@ coverage_checksum_string (unsigned chksum, const char *string)\n \t    {\n \t      int y;\n \t      unsigned seed;\n+\t      int scan;\n \n \t      for (y = 1; y < 9; y++)\n \t\tif (!(string[i + y] >= '0' && string[i + y] <= '9')\n@@ -475,8 +474,8 @@ coverage_checksum_string (unsigned chksum, const char *string)\n \t\t  break;\n \t      if (y != 18)\n \t\tcontinue;\n-\t      if (!sscanf (string + i + 10, \"%X\", &seed))\n-\t\tabort ();\n+\t      scan = sscanf (string + i + 10, \"%X\", &seed);\n+\t      gcc_assert (scan);\n \t      if (seed != crc32_string (0, flag_random_seed))\n \t\tcontinue;\n \t      string = dup = xstrdup (string);"}, {"sha": "7b540a6e6b2dfeddadb6c996511a2f9411d785a2", "filename": "gcc/cse.c", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -925,8 +925,7 @@ make_new_qty (unsigned int reg, enum machine_mode mode)\n   struct qty_table_elem *ent;\n   struct reg_eqv_elem *eqv;\n \n-  if (next_qty >= max_qty)\n-    abort ();\n+  gcc_assert (next_qty < max_qty);\n \n   q = REG_QTY (reg) = next_qty++;\n   ent = &qty_table[q];\n@@ -953,8 +952,7 @@ make_regs_eqv (unsigned int new, unsigned int old)\n   ent = &qty_table[q];\n \n   /* Nothing should become eqv until it has a \"non-invalid\" qty number.  */\n-  if (! REGNO_QTY_VALID_P (old))\n-    abort ();\n+  gcc_assert (REGNO_QTY_VALID_P (old));\n \n   REG_QTY (new) = q;\n   firstr = ent->first_reg;\n@@ -1424,8 +1422,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n \n   /* If X is a register and we haven't made a quantity for it,\n      something is wrong.  */\n-  if (REG_P (x) && ! REGNO_QTY_VALID_P (REGNO (x)))\n-    abort ();\n+  gcc_assert (!REG_P (x) || REGNO_QTY_VALID_P (REGNO (x)));\n \n   /* If X is a hard register, show it is being put in the table.  */\n   if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n@@ -1832,7 +1829,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n       return;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -2334,8 +2331,9 @@ hash_rtx (rtx x, enum machine_mode mode, int *do_not_record_p,\n   fmt = GET_RTX_FORMAT (code);\n   for (; i >= 0; i--)\n     {\n-      if (fmt[i] == 'e')\n+      switch (fmt[i])\n \t{\n+\tcase 'e':\n \t  /* If we are about to do the last recursive call\n \t     needed at this level, change it into iteration.\n \t     This function  is called enough to be worth it.  */\n@@ -2347,24 +2345,29 @@ hash_rtx (rtx x, enum machine_mode mode, int *do_not_record_p,\n \n \t  hash += hash_rtx (XEXP (x, i), 0, do_not_record_p,\n \t\t\t    hash_arg_in_memory_p, have_reg_qty);\n-\t}\n+\t  break;\n \n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  {\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    hash += hash_rtx (XVECEXP (x, i, j), 0, do_not_record_p,\n \t\t\t      hash_arg_in_memory_p, have_reg_qty);\n-\t  }\n+\t  break;\n \n-      else if (fmt[i] == 's')\n-\thash += hash_rtx_string (XSTR (x, i));\n-      else if (fmt[i] == 'i')\n-\thash += (unsigned int) XINT (x, i);\n-      else if (fmt[i] == '0' || fmt[i] == 't')\n-\t/* Unused.  */\n-\t;\n-      else\n-\tabort ();\n+\tcase 's':\n+\t  hash += hash_rtx_string (XSTR (x, i));\n+\t  break;\n+\n+\tcase 'i':\n+\t  hash += (unsigned int) XINT (x, i);\n+\t  break;\n+\n+\tcase '0': case 't':\n+\t  /* Unused.  */\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n   return hash;\n@@ -2573,7 +2576,7 @@ exp_equiv_p (rtx x, rtx y, int validate, bool for_gcse)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n \n@@ -6979,8 +6982,7 @@ cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)\n \t}\n     }\n \n-  if (next_qty > max_qty)\n-    abort ();\n+  gcc_assert (next_qty <= max_qty);\n \n   free (qty_table + max_reg);\n \n@@ -7099,7 +7101,7 @@ count_reg_usage (rtx x, int *counts, int incr)\n       return;\n \n     case INSN_LIST:\n-      abort ();\n+      gcc_unreachable ();\n \n     default:\n       break;\n@@ -7458,8 +7460,7 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n \n \t\t      if (mode != comp_mode)\n \t\t\t{\n-\t\t\t  if (! can_change_mode)\n-\t\t\t    abort ();\n+\t\t\t  gcc_assert (can_change_mode);\n \t\t\t  mode = comp_mode;\n \t\t\t  PUT_MODE (cc_src, mode);\n \t\t\t}\n@@ -7507,8 +7508,7 @@ cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n \t  submode = cse_cc_succs (e->dest, cc_reg, cc_src, false);\n \t  if (submode != VOIDmode)\n \t    {\n-\t      if (submode != mode)\n-\t\tabort ();\n+\t      gcc_assert (submode == mode);\n \t      found_equiv = true;\n \t      can_change_mode = false;\n \t    }\n@@ -7636,8 +7636,7 @@ cse_condition_code_reg (void)\n       mode = cse_cc_succs (bb, cc_reg, cc_src, true);\n       if (mode != VOIDmode)\n \t{\n-\t  if (mode != GET_MODE (cc_src))\n-\t    abort ();\n+\t  gcc_assert (mode == GET_MODE (cc_src));\n \t  if (mode != orig_mode)\n \t    {\n \t      rtx newreg = gen_rtx_REG (mode, REGNO (cc_reg));"}, {"sha": "aa9224892d9d8a27329d54642cd24c7b4e21996a", "filename": "gcc/cselib.c", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/341c100fc52d5e5175ac3e3aa3caf096c8ac1378/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=341c100fc52d5e5175ac3e3aa3caf096c8ac1378", "patch": "@@ -235,9 +235,9 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n   rtx x = (rtx) x_arg;\n   enum machine_mode mode = GET_MODE (x);\n \n-  if (GET_CODE (x) == CONST_INT\n-      || (mode == VOIDmode && GET_CODE (x) == CONST_DOUBLE))\n-    abort ();\n+  gcc_assert (GET_CODE (x) != CONST_INT\n+\t      && (mode != VOIDmode || GET_CODE (x) != CONST_DOUBLE));\n+  \n   if (mode != GET_MODE (v->u.val_rtx))\n     return 0;\n \n@@ -370,8 +370,7 @@ remove_useless_values (void)\n \n   htab_traverse (hash_table, discard_useless_values, 0);\n \n-  if (n_useless_values != 0)\n-    abort ();\n+  gcc_assert (!n_useless_values);\n }\n \n /* Return the mode in which a register was last set.  If X is not a\n@@ -524,7 +523,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -539,8 +538,7 @@ wrap_constant (enum machine_mode mode, rtx x)\n   if (GET_CODE (x) != CONST_INT\n       && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n     return x;\n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n   return gen_rtx_CONST (mode, x);\n }\n \n@@ -643,40 +641,54 @@ cselib_hash_rtx (rtx x, enum machine_mode mode, int create)\n   fmt = GET_RTX_FORMAT (code);\n   for (; i >= 0; i--)\n     {\n-      if (fmt[i] == 'e')\n+      switch (fmt[i])\n \t{\n-\t  rtx tem = XEXP (x, i);\n-\t  unsigned int tem_hash = cselib_hash_rtx (tem, 0, create);\n-\n-\t  if (tem_hash == 0)\n-\t    return 0;\n-\n-\t  hash += tem_hash;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\tcase 'e':\n \t  {\n-\t    unsigned int tem_hash = cselib_hash_rtx (XVECEXP (x, i, j), 0, create);\n-\n+\t    rtx tem = XEXP (x, i);\n+\t    unsigned int tem_hash = cselib_hash_rtx (tem, 0, create);\n+\t    \n \t    if (tem_hash == 0)\n \t      return 0;\n-\n+\t    \n \t    hash += tem_hash;\n \t  }\n-      else if (fmt[i] == 's')\n-\t{\n-\t  const unsigned char *p = (const unsigned char *) XSTR (x, i);\n+\t  break;\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    {\n+\t      unsigned int tem_hash\n+\t\t= cselib_hash_rtx (XVECEXP (x, i, j), 0, create);\n+\t      \n+\t      if (tem_hash == 0)\n+\t\treturn 0;\n+\t      \n+\t      hash += tem_hash;\n+\t    }\n+\t  break;\n+\n+\tcase 's':\n+\t  {\n+\t    const unsigned char *p = (const unsigned char *) XSTR (x, i);\n+\t    \n+\t    if (p)\n+\t      while (*p)\n+\t\thash += *p++;\n+\t    break;\n+\t  }\n+\t  \n+\tcase 'i':\n+\t  hash += XINT (x, i);\n+\t  break;\n \n-\t  if (p)\n-\t    while (*p)\n-\t      hash += *p++;\n+\tcase '0':\n+\tcase 't':\n+\t  /* unused */\n+\t  break;\n+\t  \n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (fmt[i] == 'i')\n-\thash += XINT (x, i);\n-      else if (fmt[i] == '0' || fmt[i] == 't')\n-\t/* unused */;\n-      else\n-\tabort ();\n     }\n \n   return hash ? hash : 1 + (unsigned int) GET_CODE (x);\n@@ -690,10 +702,7 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n {\n   cselib_val *e = pool_alloc (cselib_val_pool);\n \n-#ifdef ENABLE_CHECKING\n-  if (value == 0)\n-    abort ();\n-#endif\n+  gcc_assert (value);\n \n   e->value = value;\n   /* We use custom method to allocate this RTL construct because it accounts\n@@ -799,7 +808,7 @@ cselib_subst_to_values (rtx x)\n \tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n \t  return l->elt->u.val_rtx;\n \n-      abort ();\n+      gcc_unreachable ();\n \n     case MEM:\n       e = cselib_lookup_mem (x, 0);\n@@ -963,18 +972,16 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n   unsigned int i;\n \n   /* If we see pseudos after reload, something is _wrong_.  */\n-  if (reload_completed && regno >= FIRST_PSEUDO_REGISTER\n-      && reg_renumber[regno] >= 0)\n-    abort ();\n+  gcc_assert (!reload_completed || regno < FIRST_PSEUDO_REGISTER\n+\t      || reg_renumber[regno] < 0);\n \n   /* Determine the range of registers that must be invalidated.  For\n      pseudos, only REGNO is affected.  For hard regs, we must take MODE\n      into account, and we must also invalidate lower register numbers\n      if they contain values that overlap REGNO.  */\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n-      if (mode == VOIDmode)\n-\tabort ();\n+      gcc_assert (mode != VOIDmode);\n \n       if (regno < max_value_regs)\n \ti = 0;\n@@ -1188,11 +1195,9 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n \t}\n       else\n \t{\n-\t  if (REG_VALUES (dreg)->elt == 0)\n-\t    REG_VALUES (dreg)->elt = src_elt;\n-\t  else\n-\t    /* The register should have been invalidated.  */\n-\t    abort ();\n+\t  /* The register should have been invalidated.  */\n+\t  gcc_assert (REG_VALUES (dreg)->elt == 0);\n+\t  REG_VALUES (dreg)->elt = src_elt;\n \t}\n \n       if (src_elt->locs == 0)"}]}