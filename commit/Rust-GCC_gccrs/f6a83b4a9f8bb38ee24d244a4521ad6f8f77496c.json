{"sha": "f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZhODNiNGE5ZjhiYjM4ZWUyNGQyNDRhNDUyMWFkNmY4Zjc3NDk2Yw==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2013-09-12T17:52:41Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2013-09-12T17:52:41Z"}, "message": "MAINTAINERS: Add Nick Clifton and DJ Delorie as msp430 maintainers.\n\n* MAINTAINERS: Add Nick Clifton and DJ Delorie as msp430\nmaintainers.\n\n[gcc]\n* config/msp430/: New port.\n* config.gcc (msp430): Added.\n* doc/invoke.texi: Document MSP430 options.\n* doc/install.texi: Document msp430-elf\n* doc/md.texi: Document msp430-elf\n* doc/contrib.texi: Document msp430-elf\n\n[libgcc]\n* config.host (msp*-*-elf): New.\n* config/msp430/: New port.\n\n[contrib]\n* config-list.mk: Add msp430-elf.\n\nFrom-SVN: r202535", "tree": {"sha": "d690c25f951ef2f8c504a45d87bfd262e3ab226f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d690c25f951ef2f8c504a45d87bfd262e3ab226f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/comments", "author": null, "committer": null, "parents": [{"sha": "8369f38a6f3f797952452dc25cd148909e049ee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8369f38a6f3f797952452dc25cd148909e049ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8369f38a6f3f797952452dc25cd148909e049ee6"}], "stats": {"total": 4918, "additions": 4915, "deletions": 3}, "files": [{"sha": "5db944c9d4a93bc56801083b47a064c7e2fc6d8f", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -1,3 +1,8 @@\n+2013-09-12  DJ Delorie  <dj@redhat.com>\n+\n+\t* MAINTAINERS: Add Nick Clifton and DJ Delorie as msp430\n+        maintainers.\n+\n 2013-09-03  Richard Biener  <rguenther@suse.de>\n \n \t* configure.ac: Also allow ISL 0.12."}, {"sha": "48b7246b49a1c862dd8abb3806228514c0cdc138", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -87,6 +87,8 @@ mmix port\t\tHans-Peter Nilsson\thp@bitrange.com\n mn10300 port\t\tJeff Law\t\tlaw@redhat.com\n mn10300 port\t\tAlexandre Oliva\t\taoliva@redhat.com\n moxie port\t\tAnthony Green\t\tgreen@moxielogic.com\n+msp430 port\t\tDJ Delorie\t\tdj@redhat.com\n+msp430 port\t\tNick Clifton\t\tnickc@redhat.com\n nds32 port\t\tChung-Ju Wu\t\tjasonwucj@gmail.com\n nds32 port\t\tShiva Chen\t\tshiva0217@gmail.com\n pdp11 port\t\tPaul Koning\t\tni1d@arrl.net"}, {"sha": "931bb87bc2455f486984fcf375fb76ca0d8cf41d", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -1,3 +1,7 @@\n+2013-09-12  DJ Delorie  <dj@redhat.com>\n+\n+\t* config-list.mk: Add msp430-elf.\n+\n 2013-08-31  Diego Novillo  <dnovillo@google.com>\n \n \t* testsuite-management/x86_64-unknown-linux-gnu.xfail: Update."}, {"sha": "85ca6ad13e0c70d65fb97107f58bca8d95f7b65b", "filename": "contrib/config-list.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -44,6 +44,7 @@ LIST = aarch64-elf aarch64-linux-gnu \\\n   mipsel-elf mips64-elf mips64vr-elf mips64orion-elf mips-rtems \\\n   mips-wrs-vxworks mipstx39-elf mmix-knuth-mmixware mn10300-elf moxie-elf \\\n   moxie-uclinux moxie-rtems pdp11-aout picochip-elfOPT-enable-obsolete \\\n+  msp430-elf \\\n   powerpc-darwin8 \\\n   powerpc-darwin7 powerpc64-darwin powerpc-freebsd6 powerpc-netbsd \\\n   powerpc-eabispe powerpc-eabisimaltivec powerpc-eabisim ppc-elf \\"}, {"sha": "a4440a01c896f63d9952e3604497fac53be662cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -1,5 +1,12 @@\n 2013-09-12  DJ Delorie  <dj@redhat.com>\n \n+\t* config/msp430/: New port.\n+\t* config.gcc (msp430): Added.\n+\t* doc/invoke.texi: Document MSP430 options.\n+\t* doc/install.texi: Document msp430-elf\n+\t* doc/md.texi: Document msp430-elf\n+\t* doc/contrib.texi: Document msp430-elf\n+\n \t* cfgexpand.c (expand_debug_expr): Avoid sign-extending SImode to\n \tPSImode.\n "}, {"sha": "f56f738d8ee8029b78dff204cf5c1df03854881d", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -2030,6 +2030,13 @@ mn10300-*-*)\n \tuse_collect2=no\n \tuse_gcc_stdint=wrap\n \t;;\n+msp430*-*-*)\n+\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n+\tc_target_objs=\"msp430-c.o\"\n+\tcxx_target_objs=\"msp430-c.o\"\n+\ttarget_has_targetm_common=no\n+\ttmake_file=\"${tmake_file} msp430/t-msp430\"\n+\t;;\n pdp11-*-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n \tuse_gcc_stdint=wrap"}, {"sha": "e7343cfcaf1728bf85a1b830cd3c89e3dcd2b504", "filename": "gcc/config/msp430/README.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2FREADME.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2FREADME.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2FREADME.txt?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,7 @@\n+Random Notes\n+------------\n+\n+The MSP430 port does not use leading underscores.  However, the\n+assembler has no way of differentiating between, for example, register\n+R12 and symbol R12.  So, if you do \"int r12;\" in your C program, you\n+may get an assembler error, and will certainly have runtime problems."}, {"sha": "baacf923bd33605bf9a37587c9f05e9a6d6cec68", "filename": "gcc/config/msp430/constraints.md", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fconstraints.md?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,74 @@\n+;;  Machine Description for TI MSP43* processors\n+;;  Copyright (C) 2013 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_register_constraint \"R12\" \"R12_REGS\"\n+  \"Register R12.\")\n+\n+(define_register_constraint \"R13\" \"R13_REGS\"\n+  \"Register R13.\")\n+\n+(define_constraint \"K\"\n+  \"Integer constant 1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 1)\")))\n+\n+(define_constraint \"L\"\n+  \"Integer constant -1^20..1^19.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -1 << 20, 1 << 19)\")))\n+\n+(define_constraint \"M\"\n+  \"Integer constant 1-4.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 1, 4)\")))\n+\n+;; We do not allow arbitrary constants, eg symbols or labels,\n+;; because their address may be above the 16-bit address limit\n+;; supported by the offset used in the MOVA instruction.\n+(define_constraint \"Ya\"\n+  \"Memory reference, any type, but restricted range of constants\"\n+  (and (match_code \"mem\")\n+       (ior (match_code \"reg\" \"0\")\n+\t    (and (match_code \"plus\" \"0\")\n+\t\t (match_code \"reg\" \"00\")\n+\t\t (match_test (\"CONST_INT_P (XEXP (XEXP (op, 0), 1))\")))\n+\t    (match_test \"CONSTANT_P (XEXP (op, 0))\")\n+\t    )))\n+\n+(define_constraint \"Yl\"\n+  \"Memory reference, labels only.\"\n+  (and (match_code \"mem\")\n+       (match_code \"label_ref\" \"0\")))\n+\n+\n+;; These are memory references that are safe to use with the X suffix,\n+;; because we know/assume they need not index across the 64k boundary.\n+(define_constraint \"Ys\"\n+  \"Memory reference, stack only.\"\n+  (and (match_code \"mem\")\n+       (ior\n+\t(and (match_code \"plus\" \"0\")\n+\t     (and (match_code \"reg\" \"00\")\n+\t\t  (match_test (\"CONST_INT_P (XEXP (XEXP (op, 0), 1))\"))\n+\t\t  (match_test (\"IN_RANGE (INTVAL (XEXP (XEXP (op, 0), 1)), -1 << 15, (1 << 15)-1)\"))))\n+\t(match_code \"reg\" \"0\")\n+\t)))\n+  \n+"}, {"sha": "808e02c5ffd00bce1c7bceb14115b050da3d1313", "filename": "gcc/config/msp430/msp430-c.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-c.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,36 @@\n+/* MSP430 C-specific support\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"c-family/c-common.h\"\n+#include \"msp430-protos.h\"\n+\n+/* Implements REGISTER_TARGET_PRAGMAS.  */\n+void\n+msp430_register_pragmas (void)\n+{\n+  c_register_addr_space (\"__near\", ADDR_SPACE_NEAR);\n+  if (msp430x)\n+    c_register_addr_space (\"__far\", ADDR_SPACE_FAR);\n+}"}, {"sha": "9e7b70127fd76ae18634a245e79ade7c38fc016f", "filename": "gcc/config/msp430/msp430-modes.def", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-modes.def?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,3 @@\n+/* 20-bit address */\n+PARTIAL_INT_MODE (SI);\n+"}, {"sha": "df90d95c36e0fa8a383e854e383fefa31cdabcd7", "filename": "gcc/config/msp430/msp430-protos.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,44 @@\n+/* Exported function prototypes from the TI MSP430 backend.\n+   Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_MSP430_PROTOS_H\n+#define GCC_MSP430_PROTOS_H\n+\n+void\tmsp430_expand_eh_return (rtx);\n+void\tmsp430_expand_epilogue (int);\n+void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n+void\tmsp430_expand_prologue (void);\n+const char * msp430x_extendhisi (rtx *);\n+void\tmsp430_fixup_compare_operands (enum machine_mode, rtx *);\n+int\tmsp430_hard_regno_mode_ok (int, enum machine_mode);\n+int\tmsp430_hard_regno_nregs (int, enum machine_mode);\n+rtx\tmsp430_incoming_return_addr_rtx (void);\n+void\tmsp430_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n+int\tmsp430_initial_elimination_offset (int, int);\n+const char * msp430x_logical_shift_right (rtx);\n+void\tmsp430_output_labelref (FILE *, const char *);\n+void\tmsp430_register_pragmas (void);\n+rtx\tmsp430_return_addr_rtx (int);\n+void\tmsp430_split_movsi (rtx *);\n+rtx\tmsp430_subreg (enum machine_mode, rtx, enum machine_mode, int);\n+rtx\tmsp430_eh_return_stackadj_rtx (void);\n+bool\tmsp430_modes_tieable_p (enum machine_mode, enum machine_mode);\n+\n+#endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "2e6705dad9bfe192a3b7765ac9198fe775363fe9", "filename": "gcc/config/msp430/msp430.c", "status": "added", "additions": 1746, "deletions": 0, "changes": 1746, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,1746 @@\n+/* Subroutines used for code generation on TI MSP430 processors.\n+   Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"toplev.h\"\n+#include \"reload.h\"\n+#include \"df.h\"\n+#include \"ggc.h\"\n+#include \"tm_p.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\n+#include \"msp430-protos.h\"\n+#include \"dumpfile.h\"\n+#include \"opts.h\"\n+\n+\f\n+\n+static void msp430_compute_frame_info (void);\n+\n+\f\n+\n+/* Run-time Target Specification */\n+\n+bool msp430x = false;\n+\n+struct GTY(()) machine_function\n+{\n+  /* If set, the rest of the fields have been computed.  */\n+  int computed;\n+  /* Which registers need to be saved in the pro/epilogue.  */\n+  int need_to_save [FIRST_PSEUDO_REGISTER];\n+\n+  /* These fields describe the frame layout...  */\n+  /* arg pointer */\n+  /* 2/4 bytes for saved PC */\n+  int framesize_regs;\n+  /* frame pointer */\n+  int framesize_locals;\n+  int framesize_outgoing;\n+  /* stack pointer */\n+  int framesize;\n+\n+  /* How much we adjust the stack when returning from an exception\n+     handler.  */\n+  rtx eh_stack_adjust;\n+};\n+\n+/* This is our init_machine_status, as set in\n+   msp_option_override.  */\n+static struct machine_function *\n+msp430_init_machine_status (void)\n+{\n+  struct machine_function *m;\n+\n+  m = ggc_alloc_cleared_machine_function ();\n+\n+  return m;\n+}\n+\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION msp430_handle_option\n+\n+bool\n+msp430_handle_option (struct gcc_options *opts ATTRIBUTE_UNUSED,\n+\t\t      struct gcc_options *opts_set ATTRIBUTE_UNUSED,\n+\t\t      const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n+\t\t      location_t loc ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+#undef  TARGET_OPTION_OVERRIDE\n+#define TARGET_OPTION_OVERRIDE\t\tmsp430_option_override\n+\n+static void\n+msp430_option_override (void)\n+{\n+  init_machine_status = msp430_init_machine_status;\n+\n+  if (target_cpu\n+      && (strstr (target_cpu, \"430x\")\n+\t  || strstr (target_cpu, \"430X\")))\n+    msp430x = true;\n+\n+  if (TARGET_LARGE && !msp430x)\n+    error (\"-mlarge requires a 430X-compatible -mcpu=\");\n+\n+  if (flag_exceptions || flag_non_call_exceptions\n+      || flag_unwind_tables || flag_asynchronous_unwind_tables)\n+    flag_omit_frame_pointer = false;\n+  else\n+    flag_omit_frame_pointer = true;\n+\n+  /* This is a hack to work around a problem with the newlib build\n+     mechanism.  Newlib always appends CFLAGS to the end of the GCC\n+     command line and always sets -O2 in CFLAGS.  Thus it is not\n+     possible to build newlib with -Os enabled.  Until now...  */\n+  if (TARGET_OPT_SPACE && optimize < 3)\n+    optimize_size = 1;\n+}\n+\n+\f\n+\n+/* Storage Layout */\n+\n+#undef  TARGET_MS_BITFIELD_LAYOUT_P\n+#define TARGET_MS_BITFIELD_LAYOUT_P msp430_ms_bitfield_layout_p\n+\n+bool\n+msp430_ms_bitfield_layout_p (const_tree record_type ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+\f\n+\n+/* Register Usage */\n+\n+/* Implements HARD_REGNO_NREGS.  MSP430X registers can hold a single\n+   PSImode value, but not an SImode value.  */\n+int\n+msp430_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode)\n+{\n+  if (mode == PSImode && msp430x)\n+    return 1;\n+  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n+\t  / UNITS_PER_WORD);\n+}\n+\n+/* Implements HARD_REGNO_MODE_OK.  */\n+int\n+msp430_hard_regno_mode_ok (int regno ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode)\n+{\n+  return regno <= (ARG_POINTER_REGNUM - msp430_hard_regno_nregs (regno, mode));\n+}\n+\n+/* Implements MODES_TIEABLE_P.  */\n+bool\n+msp430_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+{\n+  if ((mode1 == PSImode || mode2 == SImode)\n+      || (mode1 == SImode || mode2 == PSImode))\n+    return false;\n+\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n+\n+#undef  TARGET_FRAME_POINTER_REQUIRED\n+#define TARGET_FRAME_POINTER_REQUIRED msp430_frame_pointer_required\n+\n+static bool\n+msp430_frame_pointer_required (void)\n+{\n+  return false;\n+}\n+\n+#undef  TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE\t\tmsp430_can_eliminate\n+\n+static bool\n+msp430_can_eliminate (const int from_reg ATTRIBUTE_UNUSED,\n+\t\t      const int to_reg ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+/* Implements INITIAL_ELIMINATION_OFFSET.  */\n+int\n+msp430_initial_elimination_offset (int from ATTRIBUTE_UNUSED,\n+\t\t\t\t   int to ATTRIBUTE_UNUSED)\n+{\n+  int rv = 0; /* as if arg to arg */\n+\n+  msp430_compute_frame_info ();\n+\n+  switch (to)\n+    {\n+    case STACK_POINTER_REGNUM:\n+      rv += cfun->machine->framesize_outgoing;\n+      rv += cfun->machine->framesize_locals;\n+      /* Fall through.  */\n+    case FRAME_POINTER_REGNUM:\n+      rv += cfun->machine->framesize_regs;\n+      /* Allow for the saved return address.  */\n+      rv += (TARGET_LARGE ? 4 : 2);\n+      /* NB/ No need to allow for crtl->args.pretend_args_size.\n+         GCC does that for us.  */\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  switch (from)\n+    {\n+    case FRAME_POINTER_REGNUM:\n+      /* Allow for the fall through above.  */\n+      rv -= (TARGET_LARGE ? 4 : 2);\n+      rv -= cfun->machine->framesize_regs;\n+    case ARG_POINTER_REGNUM:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return rv;\n+}\n+\f\n+/* Named Address Space support */\n+\n+\n+/* Return the appropriate mode for a named address pointer.  */\n+#undef  TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE msp430_addr_space_pointer_mode\n+#undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE msp430_addr_space_pointer_mode\n+\n+static enum machine_mode\n+msp430_addr_space_pointer_mode (addr_space_t addrspace)\n+{\n+  switch (addrspace)\n+    {\n+    default:\n+    case ADDR_SPACE_GENERIC:\n+      return Pmode;\n+    case ADDR_SPACE_NEAR:\n+      return HImode;\n+    case ADDR_SPACE_FAR:\n+      return PSImode;\n+    }\n+}\n+\n+/* Function pointers are stored in unwind_word sized\n+   variables, so make sure that unwind_word is big enough.  */\n+#undef  TARGET_UNWIND_WORD_MODE\n+#define TARGET_UNWIND_WORD_MODE msp430_unwind_word_mode\n+\n+static enum machine_mode\n+msp430_unwind_word_mode (void)\n+{\n+  return TARGET_LARGE ? SImode : HImode;\n+}\n+\n+/* Determine if one named address space is a subset of another.  */\n+#undef  TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P msp430_addr_space_subset_p\n+static bool\n+msp430_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+{\n+  if (subset == superset)\n+    return true;\n+  else\n+    return (subset != ADDR_SPACE_FAR && superset == ADDR_SPACE_FAR);\n+}\n+\n+#undef  TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT msp430_addr_space_convert\n+/* Convert from one address space to another.  */\n+static rtx\n+msp430_addr_space_convert (rtx op, tree from_type, tree to_type)\n+{\n+  addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));\n+  addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));\n+  rtx result;\n+\n+  if (to_as != ADDR_SPACE_FAR && from_as == ADDR_SPACE_FAR)\n+    {\n+      /* This is unpredictable, as we're truncating off usable address\n+\t bits.  */\n+\n+      if (CONSTANT_P (op))\n+\treturn gen_rtx_CONST (HImode, op);\n+\n+      result = gen_reg_rtx (HImode);\n+      emit_insn (gen_truncpsihi2 (result, op));\n+      return result;\n+    }\n+  else if (to_as == ADDR_SPACE_FAR && from_as != ADDR_SPACE_FAR)\n+    {\n+      /* This always works.  */\n+\n+      if (CONSTANT_P (op))\n+\treturn gen_rtx_CONST (PSImode, op);\n+\n+      result = gen_reg_rtx (PSImode);\n+      emit_insn (gen_zero_extendhipsi2 (result, op));\n+      return result;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\f\n+/* Stack Layout and Calling Conventions.  */\n+\n+/* For each function, we list the gcc version and the TI version on\n+   each line, where we're converting the function names.  */\n+static char const * const special_convention_function_names [] =\n+{\n+  \"__muldi3\", \"__mspabi_mpyll\",\n+  \"__udivdi3\", \"__mspabi_divull\",\n+  \"__umoddi3\", \"__mspabi_remull\",\n+  \"__divdi3\", \"__mspabi_divlli\",\n+  \"__moddi3\", \"__mspabi_remlli\",\n+  \"__mspabi_srall\",\n+  \"__mspabi_srlll\",\n+  \"__mspabi_sllll\",\n+  \"__adddf3\", \"__mspabi_addd\",\n+  \"__subdf3\", \"__mspabi_subd\",\n+  \"__muldf3\", \"__mspabi_mpyd\",\n+  \"__divdf3\", \"__mspabi_divd\",\n+  \"__mspabi_cmpd\",\n+  NULL\n+};\n+\n+/* TRUE if the function passed is a \"speical\" function.  Special\n+   functions pass two DImode parameters in registers.  */\n+static bool\n+msp430_special_register_convention_p (const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; special_convention_function_names [i]; i++)\n+    if (! strcmp (name, special_convention_function_names [i]))\n+      return true;\n+\n+  return false;\n+}\n+\n+#undef  TARGET_FUNCTION_VALUE_REGNO_P\n+#define TARGET_FUNCTION_VALUE_REGNO_P msp430_function_value_regno_p\n+\n+bool\n+msp430_function_value_regno_p (unsigned int regno)\n+{\n+  return regno == 12;\n+}\n+\n+\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE msp430_function_value\n+\n+rtx\n+msp430_function_value (const_tree ret_type,\n+\t\t       const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t       bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (TYPE_MODE (ret_type), 12);\n+}\n+\n+#undef  TARGET_LIBCALL_VALUE\n+#define TARGET_LIBCALL_VALUE msp430_libcall_value\n+\n+rtx\n+msp430_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (mode, 12);\n+}\n+\n+/* Implements INIT_CUMULATIVE_ARGS.  */\n+void\n+msp430_init_cumulative_args (CUMULATIVE_ARGS *ca,\n+\t\t\t     tree fntype ATTRIBUTE_UNUSED,\n+\t\t\t     rtx libname ATTRIBUTE_UNUSED,\n+\t\t\t     tree fndecl ATTRIBUTE_UNUSED,\n+\t\t\t     int n_named_args ATTRIBUTE_UNUSED)\n+{\n+  const char *fname;\n+  memset (ca, 0, sizeof(*ca));\n+\n+  ca->can_split = 1;\n+\n+  if (fndecl)\n+    fname = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  else if (libname)\n+    fname = XSTR (libname, 0);\n+  else\n+    fname = NULL;\n+\n+  if (fname && msp430_special_register_convention_p (fname))\n+    ca->special_p = 1;\n+}\n+\n+/* Helper function for argument passing; this function is the common\n+   code that determines where an argument will be passed.  */\n+static void\n+msp430_evaluate_arg (cumulative_args_t cap,\n+\t\t     enum machine_mode mode,\n+\t\t     const_tree type ATTRIBUTE_UNUSED,\n+\t\t     bool named)\n+{\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n+  int nregs = GET_MODE_SIZE (mode);\n+  int i;\n+\n+  ca->reg_count = 0;\n+  ca->mem_count = 0;\n+\n+  if (!named)\n+    return;\n+\n+  if (mode == PSImode)\n+    nregs = 1;\n+  else\n+    nregs = (nregs + 1) / 2;\n+\n+  if (ca->special_p)\n+    {\n+      /* Function is passed two DImode operands, in R8:R11 and\n+\t R12:15.  */\n+      ca->start_reg = 8;\n+      ca->reg_count = 4;\n+      return;\n+    }\n+\n+  switch (nregs)\n+    {\n+    case 1:\n+      for (i = 0; i < 4; i++)\n+\tif (! ca->reg_used [i])\n+\t  {\n+\t    ca->reg_count = 1;\n+\t    ca->start_reg = CA_FIRST_REG + i;\n+\t    return;\n+\t  }\n+      break;\n+    case 2:\n+      for (i = 0; i < 3; i++)\n+\tif (! ca->reg_used [i] && ! ca->reg_used [i + 1])\n+\t  {\n+\t    ca->reg_count = 2;\n+\t    ca->start_reg = CA_FIRST_REG + i;\n+\t    return;\n+\t  }\n+      if (! ca->reg_used [3] && ca->can_split)\n+\t{\n+\t  ca->reg_count = 1;\n+\t  ca->mem_count = 2;\n+\t  ca->start_reg = CA_FIRST_REG + 3;\n+\t  return;\n+\t}\n+      break;\n+    case 3:\n+    case 4:\n+      ca->can_split = 0;\n+      if (! ca->reg_used [0]\n+\t  && ! ca->reg_used [1]\n+\t  && ! ca->reg_used [2]\n+\t  && ! ca->reg_used [3])\n+\t{\n+\t  ca->reg_count = 4;\n+\t  ca->start_reg = CA_FIRST_REG;\n+\t  return;\n+\t}\n+      break;\n+    }\n+}\n+\n+#undef  TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES msp430_promote_prototypes\n+\n+bool\n+msp430_promote_prototypes (const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+#undef  TARGET_FUNCTION_ARG\n+#define TARGET_FUNCTION_ARG msp430_function_arg\n+\n+rtx\n+msp430_function_arg (cumulative_args_t cap,\n+\t\t     enum machine_mode mode,\n+\t\t     const_tree type,\n+\t\t     bool named)\n+{\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n+\n+  msp430_evaluate_arg (cap, mode, type, named);\n+\n+  if (ca->reg_count)\n+    return gen_rtx_REG (mode, ca->start_reg);\n+\n+  return 0;\n+}\n+\n+#undef  TARGET_ARG_PARTIAL_BYTES\n+#define TARGET_ARG_PARTIAL_BYTES msp430_arg_partial_bytes\n+\n+int\n+msp430_arg_partial_bytes (cumulative_args_t cap,\n+\t\t\t  enum machine_mode mode,\n+\t\t\t  tree type,\n+\t\t\t  bool named)\n+{\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n+\n+  msp430_evaluate_arg (cap, mode, type, named);\n+\n+  if (ca->reg_count && ca->mem_count)\n+    return ca->reg_count * UNITS_PER_WORD;\n+\n+  return 0;\n+}\n+\n+#undef  TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE msp430_pass_by_reference\n+\n+static bool\n+msp430_pass_by_reference (cumulative_args_t cap ATTRIBUTE_UNUSED,\n+\t\t\t  enum machine_mode mode,\n+\t\t\t  const_tree type,\n+\t\t\t  bool named ATTRIBUTE_UNUSED)\n+{\n+  return (mode == BLKmode\n+\t  || (type && TREE_CODE (type) == RECORD_TYPE)\n+\t  || (type && TREE_CODE (type) == UNION_TYPE));\n+}\n+\n+#undef  TARGET_CALLEE_COPIES\n+#define TARGET_CALLEE_COPIES msp430_callee_copies\n+\n+static bool\n+msp430_callee_copies (cumulative_args_t cap ATTRIBUTE_UNUSED,\n+                     enum machine_mode mode ATTRIBUTE_UNUSED,\n+                     const_tree type ATTRIBUTE_UNUSED,\n+                     bool named ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+#undef  TARGET_FUNCTION_ARG_ADVANCE\n+#define TARGET_FUNCTION_ARG_ADVANCE msp430_function_arg_advance\n+\n+void\n+msp430_function_arg_advance (cumulative_args_t cap,\n+\t\t\t     enum machine_mode mode,\n+\t\t\t     const_tree type,\n+\t\t\t     bool named)\n+{\n+  CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n+  int i;\n+\n+  msp430_evaluate_arg (cap, mode, type, named);\n+\n+  if (ca->start_reg >= CA_FIRST_REG)\n+    for (i = 0; i < ca->reg_count; i ++)\n+      ca->reg_used [i + ca->start_reg - CA_FIRST_REG] = 1;\n+\n+  ca->special_p = 0;\n+}\n+\n+#undef  TARGET_FUNCTION_ARG_BOUNDARY\n+#define TARGET_FUNCTION_ARG_BOUNDARY msp430_function_arg_boundary\n+\n+static unsigned int\n+msp430_function_arg_boundary (enum machine_mode mode, const_tree type)\n+{\n+  if (mode == BLKmode\n+      && int_size_in_bytes (type) > 1)\n+    return 16;\n+  if (GET_MODE_BITSIZE (mode) > 8)\n+    return 16;\n+  return 8;\n+}\n+\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY msp430_return_in_memory\n+\n+static bool\n+msp430_return_in_memory (const_tree ret_type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode = TYPE_MODE (ret_type);\n+\n+  if (mode == BLKmode\n+      || (fntype && TREE_CODE (TREE_TYPE (fntype)) == RECORD_TYPE)\n+      || (fntype && TREE_CODE (TREE_TYPE (fntype)) == UNION_TYPE))\n+    return true;\n+\n+  if (GET_MODE_SIZE (mode) > 8)\n+    return true;\n+\n+  return false;\n+}\n+\n+#undef  TARGET_GET_RAW_ARG_MODE\n+#define TARGET_GET_RAW_ARG_MODE msp430_get_raw_arg_mode\n+\n+static enum machine_mode\n+msp430_get_raw_arg_mode (int regno)\n+{\n+  return (regno == ARG_POINTER_REGNUM) ? VOIDmode : Pmode;\n+}\n+\n+#undef  TARGET_GET_RAW_RESULT_MODE\n+#define TARGET_GET_RAW_RESULT_MODE msp430_get_raw_result_mode\n+\n+static enum machine_mode\n+msp430_get_raw_result_mode (int regno ATTRIBUTE_UNUSED)\n+{\n+  return Pmode;\n+}\n+\f\n+/* Addressing Modes */\n+\n+#undef  TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P msp430_legitimate_address_p\n+\n+static bool\n+reg_ok_for_addr (rtx r, bool strict)\n+{\n+  int rn = REGNO (r);\n+\n+  if (strict && rn >= FIRST_PSEUDO_REGISTER)\n+    rn = reg_renumber [rn];\n+  if (strict && 0 <= rn && rn < FIRST_PSEUDO_REGISTER)\n+    return true;\n+  if (!strict)\n+    return true;\n+  return false;\n+}\n+\n+bool\n+msp430_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx x ATTRIBUTE_UNUSED,\n+\t\t\t     bool strict ATTRIBUTE_UNUSED)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case MEM:\n+      return false;\n+\n+    case PLUS:\n+      if (REG_P (XEXP (x, 0)))\n+\t{\n+\t  if (GET_MODE (x) != GET_MODE (XEXP (x, 0)))\n+\t    return false;\n+\t  if (!reg_ok_for_addr (XEXP (x, 0), strict))\n+\t    return false;\n+\t  switch (GET_CODE (XEXP (x, 1)))\n+\t    {\n+\t    case CONST:\n+\t    case SYMBOL_REF:\n+\t    case CONST_INT:\n+\t      return true;\n+\t    default:\n+\t      return false;\n+\t    }\n+\t}\n+      return false;\n+\n+    case REG:\n+      if (!reg_ok_for_addr (x, strict))\n+\treturn false;\n+      /* else... */\n+    case CONST:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+#undef  TARGET_LEGITIMATE_CONSTANT_P\n+#define TARGET_LEGITIMATE_CONSTANT_P msp430_legitimate_constant\n+\n+static bool\n+msp430_legitimate_constant (enum machine_mode mode, rtx x)\n+{\n+  return ! CONST_INT_P (x)\n+    || mode != PSImode\n+    /* GCC does not know the width of the PSImode, so make\n+       sure that it does not try to use a constant value that\n+       is out of range.  */\n+    || (INTVAL (x) < (1 << 20) && INTVAL (x) >= (-1 << 20));\n+}\n+\n+\f\n+#undef  TARGET_RTX_COSTS\n+#define TARGET_RTX_COSTS msp430_rtx_costs\n+\n+static bool msp430_rtx_costs (rtx   x ATTRIBUTE_UNUSED,\n+\t\t\t      int   code,\n+\t\t\t      int   outer_code ATTRIBUTE_UNUSED,\n+\t\t\t      int   opno ATTRIBUTE_UNUSED,\n+\t\t\t      int * total,\n+\t\t\t      bool  speed ATTRIBUTE_UNUSED)\n+{\n+  switch (code)\n+    {\n+    case SIGN_EXTEND:\n+      if (GET_MODE (x) == SImode && outer_code == SET)\n+\t{\n+\t  *total = COSTS_N_INSNS (4);\n+\t  return true;\n+\t}\n+      break;\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (!msp430x)\n+\t{\n+\t  *total = COSTS_N_INSNS (100);\n+\t  return true;\n+\t}\n+      break;\n+    }\n+  return false;\n+}\n+\f\n+/* Function Entry and Exit */\n+\n+/* The MSP430 call frame looks like this:\n+\n+   <higher addresses>\n+   +--------------------+\n+   |                    |\n+   | Stack Arguments    |\n+   |                    |\n+   +--------------------+ <-- \"arg pointer\"\n+   |                    |\n+   | PC from call       |  (2 bytes for 430, 4 for TARGET_LARGE)\n+   |                    |\n+   +--------------------+  <-- SP before prologue, also AP\n+   |                    |\n+   | Saved Regs         |  (2 bytes per reg for 430, 4 per for TARGET_LARGE)\n+   |                    |\n+   +--------------------+  <-- \"frame pointer\"\n+   |                    |\n+   | Locals             |\n+   |                    |\n+   +--------------------+\n+   |                    |\n+   | Outgoing Args      |\n+   |                    |\n+   +--------------------+  <-- SP during function\n+   <lower addresses>\n+\n+*/\n+\n+/* We use this to wrap all emitted insns in the prologue, so they get\n+   the \"frame-related\" (/f) flag set.  */\n+static rtx\n+F (rtx x)\n+{\n+  RTX_FRAME_RELATED_P (x) = 1;\n+  return x;\n+}\n+\n+/* This is the one spot that decides if a register is to be saved and\n+   restored in the prologue/epilogue.  */\n+static bool\n+msp430_preserve_reg_p (int regno)\n+{\n+  /* PC, SP, SR, and the constant generator.  */\n+  if (regno <= 3)\n+    return false;\n+\n+  /* FIXME: add interrupt, EH, etc.  */\n+  if (crtl->calls_eh_return)\n+    return true;\n+\n+  /* Shouldn't be more than the above, but just in case...  */\n+  if (fixed_regs [regno])\n+    return false;\n+\n+  if (!call_used_regs [regno]\n+      && df_regs_ever_live_p (regno))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Compute all the frame-related fields in our machine_function\n+   structure.  */\n+static void\n+msp430_compute_frame_info (void)\n+{\n+  int i;\n+\n+  cfun->machine->computed = 1;\n+  cfun->machine->framesize_regs = 0;\n+  cfun->machine->framesize_locals = get_frame_size ();\n+  cfun->machine->framesize_outgoing = crtl->outgoing_args_size;\n+\n+  for (i = 0; i < 16; i ++)\n+    if (msp430_preserve_reg_p (i))\n+      {\n+\tcfun->machine->need_to_save [i] = 1;\n+\tcfun->machine->framesize_regs += (TARGET_LARGE ? 4 : 2);\n+      }\n+    else\n+      cfun->machine->need_to_save [i] = 0;\n+\n+  if ((cfun->machine->framesize_locals + cfun->machine->framesize_outgoing) & 1)\n+    cfun->machine->framesize_locals ++;\n+\n+  cfun->machine->framesize = (cfun->machine->framesize_regs\n+\t\t\t      + cfun->machine->framesize_locals\n+\t\t\t      + cfun->machine->framesize_outgoing);\n+}\n+\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE\tmsp430_start_function\n+\n+static void\n+msp430_start_function (FILE *outfile, HOST_WIDE_INT hwi_local ATTRIBUTE_UNUSED)\n+{\n+  int r, n;\n+\n+  fprintf (outfile, \"; start of function\\n\");\n+  fprintf (outfile, \"; framesize_regs:     %d\\n\", cfun->machine->framesize_regs);\n+  fprintf (outfile, \"; framesize_locals:   %d\\n\", cfun->machine->framesize_locals);\n+  fprintf (outfile, \"; framesize_outgoing: %d\\n\", cfun->machine->framesize_outgoing);\n+  fprintf (outfile, \"; framesize:          %d\\n\", cfun->machine->framesize);\n+  fprintf (outfile, \"; elim ap -> fp       %d\\n\", msp430_initial_elimination_offset (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM));\n+  fprintf (outfile, \"; elim fp -> sp       %d\\n\", msp430_initial_elimination_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM));\n+\n+  n = 0;\n+  fprintf (outfile, \"; saved regs:\");\n+  for (r = 0; r < 16; r++)\n+    if (cfun->machine->need_to_save [r])\n+      {\n+\tfprintf (outfile, \" %s\", reg_names [r]);\n+\tn = 1;\n+      }\n+  if (n == 0)\n+    fprintf (outfile, \"(none)\");\n+  fprintf (outfile, \"\\n\");\n+}\n+\n+/* Common code to change the stack pointer.  */\n+static void\n+increment_stack (HOST_WIDE_INT amount)\n+{\n+  rtx inc;\n+  rtx sp =  stack_pointer_rtx;\n+\n+  if (amount == 0)\n+    return;\n+\n+  if (amount < 0)\n+    {\n+      inc = GEN_INT (- amount);\n+      if (TARGET_LARGE)\n+\tF (emit_insn (gen_subpsi3 (sp, sp, inc)));\n+      else\n+\tF (emit_insn (gen_subhi3 (sp, sp, inc)));\n+    }\n+  else\n+    {\n+      inc = GEN_INT (amount);\n+      if (TARGET_LARGE)\n+\temit_insn (gen_addpsi3 (sp, sp, inc));\n+      else\n+\temit_insn (gen_addhi3 (sp, sp, inc));\n+    }\n+}\n+\n+void\n+msp430_expand_prologue (void)\n+{\n+  int i, j;\n+  int fs;\n+  /* Always use stack_pointer_rtx instead of calling\n+     rtx_gen_REG ourselves.  Code elsewhere in GCC assumes\n+     that there is a single rtx representing the stack pointer,\n+     namely stack_pointer_rtx, and uses == to recognize it.  */\n+  rtx sp = stack_pointer_rtx;\n+  rtx p;\n+\n+  emit_insn (gen_prologue_start_marker ());\n+\n+  if (!cfun->machine->computed)\n+    msp430_compute_frame_info ();\n+\n+  if (flag_stack_usage_info)\n+    current_function_static_stack_size = cfun->machine->framesize;\n+  \n+  if (crtl->args.pretend_args_size)\n+    {\n+      rtx note;\n+\n+      gcc_assert (crtl->args.pretend_args_size == 2);\n+      \n+      p = emit_insn (gen_grow_and_swap ());\n+\n+      /* Document the stack decrement...  */\n+      note = F (gen_rtx_SET (Pmode, stack_pointer_rtx,\n+\t\t\t     gen_rtx_MINUS (Pmode, stack_pointer_rtx, GEN_INT (2))));\n+      add_reg_note (p, REG_FRAME_RELATED_EXPR, note);\n+\n+      /* ...and the establishment of a new location for the return address.  */\n+      note = F (gen_rtx_SET (Pmode, gen_rtx_MEM (Pmode,\n+\t\t\t\t\t\t gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-2))),\n+\t\t\t     pc_rtx));\n+      add_reg_note (p, REG_CFA_OFFSET, note);\n+      F (p);\n+    }\n+\n+  for (i = 15; i >= 4; i--)\n+    if (cfun->machine->need_to_save [i])\n+      {\n+\tint seq, count;\n+\trtx note;\n+\n+\tfor (seq = i - 1; seq >= 4 && cfun->machine->need_to_save[seq]; seq --)\n+\t  ;\n+\tcount = i - seq;\n+\n+\tif (msp430x)\n+\t  {\n+\t    /* Note: with TARGET_LARGE we still use PUSHM as PUSHX.A is two bytes bigger.  */\n+\t    p = F (emit_insn (gen_pushm (gen_rtx_REG (Pmode, i),\n+\t\t\t\t\t GEN_INT (count))));\n+\n+\t    note = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (count + 1));\n+\n+\t    XVECEXP (note, 0, 0)\n+\t      = F (gen_rtx_SET (VOIDmode,\n+\t\t\t     stack_pointer_rtx,\n+\t\t\t     gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (count * (TARGET_LARGE ? -4 : -2)))));\n+\n+\t    /* *sp-- = R[i-j] */\n+\t    /* sp+N\tR10\n+\t       ...\n+\t       sp\tR4  */\n+\t    for (j = 0; j < count; j ++)\n+\t      {\n+\t\trtx addr;\n+\t\tint ofs = (count - j - 1) * (TARGET_LARGE ? 4 : 2);\n+\n+\t\tif (ofs)\n+\t\t  addr = gen_rtx_PLUS (Pmode, sp, GEN_INT (ofs));\n+\t\telse\n+\t\t  addr = stack_pointer_rtx;\n+\n+\t\tXVECEXP (note, 0, j + 1) = \n+\t\t  F (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  gen_rtx_MEM (Pmode, addr),\n+\t\t\t\t  gen_rtx_REG (Pmode, i - j)) );\n+\t      }\n+\n+\t    add_reg_note (p, REG_FRAME_RELATED_EXPR, note);\n+\t    i -= count - 1;\n+\t  }\n+\telse\n+\t  F (emit_insn (gen_push (gen_rtx_REG (Pmode, i))));\n+      }\n+\n+  if (frame_pointer_needed)\n+    F (emit_move_insn (gen_rtx_REG (Pmode, FRAME_POINTER_REGNUM), sp));\n+\n+  fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;\n+\n+  increment_stack (- fs);\n+\n+  emit_insn (gen_prologue_end_marker ());\n+}\n+\n+void\n+msp430_expand_epilogue (int is_eh)\n+{\n+  int i;\n+  int fs;\n+  int helper_n = 0;\n+\n+  if (cfun->machine->need_to_save [10])\n+    {\n+      /* Check for a helper function.  */\n+      helper_n = 7; /* for when the loop below never sees a match.  */\n+      for (i = 9; i >= 4; i--)\n+\tif (!cfun->machine->need_to_save [i])\n+\t  {\n+\t    helper_n = 10 - i;\n+\t    for (; i >= 4; i--)\n+\t      if (cfun->machine->need_to_save [i])\n+\t\t{\n+\t\t  helper_n = 0;\n+\t\t  break;\n+\t\t}\n+\t    break;\n+\t  }\n+    }\n+\n+  emit_insn (gen_epilogue_start_marker ());\n+\n+  fs = cfun->machine->framesize_locals + cfun->machine->framesize_outgoing;\n+\n+  increment_stack (fs);\n+\n+  if (is_eh)\n+    {\n+      /* We need to add the right \"SP\" register save just after the\n+\t regular ones, so that when we pop it off we're in the EH\n+\t return frame, not this one.  This overwrites our own return\n+\t address, but we're not going to be returning anyway.  */\n+      rtx r12 = gen_rtx_REG (Pmode, 12);\n+      rtx (*addPmode)(rtx, rtx, rtx) = TARGET_LARGE ? gen_addpsi3 : gen_addhi3;\n+\n+      /* R12 will hold the new SP.  */\n+      i = cfun->machine->framesize_regs;\n+      emit_move_insn (r12, stack_pointer_rtx);\n+      emit_insn (addPmode (r12, r12, EH_RETURN_STACKADJ_RTX));\n+      emit_insn (addPmode (r12, r12, GEN_INT (i)));\n+      emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (Pmode, stack_pointer_rtx, i)), r12);\n+    }\n+\n+  for (i = 4; i <= 15; i++)\n+    if (cfun->machine->need_to_save [i])\n+      {\n+\tint seq, count;\n+\n+\tfor (seq = i + 1; seq <= 15 && cfun->machine->need_to_save[seq]; seq ++)\n+\t  ;\n+\tcount = seq - i;\n+\n+\tif (msp430x)\n+\t  {\n+\t    /* Note: With TARGET_LARGE we still use POPM as POPX.A is two\n+\t       bytes bigger.\n+\t       Note: See the popm pattern for the explanation of the strange\n+\t       arguments.  */\n+\t    emit_insn (gen_popm (stack_pointer_rtx, GEN_INT (~(seq - 1)),\n+\t\t\t\t GEN_INT (count)));\n+\t    i += count - 1;\n+\t  }\n+\telse if (i == 11 - helper_n\n+\t\t && crtl->args.pretend_args_size == 0\n+\t\t /* Calling the helper takes as many bytes as the POP;RET sequence.  */\n+\t\t && helper_n != 1\n+\t\t && !is_eh)\n+\t  {\n+\t    emit_insn (gen_epilogue_helper (GEN_INT (helper_n)));\n+\t    return;\n+\t  }\n+\telse\n+\t  emit_insn (gen_pop (gen_rtx_REG (Pmode, i)));\n+      }\n+\n+  if (is_eh)\n+    {\n+      /* Also pop SP, which puts us into the EH return frame.  Except\n+\t that you can't \"pop\" sp, you have to just load it off the\n+\t stack.  */\n+      emit_move_insn (stack_pointer_rtx, gen_rtx_MEM (Pmode, stack_pointer_rtx));\n+    }\n+\n+  if (crtl->args.pretend_args_size)\n+    emit_insn (gen_swap_and_shrink ());\n+    \n+  emit_jump_insn (gen_msp_return ());\n+}\n+\n+/* Implements EH_RETURN_STACKADJ_RTX.  Saved and used later in\n+   m32c_emit_eh_epilogue.  */\n+rtx\n+msp430_eh_return_stackadj_rtx (void)\n+{\n+  if (!cfun->machine->eh_stack_adjust)\n+    {\n+      rtx sa;\n+\n+      sa = gen_rtx_REG (Pmode, 15);\n+      cfun->machine->eh_stack_adjust = sa;\n+    }\n+  return cfun->machine->eh_stack_adjust;\n+}\n+\n+/* This function is called before reload, to \"fix\" the stack in\n+   preparation for an EH return.  */\n+void\n+msp430_expand_eh_return (rtx eh_handler)\n+{\n+  /* These are all Pmode */\n+  rtx ap, sa, ra, tmp;\n+\n+  ap = arg_pointer_rtx;\n+  sa = msp430_eh_return_stackadj_rtx ();\n+  ra = eh_handler;\n+\n+  tmp = ap;\n+  tmp = gen_rtx_PLUS (Pmode, ap, sa);\n+  tmp = plus_constant (Pmode, tmp, TARGET_LARGE ? -4 : -2);\n+  tmp = gen_rtx_MEM (Pmode, tmp);\n+  emit_move_insn (tmp, ra);\n+}\n+\n+/* This is a list of MD patterns that implement fixed-count shifts.  */\n+static struct {\n+  const char *name;\n+  int count;\n+  int need_430x;\n+  rtx (*genfunc)(rtx,rtx);\n+} const_shift_helpers[] = {\n+#define CSH(N,C,X,G) { \"__mspabi_\"N, C, X, gen_##G }\n+\n+  CSH (\"slli\", 1, 1, slli_1),\n+  CSH (\"slll\", 1, 1, slll_1),\n+  CSH (\"slll\", 2, 1, slll_2),\n+\n+  CSH (\"srai\", 1, 0, srai_1),\n+  CSH (\"sral\", 1, 0, sral_1),\n+  CSH (\"sral\", 2, 0, sral_2),\n+\n+  CSH (\"srll\", 1, 0, srll_1),\n+  CSH (\"srll\", 2, 1, srll_2x),\n+  { 0, 0, 0, 0 }\n+#undef CSH\n+};\n+\n+/* The MSP430 ABI defines a number of helper functions that should be\n+   used for, for example, 32-bit shifts.  This function is called to\n+   emit such a function, using the table above to optimize some\n+   cases.  */\n+void\n+msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variants)\n+{\n+  rtx c, f;\n+  char *helper_const = NULL;\n+  int arg2 = 13;\n+  int arg1sz = 1;\n+  enum machine_mode arg0mode = GET_MODE (operands[0]);\n+  enum machine_mode arg1mode = GET_MODE (operands[1]);\n+  enum machine_mode arg2mode = GET_MODE (operands[2]);\n+  int have_430x = msp430x ? 1 : 0;\n+\n+  if (CONST_INT_P (operands[2]))\n+    {\n+      int i;\n+\n+      for (i=0; const_shift_helpers[i].name; i++)\n+\t{\n+\t  if (const_shift_helpers[i].need_430x <= have_430x\n+\t      && strcmp (helper_name, const_shift_helpers[i].name) == 0\n+\t      && INTVAL (operands[2]) == const_shift_helpers[i].count)\n+\t    {\n+\t      emit_insn (const_shift_helpers[i].genfunc (operands[0], operands[1]));\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (arg1mode == VOIDmode)\n+    arg1mode = arg0mode;\n+  if (arg2mode == VOIDmode)\n+    arg2mode = arg0mode;\n+\n+  if (arg1mode == SImode)\n+    {\n+      arg2 = 14;\n+      arg1sz = 2;\n+    }\n+\n+  if (const_variants\n+      && CONST_INT_P (operands[2])\n+      && INTVAL (operands[2]) >= 1\n+      && INTVAL (operands[2]) <= 15)\n+    {\n+      /* Note that the INTVAL is limited in value and length by the conditional above.  */\n+      int len = strlen (helper_name) + 4;\n+      helper_const = (char *) xmalloc (len);\n+      snprintf (helper_const, len, \"%s_%ld\", helper_name, (int) INTVAL (operands[2]));\n+    }\n+\n+  emit_move_insn (gen_rtx_REG (arg1mode, 12),\n+\t\t  operands[1]);\n+  if (!helper_const)\n+    emit_move_insn (gen_rtx_REG (arg2mode, arg2),\n+\t\t    operands[2]);\n+\n+  c = gen_call_value_internal (gen_rtx_REG (arg0mode, 12),\n+\t\t\t       gen_rtx_SYMBOL_REF (VOIDmode, helper_const ? helper_const : helper_name),\n+\t\t\t       GEN_INT (0));\n+  c = emit_call_insn (c);\n+  RTL_CONST_CALL_P (c) = 1;\n+\n+  f = 0;\n+  use_regs (&f, 12, arg1sz);\n+  if (!helper_const)\n+    use_regs (&f, arg2, 1);\n+  add_function_usage_to (c, f);\n+\n+  emit_move_insn (operands[0],\n+\t\t  gen_rtx_REG (arg0mode, 12));\n+}\n+\n+/* Called by cbranch<mode>4 to coerce operands into usable forms.  */\n+void\n+msp430_fixup_compare_operands (enum machine_mode my_mode, rtx * operands)\n+{\n+  /* constants we're looking for, not constants which are allowed.  */\n+  int const_op_idx = 1;\n+\n+  if (msp430_reversible_cmp_operator (operands[0], VOIDmode))\n+    const_op_idx = 2;\n+\n+  if (GET_CODE (operands[const_op_idx]) != REG\n+      && GET_CODE (operands[const_op_idx]) != MEM)\n+    operands[const_op_idx] = copy_to_mode_reg (my_mode, operands[const_op_idx]);\n+}\n+\n+/* Simplify_gen_subreg() doesn't handle memory references the way we\n+   need it to below, so we use this function for when we must get a\n+   valid subreg in a \"natural\" state.  */\n+rtx\n+msp430_subreg (enum machine_mode mode, rtx r, enum machine_mode omode, int byte)\n+{\n+  rtx rv;\n+\n+  if (GET_CODE (r) == SUBREG\n+      && SUBREG_BYTE (r) == 0)\n+    {\n+      rtx ireg = SUBREG_REG (r);\n+      enum machine_mode imode = GET_MODE (ireg);\n+\n+      /* special case for (HI (SI (PSI ...), 0)) */\n+      if (imode == PSImode\n+\t  && mode == HImode\n+\t  && byte == 0)\n+\trv = gen_rtx_SUBREG (mode, ireg, byte);\n+      else\n+\trv = simplify_gen_subreg (mode, ireg, imode, byte);\n+    }\n+  else if (GET_CODE (r) == MEM)\n+    rv = adjust_address (r, mode, byte);\n+  else\n+    rv = simplify_gen_subreg (mode, r, omode, byte);\n+\n+  if (!rv)\n+    gcc_unreachable ();\n+\n+  return rv;\n+}\n+\n+/* Called by movsi_x to generate the HImode operands.  */\n+void\n+msp430_split_movsi (rtx *operands)\n+{\n+  rtx op00, op02, op10, op12;\n+\n+  op00 = msp430_subreg (HImode, operands[0], SImode, 0);\n+  op02 = msp430_subreg (HImode, operands[0], SImode, 2);\n+\n+  if (GET_CODE (operands[1]) == CONST\n+      || GET_CODE (operands[1]) == SYMBOL_REF)\n+    {\n+      op10 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (0));\n+      op10 = gen_rtx_CONST (HImode, op10);\n+      op12 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (16));\n+      op12 = gen_rtx_CONST (HImode, op12);\n+    }\n+  else\n+    {\n+      op10 = msp430_subreg (HImode, operands[1], SImode, 0);\n+      op12 = msp430_subreg (HImode, operands[1], SImode, 2);\n+    }\n+\n+  if (rtx_equal_p (operands[0], operands[1]))\n+    {\n+      operands[2] = op02;\n+      operands[4] = op12;\n+      operands[3] = op00;\n+      operands[5] = op10;\n+    }\n+  else if (rtx_equal_p (op00, op12)\n+\t   /* Catch the case where we are loading (rN, rN+1) from mem (rN).  */\n+\t   || (REG_P (op00) && reg_mentioned_p (op00, op10))\n+\t   /* Or storing (rN) into mem (rN).  */\n+\t   || (REG_P (op10) && reg_mentioned_p (op10, op00))\n+\t   )\n+    {\n+      operands[2] = op02;\n+      operands[4] = op12;\n+      operands[3] = op00;\n+      operands[5] = op10;\n+    }\n+  else\n+    {\n+      operands[2] = op00;\n+      operands[4] = op10;\n+      operands[3] = op02;\n+      operands[5] = op12;\n+    }\n+}\n+\n+\f\n+\n+/* The MSPABI specifies the names of various helper functions, many of\n+   which are compatible with GCC's helpers.  This table maps the GCC\n+   name to the MSPABI name.  */\n+static const struct\n+{\n+  char const * const gcc_name;\n+  char const * const ti_name;\n+}\n+  helper_function_name_mappings [] =\n+{\n+  /* Floating point to/from integer conversions.  */\n+  { \"__truncdfsf2\", \"__mspabi_cvtdf\" },\n+  { \"__extendsfdf2\", \"__mspabi_cvtfd\" },\n+  { \"__fixdfhi\", \"__mspabi_fixdi\" },\n+  { \"__fixdfsi\", \"__mspabi_fixdli\" },\n+  { \"__fixdfdi\", \"__mspabi_fixdlli\" },\n+  { \"__fixunsdfhi\", \"__mspabi_fixdu\" },\n+  { \"__fixunsdfsi\", \"__mspabi_fixdul\" },\n+  { \"__fixunsdfdi\", \"__mspabi_fixdull\" },\n+  { \"__fixsfhi\", \"__mspabi_fixfi\" },\n+  { \"__fixsfsi\", \"__mspabi_fixfli\" },\n+  { \"__fixsfdi\", \"__mspabi_fixflli\" },\n+  { \"__fixunsfhi\", \"__mspabi_fixfu\" },\n+  { \"__fixunsfsi\", \"__mspabi_fixful\" },\n+  { \"__fixunsfdi\", \"__mspabi_fixfull\" },\n+  { \"__floathisf\", \"__mspabi_fltif\" },\n+  { \"__floatsisf\", \"__mspabi_fltlif\" },\n+  { \"__floatdisf\", \"__mspabi_fltllif\" },\n+  { \"__floathidf\", \"__mspabi_fltid\" },\n+  { \"__floatsidf\", \"__mspabi_fltlid\" },\n+  { \"__floatdidf\", \"__mspabi_fltllid\" },\n+  { \"__floatunhisf\", \"__mspabi_fltuf\" },\n+  { \"__floatunsisf\", \"__mspabi_fltulf\" },\n+  { \"__floatundisf\", \"__mspabi_fltullf\" },\n+  { \"__floatunhidf\", \"__mspabi_fltud\" },\n+  { \"__floatunsidf\", \"__mspabi_fltuld\" },\n+  { \"__floatundidf\", \"__mspabi_fltulld\" },\n+\n+  /* Floating point comparisons.  */\n+  /* GCC uses individual functions for each comparison, TI uses one\n+     compare <=> function.  */\n+\n+  /* Floating point arithmatic */\n+  { \"__adddf3\", \"__mspabi_addd\" },\n+  { \"__addsf3\", \"__mspabi_addf\" },\n+  { \"__divdf3\", \"__mspabi_divd\" },\n+  { \"__divsf3\", \"__mspabi_divf\" },\n+  { \"__muldf3\", \"__mspabi_mpyd\" },\n+  { \"__mulsf3\", \"__mspabi_mpyf\" },\n+  { \"__subdf3\", \"__mspabi_subd\" },\n+  { \"__subsf3\", \"__mspabi_subf\" },\n+  /* GCC does not use helper functions for negation */\n+\n+  /* Integer multiply, divide, remainder.  */\n+  /* Note: gcc doesn't know about hardware multiply options (yet?)  */\n+  { \"__mulhi3\", \"__mspabi_mpyi\" },\n+  { \"__mulsi3\", \"__mspabi_mpyl\" },\n+  { \"__muldi3\", \"__mspabi_mpyll\" },\n+#if 0\n+  /* Clarify signed vs unsigned first.  */\n+  { \"__mulhisi3\", \"__mspabi_mpysl\" }, /* gcc doesn't use widening multiply (yet?) */\n+  { \"__mulsidi3\", \"__mspabi_mpysll\" }, /* gcc doesn't use widening multiply (yet?) */\n+#endif\n+\n+  { \"__divhi3\", \"__mspabi_divi\" },\n+  { \"__divsi3\", \"__mspabi_divli\" },\n+  { \"__divdi3\", \"__mspabi_divlli\" },\n+  { \"__udivhi3\", \"__mspabi_divu\" },\n+  { \"__udivsi3\", \"__mspabi_divlu\" },\n+  { \"__udivdi3\", \"__mspabi_divllu\" },\n+  { \"__modhi3\", \"__mspabi_remi\" },\n+  { \"__modsi3\", \"__mspabi_remli\" },\n+  { \"__moddi3\", \"__mspabi_remlli\" },\n+  { \"__umodhi3\", \"__mspabi_remu\" },\n+  { \"__umodsi3\", \"__mspabi_remul\" },\n+  { \"__umoddi3\", \"__mspabi_remull\" },\n+\n+  /* Bitwise operations.  */\n+  /* Rotation - no rotation support yet.  */\n+  /* Logical left shift - gcc already does these itself.  */\n+  /* Arithmetic left shift - gcc already does these itself.  */\n+  /* Arithmetic right shift - gcc already does these itself.  */\n+\n+  { NULL, NULL }\n+};\n+\n+/* This function does the same as the default, but it will replace GCC\n+   function names with the MSPABI-specified ones.  */\n+void\n+msp430_output_labelref (FILE *file, const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; helper_function_name_mappings [i].gcc_name; i++)\n+    if (! strcmp (helper_function_name_mappings [i].gcc_name, name))\n+      {\n+\tfputs (helper_function_name_mappings [i].ti_name, file);\n+\treturn;\n+      }\n+\n+  fputs (name, file);\n+}\n+\n+#undef  TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND\t\tmsp430_print_operand\n+\n+/* Common code for msp430_print_operand().  */\n+static void\n+msp430_print_operand_raw (FILE * file, rtx op, int letter ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG:\n+      fprintf (file, \"%s\", reg_names [REGNO (op)]);\n+      break;\n+\n+    case CONST_INT:\n+      i = INTVAL (op);\n+      if (TARGET_ASM_HEX)\n+\tfprintf (file, \"%#x\", i);\n+      else\n+\tfprintf (file, \"%d\", i);\n+      break;\n+\n+    case CONST:\n+    case PLUS:\n+    case MINUS:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      output_addr_const (file, op);\n+      break;\n+\n+    default:\n+      print_rtl (file, op);\n+      break;\n+    }\n+}\n+\n+static void\n+msp430_print_operand (FILE * file, rtx op, int letter)\n+{\n+  rtx addr;\n+\n+  /* We can't use c, n, a, or l.  */\n+  switch (letter)\n+    {\n+    case 'Z':\n+      gcc_assert (CONST_INT_P (op));\n+      /* Print the constant value, less one.  */\n+      fprintf (file, \"#%ld\", INTVAL (op) - 1);\n+      return;\n+    case 'Y':\n+      gcc_assert (CONST_INT_P (op));\n+      /* Print the constant value, less four.  */\n+      fprintf (file, \"#%ld\", INTVAL (op) - 4);\n+      return;\n+      /* case 'D': used for \"decimal without '#'\" */\n+    case 'I':\n+      if (GET_CODE (op) == CONST_INT)\n+\t{\n+\t  /* Inverse of constants */\n+\t  int i = INTVAL (op);\n+\t  fprintf (file, \"%d\", ~i);\n+\t  return;\n+\t}\n+      op = XEXP (op, 0);\n+      break;\n+    case 'r': /* Conditional jump where the condition is reversed.  */\n+      switch (GET_CODE (op))\n+\t{\n+\tcase EQ: fprintf (file, \"NE\"); break;\n+\tcase NE: fprintf (file, \"EQ\"); break;\n+\tcase GEU: fprintf (file, \"LO\"); break;\n+\tcase LTU: fprintf (file, \"HS\"); break;\n+\tcase GE: fprintf (file, \"L\"); break;\n+\tcase LT: fprintf (file, \"GE\"); break;\n+\t  /* Assume these have reversed operands.  */\n+\tcase GTU: fprintf (file, \"HS\"); break;\n+\tcase LEU: fprintf (file, \"LO\"); break;\n+\tcase GT: fprintf (file, \"GE\"); break;\n+\tcase LE: fprintf (file, \"L\"); break;\n+\tdefault:\n+\t  msp430_print_operand_raw (file, op, letter);\n+\t  break;\n+\t}\n+      return;\n+    case 'R': /* Conditional jump where the operands are reversed.  */\n+      switch (GET_CODE (op))\n+\t{\n+\tcase GTU: fprintf (file, \"LO\"); break;\n+\tcase LEU: fprintf (file, \"HS\"); break;\n+\tcase GT: fprintf (file, \"L\"); break;\n+\tcase LE: fprintf (file, \"GE\"); break;\n+\tdefault:\n+\t  msp430_print_operand_raw (file, op, letter);\n+\t  break;\n+\t}\n+      return;\n+    case 'p': /* Bit position. 0 == 0x01, 3 = 0x08 etc.  */\n+      gcc_assert (CONST_INT_P (op));\n+      fprintf (file, \"#%d\", 1 << INTVAL (op));\n+      return;\n+    case 'B':\n+      switch (GET_MODE (op))\n+\t{\n+\tcase QImode: fprintf (file, \".B\"); return;\n+\tcase HImode: fprintf (file, \".W\"); return;\n+\tcase PSImode: fprintf (file, \".A\"); return;\n+\tcase SImode: fprintf (file, \".A\"); return;\n+\tdefault:\n+\t  return;\n+\t}\n+    case 'L': /* Low half.  */\n+      switch (GET_CODE (op))\n+\t{\n+\tcase MEM:\n+\t  op = adjust_address (op, Pmode, 0);\n+\t  break;\n+\tcase REG:\n+\t  break;\n+\tcase CONST_INT:\n+\t  op = GEN_INT (INTVAL (op) & 0xffff);\n+\t  letter = 0;\n+\t  break;\n+\tdefault:\n+\t  /* If you get here, figure out a test case :-) */\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    case 'H': /* high half */\n+      switch (GET_CODE (op))\n+\t{\n+\tcase MEM:\n+\t  op = adjust_address (op, Pmode, 2);\n+\t  break;\n+\tcase REG:\n+\t  op = gen_rtx_REG (Pmode, REGNO (op) + 1);\n+\t  break;\n+\tcase CONST_INT:\n+\t  op = GEN_INT (INTVAL (op) >> 16);\n+\t  letter = 0;\n+\t  break;\n+\tdefault:\n+\t  /* If you get here, figure out a test case :-) */\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case 'X':\n+      /* This is used to turn, for example, an ADD opcode into an ADDX\n+\t opcode when we're using 20-bit addresses.  */\n+      if (TARGET_LARGE)\n+\tfprintf (file, \"X\");\n+      /* We don't care which operand we use, but we want 'X' in the MD\n+\t file, so we do it this way.  */\n+      return;\n+\n+    case 'x':\n+      /* Similarly, but only for PSImodes.  BIC, for example, needs this.  */\n+      if (TARGET_LARGE && GET_MODE (op) == PSImode)\n+\tfprintf (file, \"X\");\n+      return;\n+\n+    case 'A':\n+      /* Likewise, for BR -> BRA.  */\n+      if (TARGET_LARGE)\n+\tfprintf (file, \"A\");\n+      return;\n+    }\n+\n+  switch (GET_CODE (op))\n+    {\n+    case REG:\n+      msp430_print_operand_raw (file, op, letter);\n+      break;\n+\n+    case MEM:\n+      addr = XEXP (op, 0);\n+      switch (GET_CODE (addr))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"@%s\", reg_names [REGNO (addr)]);\n+\t  break;\n+\tcase PLUS:\n+\t  msp430_print_operand_raw (file, XEXP (addr, 1), letter);\n+\t  fprintf (file, \"(%s)\", reg_names [REGNO (XEXP (addr, 0))]);\n+\t  break;\n+\tcase CONST:\n+\tcase CONST_INT:\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  fprintf (file, \"&\");\n+\t  msp430_print_operand_raw (file, addr, letter);\n+\t  break;\n+\n+\tdefault:\n+\t  print_rtl (file, addr);\n+\t  break;\n+\t}\n+      break;\n+\n+    case CONST_INT:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      if (letter == 0)\n+\tfprintf (file, \"#\");\n+      msp430_print_operand_raw (file, op, letter);\n+      break;\n+\n+    case EQ: fprintf (file, \"EQ\"); break;\n+    case NE: fprintf (file, \"NE\"); break;\n+    case GEU: fprintf (file, \"HS\"); break;\n+    case LTU: fprintf (file, \"LO\"); break;\n+    case GE: fprintf (file, \"GE\"); break;\n+    case LT: fprintf (file, \"L\"); break;\n+\n+    default:\n+      print_rtl (file, op);\n+      break;\n+    }\n+\n+}\n+\n+\f\n+/* Frame stuff.  */\n+\n+rtx\n+msp430_return_addr_rtx (int count)\n+{\n+  int ra_size;\n+  if (count)\n+    return NULL_RTX;\n+\n+  ra_size = TARGET_LARGE ? 4 : 2;\n+  if (crtl->args.pretend_args_size)\n+    ra_size += 2;\n+\n+  return gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx, GEN_INT (- ra_size)));\n+}\n+\n+rtx\n+msp430_incoming_return_addr_rtx (void)\n+{\n+  return gen_rtx_MEM (Pmode, stack_pointer_rtx);\n+}\n+\f\n+/* Instruction generation stuff.  */\n+\n+/* Generate a sequence of instructions to sign-extend an HI\n+   value into an SI value.  Handles the tricky case where\n+   we are overwriting the destination.  */\n+\n+const char *\n+msp430x_extendhisi (rtx * operands)\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]))\n+    /* Low word of dest == source word.  */\n+    return \"BIT.W #0x8000, %L0 { SUBC.W %H0, %H0 { INV.W %H0, %H0\"; /* 8-bytes.  */\n+\n+  if (! msp430x)\n+    /* Note: This sequence is approximately the same length as invoking a helper\n+       function to perform the sign-extension, as in:\n+       \n+         MOV.W  %1, %L0\n+\t MOV.W  %1, r12\n+\t CALL   __mspabi_srai_15\n+\t MOV.W  r12, %H0\n+\n+       but this version does not involve any function calls or using argument\n+       registers, so it reduces register pressure.  */\n+    return \"MOV.W %1, %L0 { BIT.W #0x8000, %L0 { SUBC.W %H0, %H0 { INV.W %H0, %H0\"; /* 10-bytes.  */\n+  \n+  if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n+    /* High word of dest == source word.  */\n+    return \"MOV.W %1, %L0 { RPT #15 { RRAX.W %H0\"; /* 6-bytes.  */\n+\n+  /* No overlap between dest and source.  */\n+  return \"MOV.W %1, %L0 { MOV.W %1, %H0 { RPT #15 { RRAX.W %H0\"; /* 8-bytes.  */\n+}\n+\n+/* Likewise for logical right shifts.  */\n+const char *\n+msp430x_logical_shift_right (rtx amount)\n+{\n+  /* The MSP430X's logical right shift instruction - RRUM - does\n+     not use an extension word, so we cannot encode a repeat count.\n+     Try various alternatives to work around this.  If the count\n+     is in a register we are stuck, hence the assert.  */\n+  gcc_assert (CONST_INT_P (amount));\n+\n+  if (INTVAL (amount) <= 0\n+      || INTVAL (amount) >= 16)\n+    return \"# nop logical shift.\";\n+\n+  if (INTVAL (amount) > 0\t    \n+      && INTVAL (amount) < 5)\n+    return \"rrum.w\\t%2, %0\"; /* Two bytes.  */\n+\n+  if (INTVAL (amount) > 4\t    \n+      && INTVAL (amount) < 9)\n+    return \"rrum.w\\t#4, %0 { rrum.w\\t%Y2, %0 \"; /* Four bytes.  */\n+\n+  /* First we logically shift right by one.  Now we know\n+     that the top bit is zero and we can use the arithmetic\n+     right shift instruction to perform the rest of the shift.  */\n+  return \"rrum.w\\t#1, %0 { rpt\\t%Z2 { rrax.w\\t%0\"; /* Six bytes.  */\n+}\n+\f\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-msp430.h\""}, {"sha": "bf3b15c0efbdef5465239380bde3fb14225104b1", "filename": "gcc/config/msp430/msp430.h", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,399 @@\n+/* GCC backend definitions for the TI MSP430 Processor\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+\n+/* Run-time Target Specification */\n+\n+/* True if the MSP430x extensions are enabled.  */\n+#ifndef IN_LIBGCC2\n+extern bool msp430x;\n+#endif\n+\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do                                            \\\n+    {                                           \\\n+      builtin_define (\"__MSP430__\"); \t\t\\\n+      if (msp430x)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__MSP430X__\");\t\\\n+\t  builtin_assert (\"cpu=MSP430X\");\t\\\n+\t  if (TARGET_LARGE)\t\t\t\\\n+\t    builtin_define (\"__MSP430X_LARGE__\");\t\\\n+\t}\t\t\t\t\t\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_assert (\"cpu=MSP430\"); \t\t\\\n+    }                                           \\\n+  while (0)\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:crt0.o%s} crtbegin.o%s\"\n+\n+/* -lgcc is included because crtend.o needs __mspabi_func_epilog_1.  */\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s -lgcc\"\n+\n+#define ASM_SPEC \"-mP \" /* Enable polymorphic instructions.  */ \\\n+  \"%{mmcu=msp430x:-mmcu=msp430X;mmcu=*:-mmcu=%*} \" /* Pass the MCU type on to the assembler.  */  \\\n+  \"%{mrelax=-mQ} \" /* Pass the relax option on to the assembler.  */ \\\n+  \"%{mlarge:-ml} \" /* Tell the assembler if we are building for the LARGE pointer model.  */ \\\n+  \"%{ffunction-sections:-gdwarf-sections}\" /* If function sections are being created then create DWARF line number sections as well.  */\n+\n+/* Enable linker section garbage collection by default, unless we\n+   are creating a relocatable binary (gc does not work) or debugging\n+   is enabled  (the GDB testsuite relies upon unused entities not being deleted).  */\n+#define LINK_SPEC \"%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}}\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"\t\t\t\t\t\\\n+--start-group\t\t\t\t\t\t\\\n+-lc\t\t\t\t\t\t\t\\\n+-lgcc\t\t\t\t\t\t\t\\\n+%{msim:-lsim}\t\t\t\t\t\t\\\n+%{!msim:-lnosys}\t\t\t\t\t\\\n+--end-group\t\t\t\t\t   \t\\\n+%{!T*: %{msim: %{mlarge:%Tmsp430xl-sim.ld}%{!mlarge:%Tmsp430-sim.ld}}%{!msim:%Tmsp430.ld}}\t\\\n+\"\n+\f\n+\n+/* Storage Layout */\n+\n+#define BITS_BIG_ENDIAN \t\t0\n+#define BYTES_BIG_ENDIAN \t\t0\n+#define WORDS_BIG_ENDIAN \t\t0\n+\n+\n+#ifdef IN_LIBGCC2\n+/* This is to get correct SI and DI modes in libgcc2.c (32 and 64 bits).  */\n+#define\tUNITS_PER_WORD\t\t\t4\n+/* We have a problem with libgcc2.  It only defines two versions of\n+   each function, one for \"int\" and one for \"long long\".  Ie it assumes\n+   that \"sizeof (int) == sizeof (long)\".  For the MSP430 this is not true\n+   and we need a third set of functions.  We explicitly define\n+   LIBGCC2_UNITS_PER_WORD here so that it is clear that we are expecting\n+   to get the SI and DI versions from the libgcc2.c sources, and we\n+   provide our own set of HI functions, which is why this\n+   definition is surrounded by #ifndef..#endif.  */\n+#ifndef LIBGCC2_UNITS_PER_WORD\n+#define LIBGCC2_UNITS_PER_WORD \t\t4\n+#endif\n+#else\n+/* Actual width of a word, in units (bytes).  */\n+#define\tUNITS_PER_WORD \t\t\t2\n+#endif\n+\n+#define SHORT_TYPE_SIZE\t\t\t16\n+#define INT_TYPE_SIZE\t\t\t16\n+#define LONG_TYPE_SIZE\t\t\t32\n+#define LONG_LONG_TYPE_SIZE\t\t64\n+\n+#define FLOAT_TYPE_SIZE \t\t32\n+#define DOUBLE_TYPE_SIZE \t\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t\t64 /*DOUBLE_TYPE_SIZE*/\n+\n+#define LIBGCC2_HAS_DF_MODE\t\t1\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   64\n+\n+#define DEFAULT_SIGNED_CHAR\t\t0\n+\n+#define STRICT_ALIGNMENT \t\t1\n+#define FUNCTION_BOUNDARY \t\t16\n+#define BIGGEST_ALIGNMENT \t\t16\n+#define STACK_BOUNDARY \t\t\t16\n+#define PARM_BOUNDARY \t\t\t8\n+#define PCC_BITFIELD_TYPE_MATTERS\t1\n+\n+#define STACK_GROWS_DOWNWARD\t\t1\n+#define FRAME_GROWS_DOWNWARD\t\t1\n+#define FIRST_PARM_OFFSET(FNDECL) \t0\n+\n+#define MAX_REGS_PER_ADDRESS \t\t1\n+\n+#define Pmode \t\t\t\t(TARGET_LARGE ? PSImode : HImode)\n+/* Note: 32 is a lie.  Large pointers are actually 20-bits wide.  But gcc\n+   thinks that any non-power-of-2 pointer size equates to BLKmode, which\n+   causes all kinds of problems...  */\n+#define POINTER_SIZE\t\t\t(TARGET_LARGE ? 32 : 16)\n+#define\tPOINTERS_EXTEND_UNSIGNED\t1\n+\n+#define ADDR_SPACE_NEAR\t1\n+#define ADDR_SPACE_FAR\t2\n+\n+#define REGISTER_TARGET_PRAGMAS() msp430_register_pragmas()\n+\n+#if 1 /* XXX */\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 2)      \t\\\n+    (MODE) = HImode;\n+#endif\n+\f\n+/* Layout of Source Language Data Types */\n+\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE\t\t\t(TARGET_LARGE ? \"long unsigned int\" : \"unsigned int\")\n+#undef  PTRDIFF_TYPE\n+#define PTRDIFF_TYPE\t\t\t(TARGET_LARGE ? \"long int\" : \"int\")\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE\t\t\t\"long int\"\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE\t\t\tBITS_PER_WORD\n+#define FUNCTION_MODE \t\t\tHImode\n+#define CASE_VECTOR_MODE\t\tPmode\n+#define HAS_LONG_COND_BRANCH\t\t0\n+#define HAS_LONG_UNCOND_BRANCH\t\t0\n+\n+#define LOAD_EXTEND_OP(M)\t\tZERO_EXTEND\n+/*#define WORD_REGISTER_OPERATIONS\t1*/\n+\n+#define MOVE_MAX \t\t\t8\n+#define STARTING_FRAME_OFFSET\t\t0\n+\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  msp430_incoming_return_addr_rtx ()\n+\n+#define RETURN_ADDR_RTX(COUNT, FA)\t\t\\\n+  msp430_return_addr_rtx (COUNT)\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)   1\n+\n+#define SLOW_BYTE_ACCESS\t\t0\n+\f\n+\n+/* Register Usage */\n+\n+/* gas doesn't recognize PC (R0), SP (R1), and SR (R2) as register\n+   names.  */\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\",\t\t\\\n+    \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\t\\\n+  \"argptr\"\t\t\t\t\t\t\t\\\n+}\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  R12_REGS,\n+  R13_REGS,\n+  GEN_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define REG_CLASS_NAMES \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"R12_REGS\",\t\t\\\n+  \"R13_REGS\",\t\t\\\n+  \"GEN_REGS\",\t\t\\\n+  \"ALL_REGS\"\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t   \\\n+  0x00000000,\t\t   \\\n+  0x00001000,\t\t   \\\n+  0x00002000,\t\t   \\\n+  0x0000fff2,\t\t   \\\n+  0x0001ffff\t\t   \\\n+}\n+\n+#define GENERAL_REGS\t\t\tGEN_REGS\n+#define BASE_REG_CLASS  \t\tGEN_REGS\n+#define INDEX_REG_CLASS\t\t\tGEN_REGS\n+#define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n+\n+#define PC_REGNUM \t\t        0\n+#define STACK_POINTER_REGNUM \t        1\n+#define CC_REGNUM                       2\n+#define FRAME_POINTER_REGNUM \t\t4 /* not usually used, call preserved */\n+#define ARG_POINTER_REGNUM \t\t16\n+#define STATIC_CHAIN_REGNUM \t\t5 /* FIXME */\n+\n+#define FIRST_PSEUDO_REGISTER \t\t17\n+\n+#define REGNO_REG_CLASS(REGNO)          ((REGNO) < 17 \\\n+\t\t\t\t\t ? GEN_REGS : NO_REGS)\n+\n+#define TRAMPOLINE_SIZE\t\t\t4 /* FIXME */\n+#define TRAMPOLINE_ALIGNMENT\t\t16 /* FIXME */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n+  (OFFSET) = msp430_initial_elimination_offset ((FROM), (TO))\n+\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t  \t((N) >= 8 && (N) < ARG_POINTER_REGNUM)\n+#define DEFAULT_PCC_STRUCT_RETURN\t0\n+\n+/* 1 == register can't be used by gcc, in general\n+   0 == register can be used by gcc, in general */\n+#define FIXED_REGISTERS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1,0,1,1, 0,0,0,0,\t\t\t\t\t\\\n+  0,0,0,0, 0,0,0,0,\t\t\t\t\t\\\n+  1,\t\t\t\t\t\t\t\\\n+}\n+\n+/* 1 == value changes across function calls\n+   0 == value is the same after a call      */\n+/* R4 through R10 are callee-saved */\n+#define CALL_USED_REGISTERS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1,0,1,1, 0,0,0,0,\t\t\t\t\t\\\n+  0,0,0,1, 1,1,1,1,\t\t\t\t\t\\\n+  1,\t\t\t\t\t\t\\\n+}\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\\\n+  { 12, 13, 14, 15, 10, 9, 8, 7, 6, 5, 4, 11, 0, 1, 2, 3, 16 }\n+/*  { 11, 15, 14, 13, 12, 10, 9, 8, 7, 6, 5, 4, 0, 1, 2, 3, 16 }*/\n+\n+#define REGNO_OK_FOR_BASE_P(regno)\t1\n+#define REGNO_OK_FOR_INDEX_P(regno)\t1\n+\n+\f\n+\n+typedef struct {\n+  /* These two are the current argument status.  */\n+  char reg_used[4];\n+#define CA_FIRST_REG 12\n+  char can_split;\n+  /* These two are temporaries used internally.  */\n+  char start_reg;\n+  char reg_count;\n+  char mem_count;\n+  char special_p;\n+} CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CA, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+  msp430_init_cumulative_args (&CA, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS)\n+\n+\f\n+/* FIXME */\n+#define NO_PROFILE_COUNTERS     1\n+#define PROFILE_BEFORE_PROLOGUE 1\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+    fprintf (FILE, \"\\tcall\\t__mcount\\n\");\n+\f\n+#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n+  msp430_hard_regno_nregs (REGNO, MODE)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n+  msp430_hard_regno_mode_ok (REGNO, MODE)\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n+  msp430_modes_tieable_p (MODE1, MODE2)\n+\f\n+/* Exception Handling */\n+\n+/* R12,R13,R14 - EH data\n+   R15 - stack adjustment */\n+\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  (((N) < 3) ? ((N) + 12) : INVALID_REGNUM)\n+\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM(Pmode, gen_rtx_PLUS (Pmode, gen_rtx_REG(Pmode, SP_REGNO), gen_rtx_REG (Pmode, 15)))\n+\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, 15)\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) DW_EH_PE_udata4\n+\n+\f\n+/* Stack Layout and Calling Conventions */\n+\n+\f\n+/* Addressing Modes */\n+\n+\f\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+#define DATA_SECTION_ASM_OP \".data\"\n+#define BSS_SECTION_ASM_OP   \"\\t.section .bss\"\n+\n+#define ASM_COMMENT_START\t\" ;\"\n+#define ASM_APP_ON\t\t\"\"\n+#define ASM_APP_OFF \t\t\"\"\n+#define LOCAL_LABEL_PREFIX\t\".L\"\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX\t\"\"\n+\n+#define GLOBAL_ASM_OP \t\t\"\\t.global\\t\"\n+\n+#define ASM_OUTPUT_LABELREF(FILE, SYM) msp430_output_labelref ((FILE), (SYM))\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   Note: The local label referenced by the \"3b\" below is emitted by\n+   the tablejump insn.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long .L%d - 1b\\n\", VALUE)\n+\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((LOG) == 0)\t\t\t\t\\\n+        break;\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.balign %d\\n\", 1 << (LOG));\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define JUMP_TABLES_IN_TEXT_SECTION\t1\n+\f\n+#undef\tDWARF2_ADDR_SIZE\n+#define\tDWARF2_ADDR_SIZE\t\t\t4\n+\n+#define INCOMING_FRAME_SP_OFFSET\t\t(POINTER_SIZE / BITS_PER_UNIT)\n+\n+#undef  PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+#define DWARF2_ASM_LINE_DEBUG_INFO\t\t1\n+\n+/* Prevent reload (and others) from choosing HImode stack slots\n+   when spilling hard registers when they may contain PSImode values.  */\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO,NREGS,MODE) \\\n+  ((TARGET_LARGE && ((NREGS) <= 2)) ? PSImode : choose_hard_reg_mode ((REGNO), (NREGS), false))\n+\n+/* Also stop GCC from thinking that it can eliminate (SUBREG:PSI (SI)).  */\n+#define CANNOT_CHANGE_MODE_CLASS(FROM,TO,CLASS) \\\n+  (   ((TO) == PSImode && (FROM) == SImode)\t\\\n+   || ((TO) == SImode  && (FROM) == PSImode)    \\\n+   || ((TO) == DImode  && (FROM) == PSImode)    \\\n+   || ((TO) == PSImode && (FROM) == DImode)     \\\n+      )\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1"}, {"sha": "4324503a1b7bee2b12cc616b2411bebb9d633915", "filename": "gcc/config/msp430/msp430.md", "status": "added", "additions": 1229, "deletions": 0, "changes": 1229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,1229 @@\n+;;  Machine Description for TI MSP43* processors\n+;;  Copyright (C) 2013 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+\n+(define_constants\n+  [\n+   (PC_REGNO 0)\n+   (SP_REGNO 1)\n+   (CARRY 2)\n+  ])\n+\n+(define_c_enum \"unspec\"\n+  [\n+   UNS_PROLOGUE_START_MARKER\n+   UNS_PROLOGUE_END_MARKER\n+   UNS_EPILOGUE_START_MARKER\n+   UNS_EPILOGUE_HELPER\n+\n+   UNS_PUSHM\n+   UNS_POPM\n+\n+   UNS_GROW_AND_SWAP\n+   UNS_SWAP_AND_SHRINK\n+  ])\n+  \n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+(define_mode_iterator QHI [QI HI PSI])\n+\n+;; There are two basic \"family\" tests we do here:\n+;;\n+;; msp430x - true if 430X instructions are available.\n+;; TARGET_LARGE - true if pointers are 20-bits\n+;;\n+;; Note that there are three supported cases, since the base 430\n+;; doesn't have 20-bit pointers:\n+;;\n+;; 1. MSP430 cpu, small model\n+;; 2. MSP430X cpu, small model.\n+;; 3. MSP430X cpu, large model.\n+\n+;;------------------------------------------------------------\n+;; Moves\n+\n+;; Push/Pop must be before the generic move patterns\n+\n+(define_insn \"push\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNO)))\n+\t(match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"PUSH\\t%0\"\n+  )\n+\n+(define_insn \"pusha\"\n+  [(set (mem:PSI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+\t(match_operand:PSI 0 \"register_operand\" \"r\"))]\n+  \"TARGET_LARGE\"\n+  \"PUSHX.A\\t%0\"\n+  )\n+\n+(define_insn \"pushm\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n+\t\t     (match_operand 1 \"immediate_operand\" \"i\")] UNS_PUSHM)]\n+  \"\"\n+  \"PUSHM%B0\\t%1, %0\"\n+  )\n+\n+(define_insn \"pop\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (post_inc:HI (reg:HI SP_REGNO))))]\n+  \"\"\n+  \"POP\\t%0\"\n+  )\n+\n+(define_insn \"popa\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"=r\")\n+\t(mem:PSI (post_inc:PSI (reg:PSI SP_REGNO))))]\n+  \"TARGET_LARGE\"\n+  \"POPX.A\\t%0\"\n+  )\n+\n+;; This is nasty.  Operand0 is bogus.  It is only there so that we can get a\n+;; mode for the %B0 to work.  We should use operand1 for this, but that does\n+;; not have a mode.\n+;; \n+;; Operand1 is actually a register, but we cannot accept (REG...) because the\n+;; cprop_hardreg pass can and will renumber registers even inside\n+;; unspec_volatiles.  So we take an integer register number parameter and\n+;; fudge it to be a register name when we generate the assembler.  We use %I\n+;; because that is the only operator that will omit the # prefix to an\n+;; integer value.  Unfortunately it also inverts the integer value, so we\n+;; have pre-invert it when generating this insn.  (We could of course add a\n+;; new operator, eg %D, just for this pattern...)\n+;;\n+;; The pushm pattern does not have this problem because of all of the\n+;; frame info cruft attached to it, so cprop_hardreg leaves it alone.\n+(define_insn \"popm\"\n+  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n+\t\t     (match_operand 1 \"immediate_operand\" \"i\")\n+\t\t     (match_operand 2 \"immediate_operand\" \"i\")] UNS_POPM)]\n+  \"\"\n+  \"POPM%B0\\t%2, r%I1\"\n+  )\n+\n+;; The next two patterns are here to support a \"feature\" of how GCC implements\n+;; varargs.  When a function uses varargs and the *second* to last named\n+;; argument is split between argument registers and the stack, gcc expects the\n+;; callee to allocate space on the stack that can contain the register-based\n+;; part of the argument.  This space *has* to be just before the remaining\n+;; arguments (ie the ones that are fully on the stack).\n+;;\n+;; The problem is that the MSP430 CALL instruction pushes the return address\n+;; onto the stack in the exact place where the callee wants to allocate\n+;; this extra space.  So we need a sequence of instructions that can allocate\n+;; the extra space and then move the return address down the stack, so that\n+;; the extra space is now adjacent to the remaining arguments.\n+;;\n+;; This could be constructed through regular insns, but they might be split up\n+;; by a misguided optimization, so an unspec volatile is used instead.\n+\n+(define_insn \"grow_and_swap\"\n+  [(unspec_volatile [(const_int 0)] UNS_GROW_AND_SWAP)]\n+  \"\"\n+  { if (TARGET_LARGE)\n+      return \"SUBA\\t#2, r1 \\n MOVX.A\\t2(r1), 0(r1)\";\n+    return \"SUB\\t#2, r1 \\n MOV.W\\t2(r1), 0(r1)\";\n+    }\n+  )\n+\n+(define_insn \"swap_and_shrink\"\n+  [(unspec_volatile [(const_int 0)] UNS_SWAP_AND_SHRINK)]\n+  \"\"\n+  { return TARGET_LARGE\n+\t   ? \"MOVX.A\\t0(r1), 2(r1) \\n ADDA\\t#2, SP\"\n+\t   : \"MOV.W\\t0(r1), 2(r1) \\n ADD\\t#2, SP\";\n+  })\n+\n+; I set LOAD_EXTEND_OP and WORD_REGISTER_OPERATIONS, but gcc puts in a\n+; zero_extend anyway.  Catch it here.\n+(define_insn \"movqihi\"\n+  [(set (match_operand:HI                 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"Ys,m\")))]\n+  \"\"\n+  \"@\n+   MOV.B\\t%1, %0\n+   MOV%X1.B\\t%1, %0\"\n+)\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rYs,rm\")\n+\t(match_operand:QI 1 \"general_operand\" \"riYs,rmi\"))]\n+  \"\"\n+  \"@\n+  MOV.B\\t%1, %0\n+  MOV%X0.B\\t%1, %0\"\n+)\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rYs,rm\")\n+\t(match_operand:HI 1 \"general_operand\" \"riYs,rmi\"))]\n+  \"\"\n+  \"@\n+  MOV.W\\t%1, %0\n+  MOV%X0.W\\t%1, %0\"\n+)\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\"\n+  )\n+  \n+(define_insn_and_split \"movsi_x\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_operand:HI 2 \"nonimmediate_operand\")\n+\t(match_operand:HI 4 \"general_operand\"))\n+   (set (match_operand:HI 3 \"nonimmediate_operand\")\n+\t(match_operand:HI 5 \"general_operand\"))]\n+  \"msp430_split_movsi (operands);\"\n+)\n+\n+;; Some MOVX.A cases can be done with MOVA, this is only a few of them.\n+(define_insn \"movpsi\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r,Ya,rm\")\n+\t(match_operand:PSI 1 \"general_operand\" \"riYa,r,rmi\"))]\n+  \"\"\n+  \"@\n+  MOV%A0\\t%1, %0\n+  MOV%A0\\t%1, %0\n+  MOV%X0.%A0\\t%1, %0\")\n+\n+; This pattern is identical to the truncsipsi2 pattern except\n+; that it uses a SUBREG instead of a TRUNC.  It is needed in\n+; order to prevent reload from converting (set:SI (SUBREG:PSI (SI)))\n+; into (SET:PSI (PSI)).\n+;\n+; Note: using POPM.A #1 is two bytes smaller than using POPX.A....\n+\n+(define_insn \"movsipsi2\"\n+  [(set (match_operand:PSI            0 \"register_operand\" \"=r\")\n+\t(subreg:PSI (match_operand:SI 1 \"register_operand\" \"r\") 0))]\n+  \"TARGET_LARGE\"\n+  \"PUSH.W %H1 { PUSH.W %1 { POPM.A #1, %0\"\n+)\n+\n+;;------------------------------------------------------------\n+;; Math\n+\n+(define_insn \"addpsi3\"\n+  [(set (match_operand:PSI           0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:PSI (match_operand:PSI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t  (match_operand:PSI 2 \"general_operand\"      \"rLs,rmi\")))]\n+  \"\"\n+  \"@\n+  ADDA\\t%2, %0\n+  ADDX.A\\t%2, %0\"\n+)\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI          0 \"nonimmediate_operand\" \"=rYs,rm\")\n+\t(plus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\"      \"riYs,rmi\")))]\n+  \"\"\n+  \"@\n+   ADD.B\\t%2, %0\n+   ADD%X0.B\\t%2, %0\"\n+)\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI           0 \"nonimmediate_operand\" \"=rYs,rm\")\n+\t(plus:HI (match_operand:HI  1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t  (match_operand:HI 2 \"general_operand\"      \"riYs,rmi\")))]\n+  \"\"\n+  \"@\n+   ADD.W\\t%2, %0\n+   ADD%X0.W\\t%2, %0\"\n+)\n+\n+; This pattern is needed in order to avoid reload problems.\n+; It takes an SI pair of registers, adds a value to them, and\n+; then converts them into a single PSI register.\n+\n+(define_insn \"addsipsi3\"\n+  [(set (subreg:SI (match_operand:PSI 0 \"register_operand\" \"=&r\") 0)\n+\t(plus:SI (match_operand:SI    1 \"register_operand\" \"0\")\n+\t\t (match_operand       2 \"general_operand\" \"rmi\")))]\n+  \"\"\n+  \"ADD.W\\t%L2, %L0 { ADDC.W\\t%H2, %H0 { PUSH.W %H0 { PUSH.W %L0 { POPM.A #1, %0\"\n+)\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,rm\")\n+\t(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"r,mi\")))]\n+  \"\"\n+  \"@\n+   ADD\\t%L2, %L0 { ADDC\\t%H2, %H0\n+   ADD%X0\\t%L2, %L0 { ADDC%X0\\t%H2, %H0\"\n+)\n+\n+; Version of addhi that exposes the carry operations, for SImode adds.\n+;\n+; NOTE - we are playing a dangerous game with GCC here.  We have these two\n+; add patterns and the splitter that follows because our tests have shown\n+; that this results in a significant reduction in code size - because GCC is\n+; able to discard any unused part of the addition.  We have to annotate the\n+; patterns with the set and use of the carry flag because otherwise GCC will\n+; discard parts of the addition when they are actually needed.  But we have\n+; not annotated all the other patterns that set the CARRY flag as doing so\n+; results in an overall increase in code size[1].  Instead we just *hope*\n+; that GCC will not move a carry-setting instruction in between the first\n+; and second adds.\n+;\n+; So far our experiments have shown that GCC is likely to move MOV and CMP\n+; instructions in between the two adds, but not other instructions.  MOV is\n+; safe, CMP is not.  So we have annotated the CMP patterns and left the\n+; subtract, shift and other add patterns alone.  At the moment this is\n+; working, but with future changes to the generic parts of GCC that might\n+; change.\n+;\n+; [1] It is not clear exactly why the code size increases.  The cause appears\n+; to be that reload is more prevelent to spilling a variable onto the stack\n+; but why it does this is unknown.  Possibly the additional CLOBBERs necessary\n+; to correctly annotate the other patterns makes reload think that there is\n+; increased register pressure.  Or possibly reload does not handle ADD patterns\n+; that are not single_set() very well.\n+\n+(define_insn \"addhi3_cy\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"r,rm\")))\n+   (set (reg:BI CARRY)\n+\t(truncate:BI (lshiftrt:SI (plus:SI (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t   (zero_extend:SI (match_dup 2)))\n+\t\t\t\t  (const_int 16))))\n+   ]\n+  \"\"\n+  \"@\n+   ADD %2, %1 ; cy\n+   ADD%X0 %2, %1 ; cy\"\n+  )\n+\n+(define_insn \"addhi3_cy_i\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"i,i\")))\n+   (set (reg:BI CARRY)\n+\t(truncate:BI (lshiftrt:SI (plus:SI (zero_extend:SI (match_dup 1))\n+\t\t\t\t\t   (match_operand 3 \"immediate_operand\" \"i,i\"))\n+\t\t\t\t  (const_int 16))))\n+   ]\n+  \"\"\n+  \"@\n+   ADD %2, %1 ; cy\n+   ADD%X0 %2, %1 ; cy\"\n+  )\n+\n+; Version of addhi that adds the carry, for SImode adds.\n+(define_insn \"addchi4_cy\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,rm\")\n+\t(plus:HI (plus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t\t  (match_operand:HI 2 \"general_operand\" \"ri,rmi\"))\n+\t\t (zero_extend:HI (reg:BI CARRY))))\n+   ]\n+  \"\"\n+  \"@\n+   ADDC %2, %1\n+   ADDC%X0 %2, %1\"\n+  )\n+\n+; Split an SImode add into two HImode adds, keeping track of the carry\n+; so that gcc knows when it can and can't optimize away the two\n+; halves.\n+(define_split\n+  [(set (match_operand:SI 0 \"msp430_nonsubreg_operand\" \"=&rm\")\n+\t(plus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))\n+   ]\n+  \"\"\n+  [(parallel [(set (match_operand:HI 3 \"nonimmediate_operand\" \"=&rm\")\n+\t\t   (plus:HI (match_dup 4)\n+\t\t\t    (match_dup 5)))\n+\t      (set (reg:BI CARRY)\n+\t\t   (truncate:BI (lshiftrt:SI (plus:SI (zero_extend:SI (match_dup 4))\n+\t\t\t\t\t\t      (match_dup 9))\n+\t\t\t\t\t     (const_int 16))))\n+\t      ])\n+   (set (match_operand:HI 6 \"nonimmediate_operand\" \"=&rm\")\n+\t(plus:HI (plus:HI (match_dup 7)\n+\t\t\t  (match_dup 8))\n+\t\t (zero_extend:HI (reg:BI CARRY))))\n+   ]\n+  \"\n+   operands[3] = msp430_subreg (HImode, operands[0], SImode, 0);\n+   operands[4] = msp430_subreg (HImode, operands[1], SImode, 0);\n+   operands[5] = msp430_subreg (HImode, operands[2], SImode, 0);\n+   operands[6] = msp430_subreg (HImode, operands[0], SImode, 2);\n+   operands[7] = msp430_subreg (HImode, operands[1], SImode, 2);\n+   operands[8] = msp430_subreg (HImode, operands[2], SImode, 2);\n+   if (GET_CODE (operands[5]) == CONST_INT)\n+     {\n+       operands[9] = GEN_INT (INTVAL (operands[5]) & 0xffff);\n+     }\n+   else\n+     {\n+       operands[9] = gen_rtx_ZERO_EXTEND (SImode, operands[5]);\n+     }\n+   \"\n+  )\n+\n+\n+;; Alternatives 2 and 3 are to handle cases generated by reload.\n+(define_insn \"subpsi3\"\n+  [(set (match_operand:PSI            0 \"nonimmediate_operand\" \"=r,   rm, &?r, ?&r\")\n+\t(minus:PSI (match_operand:PSI 1 \"general_operand\"       \"0,   0,   !r,  !i\")\n+\t\t   (match_operand:PSI 2 \"general_operand\"       \"rLs, rmi, rmi,  r\")))]\n+  \"\"\n+  \"@\n+  SUBA\\t%2, %0\n+  SUBX.A\\t%2, %0\n+  MOVX.A\\t%1, %0 { SUBX.A\\t%2, %0\n+  MOVX.A\\t%1, %0 { SUBA\\t%2, %0\"\n+)\n+\n+;; Alternatives 2 and 3 are to handle cases generated by reload.\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI           0 \"nonimmediate_operand\" \"=rYs,  rm,  &?r, ?&r\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\"       \"0,    0,    !r,  !i\")\n+\t\t  (match_operand:QI 2 \"general_operand\"      \" riYs, rmi, rmi,   r\")))]\n+  \"\"\n+  \"@\n+  SUB.B\\t%2, %0\n+  SUB%X0.B\\t%2, %0\n+  MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\n+  MOV%X0.B\\t%1, %0 { SUB%X0.B\\t%2, %0\"\n+)\n+\n+;; Alternatives 2 and 3 are to handle cases generated by reload.\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI           0 \"nonimmediate_operand\" \"=rYs,  rm,  &?r, ?&r\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\"       \"0,    0,    !r,  !i\")\n+\t\t  (match_operand:HI 2 \"general_operand\"      \" riYs, rmi, rmi,   r\")))]\n+  \"\"\n+  \"@\n+  SUB.W\\t%2, %0\n+  SUB%X0.W\\t%2, %0\n+  MOV%X0.W\\t%1, %0 { SUB%X0.W\\t%2, %0\n+  MOV%X0.W\\t%1, %0 { SUB%X0.W\\t%2, %0\"\n+)\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI           0 \"nonimmediate_operand\" \"=&rm\")\n+\t(minus:SI (match_operand:SI 1 \"nonimmediate_operand\"   \"0\")\n+\t\t  (match_operand:SI 2 \"general_operand\"        \"rmi\")))]\n+  \"\"\n+  \"SUB%X0\\t%L2, %L0 { SUBC%X0\\t%H2, %H0\"\n+)\n+\n+(define_insn \"*bic<mode>_cg\"\n+  [(set (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"=rYs,m\")\n+\t(and:QHI (match_operand:QHI 1 \"msp_general_operand\" \"0,0\")\n+\t\t (match_operand 2 \"msp430_inv_constgen_operator\" \"n,n\")))]\n+  \"\"\n+  \"@\n+   BIC%x0%B0\\t#%I2, %0\n+   BIC%X0%B0\\t#%I2, %0\"\n+)\n+\n+(define_insn \"bic<mode>3\"\n+  [(set (match_operand:QHI                   0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+\t(and:QHI (not:QHI (match_operand:QHI 1 \"msp_general_operand\"       \"rYs,rmn\"))\n+\t\t (match_operand:QHI          2 \"msp_nonimmediate_operand\"  \"0,0\")))]\n+  \"\"\n+  \"@\n+   BIC%x0%B0\\t%1, %0\n+   BIC%X0%B0\\t%1, %0\"\n+)\n+\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+\t(and:QHI (match_operand:QHI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYs,rmi\")))]\n+  \"\"\n+  \"@\n+   AND%x0%B0\\t%2, %0\n+   AND%X0%B0\\t%2, %0\"\n+)\n+\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"=rYs,rm\")\n+\t(ior:QHI (match_operand:QHI 1 \"msp_nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QHI 2 \"msp_general_operand\" \"riYs,rmi\")))]\n+  \"\"\n+  \"@\n+   BIS%x0%B0\\t%2, %0\n+   BIS%X0%B0\\t%2, %0\"\n+)\n+\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:QHI 0 \"nonimmediate_operand\" \"=rYs,rm\")\n+\t(xor:QHI (match_operand:QHI 1 \"nonimmediate_operand\" \"%0,0\")\n+\t\t (match_operand:QHI 2 \"general_operand\" \"riYs,rmi\")))]\n+  \"\"\n+  \"@\n+   XOR%x0%B0\\t%2, %0\n+   XOR%X0%B0\\t%2, %0\"\n+)\n+\n+;; Macro : XOR #~0, %0\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:QHI 0 \"nonimmediate_operand\" \"=rYs,m\")\n+\t(not:QHI (match_operand:QHI 1 \"nonimmediate_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+   INV%x0%B0\\t%0\n+   INV%X0%B0\\t%0\"\n+)\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rYs,m\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+   SXT%X0\\t%0\n+   SXT%X0\\t%0\"\n+)\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rYs,m\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+   AND\\t#0xff, %0\n+   AND%X0\\t#0xff, %0\"\n+)\n+\n+;; Eliminate extraneous zero-extends mysteriously created by gcc.\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"register_operand\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\")))\n+   (set (match_operand:HI 2 \"register_operand\")\n+\t(zero_extend:HI (match_operand:QI 3 \"register_operand\")))]\n+  \"REGNO (operands[0]) == REGNO (operands[2]) && REGNO (operands[2]) == REGNO (operands[3])\"\n+  [(set (match_dup 0)\n+\t(zero_extend:HI (match_dup 1)))]\n+)\n+   \n+(define_insn \"zero_extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r,m\")\n+\t(zero_extend:PSI (match_operand:HI 1 \"nonimmediate_operand\" \"rm,r\")))]\n+  \"\"\n+  \"MOVX\\t%1, %0\"\n+)\n+\n+(define_insn \"truncpsihi2\"\n+  [(set (match_operand:HI               0 \"nonimmediate_operand\" \"=rm\")\n+\t(truncate:HI (match_operand:PSI 1 \"register_operand\"      \"r\")))]\n+  \"\"\n+  \"MOVX\\t%1, %0\"\n+)\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r\")))]\n+  \"\"\n+  { return msp430x_extendhisi (operands); }\n+)\n+\n+(define_insn \"extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r\")\n+\t(subreg:PSI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")) 0))]\n+  \"TARGET_LARGE\"\n+  \"RLAM #4, %0 { RRAM #4, %0\"\n+)\n+\n+;; Look for cases where integer/pointer conversions are suboptimal due\n+;; to missing patterns, despite us not having opcodes for these\n+;; patterns.  Doing these manually allows for alternate optimization\n+;; paths.\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"TARGET_LARGE\"\n+  \"MOV.W\\t#0,%H0\"\n+)\n+\n+(define_insn \"zero_extendhisipsi2\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r,r\")\n+\t(subreg:PSI (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,r\")) 0))]\n+  \"TARGET_LARGE\"\n+  \"@\n+   AND.W\\t#-1,%0\n+   MOV.W\\t%1,%0\"\n+)\n+\n+(define_insn \"extend_and_shift1_hipsi2\"\n+  [(set (subreg:SI (match_operand:PSI 0 \"nonimmediate_operand\" \"=r\") 0)\n+\t(ashift:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\"))\n+\t\t   (const_int 1)))]\n+  \"TARGET_LARGE\"\n+  \"RLAM #4, %0 { RRAM #3, %0\"\n+)\n+\n+(define_insn \"extend_and_shift2_hipsi2\"\n+  [(set (subreg:SI (match_operand:PSI 0 \"nonimmediate_operand\" \"=r\") 0)\n+\t(ashift:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\"))\n+\t\t   (const_int 2)))]\n+  \"TARGET_LARGE\"\n+  \"RLAM #4, %0 { RRAM #2, %0\"\n+)\n+\n+; Nasty - we are sign-extending a 20-bit PSI value in one register into\n+; two adjacent 16-bit registers to make an SI value.  There is no MSP430X\n+; instruction that will do this, so we push the 20-bit value onto the stack\n+; and then pop it off as two 16-bit values.\n+;\n+; FIXME: The MSP430X documentation does not specify if zero-extension or\n+; sign-extension happens when the 20-bit value is pushed onto the stack.\n+; It is probably zero-extension, but if not this pattern will not work\n+; when the PSI value is negative..\n+;\n+; Note: using PUSHM.A #1 is two bytes smaller than using PUSHX.A....\n+\n+(define_insn \"zero_extendpsisi2\"\n+  [(set (match_operand:SI                  0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_operand:PSI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+    if (REGNO (operands[1]) == SP_REGNO)\n+      /* If the source register is the stack pointer, the value\n+         stored in the stack slot will be the value *after* the\n+\t stack pointer has been decremented.  So allow for that\n+\t here.  */\n+      return \\\"PUSHM.A #1, %1 { ADDX.W #4, @r1 { POPX.W %0 { POPX.W %H0\\\";\n+    else\n+      return \\\"PUSHM.A #1, %1 { POPX.W %0 { POPX.W %H0\\\";\n+  \"\n+)\n+\n+; See the movsipsi2 pattern above for another way that GCC performs this\n+; conversion.\n+(define_insn \"truncsipsi2\"\n+  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n+\t(truncate:PSI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"PUSH.W %H1 { PUSH.W %1 { POPM.A #1, %0\"\n+)\n+\n+;;------------------------------------------------------------\n+;; Shift Functions\n+\n+;; Note:  We do not use the RPT ... SHIFT instruction sequence\n+;; when the repeat count is in a register, because even though RPT\n+;; accepts counts in registers, it does not work if the count is\n+;; zero, and the actual count in the register has to be one less\n+;; than the required number of iterations.  We could encode a\n+;; seqeunce like this:\n+;;\n+;;   bit #0xf, Rn\n+;;   bz  1f\n+;;   dec Rn\n+;;   rpt Rn\n+;;   <shift> Rm\n+;;   inc Rn\n+;; 1:\n+;;\n+;; But is longer than calling a helper function, and we are mostly\n+;; concerned with code size.  FIXME: Maybe enable a sequence like\n+;; this at -O3 and above ?\n+;;\n+;; Note - we ignore shift counts of less than one or more than 15.\n+;; This is permitted by the ISO C99 standard as such shifts result\n+;; in \"undefined\" behaviour.  [6.5.7 (3)]\n+\n+;; signed A << C\n+\n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI            0 \"nonimmediate_operand\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\")\n+\t\t   (match_operand:HI 2 \"general_operand\")))]\n+  \"\"\n+  {\n+    if (msp430x\n+        && REG_P (operands[0])\n+        && REG_P (operands[1])\n+        && CONST_INT_P (operands[2]))\n+      emit_insn (gen_430x_shift_left (operands[0], operands[1], operands[2]));\n+    else\t\t \n+      msp430_expand_helper (operands, \\\"__mspabi_slli\\\", true);\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"slli_1\"\n+  [(set (match_operand:HI            0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"RLA.W\\t%0\" ;; Note - this is a macro for ADD\n+)\n+\n+(define_insn \"430x_shift_left\"\n+  [(set (match_operand:HI            0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n+\t\t   (match_operand    2 \"immediate_operand\" \"n\")))]\n+  \"msp430x\"\n+  \"*\n+  if (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 16)\n+    return \\\"rpt\\t%2 { rlax.w\\t%0\\\";\n+  return \\\"# nop left shift\\\";\n+  \"\n+)\n+\n+(define_insn \"slll_1\"\n+  [(set (match_operand:SI            0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"RLA.W\\t%L0 { RLC.W\\t%H0\"\n+)\n+\n+(define_insn \"slll_2\"\n+  [(set (match_operand:SI            0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t   (const_int 2)))]\n+  \"\"\n+  \"RLA.W\\t%L0 { RLC.W\\t%H0 { RLA.W\\t%L0 { RLC.W\\t%H0\"\n+)\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI            0 \"nonimmediate_operand\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\")\n+\t\t   (match_operand:SI 2 \"general_operand\")))]\n+  \"\"\n+  \"msp430_expand_helper (operands, \\\"__mspabi_slll\\\", true);\n+   DONE;\"\n+)\n+\n+;;----------\n+\n+;; signed A >> C\n+\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\")\n+\t\t     (match_operand:HI 2 \"general_operand\")))]\n+  \"\"\n+  {\n+    if (msp430x\n+        && REG_P (operands[0])\n+        && REG_P (operands[1])\n+        && CONST_INT_P (operands[2]))\n+      emit_insn (gen_430x_arithmetic_shift_right (operands[0], operands[1], operands[2]));\n+    else\t\t \n+       msp430_expand_helper (operands, \\\"__mspabi_srai\\\", true);\n+   DONE;\n+   }\n+)\n+\n+(define_insn \"srai_1\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\"      \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"RRA.W\\t%0\"\n+)\n+\n+(define_insn \"430x_arithmetic_shift_right\"\n+  [(set (match_operand:HI              0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n+\t\t     (match_operand    2 \"immediate_operand\" \"n\")))]\n+  \"msp430x\"\n+  \"*\n+  if (INTVAL (operands[2]) > 0 && INTVAL (operands[2]) < 16)\n+    return \\\"rpt\\t%2 { rrax.w\\t%0\\\";\n+  return \\\"# nop arith right shift\\\";\n+  \"\n+)\n+\n+(define_insn \"srap_1\"\n+  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n+\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n+\t\t      (const_int 1)))]\n+  \"msp430x\"\n+  \"RRAM.A #1,%0\"\n+)\n+\n+(define_insn \"srap_2\"\n+  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n+\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n+\t\t      (const_int 2)))]\n+  \"msp430x\"\n+  \"RRAM.A #2,%0\"\n+)\n+\n+(define_insn \"sral_1\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"RRA.W\\t%H0 { RRC.W\\t%L0\"\n+)\n+\n+(define_insn \"sral_2\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t     (const_int 2)))]\n+  \"\"\n+  \"RRA.W\\t%H0 { RRC.W\\t%L0 { RRA.W\\t%H0 { RRC.W\\t%L0\"\n+)\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\")\n+\t\t     (match_operand:SI 2 \"general_operand\")))]\n+  \"\"\n+  \"msp430_expand_helper (operands, \\\"__mspabi_sral\\\", true);\n+   DONE;\"\n+)\n+\n+;;----------\n+\n+;; unsigned A >> C\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\")\n+\t\t     (match_operand:HI 2 \"general_operand\")))]\n+  \"\"\n+  {\n+    if (msp430x\n+        && REG_P (operands[0])\n+        && REG_P (operands[1])\n+        && CONST_INT_P (operands[2]))\n+      emit_insn (gen_430x_logical_shift_right (operands[0], operands[1], operands[2]));\n+    else\t\t \n+      msp430_expand_helper (operands, \\\"__mspabi_srli\\\", true);\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"srli_1\"\n+  [(set (match_operand:HI              0 \"nonimmediate_operand\" \"=rm\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\"       \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"CLRC { RRC.W\\t%0\"\n+)\n+\n+(define_insn \"430x_logical_shift_right\"\n+  [(set (match_operand:HI              0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0\")\n+\t\t     (match_operand    2 \"immediate_operand\" \"n\")))]\n+  \"msp430x\"\n+  {\n+    return msp430x_logical_shift_right (operands[2]);\n+  }\n+)\n+\n+(define_insn \"srlp_1\"\n+  [(set (match_operand:PSI              0 \"register_operand\" \"=r\")\n+\t(lshiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n+\t\t      (const_int 1)))]\n+  \"\"\n+  \"RRUM.A #1,%0\"\n+)\n+\n+(define_insn \"srll_1\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\" \"=rm\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"CLRC { RRC.W\\t%H0 { RRC.W\\t%L0\"\n+)\n+\n+(define_insn \"srll_2x\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\"       \"0\")\n+\t\t     (const_int 2)))]\n+  \"msp430x\"\n+  \"RRUX.W\\t%H0 { RRC.W\\t%L0 { RRUX.W\\t%H0 { RRC.W\\t%L0\"\n+)\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI              0 \"nonimmediate_operand\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\")\n+\t\t     (match_operand:SI 2 \"general_operand\")))]\n+  \"\"\n+  \"msp430_expand_helper (operands, \\\"__mspabi_srll\\\", true);\n+   DONE;\"\n+)\n+\n+;;------------------------------------------------------------\n+;; Function Entry/Exit\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"msp430_expand_prologue (); DONE;\"\n+  )\n+\n+(define_expand \"epilogue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"msp430_expand_epilogue (0); DONE;\"\n+  )\n+\n+\n+(define_insn \"epilogue_helper\"\n+  [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")] UNS_EPILOGUE_HELPER)]\n+  \"\"\n+  \"BR%A0\\t#__mspabi_func_epilog_%D0\"\n+  )\n+\n+\n+(define_insn \"prologue_start_marker\"\n+  [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_START_MARKER)]\n+  \"\"\n+  \"; start of prologue\"\n+  )\n+\n+(define_insn \"prologue_end_marker\"\n+  [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_END_MARKER)]\n+  \"\"\n+  \"; end of prologue\"\n+  )\n+\n+(define_insn \"epilogue_start_marker\"\n+  [(unspec_volatile [(const_int 0)] UNS_EPILOGUE_START_MARKER)]\n+  \"\"\n+  \"; start of epilogue\"\n+  )\n+\n+;;------------------------------------------------------------\n+;; Jumps\n+\n+(define_expand \"call\"\n+  [(call:HI (match_operand 0 \"\")\n+\t (match_operand 1 \"\"))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:HI (match_operand 0 \"general_operand\" \"rmi\"))\n+\t (match_operand 1 \"\"))]\n+  \"\"\n+  \"CALL%A0\\t%0\"\n+)\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand          0 \"register_operand\")\n+\t(call:HI (match_operand 1 \"general_operand\")\n+\t\t (match_operand 2 \"\")))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand               0 \"register_operand\" \"=r\")\n+\t(call (mem:HI (match_operand 1 \"general_operand\" \"rmi\"))\n+\t      (match_operand 2 \"\")))]\n+  \"\"\n+  \"CALL%A0\\t%1\"\n+)\n+\n+(define_insn \"msp_return\"\n+  [(return)]\n+  \"\"\n+  { return TARGET_LARGE ? \"RETA\" : \"RET\"; }\n+)\n+\n+;; This pattern is NOT, as expected, a return pattern.  It's called\n+;; before reload and must only store its operands, and emit a\n+;; placeholder where the epilog needs to be.  AFTER reload, the\n+;; placeholder should get expanded into a regular-type epilogue that\n+;; also does the EH return.\n+(define_expand \"eh_return\"\n+  [(match_operand:HI 0 \"\" \"\")]\n+  \"\"\n+  \"msp430_expand_eh_return (operands[0]);\n+   emit_jump_insn (gen_msp430_eh_epilogue ());\n+   emit_barrier ();\n+   DONE;\"\n+)\n+\n+;; This is the actual EH epilogue.  We emit it in the pattern above,\n+;; before reload, and convert it to a real epilogue after reload.\n+(define_insn_and_split \"msp430_eh_epilogue\"\n+  [(eh_return)]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"msp430_expand_epilogue (1); DONE;\"\n+  )\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"BR%A0\\t#%l0\"\n+)\n+\n+;; FIXME: GCC currently (8/feb/2013) cannot handle symbol_refs\n+;; in indirect jumps (cf gcc.c-torture/compile/991213-3.c).\n+(define_insn \"indirect_jump\"\n+  [(set (pc)\n+\t(match_operand 0 \"nonimmediate_operand\" \"rYl\"))]\n+  \"\"\n+  \"BR%A0\\t%0\"\n+)\n+\n+;;------------------------------------------------------------\n+;; Various Conditionals\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(parallel [(set (pc) (if_then_else\n+\t\t\t (match_operator 0 \"\"\n+\t\t\t\t\t [(match_operand:QHI 1 \"nonimmediate_operand\")\n+\t\t\t\t\t  (match_operand:QHI 2 \"general_operand\")])\n+\t\t\t (label_ref (match_operand 3 \"\" \"\"))\n+\t\t\t (pc)))\n+\t      (clobber (reg:BI CARRY))]\n+  )]\n+  \"\"\n+  \"msp430_fixup_compare_operands (<MODE>mode, operands);\"\n+  )\n+\n+(define_insn \"cbranchpsi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                     0 \"msp430_cmp_operator\"\n+\t\t\t      [(match_operand:PSI 1 \"nonimmediate_operand\" \"r,rYs,rm\")\n+\t\t\t       (match_operand:PSI 2 \"general_operand\"      \"rLs,rYsi,rmi\")])\n+              (label_ref (match_operand           3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+  CMP%A0\\t%2, %1 { J%0\\t%l3\n+  CMPX.A\\t%2, %1 { J%0\\t%l3\n+  CMPX.A\\t%2, %1 { J%0\\t%l3\"\n+  )\n+\n+(define_insn \"cbranchqi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"msp430_cmp_operator\"\n+\t\t\t      [(match_operand:QI 1 \"nonimmediate_operand\" \"rYs,rm\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\"      \"rYsi,rmi\")])\n+              (label_ref (match_operand          3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   CMP.B\\t%2, %1 { J%0\\t%l3\n+   CMP%X0.B\\t%2, %1 { J%0\\t%l3\"\n+  )\n+\n+(define_insn \"cbranchhi4_real\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"msp430_cmp_operator\"\n+\t\t\t      [(match_operand:HI 1 \"nonimmediate_operand\" \"rYs,rm\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\"      \"rYsi,rmi\")])\n+              (label_ref (match_operand          3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   CMP.W\\t%2, %1 { J%0\\t%l3\n+   CMP%X0.W\\t%2, %1 { J%0\\t%l3\"\n+  )\n+\n+(define_insn \"cbranchpsi4_reversed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                     0 \"msp430_reversible_cmp_operator\"\n+\t\t\t      [(match_operand:PSI 1 \"general_operand\" \"rLs,rYsi,rmi\")\n+\t\t\t       (match_operand:PSI 2 \"general_operand\" \"r,rYs,rm\")])\n+              (label_ref (match_operand           3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+  CMP%A0\\t%1, %2 { J%R0\\t%l3\n+  CMPX.A\\t%1, %2 { J%R0\\t%l3\n+  CMPX.A\\t%1, %2 { J%R0\\t%l3\"\n+  )\n+\n+(define_insn \"cbranchqi4_reversed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"msp430_reversible_cmp_operator\"\n+\t\t\t      [(match_operand:QI 1 \"general_operand\" \"rYsi,rmi\")\n+\t\t\t       (match_operand:QI 2 \"general_operand\" \"rYs,rm\")])\n+              (label_ref (match_operand          3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   CMP.B\\t%1, %2 { J%R0\\t%l3\n+   CMP%X0.B\\t%1, %2 { J%R0\\t%l3\"\n+  )\n+\n+(define_insn \"cbranchhi4_reversed\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator                    0 \"msp430_reversible_cmp_operator\"\n+\t\t\t      [(match_operand:HI 1 \"general_operand\" \"rYsi,rmi\")\n+\t\t\t       (match_operand:HI 2 \"general_operand\" \"rYs,rm\")])\n+              (label_ref (match_operand          3 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   CMP.W\\t%1, %2 { J%R0\\t%l3\n+   CMP%X0.W\\t%1, %2 { J%R0\\t%l3\"\n+  )\n+\n+\n+(define_insn \"*bitbranch<mode>4\"\n+  [(set (pc) (if_then_else\n+\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYs,rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rYsi,rmi\"))\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   BIT%x0%B0\\t%1, %0 { JNE\\t%l2\n+   BIT%X0%B0\\t%1, %0 { JNE\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4\"\n+  [(set (pc) (if_then_else\n+\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%x0%X0%B0\\t%1, %0 { JEQ\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4\"\n+  [(set (pc) (if_then_else\n+\t      (eq (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t\t  (const_int 0))\n+              (pc)\n+\t      (label_ref (match_operand 2 \"\" \"\"))))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%X0%B0\\t%1, %0 { JNE\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4\"\n+  [(set (pc) (if_then_else\n+\t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t   (match_operand:QHI 1 \"msp_general_operand\" \"rmi\"))\n+\t\t  (const_int 0))\n+              (pc)\n+\t      (label_ref (match_operand 2 \"\" \"\"))))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%X0%B0\\t%1, %0 { JEQ\\t%l2\"\n+  )\n+\n+;;------------------------------------------------------------\n+;; zero-extend versions of the above\n+\n+(define_insn \"*bitbranch<mode>4_z\"\n+  [(set (pc) (if_then_else\n+\t      (ne (zero_extract:HI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYs,rm\")\n+\t\t\t\t    (const_int 1)\n+\t\t\t\t    (match_operand 1 \"msp430_bitpos\" \"i,i\"))\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"@\n+   BIT%x0%B0\\t%p1, %0 { JNE\\t%l2\n+   BIT%X0%B0\\t%p1, %0 { JNE\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4_z\"\n+  [(set (pc) (if_then_else\n+\t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t\t   (const_int 1)\n+\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t  (const_int 0))\n+              (label_ref (match_operand 2 \"\" \"\"))\n+\t      (pc)))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%x0%X0%B0\\t%p1, %0 { JEQ\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4_z\"\n+  [(set (pc) (if_then_else\n+\t      (eq (zero_extract:HI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t\t   (const_int 1)\n+\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t  (const_int 0))\n+              (pc)\n+\t      (label_ref (match_operand 2 \"\" \"\"))))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%X0%B0\\t%p1, %0 { JNE\\t%l2\"\n+  )\n+\n+(define_insn \"*bitbranch<mode>4_z\"\n+  [(set (pc) (if_then_else\n+\t      (ne (zero_extract:HI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rm\")\n+\t\t\t\t   (const_int 1)\n+\t\t\t\t   (match_operand 1 \"msp430_bitpos\" \"i\"))\n+\t\t  (const_int 0))\n+              (pc)\n+\t      (label_ref (match_operand 2 \"\" \"\"))))\n+   (clobber (reg:BI CARRY))\n+   ]\n+  \"\"\n+  \"BIT%X0%B0\\t%p1, %0 { JEQ\\t%l2\"\n+  )\n+\n+;;------------------------------------------------------------\n+;; Misc\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"1\"\n+  \"NOP\"\n+)\n+  "}, {"sha": "6d4fc347e1a1db8a4a7106b92c489d343a77d368", "filename": "gcc/config/msp430/msp430.opt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.opt?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,26 @@\n+msim\n+Target\n+Use simulator runtime\n+\n+masm-hex\n+Target Mask(ASM_HEX)\n+Force assembly output to always use hex constants\n+\n+mmcu=\n+Target Joined RejectNegative Var(target_cpu)\n+Specify the cpu to build for.  If the name begins with 'msp430x' then the 430X instructions are enabled\n+\n+mlarge\n+Target Mask(LARGE) RejectNegative\n+Select large model - 20-bit addresses/pointers\n+\n+msmall\n+Target InverseMask(LARGE) RejectNegative\n+Select small model - 16-bit addresses/pointers (default)\n+\n+mrelax\n+Target Report\n+Optimize opcode sizes at link time\n+\n+mOs\n+Target Undocumented Mask(OPT_SPACE)"}, {"sha": "6f99caa94eb7e5fa0684ca5d1a1d705888fbccde", "filename": "gcc/config/msp430/predicates.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fpredicates.md?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,80 @@\n+;;  Machine Description for TI MSP43* processors\n+;;  Copyright (C) 2013 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_predicate \"msp_volatile_memory_operand\"\n+  (and (match_code \"mem\")\n+       (match_test (\"memory_address_addr_space_p (GET_MODE (op), XEXP (op, 0), MEM_ADDR_SPACE (op))\")))\n+)\n+\n+; TRUE for any valid general operand.  We do this because\n+; general_operand refuses to match volatile memory refs.\n+\n+(define_predicate \"msp_general_operand\"\n+  (ior (match_operand 0 \"general_operand\")\n+       (match_operand 0 \"msp_volatile_memory_operand\"))\n+)\n+\n+; Likewise for nonimmediate_operand.\n+\n+(define_predicate \"msp_nonimmediate_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_operand 0 \"msp_volatile_memory_operand\"))\n+)\n+\n+(define_predicate \"ubyte_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 255)\")))\n+\n+; TRUE for comparisons we support.\n+(define_predicate \"msp430_cmp_operator\"\n+  (match_code \"eq,ne,lt,ltu,ge,geu\"))\n+\n+; TRUE for comparisons we need to reverse.\n+(define_predicate \"msp430_reversible_cmp_operator\"\n+  (match_code \"gt,gtu,le,leu\"))\n+\n+; TRUE for constants the constant generator can produce\n+(define_predicate \"msp430_constgen_operator\"\n+  (and (match_code \"const_int\")\n+       (match_test (\"   INTVAL (op) == 0\n+\t\t     || INTVAL (op) == 1\n+\t\t     || INTVAL (op) == 2\n+\t\t     || INTVAL (op) == 4\n+\t\t     || INTVAL (op) == 8\n+\t\t     || INTVAL (op) == -1 \"))))\n+\n+; TRUE for constants the constant generator can produce\n+(define_predicate \"msp430_inv_constgen_operator\"\n+  (and (match_code \"const_int\")\n+       (match_test (\"   INTVAL (op) == ~0\n+\t\t     || INTVAL (op) == ~1\n+\t\t     || INTVAL (op) == ~2\n+\t\t     || INTVAL (op) == ~4\n+\t\t     || INTVAL (op) == ~8\n+\t\t     || INTVAL (op) == ~(-1) \"))))\n+\n+(define_predicate \"msp430_nonsubreg_operand\"\n+  (match_code \"reg,mem\"))\n+\n+; TRUE for constants which are bit positions for zero_extract\n+(define_predicate \"msp430_bitpos\"\n+  (and (match_code \"const_int\")\n+       (match_test (\"   INTVAL (op) >= 0\n+\t\t     && INTVAL (op) <= 15 \"))))"}, {"sha": "c7048378da4cbb99b09b306e5dc85ebb79313611", "filename": "gcc/config/msp430/t-msp430", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Ft-msp430", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fconfig%2Fmsp430%2Ft-msp430", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Ft-msp430?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,43 @@\n+# Makefile fragment for building GCC for the TI MSP430 target.\n+# Copyright (C) 2012-2013 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Enable multilibs:\n+\n+MULTILIB_OPTIONS    = mmcu=msp430x mlarge\n+MULTILIB_DIRNAMES   = 430x large\n+\n+# Match msp430X with msp430x.\n+MULTILIB_MATCHES    = mmcu?msp430x=mmcu?msp430X\n+\n+# each supported MCU needs a line like this:\n+# MULTILIB_MATCHES  += mmcu?msp430x123=mmcu?msp430x\n+\n+# The only way I figured this out was to hack the script to SHOW me\n+# what it's doing.  It's non-obvious, but it matches the directory\n+# structure of the multilib tree, but using the options, not the\n+# directory names.  A shell CASE statement is generated from these, so\n+# the usual CASE wildcards are supported.\n+\n+MULTILIB_EXCEPTIONS = mlarge\n+\n+MULTILIB_EXTRA_OPTS =\n+\n+msp430-c.o: $(srcdir)/config/msp430/msp430-c.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_H)\n+\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<"}, {"sha": "9dd2c26287cfa23ec26e91fc7712ef66a95ec651", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -176,7 +176,7 @@ The @uref{http://www.gnu.org/software/classpath/,,GNU Classpath project}\n for all of their merged runtime code.\n \n @item\n-Nick Clifton for arm, mcore, fr30, v850, m32r, rx work,\n+Nick Clifton for arm, mcore, fr30, v850, m32r, msp430 rx work,\n @option{--help}, and other random hacking.\n \n @item\n@@ -218,7 +218,7 @@ Mo DeJong for GCJ and libgcj bug fixes.\n \n @item\n DJ Delorie for the DJGPP port, build and libiberty maintenance,\n-various bug fixes, and the M32C, MeP, and RL78 ports.\n+various bug fixes, and the M32C, MeP, MSP430, and RL78 ports.\n \n @item\n Arnaud Desitter for helping to debug GNU Fortran."}, {"sha": "0011b68065bb70a09a9fdfd58260bbce6f423111", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -3989,6 +3989,13 @@ the O32 ABI.\n @heading @anchor{moxie-x-elf}moxie-*-elf\n The moxie processor.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{msp430-x-elf}msp430-*-elf\n+TI MSP430 processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "caca744409087d8974dff29cbcf9c4b50369443f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -804,6 +804,9 @@ Objective-C and Objective-C++ Dialects}.\n @emph{Moxie Options}\n @gccoptlist{-meb -mel -mno-crt0}\n \n+@emph{MSP430 Options}\n+@gccoptlist{-msim -masm-hex -mmcu= -mlarge -msmall -mrelax}\n+\n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n -mbcopy  -mbcopy-builtin  -mint32  -mno-int16 @gol\n@@ -11036,6 +11039,7 @@ platform.\n * MMIX Options::\n * MN10300 Options::\n * Moxie Options::\n+* MSP430 Options::\n * PDP-11 Options::\n * picoChip Options::\n * PowerPC Options::\n@@ -16026,7 +16030,7 @@ Link the SDRAM-based runtime instead of the default ROM-based runtime.\n \n @item -msim\n @opindex msim\n-Link the simulator runtime libraries.\n+Link the simulator run-time libraries.\n \n @item -msimnovec\n @opindex msimnovec\n@@ -17290,6 +17294,46 @@ Do not link in the C run-time initialization object file.\n \n @end table\n \n+@node MSP430 Options\n+@subsection MSP430 Options\n+@cindex MSP430 Options\n+\n+These options are defined for the MSP430:\n+\n+@table @gcctabopt\n+\n+@item -msim\n+@opindex msim\n+Link the simulator runtime libraries.\n+\n+@item -masm-hex\n+@opindex masm-hex\n+Force assembly output to always use hex constants.  Normally such\n+constants are signed decimals, but this option is available for\n+testsuite and/or aesthetic purposes.\n+\n+@item -mmcu=\n+@opindex mmcu=\n+Select the MCU to target.  Note that there are two ``generic'' MCUs,\n+@code{msp430} and @code{msp430x}, which should be used most of the\n+time.  This option is also passed to the assembler.\n+\n+@item -mlarge\n+@opindex mlarge\n+Use large-model addressing (20-bit pointers, 32-bit @code{size_t}).\n+\n+@item -msmall\n+@opindex msmall\n+Use small-model addressing (16-bit pointers, 16-bit @code{size_t}).\n+\n+@item -mrelax\n+@opindex mrelax\n+This option is passed to the assembler and linker, and allows the\n+linker to perform certain optimizations that cannot be done until\n+the final link.\n+\n+@end table\n+\n @node PDP-11 Options\n @subsection PDP-11 Options\n @cindex PDP-11 Options"}, {"sha": "57760469d33acdbff0b9ba69d0c47b6b0ae1fa24", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -3063,6 +3063,35 @@ A constant in the range of 0 to @minus{}255.\n \n @end table\n \n+@item MSP430--@file{config/msp430/constraints.md}\n+@table @code\n+\n+@item R12\n+Register R12.\n+\n+@item R13\n+Register R13.\n+\n+@item K\n+Integer constant 1.\n+\n+@item L\n+Integer constant -1^20..1^19.\n+\n+@item M\n+Integer constant 1-4.\n+\n+@item Ya\n+Memory references which do not require an extended MOVX instruction.\n+\n+@item Yl\n+Memory reference, labels only.\n+\n+@item Ys\n+Memory reference, stack only.\n+\n+@end table\n+\n @item PDP-11---@file{config/pdp11/constraints.md}\n @table @code\n @item a"}, {"sha": "2d9c7d4f7638bbeb5ac949ca79921f56c59e342f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -1,3 +1,8 @@\n+2013-09-12  DJ Delorie  <dj@redhat.com>\n+\n+\t* config.host (msp*-*-elf): New.\n+\t* config/msp430/: New port.\n+\n 2013-08-18  Iain Sandoe  <iain@codesourcery.com>\n \n \tPR gcov-profile/58127"}, {"sha": "1fa3a6541310b0bd033ea5235a609fd7c3dc5c7c", "filename": "libgcc/config.host", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -831,6 +831,9 @@ moxie-*-rtems*)\n \t# Don't use default.\n \textra_parts=\n \t;;\n+msp430*-*-elf)\n+\ttmake_file=\"$tm_file t-crtstuff t-fdpbit msp430/t-msp430\"\n+\t;;\n pdp11-*-*)\n \ttmake_file=\"pdp11/t-pdp11 t-fdpbit\"\n \t;;"}, {"sha": "03e690dff53ae4d2878fa34cf0ac97147d43a91f", "filename": "libgcc/config/msp430/cmpd.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fcmpd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fcmpd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fcmpd.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,19 @@\n+/* Public domain.  */\n+int\n+__mspabi_cmpf (float x, float y)\n+{\n+  if (x < y)\n+    return -1;\n+  if (x > y)\n+    return 1;\n+  return 0;\n+}\n+int\n+__mspabi_cmpd (double x, double y)\n+{\n+  if (x < y)\n+    return -1;\n+  if (x > y)\n+    return 1;\n+  return 0;\n+}"}, {"sha": "e8e5b3935a48687f5eea0b7c592d15029c5be6a5", "filename": "libgcc/config/msp430/cmpsi2.S", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fcmpsi2.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fcmpsi2.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fcmpsi2.S?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,98 @@\n+;   Copyright (C) 2012, 2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+#ifdef __MSP430X_LARGE__\n+#define ret_\tRETA\n+#else\n+#define ret_\tRET\n+#endif\n+\n+\t.text\n+\n+\t;;   int __cmpsi2 (signed long A, signed long B)\n+\t;;\n+\t;; Performs a signed comparison of A and B.\n+\t;; If A is less than B it returns 0.  If A is greater\n+\t;; than B it returns 2.  If they are equal it returns 1.\n+\n+\t;;  Note - this code is also used by the __ucmpsi2 routine below.\n+\n+\t.global\t__cmpsi2\n+        .type   __cmpsi2, @function\n+__cmpsi2:\n+\t;; A is in r12 (low), r13 (high)\n+\t;; B is in r14 (low), r15 (high)\n+\t;; Result put in r12\n+\n+\tcmp.w\tr13, r15\n+\tjeq\t.L_compare_low\n+\tjge\t.L_less_than\n+.L_greater_than:\n+\tmov.w\t#2, r12\n+\tret_\n+.L_less_than:\n+\tmov.w\t#0, r12\n+\tret_\n+\n+.L_compare_low:\n+\tcmp.w\tr12, r14\n+\tjl\t.L_greater_than\n+\tjne     .L_less_than\n+\tmov.w\t#1, r12\n+\tret_\n+\n+\t.size\t__cmpsi2, . - __cmpsi2\n+\n+\n+\t;;   int __ucmpsi2 (unsigned long A, unsigned long B)\n+\t;;\n+\t;; Performs an unsigned comparison of A and B.\n+\t;; If A is less than B it returns 0.  If A is greater\n+\t;; than B it returns 2.  If they are equal it returns 1.\n+\n+;;;  Note - this function branches into the __cmpsi2 code above.\n+\n+\t.global\t__ucmpsi2\n+        .type   __ucmpsi2, @function\n+__ucmpsi2:\n+\t;; A is in r12 (low), r13 (high)\n+\t;; B is in r14 (low), r15 (high)\n+\t;; Result put in r12\n+\n+\ttst\tr13\n+\tjn\t.L_top_bit_set_in_A\n+\ttst\tr15\n+;;; If the top bit of B is set, but A's is clear we know that A < B.\n+\tjn\t.L_less_than\n+;;; Neither A nor B has their top bit set so we can use the __cmpsi2 routine.\n+;;; Note we use Jc rather than BR as that saves two bytes.  The TST insn always\n+;;; sets the C bit.\n+\tjc\t__cmpsi2\n+\n+.L_top_bit_set_in_A:\n+\ttst\tr15\n+;;;  If both A and B have their top bit set we can use the __cmpsi2 routine.\n+\tjn\t__cmpsi2\n+;;; Otherwise A has its top bit set and B does not so A > B.\n+\tjc\t.L_greater_than\n+\n+\t.size\t__ucmpsi2, . - __ucmpsi2"}, {"sha": "2e86decafc11de735679b14baa2d75b480995992", "filename": "libgcc/config/msp430/epilogue.S", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fepilogue.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fepilogue.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fepilogue.S?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,51 @@\n+;   Copyright (C) 2012, 2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\n+\t.text\n+\n+\t.global\t__mspabi_func_epilog_7\n+\t.global\t__mspabi_func_epilog_6\n+\t.global\t__mspabi_func_epilog_5\n+\t.global\t__mspabi_func_epilog_4\n+\t.global\t__mspabi_func_epilog_3\n+\t.global\t__mspabi_func_epilog_2\n+\t.global\t__mspabi_func_epilog_1\n+\n+__mspabi_func_epilog_7:\n+\tPOP\tR4\n+__mspabi_func_epilog_6:\n+\tPOP\tR5\n+__mspabi_func_epilog_5:\n+\tPOP\tR6\n+__mspabi_func_epilog_4:\n+\tPOP\tR7\n+__mspabi_func_epilog_3:\n+\tPOP\tR8\n+__mspabi_func_epilog_2:\n+\tPOP\tR9\n+__mspabi_func_epilog_1:\n+\tPOP\tR10\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif"}, {"sha": "304731d518be87b91a99bae33e13d87a8810b438", "filename": "libgcc/config/msp430/floathidf.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloathidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloathidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Ffloathidf.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,8 @@\n+/* Public domain.  */\n+extern double __floatsidf (long);\n+\n+double\n+__floathidf (int u)\n+{\n+  return __floatsidf ((long)u);\n+}"}, {"sha": "64e5d805d21ede50f25342425797ddecfce9c9b9", "filename": "libgcc/config/msp430/floathisf.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloathisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloathisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Ffloathisf.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,11 @@\n+/* Public domain.  */\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef float SFtype __attribute__ ((mode (SF)));\n+\n+extern SFtype __floatsisf (unsigned long);\n+\n+SFtype\n+__floathisf (HItype u)\n+{\n+  return __floatsisf ((unsigned long)u);\n+}"}, {"sha": "f13b55076929ba944623745b66bc168253888481", "filename": "libgcc/config/msp430/floatunhidf.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloatunhidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloatunhidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Ffloatunhidf.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,12 @@\n+/* Public domain.  */\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef float DFtype __attribute__ ((mode (DF)));\n+\n+extern DFtype __floatunsidf (unsigned long);\n+\n+DFtype\n+__floatunhidf (UHItype u)\n+{\n+  return __floatunsidf ((unsigned long)u);\n+}"}, {"sha": "ea920bd853aa4acdd52a4f88efd5e8a619d4b8d9", "filename": "libgcc/config/msp430/floatunhisf.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloatunhisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ffloatunhisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Ffloatunhisf.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,12 @@\n+/* Public domain.  */\n+typedef int HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef float SFtype __attribute__ ((mode (SF)));\n+\n+extern SFtype __floatunsisf (unsigned long);\n+\n+SFtype\n+__floatunhisf (UHItype u)\n+{\n+  return __floatunsisf ((unsigned long)u);\n+}"}, {"sha": "f0291ad60b042802fcdcb070f1df5991e6dbdd8f", "filename": "libgcc/config/msp430/lib2bitcountHI.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2bitcountHI.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2bitcountHI.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2bitcountHI.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,50 @@\n+/* libgcc routines for MSP430\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef          int  sint08_type   __attribute__ ((mode (QI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+typedef int           word_type     __attribute__ ((mode (__word__)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+/* See the comment by the definition of LIBGCC2_UNITS_PER_WORD in\n+   msp430.h for why we are creating extra versions of some of the\n+   functions defined in libgcc2.c.  */\n+\n+#define LIBGCC2_UNITS_PER_WORD 2\n+\n+#define L_clzsi2\n+#define L_ctzsi2\n+#define L_ffssi2\n+#define L_paritysi2\n+#define L_popcountsi2\n+\n+#include \"libgcc2.c\""}, {"sha": "e70ed400513deea410ef4c846582121d01983cc0", "filename": "libgcc/config/msp430/lib2divHI.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divHI.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divHI.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2divHI.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,43 @@\n+/* HI mode divide routines for libgcc for MSP430\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef          int  sint08_type   __attribute__ ((mode (QI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+typedef int           word_type     __attribute__ ((mode (__word__)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+#define UINT_TYPE\tuint16_type\n+#define SINT_TYPE\tsint16_type\n+#define BITS_MINUS_1\t15\n+#define NAME_MODE\thi\n+\n+#include \"msp430-divmod.h\""}, {"sha": "fe341fc2fdc6d07b37e7a8b3dceba65dcfdd923e", "filename": "libgcc/config/msp430/lib2divQI.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divQI.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divQI.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2divQI.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,44 @@\n+/* QI mode divide routines for libgcc for MSP430\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef          int  sint08_type   __attribute__ ((mode (QI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+typedef int           word_type     __attribute__ ((mode (__word__)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+#define UINT_TYPE\tuint08_type\n+#define SINT_TYPE\tsint08_type\n+#define BITS_MINUS_1\t7\n+#define NAME_MODE\tqi\n+\n+#include \"msp430-divmod.h\"\n+"}, {"sha": "bc1dacaf51fbe7ec2d546ecf1744904b9454a8fc", "filename": "libgcc/config/msp430/lib2divSI.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divSI.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2divSI.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2divSI.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,43 @@\n+/* SI mode divide routines for libgcc for MSP430\n+   Copyright (C) 2012\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef          int  sint08_type   __attribute__ ((mode (QI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+typedef int           word_type     __attribute__ ((mode (__word__)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+#define UINT_TYPE\tuint32_type\n+#define SINT_TYPE\tsint32_type\n+#define BITS_MINUS_1\t31\n+#define NAME_MODE\tsi\n+\n+#include \"msp430-divmod.h\""}, {"sha": "9f68f4c5e67b6ce7f23fbf5df6b086e223cd09cf", "filename": "libgcc/config/msp430/lib2mul.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,59 @@\n+/* libgcc routines for MSP430\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n+\n+#define C3B(a,b,c) a##b##c\n+#define C3(a,b,c) C3B(a,b,c)\n+\n+\n+#define UINT_TYPE\tuint16_type\n+#define BITS_MINUS_1\t15\n+#define NAME_MODE\thi\n+\n+#include \"msp430-mul.h\"\n+\n+#undef UINT_TYPE\n+#undef BITS_MINUS_1\n+#undef NAME_MODE\n+\n+#define UINT_TYPE\tuint08_type\n+#define BITS_MINUS_1\t7\n+#define NAME_MODE\tqi\n+\n+#include \"msp430-mul.h\"\n+\n+#undef UINT_TYPE\n+#undef BITS_MINUS_1\n+#undef NAME_MODE\n+\n+#define UINT_TYPE\tuint32_type\n+#define BITS_MINUS_1\t31\n+#define NAME_MODE\tsi\n+\n+#include \"msp430-mul.h\""}, {"sha": "53d7eaec6825542675313ca87b0c4c76bb494f75", "filename": "libgcc/config/msp430/lib2shift.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Flib2shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2shift.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,113 @@\n+/* Shift functions for the GCC support library for the MSP430\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+typedef          int  sint32_type   __attribute__ ((mode (SI)));\n+typedef unsigned int  uint32_type   __attribute__ ((mode (SI)));\n+typedef          int  sint16_type   __attribute__ ((mode (HI)));\n+typedef unsigned int  uint16_type   __attribute__ ((mode (HI)));\n+\n+uint32_type __ashlsi3 (uint32_type in, char bit);\n+sint32_type __ashrsi3 (sint32_type in, char bit);\n+int __clrsbhi2 (sint16_type x);\n+extern int __clrsbsi2 (sint32_type x);\n+\n+typedef struct\n+{\n+  union\n+  {\n+    uint32_type u;\n+    uint16_type h[2];\n+  } u;\n+} dd;\n+\n+uint32_type\n+__ashlsi3 (uint32_type in, char bit)\n+{\n+  uint16_type h, l;\n+  dd d;\n+\n+  if (bit > 32)\n+    return 0;\n+  if (bit < 0)\n+    return in;\n+\n+  d.u.u = in;\n+  h = d.u.h[1];\n+  l = d.u.h[0];\n+\n+  if (bit > 15)\n+    {\n+      h = l;\n+      l = 0;\n+      bit -= 16;\n+    }\n+\n+  while (bit)\n+    {\n+      h = (h << 1) | (l >> 15);\n+      l <<= 1;\n+      bit --;\n+    }\n+\n+  d.u.h[1] = h;\n+  d.u.h[0] = l;\n+  return d.u.u;\n+}\n+\n+sint32_type\n+__ashrsi3 (sint32_type in, char bit)\n+{\n+  sint16_type h;\n+  uint16_type l;\n+  dd d;\n+\n+  if (bit > 32)\n+    return 0;\n+  if (bit < 0)\n+    return in;\n+\n+  d.u.u = in;\n+  h = d.u.h[1];\n+  l = d.u.h[0];\n+\n+  while (bit)\n+    {\n+      l = (h << 15) | (l >> 1);\n+      h >>= 1;\n+      bit --;\n+    }\n+\n+  d.u.h[1] = h;\n+  d.u.h[0] = l;\n+  return d.u.u;\n+}\n+\n+int\n+__clrsbhi2 (sint16_type x)\n+{\n+  if (x == 0)\n+    return 15;\n+  return __clrsbsi2 ((sint32_type) x) - 16;\n+}"}, {"sha": "57cffd0ba2a68b5a75355759bf4c60e0d0f73652", "filename": "libgcc/config/msp430/mpy.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fmpy.c?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,15 @@\n+/* Public domain.  */\n+extern int __mulhi3 (int, int);\n+\n+int\n+__mulhi3 (int x, int y)\n+{\n+  volatile int rv = 0;\n+\n+  while (y > 0)\n+    {\n+      rv += x;\n+      y --;\n+    }\n+  return rv;\n+}"}, {"sha": "206c7516c3ee0e6f0bf973b51488b8d3b8d8f56d", "filename": "libgcc/config/msp430/msp430-divmod.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmsp430-divmod.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmsp430-divmod.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fmsp430-divmod.h?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,118 @@\n+/* libgcc routines for MSP430\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+UINT_TYPE C3(udivmod,NAME_MODE,4) (UINT_TYPE, UINT_TYPE, word_type);\n+SINT_TYPE C3(__div,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);\n+SINT_TYPE C3(__mod,NAME_MODE,3)   (SINT_TYPE, SINT_TYPE);\n+UINT_TYPE C3(__udiv,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);\n+UINT_TYPE C3(__umod,NAME_MODE,3)  (UINT_TYPE, UINT_TYPE);\n+\n+UINT_TYPE\n+C3(udivmod,NAME_MODE,4) (UINT_TYPE num, UINT_TYPE den, word_type modwanted)\n+{\n+  UINT_TYPE bit = 1;\n+  UINT_TYPE res = 0;\n+\n+  while (den < num && bit && !(den & (1L << BITS_MINUS_1)))\n+    {\n+      den <<= 1;\n+      bit <<= 1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>= 1;\n+      den >>= 1;\n+    }\n+  if (modwanted)\n+    return num;\n+  return res;\n+}\n+\n+SINT_TYPE\n+C3(__div,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)\n+{\n+  word_type neg = 0;\n+  SINT_TYPE res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = C3(udivmod,NAME_MODE,4) (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+SINT_TYPE\n+C3(__mod,NAME_MODE,3) (SINT_TYPE a, SINT_TYPE b)\n+{\n+  word_type neg = 0;\n+  SINT_TYPE res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = C3(udivmod,NAME_MODE,4) (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+UINT_TYPE\n+C3(__udiv,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  return C3(udivmod,NAME_MODE,4) (a, b, 0);\n+}\n+\n+UINT_TYPE\n+C3(__umod,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  return C3(udivmod,NAME_MODE,4) (a, b, 1);\n+}"}, {"sha": "fc2cd6c6ebb08e768c9ac7fcdfc80b153caf7e85", "filename": "libgcc/config/msp430/msp430-mul.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmsp430-mul.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fmsp430-mul.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fmsp430-mul.h?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,43 @@\n+/* libgcc routines for RL78\n+   Copyright (C) 2005, 2009, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+UINT_TYPE C3(__mul,NAME_MODE,3)   (UINT_TYPE, UINT_TYPE);\n+UINT_TYPE\n+C3(__mul,NAME_MODE,3) (UINT_TYPE a, UINT_TYPE b)\n+{\n+  UINT_TYPE rv = 0;\n+\n+  char bit;\n+\n+  for (bit=0; b && bit<sizeof(UINT_TYPE)*8; bit++)\n+    {\n+      if (b & 1)\n+\trv += a;\n+      a <<= 1;\n+      b >>= 1;\n+    }\n+  return rv;\n+}"}, {"sha": "48ed15d3ec30878ca9141ea5a5ea9e4eaa088c18", "filename": "libgcc/config/msp430/slli.S", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fslli.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fslli.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fslli.S?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,108 @@\n+;   Copyright (C) 2012, 2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\t\n+\t.text\n+\n+/* Logical Left Shift - R12 -> R12 */\n+\n+\t.macro\t_slli n\n+\t.global __mspabi_slli_\\n\n+__mspabi_slli_\\n:\n+\tADD.W\tR12,R12\n+\t.endm\n+\n+\t_slli\t15\n+\t_slli\t14\n+\t_slli\t13\n+\t_slli\t12\n+\t_slli\t11\n+\t_slli\t10\n+\t_slli\t9\n+\t_slli\t8\n+\t_slli\t7\n+\t_slli\t6\n+\t_slli\t5\n+\t_slli\t4\n+\t_slli\t3\n+\t_slli\t2\n+\t_slli\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R13\n+\tADD.W\tR12,R12\n+\t.global\t__mspabi_slli\n+__mspabi_slli:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+/* Logical Left Shift - R12:R13 -> R12:R13 */\n+\n+\t.macro\t_slll\tn\n+\t.global\t__mspabi_slll_\\n\n+__mspabi_slll_\\n:\n+\tADD.W\tR12,R12\n+\tADDC.W\tR13,R13\n+\t.endm\n+\n+\t_slll\t15\n+\t_slll\t14\n+\t_slll\t13\n+\t_slll\t12\n+\t_slll\t11\n+\t_slll\t10\n+\t_slll\t9\n+\t_slll\t8\n+\t_slll\t7\n+\t_slll\t6\n+\t_slll\t5\n+\t_slll\t4\n+\t_slll\t3\n+\t_slll\t2\n+\t_slll\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R14\n+\tADD.W\tR12,R12\n+\tADDC.W\tR13,R13\n+\t.global\t__mspabi_slll\n+__mspabi_slll:\n+\tCMP\t#0,R14\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+"}, {"sha": "8f841229fde48dd097a6bfd24d5bec574fa7d1bd", "filename": "libgcc/config/msp430/srai.S", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fsrai.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fsrai.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fsrai.S?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,106 @@\n+;   Copyright (C) 2012, 2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\t\n+\t.text\n+\n+\t.macro\t_srai n\n+\t.global __mspabi_srai_\\n\n+__mspabi_srai_\\n:\n+\tRRA.W\tR12\n+\t.endm\n+\n+/* Logical Right Shift - R12 -> R12 */\n+\t_srai\t15\n+\t_srai\t14\n+\t_srai\t13\n+\t_srai\t12\n+\t_srai\t11\n+\t_srai\t10\n+\t_srai\t9\n+\t_srai\t8\n+\t_srai\t7\n+\t_srai\t6\n+\t_srai\t5\n+\t_srai\t4\n+\t_srai\t3\n+\t_srai\t2\n+\t_srai\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R13\n+\tRRA.W\tR12,R12\n+\t.global\t__mspabi_srai\n+__mspabi_srai:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+/* Logical Right Shift - R12:R13 -> R12:R13 */\n+\n+\t.macro\t_sral\tn\n+\t.global\t__mspabi_sral_\\n\n+__mspabi_sral_\\n:\n+\tRRA.W\tR13\n+\tRRC.W\tR12\n+\t.endm\n+\n+\t_sral\t15\n+\t_sral\t14\n+\t_sral\t13\n+\t_sral\t12\n+\t_sral\t11\n+\t_sral\t10\n+\t_sral\t9\n+\t_sral\t8\n+\t_sral\t7\n+\t_sral\t6\n+\t_sral\t5\n+\t_sral\t4\n+\t_sral\t3\n+\t_sral\t2\n+\t_sral\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R14\n+\tRRA.W\tR13\n+\tRRC.W\tR12\n+\t.global\t__mspabi_sral\n+__mspabi_sral:\n+\tCMP\t#0,R14\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif"}, {"sha": "3ec33df343fcad3bdba4cdb3f63d561939aada23", "filename": "libgcc/config/msp430/srli.S", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fsrli.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Fsrli.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Fsrli.S?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,110 @@\n+;   Copyright (C) 2012, 2013 Free Software Foundation, Inc.\n+;   Contributed by Red Hat.\n+; \n+; This file is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published by the\n+; Free Software Foundation; either version 3, or (at your option) any\n+; later version.\n+; \n+; This file is distributed in the hope that it will be useful, but\n+; WITHOUT ANY WARRANTY; without even the implied warranty of\n+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+; General Public License for more details.\n+; \n+; Under Section 7 of GPL version 3, you are granted additional\n+; permissions described in the GCC Runtime Library Exception, version\n+; 3.1, as published by the Free Software Foundation.\n+;\n+; You should have received a copy of the GNU General Public License and\n+; a copy of the GCC Runtime Library Exception along with this program;\n+; see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+; <http://www.gnu.org/licenses/>.\n+\t\n+\t.text\n+\n+\t.macro\t_srli n\n+\t.global __mspabi_srli_\\n\n+__mspabi_srli_\\n:\n+\tCLRC\n+\tRRC.W\tR12\n+\t.endm\n+\n+/* Logical Right Shift - R12 -> R12 */\n+\t_srli\t15\n+\t_srli\t14\n+\t_srli\t13\n+\t_srli\t12\n+\t_srli\t11\n+\t_srli\t10\n+\t_srli\t9\n+\t_srli\t8\n+\t_srli\t7\n+\t_srli\t6\n+\t_srli\t5\n+\t_srli\t4\n+\t_srli\t3\n+\t_srli\t2\n+\t_srli\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R13\n+\tCLRC\n+\tRRC.W\tR12,R12\n+\t.global\t__mspabi_srli\n+__mspabi_srli:\n+\tCMP\t#0,R13\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+/* Logical Right Shift - R12:R13 -> R12:R13 */\n+\n+\t.macro\t_srll\tn\n+\t.global\t__mspabi_srll_\\n\n+__mspabi_srll_\\n:\n+\tCLRC\n+\tRRC.W\tR13\n+\tRRC.W\tR12\n+\t.endm\n+\n+\t_srll\t15\n+\t_srll\t14\n+\t_srll\t13\n+\t_srll\t12\n+\t_srll\t11\n+\t_srll\t10\n+\t_srll\t9\n+\t_srll\t8\n+\t_srll\t7\n+\t_srll\t6\n+\t_srll\t5\n+\t_srll\t4\n+\t_srll\t3\n+\t_srll\t2\n+\t_srll\t1\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif\n+\n+1:\tADD.W\t#-1,R14\n+\tCLRC\n+\tRRC.W\tR13\n+\tRRC.W\tR12\n+\t.global\t__mspabi_srll\n+__mspabi_srll:\n+\tCMP\t#0,R14\n+\tJNZ\t1b\n+#ifdef __MSP430X_LARGE__\n+\tRETA\n+#else\n+\tRET\n+#endif"}, {"sha": "a4d4158e1996a98e6c44b70709e8975635aea4e5", "filename": "libgcc/config/msp430/t-msp430", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ft-msp430", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c/libgcc%2Fconfig%2Fmsp430%2Ft-msp430", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Ft-msp430?ref=f6a83b4a9f8bb38ee24d244a4521ad6f8f77496c", "patch": "@@ -0,0 +1,48 @@\n+# Makefile fragment for building LIBGCC for the TI MSP430 processor.\n+# Copyright (C) 2011 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Note - we have separate versions of the lib2div<mode> files\n+# as the functions are quite large and we do not want to pull\n+# in unneeded division routines.\n+\n+LIB2ADD = \\\n+\t$(srcdir)/config/msp430/lib2divQI.c \\\n+\t$(srcdir)/config/msp430/lib2divHI.c \\\n+\t$(srcdir)/config/msp430/lib2divSI.c \\\n+\t$(srcdir)/config/msp430/lib2bitcountHI.c \\\n+\t$(srcdir)/config/msp430/lib2mul.c \\\n+\t$(srcdir)/config/msp430/lib2shift.c \\\n+\t$(srcdir)/config/msp430/epilogue.S \\\n+\t$(srcdir)/config/msp430/mpy.c \\\n+\t$(srcdir)/config/msp430/slli.S \\\n+\t$(srcdir)/config/msp430/srai.S \\\n+\t$(srcdir)/config/msp430/srli.S \\\n+\t$(srcdir)/config/msp430/cmpsi2.S \\\n+\t$(srcdir)/config/msp430/floatunhisf.c \\\n+\t$(srcdir)/config/msp430/floatunhidf.c \\\n+\t$(srcdir)/config/msp430/floathidf.c \\\n+\t$(srcdir)/config/msp430/floathisf.c \\\n+\t$(srcdir)/config/msp430/cmpd.c\n+\n+HOST_LIBGCC2_CFLAGS += -Os -ffunction-sections -fdata-sections\n+\n+# Local Variables:\n+# mode: Makefile\n+# End:"}]}