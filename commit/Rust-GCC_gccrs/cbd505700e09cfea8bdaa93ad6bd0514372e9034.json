{"sha": "cbd505700e09cfea8bdaa93ad6bd0514372e9034", "node_id": "C_kwDOANBUbNoAKGNiZDUwNTcwMGUwOWNmZWE4YmRhYTkzYWQ2YmQwNTE0MzcyZTkwMzQ", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2022-10-17T08:20:43Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-10-21T03:56:21Z"}, "message": "RISC-V: Add RVV intrinsic basic framework.\n\ngcc/ChangeLog:\n\n\t* config.gcc: Add gt files since function_instance is GTY ((user)).\n\t* config/riscv/riscv-builtins.cc (riscv_init_builtins): Add RVV intrinsic framework.\n\t(riscv_builtin_decl): Ditto.\n\t(riscv_expand_builtin): Ditto.\n\t* config/riscv/riscv-protos.h (builtin_decl): New function.\n\t(expand_builtin): Ditto.\n\t(enum riscv_builtin_class): New enum to classify RVV intrinsic and RISC-V general built-in.\n\t* config/riscv/riscv-vector-builtins.cc (class GTY): New declaration.\n\t(struct registered_function_hasher): New struct.\n\t(DEF_RVV_OP_TYPE): New macro.\n\t(DEF_RVV_TYPE): Ditto.\n\t(DEF_RVV_PRED_TYPE): Ditto.\n\t(GTY): New declaration.\n\t(add_attribute): New function.\n\t(check_required_extensions): Ditto.\n\t(rvv_arg_type_info::get_tree_type): Ditto.\n\t(function_instance::function_instance): Ditto.\n\t(function_instance::operator==): Ditto.\n\t(function_instance::any_type_float_p): Ditto.\n\t(function_instance::get_return_type): Ditto.\n\t(function_instance::get_arg_type): Ditto.\n\t(function_instance::hash): Ditto.\n\t(function_instance::call_properties): Ditto.\n\t(function_instance::reads_global_state_p): Ditto.\n\t(function_instance::modifies_global_state_p): Ditto.\n\t(function_instance::could_trap_p): Ditto.\n\t(function_builder::function_builder): Ditto.\n\t(function_builder::~function_builder): Ditto.\n\t(function_builder::allocate_argument_types): Ditto.\n\t(function_builder::register_function_group): Ditto.\n\t(function_builder::append_name): Ditto.\n\t(function_builder::finish_name): Ditto.\n\t(function_builder::get_attributes): Ditto.\n\t(function_builder::add_function): Ditto.\n\t(function_builder::add_unique_function): Ditto.\n\t(function_call_info::function_call_info): Ditto.\n\t(function_expander::function_expander): Ditto.\n\t(function_expander::add_input_operand): Ditto.\n\t(function_expander::generate_insn): Ditto.\n\t(registered_function_hasher::hash): Ditto.\n\t(registered_function_hasher::equal): Ditto.\n\t(builtin_decl): Ditto.\n\t(expand_builtin): Ditto.\n\t(gt_ggc_mx): Define for using GCC garbage collect.\n\t(gt_pch_nx): Define for using GCC garbage collect.\n\t* config/riscv/riscv-vector-builtins.def (DEF_RVV_OP_TYPE): New macro.\n\t(DEF_RVV_PRED_TYPE): Ditto.\n\t(vbool64_t): Add suffix.\n\t(vbool32_t): Ditto.\n\t(vbool16_t): Ditto.\n\t(vbool8_t): Ditto.\n\t(vbool4_t): Ditto.\n\t(vbool2_t): Ditto.\n\t(vbool1_t): Ditto.\n\t(vint8mf8_t): Ditto.\n\t(vuint8mf8_t): Ditto.\n\t(vint8mf4_t): Ditto.\n\t(vuint8mf4_t): Ditto.\n\t(vint8mf2_t): Ditto.\n\t(vuint8mf2_t): Ditto.\n\t(vint8m1_t): Ditto.\n\t(vuint8m1_t): Ditto.\n\t(vint8m2_t): Ditto.\n\t(vuint8m2_t): Ditto.\n\t(vint8m4_t): Ditto.\n\t(vuint8m4_t): Ditto.\n\t(vint8m8_t): Ditto.\n\t(vuint8m8_t): Ditto.\n\t(vint16mf4_t): Ditto.\n\t(vuint16mf4_t): Ditto.\n\t(vint16mf2_t): Ditto.\n\t(vuint16mf2_t): Ditto.\n\t(vint16m1_t): Ditto.\n\t(vuint16m1_t): Ditto.\n\t(vint16m2_t): Ditto.\n\t(vuint16m2_t): Ditto.\n\t(vint16m4_t): Ditto.\n\t(vuint16m4_t): Ditto.\n\t(vint16m8_t): Ditto.\n\t(vuint16m8_t): Ditto.\n\t(vint32mf2_t): Ditto.\n\t(vuint32mf2_t): Ditto.\n\t(vint32m1_t): Ditto.\n\t(vuint32m1_t): Ditto.\n\t(vint32m2_t): Ditto.\n\t(vuint32m2_t): Ditto.\n\t(vint32m4_t): Ditto.\n\t(vuint32m4_t): Ditto.\n\t(vint32m8_t): Ditto.\n\t(vuint32m8_t): Ditto.\n\t(vint64m1_t): Ditto.\n\t(vuint64m1_t): Ditto.\n\t(vint64m2_t): Ditto.\n\t(vuint64m2_t): Ditto.\n\t(vint64m4_t): Ditto.\n\t(vuint64m4_t): Ditto.\n\t(vint64m8_t): Ditto.\n\t(vuint64m8_t): Ditto.\n\t(vfloat32mf2_t): Ditto.\n\t(vfloat32m1_t): Ditto.\n\t(vfloat32m2_t): Ditto.\n\t(vfloat32m4_t): Ditto.\n\t(vfloat32m8_t): Ditto.\n\t(vfloat64m1_t): Ditto.\n\t(vfloat64m2_t): Ditto.\n\t(vfloat64m4_t): Ditto.\n\t(vfloat64m8_t): Ditto.\n\t(vv): Ditto.\n\t(vx): Ditto.\n\t(v): Ditto.\n\t(wv): Ditto.\n\t(wx): Ditto.\n\t(x_x_v): Ditto.\n\t(vf2): Ditto.\n\t(vf4): Ditto.\n\t(vf8): Ditto.\n\t(vvm): Ditto.\n\t(vxm): Ditto.\n\t(x_x_w): Ditto.\n\t(v_v): Ditto.\n\t(v_x): Ditto.\n\t(vs): Ditto.\n\t(mm): Ditto.\n\t(m): Ditto.\n\t(vf): Ditto.\n\t(vm): Ditto.\n\t(wf): Ditto.\n\t(vfm): Ditto.\n\t(v_f): Ditto.\n\t(ta): Ditto.\n\t(tu): Ditto.\n\t(ma): Ditto.\n\t(mu): Ditto.\n\t(tama): Ditto.\n\t(tamu): Ditto.\n\t(tuma): Ditto.\n\t(tumu): Ditto.\n\t(tam): Ditto.\n\t(tum): Ditto.\n\t* config/riscv/riscv-vector-builtins.h (GCC_RISCV_VECTOR_BUILTINS_H): New macro.\n\t(RVV_REQUIRE_RV64BIT): Ditto.\n\t(RVV_REQUIRE_ZVE64): Ditto.\n\t(RVV_REQUIRE_ELEN_FP_32): Ditto.\n\t(RVV_REQUIRE_ELEN_FP_64): Ditto.\n\t(enum operand_type_index): New enum.\n\t(DEF_RVV_OP_TYPE): New macro.\n\t(enum predication_type_index): New enum.\n\t(DEF_RVV_PRED_TYPE): New macro.\n\t(enum rvv_base_type): New enum.\n\t(struct rvv_builtin_suffixes): New struct.\n\t(struct rvv_arg_type_info): Ditto.\n\t(struct rvv_type_info): Ditto.\n\t(struct rvv_op_info): Ditto.\n\t(class registered_function): New class.\n\t(class function_base): Ditto.\n\t(class function_shape): Ditto.\n\t(struct function_group_info): New struct.\n\t(class GTY): New class.\n\t(class function_builder): Ditto.\n\t(class function_call_info): Ditto.\n\t(function_call_info::function_returns_void_p): New function.\n\t(class function_expander): New class.\n\t(function_instance::operator!=): New function.\n\t(function_expander::expand): Ditto.\n\t(function_expander::add_input_operand): Ditto.\n\t(function_base::call_properties): Ditto.", "tree": {"sha": "85f4657d9765edc1139dd395c3d6226a878abba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85f4657d9765edc1139dd395c3d6226a878abba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbd505700e09cfea8bdaa93ad6bd0514372e9034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd505700e09cfea8bdaa93ad6bd0514372e9034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd505700e09cfea8bdaa93ad6bd0514372e9034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd505700e09cfea8bdaa93ad6bd0514372e9034/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e7ec7dbbbef3b4a83da5967b5f25e3be90c2dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7ec7dbbbef3b4a83da5967b5f25e3be90c2dc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7ec7dbbbef3b4a83da5967b5f25e3be90c2dc6"}], "stats": {"total": 1146, "additions": 1065, "deletions": 81}, "files": [{"sha": "acd1a74c5f70996d027369e4a655a7b6aa59e44c", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -520,6 +520,8 @@ riscv*)\n \textra_objs=\"${extra_objs} riscv-vector-builtins.o\"\n \td_target_objs=\"riscv-d.o\"\n \textra_headers=\"riscv_vector.h\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/riscv/riscv-vector-builtins.cc\"\n+\ttarget_gtfiles=\"$target_gtfiles \\$(srcdir)/config/riscv/riscv-vector-builtins.h\"\n \t;;\n rs6000*-*-*)\n \textra_options=\"${extra_options} g.opt fused-madd.opt rs6000/rs6000-tables.opt\""}, {"sha": "9fa4d6cffd8047640b9b7f1a6ac3278dd4e70691", "filename": "gcc/config/riscv/riscv-builtins.cc", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-builtins.cc?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -223,7 +223,10 @@ riscv_init_builtins (void)\n \t{\n \t  tree type = riscv_build_function_type (d->prototype);\n \t  riscv_builtin_decls[i]\n-\t    = add_builtin_function (d->name, type, i, BUILT_IN_MD, NULL, NULL);\n+\t    = add_builtin_function (d->name, type,\n+\t\t\t\t    (i << RISCV_BUILTIN_SHIFT)\n+\t\t\t\t      + RISCV_BUILTIN_GENERAL,\n+\t\t\t\t    BUILT_IN_MD, NULL, NULL);\n \t  riscv_builtin_decl_index[d->icode] = i;\n \t}\n     }\n@@ -234,9 +237,18 @@ riscv_init_builtins (void)\n tree\n riscv_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)\n {\n-  if (code >= ARRAY_SIZE (riscv_builtins))\n-    return error_mark_node;\n-  return riscv_builtin_decls[code];\n+  unsigned int subcode = code >> RISCV_BUILTIN_SHIFT;\n+  switch (code & RISCV_BUILTIN_CLASS)\n+    {\n+    case RISCV_BUILTIN_GENERAL:\n+      if (subcode >= ARRAY_SIZE (riscv_builtins))\n+\treturn error_mark_node;\n+      return riscv_builtin_decls[subcode];\n+\n+    case RISCV_BUILTIN_VECTOR:\n+      return riscv_vector::builtin_decl (subcode, initialize_p);\n+    }\n+  return error_mark_node;\n }\n \n /* Take argument ARGNO from EXP's argument list and convert it into\n@@ -303,15 +315,23 @@ riscv_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_MD_FUNCTION_CODE (fndecl);\n-  const struct riscv_builtin_description *d = &riscv_builtins[fcode];\n-\n-  switch (d->builtin_type)\n+  unsigned int subcode = fcode >> RISCV_BUILTIN_SHIFT;\n+  switch (fcode & RISCV_BUILTIN_CLASS)\n     {\n-    case RISCV_BUILTIN_DIRECT:\n-      return riscv_expand_builtin_direct (d->icode, target, exp, true);\n-\n-    case RISCV_BUILTIN_DIRECT_NO_TARGET:\n-      return riscv_expand_builtin_direct (d->icode, target, exp, false);\n+      case RISCV_BUILTIN_VECTOR:\n+\treturn riscv_vector::expand_builtin (subcode, exp, target);\n+      case RISCV_BUILTIN_GENERAL: {\n+\tconst struct riscv_builtin_description *d = &riscv_builtins[subcode];\n+\n+\tswitch (d->builtin_type)\n+\t  {\n+\t  case RISCV_BUILTIN_DIRECT:\n+\t    return riscv_expand_builtin_direct (d->icode, target, exp, true);\n+\n+\t  case RISCV_BUILTIN_DIRECT_NO_TARGET:\n+\t    return riscv_expand_builtin_direct (d->icode, target, exp, false);\n+\t  }\n+      }\n     }\n \n   gcc_unreachable ();"}, {"sha": "f8c9932ff8967abf5cdb8dc19b031c1980d9a1ed", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -124,6 +124,23 @@ extern const char *mangle_builtin_type (const_tree);\n extern bool verify_type_context (location_t, type_context_kind, const_tree, bool);\n #endif\n extern void handle_pragma_vector (void);\n+extern tree builtin_decl (unsigned, bool);\n+extern rtx expand_builtin (unsigned int, tree, rtx);\n }\n \n+/* We classify builtin types into two classes:\n+   1. General builtin class which is defined in riscv_builtins.\n+   2. Vector builtin class which is a special builtin architecture\n+      that implement intrinsic short into \"pragma\".  */\n+enum riscv_builtin_class\n+{\n+  RISCV_BUILTIN_GENERAL,\n+  RISCV_BUILTIN_VECTOR\n+};\n+\n+const unsigned int RISCV_BUILTIN_SHIFT = 1;\n+\n+/* Mask that selects the riscv_builtin_class part of a function code.  */\n+const unsigned int RISCV_BUILTIN_CLASS = (1 << RISCV_BUILTIN_SHIFT) - 1;\n+\n #endif /* ! GCC_RISCV_PROTOS_H */"}, {"sha": "5c20788b3abe657d913842fcec8528cffbd58b97", "filename": "gcc/config/riscv/riscv-vector-builtins.cc", "status": "modified", "additions": 474, "deletions": 1, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.cc?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -66,13 +66,55 @@ struct vector_type_info\n   const char *mangled_name;\n };\n \n-/* Information about each RVV type.  */\n+/* Describes a function decl.  */\n+class GTY (()) registered_function\n+{\n+public:\n+  function_instance GTY ((skip)) instance;\n+\n+  /* The decl itself.  */\n+  tree GTY ((skip)) decl;\n+};\n+\n+/* Hash traits for registered_function.  */\n+struct registered_function_hasher : nofree_ptr_hash<registered_function>\n+{\n+  typedef function_instance compare_type;\n+\n+  static hashval_t hash (value_type);\n+  static bool equal (value_type, const compare_type &);\n+};\n+\n+/* Static information about each RVV type.  */\n static CONSTEXPR const vector_type_info vector_types[] = {\n #define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, ARGS...)                          \\\n   {#NAME, #ABI_NAME, \"u\" #NCHARS #ABI_NAME},\n #include \"riscv-vector-builtins.def\"\n };\n \n+/* Static information about operand suffix for each RVV type.  */\n+const char *const operand_suffixes[NUM_OP_TYPES] = {\n+  \"\", /* OP_TYPE_none.  */\n+#define DEF_RVV_OP_TYPE(NAME) \"_\" # NAME,\n+#include \"riscv-vector-builtins.def\"\n+};\n+\n+/* Static information about type suffix for each RVV type.  */\n+const rvv_builtin_suffixes type_suffixes[NUM_VECTOR_TYPES + 1] = {\n+#define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n+\t\t     VECTOR_MODE_MIN_VLEN_32, VECTOR_SUFFIX, SCALAR_SUFFIX,    \\\n+\t\t     VSETVL_SUFFIX)                                            \\\n+  {#VECTOR_SUFFIX, #SCALAR_SUFFIX, #VSETVL_SUFFIX},\n+#include \"riscv-vector-builtins.def\"\n+};\n+\n+/* Static information about predication suffix for each RVV type.  */\n+const char *const predication_suffixes[NUM_PRED_TYPES] = {\n+  \"\", /* PRED_TYPE_none.  */\n+#define DEF_RVV_PRED_TYPE(NAME) \"_\" # NAME,\n+#include \"riscv-vector-builtins.def\"\n+};\n+\n /* The RVV types, with their built-in\n    \"__rvv..._t\" name.  Allow an index of NUM_VECTOR_TYPES, which always\n    yields a null tree.  */\n@@ -82,6 +124,14 @@ static GTY (()) tree abi_vector_types[NUM_VECTOR_TYPES + 1];\n extern GTY (()) rvv_builtin_types_t builtin_types[NUM_VECTOR_TYPES + 1];\n rvv_builtin_types_t builtin_types[NUM_VECTOR_TYPES + 1];\n \n+/* The list of all registered function decls, indexed by code.  */\n+static GTY (()) vec<registered_function *, va_gc> *registered_functions;\n+\n+/* All registered function decls, hashed on the function_instance\n+   that they implement.  This is used for looking up implementations of\n+   overloaded functions.  */\n+static hash_table<registered_function_hasher> *function_table;\n+\n /* RAII class for enabling enough RVV features to define the built-in\n    types and implement the riscv_vector.h pragma.\n \n@@ -118,6 +168,13 @@ rvv_switcher::~rvv_switcher ()\n \t  sizeof (have_regs_of_mode));\n }\n \n+/* Add attribute NAME to ATTRS.  */\n+static tree\n+add_attribute (const char *name, tree attrs)\n+{\n+  return tree_cons (get_identifier (name), NULL_TREE, attrs);\n+}\n+\n /* Add type attributes to builtin type tree, currently only the mangled name. */\n static void\n add_vector_type_attribute (tree type, const char *mangled_name)\n@@ -215,6 +272,7 @@ static void\n register_vector_type (vector_type_index type)\n {\n   tree vectype = abi_vector_types[type];\n+\n   /* When vectype is NULL, the corresponding builtin type\n      is disabled according to '-march'.  */\n   if (!vectype)\n@@ -237,6 +295,386 @@ register_vector_type (vector_type_index type)\n   builtin_types[type].vector_ptr = build_pointer_type (vectype);\n }\n \n+/* Check whether all the RVV_REQUIRE_* values in REQUIRED_EXTENSIONS are\n+   enabled.  */\n+static bool\n+check_required_extensions (uint64_t required_extensions)\n+{\n+  uint64_t riscv_isa_flags = 0;\n+\n+  if (TARGET_VECTOR_ELEN_FP_32)\n+    riscv_isa_flags |= RVV_REQUIRE_ELEN_FP_32;\n+  if (TARGET_VECTOR_ELEN_FP_64)\n+    riscv_isa_flags |= RVV_REQUIRE_ELEN_FP_64;\n+  if (TARGET_MIN_VLEN > 32)\n+    riscv_isa_flags |= RVV_REQUIRE_ZVE64;\n+  if (TARGET_64BIT)\n+    riscv_isa_flags |= RVV_REQUIRE_RV64BIT;\n+\n+  uint64_t missing_extensions = required_extensions & ~riscv_isa_flags;\n+  if (missing_extensions != 0)\n+    return false;\n+  return true;\n+}\n+\n+tree\n+rvv_arg_type_info::get_tree_type (vector_type_index type_idx) const\n+{\n+  switch (base_type)\n+    {\n+    case RVV_BASE_vector:\n+      return builtin_types[type_idx].vector;\n+    case RVV_BASE_scalar:\n+      return builtin_types[type_idx].scalar;\n+    case RVV_BASE_vector_ptr:\n+      return builtin_types[type_idx].vector_ptr;\n+    case RVV_BASE_scalar_ptr:\n+      return builtin_types[type_idx].scalar_ptr;\n+    case RVV_BASE_scalar_const_ptr:\n+      return builtin_types[type_idx].scalar_const_ptr;\n+    case RVV_BASE_void:\n+      return void_type_node;\n+    case RVV_BASE_size:\n+      return size_type_node;\n+    case RVV_BASE_ptrdiff:\n+      return ptrdiff_type_node;\n+    case RVV_BASE_unsigned_long:\n+      return long_unsigned_type_node;\n+    case RVV_BASE_long:\n+      return long_integer_type_node;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+function_instance::function_instance (const char *base_name_in,\n+\t\t\t\t      const function_base *base_in,\n+\t\t\t\t      const function_shape *shape_in,\n+\t\t\t\t      rvv_type_info type_in,\n+\t\t\t\t      predication_type_index pred_in,\n+\t\t\t\t      const rvv_op_info *op_info_in)\n+  : base_name (base_name_in), base (base_in), shape (shape_in), type (type_in),\n+    pred (pred_in), op_info (op_info_in)\n+{\n+}\n+\n+bool\n+function_instance::operator== (const function_instance &other) const\n+{\n+  for (unsigned int i = 0; op_info->args[i].base_type != NUM_BASE_TYPES; ++i)\n+    if (op_info->args[i].base_type != other.op_info->args[i].base_type)\n+      return false;\n+  return (base == other.base && shape == other.shape\n+\t  && type.index == other.type.index && op_info->op == other.op_info->op\n+\t  && pred == other.pred\n+\t  && op_info->ret.base_type == other.op_info->ret.base_type);\n+}\n+\n+bool\n+function_instance::any_type_float_p () const\n+{\n+  if (FLOAT_MODE_P (TYPE_MODE (get_return_type ())))\n+    return true;\n+\n+  for (int i = 0; op_info->args[i].base_type != NUM_BASE_TYPES; ++i)\n+    if (FLOAT_MODE_P (TYPE_MODE (get_arg_type (i))))\n+      return true;\n+\n+  return false;\n+}\n+\n+tree\n+function_instance::get_return_type () const\n+{\n+  return op_info->ret.get_tree_type (type.index);\n+}\n+\n+tree\n+function_instance::get_arg_type (unsigned opno) const\n+{\n+  return op_info->args[opno].get_tree_type (type.index);\n+}\n+\n+/* Return a hash code for a function_instance.  */\n+hashval_t\n+function_instance::hash () const\n+{\n+  inchash::hash h;\n+  /* BASE uniquely determines BASE_NAME, so we don't need to hash both.  */\n+  h.add_ptr (base);\n+  h.add_ptr (shape);\n+  h.add_int (type.index);\n+  h.add_int (op_info->op);\n+  h.add_int (pred);\n+  h.add_int (op_info->ret.base_type);\n+  for (unsigned int i = 0; op_info->args[i].base_type != NUM_BASE_TYPES; ++i)\n+    h.add_int (op_info->args[i].base_type);\n+  return h.end ();\n+}\n+\n+/* Return a set of CP_* flags that describe what the function could do,\n+   taking the command-line flags into account.  */\n+unsigned int\n+function_instance::call_properties () const\n+{\n+  unsigned int flags = base->call_properties (*this);\n+\n+  /* -fno-trapping-math means that we can assume any FP exceptions\n+     are not user-visible.  */\n+  if (!flag_trapping_math)\n+    flags &= ~CP_RAISE_FP_EXCEPTIONS;\n+\n+  return flags;\n+}\n+\n+/* Return true if calls to the function could read some form of\n+   global state.  */\n+bool\n+function_instance::reads_global_state_p () const\n+{\n+  unsigned int flags = call_properties ();\n+\n+  /* Preserve any dependence on rounding mode, flush to zero mode, etc.\n+     There is currently no way of turning this off; in particular,\n+     -fno-rounding-math (which is the default) means that we should make\n+     the usual assumptions about rounding mode, which for intrinsics means\n+     acting as the instructions do.  */\n+  if (flags & CP_READ_FPCR)\n+    return true;\n+\n+  /* Handle direct reads of global state.  */\n+  return flags & (CP_READ_MEMORY | CP_READ_CSR);\n+}\n+\n+/* Return true if calls to the function could modify some form of\n+   global state.  */\n+bool\n+function_instance::modifies_global_state_p () const\n+{\n+  unsigned int flags = call_properties ();\n+\n+  /* Preserve any exception state written back to the FPCR,\n+     unless -fno-trapping-math says this is unnecessary.  */\n+  if (flags & CP_RAISE_FP_EXCEPTIONS)\n+    return true;\n+\n+  /* Handle direct modifications of global state.  */\n+  return flags & (CP_WRITE_MEMORY | CP_WRITE_CSR);\n+}\n+\n+/* Return true if calls to the function could raise a signal.  */\n+bool\n+function_instance::could_trap_p () const\n+{\n+  unsigned int flags = call_properties ();\n+\n+  /* Handle functions that could raise SIGFPE.  */\n+  if (flags & CP_RAISE_FP_EXCEPTIONS)\n+    return true;\n+\n+  /* Handle functions that could raise SIGBUS or SIGSEGV.  */\n+  if (flags & (CP_READ_MEMORY | CP_WRITE_MEMORY))\n+    return true;\n+\n+  return false;\n+}\n+\n+function_builder::function_builder ()\n+{\n+  m_direct_overloads = lang_GNU_CXX ();\n+  gcc_obstack_init (&m_string_obstack);\n+}\n+\n+function_builder::~function_builder ()\n+{\n+  obstack_free (&m_string_obstack, NULL);\n+}\n+\n+/* Allocate arguments of the function.  */\n+void\n+function_builder::allocate_argument_types (const function_instance &instance,\n+\t\t\t\t\t   vec<tree> &argument_types) const\n+{\n+  for (unsigned int i = 0;\n+       instance.op_info->args[i].base_type != NUM_BASE_TYPES; ++i)\n+    argument_types.quick_push (\n+      instance.op_info->args[i].get_tree_type (instance.type.index));\n+}\n+\n+/* Register all the functions in GROUP.  */\n+void\n+function_builder::register_function_group (const function_group_info &group)\n+{\n+  (*group.shape)->build (*this, group);\n+}\n+\n+/* Add NAME to the end of the function name being built.  */\n+void\n+function_builder::append_name (const char *name)\n+{\n+  obstack_grow (&m_string_obstack, name, strlen (name));\n+}\n+\n+/* Zero-terminate and complete the function name being built.  */\n+char *\n+function_builder::finish_name ()\n+{\n+  obstack_1grow (&m_string_obstack, 0);\n+  return (char *) obstack_finish (&m_string_obstack);\n+}\n+\n+/* Return the appropriate function attributes for INSTANCE.  */\n+tree\n+function_builder::get_attributes (const function_instance &instance)\n+{\n+  tree attrs = NULL_TREE;\n+\n+  if (!instance.modifies_global_state_p ())\n+    {\n+      if (instance.reads_global_state_p ())\n+\tattrs = add_attribute (\"pure\", attrs);\n+      else\n+\tattrs = add_attribute (\"const\", attrs);\n+    }\n+\n+  if (!flag_non_call_exceptions || !instance.could_trap_p ())\n+    attrs = add_attribute (\"nothrow\", attrs);\n+\n+  return add_attribute (\"leaf\", attrs);\n+}\n+\n+/* Add a function called NAME with type FNTYPE and attributes ATTRS.\n+   INSTANCE describes what the function does.  */\n+registered_function &\n+function_builder::add_function (const function_instance &instance,\n+\t\t\t\tconst char *name, tree fntype, tree attrs,\n+\t\t\t\tbool placeholder_p)\n+{\n+  unsigned int code = vec_safe_length (registered_functions);\n+  code = (code << RISCV_BUILTIN_SHIFT) + RISCV_BUILTIN_VECTOR;\n+\n+  /* We need to be able to generate placeholders to enusre that we have a\n+     consistent numbering scheme for function codes between the C and C++\n+     frontends, so that everything ties up in LTO.\n+\n+     Currently, tree-streamer-in.c:unpack_ts_function_decl_value_fields\n+     validates that tree nodes returned by TARGET_BUILTIN_DECL are non-NULL and\n+     some node other than error_mark_node. This is a holdover from when builtin\n+     decls were streamed by code rather than by value.\n+\n+     Ultimately, we should be able to remove this validation of BUILT_IN_MD\n+     nodes and remove the target hook. For now, however, we need to appease the\n+     validation and return a non-NULL, non-error_mark_node node, so we\n+     arbitrarily choose integer_zero_node.  */\n+  tree decl = placeholder_p\n+\t\t? integer_zero_node\n+\t\t: simulate_builtin_function_decl (input_location, name, fntype,\n+\t\t\t\t\t\t  code, NULL, attrs);\n+\n+  registered_function &rfn = *ggc_alloc<registered_function> ();\n+  rfn.instance = instance;\n+  rfn.decl = decl;\n+  vec_safe_push (registered_functions, &rfn);\n+\n+  return rfn;\n+}\n+\n+/* Add a built-in function for INSTANCE, with the argument types given\n+   by ARGUMENT_TYPES and the return type given by RETURN_TYPE. NAME is\n+   the \"full\" name for C function. OVERLOAD_NAME is the \"short\" name for\n+   C++ overloaded function. OVERLOAD_NAME can be nullptr because some\n+   instance doesn't have C++ overloaded function.  */\n+void\n+function_builder::add_unique_function (const function_instance &instance,\n+\t\t\t\t       const function_shape *shape,\n+\t\t\t\t       tree return_type,\n+\t\t\t\t       vec<tree> &argument_types)\n+{\n+  /* Do not add this function if it is invalid.  */\n+  if (!check_required_extensions (instance.type.required_extensions))\n+    return;\n+\n+  /* Add the function under its full (unique) name.  */\n+  char *name = shape->get_name (*this, instance, false);\n+  tree fntype\n+    = build_function_type_array (return_type, argument_types.length (),\n+\t\t\t\t argument_types.address ());\n+  tree attrs = get_attributes (instance);\n+  registered_function &rfn\n+    = add_function (instance, name, fntype, attrs, false);\n+\n+  /* Enter the function into the hash table.  */\n+  hashval_t hash = instance.hash ();\n+  registered_function **rfn_slot\n+    = function_table->find_slot_with_hash (instance, hash, INSERT);\n+  gcc_assert (!*rfn_slot);\n+  *rfn_slot = &rfn;\n+\n+  /* Also add the function under its overloaded alias, if we want\n+     a separate decl for each instance of an overloaded function.  */\n+  char *overload_name = shape->get_name (*this, instance, true);\n+  if (overload_name)\n+    {\n+      /* Attribute lists shouldn't be shared.  */\n+      tree attrs = get_attributes (instance);\n+      bool placeholder_p = !m_direct_overloads;\n+      add_function (instance, overload_name, fntype, attrs, placeholder_p);\n+    }\n+  obstack_free (&m_string_obstack, name);\n+}\n+\n+function_call_info::function_call_info (location_t location_in,\n+\t\t\t\t\tconst function_instance &instance_in,\n+\t\t\t\t\ttree fndecl_in)\n+  : function_instance (instance_in), location (location_in), fndecl (fndecl_in)\n+{}\n+\n+function_expander::function_expander (const function_instance &instance,\n+\t\t\t\t      tree fndecl_in, tree exp_in,\n+\t\t\t\t      rtx target_in)\n+  : function_call_info (EXPR_LOCATION (exp_in), instance, fndecl_in),\n+    exp (exp_in), target (target_in), opno (0)\n+{\n+  if (!function_returns_void_p ())\n+    create_output_operand (&m_ops[opno++], target, TYPE_MODE (TREE_TYPE (exp)));\n+}\n+\n+/* Take argument ARGNO from EXP's argument list and convert it into\n+   an expand operand.  Store the operand in *M_OPS.  */\n+void\n+function_expander::add_input_operand (unsigned argno)\n+{\n+  tree arg = CALL_EXPR_ARG (exp, argno);\n+  rtx x = expand_normal (arg);\n+  add_input_operand (TYPE_MODE (TREE_TYPE (arg)), x);\n+}\n+\n+/* Generate instruction ICODE, given that its operands have already\n+   been added to M_OPS.  Return the value of the first operand.  */\n+rtx\n+function_expander::generate_insn (insn_code icode)\n+{\n+  gcc_assert (opno == insn_data[icode].n_generator_args);\n+  if (!maybe_expand_insn (icode, opno, m_ops))\n+    {\n+      error (\"invalid argument to built-in function\");\n+      return NULL_RTX;\n+    }\n+  return function_returns_void_p () ? const0_rtx : m_ops[0].value;\n+}\n+\n+inline hashval_t\n+registered_function_hasher::hash (value_type value)\n+{\n+  return value->instance.hash ();\n+}\n+\n+inline bool\n+registered_function_hasher::equal (value_type value, const compare_type &key)\n+{\n+  return value->instance == key;\n+}\n+\n /* If TYPE is a built-in type defined by the RVV ABI, return the mangled name,\n    otherwise return NULL.  */\n const char *\n@@ -356,4 +794,39 @@ handle_pragma_vector ()\n     register_vector_type ((enum vector_type_index) type_i);\n }\n \n+/* Return the function decl with RVV function subcode CODE, or error_mark_node\n+   if no such function exists.  */\n+tree\n+builtin_decl (unsigned int code, bool)\n+{\n+  if (code >= vec_safe_length (registered_functions))\n+    return error_mark_node;\n+\n+  return (*registered_functions)[code]->decl;\n+}\n+\n+/* Expand a call to the RVV function with subcode CODE.  EXP is the call\n+   expression and TARGET is the preferred location for the result.\n+   Return the value of the lhs.  */\n+rtx\n+expand_builtin (unsigned int code, tree exp, rtx target)\n+{\n+  registered_function &rfn = *(*registered_functions)[code];\n+  return function_expander (rfn.instance, rfn.decl, exp, target).expand ();\n+}\n+\n } // end namespace riscv_vector\n+\n+inline void\n+gt_ggc_mx (function_instance *)\n+{}\n+\n+inline void\n+gt_pch_nx (function_instance *)\n+{}\n+\n+inline void\n+gt_pch_nx (function_instance *, gt_pointer_operator, void *)\n+{}\n+\n+#include \"gt-riscv-vector-builtins.h\""}, {"sha": "b7a633ed376ba79b743a85e9771f2450bdad36c2", "filename": "gcc/config/riscv/riscv-vector-builtins.def", "status": "modified", "additions": 177, "deletions": 68, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.def?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -19,181 +19,290 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Use \"DEF_RVV_TYPE\" macro to define RVV datatype builtins.\n-   1.The 1 argument is the name exposed to users.\n+   1.The 'NAME' argument is the name exposed to users.\n      For example, \"vint32m1_t\".\n-   2.The 2 argument is the length of ABI-name.\n+   2.The 'NCHARS' argument is the length of ABI-name.\n      For example, length of \"__rvv_int32m1_t\" is 15.\n-   3.The 3 argument is the ABI-name. For example, \"__rvv_int32m1_t\".\n-   4.The 4 argument is associated scalar type which is used in\n+   3.The 'ABI_NAME' argument is the ABI-name. For example, \"__rvv_int32m1_t\".\n+   4.The 'SCALAR_TYPE' argument is associated scalar type which is used in\n      \"build_vector_type_for_mode\". For \"vint32m1_t\", we use \"intSI_type_node\" in\n      RV64. Otherwise, we use \"long_integer_type_node\".\n-   5.The 5 and 6 argument are the machine modes of corresponding RVV type used\n-     in \"build_vector_type_for_mode\". For \"vint32m1_t\", we use VNx2SImode when\n-     TARGET_MIN_VLEN > 32. Otherwise the machine mode is VNx1SImode.  */\n+   5.The 'VECTOR_MODE' is the machine modes of corresponding RVV type used\n+     in \"build_vector_type_for_mode\" when TARGET_MIN_VLEN > 32.\n+     For example: VECTOR_MODE = VNx2SI for \"vint32m1_t\".\n+   6.The 'VECTOR_MODE_MIN_VLEN_32' is the machine modes of corresponding RVV\n+     type used in \"build_vector_type_for_mode\" when TARGET_MIN_VLEN = 32. For\n+     example: VECTOR_MODE_MIN_VLEN_32 = VNx1SI for \"vint32m1_t\".\n+   7.The 'VECTOR_SUFFIX' define mode suffix for vector type.\n+     For example: type_suffixes[VECTOR_TYPE_vin32m1_t].vector = i32m1.\n+   8.The 'SCALAR_SUFFIX' define mode suffix for scalar type.\n+     For example: type_suffixes[VECTOR_TYPE_vin32m1_t].scalar = i32.\n+   9.The 'VSETVL_SUFFIX' define mode suffix for vsetvli instruction.\n+     For example: type_suffixes[VECTOR_TYPE_vin32m1_t].vsetvl = e32m1.\n+*/\n \n #ifndef DEF_RVV_TYPE\n #define DEF_RVV_TYPE(NAME, NCHARS, ABI_NAME, SCALAR_TYPE, VECTOR_MODE,         \\\n-\t\t     VECTOR_MODE_MIN_VLEN_32)\n+\t\t     VECTOR_MODE_MIN_VLEN_32, VECTOR_SUFFIX, SCALAR_SUFFIX,    \\\n+\t\t     VSETVL_SUFFIX)\n+#endif\n+\n+/* Use \"DEF_RVV_OP_TYPE\" macro to define RVV operand types.\n+   The 'NAME' will be concatenated into intrinsic function name.  */\n+#ifndef DEF_RVV_OP_TYPE\n+#define DEF_RVV_OP_TYPE(NAME)\n+#endif\n+\n+/* Use \"DEF_RVV_PRED_TYPE\" macro to define RVV predication types.\n+   The 'NAME' will be concatenated into intrinsic function name.  */\n+#ifndef DEF_RVV_PRED_TYPE\n+#define DEF_RVV_PRED_TYPE(NAME)\n #endif\n \n /* SEW/LMUL = 64:\n    Only enable when TARGET_MIN_VLEN > 32 and machine mode = VNx1BImode.  */\n-DEF_RVV_TYPE (vbool64_t, 14, __rvv_bool64_t, boolean, VNx1BI, VOID)\n+DEF_RVV_TYPE (vbool64_t, 14, __rvv_bool64_t, boolean, VNx1BI, VOID, _b64, , )\n /* SEW/LMUL = 32:\n    Machine mode = VNx2BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool32_t, 14, __rvv_bool32_t, boolean, VNx2BI, VNx1BI)\n+DEF_RVV_TYPE (vbool32_t, 14, __rvv_bool32_t, boolean, VNx2BI, VNx1BI, _b32, , )\n /* SEW/LMUL = 16:\n    Machine mode = VNx2BImode when TARGET_MIN_VLEN = 32.\n    Machine mode = VNx4BImode when TARGET_MIN_VLEN > 32.  */\n-DEF_RVV_TYPE (vbool16_t, 14, __rvv_bool16_t, boolean, VNx4BI, VNx2BI)\n+DEF_RVV_TYPE (vbool16_t, 14, __rvv_bool16_t, boolean, VNx4BI, VNx2BI, _b16, , )\n /* SEW/LMUL = 8:\n    Machine mode = VNx8BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool8_t, 13, __rvv_bool8_t, boolean, VNx8BI, VNx4BI)\n+DEF_RVV_TYPE (vbool8_t, 13, __rvv_bool8_t, boolean, VNx8BI, VNx4BI, _b8, , )\n /* SEW/LMUL = 4:\n    Machine mode = VNx16BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool4_t, 13, __rvv_bool4_t, boolean, VNx16BI, VNx8BI)\n+DEF_RVV_TYPE (vbool4_t, 13, __rvv_bool4_t, boolean, VNx16BI, VNx8BI, _b4, , )\n /* SEW/LMUL = 2:\n    Machine mode = VNx32BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool2_t, 13, __rvv_bool2_t, boolean, VNx32BI, VNx16BI)\n+DEF_RVV_TYPE (vbool2_t, 13, __rvv_bool2_t, boolean, VNx32BI, VNx16BI, _b2, , )\n /* SEW/LMUL = 1:\n    Machine mode = VNx64BImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx32BImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vbool1_t, 13, __rvv_bool1_t, boolean, VNx64BI, VNx32BI)\n+DEF_RVV_TYPE (vbool1_t, 13, __rvv_bool1_t, boolean, VNx64BI, VNx32BI, _b1, , )\n \n /* LMUL = 1/8:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1QImode.  */\n-DEF_RVV_TYPE (vint8mf8_t, 15, __rvv_int8mf8_t, intQI, VNx1QI, VOID)\n-DEF_RVV_TYPE (vuint8mf8_t, 16, __rvv_uint8mf8_t, unsigned_intQI, VNx1QI, VOID)\n+DEF_RVV_TYPE (vint8mf8_t, 15, __rvv_int8mf8_t, intQI, VNx1QI, VOID, _i8mf8, _i8,\n+\t      _e8mf8)\n+DEF_RVV_TYPE (vuint8mf8_t, 16, __rvv_uint8mf8_t, unsigned_intQI, VNx1QI, VOID,\n+\t      _u8mf8, _u8, _e8mf8)\n /* LMUL = 1/4:\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8mf4_t, 15, __rvv_int8mf4_t, intQI, VNx2QI, VNx1QI)\n-DEF_RVV_TYPE (vuint8mf4_t, 16, __rvv_uint8mf4_t, unsigned_intQI, VNx2QI, VNx1QI)\n+DEF_RVV_TYPE (vint8mf4_t, 15, __rvv_int8mf4_t, intQI, VNx2QI, VNx1QI, _i8mf4,\n+\t      _i8, _e8mf4)\n+DEF_RVV_TYPE (vuint8mf4_t, 16, __rvv_uint8mf4_t, unsigned_intQI, VNx2QI, VNx1QI,\n+\t      _u8mf4, _u8, _e8mf4)\n /* LMUL = 1/2:\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8mf2_t, 15, __rvv_int8mf2_t, intQI, VNx4QI, VNx2QI)\n-DEF_RVV_TYPE (vuint8mf2_t, 16, __rvv_uint8mf2_t, unsigned_intQI, VNx4QI, VNx2QI)\n+DEF_RVV_TYPE (vint8mf2_t, 15, __rvv_int8mf2_t, intQI, VNx4QI, VNx2QI, _i8mf2,\n+\t      _i8, _e8mf2)\n+DEF_RVV_TYPE (vuint8mf2_t, 16, __rvv_uint8mf2_t, unsigned_intQI, VNx4QI, VNx2QI,\n+\t      _u8mf2, _u8, _e8mf2)\n /* LMUL = 1:\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m1_t, 14, __rvv_int8m1_t, intQI, VNx8QI, VNx4QI)\n-DEF_RVV_TYPE (vuint8m1_t, 15, __rvv_uint8m1_t, unsigned_intQI, VNx8QI, VNx4QI)\n+DEF_RVV_TYPE (vint8m1_t, 14, __rvv_int8m1_t, intQI, VNx8QI, VNx4QI, _i8m1, _i8,\n+\t      _e8m1)\n+DEF_RVV_TYPE (vuint8m1_t, 15, __rvv_uint8m1_t, unsigned_intQI, VNx8QI, VNx4QI,\n+\t      _u8m1, _u8, _e8m1)\n /* LMUL = 2:\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m2_t, 14, __rvv_int8m2_t, intQI, VNx16QI, VNx8QI)\n-DEF_RVV_TYPE (vuint8m2_t, 15, __rvv_uint8m2_t, unsigned_intQI, VNx16QI, VNx8QI)\n+DEF_RVV_TYPE (vint8m2_t, 14, __rvv_int8m2_t, intQI, VNx16QI, VNx8QI, _i8m2, _i8,\n+\t      _e8m2)\n+DEF_RVV_TYPE (vuint8m2_t, 15, __rvv_uint8m2_t, unsigned_intQI, VNx16QI, VNx8QI,\n+\t      _u8m2, _u8, _e8m2)\n /* LMUL = 4:\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m4_t, 14, __rvv_int8m4_t, intQI, VNx32QI, VNx16QI)\n-DEF_RVV_TYPE (vuint8m4_t, 15, __rvv_uint8m4_t, unsigned_intQI, VNx32QI, VNx16QI)\n+DEF_RVV_TYPE (vint8m4_t, 14, __rvv_int8m4_t, intQI, VNx32QI, VNx16QI, _i8m4,\n+\t      _i8, _e8m4)\n+DEF_RVV_TYPE (vuint8m4_t, 15, __rvv_uint8m4_t, unsigned_intQI, VNx32QI, VNx16QI,\n+\t      _u8m4, _u8, _e8m4)\n /* LMUL = 8:\n    Machine mode = VNx64QImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx32QImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint8m8_t, 14, __rvv_int8m8_t, intQI, VNx64QI, VNx32QI)\n-DEF_RVV_TYPE (vuint8m8_t, 15, __rvv_uint8m8_t, unsigned_intQI, VNx64QI, VNx32QI)\n+DEF_RVV_TYPE (vint8m8_t, 14, __rvv_int8m8_t, intQI, VNx64QI, VNx32QI, _i8m8,\n+\t      _i8, _e8m8)\n+DEF_RVV_TYPE (vuint8m8_t, 15, __rvv_uint8m8_t, unsigned_intQI, VNx64QI, VNx32QI,\n+\t      _u8m8, _u8, _e8m8)\n \n /* LMUL = 1/4:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1HImode.  */\n-DEF_RVV_TYPE (vint16mf4_t, 16, __rvv_int16mf4_t, intHI, VNx1HI, VOID)\n-DEF_RVV_TYPE (vuint16mf4_t, 17, __rvv_uint16mf4_t, unsigned_intHI, VNx1HI, VOID)\n+DEF_RVV_TYPE (vint16mf4_t, 16, __rvv_int16mf4_t, intHI, VNx1HI, VOID, _i16mf4,\n+\t      _i16, _e16mf4)\n+DEF_RVV_TYPE (vuint16mf4_t, 17, __rvv_uint16mf4_t, unsigned_intHI, VNx1HI, VOID,\n+\t      _u16mf4, _u16, _e16mf4)\n /* LMUL = 1/2:\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16mf2_t, 16, __rvv_int16mf2_t, intHI, VNx2HI, VNx1HI)\n+DEF_RVV_TYPE (vint16mf2_t, 16, __rvv_int16mf2_t, intHI, VNx2HI, VNx1HI, _i16mf2,\n+\t      _i16, _e16mf2)\n DEF_RVV_TYPE (vuint16mf2_t, 17, __rvv_uint16mf2_t, unsigned_intHI, VNx2HI,\n-\t      VNx1HI)\n+\t      VNx1HI, _u16mf2, _u16, _e16mf2)\n /* LMUL = 1:\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m1_t, 15, __rvv_int16m1_t, intHI, VNx4HI, VNx2HI)\n-DEF_RVV_TYPE (vuint16m1_t, 16, __rvv_uint16m1_t, unsigned_intHI, VNx4HI, VNx2HI)\n+DEF_RVV_TYPE (vint16m1_t, 15, __rvv_int16m1_t, intHI, VNx4HI, VNx2HI, _i16m1,\n+\t      _i16, _e16m1)\n+DEF_RVV_TYPE (vuint16m1_t, 16, __rvv_uint16m1_t, unsigned_intHI, VNx4HI, VNx2HI,\n+\t      _u16m1, _u16, _e16m1)\n /* LMUL = 2:\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m2_t, 15, __rvv_int16m2_t, intHI, VNx8HI, VNx4HI)\n-DEF_RVV_TYPE (vuint16m2_t, 16, __rvv_uint16m2_t, unsigned_intHI, VNx8HI, VNx4HI)\n+DEF_RVV_TYPE (vint16m2_t, 15, __rvv_int16m2_t, intHI, VNx8HI, VNx4HI, _i16m2,\n+\t      _i16, _e16m2)\n+DEF_RVV_TYPE (vuint16m2_t, 16, __rvv_uint16m2_t, unsigned_intHI, VNx8HI, VNx4HI,\n+\t      _u16m2, _u16, _e16m2)\n /* LMUL = 4:\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m4_t, 15, __rvv_int16m4_t, intHI, VNx16HI, VNx8HI)\n+DEF_RVV_TYPE (vint16m4_t, 15, __rvv_int16m4_t, intHI, VNx16HI, VNx8HI, _i16m4,\n+\t      _i16, _e16m4)\n DEF_RVV_TYPE (vuint16m4_t, 16, __rvv_uint16m4_t, unsigned_intHI, VNx16HI,\n-\t      VNx8HI)\n+\t      VNx8HI, _u16m4, _u16, _e16m4)\n /* LMUL = 8:\n    Machine mode = VNx32HImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx16HImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint16m8_t, 15, __rvv_int16m8_t, intHI, VNx32HI, VNx16HI)\n+DEF_RVV_TYPE (vint16m8_t, 15, __rvv_int16m8_t, intHI, VNx32HI, VNx16HI, _i16m8,\n+\t      _i16, _e16m8)\n DEF_RVV_TYPE (vuint16m8_t, 16, __rvv_uint16m8_t, unsigned_intHI, VNx32HI,\n-\t      VNx16HI)\n+\t      VNx16HI, _u16m8, _u16, _e16m8)\n \n /* LMUL = 1/2:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1SImode.  */\n-DEF_RVV_TYPE (vint32mf2_t, 16, __rvv_int32mf2_t, int32, VNx1SI, VOID)\n-DEF_RVV_TYPE (vuint32mf2_t, 17, __rvv_uint32mf2_t, unsigned_int32, VNx1SI, VOID)\n+DEF_RVV_TYPE (vint32mf2_t, 16, __rvv_int32mf2_t, int32, VNx1SI, VOID, _i32mf2,\n+\t      _i32, _e32mf2)\n+DEF_RVV_TYPE (vuint32mf2_t, 17, __rvv_uint32mf2_t, unsigned_int32, VNx1SI, VOID,\n+\t      _u32mf2, _u32, _e32mf2)\n /* LMUL = 1:\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1SImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint32m1_t, 15, __rvv_int32m1_t, int32, VNx2SI, VNx1SI)\n-DEF_RVV_TYPE (vuint32m1_t, 16, __rvv_uint32m1_t, unsigned_int32, VNx2SI, VNx1SI)\n+DEF_RVV_TYPE (vint32m1_t, 15, __rvv_int32m1_t, int32, VNx2SI, VNx1SI, _i32m1,\n+\t      _i32, _e32m1)\n+DEF_RVV_TYPE (vuint32m1_t, 16, __rvv_uint32m1_t, unsigned_int32, VNx2SI, VNx1SI,\n+\t      _u32m1, _u32, _e32m1)\n /* LMUL = 2:\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2SImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint32m2_t, 15, __rvv_int32m2_t, int32, VNx4SI, VNx2SI)\n-DEF_RVV_TYPE (vuint32m2_t, 16, __rvv_uint32m2_t, unsigned_int32, VNx4SI, VNx2SI)\n+DEF_RVV_TYPE (vint32m2_t, 15, __rvv_int32m2_t, int32, VNx4SI, VNx2SI, _i32m2,\n+\t      _i32, _e32m2)\n+DEF_RVV_TYPE (vuint32m2_t, 16, __rvv_uint32m2_t, unsigned_int32, VNx4SI, VNx2SI,\n+\t      _u32m2, _u32, _e32m2)\n /* LMUL = 4:\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4SImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint32m4_t, 15, __rvv_int32m4_t, int32, VNx8SI, VNx4SI)\n-DEF_RVV_TYPE (vuint32m4_t, 16, __rvv_uint32m4_t, unsigned_int32, VNx8SI, VNx4SI)\n+DEF_RVV_TYPE (vint32m4_t, 15, __rvv_int32m4_t, int32, VNx8SI, VNx4SI, _i32m4,\n+\t      _i32, _e32m4)\n+DEF_RVV_TYPE (vuint32m4_t, 16, __rvv_uint32m4_t, unsigned_int32, VNx8SI, VNx4SI,\n+\t      _u32m4, _u32, _e32m4)\n /* LMUL = 8:\n    Machine mode = VNx16SImode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8SImode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vint32m8_t, 15, __rvv_int32m8_t, int32, VNx16SI, VNx8SI)\n+DEF_RVV_TYPE (vint32m8_t, 15, __rvv_int32m8_t, int32, VNx16SI, VNx8SI, _i32m8,\n+\t      _i32, _e32m8)\n DEF_RVV_TYPE (vuint32m8_t, 16, __rvv_uint32m8_t, unsigned_int32, VNx16SI,\n-\t      VNx8SI)\n+\t      VNx8SI, _u32m8, _u32, _e32m8)\n \n /* SEW = 64:\n    Disable when TARGET_MIN_VLEN > 32.  */\n-DEF_RVV_TYPE (vint64m1_t, 15, __rvv_int64m1_t, intDI, VNx1DI, VOID)\n-DEF_RVV_TYPE (vuint64m1_t, 16, __rvv_uint64m1_t, unsigned_intDI, VNx1DI, VOID)\n-DEF_RVV_TYPE (vint64m2_t, 15, __rvv_int64m2_t, intDI, VNx2DI, VOID)\n-DEF_RVV_TYPE (vuint64m2_t, 16, __rvv_uint64m2_t, unsigned_intDI, VNx2DI, VOID)\n-DEF_RVV_TYPE (vint64m4_t, 15, __rvv_int64m4_t, intDI, VNx4DI, VOID)\n-DEF_RVV_TYPE (vuint64m4_t, 16, __rvv_uint64m4_t, unsigned_intDI, VNx4DI, VOID)\n-DEF_RVV_TYPE (vint64m8_t, 15, __rvv_int64m8_t, intDI, VNx8DI, VOID)\n-DEF_RVV_TYPE (vuint64m8_t, 16, __rvv_uint64m8_t, unsigned_intDI, VNx8DI, VOID)\n+DEF_RVV_TYPE (vint64m1_t, 15, __rvv_int64m1_t, intDI, VNx1DI, VOID, _i64m1,\n+\t      _i64, _e64m1)\n+DEF_RVV_TYPE (vuint64m1_t, 16, __rvv_uint64m1_t, unsigned_intDI, VNx1DI, VOID,\n+\t      _u64m1, _u64, _e64m1)\n+DEF_RVV_TYPE (vint64m2_t, 15, __rvv_int64m2_t, intDI, VNx2DI, VOID, _i64m2,\n+\t      _i64, _e64m2)\n+DEF_RVV_TYPE (vuint64m2_t, 16, __rvv_uint64m2_t, unsigned_intDI, VNx2DI, VOID,\n+\t      _u64m2, _u64, _e64m2)\n+DEF_RVV_TYPE (vint64m4_t, 15, __rvv_int64m4_t, intDI, VNx4DI, VOID, _i64m4,\n+\t      _i64, _e64m4)\n+DEF_RVV_TYPE (vuint64m4_t, 16, __rvv_uint64m4_t, unsigned_intDI, VNx4DI, VOID,\n+\t      _u64m4, _u64, _e64m4)\n+DEF_RVV_TYPE (vint64m8_t, 15, __rvv_int64m8_t, intDI, VNx8DI, VOID, _i64m8,\n+\t      _i64, _e64m8)\n+DEF_RVV_TYPE (vuint64m8_t, 16, __rvv_uint64m8_t, unsigned_intDI, VNx8DI, VOID,\n+\t      _u64m8, _u64, _e64m8)\n \n /* LMUL = 1/2:\n    Only enble when TARGET_MIN_VLEN > 32 and machine mode = VNx1SFmode.  */\n-DEF_RVV_TYPE (vfloat32mf2_t, 18, __rvv_float32mf2_t, float, VNx1SF, VOID)\n+DEF_RVV_TYPE (vfloat32mf2_t, 18, __rvv_float32mf2_t, float, VNx1SF, VOID,\n+\t      _f32mf2, _f32, _e32mf2)\n /* LMUL = 1:\n    Machine mode = VNx2SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx1SFmode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vfloat32m1_t, 17, __rvv_float32m1_t, float, VNx2SF, VNx1SF)\n+DEF_RVV_TYPE (vfloat32m1_t, 17, __rvv_float32m1_t, float, VNx2SF, VNx1SF,\n+\t      _f32m1, _f32, _e32m1)\n /* LMUL = 2:\n    Machine mode = VNx4SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx2SFmode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vfloat32m2_t, 17, __rvv_float32m2_t, float, VNx4SF, VNx2SF)\n+DEF_RVV_TYPE (vfloat32m2_t, 17, __rvv_float32m2_t, float, VNx4SF, VNx2SF,\n+\t      _f32m2, _f32, _e32m2)\n /* LMUL = 4:\n    Machine mode = VNx8SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx4SFmode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vfloat32m4_t, 17, __rvv_float32m4_t, float, VNx8SF, VNx4SF)\n+DEF_RVV_TYPE (vfloat32m4_t, 17, __rvv_float32m4_t, float, VNx8SF, VNx4SF,\n+\t      _f32m4, _f32, _e32m4)\n /* LMUL = 8:\n    Machine mode = VNx16SFmode when TARGET_MIN_VLEN > 32.\n    Machine mode = VNx8SFmode when TARGET_MIN_VLEN = 32.  */\n-DEF_RVV_TYPE (vfloat32m8_t, 17, __rvv_float32m8_t, float, VNx16SF, VNx8SF)\n+DEF_RVV_TYPE (vfloat32m8_t, 17, __rvv_float32m8_t, float, VNx16SF, VNx8SF,\n+\t      _f32m8, _f32, _e32m8)\n \n /* SEW = 64:\n    Disable when TARGET_VECTOR_FP64.  */\n-DEF_RVV_TYPE (vfloat64m1_t, 17, __rvv_float64m1_t, double, VNx1DF, VOID)\n-DEF_RVV_TYPE (vfloat64m2_t, 17, __rvv_float64m2_t, double, VNx2DF, VOID)\n-DEF_RVV_TYPE (vfloat64m4_t, 17, __rvv_float64m4_t, double, VNx4DF, VOID)\n-DEF_RVV_TYPE (vfloat64m8_t, 17, __rvv_float64m8_t, double, VNx8DF, VOID)\n+DEF_RVV_TYPE (vfloat64m1_t, 17, __rvv_float64m1_t, double, VNx1DF, VOID, _f64m1,\n+\t      _f64, _e64m1)\n+DEF_RVV_TYPE (vfloat64m2_t, 17, __rvv_float64m2_t, double, VNx2DF, VOID, _f64m2,\n+\t      _f64, _e64m2)\n+DEF_RVV_TYPE (vfloat64m4_t, 17, __rvv_float64m4_t, double, VNx4DF, VOID, _f64m4,\n+\t      _f64, _e64m4)\n+DEF_RVV_TYPE (vfloat64m8_t, 17, __rvv_float64m8_t, double, VNx8DF, VOID, _f64m8,\n+\t      _f64, _e64m8)\n+\n+DEF_RVV_OP_TYPE (vv)\n+DEF_RVV_OP_TYPE (vx)\n+DEF_RVV_OP_TYPE (v)\n+DEF_RVV_OP_TYPE (wv)\n+DEF_RVV_OP_TYPE (wx)\n+DEF_RVV_OP_TYPE (x_x_v)\n+DEF_RVV_OP_TYPE (vf2)\n+DEF_RVV_OP_TYPE (vf4)\n+DEF_RVV_OP_TYPE (vf8)\n+DEF_RVV_OP_TYPE (vvm)\n+DEF_RVV_OP_TYPE (vxm)\n+DEF_RVV_OP_TYPE (x_x_w)\n+DEF_RVV_OP_TYPE (v_v)\n+DEF_RVV_OP_TYPE (v_x)\n+DEF_RVV_OP_TYPE (vs)\n+DEF_RVV_OP_TYPE (mm)\n+DEF_RVV_OP_TYPE (m)\n+DEF_RVV_OP_TYPE (vf)\n+DEF_RVV_OP_TYPE (vm)\n+DEF_RVV_OP_TYPE (wf)\n+DEF_RVV_OP_TYPE (vfm)\n+DEF_RVV_OP_TYPE (v_f)\n+\n+DEF_RVV_PRED_TYPE (ta)\n+DEF_RVV_PRED_TYPE (tu)\n+DEF_RVV_PRED_TYPE (ma)\n+DEF_RVV_PRED_TYPE (mu)\n+DEF_RVV_PRED_TYPE (tama)\n+DEF_RVV_PRED_TYPE (tamu)\n+DEF_RVV_PRED_TYPE (tuma)\n+DEF_RVV_PRED_TYPE (tumu)\n+DEF_RVV_PRED_TYPE (m)\n+DEF_RVV_PRED_TYPE (tam)\n+DEF_RVV_PRED_TYPE (tum)\n \n+#undef DEF_RVV_PRED_TYPE\n+#undef DEF_RVV_OP_TYPE\n #undef DEF_RVV_TYPE"}, {"sha": "425da12326c8e6883147ddffafbf903850d4eb29", "filename": "gcc/config/riscv/riscv-vector-builtins.h", "status": "modified", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd505700e09cfea8bdaa93ad6bd0514372e9034/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins.h?ref=cbd505700e09cfea8bdaa93ad6bd0514372e9034", "patch": "@@ -21,8 +21,101 @@\n #ifndef GCC_RISCV_VECTOR_BUILTINS_H\n #define GCC_RISCV_VECTOR_BUILTINS_H\n \n+/* The full name of an RVV intrinsic function is the concatenation of:\n+\n+   - the base name (\"vadd\", etc.)\n+   - the operand suffix (\"_vv\", \"_vx\", etc.)\n+   - the type suffix (\"_i32m1\", \"_i32mf2\", etc.)\n+   - the predication suffix (\"_tamu\", \"_tumu\", etc.)\n+\n+   Each piece of information is individually useful, so we retain this\n+   classification throughout:\n+\n+   - function_base represents the base name.\n+\n+   - operand_type_index can be used as an index to get operand suffix.\n+\n+   - rvv_op_info can be used as an index to get argument suffix.\n+\n+   - predication_type_index can be used as an index to get predication suffix.\n+\n+   In addition to its unique full name, a function may have a shorter\n+   overloaded alias.  This alias removes pieces of the suffixes that\n+   can be inferred from the arguments, such as by shortening the mode\n+   suffix or dropping some of the type suffixes.  The base name and the\n+   predication suffix stay the same.\n+\n+   - The function_instance class describes contains all properties of each\n+     individual function. Such these information will be used by\n+     function_builder, function_base, function_shape, gimple_folder,\n+     function_expander, etc.\n+\n+   - The function_builder class provides several helper function to add an\n+     intrinsic function.\n+\n+   - The function_shape class describes how that instruction has been presented\n+     at the language level:\n+\n+      1. Determine the function name for C and C++ overload function which can\n+\t be recognized by compiler at language level for each instruction\n+\t according to members of function_instance (base name, operand suffix,\n+\t type suffix, predication suffix, etc.).\n+\n+      2. Specify the arguments type and return type of each function to\n+\t describe how that instruction has presented at language level.\n+\n+   - The function_base describes how the underlying instruction behaves.\n+\n+   The static list of functions uses function_group to describe a group\n+   of related functions.  The function_builder class is responsible for\n+   expanding this static description into a list of individual functions\n+   and registering the associated built-in functions.  function_instance\n+   describes one of these individual functions in terms of the properties\n+   described above.\n+\n+   The classes involved in compiling a function call are:\n+\n+   - function_resolver, which resolves an overloaded function call to a\n+     specific function_instance and its associated function decl.\n+\n+   - function_checker, which checks whether the values of the arguments\n+     conform to the RVV ISA specification.\n+\n+   - gimple_folder, which tries to fold a function call at the gimple level\n+\n+   - function_expander, which expands a function call into rtl instructions\n+\n+   function_resolver and function_checker operate at the language level\n+   and so are associated with the function_shape.  gimple_folder and\n+   function_expander are concerned with the behavior of the function\n+   and so are associated with the function_base.  */\n+\n namespace riscv_vector {\n \n+/* Flags that describe what a function might do, in addition to reading\n+   its arguments and returning a result.  */\n+static const unsigned int CP_READ_FPCR = 1U << 0;\n+static const unsigned int CP_RAISE_FP_EXCEPTIONS = 1U << 1;\n+static const unsigned int CP_READ_MEMORY = 1U << 2;\n+static const unsigned int CP_WRITE_MEMORY = 1U << 3;\n+static const unsigned int CP_READ_CSR = 1U << 4;\n+static const unsigned int CP_WRITE_CSR = 1U << 5;\n+\n+/* Bit values used to identify required extensions for RVV intrinsics.  */\n+#define RVV_REQUIRE_RV64BIT (1 << 0)\t/* Require RV64.  */\n+#define RVV_REQUIRE_ZVE64 (1 << 1)\t/* Require TARGET_MIN_VLEN > 32.  */\n+#define RVV_REQUIRE_ELEN_FP_32 (1 << 2) /* Require FP ELEN >= 32.  */\n+#define RVV_REQUIRE_ELEN_FP_64 (1 << 3) /* Require FP ELEN >= 64.  */\n+\n+/* Enumerates the RVV operand types.  */\n+enum operand_type_index\n+{\n+  OP_TYPE_none,\n+#define DEF_RVV_OP_TYPE(NAME) OP_TYPE_##NAME,\n+#include \"riscv-vector-builtins.def\"\n+  NUM_OP_TYPES\n+};\n+\n /* Enumerates the RVV types, together called\n    \"vector types\" for brevity.  */\n enum vector_type_index\n@@ -32,6 +125,31 @@ enum vector_type_index\n   NUM_VECTOR_TYPES\n };\n \n+/* Enumerates the RVV governing predication types.  */\n+enum predication_type_index\n+{\n+  PRED_TYPE_none,\n+#define DEF_RVV_PRED_TYPE(NAME) PRED_TYPE_##NAME,\n+#include \"riscv-vector-builtins.def\"\n+  NUM_PRED_TYPES\n+};\n+\n+/* Enumerates the RVV base types.  */\n+enum rvv_base_type\n+{\n+  RVV_BASE_vector,\n+  RVV_BASE_scalar,\n+  RVV_BASE_vector_ptr,\n+  RVV_BASE_scalar_ptr,\n+  RVV_BASE_scalar_const_ptr,\n+  RVV_BASE_void,\n+  RVV_BASE_size,\n+  RVV_BASE_ptrdiff,\n+  RVV_BASE_unsigned_long,\n+  RVV_BASE_long,\n+  NUM_BASE_TYPES\n+};\n+\n /* Builtin types that are used to register RVV intrinsics.  */\n struct GTY (()) rvv_builtin_types_t\n {\n@@ -42,6 +160,251 @@ struct GTY (()) rvv_builtin_types_t\n   tree scalar_const_ptr;\n };\n \n+/* Builtin suffix that are used to register RVV intrinsics.  */\n+struct rvv_builtin_suffixes\n+{\n+  const char *vector;\n+  const char *scalar;\n+  const char *vsetvl;\n+};\n+\n+/* RVV Builtin argument information.  */\n+struct rvv_arg_type_info\n+{\n+  CONSTEXPR rvv_arg_type_info (rvv_base_type base_type_in)\n+    : base_type (base_type_in)\n+  {}\n+  enum rvv_base_type base_type;\n+\n+  tree get_tree_type (vector_type_index) const;\n+};\n+\n+/* Static information for each operand.  */\n+struct rvv_type_info\n+{\n+  enum vector_type_index index;\n+  uint64_t required_extensions;\n+};\n+\n+/* RVV Builtin operands information.  */\n+struct rvv_op_info\n+{\n+  const rvv_type_info *types;\n+  const operand_type_index op;\n+  rvv_arg_type_info ret;\n+  const rvv_arg_type_info *args;\n+};\n+\n+class registered_function;\n+class function_base;\n+class function_shape;\n+\n+/* Static information about a set of functions.  */\n+struct function_group_info\n+{\n+  /* The base name, as a string.  */\n+  const char *base_name;\n+\n+  /* Describes the behavior associated with the function base name.  */\n+  const function_base *const *base;\n+\n+  /* The shape of the functions, as described above the class definition.\n+     It's possible to have entries with the same base name but different\n+     shapes.  */\n+  const function_shape *const *shape;\n+\n+  /* A list of the available operand types, predication types,\n+     and of the available operand datatype.\n+     The function supports every combination of the two.\n+     The list of predication is terminated by two NUM_PRED_TYPES,\n+     while the list of operand info is terminated by NUM_BASE_TYPES.\n+     The list of these type suffix is lexicographically ordered based\n+     on the index value.  */\n+  const predication_type_index *preds;\n+  const rvv_op_info ops_infos;\n+};\n+\n+class GTY ((user)) function_instance\n+{\n+public:\n+  function_instance (const char *, const function_base *,\n+\t\t     const function_shape *, rvv_type_info,\n+\t\t     predication_type_index, const rvv_op_info *);\n+\n+  bool operator== (const function_instance &) const;\n+  bool operator!= (const function_instance &) const;\n+  hashval_t hash () const;\n+\n+  unsigned int call_properties () const;\n+  bool reads_global_state_p () const;\n+  bool modifies_global_state_p () const;\n+  bool could_trap_p () const;\n+\n+  /* Return true if return type or arguments are floating point type.  */\n+  bool any_type_float_p () const;\n+\n+  tree get_return_type () const;\n+  tree get_arg_type (unsigned opno) const;\n+\n+  /* The properties of the function.  (The explicit \"enum\"s are required\n+     for gengtype.)  */\n+  const char *base_name;\n+  const function_base *base;\n+  const function_shape *shape;\n+  rvv_type_info type;\n+  enum predication_type_index pred;\n+  const rvv_op_info *op_info;\n+};\n+\n+/* A class for building and registering function decls.  */\n+class function_builder\n+{\n+public:\n+  function_builder ();\n+  ~function_builder ();\n+\n+  void allocate_argument_types (const function_instance &, vec<tree> &) const;\n+  void add_unique_function (const function_instance &, const function_shape *,\n+\t\t\t    tree, vec<tree> &);\n+  void register_function_group (const function_group_info &);\n+  void append_name (const char *);\n+  char *finish_name ();\n+\n+private:\n+  tree get_attributes (const function_instance &);\n+\n+  registered_function &add_function (const function_instance &, const char *,\n+\t\t\t\t     tree, tree, bool);\n+\n+  /* True if we should create a separate decl for each instance of an\n+     overloaded function, instead of using function_builder.  */\n+  bool m_direct_overloads;\n+\n+  /* Used for building up function names.  */\n+  obstack m_string_obstack;\n+};\n+\n+/* A base class for handling calls to built-in functions.  */\n+class function_call_info : public function_instance\n+{\n+public:\n+  function_call_info (location_t, const function_instance &, tree);\n+\n+  bool function_returns_void_p ();\n+\n+  /* The location of the call.  */\n+  location_t location;\n+\n+  /* The FUNCTION_DECL that is being called.  */\n+  tree fndecl;\n+};\n+\n+/* Return true if the function has no return value.  */\n+inline bool\n+function_call_info::function_returns_void_p ()\n+{\n+  return TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node;\n+}\n+\n+/* A class for expanding a function call into RTL.  */\n+class function_expander : public function_call_info\n+{\n+public:\n+  function_expander (const function_instance &, tree, tree, rtx);\n+  rtx expand ();\n+\n+  void add_input_operand (machine_mode, rtx);\n+  void add_input_operand (unsigned argno);\n+  rtx generate_insn (insn_code);\n+\n+  /* The function call expression.  */\n+  tree exp;\n+\n+  /* For functions that return a value, this is the preferred location\n+     of that value.  It could be null or could have a different mode\n+     from the function return type.  */\n+  rtx target;\n+\n+  /* The number of the operands.  */\n+  int opno;\n+\n+private:\n+  /* Used to build up the operands to an instruction.  */\n+  struct expand_operand m_ops[MAX_RECOG_OPERANDS];\n+};\n+\n+/* Provides information about a particular function base name, and handles\n+   tasks related to the base name.  */\n+class function_base\n+{\n+public:\n+  /* Return a set of CP_* flags that describe what the function might do,\n+     in addition to reading its arguments and returning a result.  */\n+  virtual unsigned int call_properties (const function_instance &) const;\n+\n+  /* Expand the given call into rtl.  Return the result of the function,\n+     or an arbitrary value if the function doesn't return a result.  */\n+  virtual rtx expand (function_expander &) const = 0;\n+};\n+\n+/* Classifies functions into \"shapes\" base on:\n+\n+   - Base name of the intrinsic function.\n+\n+   - Operand types list.\n+\n+   - Argument type list.\n+\n+   - Predication type list.  */\n+class function_shape\n+{\n+public:\n+  /* Shape the function name according to function_instance.  */\n+  virtual char *get_name (function_builder &, const function_instance &,\n+\t\t\t  bool) const\n+    = 0;\n+\n+  /* Define all functions associated with the given group.  */\n+  virtual void build (function_builder &, const function_group_info &) const\n+    = 0;\n+};\n+\n+extern const char *const operand_suffixes[NUM_OP_TYPES];\n+extern const rvv_builtin_suffixes type_suffixes[NUM_VECTOR_TYPES + 1];\n+extern const char *const predication_suffixes[NUM_PRED_TYPES];\n+extern rvv_builtin_types_t builtin_types[NUM_VECTOR_TYPES + 1];\n+\n+inline bool\n+function_instance::operator!= (const function_instance &other) const\n+{\n+  return !operator== (other);\n+}\n+\n+/* Expand the call and return its lhs.  */\n+inline rtx\n+function_expander::expand ()\n+{\n+  return base->expand (*this);\n+}\n+\n+/* Create op and add it into M_OPS and increase OPNO.  */\n+inline void\n+function_expander::add_input_operand (machine_mode mode, rtx op)\n+{\n+  create_input_operand (&m_ops[opno++], op, mode);\n+}\n+\n+/* Default implementation of function_base::call_properties, with conservatively\n+   correct behavior for floating-point instructions.  */\n+inline unsigned int\n+function_base::call_properties (const function_instance &instance) const\n+{\n+  unsigned int flags = 0;\n+  if (instance.any_type_float_p ())\n+    return flags | CP_READ_FPCR | CP_RAISE_FP_EXCEPTIONS;\n+  return flags;\n+}\n+\n } // end namespace riscv_vector\n \n #endif"}]}