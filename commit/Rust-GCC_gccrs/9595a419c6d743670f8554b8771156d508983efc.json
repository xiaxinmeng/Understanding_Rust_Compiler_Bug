{"sha": "9595a419c6d743670f8554b8771156d508983efc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU5NWE0MTljNmQ3NDM2NzBmODU1NGI4NzcxMTU2ZDUwODk4M2VmYw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-11-03T16:25:29Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-11-03T16:25:29Z"}, "message": "predicates.md (rx_store_multiple_vector): Reverse order of expected registers.\n\n        * config/rx/predicates.md (rx_store_multiple_vector): Reverse\n        order of expected registers.\n        (rx_load_multiple_vector): Likewise.\n        (rx_rtsd_vector): Likewise.\n        * config/rx/rx.c (rx_cpu_type): New variable.\n        (rx_print_operand): Fix bug printing 64-bit constant values.\n        (rx_emit_stack_pushm): Reverse order of pushed registers.\n        (gen_rx_store_vector): Likewise.\n        (is_fast_interrupt_func): Only accept \"fast_interrupt\" as the\n        attribute name.\n        (is_exception_func): Rename to is_interrupt_func and only accept\n        \"interrupt\" as the attribute name.\n        (rx_get_stack_layout): Use new function name.\n        (rx_func_attr_inlinable): Likewise.\n        (rx_attribute_table): Remove \"exception\".\n        (rx_expand_prologue): If necessary push the accumulator register\n        in the prologue of interrupt functions.\n        (rx_expand_epilogue): If necessary pop the accumulator.\n        (rx_builtins): Add RX_BUILTIN_MVTIPL.\n        (rx_expand_builtin_stz): Remove.\n        (rx_expand_builtin_mvtipl): New function.\n        (rx_init_builtins): Handle RX_BUILTIN_MVTIPL.\n        (rx_expand_builtin): Likewise.\n        (rx_enable_fpu): New variable.\n        (rx_handle_option): Handle -fpu, -nofpu, -mcpu and -patch.\n        * config/rx/rx.h (TARGET_CPU_CPP_BUILTINS): Assert machine based\n        on rx_cpu_type.  Define __RX_FPU_INSNS__ if FPU insns are allowed.\n        (enum rx_cpu_types): Define.\n        (ASM_SPEC): Pass -m32bit-doubles on to assembler.\n        (INCOMING_FRAME_SP_OFFSET): Define.\n        (ARG_POINTER_CFA_OFFSET): Define.\n        (FRAME_POINTER_CFA_OFFSET): Define.\n        (OVERRIDE_OPTIONS): Enable fast math if RX FPU insns are enabled.\n        (ALLOW_RX_FPU_INSNS): Define.\n        * config/rx/rx.md: Test ALLOW_RX_FPU_INSNS instead of\n        fast_math_flags_set_p.\n        (UNSPEC_BUILTIN_MVTIPL): Define.\n        (revl): Rename to bswapsi2.\n        (bswaphi2): New pattern.\n        (mvtachi): Mark as volatile because it uses a register unknown to\n        GCC.\n        (mvtaclo): Likewise.\n        (racw): Likewise.\n        (mvtc): Remove clobber of cc0.\n        (mvtcp): Delete.\n        (opecp): Delete.\n        * config/rx/rx.opt (mieee): Remove.\n        (fpu): Add.\n        (nofpu): Add.\n        (mcpu=): Add.\n        (patch=): Add.\n        (msave-acc-in-interrupts): Add.\n        * config/rx/t-rx (MULTILIB_OPTIONS): Change default to 64bit\n        doubles.\n        (MULTILIB_DIRS): Likewise.\n        (MULTILIB_MATCHES): Treat -fpu as an alias for -m32bit-doubles.\n        * doc/extend.texi: Remove description of \"exception\" function\n        attribute.\n        * doc/invoke.texi: Document -fpu, -nofpu, -mcpu=, -patch= and\n        -msave-acc-in-interrupts options.\n\n        * gcc.target/rx/builtins,c: Remove redundant tests.\n        Add test of MVTIPL instruction.\n        * gcc.target/rx/interrupts.c: Use fast_interrupt and interrupt\n        function attributes.  Add -msave-acc-in-interrupts option to the\n        command line.\n\nCo-Authored-By: Kevin Buettner <kevinb@redhat.com>\n\nFrom-SVN: r153853", "tree": {"sha": "e2ed6b0428b652d000e627bca0a843d199164895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2ed6b0428b652d000e627bca0a843d199164895"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9595a419c6d743670f8554b8771156d508983efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9595a419c6d743670f8554b8771156d508983efc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9595a419c6d743670f8554b8771156d508983efc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9595a419c6d743670f8554b8771156d508983efc/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48d3ee1d0aff2ecf2545189d878ea55aa8f78002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d3ee1d0aff2ecf2545189d878ea55aa8f78002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d3ee1d0aff2ecf2545189d878ea55aa8f78002"}], "stats": {"total": 612, "additions": 459, "deletions": 153}, "files": [{"sha": "0708ec7fb2250c950ffb7f2d8c3b994d7f13cf1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -1,3 +1,67 @@\n+2009-11-03  Nick Clifton  <nickc@redhat.com>\n+\t    Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* config/rx/predicates.md (rx_store_multiple_vector): Reverse\n+\torder of expected registers.\n+\t(rx_load_multiple_vector): Likewise.\n+\t(rx_rtsd_vector): Likewise.\n+\t* config/rx/rx.c (rx_cpu_type): New variable.\n+\t(rx_print_operand): Fix bug printing 64-bit constant values.\n+\t(rx_emit_stack_pushm): Reverse order of pushed registers.\n+\t(gen_rx_store_vector): Likewise.\n+\t(is_fast_interrupt_func): Only accept \"fast_interrupt\" as the\n+\tattribute name.\n+\t(is_exception_func): Rename to is_interrupt_func and only accept\n+\t\"interrupt\" as the attribute name.\n+\t(rx_get_stack_layout): Use new function name.\n+\t(rx_func_attr_inlinable): Likewise.\n+\t(rx_attribute_table): Remove \"exception\".\n+\t(rx_expand_prologue): If necessary push the accumulator register\n+\tin the prologue of interrupt functions.\n+\t(rx_expand_epilogue): If necessary pop the accumulator.\n+\t(rx_builtins): Add RX_BUILTIN_MVTIPL.\n+\t(rx_expand_builtin_stz): Remove.\n+\t(rx_expand_builtin_mvtipl): New function.\n+\t(rx_init_builtins): Handle RX_BUILTIN_MVTIPL.\n+\t(rx_expand_builtin): Likewise.\n+\t(rx_enable_fpu): New variable.\n+\t(rx_handle_option): Handle -fpu, -nofpu, -mcpu and -patch.\n+\t* config/rx/rx.h (TARGET_CPU_CPP_BUILTINS): Assert machine based\n+\ton rx_cpu_type.  Define __RX_FPU_INSNS__ if FPU insns are allowed.\n+\t(enum rx_cpu_types): Define.\n+\t(ASM_SPEC): Pass -m32bit-doubles on to assembler.\n+\t(INCOMING_FRAME_SP_OFFSET): Define.\n+\t(ARG_POINTER_CFA_OFFSET): Define.\n+\t(FRAME_POINTER_CFA_OFFSET): Define.\n+\t(OVERRIDE_OPTIONS): Enable fast math if RX FPU insns are enabled.\n+\t(ALLOW_RX_FPU_INSNS): Define.\n+\t* config/rx/rx.md: Test ALLOW_RX_FPU_INSNS instead of\n+\tfast_math_flags_set_p.\n+\t(UNSPEC_BUILTIN_MVTIPL): Define.\n+\t(revl): Rename to bswapsi2.\n+\t(bswaphi2): New pattern.\n+\t(mvtachi): Mark as volatile because it uses a register unknown to\n+\tGCC.\n+\t(mvtaclo): Likewise.\n+\t(racw): Likewise.\n+\t(mvtc): Remove clobber of cc0.\n+\t(mvtcp): Delete.\n+\t(opecp): Delete.\n+\t* config/rx/rx.opt (mieee): Remove.\n+\t(fpu): Add.\n+\t(nofpu): Add.\n+\t(mcpu=): Add.\n+\t(patch=): Add.\n+\t(msave-acc-in-interrupts): Add.\n+\t* config/rx/t-rx (MULTILIB_OPTIONS): Change default to 64bit\n+\tdoubles.\n+\t(MULTILIB_DIRS): Likewise.\n+\t(MULTILIB_MATCHES): Treat -fpu as an alias for -m32bit-doubles.\n+\t* doc/extend.texi: Remove description of \"exception\" function\n+\tattribute.\n+\t* doc/invoke.texi: Document -fpu, -nofpu, -mcpu=, -patch= and\n+\t-msave-acc-in-interrupts options.\n+\n 2009-11-03  Richard Guenther  <rguenther@suse.de>\n \n \t* c-common.c (fold_offsetof_1): Use HOST_WIDE_INT_PRINT_DEC."}, {"sha": "52bf7df3621ade416bce062f165dcc9458565209", "filename": "gcc/config/rx/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fconstraints.md?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -55,7 +55,7 @@\n \n ;; This constraint is used by the SUBSI3 pattern because the\n ;; RX SUB instruction can only take a 4-bit unsigned integer\n-;; value.\n+;; value.  Also used by the MVTIPL instruction.\n (define_constraint \"Uint04\"\n   \"@internal An unsigned 4-bit immediate value\"\n   (and (match_code \"const_int\")"}, {"sha": "d7a363ebb88d10123ee2c70894f188027fbaa006", "filename": "gcc/config/rx/predicates.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -117,32 +117,38 @@\n   /* Check that the next element is the first push.  */\n   element = XVECEXP (op, 0, 1);\n   if (   ! SET_P (element)\n+      || ! REG_P (SET_SRC (element))\n+      || GET_MODE (SET_SRC (element)) != SImode\n       || ! MEM_P (SET_DEST (element))\n-      || ! REG_P (XEXP (SET_DEST (element), 0))\n-      ||   REGNO (XEXP (SET_DEST (element), 0)) != SP_REG\n-      || ! REG_P (SET_SRC (element)))\n+      || GET_MODE (SET_DEST (element)) != SImode\n+      || GET_CODE (XEXP (SET_DEST (element), 0)) != MINUS\n+      || ! REG_P (XEXP (XEXP (SET_DEST (element), 0), 0))\n+      ||   REGNO (XEXP (XEXP (SET_DEST (element), 0), 0)) != SP_REG\n+      || ! CONST_INT_P (XEXP (XEXP (SET_DEST (element), 0), 1))\n+      || INTVAL (XEXP (XEXP (SET_DEST (element), 0), 1))\n+        != GET_MODE_SIZE (SImode))\n     return false;\n \n   src_regno = REGNO (SET_SRC (element));\n \n   /* Check that the remaining elements use SP-<disp>\n-     addressing and incremental register numbers.  */\n+     addressing and decreasing register numbers.  */\n   for (i = 2; i < count; i++)\n     {\n       element = XVECEXP (op, 0, i);\n \n       if (   ! SET_P (element)\n \t  || ! REG_P (SET_SRC (element))\n \t  || GET_MODE (SET_SRC (element)) != SImode\n-\t  || REGNO (SET_SRC (element)) != src_regno + (i - 1)\n+\t  || REGNO (SET_SRC (element)) != src_regno - (i - 1)\n \t  || ! MEM_P (SET_DEST (element))\n \t  || GET_MODE (SET_DEST (element)) != SImode\n \t  || GET_CODE (XEXP (SET_DEST (element), 0)) != MINUS\n           || ! REG_P (XEXP (XEXP (SET_DEST (element), 0), 0))\n           ||   REGNO (XEXP (XEXP (SET_DEST (element), 0), 0)) != SP_REG\n \t  || ! CONST_INT_P (XEXP (XEXP (SET_DEST (element), 0), 1))\n \t  || INTVAL (XEXP (XEXP (SET_DEST (element), 0), 1))\n-\t     != (i - 1) * GET_MODE_SIZE (SImode))\n+\t     != i * GET_MODE_SIZE (SImode))\n \treturn false;\n     }\n   return true;"}, {"sha": "885f52581de6d54af427787a77da6f14f88ea0d3", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 211, "deletions": 57, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -51,6 +51,8 @@\n #include \"target-def.h\"\n #include \"langhooks.h\"\n \f\n+enum rx_cpu_types  rx_cpu_type = RX600;\n+\f\n /* Return true if OP is a reference to an object in a small data area.  */\n \n static bool\n@@ -249,7 +251,6 @@ rx_is_mode_dependent_addr (rtx addr)\n     }\n }\n \f\n-\n /* A C compound statement to output to stdio stream FILE the\n    assembler syntax for an instruction operand that is a memory\n    reference whose address is ADDR.  */\n@@ -445,8 +446,13 @@ rx_print_operand (FILE * file, rtx op, int letter)\n \tfprintf (file, \"%s\", reg_names [REGNO (op) + (WORDS_BIG_ENDIAN ? 0 : 1)]);\n       else if (CONST_INT_P (op))\n \t{\n+\t  HOST_WIDE_INT v = INTVAL (op);\n+\n \t  fprintf (file, \"#\");\n-\t  rx_print_integer (file, INTVAL (op) >> 32);\n+\t  /* Trickery to avoid problems with shifting 32 bits at a time.  */\n+\t  v = v >> 16;\n+\t  v = v >> 16;\t  \n+\t  rx_print_integer (file, v);\n \t}\n       else\n \t{\n@@ -840,22 +846,20 @@ has_func_attr (const_tree decl, const char * func_attr)\n   return lookup_attribute (func_attr, DECL_ATTRIBUTES (decl)) != NULL_TREE;\n }\n \n-/* Returns true if the provided function has\n-   the \"[fast_]interrupt\" attribute.  */\n+/* Returns true if the provided function has the \"fast_interrupt\" attribute.  */\n \n static inline bool\n is_fast_interrupt_func (const_tree decl)\n {\n-  return has_func_attr (decl, \"interrupt\")\n-    || has_func_attr (decl, \"fast_interrupt\") ;\n+  return has_func_attr (decl, \"fast_interrupt\");\n }\n \n-/* Returns true if the provided function has the \"exception\" attribute.  */\n+/* Returns true if the provided function has the \"interrupt\" attribute.  */\n \n static inline bool\n-is_exception_func (const_tree decl)\n+is_interrupt_func (const_tree decl)\n {\n-  return has_func_attr (decl, \"exception\");\n+  return has_func_attr (decl, \"interrupt\");\n }\n \n /* Returns true if the provided function has the \"naked\" attribute.  */\n@@ -945,27 +949,28 @@ rx_set_current_function (tree fndecl)\n {\n   /* Remember the last target of rx_set_current_function.  */\n   static tree rx_previous_fndecl;\n-  bool prev_was_interrupt;\n-  bool current_is_interrupt;\n+  bool prev_was_fast_interrupt;\n+  bool current_is_fast_interrupt;\n \n   /* Only change the context if the function changes.  This hook is called\n      several times in the course of compiling a function, and we don't want\n      to slow things down too much or call target_reinit when it isn't safe.  */\n   if (fndecl == rx_previous_fndecl)\n     return;\n \n-  prev_was_interrupt\n+  prev_was_fast_interrupt\n     = rx_previous_fndecl\n     ? is_fast_interrupt_func (rx_previous_fndecl) : false;\n-  current_is_interrupt\n+\n+  current_is_fast_interrupt\n     = fndecl ? is_fast_interrupt_func (fndecl) : false;\n       \n-  if (prev_was_interrupt != current_is_interrupt)\n+  if (prev_was_fast_interrupt != current_is_fast_interrupt)\n     {\n-      use_fixed_regs = current_is_interrupt;\n+      use_fixed_regs = current_is_fast_interrupt;\n       target_reinit ();\n     }\n-      \n+\n   rx_previous_fndecl = fndecl;\n }\n \f\n@@ -1057,8 +1062,8 @@ rx_get_stack_layout (unsigned int * lowest,\n       if (df_regs_ever_live_p (reg)\n \t  && (! call_used_regs[reg]\n \t      /* Even call clobbered registered must\n-\t\t be pushed inside exception handlers.  */\n-\t      || is_exception_func (NULL_TREE)))\n+\t\t be pushed inside interrupt handlers.  */\n+\t      || is_interrupt_func (NULL_TREE)))\n \t{\n \t  if (low == 0)\n \t    low = reg;\n@@ -1142,9 +1147,8 @@ rx_emit_stack_pushm (rtx * operands)\n   gcc_assert (REG_P (first_push));\n \n   asm_fprintf (asm_out_file, \"\\tpushm\\t%s-%s\\n\",\n-\t       reg_names [REGNO (first_push)],\n-\t       reg_names [REGNO (first_push) + last_reg]);\n-  \n+\t       reg_names [REGNO (first_push) - last_reg],\n+\t       reg_names [REGNO (first_push)]);\n }\n \n /* Generate a PARALLEL that will pass the rx_store_multiple_vector predicate.  */\n@@ -1167,14 +1171,30 @@ gen_rx_store_vector (unsigned int low, unsigned int high)\n     XVECEXP (vector, 0, i + 1) =\n       gen_rtx_SET (SImode,\n \t\t   gen_rtx_MEM (SImode,\n-\t\t\t\ti == 0 ? stack_pointer_rtx\n-\t\t\t\t: gen_rtx_MINUS (SImode, stack_pointer_rtx,\n-\t\t\t\t\t\t GEN_INT (i * UNITS_PER_WORD))),\n-\t\t   gen_rtx_REG (SImode, low + i));\n-\n+\t\t\t\tgen_rtx_MINUS (SImode, stack_pointer_rtx,\n+\t\t\t\t\t       GEN_INT ((i + 1) * UNITS_PER_WORD))),\n+\t\t   gen_rtx_REG (SImode, high - i));\n   return vector;\n }\n \n+/* Mark INSN as being frame related.  If it is a PARALLEL\n+   then mark each element as being frame related as well.  */\n+\n+static void\n+mark_frame_related (rtx insn)\n+{\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  insn = PATTERN (insn);\n+\n+  if (GET_CODE (insn) == PARALLEL)\n+    {\n+      unsigned int i;\n+\n+      for (i = 0; i < XVECLEN (insn, 0); i++)\n+\tRTX_FRAME_RELATED_P (XVECEXP (insn, 0, i)) = 1;\n+    }\n+}\n+\n void\n rx_expand_prologue (void)\n {\n@@ -1183,6 +1203,7 @@ rx_expand_prologue (void)\n   unsigned int mask;\n   unsigned int low;\n   unsigned int high;\n+  unsigned int reg;\n   rtx insn;\n \n   /* Naked functions use their own, programmer provided prologues.  */\n@@ -1196,14 +1217,12 @@ rx_expand_prologue (void)\n   /* If we use any of the callee-saved registers, save them now.  */\n   if (mask)\n     {\n-      unsigned int reg;\n-\n       /* Push registers in reverse order.  */\n       for (reg = FIRST_PSEUDO_REGISTER; reg --;)\n \tif (mask & (1 << reg))\n \t  {\n \t    insn = emit_insn (gen_stack_push (gen_rtx_REG (SImode, reg)));\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    mark_frame_related (insn);\n \t  }\n     }\n   else if (low)\n@@ -1214,7 +1233,57 @@ rx_expand_prologue (void)\n \tinsn = emit_insn (gen_stack_pushm (GEN_INT (((high - low) + 1)\n \t\t\t\t\t\t    * UNITS_PER_WORD),\n \t\t\t\t\t   gen_rx_store_vector (low, high)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      mark_frame_related (insn);\n+    }\n+\n+  if (is_interrupt_func (NULL_TREE) && TARGET_SAVE_ACC_REGISTER)\n+    {\n+      unsigned int acc_high, acc_low;\n+\n+      /* Interrupt handlers have to preserve the accumulator\n+\t register if so requested by the user.  Use the first\n+         two pushed register as intermediaries.  */\n+      if (mask)\n+\t{\n+\t  acc_low = acc_high = 0;\n+\n+\t  for (reg = 1; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\t    if (mask & (1 << reg))\n+\t      {\n+\t\tif (acc_low == 0)\n+\t\t  acc_low = reg;\n+\t\telse\n+\t\t  {\n+\t\t    acc_high = reg;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    \n+\t  /* We have assumed that there are at least two registers pushed... */\n+\t  gcc_assert (acc_high != 0);\n+\n+\t  /* Note - the bottom 16 bits of the accumulator are inaccessible.\n+\t     We just assume that they are zero.  */\n+\t  emit_insn (gen_mvfacmi (gen_rtx_REG (SImode, acc_low)));\n+\t  emit_insn (gen_mvfachi (gen_rtx_REG (SImode, acc_high)));\n+\t  emit_insn (gen_stack_push (gen_rtx_REG (SImode, acc_low)));\n+\t  emit_insn (gen_stack_push (gen_rtx_REG (SImode, acc_high)));\n+\t}\n+      else\n+\t{\n+\t  acc_low = low;\n+\t  acc_high = low + 1;\n+\n+\t  /* We have assumed that there are at least two registers pushed... */\n+\t  gcc_assert (acc_high <= high);\n+\n+\t  emit_insn (gen_mvfacmi (gen_rtx_REG (SImode, acc_low)));\n+\t  emit_insn (gen_mvfachi (gen_rtx_REG (SImode, acc_high)));\n+\t  emit_insn (gen_stack_pushm (GEN_INT (2 * UNITS_PER_WORD),\n+\t\t\t\t      gen_rx_store_vector (acc_low, acc_high)));\n+\t}\n+\n+      frame_size += 2 * UNITS_PER_WORD;\n     }\n \n   /* If needed, set up the frame pointer.  */\n@@ -1270,8 +1339,8 @@ rx_output_function_prologue (FILE * file,\n   if (is_fast_interrupt_func (NULL_TREE))\n     asm_fprintf (file, \"\\t; Note: Fast Interrupt Handler\\n\");\n \n-  if (is_exception_func (NULL_TREE))\n-    asm_fprintf (file, \"\\t; Note: Exception Handler\\n\");\n+  if (is_interrupt_func (NULL_TREE))\n+    asm_fprintf (file, \"\\t; Note: Interrupt Handler\\n\");\n \n   if (is_naked_func (NULL_TREE))\n     asm_fprintf (file, \"\\t; Note: Naked Function\\n\");\n@@ -1382,6 +1451,7 @@ rx_expand_epilogue (bool is_sibcall)\n   unsigned int stack_size;\n   unsigned int register_mask;\n   unsigned int regs_size;\n+  unsigned int reg;\n   unsigned HOST_WIDE_INT total_size;\n \n   if (is_naked_func (NULL_TREE))\n@@ -1407,25 +1477,62 @@ rx_expand_epilogue (bool is_sibcall)\n        their caller.  Instead they branch to their sibling and allow their\n        return instruction to return to this function's parent.\n \n-     - Fast interrupt and exception handling functions have to use special\n+     - Fast and normal interrupt handling functions have to use special\n        return instructions.\n \n      - Functions where we have pushed a fragmented set of registers into the\n        call-save area must have the same set of registers popped.  */\n   if (is_sibcall\n       || is_fast_interrupt_func (NULL_TREE)\n-      || is_exception_func (NULL_TREE)\n+      || is_interrupt_func (NULL_TREE)\n       || register_mask)\n     {\n       /* Cannot use the special instructions - deconstruct by hand.  */\n       if (total_size)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t       GEN_INT (total_size)));\n \n-      if (register_mask)\n+      if (is_interrupt_func (NULL_TREE) && TARGET_SAVE_ACC_REGISTER)\n \t{\n-\t  unsigned int reg;\n+\t  unsigned int acc_low, acc_high;\n+\n+\t  /* Reverse the saving of the accumulator register onto the stack.\n+\t     Note we must adjust the saved \"low\" accumulator value as it\n+\t     is really the middle 32-bits of the accumulator.  */\n+\t  if (register_mask)\n+\t    {\n+\t      acc_low = acc_high = 0;\n+\t      for (reg = 1; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\t\tif (register_mask & (1 << reg))\n+\t\t  {\n+\t\t    if (acc_low == 0)\n+\t\t      acc_low = reg;\n+\t\t    else\n+\t\t      {\n+\t\t\tacc_high = reg;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      emit_insn (gen_stack_pop (gen_rtx_REG (SImode, acc_high)));\n+\t      emit_insn (gen_stack_pop (gen_rtx_REG (SImode, acc_low)));\n+\t    }\n+\t  else\n+\t    {\n+\t      acc_low = low;\n+\t      acc_high = low + 1;\n+\t      emit_insn (gen_stack_popm (GEN_INT (2 * UNITS_PER_WORD),\n+\t\t\t\t\t gen_rx_popm_vector (acc_low, acc_high)));\n+\t    }\n+\n+\t  emit_insn (gen_ashlsi3 (gen_rtx_REG (SImode, acc_low),\n+\t\t\t\t  gen_rtx_REG (SImode, acc_low),\n+\t\t\t\t  GEN_INT (16)));\n+\t  emit_insn (gen_mvtaclo (gen_rtx_REG (SImode, acc_low)));\n+\t  emit_insn (gen_mvtachi (gen_rtx_REG (SImode, acc_high)));\n+\t}\n \n+      if (register_mask)\n+\t{\n \t  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg ++)\n \t    if (register_mask & (1 << reg))\n \t      emit_insn (gen_stack_pop (gen_rtx_REG (SImode, reg)));\n@@ -1441,7 +1548,7 @@ rx_expand_epilogue (bool is_sibcall)\n \n       if (is_fast_interrupt_func (NULL_TREE))\n \temit_jump_insn (gen_fast_interrupt_return ());\n-      else if (is_exception_func (NULL_TREE))\n+      else if (is_interrupt_func (NULL_TREE))\n \temit_jump_insn (gen_exception_return ());\n       else if (! is_sibcall)\n \temit_jump_insn (gen_simple_return ());\n@@ -1670,6 +1777,7 @@ enum rx_builtin\n   RX_BUILTIN_MVTACHI,\n   RX_BUILTIN_MVTACLO,\n   RX_BUILTIN_MVTC,\n+  RX_BUILTIN_MVTIPL,\n   RX_BUILTIN_RACW,\n   RX_BUILTIN_REVW,\n   RX_BUILTIN_RMPA,\n@@ -1725,27 +1833,14 @@ rx_init_builtins (void)\n   ADD_RX_BUILTIN1 (RMPA,    \"rmpa\",    void,  void);\n   ADD_RX_BUILTIN1 (MVFC,    \"mvfc\",    intSI, integer);\n   ADD_RX_BUILTIN2 (MVTC,    \"mvtc\",    void,  integer, integer);\n+  ADD_RX_BUILTIN1 (MVTIPL,  \"mvtipl\",  void,  integer);\n   ADD_RX_BUILTIN1 (RACW,    \"racw\",    void,  integer);\n   ADD_RX_BUILTIN1 (ROUND,   \"round\",   intSI, float);\n   ADD_RX_BUILTIN1 (REVW,    \"revw\",    intSI, intSI);\n   ADD_RX_BUILTIN1 (SAT,     \"sat\",     intSI, intSI);\n   ADD_RX_BUILTIN1 (WAIT,    \"wait\",    void,  void);\n }\n \n-static rtx\n-rx_expand_builtin_stz (rtx arg, rtx target, rtx (* gen_func)(rtx, rtx))\n-{\n-  if (! CONST_INT_P (arg))\n-    return NULL_RTX;\n-\n-  if (target == NULL_RTX || ! REG_P (target))\n-    target = gen_reg_rtx (SImode);\n-\n-  emit_insn (gen_func (target, arg));\n-\n-  return target;\n-}\n-\n static rtx\n rx_expand_void_builtin_1_arg (rtx arg, rtx (* gen_func)(rtx), bool reg)\n {\n@@ -1790,6 +1885,21 @@ rx_expand_builtin_mvfc (tree t_arg, rtx target)\n   return target;\n }\n \n+static rtx\n+rx_expand_builtin_mvtipl (rtx arg)\n+{\n+  /* The RX610 does not support the MVTIPL instruction.  */\n+  if (rx_cpu_type == RX610)\n+    return NULL_RTX;\n+\n+  if (! CONST_INT_P (arg) || ! IN_RANGE (arg, 0, (1 << 4) - 1))\n+    return NULL_RTX;\n+\n+  emit_insn (gen_mvtipl (arg));\n+\n+  return NULL_RTX;\n+}\n+\n static rtx\n rx_expand_builtin_mac (tree exp, rtx (* gen_func)(rtx, rtx))\n {\n@@ -1887,6 +1997,7 @@ rx_expand_builtin (tree exp,\n     case RX_BUILTIN_RMPA:    emit_insn (gen_rmpa ()); return NULL_RTX;\n     case RX_BUILTIN_MVFC:    return rx_expand_builtin_mvfc (arg, target);\n     case RX_BUILTIN_MVTC:    return rx_expand_builtin_mvtc (exp);\n+    case RX_BUILTIN_MVTIPL:  return rx_expand_builtin_mvtipl (op);\n     case RX_BUILTIN_RACW:    return rx_expand_void_builtin_1_arg\n \t(op, gen_racw, false);\n     case RX_BUILTIN_ROUND:   return rx_expand_builtin_round (op, target);\n@@ -1945,7 +2056,7 @@ rx_elf_asm_destructor (rtx symbol, int priority)\n   rx_elf_asm_cdtor (symbol, priority, /* is_ctor= */false);\n }\n \f\n-/* Check \"interrupt\", \"exception\" and \"naked\" attributes.  */\n+/* Check \"fast_interrupt\", \"interrupt\" and \"naked\" attributes.  */\n \n static tree\n rx_handle_func_attribute (tree * node,\n@@ -1975,9 +2086,8 @@ rx_handle_func_attribute (tree * node,\n const struct attribute_spec rx_attribute_table[] =\n {\n   /* Name, min_len, max_len, decl_req, type_req, fn_type_req, handler.  */\n-  { \"interrupt\",      0, 0, true, false, false, rx_handle_func_attribute },\n   { \"fast_interrupt\", 0, 0, true, false, false, rx_handle_func_attribute },\n-  { \"exception\",      0, 0, true, false, false, rx_handle_func_attribute },\n+  { \"interrupt\",      0, 0, true, false, false, rx_handle_func_attribute },\n   { \"naked\",          0, 0, true, false, false, rx_handle_func_attribute },\n   { NULL,             0, 0, false, false, false, NULL }\n };\n@@ -1993,7 +2103,7 @@ static bool\n rx_func_attr_inlinable (const_tree decl)\n {\n   return ! is_fast_interrupt_func (decl)\n-    &&   ! is_exception_func (decl)\n+    &&   ! is_interrupt_func (decl)\n     &&   ! is_naked_func (decl);  \n }\n \n@@ -2115,13 +2225,48 @@ rx_is_legitimate_constant (rtx x)\n \t\t        ( 1 << (rx_max_constant_size * 8)));\n }\n \n+/* This is a tri-state variable.  The default value of 0 means that the user\n+   has specified neither -mfpu nor -mnofpu on the command line.  In this case\n+   the selection of RX FPU instructions is entirely based upon the size of\n+   the floating point object and whether unsafe math optimizations were\n+   enabled.  If 32-bit doubles have been enabled then both floats and doubles\n+   can make use of FPU instructions, otherwise only floats may do so.\n+\n+   If the value is 1 then the user has specified -mfpu and the FPU\n+   instructions should be used.  Unsafe math optimizations will automatically\n+   be enabled and doubles set to 32-bits.  If the value is -1 then -mnofpu\n+   has been specified and FPU instructions will not be used, even if unsafe\n+   math optimizations have been enabled.  */\n+int rx_enable_fpu = 0;\n+\n /* Extra processing for target specific command line options.  */\n \n static bool\n rx_handle_option (size_t code, const char *  arg ATTRIBUTE_UNUSED, int value)\n {\n   switch (code)\n     {\n+      /* -mfpu enables the use of RX FPU instructions.  This implies the use\n+\t of 32-bit doubles and also the enabling of fast math optimizations.\n+\t (Since the RX FPU instructions are not IEEE compliant).  The -mnofpu\n+\t option disables the use of RX FPU instructions, but does not make\n+\t place any constraints on the size of doubles or the use of fast math\n+\t optimizations.\n+\n+\t The selection of 32-bit vs 64-bit doubles is handled by the setting\n+\t of the 32BIT_DOUBLES mask in the rx.opt file.  Enabling fast math\n+\t optimizations is performed in OVERRIDE_OPTIONS since if it was done\n+\t here it could be overridden by a -fno-fast-math option specified\n+\t *earlier* on the command line.  (Target specific options are\n+\t processed before generic ones).  */\n+    case OPT_fpu:\n+      rx_enable_fpu = 1;\n+      break;\n+\n+    case OPT_nofpu:\n+      rx_enable_fpu = -1;\n+      break;\n+\n     case OPT_mint_register_:\n       switch (value)\n \t{\n@@ -2145,12 +2290,21 @@ rx_handle_option (size_t code, const char *  arg ATTRIBUTE_UNUSED, int value)\n       break;\n \n     case OPT_mmax_constant_size_:\n-      /* Make sure that the the -mmax-constant_size option is in range.  */\n+      /* Make sure that the -mmax-constant_size option is in range.  */\n       return IN_RANGE (value, 0, 4);\n \n+    case OPT_mcpu_:\n+    case OPT_patch_:\n+      if (strcasecmp (arg, \"RX610\") == 0)\n+\trx_cpu_type = RX610;\n+      /* FIXME: Should we check for non-RX cpu names here ?  */\n+      break;\n+      \n     default:\n-      return true;\n+      break;\n     }\n+\n+  return true;\n }\n \n static int"}, {"sha": "bb7cf7f1e3e71f12d7a3890337b044a8c5d2ff29", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -24,25 +24,42 @@\n     {                                           \\\n       builtin_define (\"__RX__\"); \t\t\\\n       builtin_assert (\"cpu=RX\"); \t\t\\\n-      builtin_assert (\"machine=RX\");\t\t\\\n+      if (rx_cpu_type == RX610)\t\t\t\\\n+        builtin_assert (\"machine=RX610\");\t\\\n+     else\t\t\t\t\t\\\n+        builtin_assert (\"machine=RX600\");\t\\\n       \t\t\t\t\t\t\\\n       if (TARGET_BIG_ENDIAN_DATA)\t\t\\\n \tbuiltin_define (\"__RX_BIG_ENDIAN__\");\t\\\n       else\t\t\t\t\t\\\n \tbuiltin_define (\"__RX_LITTLE_ENDIAN__\");\\\n       \t\t\t\t\t\t\\\n-      if (TARGET_64BIT_DOUBLES)\t\t\t\\\n-\tbuiltin_define (\"__RX_64BIT_DOUBLES__\");\\\n-      else\t\t\t\t\t\\\n+      if (TARGET_32BIT_DOUBLES)\t\t\t\\\n \tbuiltin_define (\"__RX_32BIT_DOUBLES__\");\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__RX_64BIT_DOUBLES__\");\\\n       \t\t\t\t\t\t\\\n+      if (ALLOW_RX_FPU_INSNS)\t\t\t\\\n+\tbuiltin_define (\"__RX_FPU_INSNS__\");\t\\\n+\t\t\t\t\t\t\\\n       if (TARGET_AS100_SYNTAX)\t\t\t\\\n \tbuiltin_define (\"__RX_AS100_SYNTAX__\"); \\\n       else\t\t\t\t\t\\\n \tbuiltin_define (\"__RX_GAS_SYNTAX__\");   \\\n     }                                           \\\n   while (0)\n \n+enum rx_cpu_types\n+{\n+  RX600,\n+  RX610\n+};\n+\n+extern enum rx_cpu_types  rx_cpu_type;\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{mas100-syntax:%{gdwarf*:%e-mas100-syntax is incompatible with -gdwarf}}\"\n+\n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:crt0.o%s} crtbegin.o%s\"\n \n@@ -52,7 +69,8 @@\n #undef  ASM_SPEC\n #define ASM_SPEC \"\\\n %{mbig-endian-data:-mbig-endian-data} \\\n-%{m64bit-doubles:-m64bit-doubles} \\\n+%{m32bit-doubles:-m32bit-doubles} \\\n+%{!m32bit-doubles:-m64bit-doubles} \\\n %{msmall-data-limit*:-msmall-data-limit} \\\n %{mrelax:-relax} \\\n \"\n@@ -88,16 +106,17 @@\n #define LONG_LONG_TYPE_SIZE\t\t64\n \n #define FLOAT_TYPE_SIZE \t\t32\n-#define DOUBLE_TYPE_SIZE \t\t(TARGET_64BIT_DOUBLES ? 64 : 32)\n+#define DOUBLE_TYPE_SIZE \t\t(TARGET_32BIT_DOUBLES ? 32 : 64)\n #define LONG_DOUBLE_TYPE_SIZE\t\tDOUBLE_TYPE_SIZE\n \n-#ifdef __RX_64BIT_DOUBLES__\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   64\n-#define LIBGCC2_DOUBLE_TYPE_SIZE\t64\n-#define LIBGCC2_HAS_DF_MODE\t\t1\n-#else\n+#ifdef __RX_32BIT_DOUBLES__\n+#define LIBGCC2_HAS_DF_MODE\t\t0\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   32\n #define LIBGCC2_DOUBLE_TYPE_SIZE\t32\n+#else\n+#define LIBGCC2_HAS_DF_MODE\t\t1\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   64\n+#define LIBGCC2_DOUBLE_TYPE_SIZE\t64\n #endif\n \n #define DEFAULT_SIGNED_CHAR\t\t0\n@@ -591,7 +610,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n   rx_print_operand_address (FILE, ADDR)\n \f\n-\n #define CC_NO_CARRY\t\t\t0400\n #define NOTICE_UPDATE_CC(EXP, INSN)\trx_notice_update_cc (EXP, INSN)\n \n@@ -614,19 +632,28 @@ extern int rx_float_compare_mode;\n #define PREFERRED_DEBUGGING_TYPE (TARGET_AS100_SYNTAX \\\n \t\t\t\t  ? DBX_DEBUG : DWARF2_DEBUG)\n \n-#undef  CC1_SPEC\n-#define CC1_SPEC \"%{mas100-syntax:%{gdwarf*:%e-mas100-syntax is incompatible with -gdwarf}}\"\n+#define INCOMING_FRAME_SP_OFFSET\t\t4\n+#define ARG_POINTER_CFA_OFFSET(FNDECL)\t\t4\n+#define FRAME_POINTER_CFA_OFFSET(FNDECL)\t4\n+\f\n+extern int rx_enable_fpu;\n \n /* For some unknown reason LTO compression is not working, at\n    least on my local system.  So set the default compression\n-   level to none, for now.  */\n+   level to none, for now.\n+\n+   For an explanation of rx_flag_no_fpu see rx_handle_option().  */\n #define OVERRIDE_OPTIONS\t\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       if (flag_lto_compression_level == -1)\t\\\n         flag_lto_compression_level = 0;\t\t\\\n+\t\t\t\t\t\t\\\n+      if (rx_enable_fpu == 1)\t\t\t\\\n+\tset_fast_math_flags (true);\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n /* This macro is used to decide when RX FPU instructions can be used.  */\n-#define ALLOW_RX_FPU_INSNS\tflag_unsafe_math_optimizations\n+#define ALLOW_RX_FPU_INSNS\t((rx_enable_fpu != -1) \\\n+\t\t\t\t && flag_unsafe_math_optimizations)"}, {"sha": "360f6235558f77b16e3c925b2297b0aa11d9c5f7", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -27,8 +27,8 @@\n ;; This code iterator is used for sign- and zero- extensions.\n (define_mode_iterator small_int_modes [(HI \"\") (QI \"\")])\n \n-;; We do not handle DFmode here because by default it is\n-;; the same as SFmode, and if -m64bit-doubles is active\n+;; We do not handle DFmode here because it is either\n+;; the same as SFmode, or if -m64bit-doubles is active\n ;; then all operations on doubles have to be handled by\n ;; library functions.\n (define_mode_iterator register_modes\n@@ -75,15 +75,14 @@\n    (UNSPEC_BUILTIN_MVTACHI 41)\n    (UNSPEC_BUILTIN_MVTACLO 42)\n    (UNSPEC_BUILTIN_MVTC    43)\n-   (UNSPEC_BUILTIN_MVTCP   44)\n-   (UNSPEC_BUILTIN_OPEPC   45)\n-   (UNSPEC_BUILTIN_RACW\t   46)\n-   (UNSPEC_BUILTIN_REVW    47)\n-   (UNSPEC_BUILTIN_RMPA\t   48)\n-   (UNSPEC_BUILTIN_ROUND   49)\n-   (UNSPEC_BUILTIN_SAT     50)\n-   (UNSPEC_BUILTIN_SETPSW  51)\n-   (UNSPEC_BUILTIN_WAIT\t   52)\n+   (UNSPEC_BUILTIN_MVTIPL  44)\n+   (UNSPEC_BUILTIN_RACW\t   45)\n+   (UNSPEC_BUILTIN_REVW    46)\n+   (UNSPEC_BUILTIN_RMPA\t   47)\n+   (UNSPEC_BUILTIN_ROUND   48)\n+   (UNSPEC_BUILTIN_SAT     49)\n+   (UNSPEC_BUILTIN_SETPSW  50)\n+   (UNSPEC_BUILTIN_WAIT\t   51)\n   ]\n )\n \n@@ -1002,10 +1001,8 @@\n    (set_attr \"timings\" \"11,11,11,11,11,33\")\n    (set_attr \"length\" \"3,4,5,6,7,6\")]\n )\n-\n+\f\n ;; Floating Point Instructions\n-;; These patterns are only enabled with -ffast-math because the RX FPU\n-;; cannot handle sub-normal values.\n \n (define_insn \"addsf3\"\n   [(set (match_operand:SF          0 \"register_operand\"  \"=r,r,r\")\n@@ -1298,7 +1295,6 @@\n   [(set_attr \"length\" \"3,6\")\n    (set_attr \"timings\" \"22\")]\n )\n-\n \f\n ;; Block move functions.\n \n@@ -1580,26 +1576,26 @@\n \n ;; Move to Accumulator (high)\n (define_insn \"mvtachi\"\n-  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n-\t      UNSPEC_BUILTIN_MVTACHI)]\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t       UNSPEC_BUILTIN_MVTACHI)]\n   \"\"\n   \"mvtachi\\t%0\"\n   [(set_attr \"length\" \"3\")]\n )\n \n ;; Move to Accumulator (low)\n (define_insn \"mvtaclo\"\n-  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n-\t      UNSPEC_BUILTIN_MVTACLO)]\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t       UNSPEC_BUILTIN_MVTACLO)]\n   \"\"\n   \"mvtaclo\\t%0\"\n   [(set_attr \"length\" \"3\")]\n )\n \n ;; Round Accumulator\n (define_insn \"racw\"\n-  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n-\t      UNSPEC_BUILTIN_RACW)]\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n+\t\t       UNSPEC_BUILTIN_RACW)]\n   \"\"\n   \"racw\\t%0\"\n   [(set_attr \"length\" \"3\")]\n@@ -1679,7 +1675,7 @@\n \n ;; Move from control register\n (define_insn \"mvfc\"\n-  [(set (match_operand:SI                      0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n \t(unspec:SI [(match_operand:SI 1 \"immediate_operand\" \"i\")]\n \t\t   UNSPEC_BUILTIN_MVFC))]\n   \"\"\n@@ -1691,13 +1687,24 @@\n (define_insn \"mvtc\"\n   [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i\")\n \t       (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")]\n-\t      UNSPEC_BUILTIN_MVTC)\n-   (clobber (cc0))]\n+\t      UNSPEC_BUILTIN_MVTC)]\n   \"\"\n   \"mvtc\\t%1, %C0\"\n-  [(set_attr \"length\" \"3,7\")\n-   (set_attr \"cc\" \"clobber\")]  ;; Just in case the control\n-                               ;; register selected is the psw.\n+  [(set_attr \"length\" \"3,7\")]\n+  ;; Ignore possible clobbering of the comparison flags in the\n+  ;; PSW register.  This is a cc0 target so any cc0 setting\n+  ;; instruction will always be paired with a cc0 user, without\n+  ;; the possibility of this instruction being placed in between\n+  ;; them.\n+)\n+\n+;; Move to interrupt priority level\n+(define_insn \"mvtipl\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"Uint04\")]\n+\t      UNSPEC_BUILTIN_MVTIPL)]\n+  \"\"\n+  \"mvtipl\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n )\n \n ;;---------- Interrupts ------------------------\n@@ -1748,27 +1755,6 @@\n   [(set_attr \"length\" \"5\")]\n )\n \n-;; Move to co-processor register\n-(define_insn \"mvtcp\"\n-  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i\")\n-\t       (match_operand:SI 1 \"nonmemory_operand\" \"i,r\")\n-\t       (match_operand:SI 2 \"immediate_operand\" \"i,i\")]\n-\t      UNSPEC_BUILTIN_MVTCP)]\n-  \"\"\n-  \"; mvtcp\\t%0, %1, %2\"\n-  [(set_attr \"length\" \"7,5\")]\n-)\n-\n-;; Co-processor operation\n-(define_insn \"opecp\"\n-  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")\n-\t       (match_operand:SI 1 \"immediate_operand\" \"i\")]\n-\t      UNSPEC_BUILTIN_OPEPC)]\n-  \"\"\n-  \"; opecp\\t%0, %1\"\n-  [(set_attr \"length\" \"5\")]\n-)\n-\n ;;---------- Misc ------------------------\n \n ;; Required by cfglayout.c..."}, {"sha": "768d565b478f91248840862e6a9050fe06a5db15", "filename": "gcc/config/rx/rx.opt", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Frx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.opt?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -19,13 +19,31 @@\n ; <http://www.gnu.org/licenses/>.\n ;---------------------------------------------------\n \n+m32bit-doubles\n+Target RejectNegative Mask(32BIT_DOUBLES)\n+Stores doubles in 32 bits.\n+\n m64bit-doubles\n-Target RejectNegative Mask(64BIT_DOUBLES)\n-Store doubles in 64 bits.\n+Target RejectNegative InverseMask(32BIT_DOUBLES)\n+Store doubles in 64 bits.  This is the default.\n \n-m32bit-doubles\n-Target RejectNegative InverseMask(64BIT_DOUBLES)\n-Stores doubles in 32 bits.  This is the default.\n+fpu\n+Target RejectNegative Mask(32BIT_DOUBLES) MaskExists\n+Enable the use of RX FPU instructions.\n+\n+nofpu\n+Target RejectNegative InverseMask(32BIT_DOUBLES) MaskExists\n+Disable the use of RX FPU instructions.\n+\n+;---------------------------------------------------\n+\n+mcpu=\n+Target RejectNegative Joined Var(rx_cpu_name)\n+Specify the target RX cpu type.\n+\n+patch=\n+Target RejectNegative Joined Var(rx_cpu_name)\n+Alias for -mcpu.\n \n ;---------------------------------------------------\n \n@@ -72,3 +90,9 @@ Maximum size in bytes of constant values allowed as operands.\n mint-register=\n Target RejectNegative Joined UInteger Var(rx_interrupt_registers) Init(0)\n Specifies the number of registers to reserve for interrupt handlers.\n+\n+;---------------------------------------------------\n+\n+msave-acc-in-interrupts\n+Target Mask(SAVE_ACC_REGISTER)\n+Specifies whether interrupt functions should save and restore the accumulator register."}, {"sha": "eb1ca48d3a33c9070a53ee86d9c62207e1d913c9", "filename": "gcc/config/rx/t-rx", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Ft-rx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fconfig%2Frx%2Ft-rx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Ft-rx?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -20,9 +20,9 @@\n \n # Enable multilibs:\n \n-MULTILIB_OPTIONS    = m64bit-doubles mbig-endian-data\n-MULTILIB_DIRNAMES   = 64fp           big-endian-data\n-MULTILIB_MATCHES    = m64bit-doubles=mieee\n+MULTILIB_OPTIONS    = m32bit-doubles mbig-endian-data\n+MULTILIB_DIRNAMES   = 32fp           big-endian-data\n+MULTILIB_MATCHES    = m32bit-doubles=fpu\n MULTILIB_EXCEPTIONS =\n MULTILIB_EXTRA_OPTS = \n "}, {"sha": "bfcc5fb80fbb38bf59eaeb4eb55a7154ea948771", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -2270,13 +2270,6 @@ on data in the eight bit data area.  Note the eight bit data area is limited to\n You must use GAS and GLD from GNU binutils version 2.7 or later for\n this attribute to work correctly.\n \n-@item exception\n-@cindex exception handler functions on the RX processor\n-Use this attribute on the RX to indicate that the specified function\n-is an exception handler.  The compiler will generate function entry and\n-exit sequences suitable for use in an exception handler when this\n-attribute is present.\n-\n @item exception_handler\n @cindex exception handler functions on the Blackfin processor\n Use this attribute on the Blackfin to indicate that the specified function"}, {"sha": "ed652ec1d39081567d94ad9e3a4daa24745a640b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -784,14 +784,16 @@ See RS/6000 and PowerPC Options.\n -msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread}\n \n @emph{RX Options}\n-@gccoptlist{-m64bit-doubles  -m32bit-doubles  -mieee  -mno-ieee@gol\n+@gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n+-mcpu= -patch=@gol\n -mbig-endian-data -mlittle-endian-data @gol\n -msmall-data @gol\n -msim  -mno-sim@gol\n -mas100-syntax -mno-as100-syntax@gol\n -mrelax@gol\n -mmax-constant-size=@gol\n--mint-register=}\n+-mint-register=@gol\n+-msave-acc-in-interrupts}\n \n @emph{S/390 and zSeries Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n@@ -15408,16 +15410,37 @@ These @option{-m} options are defined for RX implementations:\n @table @gcctabopt\n @item -m64bit-doubles\n @itemx -m32bit-doubles\n+@itemx -fpu\n+@itemx -nofpu\n @opindex m64bit-doubles\n @opindex m32bit-doubles\n+@opindex fpu\n+@opindex nofpu\n Make the @code{double} data type be 64-bits (@option{-m64bit-doubles})\n or 32-bits (@option{-m32bit-doubles}) in size.  The default is\n-@option{-m32bit-doubles}.  @emph{Note} the RX's hardware floating\n+@option{-m64bit-doubles}.  @emph{Note} the RX's hardware floating\n point instructions are only used for 32-bit floating point values, and\n then only if @option{-ffast-math} has been specified on the command\n line.  This is because the RX FPU instructions do not properly support\n denormal (or sub-normal) values.\n \n+The options @option{-fpu} and @option{-nofpu} have been provided at\n+the request of Rensas for compatibility with their toolchain.  The\n+@option{-mfpu} option enables the use of RX FPU instructions by\n+selecting 32-bit doubles and enabling unsafe math optimizations.  The\n+@option{-mnofpu} option disables the use of RX FPU instructions, even\n+if @option{-m32bit-doubles} is active and unsafe math optimizations\n+have been enabled.\n+\n+@item -mcpu=@var{name}\n+@itemx -patch=@var{name}\n+@opindex -mcpu\n+@opindex -patch\n+Selects the type of RX CPU to be targeted.  Currently on two types are\n+supported, the generic @var{RX600} and the specific @var{RX610}.  The\n+only difference between them is that the @var{RX610} does not support\n+the @code{MVTIPL} instruction.\n+\n @item -mbig-endian-data\n @itemx -mlittle-endian-data\n @opindex mbig-endian-data\n@@ -15493,6 +15516,15 @@ of fast interrupt handlers.  A value of 2 reserves @code{r13} and\n @code{r12}.  A value of 3 reserves @code{r13}, @code{r12} and\n @code{r11}, and a value of 4 reserves @code{r13} through @code{r10}.\n A value of 0, the default, does not reserve any registers.\n+\n+@item -msave-acc-in-interrupts\n+@opindex msave-acc-in-interrupts\n+Specifies that interrupt handler functions should preserve the\n+accumulator register.  This is only necessary if normal code might use\n+the accumulator register, for example because it performs 64-bit\n+multiplications.  The default is to ignore the accumulator as this\n+makes the interrupt handlers faster.\n+\n @end table\n \n @emph{Note:} The generic GCC command line @option{-ffixed-@var{reg}}"}, {"sha": "32e07ccd49af4d9da71f19b764612ae7cc4526f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -1,3 +1,11 @@\n+2009-11-03  Nick Clifton  <nickc@redhat.com>\n+\n+\t* gcc.target/rx/builtins,c: Remove redundant tests.\n+\tAdd test of MVTIPL instruction.\n+\t* gcc.target/rx/interrupts.c: Use fast_interrupt and interrupt\n+\tfunction attributes.  Add -msave-acc-in-interrupts option to the\n+\tcommand line.\n+\n 2009-11-03  Andrew Stubbs  <ams@codesourcery.com>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n "}, {"sha": "2a6241d7cce75dbae570c787275332a5c5a93dd0", "filename": "gcc/testsuite/gcc.target/rx/builtins.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -17,7 +17,6 @@\n    to correctly set the psw flags.  */\n \n int saturate_add         (int, int)      __attribute__((__noinline__));\n-int subtract_with_borrow (int, int, int) __attribute__((__noinline__));\n int exchange             (int, int)      __attribute__((__noinline__));\n \n int\n@@ -33,6 +32,13 @@ saturate_add (int arg1, int arg2)\n   return __builtin_rx_sat (arg1);\n }\n \n+int\n+exchange (int arg1, int arg2)\n+{\n+  arg1 = __builtin_rx_xchg (arg2);\n+  return arg1;\n+}\n+\n long\n multiply_and_accumulate (long arg1, long arg2, long arg3)\n {\n@@ -157,3 +163,9 @@ rmpa (int * multiplicand, int * multiplier, int num)\n {\n   __builtin_rx_rmpa ();\n }\n+\n+void\n+set_interrupts (void)\n+{\n+  __builtin_mvtipl (3);\n+}"}, {"sha": "cdc4903ded87d445a2121f5d23ea0729411eedab", "filename": "gcc/testsuite/gcc.target/rx/interrupts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -1,10 +1,10 @@\n /* { dg-do compile } */\n-/* { dg-options \"-mint-register=3\" } */\n+/* { dg-options \"-mint-register=3 -msave-acc-in-interrupts\" } */\n \n /* Verify that the RX specific function attributes work.  */\n \n+void fast_interrupt (void) __attribute__((__fast_interrupt__));\n void interrupt (void) __attribute__((__interrupt__));\n-void exception (void) __attribute__((__exception__));\n int naked (int) __attribute__((__naked__));\n \n int flag = 0;\n@@ -13,16 +13,16 @@ int flag = 0;\n    by the -fixed-xxx gcc command line option.  Returns via RTFI.  */\n \n void\n-interrupt (void)\n+fast_interrupt (void)\n {\n   flag = 1;\n }\n \n-/* Exception handler.  Must preserve any register it uses, even\n+/* Interrupt handler.  Must preserve any register it uses, even\n    call clobbered ones.  Returns via RTE.  */\n \n void\n-exception (void)\n+interrupt (void)\n {\n   switch (flag)\n     {"}, {"sha": "e07ff71a007e0743277974a12de44b5d4bbaadd9", "filename": "gcc/testsuite/gcc.target/rx/rx-abi-function-tests.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9595a419c6d743670f8554b8771156d508983efc/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c?ref=9595a419c6d743670f8554b8771156d508983efc", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-options \"-msim\" } */\n-/* Note: The -msim abiove is actually there to override the default\n+/* Note: The -msim above is actually there to override the default\n    options which include -ansi -pendantic and -Wlong-long...   */\n \n extern int printf (const char *, ...);"}]}