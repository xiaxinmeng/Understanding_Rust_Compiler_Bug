{"sha": "37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdhMjQ3YTBhMGZkYmUxNDUwY2UyMjg0YjEyYjhlN2Y2YzMwNDkwOQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-15T08:33:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-15T08:33:27Z"}, "message": "class.c (check_bases): Don't set CLASSTYPE_NON_AGGREGATE here.\n\n\t* class.c (check_bases): Don't set CLASSTYPE_NON_AGGREGATE here.\n\tDon't check for incomplete base.\n\t(get_vfield_name): Simplify while loop.\n\t* decl.c (xref_basetypes): Set CLASSTYPE_NON_AGGREGATE here.\n\nFrom-SVN: r84747", "tree": {"sha": "0369e3e7eea1b2e7d68732896c46407961d4f9db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0369e3e7eea1b2e7d68732896c46407961d4f9db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/comments", "author": null, "committer": null, "parents": [{"sha": "400053660cdd089c226a6f6fdb4e6793c6384f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400053660cdd089c226a6f6fdb4e6793c6384f16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400053660cdd089c226a6f6fdb4e6793c6384f16"}], "stats": {"total": 52, "additions": 25, "deletions": 27}, "files": [{"sha": "703941bad9b5e37ce6ec4ff80a168877aef1b19a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "patch": "@@ -1,3 +1,10 @@\n+2004-07-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (check_bases): Don't set CLASSTYPE_NON_AGGREGATE here.\n+\tDon't check for incomplete base.\n+\t(get_vfield_name): Simplify while loop.\n+\t* decl.c (xref_basetypes): Set CLASSTYPE_NON_AGGREGATE here.\n+\n 2004-07-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lex.c (cxx_make_type): Remove call to get_pointer_type."}, {"sha": "de1aadded39cdf21718e3d5d599f0a9c42ca8a2e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "patch": "@@ -1198,9 +1198,6 @@ check_bases (tree t,\n   n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   seen_non_virtual_nearly_empty_base_p = 0;\n \n-  /* An aggregate cannot have baseclasses.  */\n-  CLASSTYPE_NON_AGGREGATE (t) |= (n_baseclasses != 0);\n-\n   for (i = 0; i < n_baseclasses; ++i) \n     {\n       tree base_binfo;\n@@ -1210,24 +1207,8 @@ check_bases (tree t,\n       base_binfo = TREE_VEC_ELT (binfos, i);\n       basetype = TREE_TYPE (base_binfo);\n \n-      /* If the type of basetype is incomplete, then we already\n-\t complained about that fact (and we should have fixed it up as\n-\t well).  */\n-      if (!COMPLETE_TYPE_P (basetype))\n-\t{\n-\t  int j;\n-\t  /* The base type is of incomplete type.  It is\n-\t     probably best to pretend that it does not\n-\t     exist.  */\n-\t  if (i == n_baseclasses-1)\n-\t    TREE_VEC_ELT (binfos, i) = NULL_TREE;\n-\t  TREE_VEC_LENGTH (binfos) -= 1;\n-\t  n_baseclasses -= 1;\n-\t  for (j = i; j+1 < n_baseclasses; j++)\n-\t    TREE_VEC_ELT (binfos, j) = TREE_VEC_ELT (binfos, j+1);\n-\t  continue;\n-\t}\n-\n+      my_friendly_assert (COMPLETE_TYPE_P (basetype), 20040714);\n+      \n       /* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P\n \t here because the case of virtual functions but non-virtual\n \t dtor is handled in finish_struct_1.  */\n@@ -6260,14 +6241,20 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n static tree\n get_vfield_name (tree type)\n {\n-  tree binfo = TYPE_BINFO (type);\n+  tree binfo, base_binfo;\n   char *buf;\n \n-  while (BINFO_BASE_BINFOS (binfo)\n-\t && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (BINFO_BASE_BINFO (binfo, 0)))\n-\t && ! BINFO_VIRTUAL_P (BINFO_BASE_BINFO (binfo, 0)))\n-    binfo = BINFO_BASE_BINFO (binfo, 0);\n+  for (binfo = TYPE_BINFO (type);\n+       BINFO_BASE_BINFOS (binfo);\n+       binfo = base_binfo)\n+    {\n+      base_binfo = BINFO_BASE_BINFO (binfo, 0);\n \n+      if (BINFO_VIRTUAL_P (base_binfo)\n+\t  || !TYPE_CONTAINS_VPTR_P (BINFO_TYPE (base_binfo)))\n+\tbreak;\n+    }\n+  \n   type = BINFO_TYPE (binfo);\n   buf = alloca (sizeof (VFIELD_NAME_FORMAT) + TYPE_NAME_LENGTH (type) + 2);\n   sprintf (buf, VFIELD_NAME_FORMAT,"}, {"sha": "d91709ea45d7cfa054cb54fb11248c1dda605a1d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37a247a0a0fdbe1450ce2284b12b8e7f6c304909/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=37a247a0a0fdbe1450ce2284b12b8e7f6c304909", "patch": "@@ -9176,7 +9176,11 @@ xref_basetypes (tree ref, tree base_list)\n \t  i++;\n \t}\n       if (i)\n-\tTREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n+\t{\n+\t  TREE_VEC_LENGTH (accesses) = TREE_VEC_LENGTH (binfos) = i;\n+\t  /* An aggregate cannot have baseclasses.  */\n+\t  CLASSTYPE_NON_AGGREGATE (ref) = 1;\n+\t}\n       else\n \tBINFO_BASE_ACCESSES (binfo) = BINFO_BASE_BINFOS (binfo) = NULL_TREE;\n       if (max_vbases)"}]}