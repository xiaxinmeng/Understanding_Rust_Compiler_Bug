{"sha": "7c0927142c51ad22532fb77f0a8027836cd1f8e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MwOTI3MTQyYzUxYWQyMjUzMmZiNzdmMGE4MDI3ODM2Y2QxZjhlOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-04-06T05:21:36Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-04-06T05:21:36Z"}, "message": "cppfiles.c (open_file): Fail directories silently, but with an errno of NOENT set.\n\n\t* cppfiles.c (open_file): Fail directories silently, but\n\twith an errno of NOENT set.\n\t(read_include_file): Move the common exit code to the sole\n\tcaller.  Return an int indicating success or failure.  Let\n\topen_file handle directories.\n\t(stack_include_file): If read_include_file fails,\n\tpush a \"null\" buffer.\n\nFrom-SVN: r41138", "tree": {"sha": "01525776aece00c4a0a1e9067077ab550278e061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01525776aece00c4a0a1e9067077ab550278e061"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c0927142c51ad22532fb77f0a8027836cd1f8e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0927142c51ad22532fb77f0a8027836cd1f8e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c0927142c51ad22532fb77f0a8027836cd1f8e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0927142c51ad22532fb77f0a8027836cd1f8e9/comments", "author": null, "committer": null, "parents": [{"sha": "8d66b99ac2041c14b836475fec83b77acea675b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d66b99ac2041c14b836475fec83b77acea675b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d66b99ac2041c14b836475fec83b77acea675b7"}], "stats": {"total": 74, "additions": 44, "deletions": 30}, "files": [{"sha": "c86f2da83fc29368e8b5da83d044f0c9ce5f147a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0927142c51ad22532fb77f0a8027836cd1f8e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0927142c51ad22532fb77f0a8027836cd1f8e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c0927142c51ad22532fb77f0a8027836cd1f8e9", "patch": "@@ -1,3 +1,13 @@\n+2001-04-06  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppfiles.c (open_file): Fail directories silently, but\n+\twith an errno of NOENT set.\n+\t(read_include_file): Move the common exit code to the sole\n+\tcaller.  Return an int indicating success or failure.  Let\n+\topen_file handle directories.\n+\t(stack_include_file): If read_include_file fails,\n+\tpush a \"null\" buffer.\n+\n 2001-04-05  DJ Delorie  <dj@redhat.com>\n \n \t* function.h (virtuals_instantiated): Declare."}, {"sha": "bff04ae5326ca887d55295724ded6d6216797260", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c0927142c51ad22532fb77f0a8027836cd1f8e9/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c0927142c51ad22532fb77f0a8027836cd1f8e9/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=7c0927142c51ad22532fb77f0a8027836cd1f8e9", "patch": "@@ -93,7 +93,7 @@ static struct include_file *\n \tfind_include_file PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t   enum include_type));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n-static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n+static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void purge_cache \tPARAMS ((struct include_file *));\n static void destroy_node\tPARAMS ((splay_tree_value));\n@@ -241,15 +241,23 @@ open_file (pfile, filename)\n \n   if (file->fd != -1 && fstat (file->fd, &file->st) == 0)\n     {\n-      /* Mark a regular, zero-length file never-reread now.  */\n-      if (S_ISREG (file->st.st_mode) && file->st.st_size == 0)\n-        {\n-\t  _cpp_never_reread (file);\n-\t  close (file->fd);\n-\t  file->fd = -1;\n-\t}\n+      /* If it's a directory, we return null and continue the search\n+\t as the file we're looking for may appear elsewhere in the\n+\t search path.  */\n+      if (S_ISDIR (file->st.st_mode))\n+\terrno = ENOENT;\n+      else\n+\t{\n+\t  /* Mark a regular, zero-length file never-reread now.  */\n+\t  if (S_ISREG (file->st.st_mode) && file->st.st_size == 0)\n+\t    {\n+\t      _cpp_never_reread (file);\n+\t      close (file->fd);\n+\t      file->fd = -1;\n+\t    }\n \n-      return file;\n+\t  return file;\n+\t}\n     }\n \n   /* Don't issue an error message if the file doesn't exist.  */\n@@ -284,13 +292,19 @@ stack_include_file (pfile, inc)\n   if (CPP_OPTION (pfile, print_deps) > deps_sysp && !inc->include_count)\n     deps_add_dep (pfile->deps, inc->name);\n \n+  /* Not in cache?  */\n+  if (! DO_NOT_REREAD (inc) && ! inc->buffer)\n+    {\n+      /* If an error occurs, do not try to read this file again.  */\n+      if (read_include_file (pfile, inc))\n+\t_cpp_never_reread (inc);\n+      close (inc->fd);\n+      inc->fd = -1;\n+    }\n+\n   if (! DO_NOT_REREAD (inc))\n     {\n-      /* Not in cache?  */\n-      if (! inc->buffer)\n-\tread_include_file (pfile, inc);\n       len = inc->st.st_size;\n-\n       if (pfile->buffer)\n \t{\n \t  /* We don't want MI guard advice for the main file.  */\n@@ -328,17 +342,17 @@ stack_include_file (pfile, inc)\n    If fd points to a plain file, we might be able to mmap it; we can\n    definitely allocate the buffer all at once.  If fd is a pipe or\n    terminal, we can't do either.  If fd is something weird, like a\n-   block device or a directory, we don't want to read it at all.\n+   block device, we don't want to read it at all.\n \n    Unfortunately, different systems use different st.st_mode values\n    for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n    zero the entire struct stat except a couple fields.  Hence we don't\n-   even try to figure out what something is, except for plain files,\n-   directories, and block devices.\n+   even try to figure out what something is, except for plain files\n+   and block devices.\n \n    FIXME: Flush file cache and try again if we run out of memory.  */\n \n-static void\n+static int\n read_include_file (pfile, inc)\n      cpp_reader *pfile;\n      struct include_file *inc;\n@@ -402,11 +416,6 @@ read_include_file (pfile, inc)\n       cpp_error (pfile, \"%s is a block device\", inc->name);\n       goto fail;\n     }\n-  else if (S_ISDIR (inc->st.st_mode))\n-    {\n-      cpp_error (pfile, \"%s is a directory\", inc->name);\n-      goto fail;\n-    }\n   else\n     {\n       /* 8 kilobytes is a sensible starting size.  It ought to be\n@@ -430,19 +439,13 @@ read_include_file (pfile, inc)\n       inc->st.st_size = offset;\n     }\n \n-  close (inc->fd);\n   inc->buffer = buf;\n-  inc->fd = -1;\n-  return;\n+  return 0;\n \n  perror_fail:\n   cpp_error_from_errno (pfile, inc->name);\n  fail:\n-  /* Do not try to read this file again.  */\n-  close (inc->fd);\n-  inc->fd = -1;\n-  _cpp_never_reread (inc);\n-  return;\n+  return 1;\n }\n \n static void\n@@ -617,6 +620,7 @@ handle_missing_header (pfile, fname, angle_brackets)\n   /* We will try making the RHS pfile->buffer->sysp after 3.0.  */\n   int print_dep = CPP_PRINT_DEPS(pfile) > (angle_brackets\n \t\t\t\t\t   || pfile->system_include_depth);\n+\n   if (CPP_OPTION (pfile, print_deps_missing_files) && print_dep)\n     {\n       if (!angle_brackets || IS_ABSOLUTE_PATHNAME (fname))"}]}