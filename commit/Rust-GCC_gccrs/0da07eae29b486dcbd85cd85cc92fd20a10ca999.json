{"sha": "0da07eae29b486dcbd85cd85cc92fd20a10ca999", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhMDdlYWUyOWI0ODZkY2JkODVjZDg1Y2M5MmZkMjBhMTBjYTk5OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:26:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-12-08T11:26:20Z"}, "message": "decl.c (maybe_pad_type): Use TYPE_SIZE_UNIT of the input type for TYPE_SIZE_UNIT of result type if...\n\n\t* decl.c (maybe_pad_type): Use TYPE_SIZE_UNIT of the input type for\n\tTYPE_SIZE_UNIT of result type if SIZE is not specified.\n\t(make_aligning_type): Pass -1 as ADDRESSABLE to prevent the creation\n\tof a bitfield, which we know is useless and causes trouble because of\n\talignment implications.\n\n\t* utils.c (create_var_decl): Set DECL_COMMON again on targets without\n\tBSS sections.\n\t(process_attributes): Clear DECL_COMMON again when a section attribute\n\tis present.\n\t(finish_record_type): Independently track if RECORD_TYPE has SIZE and/or\n\tSIZE_UNIT already set and use to compute final SIZE and SIZE_UNIT.\n\t(create_field_decl): Special case ADDRESSABLE negative to mean\n\t\"no bitfield creation\", to be used by make_aligning_type. Don't\n\trestrict bitfield creation to !ADDRESSABLE any more, as some BLKmode\n\tfields claimed addressable still have to be bitfields. Use\n\tvalue_factor_p instead of a raw binop construction to check for the\n\tposition's alignment.\n\nFrom-SVN: r91879", "tree": {"sha": "86e8b03a0b8b8a40bb0b8af7e1f70a28d75256c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86e8b03a0b8b8a40bb0b8af7e1f70a28d75256c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0da07eae29b486dcbd85cd85cc92fd20a10ca999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da07eae29b486dcbd85cd85cc92fd20a10ca999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0da07eae29b486dcbd85cd85cc92fd20a10ca999", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0da07eae29b486dcbd85cd85cc92fd20a10ca999/comments", "author": null, "committer": null, "parents": [{"sha": "a4c1cd80655ef876d7f8ff5944999492647ebab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4c1cd80655ef876d7f8ff5944999492647ebab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4c1cd80655ef876d7f8ff5944999492647ebab5"}], "stats": {"total": 82, "additions": 46, "deletions": 36}, "files": [{"sha": "eebb7cb91b456d79502f7127c3d8c97b6c745b77", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da07eae29b486dcbd85cd85cc92fd20a10ca999/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da07eae29b486dcbd85cd85cc92fd20a10ca999/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=0da07eae29b486dcbd85cd85cc92fd20a10ca999", "patch": "@@ -4618,7 +4618,6 @@ make_aligning_type (tree type, int align, tree size)\n   /* The bit position is obtained by \"and\"ing the alignment minus 1\n      with the two's complement of the address and  multiplying\n      by the number of bits per unit.  Do all this in sizetype.  */\n-\n   pos = size_binop (MULT_EXPR,\n \t\t    convert (bitsizetype,\n \t\t\t     size_binop (BIT_AND_EXPR,\n@@ -4628,9 +4627,13 @@ make_aligning_type (tree type, int align, tree size)\n \t\t\t\t\t\t    - 1))),\n \t\t    bitsize_unit_node);\n \n-  field = create_field_decl (get_identifier (\"F\"), type, record_type,\n-\t\t\t     1, size, pos, 1);\n-  DECL_BIT_FIELD (field) = 0;\n+  /* Create the field, with -1 as the 'addressable' indication to avoid the\n+     creation of a bitfield.  We don't need one, it would have damaging\n+     consequences on the alignment computation, and create_field_decl would\n+     make one without this special argument, for instance because of the\n+     complex position expression.  */\n+  field = create_field_decl (get_identifier (\"F\"), type, record_type, 1, size,\n+\t\t\t     pos, -1);\n \n   finish_record_type (record_type, field, true, false);\n   TYPE_ALIGN (record_type) = BIGGEST_ALIGNMENT;\n@@ -4822,9 +4825,10 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   DECL_INTERNAL_P (field) = 1;\n   TYPE_SIZE (record) = size ? size : orig_size;\n   TYPE_SIZE_UNIT (record)\n-    = convert (sizetype,\n-\t       size_binop (CEIL_DIV_EXPR, TYPE_SIZE (record),\n-\t\t\t   bitsize_unit_node));\n+    = (size ? convert (sizetype,\n+\t\t       size_binop (CEIL_DIV_EXPR, size, bitsize_unit_node))\n+       : TYPE_SIZE_UNIT (type));\n+\n   TYPE_ALIGN (record) = align;\n   TYPE_IS_PADDING_P (record) = 1;\n   TYPE_VOLATILE (record)"}, {"sha": "7be9d975479db31139f0929dc89cd3ce3fc5eb41", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0da07eae29b486dcbd85cd85cc92fd20a10ca999/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0da07eae29b486dcbd85cd85cc92fd20a10ca999/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=0da07eae29b486dcbd85cd85cc92fd20a10ca999", "patch": "@@ -740,6 +740,8 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n   tree ada_size = bitsize_zero_node;\n   tree size = bitsize_zero_node;\n   bool var_size = false;\n+  bool had_size = TYPE_SIZE (record_type) != 0;\n+  bool had_size_unit = TYPE_SIZE_UNIT (record_type) != 0;\n   tree field;\n \n   TYPE_FIELDS (record_type) = fieldlist;\n@@ -757,11 +759,12 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n     {\n       TYPE_ALIGN (record_type) = MAX (BITS_PER_UNIT, TYPE_ALIGN (record_type));\n       TYPE_MODE (record_type) = BLKmode;\n-      if (!TYPE_SIZE (record_type))\n-\t{\n-\t  TYPE_SIZE (record_type) = bitsize_zero_node;\n+\n+      if (!had_size_unit)\n \t  TYPE_SIZE_UNIT (record_type) = size_zero_node;\n-\t}\n+\n+      if (!had_size)\n+\tTYPE_SIZE (record_type) = bitsize_zero_node;\n       /* For all-repped records with a size specified, lay the QUAL_UNION_TYPE\n \t out just like a UNION_TYPE, since the size will be fixed.  */\n       else if (code == QUAL_UNION_TYPE)\n@@ -881,18 +884,14 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \n   if (has_rep)\n     {\n-      if (!(TREE_CODE (record_type) == RECORD_TYPE\n-\t    && TYPE_IS_PADDING_P (record_type)\n-\t    && CONTAINS_PLACEHOLDER_P (size)))\n-\t{\n-\t  tree size_unit\n-\t    = convert (sizetype, size_binop (CEIL_DIV_EXPR, size,\n-\t\t\t\t\t     bitsize_unit_node));\n-\t  TYPE_SIZE (record_type) = round_up (size, TYPE_ALIGN (record_type));\n-\t  TYPE_SIZE_UNIT (record_type)\n-\t    = round_up (size_unit,\n-\t\t\tTYPE_ALIGN (record_type) / BITS_PER_UNIT);\n-\t}\n+      tree size_unit\n+\t= (had_size_unit ? TYPE_SIZE_UNIT (record_type)\n+\t   : convert (sizetype, size_binop (CEIL_DIV_EXPR, size,\n+\t\t\t\t\t    bitsize_unit_node)));\n+\n+      TYPE_SIZE (record_type) = round_up (size, TYPE_ALIGN (record_type));\n+      TYPE_SIZE_UNIT (record_type)\n+\t= round_up (size_unit, TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n \n       compute_record_mode (record_type);\n     }\n@@ -1339,6 +1338,13 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n       || (type_annotate_only && var_init && !TREE_CONSTANT (var_init)))\n     var_init = NULL_TREE;\n \n+  /* Ada doesn't feature Fortran-like COMMON variables so we shouldn't\n+     try to fiddle with DECL_COMMON.  However, on platforms that don't\n+     support global BSS sections, uninitialized global variables would\n+     go in DATA instead, thus increasing the size of the executable.  */\n+#if !defined(ASM_OUTPUT_BSS) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n+  DECL_COMMON   (var_decl) = !flag_no_common;\n+#endif\n   DECL_INITIAL  (var_decl) = var_init;\n   TREE_READONLY (var_decl) = const_flag;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n@@ -1376,7 +1382,8 @@ create_var_decl (tree var_name, tree asm_name, tree type, tree var_init,\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n    it is the specified size for this field.  If POS is nonzero, it is the bit\n    position.  If ADDRESSABLE is nonzero, it means we are allowed to take\n-   the address of this field for aliasing purposes.  */\n+   the address of this field for aliasing purposes. If it is negative, we\n+   should not make a bitfield, which is used by make_aligning_type.   */\n \n tree\n create_field_decl (tree field_name, tree field_type, tree record_type,\n@@ -1410,29 +1417,27 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n         size = round_up (size, BITS_PER_UNIT);\n     }\n \n-  /* Make a bitfield if a size is specified for two reasons: first if the size\n-     differs from the natural size.  Second, if the alignment is insufficient.\n-     There are a number of ways the latter can be true.\n+  /* If we may, according to ADDRESSABLE, make a bitfield if a size is\n+     specified for two reasons: first if the size differs from the natural\n+     size.  Second, if the alignment is insufficient.  There are a number of\n+     ways the latter can be true.\n \n      We never make a bitfield if the type of the field has a nonconstant size,\n-     or if it is claimed to be addressable, because no such entity requiring\n-     bitfield operations should reach here.\n+     because no such entity requiring bitfield operations should reach here.\n \n      We do *preventively* make a bitfield when there might be the need for it\n      but we don't have all the necessary information to decide, as is the case\n      of a field with no specified position in a packed record.\n \n      We also don't look at STRICT_ALIGNMENT here, and rely on later processing\n      in layout_decl or finish_record_type to clear the bit_field indication if\n-     it is in fact not needed. */\n-  if (size && TREE_CODE (size) == INTEGER_CST\n+     it is in fact not needed.  */\n+  if (addressable >= 0\n+      && size\n+      && TREE_CODE (size) == INTEGER_CST\n       && TREE_CODE (TYPE_SIZE (field_type)) == INTEGER_CST\n-      && !addressable\n       && (!operand_equal_p (TYPE_SIZE (field_type), size, 0)\n-\t  || (pos\n-\t      && !value_zerop (size_binop (TRUNC_MOD_EXPR, pos,\n-\t\t\t\t\t   bitsize_int (TYPE_ALIGN\n-\t\t\t\t\t\t\t(field_type)))))\n+\t  || (pos && !value_factor_p (pos, TYPE_ALIGN (field_type)))\n \t  || packed\n \t  || (TYPE_ALIGN (record_type) != 0\n \t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (field_type))))\n@@ -1588,6 +1593,7 @@ process_attributes (tree decl, struct attrib *attr_list)\n \t    DECL_SECTION_NAME (decl)\n \t      = build_string (IDENTIFIER_LENGTH (attr_list->name),\n \t\t\t      IDENTIFIER_POINTER (attr_list->name));\n+\t    DECL_COMMON (decl) = 0;\n \t  }\n \telse\n \t  post_error (\"?section attributes are not supported for this target\","}]}