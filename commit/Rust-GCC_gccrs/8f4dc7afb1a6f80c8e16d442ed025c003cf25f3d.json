{"sha": "8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0ZGM3YWZiMWE2ZjgwYzhlMTZkNDQyZWQwMjVjMDAzY2YyNWYzZA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-05-18T20:24:32Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-05-18T20:24:32Z"}, "message": "re PR libfortran/21127 (reshape of complex broken)\n\n2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/21127\n        * Makefile.am:  Add generated/reshape_c4.c and\n        generated/reshape_c8.c.\n        * Makefile.in:  Regenerated.\n        * m4/iparm.m4:  Define rtype_ccode to be c4 or c8 for\n        complex types, 4 or 8 otherwise.\n        * m4/reshape.m4:  Use rtype_ccode instead of rtype_kind\n        in function name.\n        * generated/reshape_c4.c: New file.\n        * generated/reshape_c8.c: New file.\n\n2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/21127\n        * fortran/iresolve.c (gfc_resolve_reshape): Add\n        gfc_type_letter (BT_COMPLEX) for complex to\n        to resolved function name.\n\n2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n\n        PR libfortran/21127\n        * gfortran.dg/reshape-complex.f90:  New test.\n\nFrom-SVN: r99925", "tree": {"sha": "a66bc7623de0b253a4f3ae529a58a4948e04f604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a66bc7623de0b253a4f3ae529a58a4948e04f604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/comments", "author": null, "committer": null, "parents": [{"sha": "565d8a378f62e7c46273908cbd370873a218808b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/565d8a378f62e7c46273908cbd370873a218808b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/565d8a378f62e7c46273908cbd370873a218808b"}], "stats": {"total": 569, "additions": 564, "deletions": 5}, "files": [{"sha": "87e10472d98105431eeb295dbd3d07a0fe83e2d9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -1,3 +1,10 @@\n+2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/21127\n+\t* fortran/iresolve.c (gfc_resolve_reshape): Add \n+\tgfc_type_letter (BT_COMPLEX) for complex to\n+\tto resolved function name.\n+\n 2005-05-18 Erik Edelmann <erik.edelmann@iki.fi>\n \n \t* array.c (gfc_match_array_constructor): Support [ ... ]"}, {"sha": "e9392871fef4c4c2794e14152f93405707d1ae93", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -1137,8 +1137,14 @@ gfc_resolve_reshape (gfc_expr * f, gfc_expr * source, gfc_expr * shape,\n     case 4:\n     case 8:\n     /* case 16: */\n-      f->value.function.name =\n-\tgfc_get_string (PREFIX(\"reshape_%d\"), source->ts.kind);\n+      if (source->ts.type == BT_COMPLEX)\n+\tf->value.function.name =\n+\t  gfc_get_string (PREFIX(\"reshape_%c%d\"),\n+\t\t\t  gfc_type_letter (BT_COMPLEX), source->ts.kind);\n+      else\n+\tf->value.function.name =\n+\t  gfc_get_string (PREFIX(\"reshape_%d\"), source->ts.kind);\n+\n       break;\n \n     default:"}, {"sha": "74b37015dc074df02137c5471163e843aca82bb1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -1,3 +1,8 @@\n+2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/21127\n+\t* gfortran.dg/reshape-complex.f90:  New test.\n+\n 2005-05-18  Erik Edelmann  <erik.edelmann@iki.fi>\n \n \t* gfortran.dg/array_constructor_1.f90: New test."}, {"sha": "87c80498494893a02dada88f69c555aca1149017", "filename": "gcc/testsuite/gfortran.dg/reshape-complex.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape-complex.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape-complex.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape-complex.f90?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+! PR 21127:  Reshape of complex didn't work.\n+program main\n+  complex, dimension(8) :: b\n+  complex, dimension(2,2) :: a\n+  integer :: i\n+  b = (/(i,i=1,8)/)\n+  a = reshape(b(1:8:2),shape(a))\n+  if (a(1,1) /= (1.0, 0.0) .or. a(2,1) /= (3.0, 0.0) .or.  &\n+      a(1,2) /= (5.0, 0.0) .or. a(2,2) /= (7.0, 0.0)) call abort\n+end"}, {"sha": "f2e7bfdd7aefea2ebb8ed29a494c5a5d225595fd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -1,3 +1,16 @@\n+2005-05-18  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/21127\n+\t* Makefile.am:  Add generated/reshape_c4.c and\n+\tgenerated/reshape_c8.c.\n+\t* Makefile.in:  Regenerated.\n+\t* m4/iparm.m4:  Define rtype_ccode to be c4 or c8 for\n+\tcomplex types, 4 or 8 otherwise.\n+\t* m4/reshape.m4:  Use rtype_ccode instead of rtype_kind\n+\tin function name.\n+\t* generated/reshape_c4.c: New file.\n+\t* generated/reshape_c8.c: New file.\n+\n 2005-05-16  Andreas Jaeger  <aj@suse.de>\n \n \t* configure.ac: Add additional warning flags."}, {"sha": "02d73d258d1a1948ce196a3e312fc49116c56fd7", "filename": "libgfortran/generated/reshape_c4.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fgenerated%2Freshape_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fgenerated%2Freshape_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c4.c?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the RESHAPE\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+/* The shape parameter is ignored. We can currently deduce the shape from the\n+   return array.  */\n+\n+extern void reshape_c4 (gfc_array_c4 *, gfc_array_c4 *, shape_type *,\n+\t\t\t\t    gfc_array_c4 *, shape_type *);\n+export_proto(reshape_c4);\n+\n+void\n+reshape_c4 (gfc_array_c4 * ret, gfc_array_c4 * source, shape_type * shape,\n+                      gfc_array_c4 * pad, shape_type * order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_COMPLEX_4 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_COMPLEX_4 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_COMPLEX_4 *pptr;\n+\n+  const GFC_COMPLEX_4 *src;\n+  int n;\n+  int dim;\n+\n+  if (source->dim[0].stride == 0)\n+    source->dim[0].stride = 1;\n+  if (shape->dim[0].stride == 0)\n+    shape->dim[0].stride = 1;\n+  if (pad && pad->dim[0].stride == 0)\n+    pad->dim[0].stride = 1;\n+  if (order && order->dim[0].stride == 0)\n+    order->dim[0].stride = 1;\n+\n+  if (ret->data == NULL)\n+    {\n+      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+      rs = 1;\n+      for (n=0; n < rdim; n++)\n+\t{\n+\t  ret->dim[n].lbound = 0;\n+\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  ret->dim[n].ubound =  rex - 1;\n+\t  ret->dim[n].stride = rs;\n+\t  rs *= rex;\n+\t}\n+      ret->base = 0;\n+      ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_4));\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n+    }\n+  else\n+    {\n+      rdim = GFC_DESCRIPTOR_RANK (ret);\n+      if (ret->dim[0].stride == 0)\n+\tret->dim[0].stride = 1;\n+    }\n+\n+  rsize = 1;\n+  for (n = 0; n < rdim; n++)\n+    {\n+      if (order)\n+        dim = order->data[n * order->dim[0].stride] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = ret->dim[dim].stride;\n+      rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+\n+      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  for (n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = source->dim[n].stride;\n+      sextent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (sextent[n] <= 0)\n+        abort ();\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      for (n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = pad->dim[n].stride;\n+          pextent[n] = pad->dim[n].ubound + 1 - pad->dim[n].lbound;\n+          if (pextent[n] <= 0)\n+            abort ();\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->data;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= 4;\n+      ssize *= 4;\n+      psize *= 4;\n+      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n+\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->data;\n+  src = sptr = source->data;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+      /* Advance to the next destination element.  */\n+      n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}"}, {"sha": "e6ddf1a1bb9fb15e9287a90e092eeecc20ab3964", "filename": "libgfortran/generated/reshape_c8.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fgenerated%2Freshape_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fgenerated%2Freshape_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c8.c?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -0,0 +1,258 @@\n+/* Implementation of the RESHAPE\n+   Copyright 2002 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include \"libgfortran.h\"\n+\n+typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+/* The shape parameter is ignored. We can currently deduce the shape from the\n+   return array.  */\n+\n+extern void reshape_c8 (gfc_array_c8 *, gfc_array_c8 *, shape_type *,\n+\t\t\t\t    gfc_array_c8 *, shape_type *);\n+export_proto(reshape_c8);\n+\n+void\n+reshape_c8 (gfc_array_c8 * ret, gfc_array_c8 * source, shape_type * shape,\n+                      gfc_array_c8 * pad, shape_type * order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_COMPLEX_8 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_COMPLEX_8 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_COMPLEX_8 *pptr;\n+\n+  const GFC_COMPLEX_8 *src;\n+  int n;\n+  int dim;\n+\n+  if (source->dim[0].stride == 0)\n+    source->dim[0].stride = 1;\n+  if (shape->dim[0].stride == 0)\n+    shape->dim[0].stride = 1;\n+  if (pad && pad->dim[0].stride == 0)\n+    pad->dim[0].stride = 1;\n+  if (order && order->dim[0].stride == 0)\n+    order->dim[0].stride = 1;\n+\n+  if (ret->data == NULL)\n+    {\n+      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+      rs = 1;\n+      for (n=0; n < rdim; n++)\n+\t{\n+\t  ret->dim[n].lbound = 0;\n+\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  ret->dim[n].ubound =  rex - 1;\n+\t  ret->dim[n].stride = rs;\n+\t  rs *= rex;\n+\t}\n+      ret->base = 0;\n+      ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_8));\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n+    }\n+  else\n+    {\n+      rdim = GFC_DESCRIPTOR_RANK (ret);\n+      if (ret->dim[0].stride == 0)\n+\tret->dim[0].stride = 1;\n+    }\n+\n+  rsize = 1;\n+  for (n = 0; n < rdim; n++)\n+    {\n+      if (order)\n+        dim = order->data[n * order->dim[0].stride] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = ret->dim[dim].stride;\n+      rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+\n+      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  for (n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = source->dim[n].stride;\n+      sextent[n] = source->dim[n].ubound + 1 - source->dim[n].lbound;\n+      if (sextent[n] <= 0)\n+        abort ();\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      for (n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = pad->dim[n].stride;\n+          pextent[n] = pad->dim[n].ubound + 1 - pad->dim[n].lbound;\n+          if (pextent[n] <= 0)\n+            abort ();\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->data;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= 8;\n+      ssize *= 8;\n+      psize *= 8;\n+      reshape_packed ((char *)ret->data, rsize, (char *)source->data,\n+\t\t      ssize, pad ? (char *)pad->data : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->data;\n+  src = sptr = source->data;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+      /* Advance to the next destination element.  */\n+      n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so proabably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}"}, {"sha": "810f78c342880cc8a70f2105e8de45f52ef1ee6a", "filename": "libgfortran/m4/iparm.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fm4%2Fiparm.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fm4%2Fiparm.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparm.m4?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -30,3 +30,4 @@ define(rtype_qual,`_'rtype_kind)dnl\n define(atype_max, atype_name`_HUGE')dnl\n define(atype_min, `-'atype_max)dnl\n define(name, regexp(regexp(file, `[^/]*$', `\\&'), `^\\([^_]*\\)_', `\\1'))dnl\n+define(rtype_ccode,ifelse(rtype_letter,`c',rtype_code,rtype_kind))dnl"}, {"sha": "6b411f001ad504e73431b66b41514cde5f275e64", "filename": "libgfortran/m4/reshape.m4", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fm4%2Freshape.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d/libgfortran%2Fm4%2Freshape.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Freshape.m4?ref=8f4dc7afb1a6f80c8e16d442ed025c003cf25f3d", "patch": "@@ -40,12 +40,12 @@ typedef GFC_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n    return array.  */\n dnl Only the kind (ie size) is used to name the function.\n \n-extern void reshape_`'rtype_kind (rtype *, rtype *, shape_type *,\n+extern void reshape_`'rtype_ccode (rtype *, rtype *, shape_type *,\n \t\t\t\t    rtype *, shape_type *);\n-export_proto(reshape_`'rtype_kind);\n+export_proto(reshape_`'rtype_ccode);\n \n void\n-reshape_`'rtype_kind (rtype * ret, rtype * source, shape_type * shape,\n+reshape_`'rtype_ccode (rtype * ret, rtype * source, shape_type * shape,\n                       rtype * pad, shape_type * order)\n {\n   /* r.* indicates the return array.  */"}]}