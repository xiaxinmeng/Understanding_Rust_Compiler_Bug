{"sha": "73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxNjBiYTlkYzdiZTM2N2Q5MWYyODZlYjViMDdjYjhhZjRhNzliYw==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2010-07-03T01:00:37Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2010-07-03T01:00:37Z"}, "message": "arm.c (arm_canonicalize_comparison): Canonicalize DImode comparisons.\n\n2010-07-02  Daniel Jacobowitz  <dan@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Sandra Loosemore <sandra@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (arm_canonicalize_comparison): Canonicalize DImode\n\tcomparisons.  Adjust to take both operands.\n\t(arm_select_cc_mode): Handle DImode comparisons.\n\t(arm_gen_compare_reg): Generate a scratch register for DImode\n\tcomparisons which require one.  Use xor for Thumb equality checks.\n\t(arm_const_double_by_immediates): New.\n\t(arm_print_operand): Allow 'Q' and 'R' for constants.\n\t(get_arm_condition_code): Handle new CC_CZmode and CC_NCVmode.\n\t* config/arm/arm.h (CANONICALIZE_COMPARISON): Always use\n\tarm_canonicalize_comparison.\n\t* config/arm/arm-modes.def: Add CC_CZmode and CC_NCVmode.\n\t* config/arm/arm-protos.h (arm_canonicalize_comparison): Update\n\tprototype.\n\t(arm_const_double_by_immediates): Declare.\n\t* config/arm/constraints.md (Di): New constraint.\n\t* config/arm/predicates.md (arm_immediate_di_operand)\n\t(arm_di_operand, cmpdi_operand): New.\n\t* config/arm/arm.md (cbranchdi4): Handle non-Cirrus also.\n\t(*arm_cmpdi_insn, *arm_cmpdi_unsigned)\n\t(*arm_cmpdi_zero, *thumb_cmpdi_zero): New insns.\n\t(cstoredi4): Handle non-Cirrus also.\n\n\tgcc/testsuite/\n\t* gcc.c-torture/execute/20100416-1.c: New test case.\n\n\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r161764", "tree": {"sha": "a0af68d8ac04351704260ecd0693e4526a5d9616", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0af68d8ac04351704260ecd0693e4526a5d9616"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/comments", "author": null, "committer": null, "parents": [{"sha": "400cfcf50e5aeae792e8ef39a743b1cb6fafedd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400cfcf50e5aeae792e8ef39a743b1cb6fafedd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400cfcf50e5aeae792e8ef39a743b1cb6fafedd5"}], "stats": {"total": 485, "additions": 448, "deletions": 37}, "files": [{"sha": "7aa661884d8217739d92a78664f6576a2881e2ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -1,3 +1,29 @@\n+2010-07-02  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Sandra Loosemore <sandra@codesourcery.com>\n+\n+\t* config/arm/arm.c (arm_canonicalize_comparison): Canonicalize DImode\n+\tcomparisons.  Adjust to take both operands.\n+\t(arm_select_cc_mode): Handle DImode comparisons.\n+\t(arm_gen_compare_reg): Generate a scratch register for DImode\n+\tcomparisons which require one.  Use xor for Thumb equality checks.\n+\t(arm_const_double_by_immediates): New.\n+\t(arm_print_operand): Allow 'Q' and 'R' for constants.\n+\t(get_arm_condition_code): Handle new CC_CZmode and CC_NCVmode.\n+\t* config/arm/arm.h (CANONICALIZE_COMPARISON): Always use\n+\tarm_canonicalize_comparison.\n+\t* config/arm/arm-modes.def: Add CC_CZmode and CC_NCVmode.\n+\t* config/arm/arm-protos.h (arm_canonicalize_comparison): Update\n+\tprototype.\n+\t(arm_const_double_by_immediates): Declare.\n+\t* config/arm/constraints.md (Di): New constraint.\n+\t* config/arm/predicates.md (arm_immediate_di_operand)\n+\t(arm_di_operand, cmpdi_operand): New.\n+\t* config/arm/arm.md (cbranchdi4): Handle non-Cirrus also.\n+\t(*arm_cmpdi_insn, *arm_cmpdi_unsigned)\n+\t(*arm_cmpdi_zero, *thumb_cmpdi_zero): New insns.\n+\t(cstoredi4): Handle non-Cirrus also.\n+\n 2010-07-02  Julian Brown  <julian@codesourcery.com>\n \t    Sandra Loosemore <sandra@codesourcery.com>\n "}, {"sha": "e9825edb18e03fd4c7c6200cf05def03b7b5420b", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -39,10 +39,16 @@ ADJUST_FLOAT_FORMAT (HF, ((arm_fp16_format == ARM_FP16_FORMAT_ALTERNATIVE)\n    CC_NOTBmode should be used if only the C flag is set as a not-borrow\n      flag, after a subtraction.\n    CC_Nmode should be used if only the N (sign) flag is set correctly\n+   CC_CZmode should be used if only the C and Z flags are correct\n+   (used for DImode unsigned comparisons).\n+   CC_NCVmode should be used if only the N, C, and V flags are correct\n+   (used for DImode signed comparisons).\n    CCmode should be used otherwise.  */\n \n CC_MODE (CC_NOOV);\n CC_MODE (CC_Z);\n+CC_MODE (CC_CZ);\n+CC_MODE (CC_NCV);\n CC_MODE (CC_SWP);\n CC_MODE (CCFP);\n CC_MODE (CCFPE);"}, {"sha": "40d0f93a59398f76fbe805f98321f560d437aedd", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -50,8 +50,7 @@ extern int arm_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int arm_split_constant (RTX_CODE, enum machine_mode, rtx,\n \t\t\t       HOST_WIDE_INT, rtx, rtx, int);\n-extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, enum machine_mode,\n-\t\t\t\t\t     rtx *);\n+extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *, rtx *);\n extern int legitimate_pic_operand_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx, rtx);\n@@ -117,6 +116,7 @@ extern void arm_reload_in_hi (rtx *);\n extern void arm_reload_out_hi (rtx *);\n extern int arm_const_double_inline_cost (rtx);\n extern bool arm_const_double_by_parts (rtx);\n+extern bool arm_const_double_by_immediates (rtx);\n extern const char *fp_immediate_constant (rtx);\n extern void arm_emit_call_insn (rtx, rtx);\n extern const char *output_call (rtx *);"}, {"sha": "f59c1fcd3f9790b2cfe085fc70a5ef71d7b70ce6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 227, "deletions": 8, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -3183,13 +3183,82 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n    immediate value easier to load.  */\n \n enum rtx_code\n-arm_canonicalize_comparison (enum rtx_code code, enum machine_mode mode,\n-\t\t\t     rtx * op1)\n+arm_canonicalize_comparison (enum rtx_code code, rtx *op0, rtx *op1)\n {\n-  unsigned HOST_WIDE_INT i = INTVAL (*op1);\n-  unsigned HOST_WIDE_INT maxval;\n+  enum machine_mode mode;\n+  unsigned HOST_WIDE_INT i, maxval;\n+\n+  mode = GET_MODE (*op0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (*op1);\n+\n   maxval = (((unsigned HOST_WIDE_INT) 1) << (GET_MODE_BITSIZE(mode) - 1)) - 1;\n \n+  /* For DImode, we have GE/LT/GEU/LTU comparisons.  In ARM mode\n+     we can also use cmp/cmpeq for GTU/LEU.  GT/LE must be either\n+     reversed or (for constant OP1) adjusted to GE/LT.  Similarly\n+     for GTU/LEU in Thumb mode.  */\n+  if (mode == DImode)\n+    {\n+      rtx tem;\n+\n+      /* To keep things simple, always use the Cirrus cfcmp64 if it is\n+\t available.  */\n+      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)\n+\treturn code;\n+\n+      if (code == GT || code == LE\n+\t  || (!TARGET_ARM && (code == GTU || code == LEU)))\n+\t{\n+\t  /* Missing comparison.  First try to use an available\n+\t     comparison.  */\n+\t  if (GET_CODE (*op1) == CONST_INT)\n+\t    {\n+\t      i = INTVAL (*op1);\n+\t      switch (code)\n+\t\t{\n+\t\tcase GT:\n+\t\tcase LE:\n+\t\t  if (i != maxval\n+\t\t      && arm_const_double_by_immediates (GEN_INT (i + 1)))\n+\t\t    {\n+\t\t      *op1 = GEN_INT (i + 1);\n+\t\t      return code == GT ? GE : LT;\n+\t\t    }\n+\t\t  break;\n+\t\tcase GTU:\n+\t\tcase LEU:\n+\t\t  if (i != ~((unsigned HOST_WIDE_INT) 0)\n+\t\t      && arm_const_double_by_immediates (GEN_INT (i + 1)))\n+\t\t    {\n+\t\t      *op1 = GEN_INT (i + 1);\n+\t\t      return code == GTU ? GEU : LTU;\n+\t\t    }\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\n+\t  /* If that did not work, reverse the condition.  */\n+\t  tem = *op0;\n+\t  *op0 = *op1;\n+\t  *op1 = tem;\n+\t  return swap_condition (code);\n+\t}\n+\n+      return code;\n+    }\n+\n+  /* Comparisons smaller than DImode.  Only adjust comparisons against\n+     an out-of-range constant.  */\n+  if (GET_CODE (*op1) != CONST_INT\n+      || const_ok_for_arm (INTVAL (*op1))\n+      || const_ok_for_arm (- INTVAL (*op1)))\n+    return code;\n+\n+  i = INTVAL (*op1);\n+\n   switch (code)\n     {\n     case EQ:\n@@ -10014,6 +10083,55 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n       && (rtx_equal_p (XEXP (x, 0), y) || rtx_equal_p (XEXP (x, 1), y)))\n     return CC_Cmode;\n \n+  if (GET_MODE (x) == DImode || GET_MODE (y) == DImode)\n+    {\n+      /* To keep things simple, always use the Cirrus cfcmp64 if it is\n+\t available.  */\n+      if (TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK)\n+\treturn CCmode;\n+\n+      switch (op)\n+\t{\n+\tcase EQ:\n+\tcase NE:\n+\t  /* A DImode comparison against zero can be implemented by\n+\t     or'ing the two halves together.  */\n+\t  if (y == const0_rtx)\n+\t    return CC_Zmode;\n+\n+\t  /* We can do an equality test in three Thumb instructions.  */\n+\t  if (!TARGET_ARM)\n+\t    return CC_Zmode;\n+\n+\t  /* FALLTHROUGH */\n+\n+\tcase LTU:\n+\tcase LEU:\n+\tcase GTU:\n+\tcase GEU:\n+\t  /* DImode unsigned comparisons can be implemented by cmp +\n+\t     cmpeq without a scratch register.  Not worth doing in\n+\t     Thumb-2.  */\n+\t  if (TARGET_ARM)\n+\t    return CC_CZmode;\n+\n+\t  /* FALLTHROUGH */\n+\n+\tcase LT:\n+\tcase LE:\n+\tcase GT:\n+\tcase GE:\n+\t  /* DImode signed and unsigned comparisons can be implemented\n+\t     by cmp + sbcs with a scratch register, but that does not\n+\t     set the Z flag - we must reverse GT/LE/GTU/LEU.  */\n+\t  gcc_assert (op != EQ && op != NE);\n+\t  return CC_NCVmode;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n   return CCmode;\n }\n \n@@ -10023,10 +10141,39 @@ arm_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n rtx\n arm_gen_compare_reg (enum rtx_code code, rtx x, rtx y)\n {\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  enum machine_mode mode;\n+  rtx cc_reg;\n+  int dimode_comparison = GET_MODE (x) == DImode || GET_MODE (y) == DImode;\n+\n+  /* We might have X as a constant, Y as a register because of the predicates\n+     used for cmpdi.  If so, force X to a register here.  */\n+  if (dimode_comparison && !REG_P (x))\n+    x = force_reg (DImode, x);\n+\n+  mode = SELECT_CC_MODE (code, x, y);\n+  cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+\n+  if (dimode_comparison\n+      && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\n+      && mode != CC_CZmode)\n+    {\n+      rtx clobber, set;\n \n-  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+      /* To compare two non-zero values for equality, XOR them and\n+\t then compare against zero.  Not used for ARM mode; there\n+\t CC_CZmode is cheaper.  */\n+      if (mode == CC_Zmode && y != const0_rtx)\n+\t{\n+\t  x = expand_binop (DImode, xor_optab, x, y, NULL_RTX, 0, OPTAB_WIDEN);\n+\t  y = const0_rtx;\n+\t}\n+      /* A scratch register is required.  */\n+      clobber = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (SImode));\n+      set = gen_rtx_SET (VOIDmode, cc_reg, gen_rtx_COMPARE (mode, x, y));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set, clobber)));\n+    }\n+  else\n+    emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n \n   return cc_reg;\n }\n@@ -11355,6 +11502,34 @@ arm_const_double_by_parts (rtx val)\n   return false;\n }\n \n+/* Return true if it is possible to inline both the high and low parts\n+   of a 64-bit constant into 32-bit data processing instructions.  */\n+bool\n+arm_const_double_by_immediates (rtx val)\n+{\n+  enum machine_mode mode = GET_MODE (val);\n+  rtx part;\n+\n+  if (mode == VOIDmode)\n+    mode = DImode;\n+\n+  part = gen_highpart_mode (SImode, mode, val);\n+\n+  gcc_assert (GET_CODE (part) == CONST_INT);\n+\n+  if (!const_ok_for_arm (INTVAL (part)))\n+    return false;\n+\n+  part = gen_lowpart (SImode, val);\n+\n+  gcc_assert (GET_CODE (part) == CONST_INT);\n+\n+  if (!const_ok_for_arm (INTVAL (part)))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Scan INSN and note any of its operands that need fixing.\n    If DO_PUSHES is false we do not actually push any of the fixups\n    needed.  The function returns TRUE if any fixups were needed/pushed.\n@@ -15256,8 +15431,18 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t the value being loaded is big-wordian or little-wordian.  The\n \t order of the two register loads can matter however, if the address\n \t of the memory location is actually held in one of the registers\n-\t being overwritten by the load.  */\n+\t being overwritten by the load.\n+\n+\t The 'Q' and 'R' constraints are also available for 64-bit\n+\t constants.  */\n     case 'Q':\n+      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  rtx part = gen_lowpart (SImode, x);\n+\t  fprintf (stream, \"#\" HOST_WIDE_INT_PRINT_DEC, INTVAL (part));\n+\t  return;\n+\t}\n+\n       if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n@@ -15268,6 +15453,18 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       return;\n \n     case 'R':\n+      if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+\t{\n+\t  enum machine_mode mode = GET_MODE (x);\n+\t  rtx part;\n+\n+\t  if (mode == VOIDmode)\n+\t    mode = DImode;\n+\t  part = gen_highpart_mode (SImode, mode, x);\n+\t  fprintf (stream, \"#\" HOST_WIDE_INT_PRINT_DEC, INTVAL (part));\n+\t  return;\n+\t}\n+\n       if (GET_CODE (x) != REG || REGNO (x) > LAST_ARM_REGNUM)\n \t{\n \t  output_operand_lossage (\"invalid operand for code '%c'\", code);\n@@ -16102,6 +16299,28 @@ get_arm_condition_code (rtx comparison)\n \tdefault: gcc_unreachable ();\n \t}\n \n+    case CC_CZmode:\n+      switch (comp_code)\n+\t{\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase GEU: return ARM_CS;\n+\tcase GTU: return ARM_HI;\n+\tcase LEU: return ARM_LS;\n+\tcase LTU: return ARM_CC;\n+\tdefault: gcc_unreachable ();\n+\t}\n+\n+    case CC_NCVmode:\n+      switch (comp_code)\n+\t{\n+\tcase GE: return ARM_GE;\n+\tcase LT: return ARM_LT;\n+\tcase GEU: return ARM_CS;\n+\tcase LTU: return ARM_CC;\n+\tdefault: gcc_unreachable ();\n+\t}\n+\n     case CCmode:\n       switch (comp_code)\n \t{"}, {"sha": "cad50a85af4c18bbc80c1bbdac4303d9032f4cbf", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -2244,19 +2244,7 @@ extern int making_const_table;\n    : reverse_condition (code))\n \n #define CANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (OP1) == CONST_INT\t\t\t\t\t\\\n-          && ! (const_ok_for_arm (INTVAL (OP1))\t\t\t\t\\\n-\t        || (const_ok_for_arm (- INTVAL (OP1)))))\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          rtx const_op = OP1;\t\t\t\t\t\t\\\n-          CODE = arm_canonicalize_comparison ((CODE), GET_MODE (OP0),\t\\\n-\t\t\t\t\t      &const_op);\t\t\\\n-          OP1 = const_op;\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+  (CODE) = arm_canonicalize_comparison (CODE, &(OP0), &(OP1))\n \n /* The arm5 clz instruction returns 32.  */\n #define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)"}, {"sha": "bf91918e13ca00a9d582e1acf8c2c50e7d10fcf5", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 114, "deletions": 13, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -6593,17 +6593,45 @@\n \t\t\t\t   operands[3])); DONE;\"\n )\n \n-;; this uses the Cirrus DI compare instruction\n (define_expand \"cbranchdi4\"\n   [(set (pc) (if_then_else\n \t      (match_operator 0 \"arm_comparison_operator\"\n-\t       [(match_operand:DI 1 \"cirrus_fp_register\" \"\")\n-\t        (match_operand:DI 2 \"cirrus_fp_register\" \"\")])\n+\t       [(match_operand:DI 1 \"cmpdi_operand\" \"\")\n+\t        (match_operand:DI 2 \"cmpdi_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n-  \"emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n-\t\t\t\t   operands[3])); DONE;\"\n+  \"TARGET_32BIT\"\n+  \"{\n+     rtx swap = NULL_RTX;\n+     enum rtx_code code = GET_CODE (operands[0]);\n+\n+     /* We should not have two constants.  */\n+     gcc_assert (GET_MODE (operands[1]) == DImode\n+\t\t || GET_MODE (operands[2]) == DImode);\n+\n+    /* Flip unimplemented DImode comparisons to a form that\n+       arm_gen_compare_reg can handle.  */\n+     switch (code)\n+     {\n+     case GT:\n+       swap = gen_rtx_LT (VOIDmode, operands[2], operands[1]); break;\n+     case LE:\n+       swap = gen_rtx_GE (VOIDmode, operands[2], operands[1]); break;\n+     case GTU:\n+       swap = gen_rtx_LTU (VOIDmode, operands[2], operands[1]); break;\n+     case LEU:\n+       swap = gen_rtx_GEU (VOIDmode, operands[2], operands[1]); break;\n+     default:\n+       break;\n+     }\n+     if (swap)\n+       emit_jump_insn (gen_cbranch_cc (swap, operands[2], operands[1],\n+                                       operands[3]));\n+     else\n+       emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n+\t\t\t\t       operands[3]));\n+     DONE;\n+   }\"\n )\n \n (define_insn \"cbranchsi4_insn\"\n@@ -7767,6 +7795,52 @@\n \t\t\t\t    (const_string \"alu_shift_reg\")))]\n )\n \n+;; DImode comparisons.  The generic code generates branches that\n+;; if-conversion can not reduce to a conditional compare, so we do\n+;; that directly.\n+\n+(define_insn \"*arm_cmpdi_insn\"\n+  [(set (reg:CC_NCV CC_REGNUM)\n+\t(compare:CC_NCV (match_operand:DI 0 \"s_register_operand\" \"r\")\n+\t\t\t(match_operand:DI 1 \"arm_di_operand\"\t   \"rDi\")))\n+   (clobber (match_scratch:SI 2 \"=r\"))]\n+  \"TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_MAVERICK)\"\n+  \"cmp\\\\t%Q0, %Q1\\;sbcs\\\\t%2, %R0, %R1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n+(define_insn \"*arm_cmpdi_unsigned\"\n+  [(set (reg:CC_CZ CC_REGNUM)\n+\t(compare:CC_CZ (match_operand:DI 0 \"s_register_operand\" \"r\")\n+\t\t       (match_operand:DI 1 \"arm_di_operand\"\t\"rDi\")))]\n+  \"TARGET_ARM\"\n+  \"cmp%?\\\\t%R0, %R1\\;cmpeq\\\\t%Q0, %Q1\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"8\")]\n+)\n+\n+(define_insn \"*arm_cmpdi_zero\"\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z (match_operand:DI 0 \"s_register_operand\" \"r\")\n+\t\t      (const_int 0)))\n+   (clobber (match_scratch:SI 1 \"=r\"))]\n+  \"TARGET_32BIT\"\n+  \"orr%.\\\\t%1, %Q0, %R0\"\n+  [(set_attr \"conds\" \"set\")]\n+)\n+\n+(define_insn \"*thumb_cmpdi_zero\"\n+  [(set (reg:CC_Z CC_REGNUM)\n+\t(compare:CC_Z (match_operand:DI 0 \"s_register_operand\" \"l\")\n+\t\t      (const_int 0)))\n+   (clobber (match_scratch:SI 1 \"=l\"))]\n+  \"TARGET_THUMB1\"\n+  \"orr\\\\t%1, %Q0, %R0\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"2\")]\n+)\n+\n ;; Cirrus SF compare instruction\n (define_insn \"*cirrus_cmpsf\"\n   [(set (reg:CCFP CC_REGNUM)\n@@ -8070,18 +8144,45 @@\n \t\t\t     operands[2], operands[3])); DONE;\"\n )\n \n-;; this uses the Cirrus DI compare instruction\n (define_expand \"cstoredi4\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(match_operator:SI 1 \"arm_comparison_operator\"\n-\t [(match_operand:DI 2 \"cirrus_fp_register\" \"\")\n-\t  (match_operand:DI 3 \"cirrus_fp_register\" \"\")]))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_MAVERICK\"\n-  \"emit_insn (gen_cstore_cc (operands[0], operands[1],\n-\t\t\t     operands[2], operands[3])); DONE;\"\n+\t [(match_operand:DI 2 \"cmpdi_operand\" \"\")\n+\t  (match_operand:DI 3 \"cmpdi_operand\" \"\")]))]\n+  \"TARGET_32BIT\"\n+  \"{\n+     rtx swap = NULL_RTX;\n+     enum rtx_code code = GET_CODE (operands[1]);\n+\n+     /* We should not have two constants.  */\n+     gcc_assert (GET_MODE (operands[2]) == DImode\n+\t\t || GET_MODE (operands[3]) == DImode);\n+\n+    /* Flip unimplemented DImode comparisons to a form that\n+       arm_gen_compare_reg can handle.  */\n+     switch (code)\n+     {\n+     case GT:\n+       swap = gen_rtx_LT (VOIDmode, operands[3], operands[2]); break;\n+     case LE:\n+       swap = gen_rtx_GE (VOIDmode, operands[3], operands[2]); break;\n+     case GTU:\n+       swap = gen_rtx_LTU (VOIDmode, operands[3], operands[2]); break;\n+     case LEU:\n+       swap = gen_rtx_GEU (VOIDmode, operands[3], operands[2]); break;\n+     default:\n+       break;\n+     }\n+     if (swap)\n+       emit_insn (gen_cstore_cc (operands[0], swap, operands[3],\n+\t\t      \t         operands[2]));\n+     else\n+       emit_insn (gen_cstore_cc (operands[0], operands[1], operands[2],\n+\t\t      \t         operands[3]));\n+     DONE;\n+   }\"\n )\n \n-\n (define_expand \"cstoresi_eq0_thumb1\"\n   [(parallel\n     [(set (match_operand:SI 0 \"s_register_operand\" \"\")"}, {"sha": "8d0d184f7bec6069d0c53a8e31ee42d41d9eb844", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -29,7 +29,7 @@\n ;; in Thumb-1 state: I, J, K, L, M, N, O\n \n ;; The following multi-letter normal constraints have been used:\n-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy\n+;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy, Di\n ;; in Thumb-1 state: Pa, Pb\n ;; in Thumb-2 state: Ps, Pt, Pu, Pv, Pw, Px\n \n@@ -211,6 +211,13 @@\n       (match_test \"TARGET_32BIT && arm_const_double_inline_cost (op) == 4\n \t\t   && !(optimize_size || arm_ld_sched)\")))\n \n+(define_constraint \"Di\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_int or const_double where both the high\n+  and low SImode words can be generated as immediates in 32-bit instructions.\"\n+ (and (match_code \"const_double,const_int\")\n+      (match_test \"TARGET_32BIT && arm_const_double_by_immediates (op)\")))\n+\n (define_constraint \"Dn\"\n  \"@internal\n   In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov"}, {"sha": "0ff7aef847811b85a7d805eec95d3542cb900add", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -86,6 +86,12 @@\n   (and (match_code \"const_int\")\n        (match_test \"const_ok_for_arm (INTVAL (op))\")))\n \n+;; A constant value which fits into two instructions, each taking\n+;; an arithmetic constant operand for one of the words.\n+(define_predicate \"arm_immediate_di_operand\"\n+  (and (match_code \"const_int,const_double\")\n+       (match_test \"arm_const_double_by_immediates (op)\")))\n+\n (define_predicate \"arm_neg_immediate_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"const_ok_for_arm (-INTVAL (op))\")))\n@@ -119,6 +125,10 @@\n   (ior (match_operand 0 \"arm_rhs_operand\")\n        (match_operand 0 \"arm_not_immediate_operand\")))\n \n+(define_predicate \"arm_di_operand\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (match_operand 0 \"arm_immediate_di_operand\")))\n+\n ;; True if the operand is a memory reference which contains an\n ;; offsettable address.\n (define_predicate \"offsettable_memory_operand\"\n@@ -529,4 +539,12 @@\n (define_predicate \"neon_lane_number\"\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 7\")))\n+;; Predicates for named expanders that overlap multiple ISAs.\n+\n+(define_predicate \"cmpdi_operand\"\n+  (if_then_else (match_test \"TARGET_HARD_FLOAT && TARGET_MAVERICK\")\n+\t\t(and (match_test \"TARGET_ARM\")\n+\t\t     (match_operand 0 \"cirrus_fp_register\"))\n+\t\t(and (match_test \"TARGET_32BIT\")\n+\t\t     (match_operand 0 \"arm_di_operand\"))))\n "}, {"sha": "d4ee6d8cbee7ac3889d8dbf9ab9e62f6e20d5d4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -1,3 +1,9 @@\n+2010-07-02  Daniel Jacobowitz  <dan@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Sandra Loosemore <sandra@codesourcery.com>\n+\n+\t* gcc.c-torture/execute/20100416-1.c: New test case.\n+\n 2010-07-02  Julian Brown  <julian@codesourcery.com>\n \t    Sandra Loosemore <sandra@codesourcery.com>\n "}, {"sha": "8b5a6f45e87509c7a040c9187a69cb6769f73b4e", "filename": "gcc/testsuite/gcc.c-torture/execute/20100416-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100416-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73160ba9dc7be367d91f286eb5b07cb8af4a79bc/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100416-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100416-1.c?ref=73160ba9dc7be367d91f286eb5b07cb8af4a79bc", "patch": "@@ -0,0 +1,40 @@\n+void abort(void);\n+\n+int\n+movegt(int x, int y, long long a)\n+{\n+  int i;\n+  int ret = 0;\n+  for (i = 0; i < y; i++)\n+    {\n+      if (a >= (long long) 0xf000000000000000LL)\n+\tret = x;\n+      else\n+\tret = y;\n+    }\n+  return ret;\n+}\n+\n+struct test\n+{\n+  long long val;\n+  int ret;\n+} tests[] = {\n+  { 0xf000000000000000LL, -1 },\n+  { 0xefffffffffffffffLL, 1 },\n+  { 0xf000000000000001LL, -1 },\n+  { 0x0000000000000000LL, -1 },\n+  { 0x8000000000000000LL, 1 },\n+};\n+\n+int\n+main()\n+{\n+  int i;\n+  for (i = 0; i < sizeof (tests) / sizeof (tests[0]); i++)\n+    {\n+      if (movegt (-1, 1, tests[i].val) != tests[i].ret)\n+\tabort ();\n+    }\n+  return 0;\n+}"}]}