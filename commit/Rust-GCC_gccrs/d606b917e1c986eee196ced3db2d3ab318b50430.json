{"sha": "d606b917e1c986eee196ced3db2d3ab318b50430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwNmI5MTdlMWM5ODZlZWUxOTZjZWQzZGIyZDNhYjMxOGI1MDQzMA==", "commit": {"author": {"name": "Michael Zolotukhin", "email": "michael.v.zolotukhin@gmail.com", "date": "2013-10-21T08:30:50Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-10-21T08:30:50Z"}, "message": "i386.c (expand_set_or_movmem_via_loop): Add issetmem argument.\n\n        * config/i386/i386.c (expand_set_or_movmem_via_loop): Add issetmem\n        argument.  Update function comment.\n        (expand_set_or_movmem_via_rep): New function combining\n        expand_movmem_via_rep_mov and expand_setmem_via_rep_stos.\n        (expand_movmem_via_rep_mov): Remove.\n        expand_setmem_via_rep_stos): Remove.\n        (expand_movmem_epilogue): Update calls correspondingly.\n        (expand_setmem_epilogue_via_loop): Likewise.\n        (emit_memset): New.\n        (expand_setmem_epilogue): Add VEC_VALUE argument, refactor.\n        (expand_set_or_movmem_prologue): New function combining\n        expand_movmem_prologue and expand_setmem_prologue.\n        (expand_movmem_prologue): Remove.\n        (expand_setmem_prologue): Remove.\n        (expand_set_or_movmem_constant_prologue): New function combining\n        expand_constant_movmem_prologue and expand_constant_setmem_prologue.\n        (expand_constant_movmem_prologue): Remove.\n        (expand_constant_setmem_prologue): Remove.\n        (promote_duplicated_reg): Allow vector-const0 value.\n        (ix86_expand_set_or_movmem): New function combining ix86_expand_movmem\n        and ix86_expand_setmem.\n        (ix86_expand_movmem): Call ix86_expand_set_or_movmem.\n        (ix86_expand_setmem): Call ix86_expand_set_or_movmem.\n\n\ntestsuite/\n        * gcc.target/i386/memset-vector_loop-1.c: New test.\n        * gcc.target/i386/memset-vector_loop-2.c: New test.\n\nFrom-SVN: r203886", "tree": {"sha": "dacfe76c913ab13074ca3984af44b15a151b5172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dacfe76c913ab13074ca3984af44b15a151b5172"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d606b917e1c986eee196ced3db2d3ab318b50430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d606b917e1c986eee196ced3db2d3ab318b50430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d606b917e1c986eee196ced3db2d3ab318b50430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d606b917e1c986eee196ced3db2d3ab318b50430/comments", "author": {"login": "ZolotukhinM", "id": 4588111, "node_id": "MDQ6VXNlcjQ1ODgxMTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4588111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ZolotukhinM", "html_url": "https://github.com/ZolotukhinM", "followers_url": "https://api.github.com/users/ZolotukhinM/followers", "following_url": "https://api.github.com/users/ZolotukhinM/following{/other_user}", "gists_url": "https://api.github.com/users/ZolotukhinM/gists{/gist_id}", "starred_url": "https://api.github.com/users/ZolotukhinM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ZolotukhinM/subscriptions", "organizations_url": "https://api.github.com/users/ZolotukhinM/orgs", "repos_url": "https://api.github.com/users/ZolotukhinM/repos", "events_url": "https://api.github.com/users/ZolotukhinM/events{/privacy}", "received_events_url": "https://api.github.com/users/ZolotukhinM/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "057f1817ef6732539d41ed39bb79acaacbc15bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/057f1817ef6732539d41ed39bb79acaacbc15bec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/057f1817ef6732539d41ed39bb79acaacbc15bec"}], "stats": {"total": 1097, "additions": 453, "deletions": 644}, "files": [{"sha": "a8cbb5a196cfbe05fa7717113f611fbd21edbc35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d606b917e1c986eee196ced3db2d3ab318b50430", "patch": "@@ -1,3 +1,29 @@\n+2013-10-21  Michael Zolotukhin  <michael.v.zolotukhin@gmail.com>\n+\n+\t* config/i386/i386.c (expand_set_or_movmem_via_loop): Add issetmem\n+\targument.  Update function comment.\n+\t(expand_set_or_movmem_via_rep): New function combining\n+\texpand_movmem_via_rep_mov and expand_setmem_via_rep_stos.\n+\t(expand_movmem_via_rep_mov): Remove.\n+\texpand_setmem_via_rep_stos): Remove.\n+\t(expand_movmem_epilogue): Update calls correspondingly.\n+\t(expand_setmem_epilogue_via_loop): Likewise.\n+\t(emit_memset): New.\n+\t(expand_setmem_epilogue): Add VEC_VALUE argument, refactor.\n+\t(expand_set_or_movmem_prologue): New function combining\n+\texpand_movmem_prologue and expand_setmem_prologue.\n+\t(expand_movmem_prologue): Remove.\n+\t(expand_setmem_prologue): Remove.\n+\t(expand_set_or_movmem_constant_prologue): New function combining\n+\texpand_constant_movmem_prologue and expand_constant_setmem_prologue.\n+\t(expand_constant_movmem_prologue): Remove.\n+\t(expand_constant_setmem_prologue): Remove.\n+\t(promote_duplicated_reg): Allow vector-const0 value.\n+\t(ix86_expand_set_or_movmem): New function combining ix86_expand_movmem\n+\tand ix86_expand_setmem.\n+\t(ix86_expand_movmem): Call ix86_expand_set_or_movmem.\n+\t(ix86_expand_setmem): Call ix86_expand_set_or_movmem.\n+\n 2013-10-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/altivec.md (vec_unpacku_hi_v16qi): Adjust for"}, {"sha": "af4cef724bdabd1bb36eda81146776b0a356b780", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 401, "deletions": 644, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d606b917e1c986eee196ced3db2d3ab318b50430", "patch": "@@ -22131,10 +22131,10 @@ ix86_copy_addr_to_reg (rtx addr)\n     }\n }\n \n-/* When SRCPTR is non-NULL, output simple loop to move memory\n-   pointer to SRCPTR to DESTPTR via chunks of MODE unrolled UNROLL times,\n-   overall size is COUNT specified in bytes.  When SRCPTR is NULL, output the\n-   equivalent loop to set memory by VALUE (supposed to be in MODE).\n+/* When ISSETMEM is FALSE, output simple loop to move memory pointer to SRCPTR\n+   to DESTPTR via chunks of MODE unrolled UNROLL times, overall size is COUNT\n+   specified in bytes.  When ISSETMEM is TRUE, output the equivalent loop to set\n+   memory by VALUE (supposed to be in MODE).\n \n    The size is rounded down to whole number of chunk size moved at once.\n    SRCMEM and DESTMEM provide MEMrtx to feed proper aliasing info.  */\n@@ -22144,7 +22144,7 @@ static void\n expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t       rtx destptr, rtx srcptr, rtx value,\n \t\t\t       rtx count, enum machine_mode mode, int unroll,\n-\t\t\t       int expected_size)\n+\t\t\t       int expected_size, bool issetmem)\n {\n   rtx out_label, top_label, iter, tmp;\n   enum machine_mode iter_mode = counter_mode (count);\n@@ -22180,7 +22180,7 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n   destmem = offset_address (destmem, tmp, piece_size_n);\n   destmem = adjust_address (destmem, mode, 0);\n \n-  if (srcmem)\n+  if (!issetmem)\n     {\n       srcmem = offset_address (srcmem, copy_rtx (tmp), piece_size_n);\n       srcmem = adjust_address (srcmem, mode, 0);\n@@ -22260,7 +22260,7 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n \t\t\t     true, OPTAB_LIB_WIDEN);\n   if (tmp != destptr)\n     emit_move_insn (destptr, tmp);\n-  if (srcptr)\n+  if (!issetmem)\n     {\n       tmp = expand_simple_binop (Pmode, PLUS, srcptr, iter, srcptr,\n \t\t\t\t true, OPTAB_LIB_WIDEN);\n@@ -22270,96 +22270,85 @@ expand_set_or_movmem_via_loop (rtx destmem, rtx srcmem,\n   emit_label (out_label);\n }\n \n-/* Output \"rep; mov\" instruction.\n-   Arguments have same meaning as for previous function */\n+/* Output \"rep; mov\" or \"rep; stos\" instruction depending on ISSETMEM argument.\n+   When ISSETMEM is true, arguments SRCMEM and SRCPTR are ignored.\n+   When ISSETMEM is false, arguments VALUE and ORIG_VALUE are ignored.\n+   For setmem case, VALUE is a promoted to a wider size ORIG_VALUE.\n+   ORIG_VALUE is the original value passed to memset to fill the memory with.\n+   Other arguments have same meaning as for previous function.  */\n+\n static void\n-expand_movmem_via_rep_mov (rtx destmem, rtx srcmem,\n-\t\t\t   rtx destptr, rtx srcptr,\n+expand_set_or_movmem_via_rep (rtx destmem, rtx srcmem,\n+\t\t\t   rtx destptr, rtx srcptr, rtx value, rtx orig_value,\n \t\t\t   rtx count,\n-\t\t\t   enum machine_mode mode)\n+\t\t\t   enum machine_mode mode, bool issetmem)\n {\n   rtx destexp;\n   rtx srcexp;\n   rtx countreg;\n   HOST_WIDE_INT rounded_count;\n \n-  /* If the size is known, it is shorter to use rep movs.  */\n-  if (mode == QImode && CONST_INT_P (count)\n-      && !(INTVAL (count) & 3))\n+  /* If possible, it is shorter to use rep movs.\n+     TODO: Maybe it is better to move this logic to decide_alg.  */\n+  if (mode == QImode && CONST_INT_P (count) && !(INTVAL (count) & 3)\n+      && (!issetmem || orig_value == const0_rtx))\n     mode = SImode;\n \n   if (destptr != XEXP (destmem, 0) || GET_MODE (destmem) != BLKmode)\n     destmem = adjust_automodify_address_nv (destmem, BLKmode, destptr, 0);\n-  if (srcptr != XEXP (srcmem, 0) || GET_MODE (srcmem) != BLKmode)\n-    srcmem = adjust_automodify_address_nv (srcmem, BLKmode, srcptr, 0);\n-  countreg = ix86_zero_extend_to_Pmode (scale_counter (count, GET_MODE_SIZE (mode)));\n+\n+  countreg = ix86_zero_extend_to_Pmode (scale_counter (count,\n+\t\t\t\t\t\t       GET_MODE_SIZE (mode)));\n   if (mode != QImode)\n     {\n       destexp = gen_rtx_ASHIFT (Pmode, countreg,\n \t\t\t\tGEN_INT (exact_log2 (GET_MODE_SIZE (mode))));\n       destexp = gen_rtx_PLUS (Pmode, destexp, destptr);\n-      srcexp = gen_rtx_ASHIFT (Pmode, countreg,\n-\t\t\t       GEN_INT (exact_log2 (GET_MODE_SIZE (mode))));\n-      srcexp = gen_rtx_PLUS (Pmode, srcexp, srcptr);\n     }\n   else\n-    {\n-      destexp = gen_rtx_PLUS (Pmode, destptr, countreg);\n-      srcexp = gen_rtx_PLUS (Pmode, srcptr, countreg);\n-    }\n-  if (CONST_INT_P (count))\n+    destexp = gen_rtx_PLUS (Pmode, destptr, countreg);\n+  if ((!issetmem || orig_value == const0_rtx) && CONST_INT_P (count))\n     {\n       rounded_count = (INTVAL (count)\n \t\t       & ~((HOST_WIDE_INT) GET_MODE_SIZE (mode) - 1));\n       destmem = shallow_copy_rtx (destmem);\n-      srcmem = shallow_copy_rtx (srcmem);\n       set_mem_size (destmem, rounded_count);\n-      set_mem_size (srcmem, rounded_count);\n-    }\n-  else\n-    {\n-      if (MEM_SIZE_KNOWN_P (destmem))\n-\tclear_mem_size (destmem);\n-      if (MEM_SIZE_KNOWN_P (srcmem))\n-\tclear_mem_size (srcmem);\n     }\n-  emit_insn (gen_rep_mov (destptr, destmem, srcptr, srcmem, countreg,\n-\t\t\t  destexp, srcexp));\n-}\n-\n-/* Output \"rep; stos\" instruction.\n-   Arguments have same meaning as for previous function */\n-static void\n-expand_setmem_via_rep_stos (rtx destmem, rtx destptr, rtx value,\n-\t\t\t    rtx count, enum machine_mode mode,\n-\t\t\t    rtx orig_value)\n-{\n-  rtx destexp;\n-  rtx countreg;\n-  HOST_WIDE_INT rounded_count;\n+  else if (MEM_SIZE_KNOWN_P (destmem))\n+    clear_mem_size (destmem);\n \n-  if (destptr != XEXP (destmem, 0) || GET_MODE (destmem) != BLKmode)\n-    destmem = adjust_automodify_address_nv (destmem, BLKmode, destptr, 0);\n-  value = force_reg (mode, gen_lowpart (mode, value));\n-  countreg = ix86_zero_extend_to_Pmode (scale_counter (count, GET_MODE_SIZE (mode)));\n-  if (mode != QImode)\n+  if (issetmem)\n     {\n-      destexp = gen_rtx_ASHIFT (Pmode, countreg,\n-\t\t\t\tGEN_INT (exact_log2 (GET_MODE_SIZE (mode))));\n-      destexp = gen_rtx_PLUS (Pmode, destexp, destptr);\n+      value = force_reg (mode, gen_lowpart (mode, value));\n+      emit_insn (gen_rep_stos (destptr, countreg, destmem, value, destexp));\n     }\n   else\n-    destexp = gen_rtx_PLUS (Pmode, destptr, countreg);\n-  if (orig_value == const0_rtx && CONST_INT_P (count))\n     {\n-      rounded_count = (INTVAL (count)\n-\t\t       & ~((HOST_WIDE_INT) GET_MODE_SIZE (mode) - 1));\n-      destmem = shallow_copy_rtx (destmem);\n-      set_mem_size (destmem, rounded_count);\n+      if (srcptr != XEXP (srcmem, 0) || GET_MODE (srcmem) != BLKmode)\n+\tsrcmem = adjust_automodify_address_nv (srcmem, BLKmode, srcptr, 0);\n+      if (mode != QImode)\n+\t{\n+\t  srcexp = gen_rtx_ASHIFT (Pmode, countreg,\n+\t\t\t\t   GEN_INT (exact_log2 (GET_MODE_SIZE (mode))));\n+\t  srcexp = gen_rtx_PLUS (Pmode, srcexp, srcptr);\n+\t}\n+      else\n+\tsrcexp = gen_rtx_PLUS (Pmode, srcptr, countreg);\n+      if (CONST_INT_P (count))\n+\t{\n+\t  rounded_count = (INTVAL (count)\n+\t\t\t   & ~((HOST_WIDE_INT) GET_MODE_SIZE (mode) - 1));\n+\t  srcmem = shallow_copy_rtx (srcmem);\n+\t  set_mem_size (srcmem, rounded_count);\n+\t}\n+      else\n+\t{\n+\t  if (MEM_SIZE_KNOWN_P (srcmem))\n+\t    clear_mem_size (srcmem);\n+\t}\n+      emit_insn (gen_rep_mov (destptr, destmem, srcptr, srcmem, countreg,\n+\t\t\t      destexp, srcexp));\n     }\n-  else if (MEM_SIZE_KNOWN_P (destmem))\n-    clear_mem_size (destmem);\n-  emit_insn (gen_rep_stos (destptr, countreg, destmem, value, destexp));\n }\n \n /* This function emits moves to copy SIZE_TO_MOVE bytes from SRCMEM to\n@@ -22462,7 +22451,7 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n       count = expand_simple_binop (GET_MODE (count), AND, count, GEN_INT (max_size - 1),\n \t\t\t\t    count, 1, OPTAB_DIRECT);\n       expand_set_or_movmem_via_loop (destmem, srcmem, destptr, srcptr, NULL,\n-\t\t\t\t     count, QImode, 1, 4);\n+\t\t\t\t     count, QImode, 1, 4, false);\n       return;\n     }\n \n@@ -22547,6 +22536,59 @@ expand_movmem_epilogue (rtx destmem, rtx srcmem,\n     }\n }\n \n+/* This function emits moves to fill SIZE_TO_MOVE bytes starting from DESTMEM\n+   with value PROMOTED_VAL.\n+   SRC is passed by pointer to be updated on return.\n+   Return value is updated DST.  */\n+static rtx\n+emit_memset (rtx destmem, rtx destptr, rtx promoted_val,\n+\t     HOST_WIDE_INT size_to_move)\n+{\n+  rtx dst = destmem, adjust;\n+  enum insn_code code;\n+  enum machine_mode move_mode;\n+  int piece_size, i;\n+\n+  /* Find the widest mode in which we could perform moves.\n+     Start with the biggest power of 2 less than SIZE_TO_MOVE and half\n+     it until move of such size is supported.  */\n+  move_mode = GET_MODE (promoted_val);\n+  if (move_mode == VOIDmode)\n+    move_mode = QImode;\n+  if (size_to_move < GET_MODE_SIZE (move_mode))\n+    {\n+      move_mode = mode_for_size (size_to_move * BITS_PER_UNIT, MODE_INT, 0);\n+      promoted_val = gen_lowpart (move_mode, promoted_val);\n+    }\n+  piece_size = GET_MODE_SIZE (move_mode);\n+  code = optab_handler (mov_optab, move_mode);\n+  gcc_assert (code != CODE_FOR_nothing && promoted_val != NULL_RTX);\n+\n+  dst = adjust_automodify_address_nv (dst, move_mode, destptr, 0);\n+\n+  /* Emit moves.  We'll need SIZE_TO_MOVE/PIECE_SIZES moves.  */\n+  gcc_assert (size_to_move % piece_size == 0);\n+  adjust = GEN_INT (piece_size);\n+  for (i = 0; i < size_to_move; i += piece_size)\n+    {\n+      if (piece_size <= GET_MODE_SIZE (word_mode))\n+\t{\n+\t  emit_insn (gen_strset (destptr, dst, promoted_val));\n+\t  continue;\n+\t}\n+\n+      emit_insn (GEN_FCN (code) (dst, promoted_val));\n+\n+      emit_move_insn (destptr,\n+\t\t      gen_rtx_PLUS (Pmode, copy_rtx (destptr), adjust));\n+\n+      dst = adjust_automodify_address_nv (dst, move_mode, destptr,\n+\t\t\t\t\t  piece_size);\n+    }\n+\n+  /* Update DST rtx.  */\n+  return dst;\n+}\n /* Output code to set at most count & (max_size - 1) bytes starting by DEST.  */\n static void\n expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n@@ -22557,66 +22599,35 @@ expand_setmem_epilogue_via_loop (rtx destmem, rtx destptr, rtx value,\n \t\t\t GEN_INT (max_size - 1), count, 1, OPTAB_DIRECT);\n   expand_set_or_movmem_via_loop (destmem, NULL, destptr, NULL,\n \t\t\t\t gen_lowpart (QImode, value), count, QImode,\n-\t\t\t\t 1, max_size / 2);\n+\t\t\t\t 1, max_size / 2, true);\n }\n \n /* Output code to set at most count & (max_size - 1) bytes starting by DEST.  */\n static void\n-expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx count, int max_size)\n+expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx vec_value,\n+\t\t\trtx count, int max_size)\n {\n   rtx dest;\n \n   if (CONST_INT_P (count))\n     {\n       HOST_WIDE_INT countval = INTVAL (count);\n-      int offset = 0;\n+      HOST_WIDE_INT epilogue_size = countval % max_size;\n+      int i;\n \n-      if ((countval & 0x10) && max_size > 16)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset + 8);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t  offset += 16;\n-\t}\n-      if ((countval & 0x08) && max_size > 8)\n+      /* For now MAX_SIZE should be a power of 2.  This assert could be\n+\t relaxed, but it'll require a bit more complicated epilogue\n+\t expanding.  */\n+      gcc_assert ((max_size & (max_size - 1)) == 0);\n+      for (i = max_size; i >= 1; i >>= 1)\n \t{\n-\t  if (TARGET_64BIT)\n-\t    {\n-\t      dest = adjust_automodify_address_nv (destmem, DImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t    }\n-\t  else\n+\t  if (epilogue_size & i)\n \t    {\n-\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n-\t      dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset + 4);\n-\t      emit_insn (gen_strset (destptr, dest, value));\n+\t      if (vec_value && i > GET_MODE_SIZE (GET_MODE (value)))\n+\t\tdestmem = emit_memset (destmem, destptr, vec_value, i);\n+\t      else\n+\t\tdestmem = emit_memset (destmem, destptr, value, i);\n \t    }\n-\t  offset += 8;\n-\t}\n-      if ((countval & 0x04) && max_size > 4)\n-\t{\n-\t  dest = adjust_automodify_address_nv (destmem, SImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (SImode, value)));\n-\t  offset += 4;\n-\t}\n-      if ((countval & 0x02) && max_size > 2)\n-\t{\n-\t  dest = adjust_automodify_address_nv (destmem, HImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (HImode, value)));\n-\t  offset += 2;\n-\t}\n-      if ((countval & 0x01) && max_size > 1)\n-\t{\n-\t  dest = adjust_automodify_address_nv (destmem, QImode, destptr, offset);\n-\t  emit_insn (gen_strset (destptr, dest, gen_lowpart (QImode, value)));\n-\t  offset += 1;\n \t}\n       return;\n     }\n@@ -22688,21 +22699,32 @@ expand_setmem_epilogue (rtx destmem, rtx destptr, rtx value, rtx count, int max_\n     }\n }\n \n-/* Copy enough from DEST to SRC to align DEST known to by aligned by ALIGN to\n-   DESIRED_ALIGNMENT.\n+/* Depending on ISSETMEM, copy enough from SRCMEM to DESTMEM or set enough to\n+   DESTMEM to align it to DESIRED_ALIGNMENT.  Original alignment is ALIGN.\n+   Depending on ISSETMEM, either arguments SRCMEM/SRCPTR or VALUE/VEC_VALUE are\n+   ignored.\n    Return value is updated DESTMEM.  */\n static rtx\n-expand_movmem_prologue (rtx destmem, rtx srcmem,\n-\t\t\trtx destptr, rtx srcptr, rtx count,\n-\t\t\tint align, int desired_alignment)\n+expand_set_or_movmem_prologue (rtx destmem, rtx srcmem,\n+\t\t\t\t  rtx destptr, rtx srcptr, rtx value,\n+\t\t\t\t  rtx vec_value, rtx count, int align,\n+\t\t\t\t  int desired_alignment, bool issetmem)\n {\n   int i;\n   for (i = 1; i < desired_alignment; i <<= 1)\n     {\n       if (align <= i)\n \t{\n \t  rtx label = ix86_expand_aligntest (destptr, i, false);\n-\t  destmem = emit_memmov (destmem, &srcmem, destptr, srcptr, i);\n+\t  if (issetmem)\n+\t    {\n+\t      if (vec_value && i > GET_MODE_SIZE (GET_MODE (value)))\n+\t\tdestmem = emit_memset (destmem, destptr, vec_value, i);\n+\t      else\n+\t\tdestmem = emit_memset (destmem, destptr, value, i);\n+\t    }\n+\t  else\n+\t    destmem = emit_memmov (destmem, &srcmem, destptr, srcptr, i);\n \t  ix86_adjust_counter (count, i);\n \t  emit_label (label);\n \t  LABEL_NUSES (label) = 1;\n@@ -22712,132 +22734,77 @@ expand_movmem_prologue (rtx destmem, rtx srcmem,\n   return destmem;\n }\n \n-/* Copy enough from DST to SRC to align DST known to DESIRED_ALIGN.\n-   ALIGN_BYTES is how many bytes need to be copied.\n-   The function updates DST and SRC, namely, it sets proper alignment.\n-   DST is returned via return value, SRC is updated via pointer SRCP.  */\n+/* This function is like the previous one, except here we know how many bytes\n+   need to be copied.  That allows us to update alignment not only of DST, which\n+   is returned, but also of SRC, which is passed as a pointer for that\n+   reason.  */\n static rtx\n-expand_constant_movmem_prologue (rtx dst, rtx *srcp, rtx destreg, rtx srcreg,\n-\t\t\t\t int desired_align, int align_bytes)\n+expand_set_or_movmem_constant_prologue (rtx dst, rtx *srcp, rtx destreg,\n+\t\t\t\t\t   rtx srcreg, rtx value, rtx vec_value,\n+\t\t\t\t\t   int desired_align, int align_bytes,\n+\t\t\t\t\t   bool issetmem)\n {\n-  rtx src = *srcp;\n+  rtx src = NULL;\n   rtx orig_dst = dst;\n-  rtx orig_src = src;\n+  rtx orig_src = NULL;\n   int piece_size = 1;\n   int copied_bytes = 0;\n-  int src_align_bytes = get_mem_align_offset (src, desired_align * BITS_PER_UNIT);\n-  if (src_align_bytes >= 0)\n-    src_align_bytes = desired_align - src_align_bytes;\n+\n+  if (!issetmem)\n+    {\n+      gcc_assert (srcp != NULL);\n+      src = *srcp;\n+      orig_src = src;\n+    }\n \n   for (piece_size = 1;\n        piece_size <= desired_align && copied_bytes < align_bytes;\n        piece_size <<= 1)\n     {\n       if (align_bytes & piece_size)\n \t{\n-\t  dst = emit_memmov (dst, &src, destreg, srcreg, piece_size);\n+\t  if (issetmem)\n+\t    {\n+\t      if (vec_value && piece_size > GET_MODE_SIZE (GET_MODE (value)))\n+\t\tdst = emit_memset (dst, destreg, vec_value, piece_size);\n+\t      else\n+\t\tdst = emit_memset (dst, destreg, value, piece_size);\n+\t    }\n+\t  else\n+\t    dst = emit_memmov (dst, &src, destreg, srcreg, piece_size);\n \t  copied_bytes += piece_size;\n \t}\n     }\n-\n   if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n     set_mem_align (dst, desired_align * BITS_PER_UNIT);\n-  if (src_align_bytes >= 0)\n-    {\n-      unsigned int src_align;\n-      for (src_align = desired_align; src_align >= 2; src_align >>= 1)\n-\t{\n-\t  if ((src_align_bytes & (src_align - 1))\n-\t       == (align_bytes & (src_align - 1)))\n-\t    break;\n-\t}\n-      if (src_align > (unsigned int) desired_align)\n-\tsrc_align = desired_align;\n-      if (MEM_ALIGN (src) < src_align * BITS_PER_UNIT)\n-\tset_mem_align (src, src_align * BITS_PER_UNIT);\n-    }\n   if (MEM_SIZE_KNOWN_P (orig_dst))\n     set_mem_size (dst, MEM_SIZE (orig_dst) - align_bytes);\n-  if (MEM_SIZE_KNOWN_P (orig_src))\n-    set_mem_size (src, MEM_SIZE (orig_src) - align_bytes);\n-  *srcp = src;\n-  return dst;\n-}\n \n-/* Set enough from DEST to align DEST known to by aligned by ALIGN to\n-   DESIRED_ALIGNMENT.  */\n-static void\n-expand_setmem_prologue (rtx destmem, rtx destptr, rtx value, rtx count,\n-\t\t\tint align, int desired_alignment)\n-{\n-  if (align <= 1 && desired_alignment > 1)\n-    {\n-      rtx label = ix86_expand_aligntest (destptr, 1, false);\n-      destmem = change_address (destmem, QImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem, gen_lowpart (QImode, value)));\n-      ix86_adjust_counter (count, 1);\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-    }\n-  if (align <= 2 && desired_alignment > 2)\n-    {\n-      rtx label = ix86_expand_aligntest (destptr, 2, false);\n-      destmem = change_address (destmem, HImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem, gen_lowpart (HImode, value)));\n-      ix86_adjust_counter (count, 2);\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-    }\n-  if (align <= 4 && desired_alignment > 4)\n+  if (!issetmem)\n     {\n-      rtx label = ix86_expand_aligntest (destptr, 4, false);\n-      destmem = change_address (destmem, SImode, destptr);\n-      emit_insn (gen_strset (destptr, destmem, gen_lowpart (SImode, value)));\n-      ix86_adjust_counter (count, 4);\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n+      int src_align_bytes = get_mem_align_offset (src, desired_align\n+\t\t\t\t\t\t       * BITS_PER_UNIT);\n+      if (src_align_bytes >= 0)\n+\tsrc_align_bytes = desired_align - src_align_bytes;\n+      if (src_align_bytes >= 0)\n+\t{\n+\t  unsigned int src_align;\n+\t  for (src_align = desired_align; src_align >= 2; src_align >>= 1)\n+\t    {\n+\t      if ((src_align_bytes & (src_align - 1))\n+\t\t   == (align_bytes & (src_align - 1)))\n+\t\tbreak;\n+\t    }\n+\t  if (src_align > (unsigned int) desired_align)\n+\t    src_align = desired_align;\n+\t  if (MEM_ALIGN (src) < src_align * BITS_PER_UNIT)\n+\t    set_mem_align (src, src_align * BITS_PER_UNIT);\n+\t}\n+      if (MEM_SIZE_KNOWN_P (orig_src))\n+\tset_mem_size (src, MEM_SIZE (orig_src) - align_bytes);\n+      *srcp = src;\n     }\n-  gcc_assert (desired_alignment <= 8);\n-}\n \n-/* Set enough from DST to align DST known to by aligned by ALIGN to\n-   DESIRED_ALIGN.  ALIGN_BYTES is how many bytes need to be stored.  */\n-static rtx\n-expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n-\t\t\t\t int desired_align, int align_bytes)\n-{\n-  int off = 0;\n-  rtx orig_dst = dst;\n-  if (align_bytes & 1)\n-    {\n-      dst = adjust_automodify_address_nv (dst, QImode, destreg, 0);\n-      off = 1;\n-      emit_insn (gen_strset (destreg, dst,\n-\t\t\t     gen_lowpart (QImode, value)));\n-    }\n-  if (align_bytes & 2)\n-    {\n-      dst = adjust_automodify_address_nv (dst, HImode, destreg, off);\n-      if (MEM_ALIGN (dst) < 2 * BITS_PER_UNIT)\n-\tset_mem_align (dst, 2 * BITS_PER_UNIT);\n-      off = 2;\n-      emit_insn (gen_strset (destreg, dst,\n-\t\t\t     gen_lowpart (HImode, value)));\n-    }\n-  if (align_bytes & 4)\n-    {\n-      dst = adjust_automodify_address_nv (dst, SImode, destreg, off);\n-      if (MEM_ALIGN (dst) < 4 * BITS_PER_UNIT)\n-\tset_mem_align (dst, 4 * BITS_PER_UNIT);\n-      off = 4;\n-      emit_insn (gen_strset (destreg, dst,\n-\t\t\t     gen_lowpart (SImode, value)));\n-    }\n-  dst = adjust_automodify_address_nv (dst, BLKmode, destreg, off);\n-  if (MEM_ALIGN (dst) < (unsigned int) desired_align * BITS_PER_UNIT)\n-    set_mem_align (dst, desired_align * BITS_PER_UNIT);\n-  if (MEM_SIZE_KNOWN_P (orig_dst))\n-    set_mem_size (dst, MEM_SIZE (orig_dst) - align_bytes);\n   return dst;\n }\n \n@@ -23012,10 +22979,104 @@ decide_alignment (int align,\n   return desired_align;\n }\n \n-/* Expand string move (memcpy) operation.  Use i386 string operations\n-   when profitable.  expand_setmem contains similar code.  The code\n-   depends upon architecture, block size and alignment, but always has\n-   the same overall structure:\n+\n+/* Helper function for memcpy.  For QImode value 0xXY produce\n+   0xXYXYXYXY of wide specified by MODE.  This is essentially\n+   a * 0x10101010, but we can do slightly better than\n+   synth_mult by unwinding the sequence by hand on CPUs with\n+   slow multiply.  */\n+static rtx\n+promote_duplicated_reg (enum machine_mode mode, rtx val)\n+{\n+  enum machine_mode valmode = GET_MODE (val);\n+  rtx tmp;\n+  int nops = mode == DImode ? 3 : 2;\n+\n+  gcc_assert (mode == SImode || mode == DImode || val == const0_rtx);\n+  if (val == const0_rtx)\n+    return copy_to_mode_reg (mode, CONST0_RTX (mode));\n+  if (CONST_INT_P (val))\n+    {\n+      HOST_WIDE_INT v = INTVAL (val) & 255;\n+\n+      v |= v << 8;\n+      v |= v << 16;\n+      if (mode == DImode)\n+        v |= (v << 16) << 16;\n+      return copy_to_mode_reg (mode, gen_int_mode (v, mode));\n+    }\n+\n+  if (valmode == VOIDmode)\n+    valmode = QImode;\n+  if (valmode != QImode)\n+    val = gen_lowpart (QImode, val);\n+  if (mode == QImode)\n+    return val;\n+  if (!TARGET_PARTIAL_REG_STALL)\n+    nops--;\n+  if (ix86_cost->mult_init[mode == DImode ? 3 : 2]\n+      + ix86_cost->mult_bit * (mode == DImode ? 8 : 4)\n+      <= (ix86_cost->shift_const + ix86_cost->add) * nops\n+          + (COSTS_N_INSNS (TARGET_PARTIAL_REG_STALL == 0)))\n+    {\n+      rtx reg = convert_modes (mode, QImode, val, true);\n+      tmp = promote_duplicated_reg (mode, const1_rtx);\n+      return expand_simple_binop (mode, MULT, reg, tmp, NULL, 1,\n+\t\t\t\t  OPTAB_DIRECT);\n+    }\n+  else\n+    {\n+      rtx reg = convert_modes (mode, QImode, val, true);\n+\n+      if (!TARGET_PARTIAL_REG_STALL)\n+\tif (mode == SImode)\n+\t  emit_insn (gen_movsi_insv_1 (reg, reg));\n+\telse\n+\t  emit_insn (gen_movdi_insv_1 (reg, reg));\n+      else\n+\t{\n+\t  tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (8),\n+\t\t\t\t     NULL, 1, OPTAB_DIRECT);\n+\t  reg =\n+\t    expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n+\t}\n+      tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (16),\n+\t\t\t         NULL, 1, OPTAB_DIRECT);\n+      reg = expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n+      if (mode == SImode)\n+\treturn reg;\n+      tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (32),\n+\t\t\t\t NULL, 1, OPTAB_DIRECT);\n+      reg = expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n+      return reg;\n+    }\n+}\n+\n+/* Duplicate value VAL using promote_duplicated_reg into maximal size that will\n+   be needed by main loop copying SIZE_NEEDED chunks and prologue getting\n+   alignment from ALIGN to DESIRED_ALIGN.  */\n+static rtx\n+promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align,\n+\t\t\t\tint align)\n+{\n+  rtx promoted_val;\n+\n+  if (TARGET_64BIT\n+      && (size_needed > 4 || (desired_align > align && desired_align > 4)))\n+    promoted_val = promote_duplicated_reg (DImode, val);\n+  else if (size_needed > 2 || (desired_align > align && desired_align > 2))\n+    promoted_val = promote_duplicated_reg (SImode, val);\n+  else if (size_needed > 1 || (desired_align > align && desired_align > 1))\n+    promoted_val = promote_duplicated_reg (HImode, val);\n+  else\n+    promoted_val = val;\n+\n+  return promoted_val;\n+}\n+\n+/* Expand string move (memcpy) ot store (memset) operation.  Use i386 string\n+   operations when profitable.  The code depends upon architecture, block size\n+   and alignment, but always has the same overall structure:\n \n    1) Prologue guard: Conditional that jumps up to epilogues for small\n       blocks that can be handled by epilogue alone.  This is faster\n@@ -23025,24 +23086,24 @@ decide_alignment (int align,\n       Optional dynamic check for size and libcall for large\n       blocks is emitted here too, with -minline-stringops-dynamically.\n \n-   2) Prologue: copy first few bytes in order to get destination\n+   2) Prologue: copy/set first few bytes in order to get destination\n       aligned to DESIRED_ALIGN.  It is emitted only when ALIGN is less\n       than DESIRED_ALIGN and up to DESIRED_ALIGN - ALIGN bytes can be\n-      copied.  We emit either a jump tree on power of two sized\n+      copied/set.  We emit either a jump tree on power of two sized\n       blocks, or a byte loop.\n \n-   3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n-      with specified algorithm.\n+   3) Main body: the copying/storing loop itself, copying/storing in SIZE_NEEDED\n+      chunks with specified algorithm.\n \n-   4) Epilogue: code copying tail of the block that is too small to be\n+   4) Epilogue: code copying/storing tail of the block that is too small to be\n       handled by main body (or up to size guarded by prologue guard).  */\n-\n-bool\n-ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n-\t\t    rtx expected_align_exp, rtx expected_size_exp)\n+static bool\n+ix86_expand_set_or_movmem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n+\t\t\t      rtx align_exp, rtx expected_align_exp,\n+\t\t\t      rtx expected_size_exp, bool issetmem)\n {\n   rtx destreg;\n-  rtx srcreg;\n+  rtx srcreg = NULL;\n   rtx label = NULL;\n   rtx tmp;\n   rtx jump_around_label = NULL;\n@@ -23052,6 +23113,9 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   int size_needed = 0, epilogue_size_needed;\n   int desired_align = 0, align_bytes = 0;\n   enum stringop_alg alg;\n+  rtx promoted_val = NULL;\n+  rtx vec_promoted_val = NULL;\n+  bool force_loopy_epilogue = false;\n   int dynamic_check;\n   bool need_zero_guard = false;\n   bool noalign;\n@@ -23066,7 +23130,8 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     align = INTVAL (expected_align_exp);\n   /* ALIGN is the minimum of destination and source alignment, but we care here\n      just about destination alignment.  */\n-  else if (MEM_ALIGN (dst) > (unsigned HOST_WIDE_INT) align * BITS_PER_UNIT)\n+  else if (!issetmem\n+\t   && MEM_ALIGN (dst) > (unsigned HOST_WIDE_INT) align * BITS_PER_UNIT)\n     align = MEM_ALIGN (dst) / BITS_PER_UNIT;\n \n   if (CONST_INT_P (count_exp))\n@@ -23080,15 +23145,21 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n-  alg = decide_alg (count, expected_size, false, &dynamic_check, &noalign);\n+  alg = decide_alg (count, expected_size, issetmem, &dynamic_check, &noalign);\n   if (alg == libcall)\n     return false;\n   gcc_assert (alg != no_stringop);\n \n+  /* For now vector-version of memset is generated only for memory zeroing, as\n+     creating of promoted vector value is very cheap in this case.  */\n+  if (issetmem && alg == vector_loop && val_exp != const0_rtx)\n+    alg = unrolled_loop;\n+\n   if (!count)\n     count_exp = copy_to_mode_reg (GET_MODE (count_exp), count_exp);\n   destreg = ix86_copy_addr_to_reg (XEXP (dst, 0));\n-  srcreg = ix86_copy_addr_to_reg (XEXP (src, 0));\n+  if (!issetmem)\n+    srcreg = ix86_copy_addr_to_reg (XEXP (src, 0));\n \n   unroll_factor = 1;\n   move_mode = word_mode;\n@@ -23166,14 +23237,39 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     }\n   gcc_assert (desired_align >= 1 && align >= 1);\n \n-  /* Ensure that alignment prologue won't copy past end of block.  */\n-  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n-    {\n+  /* Do the cheap promotion to allow better CSE across the\n+     main loop and epilogue (ie one load of the big constant in the\n+     front of all code.  */\n+  if (issetmem && CONST_INT_P (val_exp))\n+    {\n+      if (alg == vector_loop)\n+\t{\n+\t  gcc_assert (val_exp == const0_rtx);\n+\t  vec_promoted_val = promote_duplicated_reg (move_mode, val_exp);\n+\t  promoted_val = promote_duplicated_reg_to_size (val_exp,\n+\t\t\t\t\t\t\t GET_MODE_SIZE (word_mode),\n+\t\t\t\t\t\t\t desired_align, align);\n+\t}\n+      else\n+\t{\n+\t  promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n+\t\t\t\t\t\t\t desired_align, align);\n+\t}\n+    }\n+  /* Ensure that alignment prologue won't copy past end of block.  */\n+  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n+    {\n       epilogue_size_needed = MAX (size_needed - 1, desired_align - align);\n       /* Epilogue always copies COUNT_EXP & EPILOGUE_SIZE_NEEDED bytes.\n \t Make sure it is power of 2.  */\n       epilogue_size_needed = 1 << (floor_log2 (epilogue_size_needed) + 1);\n \n+      /* To improve performance of small blocks, we jump around the VAL\n+\t promoting mode.  This mean that if the promoted VAL is not constant,\n+\t we might not use it in the epilogue and have to use byte\n+\t loop variant.  */\n+      if (issetmem && epilogue_size_needed > 2 && !promoted_val)\n+\tforce_loopy_epilogue = true;\n       if (count)\n \t{\n \t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n@@ -23203,7 +23299,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n      used.  */\n   if (dynamic_check != -1)\n     {\n-      if (CONST_INT_P (count_exp))\n+      if (!issetmem && CONST_INT_P (count_exp))\n \t{\n \t  if (UINTVAL (count_exp) >= (unsigned HOST_WIDE_INT)dynamic_check)\n \t    {\n@@ -23219,13 +23315,20 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t  emit_cmp_and_jump_insns (count_exp, GEN_INT (dynamic_check - 1),\n \t\t\t\t   LEU, 0, GET_MODE (count_exp), 1, hot_label);\n \t  predict_jump (REG_BR_PROB_BASE * 90 / 100);\n-\t  emit_block_move_via_libcall (dst, src, count_exp, false);\n+\t  if (issetmem)\n+\t    set_storage_via_libcall (dst, count_exp, val_exp, false);\n+\t  else\n+\t    emit_block_move_via_libcall (dst, src, count_exp, false);\n \t  emit_jump (jump_around_label);\n \t  emit_label (hot_label);\n \t}\n     }\n \n   /* Step 2: Alignment prologue.  */\n+  /* Do the expensive promotion once we branched off the small blocks.  */\n+  if (issetmem && !promoted_val)\n+    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n+\t\t\t\t\t\t   desired_align, align);\n \n   if (desired_align > align)\n     {\n@@ -23235,17 +23338,26 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n \t     constant offset in aliasing info.  It don't seems to worth\n \t     the pain to maintain it for the first move, so throw away\n \t     the info early.  */\n-\t  src = change_address (src, BLKmode, srcreg);\n \t  dst = change_address (dst, BLKmode, destreg);\n-\t  dst = expand_movmem_prologue (dst, src, destreg, srcreg, count_exp, align,\n-\t\t\t\t\tdesired_align);\n+\t  if (!issetmem)\n+\t    src = change_address (src, BLKmode, srcreg);\n+\t  dst = expand_set_or_movmem_prologue (dst, src, destreg, srcreg,\n+\t\t\t\t\t    promoted_val, vec_promoted_val,\n+\t\t\t\t\t    count_exp, align, desired_align,\n+\t\t\t\t\t    issetmem);\n \t}\n       else\n \t{\n \t  /* If we know how many bytes need to be stored before dst is\n \t     sufficiently aligned, maintain aliasing info accurately.  */\n-\t  dst = expand_constant_movmem_prologue (dst, &src, destreg, srcreg,\n-\t\t\t\t\t\t desired_align, align_bytes);\n+\t  dst = expand_set_or_movmem_constant_prologue (dst, &src, destreg,\n+\t\t\t\t\t\t\t   srcreg,\n+\t\t\t\t\t\t\t   promoted_val,\n+\t\t\t\t\t\t\t   vec_promoted_val,\n+\t\t\t\t\t\t\t   desired_align,\n+\t\t\t\t\t\t\t   align_bytes,\n+\t\t\t\t\t\t\t   issetmem);\n+\n \t  count_exp = plus_constant (counter_mode (count_exp),\n \t\t\t\t     count_exp, -align_bytes);\n \t  count -= align_bytes;\n@@ -23277,6 +23389,8 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n       LABEL_NUSES (label) = 1;\n       label = NULL;\n       epilogue_size_needed = 1;\n+      if (issetmem)\n+\tpromoted_val = val_exp;\n     }\n   else if (label == NULL_RTX)\n     epilogue_size_needed = size_needed;\n@@ -23292,29 +23406,35 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     case loop_1_byte:\n     case loop:\n     case unrolled_loop:\n-    case vector_loop:\n-      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, NULL,\n+      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg, promoted_val,\n \t\t\t\t     count_exp, move_mode, unroll_factor,\n-\t\t\t\t     expected_size);\n+\t\t\t\t     expected_size, issetmem);\n+      break;\n+    case vector_loop:\n+      expand_set_or_movmem_via_loop (dst, src, destreg, srcreg,\n+\t\t\t\t     vec_promoted_val, count_exp, move_mode,\n+\t\t\t\t     unroll_factor, expected_size, issetmem);\n       break;\n     case rep_prefix_8_byte:\n     case rep_prefix_4_byte:\n     case rep_prefix_1_byte:\n-      expand_movmem_via_rep_mov (dst, src, destreg, srcreg, count_exp,\n-\t\t\t\t move_mode);\n+      expand_set_or_movmem_via_rep (dst, src, destreg, srcreg, promoted_val,\n+\t\t\t\t       val_exp, count_exp, move_mode, issetmem);\n       break;\n     }\n   /* Adjust properly the offset of src and dest memory for aliasing.  */\n   if (CONST_INT_P (count_exp))\n     {\n-      src = adjust_automodify_address_nv (src, BLKmode, srcreg,\n-\t\t\t\t\t  (count / size_needed) * size_needed);\n+      if (!issetmem)\n+\tsrc = adjust_automodify_address_nv (src, BLKmode, srcreg,\n+\t\t\t\t\t    (count / size_needed) * size_needed);\n       dst = adjust_automodify_address_nv (dst, BLKmode, destreg,\n \t\t\t\t\t  (count / size_needed) * size_needed);\n     }\n   else\n     {\n-      src = change_address (src, BLKmode, srcreg);\n+      if (!issetmem)\n+\tsrc = change_address (src, BLKmode, srcreg);\n       dst = change_address (dst, BLKmode, destreg);\n     }\n \n@@ -23323,7 +23443,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   if (label)\n     {\n       /* When the main loop is done, COUNT_EXP might hold original count,\n- \t while we want to copy only COUNT_EXP & SIZE_NEEDED bytes.\n+\t while we want to copy only COUNT_EXP & SIZE_NEEDED bytes.\n \t Epilogue code will actually copy COUNT_EXP & EPILOGUE_SIZE_NEEDED\n \t bytes. Compensate if needed.  */\n \n@@ -23341,408 +23461,45 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n     }\n \n   if (count_exp != const0_rtx && epilogue_size_needed > 1)\n-    expand_movmem_epilogue (dst, src, destreg, srcreg, count_exp,\n-\t\t\t    epilogue_size_needed);\n-  if (jump_around_label)\n-    emit_label (jump_around_label);\n-  return true;\n-}\n-\n-/* Helper function for memcpy.  For QImode value 0xXY produce\n-   0xXYXYXYXY of wide specified by MODE.  This is essentially\n-   a * 0x10101010, but we can do slightly better than\n-   synth_mult by unwinding the sequence by hand on CPUs with\n-   slow multiply.  */\n-static rtx\n-promote_duplicated_reg (enum machine_mode mode, rtx val)\n-{\n-  enum machine_mode valmode = GET_MODE (val);\n-  rtx tmp;\n-  int nops = mode == DImode ? 3 : 2;\n-\n-  gcc_assert (mode == SImode || mode == DImode);\n-  if (val == const0_rtx)\n-    return copy_to_mode_reg (mode, const0_rtx);\n-  if (CONST_INT_P (val))\n-    {\n-      HOST_WIDE_INT v = INTVAL (val) & 255;\n-\n-      v |= v << 8;\n-      v |= v << 16;\n-      if (mode == DImode)\n-        v |= (v << 16) << 16;\n-      return copy_to_mode_reg (mode, gen_int_mode (v, mode));\n-    }\n-\n-  if (valmode == VOIDmode)\n-    valmode = QImode;\n-  if (valmode != QImode)\n-    val = gen_lowpart (QImode, val);\n-  if (mode == QImode)\n-    return val;\n-  if (!TARGET_PARTIAL_REG_STALL)\n-    nops--;\n-  if (ix86_cost->mult_init[mode == DImode ? 3 : 2]\n-      + ix86_cost->mult_bit * (mode == DImode ? 8 : 4)\n-      <= (ix86_cost->shift_const + ix86_cost->add) * nops\n-          + (COSTS_N_INSNS (TARGET_PARTIAL_REG_STALL == 0)))\n     {\n-      rtx reg = convert_modes (mode, QImode, val, true);\n-      tmp = promote_duplicated_reg (mode, const1_rtx);\n-      return expand_simple_binop (mode, MULT, reg, tmp, NULL, 1,\n-\t\t\t\t  OPTAB_DIRECT);\n-    }\n-  else\n-    {\n-      rtx reg = convert_modes (mode, QImode, val, true);\n-\n-      if (!TARGET_PARTIAL_REG_STALL)\n-\tif (mode == SImode)\n-\t  emit_insn (gen_movsi_insv_1 (reg, reg));\n-\telse\n-\t  emit_insn (gen_movdi_insv_1 (reg, reg));\n+      if (force_loopy_epilogue)\n+\texpand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n+\t\t\t\t\t epilogue_size_needed);\n       else\n \t{\n-\t  tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (8),\n-\t\t\t\t     NULL, 1, OPTAB_DIRECT);\n-\t  reg =\n-\t    expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n+\t  if (issetmem)\n+\t    expand_setmem_epilogue (dst, destreg, promoted_val,\n+\t\t\t\t    vec_promoted_val, count_exp,\n+\t\t\t\t    epilogue_size_needed);\n+\t  else\n+\t    expand_movmem_epilogue (dst, src, destreg, srcreg, count_exp,\n+\t\t\t\t    epilogue_size_needed);\n \t}\n-      tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (16),\n-\t\t\t         NULL, 1, OPTAB_DIRECT);\n-      reg = expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n-      if (mode == SImode)\n-\treturn reg;\n-      tmp = expand_simple_binop (mode, ASHIFT, reg, GEN_INT (32),\n-\t\t\t\t NULL, 1, OPTAB_DIRECT);\n-      reg = expand_simple_binop (mode, IOR, reg, tmp, reg, 1, OPTAB_DIRECT);\n-      return reg;\n     }\n+  if (jump_around_label)\n+    emit_label (jump_around_label);\n+  return true;\n }\n \n-/* Duplicate value VAL using promote_duplicated_reg into maximal size that will\n-   be needed by main loop copying SIZE_NEEDED chunks and prologue getting\n-   alignment from ALIGN to DESIRED_ALIGN.  */\n-static rtx\n-promote_duplicated_reg_to_size (rtx val, int size_needed, int desired_align, int align)\n+/* Wrapper for ix86_expand_set_or_movmem for memcpy case.  */\n+bool\n+ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n+\t\t    rtx expected_align_exp, rtx expected_size_exp)\n {\n-  rtx promoted_val;\n-\n-  if (TARGET_64BIT\n-      && (size_needed > 4 || (desired_align > align && desired_align > 4)))\n-    promoted_val = promote_duplicated_reg (DImode, val);\n-  else if (size_needed > 2 || (desired_align > align && desired_align > 2))\n-    promoted_val = promote_duplicated_reg (SImode, val);\n-  else if (size_needed > 1 || (desired_align > align && desired_align > 1))\n-    promoted_val = promote_duplicated_reg (HImode, val);\n-  else\n-    promoted_val = val;\n-\n-  return promoted_val;\n+  return ix86_expand_set_or_movmem (dst, src, count_exp, NULL, align_exp,\n+\t\t    expected_align_exp, expected_size_exp, false);\n }\n \n-/* Expand string clear operation (bzero).  Use i386 string operations when\n-   profitable.  See expand_movmem comment for explanation of individual\n-   steps performed.  */\n+/* Wrapper for ix86_expand_set_or_movmem for memset case.  */\n bool\n ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n \t\t    rtx expected_align_exp, rtx expected_size_exp)\n {\n-  rtx destreg;\n-  rtx label = NULL;\n-  rtx tmp;\n-  rtx jump_around_label = NULL;\n-  HOST_WIDE_INT align = 1;\n-  unsigned HOST_WIDE_INT count = 0;\n-  HOST_WIDE_INT expected_size = -1;\n-  int size_needed = 0, epilogue_size_needed;\n-  int desired_align = 0, align_bytes = 0;\n-  enum stringop_alg alg;\n-  rtx promoted_val = NULL;\n-  bool force_loopy_epilogue = false;\n-  int dynamic_check;\n-  bool need_zero_guard = false;\n-  bool noalign;\n-  enum machine_mode move_mode = VOIDmode;\n-  int unroll_factor;\n-\n-  if (CONST_INT_P (align_exp))\n-    align = INTVAL (align_exp);\n-  /* i386 can do misaligned access on reasonably increased cost.  */\n-  if (CONST_INT_P (expected_align_exp)\n-      && INTVAL (expected_align_exp) > align)\n-    align = INTVAL (expected_align_exp);\n-  if (CONST_INT_P (count_exp))\n-    count = expected_size = INTVAL (count_exp);\n-  if (CONST_INT_P (expected_size_exp) && count == 0)\n-    expected_size = INTVAL (expected_size_exp);\n-\n-  /* Make sure we don't need to care about overflow later on.  */\n-  if (count > ((unsigned HOST_WIDE_INT) 1 << 30))\n-    return false;\n-\n-  /* Step 0: Decide on preferred algorithm, desired alignment and\n-     size of chunks to be copied by main loop.  */\n-\n-  alg = decide_alg (count, expected_size, true, &dynamic_check, &noalign);\n-  if (alg == libcall)\n-    return false;\n-  gcc_assert (alg != no_stringop);\n-\n-  if (!count)\n-    count_exp = copy_to_mode_reg (counter_mode (count_exp), count_exp);\n-  destreg = ix86_copy_addr_to_reg (XEXP (dst, 0));\n-\n-  move_mode = word_mode;\n-  unroll_factor = 1;\n-  switch (alg)\n-    {\n-    case libcall:\n-    case no_stringop:\n-    case last_alg:\n-      gcc_unreachable ();\n-    case loop:\n-      need_zero_guard = true;\n-      break;\n-    case vector_loop:\n-    case unrolled_loop:\n-      need_zero_guard = true;\n-      unroll_factor = 4;\n-      break;\n-    case rep_prefix_8_byte:\n-      move_mode = DImode;\n-      break;\n-    case rep_prefix_4_byte:\n-      move_mode = SImode;\n-      break;\n-    case rep_prefix_1_byte:\n-      move_mode = QImode;\n-      break;\n-    case loop_1_byte:\n-      need_zero_guard = true;\n-      move_mode = QImode;\n-      break;\n-    }\n-  size_needed = GET_MODE_SIZE (move_mode) * unroll_factor;\n-  epilogue_size_needed = size_needed;\n-\n-  desired_align = decide_alignment (align, alg, expected_size, move_mode);\n-  if (!TARGET_ALIGN_STRINGOPS || noalign)\n-    align = desired_align;\n-\n-  /* Step 1: Prologue guard.  */\n-\n-  /* Alignment code needs count to be in register.  */\n-  if (CONST_INT_P (count_exp) && desired_align > align)\n-    {\n-      if (INTVAL (count_exp) > desired_align\n-\t  && INTVAL (count_exp) > size_needed)\n-\t{\n-\t  align_bytes\n-\t    = get_mem_align_offset (dst, desired_align * BITS_PER_UNIT);\n-\t  if (align_bytes <= 0)\n-\t    align_bytes = 0;\n-\t  else\n-\t    align_bytes = desired_align - align_bytes;\n-\t}\n-      if (align_bytes == 0)\n-\t{\n-\t  enum machine_mode mode = SImode;\n-\t  if (TARGET_64BIT && (count & ~0xffffffff))\n-\t    mode = DImode;\n-\t  count_exp = force_reg (mode, count_exp);\n-\t}\n-    }\n-  /* Do the cheap promotion to allow better CSE across the\n-     main loop and epilogue (ie one load of the big constant in the\n-     front of all code.  */\n-  if (CONST_INT_P (val_exp))\n-    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n-\t\t\t\t\t\t   desired_align, align);\n-  /* Ensure that alignment prologue won't copy past end of block.  */\n-  if (size_needed > 1 || (desired_align > 1 && desired_align > align))\n-    {\n-      epilogue_size_needed = MAX (size_needed - 1, desired_align - align);\n-      /* Epilogue always copies COUNT_EXP & (EPILOGUE_SIZE_NEEDED - 1) bytes.\n-\t Make sure it is power of 2.  */\n-      epilogue_size_needed = 1 << (floor_log2 (epilogue_size_needed) + 1);\n-\n-      /* To improve performance of small blocks, we jump around the VAL\n-\t promoting mode.  This mean that if the promoted VAL is not constant,\n-\t we might not use it in the epilogue and have to use byte\n-\t loop variant.  */\n-      if (epilogue_size_needed > 2 && !promoted_val)\n-        force_loopy_epilogue = true;\n-      if (count)\n-\t{\n-\t  if (count < (unsigned HOST_WIDE_INT)epilogue_size_needed)\n-\t    {\n-\t      /* If main algorithm works on QImode, no epilogue is needed.\n-\t\t For small sizes just don't align anything.  */\n-\t      if (size_needed == 1)\n-\t\tdesired_align = align;\n-\t      else\n-\t\tgoto epilogue;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (count_exp,\n-\t\t\t\t   GEN_INT (epilogue_size_needed),\n-\t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n-\t  if (expected_size == -1 || expected_size <= epilogue_size_needed)\n-\t    predict_jump (REG_BR_PROB_BASE * 60 / 100);\n-\t  else\n-\t    predict_jump (REG_BR_PROB_BASE * 20 / 100);\n-\t}\n-    }\n-  if (dynamic_check != -1)\n-    {\n-      rtx hot_label = gen_label_rtx ();\n-      jump_around_label = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (count_exp, GEN_INT (dynamic_check - 1),\n-\t\t\t       LEU, 0, counter_mode (count_exp), 1, hot_label);\n-      predict_jump (REG_BR_PROB_BASE * 90 / 100);\n-      set_storage_via_libcall (dst, count_exp, val_exp, false);\n-      emit_jump (jump_around_label);\n-      emit_label (hot_label);\n-    }\n-\n-  /* Step 2: Alignment prologue.  */\n-\n-  /* Do the expensive promotion once we branched off the small blocks.  */\n-  if (!promoted_val)\n-    promoted_val = promote_duplicated_reg_to_size (val_exp, size_needed,\n-\t\t\t\t\t\t   desired_align, align);\n-  gcc_assert (desired_align >= 1 && align >= 1);\n-\n-  if (desired_align > align)\n-    {\n-      if (align_bytes == 0)\n-\t{\n-\t  /* Except for the first move in epilogue, we no longer know\n-\t     constant offset in aliasing info.  It don't seems to worth\n-\t     the pain to maintain it for the first move, so throw away\n-\t     the info early.  */\n-\t  dst = change_address (dst, BLKmode, destreg);\n-\t  expand_setmem_prologue (dst, destreg, promoted_val, count_exp, align,\n-\t\t\t\t  desired_align);\n-\t}\n-      else\n-\t{\n-\t  /* If we know how many bytes need to be stored before dst is\n-\t     sufficiently aligned, maintain aliasing info accurately.  */\n-\t  dst = expand_constant_setmem_prologue (dst, destreg, promoted_val,\n-\t\t\t\t\t\t desired_align, align_bytes);\n-\t  count_exp = plus_constant (counter_mode (count_exp),\n-\t\t\t\t     count_exp, -align_bytes);\n-\t  count -= align_bytes;\n-\t}\n-      if (need_zero_guard\n-\t  && (count < (unsigned HOST_WIDE_INT) size_needed\n-\t      || (align_bytes == 0\n-\t\t  && count < ((unsigned HOST_WIDE_INT) size_needed\n-\t\t\t      + desired_align - align))))\n-\t{\n-\t  /* It is possible that we copied enough so the main loop will not\n-\t     execute.  */\n-\t  gcc_assert (size_needed > 1);\n-\t  if (label == NULL_RTX)\n-\t    label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (count_exp,\n-\t\t\t\t   GEN_INT (size_needed),\n-\t\t\t\t   LTU, 0, counter_mode (count_exp), 1, label);\n-\t  if (expected_size == -1\n-\t      || expected_size < (desired_align - align) / 2 + size_needed)\n-\t    predict_jump (REG_BR_PROB_BASE * 20 / 100);\n-\t  else\n-\t    predict_jump (REG_BR_PROB_BASE * 60 / 100);\n-\t}\n-    }\n-  if (label && size_needed == 1)\n-    {\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-      label = NULL;\n-      promoted_val = val_exp;\n-      epilogue_size_needed = 1;\n-    }\n-  else if (label == NULL_RTX)\n-    epilogue_size_needed = size_needed;\n-\n-  /* Step 3: Main loop.  */\n-\n-  switch (alg)\n-    {\n-    case libcall:\n-    case no_stringop:\n-    case last_alg:\n-      gcc_unreachable ();\n-    case loop_1_byte:\n-    case loop:\n-    case vector_loop:\n-    case unrolled_loop:\n-      expand_set_or_movmem_via_loop (dst, NULL, destreg, NULL, promoted_val,\n-\t\t\t\t     count_exp, move_mode, unroll_factor,\n-\t\t\t\t     expected_size);\n-      break;\n-    case rep_prefix_8_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n-\t\t\t\t  DImode, val_exp);\n-      break;\n-    case rep_prefix_4_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n-\t\t\t\t  SImode, val_exp);\n-      break;\n-    case rep_prefix_1_byte:\n-      expand_setmem_via_rep_stos (dst, destreg, promoted_val, count_exp,\n-\t\t\t\t  QImode, val_exp);\n-      break;\n-    }\n-  /* Adjust properly the offset of src and dest memory for aliasing.  */\n-  if (CONST_INT_P (count_exp))\n-    dst = adjust_automodify_address_nv (dst, BLKmode, destreg,\n-\t\t\t\t\t(count / size_needed) * size_needed);\n-  else\n-    dst = change_address (dst, BLKmode, destreg);\n-\n-  /* Step 4: Epilogue to copy the remaining bytes.  */\n-\n-  if (label)\n-    {\n-      /* When the main loop is done, COUNT_EXP might hold original count,\n- \t while we want to copy only COUNT_EXP & SIZE_NEEDED bytes.\n-\t Epilogue code will actually copy COUNT_EXP & EPILOGUE_SIZE_NEEDED\n-\t bytes. Compensate if needed.  */\n-\n-      if (size_needed < epilogue_size_needed)\n-\t{\n-\t  tmp =\n-\t    expand_simple_binop (counter_mode (count_exp), AND, count_exp,\n-\t\t\t\t GEN_INT (size_needed - 1), count_exp, 1,\n-\t\t\t\t OPTAB_DIRECT);\n-\t  if (tmp != count_exp)\n-\t    emit_move_insn (count_exp, tmp);\n-\t}\n-      emit_label (label);\n-      LABEL_NUSES (label) = 1;\n-    }\n- epilogue:\n-  if (count_exp != const0_rtx && epilogue_size_needed > 1)\n-    {\n-      if (force_loopy_epilogue)\n-\texpand_setmem_epilogue_via_loop (dst, destreg, val_exp, count_exp,\n-\t\t\t\t\t epilogue_size_needed);\n-      else\n-\texpand_setmem_epilogue (dst, destreg, promoted_val, count_exp,\n-\t\t\t\tepilogue_size_needed);\n-    }\n-  if (jump_around_label)\n-    emit_label (jump_around_label);\n-  return true;\n+  return ix86_expand_set_or_movmem (dst, NULL, count_exp, val_exp, align_exp,\n+\t\t      expected_align_exp, expected_size_exp, true);\n }\n \n+\n /* Expand the appropriate insns for doing strlen if not just doing\n    repnz; scasb\n "}, {"sha": "7acbd3b9b9e173c0d01a03095e7a0037cc6b6426", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d606b917e1c986eee196ced3db2d3ab318b50430", "patch": "@@ -1,3 +1,8 @@\n+2013-10-21  Michael Zolotukhin  <michael.v.zolotukhin@gmail.com>\n+\n+\t* gcc.target/i386/memset-vector_loop-1.c: New test.\n+\t* gcc.target/i386/memset-vector_loop-2.c: New test.\n+\n 2013-10-20  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.target/mips/mips-ps-5.c: Add alignment attributes."}, {"sha": "ad0d130371bd494d7e6d07e957c6bb464eedbf65", "filename": "gcc/testsuite/gcc.target/i386/memset-vector_loop-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-1.c?ref=d606b917e1c986eee196ced3db2d3ab318b50430", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -minline-all-stringops -mstringop-strategy=vector_loop\" } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 4 } } */\n+\n+char a[2048];\n+void t (void)\n+{\n+  __builtin_memset (a, 0, 2048);\n+}\n+\n+"}, {"sha": "f2ceb442c7bcd6b420b1160b3de72fdb2d4b9979", "filename": "gcc/testsuite/gcc.target/i386/memset-vector_loop-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d606b917e1c986eee196ced3db2d3ab318b50430/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fmemset-vector_loop-2.c?ref=d606b917e1c986eee196ced3db2d3ab318b50430", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=atom -minline-all-stringops -mstringop-strategy=vector_loop\" } */\n+/* { dg-final { scan-assembler-times \"movdqa\" 4} } */\n+\n+char *a;\n+void t (void)\n+{\n+  __builtin_memset (a, 0, 2048);\n+}\n+"}]}