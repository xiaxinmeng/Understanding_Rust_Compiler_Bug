{"sha": "9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "node_id": "C_kwDOANBUbNoAKDlmNzNlODI3YWJhMmQ0ODU4OThlOWMyZDNkNGFkY2NhMWIyY2Y3N2Q", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-09T16:30:35Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@epita.fr", "date": "2022-03-10T20:45:34Z"}, "message": "macros: Add abstraction around multiple matches\n\nAdds an extra layer of abstraction around keeping multiple matches for\nthe same fragment. This avoids ugly code fetching the first match in\norder to get the amounf of matches given by the user, while still\nallowing zero-matches to exist.\n\nCo-authored-by: philberty <philip.herron@embecosm.com>", "tree": {"sha": "a55b255cbd043db814cc6b736559f76d8fd982ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a55b255cbd043db814cc6b736559f76d8fd982ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c04258300be68a36b80f2f23929a97e8af1865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c04258300be68a36b80f2f23929a97e8af1865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c04258300be68a36b80f2f23929a97e8af1865"}], "stats": {"total": 149, "additions": 99, "deletions": 50}, "files": [{"sha": "00316792840ad558f24d26791ab808953d51b6e7", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "patch": "@@ -3102,7 +3102,7 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n \n   // find matching arm\n   AST::MacroRule *matched_rule = nullptr;\n-  std::map<std::string, std::vector<MatchedFragment>> matched_fragments;\n+  std::map<std::string, MatchedFragmentContainer> matched_fragments;\n   for (auto &rule : rules_def.get_rules ())\n     {\n       sub_stack.push ();\n@@ -3111,9 +3111,10 @@ MacroExpander::expand_decl_macro (Location invoc_locus,\n \n       if (did_match_rule)\n \t{\n-\t  for (auto &kv : matched_fragments)\n-\t    rust_debug (\"[fragment]: %s (%ld)\", kv.first.c_str (),\n-\t\t\tkv.second.size ());\n+\t  // Debugging\n+\t  //   for (auto &kv : matched_fragments)\n+\t  //     rust_debug (\"[fragment]: %s (%ld)\", kv.first.c_str (),\n+\t  // \t\tkv.second.get_fragments ().size ());\n \n \t  matched_rule = &rule;\n \t  break;\n@@ -3726,7 +3727,10 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n   rust_debug_loc (rep.get_match_locus (), \"%s matched %lu times\",\n \t\t  res ? \"successfully\" : \"unsuccessfully\", match_amount);\n \n-  // We can now set the amount to each fragment we matched in the substack\n+  // We have to handle zero fragments differently: They will not have been\n+  // \"matched\" but they are still valid and should be inserted as a special\n+  // case. So we go through the stack map, and for every fragment which doesn't\n+  // exist, insert a zero-matched fragment.\n   auto &stack_map = sub_stack.peek ();\n   for (auto &match : rep.get_matches ())\n     {\n@@ -3736,20 +3740,9 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n \t  auto fragment = static_cast<AST::MacroMatchFragment *> (match.get ());\n \t  auto it = stack_map.find (fragment->get_ident ());\n \n-\t  // If we can't find the fragment, but the result was valid, then\n-\t  // it's a zero-matched fragment and we can insert it\n \t  if (it == stack_map.end ())\n-\t    {\n-\t      sub_stack.insert_fragment (\n-\t\tMatchedFragment::zero (fragment->get_ident ()));\n-\t    }\n-\t  else\n-\t    {\n-\t      // We can just set the repetition amount on the first match\n-\t      // FIXME: Make this more ergonomic and similar to what we fetch\n-\t      // in `substitute_repetition`\n-\t      it->second[0].set_match_amount (match_amount);\n-\t    }\n+\t    sub_stack.insert_matches (fragment->get_ident (),\n+\t\t\t\t      MatchedFragmentContainer::zero ());\n \t}\n     }\n \n@@ -3759,7 +3752,7 @@ MacroExpander::match_repetition (Parser<MacroInvocLexer> &parser,\n AST::ASTFragment\n MacroExpander::transcribe_rule (\n   AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n-  std::map<std::string, std::vector<MatchedFragment>> &matched_fragments,\n+  std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n   bool semicolon, ContextType ctx)\n {\n   // we can manipulate the token tree to substitute the dollar identifiers so"}, {"sha": "dd48cbd50783cee7dc7a62e1bdb9a3f47e1b2eb2", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "patch": "@@ -54,32 +54,78 @@ struct MatchedFragment\n   std::string fragment_ident;\n   size_t token_offset_begin;\n   size_t token_offset_end;\n-  size_t match_amount;\n \n   MatchedFragment (std::string identifier, size_t token_offset_begin,\n-\t\t   size_t token_offset_end, size_t match_amount = 1)\n+\t\t   size_t token_offset_end)\n     : fragment_ident (identifier), token_offset_begin (token_offset_begin),\n-      token_offset_end (token_offset_end), match_amount (match_amount)\n+      token_offset_end (token_offset_end)\n+  {}\n+\n+  /**\n+   * Empty constructor for uninitialized fragments\n+   */\n+  MatchedFragment () : MatchedFragment (\"\", 0, 0) {}\n+\n+  std::string as_string () const\n+  {\n+    return fragment_ident + \"=\" + std::to_string (token_offset_begin) + \":\"\n+\t   + std::to_string (token_offset_end);\n+  }\n+};\n+\n+class MatchedFragmentContainer\n+{\n+public:\n+  MatchedFragmentContainer (std::vector<MatchedFragment> fragments)\n+    : fragments (fragments)\n   {}\n \n   /**\n    * Create a valid fragment matched zero times. This is useful for repetitions\n    * which allow the absence of a fragment, such as * and ?\n    */\n-  static MatchedFragment zero (std::string identifier)\n+  static MatchedFragmentContainer zero ()\n   {\n-    // We don't need offsets since there is \"no match\"\n-    return MatchedFragment (identifier, 0, 0, 0);\n+    return MatchedFragmentContainer ({});\n   }\n \n-  std::string as_string () const\n+  /**\n+   * Create a valid fragment matched one time\n+   */\n+  static MatchedFragmentContainer one (MatchedFragment fragment)\n   {\n-    return fragment_ident + \"=\" + std::to_string (token_offset_begin) + \":\"\n-\t   + std::to_string (token_offset_end) + \" (matched \"\n-\t   + std::to_string (match_amount) + \" times)\";\n+    return MatchedFragmentContainer ({fragment});\n   }\n \n-  void set_match_amount (size_t new_amount) { match_amount = new_amount; }\n+  /**\n+   * Add a matched fragment to the container\n+   */\n+  void add_fragment (MatchedFragment fragment)\n+  {\n+    fragments.emplace_back (fragment);\n+  }\n+\n+  size_t get_match_amount () const { return fragments.size (); }\n+  const std::vector<MatchedFragment> &get_fragments () const\n+  {\n+    return fragments;\n+  }\n+  // const std::string &get_fragment_name () const { return fragment_name; }\n+\n+  bool is_single_fragment () const { return get_match_amount () == 1; }\n+  const MatchedFragment get_single_fragment () const\n+  {\n+    rust_assert (get_match_amount () == 1);\n+\n+    return fragments[0];\n+  }\n+\n+private:\n+  /**\n+   * Fragments matched `match_amount` times. This can be an empty vector\n+   * in case having zero matches is allowed (i.e ? or * operators)\n+   */\n+  std::vector<MatchedFragment> fragments;\n };\n \n class SubstitutionScope\n@@ -89,38 +135,49 @@ class SubstitutionScope\n \n   void push () { stack.push_back ({}); }\n \n-  std::map<std::string, std::vector<MatchedFragment>> pop ()\n+  std::map<std::string, MatchedFragmentContainer> pop ()\n   {\n     auto top = stack.back ();\n     stack.pop_back ();\n     return top;\n   }\n \n-  std::map<std::string, std::vector<MatchedFragment>> &peek ()\n+  std::map<std::string, MatchedFragmentContainer> &peek ()\n   {\n     return stack.back ();\n   }\n \n+  /**\n+   * Insert a new matched fragment into the current substitution map\n+   */\n   void insert_fragment (MatchedFragment fragment)\n   {\n     auto &current_map = stack.back ();\n     auto it = current_map.find (fragment.fragment_ident);\n \n     if (it == current_map.end ())\n       {\n-\tauto new_frags = std::vector<MatchedFragment> ();\n-\tnew_frags.emplace_back (fragment);\n-\tcurrent_map.insert ({fragment.fragment_ident, new_frags});\n+\tcurrent_map.insert (\n+\t  {fragment.fragment_ident, MatchedFragmentContainer::one (fragment)});\n       }\n     else\n       {\n \tauto &frags = it->second;\n-\tfrags.emplace_back (fragment);\n+\tfrags.add_fragment (fragment);\n       }\n   }\n \n+  void insert_matches (std::string key, MatchedFragmentContainer matches)\n+  {\n+    auto &current_map = stack.back ();\n+    auto it = current_map.find (key);\n+    rust_assert (it == current_map.end ());\n+\n+    current_map.insert ({key, matches});\n+  }\n+\n private:\n-  std::vector<std::map<std::string, std::vector<MatchedFragment>>> stack;\n+  std::vector<std::map<std::string, MatchedFragmentContainer>> stack;\n };\n \n // Object used to store shared data (between functions) for macro expansion.\n@@ -174,7 +231,7 @@ struct MacroExpander\n \n   AST::ASTFragment transcribe_rule (\n     AST::MacroRule &match_rule, AST::DelimTokenTree &invoc_token_tree,\n-    std::map<std::string, std::vector<MatchedFragment>> &matched_fragments,\n+    std::map<std::string, MatchedFragmentContainer> &matched_fragments,\n     bool semicolon, ContextType ctx);\n \n   bool match_fragment (Parser<MacroInvocLexer> &parser,"}, {"sha": "392a9fe42f1d6598cc1839570fe052bf021fa783", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.cc", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.cc?ref=9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "patch": "@@ -16,11 +16,9 @@ SubstituteCtx::substitute_metavar (std::unique_ptr<AST::Token> &metavar)\n     }\n   else\n     {\n-      // Replace\n       // We only care about the vector when expanding repetitions.\n       // Just access the first element of the vector.\n-      // FIXME: Clean this up so it makes more sense\n-      auto &frag = it->second[0];\n+      auto &frag = it->second.get_single_fragment ();\n       for (size_t offs = frag.token_offset_begin; offs < frag.token_offset_end;\n \t   offs++)\n \t{\n@@ -66,7 +64,7 @@ SubstituteCtx::substitute_repetition (\n \t\t}\n \n \t      // FIXME: Refactor, ugly\n-\t      repeat_amount = it->second[0].match_amount;\n+\t      repeat_amount = it->second.get_match_amount ();\n \t    }\n \t}\n     }\n@@ -98,19 +96,20 @@ SubstituteCtx::substitute_repetition (\n \n   for (size_t i = 0; i < repeat_amount; i++)\n     {\n-      std::map<std::string, std::vector<MatchedFragment>> sub_map;\n+      std::map<std::string, MatchedFragmentContainer> sub_map;\n       for (auto &kv_match : fragments)\n \t{\n-\t  std::vector<MatchedFragment> sub_vec;\n+\t  MatchedFragment sub_fragment;\n \n \t  // FIXME: Hack: If a fragment is not repeated, how does it fit in the\n \t  // submap? Do we really want to expand it? Is this normal behavior?\n-\t  if (kv_match.second.size () == 1)\n-\t    sub_vec.emplace_back (kv_match.second[0]);\n+\t  if (kv_match.second.is_single_fragment ())\n+\t    sub_fragment = kv_match.second.get_single_fragment ();\n \t  else\n-\t    sub_vec.emplace_back (kv_match.second[i]);\n+\t    sub_fragment = kv_match.second.get_fragments ()[i];\n \n-\t  sub_map.insert ({kv_match.first, sub_vec});\n+\t  sub_map.insert (\n+\t    {kv_match.first, MatchedFragmentContainer::one (sub_fragment)});\n \t}\n \n       auto substitute_context = SubstituteCtx (input, new_macro, sub_map);"}, {"sha": "e89f9d788a1e2eca73bb3e1ff9129191fa83ac31", "filename": "gcc/rust/expand/rust-macro-substitute-ctx.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f73e827aba2d485898e9c2d3d4adcca1b2cf77d/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-substitute-ctx.h?ref=9f73e827aba2d485898e9c2d3d4adcca1b2cf77d", "patch": "@@ -24,12 +24,12 @@ class SubstituteCtx\n {\n   std::vector<std::unique_ptr<AST::Token>> &input;\n   std::vector<std::unique_ptr<AST::Token>> &macro;\n-  std::map<std::string, std::vector<MatchedFragment>> &fragments;\n+  std::map<std::string, MatchedFragmentContainer> &fragments;\n \n public:\n   SubstituteCtx (std::vector<std::unique_ptr<AST::Token>> &input,\n \t\t std::vector<std::unique_ptr<AST::Token>> &macro,\n-\t\t std::map<std::string, std::vector<MatchedFragment>> &fragments)\n+\t\t std::map<std::string, MatchedFragmentContainer> &fragments)\n     : input (input), macro (macro), fragments (fragments)\n   {}\n "}]}