{"sha": "52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3MDJhZTE2ZWI4MGRjMWY2ZjY4YWY4ZWRlZGIzZGNkZWU2ZDZhMw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-07-02T18:45:49Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-07-02T18:45:49Z"}, "message": "sh.c (print_operand, case 'N'): Allow zero vector.\n\nTue Jul  2 18:45:45 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n\n\t* sh.c (print_operand, case 'N'): Allow zero vector.\n\t(arith_reg_or_0_operand): Likewise.\n\t(zero_vec_operand): Check for CONST_VECTOR, not PARALLEL.\n\t* sh.h (CONST_COSTS): 0 has 0 cost.  Check OUTER_CODE for\n\tIOR, XOR, PLUS and SET and take their respective constant\n\tranges into account.\n\t(PREDICATE_CODES, arith_reg_or_0_operand): Can be CONST_VECTOR.\n\t* sh.md (subdi3, subdi3_media): Allow zero operand.\n\t(movv8qi_i+3): Only vector that is not split is the zero vector.\n\tFix operand 3 to simplify_subreg.\n\t(movv2si_i): Split alternative 1.\n\t(mshfhi_l_di_rev+1): New splitter.\n\nIndex: config/sh/sh.c\n===================================================================\nRCS file: /cvs/gcc/gcc/gcc/config/sh/sh.c,v\nretrieving revision 1.155\ndiff -p -r1.155 sh.c\n*** config/sh/sh.c\t2 Jul 2002 04:01:04 -0000\t1.155\n--- config/sh/sh.c\t2 Jul 2002 17:45:37 -0000\n*************** print_operand (stream, x, code)\n*** 434,440 ****\n        break;\n\n      case 'N':\n!       if (x == const0_rtx)\n  \t{\n  \t  fprintf ((stream), \"r63\");\n  \t  break;\n--- 434,441 ----\n        break;\n\n      case 'N':\n!       if (x == const0_rtx\n! \t  || (GET_CODE (x) == CONST_VECTOR && zero_vec_operand (x, VOIDmode)))\n  \t{\n  \t  fprintf ((stream), \"r63\");\n  \t  break;\n*************** arith_reg_or_0_operand (op, mode)\n*** 5940,5946 ****\n    if (arith_reg_operand (op, mode))\n      return 1;\n\n!   if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n      return 1;\n\n    return 0;\n--- 5941,5947 ----\n    if (arith_reg_operand (op, mode))\n      return 1;\n\n!   if (EXTRA_CONSTRAINT_U (op))\n      return 1;\n\n    return 0;\n*************** zero_vec_operand (v, mode)\n*** 6222,6228 ****\n  {\n    int i;\n\n!   if (GET_CODE (v) != PARALLEL\n        || (GET_MODE (v) != mode && mode != VOIDmode))\n      return 0;\n    for (i = XVECLEN (v, 0) - 1; i >= 0; i--)\n--- 6223,6229 ----\n  {\n    int i;\n\n!   if (GET_CODE (v) != CONST_VECTOR\n        || (GET_MODE (v) != mode && mode != VOIDmode))\n      return 0;\n    for (i = XVECLEN (v, 0) - 1; i >= 0; i--)\nIndex: config/sh/sh.h\n===================================================================\nRCS file: /cvs/gcc/gcc/gcc/config/sh/sh.h,v\nretrieving revision 1.154\ndiff -p -r1.154 sh.h\n*** config/sh/sh.h\t1 Jul 2002 19:41:53 -0000\t1.154\n--- config/sh/sh.h\t2 Jul 2002 17:45:37 -0000\n*************** while (0)\n*** 2689,2698 ****\n    case CONST_INT:\t\t\t\t\\\n      if (TARGET_SHMEDIA)\t\t\t\t\\\n        {\t\t\t\t\t\t\\\n  \tif ((OUTER_CODE) == AND && and_operand ((RTX), DImode)) \\\n  \t  return 0;\t\t\t\t\\\n  \tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n!           return COSTS_N_INSNS (1);\t\t\\\n  \telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n  \t  return COSTS_N_INSNS (2);\t\t\\\n  \telse if (CONST_OK_FOR_J ((INTVAL (RTX) >> 16) >> 16)) \\\n--- 2689,2704 ----\n    case CONST_INT:\t\t\t\t\\\n      if (TARGET_SHMEDIA)\t\t\t\t\\\n        {\t\t\t\t\t\t\\\n+ \tif (INTVAL (RTX) == 0)\t\t\t\\\n+ \t  return 0;\t\t\t\t\\\n  \tif ((OUTER_CODE) == AND && and_operand ((RTX), DImode)) \\\n  \t  return 0;\t\t\t\t\\\n+ \tif (((OUTER_CODE) == IOR || (OUTER_CODE) == XOR \\\n+ \t     || (OUTER_CODE) == PLUS) \\\n+ \t    && CONST_OK_FOR_P (INTVAL (RTX)))\t\\\n+ \t  return 0;\t\t\t\t\\\n  \tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n!           return COSTS_N_INSNS ((OUTER_CODE) != SET);\t\t\\\n  \telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n  \t  return COSTS_N_INSNS (2);\t\t\\\n  \telse if (CONST_OK_FOR_J ((INTVAL (RTX) >> 16) >> 16)) \\\n*************** extern int rtx_equal_function_value_matt\n*** 3225,3231 ****\n    {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n    {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n    {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n!   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n    {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n    {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n    {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\n--- 3231,3237 ----\n    {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n    {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n    {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n!   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_VECTOR}},\t\\\n    {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n    {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n    {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\\nIndex: config/sh/sh.md\n===================================================================\nRCS file: /cvs/gcc/gcc/gcc/config/sh/sh.md,v\nretrieving revision 1.107\ndiff -p -r1.107 sh.md\n*** config/sh/sh.md\t1 Jul 2002 19:41:54 -0000\t1.107\n--- config/sh/sh.md\t2 Jul 2002 17:45:38 -0000\n***************\n*** 546,552 ****\n  ;; There is no way to model this with gcc's function units.  This problem is\n  ;; actually mentioned in md.texi.  Tackling this problem requires first that\n  ;; it is possible to speak about the target in an open discussion.\n! ;;\n  ;; However, simple double-precision operations always conflict.\n\n  (define_function_unit \"fp\"    1 0\n--- 546,552 ----\n  ;; There is no way to model this with gcc's function units.  This problem is\n  ;; actually mentioned in md.texi.  Tackling this problem requires first that\n  ;; it is possible to speak about the target in an open discussion.\n! ;;\n  ;; However, simple double-precision operations always conflict.\n\n  (define_function_unit \"fp\"    1 0\n***************\n*** 1048,1054 ****\n    \"@\n  \taddz.l\t%1, %2, %0\n  \taddz.l\t%1, r63, %0\")\n!\n  (define_insn \"adddi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n--- 1048,1054 ----\n    \"@\n  \taddz.l\t%1, %2, %0\n  \taddz.l\t%1, r63, %0\")\n!\n  (define_insn \"adddi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n***************\n*** 1122,1128 ****\n    \"@\n  \tadd.l\t%1, %2, %0\n  \taddi.l\t%1, %2, %0\")\n!\n  (define_insn \"*addsi3_compact\"\n    [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n  \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n--- 1122,1128 ----\n    \"@\n  \tadd.l\t%1, %2, %0\n  \taddi.l\t%1, %2, %0\")\n!\n  (define_insn \"*addsi3_compact\"\n    [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n  \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n***************\n*** 1138,1162 ****\n\n  (define_expand \"subdi3\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n! \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n  \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"\")))]\n    \"\"\n    \"\n  {\n    if (TARGET_SH1)\n      {\n        emit_insn (gen_subdi3_compact (operands[0], operands[1], operands[2]));\n        DONE;\n      }\n  }\")\n!\n  (define_insn \"*subdi3_media\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n! \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n  \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n    \"TARGET_SHMEDIA\"\n!   \"sub\t%1, %2, %0\")\n!\n  (define_insn \"subdi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n--- 1138,1163 ----\n\n  (define_expand \"subdi3\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n! \t(minus:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n  \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"\")))]\n    \"\"\n    \"\n  {\n    if (TARGET_SH1)\n      {\n+       operands[1] = force_reg (DImode, operands[1]);\n        emit_insn (gen_subdi3_compact (operands[0], operands[1], operands[2]));\n        DONE;\n      }\n  }\")\n!\n  (define_insn \"*subdi3_media\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n! \t(minus:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rN\")\n  \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n    \"TARGET_SHMEDIA\"\n!   \"sub\t%N1, %2, %0\")\n!\n  (define_insn \"subdi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n***************\n*** 1558,1564 ****\n  \t\t\t\t\t   : \\\"__sdivsi3\\\")));\n\n        if (TARGET_SHMEDIA)\n! \tlast = gen_divsi3_i1_media (operands[0],\n  \t\t\t\t    Pmode == DImode\n  \t\t\t\t    ? operands[3]\n  \t\t\t\t    : gen_rtx_SUBREG (DImode, operands[3],\n--- 1559,1565 ----\n  \t\t\t\t\t   : \\\"__sdivsi3\\\")));\n\n        if (TARGET_SHMEDIA)\n! \tlast = gen_divsi3_i1_media (operands[0],\n  \t\t\t\t    Pmode == DImode\n  \t\t\t\t    ? operands[3]\n  \t\t\t\t    : gen_rtx_SUBREG (DImode, operands[3],\n***************\n*** 1771,1777 ****\n  \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n    \"TARGET_SHMEDIA\"\n    \"muls.l\t%1, %2, %0\")\n!\n  (define_insn \"mulsidi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(mult:DI\n--- 1772,1778 ----\n  \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n    \"TARGET_SHMEDIA\"\n    \"muls.l\t%1, %2, %0\")\n!\n  (define_insn \"mulsidi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(mult:DI\n***************\n*** 1841,1847 ****\n  \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n    \"TARGET_SHMEDIA\"\n    \"mulu.l\t%1, %2, %0\")\n!\n  (define_insn \"umulsidi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(mult:DI\n--- 1842,1848 ----\n  \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n    \"TARGET_SHMEDIA\"\n    \"mulu.l\t%1, %2, %0\")\n!\n  (define_insn \"umulsidi3_compact\"\n    [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n  \t(mult:DI\n***************\n*** 3440,3446 ****\n     (set_attr \"type\" \"pcload,move,load,store,move,pcload,move,move\")])\n\n  ;; If the output is a register and the input is memory or a register, we have\n! ;; to be careful and see which word needs to be loaded first.\n\n  (define_split\n    [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n--- 3441,3447 ----\n     (set_attr \"type\" \"pcload,move,load,store,move,pcload,move,move\")])\n\n  ;; If the output is a register and the input is memory or a register, we have\n! ;; to be careful and see which word needs to be loaded first.\n\n  (define_split\n    [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n***************\n*** 4195,4201 ****\n  }\")\n\n  ;; If the output is a register and the input is memory or a register, we have\n! ;; to be careful and see which word needs to be loaded first.\n\n  (define_split\n    [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n--- 4196,4202 ----\n  }\")\n\n  ;; If the output is a register and the input is memory or a register, we have\n! ;; to be careful and see which word needs to be loaded first.\n\n  (define_split\n    [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n***************\n*** 4392,4398 ****\n    DONE;\n  }\"\n    [(set_attr \"length\" \"8\")])\n!\n  (define_expand \"movv4sf\"\n    [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n  \t(match_operand:V4SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n--- 4393,4399 ----\n    DONE;\n  }\"\n    [(set_attr \"length\" \"8\")])\n!\n  (define_expand \"movv4sf\"\n    [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n  \t(match_operand:V4SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n***************\n*** 4444,4450 ****\n    DONE;\n  }\"\n    [(set_attr \"length\" \"32\")])\n!\n  (define_expand \"movv16sf\"\n    [(set (match_operand:V16SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n  \t(match_operand:V16SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n--- 4445,4451 ----\n    DONE;\n  }\"\n    [(set_attr \"length\" \"32\")])\n!\n  (define_expand \"movv16sf\"\n    [(set (match_operand:V16SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n  \t(match_operand:V16SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n***************\n*** 4499,4505 ****\n    REAL_VALUE_FROM_CONST_DOUBLE (value, operands[1]);\n    REAL_VALUE_TO_TARGET_SINGLE (value, values);\n    operands[2] = GEN_INT (values);\n!\n    operands[3] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n  }\")\n\n--- 4500,4506 ----\n    REAL_VALUE_FROM_CONST_DOUBLE (value, operands[1]);\n    REAL_VALUE_TO_TARGET_SINGLE (value, values);\n    operands[2] = GEN_INT (values);\n!\n    operands[3] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n  }\")\n\n***************\n*** 5410,5416 ****\n  \t  if (! SYMBOL_REF_FLAG (operands[0]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      emit_insn (gen_symGOTPLT2reg (reg, operands[0]));\n  \t      operands[0] = reg;\n  \t    }\n--- 5411,5417 ----\n  \t  if (! SYMBOL_REF_FLAG (operands[0]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      emit_insn (gen_symGOTPLT2reg (reg, operands[0]));\n  \t      operands[0] = reg;\n  \t    }\n***************\n*** 5634,5640 ****\n  \t  if (! SYMBOL_REF_FLAG (operands[1]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      emit_insn (gen_symGOTPLT2reg (reg, operands[1]));\n  \t      operands[1] = reg;\n  \t    }\n--- 5635,5641 ----\n  \t  if (! SYMBOL_REF_FLAG (operands[1]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      emit_insn (gen_symGOTPLT2reg (reg, operands[1]));\n  \t      operands[1] = reg;\n  \t    }\n***************\n*** 5841,5847 ****\n  \t  if (! SYMBOL_REF_FLAG (operands[0]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      /* We must not use GOTPLT for sibcalls, because PIC_REG\n  \t\t must be restored before the PLT code gets to run.  */\n  \t      emit_insn (gen_symGOT2reg (reg, operands[0]));\n--- 5842,5848 ----\n  \t  if (! SYMBOL_REF_FLAG (operands[0]))\n  \t    {\n  \t      rtx reg = gen_reg_rtx (Pmode);\n!\n  \t      /* We must not use GOTPLT for sibcalls, because PIC_REG\n  \t\t must be restored before the PLT code gets to run.  */\n  \t      emit_insn (gen_symGOT2reg (reg, operands[0]));\n***************\n*** 6167,6173 ****\n     (use (label_ref (match_operand 1 \"\" \"\")))]\n    \"TARGET_SHMEDIA\"\n    \"blink\t%0, r63\")\n!\n  ;; Call subroutine returning any type.\n  ;; ??? This probably doesn't work.\n\n--- 6168,6174 ----\n     (use (label_ref (match_operand 1 \"\" \"\")))]\n    \"TARGET_SHMEDIA\"\n    \"blink\t%0, r63\")\n!\n  ;; Call subroutine returning any type.\n  ;; ??? This probably doesn't work.\n\n***************\n*** 6284,6290 ****\n  \ttr = gen_rtx_SUBREG (GET_MODE (operands[0]), tr, 0);\n\n        insn = emit_move_insn (operands[0], tr);\n!\n        REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, equiv,\n  \t\t\t\t\t    REG_NOTES (insn));\n\n--- 6285,6291 ----\n  \ttr = gen_rtx_SUBREG (GET_MODE (operands[0]), tr, 0);\n\n        insn = emit_move_insn (operands[0], tr);\n!\n        REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, equiv,\n  \t\t\t\t\t    REG_NOTES (insn));\n\n***************\n*** 6370,6379 ****\n    if (TARGET_SHMEDIA)\n      {\n        rtx reg = operands[2];\n!\n        if (GET_MODE (reg) != DImode)\n  \treg = gen_rtx_SUBREG (DImode, reg, 0);\n!\n        if (flag_pic > 1)\n  \temit_insn (gen_movdi_const_32bit (reg, operands[1]));\n        else\n--- 6371,6380 ----\n    if (TARGET_SHMEDIA)\n      {\n        rtx reg = operands[2];\n!\n        if (GET_MODE (reg) != DImode)\n  \treg = gen_rtx_SUBREG (DImode, reg, 0);\n!\n        if (flag_pic > 1)\n  \temit_insn (gen_movdi_const_32bit (reg, operands[1]));\n        else\n***************\n*** 6391,6397 ****\n    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, XVECEXP (XEXP (operands[1],\n  \t\t\t\t\t\t\t\t  0), 0, 0),\n  \t\t\t\t\tREG_NOTES (insn));\n!\n    DONE;\n  }\")\n\n--- 6392,6398 ----\n    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, XVECEXP (XEXP (operands[1],\n  \t\t\t\t\t\t\t\t  0), 0, 0),\n  \t\t\t\t\tREG_NOTES (insn));\n!\n    DONE;\n  }\")\n\n***************\n*** 7231,7237 ****\n  \t\t\t\t    (match_dup 2))))\n  \t      (set (reg:SI T_REG)\n  \t\t   (ne:SI (ior:SI (match_dup 1) (match_dup 2))\n! \t\t\t  (const_int 0)))])]\n    \"\"\n    \"\n  {\n--- 7232,7238 ----\n  \t\t\t\t    (match_dup 2))))\n  \t      (set (reg:SI T_REG)\n  \t\t   (ne:SI (ior:SI (match_dup 1) (match_dup 2))\n! \t\t\t  (const_int 0)))])]\n    \"\"\n    \"\n  {\n***************\n*** 7282,7288 ****\n  \t\t\t\t    (match_dup 2))))\n  \t      (set (reg:SI T_REG)\n  \t\t   (ne:SI (ior:SI (match_operand 1 \"\" \"\") (match_dup 2))\n! \t\t\t  (const_int 0)))])]\n    \"TARGET_SH1\"\n    \"operands[2] = gen_reg_rtx (SImode);\")\n\n--- 7283,7289 ----\n  \t\t\t\t    (match_dup 2))))\n  \t      (set (reg:SI T_REG)\n  \t\t   (ne:SI (ior:SI (match_operand 1 \"\" \"\") (match_dup 2))\n! \t\t\t  (const_int 0)))])]\n    \"TARGET_SH1\"\n    \"operands[2] = gen_reg_rtx (SImode);\")\n\n***************\n*** 8279,8285 ****\n  ;;   \"#\"\n  ;;   [(set_attr \"length\" \"4\")\n  ;;    (set_attr \"fp_mode\" \"double\")])\n! ;;\n  ;; (define_split\n  ;;   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n  ;; \t(fix:SI (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n--- 8280,8286 ----\n  ;;   \"#\"\n  ;;   [(set_attr \"length\" \"4\")\n  ;;    (set_attr \"fp_mode\" \"double\")])\n! ;;\n  ;; (define_split\n  ;;   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n  ;; \t(fix:SI (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n***************\n*** 8320,8326 ****\n    \"* return output_ieee_ccmpeq (insn, operands);\"\n    [(set_attr \"length\" \"4\")\n     (set_attr \"fp_mode\" \"double\")])\n!\n  (define_insn \"cmpeqdf_media\"\n    [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n  \t(eq:DI (match_operand:DF 1 \"fp_arith_reg_operand\" \"f\")\n--- 8321,8327 ----\n    \"* return output_ieee_ccmpeq (insn, operands);\"\n    [(set_attr \"length\" \"4\")\n     (set_attr \"fp_mode\" \"double\")])\n!\n  (define_insn \"cmpeqdf_media\"\n    [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n  \t(eq:DI (match_operand:DF 1 \"fp_arith_reg_operand\" \"f\")\n***************\n*** 8806,8815 ****\n    \"TARGET_SHMEDIA && reload_completed\n     && GET_MODE (operands[0]) == GET_MODE (operands[1])\n     && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n!    && XVECEXP (operands[1], 0, 0) != const0_rtx\n!    && (HOST_BITS_PER_WIDE_INT >= 64\n!        || HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (GET_MODE (operands[0]))\n!        || sh_1el_vec (operands[1], VOIDmode))\"\n    [(set (match_dup 0) (match_dup 1))]\n    \"\n  {\n--- 8807,8813 ----\n    \"TARGET_SHMEDIA && reload_completed\n     && GET_MODE (operands[0]) == GET_MODE (operands[1])\n     && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n!    && ! zero_vec_operand (operands[1], VOIDmode)\"\n    [(set (match_dup 0) (match_dup 1))]\n    \"\n  {\n***************\n*** 8819,8825 ****\n\n    operands[0] = gen_rtx_REG (new_mode, true_regnum (operands[0]));\n    operands[1]\n!     = simplify_subreg (new_mode, operands[1], GET_MODE (operands[0]), 0);\n  }\")\n\n  (define_expand \"movv2hi\"\n--- 8817,8823 ----\n\n    operands[0] = gen_rtx_REG (new_mode, true_regnum (operands[0]));\n    operands[1]\n!     = simplify_subreg (new_mode, operands[1], GET_MODE (operands[1]), 0);\n  }\")\n\n  (define_expand \"movv2hi\"\n***************\n*** 8878,8884 ****\n         || register_operand (operands[1], V2SImode))\"\n    \"@\n  \tadd\t%1, r63, %0\n! \tmovi\t%1, %0\n  \t#\n  \tld%M1.q\t%m1, %0\n  \tst%M0.q\t%m0, %1\"\n--- 8876,8882 ----\n         || register_operand (operands[1], V2SImode))\"\n    \"@\n  \tadd\t%1, r63, %0\n! \t#\n  \t#\n  \tld%M1.q\t%m1, %0\n  \tst%M0.q\t%m0, %1\"\n***************\n*** 9641,9647 ****\n  /* These are useful to expand ANDs and as combiner patterns.  */\n  (define_insn \"mshfhi_l_di\"\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n! \t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n                               (const_int 32))\n  \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n  \t\t\t(const_int -4294967296))))]\n--- 9639,9645 ----\n  /* These are useful to expand ANDs and as combiner patterns.  */\n  (define_insn \"mshfhi_l_di\"\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n! \t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n                               (const_int 32))\n  \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n  \t\t\t(const_int -4294967296))))]\n***************\n*** 9653,9663 ****\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n  \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n  \t\t\t(const_int -4294967296))\n! \t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n                               (const_int 32))))]\n    \"TARGET_SHMEDIA\"\n    \"mshfhi.l\t%N2, %N1, %0\"\n    [(set_attr \"type\" \"arith_media\")])\n\n  (define_insn \"mshflo_l_di\"\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n--- 9651,9680 ----\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n  \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n  \t\t\t(const_int -4294967296))\n! \t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n                               (const_int 32))))]\n    \"TARGET_SHMEDIA\"\n    \"mshfhi.l\t%N2, %N1, %0\"\n    [(set_attr \"type\" \"arith_media\")])\n+\n+ (define_split\n+   [(set (match_operand:DI 0 \"arith_reg_dest\" \"\")\n+ \t(ior:DI (zero_extend:DI (match_operand:SI 1\n+ \t\t\t\t\t      \"extend_reg_or_0_operand\" \"\"))\n+ \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\")\n+ \t\t\t(const_int -4294967296))))\n+    (clobber (match_operand:DI 3 \"arith_reg_dest\" \"\"))]\n+   \"TARGET_SHMEDIA\"\n+   [(const_int 0)]\n+   \"\n+ {\n+   emit_insn (gen_ashldi3_media (operands[3],\n+ \t\t\t\tsimplify_gen_subreg (DImode, operands[1],\n+ \t\t\t\t\t\t     SImode, 0),\n+ \t\t\t\tGEN_INT (32)));\n+   emit_insn (gen_mshfhi_l_di (operands[0], operands[3], operands[2]));\n+   DONE;\n+ }\")\n\n  (define_insn \"mshflo_l_di\"\n    [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n\nFrom-SVN: r55189", "tree": {"sha": "e2ec7f26632c1a29ca2a80c9665ed99f4b9bed52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2ec7f26632c1a29ca2a80c9665ed99f4b9bed52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/comments", "author": null, "committer": null, "parents": [{"sha": "d16ecaec1d86e2fff32ed93f7d7edffe282878aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16ecaec1d86e2fff32ed93f7d7edffe282878aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d16ecaec1d86e2fff32ed93f7d7edffe282878aa"}], "stats": {"total": 121, "additions": 80, "deletions": 41}, "files": [{"sha": "e7a81de4c6ae8d531adca8b86c9484532566de58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "patch": "@@ -1,3 +1,18 @@\n+Tue Jul  2 18:45:45 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\t* sh.c (print_operand, case 'N'): Allow zero vector.\n+\t(arith_reg_or_0_operand): Likewise.\n+\t(zero_vec_operand): Check for CONST_VECTOR, not PARALLEL.\n+\t* sh.h (CONST_COSTS): 0 has 0 cost.  Check OUTER_CODE for \n+\tIOR, XOR, PLUS and SET and take their respective constant\n+\tranges into account.\n+\t(PREDICATE_CODES, arith_reg_or_0_operand): Can be CONST_VECTOR.\n+\t* sh.md (subdi3, subdi3_media): Allow zero operand.\n+\t(movv8qi_i+3): Only vector that is not split is the zero vector.\n+\tFix operand 3 to simplify_subreg.\n+\t(movv2si_i): Split alternative 1.\n+\t(mshfhi_l_di_rev+1): New splitter.\n+\n 2002-07-02  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cppinit.c (cpp_handle_option):  Suppress warnings with an"}, {"sha": "1acdc964e35e3b96594411afa3a97880f38c6b27", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "patch": "@@ -434,7 +434,8 @@ print_operand (stream, x, code)\n       break;\n \n     case 'N':\n-      if (x == const0_rtx)\n+      if (x == const0_rtx\n+\t  || (GET_CODE (x) == CONST_VECTOR && zero_vec_operand (x, VOIDmode)))\n \t{\n \t  fprintf ((stream), \"r63\");\n \t  break;\n@@ -5940,7 +5941,7 @@ arith_reg_or_0_operand (op, mode)\n   if (arith_reg_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONST_INT && CONST_OK_FOR_N (INTVAL (op)))\n+  if (EXTRA_CONSTRAINT_U (op))\n     return 1;\n \n   return 0;\n@@ -6222,7 +6223,7 @@ zero_vec_operand (v, mode)\n {\n   int i;\n \n-  if (GET_CODE (v) != PARALLEL\n+  if (GET_CODE (v) != CONST_VECTOR\n       || (GET_MODE (v) != mode && mode != VOIDmode))\n     return 0;\n   for (i = XVECLEN (v, 0) - 1; i >= 0; i--)"}, {"sha": "1a25849a3e2c63677cc0e1eb73bd8c59e2c53afd", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "patch": "@@ -2689,10 +2689,16 @@ while (0)\n   case CONST_INT:\t\t\t\t\\\n     if (TARGET_SHMEDIA)\t\t\t\t\\\n       {\t\t\t\t\t\t\\\n+\tif (INTVAL (RTX) == 0)\t\t\t\\\n+\t  return 0;\t\t\t\t\\\n \tif ((OUTER_CODE) == AND && and_operand ((RTX), DImode)) \\\n \t  return 0;\t\t\t\t\\\n+\tif (((OUTER_CODE) == IOR || (OUTER_CODE) == XOR \\\n+\t     || (OUTER_CODE) == PLUS) \\\n+\t    && CONST_OK_FOR_P (INTVAL (RTX)))\t\\\n+\t  return 0;\t\t\t\t\\\n \tif (CONST_OK_FOR_J (INTVAL (RTX)))\t\\\n-          return COSTS_N_INSNS (1);\t\t\\\n+          return COSTS_N_INSNS ((OUTER_CODE) != SET);\t\t\\\n \telse if (CONST_OK_FOR_J (INTVAL (RTX) >> 16)) \\\n \t  return COSTS_N_INSNS (2);\t\t\\\n \telse if (CONST_OK_FOR_J ((INTVAL (RTX) >> 16) >> 16)) \\\n@@ -3225,7 +3231,7 @@ extern int rtx_equal_function_value_matters;\n   {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n   {\"arith_reg_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n-  {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_VECTOR}},\t\\\n   {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"extend_reg_operand\", {SUBREG, REG, TRUNCATE}},\t\t\t\\"}, {"sha": "4265de20d251043a22ed446ecbaf30d92ca4db62", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "patch": "@@ -546,7 +546,7 @@\n ;; There is no way to model this with gcc's function units.  This problem is\n ;; actually mentioned in md.texi.  Tackling this problem requires first that\n ;; it is possible to speak about the target in an open discussion.\n-;; \n+;;\n ;; However, simple double-precision operations always conflict.\n \n (define_function_unit \"fp\"    1 0\n@@ -1048,7 +1048,7 @@\n   \"@\n \taddz.l\t%1, %2, %0\n \taddz.l\t%1, r63, %0\")\n-\t\t \n+\n (define_insn \"adddi3_compact\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n@@ -1122,7 +1122,7 @@\n   \"@\n \tadd.l\t%1, %2, %0\n \taddi.l\t%1, %2, %0\")\n-  \n+\n (define_insn \"*addsi3_compact\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n@@ -1138,25 +1138,26 @@\n \n (define_expand \"subdi3\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"\")\n+\t(minus:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"\")\n \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"\")))]\n   \"\"\n   \"\n {\n   if (TARGET_SH1)\n     {\n+      operands[1] = force_reg (DImode, operands[1]);\n       emit_insn (gen_subdi3_compact (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n }\")\n-  \n+\n (define_insn \"*subdi3_media\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")\n+\t(minus:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rN\")\n \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SHMEDIA\"\n-  \"sub\t%1, %2, %0\")\n-  \n+  \"sub\t%N1, %2, %0\")\n+\n (define_insn \"subdi3_compact\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n@@ -1558,7 +1559,7 @@\n \t\t\t\t\t   : \\\"__sdivsi3\\\")));\n \n       if (TARGET_SHMEDIA)\n-\tlast = gen_divsi3_i1_media (operands[0], \n+\tlast = gen_divsi3_i1_media (operands[0],\n \t\t\t\t    Pmode == DImode\n \t\t\t\t    ? operands[3]\n \t\t\t\t    : gen_rtx_SUBREG (DImode, operands[3],\n@@ -1771,7 +1772,7 @@\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SHMEDIA\"\n   \"muls.l\t%1, %2, %0\")\n-  \n+\n (define_insn \"mulsidi3_compact\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(mult:DI\n@@ -1841,7 +1842,7 @@\n \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n   \"TARGET_SHMEDIA\"\n   \"mulu.l\t%1, %2, %0\")\n-  \n+\n (define_insn \"umulsidi3_compact\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(mult:DI\n@@ -3440,7 +3441,7 @@\n    (set_attr \"type\" \"pcload,move,load,store,move,pcload,move,move\")])\n \n ;; If the output is a register and the input is memory or a register, we have\n-;; to be careful and see which word needs to be loaded first.  \n+;; to be careful and see which word needs to be loaded first.\n \n (define_split\n   [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n@@ -4195,7 +4196,7 @@\n }\")\n \n ;; If the output is a register and the input is memory or a register, we have\n-;; to be careful and see which word needs to be loaded first.  \n+;; to be careful and see which word needs to be loaded first.\n \n (define_split\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n@@ -4392,7 +4393,7 @@\n   DONE;\n }\"\n   [(set_attr \"length\" \"8\")])\n-  \n+\n (define_expand \"movv4sf\"\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n \t(match_operand:V4SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n@@ -4444,7 +4445,7 @@\n   DONE;\n }\"\n   [(set_attr \"length\" \"32\")])\n-  \n+\n (define_expand \"movv16sf\"\n   [(set (match_operand:V16SF 0 \"nonimmediate_operand\" \"=f,f,m\")\n \t(match_operand:V16SF 1 \"nonimmediate_operand\" \"f,m,f\"))]\n@@ -4499,7 +4500,7 @@\n   REAL_VALUE_FROM_CONST_DOUBLE (value, operands[1]);\n   REAL_VALUE_TO_TARGET_SINGLE (value, values);\n   operands[2] = GEN_INT (values);\n-  \n+\n   operands[3] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n }\")\n \n@@ -5410,7 +5411,7 @@\n \t  if (! SYMBOL_REF_FLAG (operands[0]))\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n-\t      \n+\n \t      emit_insn (gen_symGOTPLT2reg (reg, operands[0]));\n \t      operands[0] = reg;\n \t    }\n@@ -5634,7 +5635,7 @@\n \t  if (! SYMBOL_REF_FLAG (operands[1]))\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n-\t      \n+\n \t      emit_insn (gen_symGOTPLT2reg (reg, operands[1]));\n \t      operands[1] = reg;\n \t    }\n@@ -5841,7 +5842,7 @@\n \t  if (! SYMBOL_REF_FLAG (operands[0]))\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n-\t      \n+\n \t      /* We must not use GOTPLT for sibcalls, because PIC_REG\n \t\t must be restored before the PLT code gets to run.  */\n \t      emit_insn (gen_symGOT2reg (reg, operands[0]));\n@@ -6167,7 +6168,7 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"TARGET_SHMEDIA\"\n   \"blink\t%0, r63\")\n-  \n+\n ;; Call subroutine returning any type.\n ;; ??? This probably doesn't work.\n \n@@ -6284,7 +6285,7 @@\n \ttr = gen_rtx_SUBREG (GET_MODE (operands[0]), tr, 0);\n \n       insn = emit_move_insn (operands[0], tr);\n-      \n+\n       REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, equiv,\n \t\t\t\t\t    REG_NOTES (insn));\n \n@@ -6370,10 +6371,10 @@\n   if (TARGET_SHMEDIA)\n     {\n       rtx reg = operands[2];\n-      \n+\n       if (GET_MODE (reg) != DImode)\n \treg = gen_rtx_SUBREG (DImode, reg, 0);\n-      \n+\n       if (flag_pic > 1)\n \temit_insn (gen_movdi_const_32bit (reg, operands[1]));\n       else\n@@ -6391,7 +6392,7 @@\n   REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, XVECEXP (XEXP (operands[1],\n \t\t\t\t\t\t\t\t  0), 0, 0),\n \t\t\t\t\tREG_NOTES (insn));\n-  \n+\n   DONE;\n }\")\n \n@@ -7231,7 +7232,7 @@\n \t\t\t\t    (match_dup 2))))\n \t      (set (reg:SI T_REG)\n \t\t   (ne:SI (ior:SI (match_dup 1) (match_dup 2))\n-\t\t\t  (const_int 0)))])]  \n+\t\t\t  (const_int 0)))])]\n   \"\"\n   \"\n {\n@@ -7282,7 +7283,7 @@\n \t\t\t\t    (match_dup 2))))\n \t      (set (reg:SI T_REG)\n \t\t   (ne:SI (ior:SI (match_operand 1 \"\" \"\") (match_dup 2))\n-\t\t\t  (const_int 0)))])]  \n+\t\t\t  (const_int 0)))])]\n   \"TARGET_SH1\"\n   \"operands[2] = gen_reg_rtx (SImode);\")\n \n@@ -8279,7 +8280,7 @@\n ;;   \"#\"\n ;;   [(set_attr \"length\" \"4\")\n ;;    (set_attr \"fp_mode\" \"double\")])\n-;; \n+;;\n ;; (define_split\n ;;   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n ;; \t(fix:SI (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n@@ -8320,7 +8321,7 @@\n   \"* return output_ieee_ccmpeq (insn, operands);\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"fp_mode\" \"double\")])\n-   \n+\n (define_insn \"cmpeqdf_media\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(eq:DI (match_operand:DF 1 \"fp_arith_reg_operand\" \"f\")\n@@ -8806,10 +8807,7 @@\n   \"TARGET_SHMEDIA && reload_completed\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && VECTOR_MODE_SUPPORTED_P (GET_MODE (operands[0]))\n-   && XVECEXP (operands[1], 0, 0) != const0_rtx\n-   && (HOST_BITS_PER_WIDE_INT >= 64\n-       || HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (GET_MODE (operands[0]))\n-       || sh_1el_vec (operands[1], VOIDmode))\"\n+   && ! zero_vec_operand (operands[1], VOIDmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n {\n@@ -8819,7 +8817,7 @@\n \n   operands[0] = gen_rtx_REG (new_mode, true_regnum (operands[0]));\n   operands[1]\n-    = simplify_subreg (new_mode, operands[1], GET_MODE (operands[0]), 0);\n+    = simplify_subreg (new_mode, operands[1], GET_MODE (operands[1]), 0);\n }\")\n \n (define_expand \"movv2hi\"\n@@ -8878,7 +8876,7 @@\n        || register_operand (operands[1], V2SImode))\"\n   \"@\n \tadd\t%1, r63, %0\n-\tmovi\t%1, %0\n+\t#\n \t#\n \tld%M1.q\t%m1, %0\n \tst%M0.q\t%m0, %1\"\n@@ -9641,7 +9639,7 @@\n /* These are useful to expand ANDs and as combiner patterns.  */\n (define_insn \"mshfhi_l_di\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n-\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\") \n+\t(ior:DI (lshiftrt:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n                              (const_int 32))\n \t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t(const_int -4294967296))))]\n@@ -9653,12 +9651,31 @@\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")\n \t\t\t(const_int -4294967296))\n-\t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\") \n+\t\t(lshiftrt:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"rU\")\n                              (const_int 32))))]\n   \"TARGET_SHMEDIA\"\n   \"mshfhi.l\t%N2, %N1, %0\"\n   [(set_attr \"type\" \"arith_media\")])\n \n+(define_split\n+  [(set (match_operand:DI 0 \"arith_reg_dest\" \"\")\n+\t(ior:DI (zero_extend:DI (match_operand:SI 1\n+\t\t\t\t\t      \"extend_reg_or_0_operand\" \"\"))\n+\t\t(and:DI (match_operand:DI 2 \"arith_reg_or_0_operand\" \"\")\n+\t\t\t(const_int -4294967296))))\n+   (clobber (match_operand:DI 3 \"arith_reg_dest\" \"\"))]\n+  \"TARGET_SHMEDIA\"\n+  [(const_int 0)]\n+  \"\n+{\n+  emit_insn (gen_ashldi3_media (operands[3],\n+\t\t\t\tsimplify_gen_subreg (DImode, operands[1],\n+\t\t\t\t\t\t     SImode, 0),\n+\t\t\t\tGEN_INT (32)));\n+  emit_insn (gen_mshfhi_l_di (operands[0], operands[3], operands[2]));\n+  DONE;\n+}\")\n+\n (define_insn \"mshflo_l_di\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(ior:DI (and:DI (match_operand:DI 1 \"arith_reg_or_0_operand\" \"rU\")"}]}