{"sha": "77545d45a37ae31d6749dd80ed71362081579697", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc1NDVkNDVhMzdhZTMxZDY3NDlkZDgwZWQ3MTM2MjA4MTU3OTY5Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T21:39:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-29T21:39:58Z"}, "message": "(secondary_memlocs_elim): Now one per mode per operand.\n\n(get_secondary_mem, combine_reloads): Reflect changed var above.\n(clear_secondary_mem): Use bzero.\n\nFrom-SVN: r3915", "tree": {"sha": "884ddce8323851a3d81620ad29be0d45a445fd52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/884ddce8323851a3d81620ad29be0d45a445fd52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77545d45a37ae31d6749dd80ed71362081579697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77545d45a37ae31d6749dd80ed71362081579697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77545d45a37ae31d6749dd80ed71362081579697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77545d45a37ae31d6749dd80ed71362081579697/comments", "author": null, "committer": null, "parents": [{"sha": "7967c666c27082f9f7d31500c1ec00fa0d18d055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7967c666c27082f9f7d31500c1ec00fa0d18d055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7967c666c27082f9f7d31500c1ec00fa0d18d055"}], "stats": {"total": 29, "additions": 13, "deletions": 16}, "files": [{"sha": "aa4744c9786ee23cb7e3fd865a2ad0a29a329010", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77545d45a37ae31d6749dd80ed71362081579697/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77545d45a37ae31d6749dd80ed71362081579697/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=77545d45a37ae31d6749dd80ed71362081579697", "patch": "@@ -226,7 +226,7 @@ static int n_memlocs;\n    reload each.  */\n \n static rtx secondary_memlocs[NUM_MACHINE_MODES];\n-static rtx secondary_memlocs_elim[MAX_RECOG_OPERANDS];\n+static rtx secondary_memlocs_elim[NUM_MACHINE_MODES][MAX_RECOG_OPERANDS];\n #endif\n \n /* The instruction we are doing reloads for;\n@@ -434,9 +434,9 @@ get_secondary_mem (x, mode, opnum, type)\n   if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n     mode = mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0);\n \n-  /* If we already have made a MEM for this operand, return it.  */\n-  if (secondary_memlocs_elim[opnum] != 0)\n-    return secondary_memlocs_elim[opnum];\n+  /* If we already have made a MEM for this operand in MODE, return it.  */\n+  if (secondary_memlocs_elim[(int) mode][opnum] != 0)\n+    return secondary_memlocs_elim[(int) mode][opnum];\n \n   /* If this is the first time we've tried to get a MEM for this mode, \n      allocate a new one.  `something_changed' in reload will get set\n@@ -478,7 +478,7 @@ get_secondary_mem (x, mode, opnum, type)\n \t\t\t    opnum, type, 0);\n     }\n \n-  secondary_memlocs_elim[opnum] = loc;\n+  secondary_memlocs_elim[(int) mode][opnum] = loc;\n   return loc;\n }\n \n@@ -487,10 +487,7 @@ get_secondary_mem (x, mode, opnum, type)\n void\n clear_secondary_mem ()\n {\n-  int i;\n-\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    secondary_memlocs[i] = 0;\n+  bzero (secondary_memlocs, sizeof secondary_memlocs);\n }\n #endif /* SECONDARY_MEMORY_NEEDED */\n \f\n@@ -1385,10 +1382,10 @@ combine_reloads ()\n \t    || reload_secondary_reload[output_reload] == -1)\n #ifdef SECONDARY_MEMORY_NEEDED\n \t/* Likewise for different secondary memory locations.  */\n-\t&& (secondary_memlocs_elim[reload_opnum[i]] == 0\n-\t    || secondary_memlocs_elim[reload_opnum[output_reload]] == 0\n-\t    || rtx_equal_p (secondary_memlocs_elim[reload_opnum[i]],\n-\t\t\t    secondary_memlocs_elim[reload_opnum[output_reload]]))\n+\t&& (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]] == 0\n+\t    || secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] == 0\n+\t    || rtx_equal_p (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]],\n+\t\t\t    secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]]))\n #endif\n #ifdef SMALL_REGISTER_CLASSES\n \t&& reload_reg_class[i] == reload_reg_class[output_reload]\n@@ -1437,9 +1434,9 @@ combine_reloads ()\n \t  reload_secondary_reload[i] = reload_secondary_reload[output_reload];\n #ifdef SECONDARY_MEMORY_NEEDED\n \t/* Copy any secondary MEM.  */\n-\tif (secondary_memlocs_elim[reload_opnum[output_reload]] != 0)\n-\t  secondary_memlocs_elim[reload_opnum[i]]\n-\t    = secondary_memlocs_elim[reload_opnum[output_reload]];\n+\tif (secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]] != 0)\n+\t  secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[i]]\n+\t    = secondary_memlocs_elim[(int) reload_outmode[output_reload]][reload_opnum[output_reload]];\n #endif\n \t/* If required, minimize the register class. */\n \tif (reg_class_subset_p (reload_reg_class[output_reload],"}]}