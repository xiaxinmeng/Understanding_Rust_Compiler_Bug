{"sha": "ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ5Yzc5ZTFlYTVjMGY3NGIyNWI1ZWM5NzhiZTFlMWEzNjcyYzFkMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-03-18T11:31:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-03-18T11:31:04Z"}, "message": "re PR ipa/58721 (The subroutine perdida is no longer inlined in fatigue.f90)\n\n\tPR ipa/58721\ngcc/\n\t* internal-fn.c: Include diagnostic-core.h.\n\t(expand_BUILTIN_EXPECT): New function.\n\t* gimplify.c (gimplify_call_expr): Use false instead of FALSE.\n\t(gimplify_modify_expr): Gimplify 3 argument __builtin_expect into\n\tIFN_BUILTIN_EXPECT call instead of __builtin_expect builtin call.\n\t* ipa-inline-analysis.c (find_foldable_builtin_expect): Handle\n\tIFN_BUILTIN_EXPECT.\n\t* predict.c (expr_expected_value_1): Handle IFN_BUILTIN_EXPECT.\n\tRevert 3 argument __builtin_expect code.\n\t(strip_predict_hints): Handle IFN_BUILTIN_EXPECT.\n\t* gimple-fold.c (gimple_fold_call): Likewise.\n\t* tree.h (fold_builtin_expect): New prototype.\n\t* builtins.c (build_builtin_expect_predicate): Add predictor\n\targument, if non-NULL, create 3 argument __builtin_expect.\n\t(fold_builtin_expect): No longer static.  Add ARG2 argument,\n\tpass it through to build_builtin_expect_predicate.\n\t(fold_builtin_2): Adjust caller.\n\t(fold_builtin_3): Handle BUILT_IN_EXPECT.\n\t* internal-fn.def (BUILTIN_EXPECT): New.\ngcc/fortran/\n\t* trans.c (gfc_unlikely, gfc_likely): Don't add __builtin_expect\n\tif !optimize.\n\n2014-03-18  Tobias Burnus  <burnus@net-b.de>\n\n\tPR ipa/58721\ngcc/\n\t* predict.def (PRED_FORTRAN_OVERFLOW, PRED_FORTRAN_FAIL_ALLOC,\n\tPRED_FORTRAN_FAIL_IO, PRED_FORTRAN_WARN_ONCE, PRED_FORTRAN_SIZE_ZERO,\n\tPRED_FORTRAN_INVALID_BOUND, PRED_FORTRAN_ABSENT_DUMMY): Add.\ngcc/fortran/\n\t* trans.h (gfc_unlikely, gfc_likely): Add predictor as argument.\n\t(gfc_trans_io_runtime_check): Remove.\n\t* trans-io.c (gfc_trans_io_runtime_check): Make static; add has_iostat\n\tas argument, add predictor to block.\n\t(set_parameter_value, gfc_trans_open, gfc_trans_close, build_filepos,\n\tgfc_trans_inquire, gfc_trans_wait, build_dt): Update calls.\n\t* trans.c (gfc_unlikely, gfc_likely): Add predictor as argument.\n\t(gfc_trans_runtime_check, gfc_allocate_using_malloc,\n\tgfc_allocate_allocatable, gfc_deallocate_with_status): Set explicitly\n\tbranch predictor.\n\t* trans-expr.c (gfc_conv_procedure_call): Ditto.\n\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n\t* trans-array.c (gfc_array_init_size, gfc_array_allocate): Ditto.\n\n2014-03-18  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/58721\ngcc/\n\t* predict.c (combine_predictions_for_bb): Fix up formatting.\n\t(expr_expected_value_1, expr_expected_value): Add predictor argument,\n\tfill what it points to if non-NULL.\n\t(tree_predict_by_opcode): Adjust caller, use the predictor.\n\t* predict.def (PRED_COMPARE_AND_SWAP): Add.\n\nFrom-SVN: r208641", "tree": {"sha": "f01461267c50ab3ebcbf136cd84fd5629973931c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f01461267c50ab3ebcbf136cd84fd5629973931c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/comments", "author": null, "committer": null, "parents": [{"sha": "e33da4a1131dd198a2fc13b1a839a06397763855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33da4a1131dd198a2fc13b1a839a06397763855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e33da4a1131dd198a2fc13b1a839a06397763855"}], "stats": {"total": 455, "additions": 354, "deletions": 101}, "files": [{"sha": "85060d1d5db1dc6c520369a24aad0c11305f49e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -1,3 +1,42 @@\n+2014-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR ipa/58721\n+\t* internal-fn.c: Include diagnostic-core.h.\n+\t(expand_BUILTIN_EXPECT): New function.\n+\t* gimplify.c (gimplify_call_expr): Use false instead of FALSE.\n+\t(gimplify_modify_expr): Gimplify 3 argument __builtin_expect into\n+\tIFN_BUILTIN_EXPECT call instead of __builtin_expect builtin call.\n+\t* ipa-inline-analysis.c (find_foldable_builtin_expect): Handle\n+\tIFN_BUILTIN_EXPECT.\n+\t* predict.c (expr_expected_value_1): Handle IFN_BUILTIN_EXPECT.\n+\tRevert 3 argument __builtin_expect code.\n+\t(strip_predict_hints): Handle IFN_BUILTIN_EXPECT.\n+\t* gimple-fold.c (gimple_fold_call): Likewise.\n+\t* tree.h (fold_builtin_expect): New prototype.\n+\t* builtins.c (build_builtin_expect_predicate): Add predictor\n+\targument, if non-NULL, create 3 argument __builtin_expect.\n+\t(fold_builtin_expect): No longer static.  Add ARG2 argument,\n+\tpass it through to build_builtin_expect_predicate.\n+\t(fold_builtin_2): Adjust caller.\n+\t(fold_builtin_3): Handle BUILT_IN_EXPECT.\n+\t* internal-fn.def (BUILTIN_EXPECT): New.\n+\n+2014-03-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR ipa/58721\n+\t* predict.def (PRED_FORTRAN_OVERFLOW, PRED_FORTRAN_FAIL_ALLOC,\n+\tPRED_FORTRAN_FAIL_IO, PRED_FORTRAN_WARN_ONCE, PRED_FORTRAN_SIZE_ZERO,\n+\tPRED_FORTRAN_INVALID_BOUND, PRED_FORTRAN_ABSENT_DUMMY): Add.\n+\n+2014-03-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/58721\n+\t* predict.c (combine_predictions_for_bb): Fix up formatting.\n+\t(expr_expected_value_1, expr_expected_value): Add predictor argument,\n+\tfill what it points to if non-NULL.\n+\t(tree_predict_by_opcode): Adjust caller, use the predictor.\n+\t* predict.def (PRED_COMPARE_AND_SWAP): Add.\n+\n 2014-03-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.c (sparc_do_work_around_errata): Speed up and use"}, {"sha": "dd57b1ae42a1aeee2749c4619fcd945dec87c9a7", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -140,7 +140,6 @@ static rtx expand_builtin_frame_address (tree, tree);\n static tree stabilize_va_list_loc (location_t, tree, int);\n static rtx expand_builtin_expect (tree, rtx);\n static tree fold_builtin_constant_p (tree);\n-static tree fold_builtin_expect (location_t, tree, tree);\n static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (location_t, tree, tree);\n static tree fold_builtin_inf (location_t, tree, int);\n@@ -6978,7 +6977,8 @@ fold_builtin_constant_p (tree arg)\n    return it as a truthvalue.  */\n \n static tree\n-build_builtin_expect_predicate (location_t loc, tree pred, tree expected)\n+build_builtin_expect_predicate (location_t loc, tree pred, tree expected,\n+\t\t\t\ttree predictor)\n {\n   tree fn, arg_types, pred_type, expected_type, call_expr, ret_type;\n \n@@ -6990,7 +6990,8 @@ build_builtin_expect_predicate (location_t loc, tree pred, tree expected)\n \n   pred = fold_convert_loc (loc, pred_type, pred);\n   expected = fold_convert_loc (loc, expected_type, expected);\n-  call_expr = build_call_expr_loc (loc, fn, 2, pred, expected);\n+  call_expr = build_call_expr_loc (loc, fn, predictor ? 3 : 2, pred, expected,\n+\t\t\t\t   predictor);\n \n   return build2 (NE_EXPR, TREE_TYPE (pred), call_expr,\n \t\t build_int_cst (ret_type, 0));\n@@ -6999,8 +7000,8 @@ build_builtin_expect_predicate (location_t loc, tree pred, tree expected)\n /* Fold a call to builtin_expect with arguments ARG0 and ARG1.  Return\n    NULL_TREE if no simplification is possible.  */\n \n-static tree\n-fold_builtin_expect (location_t loc, tree arg0, tree arg1)\n+tree\n+fold_builtin_expect (location_t loc, tree arg0, tree arg1, tree arg2)\n {\n   tree inner, fndecl, inner_arg0;\n   enum tree_code code;\n@@ -7035,8 +7036,8 @@ fold_builtin_expect (location_t loc, tree arg0, tree arg1)\n       tree op0 = TREE_OPERAND (inner, 0);\n       tree op1 = TREE_OPERAND (inner, 1);\n \n-      op0 = build_builtin_expect_predicate (loc, op0, arg1);\n-      op1 = build_builtin_expect_predicate (loc, op1, arg1);\n+      op0 = build_builtin_expect_predicate (loc, op0, arg1, arg2);\n+      op1 = build_builtin_expect_predicate (loc, op1, arg1, arg2);\n       inner = build2 (code, TREE_TYPE (inner), op0, op1);\n \n       return fold_convert_loc (loc, TREE_TYPE (arg0), inner);\n@@ -10852,7 +10853,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n       return fold_builtin_strpbrk (loc, arg0, arg1, type);\n \n     case BUILT_IN_EXPECT:\n-      return fold_builtin_expect (loc, arg0, arg1);\n+      return fold_builtin_expect (loc, arg0, arg1, NULL_TREE);\n \n     CASE_FLT_FN (BUILT_IN_POW):\n       return fold_builtin_pow (loc, fndecl, arg0, arg1, type);\n@@ -11032,6 +11033,9 @@ fold_builtin_3 (location_t loc, tree fndecl,\n \treturn fold_builtin_fprintf (loc, fndecl, arg0, arg2, NULL_TREE,\n \t\t\t\t     ignore, fcode);\n \n+    case BUILT_IN_EXPECT:\n+      return fold_builtin_expect (loc, arg0, arg1, arg2);\n+\n     default:\n       break;\n     }"}, {"sha": "78dbc5d38926f172881648f959e2759cdeb0f022", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -1,3 +1,26 @@\n+2014-03-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR ipa/58721\n+\t* trans.c (gfc_unlikely, gfc_likely): Don't add __builtin_expect\n+\tif !optimize.\n+\n+2014-03-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR ipa/58721\n+\t* trans.h (gfc_unlikely, gfc_likely): Add predictor as argument.\n+\t(gfc_trans_io_runtime_check): Remove.\n+\t* trans-io.c (gfc_trans_io_runtime_check): Make static; add has_iostat\n+\tas argument, add predictor to block.\n+\t(set_parameter_value, gfc_trans_open, gfc_trans_close, build_filepos,\n+\tgfc_trans_inquire, gfc_trans_wait, build_dt): Update calls.\n+\t* trans.c (gfc_unlikely, gfc_likely): Add predictor as argument.\n+\t(gfc_trans_runtime_check, gfc_allocate_using_malloc,\n+\tgfc_allocate_allocatable, gfc_deallocate_with_status): Set explicitly\n+\tbranch predictor.\n+\t* trans-expr.c (gfc_conv_procedure_call): Ditto.\n+\t* trans-stmt.c (gfc_trans_allocate): Ditto.\n+\t* trans-array.c (gfc_array_init_size, gfc_array_allocate): Ditto.\n+\n 2014-03-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/55207"}, {"sha": "8c4afb098bf7b2fe8eea2439821ef313bd69d71a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -4993,12 +4993,14 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t\t\t\t   TYPE_MAX_VALUE (gfc_array_index_type)),\n \t\t\t\t\t   size);\n       cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\t    boolean_type_node, tmp, stride));\n+\t\t\t\t\t    boolean_type_node, tmp, stride),\n+\t\t\t   PRED_FORTRAN_OVERFLOW);\n       tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t     integer_one_node, integer_zero_node);\n       cond = gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t\t\t    boolean_type_node, size,\n-\t\t\t\t\t    gfc_index_zero_node));\n+\t\t\t\t\t    gfc_index_zero_node),\n+\t\t\t   PRED_FORTRAN_SIZE_ZERO);\n       tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t     integer_zero_node, tmp);\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n@@ -5095,12 +5097,14 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t\t size_type_node,\n \t\t\t TYPE_MAX_VALUE (size_type_node), element_size);\n   cond = gfc_unlikely (fold_build2_loc (input_location, LT_EXPR,\n-\t\t\t\t\tboolean_type_node, tmp, stride));\n+\t\t\t\t\tboolean_type_node, tmp, stride),\n+\t\t       PRED_FORTRAN_OVERFLOW);\n   tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t integer_one_node, integer_zero_node);\n   cond = gfc_unlikely (fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t\t\tboolean_type_node, element_size,\n-\t\t\t\t\tbuild_int_cst (size_type_node, 0)));\n+\t\t\t\t\tbuild_int_cst (size_type_node, 0)),\n+\t\t       PRED_FORTRAN_SIZE_ZERO);\n   tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node, cond,\n \t\t\t integer_zero_node, tmp);\n   tmp = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n@@ -5282,7 +5286,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (dimension)\n     {\n       cond = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n-\t\t\t   boolean_type_node, var_overflow, integer_zero_node));\n+\t\t\t   boolean_type_node, var_overflow, integer_zero_node),\n+\t\t\t   PRED_FORTRAN_OVERFLOW);\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\t     error, gfc_finish_block (&elseblock));\n     }\n@@ -5303,7 +5308,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t\t  build_int_cst (TREE_TYPE (status), 0));\n       gfc_add_expr_to_block (&se->pre,\n \t\t fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t  gfc_likely (cond), set_descriptor,\n+\t\t\t\t  gfc_likely (cond, PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t\t  set_descriptor,\n \t\t\t\t  build_empty_stmt (input_location)));\n     }\n   else"}, {"sha": "f5350bb5ba9d35a9f09db9d003e879ab2fa0d7b6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -4099,7 +4099,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      parmse.expr\n \t\t= fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t   TREE_TYPE (parmse.expr),\n-\t\t\t\t   gfc_unlikely (tmp),\n+\t\t\t\t   gfc_unlikely (tmp, PRED_FORTRAN_ABSENT_DUMMY),\n \t\t\t\t   fold_convert (TREE_TYPE (parmse.expr),\n \t\t\t\t\t\t null_pointer_node),\n \t\t\t\t   parmse.expr);"}, {"sha": "e21d52fece9d4bfdda138c6b2aec9cd575fd015b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -1196,8 +1196,7 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \t\t\t\t       boolean_type_node, invalid_bound, cond);\n     }\n \n-  invalid_bound = gfc_unlikely (invalid_bound);\n-\n+  invalid_bound = gfc_unlikely (invalid_bound, PRED_FORTRAN_INVALID_BOUND);\n \n   /* See Fortran 2008, C.10 for the following algorithm.  */\n "}, {"sha": "d15159857d00a1fc5c66c4b6a2c7199a98a99805", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -230,9 +230,10 @@ gfc_build_st_parameter (enum ioparam_type ptype, tree *types)\n    Therefore, the code to set these flags must be generated before\n    this function is used.  */\n \n-void\n-gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n-\t\t\t const char * msgid, stmtblock_t * pblock)\n+static void\n+gfc_trans_io_runtime_check (bool has_iostat, tree cond, tree var,\n+\t\t\t    int error_code, const char * msgid,\n+\t\t\t    stmtblock_t * pblock)\n {\n   stmtblock_t block;\n   tree body;\n@@ -246,6 +247,13 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n   /* The code to generate the error.  */\n   gfc_start_block (&block);\n \n+  if (has_iostat)\n+    gfc_add_expr_to_block (&block, build_predict_expr (PRED_FORTRAN_FAIL_IO,\n+\t\t\t\t\t\t       NOT_TAKEN));\n+  else\n+    gfc_add_expr_to_block (&block, build_predict_expr (PRED_NORETURN,\n+\t\t\t\t\t\t       NOT_TAKEN));\n+\n   arg1 = gfc_build_addr_expr (NULL_TREE, var);\n \n   arg2 = build_int_cst (integer_type_node, error_code),\n@@ -268,7 +276,6 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n     }\n   else\n     {\n-      cond = gfc_unlikely (cond);\n       tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n@@ -494,8 +501,8 @@ set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n    st_parameter_XXX structure.  This is a pass by value.  */\n \n static unsigned int\n-set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n-\t\t     gfc_expr *e)\n+set_parameter_value (stmtblock_t *block, bool has_iostat, tree var,\n+\t\t     enum iofield type, gfc_expr *e)\n {\n   gfc_se se;\n   tree tmp;\n@@ -520,18 +527,18 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n       cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t      se.expr,\n \t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n-      gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n-\t\t\t       \"Unit number in I/O statement too small\",\n-\t\t\t       &se.pre);\n+      gfc_trans_io_runtime_check (has_iostat, cond, var, LIBERROR_BAD_UNIT,\n+\t\t\t\t  \"Unit number in I/O statement too small\",\n+\t\t\t\t  &se.pre);\n \n       /* UNIT numbers should be less than the max.  */\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n       cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n \t\t\t      se.expr,\n \t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n-      gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n-\t\t\t       \"Unit number in I/O statement too large\",\n-\t\t\t       &se.pre);\n+      gfc_trans_io_runtime_check (has_iostat, cond, var, LIBERROR_BAD_UNIT,\n+\t\t\t\t  \"Unit number in I/O statement too large\",\n+\t\t\t\t  &se.pre);\n \n     }\n \n@@ -960,7 +967,8 @@ gfc_trans_open (gfc_code * code)\n     mask |= set_string (&block, &post_block, var, IOPARM_open_form, p->form);\n \n   if (p->recl)\n-    mask |= set_parameter_value (&block, var, IOPARM_open_recl_in, p->recl);\n+    mask |= set_parameter_value (&block, p->iostat, var, IOPARM_open_recl_in,\n+\t\t\t\t p->recl);\n \n   if (p->blank)\n     mask |= set_string (&block, &post_block, var, IOPARM_open_blank,\n@@ -1010,7 +1018,7 @@ gfc_trans_open (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n-    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+    set_parameter_value (&block, p->iostat, var, IOPARM_common_unit, p->unit);\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n@@ -1063,7 +1071,7 @@ gfc_trans_close (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n-    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+    set_parameter_value (&block, p->iostat, var, IOPARM_common_unit, p->unit);\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n@@ -1114,7 +1122,7 @@ build_filepos (tree function, gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n-    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+    set_parameter_value (&block, p->iostat, var, IOPARM_common_unit, p->unit);\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n@@ -1375,7 +1383,7 @@ gfc_trans_inquire (gfc_code * code)\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n-    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+    set_parameter_value (&block, p->iostat, var, IOPARM_common_unit, p->unit);\n   else\n     set_parameter_const (&block, var, IOPARM_common_unit, 0);\n \n@@ -1422,12 +1430,12 @@ gfc_trans_wait (gfc_code * code)\n     mask |= IOPARM_common_err;\n \n   if (p->id)\n-    mask |= set_parameter_value (&block, var, IOPARM_wait_id, p->id);\n+    mask |= set_parameter_value (&block, p->iostat, var, IOPARM_wait_id, p->id);\n \n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   if (p->unit)\n-    set_parameter_value (&block, var, IOPARM_common_unit, p->unit);\n+    set_parameter_value (&block, p->iostat, var, IOPARM_common_unit, p->unit);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n   tmp = build_call_expr_loc (input_location,\n@@ -1718,7 +1726,8 @@ build_dt (tree function, gfc_code * code)\n \t\t\t\t   IOPARM_dt_id, dt->id);\n \n       if (dt->pos)\n-\tmask |= set_parameter_value (&block, var, IOPARM_dt_pos, dt->pos);\n+\tmask |= set_parameter_value (&block, dt->iostat, var, IOPARM_dt_pos,\n+\t\t\t\t     dt->pos);\n \n       if (dt->asynchronous)\n \tmask |= set_string (&block, &post_block, var, IOPARM_dt_asynchronous,\n@@ -1749,7 +1758,8 @@ build_dt (tree function, gfc_code * code)\n \t\t\t    dt->sign);\n \n       if (dt->rec)\n-\tmask |= set_parameter_value (&block, var, IOPARM_dt_rec, dt->rec);\n+\tmask |= set_parameter_value (&block, dt->iostat, var, IOPARM_dt_rec,\n+\t\t\t\t     dt->rec);\n \n       if (dt->advance)\n \tmask |= set_string (&block, &post_block, var, IOPARM_dt_advance,\n@@ -1801,7 +1811,8 @@ build_dt (tree function, gfc_code * code)\n \tset_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n       if (dt->io_unit && dt->io_unit->ts.type == BT_INTEGER)\n-\tset_parameter_value (&block, var, IOPARM_common_unit, dt->io_unit);\n+\tset_parameter_value (&block, dt->iostat, var, IOPARM_common_unit,\n+\t\t\t     dt->io_unit);\n     }\n   else\n     set_parameter_const (&block, var, IOPARM_common_flags, mask);"}, {"sha": "1a9068c0f466a36eb928b34f1607766515f952e8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -5107,8 +5107,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t  boolean_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t gfc_unlikely (parm), tmp,\n-\t\t\t\t     build_empty_stmt (input_location));\n+\t\t\t\t gfc_unlikely (parm, PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t\t tmp, build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n \n@@ -5501,7 +5501,7 @@ gfc_trans_deallocate (gfc_code *code)\n \t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n \t\t\t\t  build_int_cst (TREE_TYPE (stat), 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t gfc_unlikely (cond),\n+\t\t\t\t gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC),\n \t\t\t\t build1_v (GOTO_EXPR, label_errmsg),\n \t\t\t\t build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n@@ -5541,7 +5541,7 @@ gfc_trans_deallocate (gfc_code *code)\n       cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, stat,\n \t\t\t     build_int_cst (TREE_TYPE (stat), 0));\n       tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t     gfc_unlikely (cond), tmp,\n+\t\t\t     gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC), tmp,\n \t\t\t     build_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&block, tmp);"}, {"sha": "5961c267e8c98607f6e0d7cda93e997bda43bd42", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -501,6 +501,11 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n \n   gfc_start_block (&block);\n \n+  /* For error, runtime_error_at already implies PRED_NORETURN.  */\n+  if (!error && once)\n+    gfc_add_expr_to_block (&block, build_predict_expr (PRED_FORTRAN_WARN_ONCE,\n+\t\t\t\t\t\t       NOT_TAKEN));\n+\n   /* The code to generate the error.  */\n   va_start (ap, msgid);\n   gfc_add_expr_to_block (&block,\n@@ -519,14 +524,12 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n     }\n   else\n     {\n-      /* Tell the compiler that this isn't likely.  */\n       if (once)\n \tcond = fold_build2_loc (where->lb->location, TRUTH_AND_EXPR,\n \t\t\t\tlong_integer_type_node, tmpvar, cond);\n       else\n \tcond = fold_convert (long_integer_type_node, cond);\n \n-      cond = gfc_unlikely (cond);\n       tmp = fold_build3_loc (where->lb->location, COND_EXPR, void_type_node,\n \t\t\t     cond, body,\n \t\t\t     build_empty_stmt (where->lb->location));\n@@ -616,7 +619,8 @@ void\n gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n \t\t\t   tree size, tree status)\n {\n-  tree tmp, on_error, error_cond;\n+  tree tmp, error_cond;\n+  stmtblock_t on_error;\n   tree status_type = status ? TREE_TYPE (status) : NULL_TREE;\n \n   /* Evaluate size only once, and make sure it has the right type.  */\n@@ -640,20 +644,31 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n \t\t\t\t      build_int_cst (size_type_node, 1)))));\n \n   /* What to do in case of error.  */\n+  gfc_start_block (&on_error);\n   if (status != NULL_TREE)\n-    on_error = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n-\t\t\tstatus, build_int_cst (status_type, LIBERROR_ALLOCATION));\n+    {\n+      gfc_add_expr_to_block (&on_error,\n+\t\t\t     build_predict_expr (PRED_FORTRAN_FAIL_ALLOC,\n+\t\t\t\t\t\t NOT_TAKEN));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type, status,\n+\t\t\t     build_int_cst (status_type, LIBERROR_ALLOCATION));\n+      gfc_add_expr_to_block (&on_error, tmp);\n+    }\n   else\n-    on_error = build_call_expr_loc (input_location, gfor_fndecl_os_error, 1,\n+    {\n+      /* Here, os_error already implies PRED_NORETURN.  */\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_os_error, 1,\n \t\t    gfc_build_addr_expr (pchar_type_node,\n \t\t\t\t gfc_build_localized_cstring_const\n-\t\t\t\t (\"Allocation would exceed memory limit\")));\n+\t\t\t\t    (\"Allocation would exceed memory limit\")));\n+      gfc_add_expr_to_block (&on_error, tmp);\n+    }\n \n   error_cond = fold_build2_loc (input_location, EQ_EXPR,\n \t\t\t\tboolean_type_node, pointer,\n \t\t\t\tbuild_int_cst (prvoid_type_node, 0));\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t gfc_unlikely (error_cond), on_error,\n+\t\t\t error_cond, gfc_finish_block (&on_error),\n \t\t\t build_empty_stmt (input_location));\n \n   gfc_add_expr_to_block (block, tmp);\n@@ -750,7 +765,8 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \n   null_mem = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t    boolean_type_node, mem,\n-\t\t\t\t\t    build_int_cst (type, 0)));\n+\t\t\t\t\t    build_int_cst (type, 0)),\n+\t\t\t   PRED_FORTRAN_FAIL_ALLOC);\n \n   /* If mem is NULL, we call gfc_allocate_using_malloc or\n      gfc_allocate_using_lib.  */\n@@ -770,8 +786,8 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n \t  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t\t  status, build_zero_cst (TREE_TYPE (status)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t gfc_unlikely (cond), tmp,\n-\t\t\t\t build_empty_stmt (input_location));\n+\t\t\t\t gfc_unlikely (cond, PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t\t tmp, build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&alloc_block, tmp);\n \t}\n     }\n@@ -1268,8 +1284,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t\t\t\t\t\t  status_type, status),\n \t\t\t\t build_int_cst (status_type, 0));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t\t gfc_unlikely (cond2), tmp,\n-\t\t\t\t build_empty_stmt (input_location));\n+\t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t\t tmp, build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&non_null, tmp);\n \t}\n     }\n@@ -1327,8 +1343,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n \t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-        \t\t\t gfc_unlikely (cond2), tmp,\n-\t\t\t\t build_empty_stmt (input_location));\n+\t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t\t tmp, build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&non_null, tmp);\n \t}\n     }\n@@ -2015,15 +2031,20 @@ gfc_finish_wrapped_block (gfc_wrapped_block* block)\n /* Helper function for marking a boolean expression tree as unlikely.  */\n \n tree\n-gfc_unlikely (tree cond)\n+gfc_unlikely (tree cond, enum br_predictor predictor)\n {\n   tree tmp;\n \n-  cond = fold_convert (long_integer_type_node, cond);\n-  tmp = build_zero_cst (long_integer_type_node);\n-  cond = build_call_expr_loc (input_location,\n-\t\t\t      builtin_decl_explicit (BUILT_IN_EXPECT),\n-\t\t\t      2, cond, tmp);\n+  if (optimize)\n+    {\n+      cond = fold_convert (long_integer_type_node, cond);\n+      tmp = build_zero_cst (long_integer_type_node);\n+      cond = build_call_expr_loc (input_location,\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_EXPECT),\n+\t\t\t\t  3, cond, tmp,\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t predictor));\n+    }\n   cond = fold_convert (boolean_type_node, cond);\n   return cond;\n }\n@@ -2032,15 +2053,20 @@ gfc_unlikely (tree cond)\n /* Helper function for marking a boolean expression tree as likely.  */\n \n tree\n-gfc_likely (tree cond)\n+gfc_likely (tree cond, enum br_predictor predictor)\n {\n   tree tmp;\n \n-  cond = fold_convert (long_integer_type_node, cond);\n-  tmp = build_one_cst (long_integer_type_node);\n-  cond = build_call_expr_loc (input_location,\n-\t\t\t      builtin_decl_explicit (BUILT_IN_EXPECT),\n-\t\t\t      2, cond, tmp);\n+  if (optimize)\n+    {\n+      cond = fold_convert (long_integer_type_node, cond);\n+      tmp = build_one_cst (long_integer_type_node);\n+      cond = build_call_expr_loc (input_location,\n+\t\t\t\t  builtin_decl_explicit (BUILT_IN_EXPECT),\n+\t\t\t\t  3, cond, tmp,\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t predictor));\n+    }\n   cond = fold_convert (boolean_type_node, cond);\n   return cond;\n }"}, {"sha": "4ae68c6cb859313035ad46aae6aa81b4e0747fdd", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GFC_TRANS_H\n #define GFC_TRANS_H\n \n+#include \"predict.h\"  /* For enum br_predictor and PRED_*.  */\n+\n /* Mangled symbols take the form __module__name.  */\n #define GFC_MAX_MANGLED_SYMBOL_LEN  (GFC_MAX_SYMBOL_LEN*2+4)\n \n@@ -580,8 +582,8 @@ void gfc_generate_constructors (void);\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor_base, tree *);\n \n /* Mark a condition as likely or unlikely.  */\n-tree gfc_likely (tree);\n-tree gfc_unlikely (tree);\n+tree gfc_likely (tree, enum br_predictor);\n+tree gfc_unlikely (tree, enum br_predictor);\n \n /* Return the string length of a deferred character length component.  */\n bool gfc_deferred_strlen (gfc_component *, tree *);\n@@ -630,7 +632,6 @@ tree gfc_trans_pointer_assignment (gfc_expr *, gfc_expr *);\n /* Initialize function decls for library functions.  */\n void gfc_build_intrinsic_lib_fndecls (void);\n /* Create function decls for IO library functions.  */\n-void gfc_trans_io_runtime_check (tree, tree, int, const char *, stmtblock_t *);\n void gfc_build_io_library_fndecls (void);\n /* Build a function decl for a library function.  */\n tree gfc_build_library_function_decl (tree, tree, int, ...);"}, {"sha": "eafdb2dd51498acde33d0f1b0f110db8fb4e2282", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -1181,6 +1181,20 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n       else if (gimple_call_builtin_p (stmt, BUILT_IN_MD))\n \tchanged |= targetm.gimple_fold_builtin (gsi);\n     }\n+  else if (gimple_call_internal_p (stmt)\n+\t   && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT)\n+    {\n+      tree result = fold_builtin_expect (gimple_location (stmt),\n+\t\t\t\t\t gimple_call_arg (stmt, 0),\n+\t\t\t\t\t gimple_call_arg (stmt, 1),\n+\t\t\t\t\t gimple_call_arg (stmt, 2));\n+      if (result)\n+\t{\n+\t  if (!update_call_from_tree (gsi, result))\n+\t    gimplify_and_update_call_from_tree (gsi, result);\n+\t  changed = true;\n+\t}\n+    }\n \n   return changed;\n }"}, {"sha": "ad2178dd914c8a8cbe2e333cb6010dca5f975add", "filename": "gcc/gimplify.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -2215,7 +2215,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   enum gimplify_status ret;\n   int i, nargs;\n   gimple call;\n-  bool builtin_va_start_p = FALSE;\n+  bool builtin_va_start_p = false;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   gcc_assert (TREE_CODE (*expr_p) == CALL_EXPR);\n@@ -4566,8 +4566,20 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*from_p));\n       CALL_EXPR_FN (*from_p) = TREE_OPERAND (CALL_EXPR_FN (*from_p), 0);\n       STRIP_USELESS_TYPE_CONVERSION (CALL_EXPR_FN (*from_p));\n-      assign = gimple_build_call_from_tree (*from_p);\n-      gimple_call_set_fntype (assign, TREE_TYPE (fnptrtype));\n+      tree fndecl = get_callee_fndecl (*from_p);\n+      if (fndecl\n+\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t  && call_expr_nargs (*from_p) == 3)\n+\tassign = gimple_build_call_internal (IFN_BUILTIN_EXPECT, 3,\n+\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 0),\n+\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 1),\n+\t\t\t\t\t     CALL_EXPR_ARG (*from_p, 2));\n+      else\n+\t{\n+\t  assign = gimple_build_call_from_tree (*from_p);\n+\t  gimple_call_set_fntype (assign, TREE_TYPE (fnptrtype));\n+\t}\n       notice_special_calls (assign);\n       if (!gimple_call_noreturn_p (assign))\n \tgimple_call_set_lhs (assign, *to_p);"}, {"sha": "9926ec2808be9134cd2f8d1cb45d57225deca734", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n+#include \"diagnostic-core.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -865,6 +866,23 @@ expand_ABNORMAL_DISPATCHER (gimple)\n {\n }\n \n+static void\n+expand_BUILTIN_EXPECT (gimple stmt)\n+{\n+  /* When guessing was done, the hints should be already stripped away.  */\n+  gcc_assert (!flag_guess_branch_prob || optimize == 0 || seen_error ());\n+\n+  rtx target;\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  else\n+    target = const0_rtx;\n+  rtx val = expand_expr (gimple_call_arg (stmt, 0), target, VOIDmode, EXPAND_NORMAL);\n+  if (lhs && val != target)\n+    emit_move_insn (target, val);\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "31dc4c9cacd5a949a28283521d56c1608418d8cb", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -52,3 +52,4 @@ DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN)\n+DEF_INTERNAL_FN (BUILTIN_EXPECT, ECF_CONST | ECF_LEAF | ECF_NOTHROW)"}, {"sha": "98f42ef1e55e7ea94c817491d9bdaed55fac75ce", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -2306,7 +2306,10 @@ find_foldable_builtin_expect (basic_block bb)\n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n       gimple stmt = gsi_stmt (bsi);\n-      if (gimple_call_builtin_p (stmt, BUILT_IN_EXPECT))\n+      if (gimple_call_builtin_p (stmt, BUILT_IN_EXPECT)\n+\t  || (is_gimple_call (stmt)\n+\t      && gimple_call_internal_p (stmt)\n+\t      && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT))\n         {\n           tree var = gimple_call_lhs (stmt);\n           tree arg = gimple_call_arg (stmt, 0);"}, {"sha": "249433f912952979a71835087d8a9bd323a760d7", "filename": "gcc/predict.c", "status": "modified", "additions": 76, "deletions": 24, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -956,7 +956,8 @@ combine_predictions_for_bb (basic_block bb)\n               struct edge_prediction *pred2;\n \t      int prob = probability;\n \n-              for (pred2 = (struct edge_prediction *) *preds; pred2; pred2 = pred2->ep_next)\n+\t      for (pred2 = (struct edge_prediction *) *preds;\n+\t\t   pred2; pred2 = pred2->ep_next)\n \t       if (pred2 != pred && pred2->ep_predictor == pred->ep_predictor)\n \t         {\n \t           int probability2 = pred->ep_probability;\n@@ -1788,16 +1789,19 @@ guess_outgoing_edge_probabilities (basic_block bb)\n   combine_predictions_for_insn (BB_END (bb), bb);\n }\n \f\n-static tree expr_expected_value (tree, bitmap);\n+static tree expr_expected_value (tree, bitmap, enum br_predictor *predictor);\n \n /* Helper function for expr_expected_value.  */\n \n static tree\n expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n-\t\t       tree op1, bitmap visited)\n+\t\t       tree op1, bitmap visited, enum br_predictor *predictor)\n {\n   gimple def;\n \n+  if (predictor)\n+    *predictor = PRED_UNCONDITIONAL;\n+\n   if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n     {\n       if (TREE_CONSTANT (op0))\n@@ -1822,6 +1826,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t  for (i = 0; i < n; i++)\n \t    {\n \t      tree arg = PHI_ARG_DEF (def, i);\n+\t      enum br_predictor predictor2;\n \n \t      /* If this PHI has itself as an argument, we cannot\n \t\t determine the string length of this argument.  However,\n@@ -1832,7 +1837,12 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t      if (arg == PHI_RESULT (def))\n \t\tcontinue;\n \n-\t      new_val = expr_expected_value (arg, visited);\n+\t      new_val = expr_expected_value (arg, visited, &predictor2);\n+\n+\t      /* It is difficult to combine value predictors.  Simply assume\n+\t\t that later predictor is weaker and take its prediction.  */\n+\t      if (predictor && *predictor < predictor2)\n+\t\t*predictor = predictor2;\n \t      if (!new_val)\n \t\treturn NULL;\n \t      if (!val)\n@@ -1851,14 +1861,34 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t\t\t\tgimple_assign_rhs1 (def),\n \t\t\t\t\tgimple_assign_rhs_code (def),\n \t\t\t\t\tgimple_assign_rhs2 (def),\n-\t\t\t\t\tvisited);\n+\t\t\t\t\tvisited, predictor);\n \t}\n \n       if (is_gimple_call (def))\n \t{\n \t  tree decl = gimple_call_fndecl (def);\n \t  if (!decl)\n-\t    return NULL;\n+\t    {\n+\t      if (gimple_call_internal_p (def)\n+\t\t  && gimple_call_internal_fn (def) == IFN_BUILTIN_EXPECT)\n+\t\t{\n+\t\t  gcc_assert (gimple_call_num_args (def) == 3);\n+\t\t  tree val = gimple_call_arg (def, 0);\n+\t\t  if (TREE_CONSTANT (val))\n+\t\t    return val;\n+\t\t  if (predictor)\n+\t\t    {\n+\t\t      *predictor = PRED_BUILTIN_EXPECT;\n+\t\t      tree val2 = gimple_call_arg (def, 2);\n+\t\t      gcc_assert (TREE_CODE (val2) == INTEGER_CST\n+\t\t\t\t  && tree_fits_uhwi_p (val2)\n+\t\t\t\t  && tree_to_uhwi (val2) < END_PREDICTORS);\n+\t\t      *predictor = (enum br_predictor) tree_to_uhwi (val2);\n+\t\t    }\n+\t\t  return gimple_call_arg (def, 1);\n+\t\t}\n+\t      return NULL;\n+\t    }\n \t  if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL)\n \t    switch (DECL_FUNCTION_CODE (decl))\n \t      {\n@@ -1870,6 +1900,8 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t  val = gimple_call_arg (def, 0);\n \t\t  if (TREE_CONSTANT (val))\n \t\t    return val;\n+\t\t  if (predictor)\n+\t\t    *predictor = PRED_BUILTIN_EXPECT;\n \t\t  return gimple_call_arg (def, 1);\n \t\t}\n \n@@ -1888,6 +1920,8 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t      case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_16:\n \t\t/* Assume that any given atomic operation has low contention,\n \t\t   and thus the compare-and-swap operation succeeds.  */\n+\t\tif (predictor)\n+\t\t  *predictor = PRED_COMPARE_AND_SWAP;\n \t\treturn boolean_true_node;\n \t    }\n \t}\n@@ -1898,10 +1932,13 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n   if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS)\n     {\n       tree res;\n-      op0 = expr_expected_value (op0, visited);\n+      enum br_predictor predictor2;\n+      op0 = expr_expected_value (op0, visited, predictor);\n       if (!op0)\n \treturn NULL;\n-      op1 = expr_expected_value (op1, visited);\n+      op1 = expr_expected_value (op1, visited, &predictor2);\n+      if (predictor && *predictor < predictor2)\n+\t*predictor = predictor2;\n       if (!op1)\n \treturn NULL;\n       res = fold_build2 (code, type, op0, op1);\n@@ -1912,7 +1949,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n   if (get_gimple_rhs_class (code) == GIMPLE_UNARY_RHS)\n     {\n       tree res;\n-      op0 = expr_expected_value (op0, visited);\n+      op0 = expr_expected_value (op0, visited, predictor);\n       if (!op0)\n \treturn NULL;\n       res = fold_build1 (code, type, op0);\n@@ -1932,17 +1969,22 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n    implementation.  */\n \n static tree\n-expr_expected_value (tree expr, bitmap visited)\n+expr_expected_value (tree expr, bitmap visited,\n+\t\t     enum br_predictor *predictor)\n {\n   enum tree_code code;\n   tree op0, op1;\n \n   if (TREE_CONSTANT (expr))\n-    return expr;\n+    {\n+      if (predictor)\n+\t*predictor = PRED_UNCONDITIONAL;\n+      return expr;\n+    }\n \n   extract_ops_from_tree (expr, &code, &op0, &op1);\n   return expr_expected_value_1 (TREE_TYPE (expr),\n-\t\t\t\top0, code, op1, visited);\n+\t\t\t\top0, code, op1, visited, predictor);\n }\n \n \f\n@@ -1967,14 +2009,16 @@ strip_predict_hints (void)\n \t      gsi_remove (&bi, true);\n \t      continue;\n \t    }\n-\t  else if (gimple_code (stmt) == GIMPLE_CALL)\n+\t  else if (is_gimple_call (stmt))\n \t    {\n \t      tree fndecl = gimple_call_fndecl (stmt);\n \n-\t      if (fndecl\n-\t\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t\t  && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t\t  && gimple_call_num_args (stmt) == 2)\n+\t      if ((fndecl\n+\t\t   && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n+\t\t   && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n+\t\t   && gimple_call_num_args (stmt) == 2)\n+\t\t  || (gimple_call_internal_p (stmt)\n+\t\t      && gimple_call_internal_fn (stmt) == IFN_BUILTIN_EXPECT))\n \t\t{\n \t\t  var = gimple_call_lhs (stmt);\n \t\t  if (var)\n@@ -2008,6 +2052,7 @@ tree_predict_by_opcode (basic_block bb)\n   enum tree_code cmp;\n   bitmap visited;\n   edge_iterator ei;\n+  enum br_predictor predictor;\n \n   if (!stmt || gimple_code (stmt) != GIMPLE_COND)\n     return;\n@@ -2019,16 +2064,23 @@ tree_predict_by_opcode (basic_block bb)\n   cmp = gimple_cond_code (stmt);\n   type = TREE_TYPE (op0);\n   visited = BITMAP_ALLOC (NULL);\n-  val = expr_expected_value_1 (boolean_type_node, op0, cmp, op1, visited);\n+  val = expr_expected_value_1 (boolean_type_node, op0, cmp, op1, visited,\n+\t\t\t       &predictor);\n   BITMAP_FREE (visited);\n-  if (val)\n+  if (val && TREE_CODE (val) == INTEGER_CST)\n     {\n-      int percent = PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY);\n+      if (predictor == PRED_BUILTIN_EXPECT)\n+\t{\n+\t  int percent = PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY);\n \n-      gcc_assert (percent >= 0 && percent <= 100);\n-      if (integer_zerop (val))\n-        percent = 100 - percent;\n-      predict_edge (then_edge, PRED_BUILTIN_EXPECT, HITRATE (percent));\n+\t  gcc_assert (percent >= 0 && percent <= 100);\n+\t  if (integer_zerop (val))\n+\t    percent = 100 - percent;\n+\t  predict_edge (then_edge, PRED_BUILTIN_EXPECT, HITRATE (percent));\n+\t}\n+      else\n+\tpredict_edge (then_edge, predictor,\n+\t\t      integer_zerop (val) ? NOT_TAKEN : TAKEN);\n     }\n   /* Try \"pointer heuristic.\"\n      A comparison ptr == 0 is predicted as false."}, {"sha": "145330cbed02cd497f51cbfd4adb54f7f146ae7f", "filename": "gcc/predict.def", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -57,6 +57,11 @@ DEF_PREDICTOR (PRED_UNCONDITIONAL, \"unconditional jump\", PROB_ALWAYS,\n DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* Assume that any given atomic operation has low contention,\n+   and thus the compare-and-swap operation succeeds. */\n+DEF_PREDICTOR (PRED_COMPARE_AND_SWAP, \"compare and swap\", PROB_VERY_LIKELY,\n+\t       PRED_FLAG_FIRST_MATCH)\n+\n /* Hints dropped by user via __builtin_expect feature.  Note: the\n    probability of PROB_VERY_LIKELY is now overwritten by param\n    builtin_expect_probability with a default value of HITRATE(90).\n@@ -133,3 +138,41 @@ DEF_PREDICTOR (PRED_HOT_LABEL, \"hot label\", HITRATE (85), 0)\n /* Branches to cold labels are extremely unlikely.  */\n DEF_PREDICTOR (PRED_COLD_LABEL, \"cold label\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)\n+\n+\n+/* The following predictors are used in Fortran. */\n+\n+/* Branch leading to an integer overflow are extremely unlikely.  */\n+DEF_PREDICTOR (PRED_FORTRAN_OVERFLOW, \"overflow\", PROB_ALWAYS,\n+\t       PRED_FLAG_FIRST_MATCH)\n+\n+/* Branch leading to a failure status are unlikely.  This can occur for out\n+   of memory or when trying to allocate an already allocated allocated or\n+   deallocating an already deallocated allocatable.  This predictor only\n+   occurs when the user explicitly asked for a return status.  By default,\n+   the code aborts, which is handled via PRED_NORETURN.  */\n+DEF_PREDICTOR (PRED_FORTRAN_FAIL_ALLOC, \"fail alloc\", PROB_VERY_LIKELY, 0)\n+\n+/* Branch leading to an I/O failure status are unlikely.  This predictor is\n+   used for I/O failures such as for invalid unit numbers.  This predictor\n+   only occurs when the user explicitly asked for a return status.  By default,\n+   the code aborts, which is handled via PRED_NORETURN.  */\n+DEF_PREDICTOR (PRED_FORTRAN_FAIL_IO, \"fail alloc\", HITRATE(85), 0)\n+\n+/* Branch leading to a run-time warning message which is printed only once\n+   are unlikely.  The print-warning branch itself can be likely or unlikely.  */\n+DEF_PREDICTOR (PRED_FORTRAN_WARN_ONCE, \"warn once\", HITRATE (75), 0)\n+\n+/* Branch belonging to a zero-sized array.  */\n+DEF_PREDICTOR (PRED_FORTRAN_SIZE_ZERO, \"zero-sized array\", HITRATE(70), 0)\n+\n+/* Branch belonging to an invalid bound index, in a context where it is\n+   standard conform and well defined but rather pointless and, hence, rather\n+   unlikely to occur.  */\n+DEF_PREDICTOR (PRED_FORTRAN_INVALID_BOUND, \"zero-sized array\", HITRATE(90), 0)\n+\n+/* Branch belonging to the handling of absent optional arguments.  This\n+   predictor is used when an optional dummy argument, associated with an\n+   absent argument, is passed on as actual argument to another procedure,\n+   which in turn has an optional argument.  */\n+DEF_PREDICTOR (PRED_FORTRAN_ABSENT_DUMMY, \"absent dummy\", HITRATE(60), 0)"}, {"sha": "71d68321a5500805f51f19d8670711e6f4f4608a", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ed9c79e1ea5c0f74b25b5ec978be1e1a3672c1d1", "patch": "@@ -4548,6 +4548,7 @@ extern tree fold_builtin_stxcpy_chk (location_t, tree, tree, tree, tree, tree, b\n \t\t\t\t     enum built_in_function);\n extern tree fold_builtin_stxncpy_chk (location_t, tree, tree, tree, tree, tree, bool,\n \t\t\t\t      enum built_in_function);\n+extern tree fold_builtin_expect (location_t, tree, tree, tree);\n extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);"}]}