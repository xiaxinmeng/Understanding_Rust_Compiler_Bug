{"sha": "c47f5ea57b48aec483b5e0566817143411100171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3ZjVlYTU3YjQ4YWVjNDgzYjVlMDU2NjgxNzE0MzQxMTEwMDE3MQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-27T23:35:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-27T23:35:41Z"}, "message": "reload1.c (verify_initial_offsets): New function.\n\n        * reload1.c (verify_initial_offsets): New function.\n        (reload): Call it after reload_as_needed.  Also verify that the frame\n        size stays constant during reload_as_needed.\n        * i386.h (CONST_DOUBLE_OK_FOR_LETTER_P): Undo Jul 26 change.\n\nFrom-SVN: r23378", "tree": {"sha": "ccb44a4109a98b769d6fb90622684a2ed1c3eea0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccb44a4109a98b769d6fb90622684a2ed1c3eea0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47f5ea57b48aec483b5e0566817143411100171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47f5ea57b48aec483b5e0566817143411100171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47f5ea57b48aec483b5e0566817143411100171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47f5ea57b48aec483b5e0566817143411100171/comments", "author": null, "committer": null, "parents": [{"sha": "0304f7877c4c65d129ea00cc2964a0998b9031ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0304f7877c4c65d129ea00cc2964a0998b9031ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0304f7877c4c65d129ea00cc2964a0998b9031ce"}], "stats": {"total": 56, "additions": 44, "deletions": 12}, "files": [{"sha": "1386d4e793052d94467c75f7d73dddb2d3336731", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47f5ea57b48aec483b5e0566817143411100171/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47f5ea57b48aec483b5e0566817143411100171/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c47f5ea57b48aec483b5e0566817143411100171", "patch": "@@ -12,6 +12,11 @@ Wed Oct 28 00:10:35 1998  Jeffrey A Law  (law@cygnus.com)\n \n Tue Oct 27 23:32:34 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n \n+\t* reload1.c (verify_initial_offsets): New function.\n+\t(reload): Call it after reload_as_needed.  Also verify that the frame\n+\tsize stays constant during reload_as_needed.\n+\t* i386.h (CONST_DOUBLE_OK_FOR_LETTER_P): Undo Jul 26 change.\n+\n \t* reload.h (struct insn_chain): Add need_operand_change element.\n \t* reload1.c (new_insn_chain): Clear it.\n \t(calculate_needs_all_insns): Set it; don't overload need_reload."}, {"sha": "cf890c8c6e2228eea7d23cd035cd17c8501e1aaa", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47f5ea57b48aec483b5e0566817143411100171/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47f5ea57b48aec483b5e0566817143411100171/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c47f5ea57b48aec483b5e0566817143411100171", "patch": "@@ -891,19 +891,10 @@ enum reg_class\n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  We allow constants even if\n    TARGET_387 isn't set, because the stack register converter may need to\n-   load 0.0 into the function value register.\n-\n-   We disallow these constants when -fomit-frame-pointer and compiling\n-   PIC code since reload might need to force the constant to memory.\n-   Forcing the constant to memory changes the elimination offsets after\n-   the point where they must stay constant.\n-\n-   However, we must allow them after reload as completed as reg-stack.c\n-   will create insns which use these constants.  */\n+   load 0.0 into the function value register.  */\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n-  (((reload_completed || !flag_pic || !flag_omit_frame_pointer) && (C) == 'G') \\\n-   ? standard_80387_constant_p (VALUE) : 0)\n+  ((C) == 'G' ? standard_80387_constant_p (VALUE) : 0)\n \n /* Place additional restrictions on the register class to use when it\n    is necessary to be able to hold a value of mode MODE in a reload"}, {"sha": "959233b10e2a72fc56c2d20b07aece4e9f32e354", "filename": "gcc/reload1.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47f5ea57b48aec483b5e0566817143411100171/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47f5ea57b48aec483b5e0566817143411100171/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c47f5ea57b48aec483b5e0566817143411100171", "patch": "@@ -377,6 +377,7 @@ static int eliminate_regs_in_insn\tPROTO((rtx, int));\n static void update_eliminable_offsets\tPROTO((void));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n static void set_initial_elim_offsets\tPROTO((void));\n+static void verify_initial_elim_offsets\tPROTO((void));\n static void init_elim_table\t\tPROTO((void));\n static void update_eliminables\t\tPROTO((HARD_REG_SET *));\n static void spill_hard_reg\t\tPROTO((int, FILE *, int));\n@@ -970,7 +971,17 @@ reload (first, global, dumpfile)\n \n   if (insns_need_reload != 0 || something_needs_elimination\n       || something_needs_operands_changed)\n-    reload_as_needed (global);\n+    {\n+      int old_frame_size = get_frame_size ();\n+\n+      reload_as_needed (global);\n+\n+      if (old_frame_size != get_frame_size ())\n+\tabort ();\n+\n+      if (num_eliminable)\n+\tverify_initial_elim_offsets ();\n+    }\n \n   /* If we were able to eliminate the frame pointer, show that it is no\n      longer live at the start of any basic block.  If it ls live by\n@@ -3422,6 +3433,31 @@ mark_not_eliminable (dest, x)\n       }\n }\n \n+/* Verify that the initial elimination offsets did not change since the\n+   last call to set_initial_elim_offsets.  This is used to catch cases\n+   where something illegal happened during reload_as_needed that could\n+   cause incorrect code to be generated if we did not check for it.  */\n+static void\n+verify_initial_elim_offsets ()\n+{\n+  int t;\n+\n+#ifdef ELIMINABLE_REGS\n+  struct elim_table *ep;\n+\n+  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+    {\n+      INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, t);\n+      if (t != ep->initial_offset)\n+\tabort ();\n+    }\n+#else\n+  INITIAL_FRAME_POINTER_OFFSET (t);\n+  if (t != reg_eliminate[0].initial_offset)\n+    abort ();\n+#endif  \n+}\n+\n /* Reset all offsets on eliminable registers to their initial values.  */\n static void\n set_initial_elim_offsets ()"}]}