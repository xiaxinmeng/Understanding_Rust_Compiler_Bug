{"sha": "e076271b0266a603d1503741d27e23223828b494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA3NjI3MWIwMjY2YTYwM2QxNTAzNzQxZDI3ZTIzMjIzODI4YjQ5NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-09-24T10:53:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-09-24T10:53:22Z"}, "message": "tree-ssa-pre.c (bitmap_find_leader, [...]): Remove dominating stmt argument.\n\n2012-09-24  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (bitmap_find_leader, create_expression_by_pieces,\n\tfind_or_generate_expression): Remove dominating stmt argument.\n\t(find_leader_in_sets, phi_translate_1, bitmap_find_leader,\n\tcreate_component_ref_by_pieces_1, create_component_ref_by_pieces,\n\tdo_regular_insertion, do_partial_partial_insertion): Adjust.\n\t(compute_avail): Do not set uids.\n\nFrom-SVN: r191664", "tree": {"sha": "b0d82125daad4c68dc498d0a9ea3d5c9a7b72cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0d82125daad4c68dc498d0a9ea3d5c9a7b72cb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e076271b0266a603d1503741d27e23223828b494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e076271b0266a603d1503741d27e23223828b494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e076271b0266a603d1503741d27e23223828b494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e076271b0266a603d1503741d27e23223828b494/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04208228d829c01a191264c27062af4bdf35ae84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04208228d829c01a191264c27062af4bdf35ae84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04208228d829c01a191264c27062af4bdf35ae84"}], "stats": {"total": 278, "additions": 73, "deletions": 205}, "files": [{"sha": "4cc8a4c1b1594192f3ed26261b18987f0fd4e707", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e076271b0266a603d1503741d27e23223828b494/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e076271b0266a603d1503741d27e23223828b494/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e076271b0266a603d1503741d27e23223828b494", "patch": "@@ -1,3 +1,12 @@\n+2012-09-24  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (bitmap_find_leader, create_expression_by_pieces,\n+\tfind_or_generate_expression): Remove dominating stmt argument.\n+\t(find_leader_in_sets, phi_translate_1, bitmap_find_leader,\n+\tcreate_component_ref_by_pieces_1, create_component_ref_by_pieces,\n+\tdo_regular_insertion, do_partial_partial_insertion): Adjust.\n+\t(compute_avail): Do not set uids.\n+\n 2012-09-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-streamer-in.c (unpack_ts_type_common_value_fields): Stream in"}, {"sha": "86c33d31853a0901f344eea1ee40fb3074184b3f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 64, "deletions": 205, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e076271b0266a603d1503741d27e23223828b494/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e076271b0266a603d1503741d27e23223828b494/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e076271b0266a603d1503741d27e23223828b494", "patch": "@@ -453,7 +453,7 @@ static struct\n } pre_stats;\n \n static bool do_partial_partial;\n-static pre_expr bitmap_find_leader (bitmap_set_t, unsigned int, gimple);\n+static pre_expr bitmap_find_leader (bitmap_set_t, unsigned int);\n static void bitmap_value_insert_into_set (bitmap_set_t, pre_expr);\n static void bitmap_value_replace_in_set (bitmap_set_t, pre_expr);\n static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n@@ -463,9 +463,8 @@ static void bitmap_insert_into_set_1 (bitmap_set_t, pre_expr,\n \t\t\t\t      unsigned int, bool);\n static bitmap_set_t bitmap_set_new (void);\n static tree create_expression_by_pieces (basic_block, pre_expr, gimple_seq *,\n-\t\t\t\t\t gimple, tree);\n-static tree find_or_generate_expression (basic_block, pre_expr, gimple_seq *,\n-\t\t\t\t\t gimple);\n+\t\t\t\t\t tree);\n+static tree find_or_generate_expression (basic_block, tree, gimple_seq *);\n static unsigned int get_expr_value_id (pre_expr);\n \n /* We can add and remove elements and entries to and from sets\n@@ -1339,9 +1338,9 @@ find_leader_in_sets (unsigned int val, bitmap_set_t set1, bitmap_set_t set2)\n {\n   pre_expr result;\n \n-  result = bitmap_find_leader (set1, val, NULL);\n+  result = bitmap_find_leader (set1, val);\n   if (!result && set2)\n-    result = bitmap_find_leader (set2, val, NULL);\n+    result = bitmap_find_leader (set2, val);\n   return result;\n }\n \n@@ -1733,39 +1732,26 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \n     case NAME:\n       {\n-\tgimple phi = NULL;\n-\tedge e;\n-\tgimple def_stmt;\n \ttree name = PRE_EXPR_NAME (expr);\n-\n-\tdef_stmt = SSA_NAME_DEF_STMT (name);\n+\tgimple def_stmt = SSA_NAME_DEF_STMT (name);\n+\t/* If the SSA name is defined by a PHI node in this block,\n+\t   translate it.  */\n \tif (gimple_code (def_stmt) == GIMPLE_PHI\n \t    && gimple_bb (def_stmt) == phiblock)\n-\t  phi = def_stmt;\n-\telse\n-\t  return expr;\n-\n-\te = find_edge (pred, gimple_bb (phi));\n-\tif (e)\n \t  {\n-\t    tree def = PHI_ARG_DEF (phi, e->dest_idx);\n-\t    pre_expr newexpr;\n-\n-\t    if (TREE_CODE (def) == SSA_NAME)\n-\t      def = VN_INFO (def)->valnum;\n+\t    edge e = find_edge (pred, gimple_bb (def_stmt));\n+\t    tree def = PHI_ARG_DEF (def_stmt, e->dest_idx);\n \n \t    /* Handle constant. */\n \t    if (is_gimple_min_invariant (def))\n \t      return get_or_alloc_expr_for_constant (def);\n \n-\t    if (TREE_CODE (def) == SSA_NAME && ssa_undefined_value_p (def))\n-\t      return NULL;\n-\n-\t    newexpr = get_or_alloc_expr_for_name (def);\n-\t    return newexpr;\n+\t    return get_or_alloc_expr_for_name (def);\n \t  }\n+\t/* Otherwise return it unchanged - it will get cleaned if its\n+\t   value is not available in PREDs AVAIL_OUT set of expressions.  */\n+\treturn expr;\n       }\n-      return expr;\n \n     default:\n       gcc_unreachable ();\n@@ -1854,7 +1840,7 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, basic_block pred,\n    Return NULL if no leader is found.  */\n \n static pre_expr\n-bitmap_find_leader (bitmap_set_t set, unsigned int val, gimple stmt)\n+bitmap_find_leader (bitmap_set_t set, unsigned int val)\n {\n   if (value_id_constant_p (val))\n     {\n@@ -1887,23 +1873,7 @@ bitmap_find_leader (bitmap_set_t set, unsigned int val, gimple stmt)\n       bitmap exprset = VEC_index (bitmap, value_expressions, val);\n \n       EXECUTE_IF_AND_IN_BITMAP (exprset, &set->expressions, 0, i, bi)\n-\t{\n-\t  pre_expr val = expression_for_id (i);\n-\t  /* At the point where stmt is not null, there should always\n-\t     be an SSA_NAME first in the list of expressions.  */\n-\t  if (stmt)\n-\t    {\n-\t      gimple def_stmt = SSA_NAME_DEF_STMT (PRE_EXPR_NAME (val));\n-\t      if (gimple_code (def_stmt) != GIMPLE_PHI\n-\t\t  && gimple_bb (def_stmt) == gimple_bb (stmt)\n-\t\t  /* PRE insertions are at the end of the basic-block\n-\t\t     and have UID 0.  */\n-\t\t  && (gimple_uid (def_stmt) == 0\n-\t\t      || gimple_uid (def_stmt) >= gimple_uid (stmt)))\n-\t\tcontinue;\n-\t    }\n-\t  return val;\n-\t}\n+\treturn expression_for_id (i);\n     }\n   return NULL;\n }\n@@ -2586,8 +2556,7 @@ static bitmap inserted_exprs;\n \n static tree\n create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n-\t\t\t\t  unsigned int *operand, gimple_seq *stmts,\n-\t\t\t\t  gimple domstmt)\n+\t\t\t\t  unsigned int *operand, gimple_seq *stmts)\n {\n   vn_reference_op_t currop = &VEC_index (vn_reference_op_s, ref->operands,\n \t\t\t\t\t *operand);\n@@ -2603,31 +2572,15 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \tif (TREE_CODE (currop->op0) == FUNCTION_DECL)\n \t  fn = currop->op0;\n \telse\n-\t  {\n-\t    pre_expr op0 = get_or_alloc_expr_for (currop->op0);\n-\t    fn = find_or_generate_expression (block, op0, stmts, domstmt);\n-\t    if (!fn)\n-\t      return NULL_TREE;\n-\t  }\n+\t  fn = find_or_generate_expression (block, currop->op0, stmts);\n \tif (currop->op1)\n-\t  {\n-\t    pre_expr scexpr = get_or_alloc_expr_for (currop->op1);\n-\t    sc = find_or_generate_expression (block, scexpr, stmts, domstmt);\n-\t    if (!sc)\n-\t      return NULL_TREE;\n-\t  }\n+\t  sc = find_or_generate_expression (block, currop->op1, stmts);\n \targs = XNEWVEC (tree, VEC_length (vn_reference_op_s,\n \t\t\t\t\t  ref->operands) - 1);\n \twhile (*operand < VEC_length (vn_reference_op_s, ref->operands))\n \t  {\n \t    args[nargs] = create_component_ref_by_pieces_1 (block, ref,\n-\t\t\t\t\t\t\t    operand, stmts,\n-\t\t\t\t\t\t\t    domstmt);\n-\t    if (!args[nargs])\n-\t      {\n-\t\tfree (args);\n-\t\treturn NULL_TREE;\n-\t      }\n+\t\t\t\t\t\t\t    operand, stmts);\n \t    nargs++;\n \t  }\n \tfolded = build_call_array (currop->type,\n@@ -2643,10 +2596,8 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n     case MEM_REF:\n       {\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n+\t\t\t\t\t\t\tstmts);\n \ttree offset = currop->op0;\n-\tif (!baseop)\n-\t  return NULL_TREE;\n \tif (TREE_CODE (baseop) == ADDR_EXPR\n \t    && handled_component_p (TREE_OPERAND (baseop, 0)))\n \t  {\n@@ -2665,30 +2616,15 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \n     case TARGET_MEM_REF:\n       {\n-\tpre_expr op0expr, op1expr;\n \ttree genop0 = NULL_TREE, genop1 = NULL_TREE;\n \tvn_reference_op_t nextop = &VEC_index (vn_reference_op_s, ref->operands,\n \t\t\t\t\t       ++*operand);\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n-\tif (!baseop)\n-\t  return NULL_TREE;\n+\t\t\t\t\t\t\tstmts);\n \tif (currop->op0)\n-\t  {\n-\t    op0expr = get_or_alloc_expr_for (currop->op0);\n-\t    genop0 = find_or_generate_expression (block, op0expr,\n-\t\t\t\t\t\t  stmts, domstmt);\n-\t    if (!genop0)\n-\t      return NULL_TREE;\n-\t  }\n+\t  genop0 = find_or_generate_expression (block, currop->op0, stmts);\n \tif (nextop->op0)\n-\t  {\n-\t    op1expr = get_or_alloc_expr_for (nextop->op0);\n-\t    genop1 = find_or_generate_expression (block, op1expr,\n-\t\t\t\t\t\t  stmts, domstmt);\n-\t    if (!genop1)\n-\t      return NULL_TREE;\n-\t  }\n+\t  genop1 = find_or_generate_expression (block, nextop->op0, stmts);\n \treturn build5 (TARGET_MEM_REF, currop->type,\n \t\t       baseop, currop->op2, genop0, currop->op1, genop1);\n       }\n@@ -2705,41 +2641,24 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n     case VIEW_CONVERT_EXPR:\n       {\n \ttree genop0 = create_component_ref_by_pieces_1 (block, ref,\n-\t\t\t\t\t\t\toperand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n-\tif (!genop0)\n-\t  return NULL_TREE;\n-\n+\t\t\t\t\t\t\toperand, stmts);\n \treturn fold_build1 (currop->opcode, currop->type, genop0);\n       }\n \n     case WITH_SIZE_EXPR:\n       {\n \ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n-\tpre_expr op1expr = get_or_alloc_expr_for (currop->op0);\n-\ttree genop1;\n-\n-\tif (!genop0)\n-\t  return NULL_TREE;\n-\n-\tgenop1 = find_or_generate_expression (block, op1expr, stmts, domstmt);\n-\tif (!genop1)\n-\t  return NULL_TREE;\n-\n+\t\t\t\t\t\t\tstmts);\n+\ttree genop1 = find_or_generate_expression (block, currop->op0, stmts);\n \treturn fold_build2 (currop->opcode, currop->type, genop0, genop1);\n       }\n \n     case BIT_FIELD_REF:\n       {\n \ttree genop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\t\tstmts, domstmt);\n+\t\t\t\t\t\t\tstmts);\n \ttree op1 = currop->op0;\n \ttree op2 = currop->op1;\n-\n-\tif (!genop0)\n-\t  return NULL_TREE;\n-\n \treturn fold_build3 (BIT_FIELD_REF, currop->type, genop0, op1, op2);\n       }\n \n@@ -2751,19 +2670,10 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       {\n \ttree genop0;\n \ttree genop1 = currop->op0;\n-\tpre_expr op1expr;\n \ttree genop2 = currop->op1;\n-\tpre_expr op2expr;\n \ttree genop3 = currop->op2;\n-\tpre_expr op3expr;\n-\tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\t   stmts, domstmt);\n-\tif (!genop0)\n-\t  return NULL_TREE;\n-\top1expr = get_or_alloc_expr_for (genop1);\n-\tgenop1 = find_or_generate_expression (block, op1expr, stmts, domstmt);\n-\tif (!genop1)\n-\t  return NULL_TREE;\n+\tgenop0 = create_component_ref_by_pieces_1 (block, ref, operand, stmts);\n+\tgenop1 = find_or_generate_expression (block, genop1, stmts);\n \tif (genop2)\n \t  {\n \t    tree domain_type = TYPE_DOMAIN (TREE_TYPE (genop0));\n@@ -2773,13 +2683,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t\t    || integer_zerop (TYPE_MIN_VALUE (domain_type))))\n \t      genop2 = NULL_TREE;\n \t    else\n-\t      {\n-\t\top2expr = get_or_alloc_expr_for (genop2);\n-\t\tgenop2 = find_or_generate_expression (block, op2expr, stmts,\n-\t\t\t\t\t\t      domstmt);\n-\t\tif (!genop2)\n-\t\t  return NULL_TREE;\n-\t      }\n+\t      genop2 = find_or_generate_expression (block, genop2, stmts);\n \t  }\n \tif (genop3)\n \t  {\n@@ -2794,11 +2698,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t      {\n \t\tgenop3 = size_binop (EXACT_DIV_EXPR, genop3,\n \t\t\t\t     size_int (TYPE_ALIGN_UNIT (elmt_type)));\n-\t\top3expr = get_or_alloc_expr_for (genop3);\n-\t\tgenop3 = find_or_generate_expression (block, op3expr, stmts,\n-\t\t\t\t\t\t      domstmt);\n-\t\tif (!genop3)\n-\t\t  return NULL_TREE;\n+\t\tgenop3 = find_or_generate_expression (block, genop3, stmts);\n \t      }\n \t  }\n \treturn build4 (currop->opcode, currop->type, genop0, genop1,\n@@ -2809,30 +2709,17 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \ttree op0;\n \ttree op1;\n \ttree genop2 = currop->op1;\n-\tpre_expr op2expr;\n-\top0 = create_component_ref_by_pieces_1 (block, ref, operand,\n-\t\t\t\t\t\tstmts, domstmt);\n-\tif (!op0)\n-\t  return NULL_TREE;\n-\t/* op1 should be a FIELD_DECL, which are represented by\n-\t   themselves.  */\n+\top0 = create_component_ref_by_pieces_1 (block, ref, operand, stmts);\n+\t/* op1 should be a FIELD_DECL, which are represented by themselves.  */\n \top1 = currop->op0;\n \tif (genop2)\n-\t  {\n-\t    op2expr = get_or_alloc_expr_for (genop2);\n-\t    genop2 = find_or_generate_expression (block, op2expr, stmts,\n-\t\t\t\t\t\t  domstmt);\n-\t    if (!genop2)\n-\t      return NULL_TREE;\n-\t  }\n-\n+\t  genop2 = find_or_generate_expression (block, genop2, stmts);\n \treturn fold_build3 (COMPONENT_REF, TREE_TYPE (op1), op0, op1, genop2);\n       }\n \n     case SSA_NAME:\n       {\n-\tpre_expr op0expr = get_or_alloc_expr_for (currop->op0);\n-\tgenop = find_or_generate_expression (block, op0expr, stmts, domstmt);\n+\tgenop = find_or_generate_expression (block, currop->op0, stmts);\n \treturn genop;\n       }\n     case STRING_CST:\n@@ -2867,17 +2754,17 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \n static tree\n create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n-\t\t\t\tgimple_seq *stmts, gimple domstmt)\n+\t\t\t\tgimple_seq *stmts)\n {\n   unsigned int op = 0;\n-  return create_component_ref_by_pieces_1 (block, ref, &op, stmts, domstmt);\n+  return create_component_ref_by_pieces_1 (block, ref, &op, stmts);\n }\n \n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n    complex.\n    BLOCK is the basic_block we are looking for leaders in.\n-   EXPR is the expression to find a leader or generate for.\n+   OP is the tree expression to find a leader for or generate.\n    STMTS is the statement list to put the inserted expressions on.\n    Returns the SSA_NAME of the LHS of the generated expression or the\n    leader.\n@@ -2887,51 +2774,32 @@ create_component_ref_by_pieces (basic_block block, vn_reference_t ref,\n    on failure.  */\n \n static tree\n-find_or_generate_expression (basic_block block, pre_expr expr,\n-\t\t\t     gimple_seq *stmts, gimple domstmt)\n+find_or_generate_expression (basic_block block, tree op, gimple_seq *stmts)\n {\n-  pre_expr leader = bitmap_find_leader (AVAIL_OUT (block),\n-\t\t\t\t\tget_expr_value_id (expr), domstmt);\n-  tree genop = NULL;\n+  pre_expr expr = get_or_alloc_expr_for (op);\n+  unsigned int lookfor = get_expr_value_id (expr);\n+  pre_expr leader = bitmap_find_leader (AVAIL_OUT (block), lookfor);\n   if (leader)\n     {\n       if (leader->kind == NAME)\n-\tgenop = PRE_EXPR_NAME (leader);\n+\treturn PRE_EXPR_NAME (leader);\n       else if (leader->kind == CONSTANT)\n-\tgenop = PRE_EXPR_CONSTANT (leader);\n+\treturn PRE_EXPR_CONSTANT (leader);\n     }\n \n-  /* If it's still NULL, it must be a complex expression, so generate\n-     it recursively.  Not so if inserting expressions for values generated\n-     by SCCVN.  */\n-  if (genop == NULL\n-      && !domstmt)\n+  /* It must be a complex expression, so generate it recursively.  */\n+  bitmap exprset = VEC_index (bitmap, value_expressions, lookfor);\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n     {\n-      bitmap exprset;\n-      unsigned int lookfor = get_expr_value_id (expr);\n-      bool handled = false;\n-      bitmap_iterator bi;\n-      unsigned int i;\n-\n-      exprset = VEC_index (bitmap, value_expressions, lookfor);\n-      EXECUTE_IF_SET_IN_BITMAP (exprset, 0, i, bi)\n-\t{\n-\t  pre_expr temp = expression_for_id (i);\n-\t  if (temp->kind != NAME)\n-\t    {\n-\t      handled = true;\n-\t      genop = create_expression_by_pieces (block, temp, stmts,\n-\t\t\t\t\t\t   domstmt,\n-\t\t\t\t\t\t   get_expr_type (expr));\n-\t      break;\n-\t    }\n-\t}\n-      if (!handled && domstmt)\n-\treturn NULL_TREE;\n-\n-      gcc_assert (handled);\n+      pre_expr temp = expression_for_id (i);\n+      if (temp->kind != NAME)\n+\treturn create_expression_by_pieces (block, temp, stmts,\n+\t\t\t\t\t    get_expr_type (expr));\n     }\n-  return genop;\n+\n+  gcc_unreachable ();\n }\n \n #define NECESSARY GF_PLF_1\n@@ -2956,7 +2824,7 @@ find_or_generate_expression (basic_block block, pre_expr expr,\n \n static tree\n create_expression_by_pieces (basic_block block, pre_expr expr,\n-\t\t\t     gimple_seq *stmts, gimple domstmt, tree type)\n+\t\t\t     gimple_seq *stmts, tree type)\n {\n   tree name;\n   tree folded;\n@@ -2980,7 +2848,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n     case REFERENCE:\n       {\n \tvn_reference_t ref = PRE_EXPR_REFERENCE (expr);\n-\tfolded = create_component_ref_by_pieces (block, ref, stmts, domstmt);\n+\tfolded = create_component_ref_by_pieces (block, ref, stmts);\n       }\n       break;\n     case NARY:\n@@ -2990,11 +2858,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \tunsigned i;\n \tfor (i = 0; i < nary->length; ++i)\n \t  {\n-\t    pre_expr op = get_or_alloc_expr_for (nary->op[i]);\n-\t    genop[i] = find_or_generate_expression (block, op,\n-\t\t\t\t\t\t    stmts, domstmt);\n-\t    if (!genop[i])\n-\t      return NULL_TREE;\n+\t    genop[i] = find_or_generate_expression (block, nary->op[i], stmts);\n \t    /* Ensure genop[] is properly typed for POINTER_PLUS_EXPR.  It\n \t       may have conversions stripped.  */\n \t    if (nary->opcode == POINTER_PLUS_EXPR)\n@@ -3037,7 +2901,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n       }\n       break;\n     default:\n-      return NULL_TREE;\n+      gcc_unreachable ();\n     }\n \n   if (!useless_type_conversion_p (exprtype, TREE_TYPE (folded)))\n@@ -3228,10 +3092,8 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \n       if (eprime->kind != NAME && eprime->kind != CONSTANT)\n \t{\n-\t  builtexpr = create_expression_by_pieces (bprime,\n-\t\t\t\t\t\t   eprime,\n-\t\t\t\t\t\t   &stmts, NULL,\n-\t\t\t\t\t\t   type);\n+\t  builtexpr = create_expression_by_pieces (bprime, eprime,\n+\t\t\t\t\t\t   &stmts, type);\n \t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  gsi_insert_seq_on_edge (pred, stmts);\n \t  VEC_replace (pre_expr, avail, pred->dest_idx,\n@@ -3474,7 +3336,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t      eprime = fully_constant_expression (eprime);\n \t      vprime = get_expr_value_id (eprime);\n \t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t vprime, NULL);\n+\t\t\t\t\t\t vprime);\n \t      if (edoubleprime == NULL)\n \t\t{\n \t\t  VEC_replace (pre_expr, avail, pred->dest_idx, eprime);\n@@ -3637,8 +3499,7 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \n \t      eprime = fully_constant_expression (eprime);\n \t      vprime = get_expr_value_id (eprime);\n-\t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t vprime, NULL);\n+\t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime), vprime);\n \t      VEC_replace (pre_expr, avail, pred->dest_idx, edoubleprime);\n \t      if (edoubleprime == NULL)\n \t\t{\n@@ -3870,7 +3731,6 @@ compute_avail (void)\n       gimple_stmt_iterator gsi;\n       gimple stmt;\n       basic_block dom;\n-      unsigned int stmt_uid = 1;\n \n       /* Pick a block from the worklist.  */\n       block = worklist[--sp];\n@@ -3895,7 +3755,6 @@ compute_avail (void)\n \t  tree op;\n \n \t  stmt = gsi_stmt (gsi);\n-\t  gimple_set_uid (stmt, stmt_uid++);\n \n \t  /* Cache whether the basic-block has any non-visible side-effect\n \t     or control flow."}]}