{"sha": "80a832cd25fa03a93768f3d2bc05d23a06a87e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBhODMyY2QyNWZhMDNhOTM3NjhmM2QyYmMwNWQyM2EwNmE4N2UyNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-02-28T17:05:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-02-28T17:05:07Z"}, "message": "re PR middle-end/47893 (4.6 miscompiles mesa on i686)\n\n\tPR middle-end/47893\n\t* rtl.h (ASLK_REDUCE_ALIGN, ASLK_RECORD_PAD): Define.\n\t(assign_stack_local_1): Change last argument type to int.\n\t* function.c (assign_stack_local_1): Replace reduce_alignment_ok\n\targument with kind.  If bit ASLK_RECORD_PAD is not set in it,\n\tdon't record padding space into frame_space_list nor\n\tuse those areas.\n\t(assign_stack_local): Adjust caller.\n\t(assign_stack_temp_for_type): Call assign_stack_local_1 instead\n\tof assign_stack_local, pass 0 as last argument.\n\t* caller-save.c (setup_save_areas): Adjust assign_stack_local_1\n\tcallers.\n\n\t* gcc.dg/pr47893.c: New test.\n\nFrom-SVN: r170568", "tree": {"sha": "516bcbdd71d1bf924c03920302af2c3b2d95b859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/516bcbdd71d1bf924c03920302af2c3b2d95b859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80a832cd25fa03a93768f3d2bc05d23a06a87e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a832cd25fa03a93768f3d2bc05d23a06a87e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80a832cd25fa03a93768f3d2bc05d23a06a87e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80a832cd25fa03a93768f3d2bc05d23a06a87e26/comments", "author": null, "committer": null, "parents": [{"sha": "d154f92719efa355bef3c2a19b62e8c8dd720172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d154f92719efa355bef3c2a19b62e8c8dd720172", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d154f92719efa355bef3c2a19b62e8c8dd720172"}], "stats": {"total": 299, "additions": 262, "deletions": 37}, "files": [{"sha": "c4c7a13052c4473f5ea8d9476fdc2cdba487eb45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -1,3 +1,19 @@\n+2011-02-28  Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/47893\n+\t* rtl.h (ASLK_REDUCE_ALIGN, ASLK_RECORD_PAD): Define.\n+\t(assign_stack_local_1): Change last argument type to int.\n+\t* function.c (assign_stack_local_1): Replace reduce_alignment_ok\n+\targument with kind.  If bit ASLK_RECORD_PAD is not set in it,\n+\tdon't record padding space into frame_space_list nor\n+\tuse those areas.\n+\t(assign_stack_local): Adjust caller.\n+\t(assign_stack_temp_for_type): Call assign_stack_local_1 instead\n+\tof assign_stack_local, pass 0 as last argument.\n+\t* caller-save.c (setup_save_areas): Adjust assign_stack_local_1\n+\tcallers.\n+\n 2011-02-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/47283"}, {"sha": "160d2e9117d19f694c7a992fbe0535a017496698", "filename": "gcc/caller-save.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -647,7 +647,8 @@ setup_save_areas (void)\n \t\t  saved_reg->slot\n \t\t    = assign_stack_local_1\n \t\t      (regno_save_mode[regno][1],\n-\t\t       GET_MODE_SIZE (regno_save_mode[regno][1]), 0, true);\n+\t\t       GET_MODE_SIZE (regno_save_mode[regno][1]), 0,\n+\t\t       ASLK_REDUCE_ALIGN);\n \t\t  if (dump_file != NULL)\n \t\t    fprintf (dump_file, \"%d uses a new slot\\n\", regno);\n \t\t}\n@@ -705,7 +706,7 @@ setup_save_areas (void)\n \t    regno_save_mem[i][j]\n \t      = assign_stack_local_1 (regno_save_mode[i][j],\n \t\t\t\t      GET_MODE_SIZE (regno_save_mode[i][j]),\n-\t\t\t\t      0, true);\n+\t\t\t\t      0, ASLK_REDUCE_ALIGN);\n \n \t    /* Setup single word save area just in case...  */\n \t    for (k = 0; k < j; k++)"}, {"sha": "8b80485860c1e8d5da6bc36db10e8c3f75b19c77", "filename": "gcc/function.c", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -1,7 +1,7 @@\n /* Expands front end tree to back end RTL for GCC.\n    Copyright (C) 1987, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,\n    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n-   2010  Free Software Foundation, Inc.\n+   2010, 2011  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -355,14 +355,17 @@ add_frame_space (HOST_WIDE_INT start, HOST_WIDE_INT end)\n    -2 means use BITS_PER_UNIT,\n    positive specifies alignment boundary in bits.\n \n-   If REDUCE_ALIGNMENT_OK is true, it is OK to reduce alignment.\n+   KIND has ASLK_REDUCE_ALIGN bit set if it is OK to reduce\n+   alignment and ASLK_RECORD_PAD bit set if we should remember\n+   extra space we allocated for alignment purposes.  When we are\n+   called from assign_stack_temp_for_type, it is not set so we don't\n+   track the same stack slot in two independent lists.\n \n    We do not round to stack_boundary here.  */\n \n rtx\n assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n-\t\t      int align,\n-\t\t      bool reduce_alignment_ok ATTRIBUTE_UNUSED)\n+\t\t      int align, int kind)\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n@@ -412,7 +415,7 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n \t\t  /* It is OK to reduce the alignment as long as the\n \t\t     requested size is 0 or the estimated stack\n \t\t     alignment >= mode alignment.  */\n-\t\t  gcc_assert (reduce_alignment_ok\n+\t\t  gcc_assert ((kind & ASLK_REDUCE_ALIGN)\n \t\t              || size == 0\n \t\t\t      || (crtl->stack_alignment_estimated\n \t\t\t\t  >= GET_MODE_ALIGNMENT (mode)));\n@@ -430,21 +433,24 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n \n   if (mode != BLKmode || size != 0)\n     {\n-      struct frame_space **psp;\n-\n-      for (psp = &crtl->frame_space_list; *psp; psp = &(*psp)->next)\n+      if (kind & ASLK_RECORD_PAD)\n \t{\n-\t  struct frame_space *space = *psp;\n-\t  if (!try_fit_stack_local (space->start, space->length, size,\n-\t\t\t\t    alignment, &slot_offset))\n-\t    continue;\n-\t  *psp = space->next;\n-\t  if (slot_offset > space->start)\n-\t    add_frame_space (space->start, slot_offset);\n-\t  if (slot_offset + size < space->start + space->length)\n-\t    add_frame_space (slot_offset + size,\n-\t\t\t     space->start + space->length);\n-\t  goto found_space;\n+\t  struct frame_space **psp;\n+\n+\t  for (psp = &crtl->frame_space_list; *psp; psp = &(*psp)->next)\n+\t    {\n+\t      struct frame_space *space = *psp;\n+\t      if (!try_fit_stack_local (space->start, space->length, size,\n+\t\t\t\t\talignment, &slot_offset))\n+\t\tcontinue;\n+\t      *psp = space->next;\n+\t      if (slot_offset > space->start)\n+\t\tadd_frame_space (space->start, slot_offset);\n+\t      if (slot_offset + size < space->start + space->length)\n+\t\tadd_frame_space (slot_offset + size,\n+\t\t\t\t space->start + space->length);\n+\t      goto found_space;\n+\t    }\n \t}\n     }\n   else if (!STACK_ALIGNMENT_NEEDED)\n@@ -460,20 +466,26 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n       frame_offset -= size;\n       try_fit_stack_local (frame_offset, size, size, alignment, &slot_offset);\n \n-      if (slot_offset > frame_offset)\n-\tadd_frame_space (frame_offset, slot_offset);\n-      if (slot_offset + size < old_frame_offset)\n-\tadd_frame_space (slot_offset + size, old_frame_offset);\n+      if (kind & ASLK_RECORD_PAD)\n+\t{\n+\t  if (slot_offset > frame_offset)\n+\t    add_frame_space (frame_offset, slot_offset);\n+\t  if (slot_offset + size < old_frame_offset)\n+\t    add_frame_space (slot_offset + size, old_frame_offset);\n+\t}\n     }\n   else\n     {\n       frame_offset += size;\n       try_fit_stack_local (old_frame_offset, size, size, alignment, &slot_offset);\n \n-      if (slot_offset > old_frame_offset)\n-\tadd_frame_space (old_frame_offset, slot_offset);\n-      if (slot_offset + size < frame_offset)\n-\tadd_frame_space (slot_offset + size, frame_offset);\n+      if (kind & ASLK_RECORD_PAD)\n+\t{\n+\t  if (slot_offset > old_frame_offset)\n+\t    add_frame_space (old_frame_offset, slot_offset);\n+\t  if (slot_offset + size < frame_offset)\n+\t    add_frame_space (slot_offset + size, frame_offset);\n+\t}\n     }\n \n  found_space:\n@@ -513,7 +525,7 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n rtx\n assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n {\n-  return assign_stack_local_1 (mode, size, align, false);\n+  return assign_stack_local_1 (mode, size, align, ASLK_RECORD_PAD);\n }\n \f\n \f\n@@ -868,11 +880,13 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \t and round it now.  We also make sure ALIGNMENT is at least\n \t BIGGEST_ALIGNMENT.  */\n       gcc_assert (mode != BLKmode || align == BIGGEST_ALIGNMENT);\n-      p->slot = assign_stack_local (mode,\n-\t\t\t\t    (mode == BLKmode\n-\t\t\t\t     ? CEIL_ROUND (size, (int) align / BITS_PER_UNIT)\n-\t\t\t\t     : size),\n-\t\t\t\t    align);\n+      p->slot = assign_stack_local_1 (mode,\n+\t\t\t\t      (mode == BLKmode\n+\t\t\t\t       ? CEIL_ROUND (size,\n+\t\t\t\t\t\t     (int) align\n+\t\t\t\t\t\t     / BITS_PER_UNIT)\n+\t\t\t\t       : size),\n+\t\t\t\t      align, 0);\n \n       p->align = align;\n "}, {"sha": "0552156d64808a830a22dce932cd230b7d9c0dfa", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -1,6 +1,6 @@\n /* Register Transfer Language (RTL) definitions for GCC\n    Copyright (C) 1987, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1685,7 +1685,9 @@ extern rtx simplify_subtraction (rtx);\n \n /* In function.c  */\n extern rtx assign_stack_local (enum machine_mode, HOST_WIDE_INT, int);\n-extern rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int, bool);\n+#define ASLK_REDUCE_ALIGN 1\n+#define ASLK_RECORD_PAD 2\n+extern rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int, int);\n extern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT, int);\n extern rtx assign_stack_temp_for_type (enum machine_mode,\n \t\t\t\t       HOST_WIDE_INT, int, tree);"}, {"sha": "10c430a3c886c520eda4b5534c1af064dcf61fd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -1,3 +1,8 @@\n+2011-02-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/47893\n+\t* gcc.dg/pr47893.c: New test.\n+\n 2011-02-28  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/gnu-api-2-sel.m: Test that sel_getTypedSelector return"}, {"sha": "317d95d3fb30d56cb7f459338077f2e35b279ed4", "filename": "gcc/testsuite/gcc.dg/pr47893.c", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ftestsuite%2Fgcc.dg%2Fpr47893.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80a832cd25fa03a93768f3d2bc05d23a06a87e26/gcc%2Ftestsuite%2Fgcc.dg%2Fpr47893.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr47893.c?ref=80a832cd25fa03a93768f3d2bc05d23a06a87e26", "patch": "@@ -0,0 +1,187 @@\n+/* PR middle-end/47893 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-options \"-O2 -mtune=atom -fno-omit-frame-pointer -fno-strict-aliasing\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  unsigned s1:4, s2:2, s3:2, s4:2, s5:2, s6:1, s7:1, s8:1, s9:1, s10:1;\n+  int s11:16; unsigned s12:4; int s13:16; unsigned s14:2;\n+  int s15:16; unsigned s16:4; int s17:16; unsigned s18:2;\n+};\n+\n+struct T\n+{\n+  unsigned t[3];\n+};\n+\n+struct U\n+{\n+  unsigned u1, u2;\n+};\n+\n+struct V;\n+\n+struct W\n+{\n+  char w1[24]; struct V *w2; unsigned w3; char w4[28912];\n+  unsigned int w5; char w6[60];\n+};\n+\n+struct X\n+{\n+  unsigned int x[2];\n+};\n+\n+struct V\n+{\n+  int v1;\n+  struct X v2[3];\n+  char v3[28];\n+};\n+\n+struct Y\n+{\n+  void *y1;\n+  char y2[3076];\n+  struct T y3[32];\n+  char y4[1052];\n+};\n+\n+volatile struct S v1 = { .s15 = -1, .s16 = 15, .s17 = -1, .s18 = 3 };\n+\n+__attribute__ ((noinline, noclone))\n+int\n+fn1 (int x)\n+{\n+  int r;\n+  __asm__ volatile (\"\" : \"=r\" (r) : \"0\" (1), \"r\" (x) : \"memory\");\n+  return r;\n+}\n+\n+volatile int cnt;\n+\n+__attribute__ ((noinline, noclone))\n+#ifdef __i386__\n+__attribute__ ((regparm (2)))\n+#endif\n+struct S\n+fn2 (struct Y *x, const struct X *y)\n+{\n+  if (++cnt > 1)\n+    abort ();\n+  __asm__ volatile (\"\" : : \"r\" (x), \"r\" (y) : \"memory\");\n+  return v1;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+void fn3 (void *x, unsigned y, const struct S *z, unsigned w)\n+{\n+  __asm__ volatile (\"\" : : \"r\" (x), \"r\" (y), \"r\" (z), \"r\" (w) : \"memory\");\n+}\n+\n+volatile struct U v2;\n+\n+__attribute__ ((noinline, noclone))\n+struct U\n+fn4 (void *x, unsigned y)\n+{\n+  __asm__ volatile (\"\" : : \"r\" (x), \"r\" (y) : \"memory\");\n+  return v2;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+struct S\n+fn5 (void *x)\n+{\n+  __asm__ volatile (\"\" : : \"r\" (x) : \"memory\");\n+  return v1;\n+}\n+\n+volatile struct T v3;\n+\n+__attribute__ ((noinline, noclone))\n+struct T fn6 (void *x)\n+{\n+  __asm__ volatile (\"\" : : \"r\" (x) : \"memory\");\n+  return v3;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+struct T fn7 (void *x, unsigned y, unsigned z)\n+{\n+  __asm__ volatile (\"\" : : \"r\" (x), \"r\" (y), \"r\" (z) : \"memory\");\n+  return v3;\n+}\n+\n+static void\n+fn8 (struct Y *x, const struct V *y)\n+{\n+  void *a = x->y1;\n+  struct S b[4];\n+  unsigned i, c;\n+  c = fn1 (y->v1);\n+  for (i = 0; i < c; i++)\n+    b[i] = fn2 (x, &y->v2[i]);\n+  fn3 (a, y->v1, b, c);\n+}\n+\n+static inline void\n+fn9 (void *x, struct S y __attribute__((unused)))\n+{\n+  fn4 (x, 8);\n+}\n+\n+static void\n+fn10 (struct Y *x)\n+{\n+  void *a = x->y1;\n+  struct T b __attribute__((unused)) = fn6 (a);\n+  fn9 (a, fn5 (a));\n+}\n+\n+__attribute__((noinline, noclone))\n+int\n+fn11 (unsigned int x, void *y, const struct W *z,\n+      unsigned int w, const char *v, const char *u)\n+{\n+  struct Y a, *t;\n+  unsigned i;\n+  t = &a;\n+  __builtin_memset (t, 0, sizeof *t);\n+  t->y1 = y;\n+  if (x == 0)\n+    {\n+      if (z->w3 & 1)\n+\tfn10 (t);\n+      for (i = 0; i < w; i++)\n+\t{\n+\t  if (v[i] == 0)\n+\t    t->y3[i] = fn7 (y, 0, u[i]);\n+\t  else\n+\t    return 0;\n+\t}\n+    }\n+  else\n+    for (i = 0; i < w; i++)\n+      t->y3[i] = fn7 (y, v[i], u[i]);\n+  for (i = 0; i < z->w5; i++)\n+    fn8 (t, &z->w2[i]);\n+  return 0;\n+}\n+\n+volatile int i;\n+const char *volatile p = \"\";\n+\n+int\n+main ()\n+{\n+  struct V v = { .v1 = 0 };\n+  struct W w = { .w5 = 1, .w2 = &v };\n+  fn11 (i + 1, (void *) p, &w, i, (const char *) p, (const char *) p);\n+  if (cnt != 1)\n+    abort ();\n+  return 0;\n+}"}]}