{"sha": "a3f2babd42c1b52ec313dec8af4eaa0386182d64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmMmJhYmQ0MmMxYjUyZWMzMTNkZWM4YWY0ZWFhMDM4NjE4MmQ2NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T14:09:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-04T14:09:52Z"}, "message": "[multiple changes]\n\n2010-10-04  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Set_Biased): New procedure, now used throughout, adds\n\tname of entity to biased warning msg.\n\t(Analyze_Enumeration_Representation_Clause): Remove attempt to use\n\tbiased rep (wrong and never worked anyway).\n\n2010-10-04  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_elab.adb: Minor reformatting.\n\n2010-10-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Null): Handle properly the case of a subtype of\n\tan access_to_protected subprogram type, and convert null value into\n\tcorresponding aggregate.\n\n2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gnat_ugn.texi: Clarify first point of 7.1.5 about pragma Inline.\n\n2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* make.adb (Scan_Make_Arg): Pass -Oxxx switches to the linker as well.\n\t* gnatlink.adb (Gnatlink): Filter out -Oxxx switches for CLI, RTX and\n\tAAMP.\n\n2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Indexed_Component_Form): Remove redundant test\n\tfor N_Operator_Symbol.\n\t(Indicate_Name_And_Type): Likewise.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Likewise.\n\t* sem_res.adb (Resolve): Likewise.\n\t* sem_type.adb (Add_One_Interp): Likewise.\n\t(Disambiguate): Likewise.\n\t\n2010-10-04  Vincent Celier  <celier@adacore.com>\n\n\t* osint.adb (Read_Library_Info_From_Full): If object timestamp is less\n\tthan ALI file timestamp, return null.\n\n2010-10-04  Vincent Celier  <celier@adacore.com>\n\n\t* prj-makr.adb (Finalize): Invoke Pretty_Print with Max_Length set to 79\n\t* prj-pp.adb (Pretty_Print): New parameter Max_Line_Length, that\n\treplaces global constant with the same name. When a line is too long,\n\tindent properly the next continuation line.\n\t* prj-pp.ads (Pretty_Print): New parameter Max_Line_Length with a range\n\tfrom 50 to 255, defaulted to 255, to indicate the maximum length of\n\tlines in the project file.\n\n2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch7.adb (Analyze_Package_Body_Helper) <Has_Referencer>: New\n\tCheck_Subprogram_Ref function and Check_Subprogram_Refs instantiation\n\tof Traverse_Func on it to look for subprogram references in a body.\n\tCall Check_Subprogram_Refs on the body of inlined subprograms at the\n\touter level and keep clearing the Is_Public flag of subprograms as long\n\tas it returns OK.  Do not look at anything else than subprograms once\n\tan inlined subprogram has been seen.\n\nFrom-SVN: r164940", "tree": {"sha": "14e39f952fb35b97ee8a8565380c3e0a302223ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14e39f952fb35b97ee8a8565380c3e0a302223ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3f2babd42c1b52ec313dec8af4eaa0386182d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f2babd42c1b52ec313dec8af4eaa0386182d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f2babd42c1b52ec313dec8af4eaa0386182d64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f2babd42c1b52ec313dec8af4eaa0386182d64/comments", "author": null, "committer": null, "parents": [{"sha": "d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d69cf005d0df53b9ebcd3eaf0c1e2740d5b36f1c"}], "stats": {"total": 701, "additions": 471, "deletions": 230}, "files": [{"sha": "2b1fb9836573ac012ef6952217fc7abc8d955fce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -1,3 +1,65 @@\n+2010-10-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Set_Biased): New procedure, now used throughout, adds\n+\tname of entity to biased warning msg.\n+\t(Analyze_Enumeration_Representation_Clause): Remove attempt to use\n+\tbiased rep (wrong and never worked anyway).\n+\n+2010-10-04  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_elab.adb: Minor reformatting.\n+\n+2010-10-04  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Null): Handle properly the case of a subtype of\n+\tan access_to_protected subprogram type, and convert null value into\n+\tcorresponding aggregate.\n+\n+2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat_ugn.texi: Clarify first point of 7.1.5 about pragma Inline.\n+\n+2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* make.adb (Scan_Make_Arg): Pass -Oxxx switches to the linker as well.\n+\t* gnatlink.adb (Gnatlink): Filter out -Oxxx switches for CLI, RTX and\n+\tAAMP.\n+\n+2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Indexed_Component_Form): Remove redundant test\n+\tfor N_Operator_Symbol.\n+\t(Indicate_Name_And_Type): Likewise.\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Likewise.\n+\t* sem_res.adb (Resolve): Likewise.\n+\t* sem_type.adb (Add_One_Interp): Likewise.\n+\t(Disambiguate): Likewise.\n+\t\n+2010-10-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* osint.adb (Read_Library_Info_From_Full): If object timestamp is less\n+\tthan ALI file timestamp, return null.\n+\n+2010-10-04  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-makr.adb (Finalize): Invoke Pretty_Print with Max_Length set to 79\n+\t* prj-pp.adb (Pretty_Print): New parameter Max_Line_Length, that\n+\treplaces global constant with the same name. When a line is too long,\n+\tindent properly the next continuation line.\n+\t* prj-pp.ads (Pretty_Print): New parameter Max_Line_Length with a range\n+\tfrom 50 to 255, defaulted to 255, to indicate the maximum length of\n+\tlines in the project file.\n+\n+2010-10-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper) <Has_Referencer>: New\n+\tCheck_Subprogram_Ref function and Check_Subprogram_Refs instantiation\n+\tof Traverse_Func on it to look for subprogram references in a body.\n+\tCall Check_Subprogram_Refs on the body of inlined subprograms at the\n+\touter level and keep clearing the Is_Public flag of subprograms as long\n+\tas it returns OK.  Do not look at anything else than subprograms once\n+\tan inlined subprogram has been seen.\n+\n 2010-10-04  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_cg.adb (Expand_N_Assignment_Statement): Restore tag check when"}, {"sha": "346def7f756d43af08b6dc4091e110c7913efe76", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -2183,7 +2183,7 @@ package body Exp_Ch4 is\n \n             --  if no TSS has been created for the type, check whether there is\n             --  a primitive equality declared for it. If it is abstract replace\n-            --  the call with an explicit raise.\n+            --  the call with an explicit raise (AI05-0123).\n \n             declare\n                Prim : Elmt_Id;\n@@ -2208,7 +2208,7 @@ package body Exp_Ch4 is\n                end loop;\n             end;\n \n-            --  Predfined equality applies iff no user-defined primitive exists\n+            --  Use predefined equality iff no user-defined primitive exists\n \n             return Make_Op_Eq (Loc, Lhs, Rhs);\n \n@@ -2217,8 +2217,7 @@ package body Exp_Ch4 is\n          end if;\n \n       else\n-\n-         --  It can be a simple record or the full view of a scalar private\n+         --  If not array or record type, it is predefined equality.\n \n          return Make_Op_Eq (Loc, Left_Opnd => Lhs, Right_Opnd => Rhs);\n       end if;\n@@ -5031,15 +5030,15 @@ package body Exp_Ch4 is\n    -- Expand_N_Null --\n    -------------------\n \n-   --  The only replacement required is for the case of a null of type that is\n-   --  an access to protected subprogram. We represent such access values as a\n-   --  record, and so we must replace the occurrence of null by the equivalent\n-   --  record (with a null address and a null pointer in it), so that the\n-   --  backend creates the proper value.\n+   --  The only replacement required is for the case of a null of a type that\n+   --  is an access to protected subprogram, or a subtype thereof. We represent\n+   --  such access values as a record, and so we must replace the occurrence of\n+   --  null by the equivalent record (with a null address and a null pointer in\n+   --  it), so that the backend creates the proper value.\n \n    procedure Expand_N_Null (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n-      Typ : constant Entity_Id  := Etype (N);\n+      Typ : constant Entity_Id  := Base_Type (Etype (N));\n       Agg : Node_Id;\n \n    begin"}, {"sha": "d6d003996bf0750d55dae04c41aedd4126c03df7", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -4246,7 +4246,7 @@ means that no limit applies.\n @item -gnatn\n @cindex @option{-gnatn} (@command{gcc})\n Activate inlining for subprograms for which\n-pragma @code{inline} is specified. This inlining is performed\n+pragma @code{Inline} is specified. This inlining is performed\n by the GCC back-end.\n \n @item -gnatN\n@@ -10392,8 +10392,9 @@ subprograms.\n @item\n @cindex pragma Inline\n @findex Inline\n-Either @code{pragma Inline} applies to the subprogram, or it is local to\n-the unit and called once from within it, or it is small and optimization\n+Either @code{pragma Inline} applies to the subprogram and the\n+@option{^-gnatn^/INLINE^} switch is used on the command line, or it is local\n+to the unit and called once from within it, or it is small and optimization\n level @option{-O2} is specified, or automatic inlining (optimization level\n @option{-O3}) is specified.\n @end itemize\n@@ -10419,9 +10420,7 @@ The call appears in a body (not in a package spec).\n There is a @code{pragma Inline} for the subprogram.\n \n @item\n-@cindex @option{-gnatn} (@command{gcc})\n-The @option{^-gnatn^/INLINE^} switch\n-is used in the @command{gcc} command line\n+The @option{^-gnatn^/INLINE^} switch is used on the command line.\n @end itemize\n \n Even if all these conditions are met, it may not be possible for"}, {"sha": "b2fcf23e9542acf267d47116c792a3cf2e72a511", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -1965,6 +1965,25 @@ begin\n                  or else Linker_Options.Table (J) (1 .. 2) = \"-l\"\n                  or else Linker_Options.Table (J) (1 .. 3) = \"-Wl\"\n                  or else Linker_Options.Table (J) (1 .. 3) = \"-sh\"\n+                 or else Linker_Options.Table (J) (1 .. 2) = \"-O\"\n+                 or else Linker_Options.Table (J) (1 .. 2) = \"-g\"\n+               then\n+                  Linker_Options.Table (J .. Linker_Options.Last - 1) :=\n+                    Linker_Options.Table (J + 1 .. Linker_Options.Last);\n+                  Linker_Options.Decrement_Last;\n+                  Num_Args := Num_Args - 1;\n+               end if;\n+            end loop;\n+\n+         elsif AAMP_On_Target then\n+\n+            --  Remove extraneous flags not relevant for AAMP\n+\n+            for J in reverse Linker_Options.First .. Linker_Options.Last loop\n+               if Linker_Options.Table (J)'Length = 0\n+                 or else Linker_Options.Table (J) (1 .. 3) = \"-Wl\"\n+                 or else Linker_Options.Table (J) (1 .. 3) = \"-sh\"\n+                 or else Linker_Options.Table (J) (1 .. 2) = \"-O\"\n                  or else Linker_Options.Table (J) (1 .. 2) = \"-g\"\n                then\n                   Linker_Options.Table (J .. Linker_Options.Last - 1) :=\n@@ -1986,6 +2005,7 @@ begin\n                  or else Linker_Options.Table (J) (1 .. 2) = \"-l\"\n                  or else Linker_Options.Table (J) (1 .. 3) = \"-Wl\"\n                  or else Linker_Options.Table (J) (1 .. 3) = \"-sh\"\n+                 or else Linker_Options.Table (J) (1 .. 2) = \"-O\"\n                  or else Linker_Options.Table (J) (1 .. 8) = \"-Xlinker\"\n                  or else Linker_Options.Table (J) (1 .. 9) = \"-mthreads\"\n                then"}, {"sha": "46af1ffccd90c25e12f4b0b8663c6d2b091a1019", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -8060,19 +8060,20 @@ package body Make is\n          elsif Argv (2) = 'L' then\n             Add_Switch (Argv, Linker, And_Save => And_Save);\n \n-         --  For -gxxxxx, -pg, -mxxx, -fxxx: give the switch to both the\n+         --  For -gxxx, -pg, -mxxx, -fxxx, -Oxxx, pass the switch to both the\n          --  compiler and the linker (except for -gnatxxx which is only for the\n          --  compiler). Some of the -mxxx (for example -m64) and -fxxx (for\n          --  example -ftest-coverage for gcov) need to be used when compiling\n          --  the binder generated files, and using all these gcc switches for\n-         --  the binder generated files should not be a problem.\n+         --  them should not be a problem. Pass -Oxxx to the linker for LTO.\n \n          elsif\n            (Argv (2) = 'g' and then (Argv'Last < 5\n                                        or else Argv (2 .. 5) /= \"gnat\"))\n              or else Argv (2 .. Argv'Last) = \"pg\"\n              or else (Argv (2) = 'm' and then Argv'Last > 2)\n              or else (Argv (2) = 'f' and then Argv'Last > 2)\n+             or else (Argv (2) = 'O' and then Argv'Last > 2)\n          then\n             Add_Switch (Argv, Compiler, And_Save => And_Save);\n             Add_Switch (Argv, Linker,   And_Save => And_Save);"}, {"sha": "7d2a973d1dde05e5ad2b1afda50b453debee7b84", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -2508,6 +2508,13 @@ package body Osint is\n \n                return null;\n             end if;\n+\n+         elsif Current_Full_Obj_Stamp < Current_Full_Lib_Stamp then\n+            Close (Lib_FD, Status);\n+\n+            --  No need to check the status, we return null anyway\n+\n+            return null;\n          end if;\n       end if;\n "}, {"sha": "3e02783aacb13e2122e2634259fa058fabfe8710", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -693,7 +693,8 @@ package body Prj.Makr is\n             W_Char                 => Write_A_Char'Access,\n             W_Eol                  => Write_Eol'Access,\n             W_Str                  => Write_A_String'Access,\n-            Backward_Compatibility => False);\n+            Backward_Compatibility => False,\n+            Max_Line_Length        => 79);\n          Close (Output_FD);\n \n          --  Delete the naming project file if it already exists"}, {"sha": "e03146ce4a62470cb986cca00325c736f959dff0", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 196, "deletions": 138, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,19 +34,6 @@ package body Prj.PP is\n \n    Not_Tested : array (Project_Node_Kind) of Boolean := (others => True);\n \n-   Max_Line_Length : constant := 255;\n-   --  Maximum length of a line. This is chosen to be compatible with older\n-   --  versions of GNAT that had a strict limit on the maximum line length.\n-\n-   Column : Natural := 0;\n-   --  Column number of the last character in the line. Used to avoid\n-   --  outputting lines longer than Max_Line_Length.\n-\n-   First_With_In_List : Boolean := True;\n-   --  Indicate that the next with clause is first in a list such as\n-   --    with \"A\", \"B\";\n-   --  First_With_In_List will be True for \"A\", but not for \"B\".\n-\n    procedure Indicate_Tested (Kind : Project_Node_Kind);\n    --  Set the corresponding component of array Not_Tested to False.\n    --  Only called by pragmas Debug.\n@@ -67,43 +54,52 @@ package body Prj.PP is\n    procedure Pretty_Print\n      (Project                            : Prj.Tree.Project_Node_Id;\n       In_Tree                            : Prj.Tree.Project_Node_Tree_Ref;\n-      Increment                          : Positive      := 3;\n-      Eliminate_Empty_Case_Constructions : Boolean       := False;\n-      Minimize_Empty_Lines               : Boolean       := False;\n-      W_Char                             : Write_Char_Ap := null;\n-      W_Eol                              : Write_Eol_Ap  := null;\n-      W_Str                              : Write_Str_Ap  := null;\n+      Increment                          : Positive       := 3;\n+      Eliminate_Empty_Case_Constructions : Boolean        := False;\n+      Minimize_Empty_Lines               : Boolean        := False;\n+      W_Char                             : Write_Char_Ap  := null;\n+      W_Eol                              : Write_Eol_Ap   := null;\n+      W_Str                              : Write_Str_Ap   := null;\n       Backward_Compatibility             : Boolean;\n-      Id                                 : Prj.Project_Id := Prj.No_Project)\n+      Id                                 : Prj.Project_Id := Prj.No_Project;\n+      Max_Line_Length                    : Max_Length_Of_Line :=\n+                                             Max_Length_Of_Line'Last)\n    is\n       procedure Print (Node : Project_Node_Id; Indent : Natural);\n       --  A recursive procedure that traverses a project file tree and outputs\n       --  its source. Current_Prj is the project that we are printing. This\n       --  is used when printing attributes, since in nested packages they\n       --  need to use a fully qualified name.\n \n-      procedure Output_Attribute_Name (Name : Name_Id);\n+      procedure Output_Attribute_Name (Name : Name_Id; Indent : Natural);\n       --  Outputs an attribute name, taking into account the value of\n       --  Backward_Compatibility.\n \n-      procedure Output_Name (Name : Name_Id; Capitalize : Boolean := True);\n+      procedure Output_Name\n+        (Name       : Name_Id;\n+         Indent     : Natural;\n+         Capitalize : Boolean := True);\n       --  Outputs a name\n \n       procedure Start_Line (Indent : Natural);\n       --  Outputs the indentation at the beginning of the line\n \n-      procedure Output_String (S : Name_Id);\n-      procedure Output_String (S : Path_Name_Type);\n+      procedure Output_String (S : Name_Id; Indent : Natural);\n+      procedure Output_String (S : Path_Name_Type; Indent : Natural);\n       --  Outputs a string using the default output procedures\n \n       procedure Write_Empty_Line (Always : Boolean := False);\n       --  Outputs an empty line, only if the previous line was not empty\n-      --  already and either Always is True or Minimize_Empty_Lines is False.\n+      --  already and either Always is True or Minimize_Empty_Lines is\n+      --  False.\n \n       procedure Write_Line (S : String);\n       --  Outputs S followed by a new line\n \n-      procedure Write_String (S : String; Truncated : Boolean := False);\n+      procedure Write_String\n+        (S         : String;\n+         Indent    : Natural;\n+         Truncated : Boolean := False);\n       --  Outputs S using Write_Str, starting a new line if line would\n       --  become too long, when Truncated = False.\n       --  When Truncated = True, only the part of the string that can fit on\n@@ -112,57 +108,78 @@ package body Prj.PP is\n       procedure Write_End_Of_Line_Comment (Node : Project_Node_Id);\n \n       Write_Char : Write_Char_Ap := Output.Write_Char'Access;\n-      Write_Eol  : Write_Eol_Ap  := Output.Write_Eol'Access;\n-      Write_Str  : Write_Str_Ap  := Output.Write_Str'Access;\n+      Write_Eol  : Write_Eol_Ap := Output.Write_Eol'Access;\n+      Write_Str  : Write_Str_Ap := Output.Write_Str'Access;\n       --  These three access to procedure values are used for the output\n \n       Last_Line_Is_Empty : Boolean := False;\n       --  Used to avoid two consecutive empty lines\n \n+      Column : Natural := 0;\n+      --  Column number of the last character in the line. Used to avoid\n+      --  outputting lines longer than Max_Line_Length.\n+\n+      First_With_In_List : Boolean := True;\n+      --  Indicate that the next with clause is first in a list such as\n+      --    with \"A\", \"B\";\n+      --  First_With_In_List will be True for \"A\", but not for \"B\".\n+\n       ---------------------------\n       -- Output_Attribute_Name --\n       ---------------------------\n \n-      procedure Output_Attribute_Name (Name : Name_Id) is\n+      procedure Output_Attribute_Name (Name : Name_Id; Indent : Natural) is\n       begin\n          if Backward_Compatibility then\n             case Name is\n                when Snames.Name_Spec =>\n-                  Output_Name (Snames.Name_Specification);\n+                  Output_Name (Snames.Name_Specification, Indent);\n \n                when Snames.Name_Spec_Suffix =>\n-                  Output_Name (Snames.Name_Specification_Suffix);\n+                  Output_Name (Snames.Name_Specification_Suffix, Indent);\n \n                when Snames.Name_Body =>\n-                  Output_Name (Snames.Name_Implementation);\n+                  Output_Name (Snames.Name_Implementation, Indent);\n \n                when Snames.Name_Body_Suffix =>\n-                  Output_Name (Snames.Name_Implementation_Suffix);\n+                  Output_Name (Snames.Name_Implementation_Suffix, Indent);\n \n                when others =>\n-                  Output_Name (Name);\n+                  Output_Name (Name, Indent);\n             end case;\n \n          else\n-            Output_Name (Name);\n+            Output_Name (Name, Indent);\n          end if;\n       end Output_Attribute_Name;\n \n       -----------------\n       -- Output_Name --\n       -----------------\n \n-      procedure Output_Name (Name : Name_Id; Capitalize : Boolean := True) is\n+      procedure Output_Name\n+        (Name       : Name_Id;\n+         Indent     : Natural;\n+         Capitalize : Boolean := True)\n+      is\n          Capital : Boolean := Capitalize;\n \n       begin\n+         if Column = 0 and then Indent /= 0 then\n+            Start_Line (Indent + Increment);\n+         end if;\n+\n          Get_Name_String (Name);\n \n          --  If line would become too long, create new line\n \n          if Column + Name_Len > Max_Line_Length then\n             Write_Eol.all;\n             Column := 0;\n+\n+            if Indent /= 0 then\n+               Start_Line (Indent + Increment);\n+            end if;\n          end if;\n \n          for J in 1 .. Name_Len loop\n@@ -186,18 +203,26 @@ package body Prj.PP is\n       -- Output_String --\n       -------------------\n \n-      procedure Output_String (S : Name_Id) is\n+      procedure Output_String (S : Name_Id; Indent : Natural) is\n       begin\n+         if Column = 0 and then Indent /= 0 then\n+            Start_Line (Indent + Increment);\n+         end if;\n+\n          Get_Name_String (S);\n \n-         --  If line could become too long, create new line.\n-         --  Note that the number of characters on the line could be\n-         --  twice the number of character in the string (if every\n-         --  character is a '\"') plus two (the initial and final '\"').\n+         --  If line could become too long, create new line. Note that the\n+         --  number of characters on the line could be twice the number of\n+         --  character in the string (if every character is a '\"') plus two\n+         --  (the initial and final '\"').\n \n          if Column + Name_Len + Name_Len + 2 > Max_Line_Length then\n             Write_Eol.all;\n             Column := 0;\n+\n+            if Indent /= 0 then\n+               Start_Line (Indent + Increment);\n+            end if;\n          end if;\n \n          Write_Char ('\"');\n@@ -214,24 +239,26 @@ package body Prj.PP is\n                Column := Column + 1;\n             end if;\n \n-            --  If the string does not fit on one line, cut it in parts\n-            --  and concatenate.\n+            --  If the string does not fit on one line, cut it in parts and\n+            --  concatenate.\n \n             if J < Name_Len and then Column >= Max_Line_Length then\n                Write_Str (\"\"\" &\");\n                Write_Eol.all;\n+               Column := 0;\n+               Start_Line (Indent + Increment);\n                Write_Char ('\"');\n-               Column := 1;\n+               Column := Column + 1;\n             end if;\n          end loop;\n \n          Write_Char ('\"');\n          Column := Column + 1;\n       end Output_String;\n \n-      procedure Output_String (S : Path_Name_Type) is\n+      procedure Output_String (S : Path_Name_Type; Indent : Natural) is\n       begin\n-         Output_String (Name_Id (S));\n+         Output_String (Name_Id (S), Indent);\n       end Output_String;\n \n       ----------------\n@@ -269,8 +296,8 @@ package body Prj.PP is\n \n       begin\n          if Value /= No_Name then\n-            Write_String (\" --\");\n-            Write_String (Get_Name_String (Value), Truncated => True);\n+            Write_String (\" --\", 0);\n+            Write_String (Get_Name_String (Value), 0, Truncated => True);\n          end if;\n \n          Write_Line (\"\");\n@@ -282,7 +309,7 @@ package body Prj.PP is\n \n       procedure Write_Line (S : String) is\n       begin\n-         Write_String (S);\n+         Write_String (S, 0);\n          Last_Line_Is_Empty := False;\n          Write_Eol.all;\n          Column := 0;\n@@ -292,9 +319,16 @@ package body Prj.PP is\n       -- Write_String --\n       ------------------\n \n-      procedure Write_String (S : String; Truncated : Boolean := False) is\n+      procedure Write_String\n+        (S         : String;\n+         Indent    : Natural;\n+         Truncated : Boolean := False) is\n          Length : Natural := S'Length;\n       begin\n+         if Column = 0 and then Indent /= 0 then\n+            Start_Line (Indent + Increment);\n+         end if;\n+\n          --  If the string would not fit on the line,\n          --  start a new line.\n \n@@ -305,6 +339,10 @@ package body Prj.PP is\n             else\n                Write_Eol.all;\n                Column := 0;\n+\n+               if Indent /= 0 then\n+                  Start_Line (Indent + Increment);\n+               end if;\n             end if;\n          end if;\n \n@@ -316,7 +354,7 @@ package body Prj.PP is\n       -- Print --\n       -----------\n \n-      procedure Print (Node   : Project_Node_Id; Indent : Natural) is\n+      procedure Print (Node : Project_Node_Id; Indent : Natural) is\n       begin\n          if Present (Node) then\n \n@@ -335,27 +373,29 @@ package body Prj.PP is\n \n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Write_String (\"project \");\n+                  Write_String (\"project \", Indent);\n \n                   if Id /= Prj.No_Project then\n-                     Output_Name (Id.Display_Name);\n+                     Output_Name (Id.Display_Name, Indent);\n                   else\n-                     Output_Name (Name_Of (Node, In_Tree));\n+                     Output_Name (Name_Of (Node, In_Tree), Indent);\n                   end if;\n \n                   --  Check if this project extends another project\n \n                   if Extended_Project_Path_Of (Node, In_Tree) /= No_Path then\n-                     Write_String (\" extends \");\n+                     Write_String (\" extends \", Indent);\n \n                      if Is_Extending_All (Node, In_Tree) then\n-                        Write_String (\"all \");\n+                        Write_String (\"all \", Indent);\n                      end if;\n \n-                     Output_String (Extended_Project_Path_Of (Node, In_Tree));\n+                     Output_String\n+                       (Extended_Project_Path_Of (Node, In_Tree),\n+                        Indent);\n                   end if;\n \n-                  Write_String (\" is\");\n+                  Write_String (\" is\", Indent);\n                   Write_End_Of_Line_Comment (Node);\n                   Print\n                     (First_Comment_After (Node, In_Tree), Indent + Increment);\n@@ -368,12 +408,12 @@ package body Prj.PP is\n                     (First_Comment_Before_End (Node, In_Tree),\n                      Indent + Increment);\n                   Start_Line (Indent);\n-                  Write_String (\"end \");\n+                  Write_String (\"end \", Indent);\n \n                   if Id /= Prj.No_Project then\n-                     Output_Name (Id.Display_Name);\n+                     Output_Name (Id.Display_Name, Indent);\n                   else\n-                     Output_Name (Name_Of (Node, In_Tree));\n+                     Output_Name (Name_Of (Node, In_Tree), Indent);\n                   end if;\n \n                   Write_Line (\";\");\n@@ -397,20 +437,20 @@ package body Prj.PP is\n                         if Non_Limited_Project_Node_Of (Node, In_Tree) =\n                              Empty_Node\n                         then\n-                           Write_String (\"limited \");\n+                           Write_String (\"limited \", Indent);\n                         end if;\n \n-                        Write_String (\"with \");\n+                        Write_String (\"with \", Indent);\n                      end if;\n \n-                     Output_String (String_Value_Of (Node, In_Tree));\n+                     Output_String (String_Value_Of (Node, In_Tree), Indent);\n \n                      if Is_Not_Last_In_List (Node, In_Tree) then\n-                        Write_String (\", \");\n+                        Write_String (\", \", Indent);\n                         First_With_In_List := False;\n \n                      else\n-                        Write_String (\";\");\n+                        Write_String (\";\", Indent);\n                         Write_End_Of_Line_Comment (Node);\n                         Print (First_Comment_After (Node, In_Tree), Indent);\n                         First_With_In_List := True;\n@@ -441,25 +481,26 @@ package body Prj.PP is\n                   Write_Empty_Line (Always => True);\n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Write_String (\"package \");\n-                  Output_Name (Name_Of (Node, In_Tree));\n+                  Write_String (\"package \", Indent);\n+                  Output_Name (Name_Of (Node, In_Tree), Indent);\n \n                   if Project_Of_Renamed_Package_Of (Node, In_Tree) /=\n                        Empty_Node\n                   then\n-                     Write_String (\" renames \");\n+                     Write_String (\" renames \", Indent);\n                      Output_Name\n                        (Name_Of\n                           (Project_Of_Renamed_Package_Of (Node, In_Tree),\n-                           In_Tree));\n-                     Write_String (\".\");\n-                     Output_Name (Name_Of (Node, In_Tree));\n-                     Write_String (\";\");\n+                           In_Tree),\n+                        Indent);\n+                     Write_String (\".\", Indent);\n+                     Output_Name (Name_Of (Node, In_Tree), Indent);\n+                     Write_String (\";\", Indent);\n                      Write_End_Of_Line_Comment (Node);\n                      Print (First_Comment_After_End (Node, In_Tree), Indent);\n \n                   else\n-                     Write_String (\" is\");\n+                     Write_String (\" is\", Indent);\n                      Write_End_Of_Line_Comment (Node);\n                      Print (First_Comment_After (Node, In_Tree),\n                             Indent + Increment);\n@@ -475,8 +516,8 @@ package body Prj.PP is\n                      Print (First_Comment_Before_End (Node, In_Tree),\n                             Indent + Increment);\n                      Start_Line (Indent);\n-                     Write_String (\"end \");\n-                     Output_Name (Name_Of (Node, In_Tree));\n+                     Write_String (\"end \", Indent);\n+                     Output_Name (Name_Of (Node, In_Tree), Indent);\n                      Write_Line (\";\");\n                      Print (First_Comment_After_End (Node, In_Tree), Indent);\n                      Write_Empty_Line;\n@@ -486,62 +527,69 @@ package body Prj.PP is\n                   pragma Debug (Indicate_Tested (N_String_Type_Declaration));\n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Write_String (\"type \");\n-                  Output_Name (Name_Of (Node, In_Tree));\n+                  Write_String (\"type \", Indent);\n+                  Output_Name (Name_Of (Node, In_Tree), Indent);\n                   Write_Line (\" is\");\n                   Start_Line (Indent + Increment);\n-                  Write_String (\"(\");\n+                  Write_String (\"(\", Indent);\n \n                   declare\n                      String_Node : Project_Node_Id :=\n                        First_Literal_String (Node, In_Tree);\n \n                   begin\n                      while Present (String_Node) loop\n-                        Output_String (String_Value_Of (String_Node, In_Tree));\n+                        Output_String\n+                          (String_Value_Of (String_Node, In_Tree),\n+                           Indent);\n                         String_Node :=\n                           Next_Literal_String (String_Node, In_Tree);\n \n                         if Present (String_Node) then\n-                           Write_String (\", \");\n+                           Write_String (\", \", Indent);\n                         end if;\n                      end loop;\n                   end;\n \n-                  Write_String (\");\");\n+                  Write_String (\");\", Indent);\n                   Write_End_Of_Line_Comment (Node);\n                   Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Literal_String =>\n                   pragma Debug (Indicate_Tested (N_Literal_String));\n-                  Output_String (String_Value_Of (Node, In_Tree));\n+                  Output_String (String_Value_Of (Node, In_Tree), Indent);\n \n                   if Source_Index_Of (Node, In_Tree) /= 0 then\n-                     Write_String (\" at\");\n-                     Write_String (Source_Index_Of (Node, In_Tree)'Img);\n+                     Write_String (\" at\", Indent);\n+                     Write_String\n+                       (Source_Index_Of (Node, In_Tree)'Img,\n+                        Indent);\n                   end if;\n \n                when N_Attribute_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Declaration));\n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Write_String (\"for \");\n-                  Output_Attribute_Name (Name_Of (Node, In_Tree));\n+                  Write_String (\"for \", Indent);\n+                  Output_Attribute_Name (Name_Of (Node, In_Tree), Indent);\n \n                   if Associative_Array_Index_Of (Node, In_Tree) /= No_Name then\n-                     Write_String (\" (\");\n+                     Write_String (\" (\", Indent);\n                      Output_String\n-                       (Associative_Array_Index_Of (Node, In_Tree));\n+                       (Associative_Array_Index_Of (Node, In_Tree),\n+                        Indent);\n \n                      if Source_Index_Of (Node, In_Tree) /= 0 then\n-                        Write_String (\" at\");\n-                        Write_String (Source_Index_Of (Node, In_Tree)'Img);\n+                        Write_String (\" at\", Indent);\n+                        Write_String\n+                          (Source_Index_Of (Node, In_Tree)'Img,\n+                           Indent);\n                      end if;\n \n-                     Write_String (\")\");\n+                     Write_String (\")\", Indent);\n                   end if;\n \n-                  Write_String (\" use \");\n+                  Write_String (\" use \", Indent);\n \n                   if Present (Expression_Of (Node, In_Tree)) then\n                      Print (Expression_Of (Node, In_Tree), Indent);\n@@ -555,16 +603,18 @@ package body Prj.PP is\n                         Output_Name\n                           (Name_Of\n                              (Associative_Project_Of (Node, In_Tree),\n-                              In_Tree));\n+                              In_Tree),\n+                           Indent);\n \n                         if\n                           Present (Associative_Package_Of (Node, In_Tree))\n                         then\n-                           Write_String (\".\");\n+                           Write_String (\".\", Indent);\n                            Output_Name\n                              (Name_Of\n                                 (Associative_Package_Of (Node, In_Tree),\n-                                 In_Tree));\n+                                 In_Tree),\n+                              Indent);\n                         end if;\n \n                      elsif\n@@ -573,14 +623,15 @@ package body Prj.PP is\n                         Output_Name\n                           (Name_Of\n                              (Associative_Package_Of (Node, In_Tree),\n-                              In_Tree));\n+                              In_Tree),\n+                           Indent);\n                      end if;\n \n-                     Write_String (\"'\");\n-                     Output_Attribute_Name (Name_Of (Node, In_Tree));\n+                     Write_String (\"'\", Indent);\n+                     Output_Attribute_Name (Name_Of (Node, In_Tree), Indent);\n                   end if;\n \n-                  Write_String (\";\");\n+                  Write_String (\";\", Indent);\n                   Write_End_Of_Line_Comment (Node);\n                   Print (First_Comment_After (Node, In_Tree), Indent);\n \n@@ -589,24 +640,25 @@ package body Prj.PP is\n                     (Indicate_Tested (N_Typed_Variable_Declaration));\n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Output_Name (Name_Of (Node, In_Tree));\n-                  Write_String (\" : \");\n+                  Output_Name (Name_Of (Node, In_Tree), Indent);\n+                  Write_String (\" : \", Indent);\n                   Output_Name\n-                    (Name_Of (String_Type_Of (Node, In_Tree), In_Tree));\n-                  Write_String (\" := \");\n+                    (Name_Of (String_Type_Of (Node, In_Tree), In_Tree),\n+                     Indent);\n+                  Write_String (\" := \", Indent);\n                   Print (Expression_Of (Node, In_Tree), Indent);\n-                  Write_String (\";\");\n+                  Write_String (\";\", Indent);\n                   Write_End_Of_Line_Comment (Node);\n                   Print (First_Comment_After (Node, In_Tree), Indent);\n \n                when N_Variable_Declaration =>\n                   pragma Debug (Indicate_Tested (N_Variable_Declaration));\n                   Print (First_Comment_Before (Node, In_Tree), Indent);\n                   Start_Line (Indent);\n-                  Output_Name (Name_Of (Node, In_Tree));\n-                  Write_String (\" := \");\n+                  Output_Name (Name_Of (Node, In_Tree), Indent);\n+                  Write_String (\" := \", Indent);\n                   Print (Expression_Of (Node, In_Tree), Indent);\n-                  Write_String (\";\");\n+                  Write_String (\";\", Indent);\n                   Write_End_Of_Line_Comment (Node);\n                   Print (First_Comment_After (Node, In_Tree), Indent);\n \n@@ -621,7 +673,7 @@ package body Prj.PP is\n                         Term := Next_Term (Term, In_Tree);\n \n                         if Present (Term) then\n-                           Write_String (\" & \");\n+                           Write_String (\" & \", Indent);\n                         end if;\n                      end loop;\n                   end;\n@@ -632,7 +684,7 @@ package body Prj.PP is\n \n                when N_Literal_String_List =>\n                   pragma Debug (Indicate_Tested (N_Literal_String_List));\n-                  Write_String (\"(\");\n+                  Write_String (\"(\", Indent);\n \n                   declare\n                      Expression : Project_Node_Id :=\n@@ -645,40 +697,42 @@ package body Prj.PP is\n                           Next_Expression_In_List (Expression, In_Tree);\n \n                         if Present (Expression) then\n-                           Write_String (\", \");\n+                           Write_String (\", \", Indent);\n                         end if;\n                      end loop;\n                   end;\n \n-                  Write_String (\")\");\n+                  Write_String (\")\", Indent);\n \n                when N_Variable_Reference =>\n                   pragma Debug (Indicate_Tested (N_Variable_Reference));\n                   if Present (Project_Node_Of (Node, In_Tree)) then\n                      Output_Name\n-                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n-                     Write_String (\".\");\n+                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree),\n+                        Indent);\n+                     Write_String (\".\", Indent);\n                   end if;\n \n                   if Present (Package_Node_Of (Node, In_Tree)) then\n                      Output_Name\n-                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n-                     Write_String (\".\");\n+                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree),\n+                        Indent);\n+                     Write_String (\".\", Indent);\n                   end if;\n \n-                  Output_Name (Name_Of (Node, In_Tree));\n+                  Output_Name (Name_Of (Node, In_Tree), Indent);\n \n                when N_External_Value =>\n                   pragma Debug (Indicate_Tested (N_External_Value));\n-                  Write_String (\"external (\");\n+                  Write_String (\"external (\", Indent);\n                   Print (External_Reference_Of (Node, In_Tree), Indent);\n \n                   if Present (External_Default_Of (Node, In_Tree)) then\n-                     Write_String (\", \");\n+                     Write_String (\", \", Indent);\n                      Print (External_Default_Of (Node, In_Tree), Indent);\n                   end if;\n \n-                  Write_String (\")\");\n+                  Write_String (\")\", Indent);\n \n                when N_Attribute_Reference =>\n                   pragma Debug (Indicate_Tested (N_Attribute_Reference));\n@@ -687,34 +741,37 @@ package body Prj.PP is\n                     and then Project_Node_Of (Node, In_Tree) /= Project\n                   then\n                      Output_Name\n-                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree));\n+                       (Name_Of (Project_Node_Of (Node, In_Tree), In_Tree),\n+                        Indent);\n \n                      if Present (Package_Node_Of (Node, In_Tree)) then\n-                        Write_String (\".\");\n+                        Write_String (\".\", Indent);\n                         Output_Name\n-                          (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n+                          (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree),\n+                           Indent);\n                      end if;\n \n                   elsif Present (Package_Node_Of (Node, In_Tree)) then\n                      Output_Name\n-                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree));\n+                       (Name_Of (Package_Node_Of (Node, In_Tree), In_Tree),\n+                        Indent);\n \n                   else\n-                     Write_String (\"project\");\n+                     Write_String (\"project\", Indent);\n                   end if;\n \n-                  Write_String (\"'\");\n-                  Output_Attribute_Name (Name_Of (Node, In_Tree));\n+                  Write_String (\"'\", Indent);\n+                  Output_Attribute_Name (Name_Of (Node, In_Tree), Indent);\n \n                   declare\n                      Index : constant Name_Id :=\n                                Associative_Array_Index_Of (Node, In_Tree);\n \n                   begin\n                      if Index /= No_Name then\n-                        Write_String (\" (\");\n-                        Output_String (Index);\n-                        Write_String (\")\");\n+                        Write_String (\" (\", Indent);\n+                        Output_String (Index, Indent);\n+                        Write_String (\")\", Indent);\n                      end if;\n                   end;\n \n@@ -743,11 +800,11 @@ package body Prj.PP is\n                         Write_Empty_Line;\n                         Print (First_Comment_Before (Node, In_Tree), Indent);\n                         Start_Line (Indent);\n-                        Write_String (\"case \");\n+                        Write_String (\"case \", Indent);\n                         Print\n                           (Case_Variable_Reference_Of (Node, In_Tree),\n                            Indent);\n-                        Write_String (\" is\");\n+                        Write_String (\" is\", Indent);\n                         Write_End_Of_Line_Comment (Node);\n                         Print\n                           (First_Comment_After (Node, In_Tree),\n@@ -784,10 +841,10 @@ package body Prj.PP is\n                      Write_Empty_Line;\n                      Print (First_Comment_Before (Node, In_Tree), Indent);\n                      Start_Line (Indent);\n-                     Write_String (\"when \");\n+                     Write_String (\"when \", Indent);\n \n                      if No (First_Choice_Of (Node, In_Tree)) then\n-                        Write_String (\"others\");\n+                        Write_String (\"others\", Indent);\n \n                      else\n                         declare\n@@ -799,13 +856,13 @@ package body Prj.PP is\n                               Label := Next_Literal_String (Label, In_Tree);\n \n                               if Present (Label) then\n-                                 Write_String (\" | \");\n+                                 Write_String (\" | \", Indent);\n                               end if;\n                            end loop;\n                         end;\n                      end if;\n \n-                     Write_String (\" =>\");\n+                     Write_String (\" =>\", Indent);\n                      Write_End_Of_Line_Comment (Node);\n                      Print\n                        (First_Comment_After (Node, In_Tree),\n@@ -837,9 +894,10 @@ package body Prj.PP is\n                   end if;\n \n                   Start_Line (Indent);\n-                  Write_String (\"--\");\n+                  Write_String (\"--\", Indent);\n                   Write_String\n                     (Get_Name_String (String_Value_Of (Node, In_Tree)),\n+                     Indent,\n                      Truncated => True);\n                   Write_Line (\"\");\n "}, {"sha": "85bbdeb82ec6a8218f4ce6b3c2cacfd56bb14ecc", "filename": "gcc/ada/prj-pp.ads", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,17 +43,21 @@ package Prj.PP is\n \n    type Write_Str_Ap is access procedure (S : String);\n \n+   subtype Max_Length_Of_Line is Positive range 50 .. 255;\n+\n    procedure Pretty_Print\n      (Project                            : Prj.Tree.Project_Node_Id;\n       In_Tree                            : Prj.Tree.Project_Node_Tree_Ref;\n-      Increment                          : Positive      := 3;\n-      Eliminate_Empty_Case_Constructions : Boolean       := False;\n-      Minimize_Empty_Lines               : Boolean       := False;\n-      W_Char                             : Write_Char_Ap := null;\n-      W_Eol                              : Write_Eol_Ap  := null;\n-      W_Str                              : Write_Str_Ap  := null;\n+      Increment                          : Positive       := 3;\n+      Eliminate_Empty_Case_Constructions : Boolean        := False;\n+      Minimize_Empty_Lines               : Boolean        := False;\n+      W_Char                             : Write_Char_Ap  := null;\n+      W_Eol                              : Write_Eol_Ap   := null;\n+      W_Str                              : Write_Str_Ap   := null;\n       Backward_Compatibility             : Boolean;\n-      Id                                 : Prj.Project_Id := Prj.No_Project);\n+      Id                                 : Prj.Project_Id := Prj.No_Project;\n+      Max_Line_Length                    : Max_Length_Of_Line :=\n+                                             Max_Length_Of_Line'Last);\n    --  Output a project file, using either the default output routines, or the\n    --  ones specified by W_Char, W_Eol and W_Str.\n    --\n@@ -77,6 +81,8 @@ package Prj.PP is\n    --\n    --  Id is used to compute the display name of the project including its\n    --  proper casing.\n+   --\n+   --  Max_Line_Length is the maximum line length in the project file.\n \n private\n "}, {"sha": "3d884eda7bdfcaf5a9e0416358a3654f9fb8cda3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -106,6 +106,16 @@ package body Sem_Ch13 is\n    --  renaming_as_body. For tagged types, the specification is one of the\n    --  primitive specs.\n \n+   procedure Set_Biased\n+     (E      : Entity_Id;\n+      N      : Node_Id;\n+      Msg    : String;\n+      Biased : Boolean := True);\n+   --  If Biased is True, sets Has_Biased_Representation flag for E, and\n+   --  outputs a warning message at node N if Warn_On_Biased_Representation is\n+   --  is True. This warning inserts the string Msg to describe the construct\n+   --  causing biasing.\n+\n    ----------------------------------------------\n    -- Table for Validate_Unchecked_Conversions --\n    ----------------------------------------------\n@@ -1342,17 +1352,11 @@ package body Sem_Ch13 is\n                      Set_Esize                     (New_Ctyp, Csize);\n                      Set_RM_Size                   (New_Ctyp, Csize);\n                      Init_Alignment                (New_Ctyp);\n-                     Set_Has_Biased_Representation (New_Ctyp, True);\n                      Set_Is_Itype                  (New_Ctyp, True);\n                      Set_Associated_Node_For_Itype (New_Ctyp, U_Ent);\n \n                      Set_Component_Type (Btype, New_Ctyp);\n-\n-                     if Warn_On_Biased_Representation then\n-                        Error_Msg_N\n-                          (\"?component size clause forces biased \"\n-                           & \"representation\", N);\n-                     end if;\n+                     Set_Biased (New_Ctyp, N, \"component size clause\");\n                   end if;\n \n                   Set_Component_Size (Btype, Csize);\n@@ -1574,12 +1578,7 @@ package body Sem_Ch13 is\n                  or else Has_Small_Clause (U_Ent)\n                then\n                   Check_Size (Expr, Etyp, Size, Biased);\n-                     Set_Has_Biased_Representation (U_Ent, Biased);\n-\n-                  if Biased and Warn_On_Biased_Representation then\n-                     Error_Msg_N\n-                       (\"?size clause forces biased representation\", N);\n-                  end if;\n+                  Set_Biased (U_Ent, N, \"size clause\", Biased);\n                end if;\n \n                --  For types set RM_Size and Esize if possible\n@@ -1953,12 +1952,7 @@ package body Sem_Ch13 is\n             else\n                if Is_Elementary_Type (U_Ent) then\n                   Check_Size (Expr, U_Ent, Size, Biased);\n-                  Set_Has_Biased_Representation (U_Ent, Biased);\n-\n-                  if Biased and Warn_On_Biased_Representation then\n-                     Error_Msg_N\n-                       (\"?value size clause forces biased representation\", N);\n-                  end if;\n+                  Set_Biased (U_Ent, N, \"value size clause\", Biased);\n                end if;\n \n                Set_RM_Size (U_Ent, Size);\n@@ -2362,7 +2356,8 @@ package body Sem_Ch13 is\n                   --  If biasing worked, indicate that we now have biased rep\n \n                   else\n-                     Set_Has_Biased_Representation (Enumtype);\n+                     Set_Biased\n+                       (Enumtype, Size_Clause (Enumtype), \"size clause\");\n                   end if;\n                end if;\n \n@@ -2807,13 +2802,8 @@ package body Sem_Ch13 is\n                            Esize (Comp),\n                            Biased);\n \n-                        Set_Has_Biased_Representation (Comp, Biased);\n-\n-                        if Biased and Warn_On_Biased_Representation then\n-                           Error_Msg_F\n-                             (\"?component clause forces biased \"\n-                              & \"representation\", CC);\n-                        end if;\n+                        Set_Biased\n+                          (Comp, First_Node (CC), \"component clause\", Biased);\n \n                         if Present (Ocomp) then\n                            Set_Component_Clause     (Ocomp, CC);\n@@ -2825,6 +2815,10 @@ package body Sem_Ch13 is\n                            Set_Normalized_Position_Max\n                              (Ocomp, Normalized_Position (Ocomp));\n \n+                           --  Note: we don't use Set_Biased here, because we\n+                           --  already gave a warning above if needed, and we\n+                           --  would get a duplicate for the same name here.\n+\n                            Set_Has_Biased_Representation\n                              (Ocomp, Has_Biased_Representation (Comp));\n                         end if;\n@@ -4856,7 +4850,6 @@ package body Sem_Ch13 is\n       --  cases were already dealt with.\n \n       elsif Is_Enumeration_Type (T1) then\n-\n          Enumeration_Case : declare\n             L1, L2 : Entity_Id;\n \n@@ -4884,6 +4877,27 @@ package body Sem_Ch13 is\n       end if;\n    end Same_Representation;\n \n+   ----------------\n+   -- Set_Biased --\n+   ----------------\n+\n+   procedure Set_Biased\n+     (E      : Entity_Id;\n+      N      : Node_Id;\n+      Msg    : String;\n+      Biased : Boolean := True)\n+   is\n+   begin\n+      if Biased then\n+         Set_Has_Biased_Representation (E);\n+\n+         if Warn_On_Biased_Representation then\n+            Error_Msg_NE\n+              (\"?\" & Msg & \" forces biased representation for&\", N, E);\n+         end if;\n+      end if;\n+   end Set_Biased;\n+\n    --------------------\n    -- Set_Enum_Esize --\n    --------------------"}, {"sha": "ccc5575f4c59cc06afea99c44ce140013d14355b", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -2103,9 +2103,7 @@ package body Sem_Ch4 is\n \n       P_T := Base_Type (Etype (P));\n \n-      if Is_Entity_Name (P)\n-        or else Nkind (P) = N_Operator_Symbol\n-      then\n+      if Is_Entity_Name (P) then\n          U_N := Entity (P);\n \n          if Is_Type (U_N) then\n@@ -2526,9 +2524,7 @@ package body Sem_Ch4 is\n          --  being called is noted on the selector.\n \n          if not Is_Type (Nam) then\n-            if Is_Entity_Name (Name (N))\n-              or else Nkind (Name (N)) = N_Operator_Symbol\n-            then\n+            if Is_Entity_Name (Name (N)) then\n                Set_Entity (Name (N), Nam);\n \n             elsif Nkind (Name (N)) = N_Selected_Component then"}, {"sha": "e2e234466cdb2088bfa1f9dbdb8b800b725ee425", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 105, "deletions": 22, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -52,6 +52,7 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Disp; use Sem_Disp;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n@@ -473,9 +474,10 @@ package body Sem_Ch7 is\n       --  is conservative and definitely correct.\n \n       --  We only do this at the outer (library) level non-generic packages.\n-      --  The reason is simply to cut down on the number of external symbols\n-      --  generated, so this is simply an optimization of the efficiency\n-      --  of the compilation process. It has no other effect.\n+      --  The reason is simply to cut down on the number of global symbols\n+      --  generated, which has a double effect: (1) to make the compilation\n+      --  process more efficient and (2) to give the code generator more\n+      --  freedom to optimize within each unit, especially subprograms.\n \n       if (Scope (Spec_Id) = Standard_Standard or else Is_Child_Unit (Spec_Id))\n         and then not Is_Generic_Unit (Spec_Id)\n@@ -488,16 +490,18 @@ package body Sem_Ch7 is\n                Outer : Boolean)\n                return  Boolean;\n             --  Traverse the given list of declarations in reverse order.\n-            --  Return True as soon as a referencer is reached. Return False if\n-            --  none is found. The Outer parameter is True for the outer level\n-            --  call, and False for inner level calls for nested packages. If\n-            --  Outer is True, then any entities up to the point of hitting a\n-            --  referencer get their Is_Public flag cleared, so that the\n-            --  entities will be treated as static entities in the C sense, and\n-            --  need not have fully qualified names. For inner levels, we need\n-            --  all names to be fully qualified to deal with the same name\n-            --  appearing in parallel packages (right now this is tied to their\n-            --  being external).\n+            --  Return True if a referencer is present. Return False if none is\n+            --  found. The Outer parameter is True for the outer level call and\n+            --  False for inner level calls for nested packages. If Outer is\n+            --  True, then any entities up to the point of hitting a referencer\n+            --  get their Is_Public flag cleared, so that the entities will be\n+            --  treated as static entities in the C sense, and need not have\n+            --  fully qualified names. Furthermore, if the referencer is an\n+            --  inlined subprogram that doesn't reference other subprograms,\n+            --  we keep clearing the Is_Public flag on subprograms. For inner\n+            --  levels, we need all names to be fully qualified to deal with\n+            --  the same name appearing in parallel packages (right now this\n+            --  is tied to their being external).\n \n             --------------------\n             -- Has_Referencer --\n@@ -508,11 +512,66 @@ package body Sem_Ch7 is\n                Outer : Boolean)\n                return  Boolean\n             is\n+               Has_Referencer_Except_For_Subprograms : Boolean := False;\n                D : Node_Id;\n                E : Entity_Id;\n                K : Node_Kind;\n                S : Entity_Id;\n \n+               function Check_Subprogram_Ref (N : Node_Id)\n+                 return Traverse_Result;\n+               --  Look for references to subprograms\n+\n+               --------------------------\n+               -- Check_Subprogram_Ref --\n+               --------------------------\n+\n+               function Check_Subprogram_Ref (N : Node_Id)\n+                 return Traverse_Result\n+               is\n+                  V : Node_Id;\n+\n+               begin\n+\n+                  --  Check name of procedure or function calls\n+\n+                  if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call)\n+                    and then Is_Entity_Name (Name (N))\n+                  then\n+                     return Abandon;\n+                  end if;\n+\n+                  --  Check prefix of attribute references\n+\n+                  if Nkind (N) = N_Attribute_Reference\n+                    and then Is_Entity_Name (Prefix (N))\n+                    and then Present (Entity (Prefix (N)))\n+                    and then Ekind (Entity (Prefix (N))) in Subprogram_Kind\n+                  then\n+                     return Abandon;\n+                  end if;\n+\n+                  --  Check value of constants\n+\n+                  if Nkind (N) = N_Identifier\n+                    and then Present (Entity (N))\n+                    and then Ekind (Entity (N)) = E_Constant\n+                  then\n+                     V := Constant_Value (Entity (N));\n+                     if Present (V)\n+                       and then not Compile_Time_Known_Value_Or_Aggr (V)\n+                     then\n+                        return Abandon;\n+                     end if;\n+                  end if;\n+\n+                  return OK;\n+\n+               end Check_Subprogram_Ref;\n+\n+               function Check_Subprogram_Refs is\n+                 new Traverse_Func (Check_Subprogram_Ref);\n+\n             begin\n                if No (L) then\n                   return False;\n@@ -525,6 +584,8 @@ package body Sem_Ch7 is\n                   if K in N_Body_Stub then\n                      return True;\n \n+                  --  Processing for subprogram bodies\n+\n                   elsif K = N_Subprogram_Body then\n                      if Acts_As_Spec (D) then\n                         E := Defining_Entity (D);\n@@ -541,26 +602,44 @@ package body Sem_Ch7 is\n                         --  of accessing global entities.\n \n                         if Has_Pragma_Inline (E) then\n-                           return True;\n+                           if Outer\n+                             and then Check_Subprogram_Refs (D) = OK\n+                           then\n+                              Has_Referencer_Except_For_Subprograms := True;\n+                           else\n+                              return True;\n+                           end if;\n                         else\n                            Set_Is_Public (E, False);\n                         end if;\n \n                      else\n                         E := Corresponding_Spec (D);\n \n-                        if Present (E)\n-                          and then (Is_Generic_Unit (E)\n-                                     or else Has_Pragma_Inline (E)\n-                                     or else Is_Inlined (E))\n-                        then\n-                           return True;\n+                        if Present (E) then\n+\n+                           --  A generic subprogram body acts as a referencer\n+\n+                           if Is_Generic_Unit (E) then\n+                              return True;\n+                           end if;\n+\n+                           if Has_Pragma_Inline (E) or else Is_Inlined (E) then\n+                              if Outer\n+                                and then Check_Subprogram_Refs (D) = OK\n+                              then\n+                                 Has_Referencer_Except_For_Subprograms := True;\n+                              else\n+                                 return True;\n+                              end if;\n+                           end if;\n                         end if;\n                      end if;\n \n                   --  Processing for package bodies\n \n                   elsif K = N_Package_Body\n+                    and then not Has_Referencer_Except_For_Subprograms\n                     and then Present (Corresponding_Spec (D))\n                   then\n                      E := Corresponding_Spec (D);\n@@ -590,7 +669,9 @@ package body Sem_Ch7 is\n                   --  Processing for package specs, recurse into declarations.\n                   --  Again we skip this for the case of generic instances.\n \n-                  elsif K = N_Package_Declaration then\n+                  elsif K = N_Package_Declaration\n+                    and then not Has_Referencer_Except_For_Subprograms\n+                  then\n                      S := Specification (D);\n \n                      if not Is_Generic_Unit (Defining_Entity (S)) then\n@@ -617,6 +698,8 @@ package body Sem_Ch7 is\n                      E := Defining_Entity (D);\n \n                      if Outer\n+                       and then (not Has_Referencer_Except_For_Subprograms\n+                                  or else K = N_Subprogram_Declaration)\n                        and then not Is_Imported (E)\n                        and then not Is_Exported (E)\n                        and then No (Interface_Name (E))\n@@ -628,7 +711,7 @@ package body Sem_Ch7 is\n                   Prev (D);\n                end loop;\n \n-               return False;\n+               return Has_Referencer_Except_For_Subprograms;\n             end Has_Referencer;\n \n          --  Start of processing for Make_Non_Public_Where_Possible"}, {"sha": "1ea82773591de5a747d8596076e4d745d8da5f0a", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -2078,8 +2078,7 @@ package body Sem_Ch8 is\n          Analyze_Renamed_Character (N, New_S, Present (Rename_Spec));\n          return;\n \n-      elsif (not Is_Entity_Name (Nam)\n-              and then Nkind (Nam) /= N_Operator_Symbol)\n+      elsif not Is_Entity_Name (Nam)\n         or else not Is_Overloadable (Entity (Nam))\n       then\n          Error_Msg_N (\"expect valid subprogram name in renaming\", N);"}, {"sha": "2190b59bc468e34f4f9764f21c658e8a45769311", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -2290,8 +2290,7 @@ package body Sem_Res is\n                --  and also the entity pointer for the prefix.\n \n                elsif Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call)\n-                 and then (Is_Entity_Name (Name (N))\n-                            or else Nkind (Name (N)) = N_Operator_Symbol)\n+                 and then Is_Entity_Name (Name (N))\n                then\n                   Set_Etype  (Name (N), Expr_Type);\n                   Set_Entity (Name (N), Seen);"}, {"sha": "bc68f3801b3dd6fa9947c22ce6ab27cfb91f425d", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f2babd42c1b52ec313dec8af4eaa0386182d64/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=a3f2babd42c1b52ec313dec8af4eaa0386182d64", "patch": "@@ -482,8 +482,7 @@ package body Sem_Type is\n \n          elsif (Nkind (N) = N_Function_Call\n                  or else Nkind (N) = N_Procedure_Call_Statement)\n-           and then (Nkind (Name (N)) = N_Operator_Symbol\n-                      or else Is_Entity_Name (Name (N)))\n+           and then Is_Entity_Name (Name (N))\n          then\n             Add_Entry (Entity (Name (N)), Etype (N));\n \n@@ -1622,9 +1621,7 @@ package body Sem_Type is\n                   Arg1 := Left_Opnd  (N);\n                   Arg2 := Right_Opnd (N);\n \n-               elsif Is_Entity_Name (N)\n-                 or else Nkind (N) = N_Operator_Symbol\n-               then\n+               elsif Is_Entity_Name (N) then\n                   Arg1 := First_Entity (Entity (N));\n                   Arg2 := Next_Entity (Arg1);\n "}]}