{"sha": "e35ec8520bf2e4322618732f556d72590f24dc68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM1ZWM4NTIwYmYyZTQzMjI2MTg3MzJmNTU2ZDcyNTkwZjI0ZGM2OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T23:05:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T23:05:45Z"}, "message": "Changed Class * to Class in order to match NEXTSTEP and OpenStep runtime.\n\nChanged Class * to Class in order to match NEXTSTEP and OpenStep\nruntime.\n(objc_static_instances): New struct to record static instances of a certain\nclass.\n(objc_module): New tag STATICS to point to the table of objc_statics_instances.\n\nFrom-SVN: r9493", "tree": {"sha": "67636997533187cdea2ca7d841c8ee9e20f92a08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67636997533187cdea2ca7d841c8ee9e20f92a08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e35ec8520bf2e4322618732f556d72590f24dc68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35ec8520bf2e4322618732f556d72590f24dc68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35ec8520bf2e4322618732f556d72590f24dc68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35ec8520bf2e4322618732f556d72590f24dc68/comments", "author": null, "committer": null, "parents": [{"sha": "89f0bef317b8a5ee8ced03d91c794b113bcdf587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f0bef317b8a5ee8ced03d91c794b113bcdf587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89f0bef317b8a5ee8ced03d91c794b113bcdf587"}], "stats": {"total": 80, "additions": 47, "deletions": 33}, "files": [{"sha": "981350f98e4feec1b63912910d9a88fe933a5c16", "filename": "gcc/objc/objc-api.h", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35ec8520bf2e4322618732f556d72590f24dc68/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35ec8520bf2e4322618732f556d72590f24dc68/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=e35ec8520bf2e4322618732f556d72590f24dc68", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective-C Runtime API.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -97,12 +97,22 @@ typedef struct objc_symtab {\n                                                   compiled (defined) in the \n                                                   module. */\n   void      *defs[1];                           /* Variable array of pointers.\n-                                                  cls_def_cnt of type Class* \n+                                                  cls_def_cnt of type Class \n                                                   followed by cat_def_cnt of\n                                                   type Category_t. */\n } Symtab,   *Symtab_t;\n \n \n+/* For every class which happens to have statically allocated instances in\n+   this module, one OBJC_STATIC_INSTANCES is allocated by the compiler.\n+   INSTANCES is NULL terminated and points to all statically allocated\n+   instances of this class.  */\n+struct objc_static_instances\n+{\n+  char *class_name;\n+  id instances[0];\n+};\n+\n /*\n ** The compiler generates one of these structures for each module that\n ** composes the executable (eg main.m).  \n@@ -118,6 +128,10 @@ typedef struct objc_module {\n   const char* name;                             /* Name of the file where the \n                                                   module was generated.   The \n                                                   name includes the path. */\n+\n+  /* Pointer to a NULL terminated array of objc_static_instances.  */\n+  struct objc_static_instances **statics;\n+\n   Symtab_t    symtab;                           /* Pointer to the Symtab of\n                                                   the module.  The Symtab\n                                                   holds an array of pointers to \n@@ -203,12 +217,12 @@ struct objc_protocol_list {\n #define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n #define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n \n-/* The structure is of type MetaClass* */\n+/* The structure is of type MetaClass */\n #define _CLS_META 0x2L\n #define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n \n \n-/* The structure is of type Class* */\n+/* The structure is of type Class */\n #define _CLS_CLASS 0x1L\n #define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n \n@@ -268,7 +282,7 @@ typedef struct objc_category {\n typedef struct objc_super {\n   id      self;                           /* Id of the object sending\n                                                 the message. */\n-  Class* class;                              /* Object's super class. */\n+  Class class;                              /* Object's super class. */\n } Super, *Super_t;\n \n IMP objc_msg_lookup_super(Super_t super, SEL sel);\n@@ -283,25 +297,25 @@ retval_t objc_msg_sendv(id, SEL, arglist_t);\n ** This may e.g. try to load in the class using dynamic loading.\n ** The function is guaranteed to be passed a non-NULL name string.\n */\n-extern Class* (*_objc_lookup_class)(const char *name);\n+extern Class (*_objc_lookup_class)(const char *name);\n \n-extern id (*_objc_object_alloc)(Class* class);\n+extern id (*_objc_object_alloc)(Class class);\n \n extern id (*_objc_object_copy)(id object);\n \n extern id (*_objc_object_dispose)(id object);\n \n-Method_t class_get_class_method(MetaClass* class, SEL aSel);\n+Method_t class_get_class_method(MetaClass class, SEL aSel);\n \n-Method_t class_get_instance_method(Class* class, SEL aSel);\n+Method_t class_get_instance_method(Class class, SEL aSel);\n \n-Class* class_pose_as(Class* impostor, Class* superclass);\n+Class class_pose_as(Class impostor, Class superclass);\n \n-Class* objc_get_class(const char *name);\n+Class objc_get_class(const char *name);\n \n-Class* objc_lookup_class(const char *name);\n+Class objc_lookup_class(const char *name);\n \n-Class* objc_next_class(void **enum_state);\n+Class objc_next_class(void **enum_state);\n \n const char *sel_get_name(SEL selector);\n \n@@ -320,53 +334,53 @@ SEL sel_register_typed_name(const char *name, const char*type);\n \n BOOL sel_is_mapped (SEL aSel);\n \n-extern id class_create_instance(Class* class);\n+extern id class_create_instance(Class class);\n \n static inline const char *\n-class_get_class_name(Class* class)\n+class_get_class_name(Class class)\n {\n   return CLS_ISCLASS(class)?class->name:((class==Nil)?\"Nil\":0);\n }\n \n static inline long\n-class_get_instance_size(Class* class)\n+class_get_instance_size(Class class)\n {\n   return CLS_ISCLASS(class)?class->instance_size:0;\n }\n \n-static inline MetaClass*\n-class_get_meta_class(Class* class)\n+static inline MetaClass\n+class_get_meta_class(Class class)\n {\n   return CLS_ISCLASS(class)?class->class_pointer:Nil;\n }\n \n-static inline Class*\n-class_get_super_class(Class* class)\n+static inline Class\n+class_get_super_class(Class class)\n {\n   return CLS_ISCLASS(class)?class->super_class:Nil;\n }\n \n static inline int\n-class_get_version(Class* class)\n+class_get_version(Class class)\n {\n   return CLS_ISCLASS(class)?class->version:-1;\n }\n \n static inline BOOL\n-class_is_class(Class* class)\n+class_is_class(Class class)\n {\n   return CLS_ISCLASS(class);\n }\n \n static inline BOOL\n-class_is_meta_class(Class* class)\n+class_is_meta_class(Class class)\n {\n   return CLS_ISMETA(class);\n }\n \n \n static inline void\n-class_set_version(Class* class, long version)\n+class_set_version(Class class, long version)\n {\n   if (CLS_ISCLASS(class))\n     class->version = version;\n@@ -378,20 +392,20 @@ method_get_imp(Method_t method)\n   return (method!=METHOD_NULL)?method->method_imp:(IMP)0;\n }\n \n-IMP get_imp (Class* class, SEL sel);\n+IMP get_imp (Class class, SEL sel);\n \n id object_copy(id object);\n \n id object_dispose(id object);\n \n-static inline Class*\n+static inline Class\n object_get_class(id object)\n {\n   return ((object!=nil)\n \t  ? (CLS_ISCLASS(object->class_pointer)\n \t     ? object->class_pointer\n \t     : (CLS_ISMETA(object->class_pointer)\n-\t\t? (Class*)object\n+\t\t? (Class)object\n \t\t: Nil))\n \t  : Nil);\n }\n@@ -401,11 +415,11 @@ object_get_class_name(id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n                          ?object->class_pointer->name\n-                         :((Class*)object)->name)\n+                         :((Class)object)->name)\n                        :\"Nil\");\n }\n \n-static inline MetaClass*\n+static inline MetaClass\n object_get_meta_class(id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n@@ -416,22 +430,22 @@ object_get_meta_class(id object)\n                        :Nil);\n }\n \n-static inline Class*\n+static inline Class\n object_get_super_class\n (id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n                          ?object->class_pointer->super_class\n                          :(CLS_ISMETA(object->class_pointer)\n-                           ?((Class*)object)->super_class\n+                           ?((Class)object)->super_class\n                            :Nil))\n                        :Nil);\n }\n \n static inline BOOL\n object_is_class(id object)\n {\n-  return CLS_ISCLASS((Class*)object);\n+  return CLS_ISCLASS((Class)object);\n }\n \n static inline BOOL\n@@ -443,7 +457,7 @@ object_is_instance(id object)\n static inline BOOL\n object_is_meta_class(id object)\n {\n-  return CLS_ISMETA((Class*)object);\n+  return CLS_ISMETA((Class)object);\n }\n \n #endif /* not __objc_api_INCLUDE_GNU */"}]}