{"sha": "299c98578bda88c020a6d5b2c319c9e191a315d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk5Yzk4NTc4YmRhODhjMDIwYTZkNWIyYzMxOWM5ZTE5MWEzMTVkNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-11T11:47:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-08-11T11:51:59Z"}, "message": "expr: Optimize noop copies [PR96539]\n\nAt GIMPLE e.g. for __builtin_memmove we optimize away (to just the return\nvalue) noop copies where src == dest, but at the RTL we don't, and as the\ntestcase shows, in some cases such copies can appear only at the RTL level\ne.g. from trying to copy an aggregate by value argument to the same location\nas it already has.  If the block move is expanded e.g. piecewise, we\nactually manage to optimize it away, as the individual memory copies are\nseen as noop moves, but if the target optabs are used, often the sequences\nstay until final.\n\n2020-08-11  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/96539\n\t* expr.c (emit_block_move_hints): Don't copy anything if x and y\n\tare the same and neither is MEM_VOLATILE_P.\n\n\t* gcc.target/i386/pr96539.c: New test.", "tree": {"sha": "9a9d921e04e8d1facbb1c8bb31de1757883070af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a9d921e04e8d1facbb1c8bb31de1757883070af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/299c98578bda88c020a6d5b2c319c9e191a315d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299c98578bda88c020a6d5b2c319c9e191a315d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299c98578bda88c020a6d5b2c319c9e191a315d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299c98578bda88c020a6d5b2c319c9e191a315d4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b815e113c9aec397a86d7194f66455eb189cc7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b815e113c9aec397a86d7194f66455eb189cc7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b815e113c9aec397a86d7194f66455eb189cc7a"}], "stats": {"total": 22, "additions": 22, "deletions": 0}, "files": [{"sha": "2406f9039eabd7f0c5bd16124eadb486b460b5eb", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299c98578bda88c020a6d5b2c319c9e191a315d4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299c98578bda88c020a6d5b2c319c9e191a315d4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=299c98578bda88c020a6d5b2c319c9e191a315d4", "patch": "@@ -1637,6 +1637,12 @@ emit_block_move_hints (rtx x, rtx y, rtx size, enum block_op_methods method,\n   x = adjust_address (x, BLKmode, 0);\n   y = adjust_address (y, BLKmode, 0);\n \n+  /* If source and destination are the same, no need to copy anything.  */\n+  if (rtx_equal_p (x, y)\n+      && !MEM_VOLATILE_P (x)\n+      && !MEM_VOLATILE_P (y))\n+    return 0;\n+\n   /* Set MEM_SIZE as appropriate for this block copy.  The main place this\n      can be incorrect is coming from __builtin_memcpy.  */\n   poly_int64 const_size;"}, {"sha": "fc164f8b88985df2d4fbc7041bf3eba7ba297ee3", "filename": "gcc/testsuite/gcc.target/i386/pr96539.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299c98578bda88c020a6d5b2c319c9e191a315d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96539.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299c98578bda88c020a6d5b2c319c9e191a315d4/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96539.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr96539.c?ref=299c98578bda88c020a6d5b2c319c9e191a315d4", "patch": "@@ -0,0 +1,16 @@\n+/* PR rtl-optimization/96539 */\n+/* { dg-do compile } *\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { scan-assembler-not \"rep\\[^\\n\\r]\\*movs\" } } */\n+\n+struct A { int a, b, c, d, e, f; void *g, *h, *i, *j, *k, *l, *m; };\n+\n+int bar (int a);\n+int baz (int a, int b, int c, void *p, struct A s);\n+\n+int\n+foo (int a, int b, int c, void *p, struct A s)\n+{\n+  bar (a);\n+  return baz (a, b, c, p, s);\n+}"}]}