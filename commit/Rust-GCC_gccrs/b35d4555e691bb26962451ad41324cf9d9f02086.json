{"sha": "b35d4555e691bb26962451ad41324cf9d9f02086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1ZDQ1NTVlNjkxYmIyNjk2MjQ1MWFkNDEzMjRjZjlkOWYwMjA4Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-18T01:23:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-18T01:23:20Z"}, "message": "Turn on function-at-a-time processing.\n\n\t* cp-tree.h (doing_semantic_analysis_p): New macro.\n\t(SF_DEFAULT): Define to zero, not SF_EXPAND.\n\t(start_handler_parms): Change prototype.\n\t(expand_start_catch_block): Likewise.\n\t(expand_end_catch_block): Likewise.\n\t(expand_start_eh_spec): Likewise.\n\t(expand_end_eh_spec): Declare.\n\t(finish_handler_parms): Change prototype.\n\t(begin_catch_block): Declare.\n\t(finish_handler): Change prototype.\n\t(do_pushlevel): Declare.\n\t(do_poplevel): Likewise.\n\t* decl.c (pushlevel): Don't create\n\tbinding levels when not doing semantic analysis.\n\t(poplevel): Don't pop them.\n\t(pushdecl): Assert that we are never called when not doing\n\tsemantic analysis.\n\t(pushdecl_top_level): Use push_to_top_level.\n\t(make_label_decl): Don't fiddle with obstacks.  Make RTL For the\n\tlabel when expanding.\n\t(cp_finish_decl): Only inject for-scope variables when doing\n\tsemantic analysis.  Add comments.\n\t(start_handler_parms): Return the handler parm.\n\t(start_function): Reorganize.  Don't clear DECL_INITIAL if it is\n\talready set.  Reinitialize from saved function data if available.\n\tDon't pushlevel when not doing semantic analysis.\n\t(store_parm_decls): Only generate RTL when expanding.  Only\n\tpushdecl when doing semantic analysis.  Set\n\tcurrent_eh_spec_try_block if appropriate.\n\t(finish_function): Simplify.  Use do_pushlevel and do_poplevel.\n\tCombine common code.  Don't poplevel when not doing semantic\n\tanalysis.\n\t(push_cp_function_context): Don't expand functions without an\n\texplicit call to expand_body.\n\t(mark_lang_function): Make eh_spec_try_block and\n\tx_scope_stmt_stack.\n\t* except.c (expand_end_eh_spec): Don't\n\tdeclare.\n\t(process_start_catch_block): Likewise.\n\t(push_eh_cleanup): Use finish_decl_cleanup.\n\t(initialize_handler_parm): New function.\n\t(expand_start_catch_block): Use it.\n\t(expand_end_catch_block): Use tree-generation functions, not\n\tRTL-generation functions.\n\t(expand_start_eh_spec): Likewise.\n\t(expand_end_eh_spec): Likewise.\n\t(expand_exception_blocks): Simplify.\n\t(start_anon_func): Use do_pushlevel.\n\t(end_anon_func): Use do_poplvel.  Call expand_body for the\n\tfunction.\n\t* expr.c (do_case): Don't call define_case_label.\n\t* init.c (create_temporary_var): Set DECL_CONTEXT for local\n\tvariables.\n\t* method.c (emit_thunk): Call expand_body for the\n\tthunk.\n\t(sythesize_method): Likewise.\n\t* parse.y (handler_args): Give it ttype.\n\t(eat_saved_input): Call expand_body.\n\t(base_init): Use do_pushlevel.\n\t(pending_inline): Call expand_body.\n\t(handler): Adjust calls to finish_handler_parms and\n\tfinish_handler.\n\t(handler_args): Don't call expand_start_catch_block.  Return the\n\tcatch parameter.  * pt.c (tsubst_expr): Adjust HANDLER handling.\n\t* parse.c: Regenerated.\n\t* rtti.c (synthesize_tinfo_fn): Call finish_function.\n\t* semantics.c (do_pushlevel): Give it external linkage.  Build\n\tSCOPE_STMTs.\n\t(do_poplevel): Likewise.\n\t(finish_case_label): Call define_case_label when doing semantic\n\tanalysis.\n\t(finish_goto_stmt): Create RTL for labels.\n\t(finish_function_try_block): Set in_function_try_handler\n\tunconditionally.\n\t(finish_function_handler_sequence): Unset it.\n\t(finish_handler_parms): Use expand_start_catch_block even when\n\tbuilding a statement-tree.\n\t(begin_catch_block): New function.\n\t(finish_handler): Move a little RTL-generation logic here.\n\t(finish_decl_cleanup): Allow cleanups for empty declarations.\n\t(finish_named_return_value): Don't pushdecl when not doing\n\tsemantic analysis.\n\t(expand_stmt): Don't do semantic analysis for variable\n\tdeclarations.  Handle START_CATCH_STMT.  Call expand_label\n\tdirectly for a LABEL_STMT.  Tweak handling of GOTO_STMT.  Adjust\n\tHANDLERs.  Handle SCOPE_STMT, CTOR_INITIALIZER, and RETURN_INIT.\n\t(expand_body): Let expand_stmt handle CTOR_INITIALIZER,\n\tRETURN_INIT and function try blocks.\n\nFrom-SVN: r29490", "tree": {"sha": "b9dd570a763fea2069777a6a8736ee992107849d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9dd570a763fea2069777a6a8736ee992107849d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b35d4555e691bb26962451ad41324cf9d9f02086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35d4555e691bb26962451ad41324cf9d9f02086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b35d4555e691bb26962451ad41324cf9d9f02086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b35d4555e691bb26962451ad41324cf9d9f02086/comments", "author": null, "committer": null, "parents": [{"sha": "2c146a769fe2bf862a128c3370b1faa8507b8980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c146a769fe2bf862a128c3370b1faa8507b8980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c146a769fe2bf862a128c3370b1faa8507b8980"}], "stats": {"total": 2568, "additions": 1324, "deletions": 1244}, "files": [{"sha": "20fc2a35fc380e43666d8d73e94ed37abe1068da", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -1,5 +1,95 @@\n 1999-09-17  Mark Mitchell  <mark@codesourcery.com>\n \n+        Turn on function-at-a-time processing.  \n+\t* cp-tree.h (doing_semantic_analysis_p): New macro.\n+\t(SF_DEFAULT): Define to zero, not SF_EXPAND.\n+\t(start_handler_parms): Change prototype.\n+\t(expand_start_catch_block): Likewise.\n+\t(expand_end_catch_block): Likewise.\n+\t(expand_start_eh_spec): Likewise.\n+\t(expand_end_eh_spec): Declare.\n+\t(finish_handler_parms): Change prototype.\n+\t(begin_catch_block): Declare.\n+\t(finish_handler): Change prototype.\n+\t(do_pushlevel): Declare.\n+\t(do_poplevel): Likewise.  \n+\t* decl.c (pushlevel): Don't create\n+\tbinding levels when not doing semantic analysis.\n+\t(poplevel): Don't pop them.\n+\t(pushdecl): Assert that we are never called when not doing\n+\tsemantic analysis.\n+\t(pushdecl_top_level): Use push_to_top_level.\n+\t(make_label_decl): Don't fiddle with obstacks.  Make RTL For the\n+\tlabel when expanding.\n+\t(cp_finish_decl): Only inject for-scope variables when doing\n+\tsemantic analysis.  Add comments.\n+\t(start_handler_parms): Return the handler parm.\n+\t(start_function): Reorganize.  Don't clear DECL_INITIAL if it is\n+\talready set.  Reinitialize from saved function data if available.\n+\tDon't pushlevel when not doing semantic analysis.\n+\t(store_parm_decls): Only generate RTL when expanding.  Only\n+\tpushdecl when doing semantic analysis.  Set\n+\tcurrent_eh_spec_try_block if appropriate.\n+\t(finish_function): Simplify.  Use do_pushlevel and do_poplevel.\n+\tCombine common code.  Don't poplevel when not doing semantic\n+\tanalysis.\n+\t(push_cp_function_context): Don't expand functions without an\n+\texplicit call to expand_body.\n+\t(mark_lang_function): Make eh_spec_try_block and\n+\tx_scope_stmt_stack.  \n+\t* except.c (expand_end_eh_spec): Don't\n+\tdeclare.\n+\t(process_start_catch_block): Likewise.\n+\t(push_eh_cleanup): Use finish_decl_cleanup.\n+\t(initialize_handler_parm): New function.\n+\t(expand_start_catch_block): Use it.\n+\t(expand_end_catch_block): Use tree-generation functions, not\n+\tRTL-generation functions.\n+\t(expand_start_eh_spec): Likewise.\n+\t(expand_end_eh_spec): Likewise.\n+\t(expand_exception_blocks): Simplify.\n+\t(start_anon_func): Use do_pushlevel.\n+\t(end_anon_func): Use do_poplvel.  Call expand_body for the\n+\tfunction.  \n+\t* expr.c (do_case): Don't call define_case_label.  \n+\t* init.c (create_temporary_var): Set DECL_CONTEXT for local\n+\tvariables.  \n+\t* method.c (emit_thunk): Call expand_body for the\n+\tthunk.\n+\t(sythesize_method): Likewise.  \n+\t* parse.y (handler_args): Give it ttype.\n+\t(eat_saved_input): Call expand_body.\n+\t(base_init): Use do_pushlevel.\n+\t(pending_inline): Call expand_body.\n+\t(handler): Adjust calls to finish_handler_parms and\n+\tfinish_handler.\n+\t(handler_args): Don't call expand_start_catch_block.  Return the\n+\tcatch parameter.  * pt.c (tsubst_expr): Adjust HANDLER handling.\n+\t* parse.c: Regenerated.\n+\t* rtti.c (synthesize_tinfo_fn): Call finish_function.  \n+\t* semantics.c (do_pushlevel): Give it external linkage.  Build\n+\tSCOPE_STMTs.\n+\t(do_poplevel): Likewise.\n+\t(finish_case_label): Call define_case_label when doing semantic\n+\tanalysis.\n+\t(finish_goto_stmt): Create RTL for labels.\n+\t(finish_function_try_block): Set in_function_try_handler\n+\tunconditionally.\n+\t(finish_function_handler_sequence): Unset it.\n+\t(finish_handler_parms): Use expand_start_catch_block even when\n+\tbuilding a statement-tree.\n+\t(begin_catch_block): New function.\n+\t(finish_handler): Move a little RTL-generation logic here.\n+\t(finish_decl_cleanup): Allow cleanups for empty declarations.\n+\t(finish_named_return_value): Don't pushdecl when not doing\n+\tsemantic analysis.\n+\t(expand_stmt): Don't do semantic analysis for variable\n+\tdeclarations.  Handle START_CATCH_STMT.  Call expand_label\n+\tdirectly for a LABEL_STMT.  Tweak handling of GOTO_STMT.  Adjust\n+\tHANDLERs.  Handle SCOPE_STMT, CTOR_INITIALIZER, and RETURN_INIT.\n+\t(expand_body): Let expand_stmt handle CTOR_INITIALIZER,\n+\tRETURN_INIT and function try blocks.\n+\t\n \t* cp-tree.h (language_function): Add x_eh_spec_try_block.  Add\n \tx_scope_stmt_stack.  Add x_in_charge_parm.\n \t(current_eh_spec_try_block): New macro."}, {"sha": "a572582beeb16c9267ce0d570d4676cc929bef81", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -747,6 +747,12 @@ struct language_function\n \n #define expanding_p cp_function_chain->x_expanding_p\n \n+/* Non-zero if we are in the semantic analysis phase for the current\n+   function.  */\n+\n+#define doing_semantic_analysis_p() \\\n+  (!expanding_p || !current_function->x_whole_function_mode_p)\n+\n /* Non-zero if we should treat statements as full expressions.  In\n    particular, this variable is no-zero if at the end of a statement\n    we should destroy any temporaries created during that statement.\n@@ -3022,11 +3028,7 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \t\t\t\t   result of a using declaration.  */\n \n /* Used with start function.  */\n-#define SF_DEFAULT           SF_EXPAND\n-                                /* No flags.  Temporarily, this is\n-\t\t\t\t   SF_EXPAND.  Once we are fully\n-\t\t\t\t   function-at-a-time, this will be\n-\t\t\t\t   0.  */\n+#define SF_DEFAULT           0  /* No flags.  */\n #define SF_PRE_PARSED        1  /* The function declaration has\n \t\t\t\t   already been parsed.  */\n #define SF_INCLASS_INLINE    2  /* The function is an inline, defined\n@@ -3237,7 +3239,7 @@ extern void finish_decl\t\t\t\tPROTO((tree, tree, tree));\n extern void maybe_inject_for_scope_var          PROTO((tree));\n extern void initialize_local_var                PROTO((tree, tree, int));\n extern void expand_static_init\t\t\tPROTO((tree, tree));\n-extern void start_handler_parms                 PROTO((tree, tree));\n+extern tree start_handler_parms                 PROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n /* the grokdeclarator prototype is in decl.h */\n@@ -3389,10 +3391,11 @@ extern int cp_line_of\t\t\t\tPROTO((tree));\n \n /* in except.c */\n extern void init_exception_processing\t\tPROTO((void));\n-extern void expand_start_catch_block\t\tPROTO((tree));\n-extern void expand_end_catch_block\t\tPROTO((void));\n+extern tree expand_start_catch_block\t\tPROTO((tree));\n+extern void expand_end_catch_block\t\tPROTO((tree));\n extern void expand_builtin_throw\t\tPROTO((void));\n-extern void expand_start_eh_spec\t\tPROTO((void));\n+extern tree expand_start_eh_spec\t\tPROTO((void));\n+extern void expand_end_eh_spec\t\t        PROTO((tree, tree));\n extern void expand_exception_blocks\t\tPROTO((void));\n extern tree start_anon_func\t\t\tPROTO((void));\n extern void end_anon_func\t\t\tPROTO((void));\n@@ -3660,9 +3663,9 @@ extern void finish_function_try_block           PROTO((tree));\n extern void finish_function_handler_sequence    PROTO((tree));\n extern void finish_cleanup_try_block            PROTO((tree));\n extern tree begin_handler                       PROTO((void));\n-extern void start_handler_parms                 PROTO((tree, tree));\n-extern void finish_handler_parms                PROTO((tree));\n-extern void finish_handler                      PROTO((tree));\n+extern tree finish_handler_parms                PROTO((tree, tree));\n+extern void begin_catch_block                   PROTO((tree));\n+extern void finish_handler                      PROTO((tree, tree));\n extern void finish_cleanup                      PROTO((tree, tree));\n extern tree begin_compound_stmt                 PROTO((int));\n extern tree finish_compound_stmt                PROTO((int, tree));\n@@ -3713,6 +3716,8 @@ extern void expand_body                         PROTO((tree));\n extern void begin_stmt_tree                     PROTO((tree));\n extern void finish_stmt_tree                    PROTO((tree));\n extern void prep_stmt                           PROTO((tree));\n+extern void do_pushlevel                        PROTO((void));\n+extern tree do_poplevel                         PROTO((void));\n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n #define building_stmt_tree()\t\t\t\t\t  \\"}, {"sha": "b1563cf2f948f4978ac97ee0c1a2e94855c40095", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 221, "deletions": 224, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -822,10 +822,12 @@ void\n pushlevel (tag_transparent)\n      int tag_transparent;\n {\n-  register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n+  struct binding_level *newlevel;\n \n-  /* Reuse or create a struct for this binding level.  */\n+  if (current_function && !doing_semantic_analysis_p ())\n+    return;\n \n+  /* Reuse or create a struct for this binding level.  */\n #if defined(DEBUG_CP_BINDING_LEVELS)\n   if (0)\n #else /* !defined(DEBUG_CP_BINDING_LEVELS) */\n@@ -1185,18 +1187,25 @@ poplevel (keep, reverse, functionbody)\n      Put it into forward order, just for cleanliness.  */\n   tree decls;\n   int tmp = functionbody;\n-  int real_functionbody = current_binding_level->keep == 2\n-    ? ((functionbody = 0), tmp) : functionbody;\n-  tree tags = functionbody >= 0 ? current_binding_level->tags : 0;\n-  tree subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n+  int real_functionbody;\n+  tree tags;\n+  tree subblocks;\n   tree block = NULL_TREE;\n   tree decl;\n   int block_previously_created;\n   int leaving_for_scope;\n \n+  if (current_function && !doing_semantic_analysis_p ())\n+    return NULL_TREE;\n+\n   my_friendly_assert (current_binding_level->parm_flag != 2,\n \t\t      19990916);\n \n+  real_functionbody = (current_binding_level->keep == 2\n+\t\t       ? ((functionbody = 0), tmp) : functionbody);\n+  tags = functionbody >= 0 ? current_binding_level->tags : 0;\n+  subblocks = functionbody >= 0 ? current_binding_level->blocks : 0;\n+\n   my_friendly_assert (!current_binding_level->class_shadowed,\n \t\t      19990414);\n \n@@ -3631,8 +3640,16 @@ pushdecl (x)\n      tree x;\n {\n   register tree t;\n-  register tree name = DECL_ASSEMBLER_NAME (x);\n-  int need_new_binding = 1;\n+  register tree name;\n+  int need_new_binding;\n+\n+  /* We shouldn't be calling pushdecl when we're generating RTL for a\n+     function that we already did semantic analysis on previously.  */\n+  my_friendly_assert (!current_function || doing_semantic_analysis_p (),\n+\t\t      19990913);\n+\n+  name = DECL_ASSEMBLER_NAME (x);\n+  need_new_binding = 1;\n \n   if (DECL_TEMPLATE_PARM_P (x))\n     /* Template parameters have no context; they are not X::T even\n@@ -4119,10 +4136,9 @@ tree\n pushdecl_top_level (x)\n      tree x;\n {\n-  tree cur_namespace = current_namespace;\n-  current_namespace = global_namespace;\n+  push_to_top_level ();\n   x = pushdecl_namespace_level (x);\n-  current_namespace = cur_namespace;\n+  pop_from_top_level ();\n   return x;\n }\n \n@@ -4606,12 +4622,8 @@ make_label_decl (id, local_p)\n {\n   tree decl;\n \n-  if (building_stmt_tree ())\n-    push_permanent_obstack ();\n   decl = build_decl (LABEL_DECL, id, void_type_node);\n-  if (building_stmt_tree ())\n-    pop_obstacks ();\n-  else\n+  if (expanding_p)\n     /* Make sure every label has an rtx.  */\n     label_rtx (decl);\n \n@@ -7742,9 +7754,6 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL\n       || TREE_CODE (decl) == RESULT_DECL)\n     {\n-      /* ??? FIXME: What about nested classes?  */\n-      int toplev = toplevel_bindings_p ();\n-\n       if (TREE_CODE (decl) == VAR_DECL)\n \tmaybe_commonize_var (decl);\n \n@@ -7773,10 +7782,11 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t      || TYPE_NEEDS_DESTRUCTOR (type))\n \t    expand_static_init (decl, init);\n \t}\n-      else if (! toplev)\n+      else if (TREE_CODE (CP_DECL_CONTEXT (decl)) == FUNCTION_DECL)\n \t{\n \t  /* This is a local declaration.  */\n-\t  maybe_inject_for_scope_var (decl);\n+\t  if (doing_semantic_analysis_p ())\n+\t    maybe_inject_for_scope_var (decl);\n \t  /* Initialize the local variable.  But, if we're building a\n \t     statement-tree, we'll do the initialization when we\n \t     expand the tree.  */\n@@ -7787,8 +7797,11 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t    }\n \t  else\n \t    {\n+\t      /* If we're not building RTL, then we need to do so\n+\t\t now.  */\n \t      if (!building_stmt_tree ())\n \t\temit_local_var (decl);\n+\t      /* Initialize the variable.  */\n \t      initialize_local_var (decl, init, flags);\n \t      /* Clean up the variable.  */\n \t      destroy_local_var (decl);\n@@ -8043,7 +8056,7 @@ expand_static_init (decl, init)\n \n /* Finish the declaration of a catch-parameter.  */\n \n-void\n+tree\n start_handler_parms (declspecs, declarator)\n      tree declspecs;\n      tree declarator;\n@@ -8058,7 +8071,8 @@ start_handler_parms (declspecs, declarator)\n     }\n   else\n     decl = NULL_TREE;\n-  expand_start_catch_block (decl);\n+\n+  return decl;\n }\n \n \f\n@@ -12767,6 +12781,16 @@ start_function (declspecs, declarator, attrs, flags)\n \t    }\n \t}\n     }\n+  \n+  /* Sometimes we don't notice that a function is a static member, and\n+     build a METHOD_TYPE for it.  Fix that up now.  */\n+  if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1)\n+      && TREE_CODE (TREE_TYPE (decl1)) == METHOD_TYPE)\n+    {\n+      revert_static_member_fn (&decl1, NULL, NULL);\n+      last_function_parms = TREE_CHAIN (last_function_parms);\n+      ctype = NULL_TREE;\n+    }\n \n   /* Warn if function was previously implicitly declared\n      (but not if we warned then).  */\n@@ -12798,7 +12822,8 @@ start_function (declspecs, declarator, attrs, flags)\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n-  DECL_INITIAL (decl1) = error_mark_node;\n+  if (!DECL_INITIAL (decl1))\n+    DECL_INITIAL (decl1) = error_mark_node;\n \n #ifdef SET_DEFAULT_DECL_ATTRIBUTES\n   SET_DEFAULT_DECL_ATTRIBUTES (decl1, attrs);\n@@ -12892,6 +12917,48 @@ start_function (declspecs, declarator, attrs, flags)\n   current_function_decl = decl1;\n   current_function->decl = decl1;\n \n+  /* Initialize the per-function data.  */\n+  if (!DECL_PENDING_INLINE_P (decl1) && DECL_SAVED_FUNCTION_DATA (decl1))\n+    {\n+      /* If we already parsed this function, and we're just expanding it\n+\t now, restore saved state.  */\n+      struct binding_level *bl = current_binding_level;\n+      *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (decl1);\n+      current_binding_level = bl;\n+\n+      /* This function has not assigned to `this' yet.  */\n+      current_function_assigns_this = 0;\n+      current_function_just_assigned_this = 0;\n+\n+      /* This function is being processed in whole-function mode; we\n+\t already did semantic analysis.  */\n+      current_function->x_whole_function_mode_p = 1;\n+\n+      /* We don't need the saved data anymore.  */\n+      free (DECL_SAVED_FUNCTION_DATA (decl1));\n+      DECL_SAVED_FUNCTION_DATA (decl1) = NULL;\n+    }\n+  else if (ctype && !doing_friend && !DECL_STATIC_FUNCTION_P (decl1))\n+    {\n+      /* We know that this was set up by `grokclassfn'.  We do not\n+\t wait until `store_parm_decls', since evil parse errors may\n+\t never get us to that point.  Here we keep the consistency\n+\t between `current_class_type' and `current_class_ptr'.  */\n+      tree t = DECL_ARGUMENTS (decl1);\n+\t      \n+      my_friendly_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL, \n+\t\t\t  162);\n+      my_friendly_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE,\n+\t\t\t  19990811);\n+\t  \n+      cp_function_chain->x_current_class_ref \n+\t= build_indirect_ref (t, NULL_PTR);\n+      cp_function_chain->x_current_class_ptr = t;\n+\n+      if (DECL_DESTRUCTOR_P (decl1))\n+\tcurrent_in_charge_parm = TREE_CHAIN (t);\n+    }\n+\n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n       tree ctx = hack_decl_function_context (decl1);\n@@ -12957,62 +13024,12 @@ start_function (declspecs, declarator, attrs, flags)\n \tDECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n \n-  if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n+  if (doing_semantic_analysis_p ())\n     {\n-      if (TREE_CODE (fntype) == METHOD_TYPE)\n-\tTREE_TYPE (decl1) = fntype\n-\t  = build_function_type (TREE_TYPE (fntype),\n-\t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n-      current_function_parms = TREE_CHAIN (current_function_parms);\n-      DECL_ARGUMENTS (decl1) = current_function_parms;\n-      ctype = NULL_TREE;\n-    }\n-\n-  my_friendly_assert (current_class_ptr == NULL_TREE, 19990908);\n-  my_friendly_assert (current_class_ref == NULL_TREE, 19990908);\n-  if (ctype)\n-    {\n-      /* If we're compiling a friend function, neither of the variables\n-\t current_class_ptr nor current_class_type will have values.  */\n-      if (! doing_friend)\n-\t{\n-\t  /* We know that this was set up by `grokclassfn'.\n-\t     We do not wait until `store_parm_decls', since evil\n-\t     parse errors may never get us to that point.  Here\n-\t     we keep the consistency between `current_class_type'\n-\t     and `current_class_ptr'.  */\n-\t  tree t = current_function_parms;\n-\t  int i;\n-\t      \n-\t  my_friendly_assert (t != NULL_TREE\n-\t\t\t      && TREE_CODE (t) == PARM_DECL, 162);\n-\t  my_friendly_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE,\n-\t\t\t      19990811);\n-\t  \n-\t  if (! hack_decl_function_context (decl1))\n-\t    temporary_allocation ();\n-\t  i = suspend_momentary ();\n-\t  \n-\t  /* Normally, build_indirect_ref returns current_class_ref\n-\t     whenever current_class_ptr is dereferenced.  This time,\n-\t     however, we want it to *create* current_class_ref, so we\n-\t     temporarily clear current_class_ptr to fool it.  */\n-\t  cp_function_chain->x_current_class_ref \n-\t    = build_indirect_ref (t, NULL_PTR);\n-\t  cp_function_chain->x_current_class_ptr = t;\n-\t  \n-\t  if (DECL_DESTRUCTOR_P (decl1))\n-\t    current_in_charge_parm = TREE_CHAIN (t);\n-\n-\t  resume_momentary (i);\n-\t  if (! hack_decl_function_context (decl1))\n-\t    end_temporary_allocation ();\n-\t}\n+      pushlevel (0);\n+      current_binding_level->parm_flag = 1;\n     }\n \n-  pushlevel (0);\n-  current_binding_level->parm_flag = 1;\n-\n   if (attrs)\n     cplus_decl_attributes (decl1, NULL_TREE, attrs);\n   \n@@ -13057,16 +13074,9 @@ start_function (declspecs, declarator, attrs, flags)\n \n   if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (decl1))\n       && DECL_LANGUAGE (decl1) == lang_cplusplus)\n-    {\n-      dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-      ctor_label = NULL_TREE;\n-    }\n-  else\n-    {\n-      dtor_label = NULL_TREE;\n-      if (DECL_CONSTRUCTOR_P (decl1))\n-\tctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-    }\n+    dtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+  else if (DECL_CONSTRUCTOR_P (decl1))\n+    ctor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n   return 1;\n }\n@@ -13096,9 +13106,6 @@ store_parm_decls ()\n   int parms_have_cleanups = 0;\n   tree cleanups = NULL_TREE;\n \n-  /* This is either a chain of PARM_DECLs (when a prototype is used).  */\n-  tree specparms = current_function_parms;\n-\n   /* This is a list of types declared among parms in a prototype.  */\n   tree parmtags = current_function_parm_tags;\n \n@@ -13107,39 +13114,48 @@ store_parm_decls ()\n      then CONST_DECLs for foo and bar are put here.  */\n   tree nonparms = NULL_TREE;\n \n-  if (toplevel_bindings_p ())\n-    fatal (\"parse errors have confused me too much\");\n-\n   /* Create a binding level for the parms.  */\n-  expand_start_bindings (0);\n+  if (!building_stmt_tree ())\n+    expand_start_bindings (2);\n \n-  if (specparms != NULL_TREE)\n+  if (current_function_parms)\n     {\n       /* This case is when the function was defined with an ANSI prototype.\n \t The parms already have decls, so we need not do anything here\n \t except record them as in effect\n \t and complain if any redundant old-style parm decls were written.  */\n \n-      register tree next;\n+      tree specparms = current_function_parms;\n+      tree next;\n+\n+      if (doing_semantic_analysis_p ())\n+\t{\n+\t  /* Must clear this because it might contain TYPE_DECLs declared\n+\t     at class level.  */\n+\t  storedecls (NULL_TREE);\n \n-      /* Must clear this because it might contain TYPE_DECLs declared\n-\t at class level.  */\n-      storedecls (NULL_TREE);\n+\t  /* If we're doing semantic analysis, then we'll call pushdecl\n+\t     for each of these.  We must do them in reverse order so that\n+\t     they end in the correct forward order.  */\n+\t  specparms = nreverse (specparms);\n+\t}\n \n-      for (parm = nreverse (specparms); parm; parm = next)\n+      for (parm = specparms; parm; parm = next)\n \t{\n \t  next = TREE_CHAIN (parm);\n \t  if (TREE_CODE (parm) == PARM_DECL)\n \t    {\n \t      tree cleanup;\n-\t      if (DECL_NAME (parm) == NULL_TREE)\n+\t      \n+\t      if (doing_semantic_analysis_p ())\n \t\t{\n-\t\t  pushdecl (parm);\n+\t\t  if (DECL_NAME (parm) == NULL_TREE\n+\t\t      || TREE_CODE (TREE_TYPE (parm)) != VOID_TYPE)\n+\t\t    pushdecl (parm);\n+\t\t  else\n+\t\t    cp_error (\"parameter `%D' declared void\", parm);\n \t\t}\n-\t      else if (TREE_CODE (TREE_TYPE (parm)) == VOID_TYPE)\n-\t\tcp_error (\"parameter `%D' declared void\", parm);\n-\t      else\n-\t\tpushdecl (parm);\n+\n \t      if (! building_stmt_tree ()\n \t\t  && (cleanup = maybe_build_cleanup (parm), cleanup))\n \t\t{\n@@ -13159,12 +13175,17 @@ store_parm_decls ()\n \t    }\n \t}\n \n-      /* Get the decls in their original chain order\n-\t and record in the function.  This is all and only the\n-\t PARM_DECLs that were pushed into scope by the loop above.  */\n-      DECL_ARGUMENTS (fndecl) = getdecls ();\n+      if (doing_semantic_analysis_p ())\n+\t{\n+\t  /* Get the decls in their original chain order\n+\t     and record in the function.  This is all and only the\n+\t     PARM_DECLs that were pushed into scope by the loop above.  */\n+\t  DECL_ARGUMENTS (fndecl) = getdecls ();\n+\t  storetags (chainon (parmtags, gettags ()));\n \n-      storetags (chainon (parmtags, gettags ()));\n+\t  /* We built up the cleanups in reversed order.  */\n+\t  cleanups = nreverse (cleanups);\n+\t}\n     }\n   else\n     DECL_ARGUMENTS (fndecl) = NULL_TREE;\n@@ -13173,8 +13194,8 @@ store_parm_decls ()\n      as the decl-chain of the current lexical scope.\n      Put the enumerators in as well, at the front so that\n      DECL_ARGUMENTS is not modified.  */\n-\n-  storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n+  if (doing_semantic_analysis_p ())\n+    storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n \n   /* Initialize the RTL code for the function.  */\n   DECL_SAVED_INSNS (fndecl) = 0;\n@@ -13192,17 +13213,15 @@ store_parm_decls ()\n      cleanups.  We cannot do this before, since expand_decl_cleanup\n      should not be called before the parm can be used.  */\n   if (cleanups && !building_stmt_tree ())\n-    {\n-      for (cleanups = nreverse (cleanups); \n-\t   cleanups; \n-\t   cleanups = TREE_CHAIN (cleanups))\n-\t{\n-\t  if (! expand_decl_cleanup (TREE_PURPOSE (cleanups), \n-\t\t\t\t     TREE_VALUE (cleanups)))\n-\t    cp_error (\"parser lost in parsing declaration of `%D'\",\n-\t\t      TREE_PURPOSE (cleanups));\n-\t}\n-    }\n+    while (cleanups)\n+      {\n+\tif (! expand_decl_cleanup (TREE_PURPOSE (cleanups), \n+\t\t\t\t   TREE_VALUE (cleanups)))\n+\t  cp_error (\"parser lost in parsing declaration of `%D'\",\n+\t\t    TREE_PURPOSE (cleanups));\n+\t\n+\tcleanups = TREE_CHAIN (cleanups);\n+      }\n \n   /* Create a binding contour which can be used to catch\n      cleanup-generated temporaries.  Also, if the return value needs or\n@@ -13211,15 +13230,14 @@ store_parm_decls ()\n     {\n       pushlevel (0);\n       if (!building_stmt_tree ())\n-\texpand_start_bindings (0);\n+\texpand_start_bindings (2);\n     }\n \n-  if (! building_stmt_tree () && flag_exceptions)\n-    {\n-      /* Do the starting of the exception specifications, if we have any.  */\n-      if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-\texpand_start_eh_spec ();\n-    }\n+  /* Do the starting of the exception specifications, if we have any.  */\n+  if (flag_exceptions && !processing_template_decl \n+      && building_stmt_tree () \n+      && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n+    current_eh_spec_try_block = expand_start_eh_spec ();\n \n   last_parm_cleanup_insn = get_last_insn ();\n   last_dtor_insn = get_last_insn ();\n@@ -13306,7 +13324,6 @@ finish_function (lineno, flags)\n   rtx fn_last_parm_insn, insns;\n   /* Label to use if this function is supposed to return a value.  */\n   tree no_return_label = NULL_TREE;\n-  tree decls = NULL_TREE;\n   int call_poplevel = (flags & 1) != 0;\n   int inclass_inline = (flags & 2) != 0;\n   int expand_p;\n@@ -13334,20 +13351,14 @@ finish_function (lineno, flags)\n   if (building_stmt_tree ())\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl) && call_poplevel)\n-\t{\n-\t  decls = getdecls ();\n-\t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n-\t  poplevel (decls != NULL_TREE, 0, 0);\n-\t}\n+\tdo_poplevel ();\n \n-      /* Because we do not call expand_function_end, we won't call\n-\t expand_end_bindings to match the call to\n-\t expand_start_bindings we did in store_parm_decls.  Therefore,\n-\t we explicitly call expand_end_bindings here.  However, we\n-\t really shouldn't be calling expand_start_bindings at all when\n-\t building_stmt_tree; it's conceptually an RTL-generation\n-\t function, rather than a front-end function.  */\n-      expand_end_bindings (0, 0, 0);\n+      /* Finish dealing with exception specifiers.  */\n+      if (flag_exceptions && !processing_template_decl\n+\t  && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n+\texpand_end_eh_spec (TYPE_RAISES_EXCEPTIONS \n+\t\t\t    (TREE_TYPE (current_function_decl)),\n+\t\t\t    current_eh_spec_try_block);\n     }\n   else\n     {\n@@ -13401,8 +13412,7 @@ finish_function (lineno, flags)\n \n \t  /* These initializations might go inline.  Protect\n \t     the binding level of the parms.  */\n-\t  pushlevel (0);\n-\t  expand_start_bindings (0);\n+\t  do_pushlevel ();\n \n \t  if (current_function_assigns_this)\n \t    {\n@@ -13511,8 +13521,7 @@ finish_function (lineno, flags)\n \t    }\n \n \t  /* End of destructor.  */\n-\t  expand_end_bindings (NULL_TREE, getdecls () != NULL_TREE, 0);\n-\t  poplevel (getdecls () != NULL_TREE, 0, 0);\n+\t  do_poplevel ();\n \n \t  /* Back to the top of destructor.  */\n \t  /* Don't execute destructor code if `this' is NULL.  */\n@@ -13560,89 +13569,67 @@ finish_function (lineno, flags)\n \t  if (! ok_to_optimize_dtor)\n \t    expand_end_cond ();\n \t}\n-      else if (current_function_assigns_this)\n+      else if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n-\t  /* Does not need to call emit_base_init, because\n-\t     that is done (if needed) just after assignment to this\n-\t     is seen.  */\n-\n-\t  if (DECL_CONSTRUCTOR_P (current_function_decl))\n+\t  /* If the current function assigns to `this', then code to\n+\t     initialize members and base-classes will be generated\n+\t     directly after the assignment.  */\n+\t  if (!current_function_assigns_this)\n \t    {\n-\t      end_protect_partials ();\n-\t      expand_label (ctor_label);\n-\t      ctor_label = NULL_TREE;\n+\t      start_sequence ();\n \n-\t      if (call_poplevel)\n+\t      if (flag_this_is_variable > 0)\n \t\t{\n-\t\t  decls = getdecls ();\n-\t\t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n-\t\t  poplevel (decls != NULL_TREE, 0, 0);\n+\t\t  /* Allow constructor for a type to get a new instance of\n+\t\t     the object using `build_new'.  */\n+\t\t  tree cond = NULL_TREE, thenclause = NULL_TREE;\n+\t\t  tree abstract_virtuals \n+\t\t    = CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type);\n+\t\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = NULL_TREE;\n+\n+\t\t  cond = build_binary_op (EQ_EXPR,\n+\t\t\t\t\t  current_class_ptr, integer_zero_node);\n+\n+\t\t  expand_start_cond (cond, 0);\n+\n+\t\t  thenclause \n+\t\t    = build_modify_expr (current_class_ptr, NOP_EXPR,\n+\t\t\t\t\t build_new (NULL_TREE,\n+\t\t\t\t\t\t    current_class_type,\n+\n+\t\t\t\t\t\t    void_type_node, 0));\n+\t\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) \n+\t\t    = abstract_virtuals;\n+\t\t  expand_expr_stmt (thenclause);\n+\t\t  expand_end_cond ();\n \t\t}\n-\t      /* c_expand_return knows to return 'this' from a constructor.  */\n-\t      c_expand_return (NULL_TREE);\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (DECL_RESULT (current_function_decl))) != VOID_TYPE\n-\t\t   && return_label != NULL_RTX)\n-\t    no_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-\t  current_function_assigns_this = 0;\n-\t  current_function_just_assigned_this = 0;\n-\t  base_init_expr = NULL_TREE;\n-\t}\n-      else if (DECL_CONSTRUCTOR_P (fndecl))\n-\t{\n-\t  tree cond = NULL_TREE, thenclause = NULL_TREE;\n-\t  /* Allow constructor for a type to get a new instance of the object\n-\t     using `build_new'.  */\n-\t  tree abstract_virtuals = CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type);\n-\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = NULL_TREE;\n \n-\t  if (flag_this_is_variable > 0)\n-\t    {\n-\t      cond = build_binary_op (EQ_EXPR,\n-\t\t\t\t      current_class_ptr, integer_zero_node);\n-\t      thenclause = build_modify_expr (current_class_ptr, NOP_EXPR,\n-\t\t\t\t\t      build_new (NULL_TREE, current_class_type, void_type_node, 0));\n-\t    }\n-\n-\t  CLASSTYPE_ABSTRACT_VIRTUALS (current_class_type) = abstract_virtuals;\n+\t      /* Emit insns from `emit_base_init' which sets up\n+\t\t virtual function table pointer(s).  Don't do this for\n+\t\t a function which assigns to `this' as we will emit\n+\t\t the appropriate code right after the assignment.  */\n+\t      if (!current_function_assigns_this && base_init_expr)\n+\t\t{\n+\t\t  expand_expr_stmt (base_init_expr);\n+\t\t  base_init_expr = NULL_TREE;\n+\t\t}\n \n-\t  start_sequence ();\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n \n-\t  if (flag_this_is_variable > 0)\n-\t    {\n-\t      expand_start_cond (cond, 0);\n-\t      expand_expr_stmt (thenclause);\n-\t      expand_end_cond ();\n+\t      emit_insns_after (insns, last_parm_cleanup_insn);\n \t    }\n \n-\t  /* Emit insns from `emit_base_init' which sets up virtual\n-\t     function table pointer(s).  */\n-\t  if (base_init_expr)\n-\t    {\n-\t      expand_expr_stmt (base_init_expr);\n-\t      base_init_expr = NULL_TREE;\n-\t    }\n-\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\n-\t  /* This is where the body of the constructor begins.  */\n-\n-\t  emit_insns_after (insns, last_parm_cleanup_insn);\n-\n+\t  /* This is where the body of the constructor begins.  All\n+\t     subobjects have been fully constructed at this point.  */\n \t  end_protect_partials ();\n \n \t  /* This is where the body of the constructor ends.  */\n \t  expand_label (ctor_label);\n \t  ctor_label = NULL_TREE;\n \n \t  if (call_poplevel)\n-\t    {\n-\t      decls = getdecls ();\n-\t      expand_end_bindings (decls, decls != NULL_TREE, 0);\n-\t      poplevel (decls != NULL_TREE, 1, 0);\n-\t    }\n+\t    do_poplevel ();\n \n \t  /* c_expand_return knows to return 'this' from a constructor.  */\n \t  c_expand_return (NULL_TREE);\n@@ -13660,8 +13647,13 @@ finish_function (lineno, flags)\n #endif\n \t}\n       else if (return_label != NULL_RTX\n-\t       && current_function_return_value == NULL_TREE\n-\t       && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n+\t       && ((flag_this_is_variable <= 0\n+\t\t    && current_function_return_value == NULL_TREE\n+\t\t    && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n+\t\t   || (flag_this_is_variable > 0\n+\t\t       && (TREE_CODE (TREE_TYPE (DECL_RESULT\n+\t\t\t\t\t\t (current_function_decl)))\n+\t\t\t   == VOID_TYPE))))\n \tno_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n       if (flag_exceptions)\n@@ -13743,9 +13735,12 @@ finish_function (lineno, flags)\n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n      this function's blocks.  */\n-  if (current_binding_level->parm_flag != 1)\n-    my_friendly_abort (122);\n-  poplevel (1, 0, 1);\n+  if (doing_semantic_analysis_p ())\n+    {\n+      if (current_binding_level->parm_flag != 1)\n+\tmy_friendly_abort (122);\n+      poplevel (1, 0, 1);\n+    }\n \n   /* Remember that we were in class scope.  */\n   if (current_class_name)\n@@ -13887,7 +13882,7 @@ finish_function (lineno, flags)\n   if (! nested)\n     permanent_allocation (1);\n \n-  if (DECL_SAVED_INSNS (fndecl) == 0)\n+  if (!DECL_SAVED_INSNS (fndecl) && !DECL_SAVED_FUNCTION_DATA (fndecl))\n     {\n       tree t;\n \n@@ -14314,9 +14309,9 @@ push_cp_function_context (f)\n        xcalloc (1, sizeof (struct language_function)));\n   f->language = p;\n \n-  /* For now, we always assume we're expanding all the way to RTL\n-     unless we're explicitly doing otherwise.  */\n-  expanding_p = 1;\n+  /* It takes an explicit call to expand_body to generate RTL for a\n+     function.  */\n+  expanding_p = 0;\n \n   /* Whenever we start a new function, we destroy temporaries in the\n      usual way.  */\n@@ -14353,6 +14348,8 @@ mark_lang_function (p)\n   ggc_mark_tree (p->x_current_class_ref);\n   ggc_mark_tree (p->x_last_tree);\n   ggc_mark_tree (p->x_last_expr_type);\n+  ggc_mark_tree (p->x_eh_spec_try_block);\n+  ggc_mark_tree (p->x_scope_stmt_stack);\n \n   ggc_mark_rtx (p->x_last_dtor_insn);\n   ggc_mark_rtx (p->x_last_parm_cleanup_insn);"}, {"sha": "9bfc7a272609c4b7601b11eae2d1f391af54a69e", "filename": "gcc/cp/except.c", "status": "modified", "additions": 93, "deletions": 153, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -39,7 +39,6 @@ Boston, MA 02111-1307, USA.  */\n static void push_eh_cleanup PROTO((void));\n static tree build_eh_type_type PROTO((tree));\n static tree build_eh_type PROTO((tree));\n-static void expand_end_eh_spec PROTO((tree));\n static tree call_eh_info PROTO((void));\n static void push_eh_info PROTO((void));\n static tree get_eh_info PROTO((void));\n@@ -50,11 +49,11 @@ static tree get_eh_caught PROTO((void));\n static tree get_eh_handlers PROTO((void));\n #endif\n static tree do_pop_exception PROTO((void));\n-static void process_start_catch_block PROTO((tree));\n static tree build_eh_type_type_ref PROTO((tree));\n static tree build_terminate_handler PROTO((void));\n static tree alloc_eh_object PROTO((tree));\n static int complete_ptr_ref_or_void_ptr_p PROTO((tree, tree));\n+static void initialize_handler_parm PROTO((tree));\n \n #if 0\n /* This is the startup, and finish stuff per exception table.  */\n@@ -483,7 +482,7 @@ push_eh_cleanup ()\n \n   yes = suspend_momentary ();\n   /* All cleanups must last longer than normal.  */\n-  expand_decl_cleanup (NULL_TREE, do_pop_exception ());\n+  finish_decl_cleanup (NULL_TREE, do_pop_exception ());\n   resume_momentary (yes);\n }\n \n@@ -499,131 +498,96 @@ build_terminate_handler ()\n   return term;\n }\n \n-/* Call this to start a catch block. Typename is the typename, and identifier\n-   is the variable to place the object in or NULL if the variable doesn't\n-   matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n-   everything.  In that case we don't need to do any type checking.\n-   (ie: it ends up as the \"else\" clause rather than an \"else if\" clause) */\n-\n-void\n-expand_start_catch_block (decl)\n-     tree decl;\n-{\n-  if (building_stmt_tree ())\n-    {\n-      if (decl)\n-\t{\n- \t  /* We must ensure that DECL_CONTEXT is set up before we call\n- \t     push_template_decl; that code depends on DECL_CONTEXT\n- \t     being set correctly.  */\n- \t  DECL_CONTEXT (decl) = current_function_decl;\n-\t  if (processing_template_decl)\n-\t    decl = push_template_decl (decl);\n-\t  pushdecl (decl);\n-\t  add_decl_stmt (decl);\n-\t}\n-      return;\n-    }\n-\n-  if (! doing_eh (1))\n-    return;\n-\n-  process_start_catch_block (decl);\n-}\n-\n-/* This function performs the expand_start_catch_block functionality for \n-   exceptions implemented in the new style. __throw determines whether\n-   a handler needs to be called or not, so the handler itself has to do\n-   nothing additional. */\n+/* Initialize the catch parameter DECL.  */\n \n static void \n-process_start_catch_block (decl)\n+initialize_handler_parm (decl)\n      tree decl;\n {\n+  tree exp;\n   tree init;\n+  tree init_type;\n \n-  /* Create a binding level for the eh_info and the exception object\n-     cleanup.  */\n-  pushlevel (0);\n-  expand_start_bindings (0);\n-\n-  if (decl && !complete_ptr_ref_or_void_ptr_p (TREE_TYPE (decl), NULL_TREE))\n-    decl = NULL_TREE;\n-\n-  if (decl)\n-    start_catch_handler (build_eh_type_type_ref (TREE_TYPE (decl)));\n-  else\n-    start_catch_handler (CATCH_ALL_TYPE);\n+  /* Make sure we mark the catch param as used, otherwise we'll get a\n+     warning about an unused ((anonymous)).  */\n+  TREE_USED (decl) = 1;\n \n-  emit_line_note (input_filename, lineno);\n+  /* Figure out the type that the initializer is.  */\n+  init_type = TREE_TYPE (decl);\n+  if (TREE_CODE (init_type) != REFERENCE_TYPE\n+      && TREE_CODE (init_type) != POINTER_TYPE)\n+    init_type = build_reference_type (init_type);\n \n-  push_eh_info ();\n+  exp = get_eh_value ();\n \n-  if (decl)\n-    {\n-      tree exp;\n-      tree init_type;\n+  /* Since pointers are passed by value, initialize a reference to\n+     pointer catch parm with the address of the value slot.  */ \n+  if (TREE_CODE (init_type) == REFERENCE_TYPE \n+      && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)\n+    exp = build_unary_op (ADDR_EXPR, exp, 1);\n \n-      /* Make sure we mark the catch param as used, otherwise we'll get\n-\t a warning about an unused ((anonymous)).  */\n-      TREE_USED (decl) = 1;\n+  exp = ocp_convert (init_type , exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n \n-      /* Figure out the type that the initializer is.  */\n-      init_type = TREE_TYPE (decl);\n-      if (TREE_CODE (init_type) != REFERENCE_TYPE\n-\t  && TREE_CODE (init_type) != POINTER_TYPE)\n-\tinit_type = build_reference_type (init_type);\n+  init = convert_from_reference (exp);\n \n-      exp = get_eh_value ();\n+  /* If the constructor for the catch parm exits via an exception, we\n+     must call terminate.  See eh23.C.  */\n+  if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+    {\n+      /* Generate the copy constructor call directly so we can wrap it.\n+\t See also expand_default_init.  */\n+      init = ocp_convert (TREE_TYPE (decl), init,\n+\t\t\t  CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+      init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n+\t\t    build_terminate_handler ());\n+    }\n \n-      /* Since pointers are passed by value, initialize a reference to\n-\t pointer catch parm with the address of the value slot.  */\n-      if (TREE_CODE (init_type) == REFERENCE_TYPE\n-\t  && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)\n-\texp = build_unary_op (ADDR_EXPR, exp, 1);\n+  /* Let `cp_finish_decl' know that this initializer is ok.  */\n+  DECL_INITIAL (decl) = error_mark_node;\n+  decl = pushdecl (decl);\n \n-      exp = ocp_convert (init_type , exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+  start_decl_1 (decl);\n+  cp_finish_decl (decl, init, NULL_TREE, 0,\n+\t\t  LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n+}\n \n-      push_eh_cleanup ();\n+/* Call this to start a catch block.  DECL is the catch parameter.  */\n \n-      /* Create a binding level for the parm.  */\n-      pushlevel (0);\n-      expand_start_bindings (0);\n+tree\n+expand_start_catch_block (decl)\n+     tree decl;\n+{\n+  tree compound_stmt_1;\n+  tree compound_stmt_2;\n+  tree type;\n \n-      init = convert_from_reference (exp);\n+  if (! doing_eh (1))\n+    return NULL_TREE;\n \n-      /* If the constructor for the catch parm exits via an exception, we\n-         must call terminate.  See eh23.C.  */\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n-\t{\n-\t  /* Generate the copy constructor call directly so we can wrap it.\n-\t     See also expand_default_init.  */\n-\t  init = ocp_convert (TREE_TYPE (decl), init,\n-\t\t\t      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n-\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n-\t\t\tbuild_terminate_handler ());\n-\t}\n+  /* Make sure this declaration is reasonable.  */\n+  if (decl && !complete_ptr_ref_or_void_ptr_p (TREE_TYPE (decl), NULL_TREE))\n+    decl = NULL_TREE;\n \n-      /* Let `cp_finish_decl' know that this initializer is ok.  */\n-      DECL_INITIAL (decl) = init;\n-      decl = pushdecl (decl);\n+  /* Create a binding level for the eh_info and the exception object\n+     cleanup.  */\n+  compound_stmt_1 = begin_compound_stmt (/*has_no_scope=*/0);\n \n-      start_decl_1 (decl);\n-      cp_finish_decl (decl, init, NULL_TREE, 0,\n-\t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n-    }\n+  if (decl)\n+    type = build_eh_type_type_ref (TREE_TYPE (decl));\n   else\n-    {\n-      push_eh_cleanup ();\n+    type = NULL_TREE;\n+  begin_catch_block (type);\n \n-      /* Create a binding level for the parm.  */\n-      pushlevel (0);\n-      expand_start_bindings (0);\n+  push_eh_info ();\n+  push_eh_cleanup ();\n \n-      /* Fall into the catch all section.  */\n-    }\n+  /* Create a binding level for the parm.  */\n+  compound_stmt_2 = begin_compound_stmt (/*has_no_scope=*/0);\n \n-  emit_line_note (input_filename, lineno);\n+  if (decl)\n+    initialize_handler_parm (decl);\n+\n+  return build_tree_list (compound_stmt_1, compound_stmt_2);\n }\n \n \n@@ -632,8 +596,12 @@ process_start_catch_block (decl)\n    the label to jump to if this catch block didn't match.  */\n \n void\n-expand_end_catch_block ()\n+expand_end_catch_block (blocks)\n+     tree blocks;\n {\n+  tree compound_stmt_1 = blocks ? TREE_PURPOSE (blocks): NULL_TREE;\n+  tree compound_stmt_2 = blocks ? TREE_VALUE (blocks): NULL_TREE;\n+\n   if (! doing_eh (1))\n     return;\n \n@@ -642,22 +610,12 @@ expand_end_catch_block ()\n   if (in_function_try_handler\n       && (DECL_CONSTRUCTOR_P (current_function_decl)\n \t  || DECL_DESTRUCTOR_P (current_function_decl)))\n-    expand_throw (NULL_TREE);\n+    finish_expr_stmt (build_throw (NULL_TREE));\n \n   /* Cleanup the EH parameter.  */\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  poplevel (kept_level_p (), 1, 0);\n-      \n-  /* Cleanup the EH object.  */\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  poplevel (kept_level_p (), 1, 0);\n-\n-  /* Fall to outside the try statement when done executing handler and\n-     we fall off end of handler.  This is jump Lresume in the\n-     documentation.  */\n-  expand_goto (top_label_entry (&caught_return_label_stack));\n-\n-  end_catch_handler ();\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt_1);\n+    /* Cleanup the EH object.  */\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt_2);\n }\n \n /* An exception spec is implemented more or less like:\n@@ -671,21 +629,25 @@ expand_end_catch_block ()\n \n    __check_eh_spec in exception.cc handles all the details.  */\n \n-void\n+tree\n expand_start_eh_spec ()\n {\n-  expand_start_try_stmts ();\n+  return begin_try_block ();\n }\n \n-static void\n-expand_end_eh_spec (raises)\n+void\n+expand_end_eh_spec (raises, try_block)\n      tree raises;\n+     tree try_block;\n {\n   tree tmp, fn, decl, types = NULL_TREE;\n+  tree blocks;\n+  tree handler;\n   int count = 0;\n \n-  expand_start_all_catch ();\n-  expand_start_catch_block (NULL_TREE);\n+  finish_try_block (try_block);\n+  handler = begin_handler ();\n+  blocks = finish_handler_parms (NULL_TREE, handler);\n \n   /* Build up an array of type_infos.  */\n   for (; raises && TREE_VALUE (raises); raises = TREE_CHAIN (raises))\n@@ -733,10 +695,10 @@ expand_end_eh_spec (raises)\n   tmp = tree_cons (NULL_TREE, build_int_2 (count, 0), \n \t\t   tree_cons (NULL_TREE, decl, NULL_TREE));\n   tmp = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), tmp);\n-  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  finish_expr_stmt (tmp);\n \n-  expand_end_catch_block ();\n-  expand_end_all_catch ();\n+  finish_handler (blocks, handler);\n+  finish_handler_sequence (try_block);\n }\n \n /* This is called to expand all the toplevel exception handling\n@@ -753,21 +715,6 @@ expand_exception_blocks ()\n   catch_clauses = get_insns ();\n   end_sequence ();\n \n-  /* Do this after we expand leftover cleanups, so that the\n-     expand_eh_region_end that expand_end_eh_spec does will match the\n-     right expand_eh_region_start, and make sure it comes out before\n-     the terminate protected region.  */\n-  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-    {\n-     expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));\n-     do_pending_stack_adjust ();\n-     push_to_sequence (catch_clauses);\n-     expand_leftover_cleanups ();\n-     do_pending_stack_adjust ();\n-     catch_clauses = get_insns ();\n-     end_sequence ();\n-    }\n-\n   if (catch_clauses)\n     {\n       rtx funcend = gen_label_rtx ();\n@@ -815,12 +762,7 @@ start_anon_func ()\n   start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n \t\t\t\t  void_list_node),\n \t\t  t, NULL_TREE, SF_DEFAULT);\n-  store_parm_decls ();\n-  pushlevel (0);\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-  emit_line_note (input_filename, lineno);\n+  do_pushlevel ();\n \n   interface_unknown = old_interface_unknown;\n \n@@ -832,11 +774,9 @@ start_anon_func ()\n void\n end_anon_func ()\n {\n-  expand_end_bindings (getdecls (), 1, 0);\n-  poplevel (1, 0, 0);\n-  pop_momentary ();\n+  do_poplevel ();\n \n-  finish_function (lineno, 0);\n+  expand_body (finish_function (lineno, 0));\n \n   pop_from_top_level ();\n }"}, {"sha": "1f38649d3f068c6bf8458070e5a9d03f0a4027a2", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -456,5 +456,6 @@ do_case (start, end)\n \t    cp_error (\"case label `%E' within scope of cleanup or variable array\", start);\n \t}\n     }\n-  define_case_label ();\n+\n+  current_function_return_value = NULL_TREE;\n }"}, {"sha": "e0a1d13c605fa085976a8b74b516b51a7ec16ad8", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -2656,6 +2656,7 @@ create_temporary_var (type)\n   DECL_SOURCE_FILE (decl) = input_filename;\n   DECL_SOURCE_LINE (decl) = lineno;\n   DECL_IGNORED_P (decl) = 1;\n+  DECL_CONTEXT (decl) = current_function_decl;\n \n   return decl;\n }"}, {"sha": "f4eb396b94a3ef25113038608e3cd7b938acb96b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -2149,7 +2149,7 @@ emit_thunk (thunk_fndecl)\n     t = build_call (function, TREE_TYPE (TREE_TYPE (function)), t);\n     finish_return_stmt (t);\n \n-    finish_function (lineno, 0);\n+    expand_body (finish_function (lineno, 0));\n \n     /* Don't let the backend defer this function.  */\n     if (DECL_DEFER_OUTPUT (thunk_fndecl))\n@@ -2402,7 +2402,7 @@ synthesize_method (fndecl)\n       finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n     }\n \n-  finish_function (lineno, 0);\n+  expand_body (finish_function (lineno, 0));\n \n   extract_interface_info ();\n   if (! context)"}, {"sha": "018a754285ab0f662ff1431030b96a0d8ddd1530", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 698, "deletions": 702, "changes": 1400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086"}, {"sha": "ae8849d1c8536002caf13a842455d1256df67b1d", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -282,7 +282,7 @@ empty_parms ()\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n %type <ttype> named_class_head_sans_basetype_defn\n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n-\n+%type <ttype> handler_args\n %type <ttype> self_template_type .finish_template_type\n \n %token NSNAME\n@@ -660,9 +660,9 @@ eat_saved_input:\n \n fndef:\n \t  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error\n-\t\t{ finish_function (lineno, (int)$3); }\n+\t\t{ expand_body (finish_function (lineno, (int)$3)); }\n \t| fn.def1 maybe_return_init function_try_block\n-\t\t{ finish_function (lineno, (int)$3); }\n+\t\t{ expand_body (finish_function (lineno, (int)$3)); }\n \t| fn.def1 maybe_return_init error\n \t\t{ }\n \t;\n@@ -805,12 +805,8 @@ base_init:\n \t\t    store_parm_decls ();\n \n \t\t  if (DECL_CONSTRUCTOR_P (current_function_decl))\n-\t\t    {\n-\t\t      /* Make a contour for the initializer list.  */\n-\t\t      pushlevel (0);\n-\t\t      clear_last_expr ();\n-\t\t      expand_start_bindings (0);\n-\t\t    }\n+\t\t    /* Make a contour for the initializer list.  */\n+\t\t    do_pushlevel ();\n \t\t  else if (current_class_type == NULL_TREE)\n \t\t    error (\"base initializers not allowed for non-member functions\");\n \t\t  else if (! DECL_CONSTRUCTOR_P (current_function_decl))\n@@ -2073,12 +2069,12 @@ fn.defpen:\n pending_inline:\n \t  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error\n \t\t{\n-\t\t  finish_function (lineno, (int)$3 | 2);\n+\t\t  expand_body (finish_function (lineno, (int)$3 | 2));\n \t\t  process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init function_try_block\n \t\t{ \n-\t\t  finish_function (lineno, (int)$3 | 2); \n+\t\t  expand_body (finish_function (lineno, (int)$3 | 2)); \n                   process_next_inline ($1);\n \t\t}\n \t| fn.defpen maybe_return_init error\n@@ -3368,9 +3364,9 @@ handler:\n \t  CATCH\n                 { $<ttype>$ = begin_handler(); }\n           handler_args\n-                { finish_handler_parms ($<ttype>2); }\n+                { $<ttype>$ = finish_handler_parms ($3, $<ttype>2); }\n \t  compstmt\n-                { finish_handler ($<ttype>2); }\n+                { finish_handler ($<ttype>4, $<ttype>2); }\n \t;\n \n type_specifier_seq:\n@@ -3380,7 +3376,7 @@ type_specifier_seq:\n \n handler_args:\n \t  '(' ELLIPSIS ')'\n-\t\t{ expand_start_catch_block (NULL_TREE); }\n+\t\t{ $$ = NULL_TREE; }\n \t/* This doesn't allow reference parameters, the below does.\n \t| '(' type_specifier_seq absdcl ')'\n \t\t{ check_for_new_type (\"inside exception declarations\", $2);\n@@ -3398,8 +3394,8 @@ handler_args:\n \t| '(' parm ')'\n \t\t{ \n \t\t  check_for_new_type (\"inside exception declarations\", $2);\n-\t\t  start_handler_parms (TREE_PURPOSE ($2.t),\n-\t\t\t\t       TREE_VALUE ($2.t));\n+\t\t  $$ = start_handler_parms (TREE_PURPOSE ($2.t),\n+\t\t\t\t\t    TREE_VALUE ($2.t));\n \t\t}\n \t;\n "}, {"sha": "35bf27f9da0cb44d110a3b44d20382ba40b43f2b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -7475,19 +7475,25 @@ tsubst_expr (t, args, complain, in_decl)\n \t  finish_handler_sequence (stmt);\n \t}\n       break;\n-\n+      \n     case HANDLER:\n-      prep_stmt (t);\n-      stmt = begin_handler ();\n-      if (HANDLER_PARMS (t))\n-\texpand_start_catch_block\n-\t  (tsubst (DECL_STMT_DECL (HANDLER_PARMS (t)), \n-\t\t   args, complain, in_decl));\n-      else\n-\texpand_start_catch_block (NULL_TREE);\n-      finish_handler_parms (stmt);\n-      tsubst_expr (HANDLER_BODY (t), args, complain, in_decl);\n-      finish_handler (stmt);\n+      {\n+\ttree decl;\n+\ttree blocks;\n+\n+\tprep_stmt (t);\n+\tstmt = begin_handler ();\n+\tif (HANDLER_PARMS (t))\n+\t  {\n+\t    decl = DECL_STMT_DECL (HANDLER_PARMS (t));\n+\t    decl = tsubst (decl, args, complain, in_decl);\n+\t  }\n+\telse\n+\t  decl = NULL_TREE;\n+\tblocks = finish_handler_parms (decl, stmt);\n+\ttsubst_expr (HANDLER_BODY (t), args, complain, in_decl);\n+\tfinish_handler (blocks, stmt);\n+      }\n       break;\n \n     case TAG_DEFN:"}, {"sha": "5ab8d63f85bd70850c19d0c5445462bbf4c32d37", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -1196,5 +1196,5 @@ synthesize_tinfo_fn (fndecl)\n   pop_momentary ();\n   /* Finish the function body.  */\n   finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n-  finish_function (lineno, 0);\n+  expand_body (finish_function (lineno, 0));\n }"}, {"sha": "383e981402ec287f46bf56b0c4bba0e6b61a9426", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 169, "deletions": 121, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b35d4555e691bb26962451ad41324cf9d9f02086/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b35d4555e691bb26962451ad41324cf9d9f02086", "patch": "@@ -41,8 +41,6 @@\n    parsing into this file; that will make implementing the new parser\n    much easier since it will be able to make use of these routines.  */\n \n-static void do_pushlevel PROTO((void));\n-static tree do_poplevel PROTO((void));\n static void finish_expr_stmt_real PROTO((tree, int));\n static tree expand_cond PROTO((tree));\n static tree maybe_convert_cond PROTO((tree));\n@@ -623,7 +621,12 @@ finish_case_label (low_value, high_value)\n {\n   if (building_stmt_tree ())\n     {\n+      /* Add a representation for the case label to the statement\n+\t tree.  */\n       add_tree (build_min_nt (CASE_LABEL, low_value, high_value));\n+      /* And warn about crossing initializations, etc.  */\n+      if (!processing_template_decl)\n+\tdefine_case_label ();\n       return;\n     }\n \n@@ -648,6 +651,7 @@ finish_goto_stmt (destination)\n       if (TREE_CODE (destination) == LABEL_DECL)\n \t{\n \t  TREE_USED (destination) = 1;\n+\t  label_rtx (destination);\n \t  expand_goto (destination); \n \t}\n       else\n@@ -761,8 +765,9 @@ finish_function_try_block (try_block)\n     {\n       end_protect_partials ();\n       expand_start_all_catch ();\n-      in_function_try_handler = 1;\n     }\n+\n+  in_function_try_handler = 1;\n }\n \n /* Finish a handler-sequence for a try-block, which may be given by\n@@ -784,13 +789,12 @@ void\n finish_function_handler_sequence (try_block)\n      tree try_block;\n {\n+  in_function_try_handler = 0;\n+\n   if (building_stmt_tree ())\n     RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n   else\n-    {\n-      in_function_try_handler = 0;\n-      expand_end_all_catch ();\n-    }\n+    expand_end_all_catch ();\n }\n \n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n@@ -814,26 +818,71 @@ begin_handler ()\n }\n \n /* Finish the handler-parameters for a handler, which may be given by\n-   HANDLER.  */\n+   HANDLER.  DECL is the declaration for the catch parameter, or NULL\n+   if this is a `catch (...)' clause.  */\n \n-void\n-finish_handler_parms (handler)\n+tree\n+finish_handler_parms (decl, handler)\n+     tree decl;\n      tree handler;\n+{\n+  tree blocks = NULL_TREE;\n+\n+  if (processing_template_decl)\n+    {\n+      if (decl)\n+\t{\n+\t  decl = pushdecl (decl);\n+\t  decl = push_template_decl (decl);\n+\t  add_decl_stmt (decl);\n+\t  RECHAIN_STMTS (handler, HANDLER_PARMS (handler));\n+\t}\n+    }\n+  else if (building_stmt_tree ())\n+    blocks = expand_start_catch_block (decl);\n+\n+  return blocks;\n+}\n+\n+/* Note the beginning of a handler for TYPE.  This function is called\n+   at the point to which control should be transferred when an\n+   appropriately-typed exception is thrown.  */\n+\n+void\n+begin_catch_block (type)\n+     tree type;\n {\n   if (building_stmt_tree ())\n-    RECHAIN_STMTS (handler, HANDLER_PARMS (handler));\n+    add_tree (build (START_CATCH_STMT, type));\n+  else\n+    start_catch_handler (type);\n }\n \n-/* Finish a handler, which may be given by HANDLER.  */\n+/* Finish a handler, which may be given by HANDLER.  The BLOCKs are\n+   the return value from the matching call to finish_handler_parms.  */\n \n void\n-finish_handler (handler)\n+finish_handler (blocks, handler)\n+     tree blocks;\n      tree handler;\n {\n+  if (!processing_template_decl)\n+    {\n+      if (building_stmt_tree ())\n+\texpand_end_catch_block (blocks);\n+\n+      if (!building_stmt_tree ())\n+\t{\n+\t  /* Fall to outside the try statement when done executing\n+\t     handler and we fall off end of handler.  This is jump\n+\t     Lresume in the documentation.  */\n+\t  expand_goto (top_label_entry (&caught_return_label_stack));\n+\t  end_catch_handler ();\n+\t}\n+    }\n+\n   if (building_stmt_tree ())\n     RECHAIN_STMTS (handler, HANDLER_BODY (handler));\n-  else\n-    expand_end_catch_block ();\n \n   do_poplevel ();\n }\n@@ -1044,7 +1093,8 @@ finish_decl_cleanup (decl, cleanup)\n {\n   if (building_stmt_tree ())\n     add_tree (build_min_nt (CLEANUP_STMT, decl, cleanup));\n-  else if (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node)\n+  else if (!decl \n+\t   || (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node))\n     expand_decl_cleanup (decl, cleanup);\n }\n \n@@ -1089,7 +1139,8 @@ finish_named_return_value (return_id, init)\n     {\n       /* Let `cp_finish_decl' know that this initializer is ok.  */\n       DECL_INITIAL (decl) = init;\n-      pushdecl (decl);\n+      if (doing_semantic_analysis_p ())\n+\tpushdecl (decl);\n \n       if (building_stmt_tree ())\n \tadd_tree (build_min_nt (RETURN_INIT, return_id, init));\n@@ -1127,7 +1178,7 @@ setup_vtbl_ptr ()\n \n /* Begin a new scope.  */\n \n-static void\n+void\n do_pushlevel ()\n {\n   if (!building_stmt_tree ())\n@@ -1137,24 +1188,53 @@ do_pushlevel ()\n     }\n   push_momentary ();\n   if (stmts_are_full_exprs_p)\n-    pushlevel (0);\n-  if (!building_stmt_tree () && stmts_are_full_exprs_p)\n-    expand_start_bindings (0);\n+    {\n+      pushlevel (0);\n+      if (!building_stmt_tree ()\n+\t  && !current_function->x_whole_function_mode_p)\n+\texpand_start_bindings (0);\n+      else if (building_stmt_tree () && !processing_template_decl)\n+\t{\n+\t  tree ss = build_min_nt (SCOPE_STMT);\n+\t  SCOPE_BEGIN_P (ss) = 1;\n+\t  add_tree (ss);\n+\t  current_scope_stmt_stack \n+\t    = tree_cons (NULL_TREE, ss, current_scope_stmt_stack);\n+\t}\n+    }\n }\n \n /* Finish a scope.  */\n \n-static tree\n+tree\n do_poplevel ()\n {\n-  tree t;\n+  tree t = NULL_TREE;\n \n-  if (!building_stmt_tree () && stmts_are_full_exprs_p)\n-    expand_end_bindings (getdecls (), kept_level_p (), 0);\n   if (stmts_are_full_exprs_p)\n-    t = poplevel (kept_level_p (), 1, 0);\n-  else\n-    t = NULL_TREE;\n+    {\n+      if (!building_stmt_tree ()\n+\t  && !current_function->x_whole_function_mode_p)\n+\texpand_end_bindings (getdecls (), kept_level_p (), 0);\n+      else if (building_stmt_tree () && !processing_template_decl)\n+\t{\n+\t  tree ss = build_min_nt (SCOPE_STMT);\n+\t  SCOPE_NULLIFIED_P (ss) = !kept_level_p ();\n+\t  SCOPE_NULLIFIED_P (TREE_VALUE (current_scope_stmt_stack))\n+\t    = SCOPE_NULLIFIED_P (ss);\n+\t  add_tree (ss);\n+\t  current_scope_stmt_stack = TREE_CHAIN (current_scope_stmt_stack);\n+\n+\t  /* When not in function-at-a-time mode, expand_end_bindings\n+\t     will warn about unused variables.  But, in\n+\t     function-at-a-time mode expand_end_bindings is not passed\n+\t     the list of variables in the current scope, and therefore\n+\t     no warning is emitted.  So, we explicitly warn here.  */\n+\t  warn_about_unused_variables (getdecls ());\n+\t}\n+\n+      t = poplevel (kept_level_p (), 1, 0);\n+    }\n   pop_momentary ();\n   return t;\n }\n@@ -2141,41 +2221,20 @@ expand_stmt (t)\n \n \t    emit_line_note (input_filename, lineno);\n \t    decl = DECL_STMT_DECL (t);\n-\t    if (TREE_CODE (decl) == LABEL_DECL)\n-\t      finish_label_decl (DECL_NAME (decl));\n-\t    else\n-\t      {\n-\t\t/* If we marked this variable as dead when we processed it\n-\t\t   before, we must undo that now.  The variable has been\n-\t\t   resuscitated.  */\n-\t\tif (TREE_CODE (decl) == VAR_DECL)\n-\t\t  DECL_DEAD_FOR_LOCAL (decl) = 0;\n-\t\t/* We need to clear DECL_CONTEXT so that maybe_push_decl\n-\t\t   will push it into the current scope.  */\n-\t\tif (DECL_CONTEXT (decl) == current_function_decl)\n-\t\t  {\n-\t\t    DECL_CONTEXT (decl) = NULL_TREE;\n-\t\t    maybe_push_decl (decl);\n-\t\t  }\n-\t\t/* If this is a declaration for an automatic local\n-\t\t   variable, initialize it.  Note that we might also see a\n-\t\t   declaration for a namespace-scope object (declared with\n-\t\t   `extern') or an object with static storage duration\n-\t\t   (declared with `static').  We don't have to handle the\n-\t\t   initialization of those objects here; the former can\n-\t\t   never be a definition (only a declaration), and the\n-\t\t   latter is handled in finish_file.  */\n-\t\tif (TREE_CODE (decl) == VAR_DECL \n-\t\t    && !TREE_STATIC (decl)\n-\t\t    && !DECL_EXTERNAL (decl))\n-\t\t  {\n-\t\t    /* Support the old for-scope rules for backwards\n-\t\t       compatibility.  */\n-\t\t    maybe_inject_for_scope_var (decl);\n-\t\t    /* Let the back-end know about this variable.  */\n-\t\t    emit_local_var (decl);\n-\t\t  }\n-\t      }\n+\t    /* If this is a declaration for an automatic local\n+\t       variable, initialize it.  Note that we might also see a\n+\t       declaration for a namespace-scope object (declared with\n+\t       `extern') or an object with static storage duration\n+\t       (declared with `static').  We don't have to handle the\n+\t       initialization of those objects here; the former can\n+\t       never be a definition (only a declaration), and the\n+\t       latter is handled in finish_file.  */\n+\t    if (TREE_CODE (decl) == VAR_DECL \n+\t\t&& !TREE_STATIC (decl)\n+\t\t&& !DECL_EXTERNAL (decl))\n+\t      /* Let the back-end know about this variable.  */\n+\t      emit_local_var (decl);\n+\n \t    resume_momentary (i);\n \t  }\n \t  break;\n@@ -2184,6 +2243,10 @@ expand_stmt (t)\n \t  finish_decl_cleanup (CLEANUP_DECL (t), CLEANUP_EXPR (t));\n \t  break;\n \n+\tcase START_CATCH_STMT:\n+\t  begin_catch_block (TREE_TYPE (t));\n+\t  break;\n+\n \tcase FOR_STMT:\n \t  {\n \t    tree tmp;\n@@ -2266,14 +2329,11 @@ expand_stmt (t)\n \t  break;\n \n \tcase LABEL_STMT:\n-\t  finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n+\t  expand_label (LABEL_STMT_LABEL (t));\n \t  break;\n \n \tcase GOTO_STMT:\n-\t  if (TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL)\n-\t    finish_goto_stmt (DECL_NAME (GOTO_DESTINATION (t)));\n-\t  else\n-\t    finish_goto_stmt (GOTO_DESTINATION (t));\n+\t  finish_goto_stmt (GOTO_DESTINATION (t));\n \t  break;\n \n \tcase ASM_STMT:\n@@ -2291,29 +2351,59 @@ expand_stmt (t)\n \t    }\n \t  else\n \t    {\n-\t      begin_try_block ();\n+\t      if (FN_TRY_BLOCK_P (t))\n+\t\tbegin_function_try_block ();\n+\t      else\n+\t\tbegin_try_block ();\n+\n \t      expand_stmt (TRY_STMTS (t));\n-\t      finish_try_block (NULL_TREE);\n-\t      expand_stmt (TRY_HANDLERS (t));\n-\t      finish_handler_sequence (NULL_TREE);\n+\n+\t      if (FN_TRY_BLOCK_P (t))\n+\t\t{\n+\t\t  finish_function_try_block (NULL_TREE);\n+\t\t  expand_stmt (TRY_HANDLERS (t));\n+\t\t  finish_function_handler_sequence (NULL_TREE);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  finish_try_block (NULL_TREE);\n+\t\t  expand_stmt (TRY_HANDLERS (t));\n+\t\t  finish_handler_sequence (NULL_TREE);\n+\t\t}\n \t    }\n \t  break;\n \n \tcase HANDLER:\n \t  begin_handler ();\n-\t  if (HANDLER_PARMS (t))\n-\t    expand_start_catch_block (DECL_STMT_DECL (HANDLER_PARMS (t)));\n-\t  else\n-\t    expand_start_catch_block (NULL_TREE);\n-\t  finish_handler_parms (NULL_TREE);\n \t  expand_stmt (HANDLER_BODY (t));\n-\t  finish_handler (NULL_TREE);\n+\t  finish_handler (NULL_TREE, NULL_TREE);\n \t  break;\n \n \tcase SUBOBJECT:\n \t  finish_subobject (SUBOBJECT_CLEANUP (t));\n \t  break;\n \n+\tcase SCOPE_STMT:\n+\t  if (SCOPE_BEGIN_P (t))\n+\t    expand_start_bindings (2 * SCOPE_NULLIFIED_P (t));\n+\t  else if (SCOPE_END_P (t))\n+\t    expand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n+\t  break;\n+\n+\tcase CTOR_INITIALIZER:\n+\t  current_member_init_list = TREE_OPERAND (t, 0);\n+\t  current_base_init_list = TREE_OPERAND (t, 1);\n+\t  setup_vtbl_ptr ();\n+\t  break;\n+\n+\tcase RETURN_INIT:\n+\t  /* Clear this out so that finish_named_return_value can set it\n+\t     again.  */\n+\t  DECL_NAME (DECL_RESULT (current_function_decl)) = NULL_TREE;\n+\t  finish_named_return_value (TREE_OPERAND (t, 0), \n+\t\t\t\t     TREE_OPERAND (t, 1));\n+\t  break;\n+\n \tdefault:\n \t  my_friendly_abort (19990810);\n \t  break;\n@@ -2337,8 +2427,6 @@ expand_body (fn)\n {\n   int saved_lineno;\n   char *saved_input_filename;\n-  tree t;\n-  tree try_block;\n \n   /* When the parser calls us after finishing the body of a template\n      function, we don't really want to expand the body.  When we're\n@@ -2367,48 +2455,8 @@ expand_body (fn)\n      function body.  */\n   current_function_name_declared = 1;\n \n-  /* There are a few things that we do not handle recursively.  For\n-     example, a function try-block is handled differently from an\n-     ordinary try-block, so we must handle it here.  */\n-  t = DECL_SAVED_TREE (fn);\n-  try_block = NULL_TREE;\n-  if (t && TREE_CODE (t) == TRY_BLOCK)\n-    {\n-      try_block = t;\n-      begin_function_try_block ();\n-      t = TRY_STMTS (try_block);\n-    }\n-\n-  if (t && TREE_CODE (t) == RETURN_INIT)\n-    {\n-      /* Clear this out so that finish_named_return_value can set it\n-\t again.  */\n-      DECL_NAME (DECL_RESULT (fn)) = NULL_TREE;\n-      finish_named_return_value (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1));\n-      t = TREE_CHAIN (t);\n-    }\n-\n-  if (t && TREE_CODE (t) == CTOR_INITIALIZER)\n-    {\n-      current_member_init_list = TREE_OPERAND (t, 0);\n-      current_base_init_list = TREE_OPERAND (t, 1);\n-      t = TREE_CHAIN (t);\n-    }\n-\n-  /* If this is a constructor, we need to initialize our members and\n-     base-classes.  */\n-  setup_vtbl_ptr ();\n-\n   /* Expand the body.  */\n-  expand_stmt (t);\n-\n-  /* If there was a function try-block, expand the handlers.  */\n-  if (try_block)\n-    {\n-      finish_function_try_block (NULL_TREE);\n-      expand_stmt (TRY_HANDLERS (try_block));\n-      finish_function_handler_sequence (NULL_TREE);\n-    }\n+  expand_stmt (DECL_SAVED_TREE (fn));\n \n   /* Statements should always be full-expressions at the outermost set\n      of curly braces for a function.  */"}]}