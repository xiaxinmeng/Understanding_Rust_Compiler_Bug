{"sha": "01fa3508b695c71257891097a26969090792f6af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFmYTM1MDhiNjk1YzcxMjU3ODkxMDk3YTI2OTY5MDkwNzkyZjZhZg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-11-29T04:57:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-11-29T04:57:21Z"}, "message": "pa-64.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not a list, to keep track of the sections.\n\n\t* pa/pa-64.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not\n\ta list, to keep track of the sections.\n\nFrom-SVN: r37843", "tree": {"sha": "087035804f413b7ac6d2e6c794dd97a3f195d343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/087035804f413b7ac6d2e6c794dd97a3f195d343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01fa3508b695c71257891097a26969090792f6af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01fa3508b695c71257891097a26969090792f6af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01fa3508b695c71257891097a26969090792f6af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01fa3508b695c71257891097a26969090792f6af/comments", "author": null, "committer": null, "parents": [{"sha": "5662d5333acd122c452c6f1a69e180d5c1ed1efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5662d5333acd122c452c6f1a69e180d5c1ed1efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5662d5333acd122c452c6f1a69e180d5c1ed1efe"}], "stats": {"total": 93, "additions": 55, "deletions": 38}, "files": [{"sha": "0a140f451b5d256a32e5b9aa1cc99d50b7e5b3ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01fa3508b695c71257891097a26969090792f6af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01fa3508b695c71257891097a26969090792f6af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01fa3508b695c71257891097a26969090792f6af", "patch": "@@ -1,3 +1,8 @@\n+Tue Nov 28 21:56:45 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa/pa-64.h (ASM_OUTPUT_SECTION_NAME): Use a hash table, not\n+\ta list, to keep track of the sections.\n+\n 2000-11-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/arm.md (pic_load_addr): Split into"}, {"sha": "e9aec824765c7d6eb5dcc6b34120aac212c5b484", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01fa3508b695c71257891097a26969090792f6af/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01fa3508b695c71257891097a26969090792f6af/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=01fa3508b695c71257891097a26969090792f6af", "patch": "@@ -273,46 +273,58 @@ dtors_section ()\t\t\t\t\t\t\t\\\n    If DECL is NULL, no attributes are emitted.  */\n \n #define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  static struct section_info\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      struct section_info *next;\t\t\t\t        \\\n-      char *name;\t\t\t\t\t\t        \\\n-      enum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n-    } *sections;\t\t\t\t\t\t\t\\\n-  struct section_info *s;\t\t\t\t\t\t\\\n-  char *mode;\t\t\t\t\t\t\t\t\\\n-  enum sect_enum type;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (s = sections; s; s = s->next)\t\t\t\t\t\\\n-    if (!strcmp (NAME, s->name))\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n-    type = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n-  else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\t\\\n-    type = SECT_RO, mode = \"a\";\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    type = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (s == 0)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      s = (struct section_info *) xmalloc (sizeof (struct section_info));  \\\n-      s->name = xmalloc ((strlen (NAME) + 1) * sizeof (*NAME));\t\t\\\n-      strcpy (s->name, NAME);\t\t\t\t\t\t\\\n-      s->type = type;\t\t\t\t\t\t\t\\\n-      s->next = sections;\t\t\t\t\t\t\\\n-      sections = s;\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\", NAME, mode);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (DECL && s->type != type)\t\t\t\t\t\\\n-\terror_with_decl (DECL, \"%s causes a section type conflict\");\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\t\\\n+      static htab_t htab;                                               \\\n+                                                                        \\\n+      struct section_info                                               \\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tenum sect_enum {SECT_RW, SECT_RO, SECT_EXEC} type;\t\t\\\n+      };                                                                \\\n+                                                                        \\\n+      struct section_info *s;\t\t\t\t\t\t\\\n+      const char *mode;\t\t\t\t\t\t\t\\\n+      enum sect_enum type;                                              \\\n+      PTR* slot;                                                        \\\n+                                                                        \\\n+      /* The names we put in the hashtable will always be the unique    \\\n+\t versions gived to us by the stringtable, so we can just use    \\\n+\t their addresses as the keys.  */                               \\\n+      if (!htab)                                                        \\\n+\thtab = htab_create (31,                                         \\\n+\t\t\t    htab_hash_pointer,                          \\\n+\t\t\t    htab_eq_pointer,                            \\\n+\t\t\t    NULL);                                      \\\n+                                                                        \\\n+      if (DECL && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\t\\\n+\ttype = SECT_EXEC, mode = \"ax\";\t\t\t\t\t\\\n+      else if (DECL && DECL_READONLY_SECTION (DECL, RELOC))\t\t\\\n+\ttype = SECT_RO, mode = \"a\";\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\ttype = SECT_RW, mode = \"aw\";\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+                                                                        \\\n+      /* See if we already have an entry for this section.  */          \\\n+      slot = htab_find_slot (htab, NAME, INSERT);                       \\\n+      if (!*slot)                                                       \\\n+\t{                                                               \\\n+\t  s = (struct section_info *) xmalloc (sizeof (* s));\t\t\\\n+\t  s->type = type;\t\t\t\t\t\t\\\n+\t  *slot = s;\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s,\\\"%s\\\",@progbits\\n\",\t\t\\\n+\t\t   NAME, mode);\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  s = (struct section_info *) *slot;                            \\\n+\t  if (DECL && s->type != type)\t\t\t\t\t\\\n+\t    error_with_decl (DECL,                                      \\\n+\t\t\t     \"%s causes a section type conflict\");      \\\n+\t  \t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t.section\\t%s\\n\", NAME);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  while (0)\n \n #define MAKE_DECL_ONE_ONLY(DECL) (DECL_WEAK (DECL) = 1)\n #define UNIQUE_SECTION_P(DECL) (DECL_ONE_ONLY (DECL))"}]}