{"sha": "014753cc4d898e889ab04dcdb41bb6cc99645e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0NzUzY2M0ZDg5OGU4ODlhYjA0ZGNkYjQxYmI2Y2M5OTY0NWU2OQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-09T13:29:24Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-09T13:29:24Z"}, "message": "i386.md (DWI): New mode iterator.\n\n\t* config/i386/i386.md (DWI): New mode iterator.\n\t(S): New mode attribute.\n\t(shift_operand): Ditto.\n\t(shift_immediate_operand): Ditto.\n\t(ashl_input_operand): Ditto.\n\t(ashl<mode>3): Macroize expander from ashl{qi,hi,si,di,ti}3_1\n\tusing SDWIM mode iterator.\n\t(*ashl<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n\tpattern from *ashl{di,ti}3_1 and corresponding splitters using\n\tDWI mode iterator.\n\t(*ashl<mode>3_doubleword peephole2): Macroize peephole2 pattern\n\tfrom corresponding peephole2 patterns.\n\t(x86_shift<mode>_adj_1): Macroize expander from x86_shift_adj_1\n\tand x86_64_shift_adj_1 using SWI48 mode iterator.\n\t(x86_shift<mode>_adj_2): Ditto.\n\t(*ashldi3_1_rex64): Split TYPE_LEA pattern.\n\t(*ashl<mode>3_1): Macroize insn from *ashlsi3_1 and *ashldi3_1_rex64\n\tusing SWI48 mode iterator.\n\t(*ashl<mode>3_cmp): Macroize insn from *ashl{qi,hi,si}3_cmp and\n\t*ashldi3_cmp_rex64 using SWI mode iterator.\n\t(*ashl<mode>3_cconly): Macroize insn from *ashl{qi,hi,si}3_cconly and\n\t*ashldi3_cconly_rex64 using SWI mode iterator.\n\t* config/i386/i386.c (ix86_split_ashl): Update for renamed\n\tx86_shift<mode>_adj_{1,2}.\n\t(ix86_split_ashr): Ditto.\n\t(ix86_split_lshr): Ditto.\n\nFrom-SVN: r158163", "tree": {"sha": "3603e56d0bbe511ce03876cad040f7ce686134f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3603e56d0bbe511ce03876cad040f7ce686134f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/014753cc4d898e889ab04dcdb41bb6cc99645e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014753cc4d898e889ab04dcdb41bb6cc99645e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014753cc4d898e889ab04dcdb41bb6cc99645e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014753cc4d898e889ab04dcdb41bb6cc99645e69/comments", "author": null, "committer": null, "parents": [{"sha": "88dd71504e89d86f723861404153b071d3113b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88dd71504e89d86f723861404153b071d3113b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88dd71504e89d86f723861404153b071d3113b39"}], "stats": {"total": 1194, "additions": 385, "deletions": 809}, "files": [{"sha": "0a11d90303b5b74ff6213f8799c71d20aefe4f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=014753cc4d898e889ab04dcdb41bb6cc99645e69", "patch": "@@ -1,3 +1,32 @@\n+2010-04-09  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (DWI): New mode iterator.\n+\t(S): New mode attribute.\n+\t(shift_operand): Ditto.\n+\t(shift_immediate_operand): Ditto.\n+\t(ashl_input_operand): Ditto.\n+\t(ashl<mode>3): Macroize expander from ashl{qi,hi,si,di,ti}3_1\n+\tusing SDWIM mode iterator.\n+\t(*ashl<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n+\tpattern from *ashl{di,ti}3_1 and corresponding splitters using\n+\tDWI mode iterator.\n+\t(*ashl<mode>3_doubleword peephole2): Macroize peephole2 pattern\n+\tfrom corresponding peephole2 patterns.\n+\t(x86_shift<mode>_adj_1): Macroize expander from x86_shift_adj_1\n+\tand x86_64_shift_adj_1 using SWI48 mode iterator.\n+\t(x86_shift<mode>_adj_2): Ditto.\n+\t(*ashldi3_1_rex64): Split TYPE_LEA pattern.\n+\t(*ashl<mode>3_1): Macroize insn from *ashlsi3_1 and *ashldi3_1_rex64\n+\tusing SWI48 mode iterator.\n+\t(*ashl<mode>3_cmp): Macroize insn from *ashl{qi,hi,si}3_cmp and\n+\t*ashldi3_cmp_rex64 using SWI mode iterator.\n+\t(*ashl<mode>3_cconly): Macroize insn from *ashl{qi,hi,si}3_cconly and\n+\t*ashldi3_cconly_rex64 using SWI mode iterator.\n+\t* config/i386/i386.c (ix86_split_ashl): Update for renamed\n+\tx86_shift<mode>_adj_{1,2}.\n+\t(ix86_split_ashr): Ditto.\n+\t(ix86_split_lshr): Ditto.\n+\n 2010-04-09  Richard Guenther  <rguenther@suse.de>\n \n \t* target.h (builtin_conversion): Pass in input and output types.\n@@ -58,8 +87,7 @@\n \t(x86_this_parameter): Likewise.\n \t(x86_output_mi_thunk): Likewise.\n \t(ix86_attribute_table): Add description for thiscall attribute.\n-\t* config/i386/i386.h (ix86_args): Adjust comment for member\n-\tfastcall.\n+\t* config/i386/i386.h (ix86_args): Adjust comment for member fastcall.\n \t* doc/extend.texi: Add documentation for thiscall.\n \t\n 2010-04-09  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n@@ -83,8 +111,8 @@\n \n \tPR tree-optimization/42720\n \t* tree-ssa-loop-unswitch.c (tree_ssa_unswitch_loops): Move one-time\n-\tloop unswitch conditions here from\n-\t(tree_unswitch_single_loop).\n+\tloop unswitch conditions here from ...\n+\t(tree_unswitch_single_loop): ... here.\n \n 2010-04-08  Sebastian Pop  <sebastian.pop@amd.com>\n \n@@ -108,14 +136,15 @@\n 2010-04-08  Christian Borntraeger  <borntraeger@de.ibm.com>\n             Wolfgang Gellerich  <gellerich@de.ibm.com>\n \n-        Implement target hook for loop unrolling\n-        * target.h (loop_unroll_adjust): Add a new target hook function.\n-        * target-def.h (TARGET_LOOP_UNROLL_ADJUST): Likewise.\n-        * doc/tm.texi (TARGET_LOOP_UNROLL_ADJUST): Document it.\n-        * config/s390/s390.c (TARGET_LOOP_UNROLL_ADJUST): Define it.\n-        (s390_loop_unroll_adjust): Implement the new target hook for s390.\n-        * loop-unroll.c (decide_unroll_runtime_iterations): Call loop unroll target hook\n-        (decide_unroll_stupid): Likewise.\n+\tImplement target hook for loop unrolling\n+\t* target.h (loop_unroll_adjust): Add a new target hook function.\n+\t* target-def.h (TARGET_LOOP_UNROLL_ADJUST): Likewise.\n+\t* doc/tm.texi (TARGET_LOOP_UNROLL_ADJUST): Document it.\n+\t* config/s390/s390.c (TARGET_LOOP_UNROLL_ADJUST): Define it.\n+\t(s390_loop_unroll_adjust): Implement the new target hook for s390.\n+\t* loop-unroll.c (decide_unroll_runtime_iterations): Call loop unroll\n+\ttarget hook.\n+\t(decide_unroll_stupid): Likewise.\n \n 2010-04-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n@@ -131,8 +160,8 @@\n 2010-04-08  Wolfgang Gellerich  <gellerich@de.ibm.com>\n \n \t* config/s390/s390.c (override_options): Adjust the z10\n-          defaults for max-unroll-times, max-completely-peeled-insns\n-          and max-completely-peel-times.\n+\t  defaults for max-unroll-times, max-completely-peeled-insns\n+\t  and max-completely-peel-times.\n \n 2010-04-08  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n@@ -283,8 +312,7 @@\n \t* tree-ssa-forwprop.c (forward_propagate_into_gimple_cond):\n \tHandle reversed comparison ops.\n \t* tree-sra.c (asm_visit_addr): Use get_base_address.\n-\t* ipa-prop.c (visit_store_addr_for_mod_analysis): Use\n-\tget_base_address.\n+\t* ipa-prop.c (visit_store_addr_for_mod_analysis): Use get_base_address.\n \t* ipa-reference.c (mark_address): Use get_base_address.\n \n 2010-04-07  Richard Guenther  <rguenther@suse.de>\n@@ -305,10 +333,8 @@\n \t* doc/invoke.texi (-fargument-alias, -fargument-noalias,\n \t-fargument-noalias-global, -fargument-noalias-anything): Remove.\n \t* common.opt: Likewise.\n-\t* tree-ssa-structalias.c (intra_create_variable_infos): Adjust\n-\tcomment.\n-\t* alias.c (base_alias_check): Remove flag_argument_noalias\n-\thandling.\n+\t* tree-ssa-structalias.c (intra_create_variable_infos): Adjust comment.\n+\t* alias.c (base_alias_check): Remove flag_argument_noalias handling.\n \t(nonoverlapping_memrefs_p): Likewise.\n \t* emit-rtl.c (set_mem_attributes_minus_bitpos): Likewise.\n \t* opts.c (common_handle_option): Handle OPT_fargument_alias,\n@@ -318,8 +344,7 @@\n 2010-04-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43270\n-\t* tree-vrp.c (check_array_ref): Fix flexible array member\n-\tdetection.\n+\t* tree-vrp.c (check_array_ref): Fix flexible array member detection.\n \t* tree-ssa-sccvn.h (fully_constant_vn_reference_p): Declare.\n \t* tree-ssa-pre.c (phi_translate_1): Adjust.\n \t(fully_constant_expression): Split out vn_reference handling to ...\n@@ -340,15 +365,13 @@\n \n 2010-04-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n-\t* config.gcc (i[34567]86-*-solaris2*): Default with_tune_32 to\n-\tgeneric.\n+\t* config.gcc (i[34567]86-*-solaris2*): Default with_tune_32 to generic.\n \n 2010-04-07  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/42617\n-\t* expr.c (expand_expr_real_1): For TARGET_MEM_REFs with\n-\tpointer bases build simple mem attributes to retain\n-\tpoints-to information.\n+\t* expr.c (expand_expr_real_1): For TARGET_MEM_REFs with pointer\n+\tbases build simple mem attributes to retain points-to information.\n \n 2010-04-07  Richard Guenther  <rguenther@suse.de>\n \n@@ -361,8 +384,7 @@\n \tPR middle-end/42617\n \t* emit-rtl.c (set_mem_attributes_minus_bitpos): Do not\n \tdiscard plain indirect references.\n-\t* fold-const.c (operand_equal_p): Guard against NULL_TREE\n-\ttype.\n+\t* fold-const.c (operand_equal_p): Guard against NULL_TREE type.\n \t* tree.c (tree_nop_conversion): Likewise.\n \n 2010-04-07  Dodji Seketeli  <dodji@redhat.com>\n@@ -391,11 +413,13 @@\n \n \tPR middle-end/43519\n \t* graphite-clast-to-gimple.c (max_signed_precision_type): Use\n-\tlang_hooks.types.type_for_size instead of build_nonstandard_integer_type.\n+\tlang_hooks.types.type_for_size instead of\n+\tbuild_nonstandard_integer_type.\n \tWhen converting an unsigned type to signed, double its precision.\n \t(gcc_type_for_interval): Use lang_hooks.types.type_for_size.\n \t(gcc_type_for_iv_of_clast_loop): Call max_signed_precision_type.\n-\t(graphite_create_new_loop_guard): When ub + 1 wraps around, use lb <= ub.\n+\t(graphite_create_new_loop_guard): When ub + 1 wraps around,\n+\tuse lb <= ub.\n \n 2010-04-06  Sebastian Pop  <sebastian.pop@amd.com>\n \n@@ -631,8 +655,7 @@\n \n 2010-04-02  Joseph Myers  <joseph@codesourcery.com>\n \n-\t* read-rtl.c (read_rtx_1): Give an error for EOF while looking for\n-\t']'.\n+\t* read-rtl.c (read_rtx_1): Give an error for EOF while looking for ']'.\n \n 2010-04-02  Richard Earnshaw  <rearnsha@arm.com>\n \n@@ -656,12 +679,12 @@\n \n 2010-04-01  Ralf Cors\u00e9pius <ralf.corsepius@rtems.org>\n \n-        * config.gcc (lm32-*-rtems*): Add t-lm32.\n+\t* config.gcc (lm32-*-rtems*): Add t-lm32.\n \n 2010-04-01  Joel Sherrill <joel.sherrill@oarcorp.com>\n \n-        * config.gcc: Add lm32-*-rtems*.\n-        * config/lm32/rtems.h: New file.\n+\t* config.gcc: Add lm32-*-rtems*.\n+\t* config/lm32/rtems.h: New file.\n \n 2010-04-01  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n@@ -714,7 +737,7 @@\n \tPR middle-end/43602\n \tRevert\n \t2010-03-30  Seongbae Park <seongbae.park@gmail.com>\n-\t    Jack Howarth <howarth@bromo.med.uc.edu>\n+\t\t    Jack Howarth <howarth@bromo.med.uc.edu>\n \n \t* tree-profile.c (tree_init_ic_make_global_vars): Make static\n \tvariables TLS.\n@@ -746,8 +769,7 @@\n \tUpdate IDO URL.\n \tDocument GNU as requirement.\n \tUpdate configure requirements.\n-\t(Specific, mips-sgi-irix6): Document IRIX 6 < 6.5 obsoletion,\n-\tremoval.\n+\t(Specific, mips-sgi-irix6): Document IRIX 6 < 6.5 obsoletion, removal.\n \tRecomment IRIX 6.5.18+.\n \tDocument IDF/IDL requirement.\n \tDocument GNU as requirement."}, {"sha": "6431d9bfa3225c70ff80b893ce7580647b94aa33", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=014753cc4d898e889ab04dcdb41bb6cc99645e69", "patch": "@@ -17130,20 +17130,22 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n \t\t  : gen_x86_64_shld) (high[0], low[0], operands[2]));\n     }\n \n-  emit_insn ((mode == DImode ? gen_ashlsi3 : gen_ashldi3) (low[0], low[0], operands[2]));\n+  emit_insn ((mode == DImode\n+\t      ? gen_ashlsi3\n+\t      : gen_ashldi3) (low[0], low[0], operands[2]));\n \n   if (TARGET_CMOVE && scratch)\n     {\n       ix86_expand_clear (scratch);\n       emit_insn ((mode == DImode\n-\t\t  ? gen_x86_shift_adj_1\n-\t\t  : gen_x86_64_shift_adj_1) (high[0], low[0], operands[2],\n-\t\t\t\t\t     scratch));\n+\t\t  ? gen_x86_shiftsi_adj_1\n+\t\t  : gen_x86_shiftdi_adj_1) (high[0], low[0], operands[2],\n+\t\t\t\t\t    scratch));\n     }\n   else\n     emit_insn ((mode == DImode\n-\t\t? gen_x86_shift_adj_2\n-\t\t: gen_x86_64_shift_adj_2) (high[0], low[0], operands[2]));\n+\t\t? gen_x86_shiftsi_adj_2\n+\t\t: gen_x86_shiftdi_adj_2) (high[0], low[0], operands[2]));\n }\n \n void\n@@ -17216,9 +17218,9 @@ ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n \t\t      : gen_ashrdi3) (scratch, scratch,\n \t\t\t\t      GEN_INT (single_width - 1)));\n \t  emit_insn ((mode == DImode\n-\t\t      ? gen_x86_shift_adj_1\n-\t\t      : gen_x86_64_shift_adj_1) (low[0], high[0], operands[2],\n-\t\t\t\t\t\t scratch));\n+\t\t      ? gen_x86_shiftsi_adj_1\n+\t\t      : gen_x86_shiftdi_adj_1) (low[0], high[0], operands[2],\n+\t\t\t\t\t\tscratch));\n \t}\n       else\n \temit_insn ((mode == DImode\n@@ -17281,14 +17283,14 @@ ix86_split_lshr (rtx *operands, rtx scratch, enum machine_mode mode)\n \t{\n \t  ix86_expand_clear (scratch);\n \t  emit_insn ((mode == DImode\n-\t\t      ? gen_x86_shift_adj_1\n-\t\t      : gen_x86_64_shift_adj_1) (low[0], high[0], operands[2],\n-\t\t\t\t\t\t scratch));\n+\t\t      ? gen_x86_shiftsi_adj_1\n+\t\t      : gen_x86_shiftdi_adj_1) (low[0], high[0], operands[2],\n+\t\t\t\t\t\tscratch));\n \t}\n       else\n \temit_insn ((mode == DImode\n-\t\t    ? gen_x86_shift_adj_2\n-\t\t    : gen_x86_64_shift_adj_2) (low[0], high[0], operands[2]));\n+\t\t    ? gen_x86_shiftsi_adj_2\n+\t\t    : gen_x86_shiftdi_adj_2) (low[0], high[0], operands[2]));\n     }\n }\n "}, {"sha": "b53c01daddb4f01d95fc8e361b77bc322a6dc1be", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 307, "deletions": 755, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=014753cc4d898e889ab04dcdb41bb6cc99645e69", "patch": "@@ -771,14 +771,18 @@\n (define_mode_iterator SWIM248 [(HI \"TARGET_HIMODE_MATH\")\n \t\t      \t       SI (DI \"TARGET_64BIT\")])\n \n-;; Half mode for double word integer modes.\n-(define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n-\t\t\t    (DI \"TARGET_64BIT\")])\n-\n ;; Double word integer modes.\n+(define_mode_iterator DWI [(DI \"!TARGET_64BIT\")\n+\t\t\t   (TI \"TARGET_64BIT\")])\n+\n+;; Double word integer modes as mode attribute.\n (define_mode_attr DWI [(SI \"DI\") (DI \"TI\")])\n (define_mode_attr dwi [(SI \"di\") (DI \"ti\")])\n \n+;; Half mode for double word integer modes.\n+(define_mode_iterator DWIH [(SI \"!TARGET_64BIT\")\n+\t\t\t    (DI \"TARGET_64BIT\")])\n+\n ;; Instruction suffix for integer modes.\n (define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n@@ -794,6 +798,9 @@\n ;; Immediate operand constraint for double integer modes.\n (define_mode_attr di [(SI \"iF\") (DI \"e\")])\n \n+;; Immediate operand constraint for shifts.\n+(define_mode_attr S [(QI \"I\") (HI \"I\") (SI \"I\") (DI \"J\") (TI \"O\")])\n+\n ;; General operand predicate for integer modes.\n (define_mode_attr general_operand\n \t[(QI \"general_operand\")\n@@ -809,6 +816,29 @@\n \t (SI \"general_operand\")\n \t (DI \"x86_64_szext_general_operand\")])\n \n+;; Operand predicate for shifts.\n+(define_mode_attr shift_operand\n+\t[(QI \"nonimmediate_operand\")\n+\t (HI \"nonimmediate_operand\")\n+\t (SI \"nonimmediate_operand\")\n+\t (DI \"shiftdi_operand\")\n+\t (TI \"register_operand\")])\n+\n+;; Operand predicate for shift argument.\n+(define_mode_attr shift_immediate_operand\n+\t[(QI \"const_1_to_31_operand\")\n+\t (HI \"const_1_to_31_operand\")\n+\t (SI \"const_1_to_31_operand\")\n+\t (DI \"const_1_to_63_operand\")])\n+\n+;; Input operand predicate for arithmetic left shifts.\n+(define_mode_attr ashl_input_operand\n+\t[(QI \"nonimmediate_operand\")\n+\t (HI \"nonimmediate_operand\")\n+\t (SI \"nonimmediate_operand\")\n+\t (DI \"ashldi_input_operand\")\n+\t (TI \"reg_or_pm1_operand\")])\n+\n ;; SSE and x87 SFmode and DFmode floating point modes\n (define_mode_iterator MODEF [SF DF])\n \n@@ -9523,42 +9553,40 @@\n ;; shift pair, instead using moves and sign extension for counts greater\n ;; than 31.\n \n-(define_expand \"ashlti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(ashift:TI (match_operand:TI 1 \"reg_or_pm1_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (ASHIFT, TImode, operands); DONE;\")\n+(define_expand \"ashl<mode>3\"\n+  [(set (match_operand:SDWIM 0 \"<shift_operand>\" \"\")\n+\t(ashift:SDWIM (match_operand:SDWIM 1 \"<ashl_input_operand>\" \"\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (ASHIFT, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*ashlti3_1\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=&r,r\")\n-\t(ashift:TI (match_operand:TI 1 \"reg_or_pm1_operand\" \"n,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"Oc,Oc\")))\n+(define_insn_and_split \"*ashl<mode>3_doubleword\"\n+  [(set (match_operand:DWI 0 \"register_operand\" \"=&r,r\")\n+\t(ashift:DWI (match_operand:DWI 1 \"reg_or_pm1_operand\" \"n,0\")\n+\t\t    (match_operand:QI 2 \"nonmemory_operand\" \"<S>c,<S>c\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n+  \"ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\"\n   \"#\"\n+  \"(optimize && flag_peephole2) ? epilogue_completed : reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashl (operands, NULL_RTX, <MODE>mode); DONE;\"\n   [(set_attr \"type\" \"multi\")])\n \n+;; By default we don't ask for a scratch register, because when DWImode\n+;; values are manipulated, registers are already at a premium.  But if\n+;; we have one handy, we won't turn it away.\n+\n (define_peephole2\n-  [(match_scratch:DI 3 \"r\")\n-   (parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t\t   (ashift:TI (match_operand:TI 1 \"nonmemory_operand\" \"\")\n-\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+  [(match_scratch:DWIH 3 \"r\")\n+   (parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n+\t\t   (ashift:<DWI>\n+\t\t     (match_operand:<DWI> 1 \"nonmemory_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_dup 3)]\n-  \"TARGET_64BIT\"\n-  [(const_int 0)]\n-  \"ix86_split_ashl (operands, operands[3], TImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(ashift:TI (match_operand:TI 1 \"nonmemory_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? epilogue_completed : reload_completed)\"\n+  \"TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_ashl (operands, NULL_RTX, TImode); DONE;\")\n+  \"ix86_split_ashl (operands, operands[3], <DWI>mode); DONE;\")\n \n (define_insn \"x86_64_shld\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"+r*m\")\n@@ -9575,32 +9603,49 @@\n    (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"amdfam10_decode\" \"vector\")])\n \n-(define_expand \"x86_64_shift_adj_1\"\n+(define_insn \"x86_shld\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m\")\n+        (ior:SI (ashift:SI (match_dup 0)\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"Ic\"))\n+\t\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (minus:QI (const_int 32) (match_dup 2)))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"shld{l}\\t{%s2%1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"ishift\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"vector\")])\n+\n+(define_expand \"x86_shift<mode>_adj_1\"\n   [(set (reg:CCZ FLAGS_REG)\n \t(compare:CCZ (and:QI (match_operand:QI 2 \"register_operand\" \"\")\n-\t\t\t     (const_int 64))\n+\t\t\t     (match_dup 4))\n \t\t     (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"\")\n-        (if_then_else:DI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t (match_dup 0)))\n+   (set (match_operand:SWI48 0 \"register_operand\" \"\")\n+        (if_then_else:SWI48 (ne (reg:CCZ FLAGS_REG) (const_int 0))\n+\t\t\t    (match_operand:SWI48 1 \"register_operand\" \"\")\n+\t\t\t    (match_dup 0)))\n    (set (match_dup 1)\n-\t(if_then_else:DI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t (match_operand:DI 3 \"register_operand\" \"r\")\n-\t\t\t (match_dup 1)))]\n-  \"TARGET_64BIT\"\n-  \"\")\n+\t(if_then_else:SWI48 (ne (reg:CCZ FLAGS_REG) (const_int 0))\n+\t\t\t    (match_operand:SWI48 3 \"register_operand\" \"r\")\n+\t\t\t    (match_dup 1)))]\n+  \"TARGET_CMOVE\"\n+  \"operands[4] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\")\n \n-(define_expand \"x86_64_shift_adj_2\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n+(define_expand \"x86_shift<mode>_adj_2\"\n+  [(use (match_operand:SWI48 0 \"register_operand\" \"\"))\n+   (use (match_operand:SWI48 1 \"register_operand\" \"\"))\n    (use (match_operand:QI 2 \"register_operand\" \"\"))]\n-  \"TARGET_64BIT\"\n+  \"\"\n {\n   rtx label = gen_label_rtx ();\n   rtx tmp;\n \n-  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (64)));\n+  emit_insn (gen_testqi_ccz_1 (operands[2],\n+\t\t\t       GEN_INT (GET_MODE_BITSIZE (<MODE>mode))));\n \n   tmp = gen_rtx_REG (CCZmode, FLAGS_REG);\n   tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n@@ -9619,42 +9664,31 @@\n   DONE;\n })\n \n-(define_expand \"ashldi3\"\n-  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"ashldi_input_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (ASHIFT, DImode, operands); DONE;\")\n-\n-(define_insn \"*ashldi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,l\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cJ,M\")))\n+(define_insn \"*ashl<mode>3_1\"\n+  [(set (match_operand:SWI48 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(ashift:SWI48 (match_operand:SWI48 1 \"nonimmediate_operand\" \"0,l\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"c<S>,M\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFT, DImode, operands)\"\n+  \"ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n       gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      return \"add{q}\\t%0, %0\";\n+      return \"add{<imodesuffix>}\\t%0, %0\";\n \n     case TYPE_LEA:\n-      gcc_assert (CONST_INT_P (operands[2]));\n-      gcc_assert ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) <= 3);\n-      operands[1] = gen_rtx_MULT (DImode, operands[1],\n-\t\t\t\t  GEN_INT (1 << INTVAL (operands[2])));\n-      return \"lea{q}\\t{%a1, %0|%0, %a1}\";\n+      return \"#\";\n \n     default:\n       if (REG_P (operands[2]))\n-\treturn \"sal{q}\\t{%b2, %0|%0, %b2}\";\n+\treturn \"sal{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n       else if (operands[2] == const1_rtx\n \t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{q}\\t%0\";\n+\treturn \"sal{<imodesuffix>}\\t%0\";\n       else\n-\treturn \"sal{q}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -9676,61 +9710,40 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"DI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"index_register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"immediate_operand\" \"\")))\n+(define_insn \"*ashlsi3_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI\n+\t  (ashift:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"cI,M\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n-  [(set (match_dup 0)\n-\t(mult:DI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  \"operands[2] = gen_int_mode (1 << INTVAL (operands[2]), DImode);\")\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashldi3_cmp_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun)\n-       || !TARGET_PARTIAL_FLAG_REG_STALL\n-       || (operands[2] == const1_rtx\n-\t   && (TARGET_SHIFT1\n-\t       || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, DImode, operands)\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      return \"add{q}\\t%0, %0\";\n+      return \"add{l}\\t%k0, %k0\";\n+\n+    case TYPE_LEA:\n+      return \"#\";\n \n     default:\n       if (REG_P (operands[2]))\n-\treturn \"sal{q}\\t{%b2, %0|%0, %b2}\";\n+\treturn \"sal{l}\\t{%b2, %k0|%k0, %b2}\";\n       else if (operands[2] == const1_rtx\n \t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{q}\\t%0\";\n+\treturn \"sal{l}\\t%k0\";\n       else\n-\treturn \"sal{q}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{l}\\t{%2, %k0|%k0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n+     (cond [(eq_attr \"alternative\" \"1\")\n+\t      (const_string \"lea\")\n+            (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n+\t\t     (const_int 0))\n \t\t (match_operand 2 \"const1_operand\" \"\"))\n \t      (const_string \"alu\")\n \t   ]\n@@ -9744,38 +9757,30 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"DI\")])\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*ashldi3_cconly_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun)\n-       || !TARGET_PARTIAL_FLAG_REG_STALL\n-       || (operands[2] == const1_rtx\n-\t   && (TARGET_SHIFT1\n-\t       || TARGET_DOUBLE_WITH_ADD)))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, DImode, operands)\"\n+(define_insn \"*ashlhi3_1\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n+\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_PARTIAL_REG_STALL\n+   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      return \"add{q}\\t%0, %0\";\n+      return \"add{w}\\t%0, %0\";\n \n     default:\n       if (REG_P (operands[2]))\n-\treturn \"sal{q}\\t{%b2, %0|%0, %b2}\";\n+\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n       else if (operands[2] == const1_rtx\n \t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{q}\\t%0\";\n+\treturn \"sal{w}\\t%0\";\n       else\n-\treturn \"sal{q}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -9795,133 +9800,32 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*ashldi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=&r,r\")\n-\t(ashift:DI (match_operand:DI 1 \"reg_or_pm1_operand\" \"n,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"Jc,Jc\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-;; By default we don't ask for a scratch register, because when DImode\n-;; values are manipulated, registers are already at a premium.  But if\n-;; we have one handy, we won't turn it away.\n-(define_peephole2\n-  [(match_scratch:SI 3 \"r\")\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (ashift:DI (match_operand:DI 1 \"nonmemory_operand\" \"\")\n-\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_dup 3)]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  [(const_int 0)]\n-  \"ix86_split_ashl (operands, operands[3], DImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"nonmemory_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? epilogue_completed : reload_completed)\"\n-  [(const_int 0)]\n-  \"ix86_split_ashl (operands, NULL_RTX, DImode); DONE;\")\n-\n-(define_insn \"x86_shld\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m\")\n-        (ior:SI (ashift:SI (match_dup 0)\n-\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"Ic\"))\n-\t\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (minus:QI (const_int 32) (match_dup 2)))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"shld{l}\\t{%s2%1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"prefix_0f\" \"1\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")\n-   (set_attr \"amdfam10_decode\" \"vector\")])\n-\n-(define_expand \"x86_shift_adj_1\"\n-  [(set (reg:CCZ FLAGS_REG)\n-\t(compare:CCZ (and:QI (match_operand:QI 2 \"register_operand\" \"\")\n-\t\t\t     (const_int 32))\n-\t\t     (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-        (if_then_else:SI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t (match_dup 0)))\n-   (set (match_dup 1)\n-\t(if_then_else:SI (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t (match_operand:SI 3 \"register_operand\" \"r\")\n-\t\t\t (match_dup 1)))]\n-  \"TARGET_CMOVE\"\n-  \"\")\n-\n-(define_expand \"x86_shift_adj_2\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n-   (use (match_operand:SI 1 \"register_operand\" \"\"))\n-   (use (match_operand:QI 2 \"register_operand\" \"\"))]\n-  \"\"\n-{\n-  rtx label = gen_label_rtx ();\n-  rtx tmp;\n-\n-  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (32)));\n-\n-  tmp = gen_rtx_REG (CCZmode, FLAGS_REG);\n-  tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t      pc_rtx);\n-  tmp = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n-  JUMP_LABEL (tmp) = label;\n-\n-  emit_move_insn (operands[0], operands[1]);\n-  ix86_expand_clear (operands[1]);\n-\n-  emit_label (label);\n-  LABEL_NUSES (label) = 1;\n-\n-  DONE;\n-})\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (ASHIFT, SImode, operands); DONE;\")\n+   (set_attr \"mode\" \"HI\")])\n \n-(define_insn \"*ashlsi3_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,l\")\n+(define_insn \"*ashlhi3_1_lea\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n+\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,l\")\n \t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,M\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n+  \"!TARGET_PARTIAL_REG_STALL\n+   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      gcc_assert (rtx_equal_p (operands[0], operands[1]));\n-      return \"add{l}\\t%0, %0\";\n-\n     case TYPE_LEA:\n       return \"#\";\n+    case TYPE_ALU:\n+      gcc_assert (operands[2] == const1_rtx);\n+      return \"add{w}\\t%0, %0\";\n \n     default:\n       if (REG_P (operands[2]))\n-\treturn \"sal{l}\\t{%b2, %0|%0, %b2}\";\n+\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n       else if (operands[2] == const1_rtx\n \t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{l}\\t%0\";\n+\treturn \"sal{w}\\t%0\";\n       else\n-\treturn \"sal{l}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -9943,452 +9847,48 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n+   (set_attr \"mode\" \"HI,SI\")])\n \n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(ashift (match_operand 1 \"index_register_operand\" \"\")\n-                (match_operand:QI 2 \"const_int_operand\" \"\")))\n+(define_insn \"*ashlqi3_1\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n+\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\n-   && GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\"\n-  [(const_int 0)]\n+  \"TARGET_PARTIAL_REG_STALL\n+   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n {\n-  rtx pat;\n-  enum machine_mode mode = GET_MODE (operands[0]);\n-\n-  if (GET_MODE_SIZE (mode) < 4)\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-  if (mode != Pmode)\n-    operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n-\n-  pat = gen_rtx_MULT (Pmode, operands[1], operands[2]);\n-  if (Pmode != SImode)\n-    pat = gen_rtx_SUBREG (SImode, pat, 0);\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n-  DONE;\n-})\n-\n-;; Rare case of shifting RSP is handled by generating move and shift\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(ashift (match_operand 1 \"register_operand\" \"\")\n-                (match_operand:QI 2 \"const_int_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n-  [(const_int 0)]\n-{\n-  rtx pat, clob;\n-  emit_move_insn (operands[0], operands[1]);\n-  pat = gen_rtx_SET (VOIDmode, operands[0],\n-\t\t     gen_rtx_ASHIFT (GET_MODE (operands[0]),\n-\t\t\t\t     operands[0], operands[2]));\n-  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n-  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, pat, clob)));\n-  DONE;\n-})\n-\n-(define_insn \"*ashlsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:DI (ashift:SI (match_operand:SI 1 \"register_operand\" \"0,l\")\n-\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"cI,M\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{l}\\t%k0, %k0\";\n-\n-    case TYPE_LEA:\n-      return \"#\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{l}\\t{%b2, %k0|%k0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{l}\\t%k0\";\n-      else\n-\treturn \"sal{l}\\t{%2, %k0|%k0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"1\")\n-\t      (const_string \"lea\")\n-            (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t     (const_int 0))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; Convert lea to the lea pattern to avoid flags dependency.\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI (ashift (match_operand 1 \"register_operand\" \"\")\n-\t\t\t\t(match_operand:QI 2 \"const_int_operand\" \"\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed\n-   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n-  [(set (match_dup 0) (zero_extend:DI\n-\t\t\t(subreg:SI (mult:SI (match_dup 1)\n-\t\t\t\t\t    (match_dup 2)) 0)))]\n-{\n-  operands[1] = gen_lowpart (Pmode, operands[1]);\n-  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n-})\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashlsi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:SI (match_dup 1) (match_dup 2)))]\n-   \"(optimize_function_for_size_p (cfun)\n-     || !TARGET_PARTIAL_FLAG_REG_STALL\n-     || (operands[2] == const1_rtx\n-\t && (TARGET_SHIFT1\n-\t     || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{l}\\t%0, %0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{l}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{l}\\t%0\";\n-      else\n-\treturn \"sal{l}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashlsi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& (TARGET_SHIFT1\n-\t    || TARGET_DOUBLE_WITH_ADD)))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{l}\\t%0, %0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{l}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{l}\\t%0\";\n-      else\n-\treturn \"sal{l}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashlsi3_cmp_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ashift:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun)\n-       || !TARGET_PARTIAL_FLAG_REG_STALL\n-       || (operands[2] == const1_rtx\n-\t   && (TARGET_SHIFT1\n-\t       || TARGET_DOUBLE_WITH_ADD)))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{l}\\t%k0, %k0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{l}\\t{%b2, %k0|%k0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{l}\\t%k0\";\n-      else\n-\treturn \"sal{l}\\t{%2, %k0|%k0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t     (const_int 0))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ASHIFT, HImode, operands); DONE;\")\n-\n-(define_insn \"*ashlhi3_1_lea\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,l\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,M\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_LEA:\n-      return \"#\";\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{w}\\t%0, %0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{w}\\t%0\";\n-      else\n-\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"1\")\n-\t      (const_string \"lea\")\n-            (and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"HI,SI\")])\n-\n-(define_insn \"*ashlhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{w}\\t%0, %0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{w}\\t%0\";\n-      else\n-\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"HI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashlhi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:HI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& (TARGET_SHIFT1\n-\t    || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{w}\\t%0, %0\";\n-\n-    default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{w}\\t%0\";\n-      else\n-\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n-\t\t (match_operand 2 \"const1_operand\" \"\"))\n-\t      (const_string \"alu\")\n-\t   ]\n-\t   (const_string \"ishift\")))\n-   (set (attr \"length_immediate\")\n-     (if_then_else\n-       (ior (eq_attr \"type\" \"alu\")\n-\t    (and (eq_attr \"type\" \"ishift\")\n-\t\t (and (match_operand 2 \"const1_operand\" \"\")\n-\t\t      (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n-\t\t\t  (const_int 0)))))\n-       (const_string \"0\")\n-       (const_string \"*\")))\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*ashlhi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashift:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& (TARGET_SHIFT1\n-\t    || TARGET_DOUBLE_WITH_ADD)))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, HImode, operands)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      gcc_assert (operands[2] == const1_rtx);\n-      return \"add{w}\\t%0, %0\";\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_ALU:\n+      gcc_assert (operands[2] == const1_rtx);\n+      if (REG_P (operands[1]) && !ANY_QI_REG_P (operands[1]))\n+        return \"add{l}\\t%k0, %k0\";\n+      else\n+        return \"add{b}\\t%0, %0\";\n \n     default:\n       if (REG_P (operands[2]))\n-\treturn \"sal{w}\\t{%b2, %0|%0, %b2}\";\n+\t{\n+\t  if (get_attr_mode (insn) == MODE_SI)\n+\t    return \"sal{l}\\t{%b2, %k0|%k0, %b2}\";\n+\t  else\n+\t    return \"sal{b}\\t{%b2, %0|%0, %b2}\";\n+\t}\n       else if (operands[2] == const1_rtx\n \t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{w}\\t%0\";\n+\t{\n+\t  if (get_attr_mode (insn) == MODE_SI)\n+\t    return \"sal{l}\\t%0\";\n+\t  else\n+\t    return \"sal{b}\\t%0\";\n+\t}\n       else\n-\treturn \"sal{w}\\t{%2, %0|%0, %2}\";\n+\t{\n+\t  if (get_attr_mode (insn) == MODE_SI)\n+\t    return \"sal{l}\\t{%2, %k0|%k0, %2}\";\n+\t  else\n+\t    return \"sal{b}\\t{%2, %0|%0, %2}\";\n+\t}\n     }\n }\n   [(set (attr \"type\")\n@@ -10408,17 +9908,9 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ASHIFT, QImode, operands); DONE;\")\n+   (set_attr \"mode\" \"QI,SI\")])\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n-\n (define_insn \"*ashlqi3_1_lea\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r,r\")\n \t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0,l\")\n@@ -10484,46 +9976,113 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"QI,SI,SI\")])\n \n-(define_insn \"*ashlqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,r\")\n-\t(ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"index_register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_PARTIAL_REG_STALL\n-   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n+  \"TARGET_64BIT && reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(set (match_dup 0)\n+\t(mult:DI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"operands[2] = gen_int_mode (1 << INTVAL (operands[2]), DImode);\")\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(ashift (match_operand 1 \"index_register_operand\" \"\")\n+                (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\n+   && GET_MODE_SIZE (GET_MODE (operands[0])) <= 4\"\n+  [(const_int 0)]\n+{\n+  rtx pat;\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+\n+  if (GET_MODE_SIZE (mode) < 4)\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+  if (mode != Pmode)\n+    operands[1] = gen_lowpart (Pmode, operands[1]);\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n+\n+  pat = gen_rtx_MULT (Pmode, operands[1], operands[2]);\n+  if (Pmode != SImode)\n+    pat = gen_rtx_SUBREG (SImode, pat, 0);\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], pat));\n+  DONE;\n+})\n+\n+;; Rare case of shifting RSP is handled by generating move and shift\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(ashift (match_operand 1 \"register_operand\" \"\")\n+                (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(const_int 0)]\n+{\n+  rtx pat, clob;\n+  emit_move_insn (operands[0], operands[1]);\n+  pat = gen_rtx_SET (VOIDmode, operands[0],\n+\t\t     gen_rtx_ASHIFT (GET_MODE (operands[0]),\n+\t\t\t\t     operands[0], operands[2]));\n+  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, pat, clob)));\n+  DONE;\n+})\n+\n+;; Convert lea to the lea pattern to avoid flags dependency.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extend:DI\n+\t  (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && reload_completed\n+   && true_regnum (operands[0]) != true_regnum (operands[1])\"\n+  [(set (match_dup 0)\n+\t(zero_extend:DI (subreg:SI (mult:SI (match_dup 1) (match_dup 2)) 0)))]\n+{\n+  operands[1] = gen_lowpart (Pmode, operands[1]);\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), Pmode);\n+})\n+\n+;; This pattern can't accept a variable shift count, since shifts by\n+;; zero don't affect the flags.  We assume that shifts by constant\n+;; zero are optimized away.\n+(define_insn \"*ashl<mode>3_cmp\"\n+  [(set (reg FLAGS_REG)\n+\t(compare\n+\t  (ashift:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n+\t  (const_int 0)))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(ashift:SWI (match_dup 1) (match_dup 2)))]\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_FLAG_REG_STALL\n+    || (operands[2] == const1_rtx\n+\t&& (TARGET_SHIFT1\n+\t    || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\n+   && ix86_match_ccmode (insn, CCGOCmode)\n+   && ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      if (REG_P (operands[1]) && !ANY_QI_REG_P (operands[1]))\n-        return \"add{l}\\t%k0, %k0\";\n-      else\n-        return \"add{b}\\t%0, %0\";\n+      return \"add{<imodesuffix>}\\t%0, %0\";\n \n     default:\n-      if (REG_P (operands[2]))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_SI)\n-\t    return \"sal{l}\\t{%b2, %k0|%k0, %b2}\";\n-\t  else\n-\t    return \"sal{b}\\t{%b2, %0|%0, %b2}\";\n-\t}\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_SI)\n-\t    return \"sal{l}\\t%0\";\n-\t  else\n-\t    return \"sal{b}\\t%0\";\n-\t}\n+      if (operands[2] == const1_rtx\n+\t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+\treturn \"sal{<imodesuffix>}\\t%0\";\n       else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_SI)\n-\t    return \"sal{l}\\t{%2, %k0|%k0, %2}\";\n-\t  else\n-\t    return \"sal{b}\\t{%2, %0|%0, %2}\";\n-\t}\n+\treturn \"sal{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -10543,47 +10102,42 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI,SI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashlqi3_cmp\"\n+(define_insn \"*ashlsi3_cmp_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n+\t  (ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n \t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(ashift:QI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun)\n-    || !TARGET_PARTIAL_FLAG_REG_STALL\n-    || (operands[2] == const1_rtx\n-\t&& (TARGET_SHIFT1\n-\t    || (TARGET_DOUBLE_WITH_ADD && REG_P (operands[0])))))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (ashift:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT\n+   && (optimize_function_for_size_p (cfun)\n+       || !TARGET_PARTIAL_FLAG_REG_STALL\n+       || (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1\n+\t       || TARGET_DOUBLE_WITH_ADD)))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n+   && ix86_binary_operator_ok (ASHIFT, SImode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      return \"add{b}\\t%0, %0\";\n+      return \"add{l}\\t%k0, %k0\";\n \n     default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{b}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{b}\\t%0\";\n+      if (operands[2] == const1_rtx\n+\t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+\treturn \"sal{l}\\t%k0\";\n       else\n-\treturn \"sal{b}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{l}\\t{%2, %k0|%k0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(and (and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n-\t\t          (const_int 0))\n-\t\t      (match_operand 0 \"register_operand\" \"\"))\n+     (cond [(and (ne (symbol_ref \"TARGET_DOUBLE_WITH_ADD\")\n+\t\t     (const_int 0))\n \t\t (match_operand 2 \"const1_operand\" \"\"))\n \t      (const_string \"alu\")\n \t   ]\n@@ -10597,37 +10151,35 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*ashlqi3_cconly\"\n+(define_insn \"*ashl<mode>3_cconly\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (ashift:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n+\t  (ashift:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n+   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n   \"(optimize_function_for_size_p (cfun)\n     || !TARGET_PARTIAL_FLAG_REG_STALL\n     || (operands[2] == const1_rtx\n \t&& (TARGET_SHIFT1\n \t    || TARGET_DOUBLE_WITH_ADD)))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFT, QImode, operands)\"\n+   && ix86_binary_operator_ok (ASHIFT, <MODE>mode, operands)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n       gcc_assert (operands[2] == const1_rtx);\n-      return \"add{b}\\t%0, %0\";\n+      return \"add{<imodesuffix>}\\t%0, %0\";\n \n     default:\n-      if (REG_P (operands[2]))\n-\treturn \"sal{b}\\t{%b2, %0|%0, %b2}\";\n-      else if (operands[2] == const1_rtx\n-\t       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n-\treturn \"sal{b}\\t%0\";\n+      if (operands[2] == const1_rtx\n+\t  && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+\treturn \"sal{<imodesuffix>}\\t%0\";\n       else\n-\treturn \"sal{b}\\t{%2, %0|%0, %2}\";\n+\treturn \"sal{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n   [(set (attr \"type\")\n@@ -10647,7 +10199,7 @@\n \t\t\t  (const_int 0)))))\n        (const_string \"0\")\n        (const_string \"*\")))\n-   (set_attr \"mode\" \"QI\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; See comment above `ashldi3' about how this works.\n "}, {"sha": "51895eeccd3d044fe23c79412aa8784acc706113", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014753cc4d898e889ab04dcdb41bb6cc99645e69/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=014753cc4d898e889ab04dcdb41bb6cc99645e69", "patch": "@@ -308,7 +308,7 @@\n \t* gcc.c-torture/execute/pr43629.c: New testcase.\n \n 2010-04-01  Janne Blomqvist  <jb@gcc.gnu.org>\n-            Dominique d'Humieres  <dominiq@lps.ens.fr>\n+\t    Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR libfortran/43605\n \t* gfortran.dg/ftell_3.f90: Enhance test case by reading more."}]}