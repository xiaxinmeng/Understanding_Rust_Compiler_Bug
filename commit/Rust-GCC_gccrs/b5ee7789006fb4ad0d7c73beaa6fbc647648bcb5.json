{"sha": "b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlZTc3ODkwMDZmYjRhZDBkN2M3M2JlYWE2ZmJjNjQ3NjQ4YmNiNQ==", "commit": {"author": {"name": "Catherine Moore", "email": "clm@cygnus.com", "date": "1999-11-02T15:48:26Z"}, "committer": {"name": "Catherine Moore", "email": "clm@gcc.gnu.org", "date": "1999-11-02T15:48:26Z"}, "message": "Makefile.in (genattrtab): Don't use (HOST_RTLANAL).\n\n        * Makefile.in (genattrtab): Don't use (HOST_RTLANAL).\n        * rtl.h (rtx_equal_p): Move prototype.\n        * rtl.c (rtx_equal_function_value_matters): Move from\n        rtlanal.c\n        (rtx_equal_p): Likewise.\n        * rtlanal.c (rtx_equal_function_value_matters): Delete.\n        (rtx_equal_p): Likewise.\n\nFrom-SVN: r30350", "tree": {"sha": "f83fe0290e48a0e59e062186a312f81a60d3c0dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f83fe0290e48a0e59e062186a312f81a60d3c0dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/comments", "author": null, "committer": null, "parents": [{"sha": "96e9c98d59cc40bbb51480fb408fb63919fc55c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e9c98d59cc40bbb51480fb408fb63919fc55c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e9c98d59cc40bbb51480fb408fb63919fc55c7"}], "stats": {"total": 233, "additions": 121, "deletions": 112}, "files": [{"sha": "44309c13919208a917695f3bc8e271e5e5466dd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "patch": "@@ -1,3 +1,13 @@\n+Tue Nov  2 09:43:00 1999   Catherine Moore  <clm@cygnus.com>\n+\n+        * Makefile.in (genattrtab): Don't use (HOST_RTLANAL).\n+        * rtl.h (rtx_equal_p): Move prototype.\n+        * rtl.c (rtx_equal_function_value_matters): Move from \n+        rtlanal.c\n+        (rtx_equal_p): Likewise.\n+        * rtlanal.c (rtx_equal_function_value_matters): Delete.\n+        (rtx_equal_p): Likewise.\n+\n Mon Nov  1 23:21:17 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* libgcc2.c (__do_global_dtors): Only do EH frame stuff if"}, {"sha": "f92b4d4d91f6720cdc98a801115ede7d261e931a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "patch": "@@ -571,7 +571,6 @@ HOST_LIBS = $(USE_HOST_OBSTACK) $(USE_HOST_ALLOCA) $(USE_HOST_MALLOC)  \\\n \t    $(HOST_CLIB)\n \n HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o $(HOST_PREFIX)ggc-none.o\n-HOST_RTLANAL = $(HOST_PREFIX)rtlanal.o\n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n HOST_ERRORS = $(HOST_PREFIX)errors.o\n \n@@ -1844,9 +1843,9 @@ genattr : genattr.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n genattr.o : genattr.c $(RTL_H) $(build_xm_file) system.h errors.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattr.c\n \n-genattrtab : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANAL) $(HOST_LIBDEPS)\n+genattrtab : genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBDEPS)\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ \\\n-\t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_RTLANAL) $(HOST_LIBS)\n+\t genattrtab.o $(HOST_RTL) $(HOST_PRINT) $(HOST_ERRORS) $(HOST_LIBS)\n \n genattrtab.o : genattrtab.c $(RTL_H)  $(build_xm_file) system.h errors.h ggc.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/genattrtab.c"}, {"sha": "aa3e7407d502ffbb6a8bed81080587e310edddee", "filename": "gcc/rtl.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "patch": "@@ -582,6 +582,114 @@ shallow_copy_rtx (orig)\n   return copy;\n }\n \f\n+/* This is 1 until after the rtl generation pass.  */\n+int rtx_equal_function_value_matters;\n+\f\n+/* Return 1 if X and Y are identical-looking rtx's.\n+   This is the Lisp function EQUAL for rtx arguments.  */\n+\n+int\n+rtx_equal_p (x, y)\n+     rtx x, y;\n+{\n+  register int i;\n+  register int j;\n+  register enum rtx_code code;\n+  register const char *fmt;\n+\n+  if (x == y)\n+    return 1;\n+  if (x == 0 || y == 0)\n+    return 0;\n+\n+  code = GET_CODE (x);\n+  /* Rtx's of different codes cannot be equal.  */\n+  if (code != GET_CODE (y))\n+    return 0;\n+\n+  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n+     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n+\n+  if (GET_MODE (x) != GET_MODE (y))\n+    return 0;\n+\n+  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n+\n+  if (code == REG)\n+    /* Until rtl generation is complete, don't consider a reference to the\n+       return register of the current function the same as the return from a\n+       called function.  This eases the job of function integration.  Once the\n+       distinction is no longer needed, they can be considered equivalent.  */\n+    return (REGNO (x) == REGNO (y)\n+\t    && (! rtx_equal_function_value_matters\n+\t\t|| REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n+  else if (code == LABEL_REF)\n+    return XEXP (x, 0) == XEXP (y, 0);\n+  else if (code == SYMBOL_REF)\n+    return XSTR (x, 0) == XSTR (y, 0);\n+  else if (code == SCRATCH || code == CONST_DOUBLE)\n+    return 0;\n+\n+  /* Compare the elements.  If any pair of corresponding elements\n+     fail to match, return 0 for the whole things.  */\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n+\t  if (XINT (x, i) != XINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  /* Two vectors must have the same length.  */\n+\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n+\t    return 0;\n+\n+\t  /* And the corresponding elements must match.  */\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    if (rtx_equal_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n+\t      return 0;\n+\t  break;\n+\n+\tcase 'e':\n+\t  if (rtx_equal_p (XEXP (x, i), XEXP (y, i)) == 0)\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'S':\n+\tcase 's':\n+\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n+\t    return 0;\n+\t  break;\n+\n+\tcase 'u':\n+\t  /* These are just backpointers, so they don't matter.  */\n+\t  break;\n+\n+\tcase '0':\n+\tcase 't':\n+\t  break;\n+\n+\t  /* It is believed that rtx's at this level will never\n+\t     contain anything but integers and other rtx's,\n+\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return 1;\n+}\n+\f\n /* Subroutines of read_rtx.  */\n \n /* The current line number for the file.  */"}, {"sha": "25c064bedc4f3db81f235b391d2ef0d171ffb108", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "patch": "@@ -973,6 +973,7 @@ extern rtx copy_rtx\t\t\tPROTO((rtx));\n extern rtx copy_rtx_if_shared\t\tPROTO((rtx));\n extern rtx copy_most_rtx\t\tPROTO((rtx, rtx));\n extern rtx shallow_copy_rtx\t\tPROTO((rtx));\n+extern int rtx_equal_p                  PROTO((rtx, rtx));\n extern rtvec gen_rtvec_v\t\tPROTO((int, rtx *));\n extern rtx gen_reg_rtx\t\t\tPROTO((enum machine_mode));\n extern rtx gen_label_rtx\t\tPROTO((void));\n@@ -1109,7 +1110,6 @@ extern int refers_to_regno_p\t\tPROTO((int, int, rtx, rtx *));\n extern int reg_overlap_mentioned_p\tPROTO((rtx, rtx));\n extern void note_stores\t\t\tPROTO((rtx, void (*)(rtx, rtx, void *), void *));\n extern rtx reg_set_last\t\t\tPROTO((rtx, rtx));\n-extern int rtx_equal_p\t\t\tPROTO((rtx, rtx));\n extern int dead_or_set_p\t\tPROTO((rtx, rtx));\n extern int dead_or_set_regno_p\t\tPROTO((rtx, int));\n extern rtx find_reg_note\t\tPROTO((rtx, enum reg_note, rtx));"}, {"sha": "838ca9daa0cee41aec2ef1d700de29489e5d9e69", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b5ee7789006fb4ad0d7c73beaa6fbc647648bcb5", "patch": "@@ -1069,114 +1069,6 @@ reg_set_last (x, insn)\n   return 0;\n }\n \f\n-/* This is 1 until after the rtl generation pass.  */\n-int rtx_equal_function_value_matters;\n-\n-/* Return 1 if X and Y are identical-looking rtx's.\n-   This is the Lisp function EQUAL for rtx arguments.  */\n-\n-int\n-rtx_equal_p (x, y)\n-     rtx x, y;\n-{\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n-\n-  if (x == y)\n-    return 1;\n-  if (x == 0 || y == 0)\n-    return 0;\n-\n-  code = GET_CODE (x);\n-  /* Rtx's of different codes cannot be equal.  */\n-  if (code != GET_CODE (y))\n-    return 0;\n-\n-  /* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.\n-     (REG:SI x) and (REG:HI x) are NOT equivalent.  */\n-\n-  if (GET_MODE (x) != GET_MODE (y))\n-    return 0;\n-\n-  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n-\n-  if (code == REG)\n-    /* Until rtl generation is complete, don't consider a reference to the\n-       return register of the current function the same as the return from a\n-       called function.  This eases the job of function integration.  Once the\n-       distinction is no longer needed, they can be considered equivalent.  */\n-    return (REGNO (x) == REGNO (y)\n-\t    && (! rtx_equal_function_value_matters\n-\t\t|| REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n-  else if (code == LABEL_REF)\n-    return XEXP (x, 0) == XEXP (y, 0);\n-  else if (code == SYMBOL_REF)\n-    return XSTR (x, 0) == XSTR (y, 0);\n-  else if (code == SCRATCH || code == CONST_DOUBLE)\n-    return 0;\n-\n-  /* Compare the elements.  If any pair of corresponding elements\n-     fail to match, return 0 for the whole things.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'n':\n-\tcase 'i':\n-\t  if (XINT (x, i) != XINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'V':\n-\tcase 'E':\n-\t  /* Two vectors must have the same length.  */\n-\t  if (XVECLEN (x, i) != XVECLEN (y, i))\n-\t    return 0;\n-\n-\t  /* And the corresponding elements must match.  */\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (rtx_equal_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n-\t      return 0;\n-\t  break;\n-\n-\tcase 'e':\n-\t  if (rtx_equal_p (XEXP (x, i), XEXP (y, i)) == 0)\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'S':\n-\tcase 's':\n-\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\n-\tcase '0':\n-\tcase 't':\n-\t  break;\n-\n-\t  /* It is believed that rtx's at this level will never\n-\t     contain anything but integers and other rtx's,\n-\t     except for within LABEL_REFs and SYMBOL_REFs.  */\n-\tdefault:\n-\t  abort ();\n-\t}\n-    }\n-  return 1;\n-}\n-\f\n /* Call FUN on each register or MEM that is stored into or clobbered by X.\n    (X would be the pattern of an insn).\n    FUN receives two arguments:"}]}