{"sha": "c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0MTIxNDhmNzZjNzAwNmYyYWIyMzVkOWY1MGNlOGJkNGM5N2EyNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-11-08T20:50:37Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-11-08T20:50:37Z"}, "message": "c-parser.c (c_parser_translation_unit): Use location in error.\n\ngcc\n\t* c-parser.c (c_parser_translation_unit): Use location in error.\n\t(c_parser_external_declaration): Likewise.\n\t(c_parser_declaration_or_fndef): Likewise.\n\t(c_parser_enum_specifier): Likewise.\n\t(c_parser_struct_or_union_specifier): Likewise.\n\t(c_parser_struct_declaration): Likewise.\n\t(c_parser_typeof_specifier): Likewise.\n\t(c_parser_parms_list_declarator): Likewise.\n\t(c_parser_asm_string_literal): Likewise.\n\t(c_parser_braced_init): Likewise.\n\t(c_parser_initelt): Likewise.\n\t(c_parser_compound_statement_nostart): Likewise.\n\t(c_parser_statement_after_labels): Likewise.\n\t(c_parser_do_statement): Likewise.\n\t(c_parser_asm_statement): Likewise.\n\t(c_parser_conditional_expression): Likewise.\n\t(c_parser_unary_expression): Likewise.\n\t(c_parser_sizeof_expression): Likewise.\n\t(c_parser_postfix_expression): Likewise.\n\t(c_parser_postfix_expression_after_paren_type): Likewise.\n\t(c_parser_objc_class_instance_variables): Likewise.\n\t(c_parser_objc_method_definition): Likewise.\n\t(c_parser_objc_methodprotolist): Likewise.\n\t(c_parser_pragma): Likewise.\n\t(c_parser_omp_clause_num_threads): Likewise.\n\t(c_parser_omp_clause_schedule): Likewise.\n\t(c_parser_omp_all_clauses): Likewise.\n\t(c_parser_omp_sections_scope): Likewise.\n\t(c_parser_label): Use location of label, not colon.\ngcc/testsuite\n\t* gcc.dg/empty-source-3.c: Update warning location.\n\t* gcc.dg/gomp/barrier-2.c: Likewise.\n\t* gcc.dg/label-decl-3.c: Likewise.\n\t* gcc.dg/label-decl-2.c: Likewise.\n\t* gcc.dg/empty-source-2.c: Likewise.\n\nFrom-SVN: r130025", "tree": {"sha": "0cb31b3af8f40dc9a2dc673b1f35cd767a63e495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cb31b3af8f40dc9a2dc673b1f35cd767a63e495"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/comments", "author": null, "committer": null, "parents": [{"sha": "349fcd78173b14a559f97713e8e9e2419b96ffbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/349fcd78173b14a559f97713e8e9e2419b96ffbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/349fcd78173b14a559f97713e8e9e2419b96ffbc"}], "stats": {"total": 217, "additions": 159, "deletions": 58}, "files": [{"sha": "a2ccc8a8a5b7206c3cbf2557f4fc778cf7a71e5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -1,3 +1,35 @@\n+2007-11-08  Tom Tromey  <tromey@redhat.com>\n+\n+\t* c-parser.c (c_parser_translation_unit): Use location in error.\n+\t(c_parser_external_declaration): Likewise.\n+\t(c_parser_declaration_or_fndef): Likewise.\n+\t(c_parser_enum_specifier): Likewise.\n+\t(c_parser_struct_or_union_specifier): Likewise.\n+\t(c_parser_struct_declaration): Likewise.\n+\t(c_parser_typeof_specifier): Likewise.\n+\t(c_parser_parms_list_declarator): Likewise.\n+\t(c_parser_asm_string_literal): Likewise.\n+\t(c_parser_braced_init): Likewise.\n+\t(c_parser_initelt): Likewise.\n+\t(c_parser_compound_statement_nostart): Likewise.\n+\t(c_parser_statement_after_labels): Likewise.\n+\t(c_parser_do_statement): Likewise.\n+\t(c_parser_asm_statement): Likewise.\n+\t(c_parser_conditional_expression): Likewise.\n+\t(c_parser_unary_expression): Likewise.\n+\t(c_parser_sizeof_expression): Likewise.\n+\t(c_parser_postfix_expression): Likewise.\n+\t(c_parser_postfix_expression_after_paren_type): Likewise.\n+\t(c_parser_objc_class_instance_variables): Likewise.\n+\t(c_parser_objc_method_definition): Likewise.\n+\t(c_parser_objc_methodprotolist): Likewise.\n+\t(c_parser_pragma): Likewise.\n+\t(c_parser_omp_clause_num_threads): Likewise.\n+\t(c_parser_omp_clause_schedule): Likewise.\n+\t(c_parser_omp_all_clauses): Likewise.\n+\t(c_parser_omp_sections_scope): Likewise.\n+\t(c_parser_label): Use location of label, not colon.\n+\n 2007-11-08  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/33774"}, {"sha": "32776dddab4f5c11a4b551ad52df1c2d6b0fb91f", "filename": "gcc/c-parser.c", "status": "modified", "additions": 113, "deletions": 52, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -1067,7 +1067,8 @@ c_parser_translation_unit (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_EOF))\n     {\n       if (pedantic)\n-\tpedwarn (\"ISO C forbids an empty source file\");\n+\tpedwarn (\"%HISO C forbids an empty source file\",\n+\t\t &c_parser_peek_token (parser)->location);\n     }\n   else\n     {\n@@ -1152,7 +1153,8 @@ c_parser_external_declaration (c_parser *parser)\n       break;\n     case CPP_SEMICOLON:\n       if (pedantic)\n-\tpedwarn (\"ISO C does not allow extra %<;%> outside of a function\");\n+\tpedwarn (\"%HISO C does not allow extra %<;%> outside of a function\",\n+\t\t &c_parser_peek_token (parser)->location);\n       c_parser_consume_token (parser);\n       break;\n     case CPP_PRAGMA:\n@@ -1243,6 +1245,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n   tree prefix_attrs;\n   tree all_prefix_attrs;\n   bool diagnosed_no_specs = false;\n+  location_t here = c_parser_peek_token (parser)->location;\n \n   specs = build_null_declspecs ();\n   c_parser_declspecs (parser, specs, true, true, start_attr_ok);\n@@ -1265,7 +1268,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       else\n \t{\n \t  shadow_tag_warned (specs, 1);\n-\t  pedwarn (\"empty declaration\");\n+\t  pedwarn (\"%Hempty declaration\", &here);\n \t}\n       c_parser_consume_token (parser);\n       return;\n@@ -1301,7 +1304,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t  if (!diagnosed_no_specs && !specs->declspecs_seen_p)\n \t    {\n \t      diagnosed_no_specs = true;\n-\t      pedwarn (\"data definition has no type or storage class\");\n+\t      pedwarn (\"%Hdata definition has no type or storage class\",\n+\t\t       &here);\n \t    }\n \t  /* Having seen a data definition, there cannot now be a\n \t     function definition.  */\n@@ -1371,7 +1375,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n       if (nested)\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C forbids nested functions\");\n+\t    pedwarn (\"%HISO C forbids nested functions\", &here);\n \t  push_function_context ();\n \t}\n       if (!start_function (specs, declarator, all_prefix_attrs))\n@@ -1704,6 +1708,7 @@ c_parser_enum_specifier (c_parser *parser)\n   struct c_typespec ret;\n   tree attrs;\n   tree ident = NULL_TREE;\n+  location_t ident_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n   c_parser_consume_token (parser);\n   attrs = c_parser_attributes (parser);\n@@ -1712,6 +1717,7 @@ c_parser_enum_specifier (c_parser *parser)\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       ident = c_parser_peek_token (parser)->value;\n+      ident_loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n     }\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n@@ -1731,6 +1737,7 @@ c_parser_enum_specifier (c_parser *parser)\n \t  tree enum_decl;\n \t  bool seen_comma;\n \t  c_token *token;\n+\t  location_t comma_loc;\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t    {\n \t      c_parser_error (parser, \"expected identifier\");\n@@ -1756,13 +1763,14 @@ c_parser_enum_specifier (c_parser *parser)\n \t  seen_comma = false;\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n+\t      comma_loc = c_parser_peek_token (parser)->location;\n \t      seen_comma = true;\n \t      c_parser_consume_token (parser);\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n \t    {\n \t      if (seen_comma && pedantic && !flag_isoc99)\n-\t\tpedwarn (\"comma at end of enumerator list\");\n+\t\tpedwarn (\"%Hcomma at end of enumerator list\", &comma_loc);\n \t      c_parser_consume_token (parser);\n \t      break;\n \t    }\n@@ -1791,7 +1799,11 @@ c_parser_enum_specifier (c_parser *parser)\n   /* In ISO C, enumerated types can be referred to only if already\n      defined.  */\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n-    pedwarn (\"ISO C forbids forward references to %<enum%> types\");\n+    {\n+      gcc_assert (ident);\n+      pedwarn (\"%HISO C forbids forward references to %<enum%> types\",\n+\t       &ident_loc);\n+    }\n   return ret;\n }\n \n@@ -1915,7 +1927,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n \t      if (pedantic)\n-\t\tpedwarn (\"extra semicolon in struct or union specified\");\n+\t\tpedwarn (\"%Hextra semicolon in struct or union specified\",\n+\t\t\t &c_parser_peek_token (parser)->location);\n \t      c_parser_consume_token (parser);\n \t      continue;\n \t    }\n@@ -1943,7 +1956,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  else\n \t    {\n \t      if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n-\t\tpedwarn (\"no semicolon at end of struct or union\");\n+\t\tpedwarn (\"%Hno semicolon at end of struct or union\",\n+\t\t\t &c_parser_peek_token (parser)->location);\n \t      else\n \t\t{\n \t\t  c_parser_error (parser, \"expected %<;%>\");\n@@ -2007,6 +2021,7 @@ c_parser_struct_declaration (c_parser *parser)\n   tree prefix_attrs;\n   tree all_prefix_attrs;\n   tree decls;\n+  location_t decl_loc;\n   if (c_parser_next_token_is_keyword (parser, RID_EXTENSION))\n     {\n       int ext;\n@@ -2018,6 +2033,7 @@ c_parser_struct_declaration (c_parser *parser)\n       return decl;\n     }\n   specs = build_null_declspecs ();\n+  decl_loc = c_parser_peek_token (parser)->location;\n   c_parser_declspecs (parser, specs, false, true, true);\n   if (parser->error)\n     return NULL_TREE;\n@@ -2033,7 +2049,8 @@ c_parser_struct_declaration (c_parser *parser)\n       if (!specs->type_seen_p)\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C forbids member declarations with no members\");\n+\t    pedwarn (\"%HISO C forbids member declarations with no members\",\n+\t\t     &decl_loc);\n \t  shadow_tag_warned (specs, pedantic);\n \t  ret = NULL_TREE;\n \t}\n@@ -2158,12 +2175,13 @@ c_parser_typeof_specifier (c_parser *parser)\n   else\n     {\n       bool was_vm;\n+      location_t here = c_parser_peek_token (parser)->location;\n       struct c_expr expr = c_parser_expression (parser);\n       skip_evaluation--;\n       in_typeof--;\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n-\terror (\"%<typeof%> applied to a bit-field\");\n+\terror (\"%H%<typeof%> applied to a bit-field\", &here);\n       ret.spec = TREE_TYPE (expr.value);\n       was_vm = variably_modified_type_p (ret.spec, NULL_TREE);\n       /* This should be returned with the type so that when the type\n@@ -2601,7 +2619,8 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs)\n       ret->had_vla_unspec = 0;\n       /* Suppress -Wold-style-definition for this case.  */\n       ret->types = error_mark_node;\n-      error (\"ISO C requires a named argument before %<...%>\");\n+      error (\"%HISO C requires a named argument before %<...%>\",\n+\t     &c_parser_peek_token (parser)->location);\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n@@ -2757,7 +2776,8 @@ c_parser_asm_string_literal (c_parser *parser)\n     }\n   else if (c_parser_next_token_is (parser, CPP_WSTRING))\n     {\n-      error (\"wide string literal in %<asm%>\");\n+      error (\"%Hwide string literal in %<asm%>\",\n+\t     &c_parser_peek_token (parser)->location);\n       str = build_string (1, \"\");\n       c_parser_consume_token (parser);\n     }\n@@ -3074,6 +3094,7 @@ c_parser_initializer (c_parser *parser)\n static struct c_expr\n c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n {\n+  location_t brace_loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));\n   c_parser_consume_token (parser);\n   if (nested_p)\n@@ -3083,7 +3104,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p)\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n       if (pedantic)\n-\tpedwarn (\"ISO C forbids empty initializer braces\");\n+\tpedwarn (\"%HISO C forbids empty initializer braces\", &brace_loc);\n     }\n   else\n     {\n@@ -3128,7 +3149,11 @@ c_parser_initelt (c_parser *parser)\n       /* Old-style structure member designator.  */\n       set_init_label (c_parser_peek_token (parser)->value);\n       if (pedantic)\n-\tpedwarn (\"obsolete use of designated initializer with %<:%>\");\n+\t{\n+\t  /* Use the colon as the error location.  */\n+\t  pedwarn (\"%Hobsolete use of designated initializer with %<:%>\",\n+\t\t   &c_parser_peek_2nd_token (parser)->location);\n+\t}\n       c_parser_consume_token (parser);\n       c_parser_consume_token (parser);\n     }\n@@ -3137,10 +3162,14 @@ c_parser_initelt (c_parser *parser)\n       /* des_seen is 0 if there have been no designators, 1 if there\n \t has been a single array designator and 2 otherwise.  */\n       int des_seen = 0;\n+      /* Location of a designator.  */\n+      location_t des_loc;\n       while (c_parser_next_token_is (parser, CPP_OPEN_SQUARE)\n \t     || c_parser_next_token_is (parser, CPP_DOT))\n \t{\n \t  int des_prev = des_seen;\n+\t  if (!des_seen)\n+\t    des_loc = c_parser_peek_token (parser)->location;\n \t  if (des_seen < 2)\n \t    des_seen++;\n \t  if (c_parser_next_token_is (parser, CPP_DOT))\n@@ -3166,6 +3195,7 @@ c_parser_initelt (c_parser *parser)\n \t  else\n \t    {\n \t      tree first, second;\n+\t      location_t ellipsis_loc;\n \t      /* ??? Following the old parser, [ objc-receiver\n \t\t objc-message-args ] is accepted as an initializer,\n \t\t being distinguished from a designator by what follows\n@@ -3241,6 +3271,7 @@ c_parser_initelt (c_parser *parser)\n \t    array_desig_after_first:\n \t      if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t\t{\n+\t\t  ellipsis_loc = c_parser_peek_token (parser)->location;\n \t\t  c_parser_consume_token (parser);\n \t\t  second = c_parser_expr_no_commas (parser, NULL).value;\n \t\t}\n@@ -3251,8 +3282,8 @@ c_parser_initelt (c_parser *parser)\n \t\t  c_parser_consume_token (parser);\n \t\t  set_init_index (first, second);\n \t\t  if (pedantic && second)\n-\t\t    pedwarn (\"ISO C forbids specifying range of \"\n-\t\t\t     \"elements to initialize\");\n+\t\t    pedwarn (\"%HISO C forbids specifying range of \"\n+\t\t\t     \"elements to initialize\", &ellipsis_loc);\n \t\t}\n \t      else\n \t\tc_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n@@ -3264,16 +3295,18 @@ c_parser_initelt (c_parser *parser)\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n \t      if (pedantic && !flag_isoc99)\n-\t\tpedwarn (\"ISO C90 forbids specifying subobject to initialize\");\n+\t\tpedwarn (\"%HISO C90 forbids specifying subobject \"\n+\t\t\t \"to initialize\", &des_loc);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      if (des_seen == 1)\n \t\t{\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"obsolete use of designated initializer \"\n-\t\t\t     \"without %<=%>\");\n+\t\t    pedwarn (\"%Hobsolete use of designated initializer \"\n+\t\t\t     \"without %<=%>\",\n+\t\t\t     &c_parser_peek_token (parser)->location);\n \t\t}\n \t      else\n \t\t{\n@@ -3388,13 +3421,15 @@ c_parser_compound_statement_nostart (c_parser *parser)\n {\n   bool last_stmt = false;\n   bool last_label = false;\n+  location_t label_loc;\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n       c_parser_consume_token (parser);\n       return;\n     }\n   if (c_parser_next_token_is_keyword (parser, RID_LABEL))\n     {\n+      location_t err_loc = c_parser_peek_token (parser)->location;\n       /* Read zero or more forward-declarations for labels that nested\n \t functions can jump to.  */\n       while (c_parser_next_token_is_keyword (parser, RID_LABEL))\n@@ -3422,11 +3457,8 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t    }\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n-      /* ??? Locating this diagnostic on the token after the\n-\t declarations end follows the old parser, but it might be\n-\t better to locate it where the declarations start instead.  */\n       if (pedantic)\n-\tpedwarn (\"ISO C forbids label declarations\");\n+\tpedwarn (\"%HISO C forbids label declarations\", &err_loc);\n     }\n   /* We must now have at least one statement, label or declaration.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -3443,6 +3475,10 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  || (c_parser_next_token_is (parser, CPP_NAME)\n \t      && c_parser_peek_2nd_token (parser)->type == CPP_COLON))\n \t{\n+\t  if (c_parser_next_token_is_keyword (parser, RID_CASE))\n+\t    label_loc = c_parser_peek_2nd_token (parser)->location;\n+\t  else\n+\t    label_loc = c_parser_peek_token (parser)->location;\n \t  last_label = true;\n \t  last_stmt = false;\n \t  c_parser_label (parser);\n@@ -3516,7 +3552,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n       parser->error = false;\n     }\n   if (last_label)\n-    error (\"label at end of compound statement\");\n+    error (\"%Hlabel at end of compound statement\", &label_loc);\n   c_parser_consume_token (parser);\n }\n \n@@ -3571,12 +3607,11 @@ c_parser_label (c_parser *parser)\n     {\n       tree name = c_parser_peek_token (parser)->value;\n       tree tlab;\n-      location_t loc2;\n       tree attrs;\n+      location_t loc2 = c_parser_peek_token (parser)->location;\n       gcc_assert (c_parser_next_token_is (parser, CPP_NAME));\n       c_parser_consume_token (parser);\n       gcc_assert (c_parser_next_token_is (parser, CPP_COLON));\n-      loc2 = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n       attrs = c_parser_attributes (parser);\n       tlab = define_label (loc2, name);\n@@ -3813,7 +3848,9 @@ c_parser_statement_after_labels (c_parser *parser)\n     expr_stmt:\n       if (c_parser_next_token_starts_declspecs (parser)) \n \t{\n-\t  error (\"a label can only be part of a statement and a declaration is not a statement\");\n+\t  error (\"%Ha label can only be part of a statement and \"\n+\t\t \"a declaration is not a statement\",\n+\t\t &c_parser_peek_token (parser)->location);\n \t  c_parser_declaration_or_fndef (parser, /*fndef_ok*/ false, \n \t\t\t\t\t /*nested*/ true, /*empty_ok*/ false,\n \t\t\t\t\t /*start_attr_ok*/ true);\n@@ -3996,7 +4033,8 @@ c_parser_do_statement (c_parser *parser)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     warning (OPT_Wempty_body,\n-             \"suggest braces around empty body in %<do%> statement\");\n+             \"%Hsuggest braces around empty body in %<do%> statement\",\n+\t     &c_parser_peek_token (parser)->location);\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   save_break = c_break_label;\n@@ -4151,7 +4189,8 @@ c_parser_asm_statement (c_parser *parser)\n   else if (c_parser_next_token_is_keyword (parser, RID_CONST)\n \t   || c_parser_next_token_is_keyword (parser, RID_RESTRICT))\n     {\n-      warning (0, \"%E qualifier ignored on asm\",\n+      warning (0, \"%H%E qualifier ignored on asm\",\n+\t       &c_parser_peek_token (parser)->location,\n \t       c_parser_peek_token (parser)->value);\n       quals = NULL_TREE;\n       c_parser_consume_token (parser);\n@@ -4431,7 +4470,8 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n       if (pedantic)\n-\tpedwarn (\"ISO C forbids omitting the middle term of a ?: expression\");\n+\tpedwarn (\"%HISO C forbids omitting the middle term of a ?: expression\",\n+\t\t &c_parser_peek_token (parser)->location);\n       /* Make sure first operand is calculated only once.  */\n       exp1.value = save_expr (default_conversion (cond.value));\n       cond.value = c_objc_common_truthvalue_conversion (exp1.value);\n@@ -4818,10 +4858,11 @@ c_parser_unary_expression (c_parser *parser)\n       ret.original_code = ERROR_MARK;\n       return ret;\n     case CPP_PLUS:\n-      c_parser_consume_token (parser);\n       if (!c_dialect_objc () && !in_system_header)\n \twarning (OPT_Wtraditional,\n-\t\t \"traditional C rejects the unary plus operator\");\n+\t\t \"%Htraditional C rejects the unary plus operator\",\n+\t\t &c_parser_peek_token (parser)->location);\n+      c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n       op = default_function_array_conversion (op);\n       return parser_build_unary_op (CONVERT_EXPR, op);\n@@ -4893,6 +4934,7 @@ static struct c_expr\n c_parser_sizeof_expression (c_parser *parser)\n {\n   struct c_expr expr;\n+  location_t expr_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SIZEOF));\n   c_parser_consume_token (parser);\n   skip_evaluation++;\n@@ -4904,6 +4946,7 @@ c_parser_sizeof_expression (c_parser *parser)\n \t starting with a compound literal.  */\n       struct c_type_name *type_name;\n       c_parser_consume_token (parser);\n+      expr_loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n       if (type_name == NULL)\n@@ -4928,19 +4971,21 @@ c_parser_sizeof_expression (c_parser *parser)\n \t  && type_name->declarator->u.array.vla_unspec_p)\n \t{\n \t  /* C99 6.7.5.2p4 */\n-\t  error (\"%<[*]%> not allowed in other than a declaration\");\n+\t  error (\"%H%<[*]%> not allowed in other than a declaration\",\n+\t\t &expr_loc);\n \t}\n       return c_expr_sizeof_type (type_name);\n     }\n   else\n     {\n+      expr_loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_unary_expression (parser);\n     sizeof_expr:\n       skip_evaluation--;\n       in_sizeof--;\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n-\terror (\"%<sizeof%> applied to a bit-field\");\n+\terror (\"%H%<sizeof%> applied to a bit-field\", &expr_loc);\n       return c_expr_sizeof_expr (expr);\n     }\n }\n@@ -5058,6 +5103,7 @@ c_parser_postfix_expression (c_parser *parser)\n {\n   struct c_expr expr, e1, e2, e3;\n   struct c_type_name *t1, *t2;\n+  location_t loc;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_NUMBER:\n@@ -5105,12 +5151,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t{\n \t  /* A statement expression.  */\n \t  tree stmt;\n+\t  location_t here = c_parser_peek_token (parser)->location;\n \t  c_parser_consume_token (parser);\n \t  c_parser_consume_token (parser);\n \t  if (cur_stmt_list == NULL)\n \t    {\n-\t      error (\"braced-group within expression allowed \"\n-\t\t     \"only inside a function\");\n+\t      error (\"%Hbraced-group within expression allowed \"\n+\t\t     \"only inside a function\", &here);\n \t      parser->error = true;\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -5123,7 +5170,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C forbids braced-groups within expressions\");\n+\t    pedwarn (\"%HISO C forbids braced-groups within expressions\",\n+\t\t     &here);\n \t  expr.value = c_finish_stmt_expr (stmt);\n \t  expr.original_code = ERROR_MARK;\n \t}\n@@ -5282,6 +5330,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t      expr.original_code = ERROR_MARK;\n \t      break;\n \t    }\n+\t  loc = c_parser_peek_token (parser)->location;\n \t  e1 = c_parser_expr_no_commas (parser, NULL);\n \t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n \t    {\n@@ -5306,8 +5355,8 @@ c_parser_postfix_expression (c_parser *parser)\n \n \t    c = fold (e1.value);\n \t    if (TREE_CODE (c) != INTEGER_CST)\n-\t      error (\"first argument to %<__builtin_choose_expr%> not\"\n-\t\t     \" a constant\");\n+\t      error (\"%Hfirst argument to %<__builtin_choose_expr%> not\"\n+\t\t     \" a constant\", &loc);\n \t    expr = integer_zerop (c) ? e3 : e2;\n \t  }\n \t  break;\n@@ -5469,19 +5518,21 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   tree type;\n   struct c_expr init;\n   struct c_expr expr;\n+  location_t start_loc;\n   start_init (NULL_TREE, NULL, 0);\n   type = groktypename (type_name);\n+  start_loc = c_parser_peek_token (parser)->location;\n   if (type != error_mark_node && C_TYPE_VARIABLE_SIZE (type))\n     {\n-      error (\"compound literal has variable size\");\n+      error (\"%Hcompound literal has variable size\", &start_loc);\n       type = error_mark_node;\n     }\n   init = c_parser_braced_init (parser, type, false);\n   finish_init ();\n   maybe_warn_string_init (type, init);\n \n   if (pedantic && !flag_isoc99)\n-    pedwarn (\"ISO C90 forbids compound literals\");\n+    pedwarn (\"%HISO C90 forbids compound literals\", &start_loc);\n   expr.value = build_compound_literal (type, init.value);\n   expr.original_code = ERROR_MARK;\n   return c_parser_postfix_expression_after_primary (parser, expr);\n@@ -5781,7 +5832,8 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n \t  if (pedantic)\n-\t    pedwarn (\"extra semicolon in struct or union specified\");\n+\t    pedwarn (\"%Hextra semicolon in struct or union specified\",\n+\t\t     &c_parser_peek_token (parser)->location);\n \t  c_parser_consume_token (parser);\n \t  continue;\n \t}\n@@ -5998,7 +6050,8 @@ c_parser_objc_method_definition (c_parser *parser)\n     {\n       c_parser_consume_token (parser);\n       if (pedantic)\n-\tpedwarn (\"extra semicolon in method definition specified\");\n+\tpedwarn (\"%Hextra semicolon in method definition specified\",\n+\t\t &c_parser_peek_token (parser)->location);\n     }\n   if (!c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n     {\n@@ -6035,7 +6088,9 @@ c_parser_objc_methodprotolist (c_parser *parser)\n \t{\n \tcase CPP_SEMICOLON:\n \t  if (pedantic)\n-\t    pedwarn (\"ISO C does not allow extra %<;%> outside of a function\");\n+\t    pedwarn (\"%HISO C does not allow extra %<;%> \"\n+\t\t     \"outside of a function\",\n+\t\t     &c_parser_peek_token (parser)->location);\n \t  c_parser_consume_token (parser);\n \t  break;\n \tcase CPP_PLUS:\n@@ -6565,8 +6620,9 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n       return false;\n \n     case PRAGMA_OMP_SECTION:\n-      error (\"%<#pragma omp section%> may only be used in \"\n-\t     \"%<#pragma omp sections%> construct\");\n+      error (\"%H%<#pragma omp section%> may only be used in \"\n+\t     \"%<#pragma omp sections%> construct\",\n+\t     &c_parser_peek_token (parser)->location);\n       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n       return false;\n \n@@ -6927,6 +6983,7 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n {\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n       tree c, t = c_parser_expression (parser).value;\n \n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n@@ -6942,7 +6999,7 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n \t\t       build_int_cst (TREE_TYPE (t), 0));\n       if (c == boolean_true_node)\n \t{\n-\t  warning (0, \"%<num_threads%> value must be positive\");\n+\t  warning (0, \"%H%<num_threads%> value must be positive\", &expr_loc);\n \t  t = integer_one_node;\n \t}\n \n@@ -7098,13 +7155,15 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n+      location_t here;\n       c_parser_consume_token (parser);\n \n+      here = c_parser_peek_token (parser)->location;\n       t = c_parser_expr_no_commas (parser, NULL).value;\n \n       if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n-\terror (\"schedule %<runtime%> does not take \"\n-\t       \"a %<chunk_size%> parameter\");\n+\terror (\"%Hschedule %<runtime%> does not take \"\n+\t       \"a %<chunk_size%> parameter\", &here);\n       else if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE)\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n       else\n@@ -7147,6 +7206,7 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n+      location_t here = c_parser_peek_token (parser)->location;\n       const pragma_omp_clause c_kind = c_parser_omp_clause_name (parser);\n       const char *c_name;\n       tree prev = clauses;\n@@ -7215,7 +7275,7 @@ c_parser_omp_all_clauses (c_parser *parser, unsigned int mask,\n \t  /* Remove the invalid clause(s) from the list to avoid\n \t     confusing the rest of the compiler.  */\n \t  clauses = prev;\n-\t  error (\"%qs is not valid for %qs\", c_name, where);\n+\t  error (\"%H%qs is not valid for %qs\", &here, c_name, where);\n \t}\n     }\n \n@@ -7603,7 +7663,8 @@ c_parser_omp_sections_scope (c_parser *parser)\n \t}\n       else if (!error_suppress)\n \t{\n-\t  error (\"expected %<#pragma omp section%> or %<}%>\");\n+\t  error (\"%Hexpected %<#pragma omp section%> or %<}%>\",\n+\t\t &loc);\n \t  error_suppress = true;\n \t}\n "}, {"sha": "c627561399f5d98be329a0e8a6047a36256a8959", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -1,3 +1,11 @@\n+2007-11-08  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcc.dg/empty-source-3.c: Update warning location.\n+\t* gcc.dg/gomp/barrier-2.c: Likewise.\n+\t* gcc.dg/label-decl-3.c: Likewise.\n+\t* gcc.dg/label-decl-2.c: Likewise.\n+\t* gcc.dg/empty-source-2.c: Likewise.\n+\n 2007-11-08  Tom Tromey  <tromey@redhat.com>\n \n \tPR c++/30297:"}, {"sha": "4d9cc25ff7ed27ca9604ccdf7f6047e304070f69", "filename": "gcc/testsuite/gcc.dg/empty-source-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-2.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -3,4 +3,4 @@\n /* { dg-do compile } */\n /* { dg-options \"-pedantic\" } */\n \n-/* { dg-warning \"ISO C forbids an empty source file\" \"empty\" { target *-*-* } 1 } */\n+/* { dg-warning \"ISO C forbids an empty source file\" \"empty\" { target *-*-* } 6 } */"}, {"sha": "4facdab3e7e48b01c70ef3ffeba63c0ea7f5d4b8", "filename": "gcc/testsuite/gcc.dg/empty-source-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fempty-source-3.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -4,4 +4,4 @@\n /* { dg-do compile } */\n /* { dg-options \"-pedantic-errors\" } */\n \n-/* { dg-error \"ISO C forbids an empty source file\" \"empty\" { target *-*-* } 1 } */\n+/* { dg-error \"ISO C forbids an empty source file\" \"empty\" { target *-*-* } 7 } */"}, {"sha": "3787c35a13e9b3fb2468e5823194210e6906f3bb", "filename": "gcc/testsuite/gcc.dg/gomp/barrier-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fbarrier-2.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -15,9 +15,9 @@ void f1(void)\n \n void f2(void)\n {\n-  label:\n+  label:       /* { dg-error \"label at end of compound statement\" } */\n     #pragma omp barrier\n-}\t\t/* { dg-error \"label at end of compound statement\" } */\n+}\n \n void f3(_Bool p)\n {"}, {"sha": "97c453b78b747f1a6c2352a38a14bd10ac4edeeb", "filename": "gcc/testsuite/gcc.dg/label-decl-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -10,7 +10,7 @@ f (void)\n {\n   __label__ a, b, c, d;\n   __extension__ (void)&&d; /* { dg-error \"label 'd' used but not defined\" } */\n-  /* { dg-warning \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 12 } */\n+  /* { dg-warning \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 11 } */\n   goto c; /* { dg-error \"label 'c' used but not defined\" } */\n  a: (void)0;\n  b: (void)0;"}, {"sha": "32daea87f1810ce9cf06ae3a51e8dd2c1fe85e64", "filename": "gcc/testsuite/gcc.dg/label-decl-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7412148f76c7006f2ab235d9f50ce8bd4c97a25/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-3.c?ref=c7412148f76c7006f2ab235d9f50ce8bd4c97a25", "patch": "@@ -11,7 +11,7 @@ f (void)\n {\n   __label__ a, b, c, d;\n   __extension__ (void)&&d; /* { dg-error \"label 'd' used but not defined\" } */\n-  /* { dg-error \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 13 } */\n+  /* { dg-error \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 12 } */\n   goto c; /* { dg-error \"label 'c' used but not defined\" } */\n  a: (void)0;\n  b: (void)0;"}]}