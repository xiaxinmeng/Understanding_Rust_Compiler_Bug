{"sha": "d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjY2UzYWRiODc1OWQzNzMyYThkZGY2YjQ2MGYxY2JmYzAxNDU3Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-08T22:32:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-08T22:32:58Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r424", "tree": {"sha": "95d8a2f183f95268db5c85aaad3420c5ea3bde6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95d8a2f183f95268db5c85aaad3420c5ea3bde6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cce3adb8759d3732a8ddf6b460f1cbfc014576/comments", "author": null, "committer": null, "parents": [{"sha": "c138f3280db10430f1b9b187968e72bb5f1e026a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c138f3280db10430f1b9b187968e72bb5f1e026a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c138f3280db10430f1b9b187968e72bb5f1e026a"}], "stats": {"total": 106, "additions": 91, "deletions": 15}, "files": [{"sha": "df225fdd5795a52f7976544b05594962815f84a4", "filename": "gcc/config/m68k/m68kv4.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cce3adb8759d3732a8ddf6b460f1cbfc014576/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cce3adb8759d3732a8ddf6b460f1cbfc014576/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "patch": "@@ -21,7 +21,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Use SGS_* macros to control compilation in m68k.md */\n \n-#define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n #define SGS_SWITCH_TABLES\t/* Different switch table handling */\n \n #include \"m68ksgs.h\"\t\t/* The m68k/SVR4 assembler is SGS based */"}, {"sha": "085dc1a733edf96694c1b47b1d8fb1a6b36fdaa8", "filename": "gcc/config/m68k/sgs.h", "status": "modified", "additions": 91, "deletions": 14, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cce3adb8759d3732a8ddf6b460f1cbfc014576/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cce3adb8759d3732a8ddf6b460f1cbfc014576/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=d7cce3adb8759d3732a8ddf6b460f1cbfc014576", "patch": "@@ -227,7 +227,7 @@ do { union { float f; long l;} tem;\t\t\t\\\n #undef ASM_OUTPUT_SKIP\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"%s %u\\n\", SPACE_ASM_OP, (SIZE))\n-\n+\f\n /* Translate Motorola opcodes such as `jbeq' into SGS opcodes such\n    as `beq.w'.\n    Delete the `e' in `move...' and `fmove'.\n@@ -236,18 +236,93 @@ do { union { float f; long l;} tem;\t\t\t\\\n    Change `fsne' to `fsneq'\n    Change `divsl' to `tdivs' (32/32 -> 32r:32q)\n    Change `divul' to `tdivu' (32/32 -> 32r:32q)\n+   Optionally change swap to swap.w.\n    */\n \n+#ifdef SGS_SWAP_W\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  extern int flag_pic;\t\t\t\t\t\\\n+  if (!strncmp ((PTR), \"jbsr\", 4))\t\t\t\\\n+    { if (flag_pic)\t\t\t\t\t\\\n+        fprintf ((FILE), \"bsr\");\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"jsr\");\t\t\t\\\n+    (PTR) += 4; }\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR);\t\t\t\t\t\t\\\n+      while (*(PTR) != ' ')\t\t\t\t\\\n+\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n+      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n+  else if ((PTR)[0] == 's')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"swap\", 4))\t\t\t\\\n+\t{ fprintf ((FILE), \"swap.w\"); (PTR) += 4; }\t\\\n+    }\t\t\t\t\t\t\t\\\n+/* FMOVE ==> FMOV, (and F%& F%$ translations) */\t\\\n+  else if ((PTR)[0] == 'f')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n+\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n+      else if (!strncmp ((PTR), \"ftst\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"fsne\", 4))\t\t\\\n+\t{ fprintf ((FILE), \"fsneq\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"f%$move\", 7))\t\t\\\n+\t{ (PTR) += 7;\t\t\t\t\t\\\n+\t  if (TARGET_68040_ONLY)\t\t\t\\\n+\t    fprintf ((FILE), \"fsmov\");\t\t\t\\\n+\t  else fprintf ((FILE), \"fmov\"); }\t\t\\\n+      else if (!strncmp ((PTR), \"f%&move\", 7))\t\t\\\n+\t{ (PTR) += 7;\t\t\t\t\t\\\n+\t  if (TARGET_68040_ONLY)\t\t\t\\\n+\t    fprintf ((FILE), \"fdmov\");\t\t\t\\\n+\t  else fprintf ((FILE), \"fmov\"); }\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n+  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n+    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'a'\t\t\\\n+\t   || (PTR)[0] == 'c') (PTR)++; }\t\t\\\n+/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n+  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n+\t   && (PTR)[2] == 'b')\t\t\t\t\\\n+    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'i'\t \t\\\n+\t   || (PTR)[0] == 'a') (PTR)++; }\t\t\\\n+/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n+  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n+\t   && (PTR)[2] == 'p')\t\t\t\t\\\n+    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n+       if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n+\t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n+/* DIVSL ==> TDIVS */\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 's'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivs\"); (PTR) += 5; }\t\t\\\n+/* DIVUL ==> TDIVU */\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n+\t   && (PTR)[2] == 'v' && (PTR)[3] == 'u'\t\\\n+\t   && (PTR)[4] == 'l')\t\t\t\t\\\n+    { fprintf ((FILE), \"tdivu\"); (PTR) += 5; }\t\t\\\n+}\n+\n+#else /* not SGS_SWAP_W */\n+\n #define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   extern int flag_pic;\t\t\t\t\t\\\n-  if (!strncmp ((PTR), \"jbsr\", 4)) {\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\\\n-      fprintf ((FILE), \"bsr\");\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      fprintf ((FILE),\"jsr\");\t\t\t\t\\\n-    (PTR) += 4;\t\t\t\t\t\t\\\n-  } else if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\\\n+  if (!strncmp ((PTR), \"jbsr\", 4))\t\t\t\\\n+    { if (flag_pic)\t\t\t\t\t\\\n+        fprintf ((FILE), \"bsr\");\t\t\t\\\n+      else\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"jsr\");\t\t\t\\\n+    (PTR) += 4; }\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n     { ++(PTR);\t\t\t\t\t\t\\\n       while (*(PTR) != ' ')\t\t\t\t\\\n \t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n@@ -278,20 +353,20 @@ do { union { float f; long l;} tem;\t\t\t\\\n   else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n \t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n     { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'a' ||\t\\\n-\t   (PTR)[0] == 'c') (PTR)++; }\t\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'a'\t\t\\\n+\t   || (PTR)[0] == 'c') (PTR)++; }\t\t\\\n /* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n   else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n \t   && (PTR)[2] == 'b')\t\t\t\t\\\n     { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'i' || \t\\\n-\t   (PTR)[0] == 'a') (PTR)++; }\t\t\t\\\n+       if ((PTR)[0] == 'q' || (PTR)[0] == 'i'\t \t\\\n+\t   || (PTR)[0] == 'a') (PTR)++; }\t\t\\\n /* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n   else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n \t   && (PTR)[2] == 'p')\t\t\t\t\\\n     { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'a' || (PTR)[0] == 'i' || \t\\\n-\t   (PTR)[0] == 'm') (PTR)++; }\t\t\t\\\n+       if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n+\t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n /* DIVSL ==> TDIVS */\t\t\t\t\t\\\n   else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n \t   && (PTR)[2] == 'v' && (PTR)[3] == 's'\t\\\n@@ -304,6 +379,8 @@ do { union { float f; long l;} tem;\t\t\t\\\n     { fprintf ((FILE), \"tdivu\"); (PTR) += 5; }\t\t\\\n }\n \n+#endif /* not SGS_SWAP_W */\n+\f\n /* This macro outputs the label at the start of a switch table.  The\n    \".swbeg <N>\" is an assembler directive that causes the switch table\n    size to be inserted into the object code so that disassemblers, for"}]}