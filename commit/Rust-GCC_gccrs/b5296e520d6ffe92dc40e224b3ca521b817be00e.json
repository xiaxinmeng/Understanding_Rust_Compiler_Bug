{"sha": "b5296e520d6ffe92dc40e224b3ca521b817be00e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUyOTZlNTIwZDZmZmU5MmRjNDBlMjI0YjNjYTUyMWI4MTdiZTAwZQ==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2007-05-10T21:06:55Z"}, "committer": {"name": "Roman Zippel", "email": "zippel@gcc.gnu.org", "date": "2007-05-10T21:06:55Z"}, "message": "ffi.c (ffi_prep_args,ffi_prep_cif_machdep): Fix numerous test suite failures.\n\n\t* src/m68k/ffi.c (ffi_prep_args,ffi_prep_cif_machdep): Fix\n\tnumerous test suite failures.\n\t* src/m68k/sysv.S (ffi_call_SYSV): Likewise.\n\nFrom-SVN: r124599", "tree": {"sha": "a3c4094ac4b10d8ff238c5e2bda0757e1f1acb57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3c4094ac4b10d8ff238c5e2bda0757e1f1acb57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5296e520d6ffe92dc40e224b3ca521b817be00e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5296e520d6ffe92dc40e224b3ca521b817be00e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5296e520d6ffe92dc40e224b3ca521b817be00e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5296e520d6ffe92dc40e224b3ca521b817be00e/comments", "author": null, "committer": null, "parents": [{"sha": "8b42b2fb96829c9cbc232e03e03afd124b3749ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b42b2fb96829c9cbc232e03e03afd124b3749ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b42b2fb96829c9cbc232e03e03afd124b3749ba"}], "stats": {"total": 167, "additions": 98, "deletions": 69}, "files": [{"sha": "e8cc2494d20e19e63d015b74610d98a55a3ef5df", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=b5296e520d6ffe92dc40e224b3ca521b817be00e", "patch": "@@ -1,3 +1,9 @@\n+2007-05-10  Roman Zippel <zippel@linux-m68k.org>\n+\n+\t* src/m68k/ffi.c (ffi_prep_args,ffi_prep_cif_machdep): Fix\n+\tnumerous test suite failures.\n+\t* src/m68k/sysv.S (ffi_call_SYSV): Likewise.\n+\n 2007-04-11  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* Makefile.am (EXTRA_DIST): Bring up to date."}, {"sha": "5b9650e0ae5a56c5abcae5cfe7f2a3195eade577", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 70, "deletions": 56, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=b5296e520d6ffe92dc40e224b3ca521b817be00e", "patch": "@@ -9,10 +9,15 @@\n \n #include <stdlib.h>\n \n+void ffi_call_SYSV (extended_cif *,\n+\t\t    unsigned, unsigned,\n+\t\t    void *, void (*fn) ());\n+void *ffi_prep_args (void *stack, extended_cif *ecif);\n+\n /* ffi_prep_args is called by the assembly routine once stack space has\n    been allocated for the function's arguments.  */\n \n-static void *\n+void *\n ffi_prep_args (void *stack, extended_cif *ecif)\n {\n   unsigned int i;\n@@ -24,7 +29,7 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n   argp = stack;\n \n   if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n-      && ecif->cif->rtype->size > 8)\n+      && !ecif->cif->flags)\n     struct_value_ptr = ecif->rvalue;\n   else\n     struct_value_ptr = NULL;\n@@ -37,44 +42,47 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n     {\n       size_t z;\n \n-      /* Align if necessary.  */\n-      if (((*p_arg)->alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, (*p_arg)->alignment);\n-\n-\t  z = (*p_arg)->size;\n-\t  if (z < sizeof (int))\n+      z = (*p_arg)->size;\n+      if (z < sizeof (int))\n+\t{\n+\t  switch ((*p_arg)->type)\n \t    {\n-\t      switch ((*p_arg)->type)\n-\t\t{\n-\t\tcase FFI_TYPE_SINT8:\n-\t\t  *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;\n-\t\t  break;\n-\n-\t\tcase FFI_TYPE_UINT8:\n-\t\t  *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;\n-\t\t  break;\n-\n-\t\tcase FFI_TYPE_SINT16:\n-\t\t  *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;\n-\t\t  break;\n-\n-\t\tcase FFI_TYPE_UINT16:\n-\t\t  *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;\n-\t\t  break;\n-\n-\t\tcase FFI_TYPE_STRUCT:\n-\t\t  memcpy (argp + sizeof (int) - z, *p_argv, z);\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  FFI_ASSERT (0);\n-\t\t}\n-\t      z = sizeof (int);\n+\t    case FFI_TYPE_SINT8:\n+\t      *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT8:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT8 *) *p_argv;\n+\t      break;\n+\n+\t    case FFI_TYPE_SINT16:\n+\t      *(signed int *) argp = (signed int) *(SINT16 *) *p_argv;\n+\t      break;\n+\n+\t    case FFI_TYPE_UINT16:\n+\t      *(unsigned int *) argp = (unsigned int) *(UINT16 *) *p_argv;\n+\t      break;\n+\n+\t    case FFI_TYPE_STRUCT:\n+\t      memcpy (argp + sizeof (int) - z, *p_argv, z);\n+\t      break;\n+\n+\t    default:\n+\t      FFI_ASSERT (0);\n \t    }\n-\t  else\n-\t    memcpy (argp, *p_argv, z);\n-\t  p_argv++;\n-\t  argp += z;\n+\t  z = sizeof (int);\n+\t}\n+      else\n+\t{\n+\t  memcpy (argp, *p_argv, z);\n+\n+\t  /* Align if necessary.  */\n+\t  if ((sizeof(int) - 1) & z)\n+\t    z = ALIGN(z, sizeof(int));\n+\t}\n+\n+      p_argv++;\n+      argp += z;\n     }\n \n   return struct_value_ptr;\n@@ -86,7 +94,8 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n #define CIF_FLAGS_DOUBLE\t8\n #define CIF_FLAGS_LDOUBLE\t16\n #define CIF_FLAGS_POINTER\t32\n-#define CIF_FLAGS_STRUCT\t64\n+#define CIF_FLAGS_STRUCT1\t64\n+#define CIF_FLAGS_STRUCT2\t128\n \n /* Perform machine dependent cif processing */\n ffi_status\n@@ -100,12 +109,24 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n-      if (cif->rtype->size > 4 && cif->rtype->size <= 8)\n-\tcif->flags = CIF_FLAGS_DINT;\n-      else if (cif->rtype->size <= 4)\n-\tcif->flags = CIF_FLAGS_STRUCT;\n-      else\n-\tcif->flags = 0;\n+      switch (cif->rtype->size)\n+\t{\n+\tcase 1:\n+\t  cif->flags = CIF_FLAGS_STRUCT1;\n+\t  break;\n+\tcase 2:\n+\t  cif->flags = CIF_FLAGS_STRUCT2;\n+\t  break;\n+\tcase 4:\n+\t  cif->flags = CIF_FLAGS_INT;\n+\t  break;\n+\tcase 8:\n+\t  cif->flags = CIF_FLAGS_DINT;\n+\t  break;\n+\tdefault:\n+\t  cif->flags = 0;\n+\t  break;\n+\t}\n       break;\n \n     case FFI_TYPE_FLOAT:\n@@ -137,19 +158,14 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   return FFI_OK;\n }\n \n-extern void ffi_call_SYSV (void *(*) (void *, extended_cif *), \n-\t\t\t   extended_cif *, \n-\t\t\t   unsigned, unsigned, unsigned,\n-\t\t\t   void *, void (*fn) ());\n-\n void\n ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n-  \n+\n   /* If the return value is a struct and we don't have a return value\n      address then we need to make one.  */\n \n@@ -159,13 +175,11 @@ ffi_call (ffi_cif *cif, void (*fn) (), void *rvalue, void **avalue)\n     ecif.rvalue = alloca (cif->rtype->size);\n   else\n     ecif.rvalue = rvalue;\n-    \n-  \n-  switch (cif->abi) \n+\n+  switch (cif->abi)\n     {\n     case FFI_SYSV:\n-      ffi_call_SYSV (ffi_prep_args, &ecif, cif->bytes, \n-\t\t     cif->flags, cif->rtype->size * 8,\n+      ffi_call_SYSV (&ecif, cif->bytes, cif->flags,\n \t\t     ecif.rvalue, fn);\n       break;\n "}, {"sha": "efe5854c776658fec47dc56ad1c53d6bae445ec7", "filename": "libffi/src/m68k/sysv.S", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2Fsrc%2Fm68k%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5296e520d6ffe92dc40e224b3ca521b817be00e/libffi%2Fsrc%2Fm68k%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fsysv.S?ref=b5296e520d6ffe92dc40e224b3ca521b817be00e", "patch": "@@ -12,36 +12,40 @@\n \n \t.globl\tffi_call_SYSV\n \t.type\tffi_call_SYSV,@function\n+\t.align\t4\n \n ffi_call_SYSV:\n \tlink\t%fp,#0\n \tmove.l\t%d2,-(%sp)\n \n \t| Make room for all of the new args.\n-\tsub.l\t16(%fp),%sp\n+\tsub.l\t12(%fp),%sp\n \n \t| Call ffi_prep_args\n-\tmove.l\t12(%fp),-(%sp)\n+\tmove.l\t8(%fp),-(%sp)\n \tpea\t4(%sp)\n-\tmove.l\t8(%fp),%a0\n-\tjsr\t(%a0)\n+#if !defined __PIC__\n+\tjsr\tffi_prep_args\n+#else\n+\tbsr.l\tffi_prep_args@PLTPC\n+#endif\n \taddq.l\t#8,%sp\t\n \n \t| Pass pointer to struct value, if any\n \tmove.l\t%a0,%a1\n \n \t| Call the function\n-\tmove.l\t32(%fp),%a0\n+\tmove.l\t24(%fp),%a0\n \tjsr\t(%a0)\n \n \t| Remove the space we pushed for the args\n-\tadd.l\t16(%fp),%sp\n+\tadd.l\t12(%fp),%sp\n \n \t| Load the pointer to storage for the return value\n-\tmove.l\t28(%fp),%a1\n+\tmove.l\t20(%fp),%a1\n \n \t| Load the return type code \n-\tmove.l\t20(%fp),%d2\n+\tmove.l\t16(%fp),%d2\n \n \t| If the return value pointer is NULL, assume no return value.\n \ttst.l\t%a1\n@@ -79,19 +83,24 @@ retlongdouble:\n \n retpointer:\n \tbtst\t#5,%d2\n-\tjbeq\tretstruct\n+\tjbeq\tretstruct1\n \tmove.l\t%a0,(%a1)\n \tjbra\tepilogue\n \n-retstruct:\n+retstruct1:\n \tbtst\t#6,%d2\n+\tjbeq\tretstruct2\n+\tmove.b\t%d0,(%a1)\n+\tjbra\tepilogue\n+\n+retstruct2:\n+\tbtst\t#7,%d2\n \tjbeq\tnoretval\n-\tmove.l\t24(%fp),%d2\n-\tbfins\t%d0,(%a1){#0,%d2}\n+\tmove.w\t%d0,(%a1)\n \n noretval:\n epilogue:\n \tmove.l\t(%sp)+,%d2\n-\tunlk\t%a6\n+\tunlk\t%fp\n \trts\n \t.size\tffi_call_SYSV,.-ffi_call_SYSV"}]}