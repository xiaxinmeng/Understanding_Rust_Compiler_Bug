{"sha": "cd0470594cbc319d4a179734b2d6247056d07afb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwNDcwNTk0Y2JjMzE5ZDRhMTc5NzM0YjJkNjI0NzA1NmQwN2FmYg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2013-11-19T09:48:59Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2013-11-19T09:48:59Z"}, "message": "tree-ssa-loop-ivopts.c (enum ainc_type): New.\n\n\t* tree-ssa-loop-ivopts.c (enum ainc_type): New.\n\t(address_cost_data): New field.\n\t(get_address_cost): Compute auto-increment rtx cost in ainc_costs.\n\tUse ainc_costs for auto-increment rtx patterns.\n\tCleanup TWS.\n\nFrom-SVN: r205015", "tree": {"sha": "b7ce26aadcb857ec8add5f834815ea589e35522f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7ce26aadcb857ec8add5f834815ea589e35522f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd0470594cbc319d4a179734b2d6247056d07afb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0470594cbc319d4a179734b2d6247056d07afb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0470594cbc319d4a179734b2d6247056d07afb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0470594cbc319d4a179734b2d6247056d07afb/comments", "author": null, "committer": null, "parents": [{"sha": "c1dfcec7c183a5805ab9a64d2faa46d5e55d9820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1dfcec7c183a5805ab9a64d2faa46d5e55d9820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1dfcec7c183a5805ab9a64d2faa46d5e55d9820"}], "stats": {"total": 72, "additions": 60, "deletions": 12}, "files": [{"sha": "5d39507f1dc1bd98af9c89212209144470aa57e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0470594cbc319d4a179734b2d6247056d07afb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0470594cbc319d4a179734b2d6247056d07afb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd0470594cbc319d4a179734b2d6247056d07afb", "patch": "@@ -1,3 +1,11 @@\n+2013-11-19  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (enum ainc_type): New.\n+\t(address_cost_data): New field.\n+\t(get_address_cost): Compute auto-increment rtx cost in ainc_costs.\n+\tUse ainc_costs for auto-increment rtx patterns.\n+\tCleanup TWS.\n+\n 2013-11-19  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.md: Remove v8type from all insns."}, {"sha": "f53fa2286f2edf5b9618c117c6152cd222a4ff5e", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0470594cbc319d4a179734b2d6247056d07afb/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0470594cbc319d4a179734b2d6247056d07afb/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=cd0470594cbc319d4a179734b2d6247056d07afb", "patch": "@@ -3207,10 +3207,20 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,\n \n    TODO -- there must be some better way.  This all is quite crude.  */\n \n+enum ainc_type\n+{\n+  AINC_PRE_INC,\t\t/* Pre increment.  */\n+  AINC_PRE_DEC,\t\t/* Pre decrement.  */\n+  AINC_POST_INC,\t/* Post increment.  */\n+  AINC_POST_DEC,\t/* Post decrement.  */\n+  AINC_NONE\t\t/* Also the number of auto increment types.  */\n+};\n+\n typedef struct address_cost_data_s\n {\n   HOST_WIDE_INT min_offset, max_offset;\n   unsigned costs[2][2][2][2];\n+  unsigned ainc_costs[AINC_NONE];\n } *address_cost_data;\n \n \n@@ -3228,6 +3238,7 @@ get_address_cost (bool symbol_present, bool var_present,\n   static bool has_preinc[MAX_MACHINE_MODE], has_postinc[MAX_MACHINE_MODE];\n   static bool has_predec[MAX_MACHINE_MODE], has_postdec[MAX_MACHINE_MODE];\n   unsigned cost, acost, complexity;\n+  enum ainc_type autoinc_type;\n   bool offset_p, ratio_p, autoinc;\n   HOST_WIDE_INT s_offset, autoinc_offset, msize;\n   unsigned HOST_WIDE_INT mask;\n@@ -3299,33 +3310,49 @@ get_address_cost (bool symbol_present, bool var_present,\n       reg0 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);\n       reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2);\n \n-      if (USE_LOAD_PRE_DECREMENT (mem_mode) \n+      if (USE_LOAD_PRE_DECREMENT (mem_mode)\n \t  || USE_STORE_PRE_DECREMENT (mem_mode))\n \t{\n \t  addr = gen_rtx_PRE_DEC (address_mode, reg0);\n \t  has_predec[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n+\n+\t  if (has_predec[mem_mode])\n+\t    data->ainc_costs[AINC_PRE_DEC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n \t}\n-      if (USE_LOAD_POST_DECREMENT (mem_mode) \n+      if (USE_LOAD_POST_DECREMENT (mem_mode)\n \t  || USE_STORE_POST_DECREMENT (mem_mode))\n \t{\n \t  addr = gen_rtx_POST_DEC (address_mode, reg0);\n \t  has_postdec[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n+\n+\t  if (has_postdec[mem_mode])\n+\t    data->ainc_costs[AINC_POST_DEC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n \t}\n-      if (USE_LOAD_PRE_INCREMENT (mem_mode) \n+      if (USE_LOAD_PRE_INCREMENT (mem_mode)\n \t  || USE_STORE_PRE_DECREMENT (mem_mode))\n \t{\n \t  addr = gen_rtx_PRE_INC (address_mode, reg0);\n \t  has_preinc[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n+\n+\t  if (has_preinc[mem_mode])\n+\t    data->ainc_costs[AINC_PRE_INC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n \t}\n-      if (USE_LOAD_POST_INCREMENT (mem_mode) \n+      if (USE_LOAD_POST_INCREMENT (mem_mode)\n \t  || USE_STORE_POST_INCREMENT (mem_mode))\n \t{\n \t  addr = gen_rtx_POST_INC (address_mode, reg0);\n \t  has_postinc[mem_mode]\n \t    = memory_address_addr_space_p (mem_mode, addr, as);\n+\n+\t  if (has_postinc[mem_mode])\n+\t    data->ainc_costs[AINC_POST_INC]\n+\t      = address_cost (addr, mem_mode, as, speed);\n \t}\n       for (i = 0; i < 16; i++)\n \t{\n@@ -3451,21 +3478,31 @@ get_address_cost (bool symbol_present, bool var_present,\n   s_offset = offset;\n \n   autoinc = false;\n+  autoinc_type = AINC_NONE;\n   msize = GET_MODE_SIZE (mem_mode);\n   autoinc_offset = offset;\n   if (stmt_after_inc)\n     autoinc_offset += ratio * cstep;\n   if (symbol_present || var_present || ratio != 1)\n     autoinc = false;\n-  else if ((has_postinc[mem_mode] && autoinc_offset == 0\n-\t       && msize == cstep)\n-\t   || (has_postdec[mem_mode] && autoinc_offset == 0\n+  else\n+    {\n+      if (has_postinc[mem_mode] && autoinc_offset == 0\n+\t  && msize == cstep)\n+\tautoinc_type = AINC_POST_INC;\n+      else if (has_postdec[mem_mode] && autoinc_offset == 0\n \t       && msize == -cstep)\n-\t   || (has_preinc[mem_mode] && autoinc_offset == msize\n+\tautoinc_type = AINC_POST_DEC;\n+      else if (has_preinc[mem_mode] && autoinc_offset == msize\n \t       && msize == cstep)\n-\t   || (has_predec[mem_mode] && autoinc_offset == -msize\n-\t       && msize == -cstep))\n-    autoinc = true;\n+\tautoinc_type = AINC_PRE_INC;\n+      else if (has_predec[mem_mode] && autoinc_offset == -msize\n+\t       && msize == -cstep)\n+\tautoinc_type = AINC_PRE_DEC;\n+\n+      if (autoinc_type != AINC_NONE)\n+\tautoinc = true;\n+    }\n \n   cost = 0;\n   offset_p = (s_offset != 0\n@@ -3482,7 +3519,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;\n-  acost = data->costs[symbol_present][var_present][offset_p][ratio_p];\n+  if (autoinc)\n+    acost = data->ainc_costs[autoinc_type];\n+  else\n+    acost = data->costs[symbol_present][var_present][offset_p][ratio_p];\n   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n   return new_cost (cost + acost, complexity);\n }"}]}