{"sha": "757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU3YmYxZGZmNWU4Y2VlMzRjMGE3NWQwNjE0MGNhOTcyYmZlY2ZhNw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2019-09-27T13:23:16Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-01-14T20:34:24Z"}, "message": "Initial commit of analyzer\n\nThis patch adds a static analysis pass to the middle-end, focusing\nfor this release on C code, and malloc/free issues in particular.\n\nSee:\n https://gcc.gnu.org/wiki/DavidMalcolm/StaticAnalyzer\n\ngcc/ChangeLog:\n\t* Makefile.in (lang_opt_files): Add analyzer.opt.\n\t(ANALYZER_OBJS): New.\n\t(OBJS): Add digraph.o, graphviz.o, ordered-hash-map-tests.o,\n\ttristate.o and ANALYZER_OBJS.\n\t(TEXI_GCCINT_FILES): Add analyzer.texi.\n\t* common.opt (-fanalyzer): New driver option.\n\t* config.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac (--disable-analyzer, ENABLE_ANALYZER): New option.\n\t(gccdepdir): Also create depdir for \"analyzer\" subdir.\n\t* digraph.cc: New file.\n\t* digraph.h: New file.\n\t* doc/analyzer.texi: New file.\n\t* doc/gccint.texi (\"Static Analyzer\") New menu item.\n\t(analyzer.texi): Include it.\n\t* doc/invoke.texi (\"Static Analyzer Options\"): New list and new section.\n\t(\"Warning Options\"): Add static analysis warnings to the list.\n\t(-Wno-analyzer-double-fclose): New option.\n\t(-Wno-analyzer-double-free): New option.\n\t(-Wno-analyzer-exposure-through-output-file): New option.\n\t(-Wno-analyzer-file-leak): New option.\n\t(-Wno-analyzer-free-of-non-heap): New option.\n\t(-Wno-analyzer-malloc-leak): New option.\n\t(-Wno-analyzer-possible-null-argument): New option.\n\t(-Wno-analyzer-possible-null-dereference): New option.\n\t(-Wno-analyzer-null-argument): New option.\n\t(-Wno-analyzer-null-dereference): New option.\n\t(-Wno-analyzer-stale-setjmp-buffer): New option.\n\t(-Wno-analyzer-tainted-array-index): New option.\n\t(-Wno-analyzer-use-after-free): New option.\n\t(-Wno-analyzer-use-of-pointer-in-stale-stack-frame): New option.\n\t(-Wno-analyzer-use-of-uninitialized-value): New option.\n\t(-Wanalyzer-too-complex): New option.\n\t(-fanalyzer-call-summaries): New warning.\n\t(-fanalyzer-checker=): New warning.\n\t(-fanalyzer-fine-grained): New warning.\n\t(-fno-analyzer-state-merge): New warning.\n\t(-fno-analyzer-state-purge): New warning.\n\t(-fanalyzer-transitivity): New warning.\n\t(-fanalyzer-verbose-edges): New warning.\n\t(-fanalyzer-verbose-state-changes): New warning.\n\t(-fanalyzer-verbosity=): New warning.\n\t(-fdump-analyzer): New warning.\n\t(-fdump-analyzer-callgraph): New warning.\n\t(-fdump-analyzer-exploded-graph): New warning.\n\t(-fdump-analyzer-exploded-nodes): New warning.\n\t(-fdump-analyzer-exploded-nodes-2): New warning.\n\t(-fdump-analyzer-exploded-nodes-3): New warning.\n\t(-fdump-analyzer-supergraph): New warning.\n\t* doc/sourcebuild.texi (dg-require-dot): New.\n\t(dg-check-dot): New.\n\t* gdbinit.in (break-on-saved-diagnostic): New command.\n\t* graphviz.cc: New file.\n\t* graphviz.h: New file.\n\t* ordered-hash-map-tests.cc: New file.\n\t* ordered-hash-map.h: New file.\n\t* passes.def (pass_analyzer): Add before\n\tpass_ipa_whole_program_visibility.\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::ordered_hash_map_tests_cc_tests.\n\t* selftest.h (selftest::ordered_hash_map_tests_cc_tests): New\n\tdecl.\n\t* shortest-paths.h: New file.\n\t* timevar.def (TV_ANALYZER): New timevar.\n\t(TV_ANALYZER_SUPERGRAPH): Likewise.\n\t(TV_ANALYZER_STATE_PURGE): Likewise.\n\t(TV_ANALYZER_PLAN): Likewise.\n\t(TV_ANALYZER_SCC): Likewise.\n\t(TV_ANALYZER_WORKLIST): Likewise.\n\t(TV_ANALYZER_DUMP): Likewise.\n\t(TV_ANALYZER_DIAGNOSTICS): Likewise.\n\t(TV_ANALYZER_SHORTEST_PATHS): Likewise.\n\t* tree-pass.h (make_pass_analyzer): New decl.\n\t* tristate.cc: New file.\n\t* tristate.h: New file.\n\ngcc/analyzer/ChangeLog:\n\t* ChangeLog: New file.\n\t* analyzer-selftests.cc: New file.\n\t* analyzer-selftests.h: New file.\n\t* analyzer.opt: New file.\n\t* analysis-plan.cc: New file.\n\t* analysis-plan.h: New file.\n\t* analyzer-logging.cc: New file.\n\t* analyzer-logging.h: New file.\n\t* analyzer-pass.cc: New file.\n\t* analyzer.cc: New file.\n\t* analyzer.h: New file.\n\t* call-string.cc: New file.\n\t* call-string.h: New file.\n\t* checker-path.cc: New file.\n\t* checker-path.h: New file.\n\t* constraint-manager.cc: New file.\n\t* constraint-manager.h: New file.\n\t* diagnostic-manager.cc: New file.\n\t* diagnostic-manager.h: New file.\n\t* engine.cc: New file.\n\t* engine.h: New file.\n\t* exploded-graph.h: New file.\n\t* pending-diagnostic.cc: New file.\n\t* pending-diagnostic.h: New file.\n\t* program-point.cc: New file.\n\t* program-point.h: New file.\n\t* program-state.cc: New file.\n\t* program-state.h: New file.\n\t* region-model.cc: New file.\n\t* region-model.h: New file.\n\t* sm-file.cc: New file.\n\t* sm-malloc.cc: New file.\n\t* sm-malloc.dot: New file.\n\t* sm-pattern-test.cc: New file.\n\t* sm-sensitive.cc: New file.\n\t* sm-signal.cc: New file.\n\t* sm-taint.cc: New file.\n\t* sm.cc: New file.\n\t* sm.h: New file.\n\t* state-purge.cc: New file.\n\t* state-purge.h: New file.\n\t* supergraph.cc: New file.\n\t* supergraph.h: New file.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/CVE-2005-1689-minimal.c: New test.\n\t* gcc.dg/analyzer/abort.c: New test.\n\t* gcc.dg/analyzer/alloca-leak.c: New test.\n\t* gcc.dg/analyzer/analyzer-decls.h: New header.\n\t* gcc.dg/analyzer/analyzer-verbosity-0.c: New test.\n\t* gcc.dg/analyzer/analyzer-verbosity-1.c: New test.\n\t* gcc.dg/analyzer/analyzer-verbosity-2.c: New test.\n\t* gcc.dg/analyzer/analyzer.exp: New suite.\n\t* gcc.dg/analyzer/attribute-nonnull.c: New test.\n\t* gcc.dg/analyzer/call-summaries-1.c: New test.\n\t* gcc.dg/analyzer/conditionals-2.c: New test.\n\t* gcc.dg/analyzer/conditionals-3.c: New test.\n\t* gcc.dg/analyzer/conditionals-notrans.c: New test.\n\t* gcc.dg/analyzer/conditionals-trans.c: New test.\n\t* gcc.dg/analyzer/data-model-1.c: New test.\n\t* gcc.dg/analyzer/data-model-2.c: New test.\n\t* gcc.dg/analyzer/data-model-3.c: New test.\n\t* gcc.dg/analyzer/data-model-4.c: New test.\n\t* gcc.dg/analyzer/data-model-5.c: New test.\n\t* gcc.dg/analyzer/data-model-5b.c: New test.\n\t* gcc.dg/analyzer/data-model-5c.c: New test.\n\t* gcc.dg/analyzer/data-model-5d.c: New test.\n\t* gcc.dg/analyzer/data-model-6.c: New test.\n\t* gcc.dg/analyzer/data-model-7.c: New test.\n\t* gcc.dg/analyzer/data-model-8.c: New test.\n\t* gcc.dg/analyzer/data-model-9.c: New test.\n\t* gcc.dg/analyzer/data-model-11.c: New test.\n\t* gcc.dg/analyzer/data-model-12.c: New test.\n\t* gcc.dg/analyzer/data-model-13.c: New test.\n\t* gcc.dg/analyzer/data-model-14.c: New test.\n\t* gcc.dg/analyzer/data-model-15.c: New test.\n\t* gcc.dg/analyzer/data-model-16.c: New test.\n\t* gcc.dg/analyzer/data-model-17.c: New test.\n\t* gcc.dg/analyzer/data-model-18.c: New test.\n\t* gcc.dg/analyzer/data-model-19.c: New test.\n\t* gcc.dg/analyzer/data-model-path-1.c: New test.\n\t* gcc.dg/analyzer/disabling.c: New test.\n\t* gcc.dg/analyzer/dot-output.c: New test.\n\t* gcc.dg/analyzer/double-free-lto-1-a.c: New test.\n\t* gcc.dg/analyzer/double-free-lto-1-b.c: New test.\n\t* gcc.dg/analyzer/double-free-lto-1.h: New header.\n\t* gcc.dg/analyzer/equivalence.c: New test.\n\t* gcc.dg/analyzer/explode-1.c: New test.\n\t* gcc.dg/analyzer/explode-2.c: New test.\n\t* gcc.dg/analyzer/factorial.c: New test.\n\t* gcc.dg/analyzer/fibonacci.c: New test.\n\t* gcc.dg/analyzer/fields.c: New test.\n\t* gcc.dg/analyzer/file-1.c: New test.\n\t* gcc.dg/analyzer/file-2.c: New test.\n\t* gcc.dg/analyzer/function-ptr-1.c: New test.\n\t* gcc.dg/analyzer/function-ptr-2.c: New test.\n\t* gcc.dg/analyzer/function-ptr-3.c: New test.\n\t* gcc.dg/analyzer/gzio-2.c: New test.\n\t* gcc.dg/analyzer/gzio-3.c: New test.\n\t* gcc.dg/analyzer/gzio-3a.c: New test.\n\t* gcc.dg/analyzer/gzio.c: New test.\n\t* gcc.dg/analyzer/infinite-recursion.c: New test.\n\t* gcc.dg/analyzer/loop-2.c: New test.\n\t* gcc.dg/analyzer/loop-2a.c: New test.\n\t* gcc.dg/analyzer/loop-3.c: New test.\n\t* gcc.dg/analyzer/loop-4.c: New test.\n\t* gcc.dg/analyzer/loop.c: New test.\n\t* gcc.dg/analyzer/malloc-1.c: New test.\n\t* gcc.dg/analyzer/malloc-2.c: New test.\n\t* gcc.dg/analyzer/malloc-3.c: New test.\n\t* gcc.dg/analyzer/malloc-callbacks.c: New test.\n\t* gcc.dg/analyzer/malloc-dce.c: New test.\n\t* gcc.dg/analyzer/malloc-dedupe-1.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-1.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-10.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-11.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-12.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-13.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-2.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-3.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-4.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-5.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-6.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-7.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-double-free.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-lto-a.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-lto-b.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-lto-c.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-lto.h: New test.\n\t* gcc.dg/analyzer/malloc-ipa-8-unchecked.c: New test.\n\t* gcc.dg/analyzer/malloc-ipa-9.c: New test.\n\t* gcc.dg/analyzer/malloc-macro-inline-events.c: New test.\n\t* gcc.dg/analyzer/malloc-macro-separate-events.c: New test.\n\t* gcc.dg/analyzer/malloc-macro.h: New header.\n\t* gcc.dg/analyzer/malloc-many-paths-1.c: New test.\n\t* gcc.dg/analyzer/malloc-many-paths-2.c: New test.\n\t* gcc.dg/analyzer/malloc-many-paths-3.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-1.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-10.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-2.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-3.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-4.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-5.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-6.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-7.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-8.c: New test.\n\t* gcc.dg/analyzer/malloc-paths-9.c: New test.\n\t* gcc.dg/analyzer/malloc-vs-local-1a.c: New test.\n\t* gcc.dg/analyzer/malloc-vs-local-1b.c: New test.\n\t* gcc.dg/analyzer/malloc-vs-local-2.c: New test.\n\t* gcc.dg/analyzer/malloc-vs-local-3.c: New test.\n\t* gcc.dg/analyzer/malloc-vs-local-4.c: New test.\n\t* gcc.dg/analyzer/operations.c: New test.\n\t* gcc.dg/analyzer/params-2.c: New test.\n\t* gcc.dg/analyzer/params.c: New test.\n\t* gcc.dg/analyzer/paths-1.c: New test.\n\t* gcc.dg/analyzer/paths-1a.c: New test.\n\t* gcc.dg/analyzer/paths-2.c: New test.\n\t* gcc.dg/analyzer/paths-3.c: New test.\n\t* gcc.dg/analyzer/paths-4.c: New test.\n\t* gcc.dg/analyzer/paths-5.c: New test.\n\t* gcc.dg/analyzer/paths-6.c: New test.\n\t* gcc.dg/analyzer/paths-7.c: New test.\n\t* gcc.dg/analyzer/pattern-test-1.c: New test.\n\t* gcc.dg/analyzer/pattern-test-2.c: New test.\n\t* gcc.dg/analyzer/pointer-merging.c: New test.\n\t* gcc.dg/analyzer/pr61861.c: New test.\n\t* gcc.dg/analyzer/pragma-1.c: New test.\n\t* gcc.dg/analyzer/scope-1.c: New test.\n\t* gcc.dg/analyzer/sensitive-1.c: New test.\n\t* gcc.dg/analyzer/setjmp-1.c: New test.\n\t* gcc.dg/analyzer/setjmp-2.c: New test.\n\t* gcc.dg/analyzer/setjmp-3.c: New test.\n\t* gcc.dg/analyzer/setjmp-4.c: New test.\n\t* gcc.dg/analyzer/setjmp-5.c: New test.\n\t* gcc.dg/analyzer/setjmp-6.c: New test.\n\t* gcc.dg/analyzer/setjmp-7.c: New test.\n\t* gcc.dg/analyzer/setjmp-7a.c: New test.\n\t* gcc.dg/analyzer/setjmp-8.c: New test.\n\t* gcc.dg/analyzer/setjmp-9.c: New test.\n\t* gcc.dg/analyzer/signal-1.c: New test.\n\t* gcc.dg/analyzer/signal-2.c: New test.\n\t* gcc.dg/analyzer/signal-3.c: New test.\n\t* gcc.dg/analyzer/signal-4a.c: New test.\n\t* gcc.dg/analyzer/signal-4b.c: New test.\n\t* gcc.dg/analyzer/strcmp-1.c: New test.\n\t* gcc.dg/analyzer/switch.c: New test.\n\t* gcc.dg/analyzer/taint-1.c: New test.\n\t* gcc.dg/analyzer/zlib-1.c: New test.\n\t* gcc.dg/analyzer/zlib-2.c: New test.\n\t* gcc.dg/analyzer/zlib-3.c: New test.\n\t* gcc.dg/analyzer/zlib-4.c: New test.\n\t* gcc.dg/analyzer/zlib-5.c: New test.\n\t* gcc.dg/analyzer/zlib-6.c: New test.\n\t* lib/gcc-defs.exp (dg-check-dot): New procedure.\n\t* lib/target-supports.exp (check_dot_available): New procedure.\n\t(check_effective_target_analyzer): New.\n\t* lib/target-supports-dg.exp (dg-require-dot): New procedure.", "tree": {"sha": "cca8a96a39f87c90df46a389d1777854f97017d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cca8a96a39f87c90df46a389d1777854f97017d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08c8c973c082457a7d6192673e87475f1fdfdbef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c8c973c082457a7d6192673e87475f1fdfdbef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c8c973c082457a7d6192673e87475f1fdfdbef"}], "stats": {"total": 40752, "additions": 40744, "deletions": 8}, "files": [{"sha": "38165123654c86be169d8f9f605adc6b4226d93b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -1,3 +1,81 @@\n+2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (lang_opt_files): Add analyzer.opt.\n+\t(ANALYZER_OBJS): New.\n+\t(OBJS): Add digraph.o, graphviz.o, ordered-hash-map-tests.o,\n+\ttristate.o and ANALYZER_OBJS.\n+\t(TEXI_GCCINT_FILES): Add analyzer.texi.\n+\t* common.opt (-fanalyzer): New driver option.\n+\t* config.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* configure.ac (--disable-analyzer, ENABLE_ANALYZER): New option.\n+\t(gccdepdir): Also create depdir for \"analyzer\" subdir.\n+\t* digraph.cc: New file.\n+\t* digraph.h: New file.\n+\t* doc/analyzer.texi: New file.\n+\t* doc/gccint.texi (\"Static Analyzer\") New menu item.\n+\t(analyzer.texi): Include it.\n+\t* doc/invoke.texi (\"Static Analyzer Options\"): New list and new section.\n+\t(\"Warning Options\"): Add static analysis warnings to the list.\n+\t(-Wno-analyzer-double-fclose): New option.\n+\t(-Wno-analyzer-double-free): New option.\n+\t(-Wno-analyzer-exposure-through-output-file): New option.\n+\t(-Wno-analyzer-file-leak): New option.\n+\t(-Wno-analyzer-free-of-non-heap): New option.\n+\t(-Wno-analyzer-malloc-leak): New option.\n+\t(-Wno-analyzer-possible-null-argument): New option.\n+\t(-Wno-analyzer-possible-null-dereference): New option.\n+\t(-Wno-analyzer-null-argument): New option.\n+\t(-Wno-analyzer-null-dereference): New option.\n+\t(-Wno-analyzer-stale-setjmp-buffer): New option.\n+\t(-Wno-analyzer-tainted-array-index): New option.\n+\t(-Wno-analyzer-use-after-free): New option.\n+\t(-Wno-analyzer-use-of-pointer-in-stale-stack-frame): New option.\n+\t(-Wno-analyzer-use-of-uninitialized-value): New option.\n+\t(-Wanalyzer-too-complex): New option.\n+\t(-fanalyzer-call-summaries): New warning.\n+\t(-fanalyzer-checker=): New warning.\n+\t(-fanalyzer-fine-grained): New warning.\n+\t(-fno-analyzer-state-merge): New warning.\n+\t(-fno-analyzer-state-purge): New warning.\n+\t(-fanalyzer-transitivity): New warning.\n+\t(-fanalyzer-verbose-edges): New warning.\n+\t(-fanalyzer-verbose-state-changes): New warning.\n+\t(-fanalyzer-verbosity=): New warning.\n+\t(-fdump-analyzer): New warning.\n+\t(-fdump-analyzer-callgraph): New warning.\n+\t(-fdump-analyzer-exploded-graph): New warning.\n+\t(-fdump-analyzer-exploded-nodes): New warning.\n+\t(-fdump-analyzer-exploded-nodes-2): New warning.\n+\t(-fdump-analyzer-exploded-nodes-3): New warning.\n+\t(-fdump-analyzer-supergraph): New warning.\n+\t* doc/sourcebuild.texi (dg-require-dot): New.\n+\t(dg-check-dot): New.\n+\t* gdbinit.in (break-on-saved-diagnostic): New command.\n+\t* graphviz.cc: New file.\n+\t* graphviz.h: New file.\n+\t* ordered-hash-map-tests.cc: New file.\n+\t* ordered-hash-map.h: New file.\n+\t* passes.def (pass_analyzer): Add before\n+\tpass_ipa_whole_program_visibility.\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::ordered_hash_map_tests_cc_tests.\n+\t* selftest.h (selftest::ordered_hash_map_tests_cc_tests): New\n+\tdecl.\n+\t* shortest-paths.h: New file.\n+\t* timevar.def (TV_ANALYZER): New timevar.\n+\t(TV_ANALYZER_SUPERGRAPH): Likewise.\n+\t(TV_ANALYZER_STATE_PURGE): Likewise.\n+\t(TV_ANALYZER_PLAN): Likewise.\n+\t(TV_ANALYZER_SCC): Likewise.\n+\t(TV_ANALYZER_WORKLIST): Likewise.\n+\t(TV_ANALYZER_DUMP): Likewise.\n+\t(TV_ANALYZER_DIAGNOSTICS): Likewise.\n+\t(TV_ANALYZER_SHORTEST_PATHS): Likewise.\n+\t* tree-pass.h (make_pass_analyzer): New decl.\n+\t* tristate.cc: New file.\n+\t* tristate.h: New file.\n+\n 2020-01-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/93254"}, {"sha": "5c6d0a737e6a59518ae990572705a0df424ecec9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -567,7 +567,7 @@ xm_include_list=@xm_include_list@\n xm_defines=@xm_defines@\n lang_checks=\n lang_checks_parallelized=\n-lang_opt_files=@lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt $(srcdir)/params.opt\n+lang_opt_files=@lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt $(srcdir)/params.opt $(srcdir)/analyzer/analyzer.opt\n lang_specs_files=@lang_specs_files@\n lang_tree_files=@lang_tree_files@\n target_cpu_default=@target_cpu_default@\n@@ -1214,6 +1214,32 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-ubsan.o c-family/known-headers.o \\\n   c-family/c-attribs.o c-family/c-warn.o c-family/c-spellcheck.o\n \n+# Analyzer object files\n+ANALYZER_OBJS = \\\n+\tanalyzer/analysis-plan.o \\\n+\tanalyzer/analyzer.o \\\n+\tanalyzer/analyzer-logging.o \\\n+\tanalyzer/analyzer-pass.o \\\n+\tanalyzer/analyzer-selftests.o \\\n+\tanalyzer/call-string.o \\\n+\tanalyzer/checker-path.o \\\n+\tanalyzer/constraint-manager.o \\\n+\tanalyzer/diagnostic-manager.o \\\n+\tanalyzer/engine.o \\\n+\tanalyzer/pending-diagnostic.o \\\n+\tanalyzer/program-point.o \\\n+\tanalyzer/program-state.o \\\n+\tanalyzer/region-model.o \\\n+\tanalyzer/sm.o \\\n+\tanalyzer/sm-file.o \\\n+\tanalyzer/sm-malloc.o \\\n+\tanalyzer/sm-pattern-test.o \\\n+\tanalyzer/sm-sensitive.o \\\n+\tanalyzer/sm-signal.o \\\n+\tanalyzer/sm-taint.o \\\n+\tanalyzer/state-purge.o \\\n+\tanalyzer/supergraph.o\n+\n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make\n # will build them sooner, because they are large and otherwise tend to be\n@@ -1283,6 +1309,7 @@ OBJS = \\\n \tdf-problems.o \\\n \tdf-scan.o \\\n \tdfp.o \\\n+\tdigraph.o \\\n \tdojump.o \\\n \tdominance.o \\\n \tdomwalk.o \\\n@@ -1344,6 +1371,7 @@ OBJS = \\\n \tgodump.o \\\n \tgraph.o \\\n \tgraphds.o \\\n+\tgraphviz.o \\\n \tgraphite.o \\\n \tgraphite-isl-ast-to-gimple.o \\\n \tgraphite-dependences.o \\\n@@ -1443,6 +1471,7 @@ OBJS = \\\n \toptinfo-emit-json.o \\\n \toptions-save.o \\\n \topts-global.o \\\n+\tordered-hash-map-tests.o \\\n \tpasses.o \\\n \tplugin.o \\\n \tpostreload-gcse.o \\\n@@ -1600,6 +1629,7 @@ OBJS = \\\n \ttree-vector-builder.o \\\n \ttree-vrp.o \\\n \ttree.o \\\n+\ttristate.o \\\n \ttyped-splay-tree.o \\\n \tunique-ptr-tests.o \\\n \tvaltrack.o \\\n@@ -1617,6 +1647,7 @@ OBJS = \\\n \twide-int-print.o \\\n \txcoffout.o \\\n \t$(out_object_file) \\\n+\t$(ANALYZER_OBJS) \\\n \t$(EXTRA_OBJS) \\\n \t$(host_hook_obj)\n \n@@ -3220,7 +3251,7 @@ TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t gnu.texi gpl_v3.texi fdl.texi contrib.texi languages.texi\t\\\n \t sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi\t\\\n \t loop.texi generic.texi gimple.texi plugins.texi optinfo.texi   \\\n-\t match-and-simplify.texi ux.texi poly-int.texi\n+\t match-and-simplify.texi analyzer.texi ux.texi poly-int.texi\n \n TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi\t\t\\\n \t gcc-common.texi gcc-vers.texi"}, {"sha": "684124357b6683e13c4f176dfceca0e9f55ad5df", "filename": "gcc/analyzer/ChangeLog", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,56 @@\n+2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog: New file.\n+\t* analyzer-selftests.cc: New file.\n+\t* analyzer-selftests.h: New file.\n+\t* analyzer.opt: New file.\n+\t* analysis-plan.cc: New file.\n+\t* analysis-plan.h: New file.\n+\t* analyzer-logging.cc: New file.\n+\t* analyzer-logging.h: New file.\n+\t* analyzer-pass.cc: New file.\n+\t* analyzer.cc: New file.\n+\t* analyzer.h: New file.\n+\t* call-string.cc: New file.\n+\t* call-string.h: New file.\n+\t* checker-path.cc: New file.\n+\t* checker-path.h: New file.\n+\t* constraint-manager.cc: New file.\n+\t* constraint-manager.h: New file.\n+\t* diagnostic-manager.cc: New file.\n+\t* diagnostic-manager.h: New file.\n+\t* engine.cc: New file.\n+\t* engine.h: New file.\n+\t* exploded-graph.h: New file.\n+\t* pending-diagnostic.cc: New file.\n+\t* pending-diagnostic.h: New file.\n+\t* program-point.cc: New file.\n+\t* program-point.h: New file.\n+\t* program-state.cc: New file.\n+\t* program-state.h: New file.\n+\t* region-model.cc: New file.\n+\t* region-model.h: New file.\n+\t* sm-file.cc: New file.\n+\t* sm-malloc.cc: New file.\n+\t* sm-malloc.dot: New file.\n+\t* sm-pattern-test.cc: New file.\n+\t* sm-sensitive.cc: New file.\n+\t* sm-signal.cc: New file.\n+\t* sm-taint.cc: New file.\n+\t* sm.cc: New file.\n+\t* sm.h: New file.\n+\t* state-purge.cc: New file.\n+\t* state-purge.h: New file.\n+\t* supergraph.cc: New file.\n+\t* supergraph.h: New file.\n+\n+2019-12-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Initial creation\n+\n+\f\n+Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."}, {"sha": "8ad2fa2ebb4b8e72496ca4571903e1adf1019812", "filename": "gcc/analyzer/analysis-plan.cc", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalysis-plan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalysis-plan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalysis-plan.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,130 @@\n+/* A class to encapsulate decisions about how the analysis should happen.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"timevar.h\"\n+#include \"ipa-utils.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-core.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/analysis-plan.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* class analysis_plan.  */\n+\n+/* analysis_plan's ctor.  */\n+\n+analysis_plan::analysis_plan (const supergraph &sg, logger *logger)\n+: log_user (logger), m_sg (sg),\n+  m_cgraph_node_postorder (XCNEWVEC (struct cgraph_node *,\n+\t\t\t\t     symtab->cgraph_count)),\n+  m_index_by_uid (symtab->cgraph_max_uid)\n+{\n+  LOG_SCOPE (logger);\n+  auto_timevar time (TV_ANALYZER_PLAN);\n+\n+  m_num_cgraph_nodes = ipa_reverse_postorder (m_cgraph_node_postorder);\n+  gcc_assert (m_num_cgraph_nodes == symtab->cgraph_count);\n+  if (get_logger_file ())\n+    ipa_print_order (get_logger_file (),\n+\t\t     \"analysis_plan\", m_cgraph_node_postorder,\n+\t\t     m_num_cgraph_nodes);\n+\n+  /* Populate m_index_by_uid.  */\n+  for (int i = 0; i < symtab->cgraph_max_uid; i++)\n+    m_index_by_uid.quick_push (-1);\n+  for (int i = 0; i < m_num_cgraph_nodes; i++)\n+    {\n+      gcc_assert (m_cgraph_node_postorder[i]->get_uid ()\n+\t\t  < symtab->cgraph_max_uid);\n+      m_index_by_uid[m_cgraph_node_postorder[i]->get_uid ()] = i;\n+    }\n+}\n+\n+/* analysis_plan's dtor.  */\n+\n+analysis_plan::~analysis_plan ()\n+{\n+  free (m_cgraph_node_postorder);\n+}\n+\n+/* Comparator for use by the exploded_graph's worklist, to order FUN_A\n+   and FUN_B so that functions that are to be summarized are visited\n+   before the summary is needed (based on a sort of the callgraph).  */\n+\n+int\n+analysis_plan::cmp_function (function *fun_a, function *fun_b) const\n+{\n+  cgraph_node *node_a = cgraph_node::get (fun_a->decl);\n+  cgraph_node *node_b = cgraph_node::get (fun_b->decl);\n+\n+  int idx_a = m_index_by_uid[node_a->get_uid ()];\n+  int idx_b = m_index_by_uid[node_b->get_uid ()];\n+\n+  return idx_b - idx_a;\n+}\n+\n+/* Return true if the call EDGE should be analyzed using a call summary.\n+   Return false if it should be analyzed using a full call and return.  */\n+\n+bool\n+analysis_plan::use_summary_p (const cgraph_edge *edge) const\n+{\n+  /* Don't use call summaries if -fno-analyzer-call-summaries.  */\n+  if (!flag_analyzer_call_summaries)\n+    return false;\n+\n+  /* TODO: don't count callsites each time.  */\n+  int num_call_sites = 0;\n+  const cgraph_node *callee = edge->callee;\n+  for (cgraph_edge *edge = callee->callers; edge; edge = edge->next_caller)\n+    ++num_call_sites;\n+\n+  /* Don't use a call summary if there's only one call site.  */\n+  if (num_call_sites <= 1)\n+    return false;\n+\n+  /* Require the callee to be sufficiently complex to be worth\n+     summarizing.  */\n+  if ((int)m_sg.get_num_snodes (callee->get_fun ())\n+      < param_analyzer_min_snodes_for_call_summary)\n+    return false;\n+\n+  return true;\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "a44c79561beedf826c14f3773f14bdbc356d1029", "filename": "gcc/analyzer/analysis-plan.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalysis-plan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalysis-plan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalysis-plan.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,56 @@\n+/* A class to encapsulate decisions about how the analysis should happen.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_ANALYSIS_PLAN_H\n+#define GCC_ANALYZER_ANALYSIS_PLAN_H\n+\n+/* A class to encapsulate decisions about how the analysis should happen.\n+   Examples:\n+   - the order in which functions should be analyzed, so that function\n+     summaries are created before analysis of call sites that might use\n+     them\n+   - which callgraph edges should use call summaries\n+   TODO: the above is a work-in-progress.  */\n+\n+class analysis_plan : public log_user\n+{\n+public:\n+  analysis_plan (const supergraph &sg, logger *logger);\n+  ~analysis_plan ();\n+\n+  int cmp_function (function *fun_a, function *fun_b) const;\n+\n+  bool use_summary_p (const cgraph_edge *edge) const;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (analysis_plan);\n+\n+  const supergraph &m_sg;\n+\n+  /* Result of ipa_reverse_postorder.  */\n+  cgraph_node **m_cgraph_node_postorder;\n+  int m_num_cgraph_nodes;\n+\n+  /* Index of each node within the postorder ordering,\n+     accessed via the \"m_uid\" field.  */\n+  auto_vec<int> m_index_by_uid;\n+};\n+\n+#endif /* GCC_ANALYZER_ANALYSIS_PLAN_H */"}, {"sha": "9a6b36eee3a2287fbd81c1bd6da9074ab099566a", "filename": "gcc/analyzer/analyzer-logging.cc", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-logging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-logging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,224 @@\n+/* Hierarchical log messages for the analyzer.\n+   Copyright (C) 2014-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\" /* for print_version */\n+#include \"pretty-print.h\" /* for print_version */\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\"\n+\n+#include \"analyzer/analyzer-logging.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Implementation of class logger.  */\n+\n+/* ctor for logger.  */\n+\n+logger::logger (FILE *f_out,\n+\t\tint, /* flags */\n+\t\tint /* verbosity */,\n+\t\tconst pretty_printer &reference_pp) :\n+  m_refcount (0),\n+  m_f_out (f_out),\n+  m_indent_level (0),\n+  m_log_refcount_changes (false),\n+  m_pp (reference_pp.clone ())\n+{\n+  pp_show_color (m_pp) = 0;\n+  pp_buffer (m_pp)->stream = f_out;\n+\n+  /* %qE in logs for SSA_NAMEs should show the ssa names, rather than\n+     trying to prettify things by showing the underlying var.  */\n+  pp_format_decoder (m_pp) = default_tree_printer;\n+\n+  /* Begin the log by writing the GCC version.  */\n+  print_version (f_out, \"\", false);\n+}\n+\n+/* The destructor for logger, invoked via\n+   the decref method when the refcount hits zero.\n+   Note that we do not close the underlying FILE * (m_f_out).  */\n+\n+logger::~logger ()\n+{\n+  /* This should be the last message emitted.  */\n+  log (\"%s\", __PRETTY_FUNCTION__);\n+  gcc_assert (m_refcount == 0);\n+  delete m_pp;\n+}\n+\n+/* Increment the reference count of the logger.  */\n+\n+void\n+logger::incref (const char *reason)\n+{\n+  m_refcount++;\n+  if (m_log_refcount_changes)\n+    log (\"%s: reason: %s refcount now %i \",\n+\t __PRETTY_FUNCTION__, reason, m_refcount);\n+}\n+\n+/* Decrement the reference count of the logger,\n+   deleting it if nothing is referring to it.  */\n+\n+void\n+logger::decref (const char *reason)\n+{\n+  gcc_assert (m_refcount > 0);\n+  --m_refcount;\n+  if (m_log_refcount_changes)\n+    log (\"%s: reason: %s refcount now %i\",\n+\t __PRETTY_FUNCTION__, reason, m_refcount);\n+  if (m_refcount == 0)\n+    delete this;\n+}\n+\n+/* Write a formatted message to the log, by calling the log_va method.  */\n+\n+void\n+logger::log (const char *fmt, ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+  log_va (fmt, &ap);\n+  va_end (ap);\n+}\n+\n+/* Write an indented line to the log file.\n+\n+   We explicitly flush after each line: if something crashes the process,\n+   we want the logfile/stream to contain the most up-to-date hint about the\n+   last thing that was happening, without it being hidden in an in-process\n+   buffer.  */\n+\n+void\n+logger::log_va (const char *fmt, va_list *ap)\n+{\n+  start_log_line ();\n+  log_va_partial (fmt, ap);\n+  end_log_line ();\n+}\n+\n+void\n+logger::start_log_line ()\n+{\n+  for (int i = 0; i < m_indent_level; i++)\n+    fputc (' ', m_f_out);\n+}\n+\n+void\n+logger::log_partial (const char *fmt, ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+  log_va_partial (fmt, &ap);\n+  va_end (ap);\n+}\n+\n+void\n+logger::log_va_partial (const char *fmt, va_list *ap)\n+{\n+  text_info text;\n+  text.format_spec = fmt;\n+  text.args_ptr = ap;\n+  text.err_no = 0;\n+  pp_format (m_pp, &text);\n+  pp_output_formatted_text (m_pp);\n+}\n+\n+void\n+logger::end_log_line ()\n+{\n+  pp_flush (m_pp);\n+  pp_clear_output_area (m_pp);\n+  fprintf (m_f_out, \"\\n\");\n+  fflush (m_f_out);\n+}\n+\n+/* Record the entry within a particular scope, indenting subsequent\n+   log lines accordingly.  */\n+\n+void\n+logger::enter_scope (const char *scope_name)\n+{\n+  log (\"entering: %s\", scope_name);\n+  m_indent_level += 1;\n+}\n+\n+void\n+logger::enter_scope (const char *scope_name, const char *fmt, va_list *ap)\n+{\n+  start_log_line ();\n+  log_partial (\"entering: %s: \", scope_name);\n+  log_va_partial (fmt, ap);\n+  end_log_line ();\n+\n+  m_indent_level += 1;\n+}\n+\n+\n+/* Record the exit from a particular scope, restoring the indent level to\n+   before the scope was entered.  */\n+\n+void\n+logger::exit_scope (const char *scope_name)\n+{\n+  if (m_indent_level)\n+    m_indent_level -= 1;\n+  else\n+    log (\"(mismatching indentation)\");\n+  log (\"exiting: %s\", scope_name);\n+}\n+\n+/* Implementation of class log_user.  */\n+\n+/* The constructor for log_user.  */\n+\n+log_user::log_user (logger *logger) : m_logger (logger)\n+{\n+  if (m_logger)\n+    m_logger->incref(\"log_user ctor\");\n+}\n+\n+/* The destructor for log_user.  */\n+\n+log_user::~log_user ()\n+{\n+  if (m_logger)\n+    m_logger->decref(\"log_user dtor\");\n+}\n+\n+/* Set the logger for a log_user, managing the reference counts\n+   of the old and new logger (either of which might be NULL).  */\n+\n+void\n+log_user::set_logger (logger *logger)\n+{\n+  if (logger)\n+    logger->incref (\"log_user::set_logger\");\n+  if (m_logger)\n+    m_logger->decref (\"log_user::set_logger\");\n+  m_logger = logger;\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "9d5364bfa8fa58edf3c8d4d22709bd329592b924", "filename": "gcc/analyzer/analyzer-logging.h", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-logging.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-logging.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,260 @@\n+/* Hierarchical log messages for the analyzer.\n+   Copyright (C) 2014-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Adapted from jit-logging.h.  */\n+\n+#ifndef ANALYZER_LOGGING_H\n+#define ANALYZER_LOGGING_H\n+\n+/* A logger encapsulates a logging stream: a way to send\n+   lines of pertinent information to a FILE *.  */\n+\n+class logger\n+{\n+ public:\n+  logger (FILE *f_out, int flags, int verbosity, const pretty_printer &reference_pp);\n+  ~logger ();\n+\n+  void incref (const char *reason);\n+  void decref (const char *reason);\n+\n+  void log (const char *fmt, ...)\n+    ATTRIBUTE_GCC_DIAG(2, 3);\n+  void log_va (const char *fmt, va_list *ap)\n+    ATTRIBUTE_GCC_DIAG(2, 0);\n+  void start_log_line ();\n+  void log_partial (const char *fmt, ...)\n+    ATTRIBUTE_GCC_DIAG(2, 3);\n+  void log_va_partial (const char *fmt, va_list *ap)\n+    ATTRIBUTE_GCC_DIAG(2, 0);\n+  void end_log_line ();\n+\n+  void enter_scope (const char *scope_name);\n+  void enter_scope (const char *scope_name, const char *fmt, va_list *ap)\n+    ATTRIBUTE_GCC_DIAG(3, 0);\n+  void exit_scope (const char *scope_name);\n+\n+  pretty_printer *get_printer () const { return m_pp; }\n+  FILE *get_file () const { return m_f_out; }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (logger);\n+\n+  int m_refcount;\n+  FILE *m_f_out;\n+  int m_indent_level;\n+  bool m_log_refcount_changes;\n+  pretty_printer *m_pp;\n+};\n+\n+/* The class log_scope is an RAII-style class intended to make\n+   it easy to notify a logger about entering and exiting the body of a\n+   given function.  */\n+\n+class log_scope\n+{\n+public:\n+  log_scope (logger *logger, const char *name);\n+  log_scope (logger *logger, const char *name, const char *fmt, ...)\n+    ATTRIBUTE_GCC_DIAG(4, 5);\n+  ~log_scope ();\n+\n+ private:\n+  DISABLE_COPY_AND_ASSIGN (log_scope);\n+\n+  logger *m_logger;\n+  const char *m_name;\n+};\n+\n+/* The constructor for log_scope.\n+\n+   The normal case is that the logger is NULL, in which case this should\n+   be largely a no-op.\n+\n+   If we do have a logger, notify it that we're entering the given scope.\n+   We also need to hold a reference on it, to avoid a use-after-free\n+   when logging the cleanup of the owner of the logger.  */\n+\n+inline\n+log_scope::log_scope (logger *logger, const char *name) :\n+ m_logger (logger),\n+ m_name (name)\n+{\n+  if (m_logger)\n+    {\n+      m_logger->incref (\"log_scope ctor\");\n+      m_logger->enter_scope (m_name);\n+    }\n+}\n+\n+inline\n+log_scope::log_scope (logger *logger, const char *name, const char *fmt, ...):\n+ m_logger (logger),\n+ m_name (name)\n+{\n+  if (m_logger)\n+    {\n+      m_logger->incref (\"log_scope ctor\");\n+      va_list ap;\n+      va_start (ap, fmt);\n+      m_logger->enter_scope (m_name, fmt, &ap);\n+      va_end (ap);\n+    }\n+}\n+\n+\n+/* The destructor for log_scope; essentially the opposite of\n+   the constructor.  */\n+\n+inline\n+log_scope::~log_scope ()\n+{\n+  if (m_logger)\n+    {\n+      m_logger->exit_scope (m_name);\n+      m_logger->decref (\"log_scope dtor\");\n+    }\n+}\n+\n+/* A log_user is something that potentially uses a logger (which could be NULL).\n+\n+   The log_user class keeps the reference-count of a logger up-to-date.  */\n+\n+class log_user\n+{\n+ public:\n+  log_user (logger *logger);\n+  ~log_user ();\n+\n+  logger * get_logger () const { return m_logger; }\n+  void set_logger (logger * logger);\n+\n+  void log (const char *fmt, ...) const\n+    ATTRIBUTE_GCC_DIAG(2, 3);\n+\n+  void start_log_line () const;\n+  void end_log_line () const;\n+\n+  void enter_scope (const char *scope_name);\n+  void exit_scope (const char *scope_name);\n+\n+  pretty_printer *get_logger_pp () const\n+  {\n+    gcc_assert (m_logger);\n+    return m_logger->get_printer ();\n+  }\n+\n+  FILE *get_logger_file () const\n+  {\n+    if (m_logger == NULL)\n+      return NULL;\n+    return m_logger->get_file ();\n+  }\n+\n+ private:\n+  DISABLE_COPY_AND_ASSIGN (log_user);\n+\n+  logger *m_logger;\n+};\n+\n+/* A shortcut for calling log from a log_user, handling the common\n+   case where the underlying logger is NULL via a no-op.  */\n+\n+inline void\n+log_user::log (const char *fmt, ...) const\n+{\n+  if (m_logger)\n+    {\n+      va_list ap;\n+      va_start (ap, fmt);\n+      m_logger->log_va (fmt, &ap);\n+      va_end (ap);\n+    }\n+}\n+\n+/* A shortcut for starting a log line from a log_user,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::start_log_line () const\n+{\n+  if (m_logger)\n+    m_logger->start_log_line ();\n+}\n+\n+/* A shortcut for ending a log line from a log_user,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::end_log_line () const\n+{\n+  if (m_logger)\n+    m_logger->end_log_line ();\n+}\n+\n+/* A shortcut for recording entry into a scope from a log_user,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::enter_scope (const char *scope_name)\n+{\n+  if (m_logger)\n+    m_logger->enter_scope (scope_name);\n+}\n+\n+/* A shortcut for recording exit from a scope from a log_user,\n+   handling the common case where the underlying logger is NULL via\n+   a no-op.  */\n+\n+inline void\n+log_user::exit_scope (const char *scope_name)\n+{\n+  if (m_logger)\n+    m_logger->exit_scope (scope_name);\n+}\n+\n+/* If the given logger is non-NULL, log entry/exit of this scope to\n+   it, identifying it using __PRETTY_FUNCTION__.  */\n+\n+#define LOG_SCOPE(LOGGER)\t\t\\\n+  log_scope s (LOGGER, __PRETTY_FUNCTION__)\n+\n+/* If the given logger is non-NULL, log entry/exit of this scope to\n+   it, identifying it using __func__.  */\n+\n+#define LOG_FUNC(LOGGER) \\\n+  log_scope s (LOGGER, __func__)\n+\n+#define LOG_FUNC_1(LOGGER, FMT, A0)\t\\\n+  log_scope s (LOGGER, __func__, FMT, A0)\n+\n+#define LOG_FUNC_2(LOGGER, FMT, A0, A1)\t\t\\\n+  log_scope s (LOGGER, __func__, FMT, A0, A1)\n+\n+#define LOG_FUNC_3(LOGGER, FMT, A0, A1, A2)\t\\\n+  log_scope s (LOGGER, __func__, FMT, A0, A1, A2)\n+\n+#define LOG_FUNC_4(LOGGER, FMT, A0, A1, A2, A3) \\\n+  log_scope s (LOGGER, __func__, FMT, A0, A1, A2, A3)\n+\n+#endif /* ANALYZER_LOGGING_H */"}, {"sha": "4070e6d44b5a3fb63f14f5d5f778768ee143fb91", "filename": "gcc/analyzer/analyzer-pass.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-pass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-pass.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,102 @@\n+/* Integration of the analyzer with GCC's pass manager.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"context.h\"\n+#include \"tree-pass.h\"\n+#include \"diagnostic.h\"\n+#include \"options.h\"\n+#include \"analyzer/engine.h\"\n+\n+namespace {\n+\n+/* Data for the analyzer pass.  */\n+\n+const pass_data pass_data_analyzer =\n+{\n+  IPA_PASS, /* type */\n+  \"analyzer\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_ANALYZER, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+/* The analyzer pass.  */\n+\n+class pass_analyzer : public ipa_opt_pass_d\n+{\n+public:\n+   pass_analyzer(gcc::context *ctxt)\n+   : ipa_opt_pass_d (pass_data_analyzer, ctxt,\n+\t\t     NULL, /* generate_summary */\n+\t\t     NULL, /* write_summary */\n+\t\t     NULL, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) FINAL OVERRIDE;\n+  unsigned int execute (function *) FINAL OVERRIDE;\n+}; // class pass_analyzer\n+\n+/* Only run the analyzer if -fanalyzer.  */\n+\n+bool\n+pass_analyzer::gate (function *)\n+{\n+  return flag_analyzer != 0;\n+}\n+\n+/* Entrypoint for the analyzer pass.  */\n+\n+unsigned int\n+pass_analyzer::execute (function *)\n+{\n+#if ENABLE_ANALYZER\n+  run_checkers ();\n+#else\n+  sorry (\"%qs was not enabled in this build of GCC\"\n+\t \" (missing configure-time option %qs)\",\n+\t \"-fanalyzer\", \"--enable-analyzer\");\n+#endif\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+/* Make an instance of the analyzer pass.  */\n+\n+ipa_opt_pass_d *\n+make_pass_analyzer (gcc::context *ctxt)\n+{\n+  return new pass_analyzer (ctxt);\n+}"}, {"sha": "8f52ce2e45caf253d319ddc15442c1dfbd5a6dbb", "filename": "gcc/analyzer/analyzer-selftests.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-selftests.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,61 @@\n+/* Selftest support for the analyzer.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Build a VAR_DECL named NAME of type TYPE, simulating a file-level\n+   static variable.  */\n+\n+tree\n+build_global_decl (const char *name, tree type)\n+{\n+  tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t  get_identifier (name), type);\n+  TREE_STATIC (decl) = 1;\n+  return decl;\n+}\n+\n+/* Run all analyzer-specific selftests.  */\n+\n+void\n+run_analyzer_selftests ()\n+{\n+#if ENABLE_ANALYZER\n+  analyzer_constraint_manager_cc_tests ();\n+  analyzer_program_point_cc_tests ();\n+  analyzer_program_state_cc_tests ();\n+  analyzer_region_model_cc_tests ();\n+#endif /* #if ENABLE_ANALYZER */\n+}\n+\n+} /* end of namespace selftest.  */\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "6f08aa2b1bc04ac5ca7271cbe3f7218aad1991c0", "filename": "gcc/analyzer/analyzer-selftests.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-selftests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer-selftests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-selftests.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,44 @@\n+/* Selftests for the analyzer.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_SELFTESTS_H\n+#define GCC_ANALYZER_SELFTESTS_H\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+extern tree build_global_decl (const char *name, tree type);\n+\n+extern void run_analyzer_selftests ();\n+\n+/* Declarations for specific families of tests (by source file), in\n+   alphabetical order.  */\n+extern void analyzer_checker_script_cc_tests ();\n+extern void analyzer_constraint_manager_cc_tests ();\n+extern void analyzer_program_point_cc_tests ();\n+extern void analyzer_program_state_cc_tests ();\n+extern void analyzer_region_model_cc_tests ();\n+\n+} /* end of namespace selftest.  */\n+\n+#endif /* #if CHECKING_P */\n+\n+#endif /* GCC_ANALYZER_SELFTESTS_H */"}, {"sha": "2a3ffaee852fd692bb6e71859d00c035b93c75d9", "filename": "gcc/analyzer/analyzer.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,151 @@\n+/* Utility functions for the analyzer.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"diagnostic.h\"\n+#include \"intl.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Helper function for checkers.  Is the CALL to the given function name,\n+   and with the given number of arguments?\n+\n+   This doesn't resolve function pointers via the region model;\n+   is_named_call_p should be used instead, using a fndecl from\n+   get_fndecl_for_call; this function should only be used for special cases\n+   where it's not practical to get at the region model, or for special\n+   analyzer functions such as __analyzer_dump.  */\n+\n+bool\n+is_special_named_call_p (const gcall *call, const char *funcname,\n+\t\t\t unsigned int num_args)\n+{\n+  gcc_assert (funcname);\n+\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return false;\n+\n+  return is_named_call_p (fndecl, funcname, call, num_args);\n+}\n+\n+/* Helper function for checkers.  Does FNDECL have the given FUNCNAME?  */\n+\n+bool\n+is_named_call_p (tree fndecl, const char *funcname)\n+{\n+  gcc_assert (fndecl);\n+  gcc_assert (funcname);\n+\n+  return 0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), funcname);\n+}\n+\n+/* Helper function for checkers.  Does FNDECL have the given FUNCNAME, and\n+   does CALL have the given number of arguments?  */\n+\n+bool\n+is_named_call_p (tree fndecl, const char *funcname,\n+\t\t const gcall *call, unsigned int num_args)\n+{\n+  gcc_assert (fndecl);\n+  gcc_assert (funcname);\n+\n+  if (!is_named_call_p (fndecl, funcname))\n+    return false;\n+\n+  if (gimple_call_num_args (call) != num_args)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if stmt is a setjmp call.  */\n+\n+bool\n+is_setjmp_call_p (const gimple *stmt)\n+{\n+  /* TODO: is there a less hacky way to check for \"setjmp\"?  */\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    if (is_special_named_call_p (call, \"_setjmp\", 1))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return true if stmt is a longjmp call.  */\n+\n+bool\n+is_longjmp_call_p (const gcall *call)\n+{\n+  /* TODO: is there a less hacky way to check for \"longjmp\"?  */\n+  if (is_special_named_call_p (call, \"longjmp\", 2))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Generate a label_text instance by formatting FMT, using a\n+   temporary clone of the global_dc's printer (thus using its\n+   formatting callbacks).\n+\n+   Colorize if the global_dc supports colorization and CAN_COLORIZE is\n+   true.  */\n+\n+label_text\n+make_label_text (bool can_colorize, const char *fmt, ...)\n+{\n+  pretty_printer *pp = global_dc->printer->clone ();\n+  pp_clear_output_area (pp);\n+\n+  if (!can_colorize)\n+    pp_show_color (pp) = false;\n+\n+  text_info ti;\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n+\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+\n+  ti.format_spec = _(fmt);\n+  ti.args_ptr = &ap;\n+  ti.err_no = 0;\n+  ti.x_data = NULL;\n+  ti.m_richloc = &rich_loc;\n+\n+  pp_format (pp, &ti);\n+  pp_output_formatted_text (pp);\n+\n+  va_end (ap);\n+\n+  label_text result = label_text::take (xstrdup (pp_formatted_text (pp)));\n+  delete pp;\n+  return result;\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "e207d7a94368a05a4dd1abc78b00dbd26cc1757c", "filename": "gcc/analyzer/analyzer.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,122 @@\n+/* Utility functions for the analyzer.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_ANALYZER_H\n+#define GCC_ANALYZER_ANALYZER_H\n+\n+/* Forward decls of common types, with indentation to show inheritance.  */\n+\n+class graphviz_out;\n+class supergraph;\n+class supernode;\n+class superedge;\n+  class cfg_superedge;\n+    class switch_cfg_superedge;\n+  class callgraph_superedge;\n+    class call_superedge;\n+    class return_superedge;\n+class svalue;\n+  class region_svalue;\n+  class constant_svalue;\n+  class poisoned_svalue;\n+  class unknown_svalue;\n+  class setjmp_svalue;\n+class region;\n+  class map_region;\n+  class symbolic_region;\n+class region_model;\n+class region_model_context;\n+  class impl_region_model_context;\n+class constraint_manager;\n+class equiv_class;\n+struct model_merger;\n+struct svalue_id_merger_mapping;\n+struct canonicalization;\n+class pending_diagnostic;\n+class state_change_event;\n+class checker_path;\n+class extrinsic_state;\n+class sm_state_map;\n+class stmt_finder;\n+class program_point;\n+class program_state;\n+class exploded_graph;\n+class exploded_node;\n+class exploded_edge;\n+class exploded_cluster;\n+class exploded_path;\n+class analysis_plan;\n+class state_purge_map;\n+class state_purge_per_ssa_name;\n+class state_change;\n+class rewind_info_t;\n+\n+extern bool is_special_named_call_p (const gcall *call, const char *funcname,\n+\t\t\t\t     unsigned int num_args);\n+extern bool is_named_call_p (tree fndecl, const char *funcname);\n+extern bool is_named_call_p (tree fndecl, const char *funcname,\n+\t\t\t     const gcall *call, unsigned int num_args);\n+extern bool is_setjmp_call_p (const gimple *stmt);\n+extern bool is_longjmp_call_p (const gcall *call);\n+\n+extern void register_analyzer_pass ();\n+\n+extern label_text make_label_text (bool can_colorize, const char *fmt, ...);\n+\n+/* An RAII-style class for pushing/popping cfun within a scope.\n+   Doing so ensures we get \"In function \" announcements\n+   from the diagnostics subsystem.  */\n+\n+class auto_cfun\n+{\n+public:\n+  auto_cfun (function *fun) { push_cfun (fun); }\n+  ~auto_cfun () { pop_cfun (); }\n+};\n+\n+/* Begin suppressing -Wformat and -Wformat-extra-args.  */\n+\n+#define PUSH_IGNORE_WFORMAT \\\n+  _Pragma(\"GCC diagnostic push\") \\\n+  _Pragma(\"GCC diagnostic ignored \\\"-Wformat\\\"\") \\\n+  _Pragma(\"GCC diagnostic ignored \\\"-Wformat-extra-args\\\"\")\n+\n+/* Finish suppressing -Wformat and -Wformat-extra-args.  */\n+\n+#define POP_IGNORE_WFORMAT \\\n+  _Pragma(\"GCC diagnostic pop\")\n+\n+/* A template for creating hash traits for a POD type.  */\n+\n+template <typename Type>\n+struct pod_hash_traits : typed_noop_remove<Type>\n+{\n+  typedef Type value_type;\n+  typedef Type compare_type;\n+  static inline hashval_t hash (value_type);\n+  static inline bool equal (const value_type &existing,\n+\t\t\t    const value_type &candidate);\n+  static inline void mark_deleted (Type &);\n+  static inline void mark_empty (Type &);\n+  static inline bool is_deleted (Type);\n+  static inline bool is_empty (Type);\n+};\n+\n+#endif /* GCC_ANALYZER_ANALYZER_H */"}, {"sha": "af8d81d697aba2beecd91b51bb1b8c79f8af7bc8", "filename": "gcc/analyzer/analyzer.opt", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,181 @@\n+; analyzer.opt -- Options for the analyzer.\n+\n+; Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+-param=analyzer-bb-explosion-factor=\n+Common Joined UInteger Var(param_analyzer_bb_explosion_factor) Init(5) Param\n+The maximum number of 'after supernode' exploded nodes within the analyzer per supernode, before terminating analysis.\n+\n+-param=analyzer-max-enodes-per-program-point=\n+Common Joined UInteger Var(param_analyzer_max_enodes_per_program_point) Init(8) Param\n+The maximum number of exploded nodes per program point within the analyzer, before terminating analysis of that point.\n+\n+-param=analyzer-max-recursion-depth=\n+Common Joined UInteger Var(param_analyzer_max_recursion_depth) Init(2) Param\n+The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call tha would recurse deeper.\n+\n+-param=analyzer-min-snodes-for-call-summary=\n+Common Joined UInteger Var(param_analyzer_min_snodes_for_call_summary) Init(10) Param\n+The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.\n+\n+Wanalyzer-double-fclose\n+Common Var(warn_analyzer_double_fclose) Init(1) Warning\n+Warn about code paths in which a stdio FILE can be closed more than once.\n+\n+Wanalyzer-double-free\n+Common Var(warn_analyzer_double_free) Init(1) Warning\n+Warn about code paths in which a pointer can be freed more than once.\n+\n+Wanalyzer-exposure-through-output-file\n+Common Var(warn_analyzer_exposure_through_output_file) Init(1) Warning\n+Warn about code paths in which sensitive data is written to a file.\n+\n+Wanalyzer-file-leak\n+Common Var(warn_analyzer_file_leak) Init(1) Warning\n+Warn about code paths in which a stdio FILE is not closed.\n+\n+Wanalyzer-free-of-non-heap\n+Common Var(warn_analyzer_free_of_non_heap) Init(1) Warning\n+Warn about code paths in which a non-heap pointer is freed.\n+\n+Wanalyzer-malloc-leak\n+Common Var(warn_analyzer_malloc_leak) Init(1) Warning\n+Warn about code paths in which a heap-allocated pointer leaks.\n+\n+Wanalyzer-possible-null-argument\n+Common Var(warn_analyzer_possible_null_argument) Init(1) Warning\n+Warn about code paths in which a possibly-NULL value is passed to a must-not-be-NULL function argument.\n+\n+Wanalyzer-possible-null-dereference\n+Common Var(warn_analyzer_possible_null_dereference) Init(1) Warning\n+Warn about code paths in which a possibly-NULL pointer is dereferenced.\n+\n+Wanalyzer-unsafe-call-within-signal-handler\n+Common Var(warn_analyzer_unsafe_call_within_signal_handler) Init(1) Warning\n+Warn about code paths in which an async-signal-unsafe function is called from a signal handler.\n+\n+Wanalyzer-null-argument\n+Common Var(warn_analyzer_null_argument) Init(1) Warning\n+Warn about code paths in which NULL is passed to a must-not-be-NULL function argument.\n+\n+Wanalyzer-null-dereference\n+Common Var(warn_analyzer_null_dereference) Init(1) Warning\n+Warn about code paths in which a NULL pointer is dereferenced.\n+\n+Wanalyzer-stale-setjmp-buffer\n+Common Var(warn_analyzer_stale_setjmp_buffer) Init(1) Warning\n+Warn about code paths in which a longjmp rewinds to a jmp_buf saved in a stack frame that has returned.\n+\n+Wanalyzer-tainted-array-index\n+Common Var(warn_analyzer_tainted_array_index) Init(1) Warning\n+Warn about code paths in which an unsanitized value is used as an array index.\n+\n+Wanalyzer-use-after-free\n+Common Var(warn_analyzer_use_after_free) Init(1) Warning\n+Warn about code paths in which a freed value is used.\n+\n+Wanalyzer-use-of-pointer-in-stale-stack-frame\n+Common Var(warn_analyzer_use_of_pointer_in_stale_stack_frame) Init(1) Warning\n+Warn about code paths in which a pointer to a stale stack frame is used.\n+\n+Wanalyzer-use-of-uninitialized-value\n+Common Var(warn_analyzer_use_of_uninitialized_value) Init(1) Warning\n+Warn about code paths in which an initialized value is used.\n+\n+Wanalyzer-too-complex\n+Common Var(warn_analyzer_too_complex) Init(0) Warning\n+Warn if the code is too complicated for the analyzer to fully explore.\n+\n+fanalyzer-checker=\n+Common Joined RejectNegative Var(flag_analyzer_checker)\n+Restrict the analyzer to run just the named checker.\n+\n+fanalyzer-fine-grained\n+Common Var(flag_analyzer_fine_grained) Init(0)\n+Avoid combining multiple statements into one exploded edge.\n+\n+fanalyzer-state-purge\n+Common Var(flag_analyzer_state_purge) Init(1)\n+Purge unneeded state during analysis.\n+\n+fanalyzer-state-merge\n+Common Var(flag_analyzer_state_merge) Init(1)\n+Merge similar-enough states during analysis.\n+\n+fanalyzer-transitivity\n+Common Var(flag_analyzer_transitivity) Init(0)\n+Enable transitivity of constraints during analysis.\n+\n+fanalyzer-call-summaries\n+Common Var(flag_analyzer_call_summaries) Init(0)\n+Approximate the effect of function calls to simplify analysis.\n+\n+fanalyzer-verbose-edges\n+Common Var(flag_analyzer_verbose_edges) Init(0)\n+Emit more verbose descriptions of control flow in diagnostics.\n+\n+fanalyzer-verbose-state-changes\n+Common Var(flag_analyzer_verbose_state_changes) Init(0)\n+Emit more verbose descriptions of state changes in diagnostics.\n+\n+fanalyzer-verbosity=\n+Common Joined UInteger Var(analyzer_verbosity) Init(2)\n+Control which events are displayed in diagnostic paths.\n+\n+fdump-analyzer\n+Common RejectNegative Var(flag_dump_analyzer)\n+Dump internal details about what the analyzer is doing to SRCFILE.analyzer.txt.\n+\n+fdump-analyzer-stderr\n+Common RejectNegative Var(flag_dump_analyzer_stderr)\n+Dump internal details about what the analyzer is doing to stderr.\n+\n+fdump-analyzer-callgraph\n+Common RejectNegative Var(flag_dump_analyzer_callgraph)\n+Dump the analyzer supergraph to a SRCFILE.callgraph.dot file.\n+\n+fdump-analyzer-exploded-graph\n+Common RejectNegative Var(flag_dump_analyzer_exploded_graph)\n+Dump the analyzer exploded graph to a SRCFILE.eg.dot file.\n+\n+fdump-analyzer-exploded-nodes\n+Common RejectNegative Var(flag_dump_analyzer_exploded_nodes)\n+Emit diagnostics showing the location of nodes in the exploded graph.\n+\n+fdump-analyzer-exploded-nodes-2\n+Common RejectNegative Var(flag_dump_analyzer_exploded_nodes_2)\n+Dump a textual representation of the exploded graph to SRCFILE.eg.txt.\n+\n+fdump-analyzer-exploded-nodes-3\n+Common RejectNegative Var(flag_dump_analyzer_exploded_nodes_3)\n+Dump a textual representation of the exploded graph to SRCFILE.eg-ID.txt.\n+\n+fdump-analyzer-state-purge\n+Common RejectNegative Var(flag_dump_analyzer_state_purge)\n+Dump state-purging information to a SRCFILE.state-purge.dot file.\n+\n+fdump-analyzer-supergraph\n+Common RejectNegative Var(flag_dump_analyzer_supergraph)\n+Dump the analyzer supergraph to a SRCFILE.supergraph.dot file.\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "3d398c39a88c7f09e4727d755fe40b5c7d912c04", "filename": "gcc/analyzer/call-string.cc", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,233 @@\n+/* Call stacks at program points.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"pretty-print.h\"\n+#include \"tree.h\"\n+#include \"options.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* class call_string.  */\n+\n+/* call_string's copy ctor.  */\n+\n+call_string::call_string (const call_string &other)\n+: m_return_edges (other.m_return_edges.length ())\n+{\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (other.m_return_edges, i, e)\n+    m_return_edges.quick_push (e);\n+}\n+\n+/* call_string's assignment operator.  */\n+\n+call_string&\n+call_string::operator= (const call_string &other)\n+{\n+  // would be much simpler if we could rely on vec<> assignment op\n+  m_return_edges.truncate (0);\n+  m_return_edges.reserve (other.m_return_edges.length (), true);\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (other.m_return_edges, i, e)\n+    m_return_edges.quick_push (e);\n+  return *this;\n+}\n+\n+/* call_string's equality operator.  */\n+\n+bool\n+call_string::operator== (const call_string &other) const\n+{\n+  if (m_return_edges.length () != other.m_return_edges.length ())\n+    return false;\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    if (e != other.m_return_edges[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Print this to PP.  */\n+\n+void\n+call_string::print (pretty_printer *pp) const\n+{\n+  pp_string (pp, \"[\");\n+\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      pp_printf (pp, \"(SN: %i -> SN: %i in %s)\",\n+\t\t e->m_src->m_index, e->m_dest->m_index,\n+\t\t function_name (e->m_dest->m_fun));\n+    }\n+\n+  pp_string (pp, \"]\");\n+}\n+\n+/* Generate a hash value for this call_string.  */\n+\n+hashval_t\n+call_string::hash () const\n+{\n+  inchash::hash hstate;\n+  int i;\n+  const return_superedge *e;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    hstate.add_ptr (e);\n+  return hstate.end ();\n+}\n+\n+/* Push the return superedge for CALL_SEDGE onto the end of this\n+   call_string.  */\n+\n+void\n+call_string::push_call (const supergraph &sg,\n+\t\t\tconst call_superedge *call_sedge)\n+{\n+  gcc_assert (call_sedge);\n+  const return_superedge *return_sedge = call_sedge->get_edge_for_return (sg);\n+  gcc_assert (return_sedge);\n+  m_return_edges.safe_push (return_sedge);\n+}\n+\n+/* Count the number of times the top-most call site appears in the\n+   stack.  */\n+\n+int\n+call_string::calc_recursion_depth () const\n+{\n+  if (m_return_edges.is_empty ())\n+    return 0;\n+  const return_superedge *top_return_sedge\n+    = m_return_edges[m_return_edges.length () - 1];\n+\n+  int result = 0;\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    if (e == top_return_sedge)\n+      ++result;\n+  return result;\n+}\n+\n+/* Comparator for call strings.\n+   Return negative if A is before B.\n+   Return positive if B is after A.\n+   Return 0 if they are equal.  */\n+\n+int\n+call_string::cmp (const call_string &a,\n+\t\t  const call_string &b)\n+{\n+  int result = cmp_1 (a, b);\n+\n+  /* Check that the ordering is symmetric  */\n+#if CHECKING_P\n+  int reversed = cmp_1 (b, a);\n+  gcc_assert (reversed == -result);\n+#endif\n+\n+  /* We should only have 0 for equal pairs.  */\n+  gcc_assert (result != 0\n+\t      || a == b);\n+\n+  return result;\n+}\n+\n+/* Implementation of call_string::cmp.\n+   This implements a version of lexicographical order.  */\n+\n+int\n+call_string::cmp_1 (const call_string &a,\n+\t\t    const call_string &b)\n+{\n+  unsigned len_a = a.length ();\n+  unsigned len_b = b.length ();\n+\n+  unsigned i = 0;\n+  while (1)\n+    {\n+      /* Consider index i; the strings have been equal up to it.  */\n+\n+      /* Have both strings run out?  */\n+      if (i >= len_a && i >= len_b)\n+\treturn 0;\n+\n+      /* Otherwise, has just one of the strings run out?  */\n+      if (i >= len_a)\n+\treturn 1;\n+      if (i >= len_b)\n+\treturn -1;\n+\n+      /* Otherwise, compare the edges.  */\n+      const return_superedge *edge_a = a[i];\n+      const return_superedge *edge_b = b[i];\n+      int src_cmp = edge_a->m_src->m_index - edge_b->m_src->m_index;\n+      if (src_cmp)\n+\treturn src_cmp;\n+      int dest_cmp = edge_a->m_dest->m_index - edge_b->m_dest->m_index;\n+      if (dest_cmp)\n+\treturn dest_cmp;\n+      i++;\n+      // TODO: test coverage for this\n+    }\n+}\n+\n+/* Assert that this object is sane.  */\n+\n+void\n+call_string::validate () const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  /* Each entry's \"caller\" should be the \"callee\" of the previous entry.  */\n+  const return_superedge *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_return_edges, i, e)\n+    if (i > 0)\n+      gcc_assert (e->get_caller_function ()\n+\t\t  == m_return_edges[i - 1]->get_callee_function ());\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "d0b25099336c83f060f0c1b9a009654f1cb692a6", "filename": "gcc/analyzer/call-string.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fcall-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fcall-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,76 @@\n+/* Call stacks at program points.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CALL_STRING_H\n+#define GCC_ANALYZER_CALL_STRING_H\n+\n+class supergraph;\n+class call_superedge;\n+class return_superedge;\n+\n+/* A string of return_superedge pointers, representing a call stack\n+   at a program point.\n+\n+   This is used to ensure that we generate interprocedurally valid paths\n+   i.e. that we return to the same callsite that called us.\n+\n+   The class actually stores the return edges, rather than the call edges,\n+   since that's what we need to compare against.  */\n+\n+class call_string\n+{\n+public:\n+  call_string () : m_return_edges () {}\n+  call_string (const call_string &other);\n+  call_string& operator= (const call_string &other);\n+\n+  bool operator== (const call_string &other) const;\n+\n+  void print (pretty_printer *pp) const;\n+\n+  hashval_t hash () const;\n+\n+  bool empty_p () const { return m_return_edges.is_empty (); }\n+\n+  void push_call (const supergraph &sg,\n+\t\t  const call_superedge *sedge);\n+  const return_superedge *pop () { return m_return_edges.pop (); }\n+\n+  int calc_recursion_depth () const;\n+\n+  static int cmp (const call_string &a,\n+\t\t  const call_string &b);\n+\n+  unsigned length () const { return m_return_edges.length (); }\n+  const return_superedge *operator[] (unsigned idx) const\n+  {\n+    return m_return_edges[idx];\n+  }\n+\n+  void validate () const;\n+\n+private:\n+  static int cmp_1 (const call_string &a,\n+\t\t    const call_string &b);\n+\n+  auto_vec<const return_superedge *> m_return_edges;\n+};\n+\n+#endif /* GCC_ANALYZER_CALL_STRING_H */"}, {"sha": "6c0f66cc27583cfdf6afa2452a4775cd6d061828", "filename": "gcc/analyzer/checker-path.cc", "status": "added", "additions": 957, "deletions": 0, "changes": 957, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,957 @@\n+/* Subclasses of diagnostic_path and diagnostic_event for analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"function.h\"\n+#include \"diagnostic-path.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"gimple-iterator.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Get a string for EK.  */\n+\n+const char *\n+event_kind_to_string (enum event_kind ek)\n+{\n+  switch (ek)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case EK_DEBUG:\n+      return \"EK_DEBUG\";\n+    case EK_CUSTOM:\n+      return \"EK_CUSTOM\";\n+    case EK_STMT:\n+      return \"EK_STMT\";\n+    case EK_FUNCTION_ENTRY:\n+      return \"EK_FUNCTION_ENTRY\";\n+    case EK_STATE_CHANGE:\n+      return \"EK_STATE_CHANGE\";\n+    case EK_START_CFG_EDGE:\n+      return \"EK_START_CFG_EDGE\";\n+    case EK_END_CFG_EDGE:\n+      return \"EK_END_CFG_EDGE\";\n+    case EK_CALL_EDGE:\n+      return \"EK_CALL_EDGE\";\n+    case EK_RETURN_EDGE:\n+      return \"EK_RETURN_EDGE\";\n+    case EK_SETJMP:\n+      return \"EK_SETJMP\";\n+    case EK_REWIND_FROM_LONGJMP:\n+      return \"EK_REWIND_FROM_LONGJMP\";\n+    case EK_REWIND_TO_SETJMP:\n+      return \"EK_REWIND_TO_SETJMP\";\n+    case EK_WARNING:\n+      return \"EK_WARNING\";\n+    }\n+}\n+\n+/* class checker_event : public diagnostic_event.  */\n+\n+/* Dump this event to PP (for debugging/logging purposes).  */\n+\n+void\n+checker_event::dump (pretty_printer *pp) const\n+{\n+  label_text event_desc (get_desc (false));\n+  pp_printf (pp, \"\\\"%s\\\" (depth %i, m_loc=%x)\",\n+\t     event_desc.m_buffer,\n+\t     get_stack_depth (),\n+\t     get_location ());\n+  event_desc.maybe_free ();\n+}\n+\n+/* Hook for being notified when this event has its final id EMISSION_ID\n+   and is about to emitted for PD.\n+\n+   Base implementation of checker_event::prepare_for_emission vfunc;\n+   subclasses that override this should chain up to it.\n+\n+   Record PD and EMISSION_ID, and call the get_desc vfunc, so that any\n+   side-effects of the call to get_desc take place before\n+   pending_diagnostic::emit is called.\n+\n+   For example, state_change_event::get_desc can call\n+   pending_diagnostic::describe_state_change; free_of_non_heap can use this\n+   to tweak the message (TODO: would be neater to simply capture the\n+   pertinent data within the sm-state).  */\n+\n+void\n+checker_event::prepare_for_emission (checker_path *,\n+\t\t\t\t     pending_diagnostic *pd,\n+\t\t\t\t     diagnostic_event_id_t emission_id)\n+{\n+  m_pending_diagnostic = pd;\n+  m_emission_id = emission_id;\n+\n+  label_text desc = get_desc (false);\n+  desc.maybe_free ();\n+}\n+\n+/* class debug_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   debug_event.\n+   Use the saved string as the event's description.  */\n+\n+label_text\n+debug_event::get_desc (bool) const\n+{\n+  return label_text::borrow (m_desc);\n+}\n+\n+/* class custom_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   custom_event.\n+   Use the saved string as the event's description.  */\n+\n+label_text\n+custom_event::get_desc (bool) const\n+{\n+  return label_text::borrow (m_desc);\n+}\n+\n+/* class statement_event : public checker_event.  */\n+\n+/* statement_event's ctor.  */\n+\n+statement_event::statement_event (const gimple *stmt, tree fndecl, int depth,\n+\t\t\t\t  const program_state &dst_state)\n+: checker_event (EK_STMT, gimple_location (stmt), fndecl, depth),\n+  m_stmt (stmt),\n+  m_dst_state (dst_state)\n+{\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   statement_event.\n+   Use the statement's dump form as the event's description.  */\n+\n+label_text\n+statement_event::get_desc (bool) const\n+{\n+  pretty_printer pp;\n+  pp_string (&pp, \"stmt: \");\n+  pp_gimple_stmt_1 (&pp, m_stmt, 0, (dump_flags_t)0);\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* class function_entry_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   function_entry_event.\n+\n+   Use a string such as \"entry to 'foo'\" as the event's description.  */\n+\n+label_text\n+function_entry_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize, \"entry to %qE\", m_fndecl);\n+}\n+\n+/* class state_change_event : public checker_event.  */\n+\n+/* state_change_event's ctor.  */\n+\n+state_change_event::state_change_event (const supernode *node,\n+\t\t\t\t\tconst gimple *stmt,\n+\t\t\t\t\tint stack_depth,\n+\t\t\t\t\tconst state_machine &sm,\n+\t\t\t\t\ttree var,\n+\t\t\t\t\tstate_machine::state_t from,\n+\t\t\t\t\tstate_machine::state_t to,\n+\t\t\t\t\ttree origin,\n+\t\t\t\t\tconst program_state &dst_state)\n+: checker_event (EK_STATE_CHANGE,\n+\t\t stmt->location, node->m_fun->decl,\n+\t\t stack_depth),\n+  m_node (node), m_stmt (stmt), m_sm (sm),\n+  m_var (var), m_from (from), m_to (to),\n+  m_origin (origin),\n+  m_dst_state (dst_state)\n+{\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   state_change_event.\n+\n+   Attempt to generate a nicer human-readable description.\n+   For greatest precision-of-wording, give the pending diagnostic\n+   a chance to describe this state change (in terms of the\n+   diagnostic).\n+   Note that we only have a pending_diagnostic set on the event once\n+   the diagnostic is about to being emitted, so the description for\n+   an event can change.  */\n+\n+label_text\n+state_change_event::get_desc (bool can_colorize) const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_state_change\n+\t    (evdesc::state_change (can_colorize, m_var, m_origin,\n+\t\t\t\t   m_from, m_to, m_emission_id, *this));\n+      if (custom_desc.m_buffer)\n+\t{\n+\t  if (flag_analyzer_verbose_state_changes)\n+\t    {\n+\t      /* Append debug version.  */\n+\t      label_text result;\n+\t      if (m_origin)\n+\t\tresult = make_label_text\n+\t\t  (can_colorize,\n+\t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE)\",\n+\t\t   custom_desc.m_buffer,\n+\t\t   m_var,\n+\t\t   m_sm.get_state_name (m_from),\n+\t\t   m_sm.get_state_name (m_to),\n+\t\t   m_origin);\n+\t      else\n+\t\tresult = make_label_text\n+\t\t  (can_colorize,\n+\t\t   \"%s (state of %qE: %qs -> %qs, origin: NULL)\",\n+\t\t   custom_desc.m_buffer,\n+\t\t   m_var,\n+\t\t   m_sm.get_state_name (m_from),\n+\t\t   m_sm.get_state_name (m_to));\n+\t      custom_desc.maybe_free ();\n+\t      return result;\n+\t    }\n+\t  else\n+\t    return custom_desc;\n+\t}\n+    }\n+\n+  /* Fallback description.  */\n+  if (m_var)\n+    {\n+      if (m_origin)\n+\treturn make_label_text\n+\t  (can_colorize,\n+\t   \"state of %qE: %qs -> %qs (origin: %qE)\",\n+\t   m_var,\n+\t   m_sm.get_state_name (m_from),\n+\t   m_sm.get_state_name (m_to),\n+\t   m_origin);\n+      else\n+\treturn make_label_text\n+\t  (can_colorize,\n+\t   \"state of %qE: %qs -> %qs (origin: NULL)\",\n+\t   m_var,\n+\t   m_sm.get_state_name (m_from),\n+\t   m_sm.get_state_name (m_to));\n+    }\n+  else\n+    {\n+      gcc_assert (m_origin == NULL_TREE);\n+      return make_label_text\n+\t(can_colorize,\n+\t \"global state: %qs -> %qs\",\n+\t m_sm.get_state_name (m_from),\n+\t m_sm.get_state_name (m_to));\n+    }\n+}\n+\n+/* class superedge_event : public checker_event.  */\n+\n+/* Get the callgraph_superedge for this superedge_event, which must be\n+   for an interprocedural edge, rather than a CFG edge.  */\n+\n+const callgraph_superedge&\n+superedge_event::get_callgraph_superedge () const\n+{\n+  gcc_assert (m_sedge->m_kind != SUPEREDGE_CFG_EDGE);\n+  return *m_sedge->dyn_cast_callgraph_superedge ();\n+}\n+\n+/* Determine if this event should be filtered at the given verbosity\n+   level.  */\n+\n+bool\n+superedge_event::should_filter_p (int verbosity) const\n+{\n+  switch (m_sedge->m_kind)\n+    {\n+    case SUPEREDGE_CFG_EDGE:\n+      {\n+\tif (verbosity < 2)\n+\t  return true;\n+\n+\tif (verbosity == 2)\n+\t  {\n+\t    /* Filter events with empty descriptions.  This ought to filter\n+\t       FALLTHRU, but retain true/false/switch edges.  */\n+\t    label_text desc = get_desc (false);\n+\t    gcc_assert (desc.m_buffer);\n+\t    if (desc.m_buffer[0] == '\\0')\n+\t      return true;\n+\t    desc.maybe_free ();\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* superedge_event's ctor.  */\n+\n+superedge_event::superedge_event (enum event_kind kind,\n+\t\t\t\t  const exploded_edge &eedge,\n+\t\t\t\t  location_t loc, tree fndecl, int depth)\n+: checker_event (kind, loc, fndecl, depth),\n+  m_eedge (eedge), m_sedge (eedge.m_sedge),\n+  m_var (NULL_TREE), m_critical_state (0)\n+{\n+}\n+\n+/* class cfg_edge_event : public superedge_event.  */\n+\n+/* Get the cfg_superedge for this cfg_edge_event.  */\n+\n+const cfg_superedge &\n+cfg_edge_event::get_cfg_superedge () const\n+{\n+  return *m_sedge->dyn_cast_cfg_superedge ();\n+}\n+\n+/* cfg_edge_event's ctor.  */\n+\n+cfg_edge_event::cfg_edge_event (enum event_kind kind,\n+\t\t\t\tconst exploded_edge &eedge,\n+\t\t\t\tlocation_t loc, tree fndecl, int depth)\n+: superedge_event (kind, eedge, loc, fndecl, depth)\n+{\n+  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CFG_EDGE);\n+}\n+\n+/* class start_cfg_edge_event : public cfg_edge_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   start_cfg_edge_event.\n+\n+   If -fanalyzer-verbose-edges, then generate low-level descriptions, such\n+   as\n+     \"taking 'true' edge SN:7 -> SN:8\".\n+\n+   Otherwise, generate strings using the label of the underlying CFG if\n+   any, such as:\n+     \"following 'true' branch...\" or\n+     \"following 'case 3' branch...\"\n+     \"following 'default' branch...\"\n+\n+   For conditionals, attempt to supply a description of the condition that\n+   holds, such as:\n+     \"following 'false' branch (when 'ptr' is non-NULL)...\"\n+\n+   Failing that, return an empty description (which will lead to this event\n+   being filtered).  */\n+\n+label_text\n+start_cfg_edge_event::get_desc (bool can_colorize) const\n+{\n+  bool user_facing = !flag_analyzer_verbose_edges;\n+  char *edge_desc = m_sedge->get_description (user_facing);\n+  if (user_facing)\n+    {\n+      if (edge_desc && strlen (edge_desc) > 0)\n+\t{\n+\t  label_text cond_desc = maybe_describe_condition (can_colorize);\n+\t  label_text result;\n+\t  if (cond_desc.m_buffer)\n+\t    {\n+\t      result = make_label_text (can_colorize,\n+\t\t\t\t\t\"following %qs branch (%s)...\",\n+\t\t\t\t\tedge_desc, cond_desc.m_buffer);\n+\t      cond_desc.maybe_free ();\n+\t    }\n+\t  else\n+\t    {\n+\t      result = make_label_text (can_colorize,\n+\t\t\t\t\t\"following %qs branch...\",\n+\t\t\t\t\tedge_desc);\n+\t    }\n+\t  free (edge_desc);\n+\t  return result;\n+\t}\n+      else\n+\t{\n+\t  free (edge_desc);\n+\t  return label_text::borrow (\"\");\n+\t}\n+    }\n+  else\n+    {\n+      if (strlen (edge_desc) > 0)\n+\t{\n+\t  label_text result\n+\t    = make_label_text (can_colorize,\n+\t\t\t       \"taking %qs edge SN:%i -> SN:%i\",\n+\t\t\t       edge_desc,\n+\t\t\t       m_sedge->m_src->m_index,\n+\t\t\t       m_sedge->m_dest->m_index);\n+\t  free (edge_desc);\n+\t  return result;\n+\t}\n+      else\n+\t{\n+\t  free (edge_desc);\n+\t  return make_label_text (can_colorize,\n+\t\t\t\t  \"taking edge SN:%i -> SN:%i\",\n+\t\t\t\t  m_sedge->m_src->m_index,\n+\t\t\t\t  m_sedge->m_dest->m_index);\n+\t}\n+    }\n+}\n+\n+/* Attempt to generate a description of any condition that holds at this edge.\n+\n+   The intent is to make the user-facing messages more clear, especially for\n+   cases where there's a single or double-negative, such as\n+   when describing the false branch of an inverted condition.\n+\n+   For example, rather than printing just:\n+\n+      |  if (!ptr)\n+      |     ~\n+      |     |\n+      |     (1) following 'false' branch...\n+\n+   it's clearer to spell out the condition that holds:\n+\n+      |  if (!ptr)\n+      |     ~\n+      |     |\n+      |     (1) following 'false' branch (when 'ptr' is non-NULL)...\n+                                          ^^^^^^^^^^^^^^^^^^^^^^\n+\n+   In the above example, this function would generate the highlighted\n+   string: \"when 'ptr' is non-NULL\".\n+\n+   If the edge is not a condition, or it's not clear that a description of\n+   the condition would be helpful to the user, return NULL.  */\n+\n+label_text\n+start_cfg_edge_event::maybe_describe_condition (bool can_colorize) const\n+{\n+  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n+\n+  if (cfg_sedge.true_value_p () || cfg_sedge.false_value_p ())\n+    {\n+      const gimple *last_stmt = m_sedge->m_src->get_last_stmt ();\n+      if (const gcond *cond_stmt = dyn_cast <const gcond *> (last_stmt))\n+\t{\n+\t  enum tree_code op = gimple_cond_code (cond_stmt);\n+\t  tree lhs = gimple_cond_lhs (cond_stmt);\n+\t  tree rhs = gimple_cond_rhs (cond_stmt);\n+\t  if (cfg_sedge.false_value_p ())\n+\t    op = invert_tree_comparison (op, false /* honor_nans */);\n+\t  return maybe_describe_condition (can_colorize,\n+\t\t\t\t\t   lhs, op, rhs);\n+\t}\n+    }\n+  return label_text::borrow (NULL);\n+}\n+\n+/* Subroutine of maybe_describe_condition above.\n+\n+   Attempt to generate a user-facing description of the condition\n+   LHS OP RHS, but only if it is likely to make it easier for the\n+   user to understand a condition.  */\n+\n+label_text\n+start_cfg_edge_event::maybe_describe_condition (bool can_colorize,\n+\t\t\t\t\t\ttree lhs,\n+\t\t\t\t\t\tenum tree_code op,\n+\t\t\t\t\t\ttree rhs)\n+{\n+  /* In theory we could just build a tree via\n+       fold_build2 (op, boolean_type_node, lhs, rhs)\n+     and print it with %qE on it, but this leads to warts such as\n+     parenthesizing vars, such as '(i) <= 9', and uses of '<unknown>'.  */\n+\n+  /* Special-case: describe testing the result of strcmp, as figuring\n+     out what the \"true\" or \"false\" path is can be confusing to the user.  */\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && zerop (rhs))\n+    {\n+      if (gcall *call = dyn_cast <gcall *> (SSA_NAME_DEF_STMT (lhs)))\n+\tif (is_special_named_call_p (call, \"strcmp\", 2))\n+\t  {\n+\t    if (op == EQ_EXPR)\n+\t      return label_text::borrow (\"when the strings are equal\");\n+\t    if (op == NE_EXPR)\n+\t      return label_text::borrow (\"when the strings are non-equal\");\n+\t  }\n+    }\n+\n+  /* Only attempt to generate text for sufficiently simple expressions.  */\n+  if (!should_print_expr_p (lhs))\n+    return label_text::borrow (NULL);\n+  if (!should_print_expr_p (rhs))\n+    return label_text::borrow (NULL);\n+\n+  /* Special cases for pointer comparisons against NULL.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (lhs))\n+      && POINTER_TYPE_P (TREE_TYPE (rhs))\n+      && zerop (rhs))\n+    {\n+      if (op == EQ_EXPR)\n+\treturn make_label_text (can_colorize, \"when %qE is NULL\",\n+\t\t\t\tlhs);\n+      if (op == NE_EXPR)\n+\treturn make_label_text (can_colorize, \"when %qE is non-NULL\",\n+\t\t\t\tlhs);\n+    }\n+\n+  return make_label_text (can_colorize, \"when %<%E %s %E%>\",\n+\t\t\t  lhs, op_symbol_code (op), rhs);\n+}\n+\n+/* Subroutine of maybe_describe_condition.\n+\n+   Return true if EXPR is we will get suitable user-facing output\n+   from %E on it.  */\n+\n+bool\n+start_cfg_edge_event::should_print_expr_p (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      if (SSA_NAME_VAR (expr))\n+\treturn should_print_expr_p (SSA_NAME_VAR (expr));\n+      else\n+\treturn false;\n+    }\n+\n+  if (DECL_P (expr))\n+    return true;\n+\n+  if (CONSTANT_CLASS_P (expr))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* class call_event : public superedge_event.  */\n+\n+/* call_event's ctor.  */\n+\n+call_event::call_event (const exploded_edge &eedge,\n+\t\t\tlocation_t loc, tree fndecl, int depth)\n+: superedge_event (EK_CALL_EDGE, eedge, loc, fndecl, depth)\n+{\n+  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CALL);\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   call_event.\n+\n+   If this call event passes critical state for an sm-based warning,\n+   allow the diagnostic to generate a precise description, such as:\n+\n+     \"passing freed pointer 'ptr' in call to 'foo' from 'bar'\"\n+\n+   Otherwise, generate a description of the form\n+   \"calling 'foo' from 'bar'\".  */\n+\n+label_text\n+call_event::get_desc (bool can_colorize) const\n+{\n+  if (m_critical_state && m_pending_diagnostic)\n+    {\n+      gcc_assert (m_var);\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_call_with_state\n+\t    (evdesc::call_with_state (can_colorize,\n+\t\t\t\t      m_sedge->m_src->m_fun->decl,\n+\t\t\t\t      m_sedge->m_dest->m_fun->decl,\n+\t\t\t\t      m_var,\n+\t\t\t\t      m_critical_state));\n+      if (custom_desc.m_buffer)\n+\treturn custom_desc;\n+    }\n+\n+  return make_label_text (can_colorize,\n+\t\t\t  \"calling %qE from %qE\",\n+\t\t\t  m_sedge->m_dest->m_fun->decl,\n+\t\t\t  m_sedge->m_src->m_fun->decl);\n+}\n+\n+/* Override of checker_event::is_call_p for calls.  */\n+\n+bool\n+call_event::is_call_p () const\n+{\n+  return true;\n+}\n+\n+/* class return_event : public superedge_event.  */\n+\n+/* return_event's ctor.  */\n+\n+return_event::return_event (const exploded_edge &eedge,\n+\t\t\t    location_t loc, tree fndecl, int depth)\n+: superedge_event (EK_RETURN_EDGE, eedge, loc, fndecl, depth)\n+{\n+  gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_RETURN);\n+}\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   return_event.\n+\n+   If this return event returns critical state for an sm-based warning,\n+   allow the diagnostic to generate a precise description, such as:\n+\n+      \"possible of NULL to 'foo' from 'bar'\"\n+\n+   Otherwise, generate a description of the form\n+   \"returning to 'foo' from 'bar'.  */\n+\n+label_text\n+return_event::get_desc (bool can_colorize) const\n+{\n+  /*  For greatest precision-of-wording, if this is returning the\n+      state involved in the pending diagnostic, give the pending\n+      diagnostic a chance to describe this return (in terms of\n+      itself).  */\n+  if (m_critical_state && m_pending_diagnostic)\n+    {\n+      label_text custom_desc\n+\t= m_pending_diagnostic->describe_return_of_state\n+\t    (evdesc::return_of_state (can_colorize,\n+\t\t\t\t      m_sedge->m_dest->m_fun->decl,\n+\t\t\t\t      m_sedge->m_src->m_fun->decl,\n+\t\t\t\t      m_critical_state));\n+      if (custom_desc.m_buffer)\n+\treturn custom_desc;\n+    }\n+  return make_label_text (can_colorize,\n+\t\t\t  \"returning to %qE from %qE\",\n+\t\t\t  m_sedge->m_dest->m_fun->decl,\n+\t\t\t  m_sedge->m_src->m_fun->decl);\n+}\n+\n+/* Override of checker_event::is_return_p for returns.  */\n+\n+bool\n+return_event::is_return_p () const\n+{\n+  return true;\n+}\n+\n+/* class setjmp_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   setjmp_event.  */\n+\n+label_text\n+setjmp_event::get_desc (bool can_colorize) const\n+{\n+  return make_label_text (can_colorize,\n+\t\t\t  \"%qs called here\",\n+\t\t\t  \"setjmp\");\n+}\n+\n+/* Implementation of checker_event::prepare_for_emission vfunc for setjmp_event.\n+\n+   Record this setjmp's event ID into the path, so that rewind events can\n+   use it.  */\n+\n+void\n+setjmp_event::prepare_for_emission (checker_path *path,\n+\t\t\t\t    pending_diagnostic *pd,\n+\t\t\t\t    diagnostic_event_id_t emission_id)\n+{\n+  checker_event::prepare_for_emission (path, pd, emission_id);\n+  path->record_setjmp_event (m_enode, emission_id);\n+}\n+\n+/* class rewind_event : public checker_event.  */\n+\n+/* Get the fndecl containing the site of the longjmp call.  */\n+\n+tree\n+rewind_event::get_longjmp_caller () const\n+{\n+  return m_eedge->m_src->get_function ()->decl;\n+}\n+\n+/* Get the fndecl containing the site of the setjmp call.  */\n+\n+tree\n+rewind_event::get_setjmp_caller () const\n+{\n+  return m_eedge->m_dest->get_function ()->decl;\n+}\n+\n+/* rewind_event's ctor.  */\n+\n+rewind_event::rewind_event (const exploded_edge *eedge,\n+\t\t\t    enum event_kind kind,\n+\t\t\t    location_t loc, tree fndecl, int depth)\n+: checker_event (kind, loc, fndecl, depth),\n+  m_eedge (eedge)\n+{\n+  gcc_assert (m_eedge->m_custom_info); // a rewind_info_t\n+}\n+\n+/* class rewind_from_longjmp_event : public rewind_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   rewind_from_longjmp_event.  */\n+\n+label_text\n+rewind_from_longjmp_event::get_desc (bool can_colorize) const\n+{\n+  const char *src_name = \"longjmp\";\n+\n+  if (get_longjmp_caller () == get_setjmp_caller ())\n+    /* Special-case: purely intraprocedural rewind.  */\n+    return make_label_text (can_colorize,\n+\t\t\t    \"rewinding within %qE from %qs...\",\n+\t\t\t    get_longjmp_caller (),\n+\t\t\t    src_name);\n+  else\n+    return make_label_text (can_colorize,\n+\t\t\t    \"rewinding from %qs in %qE...\",\n+\t\t\t    src_name,\n+\t\t\t    get_longjmp_caller ());\n+}\n+\n+/* class rewind_to_setjmp_event : public rewind_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   rewind_to_setjmp_event.  */\n+\n+label_text\n+rewind_to_setjmp_event::get_desc (bool can_colorize) const\n+{\n+  const char *dst_name = \"setjmp\";\n+\n+  /* If we can, identify the ID of the setjmp_event.  */\n+  if (m_original_setjmp_event_id.known_p ())\n+    {\n+      if (get_longjmp_caller () == get_setjmp_caller ())\n+\t/* Special-case: purely intraprocedural rewind.  */\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs (saved at %@)\",\n+\t\t\t\tdst_name,\n+\t\t\t\t&m_original_setjmp_event_id);\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs in %qE (saved at %@)\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller (),\n+\t\t\t\t&m_original_setjmp_event_id);\n+    }\n+  else\n+    {\n+      if (get_longjmp_caller () == get_setjmp_caller ())\n+\t/* Special-case: purely intraprocedural rewind.  */\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller ());\n+      else\n+\treturn make_label_text (can_colorize,\n+\t\t\t\t\"...to %qs in %qE\",\n+\t\t\t\tdst_name,\n+\t\t\t\tget_setjmp_caller ());\n+    }\n+}\n+\n+/* Implementation of checker_event::prepare_for_emission vfunc for\n+   rewind_to_setjmp_event.\n+\n+   Attempt to look up the setjmp event ID that recorded the jmp_buf\n+   for this rewind.  */\n+\n+void\n+rewind_to_setjmp_event::prepare_for_emission (checker_path *path,\n+\t\t\t\t\t      pending_diagnostic *pd,\n+\t\t\t\t\t      diagnostic_event_id_t emission_id)\n+{\n+  checker_event::prepare_for_emission (path, pd, emission_id);\n+  path->get_setjmp_event (m_rewind_info->get_enode_origin (),\n+\t\t\t  &m_original_setjmp_event_id);\n+}\n+\n+/* class warning_event : public checker_event.  */\n+\n+/* Implementation of diagnostic_event::get_desc vfunc for\n+   warning_event.\n+\n+   If the pending diagnostic implements describe_final_event, use it,\n+   generating a precise description e.g.\n+     \"second 'free' here; first 'free' was at (7)\"\n+\n+   Otherwise generate a generic description.  */\n+\n+label_text\n+warning_event::get_desc (bool can_colorize) const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      label_text ev_desc\n+\t= m_pending_diagnostic->describe_final_event\n+\t    (evdesc::final_event (can_colorize, m_var, m_state));\n+      if (ev_desc.m_buffer)\n+\t{\n+\t  if (m_sm && flag_analyzer_verbose_state_changes)\n+\t    {\n+\t      label_text result\n+\t\t= make_label_text (can_colorize,\n+\t\t\t\t   \"%s (%qE is in state %qs)\",\n+\t\t\t\t   ev_desc.m_buffer,\n+\t\t\t\t   m_var,m_sm->get_state_name (m_state));\n+\t      ev_desc.maybe_free ();\n+\t      return result;\n+\t    }\n+\t  else\n+\t    return ev_desc;\n+\t}\n+    }\n+\n+  if (m_sm)\n+    return make_label_text (can_colorize,\n+\t\t\t    \"here (%qE is in state %qs)\",\n+\t\t\t    m_var,\n+\t\t\t    m_sm->get_state_name (m_state));\n+  else\n+    return label_text::borrow (\"here\");\n+}\n+\n+/* Print a single-line representation of this path to PP.  */\n+\n+void\n+checker_path::dump (pretty_printer *pp) const\n+{\n+  pp_character (pp, '[');\n+\n+  checker_event *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_events, i, e)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      label_text event_desc (e->get_desc (false));\n+      pp_printf (pp, \"\\\"%s\\\"\", event_desc.m_buffer);\n+      event_desc.maybe_free ();\n+    }\n+  pp_character (pp, ']');\n+}\n+\n+/* Print a multiline form of this path to LOGGER, prefixing it with DESC.  */\n+\n+void\n+checker_path::maybe_log (logger *logger, const char *desc) const\n+{\n+  if (!logger)\n+    return;\n+  logger->start_log_line ();\n+  logger->log_partial (\"%s: \", desc);\n+  dump (logger->get_printer ());\n+  logger->end_log_line ();\n+  for (unsigned i = 0; i < m_events.length (); i++)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"%s[%i]: %s \", desc, i,\n+\t\t\t   event_kind_to_string (m_events[i]->m_kind));\n+      m_events[i]->dump (logger->get_printer ());\n+      logger->end_log_line ();\n+    }\n+}\n+\n+/* Print a multiline form of this path to STDERR.  */\n+\n+DEBUG_FUNCTION void\n+checker_path::debug () const\n+{\n+  checker_event *e;\n+  int i;\n+  FOR_EACH_VEC_ELT (m_events, i, e)\n+    {\n+      label_text event_desc (e->get_desc (false));\n+      fprintf (stderr,\n+\t       \"[%i]: %s \\\"%s\\\"\\n\",\n+\t       i,\n+\t       event_kind_to_string (m_events[i]->m_kind),\n+\t       event_desc.m_buffer);\n+      event_desc.maybe_free ();\n+    }\n+}\n+\n+/* Add a warning_event to the end of this path.  */\n+\n+void\n+checker_path::add_final_event (const state_machine *sm,\n+\t\t\t       const exploded_node *enode, const gimple *stmt,\n+\t\t\t       tree var, state_machine::state_t state)\n+{\n+  checker_event *end_of_path\n+    = new warning_event (stmt->location,\n+\t\t\t enode->get_function ()->decl,\n+\t\t\t enode->get_stack_depth (),\n+\t\t\t sm, var, state);\n+  add_event (end_of_path);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "cabbeb4fd4fcb60425bb5a304a8f1318818b1af9", "filename": "gcc/analyzer/checker-path.h", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,586 @@\n+/* Subclasses of diagnostic_path and diagnostic_event for analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CHECKER_PATH_H\n+#define GCC_ANALYZER_CHECKER_PATH_H\n+\n+/* An enum for discriminating between the concrete subclasses of\n+   checker_event.  */\n+\n+enum event_kind\n+{\n+  EK_DEBUG,\n+  EK_CUSTOM,\n+  EK_STMT,\n+  EK_FUNCTION_ENTRY,\n+  EK_STATE_CHANGE,\n+  EK_START_CFG_EDGE,\n+  EK_END_CFG_EDGE,\n+  EK_CALL_EDGE,\n+  EK_RETURN_EDGE,\n+  EK_SETJMP,\n+  EK_REWIND_FROM_LONGJMP,\n+  EK_REWIND_TO_SETJMP,\n+  EK_WARNING\n+};\n+\n+extern const char *event_kind_to_string (enum event_kind ek);\n+\n+/* Event subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with event_kinds shown for the concrete subclasses):\n+\n+   diagnostic_event\n+     checker_event\n+       debug_event (EK_DEBUG)\n+       custom_event (EK_CUSTOM)\n+       statement_event (EK_STMT)\n+       function_entry_event (EK_FUNCTION_ENTRY)\n+       state_change_event (EK_STATE_CHANGE)\n+       superedge_event\n+         cfg_edge_event\n+\t   start_cfg_edge_event (EK_START_CFG_EDGE)\n+\t   end_cfg_edge_event (EK_END_CFG_EDGE)\n+         call_event (EK_CALL_EDGE)\n+         return_edge (EK_RETURN_EDGE)\n+       setjmp_event (EK_SETJMP)\n+       rewind_event\n+         rewind_from_longjmp_event (EK_REWIND_FROM_LONGJMP)\n+\t rewind_to_setjmp_event (EK_REWIND_TO_SETJMP)\n+       warning_event (EK_WARNING).  */\n+\n+/* Abstract subclass of diagnostic_event; the base class for use in\n+   checker_path (the analyzer's diagnostic_path subclass).  */\n+\n+class checker_event : public diagnostic_event\n+{\n+public:\n+  checker_event (enum event_kind kind,\n+\t\t location_t loc, tree fndecl, int depth)\n+    : m_kind (kind), m_loc (loc), m_fndecl (fndecl), m_depth (depth),\n+      m_pending_diagnostic (NULL), m_emission_id ()\n+  {\n+  }\n+\n+  /* Implementation of diagnostic_event.  */\n+\n+  location_t get_location () const FINAL OVERRIDE { return m_loc; }\n+  tree get_fndecl () const FINAL OVERRIDE { return m_fndecl; }\n+  int get_stack_depth () const FINAL OVERRIDE { return m_depth; }\n+\n+  /* Additional functionality.  */\n+\n+  virtual checker_event *clone () const = 0;\n+\n+  virtual void prepare_for_emission (checker_path *,\n+\t\t\t\t     pending_diagnostic *pd,\n+\t\t\t\t     diagnostic_event_id_t emission_id);\n+  virtual bool is_call_p () const { return false; }\n+  virtual bool is_function_entry_p () const  { return false; }\n+  virtual bool is_return_p () const  { return false; }\n+\n+  void dump (pretty_printer *pp) const;\n+\n+ public:\n+  const enum event_kind m_kind;\n+ protected:\n+  location_t m_loc;\n+  tree m_fndecl;\n+  int m_depth;\n+  pending_diagnostic *m_pending_diagnostic;\n+  diagnostic_event_id_t m_emission_id; // only set once all pruning has occurred\n+};\n+\n+/* A concrete event subclass for a purely textual event, for use in\n+   debugging path creation and filtering.  */\n+\n+class debug_event : public checker_event\n+{\n+public:\n+  debug_event (location_t loc, tree fndecl, int depth,\n+\t      const char *desc)\n+  : checker_event (EK_DEBUG, loc, fndecl, depth),\n+    m_desc (xstrdup (desc))\n+  {\n+  }\n+  ~debug_event ()\n+  {\n+    free (m_desc);\n+  }\n+\n+  label_text get_desc (bool) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new debug_event (m_loc, m_fndecl, m_depth, m_desc);\n+  }\n+\n+private:\n+  char *m_desc;\n+};\n+\n+/* A concrete event subclass for custom events.  These are not filtered,\n+   as they are likely to be pertinent to the diagnostic.  */\n+\n+class custom_event : public checker_event\n+{\n+public:\n+  custom_event (location_t loc, tree fndecl, int depth,\n+\t\tconst char *desc)\n+  : checker_event (EK_CUSTOM, loc, fndecl, depth),\n+    m_desc (xstrdup (desc))\n+  {\n+  }\n+  ~custom_event ()\n+  {\n+    free (m_desc);\n+  }\n+\n+  label_text get_desc (bool) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new custom_event (m_loc, m_fndecl, m_depth, m_desc);\n+  }\n+\n+private:\n+  char *m_desc;\n+};\n+\n+/* A concrete event subclass describing the execution of a gimple statement,\n+   for use at high verbosity levels when debugging paths.  */\n+\n+class statement_event : public checker_event\n+{\n+public:\n+  statement_event (const gimple *stmt, tree fndecl, int depth,\n+\t\t   const program_state &dst_state);\n+\n+  label_text get_desc (bool) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new statement_event (m_stmt, m_fndecl, m_depth, m_dst_state);\n+  }\n+\n+  const gimple * const m_stmt;\n+  const program_state m_dst_state;\n+};\n+\n+/* An event subclass describing the entry to a function.  */\n+\n+class function_entry_event : public checker_event\n+{\n+public:\n+  function_entry_event (location_t loc, tree fndecl, int depth)\n+  : checker_event (EK_FUNCTION_ENTRY, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new function_entry_event (m_loc, m_fndecl, m_depth);\n+  }\n+\n+  bool is_function_entry_p () const FINAL OVERRIDE { return true; }\n+};\n+\n+/* Subclass of checker_event describing a state change.  */\n+\n+class state_change_event : public checker_event\n+{\n+public:\n+  state_change_event (const supernode *node, const gimple *stmt,\n+\t\t      int stack_depth,\n+\t\t      const state_machine &sm,\n+\t\t      tree var,\n+\t\t      state_machine::state_t from,\n+\t\t      state_machine::state_t to,\n+\t\t      tree origin,\n+\t\t      const program_state &dst_state);\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new state_change_event (m_node, m_stmt, m_depth,\n+\t\t\t\t   m_sm, m_var, m_from, m_to, m_origin,\n+\t\t\t\t   m_dst_state);\n+  }\n+\n+  region_id get_lvalue (tree expr) const\n+  {\n+    return m_dst_state.m_region_model->get_lvalue (expr, NULL);\n+  }\n+\n+  const supernode *m_node;\n+  const gimple *m_stmt;\n+  const state_machine &m_sm;\n+  tree m_var;\n+  state_machine::state_t m_from;\n+  state_machine::state_t m_to;\n+  tree m_origin;\n+  program_state m_dst_state;\n+};\n+\n+/* Subclass of checker_event; parent class for subclasses that relate to\n+   a superedge.  */\n+\n+class superedge_event : public checker_event\n+{\n+public:\n+  /* Mark this edge event as being either an interprocedural call or\n+     return in which VAR is in STATE, and that this is critical to the\n+     diagnostic (so that get_desc can attempt to get a better description\n+     from any pending_diagnostic).  */\n+  void record_critical_state (tree var, state_machine::state_t state)\n+  {\n+    m_var = var;\n+    m_critical_state = state;\n+  }\n+\n+  const callgraph_superedge& get_callgraph_superedge () const;\n+\n+  bool should_filter_p (int verbosity) const;\n+\n+ protected:\n+  superedge_event (enum event_kind kind, const exploded_edge &eedge,\n+\t\t   location_t loc, tree fndecl, int depth);\n+\n+ public:\n+  const exploded_edge &m_eedge;\n+  const superedge *m_sedge;\n+  tree m_var;\n+  state_machine::state_t m_critical_state;\n+};\n+\n+/* An abstract event subclass for when a CFG edge is followed; it has two\n+   subclasses, representing the start of the edge and the end of the\n+   edge, which come in pairs.  */\n+\n+class cfg_edge_event : public superedge_event\n+{\n+public:\n+  const cfg_superedge& get_cfg_superedge () const;\n+\n+ protected:\n+  cfg_edge_event (enum event_kind kind, const exploded_edge &eedge,\n+\t\t  location_t loc, tree fndecl, int depth);\n+};\n+\n+/* A concrete event subclass for the start of a CFG edge\n+   e.g. \"following 'false' branch...'.  */\n+\n+class start_cfg_edge_event : public cfg_edge_event\n+{\n+public:\n+  start_cfg_edge_event (const exploded_edge &eedge,\n+\t\t\tlocation_t loc, tree fndecl, int depth)\n+  : cfg_edge_event (EK_START_CFG_EDGE, eedge, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new start_cfg_edge_event (m_eedge, m_loc, m_fndecl, m_depth);\n+  }\n+\n+ private:\n+  label_text maybe_describe_condition (bool can_colorize) const;\n+\n+  static label_text maybe_describe_condition (bool can_colorize,\n+\t\t\t\t\t      tree lhs,\n+\t\t\t\t\t      enum tree_code op,\n+\t\t\t\t\t      tree rhs);\n+  static bool should_print_expr_p (tree);\n+};\n+\n+/* A concrete event subclass for the end of a CFG edge\n+   e.g. \"...to here'.  */\n+\n+class end_cfg_edge_event : public cfg_edge_event\n+{\n+public:\n+  end_cfg_edge_event (const exploded_edge &eedge,\n+\t\t      location_t loc, tree fndecl, int depth)\n+  : cfg_edge_event (EK_END_CFG_EDGE, eedge, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool /*can_colorize*/) const FINAL OVERRIDE\n+  {\n+    return label_text::borrow (\"...to here\");\n+  }\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new end_cfg_edge_event (m_eedge, m_loc, m_fndecl, m_depth);\n+  }\n+};\n+\n+/* A concrete event subclass for an interprocedural call.  */\n+\n+class call_event : public superedge_event\n+{\n+public:\n+  call_event (const exploded_edge &eedge,\n+\t      location_t loc, tree fndecl, int depth);\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new call_event (m_eedge, m_loc, m_fndecl, m_depth);\n+  }\n+\n+  bool is_call_p () const FINAL OVERRIDE;\n+};\n+\n+/* A concrete event subclass for an interprocedural return.  */\n+\n+class return_event : public superedge_event\n+{\n+public:\n+  return_event (const exploded_edge &eedge,\n+\t\tlocation_t loc, tree fndecl, int depth);\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  checker_event *clone () const FINAL OVERRIDE\n+  {\n+    return new return_event (m_eedge, m_loc, m_fndecl, m_depth);\n+  }\n+\n+  bool is_return_p () const FINAL OVERRIDE;\n+};\n+\n+/* A concrete event subclass for a setjmp call.  */\n+\n+class setjmp_event : public checker_event\n+{\n+public:\n+  setjmp_event (location_t loc, const exploded_node *enode,\n+\t\ttree fndecl, int depth)\n+  : checker_event (EK_SETJMP, loc, fndecl, depth),\n+    m_enode (enode)\n+  {\n+  }\n+\n+  setjmp_event *clone () const FINAL OVERRIDE\n+  {\n+    return new setjmp_event (m_loc, m_enode, m_fndecl, m_depth);\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  void prepare_for_emission (checker_path *path,\n+\t\t\t     pending_diagnostic *pd,\n+\t\t\t     diagnostic_event_id_t emission_id) FINAL OVERRIDE;\n+\n+private:\n+  const exploded_node *m_enode;\n+};\n+\n+/* An abstract event subclass for rewinding from a longjmp to a setjmp.\n+   Base class for two from/to subclasses, showing the two halves of the\n+   rewind.  */\n+\n+class rewind_event : public checker_event\n+{\n+public:\n+  tree get_longjmp_caller () const;\n+  tree get_setjmp_caller () const;\n+  const exploded_edge *get_eedge () const { return m_eedge; }\n+\n+ protected:\n+  rewind_event (const exploded_edge *eedge,\n+\t\tenum event_kind kind,\n+\t\tlocation_t loc, tree fndecl, int depth);\n+\n+ private:\n+  const exploded_edge *m_eedge;\n+};\n+\n+/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n+   showing the longjmp.  */\n+\n+class rewind_from_longjmp_event : public rewind_event\n+{\n+public:\n+  rewind_from_longjmp_event (const exploded_edge *eedge,\n+\t\t\t     location_t loc, tree fndecl, int depth)\n+  : rewind_event (eedge, EK_REWIND_FROM_LONGJMP, loc, fndecl, depth)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  rewind_from_longjmp_event *clone () const FINAL OVERRIDE\n+  {\n+    return new rewind_from_longjmp_event (get_eedge (),\n+\t\t\t\t\t  m_loc, m_fndecl, m_depth);\n+  }\n+};\n+\n+/* A concrete event subclass for rewinding from a longjmp to a setjmp,\n+   showing the setjmp.  */\n+\n+class rewind_to_setjmp_event : public rewind_event\n+{\n+public:\n+  rewind_to_setjmp_event (const exploded_edge *eedge,\n+\t\t\t  location_t loc, tree fndecl, int depth,\n+\t\t\t  const rewind_info_t *rewind_info)\n+  : rewind_event (eedge, EK_REWIND_TO_SETJMP, loc, fndecl, depth),\n+    m_rewind_info (rewind_info)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  rewind_to_setjmp_event *clone () const FINAL OVERRIDE\n+  {\n+    return new rewind_to_setjmp_event (get_eedge (),\n+\t\t\t\t       m_loc, m_fndecl, m_depth,\n+\t\t\t\t       m_rewind_info);\n+  }\n+\n+  void prepare_for_emission (checker_path *path,\n+\t\t\t     pending_diagnostic *pd,\n+\t\t\t     diagnostic_event_id_t emission_id) FINAL OVERRIDE;\n+\n+private:\n+  diagnostic_event_id_t m_original_setjmp_event_id;\n+  const rewind_info_t *m_rewind_info;\n+};\n+\n+/* Concrete subclass of checker_event for use at the end of a path:\n+   a repeat of the warning message at the end of the path (perhaps with\n+   references to pertinent events that occurred on the way), at the point\n+   where the problem occurs.  */\n+\n+class warning_event : public checker_event\n+{\n+public:\n+  warning_event (location_t loc, tree fndecl, int depth,\n+\t\t const state_machine *sm,\n+\t\t tree var, state_machine::state_t state)\n+  : checker_event (EK_WARNING, loc, fndecl, depth),\n+    m_sm (sm), m_var (var), m_state (state)\n+  {\n+  }\n+\n+  label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n+\n+  warning_event *clone () const FINAL OVERRIDE\n+  {\n+    return new warning_event (m_loc, m_fndecl, m_depth, m_sm, m_var, m_state);\n+  }\n+\n+private:\n+  const state_machine *m_sm;\n+  tree m_var;\n+  state_machine::state_t m_state;\n+};\n+\n+/* Subclass of diagnostic_path for analyzer diagnostics.  */\n+\n+class checker_path : public diagnostic_path\n+{\n+public:\n+  checker_path () : diagnostic_path () {}\n+\n+  /* Implementation of diagnostic_path vfuncs.  */\n+\n+  unsigned num_events () const FINAL OVERRIDE\n+  {\n+    return m_events.length ();\n+  }\n+\n+  const diagnostic_event & get_event (int idx) const FINAL OVERRIDE\n+  {\n+    return *m_events[idx];\n+  }\n+\n+  void dump (pretty_printer *pp) const;\n+  void debug () const;\n+\n+  void maybe_log (logger *logger, const char *desc) const;\n+\n+  void add_event (checker_event *event)\n+  {\n+    m_events.safe_push (event);\n+  }\n+\n+  void delete_event (int idx)\n+  {\n+    checker_event *event = m_events[idx];\n+    m_events.ordered_remove (idx);\n+    delete event;\n+  }\n+\n+  void add_final_event (const state_machine *sm,\n+\t\t\tconst exploded_node *enode, const gimple *stmt,\n+\t\t\ttree var, state_machine::state_t state);\n+\n+  /* After all event-pruning, a hook for notifying each event what\n+     its ID will be.  The events are notified in order, allowing\n+     for later events to refer to the IDs of earlier events in\n+     their descriptions.  */\n+  void prepare_for_emission (pending_diagnostic *pd)\n+  {\n+    checker_event *e;\n+    int i;\n+    FOR_EACH_VEC_ELT (m_events, i, e)\n+      e->prepare_for_emission (this, pd, diagnostic_event_id_t (i));\n+  }\n+\n+  void record_setjmp_event (const exploded_node *enode,\n+\t\t\t    diagnostic_event_id_t setjmp_emission_id)\n+  {\n+    m_setjmp_event_ids.put (enode, setjmp_emission_id);\n+  }\n+\n+  bool get_setjmp_event (const exploded_node *enode,\n+\t\t\t diagnostic_event_id_t *out_emission_id)\n+  {\n+    if (diagnostic_event_id_t *emission_id = m_setjmp_event_ids.get (enode))\n+      {\n+\t*out_emission_id = *emission_id;\n+\treturn true;\n+      }\n+    return false;\n+  }\n+\n+  /* The events that have occurred along this path.  */\n+  auto_delete_vec<checker_event> m_events;\n+\n+  /* During prepare_for_emission (and after), the setjmp_event for each\n+     exploded_node *, so that rewind events can refer to them in their\n+     descriptions.  */\n+  hash_map <const exploded_node *, diagnostic_event_id_t> m_setjmp_event_ids;\n+};\n+\n+#endif /* GCC_ANALYZER_CHECKER_PATH_H */"}, {"sha": "669d604e1b7d4b12a5b71c9542986fbfd8852fdf", "filename": "gcc/analyzer/constraint-manager.cc", "status": "added", "additions": 2260, "deletions": 0, "changes": 2260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,2260 @@\n+/* Tracking equivalence classes and constraints at a point on an execution path.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"fold-const.h\"\n+#include \"selftest.h\"\n+#include \"graphviz.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* One of the end-points of a range.  */\n+\n+struct bound\n+{\n+  bound () : m_constant (NULL_TREE), m_closed (false) {}\n+  bound (tree constant, bool closed)\n+  : m_constant (constant), m_closed (closed) {}\n+\n+  void ensure_closed (bool is_upper);\n+\n+  const char * get_relation_as_str () const;\n+\n+  tree m_constant;\n+  bool m_closed;\n+};\n+\n+/* A range of values, used for determining if a value has been\n+   constrained to just one possible constant value.  */\n+\n+struct range\n+{\n+  range () : m_lower_bound (), m_upper_bound () {}\n+  range (const bound &lower, const bound &upper)\n+  : m_lower_bound (lower), m_upper_bound (upper) {}\n+\n+  void dump (pretty_printer *pp) const;\n+\n+  bool constrained_to_single_element (tree *out);\n+\n+  bound m_lower_bound;\n+  bound m_upper_bound;\n+};\n+\n+/* struct bound.  */\n+\n+/* Ensure that this bound is closed by converting an open bound to a\n+   closed one.  */\n+\n+void\n+bound::ensure_closed (bool is_upper)\n+{\n+  if (!m_closed)\n+    {\n+      /* Offset by 1 in the appropriate direction.\n+\t For example, convert 3 < x into 4 <= x,\n+\t and convert x < 5 into x <= 4.  */\n+      gcc_assert (CONSTANT_CLASS_P (m_constant));\n+      m_constant = fold_build2 (is_upper ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t\tTREE_TYPE (m_constant),\n+\t\t\t\tm_constant, integer_one_node);\n+      gcc_assert (CONSTANT_CLASS_P (m_constant));\n+      m_closed = true;\n+    }\n+}\n+\n+/* Get \"<=\" vs \"<\" for this bound.  */\n+\n+const char *\n+bound::get_relation_as_str () const\n+{\n+  if (m_closed)\n+    return \"<=\";\n+  else\n+    return \"<\";\n+}\n+\n+/* struct range.  */\n+\n+/* Dump this range to PP, which must support %E for tree.  */\n+\n+void\n+range::dump (pretty_printer *pp) const\n+{\n+PUSH_IGNORE_WFORMAT\n+  pp_printf (pp, \"%qE %s x %s %qE\",\n+\t     m_lower_bound.m_constant,\n+\t     m_lower_bound.get_relation_as_str (),\n+\t     m_upper_bound.get_relation_as_str (),\n+\t     m_upper_bound.m_constant);\n+POP_IGNORE_WFORMAT\n+}\n+\n+/* Determine if there is only one possible value for this range.\n+   If so, return true and write the constant to *OUT.\n+   Otherwise, return false.  */\n+\n+bool\n+range::constrained_to_single_element (tree *out)\n+{\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (m_lower_bound.m_constant)))\n+    return false;\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (m_upper_bound.m_constant)))\n+    return false;\n+\n+  /* Convert any open bounds to closed bounds.  */\n+  m_lower_bound.ensure_closed (false);\n+  m_upper_bound.ensure_closed (true);\n+\n+  // Are they equal?\n+  tree comparison\n+    = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t   m_lower_bound.m_constant,\n+\t\t   m_upper_bound.m_constant);\n+  if (comparison == boolean_true_node)\n+    {\n+      *out = m_lower_bound.m_constant;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* class equiv_class.  */\n+\n+/* equiv_class's default ctor.  */\n+\n+equiv_class::equiv_class ()\n+: m_constant (NULL_TREE), m_cst_sid (svalue_id::null ()),\n+  m_vars ()\n+{\n+}\n+\n+/* equiv_class's copy ctor.  */\n+\n+equiv_class::equiv_class (const equiv_class &other)\n+: m_constant (other.m_constant), m_cst_sid (other.m_cst_sid),\n+  m_vars (other.m_vars.length ())\n+{\n+  int i;\n+  svalue_id *sid;\n+  FOR_EACH_VEC_ELT (other.m_vars, i, sid)\n+    m_vars.quick_push (*sid);\n+}\n+\n+/* Print an all-on-one-line representation of this equiv_class to PP,\n+   which must support %E for trees.  */\n+\n+void\n+equiv_class::print (pretty_printer *pp) const\n+{\n+  pp_character (pp, '{');\n+  int i;\n+  svalue_id *sid;\n+  FOR_EACH_VEC_ELT (m_vars, i, sid)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \" == \");\n+      sid->print (pp);\n+    }\n+  if (m_constant)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \" == \");\n+PUSH_IGNORE_WFORMAT\n+      pp_printf (pp, \"%qE\", m_constant);\n+POP_IGNORE_WFORMAT\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* Generate a hash value for this equiv_class.  */\n+\n+hashval_t\n+equiv_class::hash () const\n+{\n+  inchash::hash hstate;\n+  int i;\n+  svalue_id *sid;\n+\n+  inchash::add_expr (m_constant, hstate);\n+  FOR_EACH_VEC_ELT (m_vars, i, sid)\n+    inchash::add (*sid, hstate);\n+  return hstate.end ();\n+}\n+\n+/* Equality operator for equiv_class.  */\n+\n+bool\n+equiv_class::operator== (const equiv_class &other)\n+{\n+  if (m_constant != other.m_constant)\n+    return false; // TODO: use tree equality here?\n+\n+  /* FIXME: should we compare m_cst_sid?  */\n+\n+  if (m_vars.length () != other.m_vars.length ())\n+    return false;\n+\n+  int i;\n+  svalue_id *sid;\n+  FOR_EACH_VEC_ELT (m_vars, i, sid)\n+    if (! (*sid == other.m_vars[i]))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Add SID to this equiv_class, using CM to check if it's a constant.  */\n+\n+void\n+equiv_class::add (svalue_id sid, const constraint_manager &cm)\n+{\n+  gcc_assert (!sid.null_p ());\n+  if (tree cst = cm.maybe_get_constant (sid))\n+    {\n+      gcc_assert (CONSTANT_CLASS_P (cst));\n+      /* FIXME: should we canonicalize which svalue is the constant\n+\t when there are multiple equal constants?  */\n+      m_constant = cst;\n+      m_cst_sid = sid;\n+    }\n+  m_vars.safe_push (sid);\n+}\n+\n+/* Remove SID from this equivalence class.\n+   Return true if SID was the last var in the equivalence class (suggesting\n+   a possible leak).  */\n+\n+bool\n+equiv_class::del (svalue_id sid)\n+{\n+  gcc_assert (!sid.null_p ());\n+  gcc_assert (sid != m_cst_sid);\n+\n+  int i;\n+  svalue_id *iv;\n+  FOR_EACH_VEC_ELT (m_vars, i, iv)\n+    {\n+      if (*iv == sid)\n+\t{\n+\t  m_vars[i] = m_vars[m_vars.length () - 1];\n+\t  m_vars.pop ();\n+\t  return m_vars.length () == 0;\n+\t}\n+    }\n+\n+  /* SID must be in the class.  */\n+  gcc_unreachable ();\n+  return false;\n+}\n+\n+/* Get a representative member of this class, for handling cases\n+   where the IDs can change mid-traversal.  */\n+\n+svalue_id\n+equiv_class::get_representative () const\n+{\n+  if (!m_cst_sid.null_p ())\n+    return m_cst_sid;\n+  else\n+    {\n+      gcc_assert (m_vars.length () > 0);\n+      return m_vars[0];\n+    }\n+}\n+\n+/* Remap all svalue_ids within this equiv_class using MAP.  */\n+\n+void\n+equiv_class::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  int i;\n+  svalue_id *iv;\n+  FOR_EACH_VEC_ELT (m_vars, i, iv)\n+    map.update (iv);\n+  map.update (&m_cst_sid);\n+}\n+\n+/* Comparator for use by equiv_class::canonicalize.  */\n+\n+static int\n+svalue_id_cmp_by_id (const void *p1, const void *p2)\n+{\n+  const svalue_id *sid1 = (const svalue_id *)p1;\n+  const svalue_id *sid2 = (const svalue_id *)p2;\n+  return sid1->as_int () - sid2->as_int ();\n+}\n+\n+/* Sort the svalues_ids within this equiv_class.  */\n+\n+void\n+equiv_class::canonicalize ()\n+{\n+  m_vars.qsort (svalue_id_cmp_by_id);\n+}\n+\n+/* Get a debug string for C_OP.  */\n+\n+const char *\n+constraint_op_code (enum constraint_op c_op)\n+{\n+  switch (c_op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case CONSTRAINT_NE: return \"!=\";\n+    case CONSTRAINT_LT: return \"<\";\n+    case CONSTRAINT_LE: return \"<=\";\n+    }\n+}\n+\n+/* Convert C_OP to an enum tree_code.  */\n+\n+enum tree_code\n+constraint_tree_code (enum constraint_op c_op)\n+{\n+  switch (c_op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case CONSTRAINT_NE: return NE_EXPR;\n+    case CONSTRAINT_LT: return LT_EXPR;\n+    case CONSTRAINT_LE: return LE_EXPR;\n+    }\n+}\n+\n+/* Given \"lhs C_OP rhs\", determine \"lhs T_OP rhs\".\n+\n+   For example, given \"x < y\", then \"x > y\" is false.  */\n+\n+static tristate\n+eval_constraint_op_for_op (enum constraint_op c_op, enum tree_code t_op)\n+{\n+  switch (c_op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case CONSTRAINT_NE:\n+      if (t_op == EQ_EXPR)\n+\treturn tristate (tristate::TS_FALSE);\n+      if (t_op == NE_EXPR)\n+\treturn tristate (tristate::TS_TRUE);\n+      break;\n+    case CONSTRAINT_LT:\n+      if (t_op == LT_EXPR || t_op == LE_EXPR || t_op == NE_EXPR)\n+\treturn tristate (tristate::TS_TRUE);\n+      if (t_op == EQ_EXPR || t_op == GT_EXPR || t_op == GE_EXPR)\n+\treturn tristate (tristate::TS_FALSE);\n+      break;\n+    case CONSTRAINT_LE:\n+      if (t_op == LE_EXPR)\n+\treturn tristate (tristate::TS_TRUE);\n+      if (t_op == GT_EXPR)\n+\treturn tristate (tristate::TS_FALSE);\n+      break;\n+    }\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n+\n+/* class constraint.  */\n+\n+/* Print this constraint to PP (which must support %E for trees),\n+   using CM to look up equiv_class instances from ids.  */\n+\n+void\n+constraint::print (pretty_printer *pp, const constraint_manager &cm) const\n+{\n+  m_lhs.print (pp);\n+  pp_string (pp, \": \");\n+  m_lhs.get_obj (cm).print (pp);\n+  pp_string (pp, \" \");\n+  pp_string (pp, constraint_op_code (m_op));\n+  pp_string (pp, \" \");\n+  m_rhs.print (pp);\n+  pp_string (pp, \": \");\n+  m_rhs.get_obj (cm).print (pp);\n+}\n+\n+/* Generate a hash value for this constraint.  */\n+\n+hashval_t\n+constraint::hash () const\n+{\n+  inchash::hash hstate;\n+  hstate.add_int (m_lhs.m_idx);\n+  hstate.add_int (m_op);\n+  hstate.add_int (m_rhs.m_idx);\n+  return hstate.end ();\n+}\n+\n+/* Equality operator for constraints.  */\n+\n+bool\n+constraint::operator== (const constraint &other) const\n+{\n+  if (m_lhs != other.m_lhs)\n+    return false;\n+  if (m_op != other.m_op)\n+    return false;\n+  if (m_rhs != other.m_rhs)\n+    return false;\n+  return true;\n+}\n+\n+/* class equiv_class_id.  */\n+\n+/* Get the underlying equiv_class for this ID from CM.  */\n+\n+const equiv_class &\n+equiv_class_id::get_obj (const constraint_manager &cm) const\n+{\n+  return cm.get_equiv_class_by_index (m_idx);\n+}\n+\n+/* Access the underlying equiv_class for this ID from CM.  */\n+\n+equiv_class &\n+equiv_class_id::get_obj (constraint_manager &cm) const\n+{\n+  return cm.get_equiv_class_by_index (m_idx);\n+}\n+\n+/* Print this equiv_class_id to PP.  */\n+\n+void\n+equiv_class_id::print (pretty_printer *pp) const\n+{\n+  if (null_p ())\n+    pp_printf (pp, \"null\");\n+  else\n+    pp_printf (pp, \"ec%i\", m_idx);\n+}\n+\n+/* class constraint_manager.  */\n+\n+/* constraint_manager's copy ctor.  */\n+\n+constraint_manager::constraint_manager (const constraint_manager &other)\n+: m_equiv_classes (other.m_equiv_classes.length ()),\n+  m_constraints (other.m_constraints.length ())\n+{\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (other.m_equiv_classes, i, ec)\n+    m_equiv_classes.quick_push (new equiv_class (*ec));\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (other.m_constraints, i, c)\n+    m_constraints.quick_push (*c);\n+}\n+\n+/* constraint_manager's assignment operator.  */\n+\n+constraint_manager&\n+constraint_manager::operator= (const constraint_manager &other)\n+{\n+  gcc_assert (m_equiv_classes.length () == 0);\n+  gcc_assert (m_constraints.length () == 0);\n+\n+  int i;\n+  equiv_class *ec;\n+  m_equiv_classes.reserve (other.m_equiv_classes.length ());\n+  FOR_EACH_VEC_ELT (other.m_equiv_classes, i, ec)\n+    m_equiv_classes.quick_push (new equiv_class (*ec));\n+  constraint *c;\n+  m_constraints.reserve (other.m_constraints.length ());\n+  FOR_EACH_VEC_ELT (other.m_constraints, i, c)\n+    m_constraints.quick_push (*c);\n+\n+  return *this;\n+}\n+\n+/* Generate a hash value for this constraint_manager.  */\n+\n+hashval_t\n+constraint_manager::hash () const\n+{\n+  inchash::hash hstate;\n+  int i;\n+  equiv_class *ec;\n+  constraint *c;\n+\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    hstate.merge_hash (ec->hash ());\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    hstate.merge_hash (c->hash ());\n+  return hstate.end ();\n+}\n+\n+/* Equality operator for constraint_manager.  */\n+\n+bool\n+constraint_manager::operator== (const constraint_manager &other) const\n+{\n+  if (m_equiv_classes.length () != other.m_equiv_classes.length ())\n+    return false;\n+  if (m_constraints.length () != other.m_constraints.length ())\n+    return false;\n+\n+  int i;\n+  equiv_class *ec;\n+\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    if (!(*ec == *other.m_equiv_classes[i]))\n+      return false;\n+\n+  constraint *c;\n+\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    if (!(*c == other.m_constraints[i]))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Print this constraint_manager to PP (which must support %E for trees).  */\n+\n+void\n+constraint_manager::print (pretty_printer *pp) const\n+{\n+  pp_string (pp, \"{\");\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      equiv_class_id (i).print (pp);\n+      pp_string (pp, \": \");\n+      ec->print (pp);\n+    }\n+  pp_string (pp, \"  |  \");\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \" && \");\n+      c->print (pp, *this);\n+    }\n+  pp_printf (pp, \"}\");\n+}\n+\n+/* Dump a multiline representation of this constraint_manager to PP\n+   (which must support %E for trees).  */\n+\n+void\n+constraint_manager::dump_to_pp (pretty_printer *pp) const\n+{\n+  // TODO\n+  pp_string (pp, \"  equiv classes:\");\n+  pp_newline (pp);\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      pp_string (pp, \"    \");\n+      equiv_class_id (i).print (pp);\n+      pp_string (pp, \": \");\n+      ec->print (pp);\n+      pp_newline (pp);\n+    }\n+  pp_string (pp, \"  constraints:\");\n+  pp_newline (pp);\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      pp_printf (pp, \"    %i: \", i);\n+      c->print (pp, *this);\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this constraint_manager to FP.  */\n+\n+void\n+constraint_manager::dump (FILE *fp) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = fp;\n+  dump_to_pp (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this constraint_manager to stderr.  */\n+\n+DEBUG_FUNCTION void\n+constraint_manager::dump () const\n+{\n+  dump (stderr);\n+}\n+\n+/* Dump a multiline representation of CM to stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug (const constraint_manager &cm)\n+{\n+  cm.dump ();\n+}\n+\n+/* Attempt to add the constraint LHS OP RHS to this constraint_manager.\n+   Return true if the constraint could be added (or is already true).\n+   Return false if the constraint contradicts existing knowledge.  */\n+\n+bool\n+constraint_manager::add_constraint (svalue_id lhs,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    svalue_id rhs)\n+{\n+  equiv_class_id lhs_ec_id = get_or_add_equiv_class (lhs);\n+  equiv_class_id rhs_ec_id = get_or_add_equiv_class (rhs);\n+  return add_constraint (lhs_ec_id, op,rhs_ec_id);\n+}\n+\n+/* Attempt to add the constraint LHS_EC_ID OP RHS_EC_ID to this\n+   constraint_manager.\n+   Return true if the constraint could be added (or is already true).\n+   Return false if the constraint contradicts existing knowledge.  */\n+\n+bool\n+constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    equiv_class_id rhs_ec_id)\n+{\n+  tristate t = eval_condition (lhs_ec_id, op, rhs_ec_id);\n+\n+  /* Discard constraints that are already known.  */\n+  if (t.is_true ())\n+    return true;\n+\n+  /* Reject unsatisfiable constraints.  */\n+  if (t.is_false ())\n+    return false;\n+\n+  gcc_assert (lhs_ec_id != rhs_ec_id);\n+\n+  /* For now, simply accumulate constraints, without attempting any further\n+     optimization.  */\n+  switch (op)\n+    {\n+    case EQ_EXPR:\n+      {\n+\t/* Merge rhs_ec into lhs_ec.  */\n+\tequiv_class &lhs_ec_obj = lhs_ec_id.get_obj (*this);\n+\tconst equiv_class &rhs_ec_obj = rhs_ec_id.get_obj (*this);\n+\n+\tint i;\n+\tsvalue_id *sid;\n+\tFOR_EACH_VEC_ELT (rhs_ec_obj.m_vars, i, sid)\n+\t  lhs_ec_obj.add (*sid, *this);\n+\n+\tif (rhs_ec_obj.m_constant)\n+\t  {\n+\t    //gcc_assert (lhs_ec_obj.m_constant == NULL);\n+\t    lhs_ec_obj.m_constant = rhs_ec_obj.m_constant;\n+\t  }\n+\n+\t/* Drop rhs equivalence class, overwriting it with the\n+\t   final ec (which might be the same one).  */\n+\tequiv_class_id final_ec_id = m_equiv_classes.length () - 1;\n+\tequiv_class *old_ec = m_equiv_classes[rhs_ec_id.m_idx];\n+\tequiv_class *final_ec = m_equiv_classes.pop ();\n+\tif (final_ec != old_ec)\n+\t  m_equiv_classes[rhs_ec_id.m_idx] = final_ec;\n+\tdelete old_ec;\n+\n+\t/* Update the constraints.  */\n+\tconstraint *c;\n+\tFOR_EACH_VEC_ELT (m_constraints, i, c)\n+\t  {\n+\t    /* Update references to the rhs_ec so that\n+\t       they refer to the lhs_ec.  */\n+\t    if (c->m_lhs == rhs_ec_id)\n+\t      c->m_lhs = lhs_ec_id;\n+\t    if (c->m_rhs == rhs_ec_id)\n+\t      c->m_rhs = lhs_ec_id;\n+\n+\t    /* Renumber all constraints that refer to the final rhs_ec\n+\t       to the old rhs_ec, where the old final_ec now lives.  */\n+\t    if (c->m_lhs == final_ec_id)\n+\t      c->m_lhs = rhs_ec_id;\n+\t    if (c->m_rhs == final_ec_id)\n+\t      c->m_rhs = rhs_ec_id;\n+\t  }\n+      }\n+      break;\n+    case GE_EXPR:\n+      add_constraint_internal (rhs_ec_id, CONSTRAINT_LE, lhs_ec_id);\n+      break;\n+    case LE_EXPR:\n+      add_constraint_internal (lhs_ec_id, CONSTRAINT_LE, rhs_ec_id);\n+      break;\n+    case NE_EXPR:\n+      add_constraint_internal (lhs_ec_id, CONSTRAINT_NE, rhs_ec_id);\n+      break;\n+    case GT_EXPR:\n+      add_constraint_internal (rhs_ec_id, CONSTRAINT_LT, lhs_ec_id);\n+      break;\n+    case LT_EXPR:\n+      add_constraint_internal (lhs_ec_id, CONSTRAINT_LT, rhs_ec_id);\n+      break;\n+    default:\n+      /* do nothing.  */\n+      break;\n+    }\n+  validate ();\n+  return true;\n+}\n+\n+/* Subroutine of constraint_manager::add_constraint, for handling all\n+   operations other than equality (for which equiv classes are merged).  */\n+\n+void\n+constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n+\t\t\t\t\t     enum constraint_op c_op,\n+\t\t\t\t\t     equiv_class_id rhs_id)\n+{\n+  /* Add the constraint.  */\n+  m_constraints.safe_push (constraint (lhs_id, c_op, rhs_id));\n+\n+  if (!flag_analyzer_transitivity)\n+    return;\n+\n+  if (c_op != CONSTRAINT_NE)\n+    {\n+      /* The following can potentially add EQ_EXPR facts, which could lead\n+\t to ECs being merged, which would change the meaning of the EC IDs.\n+\t Hence we need to do this via representatives.  */\n+      svalue_id lhs = lhs_id.get_obj (*this).get_representative ();\n+      svalue_id rhs = rhs_id.get_obj (*this).get_representative ();\n+\n+      /* We have LHS </<= RHS */\n+\n+      /* Handle transitivity of ordering by adding additional constraints\n+\t based on what we already knew.\n+\n+\t So if we have already have:\n+\t   (a < b)\n+\t   (c < d)\n+\t Then adding:\n+\t   (b < c)\n+\t will also add:\n+\t   (a < c)\n+\t   (b < d)\n+\t We need to recurse to ensure we also add:\n+\t   (a < d).\n+\t We call the checked add_constraint to avoid adding constraints\n+\t that are already present.  Doing so also ensures termination\n+\t in the case of cycles.\n+\n+\t We also check for single-element ranges, adding EQ_EXPR facts\n+\t where we discover them.  For example 3 < x < 5 implies\n+\t that x == 4 (if x is an integer).  */\n+      for (unsigned i = 0; i < m_constraints.length (); i++)\n+\t{\n+\t  const constraint *other = &m_constraints[i];\n+\t  if (other->is_ordering_p ())\n+\t    {\n+\t      /* Refresh the EC IDs, in case any mergers have happened.  */\n+\t      lhs_id = get_or_add_equiv_class (lhs);\n+\t      rhs_id = get_or_add_equiv_class (rhs);\n+\n+\t      tree lhs_const = lhs_id.get_obj (*this).m_constant;\n+\t      tree rhs_const = rhs_id.get_obj (*this).m_constant;\n+\t      tree other_lhs_const\n+\t\t= other->m_lhs.get_obj (*this).m_constant;\n+\t      tree other_rhs_const\n+\t\t= other->m_rhs.get_obj (*this).m_constant;\n+\n+\t      /* We have \"LHS </<= RHS\" and \"other.lhs </<= other.rhs\".  */\n+\n+\t      /* If we have LHS </<= RHS and RHS </<= LHS, then we have a\n+\t\t cycle.  */\n+\t      if (rhs_id == other->m_lhs\n+\t\t  && other->m_rhs == lhs_id)\n+\t\t{\n+\t\t  /* We must have equality for this to be possible.  */\n+\t\t  gcc_assert (c_op == CONSTRAINT_LE\n+\t\t\t      && other->m_op == CONSTRAINT_LE);\n+\t\t  add_constraint (lhs_id, EQ_EXPR, rhs_id);\n+\t\t  /* Adding an equality will merge the two ECs and potentially\n+\t\t     reorganize the constraints.  Stop iterating.  */\n+\t\t  return;\n+\t\t}\n+\t      /* Otherwise, check for transitivity.  */\n+\t      if (rhs_id == other->m_lhs)\n+\t\t{\n+\t\t  /* With RHS == other.lhs, we have:\n+\t\t     \"LHS </<= (RHS, other.lhs) </<= other.rhs\"\n+\t\t     and thus this implies \"LHS </<= other.rhs\".  */\n+\n+\t\t  /* Do we have a tightly-constrained range?  */\n+\t\t  if (lhs_const\n+\t\t      && !rhs_const\n+\t\t      && other_rhs_const)\n+\t\t    {\n+\t\t      range r (bound (lhs_const, c_op == CONSTRAINT_LE),\n+\t\t\t       bound (other_rhs_const,\n+\t\t\t\t      other->m_op == CONSTRAINT_LE));\n+\t\t      tree constant;\n+\t\t      if (r.constrained_to_single_element (&constant))\n+\t\t\t{\n+\t\t\t  svalue_id cst_sid = get_sid_for_constant (constant);\n+\t\t\t  add_constraint\n+\t\t\t    (rhs_id, EQ_EXPR,\n+\t\t\t     get_or_add_equiv_class (cst_sid));\n+\t\t\t  return;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  /* Otherwise, add the constraint implied by transitivity.  */\n+\t\t  enum tree_code new_op\n+\t\t    = ((c_op == CONSTRAINT_LE && other->m_op == CONSTRAINT_LE)\n+\t\t       ? LE_EXPR : LT_EXPR);\n+\t\t  add_constraint (lhs_id, new_op, other->m_rhs);\n+\t\t}\n+\t      else if (other->m_rhs == lhs_id)\n+\t\t{\n+\t\t  /* With other.rhs == LHS, we have:\n+\t\t     \"other.lhs </<= (other.rhs, LHS) </<= RHS\"\n+\t\t     and thus this implies \"other.lhs </<= RHS\".  */\n+\n+\t\t  /* Do we have a tightly-constrained range?  */\n+\t\t  if (other_lhs_const\n+\t\t      && !lhs_const\n+\t\t      && rhs_const)\n+\t\t    {\n+\t\t      range r (bound (other_lhs_const,\n+\t\t\t\t      other->m_op == CONSTRAINT_LE),\n+\t\t\t       bound (rhs_const,\n+\t\t\t\t      c_op == CONSTRAINT_LE));\n+\t\t      tree constant;\n+\t\t      if (r.constrained_to_single_element (&constant))\n+\t\t\t{\n+\t\t\t  svalue_id cst_sid = get_sid_for_constant (constant);\n+\t\t\t  add_constraint\n+\t\t\t    (lhs_id, EQ_EXPR,\n+\t\t\t     get_or_add_equiv_class (cst_sid));\n+\t\t\t  return;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  /* Otherwise, add the constraint implied by transitivity.  */\n+\t\t  enum tree_code new_op\n+\t\t    = ((c_op == CONSTRAINT_LE && other->m_op == CONSTRAINT_LE)\n+\t\t       ? LE_EXPR : LT_EXPR);\n+\t\t  add_constraint (other->m_lhs, new_op, rhs_id);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Look for SID within the equivalence classes of this constraint_manager;\n+   if found, write the id to *OUT and return true, otherwise return false.  */\n+\n+bool\n+constraint_manager::get_equiv_class_by_sid (svalue_id sid, equiv_class_id *out) const\n+{\n+  /* TODO: should we have a map, rather than these searches?  */\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      int j;\n+      svalue_id *iv;\n+      FOR_EACH_VEC_ELT (ec->m_vars, j, iv)\n+\tif (*iv == sid)\n+\t  {\n+\t    *out = equiv_class_id (i);\n+\t    return true;\n+\t  }\n+    }\n+  return false;\n+}\n+\n+/* Ensure that SID has an equivalence class within this constraint_manager;\n+   return the ID of the class.  */\n+\n+equiv_class_id\n+constraint_manager::get_or_add_equiv_class (svalue_id sid)\n+{\n+  equiv_class_id result (-1);\n+\n+  /* Try svalue_id match.  */\n+  if (get_equiv_class_by_sid (sid, &result))\n+    return result;\n+\n+  /* Try equality of constants.  */\n+  if (tree cst = maybe_get_constant (sid))\n+    {\n+      int i;\n+      equiv_class *ec;\n+      FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+\tif (ec->m_constant)\n+\t  {\n+\t    tree eq = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t   cst, ec->m_constant);\n+\t    if (eq == boolean_true_node)\n+\t      {\n+\t\tec->add (sid, *this);\n+\t\treturn equiv_class_id (i);\n+\t      }\n+\t  }\n+    }\n+\n+\n+  /* Not found.  */\n+  equiv_class *new_ec = new equiv_class ();\n+  new_ec->add (sid, *this);\n+  m_equiv_classes.safe_push (new_ec);\n+\n+  equiv_class_id new_id (m_equiv_classes.length () - 1);\n+\n+  if (maybe_get_constant (sid))\n+    {\n+      /* If we have a new EC for a constant, add constraints comparing this\n+\t to other constants we may have (so that we accumulate the transitive\n+\t closure of all constraints on constants as the constants are\n+\t added).  */\n+      for (equiv_class_id other_id (0); other_id.m_idx < new_id.m_idx;\n+\t   other_id.m_idx++)\n+\t{\n+\t  const equiv_class &other_ec = other_id.get_obj (*this);\n+\t  if (other_ec.m_constant)\n+\t    {\n+\t      /* If we have two ECs, both with constants, the constants must be\n+\t\t non-equal (or they would be in the same EC).\n+\t\t Determine the direction of the inequality, and record that\n+\t\t fact.  */\n+\t      tree lt\n+\t\t= fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t       new_ec->m_constant, other_ec.m_constant);\n+\t      //gcc_assert (lt == boolean_true_node || lt == boolean_false_node);\n+\t      // not true for int vs float comparisons\n+\t      if (lt == boolean_true_node)\n+\t\tadd_constraint_internal (new_id, CONSTRAINT_LT, other_id);\n+\t      else if (lt == boolean_false_node)\n+\t\tadd_constraint_internal (other_id, CONSTRAINT_LT, new_id);\n+\t      /* Refresh new_id, in case ECs were merged.  SID should always\n+\t\t be present by now, so this should never lead to a\n+\t\t recursion.  */\n+\t      new_id = get_or_add_equiv_class (sid);\n+\t    }\n+\t}\n+    }\n+\n+  return new_id;\n+}\n+\n+/* Evaluate the condition LHS_EC OP RHS_EC.  */\n+\n+tristate\n+constraint_manager::eval_condition (equiv_class_id lhs_ec,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    equiv_class_id rhs_ec)\n+{\n+  if (lhs_ec == rhs_ec)\n+    {\n+      switch (op)\n+\t{\n+\tcase EQ_EXPR:\n+\tcase GE_EXPR:\n+\tcase LE_EXPR:\n+\t  return tristate (tristate::TS_TRUE);\n+\n+\tcase NE_EXPR:\n+\tcase GT_EXPR:\n+\tcase LT_EXPR:\n+\t  return tristate (tristate::TS_FALSE);\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  tree lhs_const = lhs_ec.get_obj (*this).get_any_constant ();\n+  tree rhs_const = rhs_ec.get_obj (*this).get_any_constant ();\n+  if (lhs_const && rhs_const)\n+    {\n+      tree comparison\n+\t= fold_build2 (op, boolean_type_node, lhs_const, rhs_const);\n+      if (comparison == boolean_true_node)\n+\treturn tristate (tristate::TS_TRUE);\n+      if (comparison == boolean_false_node)\n+\treturn tristate (tristate::TS_FALSE);\n+    }\n+\n+  enum tree_code swapped_op = swap_tree_comparison (op);\n+\n+  int i;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      if (c->m_lhs == lhs_ec\n+\t  && c->m_rhs == rhs_ec)\n+\t{\n+\t  tristate result_for_constraint\n+\t    = eval_constraint_op_for_op (c->m_op, op);\n+\t  if (result_for_constraint.is_known ())\n+\t    return result_for_constraint;\n+\t}\n+      /* Swapped operands.  */\n+      if (c->m_lhs == rhs_ec\n+\t  && c->m_rhs == lhs_ec)\n+\t{\n+\t  tristate result_for_constraint\n+\t    = eval_constraint_op_for_op (c->m_op, swapped_op);\n+\t  if (result_for_constraint.is_known ())\n+\t    return result_for_constraint;\n+\t}\n+    }\n+\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n+\n+/* Evaluate the condition LHS OP RHS, creating equiv_class instances for\n+   LHS and RHS if they aren't already in equiv_classes.  */\n+\n+tristate\n+constraint_manager::eval_condition (svalue_id lhs,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    svalue_id rhs)\n+{\n+  return eval_condition (get_or_add_equiv_class (lhs),\n+\t\t\t op,\n+\t\t\t get_or_add_equiv_class (rhs));\n+}\n+\n+/* Delete any information about svalue_id instances identified by P.\n+   Such instances are removed from equivalence classes, and any\n+   redundant ECs and constraints are also removed.\n+   Accumulate stats into STATS.  */\n+\n+void\n+constraint_manager::purge (const purge_criteria &p, purge_stats *stats)\n+{\n+  /* Delete any svalue_ids identified by P within the various equivalence\n+     classes.  */\n+  for (unsigned ec_idx = 0; ec_idx < m_equiv_classes.length (); )\n+    {\n+      equiv_class *ec = m_equiv_classes[ec_idx];\n+\n+      int i;\n+      svalue_id *pv;\n+      bool delete_ec = false;\n+      FOR_EACH_VEC_ELT (ec->m_vars, i, pv)\n+\t{\n+\t  if (*pv == ec->m_cst_sid)\n+\t    continue;\n+\t  if (p.should_purge_p (*pv))\n+\t    {\n+\t      if (ec->del (*pv))\n+\t\tif (!ec->m_constant)\n+\t\t  delete_ec = true;\n+\t    }\n+\t}\n+\n+      if (delete_ec)\n+\t{\n+\t  delete ec;\n+\t  m_equiv_classes.ordered_remove (ec_idx);\n+\t  if (stats)\n+\t    stats->m_num_equiv_classes++;\n+\n+\t  /* Update the constraints, potentially removing some.  */\n+\t  for (unsigned con_idx = 0; con_idx < m_constraints.length (); )\n+\t    {\n+\t      constraint *c = &m_constraints[con_idx];\n+\n+\t      /* Remove constraints that refer to the deleted EC.  */\n+\t      if (c->m_lhs == ec_idx\n+\t\t  || c->m_rhs == ec_idx)\n+\t\t{\n+\t\t  m_constraints.ordered_remove (con_idx);\n+\t\t  if (stats)\n+\t\t    stats->m_num_constraints++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Renumber constraints that refer to ECs that have\n+\t\t     had their idx changed.  */\n+\t\t  c->m_lhs.update_for_removal (ec_idx);\n+\t\t  c->m_rhs.update_for_removal (ec_idx);\n+\n+\t\t  con_idx++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tec_idx++;\n+    }\n+\n+  /* Now delete any constraints that are purely between constants.  */\n+  for (unsigned con_idx = 0; con_idx < m_constraints.length (); )\n+    {\n+      constraint *c = &m_constraints[con_idx];\n+      if (m_equiv_classes[c->m_lhs.m_idx]->m_vars.length () == 0\n+\t  && m_equiv_classes[c->m_rhs.m_idx]->m_vars.length () == 0)\n+\t{\n+\t  m_constraints.ordered_remove (con_idx);\n+\t  if (stats)\n+\t    stats->m_num_constraints++;\n+\t}\n+      else\n+\t{\n+\t  con_idx++;\n+\t}\n+    }\n+\n+  /* Finally, delete any ECs that purely contain constants and aren't\n+     referenced by any constraints.  */\n+  for (unsigned ec_idx = 0; ec_idx < m_equiv_classes.length (); )\n+    {\n+      equiv_class *ec = m_equiv_classes[ec_idx];\n+      if (ec->m_vars.length () == 0)\n+\t{\n+\t  equiv_class_id ec_id (ec_idx);\n+\t  bool has_constraint = false;\n+\t  for (unsigned con_idx = 0; con_idx < m_constraints.length ();\n+\t       con_idx++)\n+\t    {\n+\t      constraint *c = &m_constraints[con_idx];\n+\t      if (c->m_lhs == ec_id\n+\t\t  || c->m_rhs == ec_id)\n+\t\t{\n+\t\t  has_constraint = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (!has_constraint)\n+\t    {\n+\t      delete ec;\n+\t      m_equiv_classes.ordered_remove (ec_idx);\n+\t      if (stats)\n+\t\tstats->m_num_equiv_classes++;\n+\n+\t      /* Renumber constraints that refer to ECs that have\n+\t\t had their idx changed.  */\n+\t      for (unsigned con_idx = 0; con_idx < m_constraints.length ();\n+\t\t   con_idx++)\n+\t\t{\n+\t\t  constraint *c = &m_constraints[con_idx];\n+\t\t  c->m_lhs.update_for_removal (ec_idx);\n+\t\t  c->m_rhs.update_for_removal (ec_idx);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t}\n+      ec_idx++;\n+    }\n+\n+  validate ();\n+}\n+\n+/* Remap all svalue_ids within this constraint_manager using MAP.  */\n+\n+void\n+constraint_manager::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    ec->remap_svalue_ids (map);\n+}\n+\n+/* Comparator for use by constraint_manager::canonicalize.\n+   Sort a pair of equiv_class instances, using the representative\n+   svalue_id as a sort key.  */\n+\n+static int\n+equiv_class_cmp (const void *p1, const void *p2)\n+{\n+  const equiv_class *ec1 = *(const equiv_class * const *)p1;\n+  const equiv_class *ec2 = *(const equiv_class * const *)p2;\n+\n+  svalue_id rep1 = ec1->get_representative ();\n+  svalue_id rep2 = ec2->get_representative ();\n+\n+  return rep1.as_int () - rep2.as_int ();\n+}\n+\n+/* Comparator for use by constraint_manager::canonicalize.\n+   Sort a pair of constraint instances.  */\n+\n+static int\n+constraint_cmp (const void *p1, const void *p2)\n+{\n+  const constraint *c1 = (const constraint *)p1;\n+  const constraint *c2 = (const constraint *)p2;\n+  int lhs_cmp = c1->m_lhs.as_int () - c2->m_lhs.as_int ();\n+  if (lhs_cmp)\n+    return lhs_cmp;\n+  int rhs_cmp = c1->m_rhs.as_int () - c2->m_rhs.as_int ();\n+  if (rhs_cmp)\n+    return rhs_cmp;\n+  return c1->m_op - c2->m_op;\n+}\n+\n+/* Reorder the equivalence classes and constraints within this\n+   constraint_manager into a canonical order, to increase the\n+   chances of finding equality with another instance.  */\n+\n+void\n+constraint_manager::canonicalize (unsigned num_svalue_ids)\n+{\n+  /* First, sort svalue_ids within the ECs.  */\n+  unsigned i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    ec->canonicalize ();\n+\n+  /* Next, sort the ECs into a canonical order.  */\n+\n+  /* We will need to remap the equiv_class_ids in the constraints,\n+     so we need to store the original index of each EC.\n+     Build a lookup table, mapping from representative svalue_id\n+     to the original equiv_class_id of that svalue_id.  */\n+  auto_vec<equiv_class_id> original_ec_id (num_svalue_ids);\n+  for (i = 0; i < num_svalue_ids; i++)\n+    original_ec_id.quick_push (equiv_class_id::null ());\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      svalue_id rep = ec->get_representative ();\n+      gcc_assert (!rep.null_p ());\n+      original_ec_id[rep.as_int ()] = i;\n+    }\n+\n+  /* Sort the equivalence classes.  */\n+  m_equiv_classes.qsort (equiv_class_cmp);\n+\n+  /* Populate ec_id_map based on the old vs new EC ids.  */\n+  one_way_id_map<equiv_class_id> ec_id_map (m_equiv_classes.length ());\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      svalue_id rep = ec->get_representative ();\n+      ec_id_map.put (original_ec_id[rep.as_int ()], i);\n+    }\n+\n+  /* Update the EC ids within the constraints.  */\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      ec_id_map.update (&c->m_lhs);\n+      ec_id_map.update (&c->m_rhs);\n+    }\n+\n+  /* Finally, sort the constraints. */\n+  m_constraints.qsort (constraint_cmp);\n+}\n+\n+/* A concrete subclass of constraint_manager for use when\n+   merging two constraint_manager into a third constraint_manager,\n+   each of which has its own region_model.\n+   Calls are delegated to the constraint_manager for the merged model,\n+   and thus affect its region_model.  */\n+\n+class cleaned_constraint_manager : public constraint_manager\n+{\n+public:\n+  cleaned_constraint_manager (constraint_manager *merged) : m_merged (merged) {}\n+\n+  constraint_manager *clone (region_model *) const FINAL OVERRIDE\n+  {\n+    gcc_unreachable ();\n+  }\n+  tree maybe_get_constant (svalue_id sid) const FINAL OVERRIDE\n+  {\n+    return m_merged->maybe_get_constant (sid);\n+  }\n+  svalue_id get_sid_for_constant (tree cst) const FINAL OVERRIDE\n+  {\n+    return m_merged->get_sid_for_constant (cst);\n+  }\n+  virtual int get_num_svalues () const FINAL OVERRIDE\n+  {\n+    return m_merged->get_num_svalues ();\n+  }\n+private:\n+  constraint_manager *m_merged;\n+};\n+\n+/* Concrete subclass of fact_visitor for use by constraint_manager::merge.\n+   For every fact in CM_A, see if it is also true in *CM_B.  Add such\n+   facts to *OUT.  */\n+\n+class merger_fact_visitor : public fact_visitor\n+{\n+public:\n+  merger_fact_visitor (constraint_manager *cm_b,\n+\t\t       constraint_manager *out)\n+  : m_cm_b (cm_b), m_out (out)\n+  {}\n+\n+  void on_fact (svalue_id lhs, enum tree_code code, svalue_id rhs)\n+    FINAL OVERRIDE\n+  {\n+    if (m_cm_b->eval_condition (lhs, code, rhs).is_true ())\n+      {\n+\tbool sat = m_out->add_constraint (lhs, code, rhs);\n+\tgcc_assert (sat);\n+      }\n+  }\n+\n+private:\n+  constraint_manager *m_cm_b;\n+  constraint_manager *m_out;\n+};\n+\n+/* Use MERGER to merge CM_A and CM_B into *OUT.\n+   If one thinks of a constraint_manager as a subset of N-dimensional\n+   space, this takes the union of the points of CM_A and CM_B, and\n+   expresses that into *OUT.  Alternatively, it can be thought of\n+   as the intersection of the constraints.  */\n+\n+void\n+constraint_manager::merge (const constraint_manager &cm_a,\n+\t\t\t   const constraint_manager &cm_b,\n+\t\t\t   constraint_manager *out,\n+\t\t\t   const model_merger &merger)\n+{\n+  gcc_assert (merger.m_sid_mapping);\n+\n+  /* Map svalue_ids in each equiv class from both sources\n+     to the merged region_model, dropping ids that don't survive merger,\n+     and potentially creating svalues in *OUT for constants.  */\n+  cleaned_constraint_manager cleaned_cm_a (out);\n+  const one_way_svalue_id_map &map_a_to_m\n+    = merger.m_sid_mapping->m_map_from_a_to_m;\n+  clean_merger_input (cm_a, map_a_to_m, &cleaned_cm_a);\n+\n+  cleaned_constraint_manager cleaned_cm_b (out);\n+  const one_way_svalue_id_map &map_b_to_m\n+    = merger.m_sid_mapping->m_map_from_b_to_m;\n+  clean_merger_input (cm_b, map_b_to_m, &cleaned_cm_b);\n+\n+  /* At this point, the two cleaned CMs have ECs and constraints referring\n+     to svalues in the merged region model, but both of them have separate\n+     ECs.  */\n+\n+  /* Merge the equivalence classes and constraints.\n+     The easiest way to do this seems to be to enumerate all of the facts\n+     in cleaned_cm_a, see which are also true in cleaned_cm_b,\n+     and add those to *OUT.  */\n+  merger_fact_visitor v (&cleaned_cm_b, out);\n+  cleaned_cm_a.for_each_fact (&v);\n+}\n+\n+/* A subroutine of constraint_manager::merge.\n+   Use MAP_SID_TO_M to map equivalence classes and constraints from\n+   SM_IN to *OUT.  Purge any non-constant svalue_id that don't appear\n+   in the result of MAP_SID_TO_M, purging any ECs and their constraints\n+   that become empty as a result.  Potentially create svalues in\n+   the merged region_model for constants that weren't already in use there.  */\n+\n+void\n+constraint_manager::\n+clean_merger_input (const constraint_manager &cm_in,\n+\t\t    const one_way_svalue_id_map &map_sid_to_m,\n+\t\t    constraint_manager *out)\n+{\n+  one_way_id_map<equiv_class_id> map_ec_to_m\n+    (cm_in.m_equiv_classes.length ());\n+  unsigned ec_idx;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (cm_in.m_equiv_classes, ec_idx, ec)\n+    {\n+      equiv_class cleaned_ec;\n+      if (tree cst = ec->get_any_constant ())\n+\t{\n+\t  cleaned_ec.m_constant = cst;\n+\t  /* Lazily create the constant in the out region_model.  */\n+\t  cleaned_ec.m_cst_sid = out->get_sid_for_constant (cst);\n+\t}\n+      unsigned var_idx;\n+      svalue_id *var_in_sid;\n+      FOR_EACH_VEC_ELT (ec->m_vars, var_idx, var_in_sid)\n+\t{\n+\t  svalue_id var_m_sid = map_sid_to_m.get_dst_for_src (*var_in_sid);\n+\t  if (!var_m_sid.null_p ())\n+\t    cleaned_ec.m_vars.safe_push (var_m_sid);\n+\t}\n+      if (cleaned_ec.get_any_constant () || !cleaned_ec.m_vars.is_empty ())\n+\t{\n+\t  map_ec_to_m.put (ec_idx, out->m_equiv_classes.length ());\n+\t  out->m_equiv_classes.safe_push (new equiv_class (cleaned_ec));\n+\t}\n+    }\n+\n+  /* Write out to *OUT any constraints for which both sides survived\n+     cleaning, using the new EC IDs.  */\n+  unsigned con_idx;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (cm_in.m_constraints, con_idx, c)\n+    {\n+      equiv_class_id new_lhs = map_ec_to_m.get_dst_for_src (c->m_lhs);\n+      if (new_lhs.null_p ())\n+\tcontinue;\n+      equiv_class_id new_rhs = map_ec_to_m.get_dst_for_src (c->m_rhs);\n+      if (new_rhs.null_p ())\n+\tcontinue;\n+      out->m_constraints.safe_push (constraint (new_lhs,\n+\t\t\t\t\t\tc->m_op,\n+\t\t\t\t\t\tnew_rhs));\n+    }\n+}\n+\n+/* Call VISITOR's on_fact vfunc repeatedly to express the various\n+   equivalence classes and constraints.\n+   This is used by constraint_manager::merge to find the common\n+   facts between two input constraint_managers.  */\n+\n+void\n+constraint_manager::for_each_fact (fact_visitor *visitor) const\n+{\n+  /* First, call EQ_EXPR within the various equivalence classes.  */\n+  unsigned ec_idx;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, ec_idx, ec)\n+    {\n+      if (!ec->m_cst_sid.null_p ())\n+\t{\n+\t  unsigned i;\n+\t  svalue_id *sid;\n+\t  FOR_EACH_VEC_ELT (ec->m_vars, i, sid)\n+\t    visitor->on_fact (ec->m_cst_sid, EQ_EXPR, *sid);\n+\t}\n+      for (unsigned i = 0; i < ec->m_vars.length (); i++)\n+\tfor (unsigned j = i + 1; j < ec->m_vars.length (); j++)\n+\t  visitor->on_fact (ec->m_vars[i], EQ_EXPR, ec->m_vars[j]);\n+    }\n+\n+  /* Now, express the various constraints.  */\n+  unsigned con_idx;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, con_idx, c)\n+    {\n+      const equiv_class &ec_lhs = c->m_lhs.get_obj (*this);\n+      const equiv_class &ec_rhs = c->m_rhs.get_obj (*this);\n+      enum tree_code code = constraint_tree_code (c->m_op);\n+\n+      if (!ec_lhs.m_cst_sid.null_p ())\n+\t{\n+\t  for (unsigned j = 0; j < ec_rhs.m_vars.length (); j++)\n+\t    {\n+\t      visitor->on_fact (ec_lhs.m_cst_sid, code, ec_rhs.m_vars[j]);\n+\t    }\n+\t}\n+      for (unsigned i = 0; i < ec_lhs.m_vars.length (); i++)\n+\t{\n+\t  if (!ec_rhs.m_cst_sid.null_p ())\n+\t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_cst_sid);\n+\t  for (unsigned j = 0; j < ec_rhs.m_vars.length (); j++)\n+\t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_vars[j]);\n+\t}\n+    }\n+}\n+\n+/* Assert that this object is valid.  */\n+\n+void\n+constraint_manager::validate () const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  int i;\n+  equiv_class *ec;\n+  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n+    {\n+      gcc_assert (ec);\n+\n+      int j;\n+      svalue_id *sid;\n+      FOR_EACH_VEC_ELT (ec->m_vars, j, sid)\n+\t{\n+\t  gcc_assert (!sid->null_p ());\n+\t  gcc_assert (sid->as_int () < get_num_svalues ());\n+\t}\n+      if (ec->m_constant)\n+\tgcc_assert (CONSTANT_CLASS_P (ec->m_constant));\n+#if 0\n+      else\n+\tgcc_assert (ec->m_vars.length () > 0);\n+#endif\n+    }\n+\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      gcc_assert (!c->m_lhs.null_p ());\n+      gcc_assert (c->m_lhs.as_int () <= (int)m_equiv_classes.length ());\n+      gcc_assert (!c->m_rhs.null_p ());\n+      gcc_assert (c->m_rhs.as_int () <= (int)m_equiv_classes.length ());\n+    }\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Various constraint_manager selftests.\n+   These have to be written in terms of a region_model, since\n+   the latter is responsible for managing svalue and svalue_id\n+   instances.  */\n+\n+/* Verify that setting and getting simple conditions within a region_model\n+   work (thus exercising the underlying constraint_manager).  */\n+\n+static void\n+test_constraint_conditions ()\n+{\n+  tree int_42 = build_int_cst (integer_type_node, 42);\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+  tree y = build_global_decl (\"y\", integer_type_node);\n+  tree z = build_global_decl (\"z\", integer_type_node);\n+\n+  /* Self-comparisons.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_TRUE (model, x, EQ_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, x, NE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, x, LT_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, x);\n+  }\n+\n+  /* x == y.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+\n+    ASSERT_CONDITION_TRUE (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_TRUE (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, LE_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, GE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, GT_EXPR, x);\n+\n+    /* Comparison with other var.  */\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, NE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LT_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GT_EXPR, z);\n+  }\n+\n+  /* x == y, then y == z  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+    ADD_SAT_CONSTRAINT (model, y, EQ_EXPR, z);\n+\n+    ASSERT_CONDITION_TRUE (model, x, EQ_EXPR, z);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, z);\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, z);\n+    ASSERT_CONDITION_FALSE (model, x, NE_EXPR, z);\n+    ASSERT_CONDITION_FALSE (model, x, LT_EXPR, z);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, z);\n+  }\n+\n+  /* x != y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, NE_EXPR, y);\n+\n+    ASSERT_CONDITION_TRUE (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GT_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_TRUE (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, LE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, GE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, GT_EXPR, x);\n+\n+    /* Comparison with other var.  */\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, NE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LT_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GT_EXPR, z);\n+  }\n+\n+  /* x < y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, LT_EXPR, y);\n+\n+    ASSERT_CONDITION_TRUE (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GE_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_FALSE (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, LE_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, GT_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, GE_EXPR, x);\n+  }\n+\n+  /* x <= y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, LE_EXPR, y);\n+\n+    ASSERT_CONDITION_UNKNOWN (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_FALSE (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, LE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, GT_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, GE_EXPR, x);\n+  }\n+\n+  /* x > y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, GT_EXPR, y);\n+\n+    ASSERT_CONDITION_TRUE (model, x, GT_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, LE_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_FALSE (model, y, GT_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, GE_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_FALSE (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, LE_EXPR, x);\n+  }\n+\n+  /* x >= y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, GE_EXPR, y);\n+\n+    ASSERT_CONDITION_UNKNOWN (model, x, GT_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, LE_EXPR, y);\n+\n+    /* Swapped operands.  */\n+    ASSERT_CONDITION_FALSE (model, y, GT_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, GE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, NE_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, EQ_EXPR, x);\n+    ASSERT_CONDITION_UNKNOWN (model, y, LT_EXPR, x);\n+    ASSERT_CONDITION_TRUE (model, y, LE_EXPR, x);\n+  }\n+\n+  // TODO: implied orderings\n+\n+  /* Constants.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_FALSE (model, int_0, EQ_EXPR, int_42);\n+    ASSERT_CONDITION_TRUE (model, int_0, NE_EXPR, int_42);\n+    ASSERT_CONDITION_TRUE (model, int_0, LT_EXPR, int_42);\n+    ASSERT_CONDITION_TRUE (model, int_0, LE_EXPR, int_42);\n+    ASSERT_CONDITION_FALSE (model, int_0, GT_EXPR, int_42);\n+    ASSERT_CONDITION_FALSE (model, int_0, GE_EXPR, int_42);\n+  }\n+\n+  /* x == 0, y == 42.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, y, EQ_EXPR, int_42);\n+\n+    ASSERT_CONDITION_TRUE (model, x, NE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, LE_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GE_EXPR, y);\n+    ASSERT_CONDITION_TRUE (model, x, LT_EXPR, y);\n+    ASSERT_CONDITION_FALSE (model, x, GT_EXPR, y);\n+  }\n+\n+  /* Unsatisfiable combinations.  */\n+\n+  /* x == y && x != y.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+    ADD_UNSAT_CONSTRAINT (model, x, NE_EXPR, y);\n+  }\n+\n+  /* x == 0 then x == 42.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n+    ADD_UNSAT_CONSTRAINT (model, x, EQ_EXPR, int_42);\n+  }\n+\n+  /* x == 0 then x != 0.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n+    ADD_UNSAT_CONSTRAINT (model, x, NE_EXPR, int_0);\n+  }\n+\n+  /* x == 0 then x > 0.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n+    ADD_UNSAT_CONSTRAINT (model, x, GT_EXPR, int_0);\n+  }\n+\n+  /* x != y && x == y.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, NE_EXPR, y);\n+    ADD_UNSAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+  }\n+\n+  /* x <= y && x > y.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, x, LE_EXPR, y);\n+    ADD_UNSAT_CONSTRAINT (model, x, GT_EXPR, y);\n+  }\n+\n+  // etc\n+}\n+\n+/* Test transitivity of conditions.  */\n+\n+static void\n+test_transitivity ()\n+{\n+  tree a = build_global_decl (\"a\", integer_type_node);\n+  tree b = build_global_decl (\"b\", integer_type_node);\n+  tree c = build_global_decl (\"c\", integer_type_node);\n+  tree d = build_global_decl (\"d\", integer_type_node);\n+\n+  /* a == b, then c == d, then c == b.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, b);\n+    ASSERT_CONDITION_UNKNOWN (model, b, EQ_EXPR, c);\n+    ASSERT_CONDITION_UNKNOWN (model, c, EQ_EXPR, d);\n+    ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, d);\n+\n+    ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, b);\n+    ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, b);\n+\n+    ADD_SAT_CONSTRAINT (model, c, EQ_EXPR, d);\n+    ASSERT_CONDITION_TRUE (model, c, EQ_EXPR, d);\n+    ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, d);\n+\n+    ADD_SAT_CONSTRAINT (model, c, EQ_EXPR, b);\n+    ASSERT_CONDITION_TRUE (model, c, EQ_EXPR, b);\n+    ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, d);\n+  }\n+\n+  /* Transitivity: \"a < b\", \"b < c\" should imply \"a < c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, LT_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, LT_EXPR, c);\n+    ASSERT_CONDITION_FALSE (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a <= b\", \"b < c\" should imply \"a < c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, LE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, LT_EXPR, c);\n+    ASSERT_CONDITION_FALSE (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a <= b\", \"b <= c\" should imply \"a <= c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, LE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, LE_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, LE_EXPR, c);\n+    ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a > b\", \"b > c\" should imply \"a > c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, GT_EXPR, c);\n+    ASSERT_CONDITION_FALSE (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a >= b\", \"b > c\" should imply \" a > c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, GT_EXPR, c);\n+    ASSERT_CONDITION_FALSE (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a >= b\", \"b >= c\" should imply \"a >= c\".  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GE_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, GE_EXPR, c);\n+    ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"(a < b)\", \"(c < d)\", \"(b < c)\" should\n+     imply the easy cases:\n+       (a < c)\n+       (b < d)\n+     but also that:\n+       (a < d).  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, LT_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, c, LT_EXPR, d);\n+    ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n+\n+    ASSERT_CONDITION_TRUE (model, a, LT_EXPR, c);\n+    ASSERT_CONDITION_TRUE (model, b, LT_EXPR, d);\n+    ASSERT_CONDITION_TRUE (model, a, LT_EXPR, d);\n+  }\n+\n+  /* Transitivity: \"a >= b\", \"b >= a\" should imply that a == b.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GE_EXPR, a);\n+\n+    // TODO:\n+    ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, b);\n+  }\n+\n+  /* Transitivity: \"a >= b\", \"b > a\" should be impossible.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n+    ADD_UNSAT_CONSTRAINT (model, b, GT_EXPR, a);\n+  }\n+\n+  /* Transitivity: \"a >= b\", \"b >= c\", \"c >= a\" should imply\n+     that a == b == c.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GE_EXPR, c);\n+    ADD_SAT_CONSTRAINT (model, c, GE_EXPR, a);\n+\n+    ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, c);\n+  }\n+\n+  /* Transitivity: \"a > b\", \"b > c\", \"c > a\"\n+     should be impossible.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n+    ADD_UNSAT_CONSTRAINT (model, c, GT_EXPR, a);\n+  }\n+\n+}\n+\n+/* Test various conditionals involving constants where the results\n+   ought to be implied based on the values of the constants.  */\n+\n+static void\n+test_constant_comparisons ()\n+{\n+  tree int_3 = build_int_cst (integer_type_node, 3);\n+  tree int_4 = build_int_cst (integer_type_node, 4);\n+  tree int_5 = build_int_cst (integer_type_node, 5);\n+\n+  tree int_1023 = build_int_cst (integer_type_node, 1023);\n+  tree int_1024 = build_int_cst (integer_type_node, 1024);\n+\n+  tree a = build_global_decl (\"a\", integer_type_node);\n+  tree b = build_global_decl (\"b\", integer_type_node);\n+\n+  /* Given a >= 1024, then a <= 1023 should be impossible.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_1024);\n+    ADD_UNSAT_CONSTRAINT (model, a, LE_EXPR, int_1023);\n+  }\n+\n+  /* a > 4.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_4);\n+    ASSERT_CONDITION_TRUE (model, a, GT_EXPR, int_4);\n+    ASSERT_CONDITION_TRUE (model, a, NE_EXPR, int_3);\n+    ASSERT_CONDITION_UNKNOWN (model, a, NE_EXPR, int_5);\n+  }\n+\n+  /* a <= 4.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n+    ASSERT_CONDITION_FALSE (model, a, GT_EXPR, int_4);\n+    ASSERT_CONDITION_FALSE (model, a, GT_EXPR, int_5);\n+    ASSERT_CONDITION_UNKNOWN (model, a, NE_EXPR, int_3);\n+  }\n+\n+  /* If \"a > b\" and \"a == 3\", then \"b == 4\" ought to be unsatisfiable.  */\n+  {\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n+    ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, int_3);\n+    ADD_UNSAT_CONSTRAINT (model, b, EQ_EXPR, int_4);\n+  }\n+\n+  /* Various tests of int ranges where there is only one possible candidate.  */\n+  {\n+    /* If \"a <= 4\" && \"a > 3\", then \"a == 4\",\n+       assuming a is of integral type.  */\n+    {\n+      region_model model;\n+      ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n+      ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+      ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n+    }\n+\n+    /* If \"a > 3\" && \"a <= 4\", then \"a == 4\",\n+       assuming a is of integral type.  */\n+    {\n+      region_model model;\n+      ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+      ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n+      ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n+    }\n+    /* If \"a > 3\" && \"a < 5\", then \"a == 4\",\n+       assuming a is of integral type.  */\n+    {\n+      region_model model;\n+      ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n+      ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_5);\n+      ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n+    }\n+    /* If \"a >= 4\" && \"a < 5\", then \"a == 4\",\n+       assuming a is of integral type.  */\n+    {\n+      region_model model;\n+      ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_4);\n+      ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_5);\n+      ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n+    }\n+    /* If \"a >= 4\" && \"a <= 4\", then \"a == 4\".  */\n+    {\n+      region_model model;\n+      ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_4);\n+      ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n+      ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n+    }\n+  }\n+\n+  /* As above, but for floating-point:\n+     if \"f > 3\" && \"f <= 4\" we don't know that f == 4.  */\n+  {\n+    tree f = build_global_decl (\"f\", double_type_node);\n+    tree float_3 = build_real_from_int_cst (double_type_node, int_3);\n+    tree float_4 = build_real_from_int_cst (double_type_node, int_4);\n+\n+    region_model model;\n+    ADD_SAT_CONSTRAINT (model, f, GT_EXPR, float_3);\n+    ADD_SAT_CONSTRAINT (model, f, LE_EXPR, float_4);\n+    ASSERT_CONDITION_UNKNOWN (model, f, EQ_EXPR, float_4);\n+    ASSERT_CONDITION_UNKNOWN (model, f, EQ_EXPR, int_4);\n+  }\n+}\n+\n+/* Verify various lower-level implementation details about\n+   constraint_manager.  */\n+\n+static void\n+test_constraint_impl ()\n+{\n+  tree int_42 = build_int_cst (integer_type_node, 42);\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+  tree y = build_global_decl (\"y\", integer_type_node);\n+  tree z = build_global_decl (\"z\", integer_type_node);\n+\n+  /* x == y.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+\n+    /* Assert various things about the insides of model.  */\n+    constraint_manager *cm = model.get_constraints ();\n+    ASSERT_EQ (cm->m_constraints.length (), 0);\n+    ASSERT_EQ (cm->m_equiv_classes.length (), 1);\n+  }\n+\n+  /* y <= z; x == y.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+\n+    ADD_SAT_CONSTRAINT (model, y, GE_EXPR, z);\n+    ASSERT_CONDITION_TRUE (model, y, GE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n+\n+    /* Assert various things about the insides of model.  */\n+    constraint_manager *cm = model.get_constraints ();\n+    ASSERT_EQ (cm->m_constraints.length (), 1);\n+    ASSERT_EQ (cm->m_equiv_classes.length (), 2);\n+\n+    /* Ensure that we merged the constraints.  */\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, z);\n+  }\n+\n+  /* y <= z; y == x.  */\n+  {\n+    region_model model;\n+    ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+\n+    ADD_SAT_CONSTRAINT (model, y, GE_EXPR, z);\n+    ASSERT_CONDITION_TRUE (model, y, GE_EXPR, z);\n+    ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n+\n+    ADD_SAT_CONSTRAINT (model, y, EQ_EXPR, x);\n+\n+    /* Assert various things about the insides of model.  */\n+    constraint_manager *cm = model.get_constraints ();\n+    ASSERT_EQ (cm->m_constraints.length (), 1);\n+    ASSERT_EQ (cm->m_equiv_classes.length (), 2);\n+\n+    /* Ensure that we merged the constraints.  */\n+    ASSERT_CONDITION_TRUE (model, x, GE_EXPR, z);\n+  }\n+\n+  /* x == 0, then x != 42.  */\n+  {\n+    region_model model;\n+\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, x, NE_EXPR, int_42);\n+\n+    /* Assert various things about the insides of model.  */\n+    constraint_manager *cm = model.get_constraints ();\n+    ASSERT_EQ (cm->m_constraints.length (), 1);\n+    ASSERT_EQ (cm->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (cm->m_constraints[0].m_lhs,\n+\t       cm->get_or_add_equiv_class (model.get_rvalue (int_0, NULL)));\n+    ASSERT_EQ (cm->m_constraints[0].m_rhs,\n+\t       cm->get_or_add_equiv_class (model.get_rvalue (int_42, NULL)));\n+    ASSERT_EQ (cm->m_constraints[0].m_op, CONSTRAINT_LT);\n+  }\n+\n+  // TODO: selftest for merging ecs \"in the middle\"\n+  // where a non-final one gets overwritten\n+\n+  // TODO: selftest where there are pre-existing constraints\n+}\n+\n+/* Check that operator== and hashing works as expected for the\n+   various types.  */\n+\n+static void\n+test_equality ()\n+{\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+  tree y = build_global_decl (\"y\", integer_type_node);\n+\n+  {\n+    region_model model0;\n+    region_model model1;\n+\n+    constraint_manager *cm0 = model0.get_constraints ();\n+    constraint_manager *cm1 = model1.get_constraints ();\n+\n+    ASSERT_EQ (cm0->hash (), cm1->hash ());\n+    ASSERT_EQ (*cm0, *cm1);\n+\n+    ASSERT_EQ (model0.hash (), model1.hash ());\n+    ASSERT_EQ (model0, model1);\n+\n+    ADD_SAT_CONSTRAINT (model1, x, EQ_EXPR, y);\n+    ASSERT_NE (cm0->hash (), cm1->hash ());\n+    ASSERT_NE (*cm0, *cm1);\n+\n+    ASSERT_NE (model0.hash (), model1.hash ());\n+    ASSERT_NE (model0, model1);\n+\n+    region_model model2;\n+    constraint_manager *cm2 = model2.get_constraints ();\n+    /* Make the same change to cm2.  */\n+    ADD_SAT_CONSTRAINT (model2, x, EQ_EXPR, y);\n+    ASSERT_EQ (cm1->hash (), cm2->hash ());\n+    ASSERT_EQ (*cm1, *cm2);\n+\n+    ASSERT_EQ (model1.hash (), model2.hash ());\n+    ASSERT_EQ (model1, model2);\n+  }\n+}\n+\n+/* Verify tracking inequality of a variable against many constants.  */\n+\n+static void\n+test_many_constants ()\n+{\n+  tree a = build_global_decl (\"a\", integer_type_node);\n+\n+  region_model model;\n+  auto_vec<tree> constants;\n+  for (int i = 0; i < 20; i++)\n+    {\n+      tree constant = build_int_cst (integer_type_node, i);\n+      constants.safe_push (constant);\n+      ADD_SAT_CONSTRAINT (model, a, NE_EXPR, constant);\n+\n+      /* Merge, and check the result.  */\n+      region_model other (model);\n+\n+      region_model merged;\n+      ASSERT_TRUE (model.can_merge_with_p (other, &merged));\n+      model.canonicalize (NULL);\n+      merged.canonicalize (NULL);\n+      ASSERT_EQ (model, merged);\n+\n+      for (int j = 0; j <= i; j++)\n+\tASSERT_CONDITION_TRUE (model, a, NE_EXPR, constants[j]);\n+    }\n+}\n+\n+/* Run the selftests in this file, temporarily overriding\n+   flag_analyzer_transitivity with TRANSITIVITY.  */\n+\n+static void\n+run_constraint_manager_tests (bool transitivity)\n+{\n+  int saved_flag_analyzer_transitivity = flag_analyzer_transitivity;\n+  flag_analyzer_transitivity = transitivity;\n+\n+  test_constraint_conditions ();\n+  if (flag_analyzer_transitivity)\n+    {\n+      /* These selftests assume transitivity.  */\n+      test_transitivity ();\n+      test_constant_comparisons ();\n+    }\n+  test_constraint_impl ();\n+  test_equality ();\n+  test_many_constants ();\n+\n+  flag_analyzer_transitivity = saved_flag_analyzer_transitivity;\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+analyzer_constraint_manager_cc_tests ()\n+{\n+  /* Run the tests twice: with and without transitivity.  */\n+  run_constraint_manager_tests (true);\n+  run_constraint_manager_tests (false);\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "c6a40f90a3364204a6078858a8c9d36f1cfc529c", "filename": "gcc/analyzer/constraint-manager.h", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,246 @@\n+/* Tracking equivalence classes and constraints at a point on an execution path.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_CONSTRAINT_MANAGER_H\n+#define GCC_ANALYZER_CONSTRAINT_MANAGER_H\n+\n+class constraint_manager;\n+\n+/* Abstract base class for specifying how state should be purged.  */\n+\n+class purge_criteria\n+{\n+public:\n+  virtual ~purge_criteria () {}\n+  virtual bool should_purge_p (svalue_id sid) const = 0;\n+};\n+\n+/* An equivalence class within a constraint manager: a set of\n+   svalue_ids that are known to all be equal to each other,\n+   together with an optional tree constant that they are equal to.  */\n+\n+class equiv_class\n+{\n+public:\n+  equiv_class ();\n+  equiv_class (const equiv_class &other);\n+\n+  hashval_t hash () const;\n+  bool operator== (const equiv_class &other);\n+\n+  void add (svalue_id sid, const constraint_manager &cm);\n+  bool del (svalue_id sid);\n+\n+  tree get_any_constant () const { return m_constant; }\n+\n+  svalue_id get_representative () const;\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+\n+  void canonicalize ();\n+\n+  void print (pretty_printer *pp) const;\n+\n+  /* An equivalence class can contain multiple constants (e.g. multiple\n+     different zeroes, for different types); these are just for the last\n+     constant added.  */\n+  tree m_constant;\n+  svalue_id m_cst_sid;\n+\n+  // TODO: should this be a set rather than a vec?\n+  auto_vec<svalue_id> m_vars;\n+};\n+\n+/* The various kinds of constraint.  */\n+\n+enum constraint_op\n+{\n+  CONSTRAINT_NE,\n+  CONSTRAINT_LT,\n+  CONSTRAINT_LE\n+};\n+\n+const char *constraint_op_code (enum constraint_op c_op);\n+\n+/* An ID for an equiv_class within a constraint_manager.  Internally, this\n+   is an index into a vector of equiv_class * within the constraint_manager.  */\n+\n+class equiv_class_id\n+{\n+public:\n+  static equiv_class_id null () { return equiv_class_id (-1); }\n+\n+  equiv_class_id (unsigned idx) : m_idx (idx) {}\n+  const equiv_class &get_obj (const constraint_manager &cm) const;\n+  equiv_class &get_obj (constraint_manager &cm) const;\n+\n+  bool operator== (const equiv_class_id &other) const\n+  {\n+    return m_idx == other.m_idx;\n+  }\n+  bool operator!= (const equiv_class_id &other) const\n+  {\n+    return m_idx != other.m_idx;\n+  }\n+\n+  bool null_p () const { return m_idx == -1; }\n+\n+  static equiv_class_id from_int (int idx) { return equiv_class_id (idx); }\n+  int as_int () const { return m_idx; }\n+\n+  void print (pretty_printer *pp) const;\n+\n+  void update_for_removal (equiv_class_id other)\n+  {\n+    if (m_idx > other.m_idx)\n+      m_idx--;\n+  }\n+\n+  int m_idx;\n+};\n+\n+/* A relationship between two equivalence classes in a constraint_manager.  */\n+\n+class constraint\n+{\n+ public:\n+  constraint (equiv_class_id lhs, enum constraint_op c_op, equiv_class_id rhs)\n+  : m_lhs (lhs), m_op (c_op), m_rhs (rhs)\n+  {\n+    gcc_assert (!lhs.null_p ());\n+    gcc_assert (!rhs.null_p ());\n+  }\n+\n+  void print (pretty_printer *pp, const constraint_manager &cm) const;\n+\n+  hashval_t hash () const;\n+  bool operator== (const constraint &other) const;\n+\n+  /* Is this an ordering, rather than a \"!=\".  */\n+  bool is_ordering_p () const\n+  {\n+    return m_op != CONSTRAINT_NE;\n+  }\n+\n+  equiv_class_id m_lhs;\n+  enum constraint_op m_op;\n+  equiv_class_id m_rhs;\n+};\n+\n+/* An abstract base class for use with constraint_manager::for_each_fact.  */\n+\n+class fact_visitor\n+{\n+ public:\n+  virtual ~fact_visitor () {}\n+  virtual void on_fact (svalue_id lhs, enum tree_code, svalue_id rhs) = 0;\n+};\n+\n+/* A collection of equivalence classes and constraints on them.\n+\n+   Given N svalues, this can be thought of as representing a subset of\n+   N-dimensional space.  When we call add_constraint,\n+   we are effectively taking an intersection with that constraint.  */\n+\n+class constraint_manager\n+{\n+public:\n+  constraint_manager () {}\n+  constraint_manager (const constraint_manager &other);\n+  virtual ~constraint_manager () {}\n+\n+  virtual constraint_manager *clone (region_model *) const = 0;\n+  virtual tree maybe_get_constant (svalue_id sid) const = 0;\n+  virtual svalue_id get_sid_for_constant (tree cst) const = 0;\n+  virtual int get_num_svalues () const = 0;\n+\n+  constraint_manager& operator= (const constraint_manager &other);\n+\n+  hashval_t hash () const;\n+  bool operator== (const constraint_manager &other) const;\n+  bool operator!= (const constraint_manager &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  void print (pretty_printer *pp) const;\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump (FILE *fp) const;\n+  void dump () const;\n+\n+  const equiv_class &get_equiv_class_by_index (unsigned idx) const\n+  {\n+    return *m_equiv_classes[idx];\n+  }\n+  equiv_class &get_equiv_class_by_index (unsigned idx)\n+  {\n+    return *m_equiv_classes[idx];\n+  }\n+\n+  equiv_class &get_equiv_class (svalue_id sid)\n+  {\n+    equiv_class_id ec_id = get_or_add_equiv_class (sid);\n+    return ec_id.get_obj (*this);\n+  }\n+\n+  bool add_constraint (svalue_id lhs, enum tree_code op, svalue_id rhs);\n+\n+  bool add_constraint (equiv_class_id lhs_ec_id,\n+\t\t       enum tree_code op,\n+\t\t       equiv_class_id rhs_ec_id);\n+\n+  bool get_equiv_class_by_sid (svalue_id sid, equiv_class_id *out) const;\n+  equiv_class_id get_or_add_equiv_class (svalue_id sid);\n+  tristate eval_condition (equiv_class_id lhs,\n+\t\t\t   enum tree_code op,\n+\t\t\t   equiv_class_id rhs);\n+  tristate eval_condition (svalue_id lhs,\n+\t\t\t   enum tree_code op,\n+\t\t\t   svalue_id rhs);\n+\n+  void purge (const purge_criteria &p, purge_stats *stats);\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+\n+  void canonicalize (unsigned num_svalue_ids);\n+\n+  static void merge (const constraint_manager &cm_a,\n+\t\t     const constraint_manager &cm_b,\n+\t\t     constraint_manager *out,\n+\t\t     const model_merger &merger);\n+\n+  void for_each_fact (fact_visitor *) const;\n+\n+  void validate () const;\n+\n+  auto_delete_vec<equiv_class> m_equiv_classes;\n+  auto_vec<constraint> m_constraints;\n+\n+ private:\n+  static void clean_merger_input (const constraint_manager &cm_in,\n+\t\t\t\t  const one_way_svalue_id_map &map_sid_to_m,\n+\t\t\t\t  constraint_manager *out);\n+\n+  void add_constraint_internal (equiv_class_id lhs_id,\n+\t\t\t\tenum constraint_op c_op,\n+\t\t\t\tequiv_class_id rhs_id);\n+};\n+\n+#endif /* GCC_ANALYZER_CONSTRAINT_MANAGER_H */"}, {"sha": "cd2c3bf2076e65c3fa22fda078a5eca39cdd3a22", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "added", "additions": 1243, "deletions": 0, "changes": 1243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,1243 @@\n+/* Classes for saving, deduplicating, and emitting analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"pretty-print.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"diagnostic-path.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/checker-path.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* class saved_diagnostic.  */\n+\n+/* saved_diagnostic's ctor.\n+   Take ownership of D and STMT_FINDER.  */\n+\n+saved_diagnostic::saved_diagnostic (const state_machine *sm,\n+\t\t\t\t    const exploded_node *enode,\n+\t\t\t\t    const supernode *snode, const gimple *stmt,\n+\t\t\t\t    stmt_finder *stmt_finder,\n+\t\t\t\t    tree var, state_machine::state_t state,\n+\t\t\t\t    pending_diagnostic *d)\n+: m_sm (sm), m_enode (enode), m_snode (snode), m_stmt (stmt),\n+ /* stmt_finder could be on-stack; we want our own copy that can\n+    outlive that.  */\n+  m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n+  m_var (var), m_state (state),\n+  m_d (d), m_trailing_eedge (NULL)\n+{\n+  gcc_assert (m_stmt || m_stmt_finder);\n+\n+  /* We must have an enode in order to be able to look for paths\n+     through the exploded_graph to this diagnostic.  */\n+  gcc_assert (m_enode);\n+}\n+\n+/* saved_diagnostic's dtor.  */\n+\n+saved_diagnostic::~saved_diagnostic ()\n+{\n+  delete m_stmt_finder;\n+  delete m_d;\n+}\n+\n+/* class diagnostic_manager.  */\n+\n+/* diagnostic_manager's ctor.  */\n+\n+diagnostic_manager::diagnostic_manager (logger *logger, int verbosity)\n+: log_user (logger), m_verbosity (verbosity)\n+{\n+}\n+\n+/* Queue pending_diagnostic D at ENODE for later emission.  */\n+\n+void\n+diagnostic_manager::add_diagnostic (const state_machine *sm,\n+\t\t\t\t    const exploded_node *enode,\n+\t\t\t\t    const supernode *snode, const gimple *stmt,\n+\t\t\t\t    stmt_finder *finder,\n+\t\t\t\t    tree var, state_machine::state_t state,\n+\t\t\t\t    pending_diagnostic *d)\n+{\n+  LOG_FUNC (get_logger ());\n+\n+  /* We must have an enode in order to be able to look for paths\n+     through the exploded_graph to the diagnostic.  */\n+  gcc_assert (enode);\n+\n+  saved_diagnostic *sd\n+    = new saved_diagnostic (sm, enode, snode, stmt, finder, var, state, d);\n+  m_saved_diagnostics.safe_push (sd);\n+  if (get_logger ())\n+    log (\"adding saved diagnostic %i at SN %i: %qs\",\n+\t m_saved_diagnostics.length () - 1,\n+\t snode->m_index, d->get_kind ());\n+}\n+\n+/* Queue pending_diagnostic D at ENODE for later emission.  */\n+\n+void\n+diagnostic_manager::add_diagnostic (const exploded_node *enode,\n+\t\t\t\t    const supernode *snode, const gimple *stmt,\n+\t\t\t\t    stmt_finder *finder,\n+\t\t\t\t    pending_diagnostic *d)\n+{\n+  gcc_assert (enode);\n+  add_diagnostic (NULL, enode, snode, stmt, finder, NULL_TREE, 0, d);\n+}\n+\n+/* A class for identifying sets of duplicated pending_diagnostic.\n+\n+   We want to find the simplest dedupe_candidate amongst those that share a\n+   dedupe_key.  */\n+\n+class dedupe_key\n+{\n+public:\n+  dedupe_key (const saved_diagnostic &sd,\n+\t      const exploded_path &epath)\n+  : m_sd (sd), m_stmt (sd.m_stmt)\n+  {\n+    /* Support deferring the choice of stmt until after an emission path has\n+     been built, using an optional stmt_finder.  */\n+    if (m_stmt == NULL)\n+      {\n+\tgcc_assert (sd.m_stmt_finder);\n+\tm_stmt = sd.m_stmt_finder->find_stmt (epath);\n+      }\n+    gcc_assert (m_stmt);\n+  }\n+\n+  hashval_t hash () const\n+  {\n+    inchash::hash hstate;\n+    hstate.add_ptr (m_stmt);\n+    // TODO: m_sd\n+    return hstate.end ();\n+  }\n+  bool operator== (const dedupe_key &other) const\n+  {\n+    return (m_sd == other.m_sd\n+\t    && m_stmt == other.m_stmt);\n+  }\n+\n+  location_t get_location () const\n+  {\n+    return m_stmt->location;\n+  }\n+\n+  /* A qsort comparator for use by dedupe_winners::emit_best\n+     to sort them into location_t order.  */\n+\n+  static int\n+  comparator (const void *p1, const void *p2)\n+  {\n+    const dedupe_key *pk1 = *(const dedupe_key * const *)p1;\n+    const dedupe_key *pk2 = *(const dedupe_key * const *)p2;\n+\n+    location_t loc1 = pk1->get_location ();\n+    location_t loc2 = pk2->get_location ();\n+\n+    return linemap_compare_locations (line_table, loc2, loc1);\n+  }\n+\n+  const saved_diagnostic &m_sd;\n+  const gimple *m_stmt;\n+};\n+\n+/* The value of a slot for a dedupe_key within dedupe_winners:\n+   the exploded_path for the best candidate for that key, and the\n+   number of duplicates seen so far.  */\n+\n+class dedupe_candidate\n+{\n+public:\n+  // has the exploded_path\n+  dedupe_candidate (const shortest_exploded_paths &sp,\n+\t\t    const saved_diagnostic &sd)\n+  : m_epath (sp.get_shortest_path (sd.m_enode)),\n+    m_num_dupes (0)\n+  {\n+  }\n+\n+  unsigned length () const { return m_epath.length (); }\n+  const exploded_path &get_path () const { return m_epath; }\n+\n+  void add_duplicate () { m_num_dupes++; }\n+  int get_num_dupes () const { return m_num_dupes; }\n+\n+private:\n+  exploded_path m_epath;\n+public:\n+  int m_num_dupes;\n+};\n+\n+/* Traits for use by dedupe_winners.  */\n+\n+class dedupe_hash_map_traits\n+{\n+public:\n+  typedef const dedupe_key *key_type;\n+  typedef dedupe_candidate *value_type;\n+  typedef dedupe_candidate *compare_type;\n+\n+  static inline hashval_t hash (const key_type &v)\n+  {\n+    return v->hash ();\n+  }\n+  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+  {\n+    return *k1 == *k2;\n+  }\n+  template <typename T>\n+  static inline void remove (T &)\n+  {\n+    // TODO\n+  }\n+  template <typename T>\n+  static inline void mark_deleted (T &entry)\n+  {\n+    entry.m_key = reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline void mark_empty (T &entry)\n+  {\n+    entry.m_key = NULL;\n+  }\n+  template <typename T>\n+  static inline bool is_deleted (const T &entry)\n+  {\n+    return entry.m_key == reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == NULL;\n+  }\n+  static const bool empty_zero_p = true;\n+};\n+\n+/* A class for deduplicating diagnostics and finding (and emitting) the\n+   best diagnostic within each partition.  */\n+\n+class dedupe_winners\n+{\n+public:\n+  ~dedupe_winners ()\n+  {\n+    /* Delete all keys and candidates.  */\n+    for (map_t::iterator iter = m_map.begin ();\n+\t iter != m_map.end ();\n+\t ++iter)\n+      {\n+\tdelete (*iter).first;\n+\tdelete (*iter).second;\n+      }\n+  }\n+\n+  /* Determine an exploded_path for SD using SP and, if it's feasible,\n+     determine if it's the best seen so far for its dedupe_key.\n+     Retain the winner for each dedupe_key, and discard the rest.  */\n+\n+  void add (logger *logger,\n+\t    const shortest_exploded_paths &sp,\n+\t    const saved_diagnostic &sd)\n+  {\n+    /* Build a dedupe_candidate for SD.\n+       This uses SP to build an exploded_path.  */\n+    dedupe_candidate *dc = new dedupe_candidate (sp, sd);\n+\n+    /* Verify that the epath is feasible.\n+       State-merging means that not every path in the epath corresponds\n+       to a feasible one w.r.t. states.\n+       Here we simply check each duplicate saved_diagnostic's\n+       shortest_path, and reject any that aren't feasible.\n+       This could introduce false negatives, as there could be longer\n+       feasible paths within the egraph.  */\n+    if (logger)\n+      logger->log (\"considering %qs at SN: %i\",\n+\t\t   sd.m_d->get_kind (), sd.m_snode->m_index);\n+    if (!dc->get_path ().feasible_p (logger))\n+      {\n+\tif (logger)\n+\t  logger->log (\"rejecting %qs at SN: %i\"\n+\t\t       \" due to infeasible path\",\n+\t\t       sd.m_d->get_kind (), sd.m_snode->m_index);\n+\tdelete dc;\n+\treturn;\n+      }\n+    else\n+      if (logger)\n+\tlogger->log (\"accepting %qs at SN: %i with feasible path\",\n+\t\t     sd.m_d->get_kind (), sd.m_snode->m_index);\n+\n+    dedupe_key *key = new dedupe_key (sd, dc->get_path ());\n+    if (dedupe_candidate **slot = m_map.get (key))\n+      {\n+\t(*slot)->add_duplicate ();\n+\n+\tif (dc->length () < (*slot)->length ())\n+\t  {\n+\t    /* We've got a shorter path for the key; replace\n+\t       the current candidate.  */\n+\t    dc->m_num_dupes = (*slot)->get_num_dupes ();\n+\t    delete *slot;\n+\t    *slot = dc;\n+\t  }\n+\telse\n+\t  /* We haven't beaten the current best candidate;\n+\t     drop the new candidate.  */\n+\t  delete dc;\n+\tdelete key;\n+      }\n+    else\n+      /* This is the first candidate for this key.  */\n+      m_map.put (key, dc);\n+  }\n+\n+ /* Emit the simplest diagnostic within each set.  */\n+\n+  void emit_best (diagnostic_manager *dm,\n+\t\t  const exploded_graph &eg)\n+  {\n+    LOG_SCOPE (dm->get_logger ());\n+\n+    /* Get keys into a vec for sorting.  */\n+    auto_vec<const dedupe_key *> keys (m_map.elements ());\n+    for (map_t::iterator iter = m_map.begin ();\n+\t iter != m_map.end ();\n+\t ++iter)\n+      keys.quick_push ((*iter).first);\n+\n+    dm->log (\"# keys after de-duplication: %i\", keys.length ());\n+\n+    /* Sort into a good emission order.  */\n+    keys.qsort (dedupe_key::comparator);\n+\n+    /* Emit the best candidate for each key.  */\n+    int i;\n+    const dedupe_key *key;\n+    FOR_EACH_VEC_ELT (keys, i, key)\n+      {\n+\tdedupe_candidate **slot = m_map.get (key);\n+\tgcc_assert (*slot);\n+\tconst dedupe_candidate &dc = **slot;\n+\n+\tdm->emit_saved_diagnostic (eg, key->m_sd,\n+\t\t\t\t   dc.get_path (), key->m_stmt,\n+\t\t\t\t   dc.get_num_dupes ());\n+      }\n+  }\n+\n+private:\n+\n+  /* This maps from each dedupe_key to a current best dedupe_candidate.  */\n+\n+  typedef hash_map<const dedupe_key *, dedupe_candidate *,\n+\t\t   dedupe_hash_map_traits> map_t;\n+  map_t m_map;\n+};\n+\n+/* Emit all saved diagnostics.  */\n+\n+void\n+diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n+{\n+  LOG_SCOPE (get_logger ());\n+  auto_timevar tv (TV_ANALYZER_DIAGNOSTICS);\n+  log (\"# saved diagnostics: %i\", m_saved_diagnostics.length ());\n+\n+  if (m_saved_diagnostics.length () == 0)\n+    return;\n+\n+  /* Compute the shortest_paths once, sharing it between all diagnostics.  */\n+  shortest_exploded_paths sp (eg, eg.get_origin ());\n+\n+  /* Iterate through all saved diagnostics, adding them to a dedupe_winners\n+     instance.  This partitions the saved diagnostics by dedupe_key,\n+     generating exploded_paths for them, and retaining the best one in each\n+     partition.  */\n+  dedupe_winners best_candidates;\n+\n+  int i;\n+  saved_diagnostic *sd;\n+  FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n+    best_candidates.add (get_logger (), sp, *sd);\n+\n+  /* For each dedupe-key, call emit_saved_diagnostic on the \"best\"\n+     saved_diagnostic.  */\n+  best_candidates.emit_best (this, eg);\n+}\n+\n+/* Given a saved_diagnostic SD at STMT with feasible path EPATH through EG,\n+   create an checker_path of suitable events and use it to call\n+   SD's underlying pending_diagnostic \"emit\" vfunc to emit a diagnostic.  */\n+\n+void\n+diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n+\t\t\t\t\t   const saved_diagnostic &sd,\n+\t\t\t\t\t   const exploded_path &epath,\n+\t\t\t\t\t   const gimple *stmt,\n+\t\t\t\t\t   int num_dupes)\n+{\n+  LOG_SCOPE (get_logger ());\n+  log (\"sd: %qs at SN: %i\", sd.m_d->get_kind (), sd.m_snode->m_index);\n+  log (\"num dupes: %i\", num_dupes);\n+\n+  pretty_printer *pp = global_dc->printer->clone ();\n+\n+  checker_path emission_path;\n+\n+  /* Populate emission_path with a full description of EPATH.  */\n+  build_emission_path (eg, epath, &emission_path);\n+\n+  /* Now prune it to just cover the most pertinent events.  */\n+  prune_path (&emission_path, sd.m_sm, sd.m_var, sd.m_state);\n+\n+  /* Add a final event to the path, covering the diagnostic itself.\n+     We use the final enode from the epath, which might be different from\n+     the sd.m_enode, as the dedupe code doesn't care about enodes, just\n+     snodes.  */\n+  emission_path.add_final_event (sd.m_sm, epath.get_final_enode (), stmt,\n+\t\t\t\t sd.m_var, sd.m_state);\n+\n+  /* The \"final\" event might not be final; if the saved_diagnostic has a\n+     trailing eedge stashed, add any events for it.  This is for use\n+     in handling longjmp, to show where a longjmp is rewinding to.  */\n+  if (sd.m_trailing_eedge)\n+    add_events_for_eedge (*sd.m_trailing_eedge, eg.get_ext_state (),\n+\t\t\t  &emission_path);\n+\n+  emission_path.prepare_for_emission (sd.m_d);\n+\n+  gcc_rich_location rich_loc (stmt->location);\n+  rich_loc.set_path (&emission_path);\n+\n+  auto_diagnostic_group d;\n+  auto_cfun sentinel (sd.m_snode->m_fun);\n+  if (sd.m_d->emit (&rich_loc))\n+    {\n+      if (num_dupes > 0)\n+\tinform_n (stmt->location, num_dupes,\n+\t\t  \"%i duplicate\", \"%i duplicates\",\n+\t\t  num_dupes);\n+    }\n+  delete pp;\n+}\n+\n+/* Given a state change to DST_REP, determine a tree that gives the origin\n+   of that state at STMT, using DST_STATE's region model, so that state\n+   changes based on assignments can be tracked back to their origins.\n+\n+   For example, if we have\n+\n+     (S1) _1 = malloc (64);\n+     (S2) EXPR = _1;\n+\n+   then at stmt S2 we can get the origin of EXPR's state as being _1,\n+   and thus track the allocation back to S1.  */\n+\n+static tree\n+get_any_origin (const gimple *stmt,\n+\t\ttree dst_rep,\n+\t\tconst program_state &dst_state)\n+{\n+  if (!stmt)\n+    return NULL_TREE;\n+\n+  gcc_assert (dst_rep);\n+\n+  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (assign);\n+      /* Use region IDs to compare lhs with DST_REP.  */\n+      if (dst_state.m_region_model->get_lvalue (lhs, NULL)\n+\t  == dst_state.m_region_model->get_lvalue (dst_rep, NULL))\n+\t{\n+\t  tree rhs1 = gimple_assign_rhs1 (assign);\n+\t  enum tree_code op = gimple_assign_rhs_code (assign);\n+\t  switch (op)\n+\t    {\n+\t    default:\n+\t      //gcc_unreachable ();  // TODO\n+\t      break;\n+\t    case COMPONENT_REF:\n+\t    case SSA_NAME:\n+\t      return rhs1;\n+\t    }\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Emit a \"path\" of events to EMISSION_PATH describing the exploded path\n+   EPATH within EG.  */\n+\n+void\n+diagnostic_manager::build_emission_path (const exploded_graph &eg,\n+\t\t\t\t\t const exploded_path &epath,\n+\t\t\t\t\t checker_path *emission_path) const\n+{\n+  LOG_SCOPE (get_logger ());\n+  const extrinsic_state &ext_state = eg.get_ext_state ();\n+  for (unsigned i = 0; i < epath.m_edges.length (); i++)\n+    {\n+      const exploded_edge *eedge = epath.m_edges[i];\n+      add_events_for_eedge (*eedge, ext_state, emission_path);\n+    }\n+}\n+\n+/* Subclass of state_change_visitor that creates state_change_event\n+   instances.  */\n+\n+class state_change_event_creator : public state_change_visitor\n+{\n+public:\n+  state_change_event_creator (const exploded_edge &eedge,\n+\t\t\t      checker_path *emission_path)\n+    : m_eedge (eedge),\n+      m_emission_path (emission_path)\n+  {}\n+\n+  bool on_global_state_change (const state_machine &sm,\n+\t\t\t       state_machine::state_t src_sm_val,\n+\t\t\t       state_machine::state_t dst_sm_val)\n+    FINAL OVERRIDE\n+  {\n+    const exploded_node *src_node = m_eedge.m_src;\n+    const program_point &src_point = src_node->get_point ();\n+    const int src_stack_depth = src_point.get_stack_depth ();\n+    const exploded_node *dst_node = m_eedge.m_dest;\n+    const gimple *stmt = src_point.get_stmt ();\n+    const supernode *supernode = src_point.get_supernode ();\n+    const program_state &dst_state = dst_node->get_state ();\n+\n+    int stack_depth = src_stack_depth;\n+\n+    m_emission_path->add_event (new state_change_event (supernode,\n+\t\t\t\t\t\t\tstmt,\n+\t\t\t\t\t\t\tstack_depth,\n+\t\t\t\t\t\t\tsm,\n+\t\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\t\tsrc_sm_val,\n+\t\t\t\t\t\t\tdst_sm_val,\n+\t\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\t\tdst_state));\n+    return false;\n+  }\n+\n+  bool on_state_change (const state_machine &sm,\n+\t\t\tstate_machine::state_t src_sm_val,\n+\t\t\tstate_machine::state_t dst_sm_val,\n+\t\t\ttree dst_rep,\n+\t\t\tsvalue_id dst_origin_sid) FINAL OVERRIDE\n+  {\n+    const exploded_node *src_node = m_eedge.m_src;\n+    const program_point &src_point = src_node->get_point ();\n+    const int src_stack_depth = src_point.get_stack_depth ();\n+    const exploded_node *dst_node = m_eedge.m_dest;\n+    const gimple *stmt = src_point.get_stmt ();\n+    const supernode *supernode = src_point.get_supernode ();\n+    const program_state &dst_state = dst_node->get_state ();\n+\n+    int stack_depth = src_stack_depth;\n+\n+    if (m_eedge.m_sedge\n+\t&& m_eedge.m_sedge->m_kind == SUPEREDGE_CFG_EDGE)\n+      {\n+\tsupernode = src_point.get_supernode ();\n+\tstmt = supernode->get_last_stmt ();\n+\tstack_depth = src_stack_depth;\n+      }\n+\n+    /* Bulletproofing for state changes at calls/returns;\n+       TODO: is there a better way? */\n+    if (!stmt)\n+      return false;\n+\n+    tree origin_rep\n+      = dst_state.get_representative_tree (dst_origin_sid);\n+\n+    if (origin_rep == NULL_TREE)\n+      origin_rep = get_any_origin (stmt, dst_rep, dst_state);\n+    m_emission_path->add_event (new state_change_event (supernode,\n+\t\t\t\t\t\t\tstmt,\n+\t\t\t\t\t\t\tstack_depth,\n+\t\t\t\t\t\t\tsm,\n+\t\t\t\t\t\t\tdst_rep,\n+\t\t\t\t\t\t\tsrc_sm_val,\n+\t\t\t\t\t\t\tdst_sm_val,\n+\t\t\t\t\t\t\torigin_rep,\n+\t\t\t\t\t\t\tdst_state));\n+    return false;\n+  }\n+\n+  const exploded_edge &m_eedge;\n+  checker_path *m_emission_path;\n+};\n+\n+/* Compare SRC_STATE and DST_STATE (which use EXT_STATE), and call\n+   VISITOR's on_state_change for every sm-state change that occurs\n+   to a tree, and on_global_state_change for every global state change\n+   that occurs.\n+\n+   This determines the state changes that ought to be reported to\n+   the user: a combination of the effects of changes to sm_state_map\n+   (which maps svalues to sm-states), and of region_model changes\n+   (which map trees to svalues).\n+\n+   Bail out early and return true if any call to on_global_state_change\n+   or on_state_change returns true, otherwise return false.\n+\n+   This is split out to make it easier to experiment with changes to\n+   exploded_node granularity (so that we can observe what state changes\n+   lead to state_change_events being emitted).  */\n+\n+bool\n+for_each_state_change (const program_state &src_state,\n+\t\t       const program_state &dst_state,\n+\t\t       const extrinsic_state &ext_state,\n+\t\t       state_change_visitor *visitor)\n+{\n+  gcc_assert (src_state.m_checker_states.length ()\n+\t      == ext_state.m_checkers.length ());\n+  gcc_assert (dst_state.m_checker_states.length ()\n+\t      == ext_state.m_checkers.length ());\n+  for (unsigned i = 0; i < ext_state.m_checkers.length (); i++)\n+    {\n+      const state_machine &sm = ext_state.get_sm (i);\n+      const sm_state_map &src_smap = *src_state.m_checker_states[i];\n+      const sm_state_map &dst_smap = *dst_state.m_checker_states[i];\n+\n+      /* Add events for any global state changes.  */\n+      if (src_smap.get_global_state () != dst_smap.get_global_state ())\n+\tif (visitor->on_global_state_change (sm,\n+\t\t\t\t\t     src_smap.get_global_state (),\n+\t\t\t\t\t     dst_smap.get_global_state ()))\n+\t  return true;\n+\n+      /* Add events for per-svalue state changes.  */\n+      for (sm_state_map::iterator_t iter = dst_smap.begin ();\n+\t   iter != dst_smap.end ();\n+\t   ++iter)\n+\t{\n+\t  /* Ideally we'd directly compare the SM state between src state\n+\t     and dst state, but there's no guarantee that the IDs can\n+\t     be meaningfully compared.  */\n+\t  svalue_id dst_sid = (*iter).first;\n+\t  state_machine::state_t dst_sm_val = (*iter).second.m_state;\n+\n+\t  auto_vec<path_var> dst_pvs;\n+\t  dst_state.m_region_model->get_path_vars_for_svalue (dst_sid,\n+\t\t\t\t\t\t\t      &dst_pvs);\n+\n+\t  unsigned j;\n+\t  path_var *dst_pv;\n+\t  FOR_EACH_VEC_ELT (dst_pvs, j, dst_pv)\n+\t    {\n+\t      tree dst_rep = dst_pv->m_tree;\n+\t      gcc_assert (dst_rep);\n+\t      if (dst_pv->m_stack_depth\n+\t\t  >= src_state.m_region_model->get_stack_depth ())\n+\t\tcontinue;\n+\t      svalue_id src_sid\n+\t\t= src_state.m_region_model->get_rvalue (*dst_pv, NULL);\n+\t      if (src_sid.null_p ())\n+\t\tcontinue;\n+\t      state_machine::state_t src_sm_val = src_smap.get_state (src_sid);\n+\t      if (dst_sm_val != src_sm_val)\n+\t\t{\n+\t\t  svalue_id dst_origin_sid = (*iter).second.m_origin;\n+\t\t  if (visitor->on_state_change (sm, src_sm_val, dst_sm_val,\n+\t\t\t\t\t\tdst_rep, dst_origin_sid))\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Subroutine of diagnostic_manager::build_emission_path.\n+   Add any events for EEDGE to EMISSION_PATH.  */\n+\n+void\n+diagnostic_manager::add_events_for_eedge (const exploded_edge &eedge,\n+\t\t\t\t\t  const extrinsic_state &ext_state,\n+\t\t\t\t\t  checker_path *emission_path) const\n+{\n+  const exploded_node *src_node = eedge.m_src;\n+  const program_point &src_point = src_node->get_point ();\n+  const exploded_node *dst_node = eedge.m_dest;\n+  const program_point &dst_point = dst_node->get_point ();\n+  const int dst_stack_depth = dst_point.get_stack_depth ();\n+  if (get_logger ())\n+    {\n+      get_logger ()->start_log_line ();\n+      pretty_printer *pp = get_logger ()->get_printer ();\n+      pp_printf (pp, \"EN %i -> EN %i: \",\n+\t\t eedge.m_src->m_index,\n+\t\t eedge.m_dest->m_index);\n+      src_point.print (pp, format (false));\n+      pp_string (pp, \"-> \");\n+      dst_point.print (pp, format (false));\n+      get_logger ()->end_log_line ();\n+    }\n+  const program_state &src_state = src_node->get_state ();\n+  const program_state &dst_state = dst_node->get_state ();\n+\n+  /* Add state change events for the states that have changed.\n+     We add these before events for superedges, so that if we have a\n+     state_change_event due to following an edge, we'll get this sequence\n+     of events:\n+\n+      | if (!ptr)\n+      |    ~\n+      |    |\n+      |    (1) assuming 'ptr' is non-NULL  (state_change_event)\n+      |    (2) following 'false' branch... (start_cfg_edge_event)\n+     ...\n+      | do_something (ptr);\n+      | ~~~~~~~~~~~~~^~~~~\n+      |              |\n+      |              (3) ...to here        (end_cfg_edge_event).  */\n+  state_change_event_creator visitor (eedge, emission_path);\n+  for_each_state_change (src_state, dst_state, ext_state,\n+\t\t\t &visitor);\n+\n+  /* Allow non-standard edges to add events, e.g. when rewinding from\n+     longjmp to a setjmp.  */\n+  if (eedge.m_custom_info)\n+    eedge.m_custom_info->add_events_to_path (emission_path, eedge);\n+\n+  /* Add events for superedges, function entries, and for statements.  */\n+  switch (dst_point.get_kind ())\n+    {\n+    default:\n+      break;\n+    case PK_BEFORE_SUPERNODE:\n+      if (src_point.get_kind () == PK_AFTER_SUPERNODE)\n+\t{\n+\t  if (eedge.m_sedge)\n+\t    add_events_for_superedge (eedge, emission_path);\n+\t}\n+      /* Add function entry events.  */\n+      if (dst_point.get_supernode ()->entry_p ())\n+\t{\n+\t  emission_path->add_event\n+\t    (new function_entry_event\n+\t     (dst_point.get_supernode ()->get_start_location (),\n+\t      dst_point.get_fndecl (),\n+\t      dst_stack_depth));\n+\t}\n+      break;\n+    case PK_BEFORE_STMT:\n+      {\n+\tconst gimple *stmt = dst_point.get_stmt ();\n+\tif (is_setjmp_call_p (stmt))\n+\t  emission_path->add_event\n+\t    (new setjmp_event (stmt->location,\n+\t\t\t       dst_node,\n+\t\t\t       dst_point.get_fndecl (),\n+\t\t\t       dst_stack_depth));\n+\telse\n+\t  emission_path->add_event\n+\t    (new statement_event (stmt,\n+\t\t\t\t  dst_point.get_fndecl (),\n+\t\t\t\t  dst_stack_depth, dst_state));\n+      }\n+      break;\n+    }\n+}\n+\n+/* Subroutine of diagnostic_manager::add_events_for_eedge\n+   where EEDGE has an underlying superedge i.e. a CFG edge,\n+   or an interprocedural call/return.\n+   Add any events for the superedge to EMISSION_PATH.  */\n+\n+void\n+diagnostic_manager::add_events_for_superedge (const exploded_edge &eedge,\n+\t\t\t\t\t      checker_path *emission_path)\n+  const\n+{\n+  gcc_assert (eedge.m_sedge);\n+\n+  const exploded_node *src_node = eedge.m_src;\n+  const program_point &src_point = src_node->get_point ();\n+  const exploded_node *dst_node = eedge.m_dest;\n+  const program_point &dst_point = dst_node->get_point ();\n+  const int src_stack_depth = src_point.get_stack_depth ();\n+  const int dst_stack_depth = dst_point.get_stack_depth ();\n+  const gimple *last_stmt = src_point.get_supernode ()->get_last_stmt ();\n+\n+  switch (eedge.m_sedge->m_kind)\n+    {\n+    case SUPEREDGE_CFG_EDGE:\n+      {\n+\temission_path->add_event\n+\t  (new start_cfg_edge_event (eedge,\n+\t\t\t       (last_stmt\n+\t\t\t\t? last_stmt->location\n+\t\t\t\t: UNKNOWN_LOCATION),\n+\t\t\t       src_point.get_fndecl (),\n+\t\t\t       src_stack_depth));\n+\temission_path->add_event\n+\t  (new end_cfg_edge_event (eedge,\n+\t\t\t\t   dst_point.get_supernode ()->get_start_location (),\n+\t\t\t\t   dst_point.get_fndecl (),\n+\t\t\t\t   dst_stack_depth));\n+      }\n+      break;\n+\n+    case SUPEREDGE_CALL:\n+      {\n+\temission_path->add_event\n+\t  (new call_event (eedge,\n+\t\t\t   (last_stmt\n+\t\t\t    ? last_stmt->location\n+\t\t\t    : UNKNOWN_LOCATION),\n+\t\t\t   src_point.get_fndecl (),\n+\t\t\t   src_stack_depth));\n+      }\n+      break;\n+\n+    case SUPEREDGE_INTRAPROCEDURAL_CALL:\n+      {\n+\t/* TODO: add a subclass for this, or generate events for the\n+\t   summary.  */\n+\temission_path->add_event\n+\t  (new debug_event ((last_stmt\n+\t\t\t     ? last_stmt->location\n+\t\t\t     : UNKNOWN_LOCATION),\n+\t\t\t    src_point.get_fndecl (),\n+\t\t\t    src_stack_depth,\n+\t\t\t    \"call summary\"));\n+      }\n+      break;\n+\n+    case SUPEREDGE_RETURN:\n+      {\n+\tconst return_superedge *return_edge\n+\t  = as_a <const return_superedge *> (eedge.m_sedge);\n+\n+\tconst gcall *call_stmt = return_edge->get_call_stmt ();\n+\temission_path->add_event\n+\t  (new return_event (eedge,\n+\t\t\t     (call_stmt\n+\t\t\t      ? call_stmt->location\n+\t\t\t      : UNKNOWN_LOCATION),\n+\t\t\t     dst_point.get_fndecl (),\n+\t\t\t     dst_stack_depth));\n+      }\n+      break;\n+    }\n+}\n+\n+/* Prune PATH, based on the verbosity level, to the most pertinent\n+   events for a diagnostic that involves VAR ending in state STATE\n+   (for state machine SM).\n+\n+   PATH is updated in place, and the redundant checker_events are deleted.\n+\n+   As well as deleting events, call record_critical_state on events in\n+   which state critical to the pending_diagnostic is being handled; see\n+   the comment for diagnostic_manager::prune_for_sm_diagnostic.  */\n+\n+void\n+diagnostic_manager::prune_path (checker_path *path,\n+\t\t\t\tconst state_machine *sm,\n+\t\t\t\ttree var,\n+\t\t\t\tstate_machine::state_t state) const\n+{\n+  LOG_FUNC (get_logger ());\n+  path->maybe_log (get_logger (), \"path\");\n+  prune_for_sm_diagnostic (path, sm, var, state);\n+  prune_interproc_events (path);\n+  finish_pruning (path);\n+  path->maybe_log (get_logger (), \"pruned\");\n+}\n+\n+/* First pass of diagnostic_manager::prune_path: apply verbosity level,\n+   pruning unrelated state change events.\n+\n+   Iterate backwards through PATH, skipping state change events that aren't\n+   VAR but update the pertinent VAR when state-copying occurs.\n+\n+   As well as deleting events, call record_critical_state on events in\n+   which state critical to the pending_diagnostic is being handled, so\n+   that the event's get_desc vfunc can potentially supply a more precise\n+   description of the event to the user.\n+   e.g. improving\n+     \"calling 'foo' from 'bar'\"\n+   to\n+     \"passing possibly-NULL pointer 'ptr' to 'foo' from 'bar' as param 1\"\n+   when the diagnostic relates to later dereferencing 'ptr'.  */\n+\n+void\n+diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n+\t\t\t\t\t     const state_machine *sm,\n+\t\t\t\t\t     tree var,\n+\t\t\t\t\t     state_machine::state_t state) const\n+{\n+  int idx = path->m_events.length () - 1;\n+  while (idx >= 0 && idx < (signed)path->m_events.length ())\n+    {\n+      checker_event *base_event = path->m_events[idx];\n+      if (get_logger ())\n+\t{\n+\t  if (sm)\n+\t    {\n+\t      if (var)\n+\t\tlog (\"considering event %i, with var: %qE, state: %qs\",\n+\t\t     idx, var, sm->get_state_name (state));\n+\t      else\n+\t\tlog (\"considering event %i, with global state: %qs\",\n+\t\t     idx, sm->get_state_name (state));\n+\t    }\n+\t  else\n+\t    log (\"considering event %i\", idx);\n+\t}\n+      switch (base_event->m_kind)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\n+\tcase EK_DEBUG:\n+\t  if (m_verbosity < 3)\n+\t    {\n+\t      log (\"filtering event %i: debug event\", idx);\n+\t      path->delete_event (idx);\n+\t    }\n+\t  break;\n+\n+\tcase EK_CUSTOM:\n+\t  /* Don't filter custom events.  */\n+\t  break;\n+\n+\tcase EK_STMT:\n+\t  {\n+\t    /* If this stmt is the origin of \"var\", update var.  */\n+\t    if (var)\n+\t      {\n+\t\tstatement_event *stmt_event = (statement_event *)base_event;\n+\t\ttree new_var = get_any_origin (stmt_event->m_stmt, var,\n+\t\t\t\t\t       stmt_event->m_dst_state);\n+\t\tif (new_var)\n+\t\t  {\n+\t\t    log (\"event %i: switching var of interest from %qE to %qE\",\n+\t\t\t idx, var, new_var);\n+\t\t    var = new_var;\n+\t\t  }\n+\t      }\n+\t    if (m_verbosity < 3)\n+\t      {\n+\t\tlog (\"filtering event %i: statement event\", idx);\n+\t\tpath->delete_event (idx);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EK_FUNCTION_ENTRY:\n+\t  if (m_verbosity < 1)\n+\t    {\n+\t      log (\"filtering event %i: function entry\", idx);\n+\t      path->delete_event (idx);\n+\t    }\n+\t  break;\n+\n+\tcase EK_STATE_CHANGE:\n+\t  {\n+\t    state_change_event *state_change = (state_change_event *)base_event;\n+\t    if (state_change->get_lvalue (state_change->m_var)\n+\t\t== state_change->get_lvalue (var))\n+\t      {\n+\t\tif (state_change->m_origin)\n+\t\t  {\n+\t\t    log (\"event %i: switching var of interest from %qE to %qE\",\n+\t\t\t idx, var, state_change->m_origin);\n+\t\t    var = state_change->m_origin;\n+\t\t  }\n+\t\tlog (\"event %i: switching state of interest from %qs to %qs\",\n+\t\t     idx, sm->get_state_name (state_change->m_to),\n+\t\t     sm->get_state_name (state_change->m_from));\n+\t\tstate = state_change->m_from;\n+\t      }\n+\t    else if (m_verbosity < 3)\n+\t      {\n+\t\tif (var)\n+\t\t  log (\"filtering event %i:\"\n+\t\t       \" state change to %qE unrelated to %qE\",\n+\t\t       idx, state_change->m_var, var);\n+\t\telse\n+\t\t  log (\"filtering event %i: state change to %qE\",\n+\t\t       idx, state_change->m_var);\n+\t\tpath->delete_event (idx);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EK_START_CFG_EDGE:\n+\t  {\n+\t    cfg_edge_event *event = (cfg_edge_event *)base_event;\n+\t    const cfg_superedge& cfg_superedge\n+\t      = event->get_cfg_superedge ();\n+\t    const supernode *dest = event->m_sedge->m_dest;\n+\t    /* Do we have an SSA_NAME defined via a phi node in\n+\t       the dest CFG node?  */\n+\t    if (var && TREE_CODE (var) == SSA_NAME)\n+\t      if (SSA_NAME_DEF_STMT (var)->bb == dest->m_bb)\n+\t\t{\n+\t\t  if (gphi *phi\n+\t\t      = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (var)))\n+\t\t    {\n+\t\t      /* Update var based on its phi node.  */\n+\t\t      tree old_var = var;\n+\t\t      var = cfg_superedge.get_phi_arg (phi);\n+\t\t      log (\"updating from %qE to %qE based on phi node\",\n+\t\t\t   old_var, var);\n+\t\t      if (get_logger ())\n+\t\t\t{\n+\t\t\t  pretty_printer pp;\n+\t\t\t  pp_gimple_stmt_1 (&pp, phi, 0, (dump_flags_t)0);\n+\t\t\t  log (\"  phi: %s\", pp_formatted_text (&pp));\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t    /* TODO: is this edge significant to var?\n+\t       See if var can be in other states in the dest, but not\n+\t       in other states in the src?\n+\t       Must have multiple sibling edges.  */\n+\n+\t    if (event->should_filter_p (m_verbosity))\n+\t      {\n+\t\tlog (\"filtering event %i: CFG edge\", idx);\n+\t\tpath->delete_event (idx);\n+\t\t/* Also delete the corresponding EK_END_CFG_EDGE.  */\n+\t\tgcc_assert (path->m_events[idx]->m_kind == EK_END_CFG_EDGE);\n+\t\tpath->delete_event (idx);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EK_END_CFG_EDGE:\n+\t  /* These come in pairs with EK_START_CFG_EDGE events and are\n+\t     filtered when their start event is filtered.  */\n+\t  break;\n+\n+\tcase EK_CALL_EDGE:\n+\t  {\n+\t    call_event *event = (call_event *)base_event;\n+\t    const callgraph_superedge& cg_superedge\n+\t      = event->get_callgraph_superedge ();\n+\t    callsite_expr expr;\n+\t    tree caller_var\n+\t      = cg_superedge.map_expr_from_callee_to_caller (var, &expr);\n+\t    if (caller_var)\n+\t      {\n+\t\tlog (\"event %i:\"\n+\t\t     \" switching var of interest\"\n+\t\t     \" from %qE in callee to %qE in caller\",\n+\t\t     idx, var, caller_var);\n+\t\tvar = caller_var;\n+\t\tif (expr.param_p ())\n+\t\t  event->record_critical_state (var, state);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EK_RETURN_EDGE:\n+\t  // TODO: potentially update var/state based on return value,\n+\t  // args etc\n+\t  {\n+\t    if (var)\n+\t      {\n+\t\treturn_event *event = (return_event *)base_event;\n+\t\tconst callgraph_superedge& cg_superedge\n+\t\t  = event->get_callgraph_superedge ();\n+\t\tcallsite_expr expr;\n+\t\ttree callee_var\n+\t\t  = cg_superedge.map_expr_from_caller_to_callee (var, &expr);\n+\t\tif (callee_var)\n+\t\t  {\n+\t\t    log (\"event %i:\"\n+\t\t\t \" switching var of interest\"\n+\t\t\t \" from %qE in caller to %qE in callee\",\n+\t\t\t idx, var, callee_var);\n+\t\t    var = callee_var;\n+\t\t    if (expr.return_value_p ())\n+\t\t      event->record_critical_state (var, state);\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase EK_SETJMP:\n+\t  /* TODO: only show setjmp_events that matter i.e. those for which\n+\t     there is a later rewind event using them.  */\n+\tcase EK_REWIND_FROM_LONGJMP:\n+\tcase EK_REWIND_TO_SETJMP:\n+\t  break;\n+\n+\tcase EK_WARNING:\n+\t  /* Always show the final \"warning\" event in the path.  */\n+\t  break;\n+\t}\n+      idx--;\n+    }\n+}\n+\n+/* Second pass of diagnostic_manager::prune_path: remove redundant\n+   interprocedural information.\n+\n+   For example, given:\n+     (1)- calling \"f2\" from \"f1\"\n+     (2)--- entry to \"f2\"\n+     (3)--- calling \"f3\" from \"f2\"\n+     (4)----- entry to \"f3\"\n+     (5)--- returning to \"f2\" to \"f3\"\n+     (6)- returning to \"f1\" to \"f2\"\n+   with no other intervening events, then none of these events are\n+   likely to be interesting to the user.\n+\n+   Prune [..., call, function-entry, return, ...] triples repeatedly\n+   until nothing has changed.  For the example above, this would\n+   remove events (3, 4, 5), and then remove events (1, 2, 6).  */\n+\n+void\n+diagnostic_manager::prune_interproc_events (checker_path *path) const\n+{\n+  bool changed = false;\n+  do\n+    {\n+      changed = false;\n+      int idx = path->m_events.length () - 1;\n+      while (idx >= 0)\n+\t{\n+\t  /* Prune [..., call, function-entry, return, ...] triples.  */\n+\t  if (idx + 2 < (signed)path->m_events.length ()\n+\t      && path->m_events[idx]->is_call_p ()\n+\t      && path->m_events[idx + 1]->is_function_entry_p ()\n+\t      && path->m_events[idx + 2]->is_return_p ())\n+\t    {\n+\t      if (get_logger ())\n+\t\t{\n+\t\t  label_text desc (path->m_events[idx]->get_desc (false));\n+\t\t  log (\"filtering events %i-%i:\"\n+\t\t       \" irrelevant call/entry/return: %s\",\n+\t\t       idx, idx + 2, desc.m_buffer);\n+\t\t  desc.maybe_free ();\n+\t\t}\n+\t      path->delete_event (idx + 2);\n+\t      path->delete_event (idx + 1);\n+\t      path->delete_event (idx);\n+\t      changed = true;\n+\t      idx--;\n+\t      continue;\n+\t    }\n+\n+\t  /* Prune [..., call, return, ...] pairs\n+\t     (for -fanalyzer-verbosity=0).  */\n+\t  if (idx + 1 < (signed)path->m_events.length ()\n+\t      && path->m_events[idx]->is_call_p ()\n+\t      && path->m_events[idx + 1]->is_return_p ())\n+\t    {\n+\t      if (get_logger ())\n+\t\t{\n+\t\t  label_text desc (path->m_events[idx]->get_desc (false));\n+\t\t  log (\"filtering events %i-%i:\"\n+\t\t       \" irrelevant call/return: %s\",\n+\t\t       idx, idx + 1, desc.m_buffer);\n+\t\t  desc.maybe_free ();\n+\t\t}\n+\t      path->delete_event (idx + 1);\n+\t      path->delete_event (idx);\n+\t      changed = true;\n+\t      idx--;\n+\t      continue;\n+\t    }\n+\n+\t  idx--;\n+\t}\n+\n+    }\n+  while (changed);\n+}\n+\n+/* Final pass of diagnostic_manager::prune_path.\n+\n+   If all we're left with is in one function, then filter function entry\n+   events.  */\n+\n+void\n+diagnostic_manager::finish_pruning (checker_path *path) const\n+{\n+  if (!path->interprocedural_p ())\n+    {\n+      int idx = path->m_events.length () - 1;\n+      while (idx >= 0 && idx < (signed)path->m_events.length ())\n+\t{\n+\t  checker_event *base_event = path->m_events[idx];\n+\t  if (base_event->m_kind == EK_FUNCTION_ENTRY)\n+\t    {\n+\t      log (\"filtering event %i:\"\n+\t\t   \" function entry for purely intraprocedural path\", idx);\n+\t      path->delete_event (idx);\n+\t    }\n+\t  idx--;\n+\t}\n+    }\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "aa939430348fe628af8cdcf28a88509c9ccae0bd", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,135 @@\n+/* Classes for saving, deduplicating, and emitting analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_DIAGNOSTIC_MANAGER_H\n+#define GCC_ANALYZER_DIAGNOSTIC_MANAGER_H\n+\n+/* A to-be-emitted diagnostic stored within diagnostic_manager.  */\n+\n+class saved_diagnostic\n+{\n+public:\n+  saved_diagnostic (const state_machine *sm,\n+\t\t    const exploded_node *enode,\n+\t\t    const supernode *snode, const gimple *stmt,\n+\t\t    stmt_finder *stmt_finder,\n+\t\t    tree var, state_machine::state_t state,\n+\t\t    pending_diagnostic *d);\n+  ~saved_diagnostic ();\n+\n+  bool operator== (const saved_diagnostic &other) const\n+  {\n+    return (m_sm == other.m_sm\n+\t    /* We don't compare m_enode.  */\n+\t    && m_snode == other.m_snode\n+\t    && m_stmt == other.m_stmt\n+\t    /* We don't compare m_stmt_finder.  */\n+\t    && m_var == other.m_var\n+\t    && m_state == other.m_state\n+\t    && m_d->equal_p (*other.m_d)\n+\t    && m_trailing_eedge == other.m_trailing_eedge);\n+  }\n+\n+  //private:\n+  const state_machine *m_sm;\n+  const exploded_node *m_enode;\n+  const supernode *m_snode;\n+  const gimple *m_stmt;\n+  stmt_finder *m_stmt_finder;\n+  tree m_var;\n+  state_machine::state_t m_state;\n+  pending_diagnostic *m_d;\n+  exploded_edge *m_trailing_eedge;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (saved_diagnostic);\n+};\n+\n+/* A class with responsibility for saving pending diagnostics, so that\n+   they can be emitted after the exploded_graph is complete.\n+   This lets us de-duplicate diagnostics, and find the shortest path\n+   for each similar diagnostic, potentially using edges that might\n+   not have been found when each diagnostic was first saved.\n+\n+   This also lets us compute shortest_paths once, rather than\n+   per-diagnostic.  */\n+\n+class diagnostic_manager : public log_user\n+{\n+public:\n+  diagnostic_manager (logger *logger, int verbosity);\n+\n+  void add_diagnostic (const state_machine *sm,\n+\t\t       const exploded_node *enode,\n+\t\t       const supernode *snode, const gimple *stmt,\n+\t\t       stmt_finder *finder,\n+\t\t       tree var, state_machine::state_t state,\n+\t\t       pending_diagnostic *d);\n+\n+  void add_diagnostic (const exploded_node *enode,\n+\t\t       const supernode *snode, const gimple *stmt,\n+\t\t       stmt_finder *finder,\n+\t\t       pending_diagnostic *d);\n+\n+  void emit_saved_diagnostics (const exploded_graph &eg);\n+\n+  void emit_saved_diagnostic (const exploded_graph &eg,\n+\t\t\t      const saved_diagnostic &sd,\n+\t\t\t      const exploded_path &epath,\n+\t\t\t      const gimple *stmt,\n+\t\t\t      int num_dupes);\n+\n+  unsigned get_num_diagnostics () const\n+  {\n+    return m_saved_diagnostics.length ();\n+  }\n+  saved_diagnostic *get_saved_diagnostic (unsigned idx)\n+  {\n+    return m_saved_diagnostics[idx];\n+  }\n+\n+private:\n+  void build_emission_path (const exploded_graph &eg,\n+\t\t\t    const exploded_path &epath,\n+\t\t\t    checker_path *emission_path) const;\n+\n+  void add_events_for_eedge (const exploded_edge &eedge,\n+\t\t\t     const extrinsic_state &ext_state,\n+\t\t\t     checker_path *emission_path) const;\n+\n+  void add_events_for_superedge (const exploded_edge &eedge,\n+\t\t\t\t checker_path *emission_path) const;\n+\n+  void prune_path (checker_path *path,\n+\t\t   const state_machine *sm,\n+\t\t   tree var, state_machine::state_t state) const;\n+\n+  void prune_for_sm_diagnostic (checker_path *path,\n+\t\t\t\tconst state_machine *sm,\n+\t\t\t\ttree var,\n+\t\t\t\tstate_machine::state_t state) const;\n+  void prune_interproc_events (checker_path *path) const;\n+  void finish_pruning (checker_path *path) const;\n+\n+  auto_delete_vec<saved_diagnostic> m_saved_diagnostics;\n+  const int m_verbosity;\n+};\n+\n+#endif /* GCC_ANALYZER_DIAGNOSTIC_MANAGER_H */"}, {"sha": "720fa219d16016fc4262fad8c128a444c7d007d3", "filename": "gcc/analyzer/engine.cc", "status": "added", "additions": 3614, "deletions": 0, "changes": 3614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "bbad2e2fe04d482266bb3c91a656753c86ee057c", "filename": "gcc/analyzer/engine.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fengine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fengine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,26 @@\n+/* The analysis \"engine\".\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_ENGINE_H\n+#define GCC_ANALYZER_ENGINE_H\n+\n+extern void run_checkers ();\n+\n+#endif /* GCC_ANALYZER_ENGINE_H */"}, {"sha": "8c29e552cac169ffebc318ac60cb65922785743f", "filename": "gcc/analyzer/exploded-graph.h", "status": "added", "additions": 829, "deletions": 0, "changes": 829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,829 @@\n+/* Classes for managing a directed graph of <point, state> pairs.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_EXPLODED_GRAPH_H\n+#define GCC_ANALYZER_EXPLODED_GRAPH_H\n+\n+/* Concrete implementation of region_model_context, wiring it up to the\n+   rest of the analysis engine.  */\n+\n+class impl_region_model_context : public region_model_context\n+{\n+ public:\n+  impl_region_model_context (exploded_graph &eg,\n+\t\t\t     const exploded_node *enode_for_diag,\n+\n+\t\t\t     /* TODO: should we be getting the ECs from the\n+\t\t\t\told state, rather than the new?  */\n+\t\t\t     const program_state *old_state,\n+\t\t\t     program_state *new_state,\n+\t\t\t     state_change *change,\n+\n+\t\t\t     const gimple *stmt,\n+\t\t\t     stmt_finder *stmt_finder = NULL);\n+\n+  impl_region_model_context (program_state *state,\n+\t\t\t     state_change *change,\n+\t\t\t     const extrinsic_state &ext_state);\n+\n+  void warn (pending_diagnostic *d) FINAL OVERRIDE;\n+\n+  void remap_svalue_ids (const svalue_id_map &map) FINAL OVERRIDE;\n+\n+  int on_svalue_purge (svalue_id first_unused_sid,\n+\t\t       const svalue_id_map &map) FINAL OVERRIDE;\n+\n+  logger *get_logger () FINAL OVERRIDE\n+  {\n+    return m_logger.get_logger ();\n+  }\n+\n+  void on_state_leak (const state_machine &sm,\n+\t\t      int sm_idx,\n+\t\t      svalue_id sid,\n+\t\t      svalue_id first_unused_sid,\n+\t\t      const svalue_id_map &map,\n+\t\t      state_machine::state_t state);\n+\n+  void on_inherited_svalue (svalue_id parent_sid,\n+\t\t\t    svalue_id child_sid) FINAL OVERRIDE;\n+\n+  void on_cast (svalue_id src_sid,\n+\t\tsvalue_id dst_sid) FINAL OVERRIDE;\n+\n+  void on_condition (tree lhs, enum tree_code op, tree rhs) FINAL OVERRIDE;\n+\n+  exploded_graph *m_eg;\n+  log_user m_logger;\n+  const exploded_node *m_enode_for_diag;\n+  const program_state *m_old_state;\n+  program_state *m_new_state;\n+  state_change *m_change;\n+  const gimple *m_stmt;\n+  stmt_finder *m_stmt_finder;\n+  const extrinsic_state &m_ext_state;\n+};\n+\n+/* A <program_point, program_state> pair, used internally by\n+   exploded_node as its immutable data, and as a key for identifying\n+   exploded_nodes we've already seen in the graph.  */\n+\n+class point_and_state\n+{\n+public:\n+  point_and_state (const program_point &point,\n+\t\t   const program_state &state)\n+  : m_point (point),\n+    m_state (state),\n+    m_hash (m_point.hash () ^ m_state.hash ())\n+  {\n+  }\n+\n+  hashval_t hash () const\n+  {\n+    return m_hash;\n+  }\n+  bool operator== (const point_and_state &other) const\n+  {\n+    return m_point == other.m_point && m_state == other.m_state;\n+  }\n+\n+  const program_point &get_point () const { return m_point; }\n+  const program_state &get_state () const { return m_state; }\n+\n+  void set_state (const program_state &state)\n+  {\n+    m_state = state;\n+    m_hash = m_point.hash () ^ m_state.hash ();\n+  }\n+\n+  void validate (const extrinsic_state &ext_state) const;\n+\n+private:\n+  program_point m_point;\n+  program_state m_state;\n+  hashval_t m_hash;\n+};\n+\n+/* A traits class for exploded graphs and their nodes and edges.  */\n+\n+struct eg_traits\n+{\n+  typedef exploded_node node_t;\n+  typedef exploded_edge edge_t;\n+  typedef exploded_graph graph_t;\n+  struct dump_args_t\n+  {\n+    dump_args_t (const exploded_graph &eg) : m_eg (eg) {}\n+    const exploded_graph &m_eg;\n+  };\n+  typedef exploded_cluster cluster_t;\n+};\n+\n+/* An exploded_node is a unique, immutable <point, state> pair within the\n+   exploded_graph.\n+   Each exploded_node has a unique index within the graph\n+   (for ease of debugging).  */\n+\n+class exploded_node : public dnode<eg_traits>\n+{\n+ public:\n+  exploded_node (point_and_state ps,\n+\t\t int index)\n+  : m_ps (ps), m_index (index)\n+  {\n+    gcc_checking_assert (ps.get_state ().m_region_model->canonicalized_p ());\n+  }\n+\n+  hashval_t hash () const { return m_ps.hash (); }\n+\n+  void dump_dot (graphviz_out *gv, const dump_args_t &args)\n+    const FINAL OVERRIDE;\n+  void dump_dot_id (pretty_printer *pp) const;\n+\n+  void dump_to_pp (pretty_printer *pp, const extrinsic_state &ext_state) const;\n+  void dump (FILE *fp, const extrinsic_state &ext_state) const;\n+  void dump (const extrinsic_state &ext_state) const;\n+\n+  /* The result of on_stmt.  */\n+  struct on_stmt_flags\n+  {\n+    on_stmt_flags (bool sm_changes)\n+    : m_sm_changes (sm_changes),\n+      m_terminate_path (false)\n+    {}\n+\n+    static on_stmt_flags terminate_path ()\n+    {\n+      return on_stmt_flags (true, true);\n+    }\n+\n+    static on_stmt_flags state_change (bool any_sm_changes)\n+    {\n+      return on_stmt_flags (any_sm_changes, false);\n+    }\n+\n+    /* Did any sm-changes occur handling the stmt.  */\n+    bool m_sm_changes : 1;\n+\n+    /* Should we stop analyzing this path (on_stmt may have already\n+       added nodes/edges, e.g. when handling longjmp).  */\n+    bool m_terminate_path : 1;\n+\n+  private:\n+    on_stmt_flags (bool sm_changes,\n+\t\t   bool terminate_path)\n+    : m_sm_changes (sm_changes),\n+      m_terminate_path (terminate_path)\n+    {}\n+  };\n+\n+  on_stmt_flags on_stmt (exploded_graph &eg,\n+\t\t\t const supernode *snode,\n+\t\t\t const gimple *stmt,\n+\t\t\t program_state *state,\n+\t\t\t state_change *change) const;\n+  bool on_edge (exploded_graph &eg,\n+\t\tconst superedge *succ,\n+\t\tprogram_point *next_point,\n+\t\tprogram_state *next_state,\n+\t\tstate_change *change) const;\n+  void on_longjmp (exploded_graph &eg,\n+\t\t   const gcall *call,\n+\t\t   program_state *new_state,\n+\t\t   region_model_context *ctxt) const;\n+\n+  void detect_leaks (exploded_graph &eg) const;\n+\n+  const program_point &get_point () const { return m_ps.get_point (); }\n+  const supernode *get_supernode () const\n+  {\n+    return get_point ().get_supernode ();\n+  }\n+  function *get_function () const\n+  {\n+    return get_point ().get_function ();\n+  }\n+  int get_stack_depth () const\n+  {\n+    return get_point ().get_stack_depth ();\n+  }\n+  const gimple *get_stmt () const { return get_point ().get_stmt (); }\n+\n+  const program_state &get_state () const { return m_ps.get_state (); }\n+\n+  const point_and_state *get_ps_key () const { return &m_ps; }\n+  const program_point *get_point_key () const { return &m_ps.get_point (); }\n+\n+  void dump_succs_and_preds (FILE *outf) const;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (exploded_node);\n+\n+  const char * get_dot_fillcolor () const;\n+\n+  /* The <program_point, program_state> pair.  This is const, as it\n+     is immutable once the exploded_node has been created.  */\n+  const point_and_state m_ps;\n+\n+public:\n+  /* The index of this exploded_node.  */\n+  const int m_index;\n+};\n+\n+/* An edge within the exploded graph.\n+   Some exploded_edges have an underlying superedge; others don't.  */\n+\n+class exploded_edge : public dedge<eg_traits>\n+{\n+ public:\n+  /* Abstract base class for associating custom data with an\n+     exploded_edge, for handling non-standard edges such as\n+     rewinding from a longjmp, signal handlers, etc.  */\n+  class custom_info_t\n+  {\n+  public:\n+    virtual ~custom_info_t () {}\n+\n+    /* Hook for making .dot label more readable .  */\n+    virtual void print (pretty_printer *pp) = 0;\n+\n+    /* Hook for updating MODEL within exploded_path::feasible_p.  */\n+    virtual void update_model (region_model *model,\n+\t\t\t       const exploded_edge &eedge) = 0;\n+\n+    virtual void add_events_to_path (checker_path *emission_path,\n+\t\t\t\t     const exploded_edge &eedge) = 0;\n+  };\n+\n+  exploded_edge (exploded_node *src, exploded_node *dest,\n+\t\t const superedge *sedge,\n+\t\t const state_change &change,\n+\t\t custom_info_t *custom_info);\n+  ~exploded_edge ();\n+  void dump_dot (graphviz_out *gv, const dump_args_t &args)\n+    const FINAL OVERRIDE;\n+\n+  //private:\n+  const superedge *const m_sedge;\n+\n+  const state_change m_change;\n+\n+  /* NULL for most edges; will be non-NULL for special cases\n+     such as an unwind from a longjmp to a setjmp, or when\n+     a signal is delivered to a signal-handler.\n+\n+     Owned by this class.  */\n+  custom_info_t *m_custom_info;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (exploded_edge);\n+};\n+\n+/* Extra data for an exploded_edge that represents a rewind from a\n+   longjmp to a setjmp.  */\n+\n+class rewind_info_t : public exploded_edge::custom_info_t\n+{\n+public:\n+  rewind_info_t (const exploded_node *enode_origin)\n+  : m_enode_origin (enode_origin)\n+  {}\n+\n+  void print (pretty_printer *pp) FINAL OVERRIDE\n+  {\n+    pp_string (pp, \"rewind\");\n+  }\n+\n+  void update_model (region_model *model,\n+\t\t     const exploded_edge &eedge) FINAL OVERRIDE;\n+\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &eedge) FINAL OVERRIDE;\n+\n+  const program_point &get_setjmp_point () const\n+  {\n+    const program_point &origin_point = m_enode_origin->get_point ();\n+\n+    /* \"origin_point\" ought to be before the call to \"setjmp\".  */\n+    gcc_assert (origin_point.get_kind () == PK_BEFORE_STMT);\n+\n+    /* TODO: assert that it's the final stmt in its supernode.  */\n+\n+    return origin_point;\n+  }\n+\n+  const gcall *get_setjmp_call () const\n+  {\n+    return as_a <const gcall *> (get_setjmp_point ().get_stmt ());\n+  }\n+\n+  const exploded_node *get_enode_origin () const { return m_enode_origin; }\n+\n+private:\n+  const exploded_node *m_enode_origin;\n+};\n+\n+/* Statistics about aspects of an exploded_graph.  */\n+\n+struct stats\n+{\n+  stats (int num_supernodes);\n+  void log (logger *logger) const;\n+  void dump (FILE *out) const;\n+\n+  int m_num_nodes[NUM_POINT_KINDS];\n+  int m_node_reuse_count;\n+  int m_node_reuse_after_merge_count;\n+  int m_num_supernodes;\n+};\n+\n+/* Traits class for ensuring uniqueness of point_and_state data within\n+   an exploded_graph.  */\n+\n+struct eg_hash_map_traits\n+{\n+  typedef const point_and_state *key_type;\n+  typedef exploded_node *value_type;\n+  typedef exploded_node *compare_type;\n+\n+  static inline hashval_t hash (const key_type &k)\n+  {\n+    gcc_assert (k != NULL);\n+    gcc_assert (k != reinterpret_cast<key_type> (1));\n+    return k->hash ();\n+  }\n+  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+  {\n+    gcc_assert (k1 != NULL);\n+    gcc_assert (k2 != NULL);\n+    gcc_assert (k1 != reinterpret_cast<key_type> (1));\n+    gcc_assert (k2 != reinterpret_cast<key_type> (1));\n+    if (k1 && k2)\n+      return *k1 == *k2;\n+    else\n+      /* Otherwise they must both be non-NULL.  */\n+      return k1 == k2;\n+  }\n+  template <typename T>\n+  static inline void remove (T &)\n+  {\n+    /* empty; the nodes are handled elsewhere.  */\n+  }\n+  template <typename T>\n+  static inline void mark_deleted (T &entry)\n+  {\n+    entry.m_key = reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline void mark_empty (T &entry)\n+  {\n+    entry.m_key = NULL;\n+  }\n+  template <typename T>\n+  static inline bool is_deleted (const T &entry)\n+  {\n+    return entry.m_key == reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == NULL;\n+  }\n+  static const bool empty_zero_p = false;\n+};\n+\n+/* Per-program_point data for an exploded_graph.  */\n+\n+struct per_program_point_data\n+{\n+  per_program_point_data (const program_point &key)\n+  : m_key (key)\n+  {}\n+\n+  const program_point m_key;\n+  auto_vec<exploded_node *> m_enodes;\n+};\n+\n+/* Traits class for storing per-program_point data within\n+   an exploded_graph.  */\n+\n+struct eg_point_hash_map_traits\n+{\n+  typedef const program_point *key_type;\n+  typedef per_program_point_data *value_type;\n+  typedef per_program_point_data *compare_type;\n+\n+  static inline hashval_t hash (const key_type &k)\n+  {\n+    gcc_assert (k != NULL);\n+    gcc_assert (k != reinterpret_cast<key_type> (1));\n+    return k->hash ();\n+  }\n+  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+  {\n+    gcc_assert (k1 != NULL);\n+    gcc_assert (k2 != NULL);\n+    gcc_assert (k1 != reinterpret_cast<key_type> (1));\n+    gcc_assert (k2 != reinterpret_cast<key_type> (1));\n+    if (k1 && k2)\n+      return *k1 == *k2;\n+    else\n+      /* Otherwise they must both be non-NULL.  */\n+      return k1 == k2;\n+  }\n+  template <typename T>\n+  static inline void remove (T &)\n+  {\n+    /* empty; the nodes are handled elsewhere.  */\n+  }\n+  template <typename T>\n+  static inline void mark_deleted (T &entry)\n+  {\n+    entry.m_key = reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline void mark_empty (T &entry)\n+  {\n+    entry.m_key = NULL;\n+  }\n+  template <typename T>\n+  static inline bool is_deleted (const T &entry)\n+  {\n+    return entry.m_key == reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == NULL;\n+  }\n+  static const bool empty_zero_p = false;\n+};\n+\n+/* Data about a particular call_string within an exploded_graph.  */\n+\n+struct per_call_string_data\n+{\n+  per_call_string_data (const call_string &key, int num_supernodes)\n+  : m_key (key), m_stats (num_supernodes)\n+  {}\n+\n+  const call_string m_key;\n+  stats m_stats;\n+};\n+\n+/* Traits class for storing per-call_string data within\n+   an exploded_graph.  */\n+\n+struct eg_call_string_hash_map_traits\n+{\n+  typedef const call_string *key_type;\n+  typedef per_call_string_data *value_type;\n+  typedef per_call_string_data *compare_type;\n+\n+  static inline hashval_t hash (const key_type &k)\n+  {\n+    gcc_assert (k != NULL);\n+    gcc_assert (k != reinterpret_cast<key_type> (1));\n+    return k->hash ();\n+  }\n+  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+  {\n+    gcc_assert (k1 != NULL);\n+    gcc_assert (k2 != NULL);\n+    gcc_assert (k1 != reinterpret_cast<key_type> (1));\n+    gcc_assert (k2 != reinterpret_cast<key_type> (1));\n+    if (k1 && k2)\n+      return *k1 == *k2;\n+    else\n+      /* Otherwise they must both be non-NULL.  */\n+      return k1 == k2;\n+  }\n+  template <typename T>\n+  static inline void remove (T &)\n+  {\n+    /* empty; the nodes are handled elsewhere.  */\n+  }\n+  template <typename T>\n+  static inline void mark_deleted (T &entry)\n+  {\n+    entry.m_key = reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline void mark_empty (T &entry)\n+  {\n+    entry.m_key = NULL;\n+  }\n+  template <typename T>\n+  static inline bool is_deleted (const T &entry)\n+  {\n+    return entry.m_key == reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == NULL;\n+  }\n+  static const bool empty_zero_p = false;\n+};\n+\n+/* Data about a particular function within an exploded_graph.  */\n+\n+struct per_function_data\n+{\n+  per_function_data () {}\n+\n+  void add_call_summary (exploded_node *node)\n+  {\n+    m_summaries.safe_push (node);\n+  }\n+\n+  auto_vec<exploded_node *> m_summaries;\n+};\n+\n+\n+/* The strongly connected components of a supergraph.\n+   In particular, this allows us to compute a partial ordering\n+   of supernodes.  */\n+\n+class strongly_connected_components\n+{\n+public:\n+  strongly_connected_components (const supergraph &sg, logger *logger);\n+\n+  int get_scc_id (int node_index) const\n+  {\n+    return m_per_node[node_index].m_lowlink;\n+  }\n+\n+  void dump () const;\n+\n+private:\n+  struct per_node_data\n+  {\n+    per_node_data ()\n+      : m_index (-1), m_lowlink (-1), m_on_stack (false)\n+    {}\n+\n+    int m_index;\n+    int m_lowlink;\n+    bool m_on_stack;\n+  };\n+\n+  void strong_connect (unsigned index);\n+\n+  const supergraph &m_sg;\n+  auto_vec<unsigned> m_stack;\n+  auto_vec<per_node_data> m_per_node;\n+};\n+\n+/* The worklist of exploded_node instances that have been added to\n+   an exploded_graph, but that haven't yet been processed to find\n+   their successors (or warnings).\n+\n+   The enodes are stored in a priority queue, ordered by a topological\n+   sort of the SCCs in the supergraph, so that enodes for the same\n+   program_point should appear at the front of the queue together.\n+   This allows for state-merging at CFG join-points, so that\n+   sufficiently-similar enodes can be merged into one.  */\n+\n+class worklist\n+{\n+public:\n+  worklist (const exploded_graph &eg, const analysis_plan &plan);\n+  unsigned length () const;\n+  exploded_node *take_next ();\n+  exploded_node *peek_next ();\n+  void add_node (exploded_node *enode);\n+\n+private:\n+  class key_t\n+  {\n+  public:\n+    key_t (const worklist &w, exploded_node *enode)\n+    : m_worklist (w), m_enode (enode)\n+    {}\n+\n+    bool operator< (const key_t &other) const\n+    {\n+      return cmp (*this, other) < 0;\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      return cmp (*this, other) == 0;\n+    }\n+\n+    bool operator> (const key_t &other) const\n+    {\n+      return !(*this == other || *this < other);\n+    }\n+\n+  private:\n+    static int cmp_1 (const key_t &ka, const key_t &kb);\n+    static int cmp (const key_t &ka, const key_t &kb);\n+\n+    int get_scc_id (const exploded_node *enode) const\n+    {\n+      const supernode *snode = enode->get_supernode ();\n+      if (snode == NULL)\n+\treturn 0;\n+      return m_worklist.m_scc.get_scc_id (snode->m_index);\n+    }\n+\n+    const worklist &m_worklist;\n+    exploded_node *m_enode;\n+  };\n+\n+  /* The order is important here: m_scc needs to stick around\n+     until after m_queue has finished being cleaned up (the dtor\n+     calls the ordering fns).  */\n+  const exploded_graph &m_eg;\n+  strongly_connected_components m_scc;\n+  const analysis_plan &m_plan;\n+\n+  /* Priority queue, backed by a fibonacci_heap.  */\n+  typedef fibonacci_heap<key_t, exploded_node> queue_t;\n+  queue_t m_queue;\n+};\n+\n+/* An exploded_graph is a directed graph of unique <point, state> pairs.\n+   It also has a worklist of nodes that are waiting for their successors\n+   to be added to the graph.  */\n+\n+class exploded_graph : public digraph<eg_traits>\n+{\n+public:\n+  typedef hash_map <const call_string *, per_call_string_data *,\n+\t\t    eg_call_string_hash_map_traits> call_string_data_map_t;\n+\n+  exploded_graph (const supergraph &sg, logger *logger,\n+\t\t  const extrinsic_state &ext_state,\n+\t\t  const state_purge_map *purge_map,\n+\t\t  const analysis_plan &plan,\n+\t\t  int verbosity);\n+  ~exploded_graph ();\n+\n+  logger *get_logger () const { return m_logger.get_logger (); }\n+\n+  const supergraph &get_supergraph () const { return m_sg; }\n+  const extrinsic_state &get_ext_state () const { return m_ext_state; }\n+  const state_purge_map *get_purge_map () const { return m_purge_map; }\n+  const analysis_plan &get_analysis_plan () const { return m_plan; }\n+\n+  exploded_node *get_origin () const { return m_origin; }\n+\n+  exploded_node *add_function_entry (function *fun);\n+\n+  void build_initial_worklist ();\n+  void process_worklist ();\n+  void process_node (exploded_node *node);\n+\n+  exploded_node *get_or_create_node (const program_point &point,\n+\t\t\t\t     const program_state &state,\n+\t\t\t\t     state_change *change);\n+  exploded_edge *add_edge (exploded_node *src, exploded_node *dest,\n+\t\t\t   const superedge *sedge,\n+\t\t\t   const state_change &change,\n+\t\t\t   exploded_edge::custom_info_t *custom = NULL);\n+\n+  per_program_point_data *\n+  get_or_create_per_program_point_data (const program_point &);\n+\n+  per_call_string_data *\n+  get_or_create_per_call_string_data (const call_string &);\n+\n+  per_function_data *\n+  get_or_create_per_function_data (function *);\n+  per_function_data *get_per_function_data (function *) const;\n+\n+  void save_diagnostic (const state_machine &sm,\n+\t\t\tconst exploded_node *enode,\n+\t\t\tconst supernode *node, const gimple *stmt,\n+\t\t\tstmt_finder *finder,\n+\t\t\ttree var, state_machine::state_t state,\n+\t\t\tpending_diagnostic *d);\n+\n+  diagnostic_manager &get_diagnostic_manager ()\n+  {\n+    return m_diagnostic_manager;\n+  }\n+\n+  stats *get_global_stats () { return &m_global_stats; }\n+  stats *get_or_create_function_stats (function *fn);\n+  void log_stats () const;\n+  void dump_stats (FILE *) const;\n+  void dump_states_for_supernode (FILE *, const supernode *snode) const;\n+  void dump_exploded_nodes () const;\n+\n+  const call_string_data_map_t *get_per_call_string_data () const\n+  { return &m_per_call_string_data; }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (exploded_graph);\n+\n+  const supergraph &m_sg;\n+\n+  log_user m_logger;\n+\n+  /* Map from point/state to exploded node.\n+     To avoid duplication we store point_and_state\n+     *pointers* as keys, rather than point_and_state, using the\n+     instance from within the exploded_node, with a custom hasher.  */\n+  typedef hash_map <const point_and_state *, exploded_node *,\n+\t\t    eg_hash_map_traits> map_t;\n+  map_t m_point_and_state_to_node;\n+\n+  /* Map from program_point to per-program_point data.  */\n+  typedef hash_map <const program_point *, per_program_point_data *,\n+\t\t    eg_point_hash_map_traits> point_map_t;\n+  point_map_t m_per_point_data;\n+\n+  worklist m_worklist;\n+\n+  exploded_node *m_origin;\n+\n+  const extrinsic_state &m_ext_state;\n+\n+  const state_purge_map *const m_purge_map;\n+\n+  const analysis_plan &m_plan;\n+\n+  typedef hash_map<function *, per_function_data *> per_function_data_t;\n+  per_function_data_t m_per_function_data;\n+\n+  diagnostic_manager m_diagnostic_manager;\n+\n+  /* Stats.  */\n+  stats m_global_stats;\n+  typedef ordered_hash_map<function *, stats *> function_stat_map_t;\n+  function_stat_map_t m_per_function_stats;\n+  stats m_functionless_stats;\n+\n+  call_string_data_map_t m_per_call_string_data;\n+\n+  auto_vec<int> m_PK_AFTER_SUPERNODE_per_snode;\n+};\n+\n+/* A path within an exploded_graph: a sequence of edges.  */\n+\n+class exploded_path\n+{\n+public:\n+  exploded_path () : m_edges () {}\n+  exploded_path (const exploded_path &other);\n+  exploded_path & operator= (const exploded_path &other);\n+\n+  unsigned length () const { return m_edges.length (); }\n+\n+  bool find_stmt_backwards (const gimple *search_stmt,\n+\t\t\t    int *out_idx) const;\n+\n+  exploded_node *get_final_enode () const;\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump (FILE *fp) const;\n+  void dump () const;\n+\n+  bool feasible_p (logger *logger) const;\n+\n+  auto_vec<const exploded_edge *> m_edges;\n+};\n+\n+/* Finding the shortest exploded_path within an exploded_graph.  */\n+\n+typedef shortest_paths<eg_traits, exploded_path> shortest_exploded_paths;\n+\n+/* Abstract base class for use when passing NULL as the stmt for\n+   a possible warning, allowing the choice of stmt to be deferred\n+   until after we have an emission path (and know we're emitting a\n+   warning).  */\n+\n+class stmt_finder\n+{\n+public:\n+  virtual ~stmt_finder () {}\n+  virtual stmt_finder *clone () const = 0;\n+  virtual const gimple *find_stmt (const exploded_path &epath) = 0;\n+};\n+\n+// TODO: split the above up?\n+\n+#endif /* GCC_ANALYZER_EXPLODED_GRAPH_H */"}, {"sha": "f6c48837a59bf974c032d3bae910d9af50f5e7c6", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,70 @@\n+/* Classes for analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Generate a label_text by printing FMT.\n+\n+   Use a clone of the global_dc for formatting callbacks.\n+\n+   Use this evdesc::event_desc's m_colorize flag to control colorization\n+   (so that e.g. we can disable it for JSON output).  */\n+\n+label_text\n+evdesc::event_desc::formatted_print (const char *fmt, ...) const\n+{\n+  pretty_printer *pp = global_dc->printer->clone ();\n+\n+  pp_show_color (pp) = m_colorize;\n+\n+  text_info ti;\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n+  va_list ap;\n+  va_start (ap, fmt);\n+  ti.format_spec = _(fmt);\n+  ti.args_ptr = &ap;\n+  ti.err_no = 0;\n+  ti.x_data = NULL;\n+  ti.m_richloc = &rich_loc;\n+  pp_format (pp, &ti);\n+  pp_output_formatted_text (pp);\n+  va_end (ap);\n+\n+  label_text result = label_text::take (xstrdup (pp_formatted_text (pp)));\n+  delete pp;\n+  return result;\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "bb03e752530d5ac04cbfb0addfb3127fccbc8a39", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,266 @@\n+/* Classes for analyzer diagnostics.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_PENDING_DIAGNOSTIC_H\n+#define GCC_ANALYZER_PENDING_DIAGNOSTIC_H\n+\n+/* Various bundles of information used for generating more precise\n+   messages for events within a diagnostic_path, for passing to the\n+   various \"describe_*\" vfuncs of pending_diagnostic.  See those\n+   for more information.  */\n+\n+namespace evdesc {\n+\n+struct event_desc\n+{\n+  event_desc (bool colorize) : m_colorize (colorize) {}\n+\n+  label_text formatted_print (const char *fmt, ...) const\n+    ATTRIBUTE_GCC_DIAG(2,3);\n+\n+  bool m_colorize;\n+};\n+\n+/* For use by pending_diagnostic::describe_state_change.  */\n+\n+struct state_change : public event_desc\n+{\n+  state_change (bool colorize,\n+\t\ttree expr,\n+\t\ttree origin,\n+\t\tstate_machine::state_t old_state,\n+\t\tstate_machine::state_t new_state,\n+\t\tdiagnostic_event_id_t event_id,\n+\t\tconst state_change_event &event)\n+  : event_desc (colorize),\n+    m_expr (expr), m_origin (origin),\n+    m_old_state (old_state), m_new_state (new_state),\n+    m_event_id (event_id), m_event (event)\n+  {}\n+\n+  bool is_global_p () const { return m_expr == NULL_TREE; }\n+\n+  tree m_expr;\n+  tree m_origin;\n+  state_machine::state_t m_old_state;\n+  state_machine::state_t m_new_state;\n+  diagnostic_event_id_t m_event_id;\n+  const state_change_event &m_event;\n+};\n+\n+/* For use by pending_diagnostic::describe_call_with_state.  */\n+\n+struct call_with_state : public event_desc\n+{\n+  call_with_state (bool colorize,\n+\t\t   tree caller_fndecl, tree callee_fndecl,\n+\t\t   tree expr, state_machine::state_t state)\n+  : event_desc (colorize),\n+    m_caller_fndecl (caller_fndecl),\n+    m_callee_fndecl (callee_fndecl),\n+    m_expr (expr),\n+    m_state (state)\n+  {\n+  }\n+\n+  tree m_caller_fndecl;\n+  tree m_callee_fndecl;\n+  tree m_expr;\n+  state_machine::state_t m_state;\n+};\n+\n+/* For use by pending_diagnostic::describe_return_of_state.  */\n+\n+struct return_of_state : public event_desc\n+{\n+  return_of_state (bool colorize,\n+\t\t   tree caller_fndecl, tree callee_fndecl,\n+\t\t   state_machine::state_t state)\n+  : event_desc (colorize),\n+    m_caller_fndecl (caller_fndecl),\n+    m_callee_fndecl (callee_fndecl),\n+    m_state (state)\n+  {\n+  }\n+\n+  tree m_caller_fndecl;\n+  tree m_callee_fndecl;\n+  state_machine::state_t m_state;\n+};\n+\n+/* For use by pending_diagnostic::describe_final_event.  */\n+\n+struct final_event : public event_desc\n+{\n+  final_event (bool colorize,\n+\t       tree expr, state_machine::state_t state)\n+  : event_desc (colorize),\n+    m_expr (expr), m_state (state)\n+  {}\n+\n+  tree m_expr;\n+  state_machine::state_t m_state;\n+};\n+\n+} /* end of namespace evdesc */\n+\n+/* An abstract base class for capturing information about a diagnostic in\n+   a form that is ready to emit at a later point (or be rejected).\n+   Each kind of diagnostic will have a concrete subclass of\n+   pending_diagnostic.\n+\n+   Normally, gcc diagnostics are emitted using va_list, which can't be\n+   portably stored for later use, so we have to use an \"emit\" virtual\n+   function.\n+\n+   This class also supports comparison, so that multiple pending_diagnostic\n+   instances can be de-duplicated.\n+\n+   As well as emitting a diagnostic, the class has various \"precision of\n+   wording\" virtual functions, for generating descriptions for events\n+   within a diagnostic_path.  These are optional, but implementing these\n+   allows for more precise wordings than the more generic\n+   implementation.  */\n+\n+class pending_diagnostic\n+{\n+ public:\n+  virtual ~pending_diagnostic () {}\n+\n+  /* Vfunc for emitting the diagnostic.  The rich_location will have been\n+     populated with a diagnostic_path.\n+     Return true if a diagnostic is actually emitted.  */\n+  virtual bool emit (rich_location *) = 0;\n+\n+  /* Hand-coded RTTI: get an ID for the subclass.  */\n+  virtual const char *get_kind () const = 0;\n+\n+  /* Compare for equality with OTHER, which might be of a different\n+     subclass.  */\n+\n+  bool equal_p (const pending_diagnostic &other)\n+  {\n+    /* Check for pointer equality on the IDs from get_kind.  */\n+    if (get_kind () != other.get_kind ())\n+      return false;\n+    /* Call vfunc now we know they have the same ID: */\n+    return subclass_equal_p (other);\n+  }\n+\n+  /* A vfunc for testing for equality, where we've already\n+     checked they have the same ID.  See pending_diagnostic_subclass\n+     below for a convenience subclass for implementing this.  */\n+  virtual bool subclass_equal_p (const pending_diagnostic &other) const = 0;\n+\n+  /* For greatest precision-of-wording, the various following \"describe_*\"\n+     virtual functions give the pending diagnostic a way to describe events\n+     in a diagnostic_path in terms that make sense for that diagnostic.\n+\n+     In each case, return a non-NULL label_text to give the event a custom\n+     description; NULL otherwise (falling back on a more generic\n+     description).  */\n+\n+  /* Precision-of-wording vfunc for describing a critical state change\n+     within the diagnostic_path.\n+\n+     For example, a double-free diagnostic might use the descriptions:\n+     - \"first 'free' happens here\"\n+     - \"second 'free' happens here\"\n+     for the pertinent events, whereas a use-after-free might use the\n+     descriptions:\n+     - \"freed here\"\n+     - \"use after free here\"\n+     Note how in both cases the first event is a \"free\": the best\n+     description to use depends on the diagnostic.  */\n+\n+  virtual label_text describe_state_change (const evdesc::state_change &)\n+  {\n+    /* Default no-op implementation.  */\n+    return label_text ();\n+  }\n+\n+  /* Precision-of-wording vfunc for describing an interprocedural call\n+     carrying critial state for the diagnostic, from caller to callee.\n+\n+     For example a double-free diagnostic might use:\n+     - \"passing freed pointer 'ptr' in call to 'deallocator' from 'test'\"\n+     to make it clearer how the freed value moves from caller to\n+     callee.  */\n+\n+  virtual label_text describe_call_with_state (const evdesc::call_with_state &)\n+  {\n+    /* Default no-op implementation.  */\n+    return label_text ();\n+  }\n+\n+  /* Precision-of-wording vfunc for describing an interprocedural return\n+     within the diagnostic_path that carries critial state for the\n+     diagnostic, from callee back to caller.\n+\n+     For example, a deref-of-unchecked-malloc diagnostic might use:\n+     - \"returning possibly-NULL pointer to 'make_obj' from 'allocator'\"\n+     to make it clearer how the unchecked value moves from callee\n+     back to caller.  */\n+\n+  virtual label_text describe_return_of_state (const evdesc::return_of_state &)\n+  {\n+    /* Default no-op implementation.  */\n+    return label_text ();\n+  }\n+\n+  /* Precision-of-wording vfunc for describing the final event within a\n+     diagnostic_path.\n+\n+     For example a double-free diagnostic might use:\n+      - \"second 'free' here; first 'free' was at (3)\"\n+     and a use-after-free might use\n+      - \"use after 'free' here; memory was freed at (2)\".  */\n+\n+  virtual label_text describe_final_event (const evdesc::final_event &)\n+  {\n+    /* Default no-op implementation.  */\n+    return label_text ();\n+  }\n+\n+  /* End of precision-of-wording vfuncs.  */\n+};\n+\n+/* A template to make it easier to make subclasses of pending_diagnostic.\n+\n+   This uses the curiously-recurring template pattern, to implement\n+   pending_diagnostic::subclass_equal_p by casting and calling\n+   the operator==\n+\n+   This assumes that BASE_OTHER has already been checked to have\n+   been of the same subclass (which pending_diagnostic::equal_p does).  */\n+\n+template <class Subclass>\n+class pending_diagnostic_subclass : public pending_diagnostic\n+{\n+ public:\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const\n+    FINAL OVERRIDE\n+  {\n+    const Subclass &other = (const Subclass &)base_other;\n+    return *(const Subclass*)this == other;\n+  }\n+};\n+\n+#endif /* GCC_ANALYZER_PENDING_DIAGNOSTIC_H */"}, {"sha": "e85f1ba49f096cef91a3e9a2073291e79ebe94b6", "filename": "gcc/analyzer/program-point.cc", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,554 @@\n+/* Classes for representing locations within the program.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"function.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/analysis-plan.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Get a string for PK.  */\n+\n+const char *\n+point_kind_to_string (enum point_kind pk)\n+{\n+  switch (pk)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case PK_ORIGIN:\n+      return \"PK_ORIGIN\";\n+    case PK_BEFORE_SUPERNODE:\n+      return \"PK_BEFORE_SUPERNODE\";\n+    case PK_BEFORE_STMT:\n+      return \"PK_BEFORE_STMT\";\n+    case PK_AFTER_SUPERNODE:\n+      return \"PK_AFTER_SUPERNODE\";\n+    case PK_EMPTY:\n+      return \"PK_EMPTY\";\n+    case PK_DELETED:\n+      return \"PK_DELETED\";\n+    }\n+}\n+\n+/* class function_point.  */\n+\n+/* Print this function_point to PP.  */\n+\n+void\n+function_point::print (pretty_printer *pp, const format &f) const\n+{\n+  switch (get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case PK_ORIGIN:\n+      pp_printf (pp, \"origin\");\n+      break;\n+\n+    case PK_BEFORE_SUPERNODE:\n+      {\n+\tif (m_from_edge)\n+\t  pp_printf (pp, \"before SN: %i (from SN: %i)\",\n+\t\t     m_supernode->m_index, m_from_edge->m_src->m_index);\n+\telse\n+\t  pp_printf (pp, \"before SN: %i (NULL from-edge)\",\n+\t\t     m_supernode->m_index);\n+\tf.spacer (pp);\n+\tfor (gphi_iterator gpi\n+\t       = const_cast<supernode *>(get_supernode ())->start_phis ();\n+\t     !gsi_end_p (gpi); gsi_next (&gpi))\n+\t  {\n+\t    const gphi *phi = gpi.phi ();\n+\t    pp_gimple_stmt_1 (pp, phi, 0, (dump_flags_t)0);\n+\t  }\n+      }\n+      break;\n+\n+    case PK_BEFORE_STMT:\n+      pp_printf (pp, \"before (SN: %i stmt: %i): \", m_supernode->m_index,\n+\t\t m_stmt_idx);\n+      f.spacer (pp);\n+      pp_gimple_stmt_1 (pp, get_stmt (), 0, (dump_flags_t)0);\n+      if (f.m_newlines)\n+\t{\n+\t  pp_newline (pp);\n+\t  print_source_line (pp);\n+\t}\n+      break;\n+\n+    case PK_AFTER_SUPERNODE:\n+      pp_printf (pp, \"after SN: %i\", m_supernode->m_index);\n+      break;\n+    }\n+}\n+\n+/* Generate a hash value for this function_point.  */\n+\n+hashval_t\n+function_point::hash () const\n+{\n+  inchash::hash hstate;\n+  if (m_supernode)\n+    hstate.add_int (m_supernode->m_index);\n+  hstate.add_ptr (m_from_edge);\n+  hstate.add_int (m_stmt_idx);\n+  hstate.add_int (m_kind);\n+  return hstate.end ();\n+}\n+\n+/* Get the gimple stmt for this function_point, if any.  */\n+\n+const gimple *\n+function_point::get_stmt () const\n+{\n+  if (m_kind == PK_BEFORE_STMT)\n+    return m_supernode->m_stmts[m_stmt_idx];\n+  else if (m_kind == PK_AFTER_SUPERNODE)\n+    return m_supernode->get_last_stmt ();\n+  else\n+    return NULL;\n+}\n+\n+/* Get a location for this function_point, if any.  */\n+\n+location_t\n+function_point::get_location () const\n+{\n+  const gimple *stmt = get_stmt ();\n+  if (stmt)\n+    return stmt->location;\n+\n+  return UNKNOWN_LOCATION;\n+}\n+\n+/* A subclass of diagnostic_context for use by\n+   program_point::print_source_line.  */\n+\n+class debug_diagnostic_context : public diagnostic_context\n+{\n+public:\n+  debug_diagnostic_context ()\n+  {\n+    diagnostic_initialize (this, 0);\n+    show_line_numbers_p = true;\n+    show_caret = true;\n+  }\n+  ~debug_diagnostic_context ()\n+  {\n+    diagnostic_finish (this);\n+  }\n+};\n+\n+/* Print the source line (if any) for this function_point to PP.  */\n+\n+void\n+function_point::print_source_line (pretty_printer *pp) const\n+{\n+  const gimple *stmt = get_stmt ();\n+  if (!stmt)\n+    return;\n+  // TODO: monospace font\n+  debug_diagnostic_context tmp_dc;\n+  gcc_rich_location richloc (stmt->location);\n+  diagnostic_show_locus (&tmp_dc, &richloc, DK_ERROR);\n+  pp_string (pp, pp_formatted_text (tmp_dc.printer));\n+}\n+\n+/* class program_point.  */\n+\n+/* Print this program_point to PP.  */\n+\n+void\n+program_point::print (pretty_printer *pp, const format &f) const\n+{\n+  pp_string (pp, \"callstring: \");\n+  m_call_string.print (pp);\n+  f.spacer (pp);\n+\n+  m_function_point.print (pp, f);\n+}\n+\n+/* Dump this point to stderr.  */\n+\n+DEBUG_FUNCTION void\n+program_point::dump () const\n+{\n+  pretty_printer pp;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  print (&pp, format (true));\n+  pp_flush (&pp);\n+}\n+\n+/* Generate a hash value for this program_point.  */\n+\n+hashval_t\n+program_point::hash () const\n+{\n+  inchash::hash hstate;\n+  hstate.merge_hash (m_function_point.hash ());\n+  hstate.merge_hash (m_call_string.hash ());\n+  return hstate.end ();\n+}\n+\n+/* Get the function * at DEPTH within the call stack.  */\n+\n+function *\n+program_point::get_function_at_depth (unsigned depth) const\n+{\n+  gcc_assert (depth <= m_call_string.length ());\n+  if (depth == m_call_string.length ())\n+    return m_function_point.get_function ();\n+  else\n+    return m_call_string[depth]->get_caller_function ();\n+}\n+\n+/* Assert that this object is sane.  */\n+\n+void\n+program_point::validate () const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  m_call_string.validate ();\n+  /* The \"callee\" of the final entry in the callstring should be the\n+     function of the m_function_point.  */\n+  if (m_call_string.length () > 0)\n+    gcc_assert (m_call_string[m_call_string.length () - 1]->get_callee_function ()\n+\t\t== get_function ());\n+}\n+\n+/* Check to see if SUCC is a valid edge to take (ensuring that we have\n+   interprocedurally valid paths in the exploded graph, and enforcing\n+   recursion limits).\n+\n+   Update the call string if SUCC is a call or a return.\n+\n+   Return true if SUCC can be taken, or false otherwise.\n+\n+   This is the \"point\" half of exploded_node::on_edge.  */\n+\n+bool\n+program_point::on_edge (exploded_graph &eg,\n+\t\t\tconst superedge *succ)\n+{\n+  logger * const logger = eg.get_logger ();\n+  LOG_FUNC (logger);\n+  switch (succ->m_kind)\n+    {\n+    case SUPEREDGE_CFG_EDGE:\n+      {\n+\tconst cfg_superedge *cfg_sedge = as_a <const cfg_superedge *> (succ);\n+\n+\t/* Reject abnormal edges; we special-case setjmp/longjmp.  */\n+\tif (cfg_sedge->get_flags () & EDGE_ABNORMAL)\n+\t  return false;\n+      }\n+      break;\n+\n+    case SUPEREDGE_CALL:\n+      {\n+\tconst call_superedge *call_sedge = as_a <const call_superedge *> (succ);\n+\n+\tif (eg.get_analysis_plan ().use_summary_p (call_sedge->m_cedge))\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"rejecting call edge: using summary instead\");\n+\t    return false;\n+\t  }\n+\n+\t/* Add the callsite to the call string.  */\n+\tm_call_string.push_call (eg.get_supergraph (), call_sedge);\n+\n+\t/* Impose a maximum recursion depth and don't analyze paths\n+\t   that exceed it further.\n+\t   This is something of a blunt workaround, but it only\n+\t   applies to recursion (and mutual recursion), not to\n+\t   general call stacks.  */\n+\tif (m_call_string.calc_recursion_depth ()\n+\t    > param_analyzer_max_recursion_depth)\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"rejecting call edge: recursion limit exceeded\");\n+\t    // TODO: issue a sorry for this?\n+\t    return false;\n+\t  }\n+      }\n+      break;\n+\n+    case SUPEREDGE_RETURN:\n+      {\n+\t/* Require that we return to the call site in the call string.  */\n+\tif (m_call_string.empty_p ())\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"rejecting return edge: empty call string\");\n+\t    return false;\n+\t  }\n+\tconst return_superedge *top_of_stack = m_call_string.pop ();\n+\tif (top_of_stack != succ)\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"rejecting return edge: return to wrong callsite\");\n+\t    return false;\n+\t  }\n+      }\n+      break;\n+\n+    case SUPEREDGE_INTRAPROCEDURAL_CALL:\n+      {\n+\tconst callgraph_superedge *cg_sedge\n+\t  = as_a <const callgraph_superedge *> (succ);\n+\t/* Consider turning this edge into a use of an\n+\t   interprocedural summary.  */\n+\tif (eg.get_analysis_plan ().use_summary_p (cg_sedge->m_cedge))\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"using function summary for %qE in %qE\",\n+\t\t\t   cg_sedge->get_callee_decl (),\n+\t\t\t   cg_sedge->get_caller_decl ());\n+\t    return true;\n+\t  }\n+\telse\n+\t  {\n+\t    /* Otherwise, we ignore these edges  */\n+\t    if (logger)\n+\t      logger->log (\"rejecting interprocedural edge\");\n+\t    return false;\n+\t  }\n+      }\n+    }\n+\n+  return true;\n+}\n+\n+/* Comparator for program points within the same supernode,\n+   for implementing worklist::key_t comparison operators.\n+   Return negative if POINT_A is before POINT_B\n+   Return positive if POINT_A is after POINT_B\n+   Return 0 if they are equal.  */\n+\n+int\n+function_point::cmp_within_supernode_1 (const function_point &point_a,\n+\t\t\t\t\tconst function_point &point_b)\n+{\n+  gcc_assert (point_a.get_supernode () == point_b.get_supernode ());\n+\n+  switch (point_a.m_kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case PK_BEFORE_SUPERNODE:\n+      switch (point_b.m_kind)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase PK_BEFORE_SUPERNODE:\n+\t  {\n+\t    int a_src_idx = -1;\n+\t    int b_src_idx = -1;\n+\t    if (point_a.m_from_edge)\n+\t      a_src_idx = point_a.m_from_edge->m_src->m_index;\n+\t    if (point_b.m_from_edge)\n+\t      b_src_idx = point_b.m_from_edge->m_src->m_index;\n+\t    return a_src_idx - b_src_idx;\n+\t  }\n+\t  break;\n+\n+\tcase PK_BEFORE_STMT:\n+\tcase PK_AFTER_SUPERNODE:\n+\t  return -1;\n+\t}\n+      break;\n+    case PK_BEFORE_STMT:\n+      switch (point_b.m_kind)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase PK_BEFORE_SUPERNODE:\n+\t  return 1;\n+\n+\tcase PK_BEFORE_STMT:\n+\t  return point_a.m_stmt_idx - point_b.m_stmt_idx;\n+\n+\tcase PK_AFTER_SUPERNODE:\n+\t  return -1;\n+\t}\n+      break;\n+    case PK_AFTER_SUPERNODE:\n+      switch (point_b.m_kind)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase PK_BEFORE_SUPERNODE:\n+\tcase PK_BEFORE_STMT:\n+\t  return 1;\n+\n+\tcase PK_AFTER_SUPERNODE:\n+\t  return 0;\n+\t}\n+      break;\n+    }\n+}\n+\n+/* Comparator for program points within the same supernode,\n+   for implementing worklist::key_t comparison operators.\n+   Return negative if POINT_A is before POINT_B\n+   Return positive if POINT_A is after POINT_B\n+   Return 0 if they are equal.  */\n+\n+int\n+function_point::cmp_within_supernode (const function_point &point_a,\n+\t\t\t\t      const function_point &point_b)\n+{\n+  int result = cmp_within_supernode_1 (point_a, point_b);\n+\n+  /* Check that the ordering is symmetric  */\n+#if CHECKING_P\n+  int reversed = cmp_within_supernode_1 (point_b, point_a);\n+  gcc_assert (reversed == -result);\n+#endif\n+\n+  return result;\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that function_point::operator== works as expected.  */\n+\n+static void\n+test_function_point_equality ()\n+{\n+  const supernode *snode = NULL;\n+\n+  function_point a = function_point (snode, NULL, 0,\n+\t\t\t\t     PK_BEFORE_SUPERNODE);\n+  function_point b = function_point::before_supernode (snode, NULL);\n+  ASSERT_EQ (a, b);\n+}\n+\n+/* Verify that function_point::cmp_within_supernode works as expected.  */\n+\n+static void\n+test_function_point_ordering ()\n+{\n+  const supernode *snode = NULL;\n+  const call_string call_string;\n+\n+  /* Populate an array with various points within the same\n+     snode, in order.  */\n+  auto_vec<function_point> points;\n+  points.safe_push (function_point::before_supernode (snode, NULL));\n+  points.safe_push (function_point::before_stmt (snode, 0));\n+  points.safe_push (function_point::before_stmt (snode, 1));\n+  points.safe_push (function_point::after_supernode (snode));\n+\n+  /* Check all pairs.  */\n+  unsigned i;\n+  function_point *point_a;\n+  FOR_EACH_VEC_ELT (points, i, point_a)\n+    {\n+      unsigned j;\n+      function_point *point_b;\n+      FOR_EACH_VEC_ELT (points, j, point_b)\n+\t{\n+\t  int cmp = function_point::cmp_within_supernode (*point_a, *point_b);\n+\t  if (i == j)\n+\t    ASSERT_EQ (cmp, 0);\n+\t  if (i < j)\n+\t    ASSERT_TRUE (cmp < 0);\n+\t  if (i > j)\n+\t    ASSERT_TRUE (cmp > 0);\n+\t}\n+    }\n+}\n+\n+/* Verify that program_point::operator== works as expected.  */\n+\n+static void\n+test_program_point_equality ()\n+{\n+  const supernode *snode = NULL;\n+\n+  const call_string cs;\n+\n+  program_point a = program_point::before_supernode (snode, NULL,\n+\t\t\t\t\t\t     cs);\n+\n+  program_point b = program_point::before_supernode (snode, NULL,\n+\t\t\t\t\t\t     cs);\n+\n+  ASSERT_EQ (a, b);\n+  // TODO: verify with non-empty callstrings, with different edges\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+analyzer_program_point_cc_tests ()\n+{\n+  test_function_point_equality ();\n+  test_function_point_ordering ();\n+  test_program_point_equality ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "b9fe548f3a6644c4eb991e3c71542e4bbff3ce6d", "filename": "gcc/analyzer/program-point.h", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,310 @@\n+/* Classes for representing locations within the program.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_PROGRAM_POINT_H\n+#define GCC_ANALYZER_PROGRAM_POINT_H\n+\n+class exploded_graph;\n+\n+/* An enum for distinguishing the various kinds of program_point.  */\n+\n+enum point_kind {\n+  /* A \"fake\" node which has edges to all entrypoints.  */\n+  PK_ORIGIN,\n+\n+  PK_BEFORE_SUPERNODE,\n+  PK_BEFORE_STMT,\n+  PK_AFTER_SUPERNODE,\n+\n+  /* Special values used for hash_map:  */\n+  PK_EMPTY,\n+  PK_DELETED,\n+\n+  NUM_POINT_KINDS\n+};\n+\n+extern const char *point_kind_to_string (enum point_kind pk);\n+\n+class format\n+{\n+public:\n+  format (bool newlines) : m_newlines (newlines) {}\n+\n+  void spacer (pretty_printer *pp) const\n+  {\n+    if (m_newlines)\n+      pp_newline (pp);\n+    else\n+      pp_space (pp);\n+  }\n+\n+  bool m_newlines;\n+};\n+\n+/* A class for representing a location within the program, without\n+   interprocedural information.\n+\n+   This represents a fine-grained location within the supergraph (or\n+   within one of its nodes).  */\n+\n+class function_point\n+{\n+public:\n+  function_point (const supernode *supernode,\n+\t\t  const superedge *from_edge,\n+\t\t  unsigned stmt_idx,\n+\t\t  enum point_kind kind)\n+  : m_supernode (supernode), m_from_edge (from_edge),\n+    m_stmt_idx (stmt_idx), m_kind (kind)\n+  {\n+    if (from_edge)\n+      {\n+\tgcc_checking_assert (m_kind == PK_BEFORE_SUPERNODE);\n+\tgcc_checking_assert (from_edge->get_kind () == SUPEREDGE_CFG_EDGE);\n+      }\n+    if (stmt_idx)\n+      gcc_checking_assert (m_kind == PK_BEFORE_STMT);\n+  }\n+\n+  void print (pretty_printer *pp, const format &f) const;\n+  void print_source_line (pretty_printer *pp) const;\n+  void dump () const;\n+\n+  hashval_t hash () const;\n+  bool operator== (const function_point &other) const\n+  {\n+    return (m_supernode == other.m_supernode\n+\t    && m_from_edge == other.m_from_edge\n+\t    && m_stmt_idx == other.m_stmt_idx\n+\t    && m_kind == other.m_kind);\n+  }\n+\n+  /* Accessors.  */\n+\n+  const supernode *get_supernode () const { return m_supernode; }\n+  function *get_function () const\n+  {\n+    if (m_supernode)\n+      return m_supernode->m_fun;\n+    else\n+      return NULL;\n+  }\n+  const gimple *get_stmt () const;\n+  location_t get_location () const;\n+  enum point_kind get_kind () const { return m_kind; }\n+  const superedge *get_from_edge () const\n+  {\n+    return m_from_edge;\n+  }\n+  unsigned get_stmt_idx () const\n+  {\n+    gcc_assert (m_kind == PK_BEFORE_STMT);\n+    return m_stmt_idx;\n+  }\n+\n+  /* Factory functions for making various kinds of program_point.  */\n+\n+  static function_point from_function_entry (const supergraph &sg,\n+\t\t\t\t\t    function *fun)\n+  {\n+    return before_supernode (sg.get_node_for_function_entry (fun),\n+\t\t\t     NULL);\n+  }\n+\n+  static function_point before_supernode (const supernode *supernode,\n+\t\t\t\t\t  const superedge *from_edge)\n+  {\n+    if (from_edge && from_edge->get_kind () != SUPEREDGE_CFG_EDGE)\n+      from_edge = NULL;\n+    return function_point (supernode, from_edge, 0, PK_BEFORE_SUPERNODE);\n+  }\n+\n+  static function_point before_stmt (const supernode *supernode,\n+\t\t\t\t     unsigned stmt_idx)\n+  {\n+    return function_point (supernode, NULL, stmt_idx, PK_BEFORE_STMT);\n+  }\n+\n+  static function_point after_supernode (const supernode *supernode)\n+  {\n+    return function_point (supernode, NULL, 0, PK_AFTER_SUPERNODE);\n+  }\n+\n+  /* Support for hash_map.  */\n+\n+  static function_point empty ()\n+  {\n+    return function_point (NULL, NULL, 0, PK_EMPTY);\n+  }\n+  static function_point deleted ()\n+  {\n+    return function_point (NULL, NULL, 0, PK_DELETED);\n+  }\n+\n+  static int cmp_within_supernode_1 (const function_point &point_a,\n+\t\t\t\t     const function_point &point_b);\n+  static int cmp_within_supernode (const function_point &point_a,\n+\t\t\t\t   const function_point &point_b);\n+\n+ private:\n+  const supernode *m_supernode;\n+\n+  /* For PK_BEFORE_SUPERNODE, and only for CFG edges.  */\n+  const superedge *m_from_edge;\n+\n+  /* Only for PK_BEFORE_STMT.  */\n+  unsigned m_stmt_idx;\n+\n+  enum point_kind m_kind;\n+};\n+\n+/* A class for representing a location within the program, including\n+   interprocedural information.\n+\n+   This represents a fine-grained location within the supergraph (or\n+   within one of its nodes), along with a call string giving the\n+   interprocedural context.  */\n+\n+class program_point\n+{\n+public:\n+  program_point (const function_point &fn_point,\n+\t\t const call_string &call_string)\n+  : m_function_point (fn_point),\n+    m_call_string (call_string)\n+  {\n+  }\n+\n+  void print (pretty_printer *pp, const format &f) const;\n+  void print_source_line (pretty_printer *pp) const;\n+  void dump () const;\n+\n+  hashval_t hash () const;\n+  bool operator== (const program_point &other) const\n+  {\n+    return (m_function_point == other.m_function_point\n+\t    && m_call_string == other.m_call_string);\n+  }\n+\n+  /* Accessors.  */\n+\n+  const function_point &get_function_point () const { return m_function_point; }\n+  const call_string &get_call_string () const { return m_call_string; }\n+\n+  const supernode *get_supernode () const\n+  {\n+    return m_function_point.get_supernode ();\n+  }\n+  function *get_function () const\n+  {\n+    return m_function_point.get_function ();\n+  }\n+  function *get_function_at_depth (unsigned depth) const;\n+  tree get_fndecl () const\n+  {\n+    gcc_assert (get_kind () != PK_ORIGIN);\n+    return get_function ()->decl;\n+  }\n+  const gimple *get_stmt () const\n+  {\n+    return m_function_point.get_stmt ();\n+  }\n+  location_t get_location () const\n+  {\n+    return m_function_point.get_location ();\n+  }\n+  enum point_kind get_kind () const\n+  {\n+    return m_function_point.get_kind ();\n+  }\n+  const superedge *get_from_edge () const\n+  {\n+    return m_function_point.get_from_edge ();\n+  }\n+  unsigned get_stmt_idx () const\n+  {\n+    return m_function_point.get_stmt_idx ();\n+  }\n+\n+  /* Get the number of frames we expect at this program point.\n+     This will be one more than the length of the call_string\n+     (which stores the parent callsites), apart from the origin\n+     node, which doesn't have any frames.  */\n+  int get_stack_depth () const\n+  {\n+    if (get_kind () == PK_ORIGIN)\n+      return 0;\n+    return m_call_string.length () + 1;\n+  }\n+\n+  /* Factory functions for making various kinds of program_point.  */\n+\n+  static program_point from_function_entry (const supergraph &sg,\n+\t\t\t\t\t    function *fun)\n+  {\n+    return program_point (function_point::from_function_entry (sg, fun),\n+\t\t\t  call_string ());\n+  }\n+\n+  static program_point before_supernode (const supernode *supernode,\n+\t\t\t\t\t const superedge *from_edge,\n+\t\t\t\t\t const call_string &call_string)\n+  {\n+    return program_point (function_point::before_supernode (supernode,\n+\t\t\t\t\t\t\t    from_edge),\n+\t\t\t  call_string);\n+  }\n+\n+  static program_point before_stmt (const supernode *supernode,\n+\t\t\t\t    unsigned stmt_idx,\n+\t\t\t\t    const call_string &call_string)\n+  {\n+    return program_point (function_point::before_stmt (supernode, stmt_idx),\n+\t\t\t  call_string);\n+  }\n+\n+  static program_point after_supernode (const supernode *supernode,\n+\t\t\t\t\tconst call_string &call_string)\n+  {\n+    return program_point (function_point::after_supernode (supernode),\n+\t\t\t  call_string);\n+  }\n+\n+  /* Support for hash_map.  */\n+\n+  static program_point empty ()\n+  {\n+    return program_point (function_point::empty (), call_string ());\n+  }\n+  static program_point deleted ()\n+  {\n+    return program_point (function_point::deleted (), call_string ());\n+  }\n+\n+  bool on_edge (exploded_graph &eg, const superedge *succ);\n+\n+  void validate () const;\n+\n+ private:\n+  const function_point m_function_point;\n+  call_string m_call_string;\n+};\n+\n+#endif /* GCC_ANALYZER_PROGRAM_POINT_H */"}, {"sha": "04346ae9dc8973d6b9175d79a91f40101aa81d83", "filename": "gcc/analyzer/program-state.cc", "status": "added", "additions": 1356, "deletions": 0, "changes": 1356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,1356 @@\n+/* Classes for representing the state of interest at a given path of analysis.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/constraint-manager.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"cfg.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/exploded-graph.h\"\n+#include \"analyzer/state-purge.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* class sm_state_map.  */\n+\n+/* sm_state_map's ctor.  */\n+\n+sm_state_map::sm_state_map ()\n+: m_map (), m_global_state (0)\n+{\n+}\n+\n+/* Clone the sm_state_map.  */\n+\n+sm_state_map *\n+sm_state_map::clone () const\n+{\n+  return new sm_state_map (*this);\n+}\n+\n+/* Clone this sm_state_map, remapping all svalue_ids within it with ID_MAP.\n+\n+   Return NULL if there are any svalue_ids that have sm-state for which\n+   ID_MAP maps them to svalue_id::null (and thus the clone would have lost\n+   the sm-state information). */\n+\n+sm_state_map *\n+sm_state_map::clone_with_remapping (const one_way_svalue_id_map &id_map) const\n+{\n+  sm_state_map *result = new sm_state_map ();\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      svalue_id sid = (*iter).first;\n+      gcc_assert (!sid.null_p ());\n+      entry_t e = (*iter).second;\n+      /* TODO: what should we do if the origin maps from non-null to null?\n+\t Is that loss of information acceptable?  */\n+      id_map.update (&e.m_origin);\n+\n+      svalue_id new_sid = id_map.get_dst_for_src (sid);\n+      if (new_sid.null_p ())\n+\t{\n+\t  delete result;\n+\t  return NULL;\n+\t}\n+      result->m_map.put (new_sid, e);\n+    }\n+  return result;\n+}\n+\n+/* Print this sm_state_map (for SM) to PP.  */\n+\n+void\n+sm_state_map::print (const state_machine &sm, pretty_printer *pp) const\n+{\n+  bool first = true;\n+  pp_string (pp, \"{\");\n+  if (m_global_state != 0)\n+    {\n+      pp_printf (pp, \"global: %s\", sm.get_state_name (m_global_state));\n+      first = false;\n+    }\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      if (!first)\n+\tpp_string (pp, \", \");\n+      first = false;\n+      svalue_id sid = (*iter).first;\n+      sid.print (pp);\n+\n+      entry_t e = (*iter).second;\n+      pp_printf (pp, \": %s (origin: \",\n+\t\t sm.get_state_name (e.m_state));\n+      e.m_origin.print (pp);\n+      pp_string (pp, \")\");\n+    }\n+  pp_string (pp, \"}\");\n+}\n+\n+/* Dump this object (for SM) to stderr.  */\n+\n+DEBUG_FUNCTION void\n+sm_state_map::dump (const state_machine &sm) const\n+{\n+  pretty_printer pp;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  print (sm, &pp);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Return true if no states have been set within this map\n+   (all expressions are for the start state).  */\n+\n+bool\n+sm_state_map::is_empty_p () const\n+{\n+  return m_map.elements () == 0 && m_global_state == 0;\n+}\n+\n+/* Generate a hash value for this sm_state_map.  */\n+\n+hashval_t\n+sm_state_map::hash () const\n+{\n+  hashval_t result = 0;\n+\n+  /* Accumulate the result by xoring a hash for each slot, so that the\n+     result doesn't depend on the ordering of the slots in the map.  */\n+\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      inchash::hash hstate;\n+      inchash::add ((*iter).first, hstate);\n+      entry_t e = (*iter).second;\n+      hstate.add_int (e.m_state);\n+      inchash::add (e.m_origin, hstate);\n+      result ^= hstate.end ();\n+    }\n+  result ^= m_global_state;\n+\n+  return result;\n+}\n+\n+/* Equality operator for sm_state_map.  */\n+\n+bool\n+sm_state_map::operator== (const sm_state_map &other) const\n+{\n+  if (m_global_state != other.m_global_state)\n+    return false;\n+\n+  if (m_map.elements () != other.m_map.elements ())\n+    return false;\n+\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      svalue_id sid = (*iter).first;\n+      entry_t e = (*iter).second;\n+      entry_t *other_slot = const_cast <map_t &> (other.m_map).get (sid);\n+      if (other_slot == NULL)\n+\treturn false;\n+      if (e != *other_slot)\n+\treturn false;\n+    }\n+\n+  gcc_checking_assert (hash () == other.hash ());\n+\n+  return true;\n+}\n+\n+/* Get the state of SID within this object.\n+   States default to the start state.  */\n+\n+state_machine::state_t\n+sm_state_map::get_state (svalue_id sid) const\n+{\n+  gcc_assert (!sid.null_p ());\n+\n+  if (entry_t *slot\n+      = const_cast <map_t &> (m_map).get (sid))\n+    return slot->m_state;\n+  else\n+    return 0;\n+}\n+\n+/* Get the \"origin\" svalue_id for any state of SID.  */\n+\n+svalue_id\n+sm_state_map::get_origin (svalue_id sid) const\n+{\n+  gcc_assert (!sid.null_p ());\n+\n+  entry_t *slot\n+    = const_cast <map_t &> (m_map).get (sid);\n+  if (slot)\n+    return slot->m_origin;\n+  else\n+    return svalue_id::null ();\n+}\n+\n+/* Set the state of SID within MODEL to STATE, recording that\n+   the state came from ORIGIN.  */\n+\n+void\n+sm_state_map::set_state (region_model *model,\n+\t\t\t svalue_id sid,\n+\t\t\t state_machine::state_t state,\n+\t\t\t svalue_id origin)\n+{\n+  if (model == NULL)\n+    return;\n+  equiv_class &ec = model->get_constraints ()->get_equiv_class (sid);\n+  set_state (ec, state, origin);\n+\n+  /* Also do it for all svalues that are equal via non-cm, so that\n+     e.g. (void *)&r and (foo *)&r transition together.  */\n+  for (unsigned i = 0; i < model->get_num_svalues (); i++)\n+    {\n+      svalue_id other_sid = svalue_id::from_int (i);\n+      if (other_sid == sid)\n+\tcontinue;\n+\n+      tristate eq = model->eval_condition_without_cm (sid, EQ_EXPR, other_sid);\n+      if (eq.is_true ())\n+\timpl_set_state (other_sid, state, origin);\n+    }\n+}\n+\n+/* Set the state of EC to STATE, recording that the state came from\n+   ORIGIN.  */\n+\n+void\n+sm_state_map::set_state (const equiv_class &ec,\n+\t\t\t state_machine::state_t state,\n+\t\t\t svalue_id origin)\n+{\n+  int i;\n+  svalue_id *sid;\n+  FOR_EACH_VEC_ELT (ec.m_vars, i, sid)\n+    impl_set_state (*sid, state, origin);\n+}\n+\n+/* Set state of PV to STATE, bypassing equivalence classes.  */\n+\n+void\n+sm_state_map::impl_set_state (svalue_id sid, state_machine::state_t state,\n+\t\t\t      svalue_id origin)\n+{\n+  /* Special-case state 0 as the default value.  */\n+  if (state == 0)\n+    {\n+      if (m_map.get (sid))\n+\tm_map.remove (sid);\n+      return;\n+    }\n+  gcc_assert (!sid.null_p ());\n+  m_map.put (sid, entry_t (state, origin));\n+}\n+\n+/* Set the \"global\" state within this state map to STATE.  */\n+\n+void\n+sm_state_map::set_global_state (state_machine::state_t state)\n+{\n+  m_global_state = state;\n+}\n+\n+/* Get the \"global\" state within this state map.  */\n+\n+state_machine::state_t\n+sm_state_map::get_global_state () const\n+{\n+  return m_global_state;\n+}\n+\n+/* Handle CALL to unknown FNDECL with an unknown function body, which\n+   could do anything to the states passed to it.\n+   Clear any state for SM for the params and any LHS.\n+   Note that the function might be known to other state machines, but\n+   not to this one.  */\n+\n+void\n+sm_state_map::purge_for_unknown_fncall (const exploded_graph &eg,\n+\t\t\t\t\tconst state_machine &sm,\n+\t\t\t\t\tconst gcall *call,\n+\t\t\t\t\ttree fndecl,\n+\t\t\t\t\tregion_model *new_model)\n+{\n+  logger * const logger = eg.get_logger ();\n+  if (logger)\n+    {\n+      if (fndecl)\n+\tlogger->log (\"function %qE is unknown to checker %qs\",\n+\t\t     fndecl, sm.get_name ());\n+      else\n+\tlogger->log (\"unknown function pointer for checker %qs\",\n+\t\t     sm.get_name ());\n+    }\n+\n+  /* Purge any state for parms.  */\n+  tree iter_param_types = NULL_TREE;\n+  if (fndecl)\n+    iter_param_types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+  for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\n+    {\n+      /* Track expected param type, where available.  */\n+      if (iter_param_types)\n+\t{\n+\t  tree param_type = TREE_VALUE (iter_param_types);\n+\t  gcc_assert (param_type);\n+\t  iter_param_types = TREE_CHAIN (iter_param_types);\n+\n+\t  /* Don't purge state if it was passed as a const pointer\n+\t     e.g. for things like strlen (PTR).  */\n+\t  if (TREE_CODE (param_type) == POINTER_TYPE)\n+\t    if (TYPE_READONLY (TREE_TYPE (param_type)))\n+\t      continue;\n+\t}\n+      tree parm = gimple_call_arg (call, arg_idx);\n+      svalue_id parm_sid = new_model->get_rvalue (parm, NULL);\n+      set_state (new_model, parm_sid, 0, svalue_id::null ());\n+\n+      /* Also clear sm-state from svalue_ids that are passed via a\n+\t pointer.  */\n+      if (TREE_CODE (parm) == ADDR_EXPR)\n+\t{\n+\t  tree pointee = TREE_OPERAND (parm, 0);\n+\t  svalue_id parm_sid = new_model->get_rvalue (pointee, NULL);\n+\t  set_state (new_model, parm_sid, 0, svalue_id::null ());\n+\t}\n+    }\n+\n+  /* Purge any state for any LHS.  */\n+  if (tree lhs = gimple_call_lhs (call))\n+    {\n+      svalue_id lhs_sid = new_model->get_rvalue (lhs, NULL);\n+      set_state (new_model, lhs_sid, 0, svalue_id::null ());\n+    }\n+}\n+\n+/* Update this map based on MAP.  */\n+\n+void\n+sm_state_map::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  map_t tmp_map;\n+\n+  /* Build an intermediate map, using the new sids.  */\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      svalue_id sid = (*iter).first;\n+      entry_t e = (*iter).second;\n+\n+      map.update (&sid);\n+      map.update (&e.m_origin);\n+      tmp_map.put (sid, e);\n+    }\n+\n+  /* Clear the existing values.  */\n+  m_map.empty ();\n+\n+  /* Copy over from intermediate map.  */\n+  for (typename map_t::iterator iter = tmp_map.begin ();\n+       iter != tmp_map.end ();\n+       ++iter)\n+    {\n+      svalue_id sid = (*iter).first;\n+      entry_t e = (*iter).second;\n+\n+      impl_set_state (sid, e.m_state, e.m_origin);\n+    }\n+}\n+\n+/* Purge any state for svalue_ids >= FIRST_UNUSED_SID.\n+   If !SM::can_purge_p, then report the state as leaking,\n+   using SM_IDX, CTXT, and MAP.\n+   Return the number of states that were purged.  */\n+\n+int\n+sm_state_map::on_svalue_purge (const state_machine &sm,\n+\t\t\t       int sm_idx,\n+\t\t\t       svalue_id first_unused_sid,\n+\t\t\t       const svalue_id_map &map,\n+\t\t\t       impl_region_model_context *ctxt)\n+{\n+  /* TODO: ideally remove the slot directly; for now\n+     do it in two stages.  */\n+  auto_vec<svalue_id> to_remove;\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      svalue_id dst_sid ((*iter).first);\n+      if (dst_sid.as_int () >= first_unused_sid.as_int ())\n+\t{\n+\t  /* Complain about leaks here.  */\n+\t  entry_t e = (*iter).second;\n+\n+\t  if (!sm.can_purge_p (e.m_state))\n+\t    ctxt->on_state_leak (sm, sm_idx, dst_sid, first_unused_sid,\n+\t\t\t\t map, e.m_state);\n+\n+\t  to_remove.safe_push (dst_sid);\n+\t}\n+    }\n+\n+  int i;\n+  svalue_id *dst_sid;\n+  FOR_EACH_VEC_ELT (to_remove, i, dst_sid)\n+    m_map.remove (*dst_sid);\n+\n+  return to_remove.length ();\n+}\n+\n+/* Set the state of CHILD_SID to that of PARENT_SID.  */\n+\n+void\n+sm_state_map::on_inherited_svalue (svalue_id parent_sid,\n+\t\t\t\t   svalue_id child_sid)\n+{\n+  state_machine::state_t state = get_state (parent_sid);\n+  impl_set_state (child_sid, state, parent_sid);\n+}\n+\n+/* Set the state of DST_SID to that of SRC_SID.  */\n+\n+void\n+sm_state_map::on_cast (svalue_id src_sid,\n+\t\t       svalue_id dst_sid)\n+{\n+  state_machine::state_t state = get_state (src_sid);\n+  impl_set_state (dst_sid, state, get_origin (src_sid));\n+}\n+\n+/* Assert that this object is sane.  */\n+\n+void\n+sm_state_map::validate (const state_machine &sm,\n+\t\t\tint num_svalues) const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  for (typename map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end ();\n+       ++iter)\n+    {\n+      svalue_id sid = (*iter).first;\n+      entry_t e = (*iter).second;\n+\n+      gcc_assert (sid.as_int () < num_svalues);\n+      sm.validate (e.m_state);\n+      gcc_assert (e.m_origin.as_int () < num_svalues);\n+    }\n+}\n+\n+/* class program_state.  */\n+\n+/* program_state's ctor.  */\n+\n+program_state::program_state (const extrinsic_state &ext_state)\n+: m_region_model (new region_model ()),\n+  m_checker_states (ext_state.m_checkers.length ())\n+{\n+  int num_states = ext_state.m_checkers.length ();\n+  for (int i = 0; i < num_states; i++)\n+    m_checker_states.quick_push (new sm_state_map ());\n+}\n+\n+/* program_state's copy ctor.  */\n+\n+program_state::program_state (const program_state &other)\n+: m_region_model (new region_model (*other.m_region_model)),\n+  m_checker_states (other.m_checker_states.length ())\n+{\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (other.m_checker_states, i, smap)\n+    m_checker_states.quick_push (smap->clone ());\n+}\n+\n+/* program_state's assignment operator.  */\n+\n+program_state&\n+program_state::operator= (const program_state &other)\n+{\n+  delete m_region_model;\n+  m_region_model = new region_model (*other.m_region_model);\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    delete smap;\n+  m_checker_states.truncate (0);\n+  gcc_assert (m_checker_states.space (other.m_checker_states.length ()));\n+\n+  FOR_EACH_VEC_ELT (other.m_checker_states, i, smap)\n+    m_checker_states.quick_push (smap->clone ());\n+\n+  return *this;\n+}\n+\n+#if __cplusplus >= 201103\n+/* Move constructor for program_state (when building with C++11).  */\n+program_state::program_state (program_state &&other)\n+: m_region_model (other.m_region_model),\n+  m_checker_states (other.m_checker_states.length ())\n+{\n+  other.m_region_model = NULL;\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (other.m_checker_states, i, smap)\n+    m_checker_states.quick_push (smap);\n+  other.m_checker_states.truncate (0);\n+}\n+#endif\n+\n+/* program_state's dtor.  */\n+\n+program_state::~program_state ()\n+{\n+  delete m_region_model;\n+}\n+\n+/* Generate a hash value for this program_state.  */\n+\n+hashval_t\n+program_state::hash () const\n+{\n+  hashval_t result = m_region_model->hash ();\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    result ^= smap->hash ();\n+  return result;\n+}\n+\n+/* Equality operator for program_state.\n+   All parts of the program_state (region model, checker states) must\n+   equal their counterparts in OTHER for the two program_states to be\n+   considered equal.  */\n+\n+bool\n+program_state::operator== (const program_state &other) const\n+{\n+  if (!(*m_region_model == *other.m_region_model))\n+    return false;\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    if (!(*smap == *other.m_checker_states[i]))\n+      return false;\n+\n+  gcc_checking_assert (hash () == other.hash ());\n+\n+  return true;\n+}\n+\n+/* Print a compact representation of this state to PP.  */\n+\n+void\n+program_state::print (const extrinsic_state &ext_state,\n+\t\t      pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"rmodel: \");\n+  m_region_model->print (pp);\n+  pp_newline (pp);\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    {\n+      if (!smap->is_empty_p ())\n+\t{\n+\t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n+\t  smap->print (ext_state.get_sm (i), pp);\n+\t  pp_newline (pp);\n+\t}\n+    }\n+}\n+\n+/* Dump a multiline representation of this state to PP.  */\n+\n+void\n+program_state::dump_to_pp (const extrinsic_state &ext_state,\n+\t\t\t   bool summarize,\n+\t\t\t   pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"rmodel: \");\n+  m_region_model->dump_to_pp (pp, summarize);\n+\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    {\n+      if (!smap->is_empty_p ())\n+\t{\n+\t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n+\t  smap->print (ext_state.get_sm (i), pp);\n+\t  pp_newline (pp);\n+\t}\n+    }\n+}\n+\n+/* Dump a multiline representation of this state to OUTF.  */\n+\n+void\n+program_state::dump_to_file (const extrinsic_state &ext_state,\n+\t\t\t     bool summarize,\n+\t\t\t     FILE *outf) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  if (outf == stderr)\n+    pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = outf;\n+  dump_to_pp (ext_state, summarize, &pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Dump a multiline representation of this state to stderr.  */\n+\n+DEBUG_FUNCTION void\n+program_state::dump (const extrinsic_state &ext_state,\n+\t\t     bool summarize) const\n+{\n+  dump_to_file (ext_state, summarize, stderr);\n+}\n+\n+/* Determine if following edge SUCC from ENODE is valid within the graph EG\n+   and update this state accordingly in-place.\n+\n+   Return true if the edge can be followed, or false otherwise.\n+\n+   Check for relevant conditionals and switch-values for conditionals\n+   and switch statements, adding the relevant conditions to this state.\n+   Push/pop frames for interprocedural edges and update params/returned\n+   values.\n+\n+   This is the \"state\" half of exploded_node::on_edge.  */\n+\n+bool\n+program_state::on_edge (exploded_graph &eg,\n+\t\t\tconst exploded_node &enode,\n+\t\t\tconst superedge *succ,\n+\t\t\tstate_change *change)\n+{\n+  /* Update state.  */\n+  const program_point &point = enode.get_point ();\n+  const gimple *last_stmt = point.get_supernode ()->get_last_stmt ();\n+\n+  /* For conditionals and switch statements, add the\n+     relevant conditions (for the specific edge) to new_state;\n+     skip edges for which the resulting constraints\n+     are impossible.\n+     This also updates frame information for call/return superedges.\n+     Adding the relevant conditions for the edge could also trigger\n+     sm-state transitions (e.g. transitions due to ptrs becoming known\n+     to be NULL or non-NULL) */\n+\n+  impl_region_model_context ctxt (eg, &enode,\n+\t\t\t\t  &enode.get_state (),\n+\t\t\t\t  this, change,\n+\t\t\t\t  last_stmt);\n+  if (!m_region_model->maybe_update_for_edge (*succ,\n+\t\t\t\t\t      last_stmt,\n+\t\t\t\t\t      &ctxt))\n+    {\n+      logger * const logger = eg.get_logger ();\n+      if (logger)\n+\tlogger->log (\"edge to SN: %i is impossible\"\n+\t\t     \" due to region_model constraints\",\n+\t\t     succ->m_dest->m_index);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Generate a simpler version of THIS, discarding state that's no longer\n+   relevant at POINT.\n+   The idea is that we're more likely to be able to consolidate\n+   multiple (point, state) into single exploded_nodes if we discard\n+   irrelevant state (e.g. at the end of functions).\n+\n+   Retain state affected by CHANGE, to make it easier to generate\n+   state_change_events.  */\n+\n+program_state\n+program_state::prune_for_point (exploded_graph &eg,\n+\t\t\t\tconst program_point &point,\n+\t\t\t\tstate_change *change) const\n+{\n+  logger * const logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+\n+  function *fun = point.get_function ();\n+  if (!fun)\n+    return *this;\n+\n+  program_state new_state (*this);\n+\n+  purge_stats stats;\n+\n+  const state_purge_map *pm = eg.get_purge_map ();\n+  if (pm)\n+    {\n+      region_id_set purgeable_ssa_regions (new_state.m_region_model);\n+      region_id frame_rid\n+\t= new_state.m_region_model->get_current_frame_id ();\n+      frame_region *frame\n+\t= new_state.m_region_model->get_region <frame_region>(frame_rid);\n+\n+      /* TODO: maybe move to a member of region_model?  */\n+\n+      auto_vec<tree> ssa_names_to_purge;\n+      for (frame_region::map_t::iterator iter = frame->begin ();\n+\t   iter != frame->end ();\n+\t   ++iter)\n+\t{\n+\t  tree var = (*iter).first;\n+\t  region_id rid = (*iter).second;\n+\t  if (TREE_CODE (var) == SSA_NAME)\n+\t    {\n+\t      const state_purge_per_ssa_name &per_ssa\n+\t\t= pm->get_data_for_ssa_name (var);\n+\t      if (!per_ssa.needed_at_point_p (point.get_function_point ()))\n+\t\t{\n+\t\t  region *region\n+\t\t    = new_state.m_region_model->get_region (rid);\n+\t\t  svalue_id sid = region->get_value_direct ();\n+\t\t  if (!sid.null_p ())\n+\t\t    {\n+\t\t      if (!new_state.can_purge_p (eg.get_ext_state (), sid))\n+\t\t\t{\n+\t\t\t  /* (currently only state maps can keep things\n+\t\t\t     alive).  */\n+\t\t\t  if (logger)\n+\t\t\t    logger->log (\"not purging RID: %i for %qE\"\n+\t\t\t\t\t \" (used by state map)\",\n+\t\t\t\t\t rid.as_int (), var);\n+\t\t\t  continue;\n+\t\t\t}\n+\n+\t\t      /* Don't purge regions containing svalues that\n+\t\t\t have a change of sm-state, to make it easier to\n+\t\t\t generate state_change_event messages.  */\n+\t\t      if (change)\n+\t\t\tif (change->affects_p (sid))\n+\t\t\t  {\n+\t\t\t    if (logger)\n+\t\t\t      logger->log (\"not purging RID: %i for %qE\"\n+\t\t\t\t\t   \" (affected by change)\",\n+\t\t\t\t\t   rid.as_int (), var);\n+\t\t\t    continue;\n+\t\t\t  }\n+\t\t    }\n+\t\t  purgeable_ssa_regions.add_region (rid);\n+\t\t  ssa_names_to_purge.safe_push (var);\n+\t\t  if (logger)\n+\t\t    logger->log (\"purging RID: %i for %qE\", rid.as_int (), var);\n+\t\t  /* We also need to remove the region from the map.\n+\t\t     We're in mid-traversal, so the removal is done in\n+\t\t     unbind below.  */\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Unbind the regions from the frame's map of vars-to-regions.  */\n+      unsigned i;\n+      tree var;\n+      FOR_EACH_VEC_ELT (ssa_names_to_purge, i, var)\n+\tframe->unbind (var);\n+\n+      /* Purge the regions.  Nothing should point to them, and they\n+\t should have no children, as they are for SSA names.  */\n+      new_state.m_region_model->purge_regions (purgeable_ssa_regions,\n+\t\t\t\t\t       &stats,\n+\t\t\t\t\t       eg.get_logger ());\n+    }\n+\n+  /* Purge unused svalues.  */\n+  // TODO: which enode to use, if any?\n+  impl_region_model_context ctxt (eg, NULL,\n+\t\t\t\t  this,\n+\t\t\t\t  &new_state,\n+\t\t\t\t  change,\n+\t\t\t\t  NULL);\n+  new_state.m_region_model->purge_unused_svalues (&stats, &ctxt);\n+  if (logger)\n+    {\n+      logger->log (\"num svalues purged: %i\", stats.m_num_svalues);\n+      logger->log (\"num regions purged: %i\", stats.m_num_regions);\n+      logger->log (\"num equiv_classes purged: %i\", stats.m_num_equiv_classes);\n+      logger->log (\"num constraints purged: %i\", stats.m_num_constraints);\n+      logger->log (\"num sm map items purged: %i\", stats.m_num_client_items);\n+    }\n+\n+  new_state.m_region_model->canonicalize (&ctxt);\n+\n+  return new_state;\n+}\n+\n+/* Remap all svalue_ids in this state's m_checker_states according to MAP.\n+   The svalues_ids in the region_model are assumed to already have been\n+   remapped.  */\n+\n+void\n+program_state::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    smap->remap_svalue_ids (map);\n+}\n+\n+/* Attempt to return a tree that represents SID, or return NULL_TREE.\n+   Find the first region that stores the value (e.g. a local) and\n+   generate a representative tree for it.  */\n+\n+tree\n+program_state::get_representative_tree (svalue_id sid) const\n+{\n+  return m_region_model->get_representative_tree (sid);\n+}\n+\n+/* Attempt to merge this state with OTHER, both using EXT_STATE.\n+   Write the result to *OUT.\n+   If the states were merged successfully, return true.  */\n+\n+bool\n+program_state::can_merge_with_p (const program_state &other,\n+\t\t\t\t const extrinsic_state &ext_state,\n+\t\t\t\t program_state *out) const\n+{\n+  gcc_assert (out);\n+\n+  /* TODO:  initially I had an early reject here if there\n+     are sm-differences between the states.  However, this was\n+     falsely rejecting merger opportunities for states where the\n+     only difference was in svalue_id ordering.  */\n+\n+  /* Attempt to merge the region_models.  */\n+\n+  svalue_id_merger_mapping sid_mapping (*m_region_model,\n+\t\t\t\t\t*other.m_region_model);\n+  if (!m_region_model->can_merge_with_p (*other.m_region_model,\n+\t\t\t\t\t out->m_region_model,\n+\t\t\t\t\t &sid_mapping))\n+    return false;\n+\n+  /* Copy m_checker_states to result, remapping svalue_ids using\n+     sid_mapping.  */\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)\n+    delete smap;\n+  out->m_checker_states.truncate (0);\n+\n+  /* Remap this and other's m_checker_states using sid_mapping.\n+     Only merge states that have equality between the two end-results:\n+     sm-state differences are likely to be interesting to end-users, and\n+     hence are worth exploring as separate paths in the exploded graph.  */\n+  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+    {\n+      sm_state_map *other_smap = other.m_checker_states[i];\n+\n+      /* If clone_with_remapping returns NULL for one of the input smaps,\n+\t then it has sm-state for an svalue_id where the svalue_id is\n+\t being mapped to svalue_id::null in its sid_mapping, meaning that\n+\t the svalue is to be dropped during the merger.  We don't want\n+\t to lose sm-state during a state merger, so return false for these\n+\t cases.  */\n+      sm_state_map *remapped_a_smap\n+\t= smap->clone_with_remapping (sid_mapping.m_map_from_a_to_m);\n+      if (!remapped_a_smap)\n+\treturn false;\n+      sm_state_map *remapped_b_smap\n+\t= other_smap->clone_with_remapping (sid_mapping.m_map_from_b_to_m);\n+      if (!remapped_b_smap)\n+\t{\n+\t  delete remapped_a_smap;\n+\t  return false;\n+\t}\n+\n+      /* Both states have sm-state for the same values; now ensure that the\n+\t states are equal.  */\n+      if (*remapped_a_smap == *remapped_b_smap)\n+\t{\n+\t  out->m_checker_states.safe_push (remapped_a_smap);\n+\t  delete remapped_b_smap;\n+\t}\n+      else\n+\t{\n+\t  /* Don't merge if there are sm-state differences.  */\n+\t  delete remapped_a_smap;\n+\t  delete remapped_b_smap;\n+\t  return false;\n+\t}\n+    }\n+\n+  impl_region_model_context ctxt (out, NULL, ext_state);\n+  out->m_region_model->canonicalize (&ctxt);\n+\n+  return true;\n+}\n+\n+/* Assert that this object is valid.  */\n+\n+void\n+program_state::validate (const extrinsic_state &ext_state) const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+\n+  m_region_model->validate ();\n+  gcc_assert (m_checker_states.length () == ext_state.get_num_checkers ());\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_checker_states, sm_idx, smap)\n+    {\n+      const state_machine &sm = ext_state.get_sm (sm_idx);\n+      smap->validate (sm, m_region_model->get_num_svalues ());\n+    }\n+}\n+\n+/* Dump this sm_change to PP.  */\n+\n+void\n+state_change::sm_change::dump (pretty_printer *pp,\n+\t\t\t       const extrinsic_state &ext_state) const\n+{\n+  const state_machine &sm = get_sm (ext_state);\n+  pp_string (pp, \"(\");\n+  m_new_sid.print (pp);\n+  pp_printf (pp, \": %s: %qs -> %qs)\",\n+\t     sm.get_name (),\n+\t     sm.get_state_name (m_old_state),\n+\t     sm.get_state_name (m_new_state));\n+}\n+\n+/* Remap all svalue_ids in this change according to MAP.  */\n+\n+void\n+state_change::sm_change::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  map.update (&m_new_sid);\n+}\n+\n+/* Purge any svalue_ids >= FIRST_UNUSED_SID.\n+   Return the number of states that were purged.  */\n+\n+int\n+state_change::sm_change::on_svalue_purge (svalue_id first_unused_sid)\n+{\n+  if (m_new_sid.as_int () >= first_unused_sid.as_int ())\n+    {\n+      m_new_sid = svalue_id::null ();\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Assert that this object is sane.  */\n+\n+void\n+state_change::sm_change::validate (const program_state &new_state) const\n+{\n+  m_new_sid.validate (*new_state.m_region_model);\n+}\n+\n+/* state_change's ctor.  */\n+\n+state_change::state_change ()\n+{\n+}\n+\n+/* state_change's copy ctor.  */\n+\n+state_change::state_change (const state_change &other)\n+: m_sm_changes (other.m_sm_changes.length ())\n+{\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (other.m_sm_changes, i, change)\n+    m_sm_changes.quick_push (*change);\n+}\n+\n+/* Record a state-machine state change.  */\n+\n+void\n+state_change::add_sm_change (int sm_idx,\n+\t\t\t     svalue_id new_sid,\n+\t\t\t     state_machine::state_t old_state,\n+\t\t\t     state_machine::state_t new_state)\n+{\n+  m_sm_changes.safe_push (sm_change (sm_idx,\n+\t\t\t\t     new_sid,\n+\t\t\t\t     old_state, new_state));\n+}\n+\n+/* Return true if SID (in the new state) was affected by any\n+   sm-state changes.  */\n+\n+bool\n+state_change::affects_p (svalue_id sid) const\n+{\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+    {\n+      if (sid == change->m_new_sid)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Dump this state_change to PP.  */\n+\n+void\n+state_change::dump (pretty_printer *pp,\n+\t\t    const extrinsic_state &ext_state) const\n+{\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      change->dump (pp, ext_state);\n+    }\n+}\n+\n+/* Dump this state_change to stderr.  */\n+\n+void\n+state_change::dump (const extrinsic_state &ext_state) const\n+{\n+  pretty_printer pp;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump (&pp, ext_state);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Remap all svalue_ids in this state_change according to MAP.  */\n+\n+void\n+state_change::remap_svalue_ids (const svalue_id_map &map)\n+{\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+    change->remap_svalue_ids (map);\n+}\n+\n+/* Purge any svalue_ids >= FIRST_UNUSED_SID.\n+   Return the number of states that were purged.  */\n+\n+int\n+state_change::on_svalue_purge (svalue_id first_unused_sid)\n+{\n+  int result = 0;\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+    result += change->on_svalue_purge (first_unused_sid);\n+  return result;\n+}\n+\n+/* Assert that this object is sane.  */\n+\n+void\n+state_change::validate (const program_state &new_state) const\n+{\n+  /* Skip this in a release build.  */\n+#if !CHECKING_P\n+  return;\n+#endif\n+  unsigned i;\n+  sm_change *change;\n+  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+    change->validate (new_state);\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Tests for sm_state_map.  */\n+\n+static void\n+test_sm_state_map ()\n+{\n+  tree x = build_global_decl (\"x\", integer_type_node);\n+  tree y = build_global_decl (\"y\", integer_type_node);\n+  tree z = build_global_decl (\"z\", integer_type_node);\n+\n+  /* Test setting states on svalue_id instances directly.  */\n+  {\n+    region_model model;\n+    svalue_id sid_x = model.get_rvalue (x, NULL);\n+    svalue_id sid_y = model.get_rvalue (y, NULL);\n+    svalue_id sid_z = model.get_rvalue (z, NULL);\n+\n+    sm_state_map map;\n+    ASSERT_TRUE (map.is_empty_p ());\n+    ASSERT_EQ (map.get_state (sid_x), 0);\n+\n+    map.impl_set_state (sid_x, 42, sid_z);\n+    ASSERT_EQ (map.get_state (sid_x), 42);\n+    ASSERT_EQ (map.get_origin (sid_x), sid_z);\n+    ASSERT_EQ (map.get_state (sid_y), 0);\n+    ASSERT_FALSE (map.is_empty_p ());\n+\n+    map.impl_set_state (sid_y, 0, sid_z);\n+    ASSERT_EQ (map.get_state (sid_y), 0);\n+\n+    map.impl_set_state (sid_x, 0, sid_z);\n+    ASSERT_EQ (map.get_state (sid_x), 0);\n+    ASSERT_TRUE (map.is_empty_p ());\n+  }\n+\n+  /* Test setting states via equivalence classes.  */\n+  {\n+    region_model model;\n+    svalue_id sid_x = model.get_rvalue (x, NULL);\n+    svalue_id sid_y = model.get_rvalue (y, NULL);\n+    svalue_id sid_z = model.get_rvalue (z, NULL);\n+\n+    sm_state_map map;\n+    ASSERT_TRUE (map.is_empty_p ());\n+    ASSERT_EQ (map.get_state (sid_x), 0);\n+    ASSERT_EQ (map.get_state (sid_y), 0);\n+\n+    model.add_constraint (x, EQ_EXPR, y, NULL);\n+\n+    /* Setting x to a state should also update y, as they\n+       are in the same equivalence class.  */\n+    map.set_state (&model, sid_x, 5, sid_z);\n+    ASSERT_EQ (map.get_state (sid_x), 5);\n+    ASSERT_EQ (map.get_state (sid_y), 5);\n+    ASSERT_EQ (map.get_origin (sid_x), sid_z);\n+    ASSERT_EQ (map.get_origin (sid_y), sid_z);\n+  }\n+\n+  /* Test equality and hashing.  */\n+  {\n+    region_model model;\n+    svalue_id sid_y = model.get_rvalue (y, NULL);\n+    svalue_id sid_z = model.get_rvalue (z, NULL);\n+\n+    sm_state_map map0;\n+    sm_state_map map1;\n+    sm_state_map map2;\n+\n+    ASSERT_EQ (map0.hash (), map1.hash ());\n+    ASSERT_EQ (map0, map1);\n+\n+    map1.impl_set_state (sid_y, 5, sid_z);\n+    ASSERT_NE (map0.hash (), map1.hash ());\n+    ASSERT_NE (map0, map1);\n+\n+    /* Make the same change to map2.  */\n+    map2.impl_set_state (sid_y, 5, sid_z);\n+    ASSERT_EQ (map1.hash (), map2.hash ());\n+    ASSERT_EQ (map1, map2);\n+  }\n+\n+  /* Equality and hashing shouldn't depend on ordering.  */\n+  {\n+    sm_state_map map0;\n+    sm_state_map map1;\n+    sm_state_map map2;\n+\n+    ASSERT_EQ (map0.hash (), map1.hash ());\n+    ASSERT_EQ (map0, map1);\n+\n+    map1.impl_set_state (svalue_id::from_int (14), 2, svalue_id::null ());\n+    map1.impl_set_state (svalue_id::from_int (16), 3, svalue_id::null ());\n+    map1.impl_set_state (svalue_id::from_int (1), 2, svalue_id::null ());\n+    map1.impl_set_state (svalue_id::from_int (9), 2, svalue_id::null ());\n+\n+    map2.impl_set_state (svalue_id::from_int (1), 2, svalue_id::null ());\n+    map2.impl_set_state (svalue_id::from_int (16), 3, svalue_id::null ());\n+    map2.impl_set_state (svalue_id::from_int (14), 2, svalue_id::null ());\n+    map2.impl_set_state (svalue_id::from_int (9), 2, svalue_id::null ());\n+\n+    ASSERT_EQ (map1.hash (), map2.hash ());\n+    ASSERT_EQ (map1, map2);\n+  }\n+\n+  /* Test sm_state_map::remap_svalue_ids.  */\n+  {\n+    sm_state_map map;\n+    svalue_id sid_0 = svalue_id::from_int (0);\n+    svalue_id sid_1 = svalue_id::from_int (1);\n+    svalue_id sid_2 = svalue_id::from_int (2);\n+\n+    map.impl_set_state (sid_0, 42, sid_2);\n+    ASSERT_EQ (map.get_state (sid_0), 42);\n+    ASSERT_EQ (map.get_origin (sid_0), sid_2);\n+    ASSERT_EQ (map.get_state (sid_1), 0);\n+    ASSERT_EQ (map.get_state (sid_2), 0);\n+\n+    /* Apply a remapping to the IDs.  */\n+    svalue_id_map remapping (3);\n+    remapping.put (sid_0, sid_1);\n+    remapping.put (sid_1, sid_2);\n+    remapping.put (sid_2, sid_0);\n+    map.remap_svalue_ids (remapping);\n+\n+    /* Verify that the IDs have been remapped.  */\n+    ASSERT_EQ (map.get_state (sid_1), 42);\n+    ASSERT_EQ (map.get_origin (sid_1), sid_0);\n+    ASSERT_EQ (map.get_state (sid_2), 0);\n+    ASSERT_EQ (map.get_state (sid_0), 0);\n+  }\n+\n+  // TODO: coverage for purging\n+}\n+\n+/* Verify that program_states with identical sm-state can be merged,\n+   and that the merged program_state preserves the sm-state.  */\n+\n+static void\n+test_program_state_merging ()\n+{\n+  /* Create a program_state for a global ptr \"p\" that has\n+     malloc sm-state, pointing to a region on the heap.  */\n+  tree p = build_global_decl (\"p\", ptr_type_node);\n+\n+  auto_delete_vec <state_machine> checkers;\n+  checkers.safe_push (make_malloc_state_machine (NULL));\n+  extrinsic_state ext_state (checkers);\n+\n+  program_state s0 (ext_state);\n+  impl_region_model_context ctxt (&s0, NULL, ext_state);\n+\n+  region_model *model0 = s0.m_region_model;\n+  region_id new_rid = model0->add_new_malloc_region ();\n+  svalue_id ptr_sid\n+      = model0->get_or_create_ptr_svalue (ptr_type_node, new_rid);\n+  model0->set_value (model0->get_lvalue (p, &ctxt),\n+\t\t     ptr_sid, &ctxt);\n+  sm_state_map *smap = s0.m_checker_states[0];\n+  const state_machine::state_t TEST_STATE = 3;\n+  smap->impl_set_state (ptr_sid, TEST_STATE, svalue_id::null ());\n+  ASSERT_EQ (smap->get_state (ptr_sid), TEST_STATE);\n+\n+  model0->canonicalize (&ctxt);\n+\n+  /* Verify that canonicalization preserves sm-state.  */\n+  ASSERT_EQ (smap->get_state (model0->get_rvalue (p, NULL)), TEST_STATE);\n+\n+  /* Make a copy of the program_state.  */\n+  program_state s1 (s0);\n+  ASSERT_EQ (s0, s1);\n+\n+  /* We have two identical states with \"p\" pointing to a heap region\n+     with the given sm-state.\n+     They ought to be mergeable, preserving the sm-state.  */\n+  program_state merged (ext_state);\n+  ASSERT_TRUE (s0.can_merge_with_p (s1, ext_state, &merged));\n+  merged.validate (ext_state);\n+\n+  /* Verify that the merged state has the sm-state for \"p\".  */\n+  region_model *merged_model = merged.m_region_model;\n+  sm_state_map *merged_smap = merged.m_checker_states[0];\n+  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL)),\n+\t     TEST_STATE);\n+\n+  /* Try canonicalizing.  */\n+  impl_region_model_context merged_ctxt (&merged, NULL, ext_state);\n+  merged.m_region_model->canonicalize (&merged_ctxt);\n+  merged.validate (ext_state);\n+\n+  /* Verify that the merged state still has the sm-state for \"p\".  */\n+  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL)),\n+\t     TEST_STATE);\n+\n+  /* After canonicalization, we ought to have equality with the inputs.  */\n+  ASSERT_EQ (s0, merged);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+analyzer_program_state_cc_tests ()\n+{\n+  test_sm_state_map ();\n+  test_program_state_merging ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "75b65b780c91cf2e89a51afbf5da9e46af76f67f", "filename": "gcc/analyzer/program-state.h", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,363 @@\n+/* Classes for representing the state of interest at a given path of analysis.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_PROGRAM_STATE_H\n+#define GCC_ANALYZER_PROGRAM_STATE_H\n+\n+/* Data shared by all program_state instances.  */\n+\n+class extrinsic_state\n+{\n+public:\n+  extrinsic_state (auto_delete_vec <state_machine> &checkers)\n+  : m_checkers (checkers)\n+  {\n+  }\n+\n+  const state_machine &get_sm (int idx) const\n+  {\n+    return *m_checkers[idx];\n+  }\n+\n+  const char *get_name (int idx) const\n+  {\n+    return m_checkers[idx]->get_name ();\n+  }\n+\n+  unsigned get_num_checkers () const { return m_checkers.length (); }\n+\n+  /* The state machines.  */\n+  auto_delete_vec <state_machine> &m_checkers;\n+};\n+\n+template <> struct default_hash_traits<svalue_id>\n+: public pod_hash_traits<svalue_id>\n+{\n+  static const bool empty_zero_p = false;\n+};\n+\n+template <>\n+inline hashval_t\n+pod_hash_traits<svalue_id>::hash (value_type v)\n+{\n+  return v.as_int ();\n+}\n+\n+template <>\n+inline bool\n+pod_hash_traits<svalue_id>::equal (const value_type &existing,\n+\t\t\t\t   const value_type &candidate)\n+{\n+  return existing == candidate;\n+}\n+template <>\n+inline void\n+pod_hash_traits<svalue_id>::mark_deleted (value_type &v)\n+{\n+  v = svalue_id::from_int (-2);\n+}\n+template <>\n+inline void\n+pod_hash_traits<svalue_id>::mark_empty (value_type &v)\n+{\n+  v = svalue_id::null ();\n+}\n+template <>\n+inline bool\n+pod_hash_traits<svalue_id>::is_deleted (value_type v)\n+{\n+  return v.as_int () == -2;\n+}\n+template <>\n+inline bool\n+pod_hash_traits<svalue_id>::is_empty (value_type v)\n+{\n+  return v.null_p ();\n+}\n+\n+/* Map from svalue_id to state machine state, also capturing the origin of\n+   each state.  */\n+\n+class sm_state_map\n+{\n+public:\n+  /* An entry in the hash_map.  */\n+  struct entry_t\n+  {\n+    /* Default ctor needed by hash_map::empty.  */\n+    entry_t ()\n+    : m_state (0), m_origin (svalue_id::null ())\n+    {\n+    }\n+\n+    entry_t (state_machine::state_t state,\n+\t     svalue_id origin)\n+    : m_state (state), m_origin (origin)\n+    {}\n+\n+    bool operator== (const entry_t &other) const\n+    {\n+      return (m_state == other.m_state\n+\t      && m_origin == other.m_origin);\n+    }\n+    bool operator!= (const entry_t &other) const\n+    {\n+      return !(*this == other);\n+    }\n+\n+    state_machine::state_t m_state;\n+    svalue_id m_origin;\n+  };\n+  typedef hash_map <svalue_id, entry_t> map_t;\n+  typedef typename map_t::iterator iterator_t;\n+\n+  sm_state_map ();\n+\n+  sm_state_map *clone () const;\n+\n+  sm_state_map *\n+  clone_with_remapping (const one_way_svalue_id_map &id_map) const;\n+\n+  void print (const state_machine &sm, pretty_printer *pp) const;\n+  void dump (const state_machine &sm) const;\n+\n+  bool is_empty_p () const;\n+\n+  hashval_t hash () const;\n+\n+  bool operator== (const sm_state_map &other) const;\n+  bool operator!= (const sm_state_map &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  state_machine::state_t get_state (svalue_id sid) const;\n+  svalue_id get_origin (svalue_id sid) const;\n+\n+  void set_state (region_model *model,\n+\t\t  svalue_id sid,\n+\t\t  state_machine::state_t state,\n+\t\t  svalue_id origin);\n+  void set_state (const equiv_class &ec,\n+\t\t  state_machine::state_t state,\n+\t\t  svalue_id origin);\n+  void impl_set_state (svalue_id sid,\n+\t\t       state_machine::state_t state,\n+\t\t       svalue_id origin);\n+\n+  void set_global_state (state_machine::state_t state);\n+  state_machine::state_t get_global_state () const;\n+\n+  void purge_for_unknown_fncall (const exploded_graph &eg,\n+\t\t\t\t const state_machine &sm,\n+\t\t\t\t const gcall *call, tree fndecl,\n+\t\t\t\t region_model *new_model);\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+\n+  int on_svalue_purge (const state_machine &sm,\n+\t\t       int sm_idx,\n+\t\t       svalue_id first_unused_sid,\n+\t\t       const svalue_id_map &map,\n+\t\t       impl_region_model_context *ctxt);\n+\n+  void on_inherited_svalue (svalue_id parent_sid,\n+\t\t\t    svalue_id child_sid);\n+\n+  void on_cast (svalue_id src_sid,\n+\t\tsvalue_id dst_sid);\n+\n+  void validate (const state_machine &sm, int num_svalues) const;\n+\n+  iterator_t begin () const { return m_map.begin (); }\n+  iterator_t end () const { return m_map.end (); }\n+\n+private:\n+  map_t m_map;\n+  state_machine::state_t m_global_state;\n+};\n+\n+/* A class for representing the state of interest at a given path of\n+   analysis.\n+\n+   Currently this is a combination of:\n+   (a) a region_model, giving:\n+      (a.1) a hierarchy of memory regions\n+      (a.2) values for the regions\n+      (a.3) inequalities between values\n+   (b) sm_state_maps per state machine, giving a sparse mapping of\n+       values to states.  */\n+\n+class program_state\n+{\n+public:\n+  program_state (const extrinsic_state &ext_state);\n+  program_state (const program_state &other);\n+  program_state& operator= (const program_state &other);\n+\n+#if __cplusplus >= 201103\n+  program_state (program_state &&other);\n+  program_state& operator= (program_state &&other); // doesn't seem to be used\n+#endif\n+\n+  ~program_state ();\n+\n+  hashval_t hash () const;\n+  bool operator== (const program_state &other) const;\n+  bool operator!= (const program_state &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  void print (const extrinsic_state &ext_state,\n+\t      pretty_printer *pp) const;\n+\n+  void dump_to_pp (const extrinsic_state &ext_state, bool summarize,\n+\t\t   pretty_printer *pp) const;\n+  void dump_to_file (const extrinsic_state &ext_state, bool summarize,\n+\t\t     FILE *outf) const;\n+  void dump (const extrinsic_state &ext_state, bool summarize) const;\n+\n+  bool on_edge (exploded_graph &eg,\n+\t\tconst exploded_node &enode,\n+\t\tconst superedge *succ,\n+\t\tstate_change *change);\n+\n+  program_state prune_for_point (exploded_graph &eg,\n+\t\t\t\t const program_point &point,\n+\t\t\t\t state_change *change) const;\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+\n+  tree get_representative_tree (svalue_id sid) const;\n+\n+  bool can_purge_p (const extrinsic_state &ext_state,\n+\t\t    svalue_id sid)\n+  {\n+    /* Don't purge vars that have non-purgeable sm state, to avoid\n+       generating false \"leak\" complaints.  */\n+    int i;\n+    sm_state_map *smap;\n+    FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n+      {\n+\tconst state_machine &sm = ext_state.get_sm (i);\n+\tif (!sm.can_purge_p (smap->get_state (sid)))\n+\t  return false;\n+      }\n+    return true;\n+  }\n+\n+  bool can_merge_with_p (const program_state &other,\n+\t\t\t const extrinsic_state &ext_state,\n+\t\t\t program_state *out) const;\n+\n+  void validate (const extrinsic_state &ext_state) const;\n+\n+  /* TODO: lose the pointer here (const-correctness issues?).  */\n+  region_model *m_region_model;\n+  auto_delete_vec<sm_state_map> m_checker_states;\n+};\n+\n+/* An abstract base class for use with for_each_state_change.  */\n+\n+class state_change_visitor\n+{\n+public:\n+  virtual ~state_change_visitor () {}\n+\n+  /* Return true for early exit, false to keep iterating.  */\n+  virtual bool on_global_state_change (const state_machine &sm,\n+\t\t\t\t       state_machine::state_t src_sm_val,\n+\t\t\t\t       state_machine::state_t dst_sm_val) = 0;\n+\n+  /* Return true for early exit, false to keep iterating.  */\n+  virtual bool on_state_change (const state_machine &sm,\n+\t\t\t\tstate_machine::state_t src_sm_val,\n+\t\t\t\tstate_machine::state_t dst_sm_val,\n+\t\t\t\ttree dst_rep,\n+\t\t\t\tsvalue_id dst_origin_sid) = 0;\n+};\n+\n+extern bool for_each_state_change (const program_state &src_state,\n+\t\t\t\t   const program_state &dst_state,\n+\t\t\t\t   const extrinsic_state &ext_state,\n+\t\t\t\t   state_change_visitor *visitor);\n+\n+/* A class for recording \"interesting\" state changes.\n+   This is used for annotating edges in the GraphViz output of the\n+   exploded_graph, and for recording sm-state-changes, so that\n+   values that change aren't purged (to make it easier to generate\n+   state_change_event instances in the diagnostic_path).  */\n+\n+class state_change\n+{\n+ public:\n+  struct sm_change\n+  {\n+    sm_change (int sm_idx,\n+\t       svalue_id new_sid,\n+\t       state_machine::state_t old_state,\n+\t       state_machine::state_t new_state)\n+    : m_sm_idx (sm_idx),\n+      m_new_sid (new_sid),\n+      m_old_state (old_state), m_new_state (new_state)\n+    {}\n+\n+    const state_machine &get_sm (const extrinsic_state &ext_state) const\n+    {\n+      return ext_state.get_sm (m_sm_idx);\n+    }\n+\n+    void dump (pretty_printer *pp, const extrinsic_state &ext_state) const;\n+\n+    void remap_svalue_ids (const svalue_id_map &map);\n+    int on_svalue_purge (svalue_id first_unused_sid);\n+\n+    void validate (const program_state &new_state) const;\n+\n+    int m_sm_idx;\n+    svalue_id m_new_sid;\n+    state_machine::state_t m_old_state;\n+    state_machine::state_t m_new_state;\n+  };\n+\n+  state_change ();\n+  state_change (const state_change &other);\n+\n+  void add_sm_change (int sm_idx,\n+\t\t      svalue_id new_sid,\n+\t\t      state_machine::state_t old_state,\n+\t\t      state_machine::state_t new_state);\n+\n+  bool affects_p (svalue_id sid) const;\n+\n+  void dump (pretty_printer *pp, const extrinsic_state &ext_state) const;\n+  void dump (const extrinsic_state &ext_state) const;\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+  int on_svalue_purge (svalue_id first_unused_sid);\n+\n+  void validate (const program_state &new_state) const;\n+\n+ private:\n+  auto_vec<sm_change> m_sm_changes;\n+};\n+\n+#endif /* GCC_ANALYZER_PROGRAM_STATE_H */"}, {"sha": "2b0945a4ce8cf80722e785ba725f7bab24ef38fe", "filename": "gcc/analyzer/region-model.cc", "status": "added", "additions": 7785, "deletions": 0, "changes": 7785, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ec5282f6956cccf35af2d162701752dcc1772d7e", "filename": "gcc/analyzer/region-model.h", "status": "added", "additions": 2057, "deletions": 0, "changes": 2057, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,2057 @@\n+/* Classes for modeling the state of memory.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REGION_MODEL_H\n+#define GCC_ANALYZER_REGION_MODEL_H\n+\n+/* Implementation of the region-based ternary model described in:\n+     \"A Memory Model for Static Analysis of C Programs\"\n+      (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n+     http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf  */\n+\n+/* A tree, extended with stack frame information for locals, so that\n+   we can distinguish between different values of locals within a potentially\n+   recursive callstack.  */\n+// TODO: would this be better as a new tree code?\n+\n+class path_var\n+{\n+public:\n+  path_var (tree t, int stack_depth)\n+  : m_tree (t), m_stack_depth (stack_depth)\n+  {\n+    // TODO: ignore stack depth for globals and constants\n+  }\n+\n+  bool operator== (const path_var &other) const\n+  {\n+    return (m_tree == other.m_tree\n+\t    && m_stack_depth == other.m_stack_depth);\n+  }\n+\n+  void dump (pretty_printer *pp) const;\n+\n+  tree m_tree;\n+  int m_stack_depth; // or -1 for globals?\n+};\n+\n+namespace inchash\n+{\n+  extern void add_path_var (path_var pv, hash &hstate);\n+} // namespace inchash\n+\n+\n+/* A region_model is effectively a graph of regions and symbolic values.\n+   We store per-model IDs rather than pointers to make it easier to clone\n+   and to compare graphs.  */\n+\n+/* An ID for an svalue within a region_model.  Internally, this is an index\n+   into a vector of svalue * within the region_model.  */\n+\n+class svalue_id\n+{\n+public:\n+  static svalue_id null () { return svalue_id (-1); }\n+\n+  svalue_id () : m_idx (-1) {}\n+\n+  bool operator== (const svalue_id &other) const\n+  {\n+    return m_idx == other.m_idx;\n+  }\n+\n+  bool operator!= (const svalue_id &other) const\n+  {\n+    return m_idx != other.m_idx;\n+  }\n+\n+  bool null_p () const { return m_idx == -1; }\n+\n+  static svalue_id from_int (int idx) { return svalue_id (idx); }\n+  int as_int () const { return m_idx; }\n+\n+  void print (pretty_printer *pp) const;\n+  void dump_node_name_to_pp (pretty_printer *pp) const;\n+\n+  void validate (const region_model &model) const;\n+\n+private:\n+  svalue_id (int idx) : m_idx (idx) {}\n+\n+  int m_idx;\n+};\n+\n+/* An ID for a region within a region_model.  Internally, this is an index\n+   into a vector of region * within the region_model.  */\n+\n+class region_id\n+{\n+public:\n+  static region_id null () { return region_id (-1); }\n+\n+  region_id () : m_idx (-1) {}\n+\n+  bool operator== (const region_id &other) const\n+  {\n+    return m_idx == other.m_idx;\n+  }\n+\n+  bool operator!= (const region_id &other) const\n+  {\n+    return m_idx != other.m_idx;\n+  }\n+\n+  bool null_p () const { return m_idx == -1; }\n+\n+  static region_id from_int (int idx) { return region_id (idx); }\n+  int as_int () const { return m_idx; }\n+\n+  void print (pretty_printer *pp) const;\n+  void dump_node_name_to_pp (pretty_printer *pp) const;\n+\n+  void validate (const region_model &model) const;\n+\n+private:\n+  region_id (int idx) : m_idx (idx) {}\n+\n+  int m_idx;\n+};\n+\n+/* A class for renumbering IDs within a region_model, mapping old IDs\n+   to new IDs (e.g. when removing one or more elements, thus needing to\n+   renumber).  */\n+// TODO: could this be useful for equiv_class_ids?\n+\n+template <typename T>\n+class id_map\n+{\n+ public:\n+  id_map (int num_ids);\n+  void put (T src, T dst);\n+  T get_dst_for_src (T src) const;\n+  T get_src_for_dst (T dst) const;\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump () const;\n+  void update (T *) const;\n+\n+ private:\n+  auto_vec<T> m_src_to_dst;\n+  auto_vec<T> m_dst_to_src;\n+};\n+\n+typedef id_map<svalue_id> svalue_id_map;\n+typedef id_map<region_id> region_id_map;\n+\n+/* class id_map.  */\n+\n+/* id_map's ctor, which populates the map with dummy null values.  */\n+\n+template <typename T>\n+inline id_map<T>::id_map (int num_svalues)\n+: m_src_to_dst (num_svalues),\n+  m_dst_to_src (num_svalues)\n+{\n+  for (int i = 0; i < num_svalues; i++)\n+    {\n+      m_src_to_dst.quick_push (T::null ());\n+      m_dst_to_src.quick_push (T::null ());\n+    }\n+}\n+\n+/* Record that SRC is to be mapped to DST.  */\n+\n+template <typename T>\n+inline void\n+id_map<T>::put (T src, T dst)\n+{\n+  m_src_to_dst[src.as_int ()] = dst;\n+  m_dst_to_src[dst.as_int ()] = src;\n+}\n+\n+/* Get the new value for SRC within the map.  */\n+\n+template <typename T>\n+inline T\n+id_map<T>::get_dst_for_src (T src) const\n+{\n+  if (src.null_p ())\n+    return src;\n+  return m_src_to_dst[src.as_int ()];\n+}\n+\n+/* Given DST, a new value, determine which old value will be mapped to it\n+   (the inverse of the map).  */\n+\n+template <typename T>\n+inline T\n+id_map<T>::get_src_for_dst (T dst) const\n+{\n+  if (dst.null_p ())\n+    return dst;\n+  return m_dst_to_src[dst.as_int ()];\n+}\n+\n+/* Dump this id_map to PP.  */\n+\n+template <typename T>\n+inline void\n+id_map<T>::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_string (pp, \"src to dst: {\");\n+  unsigned i;\n+  T *dst;\n+  FOR_EACH_VEC_ELT (m_src_to_dst, i, dst)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      T src (T::from_int (i));\n+      src.print (pp);\n+      pp_string (pp, \" -> \");\n+      dst->print (pp);\n+    }\n+  pp_string (pp, \"}\");\n+  pp_newline (pp);\n+\n+  pp_string (pp, \"dst to src: {\");\n+  T *src;\n+  FOR_EACH_VEC_ELT (m_dst_to_src, i, src)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      T dst (T::from_int (i));\n+      dst.print (pp);\n+      pp_string (pp, \" <- \");\n+      src->print (pp);\n+    }\n+  pp_string (pp, \"}\");\n+  pp_newline (pp);\n+}\n+\n+/* Dump this id_map to stderr.  */\n+\n+template <typename T>\n+DEBUG_FUNCTION inline void\n+id_map<T>::dump () const\n+{\n+  pretty_printer pp;\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Update *ID from the old value to its new value in this map.  */\n+\n+template <typename T>\n+inline void\n+id_map<T>::update (T *id) const\n+{\n+  *id = get_dst_for_src (*id);\n+}\n+\n+/* Variant of the above, which only stores things in one direction.\n+   (e.g. for merging, when the number of destination regions is not\n+   the same of the src regions, and can grow).  */\n+\n+template <typename T>\n+class one_way_id_map\n+{\n+ public:\n+  one_way_id_map (int num_ids);\n+  void put (T src, T dst);\n+  T get_dst_for_src (T src) const;\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump () const;\n+  void update (T *) const;\n+\n+ private:\n+  auto_vec<T> m_src_to_dst;\n+};\n+\n+typedef one_way_id_map<svalue_id> one_way_svalue_id_map;\n+typedef one_way_id_map<region_id> one_way_region_id_map;\n+\n+/* class one_way_id_map.  */\n+\n+/* one_way_id_map's ctor, which populates the map with dummy null values.  */\n+\n+template <typename T>\n+inline one_way_id_map<T>::one_way_id_map (int num_svalues)\n+: m_src_to_dst (num_svalues)\n+{\n+  for (int i = 0; i < num_svalues; i++)\n+    m_src_to_dst.quick_push (T::null ());\n+}\n+\n+/* Record that SRC is to be mapped to DST.  */\n+\n+template <typename T>\n+inline void\n+one_way_id_map<T>::put (T src, T dst)\n+{\n+  m_src_to_dst[src.as_int ()] = dst;\n+}\n+\n+/* Get the new value for SRC within the map.  */\n+\n+template <typename T>\n+inline T\n+one_way_id_map<T>::get_dst_for_src (T src) const\n+{\n+  if (src.null_p ())\n+    return src;\n+  return m_src_to_dst[src.as_int ()];\n+}\n+\n+/* Dump this map to PP.  */\n+\n+template <typename T>\n+inline void\n+one_way_id_map<T>::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_string (pp, \"src to dst: {\");\n+  unsigned i;\n+  T *dst;\n+  FOR_EACH_VEC_ELT (m_src_to_dst, i, dst)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      T src (T::from_int (i));\n+      src.print (pp);\n+      pp_string (pp, \" -> \");\n+      dst->print (pp);\n+    }\n+  pp_string (pp, \"}\");\n+  pp_newline (pp);\n+}\n+\n+/* Dump this map to stderr.  */\n+\n+template <typename T>\n+DEBUG_FUNCTION inline void\n+one_way_id_map<T>::dump () const\n+{\n+  pretty_printer pp;\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Update *ID from the old value to its new value in this map.  */\n+\n+template <typename T>\n+inline void\n+one_way_id_map<T>::update (T *id) const\n+{\n+  *id = get_dst_for_src (*id);\n+}\n+\n+/* A set of IDs within a region_model (either svalue_id or region_id).  */\n+\n+template <typename T>\n+class id_set\n+{\n+public:\n+  id_set (const region_model *model);\n+\n+  void add_region (T id)\n+  {\n+    if (!id.null_p ())\n+      bitmap_set_bit (m_bitmap, id.as_int ());\n+  }\n+\n+  bool region_p (T id) const\n+  {\n+    gcc_assert (!id.null_p ());\n+    return bitmap_bit_p (const_cast <auto_sbitmap &> (m_bitmap),\n+\t\t\t id.as_int ());\n+  }\n+\n+  unsigned int num_regions ()\n+  {\n+    return bitmap_count_bits (m_bitmap);\n+  }\n+\n+private:\n+  auto_sbitmap m_bitmap;\n+};\n+\n+typedef id_set<region_id> region_id_set;\n+\n+/* Various operations delete information from a region_model.\n+\n+   This struct tracks how many of each kind of entity were purged (e.g.\n+   for selftests, and for debugging).  */\n+\n+struct purge_stats\n+{\n+  purge_stats ()\n+  : m_num_svalues (0),\n+    m_num_regions (0),\n+    m_num_equiv_classes (0),\n+    m_num_constraints (0),\n+    m_num_client_items (0)\n+  {}\n+\n+  int m_num_svalues;\n+  int m_num_regions;\n+  int m_num_equiv_classes;\n+  int m_num_constraints;\n+  int m_num_client_items;\n+};\n+\n+/* An enum for discriminating between the different concrete subclasses\n+   of svalue.  */\n+\n+enum svalue_kind\n+{\n+  SK_REGION,\n+  SK_CONSTANT,\n+  SK_UNKNOWN,\n+  SK_POISONED,\n+  SK_SETJMP\n+};\n+\n+/* svalue and its subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with svalue_kinds shown for the concrete subclasses):\n+\n+   svalue\n+     region_svalue (SK_REGION)\n+     constant_svalue (SK_CONSTANT)\n+     unknown_svalue (SK_UNKNOWN)\n+     poisoned_svalue (SK_POISONED)\n+     setjmp_svalue (SK_SETJMP).  */\n+\n+/* An abstract base class representing a value held by a region of memory.  */\n+\n+class svalue\n+{\n+public:\n+  virtual ~svalue () {}\n+\n+  bool operator== (const svalue &other) const;\n+  bool operator!= (const svalue &other) const { return !(*this == other); }\n+\n+  virtual svalue *clone () const = 0;\n+\n+  tree get_type () const { return m_type; }\n+\n+  virtual enum svalue_kind get_kind () const = 0;\n+\n+  hashval_t hash () const;\n+\n+  void print (const region_model &model,\n+\t      svalue_id this_sid,\n+\t      pretty_printer *pp) const;\n+\n+  virtual void dump_dot_to_pp (const region_model &model,\n+\t\t\t       svalue_id this_sid,\n+\t\t\t       pretty_printer *pp) const;\n+\n+  virtual region_svalue *dyn_cast_region_svalue () { return NULL; }\n+  virtual constant_svalue *dyn_cast_constant_svalue () { return NULL; }\n+  virtual const constant_svalue *dyn_cast_constant_svalue () const\n+  { return NULL; }\n+  virtual poisoned_svalue *dyn_cast_poisoned_svalue () { return NULL; }\n+  virtual unknown_svalue *dyn_cast_unknown_svalue () { return NULL; }\n+  virtual setjmp_svalue *dyn_cast_setjmp_svalue () { return NULL; }\n+\n+  virtual void remap_region_ids (const region_id_map &map);\n+\n+  virtual void walk_for_canonicalization (canonicalization *c) const;\n+\n+  virtual svalue_id get_child_sid (region *parent, region *child,\n+\t\t\t\t   region_model &model,\n+\t\t\t\t   region_model_context *ctxt);\n+\n+  tree maybe_get_constant () const;\n+\n+ protected:\n+  svalue (tree type) : m_type (type) {}\n+\n+  virtual void add_to_hash (inchash::hash &hstate) const = 0;\n+\n+ private:\n+  virtual void print_details (const region_model &model,\n+\t\t\t      svalue_id this_sid,\n+\t\t\t      pretty_printer *pp) const = 0;\n+  tree m_type;\n+};\n+\n+/* Concrete subclass of svalue representing a pointer value that points to\n+   a known region  */\n+\n+class region_svalue : public svalue\n+{\n+public:\n+  region_svalue (tree type, region_id rid) : svalue (type), m_rid (rid)\n+  {\n+    /* Should we support NULL ptrs here?  */\n+    gcc_assert (!rid.null_p ());\n+  }\n+\n+  bool compare_fields (const region_svalue &other) const;\n+\n+  svalue *clone () const FINAL OVERRIDE\n+  { return new region_svalue (get_type (), m_rid); }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_REGION; }\n+\n+  void dump_dot_to_pp (const region_model &model,\n+\t\t       svalue_id this_sid,\n+\t\t       pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  region_svalue *dyn_cast_region_svalue () FINAL OVERRIDE { return this; }\n+\n+  region_id get_pointee () const { return m_rid; }\n+\n+  void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n+\n+  static void merge_values (const region_svalue &region_sval_a,\n+\t\t\t    const region_svalue &region_sval_b,\n+\t\t\t    svalue_id *merged_sid,\n+\t\t\t    tree type,\n+\t\t\t    model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  static tristate eval_condition (region_svalue *lhs_ptr,\n+\t\t\t\t  enum tree_code op,\n+\t\t\t\t  region_svalue *rhs_ptr);\n+\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+ private:\n+  void print_details (const region_model &model,\n+\t\t      svalue_id this_sid,\n+\t\t      pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  region_id m_rid;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <region_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_REGION;\n+}\n+\n+/* Concrete subclass of svalue representing a specific constant value.  */\n+\n+class constant_svalue : public svalue\n+{\n+public:\n+  constant_svalue (tree cst_expr)\n+  : svalue (TREE_TYPE (cst_expr)), m_cst_expr (cst_expr)\n+  {\n+    gcc_assert (cst_expr);\n+    gcc_assert (CONSTANT_CLASS_P (cst_expr));\n+  }\n+\n+  bool compare_fields (const constant_svalue &other) const;\n+\n+  svalue *clone () const FINAL OVERRIDE\n+  { return new constant_svalue (m_cst_expr); }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_CONSTANT; }\n+\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+  constant_svalue *dyn_cast_constant_svalue () FINAL OVERRIDE { return this; }\n+  const constant_svalue *dyn_cast_constant_svalue () const FINAL OVERRIDE\n+  { return this; }\n+\n+  tree get_constant () const { return m_cst_expr; }\n+\n+  static void merge_values (const constant_svalue &cst_sval_a,\n+\t\t\t    const constant_svalue &cst_sval_b,\n+\t\t\t    svalue_id *merged_sid,\n+\t\t\t    model_merger *merger);\n+\n+  static tristate eval_condition (constant_svalue *lhs,\n+\t\t\t\t  enum tree_code op,\n+\t\t\t\t  constant_svalue *rhs);\n+\n+  svalue_id get_child_sid (region *parent, region *child,\n+\t\t\t   region_model &model,\n+\t\t\t   region_model_context *ctxt) FINAL OVERRIDE;\n+\n+ private:\n+  void print_details (const region_model &model,\n+\t\t      svalue_id this_sid,\n+\t\t      pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  tree m_cst_expr;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <constant_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_CONSTANT;\n+}\n+\n+/* Concrete subclass of svalue representing a unique but unknown value.\n+   Comparisons of variables that share the same unknown value are known\n+   to be equal, even if we don't know what the value is.  */\n+\n+class unknown_svalue : public svalue\n+{\n+public:\n+  unknown_svalue (tree type)\n+  : svalue (type)\n+  {}\n+\n+  bool compare_fields (const unknown_svalue &other) const;\n+\n+  svalue *clone () const FINAL OVERRIDE\n+  { return new unknown_svalue (get_type ()); }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_UNKNOWN; }\n+\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+  unknown_svalue *dyn_cast_unknown_svalue () FINAL OVERRIDE { return this; }\n+\n+ private:\n+  void print_details (const region_model &model,\n+\t\t      svalue_id this_sid,\n+\t\t      pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+};\n+\n+/* An enum describing a particular kind of \"poisoned\" value.  */\n+\n+enum poison_kind\n+{\n+  /* For use to describe uninitialized memory.  */\n+  POISON_KIND_UNINIT,\n+\n+  /* For use to describe freed memory.  */\n+  POISON_KIND_FREED,\n+\n+  /* For use on pointers to regions within popped stack frames.  */\n+  POISON_KIND_POPPED_STACK\n+};\n+\n+extern const char *poison_kind_to_str (enum poison_kind);\n+\n+/* Concrete subclass of svalue representing a value that should not\n+   be used (e.g. uninitialized memory, freed memory).  */\n+\n+class poisoned_svalue : public svalue\n+{\n+public:\n+  poisoned_svalue (enum poison_kind kind, tree type)\n+  : svalue (type), m_kind (kind) {}\n+\n+  bool compare_fields (const poisoned_svalue &other) const;\n+\n+  svalue *clone () const FINAL OVERRIDE\n+  { return new poisoned_svalue (m_kind, get_type ()); }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_POISONED; }\n+\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+  poisoned_svalue *dyn_cast_poisoned_svalue () FINAL OVERRIDE { return this; }\n+\n+  enum poison_kind get_poison_kind () const { return m_kind; }\n+\n+ private:\n+  void print_details (const region_model &model,\n+\t\t      svalue_id this_sid,\n+\t\t      pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  enum poison_kind m_kind;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <poisoned_svalue *>::test (svalue *sval)\n+{\n+  return sval->get_kind () == SK_POISONED;\n+}\n+\n+/* Concrete subclass of svalue representing setjmp buffers, so that\n+   longjmp can potentially \"return\" to an entirely different function.  */\n+\n+class setjmp_svalue : public svalue\n+{\n+public:\n+  setjmp_svalue (const exploded_node *enode, tree type)\n+  : svalue (type), m_enode (enode)\n+  {}\n+\n+  bool compare_fields (const setjmp_svalue &other) const;\n+\n+  svalue *clone () const FINAL OVERRIDE\n+  { return new setjmp_svalue (m_enode, get_type ()); }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_SETJMP; }\n+\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+  setjmp_svalue *dyn_cast_setjmp_svalue () FINAL OVERRIDE { return this; }\n+\n+  int get_index () const;\n+\n+  const exploded_node *get_exploded_node () const { return m_enode; }\n+\n+ private:\n+  void print_details (const region_model &model,\n+\t\t      svalue_id this_sid,\n+\t\t      pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  const exploded_node *m_enode;\n+};\n+\n+/* An enum for discriminating between the different concrete subclasses\n+   of region.  */\n+\n+enum region_kind\n+{\n+  RK_PRIMITIVE,\n+  RK_STRUCT,\n+  RK_UNION,\n+  RK_FRAME,\n+  RK_GLOBALS,\n+  RK_CODE,\n+  RK_FUNCTION,\n+  RK_ARRAY,\n+  RK_STACK,\n+  RK_HEAP,\n+  RK_ROOT,\n+  RK_SYMBOLIC\n+};\n+\n+extern const char *region_kind_to_str (enum region_kind);\n+\n+/* Region and its subclasses.\n+\n+   The class hierarchy looks like this (using indentation to show\n+   inheritance, and with region_kinds shown for the concrete subclasses):\n+\n+   region\n+     primitive_region (RK_PRIMITIVE)\n+     map_region\n+       struct_or_union_region\n+         struct_region (RK_STRUCT)\n+         union_region (RK_UNION)\n+       scope_region\n+         frame_region (RK_FRAME)\n+         globals_region (RK_GLOBALS)\n+       code_region (RK_CODE)\n+       function_region (RK_FUNCTION)\n+     array_region (RK_ARRAY)\n+     stack_region (RK_STACK)\n+     heap_region (RK_HEAP)\n+     root_region (RK_ROOT)\n+     label_region (RK_FUNCTION)\n+     symbolic_region (RK_SYMBOLIC).  */\n+\n+/* Abstract base class representing a chunk of memory.\n+\n+   Regions form a tree-like hierarchy, with a root region at the base,\n+   with memory space regions within it, representing the stack and\n+   globals, with frames within the stack, and regions for variables\n+   within the frames and the \"globals\" region.  Regions for structs\n+   can have subregions for fields.\n+\n+   A region can optionally have a value, or inherit its value from\n+   the first ancestor with a value.  For example, the stack region\n+   has a \"uninitialized\" poison value which is inherited by all\n+   descendent regions that don't themselves have a value.  */\n+\n+class region\n+{\n+public:\n+  virtual ~region () {}\n+\n+  bool operator== (const region &other) const;\n+  bool operator!= (const region &other) const { return !(*this == other); }\n+\n+  virtual region *clone () const = 0;\n+\n+  virtual enum region_kind get_kind () const = 0;\n+  virtual map_region *dyn_cast_map_region () { return NULL; }\n+  virtual const symbolic_region *dyn_cast_symbolic_region () const\n+  { return NULL; }\n+\n+  region_id get_parent () const { return m_parent_rid; }\n+  region *get_parent_region (const region_model &model) const;\n+\n+  void set_value (region_model &model, region_id this_rid, svalue_id rhs_sid,\n+\t\t  region_model_context *ctxt);\n+  svalue_id get_value (region_model &model, bool non_null,\n+\t\t       region_model_context *ctxt);\n+  svalue_id get_value_direct () const { return m_sval_id; }\n+\n+  svalue_id get_inherited_child_sid (region *child,\n+\t\t\t\t     region_model &model,\n+\t\t\t\t     region_model_context *ctxt);\n+\n+  tree get_type () const { return m_type; }\n+\n+  hashval_t hash () const;\n+\n+  void print (const region_model &model,\n+\t      region_id this_rid,\n+\t      pretty_printer *pp) const;\n+\n+  virtual void dump_dot_to_pp (const region_model &model,\n+\t\t\t       region_id this_rid,\n+\t\t\t       pretty_printer *pp) const;\n+\n+  void dump_to_pp (const region_model &model,\n+\t\t   region_id this_rid,\n+\t\t   pretty_printer *pp,\n+\t\t   const char *prefix,\n+\t\t   bool is_last_child) const;\n+  virtual void dump_child_label (const region_model &model,\n+\t\t\t\t region_id this_rid,\n+\t\t\t\t region_id child_rid,\n+\t\t\t\t pretty_printer *pp) const;\n+\n+  void remap_svalue_ids (const svalue_id_map &map);\n+  virtual void remap_region_ids (const region_id_map &map);\n+\n+  virtual void walk_for_canonicalization (canonicalization *c) const = 0;\n+\n+  void add_view (region_id view_rid, region_model *model);\n+  region_id get_view (tree type, region_model *model) const;\n+  bool is_view_p () const { return m_is_view; }\n+\n+  void validate (const region_model *model) const;\n+\n+  bool non_null_p (const region_model &model) const;\n+\n+ protected:\n+  region (region_id parent_rid, svalue_id sval_id, tree type);\n+  region (const region &other);\n+\n+  virtual void add_to_hash (inchash::hash &hstate) const;\n+  virtual void print_fields (const region_model &model,\n+\t\t\t     region_id this_rid,\n+\t\t\t     pretty_printer *pp) const;\n+\n+ private:\n+  void become_active_view (region_model &model, region_id this_rid);\n+  void deactivate_any_active_view (region_model &model);\n+  void deactivate_view (region_model &model, region_id this_view_rid);\n+\n+  region_id m_parent_rid;\n+  svalue_id m_sval_id;\n+  tree m_type;\n+  /* Child regions that are \"views\" (one per type).  */\n+  auto_vec<region_id> m_view_rids;\n+\n+  bool m_is_view;\n+  region_id m_active_view_rid;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <region *>::test (region *)\n+{\n+  return true;\n+}\n+\n+/* Concrete region subclass for storing \"primitive\" types (integral types,\n+   pointers, etc).  */\n+\n+class primitive_region : public region\n+{\n+public:\n+  primitive_region (region_id parent_rid, tree type)\n+  : region (parent_rid, svalue_id::null (), type)\n+  {}\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_PRIMITIVE; }\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+};\n+\n+/* A region that has children identified by tree keys.\n+   For example a stack frame has subregions per local, and a region\n+   for a struct has subregions per field.  */\n+\n+class map_region : public region\n+{\n+public:\n+  typedef ordered_hash_map<tree, region_id> map_t;\n+  typedef map_t::iterator iterator_t;\n+\n+  map_region (region_id parent_rid, tree type)\n+  : region (parent_rid, svalue_id::null (), type)\n+  {}\n+  map_region (const map_region &other);\n+\n+  map_region *dyn_cast_map_region () FINAL OVERRIDE { return this; }\n+\n+  void dump_dot_to_pp (const region_model &model,\n+\t\t       region_id this_rid,\n+\t\t       pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  void dump_child_label (const region_model &model,\n+\t\t\t region_id this_rid,\n+\t\t\t region_id child_rid,\n+\t\t\t pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  region_id get_or_create (region_model *model,\n+\t\t\t   region_id this_rid,\n+\t\t\t   tree expr, tree type);\n+  void unbind (tree expr);\n+  region_id *get (tree expr);\n+\n+  void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n+\n+  tree get_tree_for_child_region (region_id child_rid) const;\n+\n+  tree get_tree_for_child_region (region *child,\n+\t\t\t\t  const region_model &model) const;\n+\n+  static bool can_merge_p (const map_region *map_region_a,\n+\t\t\t   const map_region *map_region_b,\n+\t\t\t   map_region *merged_map_region,\n+\t\t\t   region_id merged_rid,\n+\t\t\t   model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  virtual bool valid_key_p (tree key) const = 0;\n+\n+  svalue_id get_value_by_name (tree identifier,\n+\t\t\t       const region_model &model) const;\n+\n+  iterator_t begin () { return m_map.begin (); }\n+  iterator_t end () { return m_map.end (); }\n+  size_t elements () const { return m_map.elements (); }\n+\n+ protected:\n+  bool compare_fields (const map_region &other) const;\n+  void add_to_hash (inchash::hash &hstate) const OVERRIDE;\n+  void print_fields (const region_model &model,\n+\t\t     region_id this_rid,\n+\t\t     pretty_printer *pp) const\n+    OVERRIDE;\n+\n+ private:\n+  /* Mapping from tree to child region.  */\n+  map_t m_map;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <map_region *>::test (region *reg)\n+{\n+  return (reg->dyn_cast_map_region () != NULL);\n+}\n+\n+/* Abstract subclass representing a region with fields\n+   (either a struct or a union).  */\n+\n+class struct_or_union_region : public map_region\n+{\n+public:\n+  bool valid_key_p (tree key) const FINAL OVERRIDE;\n+\n+ protected:\n+  struct_or_union_region (region_id parent_rid, tree type)\n+  : map_region (parent_rid, type)\n+  {}\n+\n+  bool compare_fields (const struct_or_union_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <struct_or_union_region *>::test (region *reg)\n+{\n+  return (reg->get_kind () == RK_STRUCT\n+\t  || reg->get_kind () == RK_UNION);\n+}\n+\n+/* Concrete region subclass.  A map_region representing a struct, using\n+   FIELD_DECLs for its keys.  */\n+\n+class struct_region : public struct_or_union_region\n+{\n+public:\n+  struct_region (region_id parent_rid, tree type)\n+  : struct_or_union_region (parent_rid, type)\n+  {\n+    gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+  }\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STRUCT; }\n+\n+  bool compare_fields (const struct_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <struct_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_STRUCT;\n+}\n+\n+/* Concrete region subclass.  A map_region representing a union, using\n+   FIELD_DECLs for its keys.  */\n+\n+class union_region : public struct_or_union_region\n+{\n+public:\n+  union_region (region_id parent_rid, tree type)\n+  : struct_or_union_region (parent_rid, type)\n+  {\n+    gcc_assert (TREE_CODE (type) == UNION_TYPE);\n+  }\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_UNION; }\n+\n+  bool compare_fields (const union_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <union_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_UNION;\n+}\n+\n+/* Abstract map_region subclass for accessing decls, used as a base class\n+   for function frames and for the globals region.  */\n+\n+class scope_region : public map_region\n+{\n+ public:\n+\n+ protected:\n+  scope_region (region_id parent_rid)\n+  : map_region (parent_rid, NULL_TREE)\n+  {}\n+\n+  scope_region (const scope_region &other)\n+  : map_region (other)\n+  {\n+  }\n+\n+  bool compare_fields (const scope_region &other) const;\n+};\n+\n+/* Concrete region subclass, representing a function frame on the stack,\n+   to contain the locals.  */\n+\n+class frame_region : public scope_region\n+{\n+public:\n+  frame_region (region_id parent_rid, function *fun, int depth)\n+  : scope_region (parent_rid), m_fun (fun), m_depth (depth)\n+  {}\n+\n+  frame_region (const frame_region &other)\n+  : scope_region (other), m_fun (other.m_fun), m_depth (other.m_depth)\n+  {\n+  }\n+\n+  /* region vfuncs.  */\n+  region *clone () const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FRAME; }\n+  void print_fields (const region_model &model,\n+\t\t     region_id this_rid,\n+\t\t     pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+\n+  /* map_region vfuncs.  */\n+  bool valid_key_p (tree key) const FINAL OVERRIDE;\n+\n+  /* Accessors.  */\n+  function *get_function () const { return m_fun; }\n+  int get_depth () const { return m_depth; }\n+\n+  bool compare_fields (const frame_region &other) const;\n+\n+ private:\n+  function *m_fun;\n+  int m_depth;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <frame_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_FRAME;\n+}\n+\n+/* Concrete region subclass, to hold global variables (data and bss).  */\n+\n+class globals_region : public scope_region\n+{\n+ public:\n+  globals_region (region_id parent_rid)\n+  : scope_region (parent_rid)\n+  {}\n+\n+  globals_region (const globals_region &other)\n+  : scope_region (other)\n+  {\n+  }\n+\n+  /* region vfuncs.  */\n+  region *clone () const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_GLOBALS; }\n+\n+  /* map_region vfuncs.  */\n+  bool valid_key_p (tree key) const FINAL OVERRIDE;\n+\n+  bool compare_fields (const globals_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <globals_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_GLOBALS;\n+}\n+\n+/* Concrete region subclass.  A map_region representing the code, using\n+   FUNCTION_DECLs for its keys.  */\n+\n+class code_region : public map_region\n+{\n+public:\n+  code_region (region_id parent_rid)\n+  : map_region (parent_rid, NULL_TREE)\n+  {}\n+  code_region (const code_region &other)\n+  : map_region (other)\n+  {}\n+\n+  /* region vfuncs.  */\n+  region *clone () const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_CODE; }\n+\n+  /* map_region vfunc.  */\n+  bool valid_key_p (tree key) const FINAL OVERRIDE;\n+\n+  region_id get_element (region_model *model,\n+\t\t\t region_id this_rid,\n+\t\t\t svalue_id index_sid,\n+\t\t\t region_model_context *ctxt);\n+\n+  bool compare_fields (const code_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <code_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_CODE;\n+}\n+\n+/* Concrete region subclass.  A map_region representing the code for\n+   a particular function, using LABEL_DECLs for its keys.  */\n+\n+class function_region : public map_region\n+{\n+public:\n+  function_region (region_id parent_rid, tree type)\n+  : map_region (parent_rid, type)\n+  {\n+    gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n+  }\n+  function_region (const function_region &other)\n+  : map_region (other)\n+  {}\n+\n+  /* region vfuncs.  */\n+  region *clone () const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_FUNCTION; }\n+\n+  /* map_region vfunc.  */\n+  bool valid_key_p (tree key) const FINAL OVERRIDE;\n+\n+  region_id get_element (region_model *model,\n+\t\t\t region_id this_rid,\n+\t\t\t svalue_id index_sid,\n+\t\t\t region_model_context *ctxt);\n+\n+  bool compare_fields (const function_region &other) const;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <function_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_FUNCTION;\n+}\n+\n+/* Concrete region subclass representing an array (or an array-like view\n+   of a parent region of memory.\n+   This can't be a map_region as we can't use trees as the keys: there's\n+   no guarantee about the uniqueness of an INTEGER_CST.  */\n+\n+class array_region : public region\n+{\n+public:\n+#if 0\n+  wide_int m_test;\n+\n+  typedef wide_int key_t;\n+  typedef int_hash <wide_int, -1, -2> hash_t;\n+  typedef ordered_hash_map<hash_t, region_id> map_t;\n+#else\n+  typedef int key_t;\n+  typedef int_hash <int, -1, -2> int_hash_t;\n+  typedef ordered_hash_map<int_hash_t, region_id> map_t;\n+#endif\n+  typedef map_t::iterator iterator_t;\n+\n+  array_region (region_id parent_rid, tree type)\n+  : region (parent_rid, svalue_id::null (), type)\n+  {\n+    gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+  }\n+  array_region (const array_region &other);\n+\n+  void dump_dot_to_pp (const region_model &model,\n+\t\t       region_id this_rid,\n+\t\t       pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  void dump_child_label (const region_model &model,\n+\t\t\t region_id this_rid,\n+\t\t\t region_id child_rid,\n+\t\t\t pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  /* region vfuncs.  */\n+  region *clone () const FINAL OVERRIDE;\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ARRAY; }\n+\n+  region_id get_element (region_model *model,\n+\t\t\t region_id this_rid,\n+\t\t\t svalue_id index_sid,\n+\t\t\t region_model_context *ctxt);\n+\n+  bool compare_fields (const array_region &other) const;\n+\n+  static bool can_merge_p (const array_region *array_region_a,\n+\t\t\t   const array_region *array_region_b,\n+\t\t\t   array_region *merged_array_region,\n+\t\t\t   region_id merged_rid,\n+\t\t\t   model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  iterator_t begin () { return m_map.begin (); }\n+  iterator_t end () { return m_map.end (); }\n+  size_t elements () const { return m_map.elements (); }\n+\n+  region_id get_or_create (region_model *model,\n+\t\t\t   region_id this_rid,\n+\t\t\t   key_t key, tree type);\n+//  void unbind (int expr);\n+  region_id *get (key_t key);\n+\n+  void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n+\n+  bool get_key_for_child_region (region_id child_rid,\n+\t\t\t\t key_t *out) const;\n+\n+#if 0\n+  bool get_key_for_child_region (region *child,\n+\t\t\t\t const region_model &model,\n+\t\t\t\t key_t *out) const;\n+#endif\n+\n+  void add_to_hash (inchash::hash &hstate) const OVERRIDE;\n+  void print_fields (const region_model &model,\n+\t\t     region_id this_rid,\n+\t\t     pretty_printer *pp) const\n+    OVERRIDE;\n+\n+  static key_t key_from_constant (tree cst);\n+\n+ private:\n+  /* Mapping from tree to child region.  */\n+  map_t m_map;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <array_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_ARRAY;\n+}\n+\n+/* Concrete region subclass representing a stack, containing all stack\n+   frames, and implicitly providing a POISON_KIND_UNINIT value to all\n+   child regions by default.  */\n+\n+class stack_region : public region\n+{\n+public:\n+  stack_region (region_id parent_rid, svalue_id sval_id)\n+  : region (parent_rid, sval_id, NULL_TREE)\n+  {}\n+\n+  stack_region (const stack_region &other);\n+\n+  bool compare_fields (const stack_region &other) const;\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_STACK; }\n+\n+  void dump_child_label (const region_model &model,\n+\t\t\t region_id this_rid,\n+\t\t\t region_id child_rid,\n+\t\t\t pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  void push_frame (region_id frame_rid);\n+  region_id get_current_frame_id () const;\n+  svalue_id pop_frame (region_model *model, bool purge, purge_stats *stats,\n+\t\t       region_model_context *ctxt);\n+\n+  void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n+\n+  unsigned get_num_frames () const { return m_frame_rids.length (); }\n+  region_id get_frame_rid (unsigned i) const { return m_frame_rids[i]; }\n+\n+  static bool can_merge_p (const stack_region *stack_region_a,\n+\t\t\t   const stack_region *stack_region_b,\n+\t\t\t   model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  svalue_id get_value_by_name (tree identifier,\n+\t\t\t       const region_model &model) const;\n+\n+ private:\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+  void print_fields (const region_model &model,\n+\t\t     region_id this_rid,\n+\t\t     pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  auto_vec<region_id> m_frame_rids;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <stack_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_STACK;\n+}\n+\n+/* Concrete region subclass: a region within which regions can be\n+   dynamically allocated.  */\n+\n+class heap_region : public region\n+{\n+public:\n+  heap_region (region_id parent_rid, svalue_id sval_id)\n+  : region (parent_rid, sval_id, NULL_TREE)\n+  {}\n+  heap_region (const heap_region &other);\n+\n+  bool compare_fields (const heap_region &other) const;\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_HEAP; }\n+\n+  static bool can_merge_p (const heap_region *heap_a, region_id heap_a_rid,\n+\t\t\t   const heap_region *heap_b, region_id heap_b_rid,\n+\t\t\t   heap_region *merged_heap, region_id merged_heap_rid,\n+\t\t\t   model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <heap_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_HEAP;\n+}\n+\n+/* Concrete region subclass.  The root region, containing all regions\n+   (either directly, or as descendents).\n+   Unique within a region_model.  */\n+\n+class root_region : public region\n+{\n+public:\n+  root_region ();\n+  root_region (const root_region &other);\n+\n+  bool compare_fields (const root_region &other) const;\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_ROOT; }\n+\n+  void dump_child_label (const region_model &model,\n+\t\t\t region_id this_rid,\n+\t\t\t region_id child_rid,\n+\t\t\t pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  region_id push_frame (region_model *model, function *fun,\n+\t\t\tvec<svalue_id> *arg_sids,\n+\t\t\tregion_model_context *ctxt);\n+  region_id get_current_frame_id (const region_model &model) const;\n+  svalue_id pop_frame (region_model *model, bool purge, purge_stats *stats,\n+\t\t       region_model_context *ctxt);\n+\n+  region_id ensure_stack_region (region_model *model);\n+  region_id get_stack_region_id () const { return m_stack_rid; }\n+  stack_region *get_stack_region (const region_model *model) const;\n+\n+  region_id ensure_globals_region (region_model *model);\n+  region_id get_globals_region_id () const { return m_globals_rid; }\n+  globals_region *get_globals_region (const region_model *model) const;\n+\n+  region_id ensure_code_region (region_model *model);\n+  code_region *get_code_region (const region_model *model) const;\n+\n+  region_id ensure_heap_region (region_model *model);\n+  heap_region *get_heap_region (const region_model *model) const;\n+\n+  void remap_region_ids (const region_id_map &map) FINAL OVERRIDE;\n+\n+  static bool can_merge_p (const root_region *root_region_a,\n+\t\t\t   const root_region *root_region_b,\n+\t\t\t   root_region *merged_root_region,\n+\t\t\t   model_merger *merger);\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  svalue_id get_value_by_name (tree identifier,\n+\t\t\t       const region_model &model) const;\n+\n+private:\n+  void add_to_hash (inchash::hash &hstate) const FINAL OVERRIDE;\n+  void print_fields (const region_model &model,\n+\t\t     region_id this_rid,\n+\t\t     pretty_printer *pp) const\n+    FINAL OVERRIDE;\n+\n+  region_id m_stack_rid;\n+  region_id m_globals_rid;\n+  region_id m_code_rid;\n+  region_id m_heap_rid;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <root_region *>::test (region *reg)\n+{\n+  return reg->get_kind () == RK_ROOT;\n+}\n+\n+/* Concrete region subclass: a region to use when dereferencing an unknown\n+   pointer.  */\n+\n+class symbolic_region : public region\n+{\n+public:\n+  symbolic_region (region_id parent_rid, bool possibly_null)\n+  : region (parent_rid, svalue_id::null (), NULL_TREE),\n+    m_possibly_null (possibly_null)\n+  {}\n+  symbolic_region (const symbolic_region &other);\n+\n+  const symbolic_region *dyn_cast_symbolic_region () const FINAL OVERRIDE\n+  { return this; }\n+\n+  bool compare_fields (const symbolic_region &other) const;\n+\n+  region *clone () const FINAL OVERRIDE;\n+\n+  enum region_kind get_kind () const FINAL OVERRIDE { return RK_SYMBOLIC; }\n+\n+  void walk_for_canonicalization (canonicalization *c) const FINAL OVERRIDE;\n+\n+  bool m_possibly_null;\n+};\n+\n+/* A region_model encapsulates a representation of the state of memory, with\n+   a tree of regions, along with their associated values.\n+   The representation is graph-like because values can be pointers to\n+   regions.\n+   It also stores a constraint_manager, capturing relationships between\n+   the values.  */\n+\n+class region_model\n+{\n+ public:\n+  region_model ();\n+  region_model (const region_model &other);\n+  ~region_model ();\n+\n+#if 0//__cplusplus >= 201103\n+  region_model (region_model &&other);\n+#endif\n+\n+  region_model &operator= (const region_model &other);\n+\n+  bool operator== (const region_model &other) const;\n+  bool operator!= (const region_model &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  hashval_t hash () const;\n+\n+  void print (pretty_printer *pp) const;\n+\n+  void print_svalue (svalue_id sid, pretty_printer *pp) const;\n+\n+  void dump_dot_to_pp (pretty_printer *pp) const;\n+  void dump_dot_to_file (FILE *fp) const;\n+  void dump_dot (const char *path) const;\n+\n+  void dump_to_pp (pretty_printer *pp, bool summarize) const;\n+  void dump (FILE *fp, bool summarize) const;\n+  void dump (bool summarize) const;\n+\n+  void debug () const;\n+\n+  void validate () const;\n+\n+  void canonicalize (region_model_context *ctxt);\n+  bool canonicalized_p () const;\n+\n+  void check_for_poison (tree expr, region_model_context *ctxt);\n+  void on_assignment (const gassign *stmt, region_model_context *ctxt);\n+  void on_call_pre (const gcall *stmt, region_model_context *ctxt);\n+  void on_call_post (const gcall *stmt, region_model_context *ctxt);\n+  void on_return (const greturn *stmt, region_model_context *ctxt);\n+  void on_setjmp (const gcall *stmt, const exploded_node *enode,\n+\t\t  region_model_context *ctxt);\n+  void on_longjmp (const gcall *longjmp_call, const gcall *setjmp_call,\n+\t\t   int setjmp_stack_depth, region_model_context *ctxt);\n+\n+  void update_for_phis (const supernode *snode,\n+\t\t\tconst cfg_superedge *last_cfg_superedge,\n+\t\t\tregion_model_context *ctxt);\n+\n+  void handle_phi (tree lhs, tree rhs, bool is_back_edge,\n+\t\t   region_model_context *ctxt);\n+\n+  bool maybe_update_for_edge (const superedge &edge,\n+\t\t\t      const gimple *last_stmt,\n+\t\t\t      region_model_context *ctxt);\n+\n+  region_id get_root_rid () const { return m_root_rid; }\n+  root_region *get_root_region () const;\n+\n+  region_id get_stack_region_id () const;\n+  region_id push_frame (function *fun, vec<svalue_id> *arg_sids,\n+\t\t\tregion_model_context *ctxt);\n+  region_id get_current_frame_id () const;\n+  function * get_current_function () const;\n+  svalue_id pop_frame (bool purge, purge_stats *stats,\n+\t\t       region_model_context *ctxt);\n+  int get_stack_depth () const;\n+  function *get_function_at_depth (unsigned depth) const;\n+\n+  region_id get_globals_region_id () const;\n+\n+  svalue_id add_svalue (svalue *sval);\n+  void replace_svalue (svalue_id sid, svalue *new_sval);\n+\n+  region_id add_region (region *r);\n+\n+  region_id add_region_for_type (region_id parent_rid, tree type);\n+\n+  svalue *get_svalue (svalue_id sval_id) const;\n+  region *get_region (region_id rid) const;\n+\n+  template <typename Subclass>\n+  Subclass *get_region (region_id rid) const\n+  {\n+    region *result = get_region (rid);\n+    if (result)\n+      gcc_assert (is_a<Subclass *> (result));\n+    return (Subclass *)result;\n+  }\n+\n+  region_id get_lvalue (path_var pv, region_model_context *ctxt);\n+  region_id get_lvalue (tree expr, region_model_context *ctxt);\n+  svalue_id get_rvalue (path_var pv, region_model_context *ctxt);\n+  svalue_id get_rvalue (tree expr, region_model_context *ctxt);\n+\n+  svalue_id get_or_create_ptr_svalue (tree ptr_type, region_id id);\n+  svalue_id get_or_create_constant_svalue (tree cst_expr);\n+  svalue_id get_svalue_for_fndecl (tree ptr_type, tree fndecl);\n+  svalue_id get_svalue_for_label (tree ptr_type, tree label);\n+\n+  region_id get_region_for_fndecl (tree fndecl);\n+  region_id get_region_for_label (tree label);\n+\n+  svalue_id maybe_cast (tree type, svalue_id sid, region_model_context *ctxt);\n+  svalue_id maybe_cast_1 (tree type, svalue_id sid);\n+\n+  region_id get_field_region (region_id rid, tree field);\n+\n+  region_id deref_rvalue (svalue_id ptr_sid, region_model_context *ctxt);\n+  region_id deref_rvalue (tree ptr, region_model_context *ctxt);\n+\n+  void set_value (region_id lhs_rid, svalue_id rhs_sid,\n+\t\t  region_model_context *ctxt);\n+  svalue_id set_to_new_unknown_value (region_id dst_rid, tree type,\n+\t\t\t\t      region_model_context *ctxt);\n+\n+  tristate eval_condition (svalue_id lhs,\n+\t\t\t   enum tree_code op,\n+\t\t\t   svalue_id rhs) const;\n+  tristate eval_condition_without_cm (svalue_id lhs,\n+\t\t\t\t      enum tree_code op,\n+\t\t\t\t      svalue_id rhs) const;\n+  tristate eval_condition (tree lhs,\n+\t\t\t   enum tree_code op,\n+\t\t\t   tree rhs,\n+\t\t\t   region_model_context *ctxt);\n+  bool add_constraint (tree lhs, enum tree_code op, tree rhs,\n+\t\t       region_model_context *ctxt);\n+\n+  tree maybe_get_constant (svalue_id sid) const;\n+\n+  region_id add_new_malloc_region ();\n+\n+  tree get_representative_tree (svalue_id sid) const;\n+  path_var get_representative_path_var (region_id rid) const;\n+  void get_path_vars_for_svalue (svalue_id sid, vec<path_var> *out) const;\n+\n+  void purge_unused_svalues (purge_stats *out,\n+\t\t\t     region_model_context *ctxt,\n+\t\t\t     svalue_id *known_used_sid = NULL);\n+  void remap_svalue_ids (const svalue_id_map &map);\n+  void remap_region_ids (const region_id_map &map);\n+\n+  void purge_regions (const region_id_set &set,\n+\t\t      purge_stats *stats,\n+\t\t      logger *logger);\n+\n+  unsigned get_num_svalues () const { return m_svalues.length (); }\n+  unsigned get_num_regions () const { return m_regions.length (); }\n+\n+  /* For selftests.  */\n+  constraint_manager *get_constraints ()\n+  {\n+    return m_constraints;\n+  }\n+\n+  void get_descendents (region_id rid, region_id_set *out,\n+\t\t\tregion_id exclude_rid) const;\n+\n+  void delete_region_and_descendents (region_id rid,\n+\t\t\t\t      enum poison_kind pkind,\n+\t\t\t\t      purge_stats *stats,\n+\t\t\t\t      logger *logger);\n+\n+  bool can_merge_with_p (const region_model &other_model,\n+\t\t\t region_model *out_model,\n+\t\t\t svalue_id_merger_mapping *out) const;\n+  bool can_merge_with_p (const region_model &other_model,\n+\t\t\t region_model *out_model) const;\n+\n+  svalue_id get_value_by_name (const char *name) const;\n+\n+  svalue_id convert_byte_offset_to_array_index (tree ptr_type,\n+\t\t\t\t\t\tsvalue_id offset_sid);\n+\n+  region_id get_or_create_mem_ref (tree type,\n+\t\t\t\t   svalue_id ptr_sid,\n+\t\t\t\t   svalue_id offset_sid,\n+\t\t\t\t   region_model_context *ctxt);\n+  region_id get_or_create_pointer_plus_expr (tree type,\n+\t\t\t\t\t     svalue_id ptr_sid,\n+\t\t\t\t\t     svalue_id offset_sid,\n+\t\t\t\t\t     region_model_context *ctxt);\n+  region_id get_or_create_view (region_id raw_rid, tree type);\n+\n+  tree get_fndecl_for_call (const gcall *call,\n+\t\t\t    region_model_context *ctxt);\n+\n+ private:\n+  region_id get_lvalue_1 (path_var pv, region_model_context *ctxt);\n+  svalue_id get_rvalue_1 (path_var pv, region_model_context *ctxt);\n+\n+  void add_any_constraints_from_ssa_def_stmt (tree lhs,\n+\t\t\t\t\t      enum tree_code op,\n+\t\t\t\t\t      tree rhs,\n+\t\t\t\t\t      region_model_context *ctxt);\n+\n+  void update_for_call_superedge (const call_superedge &call_edge,\n+\t\t\t\t  region_model_context *ctxt);\n+  void update_for_return_superedge (const return_superedge &return_edge,\n+\t\t\t\t    region_model_context *ctxt);\n+  void update_for_call_summary (const callgraph_superedge &cg_sedge,\n+\t\t\t\tregion_model_context *ctxt);\n+  bool apply_constraints_for_gcond (const cfg_superedge &edge,\n+\t\t\t\t    const gcond *cond_stmt,\n+\t\t\t\t    region_model_context *ctxt);\n+  bool apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n+\t\t\t\t      const gswitch *switch_stmt,\n+\t\t\t\t      region_model_context *ctxt);\n+\n+  void poison_any_pointers_to_bad_regions (const region_id_set &bad_regions,\n+\t\t\t\t\t   enum poison_kind pkind);\n+\n+  void dump_summary_of_map (pretty_printer *pp, map_region *map_region,\n+\t\t\t    bool *is_first) const;\n+\n+  auto_delete_vec<svalue> m_svalues;\n+  auto_delete_vec<region> m_regions;\n+  region_id m_root_rid;\n+  constraint_manager *m_constraints; // TODO: embed, rather than dynalloc?\n+};\n+\n+/* Some region_model activity could lead to warnings (e.g. attempts to use an\n+   uninitialized value).  This abstract base class encapsulates an interface\n+   for the region model to use when emitting such warnings.\n+\n+   It also provides an interface for being notified about svalue_ids being\n+   remapped, and being deleted.\n+\n+   Having this as an abstract base class allows us to support the various\n+   operations needed by program_state in the analyzer within region_model,\n+   whilst keeping them somewhat modularized.  */\n+\n+class region_model_context\n+{\n+ public:\n+  virtual void warn (pending_diagnostic *d) = 0;\n+\n+  /* Hook for clients that store svalue_id instances, so that they\n+     can remap their IDs when the underlying region_model renumbers\n+     the IDs.  */\n+  virtual void remap_svalue_ids (const svalue_id_map &map) = 0;\n+\n+#if 0\n+  /* Return true if if's OK to purge SID when simplifying state.\n+     Subclasses can return false for values that have sm state,\n+     to avoid generating \"leak\" false positives.  */\n+  virtual bool can_purge_p (svalue_id sid) = 0;\n+#endif\n+\n+  /* Hook for clients to be notified when a range of SIDs have\n+     been purged, so that they can purge state relating to those\n+     values (and potentially emit warnings about leaks).\n+     All SIDs from FIRST_PURGED_SID numerically upwards are being\n+     purged.\n+     The return values is a count of how many items of data the client\n+     has purged (potentially for use in selftests).\n+     MAP has already been applied to the IDs, but is provided in case\n+     the client needs to figure out the old IDs.  */\n+  virtual int on_svalue_purge (svalue_id first_purged_sid,\n+\t\t\t       const svalue_id_map &map) = 0;\n+\n+  virtual logger *get_logger () = 0;\n+\n+  /* Hook for clients to be notified when CHILD_SID is created\n+     from PARENT_SID, when \"inheriting\" a value for a region from a\n+     parent region.\n+     This exists so that state machines that inherit state can\n+     propagate the state from parent to child.  */\n+  virtual void on_inherited_svalue (svalue_id parent_sid,\n+\t\t\t\t    svalue_id child_sid) = 0;\n+\n+  /* Hook for clients to be notified when DST_SID is created\n+     (or reused) as a cast from SRC_SID.\n+     This exists so that state machines can propagate the state\n+     from SRC_SID to DST_SID.  */\n+  virtual void on_cast (svalue_id src_sid,\n+\t\t\tsvalue_id dst_sid) = 0;\n+\n+  /* Hook for clients to be notified when the condition\n+     \"LHS OP RHS\" is added to the region model.\n+     This exists so that state machines can detect tests on edges,\n+     and use them to trigger sm-state transitions (e.g. transitions due\n+     to ptrs becoming known to be NULL or non-NULL, rather than just\n+     \"unchecked\") */\n+  virtual void on_condition (tree lhs, enum tree_code op, tree rhs) = 0;\n+};\n+\n+/* A bundle of data for use when attempting to merge two region_model\n+   instances to make a third.  */\n+\n+struct model_merger\n+{\n+  model_merger (const region_model *model_a,\n+\t\tconst region_model *model_b,\n+\t\tregion_model *merged_model,\n+\t\tsvalue_id_merger_mapping *sid_mapping)\n+  : m_model_a (model_a), m_model_b (model_b),\n+    m_merged_model (merged_model),\n+    m_map_regions_from_a_to_m (model_a->get_num_regions ()),\n+    m_map_regions_from_b_to_m (model_b->get_num_regions ()),\n+    m_sid_mapping (sid_mapping)\n+  {\n+    gcc_assert (sid_mapping);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump (FILE *fp) const;\n+  void dump () const;\n+\n+  template <typename Subclass>\n+  Subclass *get_region_a (region_id rid_a) const\n+  {\n+    return m_model_a->get_region <Subclass> (rid_a);\n+  }\n+\n+  template <typename Subclass>\n+  Subclass *get_region_b (region_id rid_b) const\n+  {\n+    return m_model_b->get_region <Subclass> (rid_b);\n+  }\n+\n+  bool can_merge_values_p (svalue_id sid_a,\n+\t\t\t   svalue_id sid_b,\n+\t\t\t   svalue_id *merged_sid);\n+\n+  void record_regions (region_id a_rid,\n+\t\t       region_id b_rid,\n+\t\t       region_id merged_rid);\n+\n+  void record_svalues (svalue_id a_sid,\n+\t\t       svalue_id b_sid,\n+\t\t       svalue_id merged_sid);\n+\n+  const region_model *m_model_a;\n+  const region_model *m_model_b;\n+  region_model *m_merged_model;\n+\n+  one_way_region_id_map m_map_regions_from_a_to_m;\n+  one_way_region_id_map m_map_regions_from_b_to_m;\n+  svalue_id_merger_mapping *m_sid_mapping;\n+};\n+\n+/* A bundle of data that can be optionally generated during merger of two\n+   region_models that describes how svalue_ids in each of the two inputs\n+   are mapped to svalue_ids in the merged output.\n+\n+   For use when merging sm-states within program_state.  */\n+\n+struct svalue_id_merger_mapping\n+{\n+  svalue_id_merger_mapping (const region_model &a,\n+\t\t\t    const region_model &b);\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump (FILE *fp) const;\n+  void dump () const;\n+\n+  one_way_svalue_id_map m_map_from_a_to_m;\n+  one_way_svalue_id_map m_map_from_b_to_m;\n+};\n+\n+/* A bundle of data used when canonicalizing a region_model so that the\n+   order of regions and svalues is in a predictable order (thus increasing\n+   the chance of two region_models being equal).\n+\n+   This object is used to keep track of a recursive traversal across the\n+   svalues and regions within the model, made in a deterministic order,\n+   assigning new ids the first time each region or svalue is\n+   encountered.  */\n+\n+struct canonicalization\n+{\n+  canonicalization (const region_model &model);\n+  void walk_rid (region_id rid);\n+  void walk_sid (svalue_id sid);\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump (FILE *fp) const;\n+  void dump () const;\n+\n+  const region_model &m_model;\n+  /* Maps from existing IDs to new IDs.  */\n+  region_id_map m_rid_map;\n+  svalue_id_map m_sid_map;\n+  /* The next IDs to hand out.  */\n+  int m_next_rid_int;\n+  int m_next_sid_int;\n+};\n+\n+namespace inchash\n+{\n+  extern void add (svalue_id sid, hash &hstate);\n+  extern void add (region_id rid, hash &hstate);\n+} // namespace inchash\n+\n+extern void debug (const region_model &rmodel);\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* An implementation of region_model_context for use in selftests, which\n+   stores any pending_diagnostic instances passed to it.  */\n+\n+class test_region_model_context : public region_model_context\n+{\n+public:\n+  void warn (pending_diagnostic *d) FINAL OVERRIDE\n+  {\n+    m_diagnostics.safe_push (d);\n+  }\n+\n+  void remap_svalue_ids (const svalue_id_map &) FINAL OVERRIDE\n+  {\n+    /* Empty.  */\n+  }\n+\n+#if 0\n+  bool can_purge_p (svalue_id) FINAL OVERRIDE\n+  {\n+    return true;\n+  }\n+#endif\n+\n+  int on_svalue_purge (svalue_id, const svalue_id_map &) FINAL OVERRIDE\n+  {\n+    /* Empty.  */\n+    return 0;\n+  }\n+\n+  logger *get_logger () FINAL OVERRIDE { return NULL; }\n+\n+  void on_inherited_svalue (svalue_id parent_sid ATTRIBUTE_UNUSED,\n+\t\t\t    svalue_id child_sid  ATTRIBUTE_UNUSED)\n+    FINAL OVERRIDE\n+  {\n+  }\n+\n+  void on_cast (svalue_id src_sid ATTRIBUTE_UNUSED,\n+\t\tsvalue_id dst_sid ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+\n+  unsigned get_num_diagnostics () const { return m_diagnostics.length (); }\n+\n+  void on_condition (tree lhs ATTRIBUTE_UNUSED,\n+\t\t     enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t     tree rhs ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+\n+private:\n+  /* Implicitly delete any diagnostics in the dtor.  */\n+  auto_delete_vec<pending_diagnostic> m_diagnostics;\n+};\n+\n+/* Attempt to add the constraint (LHS OP RHS) to MODEL.\n+   Verify that MODEL remains satisfiable.  */\n+\n+#define ADD_SAT_CONSTRAINT(MODEL, LHS, OP, RHS)\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\\\n+    bool sat = (MODEL).add_constraint (LHS, OP, RHS, NULL);\t\\\n+    ASSERT_TRUE (sat);\t\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Attempt to add the constraint (LHS OP RHS) to MODEL.\n+   Verify that the result is not satisfiable.  */\n+\n+#define ADD_UNSAT_CONSTRAINT(MODEL, LHS, OP, RHS)\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\\\n+    bool sat = (MODEL).add_constraint (LHS, OP, RHS, NULL);\t\\\n+    ASSERT_FALSE (sat);\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Implementation detail of the ASSERT_CONDITION_* macros.  */\n+\n+void assert_condition (const location &loc,\n+\t\t       region_model &model,\n+\t\t       tree lhs, tree_code op, tree rhs,\n+\t\t       tristate expected);\n+\n+/* Assert that REGION_MODEL evaluates the condition \"LHS OP RHS\"\n+   as \"true\".  */\n+\n+#define ASSERT_CONDITION_TRUE(REGION_MODEL, LHS, OP, RHS) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_condition (SELFTEST_LOCATION, REGION_MODEL, LHS, OP, RHS,\t\\\n+\t\t    tristate (tristate::TS_TRUE));\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Assert that REGION_MODEL evaluates the condition \"LHS OP RHS\"\n+   as \"false\".  */\n+\n+#define ASSERT_CONDITION_FALSE(REGION_MODEL, LHS, OP, RHS) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_condition (SELFTEST_LOCATION, REGION_MODEL, LHS, OP, RHS,\t\\\n+\t\t    tristate (tristate::TS_FALSE));\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Assert that REGION_MODEL evaluates the condition \"LHS OP RHS\"\n+   as \"unknown\".  */\n+\n+#define ASSERT_CONDITION_UNKNOWN(REGION_MODEL, LHS, OP, RHS) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_condition (SELFTEST_LOCATION, REGION_MODEL, LHS, OP, RHS,\t\\\n+\t\t    tristate (tristate::TS_UNKNOWN));\t\t\\\n+  SELFTEST_END_STMT\n+\n+} /* end of namespace selftest.  */\n+\n+#endif /* #if CHECKING_P */\n+\n+#endif /* GCC_ANALYZER_REGION_MODEL_H */"}, {"sha": "ba18bf71a73da002afa52ec140aaf3f9c85aea8a", "filename": "gcc/analyzer/sm-file.cc", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,339 @@\n+/* A state machine for detecting misuses of <stdio.h>'s FILE * API.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* A state machine for detecting misuses of <stdio.h>'s FILE * API.  */\n+\n+class fileptr_state_machine : public state_machine\n+{\n+public:\n+  fileptr_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+  pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n+\n+  /* Start state.  */\n+  state_t m_start;\n+\n+  /* State for a FILE * returned from fopen that hasn't been checked for\n+     NULL.\n+     It could be an open stream, or could be NULL.  */\n+  state_t m_unchecked;\n+\n+  /* State for a FILE * that's known to be NULL.  */\n+  state_t m_null;\n+\n+  /* State for a FILE * that's known to be a non-NULL open stream.  */\n+  state_t m_nonnull;\n+\n+  /* State for a FILE * that's had fclose called on it.  */\n+  state_t m_closed;\n+\n+  /* Stop state, for a FILE * we don't want to track any more.  */\n+  state_t m_stop;\n+};\n+\n+/* Base class for diagnostics relative to fileptr_state_machine.  */\n+\n+class file_diagnostic : public pending_diagnostic\n+{\n+public:\n+  file_diagnostic (const fileptr_state_machine &sm, tree arg)\n+  : m_sm (sm), m_arg (arg)\n+  {}\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    return m_arg == ((const file_diagnostic &)base_other).m_arg;\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    OVERRIDE\n+  {\n+    if (change.m_old_state == m_sm.m_start\n+\t&& change.m_new_state == m_sm.m_unchecked)\n+      // TODO: verify that it's the fopen stmt, not a copy\n+      return label_text::borrow (\"opened here\");\n+    if (change.m_old_state == m_sm.m_unchecked\n+\t&& change.m_new_state == m_sm.m_nonnull)\n+      return change.formatted_print (\"assuming %qE is non-NULL\",\n+\t\t\t\t     change.m_expr);\n+    if (change.m_new_state == m_sm.m_null)\n+      return change.formatted_print (\"assuming %qE is NULL\",\n+\t\t\t\t     change.m_expr);\n+    return label_text ();\n+  }\n+\n+protected:\n+  const fileptr_state_machine &m_sm;\n+  tree m_arg;\n+};\n+\n+class double_fclose : public file_diagnostic\n+{\n+public:\n+  double_fclose (const fileptr_state_machine &sm, tree arg)\n+    : file_diagnostic (sm, arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"double_fclose\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    return warning_at (rich_loc, OPT_Wanalyzer_double_fclose,\n+\t\t       \"double %<fclose%> of FILE %qE\",\n+\t\t       m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_closed)\n+      {\n+\tm_first_fclose_event = change.m_event_id;\n+\treturn change.formatted_print (\"first %qs here\", \"fclose\");\n+      }\n+    return file_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_first_fclose_event.known_p ())\n+      return ev.formatted_print (\"second %qs here; first %qs was at %@\",\n+\t\t\t\t \"fclose\", \"fclose\",\n+\t\t\t\t &m_first_fclose_event);\n+    return ev.formatted_print (\"second %qs here\", \"fclose\");\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_fclose_event;\n+};\n+\n+class file_leak : public file_diagnostic\n+{\n+public:\n+  file_leak (const fileptr_state_machine &sm, tree arg)\n+    : file_diagnostic (sm, arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"file_leak\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-775: \"Missing Release of File Descriptor or Handle after\n+       Effective Lifetime\". */\n+    m.add_cwe (775);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_file_leak,\n+\t\t       \"leak of FILE %qE\",\n+\t\t       m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_unchecked)\n+      {\n+\tm_fopen_event = change.m_event_id;\n+\treturn label_text::borrow (\"opened here\");\n+      }\n+    return file_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_fopen_event.known_p ())\n+      return ev.formatted_print (\"%qE leaks here; was opened at %@\",\n+\t\t\t\t ev.m_expr, &m_fopen_event);\n+    else\n+      return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_fopen_event;\n+};\n+\n+/* fileptr_state_machine's ctor.  */\n+\n+fileptr_state_machine::fileptr_state_machine (logger *logger)\n+: state_machine (\"file\", logger)\n+{\n+  m_start = add_state (\"start\");\n+  m_unchecked = add_state (\"unchecked\");\n+  m_null = add_state (\"null\");\n+  m_nonnull = add_state (\"nonnull\");\n+  m_closed = add_state (\"closed\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for fileptr_state_machine.  */\n+\n+bool\n+fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t\tconst supernode *node,\n+\t\t\t\tconst gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+      {\n+\tif (is_named_call_p (callee_fndecl, \"fopen\", call, 2))\n+\t  {\n+\t    tree lhs = gimple_call_lhs (call);\n+\t    if (lhs)\n+\t      {\n+\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n+\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* TODO: report leak.  */\n+\t      }\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"fclose\", call, 1))\n+\t  {\n+\t    tree arg = gimple_call_arg (call, 0);\n+\t    arg = sm_ctxt->get_readable_tree (arg);\n+\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_closed);\n+\n+\t    // TODO: is it safe to call fclose (NULL) ?\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_closed);\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_null, m_closed);\n+\n+\t    sm_ctxt->on_transition (node, stmt , arg, m_nonnull, m_closed);\n+\n+\t    sm_ctxt->warn_for_state (node, stmt, arg, m_closed,\n+\t\t\t\t     new double_fclose (*this, arg));\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_closed, m_stop);\n+\t    return true;\n+\t  }\n+\n+\t// TODO: operations on closed file\n+\t// etc\n+      }\n+\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for\n+   fileptr_state_machine.\n+   Potentially transition state 'unchecked' to 'nonnull' or to 'null'.  */\n+\n+void\n+fileptr_state_machine::on_condition (sm_context *sm_ctxt,\n+\t\t\t\t     const supernode *node,\n+\t\t\t\t     const gimple *stmt,\n+\t\t\t\t     tree lhs,\n+\t\t\t\t     enum tree_code op,\n+\t\t\t\t     tree rhs) const\n+{\n+  if (!zerop (rhs))\n+    return;\n+\n+  // TODO: has to be a FILE *, specifically\n+  if (TREE_CODE (TREE_TYPE (lhs)) != POINTER_TYPE)\n+    return;\n+\n+  // TODO: has to be a FILE *, specifically\n+  if (TREE_CODE (TREE_TYPE (rhs)) != POINTER_TYPE)\n+    return;\n+\n+  if (op == NE_EXPR)\n+    {\n+      log (\"got 'ARG != 0' match\");\n+      sm_ctxt->on_transition (node, stmt,\n+\t\t\t      lhs, m_unchecked, m_nonnull);\n+    }\n+  else if (op == EQ_EXPR)\n+    {\n+      log (\"got 'ARG == 0' match\");\n+      sm_ctxt->on_transition (node, stmt,\n+\t\t\t      lhs, m_unchecked, m_null);\n+    }\n+}\n+\n+/* Implementation of state_machine::can_purge_p vfunc for fileptr_state_machine.\n+   Don't allow purging of pointers in state 'unchecked' or 'nonnull'\n+   (to avoid false leak reports).  */\n+\n+bool\n+fileptr_state_machine::can_purge_p (state_t s) const\n+{\n+  return s != m_unchecked && s != m_nonnull;\n+}\n+\n+/* Implementation of state_machine::on_leak vfunc for\n+   fileptr_state_machine, for complaining about leaks of FILE * in\n+   state 'unchecked' and 'nonnull'.  */\n+\n+pending_diagnostic *\n+fileptr_state_machine::on_leak (tree var) const\n+{\n+  return new file_leak (*this, var);\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_fileptr_state_machine (logger *logger)\n+{\n+  return new fileptr_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "80ceb0f59137eb4b7716b6d08cbfa3470bc11069", "filename": "gcc/analyzer/sm-malloc.cc", "status": "added", "additions": 797, "deletions": 0, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,797 @@\n+/* A state machine for detecting misuses of the malloc/free API.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"bitmap.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* A state machine for detecting misuses of the malloc/free API.\n+\n+   See sm-malloc.dot for an overview (keep this in-sync with that file).  */\n+\n+class malloc_state_machine : public state_machine\n+{\n+public:\n+  malloc_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+  pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n+\n+  /* Start state.  */\n+  state_t m_start;\n+\n+  /* State for a pointer returned from malloc that hasn't been checked for\n+     NULL.\n+     It could be a pointer to heap-allocated memory, or could be NULL.  */\n+  state_t m_unchecked;\n+\n+  /* State for a pointer that's known to be NULL.  */\n+  state_t m_null;\n+\n+  /* State for a pointer to heap-allocated memory, known to be non-NULL.  */\n+  state_t m_nonnull;\n+\n+  /* State for a pointer to freed memory.  */\n+  state_t m_freed;\n+\n+  /* State for a pointer that's known to not be on the heap (e.g. to a local\n+     or global).  */\n+  state_t m_non_heap; // TODO: or should this be a different state machine?\n+  // or do we need child values etc?\n+\n+  /* Stop state, for pointers we don't want to track any more.  */\n+  state_t m_stop;\n+};\n+\n+/* Class for diagnostics relating to malloc_state_machine.  */\n+\n+class malloc_diagnostic : public pending_diagnostic\n+{\n+public:\n+  malloc_diagnostic (const malloc_state_machine &sm, tree arg)\n+  : m_sm (sm), m_arg (arg)\n+  {}\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const OVERRIDE\n+  {\n+    return m_arg == ((const malloc_diagnostic &)base_other).m_arg;\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    OVERRIDE\n+  {\n+    if (change.m_old_state == m_sm.m_start\n+\t&& change.m_new_state == m_sm.m_unchecked)\n+      // TODO: verify that it's the allocation stmt, not a copy\n+      return label_text::borrow (\"allocated here\");\n+    if (change.m_old_state == m_sm.m_unchecked\n+\t&& change.m_new_state == m_sm.m_nonnull)\n+      return change.formatted_print (\"assuming %qE is non-NULL\",\n+\t\t\t\t     change.m_expr);\n+    if (change.m_new_state == m_sm.m_null)\n+      return change.formatted_print (\"assuming %qE is NULL\",\n+\t\t\t\t     change.m_expr);\n+    return label_text ();\n+  }\n+\n+protected:\n+  const malloc_state_machine &m_sm;\n+  tree m_arg;\n+};\n+\n+/* Concrete subclass for reporting double-free diagnostics.  */\n+\n+class double_free : public malloc_diagnostic\n+{\n+public:\n+  double_free (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"double_free\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    diagnostic_metadata m;\n+    m.add_cwe (415); /* CWE-415: Double Free.  */\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_double_free,\n+\t\t       \"double-%<free%> of %qE\", m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_freed)\n+      {\n+\tm_first_free_event = change.m_event_id;\n+\treturn change.formatted_print (\"first %qs here\", \"free\");\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_call_with_state (const evdesc::call_with_state &info)\n+    FINAL OVERRIDE\n+  {\n+    if (info.m_state == m_sm.m_freed)\n+      return info.formatted_print\n+\t(\"passing freed pointer %qE in call to %qE from %qE\",\n+\t info.m_expr, info.m_callee_fndecl, info.m_caller_fndecl);\n+    return label_text ();\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_first_free_event.known_p ())\n+      return ev.formatted_print (\"second %qs here; first %qs was at %@\",\n+\t\t\t\t \"free\", \"free\",\n+\t\t\t\t &m_first_free_event);\n+    return ev.formatted_print (\"second %qs here\", \"free\");\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_free_event;\n+};\n+\n+/* Abstract subclass for describing possible bad uses of NULL.\n+   Responsible for describing the call that could return NULL.  */\n+\n+class possible_null : public malloc_diagnostic\n+{\n+public:\n+  possible_null (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg)\n+  {}\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_old_state == m_sm.m_start\n+\t&& change.m_new_state == m_sm.m_unchecked)\n+      {\n+\tm_origin_of_unchecked_event = change.m_event_id;\n+\treturn label_text::borrow (\"this call could return NULL\");\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_return_of_state (const evdesc::return_of_state &info)\n+    FINAL OVERRIDE\n+  {\n+    if (info.m_state == m_sm.m_unchecked)\n+      return info.formatted_print (\"possible return of NULL to %qE from %qE\",\n+\t\t\t\t   info.m_caller_fndecl, info.m_callee_fndecl);\n+    return label_text ();\n+  }\n+\n+protected:\n+  diagnostic_event_id_t m_origin_of_unchecked_event;\n+};\n+\n+/* Concrete subclass for describing dereference of a possible NULL\n+   value.  */\n+\n+class possible_null_deref : public possible_null\n+{\n+public:\n+  possible_null_deref (const malloc_state_machine &sm, tree arg)\n+  : possible_null (sm, arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"possible_null_deref\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    /* CWE-690: Unchecked Return Value to NULL Pointer Dereference.  */\n+    diagnostic_metadata m;\n+    m.add_cwe (690);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_possible_null_dereference,\n+\t\t       \"dereference of possibly-NULL %qE\", m_arg);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_origin_of_unchecked_event.known_p ())\n+      return ev.formatted_print (\"%qE could be NULL: unchecked value from %@\",\n+\t\t\t\t ev.m_expr,\n+\t\t\t\t &m_origin_of_unchecked_event);\n+    else\n+      return ev.formatted_print (\"%qE could be NULL\", ev.m_expr);\n+  }\n+\n+};\n+\n+/* Subroutine for use by possible_null_arg::emit and null_arg::emit.\n+   Issue a note informing that the pertinent argument must be non-NULL.  */\n+\n+static void\n+inform_nonnull_attribute (tree fndecl, int arg_idx)\n+{\n+  inform (DECL_SOURCE_LOCATION (fndecl),\n+\t  \"argument %u of %qD must be non-null\",\n+\t  arg_idx + 1, fndecl);\n+  /* Ideally we would use the location of the parm and underline the\n+     attribute also - but we don't have the location_t values at this point\n+     in the middle-end.\n+     For reference, the C and C++ FEs have get_fndecl_argument_location.  */\n+}\n+\n+/* Concrete subclass for describing passing a possibly-NULL value to a\n+   function marked with __attribute__((nonnull)).  */\n+\n+class possible_null_arg : public possible_null\n+{\n+public:\n+  possible_null_arg (const malloc_state_machine &sm, tree arg,\n+\t\t     tree fndecl, int arg_idx)\n+  : possible_null (sm, arg),\n+    m_fndecl (fndecl), m_arg_idx (arg_idx)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"possible_null_arg\"; }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const\n+  {\n+    const possible_null_arg &sub_other\n+      = (const possible_null_arg &)base_other;\n+    return (m_arg == sub_other.m_arg\n+\t    && m_fndecl == sub_other.m_fndecl\n+\t    && m_arg_idx == sub_other.m_arg_idx);\n+  }\n+\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    /* CWE-690: Unchecked Return Value to NULL Pointer Dereference.  */\n+    auto_diagnostic_group d;\n+    diagnostic_metadata m;\n+    m.add_cwe (690);\n+    bool warned\n+      = warning_at (rich_loc, m, OPT_Wanalyzer_possible_null_argument,\n+\t\t    \"use of possibly-NULL %qE where non-null expected\",\n+\t\t    m_arg);\n+    if (warned)\n+      inform_nonnull_attribute (m_fndecl, m_arg_idx);\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_origin_of_unchecked_event.known_p ())\n+      return ev.formatted_print (\"argument %u (%qE) from %@ could be NULL\"\n+\t\t\t\t \" where non-null expected\",\n+\t\t\t\t m_arg_idx + 1, ev.m_expr,\n+\t\t\t\t &m_origin_of_unchecked_event);\n+    else\n+      return ev.formatted_print (\"argument %u (%qE) could be NULL\"\n+\t\t\t\t \" where non-null expected\",\n+\t\t\t\t m_arg_idx + 1, ev.m_expr);\n+  }\n+\n+private:\n+  tree m_fndecl;\n+  int m_arg_idx;\n+};\n+\n+/* Concrete subclass for describing a dereference of a NULL value.  */\n+\n+class null_deref : public malloc_diagnostic\n+{\n+public:\n+  null_deref (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg) {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"null_deref\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    /* CWE-690: Unchecked Return Value to NULL Pointer Dereference.  */\n+    diagnostic_metadata m;\n+    m.add_cwe (690);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_null_dereference,\n+\t\t       \"dereference of NULL %qE\", m_arg);\n+  }\n+\n+  label_text describe_return_of_state (const evdesc::return_of_state &info)\n+    FINAL OVERRIDE\n+  {\n+    if (info.m_state == m_sm.m_null)\n+      return info.formatted_print (\"return of NULL to %qE from %qE\",\n+\t\t\t\t   info.m_caller_fndecl, info.m_callee_fndecl);\n+    return label_text ();\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"dereference of NULL %qE\", ev.m_expr);\n+  }\n+};\n+\n+/* Concrete subclass for describing passing a NULL value to a\n+   function marked with __attribute__((nonnull)).  */\n+\n+class null_arg : public malloc_diagnostic\n+{\n+public:\n+  null_arg (const malloc_state_machine &sm, tree arg,\n+\t    tree fndecl, int arg_idx)\n+  : malloc_diagnostic (sm, arg),\n+    m_fndecl (fndecl), m_arg_idx (arg_idx)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"null_arg\"; }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const\n+  {\n+    const null_arg &sub_other\n+      = (const null_arg &)base_other;\n+    return (m_arg == sub_other.m_arg\n+\t    && m_fndecl == sub_other.m_fndecl\n+\t    && m_arg_idx == sub_other.m_arg_idx);\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    /* CWE-690: Unchecked Return Value to NULL Pointer Dereference.  */\n+    auto_diagnostic_group d;\n+    diagnostic_metadata m;\n+    m.add_cwe (690);\n+    bool warned = warning_at (rich_loc, m, OPT_Wanalyzer_null_argument,\n+\t\t\t      \"use of NULL %qE where non-null expected\", m_arg);\n+    if (warned)\n+      inform_nonnull_attribute (m_fndecl, m_arg_idx);\n+    return warned;\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"argument %u (%qE) NULL\"\n+\t\t\t       \" where non-null expected\",\n+\t\t\t       m_arg_idx + 1, ev.m_expr);\n+  }\n+\n+private:\n+  tree m_fndecl;\n+  int m_arg_idx;\n+};\n+\n+class use_after_free : public malloc_diagnostic\n+{\n+public:\n+  use_after_free (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"use_after_free\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    /* CWE-416: Use After Free.  */\n+    diagnostic_metadata m;\n+    m.add_cwe (416);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_use_after_free,\n+\t\t       \"use after %<free%> of %qE\", m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_freed)\n+      {\n+\tm_free_event = change.m_event_id;\n+\treturn label_text::borrow (\"freed here\");\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_free_event.known_p ())\n+      return ev.formatted_print (\"use after %<free%> of %qE; freed at %@\",\n+\t\t\t\t ev.m_expr, &m_free_event);\n+    else\n+      return ev.formatted_print (\"use after %<free%> of %qE\", ev.m_expr);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_free_event;\n+};\n+\n+class malloc_leak : public malloc_diagnostic\n+{\n+public:\n+  malloc_leak (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg) {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"malloc_leak\"; }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (401);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n+\t\t       \"leak of %qE\", m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_unchecked)\n+      {\n+\tm_malloc_event = change.m_event_id;\n+\treturn label_text::borrow (\"allocated here\");\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_malloc_event.known_p ())\n+      return ev.formatted_print (\"%qE leaks here; was allocated at %@\",\n+\t\t\t\t ev.m_expr, &m_malloc_event);\n+    else\n+      return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_malloc_event;\n+};\n+\n+class free_of_non_heap : public malloc_diagnostic\n+{\n+public:\n+  free_of_non_heap (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg), m_kind (KIND_UNKNOWN)\n+  {\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"free_of_non_heap\"; }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const\n+    FINAL OVERRIDE\n+  {\n+    const free_of_non_heap &other = (const free_of_non_heap &)base_other;\n+    return (m_arg == other.m_arg && m_kind == other.m_kind);\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    diagnostic_metadata m;\n+    m.add_cwe (590); /* CWE-590: Free of Memory not on the Heap.  */\n+    switch (m_kind)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case KIND_UNKNOWN:\n+\treturn warning_at (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n+\t\t\t   \"%<free%> of %qE which points to memory\"\n+\t\t\t   \" not on the heap\",\n+\t\t\t   m_arg);\n+\tbreak;\n+      case KIND_ALLOCA:\n+\treturn warning_at (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n+\t\t\t   \"%<free%> of memory allocated on the stack by\"\n+\t\t\t   \" %qs (%qE) will corrupt the heap\",\n+\t\t\t   \"alloca\", m_arg);\n+\tbreak;\n+      }\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    /* Attempt to reconstruct what kind of pointer it is.\n+       (It seems neater for this to be a part of the state, though).  */\n+    if (TREE_CODE (change.m_expr) == SSA_NAME)\n+      {\n+\tgimple *def_stmt = SSA_NAME_DEF_STMT (change.m_expr);\n+\tif (gcall *call = dyn_cast <gcall *> (def_stmt))\n+\t  {\n+\t    if (is_special_named_call_p (call, \"alloca\", 1)\n+\t\t|| is_special_named_call_p (call, \"__builtin_alloca\", 1))\n+\t      {\n+\t\tm_kind = KIND_ALLOCA;\n+\t\treturn label_text::borrow\n+\t\t  (\"memory is allocated on the stack here\");\n+\t      }\n+\t  }\n+      }\n+    return label_text::borrow (\"pointer is from here\");\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"call to %qs here\", \"free\");\n+  }\n+\n+private:\n+  enum kind\n+  {\n+    KIND_UNKNOWN,\n+    KIND_ALLOCA\n+  };\n+  enum kind m_kind;\n+};\n+\n+/* malloc_state_machine's ctor.  */\n+\n+malloc_state_machine::malloc_state_machine (logger *logger)\n+: state_machine (\"malloc\", logger)\n+{\n+  m_start = add_state (\"start\");\n+  m_unchecked = add_state (\"unchecked\");\n+  m_null = add_state (\"null\");\n+  m_nonnull = add_state (\"nonnull\");\n+  m_freed = add_state (\"freed\");\n+  m_non_heap = add_state (\"non-heap\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for malloc_state_machine.  */\n+\n+bool\n+malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t       const supernode *node,\n+\t\t\t       const gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+      {\n+\tif (is_named_call_p (callee_fndecl, \"malloc\", call, 1)\n+\t    || is_named_call_p (callee_fndecl, \"calloc\", call, 2)\n+\t    || is_named_call_p (callee_fndecl, \"__builtin_malloc\", call, 1)\n+\t    || is_named_call_p (callee_fndecl, \"__builtin_calloc\", call, 2))\n+\t  {\n+\t    tree lhs = gimple_call_lhs (call);\n+\t    if (lhs)\n+\t      {\n+\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n+\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* TODO: report leak.  */\n+\t      }\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"alloca\", call, 1)\n+\t    || is_named_call_p (callee_fndecl, \"__builtin_alloca\", call, 1))\n+\t  {\n+\t    tree lhs = gimple_call_lhs (call);\n+\t    if (lhs)\n+\t      {\n+\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n+\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n+\t      }\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"free\", call, 1)\n+\t    || is_named_call_p (callee_fndecl, \"__builtin_free\", call, 1))\n+\t  {\n+\t    tree arg = gimple_call_arg (call, 0);\n+\n+\t    arg = sm_ctxt->get_readable_tree (arg);\n+\n+\t    /* start/unchecked/nonnull -> freed.  */\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_freed);\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_freed);\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_nonnull, m_freed);\n+\n+\t    /* Keep state \"null\" as-is, rather than transitioning to \"free\";\n+\t       we don't want want to complain about double-free of NULL.  */\n+\n+\t    /* freed -> stop, with warning.  */\n+\t    sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n+\t\t\t\t     new double_free (*this, arg));\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n+\n+\t    /* non-heap -> stop, with warning.  */\n+\t    sm_ctxt->warn_for_state (node, stmt, arg, m_non_heap,\n+\t\t\t\t     new free_of_non_heap (*this, arg));\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_non_heap, m_stop);\n+\t    return true;\n+\t  }\n+\n+\t/* Handle \"__attribute__((nonnull))\".   */\n+\t{\n+\t  tree fntype = TREE_TYPE (callee_fndecl);\n+\t  bitmap nonnull_args = get_nonnull_args (fntype);\n+\t  if (nonnull_args)\n+\t    {\n+\t      for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+\t\t{\n+\t\t  tree arg = gimple_call_arg (stmt, i);\n+\t\t  if (TREE_CODE (TREE_TYPE (arg)) != POINTER_TYPE)\n+\t\t    continue;\n+\t\t  /* If we have a nonnull-args, and either all pointers, or just\n+\t\t     the specified pointers.  */\n+\t\t  if (bitmap_empty_p (nonnull_args)\n+\t\t      || bitmap_bit_p (nonnull_args, i))\n+\t\t    {\n+\t\t      sm_ctxt->warn_for_state\n+\t\t\t(node, stmt, arg, m_unchecked,\n+\t\t\t new possible_null_arg (*this, arg, callee_fndecl, i));\n+\t\t      sm_ctxt->on_transition (node, stmt, arg, m_unchecked,\n+\t\t\t\t\t      m_nonnull);\n+\n+\t\t      sm_ctxt->warn_for_state\n+\t\t\t(node, stmt, arg, m_null,\n+\t\t\t new null_arg (*this, arg, callee_fndecl, i));\n+\t\t      sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n+\t\t    }\n+\t\t}\n+\t      BITMAP_FREE (nonnull_args);\n+\t    }\n+\t}\n+      }\n+\n+  if (tree lhs = is_zero_assignment (stmt))\n+    {\n+      if (any_pointer_p (lhs))\n+\t{\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_start, m_null);\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked, m_null);\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_nonnull, m_null);\n+\t  sm_ctxt->on_transition (node, stmt, lhs, m_freed, m_null);\n+\t}\n+    }\n+\n+  if (const gassign *assign_stmt = dyn_cast <const gassign *> (stmt))\n+    {\n+      enum tree_code op = gimple_assign_rhs_code (assign_stmt);\n+      if (op == ADDR_EXPR)\n+\t{\n+\t  tree lhs = gimple_assign_lhs (assign_stmt);\n+\t  if (lhs)\n+\t    {\n+\t      lhs = sm_ctxt->get_readable_tree (lhs);\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n+\t    }\n+\t}\n+    }\n+\n+  /* Handle dereferences.  */\n+  for (unsigned i = 0; i < gimple_num_ops (stmt); i++)\n+    {\n+      tree op = gimple_op (stmt, i);\n+      if (!op)\n+\tcontinue;\n+      if (TREE_CODE (op) == COMPONENT_REF)\n+\top = TREE_OPERAND (op, 0);\n+\n+      if (TREE_CODE (op) == MEM_REF)\n+\t{\n+\t  tree arg = TREE_OPERAND (op, 0);\n+\t  arg = sm_ctxt->get_readable_tree (arg);\n+\n+\t  sm_ctxt->warn_for_state (node, stmt, arg, m_unchecked,\n+\t\t\t\t   new possible_null_deref (*this, arg));\n+\t  sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_nonnull);\n+\n+\t  sm_ctxt->warn_for_state (node, stmt, arg, m_null,\n+\t\t\t\t   new null_deref (*this, arg));\n+\t  sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n+\n+\t  sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n+\t\t\t\t   new use_after_free (*this, arg));\n+\t  sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for malloc_state_machine.\n+   Potentially transition state 'unchecked' to 'nonnull' or to 'null'.  */\n+\n+void\n+malloc_state_machine::on_condition (sm_context *sm_ctxt,\n+\t\t\t\t    const supernode *node,\n+\t\t\t\t    const gimple *stmt,\n+\t\t\t\t    tree lhs,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    tree rhs) const\n+{\n+  if (!zerop (rhs))\n+    return;\n+\n+  if (!any_pointer_p (lhs))\n+    return;\n+  if (!any_pointer_p (rhs))\n+    return;\n+\n+  if (op == NE_EXPR)\n+    {\n+      log (\"got 'ARG != 0' match\");\n+      sm_ctxt->on_transition (node, stmt,\n+\t\t\t      lhs, m_unchecked, m_nonnull);\n+    }\n+  else if (op == EQ_EXPR)\n+    {\n+      log (\"got 'ARG == 0' match\");\n+      sm_ctxt->on_transition (node, stmt,\n+\t\t\t      lhs, m_unchecked, m_null);\n+    }\n+}\n+\n+/* Implementation of state_machine::can_purge_p vfunc for malloc_state_machine.\n+   Don't allow purging of pointers in state 'unchecked' or 'nonnull'\n+   (to avoid false leak reports).  */\n+\n+bool\n+malloc_state_machine::can_purge_p (state_t s) const\n+{\n+  return s != m_unchecked && s != m_nonnull;\n+}\n+\n+/* Implementation of state_machine::on_leak vfunc for malloc_state_machine\n+   (for complaining about leaks of pointers in state 'unchecked' and\n+   'nonnull').  */\n+\n+pending_diagnostic *\n+malloc_state_machine::on_leak (tree var) const\n+{\n+  return new malloc_leak (*this, var);\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_malloc_state_machine (logger *logger)\n+{\n+  return new malloc_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "12e28d5116673e2a08bdd125431d5acd6f89c6a3", "filename": "gcc/analyzer/sm-malloc.dot", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-malloc.dot", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-malloc.dot", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.dot?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,89 @@\n+/* An overview of the state machine from sm-malloc.cc.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Keep this in-sync with sm-malloc.cc  */\n+\n+digraph \"malloc\" {\n+\n+  /* STATES. */\n+\n+  /* Start state.  */\n+  start;\n+\n+  /* State for a pointer returned from malloc that hasn't been checked for\n+     NULL.\n+     It could be a pointer to heap-allocated memory, or could be NULL.  */\n+  unchecked;\n+\n+  /* State for a pointer that's known to be NULL.  */\n+  null;\n+\n+  /* State for a pointer to heap-allocated memory, known to be non-NULL.  */\n+  nonnull;\n+\n+  /* State for a pointer to freed memory.  */\n+  freed;\n+\n+  /* State for a pointer that's known to not be on the heap (e.g. to a local\n+     or global).  */\n+  non_heap;\n+\n+  /* Stop state, for pointers we don't want to track any more.  */\n+  stop;\n+\n+  /* TRANSITIONS. */\n+\n+  start -> unchecked [label=\"on 'X=malloc(...);'\"];\n+  start -> unchecked [label=\"on 'X=calloc(...);'\"];\n+\n+  start -> non_heap [label=\"on 'X=alloca(...);'\"];\n+  start -> non_heap [label=\"on 'X=__builtin_alloca(...);'\"];\n+\n+  /* On \"free\".  */\n+  start -> freed [label=\"on 'free(X);'\"];\n+  unchecked -> freed [label=\"on 'free(X);'\"];\n+  nonnull -> freed [label=\"on 'free(X);'\"];\n+  freed -> stop [label=\"on 'free(X);':\\n Warn('double-free')\"];\n+  non_heap -> stop  [label=\"on 'free(X);':\\n Warn('free of non-heap')\"];\n+\n+  /* Handle \"__attribute__((nonnull))\".   */\n+  unchecked -> nonnull [label=\"on 'FN(X)' with __attribute__((nonnull)):\\nWarn('possible NULL arg')\"];\n+  null -> stop [label=\"on 'FN(X)' with __attribute__((nonnull)):\\nWarn('NULL arg')\"];\n+\n+  /* is_zero_assignment.  */\n+  start -> null [label=\"on 'X = 0;'\"];\n+  unchecked -> null [label=\"on 'X = 0;'\"];\n+  nonnull -> null [label=\"on 'X = 0;'\"];\n+  freed -> null [label=\"on 'X = 0;'\"];\n+\n+  start -> non_heap [label=\"on 'X = &EXPR;'\"];\n+\n+  /* Handle dereferences.  */\n+  unchecked -> nonnull [label=\"on '*X':\\nWarn('possible NULL deref')\"];\n+  null -> stop [label=\"on '*X':\\nWarn('NULL deref')\"];\n+  freed -> stop [label=\"on '*X':\\nWarn('use after free')\"];\n+\n+  /* on_condition.  */\n+  unchecked -> nonnull [label=\"on 'X != 0'\"];\n+  unchecked -> null [label=\"on 'X == 0'\"];\n+\n+  unchecked -> stop [label=\"on leak:\\nWarn('leak')\"];\n+  nonnull -> stop [label=\"on leak:\\nWarn('leak')\"];\n+}"}, {"sha": "8c70858e938b86d968c03b76caf8a1c21ff043bf", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,152 @@\n+/* A state machine for use in DejaGnu tests, to check that\n+   pattern-matching works as expected.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* A state machine for use in DejaGnu tests, to check that\n+   pattern-matching works as expected.  */\n+\n+class pattern_test_state_machine : public state_machine\n+{\n+public:\n+  pattern_test_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+\n+private:\n+  state_t m_start;\n+};\n+\n+class pattern_match : public pending_diagnostic_subclass<pattern_match>\n+{\n+public:\n+  pattern_match (tree lhs, enum tree_code op, tree rhs)\n+  : m_lhs (lhs), m_op (op), m_rhs (rhs) {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"pattern_match\"; }\n+\n+  bool operator== (const pattern_match &other) const\n+  {\n+    return (m_lhs == other.m_lhs\n+\t    && m_op == other.m_op\n+\t    && m_rhs == other.m_rhs);\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    return warning_at (rich_loc, 0, \"pattern match on %<%E %s %E%>\",\n+\t\t       m_lhs, op_symbol_code (m_op), m_rhs);\n+  }\n+\n+private:\n+  tree m_lhs;\n+  enum tree_code m_op;\n+  tree m_rhs;\n+};\n+\n+pattern_test_state_machine::pattern_test_state_machine (logger *logger)\n+: state_machine (\"pattern-test\", logger)\n+{\n+  m_start = add_state (\"start\");\n+}\n+\n+bool\n+pattern_test_state_machine::on_stmt (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t\t\t     const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t     const gimple *stmt ATTRIBUTE_UNUSED) const\n+{\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for\n+   pattern_test_state_machine.\n+\n+   Queue a pattern_match diagnostic for any comparison against a\n+   constant.  */\n+\n+void\n+pattern_test_state_machine::on_condition (sm_context *sm_ctxt,\n+\t\t\t\t\t  const supernode *node,\n+\t\t\t\t\t  const gimple *stmt,\n+\t\t\t\t\t  tree lhs,\n+\t\t\t\t\t  enum tree_code op,\n+\t\t\t\t\t  tree rhs) const\n+{\n+  if (stmt == NULL)\n+    return;\n+\n+  if (!CONSTANT_CLASS_P (rhs))\n+    return;\n+\n+  pending_diagnostic *diag = new pattern_match (lhs, op, rhs);\n+  sm_ctxt->warn_for_state (node, stmt, lhs, m_start, diag);\n+}\n+\n+bool\n+pattern_test_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n+{\n+  return true;\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_pattern_test_state_machine (logger *logger)\n+{\n+  return new pattern_test_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "efb24325fbd19d96d95a653f855f70c949e21d4f", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,248 @@\n+/* An experimental state machine, for tracking exposure of sensitive\n+   data (e.g. through logging).\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* An experimental state machine, for tracking exposure of sensitive\n+   data (e.g. through logging).  */\n+\n+class sensitive_state_machine : public state_machine\n+{\n+public:\n+  sensitive_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return true; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+\n+  /* Start state.  */\n+  state_t m_start;\n+\n+  /* State for \"sensitive\" data, such as a password.  */\n+  state_t m_sensitive;\n+\n+  /* Stop state, for a value we don't want to track any more.  */\n+  state_t m_stop;\n+\n+private:\n+  void warn_for_any_exposure (sm_context *sm_ctxt,\n+\t\t\t      const supernode *node,\n+\t\t\t      const gimple *stmt,\n+\t\t\t      tree arg) const;\n+};\n+\n+class exposure_through_output_file\n+  : public pending_diagnostic_subclass<exposure_through_output_file>\n+{\n+public:\n+  exposure_through_output_file (const sensitive_state_machine &sm, tree arg)\n+  : m_sm (sm), m_arg (arg)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"exposure_through_output_file\";\n+  }\n+\n+  bool operator== (const exposure_through_output_file &other) const\n+  {\n+    return m_arg == other.m_arg;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-532: Information Exposure Through Log Files */\n+    m.add_cwe (532);\n+    return warning_at (rich_loc, m, OPT_Wanalyzer_exposure_through_output_file,\n+\t\t       \"sensitive value %qE written to output file\",\n+\t\t       m_arg);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_sensitive)\n+      {\n+\tm_first_sensitive_event = change.m_event_id;\n+\treturn change.formatted_print (\"sensitive value acquired here\");\n+      }\n+    return label_text ();\n+  }\n+\n+  label_text describe_call_with_state (const evdesc::call_with_state &info)\n+    FINAL OVERRIDE\n+  {\n+    if (info.m_state == m_sm.m_sensitive)\n+      return info.formatted_print\n+\t(\"passing sensitive value %qE in call to %qE from %qE\",\n+\t info.m_expr, info.m_callee_fndecl, info.m_caller_fndecl);\n+    return label_text ();\n+  }\n+\n+  label_text describe_return_of_state (const evdesc::return_of_state &info)\n+    FINAL OVERRIDE\n+  {\n+    if (info.m_state == m_sm.m_sensitive)\n+      return info.formatted_print (\"returning sensitive value to %qE from %qE\",\n+\t\t\t\t   info.m_caller_fndecl, info.m_callee_fndecl);\n+    return label_text ();\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_first_sensitive_event.known_p ())\n+      return ev.formatted_print (\"sensitive value %qE written to output file\"\n+\t\t\t\t \"; acquired at %@\",\n+\t\t\t\t m_arg, &m_first_sensitive_event);\n+    else\n+      return ev.formatted_print (\"sensitive value %qE written to output file\",\n+\t\t\t\t m_arg);\n+  }\n+\n+private:\n+  const sensitive_state_machine &m_sm;\n+  tree m_arg;\n+  diagnostic_event_id_t m_first_sensitive_event;\n+};\n+\n+/* sensitive_state_machine's ctor.  */\n+\n+sensitive_state_machine::sensitive_state_machine (logger *logger)\n+: state_machine (\"sensitive\", logger)\n+{\n+  m_start = add_state (\"start\");\n+  m_sensitive = add_state (\"sensitive\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+/* Warn about an exposure at NODE and STMT if ARG is in the \"sensitive\"\n+   state.  */\n+\n+void\n+sensitive_state_machine::warn_for_any_exposure (sm_context *sm_ctxt,\n+\t\t\t\t\t\tconst supernode *node,\n+\t\t\t\t\t\tconst gimple *stmt,\n+\t\t\t\t\t\ttree arg) const\n+{\n+  sm_ctxt->warn_for_state (node, stmt, arg, m_sensitive,\n+\t\t\t   new exposure_through_output_file (*this, arg));\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for\n+   sensitive_state_machine.  */\n+\n+bool\n+sensitive_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t\t  const supernode *node,\n+\t\t\t\t  const gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+      {\n+\tif (is_named_call_p (callee_fndecl, \"getpass\", call, 1))\n+\t  {\n+\t    tree lhs = gimple_call_lhs (call);\n+\t    if (lhs)\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_sensitive);\n+\t    return true;\n+\t  }\n+\telse if (is_named_call_p (callee_fndecl, \"fprintf\")\n+\t\t || is_named_call_p (callee_fndecl, \"printf\"))\n+\t  {\n+\t    /* Handle a match at any position in varargs.  */\n+\t    for (unsigned idx = 1; idx < gimple_call_num_args (call); idx++)\n+\t      {\n+\t\ttree arg = gimple_call_arg (call, idx);\n+\t\twarn_for_any_exposure (sm_ctxt, node, stmt, arg);\n+\t      }\n+\t    return true;\n+\t  }\n+\telse if (is_named_call_p (callee_fndecl, \"fwrite\", call, 4))\n+\t  {\n+\t    tree arg = gimple_call_arg (call, 0);\n+\t    warn_for_any_exposure (sm_ctxt, node, stmt, arg);\n+\t    return true;\n+\t  }\n+\t// TODO: ...etc.  This is just a proof-of-concept at this point.\n+      }\n+  return false;\n+}\n+\n+void\n+sensitive_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t\t\t       const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t       const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t       tree lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t       enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t\t\t       tree rhs ATTRIBUTE_UNUSED) const\n+{\n+  /* Empty.  */\n+}\n+\n+bool\n+sensitive_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n+{\n+  return true;\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_sensitive_state_machine (logger *logger)\n+{\n+  return new sensitive_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "ee41d1976c089813b38628da36501889420886ea", "filename": "gcc/analyzer/sm-signal.cc", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,328 @@\n+/* An experimental state machine, for tracking bad calls from within\n+   signal handlers.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"bitmap.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"sbitmap.h\"\n+#include \"tristate.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/program-state.h\"\n+#include \"analyzer/checker-path.h\"\n+#include \"digraph.h\"\n+#include \"cfg.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"alloc-pool.h\"\n+#include \"fibonacci_heap.h\"\n+#include \"analyzer/diagnostic-manager.h\"\n+#include \"shortest-paths.h\"\n+#include \"analyzer/exploded-graph.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* An experimental state machine, for tracking calls to async-signal-unsafe\n+   functions from within signal handlers.  */\n+\n+class signal_state_machine : public state_machine\n+{\n+public:\n+  signal_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return false; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+\n+  /* These states are \"global\", rather than per-expression.  */\n+\n+  /* Start state.  */\n+  state_t m_start;\n+\n+  /* State for when we're in a signal handler.  */\n+  state_t m_in_signal_handler;\n+\n+  /* Stop state.  */\n+  state_t m_stop;\n+};\n+\n+/* Concrete subclass for describing call to an async-signal-unsafe function\n+   from a signal handler.  */\n+\n+class signal_unsafe_call\n+  : public pending_diagnostic_subclass<signal_unsafe_call>\n+{\n+public:\n+  signal_unsafe_call (const signal_state_machine &sm, const gcall *unsafe_call,\n+\t\t      tree unsafe_fndecl)\n+  : m_sm (sm), m_unsafe_call (unsafe_call), m_unsafe_fndecl (unsafe_fndecl)\n+  {\n+    gcc_assert (m_unsafe_fndecl);\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"signal_unsafe_call\"; }\n+\n+  bool operator== (const signal_unsafe_call &other) const\n+  {\n+    return m_unsafe_call == other.m_unsafe_call;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    /* CWE-479: Signal Handler Use of a Non-reentrant Function.  */\n+    m.add_cwe (479);\n+    return warning_at (rich_loc, m,\n+\t\t       OPT_Wanalyzer_unsafe_call_within_signal_handler,\n+\t\t       \"call to %qD from within signal handler\",\n+\t\t       m_unsafe_fndecl);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.is_global_p ()\n+\t&& change.m_new_state == m_sm.m_in_signal_handler)\n+      {\n+\tfunction *handler\n+\t  = change.m_event.m_dst_state.m_region_model->get_current_function ();\n+\treturn change.formatted_print (\"registering %qD as signal handler\",\n+\t\t\t\t       handler->decl);\n+      }\n+    return label_text ();\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    return ev.formatted_print (\"call to %qD from within signal handler\",\n+\t\t\t       m_unsafe_fndecl);\n+  }\n+\n+private:\n+  const signal_state_machine &m_sm;\n+  const gcall *m_unsafe_call;\n+  tree m_unsafe_fndecl;\n+};\n+\n+/* signal_state_machine's ctor.  */\n+\n+signal_state_machine::signal_state_machine (logger *logger)\n+: state_machine (\"signal\", logger)\n+{\n+  m_start = add_state (\"start\");\n+  m_in_signal_handler = add_state (\"in_signal_handler\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+/* Update MODEL for edges that simulate HANDLER_FUN being called as\n+   an signal-handler in response to a signal.  */\n+\n+static void\n+update_model_for_signal_handler (region_model *model,\n+\t\t\t\t function *handler_fun)\n+{\n+  /* Purge all state within MODEL.  */\n+  *model = region_model ();\n+  model->push_frame (handler_fun, NULL, NULL);\n+}\n+\n+/* Custom exploded_edge info: entry into a signal-handler.  */\n+\n+class signal_delivery_edge_info_t : public exploded_edge::custom_info_t\n+{\n+public:\n+  void print (pretty_printer *pp) FINAL OVERRIDE\n+  {\n+    pp_string (pp, \"signal delivered\");\n+  }\n+\n+  void update_model (region_model *model,\n+\t\t     const exploded_edge &eedge) FINAL OVERRIDE\n+  {\n+    update_model_for_signal_handler (model, eedge.m_dest->get_function ());\n+  }\n+\n+  void add_events_to_path (checker_path *emission_path,\n+\t\t\t   const exploded_edge &eedge ATTRIBUTE_UNUSED)\n+    FINAL OVERRIDE\n+  {\n+    emission_path->add_event\n+      (new custom_event (UNKNOWN_LOCATION, NULL_TREE, 0,\n+\t\t\t \"later on,\"\n+\t\t\t \" when the signal is delivered to the process\"));\n+  }\n+};\n+\n+/* Concrete subclass of custom_transition for modeling registration of a\n+   signal handler and the signal handler later being called.  */\n+\n+class register_signal_handler : public custom_transition\n+{\n+public:\n+  register_signal_handler (const signal_state_machine &sm,\n+\t\t\t   tree fndecl)\n+  : m_sm (sm), m_fndecl (fndecl) {}\n+\n+  /* Model a signal-handler FNDECL being called at some later point\n+     by injecting an edge to a new function-entry node with an empty\n+     callstring, setting the 'in-signal-handler' global state\n+     on the node.  */\n+  void impl_transition (exploded_graph *eg,\n+\t\t\texploded_node *src_enode,\n+\t\t\tint sm_idx) FINAL OVERRIDE\n+  {\n+    function *handler_fun = DECL_STRUCT_FUNCTION (m_fndecl);\n+    if (!handler_fun)\n+      return;\n+    program_point entering_handler\n+      = program_point::from_function_entry (eg->get_supergraph (),\n+\t\t\t\t\t    handler_fun);\n+\n+    program_state state_entering_handler (eg->get_ext_state ());\n+    update_model_for_signal_handler (state_entering_handler.m_region_model,\n+\t\t\t\t     handler_fun);\n+    state_entering_handler.m_checker_states[sm_idx]->set_global_state\n+      (m_sm.m_in_signal_handler);\n+\n+    exploded_node *dst_enode = eg->get_or_create_node (entering_handler,\n+\t\t\t\t\t\t       state_entering_handler,\n+\t\t\t\t\t\t       NULL);\n+    if (dst_enode)\n+      eg->add_edge (src_enode, dst_enode, NULL, state_change (),\n+\t\t    new signal_delivery_edge_info_t ());\n+  }\n+\n+  const signal_state_machine &m_sm;\n+  tree m_fndecl;\n+};\n+\n+/* Return true if CALL is known to be unsafe to call from a signal handler.  */\n+\n+static bool\n+signal_unsafe_p (tree callee_fndecl)\n+{\n+  // TODO: maintain a list of known unsafe functions\n+  if (is_named_call_p (callee_fndecl, \"fprintf\"))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for signal_state_machine.  */\n+\n+bool\n+signal_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t       const supernode *node,\n+\t\t\t       const gimple *stmt) const\n+{\n+  const state_t global_state = sm_ctxt->get_global_state ();\n+  if (global_state == m_start)\n+    {\n+      if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+\tif (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+\t  if (is_named_call_p (callee_fndecl, \"signal\", call, 2))\n+\t    {\n+\t      tree handler = gimple_call_arg (call, 1);\n+\t      if (TREE_CODE (handler) == ADDR_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (handler, 0)) == FUNCTION_DECL)\n+\t\t{\n+\t\t  tree fndecl = TREE_OPERAND (handler, 0);\n+\t\t  register_signal_handler rsh (*this, fndecl);\n+\t\t  sm_ctxt->on_custom_transition (&rsh);\n+\t\t}\n+\t    }\n+    }\n+  else if (global_state == m_in_signal_handler)\n+    {\n+      if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+\tif (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+\t  if (signal_unsafe_p (callee_fndecl))\n+\t    sm_ctxt->warn_for_state (node, stmt, NULL_TREE, m_in_signal_handler,\n+\t\t\t\t     new signal_unsafe_call (*this, call,\n+\t\t\t\t\t\t\t     callee_fndecl));\n+    }\n+\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for\n+   signal_state_machine.  */\n+\n+void\n+signal_state_machine::on_condition (sm_context *sm_ctxt ATTRIBUTE_UNUSED,\n+\t\t\t\t    const supernode *node ATTRIBUTE_UNUSED,\n+\t\t\t\t    const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t    tree lhs ATTRIBUTE_UNUSED,\n+\t\t\t\t    enum tree_code op ATTRIBUTE_UNUSED,\n+\t\t\t\t    tree rhs ATTRIBUTE_UNUSED) const\n+{\n+  // Empty\n+}\n+\n+bool\n+signal_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n+{\n+  return true;\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_signal_state_machine (logger *logger)\n+{\n+  return new signal_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "9382853503f49eb6341423312104ef8eb32e7bcc", "filename": "gcc/analyzer/sm-taint.cc", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,328 @@\n+/* An experimental state machine, for tracking \"taint\": unsanitized uses\n+   of data potentially under an attacker's control.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace {\n+\n+/* An experimental state machine, for tracking \"taint\": unsanitized uses\n+   of data potentially under an attacker's control.  */\n+\n+class taint_state_machine : public state_machine\n+{\n+public:\n+  taint_state_machine (logger *logger);\n+\n+  bool inherited_state_p () const FINAL OVERRIDE { return true; }\n+\n+  bool on_stmt (sm_context *sm_ctxt,\n+\t\tconst supernode *node,\n+\t\tconst gimple *stmt) const FINAL OVERRIDE;\n+\n+  void on_condition (sm_context *sm_ctxt,\n+\t\t     const supernode *node,\n+\t\t     const gimple *stmt,\n+\t\t     tree lhs,\n+\t\t     enum tree_code op,\n+\t\t     tree rhs) const FINAL OVERRIDE;\n+\n+  bool can_purge_p (state_t s) const FINAL OVERRIDE;\n+\n+  /* Start state.  */\n+  state_t m_start;\n+\n+  /* State for a \"tainted\" value: unsanitized data potentially under an\n+     attacker's control.  */\n+  state_t m_tainted;\n+\n+  /* State for a \"tainted\" value that has a lower bound.  */\n+  state_t m_has_lb;\n+\n+  /* State for a \"tainted\" value that has an upper bound.  */\n+  state_t m_has_ub;\n+\n+  /* Stop state, for a value we don't want to track any more.  */\n+  state_t m_stop;\n+};\n+\n+enum bounds\n+{\n+  BOUNDS_NONE,\n+  BOUNDS_UPPER,\n+  BOUNDS_LOWER\n+};\n+\n+class tainted_array_index\n+  : public pending_diagnostic_subclass<tainted_array_index>\n+{\n+public:\n+  tainted_array_index (const taint_state_machine &sm, tree arg,\n+\t\t       enum bounds has_bounds)\n+  : m_sm (sm), m_arg (arg), m_has_bounds (has_bounds) {}\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"tainted_array_index\"; }\n+\n+  bool operator== (const tainted_array_index &other) const\n+  {\n+    return m_arg == other.m_arg;\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (129);\n+    switch (m_has_bounds)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case BOUNDS_NONE:\n+\treturn warning_at (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\t\t\t   \"use of tainted value %qE in array lookup\"\n+\t\t\t   \" without bounds checking\",\n+\t\t\t   m_arg);\n+\tbreak;\n+      case BOUNDS_UPPER:\n+\treturn warning_at (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\t\t\t   \"use of tainted value %qE in array lookup\"\n+\t\t\t   \" without lower-bounds checking\",\n+\t\t\t   m_arg);\n+\tbreak;\n+      case BOUNDS_LOWER:\n+\treturn warning_at (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\t\t\t   \"use of tainted value %qE in array lookup\"\n+\t\t\t   \" without upper-bounds checking\",\n+\t\t\t   m_arg);\n+\tbreak;\n+      }\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (change.m_new_state == m_sm.m_tainted)\n+      {\n+\tif (change.m_origin)\n+\t  return change.formatted_print (\"%qE has an unchecked value here\"\n+\t\t\t\t\t \" (from %qE)\",\n+\t\t\t\t\t change.m_expr, change.m_origin);\n+\telse\n+\t  return change.formatted_print (\"%qE gets an unchecked value here\",\n+\t\t\t\t\t change.m_expr);\n+      }\n+    else if (change.m_new_state == m_sm.m_has_lb)\n+      return change.formatted_print (\"%qE has its lower bound checked here\",\n+\t\t\t\t     change.m_expr);\n+    else if (change.m_new_state == m_sm.m_has_ub)\n+      return change.formatted_print (\"%qE has its upper bound checked here\",\n+\t\t\t\t     change.m_expr);\n+    return label_text ();\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    switch (m_has_bounds)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case BOUNDS_NONE:\n+\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n+\t\t\t\t   \" without bounds checking\",\n+\t\t\t\t   m_arg);\n+      case BOUNDS_UPPER:\n+\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n+\t\t\t\t   \" without lower-bounds checking\",\n+\t\t\t\t   m_arg);\n+      case BOUNDS_LOWER:\n+\treturn ev.formatted_print (\"use of tainted value %qE in array lookup\"\n+\t\t\t\t   \" without upper-bounds checking\",\n+\t\t\t\t   m_arg);\n+      }\n+  }\n+\n+private:\n+  const taint_state_machine &m_sm;\n+  tree m_arg;\n+  enum bounds m_has_bounds;\n+};\n+\n+/* taint_state_machine's ctor.  */\n+\n+taint_state_machine::taint_state_machine (logger *logger)\n+: state_machine (\"taint\", logger)\n+{\n+  m_start = add_state (\"start\");\n+  m_tainted = add_state (\"tainted\");\n+  m_has_lb = add_state (\"has_lb\");\n+  m_has_ub = add_state (\"has_ub\");\n+  m_stop = add_state (\"stop\");\n+}\n+\n+/* Implementation of state_machine::on_stmt vfunc for taint_state_machine.  */\n+\n+bool\n+taint_state_machine::on_stmt (sm_context *sm_ctxt,\n+\t\t\t       const supernode *node,\n+\t\t\t       const gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+      {\n+\tif (is_named_call_p (callee_fndecl, \"fread\", call, 4))\n+\t  {\n+\t    tree arg = gimple_call_arg (call, 0);\n+\t    arg = sm_ctxt->get_readable_tree (arg);\n+\n+\t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_tainted);\n+\n+\t    /* Dereference an ADDR_EXPR.  */\n+\t    // TODO: should the engine do this?\n+\t    if (TREE_CODE (arg) == ADDR_EXPR)\n+\t      sm_ctxt->on_transition (node, stmt, TREE_OPERAND (arg, 0),\n+\t\t\t\t      m_start, m_tainted);\n+\t    return true;\n+\t  }\n+      }\n+  // TODO: ...etc; many other sources of untrusted data\n+\n+  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n+    {\n+      tree rhs1 = gimple_assign_rhs1 (assign);\n+      enum tree_code op = gimple_assign_rhs_code (assign);\n+\n+      /* Check array accesses.  */\n+      if (op == ARRAY_REF)\n+\t{\n+\t  tree arg = TREE_OPERAND (rhs1, 1);\n+\t  arg = sm_ctxt->get_readable_tree (arg);\n+\n+\t  /* Unsigned types have an implicit lower bound.  */\n+\t  bool is_unsigned = false;\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (arg)))\n+\t    is_unsigned = TYPE_UNSIGNED (TREE_TYPE (arg));\n+\n+\t  /* Complain about missing bounds.  */\n+\t  sm_ctxt->warn_for_state\n+\t    (node, stmt, arg, m_tainted,\n+\t     new tainted_array_index (*this, arg,\n+\t\t\t\t      is_unsigned\n+\t\t\t\t      ? BOUNDS_LOWER : BOUNDS_NONE));\n+\t  sm_ctxt->on_transition (node, stmt, arg, m_tainted, m_stop);\n+\n+\t  /* Complain about missing upper bound.  */\n+\t  sm_ctxt->warn_for_state  (node, stmt, arg, m_has_lb,\n+\t\t\t\t    new tainted_array_index (*this, arg,\n+\t\t\t\t\t\t\t     BOUNDS_LOWER));\n+\t  sm_ctxt->on_transition (node, stmt, arg, m_has_lb, m_stop);\n+\n+\t  /* Complain about missing lower bound.  */\n+\t  if (!is_unsigned)\n+\t    {\n+\t      sm_ctxt->warn_for_state  (node, stmt, arg, m_has_ub,\n+\t\t\t\t\tnew tainted_array_index (*this, arg,\n+\t\t\t\t\t\t\t\t BOUNDS_UPPER));\n+\t      sm_ctxt->on_transition (node, stmt, arg, m_has_ub, m_stop);\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Implementation of state_machine::on_condition vfunc for taint_state_machine.\n+   Potentially transition state 'tainted' to 'has_ub' or 'has_lb',\n+   and states 'has_ub' and 'has_lb' to 'stop'.  */\n+\n+void\n+taint_state_machine::on_condition (sm_context *sm_ctxt,\n+\t\t\t\t   const supernode *node,\n+\t\t\t\t   const gimple *stmt,\n+\t\t\t\t   tree lhs,\n+\t\t\t\t   enum tree_code op,\n+\t\t\t\t   tree rhs ATTRIBUTE_UNUSED) const\n+{\n+  if (stmt == NULL)\n+    return;\n+\n+  // TODO: this doesn't use the RHS; should we make it symmetric?\n+\n+  // TODO\n+  switch (op)\n+    {\n+      //case NE_EXPR:\n+      //case EQ_EXPR:\n+    case GE_EXPR:\n+    case GT_EXPR:\n+      {\n+\tsm_ctxt->on_transition (node, stmt, lhs, m_tainted,\n+\t\t\t\tm_has_lb);\n+\tsm_ctxt->on_transition (node, stmt, lhs, m_has_ub,\n+\t\t\t\tm_stop);\n+      }\n+      break;\n+    case LE_EXPR:\n+    case LT_EXPR:\n+      {\n+\tsm_ctxt->on_transition (node, stmt, lhs, m_tainted,\n+\t\t\t\tm_has_ub);\n+\tsm_ctxt->on_transition (node, stmt, lhs, m_has_lb,\n+\t\t\t\tm_stop);\n+      }\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+bool\n+taint_state_machine::can_purge_p (state_t s ATTRIBUTE_UNUSED) const\n+{\n+  return true;\n+}\n+\n+} // anonymous namespace\n+\n+/* Internal interface to this file. */\n+\n+state_machine *\n+make_taint_state_machine (logger *logger)\n+{\n+  return new taint_state_machine (logger);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "03d65ffed3d580f7b268c7d1892793662a05cd82", "filename": "gcc/analyzer/sm.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,122 @@\n+/* Modeling API uses and misuses via state machines.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"function.h\"\n+#include \"diagnostic-core.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* If STMT is an assignment from zero, return the LHS.  */\n+\n+tree\n+is_zero_assignment (const gimple *stmt)\n+{\n+  const gassign *assign_stmt = dyn_cast <const gassign *> (stmt);\n+  if (!assign_stmt)\n+    return NULL_TREE;\n+\n+  enum tree_code op = gimple_assign_rhs_code (assign_stmt);\n+  if (TREE_CODE_CLASS (op) != tcc_constant)\n+    return NULL_TREE;\n+\n+  if (!zerop (gimple_assign_rhs1 (assign_stmt)))\n+    return NULL_TREE;\n+\n+  return gimple_assign_lhs (assign_stmt);\n+}\n+\n+/* Return true if VAR has pointer or reference type.  */\n+\n+bool\n+any_pointer_p (tree var)\n+{\n+  return POINTER_TYPE_P (TREE_TYPE (var));\n+}\n+\n+/* Add a state with name NAME to this state_machine.\n+   The string is required to outlive the state_machine.\n+\n+   Return the state_t for the new state.  */\n+\n+state_machine::state_t\n+state_machine::add_state (const char *name)\n+{\n+  m_state_names.safe_push (name);\n+  return m_state_names.length () - 1;\n+}\n+\n+/* Get the name of state S within this state_machine.  */\n+\n+const char *\n+state_machine::get_state_name (state_t s) const\n+{\n+  return m_state_names[s];\n+}\n+\n+/* Assert that S is a valid state for this state_machine.  */\n+\n+void\n+state_machine::validate (state_t s) const\n+{\n+  gcc_assert (s < m_state_names.length ());\n+}\n+\n+/* Create instances of the various state machines, each using LOGGER,\n+   and populate OUT with them.  */\n+\n+void\n+make_checkers (auto_delete_vec <state_machine> &out, logger *logger)\n+{\n+  out.safe_push (make_malloc_state_machine (logger));\n+  out.safe_push (make_fileptr_state_machine (logger));\n+  out.safe_push (make_taint_state_machine (logger));\n+  out.safe_push (make_sensitive_state_machine (logger));\n+  out.safe_push (make_signal_state_machine (logger));\n+\n+  /* We only attempt to run the pattern tests if it might have been manually\n+     enabled (for DejaGnu purposes).  */\n+  if (flag_analyzer_checker)\n+    out.safe_push (make_pattern_test_state_machine (logger));\n+\n+  if (flag_analyzer_checker)\n+    {\n+      unsigned read_index, write_index;\n+      state_machine **sm;\n+\n+      /* TODO: this leaks the machines\n+\t Would be nice to log the things that were removed.  */\n+      VEC_ORDERED_REMOVE_IF (out, read_index, write_index, sm,\n+\t\t\t     0 != strcmp (flag_analyzer_checker,\n+\t\t\t\t\t  (*sm)->get_name ()));\n+    }\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "fb49630f073699e0e05f12a0287e854976e9036d", "filename": "gcc/analyzer/sm.h", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,178 @@\n+/* Modeling API uses and misuses via state machines.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_SM_H\n+#define GCC_ANALYZER_SM_H\n+\n+/* Utility functions for use by state machines.  */\n+\n+extern tree is_zero_assignment (const gimple *stmt);\n+extern bool any_pointer_p (tree var);\n+\n+class state_machine;\n+class sm_context;\n+class pending_diagnostic;\n+\n+/* An abstract base class for a state machine describing an API.\n+   A mapping from state IDs to names, and various virtual functions\n+   for pattern-matching on statements.  */\n+\n+class state_machine : public log_user\n+{\n+public:\n+  typedef unsigned state_t;\n+\n+  state_machine (const char *name, logger *logger)\n+  : log_user (logger), m_name (name) {}\n+\n+  virtual ~state_machine () {}\n+\n+  /* Should states be inherited from a parent region to a child region,\n+     when first accessing a child region?\n+     For example we should inherit the taintedness of a subregion,\n+     but we should not inherit the \"malloc:non-null\" state of a field\n+     within a heap-allocated struct.  */\n+  virtual bool inherited_state_p () const = 0;\n+\n+  const char *get_name () const { return m_name; }\n+\n+  const char *get_state_name (state_t s) const;\n+\n+  /* Return true if STMT is a function call recognized by this sm.  */\n+  virtual bool on_stmt (sm_context *sm_ctxt,\n+\t\t\tconst supernode *node,\n+\t\t\tconst gimple *stmt) const = 0;\n+\n+  virtual void on_condition (sm_context *sm_ctxt,\n+\t\t\t     const supernode *node,\n+\t\t\t     const gimple *stmt,\n+\t\t\t     tree lhs, enum tree_code op, tree rhs) const = 0;\n+\n+  /* Return true if it safe to discard the given state (to help\n+     when simplifying state objects).\n+     States that need leak detection should return false.  */\n+  virtual bool can_purge_p (state_t s) const = 0;\n+\n+  /* Called when VAR leaks (and !can_purge_p).  */\n+  virtual pending_diagnostic *on_leak (tree var ATTRIBUTE_UNUSED) const\n+  {\n+    return NULL;\n+  }\n+\n+  void validate (state_t s) const;\n+\n+protected:\n+  state_t add_state (const char *name);\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (state_machine);\n+\n+  const char *m_name;\n+  auto_vec<const char *> m_state_names;\n+};\n+\n+/* Is STATE the start state?  (zero is hardcoded as the start state).  */\n+\n+static inline bool\n+start_start_p (state_machine::state_t state)\n+{\n+  return state == 0;\n+}\n+\n+/* Abstract base class for state machines to pass to\n+   sm_context::on_custom_transition for handling non-standard transitions\n+   (e.g. adding a node and edge to simulate registering a callback and having\n+   the callback be called later).  */\n+\n+class custom_transition\n+{\n+public:\n+  virtual ~custom_transition () {}\n+  virtual void impl_transition (exploded_graph *eg,\n+\t\t\t\texploded_node *src_enode,\n+\t\t\t\tint sm_idx) = 0;\n+};\n+\n+/* Abstract base class giving an interface for the state machine to call\n+   the checker engine, at a particular stmt.  */\n+\n+class sm_context\n+{\n+public:\n+  virtual ~sm_context () {}\n+\n+  /* Get the fndecl used at call, or NULL_TREE.\n+     Use in preference to gimple_call_fndecl (and gimple_call_addr_fndecl),\n+     since it can look through function pointer assignments and\n+     other callback handling.  */\n+  virtual tree get_fndecl_for_call (const gcall *call) = 0;\n+\n+  /* Called by state_machine in response to pattern matches:\n+     if VAR is in state FROM, transition it to state TO, potentially\n+     recording the \"origin\" of the state as ORIGIN.\n+     Use NODE and STMT for location information.  */\n+   virtual void on_transition (const supernode *node, const gimple *stmt,\n+\t\t\t      tree var,\n+\t\t\t      state_machine::state_t from,\n+\t\t\t      state_machine::state_t to,\n+\t\t\t      tree origin = NULL_TREE) = 0;\n+\n+  /* Called by state_machine in response to pattern matches:\n+     issue a diagnostic D if VAR is in state STATE, using NODE and STMT\n+     for location information.  */\n+  virtual void warn_for_state (const supernode *node, const gimple *stmt,\n+\t\t\t       tree var, state_machine::state_t state,\n+\t\t\t       pending_diagnostic *d) = 0;\n+\n+  virtual tree get_readable_tree (tree expr)\n+  {\n+    return expr;\n+  }\n+\n+  virtual state_machine::state_t get_global_state () const = 0;\n+  virtual void set_global_state (state_machine::state_t) = 0;\n+\n+  /* A vfunc for handling custom transitions, such as when registering\n+     a signal handler.  */\n+  virtual void on_custom_transition (custom_transition *transition) = 0;\n+\n+protected:\n+  sm_context (int sm_idx, const state_machine &sm)\n+  : m_sm_idx (sm_idx), m_sm (sm) {}\n+\n+  int m_sm_idx;\n+  const state_machine &m_sm;\n+};\n+\n+\n+/* The various state_machine subclasses are hidden in their respective\n+   implementation files.  */\n+\n+extern void make_checkers (auto_delete_vec <state_machine> &out,\n+\t\t\t   logger *logger);\n+\n+extern state_machine *make_malloc_state_machine (logger *logger);\n+extern state_machine *make_fileptr_state_machine (logger *logger);\n+extern state_machine *make_taint_state_machine (logger *logger);\n+extern state_machine *make_sensitive_state_machine (logger *logger);\n+extern state_machine *make_signal_state_machine (logger *logger);\n+extern state_machine *make_pattern_test_state_machine (logger *logger);\n+\n+#endif /* GCC_ANALYZER_SM_H */"}, {"sha": "32c564767f9b9cf533908bfe45b00b7899f4b6e8", "filename": "gcc/analyzer/state-purge.cc", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fstate-purge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fstate-purge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,534 @@\n+/* Classes for purging state at function_points.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"timevar.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"stringpool.h\"\n+#include \"tree-vrp.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-phinodes.h\"\n+#include \"options.h\"\n+#include \"ssa-iterators.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"digraph.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"cfg.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/state-purge.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* state_purge_map's ctor.  Walk all SSA names in all functions, building\n+   a state_purge_per_ssa_name instance for each.  */\n+\n+state_purge_map::state_purge_map (const supergraph &sg,\n+\t\t\t\t  logger *logger)\n+: log_user (logger), m_sg (sg)\n+{\n+  LOG_FUNC (logger);\n+\n+  auto_timevar tv (TV_ANALYZER_STATE_PURGE);\n+\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+  {\n+    function *fun = node->get_fun ();\n+    if (logger)\n+      log (\"function: %s\", function_name (fun));\n+    tree name;\n+    unsigned int i;;\n+    FOR_EACH_SSA_NAME (i, name, fun)\n+      {\n+\t/* For now, don't bother tracking the .MEM SSA names.  */\n+\tif (tree var = SSA_NAME_VAR (name))\n+\t  if (TREE_CODE (var) == VAR_DECL)\n+\t    if (VAR_DECL_IS_VIRTUAL_OPERAND (var))\n+\t      continue;\n+\tm_map.put (name, new state_purge_per_ssa_name (*this, name, fun));\n+      }\n+  }\n+}\n+\n+/* state_purge_map's dtor.  */\n+\n+state_purge_map::~state_purge_map ()\n+{\n+  for (iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+    delete (*iter).second;\n+}\n+\n+/* state_purge_per_ssa_name's ctor.\n+\n+   Locate all uses of VAR within FUN.\n+   Walk backwards from each use, marking program points, until\n+   we reach the def stmt, populating m_points_needing_var.\n+\n+   We have to track program points rather than\n+   just stmts since there could be empty basic blocks on the way.  */\n+\n+state_purge_per_ssa_name::state_purge_per_ssa_name (const state_purge_map &map,\n+\t\t\t\t\t\t    tree name,\n+\t\t\t\t\t\t    function *fun)\n+: m_points_needing_name (), m_name (name), m_fun (fun)\n+{\n+  LOG_FUNC (map.get_logger ());\n+\n+  if (map.get_logger ())\n+    {\n+      map.log (\"SSA name: %qE within %qD\", name, fun->decl);\n+\n+      /* Show def stmt.  */\n+      const gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+      pretty_printer pp;\n+      pp_gimple_stmt_1 (&pp, def_stmt, 0, (dump_flags_t)0);\n+      map.log (\"def stmt: %s\", pp_formatted_text (&pp));\n+    }\n+\n+  auto_vec<function_point> worklist;\n+\n+  /* Add all immediate uses of name to the worklist.\n+     Compare with debug_immediate_uses.  */\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n+    {\n+      if (USE_STMT (use_p))\n+\t{\n+\t  const gimple *use_stmt = USE_STMT (use_p);\n+\t  if (map.get_logger ())\n+\t    {\n+\t      pretty_printer pp;\n+\t      pp_gimple_stmt_1 (&pp, use_stmt, 0, (dump_flags_t)0);\n+\t      map.log (\"used by stmt: %s\", pp_formatted_text (&pp));\n+\t    }\n+\n+\t  const supernode *snode\n+\t    = map.get_sg ().get_supernode_for_stmt (use_stmt);\n+\n+\t  /* If it's a use within a phi node, then we care about\n+\t     which in-edge we came from.  */\n+\t  if (use_stmt->code == GIMPLE_PHI)\n+\t    {\n+\t      for (gphi_iterator gpi\n+\t\t     = const_cast<supernode *> (snode)->start_phis ();\n+\t\t   !gsi_end_p (gpi); gsi_next (&gpi))\n+\t\t{\n+\t\t  gphi *phi = gpi.phi ();\n+\t\t  if (phi == use_stmt)\n+\t\t    {\n+\t\t      /* Find arguments (and thus in-edges) which use NAME.  */\n+\t\t      for (unsigned arg_idx = 0;\n+\t\t\t   arg_idx < gimple_phi_num_args (phi);\n+\t\t\t   ++arg_idx)\n+\t\t\t{\n+\t\t\t  if (name == gimple_phi_arg (phi, arg_idx)->def)\n+\t\t\t    {\n+\t\t\t      edge in_edge = gimple_phi_arg_edge (phi, arg_idx);\n+\t\t\t      const superedge *in_sedge\n+\t\t\t\t= map.get_sg ().get_edge_for_cfg_edge (in_edge);\n+\t\t\t      function_point point\n+\t\t\t\t= function_point::before_supernode\n+\t\t\t\t(snode, in_sedge);\n+\t\t\t      add_to_worklist (point, &worklist,\n+\t\t\t\t\t       map.get_logger ());\n+\t\t\t      m_points_needing_name.add (point);\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      function_point point = before_use_stmt (map, use_stmt);\n+\t      add_to_worklist (point, &worklist, map.get_logger ());\n+\t      m_points_needing_name.add (point);\n+\n+\t      /* We also need to add uses for conditionals and switches,\n+\t\t where the stmt \"happens\" at the after_supernode, for filtering\n+\t\t the out-edges.  */\n+\t      if (use_stmt == snode->get_last_stmt ())\n+\t\t{\n+\t\t  if (map.get_logger ())\n+\t\t    map.log (\"last stmt in BB\");\n+\t\t  function_point point\n+\t\t    = function_point::after_supernode (snode);\n+\t\t  add_to_worklist (point, &worklist, map.get_logger ());\n+\t\t  m_points_needing_name.add (point);\n+\t\t}\n+\t      else\n+\t\tif (map.get_logger ())\n+\t\t  map.log (\"not last stmt in BB\");\n+\t    }\n+\t}\n+    }\n+\n+  /* Process worklist by walking backwards until we reach the def stmt.  */\n+  {\n+    log_scope s (map.get_logger (), \"processing worklist\");\n+    while (worklist.length () > 0)\n+      {\n+\tfunction_point point = worklist.pop ();\n+\tprocess_point (point, &worklist, map);\n+    }\n+  }\n+\n+  if (map.get_logger ())\n+    {\n+      map.log (\"%qE in %qD is needed to process:\", name, fun->decl);\n+      for (point_set_t::iterator iter = m_points_needing_name.begin ();\n+\t   iter != m_points_needing_name.end ();\n+\t   ++iter)\n+\t{\n+\t  map.start_log_line ();\n+\t  map.get_logger ()->log_partial (\"  point: \");\n+\t  (*iter).print (map.get_logger ()->get_printer (), format (false));\n+\t  map.end_log_line ();\n+\t}\n+    }\n+}\n+\n+/* Return true if the SSA name is needed at POINT.  */\n+\n+bool\n+state_purge_per_ssa_name::needed_at_point_p (const function_point &point) const\n+{\n+  return const_cast <point_set_t &> (m_points_needing_name).contains (point);\n+}\n+\n+/* Get the function_point representing immediately before USE_STMT.\n+   Subroutine of ctor.  */\n+\n+function_point\n+state_purge_per_ssa_name::before_use_stmt (const state_purge_map &map,\n+\t\t\t\t\t   const gimple *use_stmt)\n+{\n+  gcc_assert (use_stmt->code != GIMPLE_PHI);\n+\n+  const supernode *supernode\n+    = map.get_sg ().get_supernode_for_stmt (use_stmt);\n+  unsigned int stmt_idx = supernode->get_stmt_index (use_stmt);\n+  return function_point::before_stmt (supernode, stmt_idx);\n+}\n+\n+/* Add POINT to *WORKLIST if the point has not already been seen.\n+   Subroutine of ctor.  */\n+\n+void\n+state_purge_per_ssa_name::add_to_worklist (const function_point &point,\n+\t\t\t\t\t   auto_vec<function_point> *worklist,\n+\t\t\t\t\t   logger *logger)\n+{\n+  LOG_FUNC (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"point: '\");\n+      point.print (logger->get_printer (), format (false));\n+      logger->log_partial (\"' for worklist for %qE\", m_name);\n+      logger->end_log_line ();\n+    }\n+\n+  gcc_assert (point.get_function () == m_fun);\n+  if (point.get_from_edge ())\n+    gcc_assert (point.get_from_edge ()->get_kind () == SUPEREDGE_CFG_EDGE);\n+\n+  if (m_points_needing_name.contains (point))\n+    {\n+      if (logger)\n+\tlogger->log (\"already seen for %qE\", m_name);\n+    }\n+  else\n+    {\n+      if (logger)\n+\tlogger->log (\"not seen; adding to worklist for %qE\", m_name);\n+      m_points_needing_name.add (point);\n+      worklist->safe_push (point);\n+    }\n+}\n+\n+/* Process POINT, popped from WORKLIST.\n+   Iterate over predecessors of POINT, adding to WORKLIST.  */\n+\n+void\n+state_purge_per_ssa_name::process_point (const function_point &point,\n+\t\t\t\t\t auto_vec<function_point> *worklist,\n+\t\t\t\t\t const state_purge_map &map)\n+{\n+  logger *logger = map.get_logger ();\n+  LOG_FUNC (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"considering point: '\");\n+      point.print (logger->get_printer (), format (false));\n+      logger->log_partial (\"' for %qE\", m_name);\n+      logger->end_log_line ();\n+    }\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (m_name);\n+\n+  const supernode *snode = point.get_supernode ();\n+\n+  switch (point.get_kind ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case PK_ORIGIN:\n+      break;\n+\n+    case PK_BEFORE_SUPERNODE:\n+      {\n+\tfor (gphi_iterator gpi\n+\t       = const_cast<supernode *> (snode)->start_phis ();\n+\t     !gsi_end_p (gpi); gsi_next (&gpi))\n+\t  {\n+\t    gphi *phi = gpi.phi ();\n+\t    if (phi == def_stmt)\n+\t      {\n+\t\tif (logger)\n+\t\t  logger->log (\"def stmt within phis; terminating\");\n+\t\treturn;\n+\t      }\n+\t  }\n+\n+\t/* Add given pred to worklist.  */\n+\tif (point.get_from_edge ())\n+\t  {\n+\t    gcc_assert (point.get_from_edge ()->m_src);\n+\t    add_to_worklist\n+\t      (function_point::after_supernode (point.get_from_edge ()->m_src),\n+\t       worklist, logger);\n+\t  }\n+\telse\n+\t  {\n+\t    /* Add any intraprocedually edge for a call.  */\n+\t    if (snode->m_returning_call)\n+\t      {\n+\t\tcgraph_edge *cedge\n+\t\t  = supergraph_call_edge (snode->m_fun,\n+\t\t\t\t\t  snode->m_returning_call);\n+\t\tgcc_assert (cedge);\n+\t\tsuperedge *sedge\n+\t\t  = map.get_sg ().get_intraprocedural_edge_for_call (cedge);\n+\t\tgcc_assert (sedge);\n+\t\tadd_to_worklist\n+\t\t  (function_point::after_supernode (sedge->m_src),\n+\t\t   worklist, logger);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case PK_BEFORE_STMT:\n+      {\n+\tif (def_stmt == point.get_stmt ())\n+\t  {\n+\t    if (logger)\n+\t      logger->log (\"def stmt; terminating\");\n+\t    return;\n+\t  }\n+\tif (point.get_stmt_idx () > 0)\n+\t  add_to_worklist (function_point::before_stmt\n+\t\t\t     (snode, point.get_stmt_idx () - 1),\n+\t\t\t   worklist, logger);\n+\telse\n+\t{\n+\t  /* Add before_supernode to worklist.  This captures the in-edge,\n+\t     so we have to do it once per in-edge.  */\n+\t  unsigned i;\n+\t  superedge *pred;\n+\t  FOR_EACH_VEC_ELT (snode->m_preds, i, pred)\n+\t    add_to_worklist (function_point::before_supernode (snode,\n+\t\t\t\t\t\t\t       pred),\n+\t\t\t     worklist, logger);\n+\t}\n+      }\n+      break;\n+\n+    case PK_AFTER_SUPERNODE:\n+      {\n+\tif (snode->m_stmts.length ())\n+\t  add_to_worklist\n+\t    (function_point::before_stmt (snode,\n+\t\t\t\t\t  snode->m_stmts.length () - 1),\n+\t     worklist, logger);\n+\telse\n+\t  {\n+\t    /* Add before_supernode to worklist.  This captures the in-edge,\n+\t       so we have to do it once per in-edge.  */\n+\t    unsigned i;\n+\t    superedge *pred;\n+\t    FOR_EACH_VEC_ELT (snode->m_preds, i, pred)\n+\t      add_to_worklist (function_point::before_supernode (snode,\n+\t\t\t\t\t\t\t\t pred),\n+\t\t\t       worklist, logger);\n+\t    /* If it's the initial BB, add it, to ensure that we\n+\t       have \"before supernode\" for the initial ENTRY block, and don't\n+\t       erroneously purge SSA names for initial values of parameters.  */\n+\t    if (snode->entry_p ())\n+\t      {\n+\t\tadd_to_worklist\n+\t\t  (function_point::before_supernode (snode, NULL),\n+\t\t   worklist, logger);\n+\t      }\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+/* class state_purge_annotator : public dot_annotator.  */\n+\n+/* Implementation of dot_annotator::add_node_annotations vfunc for\n+   state_purge_annotator.\n+\n+   Add an additional record showing which names are purged on entry\n+   to the supernode N.  */\n+\n+void\n+state_purge_annotator::add_node_annotations (graphviz_out *gv,\n+\t\t\t\t\t     const supernode &n) const\n+{\n+  if (m_map == NULL)\n+    return;\n+\n+  pretty_printer *pp = gv->get_pp ();\n+\n+   pp_printf (pp, \"annotation_for_node_%i\", n.m_index);\n+   pp_printf (pp, \" [shape=none,margin=0,style=filled,fillcolor=%s,label=\\\"\",\n+\t      \"lightblue\");\n+   pp_write_text_to_stream (pp);\n+\n+   // FIXME: passing in a NULL in-edge means we get no hits\n+   function_point before_supernode\n+     (function_point::before_supernode (&n, NULL));\n+\n+   for (state_purge_map::iterator iter = m_map->begin ();\n+\titer != m_map->end ();\n+\t++iter)\n+     {\n+       tree name = (*iter).first;\n+       state_purge_per_ssa_name *per_name_data = (*iter).second;\n+       if (per_name_data->get_function () == n.m_fun)\n+\t {\n+PUSH_IGNORE_WFORMAT\n+\t   if (per_name_data->needed_at_point_p (before_supernode))\n+\t     pp_printf (pp, \"%qE needed here\", name);\n+\t   else\n+\t     pp_printf (pp, \"%qE not needed here\", name);\n+POP_IGNORE_WFORMAT\n+\t }\n+       pp_newline (pp);\n+     }\n+\n+   pp_string (pp, \"\\\"];\\n\\n\");\n+   pp_flush (pp);\n+}\n+\n+/* Print V to GV as a comma-separated list in braces within a <TR>,\n+   titling it with TITLE.\n+\n+   Subroutine of state_purge_annotator::add_stmt_annotations.  */\n+\n+static void\n+print_vec_of_names (graphviz_out *gv, const char *title,\n+\t\t    const auto_vec<tree> &v)\n+{\n+  pretty_printer *pp = gv->get_pp ();\n+  tree name;\n+  unsigned i;\n+  gv->begin_tr ();\n+  pp_printf (pp, \"%s: {\", title);\n+  FOR_EACH_VEC_ELT (v, i, name)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+PUSH_IGNORE_WFORMAT\n+      pp_printf (pp, \"%qE\", name);\n+POP_IGNORE_WFORMAT\n+    }\n+  pp_printf (pp, \"}\");\n+  pp_write_text_as_html_like_dot_to_stream (pp);\n+  gv->end_tr ();\n+  pp_newline (pp);\n+}\n+\n+/* Implementation of dot_annotator::add_stmt_annotations for\n+   state_purge_annotator.\n+\n+   Add text showing which names are purged at STMT.  */\n+\n+void\n+state_purge_annotator::add_stmt_annotations (graphviz_out *gv,\n+\t\t\t\t\t     const gimple *stmt) const\n+{\n+  if (m_map == NULL)\n+    return;\n+\n+  if (stmt->code == GIMPLE_PHI)\n+    return;\n+\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  pp_newline (pp);\n+\n+  const supernode *supernode = m_map->get_sg ().get_supernode_for_stmt (stmt);\n+  unsigned int stmt_idx = supernode->get_stmt_index (stmt);\n+  function_point before_stmt\n+    (function_point::before_stmt (supernode, stmt_idx));\n+\n+  auto_vec<tree> needed;\n+  auto_vec<tree> not_needed;\n+  for (state_purge_map::iterator iter = m_map->begin ();\n+       iter != m_map->end ();\n+       ++iter)\n+    {\n+      tree name = (*iter).first;\n+      state_purge_per_ssa_name *per_name_data = (*iter).second;\n+      if (per_name_data->get_function () == supernode->m_fun)\n+\t{\n+\t  if (per_name_data->needed_at_point_p (before_stmt))\n+\t    needed.safe_push (name);\n+\t  else\n+\t    not_needed.safe_push (name);\n+\t}\n+    }\n+\n+  print_vec_of_names (gv, \"needed here\", needed);\n+  print_vec_of_names (gv, \"not needed here\", not_needed);\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "e33733a6cc5bacc42f8d2521e46b7ae9ac1497c4", "filename": "gcc/analyzer/state-purge.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fstate-purge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fstate-purge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstate-purge.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,162 @@\n+/* Classes for purging state at function_points.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_STATE_PURGE_H\n+#define GCC_ANALYZER_STATE_PURGE_H\n+\n+/* Hash traits for function_point.  */\n+\n+template <> struct default_hash_traits<function_point>\n+: public pod_hash_traits<function_point>\n+{\n+  static const bool empty_zero_p = false;\n+};\n+\n+template <>\n+inline hashval_t\n+pod_hash_traits<function_point>::hash (value_type v)\n+{\n+  return v.hash ();\n+}\n+\n+template <>\n+inline bool\n+pod_hash_traits<function_point>::equal (const value_type &existing,\n+                                 const value_type &candidate)\n+{\n+  return existing == candidate;\n+}\n+template <>\n+inline void\n+pod_hash_traits<function_point>::mark_deleted (value_type &v)\n+{\n+  v = function_point::deleted ();\n+}\n+template <>\n+inline void\n+pod_hash_traits<function_point>::mark_empty (value_type &v)\n+{\n+  v = function_point::empty ();\n+}\n+template <>\n+inline bool\n+pod_hash_traits<function_point>::is_deleted (value_type v)\n+{\n+  return v.get_kind () == PK_DELETED;\n+}\n+template <>\n+inline bool\n+pod_hash_traits<function_point>::is_empty (value_type v)\n+{\n+  return v.get_kind () == PK_EMPTY;\n+}\n+\n+/* The result of analyzing which SSA names can be purged from state at\n+   different points in the program, so that we can simplify program_state\n+   objects, in the hope of reducing state-blowup.  */\n+\n+class state_purge_map : public log_user\n+{\n+public:\n+  typedef ordered_hash_map<tree, state_purge_per_ssa_name *> map_t;\n+  typedef map_t::iterator iterator;\n+\n+  state_purge_map (const supergraph &sg, logger *logger);\n+  ~state_purge_map ();\n+\n+  const state_purge_per_ssa_name &get_data_for_ssa_name (tree name) const\n+  {\n+    gcc_assert (TREE_CODE (name) == SSA_NAME);\n+    if (tree var = SSA_NAME_VAR (name))\n+      if (TREE_CODE (var) == VAR_DECL)\n+\tgcc_assert (!VAR_DECL_IS_VIRTUAL_OPERAND (var));\n+\n+    state_purge_per_ssa_name **slot\n+      = const_cast <map_t&> (m_map).get (name);\n+    return **slot;\n+  }\n+\n+  const supergraph &get_sg () const { return m_sg; }\n+\n+  iterator begin () const { return m_map.begin (); }\n+  iterator end () const { return m_map.end (); }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (state_purge_map);\n+\n+  const supergraph &m_sg;\n+  map_t m_map;\n+};\n+\n+/* The part of a state_purge_map relating to a specific SSA name.\n+\n+   The result of analyzing a given SSA name, recording which\n+   function_points need to retain state information about it to handle\n+   their successor states, so that we can simplify program_state objects,\n+   in the hope of reducing state-blowup.  */\n+\n+class state_purge_per_ssa_name\n+{\n+public:\n+  state_purge_per_ssa_name (const state_purge_map &map,\n+\t\t\t    tree name,\n+\t\t\t    function *fun);\n+\n+  bool needed_at_point_p (const function_point &point) const;\n+\n+  function *get_function () const { return m_fun; }\n+\n+private:\n+  static function_point before_use_stmt (const state_purge_map &map,\n+\t\t\t\t\t const gimple *use_stmt);\n+\n+  void add_to_worklist (const function_point &point,\n+\t\t\tauto_vec<function_point> *worklist,\n+\t\t\tlogger *logger);\n+\n+  void process_point (const function_point &point,\n+\t\t      auto_vec<function_point> *worklist,\n+\t\t      const state_purge_map &map);\n+\n+  typedef hash_set<function_point> point_set_t;\n+  point_set_t m_points_needing_name;\n+  tree m_name;\n+  function *m_fun;\n+};\n+\n+/* Subclass of dot_annotator for use by -fdump-analyzer-state-purge.\n+   Annotate the .dot output with state-purge information.  */\n+\n+class state_purge_annotator : public dot_annotator\n+{\n+public:\n+  state_purge_annotator (const state_purge_map *map) : m_map (map) {}\n+\n+  void add_node_annotations (graphviz_out *gv, const supernode &n)\n+    const FINAL OVERRIDE;\n+\n+  void add_stmt_annotations (graphviz_out *gv, const gimple *stmt)\n+    const FINAL OVERRIDE;\n+\n+private:\n+  const state_purge_map *m_map;\n+};\n+\n+#endif /* GCC_ANALYZER_STATE_PURGE_H */"}, {"sha": "24f83c9b719b5d96c74c8e4f7c40131a0c95896d", "filename": "gcc/analyzer/supergraph.cc", "status": "added", "additions": 961, "deletions": 0, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,961 @@\n+/* \"Supergraph\" classes that combine CFGs and callgraph into one digraph.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"function.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"timevar.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"graphviz.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"cfganal.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+/* Get the cgraph_edge, but only if there's an underlying function body.  */\n+\n+cgraph_edge *\n+supergraph_call_edge (function *fun, gimple *stmt)\n+{\n+  gcall *call = dyn_cast<gcall *> (stmt);\n+  if (!call)\n+    return NULL;\n+  cgraph_edge *edge = cgraph_node::get (fun->decl)->get_edge (stmt);\n+  if (!edge)\n+    return NULL;\n+  if (!edge->callee)\n+    return NULL; /* e.g. for a function pointer.  */\n+  if (!edge->callee->get_fun ())\n+    return NULL;\n+  return edge;\n+}\n+\n+/* supergraph's ctor.  Walk the callgraph, building supernodes for each\n+   CFG basic block, splitting the basic blocks at callsites.  Join\n+   together the supernodes with interprocedural and intraprocedural\n+   superedges as appropriate.  */\n+\n+supergraph::supergraph (logger *logger)\n+{\n+  auto_timevar tv (TV_ANALYZER_SUPERGRAPH);\n+\n+  LOG_FUNC (logger);\n+\n+  /* First pass: make supernodes.  */\n+  {\n+    /* Sort the cgraph_nodes?  */\n+    cgraph_node *node;\n+    FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *fun = node->get_fun ();\n+\n+      /* Ensure that EDGE_DFS_BACK is correct for every CFG edge in\n+\t the supergraph (by doing it per-function).  */\n+      auto_cfun sentinel (fun);\n+      mark_dfs_back_edges ();\n+\n+      const int start_idx = m_nodes.length ();\n+\n+      basic_block bb;\n+      FOR_ALL_BB_FN (bb, fun)\n+\t{\n+\t  /* The initial supernode for the BB gets the phi nodes (if any).  */\n+\t  supernode *node_for_stmts = add_node (fun, bb, NULL, phi_nodes (bb));\n+\t  m_bb_to_initial_node.put (bb, node_for_stmts);\n+\t  for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);\n+\t       gsi_next (&gpi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gpi);\n+\t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n+\t    }\n+\n+\t  /* Append statements from BB to the current supernode, splitting\n+\t     them into a new supernode at each call site; such call statements\n+\t     appear in both supernodes (representing call and return).  */\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      node_for_stmts->m_stmts.safe_push (stmt);\n+\t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n+\t      if (cgraph_edge *edge = supergraph_call_edge (fun, stmt))\n+\t\t{\n+\t\t  m_cgraph_edge_to_caller_prev_node.put(edge, node_for_stmts);\n+\t\t  node_for_stmts = add_node (fun, bb, as_a <gcall *> (stmt), NULL);\n+\t\t  m_cgraph_edge_to_caller_next_node.put (edge, node_for_stmts);\n+\t\t}\n+\t    }\n+\n+\t  m_bb_to_final_node.put (bb, node_for_stmts);\n+\t}\n+\n+      const unsigned num_snodes = m_nodes.length () - start_idx;\n+      m_function_to_num_snodes.put (fun, num_snodes);\n+\n+      if (logger)\n+\t{\n+\t  const int end_idx = m_nodes.length () - 1;\n+\t  logger->log (\"SN: %i...%i: function %qD\",\n+\t\t       start_idx, end_idx, fun->decl);\n+\t}\n+    }\n+  }\n+\n+  /* Second pass: make superedges.  */\n+  {\n+    /* Make superedges for CFG edges.  */\n+    for (bb_to_node_t::iterator iter = m_bb_to_final_node.begin ();\n+\t iter != m_bb_to_final_node.end ();\n+\t ++iter)\n+      {\n+\tbasic_block bb = (*iter).first;\n+\tsupernode *src_supernode = (*iter).second;\n+\n+\t::edge cfg_edge;\n+\tint idx;\n+\tif (bb->succs)\n+\t  FOR_EACH_VEC_ELT (*bb->succs, idx, cfg_edge)\n+\t    {\n+\t      basic_block dest_cfg_block = cfg_edge->dest;\n+\t      supernode *dest_supernode\n+\t\t= *m_bb_to_initial_node.get (dest_cfg_block);\n+\t      cfg_superedge *cfg_sedge\n+\t\t= add_cfg_edge (src_supernode, dest_supernode, cfg_edge, idx);\n+\t      m_cfg_edge_to_cfg_superedge.put (cfg_edge, cfg_sedge);\n+\t    }\n+      }\n+\n+    /* Make interprocedural superedges for calls.  */\n+    {\n+      for (cgraph_edge_to_node_t::iterator iter\n+\t     = m_cgraph_edge_to_caller_prev_node.begin ();\n+\t   iter != m_cgraph_edge_to_caller_prev_node.end ();\n+\t   ++iter)\n+\t{\n+\t  cgraph_edge *edge = (*iter).first;\n+\t  supernode *caller_prev_supernode = (*iter).second;\n+\t  basic_block callee_cfg_block\n+\t    = ENTRY_BLOCK_PTR_FOR_FN (edge->callee->get_fun ());\n+\t  supernode *callee_supernode\n+\t    = *m_bb_to_initial_node.get (callee_cfg_block);\n+\t  call_superedge *sedge\n+\t    = add_call_superedge (caller_prev_supernode,\n+\t\t\t\t  callee_supernode,\n+\t\t\t\t  edge);\n+\t  m_cgraph_edge_to_call_superedge.put (edge, sedge);\n+\t}\n+    }\n+\n+    /* Make interprocedural superedges for returns.  */\n+    {\n+      for (cgraph_edge_to_node_t::iterator iter\n+\t     = m_cgraph_edge_to_caller_next_node.begin ();\n+\t   iter != m_cgraph_edge_to_caller_next_node.end ();\n+\t   ++iter)\n+\t{\n+\t  cgraph_edge *edge = (*iter).first;\n+\t  supernode *caller_next_supernode = (*iter).second;\n+\t  basic_block callee_cfg_block\n+\t    = EXIT_BLOCK_PTR_FOR_FN (edge->callee->get_fun ());\n+\t  supernode *callee_supernode\n+\t    = *m_bb_to_initial_node.get (callee_cfg_block);\n+\t  return_superedge *sedge\n+\t    = add_return_superedge (callee_supernode,\n+\t\t\t\t    caller_next_supernode,\n+\t\t\t\t    edge);\n+\t  m_cgraph_edge_to_return_superedge.put (edge, sedge);\n+\t}\n+    }\n+\n+    /* Make intraprocedural superedges linking the two halves of a call.  */\n+    {\n+      for (cgraph_edge_to_node_t::iterator iter\n+\t     = m_cgraph_edge_to_caller_prev_node.begin ();\n+\t   iter != m_cgraph_edge_to_caller_prev_node.end ();\n+\t   ++iter)\n+\t{\n+\t  cgraph_edge *edge = (*iter).first;\n+\t  supernode *caller_prev_supernode = (*iter).second;\n+\t  supernode *caller_next_supernode\n+\t    = *m_cgraph_edge_to_caller_next_node.get (edge);\n+\t  superedge *sedge\n+\t    = new callgraph_superedge (caller_prev_supernode,\n+\t\t\t\t       caller_next_supernode,\n+\t\t\t\t       SUPEREDGE_INTRAPROCEDURAL_CALL,\n+\t\t\t\t       edge);\n+\t  add_edge (sedge);\n+\t  m_cgraph_edge_to_intraproc_superedge.put (edge, sedge);\n+\t}\n+\n+    }\n+  }\n+}\n+\n+/* Dump this graph in .dot format to PP, using DUMP_ARGS.\n+   Cluster the supernodes by function, then by BB from original CFG.  */\n+\n+void\n+supergraph::dump_dot_to_pp (pretty_printer *pp,\n+\t\t\t    const dump_args_t &dump_args) const\n+{\n+  graphviz_out gv (pp);\n+\n+  pp_string (pp, \"digraph \\\"\");\n+  pp_write_text_to_stream (pp);\n+  pp_string (pp, \"supergraph\");\n+  pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/false);\n+  pp_string (pp, \"\\\" {\\n\");\n+  gv.indent ();\n+\n+  gv.println (\"overlap=false;\");\n+  gv.println (\"compound=true;\");\n+\n+  /* TODO: maybe (optionally) sub-subdivide by TU, for LTO; see also:\n+     https://gcc-python-plugin.readthedocs.io/en/latest/_images/sample-supergraph.png\n+  */\n+\n+  /* Break out the supernodes into clusters by function.  */\n+  {\n+    cgraph_node *node;\n+    FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *fun = node->get_fun ();\n+      const char *funcname = function_name (fun);\n+      gv.println (\"subgraph \\\"cluster_%s\\\" {\",\n+\t\t  funcname);\n+      gv.indent ();\n+      pp_printf (pp,\n+\t\t (\"style=\\\"dashed\\\";\"\n+\t\t  \" color=\\\"black\\\";\"\n+\t\t  \" label=\\\"%s\\\";\\n\"),\n+\t\t funcname);\n+\n+      /* Break out the nodes into clusters by BB from original CFG.  */\n+      {\n+\tbasic_block bb;\n+\tFOR_ALL_BB_FN (bb, fun)\n+\t  {\n+\t    if (dump_args.m_flags & SUPERGRAPH_DOT_SHOW_BBS)\n+\t      {\n+\t\tgv.println (\"subgraph \\\"cluster_%s_bb_%i\\\" {\",\n+\t\t\t    funcname, bb->index);\n+\t\tgv.indent ();\n+\t\tpp_printf (pp,\n+\t\t\t   (\"style=\\\"dashed\\\";\"\n+\t\t\t    \" color=\\\"black\\\";\"\n+\t\t\t    \" label=\\\"bb: %i\\\";\\n\"),\n+\t\t\t   bb->index);\n+\t      }\n+\n+\t    // TODO: maybe keep an index per-function/per-bb to speed this up???\n+\t    int i;\n+\t    supernode *n;\n+\t    FOR_EACH_VEC_ELT (m_nodes, i, n)\n+\t      if (n->m_fun == fun && n->m_bb == bb)\n+\t\tn->dump_dot (&gv, dump_args);\n+\n+\t    if (dump_args.m_flags & SUPERGRAPH_DOT_SHOW_BBS)\n+\t      {\n+\t\t/* Terminate per-bb \"subgraph\" */\n+\t\tgv.outdent ();\n+\t\tgv.println (\"}\");\n+\t      }\n+\t  }\n+      }\n+\n+      /* Add an invisible edge from ENTRY to EXIT, to improve the graph layout.  */\n+      pp_string (pp, \"\\t\");\n+      get_node_for_function_entry (fun)->dump_dot_id (pp);\n+      pp_string (pp, \":s -> \");\n+      get_node_for_function_exit (fun)->dump_dot_id (pp);\n+      pp_string (pp, \":n [style=\\\"invis\\\",constraint=true];\\n\");\n+\n+      /* Terminate per-function \"subgraph\" */\n+      gv.outdent ();\n+      gv.println (\"}\");\n+    }\n+  }\n+\n+  /* Superedges.  */\n+  int i;\n+  superedge *e;\n+  FOR_EACH_VEC_ELT (m_edges, i, e)\n+    e->dump_dot (&gv, dump_args);\n+\n+  /* Terminate \"digraph\" */\n+  gv.outdent ();\n+  gv.println (\"}\");\n+}\n+\n+/* Dump this graph in .dot format to FP, using DUMP_ARGS.  */\n+\n+void\n+supergraph::dump_dot_to_file (FILE *fp, const dump_args_t &dump_args) const\n+{\n+  pretty_printer *pp = global_dc->printer->clone ();\n+  pp_show_color (pp) = 0;\n+  /* %qE in logs for SSA_NAMEs should show the ssa names, rather than\n+     trying to prettify things by showing the underlying var.  */\n+  pp_format_decoder (pp) = default_tree_printer;\n+\n+  pp->buffer->stream = fp;\n+  dump_dot_to_pp (pp, dump_args);\n+  pp_flush (pp);\n+  delete pp;\n+}\n+\n+/* Dump this graph in .dot format to PATH, using DUMP_ARGS.  */\n+\n+void\n+supergraph::dump_dot (const char *path, const dump_args_t &dump_args) const\n+{\n+  FILE *fp = fopen (path, \"w\");\n+  dump_dot_to_file (fp, dump_args);\n+  fclose (fp);\n+}\n+\n+/* Create a supernode for BB within FUN and add it to this supergraph.\n+\n+   If RETURNING_CALL is non-NULL, the supernode represents the resumption\n+   of the basic block after returning from that call.\n+\n+   If PHI_NODES is non-NULL, this is the initial supernode for the basic\n+   block, and is responsible for any handling of the phi nodes.  */\n+\n+supernode *\n+supergraph::add_node (function *fun, basic_block bb, gcall *returning_call,\n+\t\t      gimple_seq phi_nodes)\n+{\n+  supernode *n = new supernode (fun, bb, returning_call, phi_nodes,\n+\t\t\t\tm_nodes.length ());\n+  m_nodes.safe_push (n);\n+  return n;\n+}\n+\n+/* Create a new cfg_superedge from SRC to DEST for the underlying CFG edge E,\n+   adding it to this supergraph.\n+\n+   If the edge is for a switch statement, create a switch_cfg_superedge\n+   subclass using IDX (the index of E within the out-edges from SRC's\n+   underlying basic block).  */\n+\n+cfg_superedge *\n+supergraph::add_cfg_edge (supernode *src, supernode *dest, ::edge e, int idx)\n+{\n+  /* Special-case switch edges.  */\n+  gimple *stmt = src->get_last_stmt ();\n+  cfg_superedge *new_edge;\n+  if (stmt && stmt->code == GIMPLE_SWITCH)\n+    new_edge = new switch_cfg_superedge (src, dest, e, idx);\n+  else\n+    new_edge = new cfg_superedge (src, dest, e);\n+  add_edge (new_edge);\n+  return new_edge;\n+}\n+\n+/* Create and add a call_superedge representing an interprocedural call\n+   from SRC to DEST, using CEDGE.  */\n+\n+call_superedge *\n+supergraph::add_call_superedge (supernode *src, supernode *dest,\n+\t\t\t\tcgraph_edge *cedge)\n+{\n+  call_superedge *new_edge = new call_superedge (src, dest, cedge);\n+  add_edge (new_edge);\n+  return new_edge;\n+}\n+\n+/* Create and add a return_superedge representing returning from an\n+   interprocedural call, returning from SRC to DEST, using CEDGE.  */\n+\n+return_superedge *\n+supergraph::add_return_superedge (supernode *src, supernode *dest,\n+\t\t\t\t  cgraph_edge *cedge)\n+{\n+  return_superedge *new_edge = new return_superedge (src, dest, cedge);\n+  add_edge (new_edge);\n+  return new_edge;\n+}\n+\n+/* Implementation of dnode::dump_dot vfunc for supernodes.\n+\n+   Write a cluster for the node, and within it a .dot node showing\n+   the phi nodes and stmts.  Call into any node annotator from ARGS to\n+   potentially add other records to the cluster.  */\n+\n+void\n+supernode::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n+{\n+  gv->println (\"subgraph cluster_node_%i {\",\n+\t       m_index);\n+  gv->indent ();\n+\n+  gv->println(\"style=\\\"solid\\\";\");\n+  gv->println(\"color=\\\"black\\\";\");\n+  gv->println(\"fillcolor=\\\"lightgrey\\\";\");\n+  gv->println(\"label=\\\"sn: %i\\\";\", m_index);\n+\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  if (args.m_node_annotator)\n+    args.m_node_annotator->add_node_annotations (gv, *this);\n+\n+  gv->write_indent ();\n+  dump_dot_id (pp);\n+  pp_printf (pp,\n+\t     \" [shape=none,margin=0,style=filled,fillcolor=%s,label=<\",\n+\t     \"lightgrey\");\n+  pp_string (pp, \"<TABLE BORDER=\\\"0\\\">\");\n+  pp_write_text_to_stream (pp);\n+\n+  if (m_returning_call)\n+    {\n+      gv->begin_tr ();\n+      pp_string (pp, \"returning call: \");\n+      gv->end_tr ();\n+\n+      gv->begin_tr ();\n+      pp_gimple_stmt_1 (pp, m_returning_call, 0, (dump_flags_t)0);\n+      pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_tr ();\n+\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, m_returning_call);\n+      pp_newline (pp);\n+    }\n+\n+  if (entry_p ())\n+    {\n+      pp_string (pp, \"<TR><TD>ENTRY</TD></TR>\");\n+      pp_newline (pp);\n+    }\n+\n+  if (return_p ())\n+    {\n+      pp_string (pp, \"<TR><TD>EXIT</TD></TR>\");\n+      pp_newline (pp);\n+    }\n+\n+  /* Phi nodes.  */\n+  for (gphi_iterator gpi = const_cast<supernode *> (this)->start_phis ();\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      const gimple *stmt = gsi_stmt (gpi);\n+      gv->begin_tr ();\n+      pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n+      pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_tr ();\n+\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt);\n+\n+      pp_newline (pp);\n+    }\n+\n+  /* Statements.  */\n+  int i;\n+  gimple *stmt;\n+  FOR_EACH_VEC_ELT (m_stmts, i, stmt)\n+    {\n+      gv->begin_tr ();\n+      pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n+      pp_write_text_as_html_like_dot_to_stream (pp);\n+      gv->end_tr ();\n+\n+      if (args.m_node_annotator)\n+\targs.m_node_annotator->add_stmt_annotations (gv, stmt);\n+\n+      pp_newline (pp);\n+    }\n+\n+  pp_string (pp, \"</TABLE>>];\\n\\n\");\n+  pp_flush (pp);\n+\n+  /* Terminate \"subgraph\" */\n+  gv->outdent ();\n+  gv->println (\"}\");\n+}\n+\n+/* Write an ID for this node to PP, for use in .dot output.  */\n+\n+void\n+supernode::dump_dot_id (pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"node_%i\", m_index);\n+}\n+\n+/* Get a location_t for the start of this supernode.  */\n+\n+location_t\n+supernode::get_start_location () const\n+{\n+  if (m_returning_call && m_returning_call->location != UNKNOWN_LOCATION)\n+    return m_returning_call->location;\n+\n+  int i;\n+  gimple *stmt;\n+  FOR_EACH_VEC_ELT (m_stmts, i, stmt)\n+    if (stmt->location != UNKNOWN_LOCATION)\n+      return stmt->location;\n+\n+  if (entry_p ())\n+    {\n+      // TWEAK: show the decl instead; this leads to more readable output:\n+      return DECL_SOURCE_LOCATION (m_fun->decl);\n+\n+      return m_fun->function_start_locus;\n+    }\n+  if (return_p ())\n+    return m_fun->function_end_locus;\n+\n+  return UNKNOWN_LOCATION;\n+}\n+\n+/* Get a location_t for the end of this supernode.  */\n+\n+location_t\n+supernode::get_end_location () const\n+{\n+  int i;\n+  gimple *stmt;\n+  FOR_EACH_VEC_ELT_REVERSE (m_stmts, i, stmt)\n+    if (stmt->location != UNKNOWN_LOCATION)\n+      return stmt->location;\n+\n+  if (m_returning_call && m_returning_call->location != UNKNOWN_LOCATION)\n+    return m_returning_call->location;\n+\n+  if (entry_p ())\n+    return m_fun->function_start_locus;\n+  if (return_p ())\n+    return m_fun->function_end_locus;\n+\n+  return UNKNOWN_LOCATION;\n+}\n+\n+/* Given STMT within this supernode, return its index within m_stmts.  */\n+\n+unsigned int\n+supernode::get_stmt_index (const gimple *stmt) const\n+{\n+  unsigned i;\n+  gimple *iter_stmt;\n+  FOR_EACH_VEC_ELT (m_stmts, i, iter_stmt)\n+    if (iter_stmt == stmt)\n+      return i;\n+  gcc_unreachable ();\n+}\n+\n+/* Implementation of dedge::dump_dot for superedges.\n+   Write a .dot edge to GV representing this superedge.  */\n+\n+void\n+superedge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n+{\n+  const char *style = \"\\\"solid,bold\\\"\";\n+  const char *color = \"black\";\n+  int weight = 10;\n+  const char *constraint = \"true\";\n+\n+  switch (m_kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case SUPEREDGE_CFG_EDGE:\n+      break;\n+    case SUPEREDGE_CALL:\n+      color = \"red\";\n+      break;\n+    case SUPEREDGE_RETURN:\n+      color = \"green\";\n+      break;\n+    case SUPEREDGE_INTRAPROCEDURAL_CALL:\n+      style = \"\\\"dotted\\\"\";\n+      break;\n+    }\n+\n+  /* Adapted from graph.c:draw_cfg_node_succ_edges.  */\n+  if (::edge cfg_edge = get_any_cfg_edge ())\n+    {\n+      if (cfg_edge->flags & EDGE_FAKE)\n+\t{\n+\t  style = \"dotted\";\n+\t  color = \"green\";\n+\t  weight = 0;\n+\t}\n+      else if (cfg_edge->flags & EDGE_DFS_BACK)\n+\t{\n+\t  style = \"\\\"dotted,bold\\\"\";\n+\t  color = \"blue\";\n+\t  weight = 10;\n+\t}\n+      else if (cfg_edge->flags & EDGE_FALLTHRU)\n+\t{\n+\t  color = \"blue\";\n+\t  weight = 100;\n+\t}\n+\n+      if (cfg_edge->flags & EDGE_ABNORMAL)\n+\tcolor = \"red\";\n+    }\n+\n+  gv->write_indent ();\n+\n+  pretty_printer *pp = gv->get_pp ();\n+\n+  m_src->dump_dot_id (pp);\n+  pp_string (pp, \" -> \");\n+  m_dest->dump_dot_id (pp);\n+  pp_printf (pp,\n+\t     (\" [style=%s, color=%s, weight=%d, constraint=%s,\"\n+\t      \" ltail=\\\"cluster_node_%i\\\", lhead=\\\"cluster_node_%i\\\"\"\n+\t      \" headlabel=\\\"\"),\n+\t     style, color, weight, constraint,\n+\t     m_src->m_index, m_dest->m_index);\n+\n+  dump_label_to_pp (pp, false);\n+\n+  pp_printf (pp, \"\\\"];\\n\");\n+}\n+\n+/* If this is an intraprocedural superedge, return the associated\n+   CFG edge.  Otherwise, return NULL.  */\n+\n+::edge\n+superedge::get_any_cfg_edge () const\n+{\n+  if (const cfg_superedge *sub = dyn_cast_cfg_superedge ())\n+    return sub->get_cfg_edge ();\n+  return NULL;\n+}\n+\n+/* If this is an interprocedural superedge, return the associated\n+   cgraph_edge *.  Otherwise, return NULL.  */\n+\n+cgraph_edge *\n+superedge::get_any_callgraph_edge () const\n+{\n+  if (const callgraph_superedge *sub = dyn_cast_callgraph_superedge ())\n+    return sub->m_cedge;\n+  return NULL;\n+}\n+\n+/* Build a description of this superedge (e.g. \"true\" for the true\n+   edge of a conditional, or \"case 42:\" for a switch case).\n+\n+   The caller is responsible for freeing the result.\n+\n+   If USER_FACING is false, the result also contains any underlying\n+   CFG edge flags. e.g. \" (flags FALLTHRU | DFS_BACK)\".  */\n+\n+char *\n+superedge::get_description (bool user_facing) const\n+{\n+  pretty_printer pp;\n+  dump_label_to_pp (&pp, user_facing);\n+  return xstrdup (pp_formatted_text (&pp));\n+}\n+\n+/* Implementation of superedge::dump_label_to_pp for non-switch CFG\n+   superedges.\n+\n+   For true/false edges, print \"true\" or \"false\" to PP.\n+\n+   If USER_FACING is false, also print flags on the underlying CFG edge to\n+   PP.  */\n+\n+void\n+cfg_superedge::dump_label_to_pp (pretty_printer *pp,\n+\t\t\t\t bool user_facing) const\n+{\n+  if (true_value_p ())\n+    pp_printf (pp, \"true\");\n+  else if (false_value_p ())\n+    pp_printf (pp, \"false\");\n+\n+  if (user_facing)\n+    return;\n+\n+  /* Express edge flags as a string with \" | \" separator.\n+     e.g. \" (flags FALLTHRU | DFS_BACK)\".  */\n+  if (get_flags ())\n+    {\n+      pp_string (pp, \" (flags \");\n+      bool seen_flag = false;\n+#define DEF_EDGE_FLAG(NAME,IDX)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (get_flags () & EDGE_##NAME)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tif (seen_flag)\t\t\t\t\\\n+\t  pp_string (pp, \" | \");\t\t\t\\\n+\tpp_printf (pp, \"%s\", (#NAME));\t\t\\\n+\tseen_flag = true;\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  } while (0);\n+#include \"cfg-flags.def\"\n+#undef DEF_EDGE_FLAG\n+      pp_string (pp, \")\");\n+    }\n+\n+  /* Otherwise, no label.  */\n+}\n+\n+/* Get the phi argument for PHI for this CFG edge.  */\n+\n+tree\n+cfg_superedge::get_phi_arg (const gphi *phi) const\n+{\n+  size_t index = m_cfg_edge->dest_idx;\n+  return gimple_phi_arg_def (phi, index);\n+}\n+\n+/* Implementation of superedge::dump_label_to_pp for CFG superedges for\n+   \"switch\" statements.\n+\n+   Print \"case VAL:\", \"case LOWER ... UPPER:\", or \"default:\" to PP.  */\n+\n+void\n+switch_cfg_superedge::dump_label_to_pp (pretty_printer *pp,\n+\t\t\t\t\tbool user_facing ATTRIBUTE_UNUSED) const\n+{\n+  tree case_label = get_case_label ();\n+  gcc_assert (TREE_CODE (case_label) == CASE_LABEL_EXPR);\n+  tree lower_bound = CASE_LOW (case_label);\n+  tree upper_bound = CASE_HIGH (case_label);\n+  if (lower_bound)\n+    {\n+      pp_printf (pp, \"case \");\n+      dump_generic_node (pp, lower_bound, 0, (dump_flags_t)0, false);\n+      if (upper_bound)\n+\t{\n+\t  pp_printf (pp, \" ... \");\n+\t  dump_generic_node (pp, upper_bound, 0, (dump_flags_t)0, false);\n+\t}\n+      pp_printf (pp, \":\");\n+    }\n+  else\n+    pp_printf (pp, \"default:\");\n+}\n+\n+/* Get the case label for this \"switch\" superedge.  */\n+\n+tree\n+switch_cfg_superedge::get_case_label () const\n+{\n+  return gimple_switch_label (get_switch_stmt (), m_idx);\n+}\n+\n+/* Implementation of superedge::dump_label_to_pp for interprocedural\n+   superedges.  */\n+\n+void\n+callgraph_superedge::dump_label_to_pp (pretty_printer *pp,\n+\t\t\t\t       bool user_facing ATTRIBUTE_UNUSED) const\n+{\n+  switch (m_kind)\n+    {\n+    default:\n+    case SUPEREDGE_CFG_EDGE:\n+      gcc_unreachable ();\n+\n+    case SUPEREDGE_CALL:\n+      pp_printf (pp, \"call\");\n+      break;\n+\n+    case SUPEREDGE_RETURN:\n+      pp_printf (pp, \"return\");\n+      break;\n+\n+    case SUPEREDGE_INTRAPROCEDURAL_CALL:\n+      pp_printf (pp, \"intraproc link\");\n+      break;\n+    }\n+}\n+\n+/* Get the function that was called at this interprocedural call/return\n+   edge.  */\n+\n+function *\n+callgraph_superedge::get_callee_function () const\n+{\n+  return m_cedge->callee->get_fun ();\n+}\n+\n+/* Get the calling function at this interprocedural call/return edge.  */\n+\n+function *\n+callgraph_superedge::get_caller_function () const\n+{\n+  return m_cedge->caller->get_fun ();\n+}\n+\n+/* Get the fndecl that was called at this interprocedural call/return\n+   edge.  */\n+\n+tree\n+callgraph_superedge::get_callee_decl () const\n+{\n+  return get_callee_function ()->decl;\n+}\n+\n+/* Get the calling fndecl at this interprocedural call/return edge.  */\n+\n+tree\n+callgraph_superedge::get_caller_decl () const\n+{\n+  return get_caller_function ()->decl;\n+}\n+\n+/* Given PARM_TO_FIND, a PARM_DECL, identify its index (writing it\n+   to *OUT if OUT is non-NULL), and return the corresponding argument\n+   at the callsite.  */\n+\n+tree\n+callgraph_superedge::get_arg_for_parm (tree parm_to_find,\n+\t\t\t\t       callsite_expr *out) const\n+{\n+  gcc_assert  (TREE_CODE (parm_to_find) == PARM_DECL);\n+\n+  tree callee = get_callee_decl ();\n+\n+  int i = 0;\n+  for (tree iter_parm = DECL_ARGUMENTS (callee); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm), ++i)\n+    {\n+      if (iter_parm == parm_to_find)\n+\t{\n+\t  if (out)\n+\t    *out = callsite_expr::from_zero_based_param (i);\n+\t  return gimple_call_arg (get_call_stmt (), i);\n+\t}\n+    }\n+\n+  /* Not found.  */\n+  return NULL_TREE;\n+}\n+\n+/* Look for a use of ARG_TO_FIND as an argument at this callsite.\n+   If found, return the default SSA def of the corresponding parm within\n+   the callee, and if OUT is non-NULL, write the index to *OUT.\n+   Only the first match is handled.  */\n+\n+tree\n+callgraph_superedge::get_parm_for_arg (tree arg_to_find,\n+\t\t\t\t       callsite_expr *out) const\n+{\n+  tree callee = get_callee_decl ();\n+\n+  int i = 0;\n+  for (tree iter_parm = DECL_ARGUMENTS (callee); iter_parm;\n+       iter_parm = DECL_CHAIN (iter_parm), ++i)\n+    {\n+      tree param = gimple_call_arg (get_call_stmt (), i);\n+      if (arg_to_find == param)\n+\t{\n+\t  if (out)\n+\t    *out = callsite_expr::from_zero_based_param (i);\n+\t  return ssa_default_def (get_callee_function (), iter_parm);\n+\t}\n+    }\n+\n+  /* Not found.  */\n+  return NULL_TREE;\n+}\n+\n+/* Map caller_expr back to an expr within the callee, or return NULL_TREE.\n+   If non-NULL is returned, populate OUT.  */\n+\n+tree\n+callgraph_superedge::map_expr_from_caller_to_callee (tree caller_expr,\n+\t\t\t\t\t\t     callsite_expr *out) const\n+{\n+  /* Is it an argument (actual param)?  If so, convert to\n+     parameter (formal param).  */\n+  tree parm = get_parm_for_arg (caller_expr, out);\n+  if (parm)\n+    return parm;\n+  /* Otherwise try return value.  */\n+  if (caller_expr == gimple_call_lhs (get_call_stmt ()))\n+    {\n+      if (out)\n+\t*out = callsite_expr::from_return_value ();\n+      return DECL_RESULT (get_callee_decl ());\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Map callee_expr back to an expr within the caller, or return NULL_TREE.\n+   If non-NULL is returned, populate OUT.  */\n+\n+tree\n+callgraph_superedge::map_expr_from_callee_to_caller (tree callee_expr,\n+\t\t\t\t\t\t     callsite_expr *out) const\n+{\n+  if (callee_expr == NULL_TREE)\n+    return NULL_TREE;\n+\n+  /* If it's a parameter (formal param), get the argument (actual param).  */\n+  if (TREE_CODE (callee_expr) == PARM_DECL)\n+    return get_arg_for_parm (callee_expr, out);\n+\n+  /* Similar for the default SSA name of the PARM_DECL.  */\n+  if (TREE_CODE (callee_expr) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (callee_expr)\n+      && TREE_CODE (SSA_NAME_VAR (callee_expr)) == PARM_DECL)\n+    return get_arg_for_parm (SSA_NAME_VAR (callee_expr), out);\n+\n+  /* Otherwise try return value.  */\n+  if (callee_expr == DECL_RESULT (get_callee_decl ()))\n+    {\n+      if (out)\n+\t*out = callsite_expr::from_return_value ();\n+      return gimple_call_lhs (get_call_stmt ());\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "4c0775c59e225e2baeea21254a7e385b00915b91", "filename": "gcc/analyzer/supergraph.h", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,554 @@\n+/* \"Supergraph\" classes that combine CFGs and callgraph into one digraph.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_SUPERGRAPH_H\n+#define GCC_ANALYZER_SUPERGRAPH_H\n+\n+/* Forward decls, using indentation to show inheritance.  */\n+\n+class supergraph;\n+class supernode;\n+class superedge;\n+  class callgraph_superedge;\n+    class call_superedge;\n+    class return_superedge;\n+  class cfg_superedge;\n+    class switch_cfg_superedge;\n+class supercluster;\n+class dot_annotator;\n+\n+class logger;\n+\n+/* An enum for discriminating between superedge subclasses.  */\n+\n+enum edge_kind\n+{\n+  SUPEREDGE_CFG_EDGE,\n+  SUPEREDGE_CALL,\n+  SUPEREDGE_RETURN,\n+  SUPEREDGE_INTRAPROCEDURAL_CALL\n+};\n+\n+/* Flags for controlling the appearance of .dot dumps.  */\n+\n+enum supergraph_dot_flags\n+{\n+  SUPERGRAPH_DOT_SHOW_BBS = (1 << 0)\n+};\n+\n+/* A traits struct describing the family of node, edge and digraph\n+   classes for supergraphs.  */\n+\n+struct supergraph_traits\n+{\n+  typedef supernode node_t;\n+  typedef superedge edge_t;\n+  typedef supergraph graph_t;\n+  struct dump_args_t\n+  {\n+    dump_args_t (enum supergraph_dot_flags flags,\n+\t\t const dot_annotator *node_annotator)\n+    : m_flags (flags),\n+      m_node_annotator (node_annotator)\n+    {}\n+\n+    enum supergraph_dot_flags m_flags;\n+    const dot_annotator *m_node_annotator;\n+  };\n+  typedef supercluster cluster_t;\n+};\n+\n+/* A \"supergraph\" is a directed graph formed by joining together all CFGs,\n+   linking them via interprocedural call and return edges.\n+\n+   Basic blocks are split at callsites, so that a call statement occurs\n+   twice: once at the end of a supernode, and a second instance at the\n+   start of the next supernode (to handle the return).  */\n+\n+class supergraph : public digraph<supergraph_traits>\n+{\n+public:\n+  supergraph (logger *logger);\n+\n+  supernode *get_node_for_function_entry (function *fun) const\n+  {\n+    return get_node_for_block (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  }\n+\n+  supernode *get_node_for_function_exit (function *fun) const\n+  {\n+    return get_node_for_block (EXIT_BLOCK_PTR_FOR_FN (fun));\n+  }\n+\n+  supernode *get_node_for_block (basic_block bb) const\n+  {\n+    return *const_cast <bb_to_node_t &> (m_bb_to_initial_node).get (bb);\n+  }\n+\n+  /* Get the supernode containing the second half of the gcall *\n+     at an interprocedural call, within the caller.  */\n+  supernode *get_caller_next_node (cgraph_edge *edge) const\n+  {\n+    return (*const_cast <cgraph_edge_to_node_t &>\n+\t      (m_cgraph_edge_to_caller_next_node).get (edge));\n+  }\n+\n+  call_superedge *get_edge_for_call (cgraph_edge *edge) const\n+  {\n+    return (*const_cast <cgraph_edge_to_call_superedge_t &>\n+\t      (m_cgraph_edge_to_call_superedge).get (edge));\n+  }\n+\n+  return_superedge *get_edge_for_return (cgraph_edge *edge) const\n+  {\n+    return (*const_cast <cgraph_edge_to_return_superedge_t &>\n+\t      (m_cgraph_edge_to_return_superedge).get (edge));\n+  }\n+\n+  superedge *get_intraprocedural_edge_for_call (cgraph_edge *edge) const\n+  {\n+    return (*const_cast <cgraph_edge_to_intraproc_superedge_t &>\n+\t      (m_cgraph_edge_to_intraproc_superedge).get (edge));\n+  }\n+\n+  cfg_superedge *get_edge_for_cfg_edge (edge e) const\n+  {\n+    return (*const_cast <cfg_edge_to_cfg_superedge_t &>\n+\t      (m_cfg_edge_to_cfg_superedge).get (e));\n+  }\n+\n+  supernode *get_supernode_for_stmt (const gimple *stmt) const\n+  {\n+    return (*const_cast <stmt_to_node_t &>(m_stmt_to_node_t).get\n+\t    (const_cast <gimple *> (stmt)));\n+  }\n+\n+  void dump_dot_to_pp (pretty_printer *pp, const dump_args_t &) const;\n+  void dump_dot_to_file (FILE *fp, const dump_args_t &) const;\n+  void dump_dot (const char *path, const dump_args_t &) const;\n+\n+  int num_nodes () const { return m_nodes.length (); }\n+  int num_edges () const { return m_edges.length (); }\n+\n+  supernode *get_node_by_index (int idx) const\n+  {\n+    return m_nodes[idx];\n+  }\n+\n+  unsigned get_num_snodes (function *fun) const\n+  {\n+    function_to_num_snodes_t &map\n+      = const_cast <function_to_num_snodes_t &>(m_function_to_num_snodes);\n+    return *map.get (fun);\n+  }\n+\n+private:\n+  supernode *add_node (function *fun, basic_block bb, gcall *returning_call,\n+\t\t       gimple_seq phi_nodes);\n+  cfg_superedge *add_cfg_edge (supernode *src, supernode *dest, ::edge e, int idx);\n+  call_superedge *add_call_superedge (supernode *src, supernode *dest,\n+\t\t\t\t      cgraph_edge *cedge);\n+  return_superedge *add_return_superedge (supernode *src, supernode *dest,\n+\t\t\t\t\t  cgraph_edge *cedge);\n+\n+  /* Data.  */\n+\n+  typedef ordered_hash_map<basic_block, supernode *> bb_to_node_t;\n+  bb_to_node_t m_bb_to_initial_node;\n+  bb_to_node_t m_bb_to_final_node;\n+\n+  typedef ordered_hash_map<cgraph_edge *, supernode *> cgraph_edge_to_node_t;\n+  cgraph_edge_to_node_t m_cgraph_edge_to_caller_prev_node;\n+  cgraph_edge_to_node_t m_cgraph_edge_to_caller_next_node;\n+\n+  typedef ordered_hash_map< ::edge, cfg_superedge *>\n+    cfg_edge_to_cfg_superedge_t;\n+  cfg_edge_to_cfg_superedge_t m_cfg_edge_to_cfg_superedge;\n+\n+  typedef ordered_hash_map<cgraph_edge *, call_superedge *>\n+    cgraph_edge_to_call_superedge_t;\n+  cgraph_edge_to_call_superedge_t m_cgraph_edge_to_call_superedge;\n+\n+  typedef ordered_hash_map<cgraph_edge *, return_superedge *>\n+    cgraph_edge_to_return_superedge_t;\n+  cgraph_edge_to_return_superedge_t m_cgraph_edge_to_return_superedge;\n+\n+  typedef ordered_hash_map<cgraph_edge *, superedge *>\n+    cgraph_edge_to_intraproc_superedge_t;\n+  cgraph_edge_to_intraproc_superedge_t m_cgraph_edge_to_intraproc_superedge;\n+\n+  typedef ordered_hash_map<gimple *, supernode *> stmt_to_node_t;\n+  stmt_to_node_t m_stmt_to_node_t;\n+\n+  typedef hash_map<function *, unsigned> function_to_num_snodes_t;\n+  function_to_num_snodes_t m_function_to_num_snodes;\n+};\n+\n+/* A node within a supergraph.  */\n+\n+class supernode : public dnode<supergraph_traits>\n+{\n+ public:\n+  supernode (function *fun, basic_block bb, gcall *returning_call,\n+\t     gimple_seq phi_nodes, int index)\n+  : m_fun (fun), m_bb (bb), m_returning_call (returning_call),\n+    m_phi_nodes (phi_nodes), m_index (index)\n+  {}\n+\n+  bool entry_p () const\n+  {\n+    return m_bb == ENTRY_BLOCK_PTR_FOR_FN (m_fun);\n+  }\n+\n+  bool return_p () const\n+  {\n+    return m_bb == EXIT_BLOCK_PTR_FOR_FN (m_fun);\n+  }\n+\n+  void dump_dot (graphviz_out *gv, const dump_args_t &args) const OVERRIDE;\n+  void dump_dot_id (pretty_printer *pp) const;\n+\n+  location_t get_start_location () const;\n+  location_t get_end_location () const;\n+\n+  /* Returns iterator at the start of the list of phi nodes, if any.  */\n+  gphi_iterator start_phis ()\n+  {\n+    gimple_seq *pseq = &m_phi_nodes;\n+\n+    /* Adapted from gsi_start_1. */\n+    gphi_iterator i;\n+\n+    i.ptr = gimple_seq_first (*pseq);\n+    i.seq = pseq;\n+    i.bb = i.ptr ? gimple_bb (i.ptr) : NULL;\n+\n+    return i;\n+  }\n+\n+  gimple *get_last_stmt () const\n+  {\n+    if (m_stmts.length () == 0)\n+      return NULL;\n+    return m_stmts[m_stmts.length () - 1];\n+  }\n+\n+  gcall *get_final_call () const\n+  {\n+    gimple *stmt = get_last_stmt ();\n+    if (stmt == NULL)\n+      return NULL;\n+    return dyn_cast<gcall *> (stmt);\n+  }\n+\n+  unsigned int get_stmt_index (const gimple *stmt) const;\n+\n+  function * const m_fun; // alternatively could be stored as runs of indices within the supergraph\n+  const basic_block m_bb;\n+  gcall * const m_returning_call; // for handling the result of a returned call\n+  gimple_seq m_phi_nodes; // ptr to that of the underlying BB, for the first supernode for the BB\n+  auto_vec<gimple *> m_stmts;\n+  const int m_index; /* unique within the supergraph as a whole.  */\n+};\n+\n+/* An abstract base class encapsulating an edge within a supergraph.\n+   Edges can be CFG edges, or calls/returns for callgraph edges.  */\n+\n+class superedge : public dedge<supergraph_traits>\n+{\n+ public:\n+  virtual ~superedge () {}\n+\n+  void dump_dot (graphviz_out *gv, const dump_args_t &args) const;\n+\n+  virtual void dump_label_to_pp (pretty_printer *pp,\n+\t\t\t\t bool user_facing) const = 0;\n+\n+  enum edge_kind get_kind () const { return m_kind; }\n+\n+  virtual cfg_superedge *dyn_cast_cfg_superedge () { return NULL; }\n+  virtual const cfg_superedge *dyn_cast_cfg_superedge () const { return NULL; }\n+  virtual const switch_cfg_superedge *dyn_cast_switch_cfg_superedge () const { return NULL; }\n+  virtual callgraph_superedge *dyn_cast_callgraph_superedge () { return NULL; }\n+  virtual const callgraph_superedge *dyn_cast_callgraph_superedge () const { return NULL; }\n+  virtual call_superedge *dyn_cast_call_superedge () { return NULL; }\n+  virtual const call_superedge *dyn_cast_call_superedge () const { return NULL; }\n+  virtual return_superedge *dyn_cast_return_superedge () { return NULL; }\n+  virtual const return_superedge *dyn_cast_return_superedge () const { return NULL; }\n+\n+  ::edge get_any_cfg_edge () const;\n+  cgraph_edge *get_any_callgraph_edge () const;\n+\n+  char *get_description (bool user_facing) const;\n+\n+ protected:\n+  superedge (supernode *src, supernode *dest, enum edge_kind kind)\n+  : dedge (src, dest),\n+    m_kind (kind)\n+  {}\n+\n+ public:\n+  const enum edge_kind m_kind;\n+};\n+\n+/* An ID representing an expression at a callsite:\n+   either a parameter index, or the return value (or unknown).  */\n+\n+class callsite_expr\n+{\n+ public:\n+  callsite_expr () : m_val (-1) {}\n+\n+  static callsite_expr from_zero_based_param (int idx)\n+  {\n+    return callsite_expr (idx + 1);\n+  }\n+\n+  static callsite_expr from_return_value ()\n+  {\n+    return callsite_expr (0);\n+  }\n+\n+  bool param_p () const\n+  {\n+    return m_val > 0;\n+  }\n+\n+  bool return_value_p () const\n+  {\n+    return m_val == 0;\n+  }\n+\n+ private:\n+  callsite_expr (int val) : m_val (val) {}\n+\n+  int m_val; /* 1-based parm, 0 for return value, or -1 for \"unknown\".  */\n+};\n+\n+/* A subclass of superedge with an associated callgraph edge (either a\n+   call or a return).  */\n+\n+class callgraph_superedge : public superedge\n+{\n+ public:\n+  callgraph_superedge (supernode *src, supernode *dst, enum edge_kind kind,\n+\t\t       cgraph_edge *cedge)\n+  : superedge (src, dst, kind),\n+    m_cedge (cedge)\n+  {}\n+\n+  void dump_label_to_pp (pretty_printer *pp, bool user_facing) const\n+    FINAL OVERRIDE;\n+\n+  function *get_callee_function () const;\n+  function *get_caller_function () const;\n+  tree get_callee_decl () const;\n+  tree get_caller_decl () const;\n+  gcall *get_call_stmt () const { return m_cedge->call_stmt; }\n+  tree get_arg_for_parm (tree parm, callsite_expr *out) const;\n+  tree get_parm_for_arg (tree arg, callsite_expr *out) const;\n+  tree map_expr_from_caller_to_callee (tree caller_expr,\n+\t\t\t\t       callsite_expr *out) const;\n+  tree map_expr_from_callee_to_caller (tree callee_expr,\n+\t\t\t\t       callsite_expr *out) const;\n+\n+  cgraph_edge *const m_cedge;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const callgraph_superedge *>::test (const superedge *sedge)\n+{\n+  return (sedge->get_kind () == SUPEREDGE_INTRAPROCEDURAL_CALL\n+\t  || sedge->get_kind () == SUPEREDGE_CALL\n+\t  || sedge->get_kind () == SUPEREDGE_RETURN);\n+}\n+\n+/* A subclass of superedge representing an interprocedural call.  */\n+\n+class call_superedge : public callgraph_superedge\n+{\n+ public:\n+  call_superedge (supernode *src, supernode *dst, cgraph_edge *cedge)\n+  : callgraph_superedge (src, dst, SUPEREDGE_CALL, cedge)\n+  {}\n+\n+  callgraph_superedge *dyn_cast_callgraph_superedge () FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+  const callgraph_superedge *dyn_cast_callgraph_superedge () const\n+    FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  call_superedge *dyn_cast_call_superedge () FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+  const call_superedge *dyn_cast_call_superedge () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  return_superedge *get_edge_for_return (const supergraph &sg) const\n+  {\n+    return sg.get_edge_for_return (m_cedge);\n+  }\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const call_superedge *>::test (const superedge *sedge)\n+{\n+  return sedge->get_kind () == SUPEREDGE_CALL;\n+}\n+\n+/* A subclass of superedge represesnting an interprocedural return.  */\n+\n+class return_superedge : public callgraph_superedge\n+{\n+ public:\n+  return_superedge (supernode *src, supernode *dst, cgraph_edge *cedge)\n+  : callgraph_superedge (src, dst, SUPEREDGE_RETURN, cedge)\n+  {}\n+\n+  callgraph_superedge *dyn_cast_callgraph_superedge () FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+  const callgraph_superedge *dyn_cast_callgraph_superedge () const\n+    FINAL OVERRIDE\n+  { return this; }\n+\n+  return_superedge *dyn_cast_return_superedge () FINAL OVERRIDE { return this; }\n+  const return_superedge *dyn_cast_return_superedge () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  call_superedge *get_edge_for_call (const supergraph &sg) const\n+  {\n+    return sg.get_edge_for_call (m_cedge);\n+  }\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const return_superedge *>::test (const superedge *sedge)\n+{\n+  return sedge->get_kind () == SUPEREDGE_RETURN;\n+}\n+\n+/* A subclass of superedge that corresponds to a CFG edge.  */\n+\n+class cfg_superedge : public superedge\n+{\n+ public:\n+  cfg_superedge (supernode *src, supernode *dst, ::edge e)\n+  : superedge (src, dst, SUPEREDGE_CFG_EDGE),\n+    m_cfg_edge (e)\n+  {}\n+\n+  void dump_label_to_pp (pretty_printer *pp, bool user_facing) const OVERRIDE;\n+  cfg_superedge *dyn_cast_cfg_superedge () FINAL OVERRIDE { return this; }\n+  const cfg_superedge *dyn_cast_cfg_superedge () const FINAL OVERRIDE { return this; }\n+\n+  ::edge get_cfg_edge () const { return m_cfg_edge; }\n+  int get_flags () const { return m_cfg_edge->flags; }\n+  int true_value_p () const { return get_flags () & EDGE_TRUE_VALUE; }\n+  int false_value_p () const { return get_flags () & EDGE_FALSE_VALUE; }\n+  int back_edge_p () const { return get_flags () & EDGE_DFS_BACK; }\n+\n+  tree get_phi_arg (const gphi *phi) const;\n+\n+ private:\n+  const ::edge m_cfg_edge;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const cfg_superedge *>::test (const superedge *sedge)\n+{\n+  return sedge->get_kind () == SUPEREDGE_CFG_EDGE;\n+}\n+\n+/* A subclass for edges from switch statements, retaining enough\n+   information to identify the pertinent case, and for adding labels\n+   when rendering via graphviz.  */\n+\n+class switch_cfg_superedge : public cfg_superedge {\n+ public:\n+  switch_cfg_superedge (supernode *src, supernode *dst, ::edge e, int idx)\n+  : cfg_superedge (src, dst, e),\n+    m_idx (idx)\n+  {}\n+\n+  const switch_cfg_superedge *dyn_cast_switch_cfg_superedge () const\n+    FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_label_to_pp (pretty_printer *pp, bool user_facing) const\n+    FINAL OVERRIDE;\n+\n+  gswitch *get_switch_stmt () const\n+  {\n+    return as_a <gswitch *> (m_src->get_last_stmt ());\n+  }\n+\n+  tree get_case_label () const;\n+\n+ private:\n+  const int m_idx;\n+};\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const switch_cfg_superedge *>::test (const superedge *sedge)\n+{\n+  return sedge->dyn_cast_switch_cfg_superedge () != NULL;\n+}\n+\n+/* Base class for adding additional content to the .dot output\n+   for a supergraph.  */\n+\n+class dot_annotator\n+{\n+ public:\n+  virtual ~dot_annotator () {}\n+  virtual void add_node_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n+\t\t\t\t     const supernode &n ATTRIBUTE_UNUSED)\n+    const {}\n+  virtual void add_stmt_annotations (graphviz_out *gv ATTRIBUTE_UNUSED,\n+\t\t\t\t     const gimple *stmt ATTRIBUTE_UNUSED)\n+    const {}\n+};\n+\n+extern cgraph_edge *supergraph_call_edge (function *fun, gimple *stmt);\n+\n+#endif /* GCC_ANALYZER_SUPERGRAPH_H */"}, {"sha": "5692cd0437415079ea5d065e4c99a9c5d9facadc", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -989,6 +989,10 @@ fallow-store-data-races\n Common Report Var(flag_store_data_races) Optimization\n Allow the compiler to introduce new data races on stores.\n \n+fanalyzer\n+Common Var(flag_analyzer)\n+Enable static analysis pass.\n+\n fargument-alias\n Common Ignore\n Does nothing. Preserved for backward compatibility."}, {"sha": "ec5c46abdb58b22382c93cb4ba0a701092cacb3e", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -76,6 +76,12 @@\n #endif\n \n \n+/* Define 0/1 if static analyzer feature is enabled. */\n+#ifndef USED_FOR_TARGET\n+#undef ENABLE_ANALYZER\n+#endif\n+\n+\n /* Define if you want assertions enabled. This is a cheap check. */\n #ifndef USED_FOR_TARGET\n #undef ENABLE_ASSERT_CHECKING"}, {"sha": "490fe6ac8e86fb04c53662a7b75f4fd60b8f87ec", "filename": "gcc/configure", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -958,6 +958,7 @@ enable_fixed_point\n enable_threads\n enable_tls\n enable_vtable_verify\n+enable_analyzer\n enable_objc_gc\n with_dwarf2\n enable_shared\n@@ -1685,6 +1686,7 @@ Optional Features:\n   --enable-tls            enable or disable generation of tls code overriding\n                           the assembler check for tls support\n   --enable-vtable-verify  enable vtable verification feature\n+  --disable-analyzer      disable -fanalyzer static analyzer\n   --enable-objc-gc        enable the use of Boehm's garbage collector with the\n                           GNU Objective-C runtime\n   --disable-shared        don't provide a shared libgcc\n@@ -7703,6 +7705,23 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n+# Check whether --enable-analyzer was given.\n+if test \"${enable_analyzer+set}\" = set; then :\n+  enableval=$enable_analyzer; if test x$enable_analyzer = xno; then\n+\tanalyzer=0\n+else\n+\tanalyzer=1\n+fi\n+else\n+  analyzer=1\n+fi\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define ENABLE_ANALYZER $analyzer\n+_ACEOF\n+\n+\n # Check whether --enable-objc-gc was given.\n if test \"${enable_objc_gc+set}\" = set; then :\n   enableval=$enable_objc_gc; if test x$enable_objc_gc = xno; then\n@@ -18938,7 +18957,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18941 \"configure\"\n+#line 18960 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -19044,7 +19063,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 19047 \"configure\"\n+#line 19066 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -31960,7 +31979,7 @@ $as_echo \"$as_me: executing $ac_file commands\" >&6;}\n     \"depdir\":C) $SHELL $ac_aux_dir/mkinstalldirs $DEPDIR ;;\n     \"gccdepdir\":C)\n   ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs build/$DEPDIR\n-  for lang in $subdirs c-family common\n+  for lang in $subdirs c-family common analyzer\n   do\n       ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs $lang/$DEPDIR\n   done ;;"}, {"sha": "4a1790b4ba79431fbe78fed588cb355ce26ba184", "filename": "gcc/configure.ac", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -909,6 +909,18 @@ vtable_verify=`if test x$enable_vtable_verify = xyes; then echo 1; else echo 0;\n AC_DEFINE_UNQUOTED(ENABLE_VTABLE_VERIFY, $vtable_verify,\n [Define 0/1 if vtable verification feature is enabled.])\n \n+AC_ARG_ENABLE(analyzer,\n+[AS_HELP_STRING([--disable-analyzer],\n+\t\t[disable -fanalyzer static analyzer])],\n+if test x$enable_analyzer = xno; then\n+\tanalyzer=0\n+else\n+\tanalyzer=1\n+fi,\n+analyzer=1)\n+AC_DEFINE_UNQUOTED(ENABLE_ANALYZER, $analyzer,\n+[Define 0/1 if static analyzer feature is enabled.])\n+\n AC_ARG_ENABLE(objc-gc,\n [AS_HELP_STRING([--enable-objc-gc],\n \t\t[enable the use of Boehm's garbage collector with\n@@ -1214,7 +1226,7 @@ AC_CHECK_HEADERS(ext/hash_map)\n ZW_CREATE_DEPDIR\n AC_CONFIG_COMMANDS([gccdepdir],[\n   ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs build/$DEPDIR\n-  for lang in $subdirs c-family common\n+  for lang in $subdirs c-family common analyzer\n   do\n       ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/mkinstalldirs $lang/$DEPDIR\n   done], [subdirs=\"$subdirs\" ac_aux_dir=$ac_aux_dir DEPDIR=$DEPDIR])"}, {"sha": "02ff93dac13c0251e1936150f0272b9cec0089cc", "filename": "gcc/digraph.cc", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdigraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdigraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdigraph.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,188 @@\n+/* Template classes for directed graphs.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"graphviz.h\"\n+#include \"digraph.h\"\n+#include \"shortest-paths.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* A family of digraph classes for writing selftests.  */\n+\n+struct test_node;\n+struct test_edge;\n+struct test_graph;\n+struct test_dump_args_t {};\n+struct test_cluster;\n+\n+struct test_graph_traits\n+{\n+  typedef test_node node_t;\n+  typedef test_edge edge_t;\n+  typedef test_graph graph_t;\n+  typedef test_dump_args_t dump_args_t;\n+  typedef test_cluster cluster_t;\n+};\n+\n+struct test_node : public dnode<test_graph_traits>\n+{\n+  test_node (const char *name, int index) : m_name (name), m_index (index) {}\n+  void dump_dot (graphviz_out *, const dump_args_t &) const OVERRIDE\n+  {\n+  }\n+\n+  const char *m_name;\n+  int m_index;\n+};\n+\n+struct test_edge : public dedge<test_graph_traits>\n+{\n+  test_edge (node_t *src, node_t *dest)\n+  : dedge (src, dest)\n+  {}\n+\n+  void dump_dot (graphviz_out *gv, const dump_args_t &) const OVERRIDE\n+  {\n+    gv->println (\"%s -> %s;\", m_src->m_name, m_dest->m_name);\n+  }\n+};\n+\n+struct test_graph : public digraph<test_graph_traits>\n+{\n+  test_node *add_test_node (const char *name)\n+  {\n+    test_node *result = new test_node (name, m_nodes.length ());\n+    add_node (result);\n+    return result;\n+  }\n+\n+  test_edge *add_test_edge (test_node *src, test_node *dst)\n+  {\n+    test_edge *result = new test_edge (src, dst);\n+    add_edge (result);\n+    return result;\n+  }\n+};\n+\n+struct test_cluster : public cluster<test_graph_traits>\n+{\n+};\n+\n+struct test_path\n+{\n+  auto_vec<const test_edge *> m_edges;\n+};\n+\n+/* Smoketest of digraph dumping.  */\n+\n+static void\n+test_dump_to_dot ()\n+{\n+  test_graph g;\n+  test_node *a = g.add_test_node (\"a\");\n+  test_node *b = g.add_test_node (\"b\");\n+  g.add_test_edge (a, b);\n+\n+  pretty_printer pp;\n+  pp.buffer->stream = NULL;\n+  test_dump_args_t dump_args;\n+  g.dump_dot_to_pp (&pp, NULL, dump_args);\n+\n+  ASSERT_STR_CONTAINS (pp_formatted_text (&pp),\n+\t\t       \"a -> b;\\n\");\n+}\n+\n+/* Test shortest paths from A in this digraph,\n+   where edges run top-to-bottom if not otherwise labeled:\n+\n+      A\n+     / \\\n+    B   C-->D\n+    |   |\n+    E   |\n+     \\ /\n+      F.  */\n+\n+static void\n+test_shortest_paths ()\n+{\n+  test_graph g;\n+  test_node *a = g.add_test_node (\"a\");\n+  test_node *b = g.add_test_node (\"b\");\n+  test_node *c = g.add_test_node (\"d\");\n+  test_node *d = g.add_test_node (\"d\");\n+  test_node *e = g.add_test_node (\"e\");\n+  test_node *f = g.add_test_node (\"f\");\n+\n+  test_edge *ab = g.add_test_edge (a, b);\n+  test_edge *ac = g.add_test_edge (a, c);\n+  test_edge *cd = g.add_test_edge (c, d);\n+  test_edge *be = g.add_test_edge (b, e);\n+  g.add_test_edge (e, f);\n+  test_edge *cf = g.add_test_edge (c, f);\n+\n+  shortest_paths<test_graph_traits, test_path> sp (g, a);\n+\n+  test_path path_to_a = sp.get_shortest_path (a);\n+  ASSERT_EQ (path_to_a.m_edges.length (), 0);\n+\n+  test_path path_to_b = sp.get_shortest_path (b);\n+  ASSERT_EQ (path_to_b.m_edges.length (), 1);\n+  ASSERT_EQ (path_to_b.m_edges[0], ab);\n+\n+  test_path path_to_c = sp.get_shortest_path (c);\n+  ASSERT_EQ (path_to_c.m_edges.length (), 1);\n+  ASSERT_EQ (path_to_c.m_edges[0], ac);\n+\n+  test_path path_to_d = sp.get_shortest_path (d);\n+  ASSERT_EQ (path_to_d.m_edges.length (), 2);\n+  ASSERT_EQ (path_to_d.m_edges[0], ac);\n+  ASSERT_EQ (path_to_d.m_edges[1], cd);\n+\n+  test_path path_to_e = sp.get_shortest_path (e);\n+  ASSERT_EQ (path_to_e.m_edges.length (), 2);\n+  ASSERT_EQ (path_to_e.m_edges[0], ab);\n+  ASSERT_EQ (path_to_e.m_edges[1], be);\n+\n+  test_path path_to_f = sp.get_shortest_path (f);\n+  ASSERT_EQ (path_to_f.m_edges.length (), 2);\n+  ASSERT_EQ (path_to_f.m_edges[0], ac);\n+  ASSERT_EQ (path_to_f.m_edges[1], cf);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+digraph_cc_tests ()\n+{\n+  test_dump_to_dot ();\n+  test_shortest_paths ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "07b43ec533c54d121c488ed2e2fa3e1fb5b7d5af", "filename": "gcc/digraph.h", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdigraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdigraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdigraph.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,246 @@\n+/* Template classes for directed graphs.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DIGRAPH_H\n+#define GCC_DIGRAPH_H\n+\n+#include \"diagnostic.h\"\n+#include \"tree-diagnostic.h\" /* for default_tree_printer.  */\n+#include \"graphviz.h\"\n+\n+/* Templates for a family of classes: digraph, node, edge, and cluster.\n+   This assumes a traits type with the following typedefs:\n+   node_t: the node class\n+   edge_t: the edge class\n+   dump_args_t: additional args for dot-dumps\n+   cluster_t: the cluster class (for use when generating .dot files).\n+\n+   Using a template allows for typesafe nodes and edges: a node's\n+   predecessor and successor edges can be of a node-specific edge\n+   subclass, without needing casting.  */\n+\n+/* Abstract base class for a node in a directed graph.  */\n+\n+template <typename GraphTraits>\n+class dnode\n+{\n+ public:\n+  typedef typename GraphTraits::edge_t edge_t;\n+  typedef typename GraphTraits::dump_args_t dump_args_t;\n+\n+  virtual ~dnode () {}\n+  virtual void dump_dot (graphviz_out *gv, const dump_args_t &args) const = 0;\n+\n+  auto_vec<edge_t *> m_preds;\n+  auto_vec<edge_t *> m_succs;\n+};\n+\n+/* Abstract base class for an edge in a directed graph.  */\n+\n+template <typename GraphTraits>\n+class dedge\n+{\n+ public:\n+  typedef typename GraphTraits::node_t node_t;\n+  typedef typename GraphTraits::dump_args_t dump_args_t;\n+\n+  dedge (node_t *src, node_t *dest)\n+  : m_src (src), m_dest (dest) {}\n+\n+  virtual ~dedge () {}\n+\n+  virtual void dump_dot (graphviz_out *gv, const dump_args_t &args) const = 0;\n+\n+  node_t *const m_src;\n+  node_t *const m_dest;\n+};\n+\n+/* Abstract base class for a directed graph.\n+   This class maintains the vectors of nodes and edges,\n+   and owns the nodes and edges.  */\n+\n+template <typename GraphTraits>\n+class digraph\n+{\n+ public:\n+  typedef typename GraphTraits::node_t node_t;\n+  typedef typename GraphTraits::edge_t edge_t;\n+  typedef typename GraphTraits::dump_args_t dump_args_t;\n+  typedef typename GraphTraits::cluster_t cluster_t;\n+\n+  digraph () {}\n+  virtual ~digraph () {}\n+\n+  void dump_dot_to_pp (pretty_printer *pp,\n+\t\t       cluster_t *root_cluster,\n+\t\t       const dump_args_t &args) const;\n+  void dump_dot_to_file (FILE *fp,\n+\t\t\t cluster_t *root_cluster,\n+\t\t\t const dump_args_t &args) const;\n+  void dump_dot (const char *path,\n+\t\t cluster_t *root_cluster,\n+\t\t const dump_args_t &args) const;\n+\n+  void add_node (node_t *node);\n+  void add_edge (edge_t *edge);\n+\n+  auto_delete_vec<node_t> m_nodes;\n+  auto_delete_vec<edge_t> m_edges;\n+};\n+\n+/* Abstract base class for splitting dnodes into hierarchical clusters\n+   in the generated .dot file.\n+\n+   See \"Subgraphs and Clusters\" within\n+     https://www.graphviz.org/doc/info/lang.html\n+   and e.g.\n+     https://graphviz.gitlab.io/_pages/Gallery/directed/cluster.html\n+\n+   If a root_cluster is passed to dump_dot*, then all nodes will be\n+   added to it at the start of dumping, via calls to add_node.\n+\n+   The root cluster can organize the nodes into a hierarchy of\n+   child clusters.\n+\n+   After all nodes are added to the root cluster, dump_dot will then\n+   be called on it (and not on the nodes themselves).  */\n+\n+template <typename GraphTraits>\n+class cluster\n+{\n+ public:\n+  typedef typename GraphTraits::node_t node_t;\n+  typedef typename GraphTraits::dump_args_t dump_args_t;\n+\n+  virtual ~cluster () {}\n+\n+  virtual void add_node (node_t *node) = 0;\n+\n+  /* Recursively dump the cluster, all nodes, and child clusters.  */\n+  virtual void dump_dot (graphviz_out *gv, const dump_args_t &) const = 0;\n+};\n+\n+/* Write .dot information for this graph to PP, passing ARGS to the nodes\n+   and edges.\n+   If ROOT_CLUSTER is non-NULL, use it to organize the nodes into clusters.  */\n+\n+template <typename GraphTraits>\n+inline void\n+digraph<GraphTraits>::dump_dot_to_pp (pretty_printer *pp,\n+\t\t\t\t      cluster_t *root_cluster,\n+\t\t\t\t      const dump_args_t &args) const\n+{\n+  graphviz_out gv (pp);\n+\n+  pp_string (pp, \"digraph \\\"\");\n+  pp_string (pp, \"base\");\n+  pp_string (pp, \"\\\" {\\n\");\n+\n+  gv.indent ();\n+\n+  pp_string (pp, \"overlap=false;\\n\");\n+  pp_string (pp, \"compound=true;\\n\");\n+\n+  /* If using clustering, emit all nodes via clusters.  */\n+  if (root_cluster)\n+    {\n+      int i;\n+      node_t *n;\n+      FOR_EACH_VEC_ELT (m_nodes, i, n)\n+\troot_cluster->add_node (n);\n+      root_cluster->dump_dot (&gv, args);\n+    }\n+  else\n+    {\n+      /* Otherwise, display all nodes at top level.  */\n+      int i;\n+      node_t *n;\n+      FOR_EACH_VEC_ELT (m_nodes, i, n)\n+\tn->dump_dot (&gv, args);\n+    }\n+\n+  /* Edges.  */\n+  int i;\n+  edge_t *e;\n+  FOR_EACH_VEC_ELT (m_edges, i, e)\n+    e->dump_dot (&gv, args);\n+\n+  /* Terminate \"digraph\" */\n+  gv.outdent ();\n+  pp_string (pp, \"}\");\n+  pp_newline (pp);\n+}\n+\n+/* Write .dot information for this graph to FP, passing ARGS to the nodes\n+   and edges.\n+   If ROOT_CLUSTER is non-NULL, use it to organize the nodes into clusters.  */\n+\n+template <typename GraphTraits>\n+inline void\n+digraph<GraphTraits>::dump_dot_to_file (FILE *fp,\n+\t\t\t\t\tcluster_t *root_cluster,\n+\t\t\t\t\tconst dump_args_t &args) const\n+{\n+  pretty_printer pp;\n+  // TODO:\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp.buffer->stream = fp;\n+  dump_dot_to_pp (&pp, root_cluster, args);\n+  pp_flush (&pp);\n+}\n+\n+/* Write .dot information for this graph to a file at PATH, passing ARGS\n+   to the nodes and edges.\n+   If ROOT_CLUSTER is non-NULL, use it to organize the nodes into clusters.  */\n+\n+template <typename GraphTraits>\n+inline void\n+digraph<GraphTraits>::dump_dot (const char *path,\n+\t\t\t\tcluster_t *root_cluster,\n+\t\t\t\tconst dump_args_t &args) const\n+{\n+  FILE *fp = fopen (path, \"w\");\n+  dump_dot_to_file (fp, root_cluster, args);\n+  fclose (fp);\n+}\n+\n+/* Add NODE to this DIGRAPH, taking ownership.  */\n+\n+template <typename GraphTraits>\n+inline void\n+digraph<GraphTraits>::add_node (node_t *node)\n+{\n+  m_nodes.safe_push (node);\n+}\n+\n+/* Add EDGE to this digraph, and to the preds/succs of its endpoints.\n+   Take ownership of EDGE.  */\n+\n+template <typename GraphTraits>\n+inline void\n+digraph<GraphTraits>::add_edge (edge_t *edge)\n+{\n+  m_edges.safe_push (edge);\n+  edge->m_dest->m_preds.safe_push (edge);\n+  edge->m_src->m_succs.safe_push (edge);\n+\n+}\n+\n+#endif /* GCC_DIGRAPH_H */"}, {"sha": "67efa52953b860fe828ab49d01b28ba336329b19", "filename": "gcc/doc/analyzer.texi", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,513 @@\n+@c Copyright (C) 2019 Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+@c Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+@node Static Analyzer\n+@chapter Static Analyzer\n+@cindex analyzer\n+@cindex static analysis\n+@cindex static analyzer\n+\n+@menu\n+* Analyzer Internals::       Analyzer Internals\n+* Debugging the Analyzer::   Useful debugging tips\n+@end menu\n+\n+@node Analyzer Internals\n+@section Analyzer Internals\n+@cindex analyzer, internals\n+@cindex static analyzer, internals\n+\n+@subsection Overview\n+\n+The analyzer implementation works on the gimple-SSA representation.\n+(I chose this in the hopes of making it easy to work with LTO to\n+do whole-program analysis).\n+\n+The implementation is read-only: it doesn't attempt to change anything,\n+just emit warnings.\n+\n+First, we build a @code{supergraph} which combines the callgraph and all\n+of the CFGs into a single directed graph, with both interprocedural and\n+intraprocedural edges.  The nodes and edges in the supergraph are called\n+``supernodes'' and ``superedges'', and often referred to in code as\n+@code{snodes} and @code{sedges}.  Basic blocks in the CFGs are split at\n+interprocedural calls, so there can be more than one supernode per\n+basic block.  Most statements will be in just one supernode, but a call\n+statement can appear in two supernodes: at the end of one for the call,\n+and again at the start of another for the return.\n+\n+The supergraph can be seen using @option{-fdump-analyzer-supergraph}.\n+\n+We then build an @code{analysis_plan} which walks the callgraph to\n+determine which calls might be suitable for being summarized (rather\n+than fully explored) and thus in what order to explore the functions.\n+\n+Next is the heart of the analyzer: we use a worklist to explore state\n+within the supergraph, building an \"exploded graph\".\n+Nodes in the exploded graph correspond to <point,@w{ }state> pairs, as in\n+     \"Precise Interprocedural Dataflow Analysis via Graph Reachability\"\n+     (Thomas Reps, Susan Horwitz and Mooly Sagiv).\n+\n+We reuse nodes for <point, state> pairs we've already seen, and avoid\n+tracking state too closely, so that (hopefully) we rapidly converge\n+on a final exploded graph, and terminate the analysis.  We also bail\n+out if the number of exploded <end-of-basic-block, state> nodes gets\n+larger than a particular multiple of the total number of basic blocks\n+(to ensure termination in the face of pathological state-explosion\n+cases, or bugs).  We also stop exploring a point once we hit a limit\n+of states for that point.\n+\n+We can identify problems directly when processing a <point,@w{ }state>\n+instance.  For example, if we're finding the successors of\n+\n+@smallexample\n+   <point: before-stmt: \"free (ptr);\",\n+    state: @{\"ptr\": freed@}>\n+@end smallexample\n+\n+then we can detect a double-free of \"ptr\".  We can then emit a path\n+to reach the problem by finding the simplest route through the graph.\n+\n+Program points in the analysis are much more fine-grained than in the\n+CFG and supergraph, with points (and thus potentially exploded nodes)\n+for various events, including before individual statements.\n+By default the exploded graph merges multiple consecutive statements\n+in a supernode into one exploded edge to minimize the size of the\n+exploded graph.  This can be suppressed via\n+@option{-fanalyzer-fine-grained}.\n+The fine-grained approach seems to make things simpler and more debuggable\n+that other approaches I tried, in that each point is responsible for one\n+thing.\n+\n+Program points in the analysis also have a \"call string\" identifying the\n+stack of callsites below them, so that paths in the exploded graph\n+correspond to interprocedurally valid paths: we always return to the\n+correct call site, propagating state information accordingly.\n+We avoid infinite recursion by stopping the analysis if a callsite\n+appears more than @code{analyzer-max-recursion-depth} in a callstring\n+(defaulting to 2).\n+\n+@subsection Graphs\n+\n+Nodes and edges in the exploded graph are called ``exploded nodes'' and\n+``exploded edges'' and often referred to in the code as\n+@code{enodes} and @code{eedges} (especially when distinguishing them\n+from the @code{snodes} and @code{sedges} in the supergraph).\n+\n+Each graph numbers its nodes, giving unique identifiers - supernodes\n+are referred to throughout dumps in the form @samp{SN': @var{index}} and\n+exploded nodes in the form @samp{EN: @var{index}} (e.g. @samp{SN: 2} and\n+@samp{EN:29}).\n+\n+The supergraph can be seen using @option{-fdump-analyzer-supergraph-graph}.\n+\n+The exploded graph can be seen using @option{-fdump-analyzer-exploded-graph}\n+and other dump options.  Exploded nodes are color-coded in the .dot output\n+based on state-machine states to make it easier to see state changes at\n+a glance.\n+\n+@subsection State Tracking\n+\n+There's a tension between:\n+@itemize @bullet\n+@item\n+precision of analysis in the straight-line case, vs\n+@item\n+exponential blow-up in the face of control flow.\n+@end itemize\n+\n+For example, in general, given this CFG:\n+\n+@smallexample\n+      A\n+     / \\\n+    B   C\n+     \\ /\n+      D\n+     / \\\n+    E   F\n+     \\ /\n+      G\n+@end smallexample\n+\n+we want to avoid differences in state-tracking in B and C from\n+leading to blow-up.  If we don't prevent state blowup, we end up\n+with exponential growth of the exploded graph like this:\n+\n+@smallexample\n+\n+           1:A\n+          /   \\\n+         /     \\\n+        /       \\\n+      2:B       3:C\n+       |         |\n+      4:D       5:D        (2 exploded nodes for D)\n+     /   \\     /   \\\n+   6:E   7:F 8:E   9:F\n+    |     |   |     |\n+   10:G 11:G 12:G  13:G    (4 exploded nodes for G)\n+\n+@end smallexample\n+\n+Similar issues arise with loops.\n+\n+To prevent this, we follow various approaches:\n+\n+@enumerate a\n+@item\n+state pruning: which tries to discard state that won't be relevant\n+later on withing the function.\n+This can be disabled via @option{-fno-analyzer-state-purge}.\n+\n+@item\n+state merging.  We can try to find the commonality between two\n+program_state instances to make a third, simpler program_state.\n+We have two strategies here:\n+\n+  @enumerate\n+  @item\n+     the worklist keeps new nodes for the same program_point together,\n+     and tries to merge them before processing, and thus before they have\n+     successors.  Hence, in the above, the two nodes for D (4 and 5) reach\n+     the front of the worklist together, and we create a node for D with\n+     the merger of the incoming states.\n+\n+  @item\n+     try merging with the state of existing enodes for the program_point\n+     (which may have already been explored).  There will be duplication,\n+     but only one set of duplication; subsequent duplicates are more likely\n+     to hit the cache.  In particular, (hopefully) all merger chains are\n+     finite, and so we guarantee termination.\n+     This is intended to help with loops: we ought to explore the first\n+     iteration, and then have a \"subsequent iterations\" exploration,\n+     which uses a state merged from that of the first, to be more abstract.\n+  @end enumerate\n+\n+We avoid merging pairs of states that have state-machine differences,\n+as these are the kinds of differences that are likely to be most\n+interesting.  So, for example, given:\n+\n+@smallexample\n+      if (condition)\n+        ptr = malloc (size);\n+      else\n+        ptr = local_buf;\n+\n+      .... do things with 'ptr'\n+\n+      if (condition)\n+        free (ptr);\n+\n+      ...etc\n+@end smallexample\n+\n+then we end up with an exploded graph that looks like this:\n+\n+@smallexample\n+\n+                   if (condition)\n+                     / T      \\ F\n+            ---------          ----------\n+           /                             \\\n+      ptr = malloc (size)             ptr = local_buf\n+          |                               |\n+      copy of                         copy of\n+        \"do things with 'ptr'\"          \"do things with 'ptr'\"\n+      with ptr: heap-allocated        with ptr: stack-allocated\n+          |                               |\n+      if (condition)                  if (condition)\n+          | known to be T                 | known to be F\n+      free (ptr);                         |\n+           \\                             /\n+            -----------------------------\n+                         | ('ptr' is pruned, so states can be merged)\n+                        etc\n+\n+@end smallexample\n+\n+where some duplication has occurred, but only for the places where the\n+the different paths are worth exploringly separately.\n+\n+Merging can be disabled via @option{-fno-analyzer-state-merge}.\n+@end enumerate\n+\n+@subsection Region Model\n+\n+Part of the state stored at a @code{exploded_node} is a @code{region_model}.\n+This is an implementation of the region-based ternary model described in\n+@url{http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf,\n+\"A Memory Model for Static Analysis of C Programs\"}\n+(Zhongxing Xu, Ted Kremenek, and Jian Zhang).\n+\n+A @code{region_model} encapsulates a representation of the state of\n+memory, with a tree of @code{region} instances, along with their associated\n+values.  The representation is graph-like because values can be pointers\n+to regions.  It also stores a constraint_manager, capturing relationships\n+between the values.\n+\n+Because each node in the @code{exploded_graph} has a @code{region_model},\n+and each of the latter is graph-like, the @code{exploded_graph} is in some\n+ways a graph of graphs.\n+\n+Here's an example of printing a @code{region_model}, showing the ASCII-art\n+used to visualize the region hierarchy (colorized when printing to stderr):\n+\n+@smallexample\n+(gdb) call debug (*this)\n+r0: @{kind: 'root', parent: null, sval: null@}\n+|-stack: r1: @{kind: 'stack', parent: r0, sval: sv1@}\n+|  |: sval: sv1: @{poisoned: uninit@}\n+|  |-frame for 'test': r2: @{kind: 'frame', parent: r1, sval: null, map: @{'ptr_3': r3@}, function: 'test', depth: 0@}\n+|  |  `-'ptr_3': r3: @{kind: 'map', parent: r2, sval: sv3, type: 'void *', map: @{@}@}\n+|  |    |: sval: sv3: @{type: 'void *', unknown@}\n+|  |    |: type: 'void *'\n+|  `-frame for 'calls_malloc': r4: @{kind: 'frame', parent: r1, sval: null, map: @{'result_3': r7, '_4': r8, '<anonymous>': r5@}, function: 'calls_malloc', depth: 1@}\n+|    |-'<anonymous>': r5: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n+|    |  |: sval: sv4: @{type: 'void *', &r6@}\n+|    |  |: type: 'void *'\n+|    |-'result_3': r7: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n+|    |  |: sval: sv4: @{type: 'void *', &r6@}\n+|    |  |: type: 'void *'\n+|    `-'_4': r8: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n+|      |: sval: sv4: @{type: 'void *', &r6@}\n+|      |: type: 'void *'\n+`-heap: r9: @{kind: 'heap', parent: r0, sval: sv2@}\n+  |: sval: sv2: @{poisoned: uninit@}\n+  `-r6: @{kind: 'symbolic', parent: r9, sval: null, map: @{@}@}\n+svalues:\n+  sv0: @{type: 'size_t', '1024'@}\n+  sv1: @{poisoned: uninit@}\n+  sv2: @{poisoned: uninit@}\n+  sv3: @{type: 'void *', unknown@}\n+  sv4: @{type: 'void *', &r6@}\n+constraint manager:\n+  equiv classes:\n+    ec0: @{sv0 == '1024'@}\n+    ec1: @{sv4@}\n+  constraints:\n+@end smallexample\n+\n+This is the state at the point of returning from @code{calls_malloc} back\n+to @code{test} in the following:\n+\n+@smallexample\n+void *\n+calls_malloc (void)\n+@{\n+  void *result = malloc (1024);\n+  return result;\n+@}\n+\n+void test (void)\n+@{\n+  void *ptr = calls_malloc ();\n+  /* etc.  */\n+@}\n+@end smallexample\n+\n+The ``root'' region (``r0'') has a ``stack'' child (``r1''), with two\n+children: a frame for @code{test} (``r2''), and a frame for\n+@code{calls_malloc} (``r4'').  These frame regions have child regions for\n+storing their local variables.  For example, the return region\n+and that of various other regions within the ``calls_malloc'' frame all have\n+value ``sv4'', a pointer to a heap-allocated region ``r6''.  Within the parent\n+frame, @code{ptr_3} has value ``sv3'', an unknown @code{void *}.\n+\n+@subsection Analyzer Paths\n+\n+We need to explain to the user what the problem is, and to persuade them\n+that there really is a problem.  Hence having a @code{diagnostic_path}\n+isn't just an incidental detail of the analyzer; it's required.\n+\n+Paths ought to be:\n+@itemize @bullet\n+@item\n+interprocedurally-valid\n+@item\n+feasible\n+@end itemize\n+\n+Without state-merging, all paths in the exploded graph are feasible\n+(in terms of constraints being satisified).\n+With state-merging, paths in the exploded graph can be infeasible.\n+\n+We collate warnings and only emit them for the simplest path\n+e.g. for a bug in a utility function, with lots of routes to calling it,\n+we only emit the simplest path (which could be intraprocedural, if\n+it can be reproduced without a caller).  We apply a check that\n+each duplicate warning's shortest path is feasible, rejecting any\n+warnings for which the shortest path is infeasible (which could lead to\n+false negatives).\n+\n+We use the shortest feasible @code{exploded_path} through the\n+@code{exploded_graph} (a list of @code{exploded_edge *}) to build a\n+@code{diagnostic_path} (a list of events for the diagnostic subsystem) -\n+specifically a @code{checker_path}.\n+\n+Having built the @code{checker_path}, we prune it to try to eliminate\n+events that aren't relevant, to minimize how much the user has to read.\n+\n+After pruning, we notify each event in the path of its ID and record the\n+IDs of interesting events, allowing for events to refer to other events\n+in their descriptions.  The @code{pending_diagnostic} class has various\n+vfuncs to support emitting more precise descriptions, so that e.g.\n+\n+@itemize @bullet\n+@item\n+a deref-of-unchecked-malloc diagnostic might use:\n+@smallexample\n+  returning possibly-NULL pointer to 'make_obj' from 'allocator'\n+@end smallexample\n+for a @code{return_event} to make it clearer how the unchecked value moves\n+from callee back to caller\n+@item\n+a double-free diagnostic might use:\n+@smallexample\n+  second 'free' here; first 'free' was at (3)\n+@end smallexample\n+and a use-after-free might use\n+@smallexample\n+  use after 'free' here; memory was freed at (2)\n+@end smallexample\n+@end itemize\n+\n+At this point we can emit the diagnostic.\n+\n+@subsection Limitations\n+\n+@itemize @bullet\n+@item\n+Only for C so far\n+@item\n+The implementation of call summaries is currently very simplistic.\n+@item\n+Lack of function pointer analysis\n+@item\n+The region model code creates lots of little mutable objects at each\n+@code{region_model} (and thus per @code{exploded_node}) rather than\n+sharing immutable objects and having the mutable state in the\n+@code{program_state} or @code{region_model}.  The latter approach might be\n+more efficient, and might avoid dealing with IDs rather than pointers\n+(which requires us to impose an ordering to get meaningful equality).\n+@item\n+The region model code doesn't yet support @code{memcpy}.  At the\n+gimple-ssa level these have been optimized to statements like this:\n+@smallexample\n+_10 = MEM <long unsigned int> [(char * @{ref-all@})&c]\n+MEM <long unsigned int> [(char * @{ref-all@})&d] = _10;\n+@end smallexample\n+Perhaps they could be supported via a new @code{compound_svalue} type.\n+@item\n+There are various other limitations in the region model (grep for TODO/xfail\n+in the testsuite).\n+@item\n+The constraint_manager's implementation of transitivity is currently too\n+expensive to enable by default and so must be manually enabled via\n+@option{-fanalyzer-transitivity}).\n+@item\n+The checkers are currently hardcoded and don't allow for user extensibility\n+(e.g. adding allocate/release pairs).\n+@item\n+Although the analyzer's test suite has a proof-of-concept test case for\n+LTO, LTO support hasn't had extensive testing.  There are various\n+lang-specific things in the analyzer that assume C rather than LTO.\n+For example, SSA names are printed to the user in ``raw'' form, rather\n+than printing the underlying variable name.\n+@end itemize\n+\n+Some ideas for other checkers\n+@itemize @bullet\n+@item\n+File-descriptor-based APIs\n+@item\n+Linux kernel internal APIs\n+@item\n+Signal handling\n+@end itemize\n+\n+@node Debugging the Analyzer\n+@section Debugging the Analyzer\n+@cindex analyzer, debugging\n+@cindex static analyzer, debugging\n+\n+@subsection Special Functions for Debugging the Analyzer\n+\n+The analyzer recognizes various special functions by name, for use\n+in debugging the analyzer.  Declarations can be seen in the testsuite\n+in @file{analyzer-decls.h}.  None of these functions are actually\n+implemented.\n+\n+Add:\n+@smallexample\n+  __analyzer_break ();\n+@end smallexample\n+to the source being analyzed to trigger a breakpoint in the analyzer when\n+that source is reached.  By putting a series of these in the source, it's\n+much easier to effectively step through the program state as it's analyzed.\n+\n+@smallexample\n+__analyzer_dump ();\n+@end smallexample\n+\n+will dump the copious information about the analyzer's state each time it\n+reaches the call in its traversal of the source.\n+\n+@smallexample\n+__analyzer_dump_path ();\n+@end smallexample\n+\n+will emit a placeholder ``note'' diagnostic with a path to that call site,\n+if the analyzer finds a feasible path to it.\n+\n+The builtin @code{__analyzer_dump_exploded_nodes} will dump information\n+after analysis on all of the exploded nodes at that program point:\n+\n+@smallexample\n+  __analyzer_dump_exploded_nodes (0);\n+@end smallexample\n+\n+will dump just the number of nodes, and their IDs.\n+\n+@smallexample\n+  __analyzer_dump_exploded_nodes (1);\n+@end smallexample\n+\n+will also dump all of the states within those nodes.\n+\n+@smallexample\n+   __analyzer_dump_region_model ();\n+@end smallexample\n+will dump the region_model's state to stderr.\n+\n+@smallexample\n+__analyzer_eval (expr);\n+@end smallexample\n+will emit a warning with text \"TRUE\", FALSE\" or \"UNKNOWN\" based on the\n+truthfulness of the argument.  This is useful for writing DejaGnu tests.\n+\n+\n+@subsection Other Debugging Techniques\n+\n+One approach when tracking down where a particular bogus state is\n+introduced into the @code{exploded_graph} is to add custom code to\n+@code{region_model::validate}.\n+\n+For example, this custom code (added to @code{region_model::validate})\n+breaks with an assertion failure when a variable called @code{ptr}\n+acquires a value that's unknown, using\n+@code{region_model::get_value_by_name} to locate the variable\n+\n+@smallexample\n+    /* Find a variable matching \"ptr\".  */\n+    svalue_id sid = get_value_by_name (\"ptr\");\n+    if (!sid.null_p ())\n+      @{\n+\tsvalue *sval = get_svalue (sid);\n+\tgcc_assert (sval->get_kind () != SK_UNKNOWN);\n+      @}\n+@end smallexample\n+\n+making it easier to investigate further in a debugger when this occurs."}, {"sha": "57a8956dac7c4181115a116e1c88b9e4d2616563", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -125,6 +125,7 @@ Additional tutorial information is linked to from\n * LTO::             Using Link-Time Optimization.\n \n * Match and Simplify:: How to write expression simplification patterns for GIMPLE and GENERIC\n+* Static Analyzer:: Working with the static analyzer.\n * User Experience Guidelines:: Guidelines for implementing diagnostics and options.\n * Funding::         How to help assure funding for free software.\n * GNU Project::     The GNU Project and GNU/Linux.\n@@ -163,6 +164,7 @@ Additional tutorial information is linked to from\n @include plugins.texi\n @include lto.texi\n @include match-and-simplify.texi\n+@include analyzer.texi\n @include ux.texi\n \n @include funding.texi"}, {"sha": "180cde3542492d6cfc1f00551406681c1f1a41bb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 433, "deletions": 2, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -153,6 +153,7 @@ listing and explanation of the binary and decimal byte size prefixes.\n * Diagnostic Message Formatting Options:: Controlling how diagnostics should\n                         be formatted.\n * Warning Options::     How picky should the compiler be?\n+* Static Analyzer Options:: More expensive warnings.\n * Debugging Options::   Producing debuggable code.\n * Optimize Options::    How much optimization?\n * Instrumentation Options:: Enabling profiling and extra run-time error checking.\n@@ -287,13 +288,31 @@ Objective-C and Objective-C++ Dialects}.\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n-@gccoptlist{-fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol\n+@gccoptlist{-fanalyzer -fsyntax-only  -fmax-errors=@var{n}  -Wpedantic @gol\n -pedantic-errors @gol\n -w  -Wextra  -Wall  -Waddress  -Waddress-of-packed-member @gol\n -Waggregate-return  -Waligned-new @gol\n -Walloc-zero  -Walloc-size-larger-than=@var{byte-size} @gol\n -Walloca  -Walloca-larger-than=@var{byte-size} @gol\n--Wno-aggressive-loop-optimizations  -Warray-bounds  -Warray-bounds=@var{n} @gol\n+-Wno-aggressive-loop-optimizations @gol\n+-Wno-analyzer-double-fclose @gol\n+-Wno-analyzer-double-free @gol\n+-Wno-analyzer-exposure-through-output-file @gol\n+-Wno-analyzer-file-leak @gol\n+-Wno-analyzer-free-of-non-heap @gol\n+-Wno-analyzer-malloc-leak @gol\n+-Wno-analyzer-possible-null-argument @gol\n+-Wno-analyzer-possible-null-dereference @gol\n+-Wno-analyzer-null-argument @gol\n+-Wno-analyzer-null-dereference @gol\n+-Wno-analyzer-stale-setjmp-buffer @gol\n+-Wno-analyzer-tainted-array-index @gol\n+-Wno-analyzer-unsafe-call-within-signal-handler @gol\n+-Wno-analyzer-use-after-free @gol\n+-Wno-analyzer-use-of-pointer-in-stale-stack-frame @gol\n+-Wno-analyzer-use-of-uninitialized-value @gol\n+-Wanalyzer-too-complex @gol\n+-Warray-bounds  -Warray-bounds=@var{n} @gol\n -Wno-attributes  -Wattribute-alias=@var{n}  @gol\n -Wbool-compare  -Wbool-operation @gol\n -Wno-builtin-declaration-mismatch @gol\n@@ -375,6 +394,44 @@ Objective-C and Objective-C++ Dialects}.\n -Wwrite-strings @gol\n -Wzero-as-null-pointer-constant}\n \n+@item Static Analyzer Options\n+@gccoptlist{-Wanalyzer-double-fclose @gol\n+-Wanalyzer-double-free @gol\n+-Wanalyzer-exposure-through-output-file @gol\n+-Wanalyzer-file-leak @gol\n+-Wanalyzer-free-of-non-heap @gol\n+-Wanalyzer-malloc-leak @gol\n+-Wanalyzer-null-argument @gol\n+-Wanalyzer-null-dereference @gol\n+-Wanalyzer-possible-null-argument @gol\n+-Wanalyzer-possible-null-dereference @gol\n+-Wanalyzer-stale-setjmp-buffer @gol\n+-Wanalyzer-tainted-array-index @gol\n+-Wanalyzer-unsafe-call-within-signal-handler @gol\n+-Wanalyzer-use-after-free @gol\n+-Wanalyzer-use-of-pointer-in-stale-stack-frame @gol\n+-Wanalyzer-use-of-uninitialized-value @gol\n+-Wanalyzer-too-complex  @gol\n+-fanalyzer-call-summaries @gol\n+-fanalyzer-checker=@var{name} @gol\n+-fanalyzer-fine-grained @gol\n+-fanalyzer-state-merge @gol\n+-fanalyzer-state-purge @gol\n+-fanalyzer-transitivity @gol\n+-fanalyzer-verbose-edges @gol\n+-fanalyzer-verbose-state-changes @gol\n+-fanalyzer-verbosity=@var{level} @gol\n+-fdump-analyzer @gol\n+-fdump-analyzer-stderr @gol\n+-fdump-analyzer-callgraph @gol\n+-fdump-analyzer-exploded-graph @gol\n+-fdump-analyzer-exploded-nodes @gol\n+-fdump-analyzer-exploded-nodes-2 @gol\n+-fdump-analyzer-exploded-nodes-3 @gol\n+-fdump-analyzer-state-purge @gol\n+-fdump-analyzer-supergraph @gol\n+}\n+\n @item C and Objective-C-only Warning Options\n @gccoptlist{-Wbad-function-cast  -Wmissing-declarations @gol\n -Wmissing-parameter-type  -Wmissing-prototypes  -Wnested-externs @gol\n@@ -6412,6 +6469,169 @@ See also @option{-Wvla-larger-than=}@samp{byte-size}.\n Disable @option{-Walloca-larger-than=} warnings.  The option is\n equivalent to @option{-Walloca-larger-than=}@samp{SIZE_MAX} or larger.\n \n+@item -Wno-analyzer-double-fclose\n+@opindex Wanalyzer-double-fclose\n+@opindex Wno-analyzer-double-fclose\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-double-fclose} to disable it.\n+\n+This diagnostic warns for paths through the code in which a @code{FILE *}\n+can have @code{fclose} called on it more than once.\n+\n+@item -Wno-analyzer-double-free\n+@opindex Wanalyzer-double-free\n+@opindex Wno-analyzer-double-free\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-double-free} to disable it.\n+\n+This diagnostic warns for paths through the code in which a pointer\n+can have @code{free} called on it more than once.\n+\n+@item -Wno-analyzer-exposure-through-output-file\n+@opindex Wanalyzer-exposure-through-output-file\n+@opindex Wno-analyzer-exposure-through-output-file\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-exposure-through-output-file}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+security-sensitive value is written to an output file\n+(such as writing a password to a log file).\n+\n+@item -Wno-analyzer-file-leak\n+@opindex Wanalyzer-file-leak\n+@opindex Wno-analyzer-file-leak\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-file-leak}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+@code{<stdio.h>} @code{FILE *} stream object is leaked.\n+\n+@item -Wno-analyzer-free-of-non-heap\n+@opindex Wanalyzer-free-of-non-heap\n+@opindex Wno-analyzer-free-of-non-heap\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-free-of-non-heap}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which @code{free}\n+is called on a non-heap pointer (e.g. an on-stack buffer, or a global).\n+\n+@item -Wno-analyzer-malloc-leak\n+@opindex Wanalyzer-malloc-leak\n+@opindex Wno-analyzer-malloc-leak\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-malloc-leak}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+pointer allocated via @code{malloc} is leaked.\n+\n+@item -Wno-analyzer-possible-null-argument\n+@opindex Wanalyzer-possible-null-argument\n+@opindex Wno-analyzer-possible-null-argument\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-possible-null-argument} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+possibly-NULL value is passed to a function argument marked\n+with @code{__attribute__((nonnull))} as requiring a non-NULL\n+value.\n+\n+@item -Wno-analyzer-possible-null-dereference\n+@opindex Wanalyzer-possible-null-dereference\n+@opindex Wno-analyzer-possible-null-dereference\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-possible-null-dereference} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+possibly-NULL value is dereferenced.\n+\n+@item -Wno-analyzer-null-argument\n+@opindex Wanalyzer-null-argument\n+@opindex Wno-analyzer-null-argument\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-null-argument} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+value known to be NULL is passed to a function argument marked\n+with @code{__attribute__((nonnull))} as requiring a non-NULL\n+value.\n+\n+@item -Wno-analyzer-null-dereference\n+@opindex Wanalyzer-null-dereference\n+@opindex Wno-analyzer-null-dereference\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-null-dereference} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+value known to be NULL is dereferenced.\n+\n+@item -Wno-analyzer-stale-setjmp-buffer\n+@opindex Wanalyzer-stale-setjmp-buffer\n+@opindex Wno-analyzer-stale-setjmp-buffer\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-stale-setjmp-buffer} to disable it.\n+\n+This diagnostic warns for paths through the code in which\n+@code{longjmp} is called to rewind to a @code{jmp_buf} relating\n+to a @code{setjmp} call in a function that has returned.\n+\n+When @code{setjmp} is called on a @code{jmp_buf} to record a rewind\n+location, it records the stack frame.  The stack frame becomes invalid\n+when the function containing the @code{setjmp} call returns.  Attempting\n+to rewind to it via @code{longjmp} would reference a stack frame that\n+no longer exists, and likely lead to a crash (or worse).\n+\n+@item -Wno-analyzer-tainted-array-index\n+@opindex Wanalyzer-tainted-array-index\n+@opindex Wno-analyzer-tainted-array-index\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-tainted-array-index} to disable it.\n+\n+This diagnostic warns for paths through the code in which a value\n+that could be under an attacker's control is used as the index\n+of an array access without being sanitized.\n+\n+@item -Wno-analyzer-unsafe-call-within-signal-handler\n+@opindex Wanalyzer-unsafe-call-within-signal-handler\n+@opindex Wno-analyzer-unsafe-call-within-signal-handler\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-unsafe-call-within-signal-handler} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+function known to be async-signal-unsafe (such as @code{fprintf}) is\n+called from a signal handler.\n+\n+@item -Wno-analyzer-use-after-free\n+@opindex Wanalyzer-use-after-free\n+@opindex Wno-analyzer-use-after-free\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-use-after-free} to disable it.\n+\n+This diagnostic warns for paths through the code in which a\n+pointer is used after @code{free} is called on it.\n+\n+@item -Wno-analyzer-use-of-pointer-in-stale-stack-frame\n+@opindex Wanalyzer-use-of-pointer-in-stale-stack-frame\n+@opindex Wno-analyzer-use-of-pointer-in-stale-stack-frame\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-use-of-pointer-in-stale-stack-frame}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which a pointer\n+is dereferenced that points to a variable in a stale stack frame.\n+\n+@item -Wno-analyzer-use-of-uninitialized-value\n+@opindex Wanalyzer-use-of-uninitialized-value\n+@opindex Wno-analyzer-use-of-uninitialized-value\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-use-of-uninitialized-value} to disable it.\n+\n+This diagnostic warns for paths through the code in which an uninitialized\n+value is used.\n+\n @item -Warray-bounds\n @itemx -Warray-bounds=@var{n}\n @opindex Wno-array-bounds\n@@ -8078,6 +8298,217 @@ OpenMP construct.\n \n @end table\n \n+@node Static Analyzer Options\n+@section Options That Control Static Analysis\n+\n+@table @gcctabopt\n+@item -fanalyzer\n+@opindex analyzer\n+@opindex fanalyzer\n+@opindex fno-analyzer\n+This option enables an static analysis of program flow which looks\n+for ``interesting'' interprocedural paths through the\n+code, and issues warnings for problems found on them.\n+\n+This analysis is much more expensive than other GCC warnings.\n+\n+Enabling this option effectively enables the following warnings:\n+\n+@gccoptlist{ @gol\n+-Wanalyzer-double-fclose @gol\n+-Wanalyzer-double-free @gol\n+-Wanalyzer-exposure-through-output-file @gol\n+-Wanalyzer-file-leak @gol\n+-Wanalyzer-free-of-non-heap @gol\n+-Wanalyzer-malloc-leak @gol\n+-Wanalyzer-possible-null-argument @gol\n+-Wanalyzer-possible-null-dereference @gol\n+-Wanalyzer-null-argument @gol\n+-Wanalyzer-null-dereference @gol\n+-Wanalyzer-tainted-array-index @gol\n+-Wanalyzer-unsafe-call-within-signal-handler @gol\n+-Wanalyzer-use-after-free @gol\n+-Wanalyzer-use-of-uninitialized-value @gol\n+-Wanalyzer-use-of-pointer-in-stale-stack-frame @gol\n+}\n+\n+This option is only available if GCC was configured with analyzer\n+support enabled.\n+\n+@item -Wanalyzer-too-complex\n+@opindex Wanalyzer-too-complex\n+@opindex Wno-analyzer-too-complex\n+If @option{-fanalyzer} is enabled, the analyzer uses various heuristics\n+to attempt to explore the control flow and data flow in the program,\n+but these can be defeated by sufficiently complicated code.\n+\n+By default, the analysis will silently stop if the code is too\n+complicated for the analyzer to fully explore and it reaches an internal\n+limit.\n+\n+The @option{-Wanalyzer-too-complex} option will warn if this occurs.\n+\n+@end table\n+\n+Pertinent parameters for controlling the exploration are:\n+@option{--param analyzer-bb-explosion-factor=@var{value}},\n+@option{--param analyzer-max-enodes-per-program-point=@var{value}},\n+@option{--param analyzer-max-recursion-depth=@var{value}}, and\n+@option{--param analyzer-min-snodes-for-call-summary=@var{value}}.\n+\n+The following options control the analyzer.\n+\n+@table @gcctabopt\n+\n+@item -fanalyzer-call-summaries\n+@opindex fanalyzer-call-summaries\n+@opindex fno-analyzer-call-summaries\n+Simplify interprocedural analysis by computing the effect of certain calls,\n+rather than exploring all paths through the function from callsite to each\n+possible return.\n+\n+If enabled, call summaries are only used for functions with more than one\n+call site, and that are sufficiently complicated (as per\n+@option{--param analyzer-min-snodes-for-call-summary=@var{value}}).\n+\n+@item -fanalyzer-checker=@var{name}\n+@opindex fanalyzer-checker\n+Restrict the analyzer to run just the named checker.\n+\n+@item -fanalyzer-fine-grained\n+@opindex fanalyzer-fine-grained\n+@opindex fno-analyzer-fine-grained\n+This option is intended for analyzer developers.\n+\n+Internally the analyzer builds an ``exploded graph'' that combines\n+control flow graphs with data flow information.\n+\n+By default, an edge in this graph can contain the effects of a run\n+of multiple statements within a basic block.  With\n+@option{-fanalyzer-fine-grained}, each statement gets its own edge.\n+\n+@item -fno-analyzer-state-merge\n+@opindex fanalyzer-state-merge\n+@opindex fno-analyzer-state-merge\n+This option is intended for analyzer developers.\n+\n+By default the analyzer will attempt to simplify analysis by merging\n+sufficiently similar states at each program point as it builds its\n+``exploded graph''.  With @option{-fno-analyzer-state-merge} this\n+merging can be suppressed, for debugging state-handling issues.\n+\n+@item -fno-analyzer-state-purge\n+@opindex fanalyzer-state-purge\n+@opindex fno-analyzer-state-purge\n+This option is intended for analyzer developers.\n+\n+By default the analyzer will attempt to simplify analysis by purging\n+aspects of state at a program point that appear to no longer be relevant\n+e.g. the values of locals that aren't accessed later in the function\n+and which aren't relevant to leak analysis.\n+\n+With @option{-fno-analyzer-state-purge} this purging of state can\n+be suppressed, for debugging state-handling issues.\n+\n+@item -fanalyzer-transitivity\n+@opindex fanalyzer-transitivity\n+@opindex fno-analyzer-transitivity\n+This option enables transitivity of constraints within the analyzer.\n+\n+@item -fanalyzer-verbose-edges\n+This option is intended for analyzer developers.  It enables more\n+verbose, lower-level detail in the descriptions of control flow\n+within diagnostic paths.\n+\n+@item -fanalyzer-verbose-state-changes\n+This option is intended for analyzer developers.  It enables more\n+verbose, lower-level detail in the descriptions of events relating\n+to state machines within diagnostic paths.\n+\n+@item -fanalyzer-verbosity=@var{level}\n+This option controls the complexity of the control flow paths that are\n+emitted for analyzer diagnostics.\n+\n+The @var{level} can be one of:\n+\n+@table @samp\n+@item 0\n+At this level, interprocedural call and return events are displayed,\n+along with the most pertinent state-change events relating to\n+a diagnostic.  For example, for a double-@code{free} diagnostic,\n+both calls to @code{free} will be shown.\n+\n+@item 1\n+As per the previous level, but also show events for the entry\n+to each function.\n+\n+@item 2\n+As per the previous level, but also show  events relating to\n+control flow (e.g. ``true path taken'' at a conditional).\n+\n+This level is the default.\n+\n+@item 3\n+This level is intended for analyzer developers; it adds various\n+other events intended for debugging the analyzer.\n+\n+@end table\n+\n+@item -fdump-analyzer\n+@opindex fdump-analyzer\n+Dump internal details about what the analyzer is doing to\n+@file{@var{file}.analyzer.txt}.\n+This option is overridden by @option{-fdump-analyzer-stderr}.\n+\n+@item -fdump-analyzer-stderr\n+@opindex fdump-analyzer-stderr\n+Dump internal details about what the analyzer is doing to stderr.\n+This option overrides @option{-fdump-analyzer}.\n+\n+@item -fdump-analyzer-callgraph\n+@opindex fdump-analyzer-callgraph\n+Dump a representation of the call graph suitable for viewing with\n+GraphViz to @file{@var{file}.callgraph.dot}.\n+\n+@item -fdump-analyzer-exploded-graph\n+@opindex fdump-analyzer-exploded-graph\n+Dump a representation of the ``exploded graph'' suitable for viewing with\n+GraphViz to @file{@var{file}.eg.dot}.\n+Nodes are color-coded based on state-machine states to emphasize\n+state changes.\n+\n+@item -fdump-analyzer-exploded-nodes\n+@opindex dump-analyzer-exploded-nodes\n+Emit diagnostics showing where nodes in the ``exploded graph'' are\n+in relation to the program source.\n+\n+@item -fdump-analyzer-exploded-nodes-2\n+@opindex dump-analyzer-exploded-nodes-2\n+Dump a textual representation of the ``exploded graph'' to\n+@file{@var{file}.eg.txt}.\n+\n+@item -fdump-analyzer-exploded-nodes-3\n+@opindex dump-analyzer-exploded-nodes-3\n+Dump a textual representation of the ``exploded graph'' to\n+one dump file per node, to @file{@var{file}.eg-@var{id}.txt}.\n+This is typically a large number of dump files.\n+\n+@item -fdump-analyzer-state-purge\n+@opindex fdump-analyzer-state-purge\n+As per @option{-fdump-analyzer-supergraph}, dump a representation of the\n+``supergraph'' suitable for viewing with GraphViz, but annotate the\n+graph with information on what state will be purged at each node.\n+The graph is written to @file{@var{file}.state-purge.dot}.\n+\n+@item -fdump-analyzer-supergraph\n+@opindex fdump-analyzer-supergraph\n+Dump a representation of the ``supergraph'' suitable for viewing with\n+GraphViz to @file{@var{file}.supergraph.dot}.  This shows all of the\n+control flow graphs in the program, with interprocedural edges for\n+calls and returns.\n+\n+@end table\n+\n @node Debugging Options\n @section Options for Debugging Your Program\n @cindex options, debugging"}, {"sha": "c18a630343e2c1e79a5f9a0151499a769d81597d", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -2644,6 +2644,9 @@ This is equivalent to @code{dg-require-effective-target cxa_atexit}.\n @item dg-require-dll \"\"\n Skip the test if the target does not support DLL attributes.\n \n+@item dg-require-dot \"\"\n+Skip the test if the host does not have @command{dot}.\n+\n @item dg-require-fork \"\"\n Skip the test if the target does not support @code{fork}.\n \n@@ -2687,6 +2690,9 @@ Passes if @var{regexp} matches text in @var{filename}.\n Passes if @var{regexp} does not match text in @var{filename}.\n @item scan-module @var{module} @var{regexp} [@{ target/xfail @var{selector} @}]\n Passes if @var{regexp} matches in Fortran module @var{module}.\n+@item dg-check-dot @var{filename}\n+Passes if @var{filename} is a valid @file{.dot} file (by running\n+@code{dot -Tpng} on it, and verifying the exit code is 0).\n @end table\n \n @subsubsection Scan the assembly output"}, {"sha": "c5b020c2180e57ba15e660e59c92ba13f22ffa2d", "filename": "gcc/gdbinit.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgdbinit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgdbinit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbinit.in?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -219,6 +219,16 @@ is emitted (as opposed to those warnings that are suppressed by\n command-line options).\n end\n \n+define break-on-saved-diagnostic\n+break diagnostic_manager::add_diagnostic\n+end\n+\n+document break-on-saved-diagnostic\n+Put a breakpoint on diagnostic_manager::add_diagnostic, called within\n+the analyzer whenever a diagnostic is saved for later de-duplication and\n+possible emission.\n+end\n+\n define reload-gdbhooks\n python import imp; imp.reload(gdbhooks)\n end"}, {"sha": "1185fdb41afb4ec4d60e26c671063335cba6e70a", "filename": "gcc/graphviz.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgraphviz.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgraphviz.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphviz.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,100 @@\n+/* Helper code for graphviz output.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"graphviz.h\"\n+\n+/* graphviz_out's ctor, wrapping PP.  */\n+\n+graphviz_out::graphviz_out (pretty_printer *pp)\n+: m_pp (pp),\n+  m_indent (0)\n+{\n+}\n+\n+/* Formatted print of FMT.  */\n+\n+void\n+graphviz_out::print (const char *fmt, ...)\n+{\n+  text_info text;\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+  text.err_no = errno;\n+  text.args_ptr = &ap;\n+  text.format_spec = fmt;\n+  pp_format (m_pp, &text);\n+  pp_output_formatted_text (m_pp);\n+  va_end (ap);\n+}\n+\n+/* Formatted print of FMT.  The text is indented by the current\n+   indent, and a newline is added.  */\n+\n+void\n+graphviz_out::println (const char *fmt, ...)\n+{\n+  text_info text;\n+  va_list ap;\n+\n+  write_indent ();\n+\n+  va_start (ap, fmt);\n+  text.err_no = errno;\n+  text.args_ptr = &ap;\n+  text.format_spec = fmt;\n+  pp_format (m_pp, &text);\n+  pp_output_formatted_text (m_pp);\n+  va_end (ap);\n+\n+  pp_newline (m_pp);\n+}\n+\n+/* Print the current indent to the underlying pp.  */\n+\n+void\n+graphviz_out::write_indent ()\n+{\n+  for (int i = 0; i < m_indent * 2; ++i)\n+    pp_space (m_pp);\n+}\n+\n+/* Write the start of an HTML-like row via <TR><TD>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::begin_tr ()\n+{\n+  pp_string (m_pp, \"<TR><TD ALIGN=\\\"LEFT\\\">\");\n+  pp_write_text_to_stream (m_pp);\n+}\n+\n+/* Write the end of an HTML-like row via </TD></TR>, writing to the stream\n+   so that followup text can be escaped.  */\n+\n+void\n+graphviz_out::end_tr ()\n+{\n+  pp_string (m_pp, \"</TD></TR>\");\n+  pp_write_text_to_stream (m_pp);\n+}"}, {"sha": "7f771673402e93cf41ee79553655d490edc9c149", "filename": "gcc/graphviz.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgraphviz.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fgraphviz.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphviz.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,53 @@\n+/* Helper code for graphviz output.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHVIZ_H\n+#define GCC_GRAPHVIZ_H\n+\n+#include \"pretty-print.h\" /* for ATTRIBUTE_GCC_PPDIAG.  */\n+\n+/* A class for writing .dot output to a pretty_printer with\n+   indentation to show nesting.  */\n+\n+class graphviz_out {\n+ public:\n+  graphviz_out (pretty_printer *pp);\n+\n+  void print (const char *fmt, ...)\n+    ATTRIBUTE_GCC_PPDIAG(2,3);\n+  void println (const char *fmt, ...)\n+    ATTRIBUTE_GCC_PPDIAG(2,3);\n+\n+  void indent () { m_indent++; }\n+  void outdent () { m_indent--; }\n+\n+  void write_indent ();\n+\n+  void begin_tr ();\n+  void end_tr ();\n+\n+  pretty_printer *get_pp () const { return m_pp; }\n+\n+ private:\n+  pretty_printer *m_pp;\n+  int m_indent;\n+};\n+\n+#endif /* GCC_GRAPHVIZ_H */"}, {"sha": "2bc5f6ed715e9e983254e32f352cdd79644b6dbd", "filename": "gcc/ordered-hash-map-tests.cc", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fordered-hash-map-tests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fordered-hash-map-tests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fordered-hash-map-tests.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7", "patch": "@@ -0,0 +1,247 @@\n+/* Unit tests for ordered-hash-map.h.\n+   Copyright (C) 2015-2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"opts.h\"\n+#include \"hash-set.h\"\n+#include \"fixed-value.h\"\n+#include \"alias.h\"\n+#include \"flags.h\"\n+#include \"symtab.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Populate *OUT_KVS with the key/value pairs of M.  */\n+\n+template <typename HashMap, typename Key, typename Value>\n+static void\n+get_kv_pairs (const HashMap &m,\n+\t      auto_vec<std::pair<Key, Value> > *out_kvs)\n+{\n+  for (typename HashMap::iterator iter = m.begin ();\n+       iter != m.end ();\n+       ++iter)\n+    out_kvs->safe_push (std::make_pair ((*iter).first, (*iter).second));\n+}\n+\n+/* Construct an ordered_hash_map <const char *, int> and verify that\n+   various operations work correctly.  */\n+\n+static void\n+test_map_of_strings_to_int ()\n+{\n+  ordered_hash_map <const char *, int> m;\n+\n+  const char *ostrich = \"ostrich\";\n+  const char *elephant = \"elephant\";\n+  const char *ant = \"ant\";\n+  const char *spider = \"spider\";\n+  const char *millipede = \"Illacme plenipes\";\n+  const char *eric = \"half a bee\";\n+\n+  /* A fresh hash_map should be empty.  */\n+  ASSERT_EQ (0, m.elements ());\n+  ASSERT_EQ (NULL, m.get (ostrich));\n+\n+  /* Populate the hash_map.  */\n+  ASSERT_EQ (false, m.put (ostrich, 2));\n+  ASSERT_EQ (false, m.put (elephant, 4));\n+  ASSERT_EQ (false, m.put (ant, 6));\n+  ASSERT_EQ (false, m.put (spider, 8));\n+  ASSERT_EQ (false, m.put (millipede, 750));\n+  ASSERT_EQ (false, m.put (eric, 3));\n+\n+  /* Verify that we can recover the stored values.  */\n+  ASSERT_EQ (6, m.elements ());\n+  ASSERT_EQ (2, *m.get (ostrich));\n+  ASSERT_EQ (4, *m.get (elephant));\n+  ASSERT_EQ (6, *m.get (ant));\n+  ASSERT_EQ (8, *m.get (spider));\n+  ASSERT_EQ (750, *m.get (millipede));\n+  ASSERT_EQ (3, *m.get (eric));\n+\n+  /* Verify that the order of insertion is preserved.  */\n+  auto_vec<std::pair<const char *, int> > kvs;\n+  get_kv_pairs (m, &kvs);\n+  ASSERT_EQ (kvs.length (), 6);\n+  ASSERT_EQ (kvs[0].first, ostrich);\n+  ASSERT_EQ (kvs[0].second, 2);\n+  ASSERT_EQ (kvs[1].first, elephant);\n+  ASSERT_EQ (kvs[1].second, 4);\n+  ASSERT_EQ (kvs[2].first, ant);\n+  ASSERT_EQ (kvs[2].second, 6);\n+  ASSERT_EQ (kvs[3].first, spider);\n+  ASSERT_EQ (kvs[3].second, 8);\n+  ASSERT_EQ (kvs[4].first, millipede);\n+  ASSERT_EQ (kvs[4].second, 750);\n+  ASSERT_EQ (kvs[5].first, eric);\n+  ASSERT_EQ (kvs[5].second, 3);\n+}\n+\n+/* Construct an ordered_hash_map using int_hash and verify that various\n+   operations work correctly.  */\n+\n+static void\n+test_map_of_int_to_strings ()\n+{\n+  const int EMPTY = -1;\n+  const int DELETED = -2;\n+  typedef int_hash <int, EMPTY, DELETED> int_hash_t;\n+  ordered_hash_map <int_hash_t, const char *> m;\n+\n+  const char *ostrich = \"ostrich\";\n+  const char *elephant = \"elephant\";\n+  const char *ant = \"ant\";\n+  const char *spider = \"spider\";\n+  const char *millipede = \"Illacme plenipes\";\n+  const char *eric = \"half a bee\";\n+\n+  /* A fresh hash_map should be empty.  */\n+  ASSERT_EQ (0, m.elements ());\n+  ASSERT_EQ (NULL, m.get (2));\n+\n+  /* Populate the hash_map.  */\n+  ASSERT_EQ (false, m.put (2, ostrich));\n+  ASSERT_EQ (false, m.put (4, elephant));\n+  ASSERT_EQ (false, m.put (6, ant));\n+  ASSERT_EQ (false, m.put (8, spider));\n+  ASSERT_EQ (false, m.put (750, millipede));\n+  ASSERT_EQ (false, m.put (3, eric));\n+\n+  /* Verify that we can recover the stored values.  */\n+  ASSERT_EQ (6, m.elements ());\n+  ASSERT_EQ (*m.get (2), ostrich);\n+  ASSERT_EQ (*m.get (4), elephant);\n+  ASSERT_EQ (*m.get (6), ant);\n+  ASSERT_EQ (*m.get (8), spider);\n+  ASSERT_EQ (*m.get (750), millipede);\n+  ASSERT_EQ (*m.get (3), eric);\n+\n+  /* Verify that the order of insertion is preserved.  */\n+  auto_vec<std::pair<int, const char *> > kvs;\n+  get_kv_pairs (m, &kvs);\n+  ASSERT_EQ (kvs.length (), 6);\n+  ASSERT_EQ (kvs[0].first, 2);\n+  ASSERT_EQ (kvs[0].second, ostrich);\n+  ASSERT_EQ (kvs[1].first, 4);\n+  ASSERT_EQ (kvs[1].second, elephant);\n+  ASSERT_EQ (kvs[2].first, 6);\n+  ASSERT_EQ (kvs[2].second, ant);\n+  ASSERT_EQ (kvs[3].first, 8);\n+  ASSERT_EQ (kvs[3].second, spider);\n+  ASSERT_EQ (kvs[4].first, 750);\n+  ASSERT_EQ (kvs[4].second, millipede);\n+  ASSERT_EQ (kvs[5].first, 3);\n+  ASSERT_EQ (kvs[5].second, eric);\n+}\n+\n+/* Verify that we can remove items from an ordered_hash_map.  */\n+\n+static void\n+test_removal ()\n+{\n+  ordered_hash_map <const char *, int> m;\n+\n+  const char *ostrich = \"ostrich\";\n+  ASSERT_EQ (false, m.put (ostrich, 2));\n+\n+  ASSERT_EQ (1, m.elements ());\n+  ASSERT_EQ (2, *m.get (ostrich));\n+\n+  {\n+    auto_vec<std::pair<const char *, int> > kvs;\n+    get_kv_pairs (m, &kvs);\n+    ASSERT_EQ (kvs.length (), 1);\n+    ASSERT_EQ (kvs[0].first, ostrich);\n+    ASSERT_EQ (kvs[0].second, 2);\n+  }\n+\n+  m.remove (ostrich);\n+\n+  ASSERT_EQ (0, m.elements ());\n+  {\n+    auto_vec<std::pair<const char *, int> > kvs;\n+    get_kv_pairs (m, &kvs);\n+    ASSERT_EQ (kvs.length (), 0);\n+  }\n+\n+  /* Reinsertion (with a different value).  */\n+  ASSERT_EQ (false, m.put (ostrich, 42));\n+  ASSERT_EQ (1, m.elements ());\n+  ASSERT_EQ (42, *m.get (ostrich));\n+  {\n+    auto_vec<std::pair<const char *, int> > kvs;\n+    get_kv_pairs (m, &kvs);\n+    ASSERT_EQ (kvs.length (), 1);\n+    ASSERT_EQ (kvs[0].first, ostrich);\n+    ASSERT_EQ (kvs[0].second, 42);\n+  }\n+}\n+\n+/* Verify that ordered_hash_map's copy-ctor works.  */\n+\n+static void\n+test_copy_ctor ()\n+{\n+  ordered_hash_map <const char *, int> m;\n+\n+  const char *ostrich = \"ostrich\";\n+  ASSERT_EQ (false, m.put (ostrich, 2));\n+\n+  ASSERT_EQ (1, m.elements ());\n+  ASSERT_EQ (2, *m.get (ostrich));\n+\n+  ordered_hash_map <const char *, int> copy (m);\n+  ASSERT_EQ (1, copy.elements ());\n+  ASSERT_EQ (2, *copy.get (ostrich));\n+\n+  /* Remove from source.  */\n+  m.remove (ostrich);\n+  ASSERT_EQ (0, m.elements ());\n+\n+  /* Copy should be unaffected.  */\n+  ASSERT_EQ (1, copy.elements ());\n+  ASSERT_EQ (2, *copy.get (ostrich));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+ordered_hash_map_tests_cc_tests ()\n+{\n+  test_map_of_strings_to_int ();\n+  test_map_of_int_to_strings ();\n+  test_removal ();\n+  test_copy_ctor ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "188519fd3dc5a2fb829245b0f15375a9a6c80294", "filename": "gcc/ordered-hash-map.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fordered-hash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fordered-hash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fordered-hash-map.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "0106c8d5fd074fdb26d9b56f3c61931935a83daf", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "e451387ab21122e1e3fb50401dd3adee5f99024b", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "df98e0b5f12c45b713110944588f23dbe2bbc0c0", "filename": "gcc/selftest.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "fa0b0d897dca426b4f37e9c2ae52155348642d06", "filename": "gcc/shortest-paths.h", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fshortest-paths.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Fshortest-paths.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshortest-paths.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8e3b910518836ac991f51b22365a36c99d480585", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "aa9deb3be196939ba3501b4bc4fd316824305a05", "filename": "gcc/testsuite/gcc.dg/analyzer/CVE-2005-1689-minimal.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ea1756e47cb0c8a29581c8f36b1e63b9e2a0ff4e", "filename": "gcc/testsuite/gcc.dg/analyzer/abort.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabort.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6d9fe3431ceaf400e3548471bba2c5492744fbc9", "filename": "gcc/testsuite/gcc.dg/analyzer/alloca-leak.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Falloca-leak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Falloca-leak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Falloca-leak.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "180e873b67c97f79d5a5052cebaf163baeef4032", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-decls.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f21cd37782415b5e21306adc2101e2631db8e07e", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-0.c", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-0.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6d6e70a8ae11f2e13fcebee7796896915acfc447", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-1.c", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "3d3316af1f9a4123b8d3c29e45ccb5e432951186", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-verbosity-2.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-verbosity-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ac9c49511aa0ab014f46c60ade2b3ae3c442809e", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer.exp", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer.exp?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8c27b3ae7a453aee77c620dec7027b0e49c7aae7", "filename": "gcc/testsuite/gcc.dg/analyzer/attribute-nonnull.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a64b230cef32e23bf403b349b2d4c94d0dee4b7e", "filename": "gcc/testsuite/gcc.dg/analyzer/call-summaries-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcall-summaries-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6f291f4861b2b0b37f02352bb156019a58c094c1", "filename": "gcc/testsuite/gcc.dg/analyzer/conditionals-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5f29f215dd17b39083fd58b4b2535778266f1476", "filename": "gcc/testsuite/gcc.dg/analyzer/conditionals-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8e4ea5f58a7132aba86fd955838677aa4f24197b", "filename": "gcc/testsuite/gcc.dg/analyzer/conditionals-notrans.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ab34618c4110356fe07ac5c4202d7945ecd3f8b4", "filename": "gcc/testsuite/gcc.dg/analyzer/conditionals-trans.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-trans.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7260e3bb59ad2c48b8c6f3a70d807856d3aae8a4", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "added", "additions": 1085, "deletions": 0, "changes": 1085, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c261edcc827fb5e12a1d331f5a3b87a11aebfad9", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-10.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "27663247c327438b42e744704fb872d27bd3daa8", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-11.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-11.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "653b7ad628464158aed6eaeb258b80666bbc8bdb", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-12.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-12.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "e7cb8455b7dc251fcb57bb023cf8cbbb1e5cc3e5", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-13.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f9bb540b0229dc876672eab3c7d95ec7efd356aa", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-14.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "12e84a12420b159e2bef31c7008d4f2614114d20", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-15.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-15.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a8acfbeeb77a7a24168232788966f810008a1495", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-16.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-16.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d50b84ab43aee84fb677fe5bdecdd2895927bbc9", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-17.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-17.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7b096b0674d65c83137a49a05df23248d2cdc2fc", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-18.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "69978383d1b2d0a363acb55c0817056b327501e3", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-19.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-19.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d5be03ba565257a96abf02f30715c70c3f663e89", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "3d572eb8d73f0f0f542a49df1eff6a17de007b3e", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "33f90871dfbcda4cd28ad4497a490b92e9f77fda", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5cf334768d82192d6be0a9c55df5ddd92ff02919", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b0203af9975c3723eee377dc9b5daf97bfc0dd66", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5b.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1e52350c6c16de8b20048b91551fe13f4d1f03b3", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5c.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8c7bfa91a9689772b8140a8939297b8db24a6cf1", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5d.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "78a797ead76e4a6445e6eeb05012792b2f404db8", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "67a681be607f3b38986fe4142c7bac7354caa728", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-7.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "aff9036919606e85294cfd87c9afb11117cfcb70", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "bab4b573f5bd178d912bc45b6460a54375669d02", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-9.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-9.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d7058ea18e034a181bf7fac686956703ac9394a9", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-path-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-path-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-path-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-path-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a696d1e021e0611006f2f366d90cd2ca1734021e", "filename": "gcc/testsuite/gcc.dg/analyzer/disabling.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdisabling.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdisabling.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdisabling.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "586e14421e0ee7b0d75288b7912e51650808148b", "filename": "gcc/testsuite/gcc.dg/analyzer/dot-output.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "61e7846773246e453cb3ee77f360542ea027fa04", "filename": "gcc/testsuite/gcc.dg/analyzer/double-free-lto-1-a.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6041e6983a2f2ae2e202baabfcbddec30e376e59", "filename": "gcc/testsuite/gcc.dg/analyzer/double-free-lto-1-b.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1-b.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c5e21570d00dd2ca4f50098e6b5c82affc24c80b", "filename": "gcc/testsuite/gcc.dg/analyzer/double-free-lto-1.h", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdouble-free-lto-1.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "609b6fdef50c98ffca761fbfd7f52234006bfb0e", "filename": "gcc/testsuite/gcc.dg/analyzer/equivalence.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fequivalence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fequivalence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fequivalence.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6b62e8e871c86fb4319680a8202ff744fab1c4d4", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d786aa93896b7d6b84d321828ca4f09a0cdf2ac9", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "384713a245a4f2b9f23d173dd4d561c65340f406", "filename": "gcc/testsuite/gcc.dg/analyzer/factorial.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffactorial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffactorial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffactorial.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5d4a4e02e39e71cc3bdbdb0b121e56b12d88452d", "filename": "gcc/testsuite/gcc.dg/analyzer/fibonacci.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffibonacci.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffibonacci.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffibonacci.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "de55208070a26daa773845a5fd79b630654e99a6", "filename": "gcc/testsuite/gcc.dg/analyzer/fields.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffields.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "91d9685d9e9e7274c4ca68d99c5b225698dbece1", "filename": "gcc/testsuite/gcc.dg/analyzer/file-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "aa0457071eaf9121402499940fdd2cf964b41da6", "filename": "gcc/testsuite/gcc.dg/analyzer/file-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "38c3e597d7e08f11af85c7ea1bbe01e9a48c2e6b", "filename": "gcc/testsuite/gcc.dg/analyzer/function-ptr-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "411b1b39377f68ec71d965e64d8460cf726042d0", "filename": "gcc/testsuite/gcc.dg/analyzer/function-ptr-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "348ee4a0cb3f487a0bbb7fd699ce1cc84b0544b7", "filename": "gcc/testsuite/gcc.dg/analyzer/function-ptr-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffunction-ptr-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "855ecc8f73d43b67eebad50ff736d87f13c6d676", "filename": "gcc/testsuite/gcc.dg/analyzer/gzio-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "0a11f65fdcaf54b9c32e593ad5e74d43cee6d878", "filename": "gcc/testsuite/gcc.dg/analyzer/gzio-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "15ed0103fe07d8b58c9ab0679dbe91a87dd6d6f4", "filename": "gcc/testsuite/gcc.dg/analyzer/gzio-3a.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio-3a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "54efa77d05617d0b09a31e1964891a6ac30fcdb3", "filename": "gcc/testsuite/gcc.dg/analyzer/gzio.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fgzio.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b770e128bc689c39d568e612332f6608220c56ef", "filename": "gcc/testsuite/gcc.dg/analyzer/infinite-recursion.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finfinite-recursion.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "595f23915caa24ccc2f7778e520e2e0ff0ca786d", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d50bfe0f31b78b1422b0d1ae660dc794da7853a6", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-2a.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1d01771d7cb720bee34b7fd31c1207ef5075fb45", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "105237570d1f2dc3f42361883130df22fd4c2e46", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "3f29fa6146e29a879a86e55f7ab87b298e3a9fc6", "filename": "gcc/testsuite/gcc.dg/analyzer/loop.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b9a724d0034db68c99949a1a90b816edee518031", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6d073f56619390a3e764bd7240640ecf0bf50985", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5afb6b3b0f7b62210365f830b9d40ab618978fb2", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-3.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "eb5545e5da00bbf412ab3ea141f7652b29b9186a", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-callbacks.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-callbacks.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1b4b8788b86b831148de0c2396822c4f8392e996", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-dce.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dce.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "233ab485b5afb37e8d3633ebaad8d22d3f9e79e1", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-dedupe-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dedupe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dedupe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-dedupe-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ad536ce5f02f08cbfc7519adcb5aec1a5ee4791f", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7e8f274e7bc86ec65a30e543f79c032a036ca0e3", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-10.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-10.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b65ff9165e4da5c1bd730e8bc306a3618e18f2b4", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-11.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-11.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "fce5437edd16e6ab2824d97086ca3747d85bf0f7", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-12.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-12.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2e3d80ed5cc623b95bdfc9715254850ec6b7d85a", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-13.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "efeb94bc1feb3f1e72b4d14b6d32b211ac0a251c", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "3dcfae8f0a296118d4c98c4885ea211695ef3d2b", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "82d50bd3c9367966a9075bc68e4c660025caf311", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c66ecb5c5635257db7852fd10a2ad1179180b8d8", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "62f8b55c3643bbd2fd42ab11ad2262ce431e445f", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-6.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "0742370d2f91d776c7c060603381fe58a2843c27", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-7.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-7.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f86e8ac72d733c63c23203f4050120830d9d7ff9", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-double-free.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c34e4beee4b07e25114c565f598685ecc96c6fa6", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-lto-a.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c9d7df1a45227d3b1d529926931aed1fd31e8e20", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-lto-b.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-b.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d332db13ef0528b3d3131b40f7f2b8b032e0e935", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-lto-c.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto-c.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f24eefc0d0ea7665256e8b6330904b2df9bdbb40", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-lto.h", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-lto.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a778a29852f8e6f4cd2a8cdfd1c0ae08fdbac07a", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-unchecked.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a0c78fd6c4ec706414c621abf73eaa36da284ec0", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-9.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-9.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f08aee626a5e02af6d8f6b13dd099d4ef5fb372f", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-macro-inline-events.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-inline-events.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-inline-events.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-inline-events.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "e7483af9230e23597742c0e78b0ceea12dd0c855", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-macro-separate-events.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-separate-events.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-separate-events.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro-separate-events.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8c05b406bd90608e588a2033de2b27da96d13842", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-macro.h", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-macro.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "82ad547a201654b79eeb4c0ebfdafd15222ab3dd", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-many-paths-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "9f6440b52b2d81f7bedd7fc3c8fd184b28f8c2bd", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-many-paths-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "e5d27a4a33a697f87b4839857490b87cf1accfd8", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-many-paths-3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-many-paths-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5d989ea665b7e12c94b21f0fb4cbb29585060f0b", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2a2937ed043e95f1f6ea118b02e64090d2d73f67", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-10.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a9bf7a94d6013c323ec4dba6bef7763ece976260", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ed6026019dcf4bd5117d9de907a0251b75ea0f9e", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "3385245828b3232618764e37296b74ead96edfa4", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b54a81fbdcf2b94bff4038b577ad53e5c60bb5c0", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-5.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1df6964544e275be5c995244bafd34d72465b883", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-6.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "eb55604f0a57849b66c97e641af4b43eb63a4a6e", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-7.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-7.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "bf858e04840d49ff49a93727b3c571c02b856265", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-8.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-8.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7b3a0a110e2ae2c483d71e76e779fc6ac04c07da", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-9.c", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "72360c2f9fadf92d29b8b3401cacff5fc409f8ea", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-1a.c", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1997bb7adb42b862cf70865bec588bede2cae079", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-1b.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1b.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "74d9687b960f00d77e22bb1ba67c99fd68426e76", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-2.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "fe9b240be5b7e973330124f56ed518db7bd86dcf", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7410a717762bd14481c903807ec3656b56dceeca", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "0f8aad21afe7241c1e2aad70172e0c23ec7d50b2", "filename": "gcc/testsuite/gcc.dg/analyzer/operations.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Foperations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Foperations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Foperations.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "433c658720f232e85aca34e982b074fafc995838", "filename": "gcc/testsuite/gcc.dg/analyzer/params-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "02371da98871f05c0ce89aa9089e732919efe7c2", "filename": "gcc/testsuite/gcc.dg/analyzer/params.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fparams.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "0646877447234d42aa688ee99382803f64d30f5e", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8760de93499f085193daa9faf9837dd73c018193", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-1a.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-1a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c48a2d7758c5a0ade55727592964273133bdc5e5", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "440213b79915d0425e4a41c8529de8f7d3140b32", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "34bd09eee057915bd03e7cc74e59b8ed84aee749", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-4.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f96169d9d2bcc57cbf3914e55a61a910d4fdffca", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "7a1a94228dd93190cda7aa03dbf90392aade19c7", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-6.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "6a99e64439fcf32cb0cd118166dd5661e328ec77", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-7.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "8a1ca58eb184fa73eee4f6f41ffac2b9277e86c7", "filename": "gcc/testsuite/gcc.dg/analyzer/pattern-test-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "392490034dfa2ca0d628b0f18e6197f2f9134562", "filename": "gcc/testsuite/gcc.dg/analyzer/pattern-test-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpattern-test-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "dcf0ff048bb29049580df3a861cc9d43d7925407", "filename": "gcc/testsuite/gcc.dg/analyzer/pointer-merging.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpointer-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpointer-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpointer-merging.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a85e743890522df32ba77b1baa6790517fb2808c", "filename": "gcc/testsuite/gcc.dg/analyzer/pr61861.c", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr61861.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr61861.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr61861.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2e533489405b5bf4593ffb263c29cd6288386092", "filename": "gcc/testsuite/gcc.dg/analyzer/pragma-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpragma-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpragma-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpragma-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f8acffa18e4124a46850fbbbfe183a5530275dbc", "filename": "gcc/testsuite/gcc.dg/analyzer/scope-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fscope-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fscope-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fscope-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "1a5ab47d3e7e6fb37d277cbe0ddc96b49926034c", "filename": "gcc/testsuite/gcc.dg/analyzer/sensitive-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsensitive-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsensitive-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsensitive-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c9827fbd2989fbe707ad3861e0ba2d1e14bc2b10", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-1.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f0fd23cf2641eba6922d54af90d8e3e59d8ec306", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "19504d20c444dd17ef4575b2bf34a2a1a1f6d783", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-3.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5325612855a1f95dc4e2cbe975a82acbbc79d1c1", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-4.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2c41e6dff773ae935b4b0c4d151edde298478c63", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-5.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "84a6318ed3cafda76500edef24f1319d13908977", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-6.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ee4183dfb2a77851d1c38d85aa1e3b3b6cdf2175", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-7.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "10cb4c165c43db7ad33c0f2f3ac19fb1478d7d89", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-7a.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2fb88d2ae647679142085dc5f425b736334dee30", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-8.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "c17aaa10fd04342dd4c9f901350f582c84e2283f", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-9.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "4dcbcc0fc6bd21f47a7cc9ec90f0b6055f7e7528", "filename": "gcc/testsuite/gcc.dg/analyzer/signal-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "a56acb060ec816a4151a302f5176059fa4ae79db", "filename": "gcc/testsuite/gcc.dg/analyzer/signal-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5b308888777149acd20d5cde7c6647234aab3c91", "filename": "gcc/testsuite/gcc.dg/analyzer/signal-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "4b68b6d045b9080b56b5478a4a5863b608b23cf9", "filename": "gcc/testsuite/gcc.dg/analyzer/signal-4a.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4a.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "38d40247357473d5fe05942ec9b774cc7626622c", "filename": "gcc/testsuite/gcc.dg/analyzer/signal-4b.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsignal-4b.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "cc50a6fdba595b378f29cede79770aedfb969aff", "filename": "gcc/testsuite/gcc.dg/analyzer/strcmp-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstrcmp-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "ad4b6568dc2ae1081c1f62c3fdbe370852367563", "filename": "gcc/testsuite/gcc.dg/analyzer/switch.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fswitch.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "cea5440d14c44677cd7e93ef217efd8b9a44e368", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-1.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5537c984e1aa1c841ec114a1a3001b394b68cca6", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-1.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d0b587cbbbea750b4a5c8d3a8db663a93bae4130", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-2.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "5faada16f38f5b3b6832f6b8a6b7f4af7ce0a102", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-3.c", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "08261442128fa066e1c4ca3e8eb2567691e8559e", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "715604dbe774103eac393513b69372dd745a7234", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-5.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-5.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "d68c387fa534c6ccb05a82827c76743eb522b50c", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-6.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "180a9ab3a52554bd8977df5e008b1b043ea45d69", "filename": "gcc/testsuite/lib/gcc-defs.exp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-defs.exp?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "2a21424b8905d82bc2cceb62dc0987da6bd1e28e", "filename": "gcc/testsuite/lib/target-supports-dg.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "62a745a7c7e8037712c684568b9f88438f019bde", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "f467d0251f77ec75c19bedff89d6cf980951bf33", "filename": "gcc/timevar.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "b6abeab751ec13d1bc584b9ed3174bd95f1bf54a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "127d7407163ad8feb5f48d6aa89438f32eebb894", "filename": "gcc/tristate.cc", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftristate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftristate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftristate.cc?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}, {"sha": "e65cb6a09ac8e79897f2f92ebc6b39e8886c3d7b", "filename": "gcc/tristate.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftristate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/757bf1dff5e8cee34c0a75d06140ca972bfecfa7/gcc%2Ftristate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftristate.h?ref=757bf1dff5e8cee34c0a75d06140ca972bfecfa7"}]}