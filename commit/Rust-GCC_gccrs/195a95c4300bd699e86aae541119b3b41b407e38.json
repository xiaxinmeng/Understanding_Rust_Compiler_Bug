{"sha": "195a95c4300bd699e86aae541119b3b41b407e38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1YTk1YzQzMDBiZDY5OWU4NmFhZTU0MTExOWIzYjQxYjQwN2UzOA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-06T05:55:10Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-06T05:55:10Z"}, "message": "re PR fortran/38282 (Bit intrinsics: ILEN and IBCHNG)\n\n2010-09-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/38282\n        * intrinsic.c (add_functions): Support IALL, IANY, IPARITY.\n        (check_specific): Special case for those intrinsics.\n        * gfortran.h (gfc_isym_id): Add new intrinsics\n        * intrinsic.h (gfc_check_transf_bit_intrins,\n        gfc_simplify_iall, gfc_simplify_iany, gfc_simplify_iparity,\n        gfc_resolve_iall, gfc_resolve_iany, gfc_resolve_iparity):\n        New prototypes.\n        * iresolve.c (gfc_resolve_iall, gfc_resolve_iany,\n        gfc_resolve_iparity, resolve_transformational): New functions.\n        (gfc_resolve_product, gfc_resolve_sum,\n        gfc_resolve_parity): Use resolve_transformational.\n        * check.c (gfc_check_transf_bit_intrins): New function.\n        * simplify.c (gfc_simplify_iall, gfc_simplify_iany,\n        gfc_simplify_iparity, do_bit_any, do_bit_ior,\n        do_bit_xor, simplify_transformation): New functions.\n        (gfc_simplify_all, gfc_simplify_any, gfc_simplify_parity,\n        gfc_simplify_sum, gfc_simplify_product): Use simplify_transformation.\n        * trans-intrinsic.c (gfc_conv_intrinsic_arith,\n        gfc_conv_intrinsic_function, gfc_is_intrinsic_libcall):\n        Handle IALL, IANY and IPARITY intrinsics.       \n        * intrinsic.texi (IMAGE_INDEX): Move up to fix alphabetic\n        order.\n        (IALL, IANY, IPARITY): Document new intrinsics.\n\n2010-09-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/38282\n        * gfortran.dg/iall_iany_iparity_1.f90: New.\n        * gfortran.dg/iall_iany_iparity_2.f90: New.\n\n2010-09-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/38282\n        * gfortran.map: Add new iany, iall and iparity intrinsics.\n        * Makefile.am: Ditto.\n        * m4/iany.m4: New.\n        * m4/iall.m4: New.\n        * m4/iparity.m4: New.\n        * Makefile.in: Regenerate.\n        * generated/iall_i1.c: Generate.\n        * generated/iall_i2.c: Generate.\n        * generated/iall_i4.c: Generate.\n        * generated/iall_i8.c: Generate.\n        * generated/iall_i16.c: Generate.\n        * generated/iany_i1.c: Generate.\n        * generated/iany_i2.c: Generate.\n        * generated/iany_i4.c: Generate.\n        * generated/iany_i8.c: Generate.\n        * generated/iany_i16.c: Generate.\n        * generated/iparity_i1.c: Generate.\n        * generated/iparity_i2.c: Generate.\n        * generated/iparity_i4.c: Generate.\n        * generated/iparity_i8.c: Generate.\n        * generated/iparity_i16.c: Generate.\n\nFrom-SVN: r163898", "tree": {"sha": "b60ae679f939f761998c881713e1adbe57c96041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b60ae679f939f761998c881713e1adbe57c96041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/195a95c4300bd699e86aae541119b3b41b407e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195a95c4300bd699e86aae541119b3b41b407e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/195a95c4300bd699e86aae541119b3b41b407e38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195a95c4300bd699e86aae541119b3b41b407e38/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1c53d72bec3e943a4f57f9b5530626a2e6882eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c53d72bec3e943a4f57f9b5530626a2e6882eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c53d72bec3e943a4f57f9b5530626a2e6882eef"}], "stats": {"total": 8807, "additions": 8570, "deletions": 237}, "files": [{"sha": "e661b441ac6dc023ad8f4ee6f1e47dbbdfe03417", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -1,3 +1,30 @@\n+2010-09-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/38282\n+\t* intrinsic.c (add_functions): Support IALL, IANY, IPARITY.\n+\t(check_specific): Special case for those intrinsics.\n+\t* gfortran.h (gfc_isym_id): Add new intrinsics\n+\t* intrinsic.h (gfc_check_transf_bit_intrins,\n+\tgfc_simplify_iall, gfc_simplify_iany, gfc_simplify_iparity,\n+\tgfc_resolve_iall, gfc_resolve_iany, gfc_resolve_iparity):\n+\tNew prototypes.\n+\t* iresolve.c (gfc_resolve_iall, gfc_resolve_iany,\n+\tgfc_resolve_iparity, resolve_transformational): New functions.\n+\t(gfc_resolve_product, gfc_resolve_sum,\n+\tgfc_resolve_parity): Use resolve_transformational.\n+\t* check.c (gfc_check_transf_bit_intrins): New function.\n+\t* simplify.c (gfc_simplify_iall, gfc_simplify_iany,\n+\tgfc_simplify_iparity, do_bit_any, do_bit_ior,\n+\tdo_bit_xor, simplify_transformation): New functions.\n+\t(gfc_simplify_all, gfc_simplify_any, gfc_simplify_parity,\n+\tgfc_simplify_sum, gfc_simplify_product): Use simplify_transformation.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_arith,\n+\tgfc_conv_intrinsic_function, gfc_is_intrinsic_libcall):\n+\tHandle IALL, IANY and IPARITY intrinsics.\t\n+\t* intrinsic.texi (IMAGE_INDEX): Move up to fix alphabetic\n+\torder.\n+\t(IALL, IANY, IPARITY): Document new intrinsics.\n+\n 2010-09-05  Tobias Burnus <burnus@net-b.de>\n \n \tPR fortran/45186"}, {"sha": "308895d8597ee7204bd4b020f2e61bc338ea80a8", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -2353,6 +2353,26 @@ gfc_check_product_sum (gfc_actual_arglist *ap)\n }\n \n \n+/* For IANY, IALL and IPARITY.  */\n+\n+gfc_try\n+gfc_check_transf_bit_intrins (gfc_actual_arglist *ap)\n+{\n+  if (ap->expr->ts.type != BT_INTEGER)\n+    {\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER\",\n+                 gfc_current_intrinsic_arg[0]->name,\n+                 gfc_current_intrinsic, &ap->expr->where);\n+      return FAILURE;\n+    }\n+\n+  if (array_check (ap->expr, 0) == FAILURE)\n+    return FAILURE;\n+\n+  return check_reduction (ap);\n+}\n+\n+\n gfc_try\n gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {"}, {"sha": "06ef0c52d4bf0f9350ae6549d18cf7c46897f778", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -397,7 +397,9 @@ enum gfc_isym_id\n   GFC_ISYM_HUGE,\n   GFC_ISYM_HYPOT,\n   GFC_ISYM_IACHAR,\n+  GFC_ISYM_IALL,\n   GFC_ISYM_IAND,\n+  GFC_ISYM_IANY,\n   GFC_ISYM_IARGC,\n   GFC_ISYM_IBCLR,\n   GFC_ISYM_IBITS,\n@@ -412,6 +414,7 @@ enum gfc_isym_id\n   GFC_ISYM_INT2,\n   GFC_ISYM_INT8,\n   GFC_ISYM_IOR,\n+  GFC_ISYM_IPARITY,\n   GFC_ISYM_IRAND,\n   GFC_ISYM_ISATTY,\n   GFC_ISYM_IS_IOSTAT_END,"}, {"sha": "f36484a8e2b77f51b48495f6101165ce6350b07b", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -1777,6 +1777,20 @@ add_functions (void)\n \n   make_generic (\"and\", GFC_ISYM_AND, GFC_STD_GNU);\n \n+  add_sym_3red (\"iall\", GFC_ISYM_IALL, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n+\t\tgfc_check_transf_bit_intrins, gfc_simplify_iall, gfc_resolve_iall,\n+\t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n+\n+  make_generic (\"iall\", GFC_ISYM_IALL, GFC_STD_F2008);\n+\n+  add_sym_3red (\"iany\", GFC_ISYM_IANY, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n+\t\tgfc_check_transf_bit_intrins, gfc_simplify_iany, gfc_resolve_iany,\n+\t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n+\n+  make_generic (\"iany\", GFC_ISYM_IANY, GFC_STD_F2008);\n+\n   add_sym_0 (\"iargc\", GFC_ISYM_IARGC, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER,\n \t     di, GFC_STD_GNU, NULL, NULL, NULL);\n \n@@ -1885,6 +1899,13 @@ add_functions (void)\n \n   make_generic (\"or\", GFC_ISYM_OR, GFC_STD_GNU);\n \n+  add_sym_3red (\"iparity\", GFC_ISYM_IPARITY, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F2008,\n+\t\tgfc_check_transf_bit_intrins, gfc_simplify_iparity, gfc_resolve_iparity,\n+\t\tar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL,\n+\t\tmsk, BT_LOGICAL, dl, OPTIONAL);\n+\n+  make_generic (\"iparity\", GFC_ISYM_IPARITY, GFC_STD_F2008);\n+\n   /* The following function is for G77 compatibility.  */\n   add_sym_1 (\"irand\", GFC_ISYM_IRAND, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER,\n \t     4, GFC_STD_GNU, gfc_check_irand, NULL, NULL,\n@@ -3737,6 +3758,9 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n     /* Same here. The difference to the previous case is that we allow a\n        general numeric type.  */\n     t = gfc_check_product_sum (*ap);\n+  else if (specific->check.f3red == gfc_check_transf_bit_intrins)\n+    /* Same as for PRODUCT and SUM, but different checks.  */\n+    t = gfc_check_transf_bit_intrins (*ap);\n   else\n      {\n        if (specific->check.f1 == NULL)"}, {"sha": "178dbf7395c9fcafd0be45aee57369b3630379bc", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -144,6 +144,7 @@ gfc_try gfc_check_stat (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_storage_size (gfc_expr *, gfc_expr *);\n gfc_try gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_symlnk (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_transf_bit_intrins (gfc_actual_arglist *);\n gfc_try gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_try gfc_check_transpose (gfc_expr *);\n gfc_try gfc_check_trim (gfc_expr *);\n@@ -260,7 +261,9 @@ gfc_expr *gfc_simplify_gamma (gfc_expr *);\n gfc_expr *gfc_simplify_huge (gfc_expr *);\n gfc_expr *gfc_simplify_hypot (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_iachar (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_iall (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_iand (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_iany (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibclr (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ibset (gfc_expr *, gfc_expr *);\n@@ -275,6 +278,7 @@ gfc_expr *gfc_simplify_long (gfc_expr *);\n gfc_expr *gfc_simplify_ifix (gfc_expr *);\n gfc_expr *gfc_simplify_idint (gfc_expr *);\n gfc_expr *gfc_simplify_ior (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_iparity (gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_is_iostat_end (gfc_expr *);\n gfc_expr *gfc_simplify_is_iostat_eor (gfc_expr *);\n gfc_expr *gfc_simplify_isnan (gfc_expr *);\n@@ -441,12 +445,15 @@ void gfc_resolve_ierrno (gfc_expr *);\n void gfc_resolve_ieor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ichar (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_iachar (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_iall (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_iany (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_idnint (gfc_expr *, gfc_expr *);\n void gfc_resolve_int (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_int2 (gfc_expr *, gfc_expr *);\n void gfc_resolve_int8 (gfc_expr *, gfc_expr *);\n void gfc_resolve_long (gfc_expr *, gfc_expr *);\n void gfc_resolve_ior (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_iparity (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_isatty (gfc_expr *, gfc_expr *);\n void gfc_resolve_rshift (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_lshift (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "bea3b36fc4f251901ea5ce5b4d2503b410b8f741", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 229, "deletions": 45, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -139,7 +139,9 @@ Some basic guidelines for editing this document:\n * @code{HUGE}:          HUGE,      Largest number of a kind\n * @code{HYPOT}:         HYPOT,     Euclidian distance function\n * @code{IACHAR}:        IACHAR,    Code in @acronym{ASCII} collating sequence\n+* @code{IALL}:          IALL,      Bitwise AND of array elements\n * @code{IAND}:          IAND,      Bitwise logical and\n+* @code{IANY}:          IANY,      Bitwise OR of array elements\n * @code{IARGC}:         IARGC,     Get the number of command line arguments\n * @code{IBCLR}:         IBCLR,     Clear bit\n * @code{IBITS}:         IBITS,     Bit extraction\n@@ -148,13 +150,14 @@ Some basic guidelines for editing this document:\n * @code{IDATE}:         IDATE,     Current local time (day/month/year)\n * @code{IEOR}:          IEOR,      Bitwise logical exclusive or\n * @code{IERRNO}:        IERRNO,    Function to get the last system error number\n+* @code{IMAGE_INDEX}:   IMAGE_INDEX, Cosubscript to image index convertion\n * @code{INDEX}:         INDEX intrinsic, Position of a substring within a string\n * @code{INT}:           INT,       Convert to integer type\n * @code{INT2}:          INT2,      Convert to 16-bit integer type\n * @code{INT8}:          INT8,      Convert to 64-bit integer type\n * @code{IOR}:           IOR,       Bitwise logical or\n+* @code{IPARITY}:       IPARITY,   Bitwise XOR of array elements\n * @code{IRAND}:         IRAND,     Integer pseudo-random number\n-* @code{IMAGE_INDEX}:   IMAGE_INDEX, Cosubscript to image index convertion\n * @code{IS_IOSTAT_END}:  IS_IOSTAT_END, Test for end-of-file value\n * @code{IS_IOSTAT_EOR}:  IS_IOSTAT_EOR, Test for end-of-record value\n * @code{ISATTY}:        ISATTY,    Whether a unit is a terminal device\n@@ -5580,6 +5583,66 @@ and formatted string representations.\n \n \n \n+@node IALL\n+@section @code{IALL} --- Bitwise AND of array elements\n+@fnindex IALL\n+@cindex array, AND\n+@cindex bits, AND of array elements\n+\n+@table @asis\n+@item @emph{Description}:\n+Reduces with bitwise AND the elements of @var{ARRAY} along dimension @var{DIM}\n+if the corresponding element in @var{MASK} is @code{TRUE}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Transformational function\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .80\n+@item @code{RESULT = IALL(ARRAY[, MASK])}\n+@item @code{RESULT = IALL(ARRAY, DIM[, MASK])}\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER}\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type \n+@code{INTEGER} with a value in the range from 1 to n, where n \n+equals the rank of @var{ARRAY}.\n+@item @var{MASK}  @tab (Optional) shall be of type @code{LOGICAL} \n+and either be a scalar or an array of the same shape as @var{ARRAY}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The result is of the same type as @var{ARRAY}.\n+\n+If @var{DIM} is absent, a scalar with the bitwise ALL of all elements in\n+@var{ARRAY} is returned. Otherwise, an array of rank n-1, where n equals\n+the rank of @var{ARRAY}, and a shape similar to that of @var{ARRAY} with\n+dimension @var{DIM} dropped is returned.\n+\n+@item @emph{Example}:\n+@smallexample\n+PROGRAM test_iall\n+  INTEGER(1) :: a(2)\n+\n+  a(1) = b'00100100'\n+  a(1) = b'01101010'\n+\n+  ! prints 00100000\n+  PRINT '(b8.8)', IALL(a)\n+END PROGRAM\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{IANY}, @ref{IPARITY}, @ref{IAND}\n+@end table\n+\n+\n+\n @node IAND\n @section @code{IAND} --- Bitwise logical and\n @fnindex IAND\n@@ -5628,6 +5691,66 @@ END PROGRAM\n \n \n \n+@node IANY\n+@section @code{IANY} --- Bitwise XOR of array elements\n+@fnindex IANY\n+@cindex array, OR\n+@cindex bits, OR of array elements\n+\n+@table @asis\n+@item @emph{Description}:\n+Reduces with bitwise OR (inclusive or) the elements of @var{ARRAY} along\n+dimension @var{DIM} if the corresponding element in @var{MASK} is @code{TRUE}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Transformational function\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .80\n+@item @code{RESULT = IANY(ARRAY[, MASK])}\n+@item @code{RESULT = IANY(ARRAY, DIM[, MASK])}\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER}\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type \n+@code{INTEGER} with a value in the range from 1 to n, where n \n+equals the rank of @var{ARRAY}.\n+@item @var{MASK}  @tab (Optional) shall be of type @code{LOGICAL} \n+and either be a scalar or an array of the same shape as @var{ARRAY}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The result is of the same type as @var{ARRAY}.\n+\n+If @var{DIM} is absent, a scalar with the bitwise OR of all elements in\n+@var{ARRAY} is returned. Otherwise, an array of rank n-1, where n equals\n+the rank of @var{ARRAY}, and a shape similar to that of @var{ARRAY} with\n+dimension @var{DIM} dropped is returned.\n+\n+@item @emph{Example}:\n+@smallexample\n+PROGRAM test_iany\n+  INTEGER(1) :: a(2)\n+\n+  a(1) = b'00100100'\n+  a(1) = b'01101010'\n+\n+  ! prints 01111011\n+  PRINT '(b8.8)', IANY(a)\n+END PROGRAM\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{IPARITY}, @ref{IALL}, @ref{IOR}\n+@end table\n+\n+\n+\n @node IARGC\n @section @code{IARGC} --- Get the number of command line arguments\n @fnindex IARGC\n@@ -5977,6 +6100,50 @@ kind.\n \n \n \n+@node IMAGE_INDEX\n+@section @code{IMAGE_INDEX} --- Function that converts a cosubscript to an image index\n+@fnindex IMAGE_INDEX\n+@cindex coarray, IMAGE_INDEX\n+@cindex images, cosubscript to image index conversion\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the image index belonging to a cosubscript.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Inquiry function.\n+\n+@item @emph{Syntax}:\n+@code{RESULT = IMAGE_INDEX(COARRAY, SUB)}\n+\n+@item @emph{Arguments}: None.\n+@multitable @columnfractions .15 .70\n+@item @var{COARRAY} @tab Coarray of any type.\n+@item @var{SUB}     @tab default integer rank-1 array of a size equal to\n+the corank of @var{COARRAY}.\n+@end multitable\n+\n+\n+@item @emph{Return value}:\n+Scalar default integer with the value of the image index which corresponds\n+to the cosubscripts. For invalid cosubscripts the result is zero.\n+\n+@item @emph{Example}:\n+@smallexample\n+INTEGER :: array[2,-1:4,8,*]\n+! Writes  28 (or 0 if there are fewer than 28 images)\n+WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{THIS_IMAGE}, @ref{NUM_IMAGES}\n+@end table\n+\n+\n+\n @node INDEX intrinsic\n @section @code{INDEX} --- Position of a substring within a string\n @fnindex INDEX\n@@ -6204,6 +6371,67 @@ the larger argument.)\n \n \n \n+@node IPARITY\n+@section @code{IPARITY} --- Bitwise XOR of array elements\n+@fnindex IPARITY\n+@cindex array, parity\n+@cindex array, XOR\n+@cindex bits, XOR of array elements\n+\n+@table @asis\n+@item @emph{Description}:\n+Reduces with bitwise XOR (exclusive or) the elements of @var{ARRAY} along\n+dimension @var{DIM} if the corresponding element in @var{MASK} is @code{TRUE}.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Transformational function\n+\n+@item @emph{Syntax}:\n+@multitable @columnfractions .80\n+@item @code{RESULT = IPARITY(ARRAY[, MASK])}\n+@item @code{RESULT = IPARITY(ARRAY, DIM[, MASK])}\n+@end multitable\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of type @code{INTEGER}\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type \n+@code{INTEGER} with a value in the range from 1 to n, where n \n+equals the rank of @var{ARRAY}.\n+@item @var{MASK}  @tab (Optional) shall be of type @code{LOGICAL} \n+and either be a scalar or an array of the same shape as @var{ARRAY}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The result is of the same type as @var{ARRAY}.\n+\n+If @var{DIM} is absent, a scalar with the bitwise XOR of all elements in\n+@var{ARRAY} is returned. Otherwise, an array of rank n-1, where n equals\n+the rank of @var{ARRAY}, and a shape similar to that of @var{ARRAY} with\n+dimension @var{DIM} dropped is returned.\n+\n+@item @emph{Example}:\n+@smallexample\n+PROGRAM test_iparity\n+  INTEGER(1) :: a(2)\n+\n+  a(1) = b'00100100'\n+  a(1) = b'01101010'\n+\n+  ! prints 10111011\n+  PRINT '(b8.8)', IPARITY(a)\n+END PROGRAM\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{IANY}, @ref{IALL}, @ref{IEOR}, @ref{PARITY}\n+@end table\n+\n+\n+\n @node IRAND\n @section @code{IRAND} --- Integer pseudo-random number\n @fnindex IRAND\n@@ -6255,50 +6483,6 @@ end program test_irand\n \n \n \n-@node IMAGE_INDEX\n-@section @code{IMAGE_INDEX} --- Function that converts a cosubscript to an image index\n-@fnindex IMAGE_INDEX\n-@cindex coarray, IMAGE_INDEX\n-@cindex images, cosubscript to image index conversion\n-\n-@table @asis\n-@item @emph{Description}:\n-Returns the image index belonging to a cosubscript.\n-\n-@item @emph{Standard}:\n-Fortran 2008 and later\n-\n-@item @emph{Class}:\n-Inquiry function.\n-\n-@item @emph{Syntax}:\n-@code{RESULT = IMAGE_INDEX(COARRAY, SUB)}\n-\n-@item @emph{Arguments}: None.\n-@multitable @columnfractions .15 .70\n-@item @var{COARRAY} @tab Coarray of any type.\n-@item @var{SUB}     @tab default integer rank-1 array of a size equal to\n-the corank of @var{COARRAY}.\n-@end multitable\n-\n-\n-@item @emph{Return value}:\n-Scalar default integer with the value of the image index which corresponds\n-to the cosubscripts. For invalid cosubscripts the result is zero.\n-\n-@item @emph{Example}:\n-@smallexample\n-INTEGER :: array[2,-1:4,8,*]\n-! Writes  28 (or 0 if there are fewer than 28 images)\n-WRITE (*,*) IMAGE_INDEX (array, [2,0,3,1])\n-@end smallexample\n-\n-@item @emph{See also}:\n-@ref{THIS_IMAGE}, @ref{NUM_IMAGES}\n-@end table\n-\n-\n-\n @node IS_IOSTAT_END\n @section @code{IS_IOSTAT_END} --- Test for end-of-file value\n @fnindex IS_IOSTAT_END"}, {"sha": "9aab4995f7c0d391c989c155e8b6df282ef21ebc", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 59, "deletions": 76, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -141,6 +141,40 @@ resolve_bound (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *kind,\n   f->value.function.name = xstrdup (name);\n }\n \n+\n+static void\n+resolve_transformational (const char *name, gfc_expr *f, gfc_expr *array,\n+\t\t\t  gfc_expr *dim, gfc_expr *mask)\n+{\n+  const char *prefix;\n+\n+  f->ts = array->ts;\n+\n+  if (mask)\n+    {\n+      if (mask->rank == 0)\n+\tprefix = \"s\";\n+      else\n+\tprefix = \"m\";\n+\n+      resolve_mask_arg (mask);\n+    }\n+  else\n+    prefix = \"\";\n+\n+  if (dim != NULL)\n+    {\n+      f->rank = array->rank - 1;\n+      f->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n+      gfc_resolve_dim_arg (dim);\n+    }\n+\n+  f->value.function.name\n+    = gfc_get_string (PREFIX (\"%s%s_%c%d\"), prefix, name,\n+\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+}\n+\n+\n /********************** Resolution functions **********************/\n \n \n@@ -1043,6 +1077,13 @@ gfc_resolve_hypot (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)\n }\n \n \n+void\n+gfc_resolve_iall (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  resolve_transformational (\"iall\", f, array, dim, mask);\n+}\n+\n+\n void\n gfc_resolve_iand (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n {\n@@ -1062,6 +1103,13 @@ gfc_resolve_iand (gfc_expr *f, gfc_expr *i, gfc_expr *j)\n }\n \n \n+void\n+gfc_resolve_iany (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  resolve_transformational (\"iany\", f, array, dim, mask);\n+}\n+\n+\n void\n gfc_resolve_ibclr (gfc_expr *f, gfc_expr *i, gfc_expr *pos ATTRIBUTE_UNUSED)\n {\n@@ -1238,6 +1286,13 @@ gfc_resolve_long (gfc_expr *f, gfc_expr *a)\n }\n \n \n+void\n+gfc_resolve_iparity (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  resolve_transformational (\"iparity\", f, array, dim, mask);\n+}\n+\n+\n void\n gfc_resolve_isatty (gfc_expr *f, gfc_expr *u)\n {\n@@ -1827,17 +1882,7 @@ gfc_resolve_nint (gfc_expr *f, gfc_expr *a, gfc_expr *kind)\n void\n gfc_resolve_norm2 (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n {\n-  f->ts = array->ts;\n-\n-  if (dim != NULL)\n-    {\n-      f->rank = array->rank - 1;\n-      f->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n-      gfc_resolve_dim_arg (dim);\n-    }\n-\n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"norm2_r%d\"), array->ts.kind);\n+  resolve_transformational (\"norm2\", f, array, dim, NULL);\n }\n \n \n@@ -1908,52 +1953,15 @@ gfc_resolve_pack (gfc_expr *f, gfc_expr *array, gfc_expr *mask,\n void\n gfc_resolve_parity (gfc_expr *f, gfc_expr *array, gfc_expr *dim)\n {\n-  f->ts = array->ts;\n-\n-  if (dim != NULL)\n-    {\n-      f->rank = array->rank - 1;\n-      f->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n-      gfc_resolve_dim_arg (dim);\n-    }\n-\n-  resolve_mask_arg (array);\n-\n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"parity_l%d\"), array->ts.kind);\n+  resolve_transformational (\"parity\", f, array, dim, NULL);\n }\n \n \n void\n gfc_resolve_product (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n \t\t     gfc_expr *mask)\n {\n-  const char *name;\n-\n-  f->ts = array->ts;\n-\n-  if (dim != NULL)\n-    {\n-      f->rank = array->rank - 1;\n-      f->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n-      gfc_resolve_dim_arg (dim);\n-    }\n-\n-  if (mask)\n-    {\n-      if (mask->rank == 0)\n-\tname = \"sproduct\";\n-      else\n-\tname = \"mproduct\";\n-\n-      resolve_mask_arg (mask);\n-    }\n-  else\n-    name = \"product\";\n-\n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n-\t\t      gfc_type_letter (array->ts.type), array->ts.kind);\n+  resolve_transformational (\"product\", f, array, dim, mask);\n }\n \n \n@@ -2412,32 +2420,7 @@ gfc_resolve_storage_size (gfc_expr *f, gfc_expr *a ATTRIBUTE_UNUSED,\n void\n gfc_resolve_sum (gfc_expr *f, gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  const char *name;\n-\n-  f->ts = array->ts;\n-\n-  if (mask)\n-    {\n-      if (mask->rank == 0)\n-\tname = \"ssum\";\n-      else\n-\tname = \"msum\";\n-\n-      resolve_mask_arg (mask);\n-    }\n-  else\n-    name = \"sum\";\n-\n-  if (dim != NULL)\n-    {\n-      f->rank = array->rank - 1;\n-      f->shape = gfc_copy_shape_excluding (array->shape, array->rank, dim);\n-      gfc_resolve_dim_arg (dim);\n-    }\n-\n-  f->value.function.name\n-    = gfc_get_string (PREFIX (\"%s_%c%d\"), name,\n-\t\t    gfc_type_letter (array->ts.type), array->ts.kind);\n+  resolve_transformational (\"sum\", f, array, dim, mask);\n }\n \n "}, {"sha": "248df6cc5d26fe3d0aa2e025410c70a0fe8a9174", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 87, "deletions": 74, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -620,6 +620,30 @@ simplify_transformation_to_array (gfc_expr *result, gfc_expr *array, gfc_expr *d\n }\n \n \n+static gfc_expr *\n+simplify_transformation (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n+\t\t\t int init_val, transformational_op op)\n+{\n+  gfc_expr *result;\n+\n+  if (!is_constant_array_expr (array)\n+      || !gfc_is_constant_expr (dim))\n+    return NULL;\n+\n+  if (mask\n+      && !is_constant_array_expr (mask)\n+      && mask->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  result = transformational_result (array, dim, array->ts.type,\n+\t\t\t\t    array->ts.kind, &array->where);\n+  init_result_expr (result, init_val, NULL);\n+\n+  return !dim || array->rank == 1 ?\n+    simplify_transformation_to_scalar (result, array, mask, op) :\n+    simplify_transformation_to_array (result, array, dim, mask, op, NULL);\n+}\n+\n \n /********************** Simplification functions *****************************/\n \n@@ -888,19 +912,7 @@ gfc_simplify_aint (gfc_expr *e, gfc_expr *k)\n gfc_expr *\n gfc_simplify_all (gfc_expr *mask, gfc_expr *dim)\n {\n-  gfc_expr *result;\n-\n-  if (!is_constant_array_expr (mask)\n-      || !gfc_is_constant_expr (dim))\n-    return NULL;\n-\n-  result = transformational_result (mask, dim, mask->ts.type,\n-\t\t\t\t    mask->ts.kind, &mask->where);\n-  init_result_expr (result, true, NULL);\n-\n-  return !dim || mask->rank == 1 ?\n-    simplify_transformation_to_scalar (result, mask, NULL, gfc_and) :\n-    simplify_transformation_to_array (result, mask, dim, NULL, gfc_and, NULL);\n+  return simplify_transformation (mask, dim, NULL, true, gfc_and);\n }\n \n \n@@ -974,19 +986,7 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n gfc_expr *\n gfc_simplify_any (gfc_expr *mask, gfc_expr *dim)\n {\n-  gfc_expr *result;\n-\n-  if (!is_constant_array_expr (mask)\n-      || !gfc_is_constant_expr (dim))\n-    return NULL;\n-\n-  result = transformational_result (mask, dim, mask->ts.type,\n-\t\t\t\t    mask->ts.kind, &mask->where);\n-  init_result_expr (result, false, NULL);\n-\n-  return !dim || mask->rank == 1 ?\n-    simplify_transformation_to_scalar (result, mask, NULL, gfc_or) :\n-    simplify_transformation_to_array (result, mask, dim, NULL, gfc_or, NULL);\n+  return simplify_transformation (mask, dim, NULL, false, gfc_or);\n }\n \n \n@@ -2231,6 +2231,44 @@ gfc_simplify_iachar (gfc_expr *e, gfc_expr *kind)\n }\n \n \n+static gfc_expr *\n+do_bit_and (gfc_expr *result, gfc_expr *e)\n+{\n+  gcc_assert (e->ts.type == BT_INTEGER && e->expr_type == EXPR_CONSTANT);\n+  gcc_assert (result->ts.type == BT_INTEGER\n+\t      && result->expr_type == EXPR_CONSTANT);\n+\n+  mpz_and (result->value.integer, result->value.integer, e->value.integer);\n+  return result;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_iall (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  return simplify_transformation (array, dim, mask, -1, do_bit_and);\n+}\n+\n+\n+static gfc_expr *\n+do_bit_ior (gfc_expr *result, gfc_expr *e)\n+{\n+  gcc_assert (e->ts.type == BT_INTEGER && e->expr_type == EXPR_CONSTANT);\n+  gcc_assert (result->ts.type == BT_INTEGER\n+\t      && result->expr_type == EXPR_CONSTANT);\n+\n+  mpz_ior (result->value.integer, result->value.integer, e->value.integer);\n+  return result;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_iany (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  return simplify_transformation (array, dim, mask, 0, do_bit_ior);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_iand (gfc_expr *x, gfc_expr *y)\n {\n@@ -2683,6 +2721,26 @@ gfc_simplify_ior (gfc_expr *x, gfc_expr *y)\n }\n \n \n+static gfc_expr *\n+do_bit_xor (gfc_expr *result, gfc_expr *e)\n+{\n+  gcc_assert (e->ts.type == BT_INTEGER && e->expr_type == EXPR_CONSTANT);\n+  gcc_assert (result->ts.type == BT_INTEGER\n+\t      && result->expr_type == EXPR_CONSTANT);\n+\n+  mpz_xor (result->value.integer, result->value.integer, e->value.integer);\n+  return result;\n+}\n+\n+\n+gfc_expr *\n+gfc_simplify_iparity (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n+{\n+  return simplify_transformation (array, dim, mask, 0, do_bit_xor);\n+}\n+\n+\n+\n gfc_expr *\n gfc_simplify_is_iostat_end (gfc_expr *x)\n {\n@@ -4277,18 +4335,7 @@ do_xor (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_parity (gfc_expr *e, gfc_expr *dim)\n {\n-  gfc_expr *result;\n-\n-  if (!is_constant_array_expr (e)\n-      || (dim != NULL && !gfc_is_constant_expr (dim)))\n-    return NULL;\n-\n-  result = transformational_result (e, dim, e->ts.type, e->ts.kind, &e->where);\n-  init_result_expr (result, 0, NULL);\n-\n-  return (!dim || e->rank == 1)\n-    ? simplify_transformation_to_scalar (result, e, NULL, do_xor)\n-    : simplify_transformation_to_array (result, e, dim, NULL, do_xor, NULL);\n+  return simplify_transformation (e, dim, NULL, 0, do_xor);\n }\n \n \n@@ -4345,24 +4392,7 @@ gfc_simplify_precision (gfc_expr *e)\n gfc_expr *\n gfc_simplify_product (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  gfc_expr *result;\n-\n-  if (!is_constant_array_expr (array)\n-      || !gfc_is_constant_expr (dim))\n-    return NULL;\n-\n-  if (mask\n-      && !is_constant_array_expr (mask)\n-      && mask->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n-  result = transformational_result (array, dim, array->ts.type,\n-\t\t\t\t    array->ts.kind, &array->where);\n-  init_result_expr (result, 1, NULL);\n-\n-  return !dim || array->rank == 1 ?\n-    simplify_transformation_to_scalar (result, array, mask, gfc_multiply) :\n-    simplify_transformation_to_array (result, array, dim, mask, gfc_multiply, NULL);\n+  return simplify_transformation (array, dim, mask, 1, gfc_multiply);\n }\n \n \n@@ -5508,24 +5538,7 @@ gfc_simplify_sqrt (gfc_expr *e)\n gfc_expr *\n gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  gfc_expr *result;\n-\n-  if (!is_constant_array_expr (array)\n-      || !gfc_is_constant_expr (dim))\n-    return NULL;\n-\n-  if (mask\n-      && !is_constant_array_expr (mask)\n-      && mask->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n-  result = transformational_result (array, dim, array->ts.type,\n-\t\t\t\t    array->ts.kind, &array->where);\n-  init_result_expr (result, 0, NULL);\n-\n-  return !dim || array->rank == 1 ?\n-    simplify_transformation_to_scalar (result, array, mask, gfc_add) :\n-    simplify_transformation_to_array (result, array, dim, mask, gfc_add, NULL);\n+  return simplify_transformation (array, dim, mask, 0, gfc_add);\n }\n \n "}, {"sha": "c49908b76d3474ca962dd6111386e02347ff666c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -2004,11 +2004,14 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op,\n \t\t      gfc_build_const (type, integer_one_node));\n       tmp = gfc_build_const (type, integer_zero_node);\n     }\n-  else if (op == PLUS_EXPR)\n+  else if (op == PLUS_EXPR || op == BIT_IOR_EXPR || op == BIT_XOR_EXPR)\n     tmp = gfc_build_const (type, integer_zero_node);\n   else if (op == NE_EXPR)\n     /* PARITY.  */\n     tmp = convert (type, boolean_false_node);\n+  else if (op == BIT_AND_EXPR)\n+    tmp = gfc_build_const (type, fold_build1_loc (input_location, NEGATE_EXPR,\n+\t\t\t\t\t\t  type, integer_one_node));\n   else\n     tmp = gfc_build_const (type, integer_one_node);\n \n@@ -5530,10 +5533,18 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_fraction (se, expr);\n       break;\n \n+    case GFC_ISYM_IALL:\n+      gfc_conv_intrinsic_arith (se, expr, BIT_AND_EXPR, false);\n+      break;\n+\n     case GFC_ISYM_IAND:\n       gfc_conv_intrinsic_bitop (se, expr, BIT_AND_EXPR);\n       break;\n \n+    case GFC_ISYM_IANY:\n+      gfc_conv_intrinsic_arith (se, expr, BIT_IOR_EXPR, false);\n+      break;\n+\n     case GFC_ISYM_IBCLR:\n       gfc_conv_intrinsic_singlebitop (se, expr, 0);\n       break;\n@@ -5576,6 +5587,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bitop (se, expr, BIT_IOR_EXPR);\n       break;\n \n+    case GFC_ISYM_IPARITY:\n+      gfc_conv_intrinsic_arith (se, expr, BIT_XOR_EXPR, false);\n+      break;\n+\n     case GFC_ISYM_IS_IOSTAT_END:\n       gfc_conv_has_intvalue (se, expr, LIBERROR_END);\n       break;\n@@ -5919,6 +5934,9 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n     case GFC_ISYM_ANY:\n     case GFC_ISYM_COUNT:\n     case GFC_ISYM_JN2:\n+    case GFC_ISYM_IANY:\n+    case GFC_ISYM_IALL:\n+    case GFC_ISYM_IPARITY:\n     case GFC_ISYM_MATMUL:\n     case GFC_ISYM_MAXLOC:\n     case GFC_ISYM_MAXVAL:"}, {"sha": "ac579359d82ebc25e28b34d32cb8bf402d6cb9a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -1,3 +1,9 @@\n+2010-09-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/38282\n+\t* gfortran.dg/iall_iany_iparity_1.f90: New.\n+\t* gfortran.dg/iall_iany_iparity_2.f90: New.\n+\n 2010-09-06  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/initlist42.C: New."}, {"sha": "35b4e168e77f317f69a439507b591f60368d7e13", "filename": "gcc/testsuite/gfortran.dg/iall_iany_iparity_1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_1.f90?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+!\n+! PR fortran/38282\n+!\n+implicit none\n+integer :: a(2,1)\n+\n+a(1,1) = 35\n+a(2,1) = -74\n+\n+if (iand(a(1,1),a(2,1)) /= iall(a)) call abort ()\n+if (iand(a(1,1),a(2,1)) /= iall(array=[35, -74])) call abort ()\n+if (any (iand(a(1,1),a(2,1)) /= iall(a,dim=1))) call abort ()\n+if (iand(a(1,1),a(2,1)) /= iall(dim=1,mask=[.true.,.true.],array=[35, -74])) call abort ()\n+\n+if (ior(a(1,1),a(2,1)) /= iany(a)) call abort ()\n+if (ior(a(1,1),a(2,1)) /= iany(array=[35, -74])) call abort ()\n+if (any (ior(a(1,1),a(2,1)) /= iany(a,dim=1))) call abort ()\n+if (ior(a(1,1),a(2,1)) /= iany(dim=1,mask=[.true.,.true.],array=[35, -74])) call abort ()\n+\n+if (ieor(a(1,1),a(2,1)) /= iparity(a)) call abort ()\n+if (ieor(a(1,1),a(2,1)) /= iparity(array=[35, -74])) call abort ()\n+if (any (ieor(a(1,1),a(2,1)) /= iparity(a,dim=1))) call abort ()\n+if (ieor(a(1,1),a(2,1)) /= iparity(dim=1,mask=[.true.,.true.],array=[35, -74])) call abort ()\n+\n+end"}, {"sha": "4872ddf7f2ab1fe0f0bb3eb8eca0810267a77ab2", "filename": "gcc/testsuite/gfortran.dg/iall_iany_iparity_2.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiall_iany_iparity_2.f90?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR fortran/38282\n+!\n+implicit none\n+integer :: a(2,1)\n+\n+a(1,1) = 35\n+a(2,1) = -74\n+\n+if (iand(a(1,1),a(2,1)) /= iall(a)) stop 1 ! { dg-error \" .iall. at .1. has no IMPLICIT type\" }\n+\n+if (ior(a(1,1),a(2,1)) /= iany(a)) stop 1 ! { dg-error \" .iany. at .1. has no IMPLICIT type\" }\n+\n+if (ieor(a(1,1),a(2,1)) /= iparity(a)) stop 1 ! { dg-error \" .iparity. at .1. has no IMPLICIT type\" }\n+\n+end"}, {"sha": "e21064ecfde2008886d3776f3eeb0b55472abf8e", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -1,3 +1,28 @@\n+2010-09-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/38282\n+\t* gfortran.map: Add new iany, iall and iparity intrinsics.\n+\t* Makefile.am: Ditto.\n+\t* m4/iany.m4: New.\n+\t* m4/iall.m4: New.\n+\t* m4/iparity.m4: New.\n+\t* Makefile.in: Regenerate.\n+\t* generated/iall_i1.c: Generate.\n+\t* generated/iall_i2.c: Generate.\n+\t* generated/iall_i4.c: Generate.\n+\t* generated/iall_i8.c: Generate.\n+\t* generated/iall_i16.c: Generate.\n+\t* generated/iany_i1.c: Generate.\n+\t* generated/iany_i2.c: Generate.\n+\t* generated/iany_i4.c: Generate.\n+\t* generated/iany_i8.c: Generate.\n+\t* generated/iany_i16.c: Generate.\n+\t* generated/iparity_i1.c: Generate.\n+\t* generated/iparity_i2.c: Generate.\n+\t* generated/iparity_i4.c: Generate.\n+\t* generated/iparity_i8.c: Generate.\n+\t* generated/iparity_i16.c: Generate.\n+\n 2010-09-05  Tobias Burnus  <burnus@net-b.de>\n \n \t* m4/bessel.m4: Fix printf warning by casting to (long int)."}, {"sha": "2952f9964c0da2e448232d33de632b9ca28cc6b8", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -189,6 +189,27 @@ $(srcdir)/generated/count_4_l.c \\\n $(srcdir)/generated/count_8_l.c \\\n $(srcdir)/generated/count_16_l.c\n \n+i_iall_c= \\\n+$(srcdir)/generated/iall_i1.c \\\n+$(srcdir)/generated/iall_i2.c \\\n+$(srcdir)/generated/iall_i4.c \\\n+$(srcdir)/generated/iall_i8.c \\\n+$(srcdir)/generated/iall_i16.c\n+\n+i_iany_c= \\\n+$(srcdir)/generated/iany_i1.c \\\n+$(srcdir)/generated/iany_i2.c \\\n+$(srcdir)/generated/iany_i4.c \\\n+$(srcdir)/generated/iany_i8.c \\\n+$(srcdir)/generated/iany_i16.c\n+\n+i_iparity_c= \\\n+$(srcdir)/generated/iparity_i1.c \\\n+$(srcdir)/generated/iparity_i2.c \\\n+$(srcdir)/generated/iparity_i4.c \\\n+$(srcdir)/generated/iparity_i8.c \\\n+$(srcdir)/generated/iparity_i16.c\n+\n i_maxloc0_c= \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n $(srcdir)/generated/maxloc0_8_i1.c \\\n@@ -603,11 +624,13 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4\n+    m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n-    $(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_norm2_c) $(i_parity_c) \\\n+    $(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_iall_c) $(i_iany_c) \\\n+    $(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n@@ -850,6 +873,15 @@ $(i_any_c): m4/any.m4 $(I_M4_DEPS2)\n $(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n+$(i_iall_c): m4/iall.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iall.m4 > $@\n+\n+$(i_iany_c): m4/iany.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iany.m4 > $@\n+\n+$(i_iparity_c): m4/iparity.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iparity.m4 > $@\n+\n $(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0.m4 > $@\n "}, {"sha": "e6be1c1d0cab7f164f5fa6c19f9e1b9a111b49dd", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 196, "deletions": 37, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -144,70 +144,76 @@ am__objects_12 = sum_i1.lo sum_i2.lo sum_i4.lo sum_i8.lo sum_i16.lo \\\n \tsum_r4.lo sum_r8.lo sum_r10.lo sum_r16.lo sum_c4.lo sum_c8.lo \\\n \tsum_c10.lo sum_c16.lo\n am__objects_13 = bessel_r4.lo bessel_r8.lo bessel_r10.lo bessel_r16.lo\n-am__objects_14 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo\n-am__objects_15 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \\\n+am__objects_14 = iall_i1.lo iall_i2.lo iall_i4.lo iall_i8.lo \\\n+\tiall_i16.lo\n+am__objects_15 = iany_i1.lo iany_i2.lo iany_i4.lo iany_i8.lo \\\n+\tiany_i16.lo\n+am__objects_16 = iparity_i1.lo iparity_i2.lo iparity_i4.lo \\\n+\tiparity_i8.lo iparity_i16.lo\n+am__objects_17 = norm2_r4.lo norm2_r8.lo norm2_r10.lo norm2_r16.lo\n+am__objects_18 = parity_l1.lo parity_l2.lo parity_l4.lo parity_l8.lo \\\n \tparity_l16.lo\n-am__objects_16 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \\\n+am__objects_19 = matmul_i1.lo matmul_i2.lo matmul_i4.lo matmul_i8.lo \\\n \tmatmul_i16.lo matmul_r4.lo matmul_r8.lo matmul_r10.lo \\\n \tmatmul_r16.lo matmul_c4.lo matmul_c8.lo matmul_c10.lo \\\n \tmatmul_c16.lo\n-am__objects_17 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n-am__objects_18 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n+am__objects_20 = matmul_l4.lo matmul_l8.lo matmul_l16.lo\n+am__objects_21 = transpose_i4.lo transpose_i8.lo transpose_i16.lo \\\n \ttranspose_r4.lo transpose_r8.lo transpose_r10.lo \\\n \ttranspose_r16.lo transpose_c4.lo transpose_c8.lo \\\n \ttranspose_c10.lo transpose_c16.lo\n-am__objects_19 = shape_i4.lo shape_i8.lo shape_i16.lo\n-am__objects_20 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n-am__objects_21 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n-am__objects_22 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n-am__objects_23 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n+am__objects_22 = shape_i4.lo shape_i8.lo shape_i16.lo\n+am__objects_23 = eoshift1_4.lo eoshift1_8.lo eoshift1_16.lo\n+am__objects_24 = eoshift3_4.lo eoshift3_8.lo eoshift3_16.lo\n+am__objects_25 = cshift1_4.lo cshift1_8.lo cshift1_16.lo\n+am__objects_26 = reshape_i4.lo reshape_i8.lo reshape_i16.lo \\\n \treshape_r4.lo reshape_r8.lo reshape_r10.lo reshape_r16.lo \\\n \treshape_c4.lo reshape_c8.lo reshape_c10.lo reshape_c16.lo\n-am__objects_24 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \\\n+am__objects_27 = in_pack_i1.lo in_pack_i2.lo in_pack_i4.lo \\\n \tin_pack_i8.lo in_pack_i16.lo in_pack_r4.lo in_pack_r8.lo \\\n \tin_pack_r10.lo in_pack_r16.lo in_pack_c4.lo in_pack_c8.lo \\\n \tin_pack_c10.lo in_pack_c16.lo\n-am__objects_25 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \\\n+am__objects_28 = in_unpack_i1.lo in_unpack_i2.lo in_unpack_i4.lo \\\n \tin_unpack_i8.lo in_unpack_i16.lo in_unpack_r4.lo \\\n \tin_unpack_r8.lo in_unpack_r10.lo in_unpack_r16.lo \\\n \tin_unpack_c4.lo in_unpack_c8.lo in_unpack_c10.lo \\\n \tin_unpack_c16.lo\n-am__objects_26 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \\\n+am__objects_29 = exponent_r4.lo exponent_r8.lo exponent_r10.lo \\\n \texponent_r16.lo\n-am__objects_27 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \\\n+am__objects_30 = fraction_r4.lo fraction_r8.lo fraction_r10.lo \\\n \tfraction_r16.lo\n-am__objects_28 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \\\n+am__objects_31 = nearest_r4.lo nearest_r8.lo nearest_r10.lo \\\n \tnearest_r16.lo\n-am__objects_29 = set_exponent_r4.lo set_exponent_r8.lo \\\n+am__objects_32 = set_exponent_r4.lo set_exponent_r8.lo \\\n \tset_exponent_r10.lo set_exponent_r16.lo\n-am__objects_30 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_c4_i4.lo \\\n+am__objects_33 = pow_i4_i4.lo pow_i8_i4.lo pow_i16_i4.lo pow_c4_i4.lo \\\n \tpow_c8_i4.lo pow_c10_i4.lo pow_c16_i4.lo pow_i4_i8.lo \\\n \tpow_i8_i8.lo pow_i16_i8.lo pow_r4_i8.lo pow_r8_i8.lo \\\n \tpow_r10_i8.lo pow_r16_i8.lo pow_c4_i8.lo pow_c8_i8.lo \\\n \tpow_c10_i8.lo pow_c16_i8.lo pow_i4_i16.lo pow_i8_i16.lo \\\n \tpow_i16_i16.lo pow_r4_i16.lo pow_r8_i16.lo pow_r10_i16.lo \\\n \tpow_r16_i16.lo pow_c4_i16.lo pow_c8_i16.lo pow_c10_i16.lo \\\n \tpow_c16_i16.lo\n-am__objects_31 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \\\n+am__objects_34 = rrspacing_r4.lo rrspacing_r8.lo rrspacing_r10.lo \\\n \trrspacing_r16.lo\n-am__objects_32 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n+am__objects_35 = spacing_r4.lo spacing_r8.lo spacing_r10.lo \\\n \tspacing_r16.lo\n-am__objects_33 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n+am__objects_36 = pack_i1.lo pack_i2.lo pack_i4.lo pack_i8.lo \\\n \tpack_i16.lo pack_r4.lo pack_r8.lo pack_r10.lo pack_r16.lo \\\n \tpack_c4.lo pack_c8.lo pack_c10.lo pack_c16.lo\n-am__objects_34 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n+am__objects_37 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n \tunpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \\\n \tunpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \\\n \tunpack_c16.lo\n-am__objects_35 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n+am__objects_38 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n \tspread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \\\n \tspread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \\\n \tspread_c16.lo\n-am__objects_36 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n+am__objects_39 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n \tcshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \\\n \tcshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \\\n \tcshift0_c10.lo cshift0_c16.lo\n-am__objects_37 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_40 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -218,11 +224,12 @@ am__objects_37 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n \t$(am__objects_29) $(am__objects_30) $(am__objects_31) \\\n \t$(am__objects_32) $(am__objects_33) $(am__objects_34) \\\n-\t$(am__objects_35) $(am__objects_36)\n-am__objects_38 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_35) $(am__objects_36) $(am__objects_37) \\\n+\t$(am__objects_38) $(am__objects_39)\n+am__objects_41 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo fbuf.lo\n-am__objects_39 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_42 = associated.lo abort.lo access.lo args.lo \\\n \tbit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \\\n \tcpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \\\n \tenv.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo \\\n@@ -237,8 +244,8 @@ am__objects_39 = associated.lo abort.lo access.lo args.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_40 =\n-am__objects_41 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_43 =\n+am__objects_44 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -262,18 +269,18 @@ am__objects_41 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_42 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_45 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_43 = misc_specifics.lo\n-am__objects_44 = $(am__objects_41) $(am__objects_42) $(am__objects_43) \\\n+am__objects_46 = misc_specifics.lo\n+am__objects_47 = $(am__objects_44) $(am__objects_45) $(am__objects_46) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_45 = $(am__objects_1) $(am__objects_37) $(am__objects_38) \\\n-\t$(am__objects_39) $(am__objects_40) $(am__objects_44)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_45)\n+am__objects_48 = $(am__objects_1) $(am__objects_40) $(am__objects_41) \\\n+\t$(am__objects_42) $(am__objects_43) $(am__objects_47)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_48)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -609,6 +616,27 @@ $(srcdir)/generated/count_4_l.c \\\n $(srcdir)/generated/count_8_l.c \\\n $(srcdir)/generated/count_16_l.c\n \n+i_iall_c = \\\n+$(srcdir)/generated/iall_i1.c \\\n+$(srcdir)/generated/iall_i2.c \\\n+$(srcdir)/generated/iall_i4.c \\\n+$(srcdir)/generated/iall_i8.c \\\n+$(srcdir)/generated/iall_i16.c\n+\n+i_iany_c = \\\n+$(srcdir)/generated/iany_i1.c \\\n+$(srcdir)/generated/iany_i2.c \\\n+$(srcdir)/generated/iany_i4.c \\\n+$(srcdir)/generated/iany_i8.c \\\n+$(srcdir)/generated/iany_i16.c\n+\n+i_iparity_c = \\\n+$(srcdir)/generated/iparity_i1.c \\\n+$(srcdir)/generated/iparity_i2.c \\\n+$(srcdir)/generated/iparity_i4.c \\\n+$(srcdir)/generated/iparity_i8.c \\\n+$(srcdir)/generated/iparity_i16.c\n+\n i_maxloc0_c = \\\n $(srcdir)/generated/maxloc0_4_i1.c \\\n $(srcdir)/generated/maxloc0_8_i1.c \\\n@@ -1022,11 +1050,13 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4\n+    m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n+    m4/iall.m4 m4/iany.m4 m4/iparity.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n-    $(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_norm2_c) $(i_parity_c) \\\n+    $(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_iall_c) $(i_iany_c) \\\n+    $(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n     $(i_matmul_c) $(i_matmull_c) $(i_transpose_c) $(i_shape_c) $(i_eoshift1_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n@@ -1427,6 +1457,16 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getcwd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getlog.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hostnm.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iall_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iall_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iall_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iall_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iall_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iany_i8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ierrno.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_pack_c16.Plo@am__quote@\n@@ -1458,6 +1498,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/in_unpack_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/inquire.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/intrinsics.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iparity_i8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ishftc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso_c_binding.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso_c_generated_procs.Plo@am__quote@\n@@ -3523,6 +3568,111 @@ bessel_r16.lo: $(srcdir)/generated/bessel_r16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel_r16.lo `test -f '$(srcdir)/generated/bessel_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/bessel_r16.c\n \n+iall_i1.lo: $(srcdir)/generated/iall_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iall_i1.lo -MD -MP -MF $(DEPDIR)/iall_i1.Tpo -c -o iall_i1.lo `test -f '$(srcdir)/generated/iall_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iall_i1.Tpo $(DEPDIR)/iall_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iall_i1.c' object='iall_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iall_i1.lo `test -f '$(srcdir)/generated/iall_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i1.c\n+\n+iall_i2.lo: $(srcdir)/generated/iall_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iall_i2.lo -MD -MP -MF $(DEPDIR)/iall_i2.Tpo -c -o iall_i2.lo `test -f '$(srcdir)/generated/iall_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iall_i2.Tpo $(DEPDIR)/iall_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iall_i2.c' object='iall_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iall_i2.lo `test -f '$(srcdir)/generated/iall_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i2.c\n+\n+iall_i4.lo: $(srcdir)/generated/iall_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iall_i4.lo -MD -MP -MF $(DEPDIR)/iall_i4.Tpo -c -o iall_i4.lo `test -f '$(srcdir)/generated/iall_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iall_i4.Tpo $(DEPDIR)/iall_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iall_i4.c' object='iall_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iall_i4.lo `test -f '$(srcdir)/generated/iall_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i4.c\n+\n+iall_i8.lo: $(srcdir)/generated/iall_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iall_i8.lo -MD -MP -MF $(DEPDIR)/iall_i8.Tpo -c -o iall_i8.lo `test -f '$(srcdir)/generated/iall_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iall_i8.Tpo $(DEPDIR)/iall_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iall_i8.c' object='iall_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iall_i8.lo `test -f '$(srcdir)/generated/iall_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i8.c\n+\n+iall_i16.lo: $(srcdir)/generated/iall_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iall_i16.lo -MD -MP -MF $(DEPDIR)/iall_i16.Tpo -c -o iall_i16.lo `test -f '$(srcdir)/generated/iall_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iall_i16.Tpo $(DEPDIR)/iall_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iall_i16.c' object='iall_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iall_i16.lo `test -f '$(srcdir)/generated/iall_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iall_i16.c\n+\n+iany_i1.lo: $(srcdir)/generated/iany_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iany_i1.lo -MD -MP -MF $(DEPDIR)/iany_i1.Tpo -c -o iany_i1.lo `test -f '$(srcdir)/generated/iany_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iany_i1.Tpo $(DEPDIR)/iany_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iany_i1.c' object='iany_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iany_i1.lo `test -f '$(srcdir)/generated/iany_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i1.c\n+\n+iany_i2.lo: $(srcdir)/generated/iany_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iany_i2.lo -MD -MP -MF $(DEPDIR)/iany_i2.Tpo -c -o iany_i2.lo `test -f '$(srcdir)/generated/iany_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iany_i2.Tpo $(DEPDIR)/iany_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iany_i2.c' object='iany_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iany_i2.lo `test -f '$(srcdir)/generated/iany_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i2.c\n+\n+iany_i4.lo: $(srcdir)/generated/iany_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iany_i4.lo -MD -MP -MF $(DEPDIR)/iany_i4.Tpo -c -o iany_i4.lo `test -f '$(srcdir)/generated/iany_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iany_i4.Tpo $(DEPDIR)/iany_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iany_i4.c' object='iany_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iany_i4.lo `test -f '$(srcdir)/generated/iany_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i4.c\n+\n+iany_i8.lo: $(srcdir)/generated/iany_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iany_i8.lo -MD -MP -MF $(DEPDIR)/iany_i8.Tpo -c -o iany_i8.lo `test -f '$(srcdir)/generated/iany_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iany_i8.Tpo $(DEPDIR)/iany_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iany_i8.c' object='iany_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iany_i8.lo `test -f '$(srcdir)/generated/iany_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i8.c\n+\n+iany_i16.lo: $(srcdir)/generated/iany_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iany_i16.lo -MD -MP -MF $(DEPDIR)/iany_i16.Tpo -c -o iany_i16.lo `test -f '$(srcdir)/generated/iany_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iany_i16.Tpo $(DEPDIR)/iany_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iany_i16.c' object='iany_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iany_i16.lo `test -f '$(srcdir)/generated/iany_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iany_i16.c\n+\n+iparity_i1.lo: $(srcdir)/generated/iparity_i1.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iparity_i1.lo -MD -MP -MF $(DEPDIR)/iparity_i1.Tpo -c -o iparity_i1.lo `test -f '$(srcdir)/generated/iparity_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i1.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iparity_i1.Tpo $(DEPDIR)/iparity_i1.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iparity_i1.c' object='iparity_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iparity_i1.lo `test -f '$(srcdir)/generated/iparity_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i1.c\n+\n+iparity_i2.lo: $(srcdir)/generated/iparity_i2.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iparity_i2.lo -MD -MP -MF $(DEPDIR)/iparity_i2.Tpo -c -o iparity_i2.lo `test -f '$(srcdir)/generated/iparity_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i2.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iparity_i2.Tpo $(DEPDIR)/iparity_i2.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iparity_i2.c' object='iparity_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iparity_i2.lo `test -f '$(srcdir)/generated/iparity_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i2.c\n+\n+iparity_i4.lo: $(srcdir)/generated/iparity_i4.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iparity_i4.lo -MD -MP -MF $(DEPDIR)/iparity_i4.Tpo -c -o iparity_i4.lo `test -f '$(srcdir)/generated/iparity_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i4.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iparity_i4.Tpo $(DEPDIR)/iparity_i4.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iparity_i4.c' object='iparity_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iparity_i4.lo `test -f '$(srcdir)/generated/iparity_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i4.c\n+\n+iparity_i8.lo: $(srcdir)/generated/iparity_i8.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iparity_i8.lo -MD -MP -MF $(DEPDIR)/iparity_i8.Tpo -c -o iparity_i8.lo `test -f '$(srcdir)/generated/iparity_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i8.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iparity_i8.Tpo $(DEPDIR)/iparity_i8.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iparity_i8.c' object='iparity_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iparity_i8.lo `test -f '$(srcdir)/generated/iparity_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i8.c\n+\n+iparity_i16.lo: $(srcdir)/generated/iparity_i16.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT iparity_i16.lo -MD -MP -MF $(DEPDIR)/iparity_i16.Tpo -c -o iparity_i16.lo `test -f '$(srcdir)/generated/iparity_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i16.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/iparity_i16.Tpo $(DEPDIR)/iparity_i16.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/iparity_i16.c' object='iparity_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o iparity_i16.lo `test -f '$(srcdir)/generated/iparity_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/iparity_i16.c\n+\n norm2_r4.lo: $(srcdir)/generated/norm2_r4.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT norm2_r4.lo -MD -MP -MF $(DEPDIR)/norm2_r4.Tpo -c -o norm2_r4.lo `test -f '$(srcdir)/generated/norm2_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/norm2_r4.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/norm2_r4.Tpo $(DEPDIR)/norm2_r4.Plo\n@@ -5671,6 +5821,15 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_count_c): m4/count.m4 $(I_M4_DEPS2)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 count.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_iall_c): m4/iall.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iall.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_iany_c): m4/iany.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iany.m4 > $@\n+\n+@MAINTAINER_MODE_TRUE@$(i_iparity_c): m4/iparity.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 iparity.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_maxloc0_c): m4/maxloc0.m4 $(I_M4_DEPS0)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 maxloc0.m4 > $@\n "}, {"sha": "c6bacab6e584afa6cb99f1092656a99f298872c7", "filename": "libgfortran/generated/iall_i1.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i1.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void iall_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(iall_i1);\n+\n+void\n+iall_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IALL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = (GFC_INTEGER_1) -1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result &= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miall_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miall_i1);\n+\n+void\n+miall_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IALL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IALL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IALL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result &= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siall_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siall_i1);\n+\n+void\n+siall_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iall_i1 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IALL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "618f3338803eb9c65256900fee1d39d893a65716", "filename": "libgfortran/generated/iall_i16.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i16.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void iall_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+export_proto(iall_i16);\n+\n+void\n+iall_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_16 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IALL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = (GFC_INTEGER_16) -1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result &= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miall_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miall_i16);\n+\n+void\n+miall_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IALL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IALL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IALL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result &= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siall_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siall_i16);\n+\n+void\n+siall_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iall_i16 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IALL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "c90005947d57629cd3b2ccfa6f80fde4a6ee3ef0", "filename": "libgfortran/generated/iall_i2.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i2.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void iall_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(iall_i2);\n+\n+void\n+iall_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IALL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = (GFC_INTEGER_2) -1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result &= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miall_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miall_i2);\n+\n+void\n+miall_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IALL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IALL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IALL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result &= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siall_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siall_i2);\n+\n+void\n+siall_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iall_i2 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IALL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "d5e7dfe3f84d6d982b501e2da13847ff98490206", "filename": "libgfortran/generated/iall_i4.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i4.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void iall_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+export_proto(iall_i4);\n+\n+void\n+iall_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IALL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  result = (GFC_INTEGER_4) -1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result &= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miall_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miall_i4);\n+\n+void\n+miall_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IALL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IALL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IALL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result &= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siall_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siall_i4);\n+\n+void\n+siall_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iall_i4 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IALL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "74ae1b5ed941aa7925d5ef6c386ae6b8e641d195", "filename": "libgfortran/generated/iall_i8.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiall_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiall_i8.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void iall_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+export_proto(iall_i8);\n+\n+void\n+iall_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_8 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IALL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  result = (GFC_INTEGER_8) -1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result &= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miall_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miall_i8);\n+\n+void\n+miall_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IALL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IALL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IALL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result &= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siall_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siall_i8);\n+\n+void\n+siall_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iall_i8 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IALL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IALL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "e5d7855a7c642fbb853570d9912c1f1893e332ef", "filename": "libgfortran/generated/iany_i1.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i1.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void iany_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(iany_i1);\n+\n+void\n+iany_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IANY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result |= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miany_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miany_i1);\n+\n+void\n+miany_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IANY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IANY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IANY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result |= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siany_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siany_i1);\n+\n+void\n+siany_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iany_i1 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IANY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "20d14d56d99ec7b2dcb486697d7e28f7821e0a31", "filename": "libgfortran/generated/iany_i16.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i16.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void iany_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+export_proto(iany_i16);\n+\n+void\n+iany_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_16 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IANY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result |= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miany_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miany_i16);\n+\n+void\n+miany_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IANY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IANY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IANY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result |= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siany_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siany_i16);\n+\n+void\n+siany_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iany_i16 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IANY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "b464c5d5f9e4a309dd5d08c4eb22c6c2a3a3095a", "filename": "libgfortran/generated/iany_i2.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i2.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void iany_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(iany_i2);\n+\n+void\n+iany_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IANY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result |= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miany_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miany_i2);\n+\n+void\n+miany_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IANY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IANY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IANY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result |= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siany_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siany_i2);\n+\n+void\n+siany_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iany_i2 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IANY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "3e202820df6aac406959252ff90924d150058028", "filename": "libgfortran/generated/iany_i4.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i4.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void iany_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+export_proto(iany_i4);\n+\n+void\n+iany_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IANY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result |= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miany_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miany_i4);\n+\n+void\n+miany_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IANY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IANY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IANY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result |= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siany_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siany_i4);\n+\n+void\n+siany_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iany_i4 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IANY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "8c89e4d28743c162029d9ba8c7b7b0423fef698a", "filename": "libgfortran/generated/iany_i8.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiany_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiany_i8.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void iany_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+export_proto(iany_i8);\n+\n+void\n+iany_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_8 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IANY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result |= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miany_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miany_i8);\n+\n+void\n+miany_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IANY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IANY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IANY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result |= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siany_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siany_i8);\n+\n+void\n+siany_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iany_i8 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IANY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IANY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "35c51c04dbaabdafe6e0f8598c1b832ab5c9f041", "filename": "libgfortran/generated/iparity_i1.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i1.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1) && defined (HAVE_GFC_INTEGER_1)\n+\n+\n+extern void iparity_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict);\n+export_proto(iparity_i1);\n+\n+void\n+iparity_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_1 * restrict base;\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IPARITY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result ^= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miparity_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miparity_i1);\n+\n+void\n+miparity_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  const GFC_INTEGER_1 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IPARITY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IPARITY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IPARITY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_1 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_1 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result ^= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siparity_i1 (gfc_array_i1 * const restrict, \n+\tgfc_array_i1 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siparity_i1);\n+\n+void\n+siparity_i1 (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_1 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iparity_i1 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_1) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IPARITY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "608fe224a37e3342f661e09646ea8f04f9b21f12", "filename": "libgfortran/generated/iparity_i16.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i16.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void iparity_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict);\n+export_proto(iparity_i16);\n+\n+void\n+iparity_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_16 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IPARITY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result ^= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miparity_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miparity_i16);\n+\n+void\n+miparity_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_INTEGER_16 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IPARITY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IPARITY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IPARITY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_16 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result ^= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siparity_i16 (gfc_array_i16 * const restrict, \n+\tgfc_array_i16 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siparity_i16);\n+\n+void\n+siparity_i16 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iparity_i16 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IPARITY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "a1e465c5ce525c73be23676987ad783acf37a253", "filename": "libgfortran/generated/iparity_i2.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i2.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2) && defined (HAVE_GFC_INTEGER_2)\n+\n+\n+extern void iparity_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict);\n+export_proto(iparity_i2);\n+\n+void\n+iparity_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_2 * restrict base;\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IPARITY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result ^= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miparity_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miparity_i2);\n+\n+void\n+miparity_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  const GFC_INTEGER_2 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IPARITY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IPARITY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IPARITY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_2 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_2 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result ^= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siparity_i2 (gfc_array_i2 * const restrict, \n+\tgfc_array_i2 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siparity_i2);\n+\n+void\n+siparity_i2 (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_2 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iparity_i2 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_2) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IPARITY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "e4a492cbf0ea78d46e1be585699a2b81d010d5cd", "filename": "libgfortran/generated/iparity_i4.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i4.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void iparity_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict);\n+export_proto(iparity_i4);\n+\n+void\n+iparity_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_4 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IPARITY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result ^= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miparity_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miparity_i4);\n+\n+void\n+miparity_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_INTEGER_4 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IPARITY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IPARITY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IPARITY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_4 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result ^= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siparity_i4 (gfc_array_i4 * const restrict, \n+\tgfc_array_i4 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siparity_i4);\n+\n+void\n+siparity_i4 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iparity_i4 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IPARITY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "b3997518cdfbe5c404b076b7c33e8db88d75099c", "filename": "libgfortran/generated/iparity_i8.c", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgenerated%2Fiparity_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fiparity_i8.c?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,509 @@\n+/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void iparity_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict);\n+export_proto(iparity_i8);\n+\n+void\n+iparity_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_INTEGER_8 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"IPARITY\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\tlen = 0;\n+    }\n+\n+  base = array->data;\n+  dest = retarray->data;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+\n+  result ^= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void miparity_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(miparity_i8);\n+\n+void\n+miparity_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_INTEGER_8 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  int rank;\n+  int dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in IPARITY intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"IPARITY\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"IPARITY\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->data;\n+  base = array->data;\n+\n+  while (base)\n+    {\n+      const GFC_INTEGER_8 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 0;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+\t    for (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+\n+  if (*msrc)\n+    result ^= *src;\n+\t      }\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      /* Break out of the look.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void siparity_i8 (gfc_array_i8 * const restrict, \n+\tgfc_array_i8 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(siparity_i8);\n+\n+void\n+siparity_i8 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (*mask)\n+    {\n+      iparity_i8 (retarray, array, pdim);\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->data == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * GFC_DESCRIPTOR_STRIDE(retarray,rank-1)\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" IPARITY intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" IPARITY intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->data;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "ea6ebfa12eb7ea95fc34715c0788455b4f6d3681", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -1107,8 +1107,6 @@ GFORTRAN_1.3 {\n \n GFORTRAN_1.4 {\n   global:\n-    _gfortran_error_stop_numeric;\n-    _gfortran_selected_real_kind2008;\n     _gfortran_bessel_jn_r4;\n     _gfortran_bessel_jn_r8;\n     _gfortran_bessel_jn_r10;\n@@ -1117,6 +1115,22 @@ GFORTRAN_1.4 {\n     _gfortran_bessel_yn_r8;\n     _gfortran_bessel_yn_r10;\n     _gfortran_bessel_yn_r16;\n+    _gfortran_error_stop_numeric;\n+    _gfortran_iall_i1;\n+    _gfortran_iall_i2;\n+    _gfortran_iall_i4;\n+    _gfortran_iall_i8;\n+    _gfortran_iall_i16;\n+    _gfortran_iany_i1;\n+    _gfortran_iany_i2;\n+    _gfortran_iany_i4;\n+    _gfortran_iany_i8;\n+    _gfortran_iany_i16;\n+    _gfortran_iparity_i1;\n+    _gfortran_iparity_i2;\n+    _gfortran_iparity_i4;\n+    _gfortran_iparity_i8;\n+    _gfortran_iparity_i16;\n     _gfortran_norm2_r4;\n     _gfortran_norm2_r8;\n     _gfortran_norm2_r10;\n@@ -1126,6 +1140,7 @@ GFORTRAN_1.4 {\n     _gfortran_parity_l4;\n     _gfortran_parity_l8;\n     _gfortran_parity_l16;\n+    _gfortran_selected_real_kind2008;\n } GFORTRAN_1.3; \n \n F2C_1.0 {"}, {"sha": "2e6667e2664e2de08d07d1d5ce5c51812ffbfc5f", "filename": "libgfortran/m4/iall.m4", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiall.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiall.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiall.m4?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,46 @@\n+`/* Implementation of the IALL intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>'\n+\n+include(iparm.m4)dnl\n+include(ifunction.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`  result = ('rtype_name`) -1;',\n+`  result &= *src;')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`  result = 0;',\n+`  if (*msrc)\n+    result &= *src;')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}, {"sha": "a17d951e5cc2fc07233fc94cf673edb1157fedfd", "filename": "libgfortran/m4/iany.m4", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiany.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiany.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiany.m4?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,46 @@\n+`/* Implementation of the IANY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>'\n+\n+include(iparm.m4)dnl\n+include(ifunction.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`  result = 0;',\n+`  result |= *src;')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`  result = 0;',\n+`  if (*msrc)\n+    result |= *src;')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}, {"sha": "78dbc3dd43433db2918ce4623ef9801b097eca1c", "filename": "libgfortran/m4/iparity.m4", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiparity.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195a95c4300bd699e86aae541119b3b41b407e38/libgfortran%2Fm4%2Fiparity.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiparity.m4?ref=195a95c4300bd699e86aae541119b3b41b407e38", "patch": "@@ -0,0 +1,46 @@\n+`/* Implementation of the IPARITY intrinsic\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>'\n+\n+include(iparm.m4)dnl\n+include(ifunction.m4)dnl\n+\n+`#if defined (HAVE_'atype_name`) && defined (HAVE_'rtype_name`)'\n+\n+ARRAY_FUNCTION(0,\n+`  result = 0;',\n+`  result ^= *src;')\n+\n+MASKED_ARRAY_FUNCTION(0,\n+`  result = 0;',\n+`  if (*msrc)\n+    result ^= *src;')\n+\n+SCALAR_ARRAY_FUNCTION(0)\n+\n+#endif"}]}