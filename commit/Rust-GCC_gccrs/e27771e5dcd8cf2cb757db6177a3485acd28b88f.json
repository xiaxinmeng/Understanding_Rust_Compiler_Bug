{"sha": "e27771e5dcd8cf2cb757db6177a3485acd28b88f", "node_id": "C_kwDOANBUbNoAKGUyNzc3MWU1ZGNkOGNmMmNiNzU3ZGI2MTc3YTM0ODVhY2QyOGI4OGY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-15T09:58:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-15T17:26:53Z"}, "message": "libstdc++: Remove try/catch overhead in std::variant::emplace\n\nThe __variant_construct_by_index helper function sets the new index\nbefore constructing the new object. This means that if the construction\nthrows then the exception needs to be caught, so the index can be reset\nto variant_npos, and then the exception rethrown. This means callers are\nresponsible for restoring the variant's invariants and they need the\noverhead of a catch handler and a rethrow.\n\nIf we don't set the index until after construction completes then the\ninvariant is never broken, and callers can ignore the exception and let\nit propagate. The callers all call _M_reset() first, which sets index to\nvariant_npos as required while the variant is valueless.\n\nWe need to be slightly careful here, because changing the order of\noperations in __variant_construct_by_index and removing the try-block\nfrom variant::emplace<I> changes an implicit ABI contract between those\ntwo functions. If the linker were to create an executable containing an\ninstantiation of the old __variant_construct_by_index and an\ninstantiation of the new variant::emplace<I> code then we would have a\ncombination that breaks the invariant and doesn't have the exception\nhandling to restore it. To avoid this problem, we can rename the\n__variant_construct_by_index function so that the new emplace<I> code\ncalls a new symbol, and is unaffected by the behaviour of the old\nsymbol.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/variant (__detail::__variant::__get_storage):\n\tRemove unused function.\n\t(__variant_construct_by_index): Set index after construction is\n\tcomplete. Rename to ...\n\t(__detail::__variant::__construct_by_index): ... this.\n\t(variant): Use new name for __variant_construct_by_index friend\n\tdeclaration. Remove __get_storage friend declaration.\n\t(variant::emplace): Use new name and remove try-blocks.", "tree": {"sha": "3e20a8f7438b874abb66dd4d0c83d8c68a77300b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e20a8f7438b874abb66dd4d0c83d8c68a77300b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e27771e5dcd8cf2cb757db6177a3485acd28b88f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27771e5dcd8cf2cb757db6177a3485acd28b88f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27771e5dcd8cf2cb757db6177a3485acd28b88f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27771e5dcd8cf2cb757db6177a3485acd28b88f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba7adabf29eb671e418692fad076ea6edd08e3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba7adabf29eb671e418692fad076ea6edd08e3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba7adabf29eb671e418692fad076ea6edd08e3d"}], "stats": {"total": 55, "additions": 21, "deletions": 34}, "files": [{"sha": "f49094130ee0c31ca3773d1b0e76cc389893d993", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e27771e5dcd8cf2cb757db6177a3485acd28b88f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e27771e5dcd8cf2cb757db6177a3485acd28b88f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=e27771e5dcd8cf2cb757db6177a3485acd28b88f", "patch": "@@ -1094,19 +1094,21 @@ namespace __variant\n \t>;\n     }\n \n-} // namespace __variant\n-} // namespace __detail\n-\n   template<size_t _Np, typename _Variant, typename... _Args>\n-    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)\n+    inline void\n+    __construct_by_index(_Variant& __v, _Args&&... __args)\n     {\n-      __v._M_index = _Np;\n       auto&& __storage = __detail::__variant::__get<_Np>(__v);\n       ::new ((void*)std::addressof(__storage))\n         remove_reference_t<decltype(__storage)>\n \t  (std::forward<_Args>(__args)...);\n+      // Construction didn't throw, so can set the new index now:\n+      __v._M_index = _Np;\n     }\n \n+} // namespace __variant\n+} // namespace __detail\n+\n   template<typename _Tp, typename... _Types>\n     constexpr bool\n     holds_alternative(const variant<_Types...>& __v) noexcept\n@@ -1342,8 +1344,9 @@ namespace __variant\n       template <typename... _UTypes, typename _Tp>\n \tfriend decltype(auto) __variant_cast(_Tp&&);\n       template<size_t _Np, typename _Variant, typename... _Args>\n-\tfriend void __variant_construct_by_index(_Variant& __v,\n-\t\t\t\t\t\t _Args&&... __args);\n+\tfriend void\n+\t__detail::__variant::__construct_by_index(_Variant& __v,\n+\t\t\t\t\t\t  _Args&&... __args);\n \n       static_assert(sizeof...(_Types) > 0,\n \t\t    \"variant must have at least one alternative\");\n@@ -1507,12 +1510,13 @@ namespace __variant\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index must be in [0, number of alternatives)\");\n \t  using type = variant_alternative_t<_Np, variant>;\n+\t  namespace __variant = std::__detail::__variant;\n \t  // Provide the strong exception-safety guarantee when possible,\n \t  // to avoid becoming valueless.\n \t  if constexpr (is_nothrow_constructible_v<type, _Args...>)\n \t    {\n \t      this->_M_reset();\n-\t      __variant_construct_by_index<_Np>(*this,\n+\t      __variant::__construct_by_index<_Np>(*this,\n \t\t  std::forward<_Args>(__args)...);\n \t    }\n \t  else if constexpr (is_scalar_v<type>)\n@@ -1521,9 +1525,9 @@ namespace __variant\n \t      const type __tmp(std::forward<_Args>(__args)...);\n \t      // But these steps won't throw:\n \t      this->_M_reset();\n-\t      __variant_construct_by_index<_Np>(*this, __tmp);\n+\t      __variant::__construct_by_index<_Np>(*this, __tmp);\n \t    }\n-\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()\n+\t  else if constexpr (__variant::_Never_valueless_alt<type>()\n \t      && _Traits::_S_move_assign)\n \t    {\n \t      // This construction might throw:\n@@ -1537,17 +1541,8 @@ namespace __variant\n \t      // This case only provides the basic exception-safety guarantee,\n \t      // i.e. the variant can become valueless.\n \t      this->_M_reset();\n-\t      __try\n-\t\t{\n-\t\t  __variant_construct_by_index<_Np>(*this,\n-\t\t    std::forward<_Args>(__args)...);\n-\t\t}\n-\t      __catch (...)\n-\t\t{\n-\t\t  using __index_type = decltype(this->_M_index);\n-\t\t  this->_M_index = static_cast<__index_type>(variant_npos);\n-\t\t  __throw_exception_again;\n-\t\t}\n+\t      __variant::__construct_by_index<_Np>(*this,\n+\t\tstd::forward<_Args>(__args)...);\n \t    }\n \t  return std::get<_Np>(*this);\n \t}\n@@ -1561,17 +1556,18 @@ namespace __variant\n \t  static_assert(_Np < sizeof...(_Types),\n \t\t\t\"The index must be in [0, number of alternatives)\");\n \t  using type = variant_alternative_t<_Np, variant>;\n+\t  namespace __variant = std::__detail::__variant;\n \t  // Provide the strong exception-safety guarantee when possible,\n \t  // to avoid becoming valueless.\n \t  if constexpr (is_nothrow_constructible_v<type,\n \t\t\t\t\t\t   initializer_list<_Up>&,\n \t\t\t\t\t\t   _Args...>)\n \t    {\n \t      this->_M_reset();\n-\t      __variant_construct_by_index<_Np>(*this, __il,\n+\t      __variant::__construct_by_index<_Np>(*this, __il,\n \t\t  std::forward<_Args>(__args)...);\n \t    }\n-\t  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()\n+\t  else if constexpr (__variant::_Never_valueless_alt<type>()\n \t      && _Traits::_S_move_assign)\n \t    {\n \t      // This construction might throw:\n@@ -1585,17 +1581,8 @@ namespace __variant\n \t      // This case only provides the basic exception-safety guarantee,\n \t      // i.e. the variant can become valueless.\n \t      this->_M_reset();\n-\t      __try\n-\t\t{\n-\t\t  __variant_construct_by_index<_Np>(*this, __il,\n-\t\t    std::forward<_Args>(__args)...);\n-\t\t}\n-\t      __catch (...)\n-\t\t{\n-\t\t  using __index_type = decltype(this->_M_index);\n-\t\t  this->_M_index = static_cast<__index_type>(variant_npos);\n-\t\t  __throw_exception_again;\n-\t\t}\n+\t      __variant::__construct_by_index<_Np>(*this, __il,\n+\t\tstd::forward<_Args>(__args)...);\n \t    }\n \t  return std::get<_Np>(*this);\n \t}"}]}