{"sha": "67a44b16b1678e2f3bda0db7127e99dace8399fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdhNDRiMTZiMTY3OGUyZjNiZGEwZGI3MTI3ZTk5ZGFjZTgzOTlmYg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-08-27T18:25:23Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-08-27T18:25:23Z"}, "message": "reload.c (find_reloads_toplev): Back out this change:\n\n\t* reload.c (find_reloads_toplev): Back out this change:\n\n\tWed Jul 26 19:44:05 2000   Hans-Peter Nilsson  <hp@axis.com>\n\n\t* reload.c (find_reloads_toplev): Reload a paradoxical subreg of a\n\tmem if the address is a mode_dependent_address_p.\n\nFrom-SVN: r45203", "tree": {"sha": "179bfccd4b01f619ca65418a42ccba423d58a92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/179bfccd4b01f619ca65418a42ccba423d58a92f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67a44b16b1678e2f3bda0db7127e99dace8399fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a44b16b1678e2f3bda0db7127e99dace8399fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a44b16b1678e2f3bda0db7127e99dace8399fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a44b16b1678e2f3bda0db7127e99dace8399fb/comments", "author": null, "committer": null, "parents": [{"sha": "acd7baf7297545ff01b3a0a24d9025de8cd479fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd7baf7297545ff01b3a0a24d9025de8cd479fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd7baf7297545ff01b3a0a24d9025de8cd479fc"}], "stats": {"total": 33, "additions": 9, "deletions": 24}, "files": [{"sha": "01cba25433d8155e651fba82ccd0a11b2498227c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a44b16b1678e2f3bda0db7127e99dace8399fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a44b16b1678e2f3bda0db7127e99dace8399fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67a44b16b1678e2f3bda0db7127e99dace8399fb", "patch": "@@ -1,3 +1,12 @@\n+2001-08-27  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* reload.c (find_reloads_toplev): Back out this change:\n+\n+\tWed Jul 26 19:44:05 2000   Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* reload.c (find_reloads_toplev): Reload a paradoxical subreg of a\n+\tmem if the address is a mode_dependent_address_p.\n+\n 2001-08-27  Vladimir Makarov  <vmakarov@touchme.toronto.redhat.com>\n \n         * rtl.def (DEFINE_CPU_UNIT, DEFINE_QUERY_CPU_UNIT, EXCLUSION_SET,"}, {"sha": "4eaed380c24470017aaa1b49d77031de62965997", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a44b16b1678e2f3bda0db7127e99dace8399fb/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a44b16b1678e2f3bda0db7127e99dace8399fb/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=67a44b16b1678e2f3bda0db7127e99dace8399fb", "patch": "@@ -4419,30 +4419,6 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n \t\t\t\t\t insn);\n     }\n-  else if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == MEM\n-\t   && (GET_MODE_SIZE (GET_MODE (x))\n-\t       > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-\t   && mode_dependent_address_p (XEXP (SUBREG_REG (x), 0)))\n-    {\n-      /* A paradoxical subreg will simply have the mode of the access\n-\t changed, so we need to reload such a memory operand to stabilize\n-\t the meaning of the memory access.  */\n-      enum machine_mode subreg_mode = GET_MODE (SUBREG_REG (x));\n-\n-      /* SUBREG_REG (x) is a MEM, so we cant take the offset, instead we \n-         calculate the register number as : \n-\t SUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode) */\n-      if (is_set_dest)\n-\tpush_reload (NULL_RTX, SUBREG_REG (x), (rtx*)0, &SUBREG_REG (x),\n-\t\t     find_valid_class (subreg_mode, \n-\t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n-\t\t     VOIDmode, subreg_mode, 0, 0, opnum, type);\n-      else\n-\tpush_reload (SUBREG_REG (x), NULL_RTX, &SUBREG_REG (x), (rtx*)0,\n-\t\t     find_valid_class (subreg_mode,\n-\t\t     \t\tSUBREG_BYTE (x) / GET_MODE_SIZE (subreg_mode)),\n-\t\t     subreg_mode, VOIDmode, 0, 0, opnum, type);\n-    }\n \n   for (copied = 0, i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {"}]}