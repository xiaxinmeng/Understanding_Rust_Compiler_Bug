{"sha": "6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE0Y2Y0MTg4YjI5Njk2ODBmZThlMDQ4ZGEyZDRhNjE0Y2ZlYmNjNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-11-04T17:42:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-11-04T17:42:32Z"}, "message": "defaults.h (LOAD_EXTEND_OP): Define if not already defined.\n\n\t* defaults.h (LOAD_EXTEND_OP): Define if not already defined.\n\t* combine.c (LOAD_EXTEND_OP): Delete.\n\t(simplify_comparison): Fix comment about LOAD_EXTEND_OP.\n\t* cse.c (LOAD_EXTEND_OP): Delete.\n\t* fold-const.c (LOAD_EXTEND_OP): Likewise.\n\t* fwprop.c (free_load_extend): Remove #ifdef LOAD_EXTEND_OP/#endif.\n\t* postreload.c (LOAD_EXTEND_OP): Delete.\n\t* reload.c (push_reload): Remove #ifdef LOAD_EXTEND_OP/#endif.\n\tConvert conditional compilation based on WORD_REGISTER_OPERATIONS.\n\t(find_reloads): Likewise.\n\t* reload1.c (eliminate_regs_1): Likewise.\n\t* rtlanal.c (nonzero_bits1): Remove #ifdef LOAD_EXTEND_OP/#endif.\n\t(num_sign_bit_copies1): Likewise.\n\nFrom-SVN: r241855", "tree": {"sha": "19304350ea337fd0ad982ff31dfc86f212bb2f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19304350ea337fd0ad982ff31dfc86f212bb2f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/comments", "author": null, "committer": null, "parents": [{"sha": "bef3a8d7a6d2697a8ed7bcb1a26ce08ce0ae42af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bef3a8d7a6d2697a8ed7bcb1a26ce08ce0ae42af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bef3a8d7a6d2697a8ed7bcb1a26ce08ce0ae42af"}], "stats": {"total": 117, "additions": 49, "deletions": 68}, "files": [{"sha": "c8cfc058449fa0939ee224405801594a6bfe8eed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -1,3 +1,19 @@\n+2016-11-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* defaults.h (LOAD_EXTEND_OP): Define if not already defined.\n+\t* combine.c (LOAD_EXTEND_OP): Delete.\n+\t(simplify_comparison): Fix comment about LOAD_EXTEND_OP.\n+\t* cse.c (LOAD_EXTEND_OP): Delete.\n+\t* fold-const.c (LOAD_EXTEND_OP): Likewise.\n+\t* fwprop.c (free_load_extend): Remove #ifdef LOAD_EXTEND_OP/#endif.\n+\t* postreload.c (LOAD_EXTEND_OP): Delete.\n+\t* reload.c (push_reload): Remove #ifdef LOAD_EXTEND_OP/#endif.\n+\tConvert conditional compilation based on WORD_REGISTER_OPERATIONS.\n+\t(find_reloads): Likewise.\n+\t* reload1.c (eliminate_regs_1): Likewise.\n+\t* rtlanal.c (nonzero_bits1): Remove #ifdef LOAD_EXTEND_OP/#endif.\n+\t(num_sign_bit_copies1): Likewise.\n+\n 2016-11-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/i386/i386.c: Include \"selftest.h\" and \"selftest-rtl.h\"."}, {"sha": "f7728783c51ed6fec3018dabfae4f08562c28abb", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -104,10 +104,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"print-rtl.h\"\n \n-#ifndef LOAD_EXTEND_OP\n-#define LOAD_EXTEND_OP(M) UNKNOWN\n-#endif\n-\n /* Number of attempts to combine instructions in this function.  */\n \n static int combine_attempts;\n@@ -12465,14 +12461,14 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n      care bits and we can assume they have any convenient value.  So\n      making the transformation is safe.\n \n-     2. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is not defined.\n+     2. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is UNKNOWN.\n      In this case the upper bits of op0 are undefined.  We should not make\n      the simplification in that case as we do not know the contents of\n      those bits.\n \n-     3. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is defined and not\n-     UNKNOWN.  In that case we know those bits are zeros or ones.  We must\n-     also be sure that they are the same as the upper bits of op1.\n+     3. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is not UNKNOWN.\n+     In that case we know those bits are zeros or ones.  We must also be\n+     sure that they are the same as the upper bits of op1.\n \n      We can never remove a SUBREG for a non-equality comparison because\n      the sign bit is in a different place in the underlying object.  */"}, {"sha": "11b8fbed06eea54d65735b9958e2d897753612d5", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -43,10 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n \n-#ifndef LOAD_EXTEND_OP\n-#define LOAD_EXTEND_OP(M) UNKNOWN\n-#endif\n-\n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n    have the same value at the current scan point, and replacing"}, {"sha": "9c4000252a207f88f8e81991899104cfc7873db7", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -1259,6 +1259,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define WORD_REGISTER_OPERATIONS 0\n #endif\n \n+#ifndef LOAD_EXTEND_OP\n+#define LOAD_EXTEND_OP(M) UNKNOWN\n+#endif\n+\n #ifndef CONSTANT_ALIGNMENT\n #define CONSTANT_ALIGNMENT(EXP, ALIGN) ALIGN\n #endif"}, {"sha": "603aff096590ac2cd65e2c23a08972675e59039d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -80,10 +80,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"selftest.h\"\n \n-#ifndef LOAD_EXTEND_OP\n-#define LOAD_EXTEND_OP(M) UNKNOWN\n-#endif\n-\n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n int folding_initializer = 0;"}, {"sha": "b2d670061befe09b6250c371159fbd39f11f3438", "filename": "gcc/fwprop.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -1051,9 +1051,7 @@ free_load_extend (rtx src, rtx_insn *insn)\n   df_ref def, use;\n \n   reg = XEXP (src, 0);\n-#ifdef LOAD_EXTEND_OP\n   if (LOAD_EXTEND_OP (GET_MODE (reg)) != GET_CODE (src))\n-#endif\n     return false;\n \n   FOR_EACH_INSN_USE (use, insn)"}, {"sha": "8a4456238c438eadc9c2c0bb98aca0ae3bb0c576", "filename": "gcc/postreload.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -41,10 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n \n-#ifndef LOAD_EXTEND_OP\n-#define LOAD_EXTEND_OP(M) UNKNOWN\n-#endif\n-\n static int reload_cse_noop_set_p (rtx);\n static bool reload_cse_simplify (rtx_insn *, rtx);\n static void reload_cse_regs_1 (void);"}, {"sha": "7d1681772b480c9d8bb1385034583eb993c511d9", "filename": "gcc/reload.c", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -1064,23 +1064,19 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       || MEM_P (SUBREG_REG (in)))\n \t      && ((GET_MODE_PRECISION (inmode)\n \t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n-#ifdef LOAD_EXTEND_OP\n \t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t  <= UNITS_PER_WORD)\n \t\t      && (GET_MODE_PRECISION (inmode)\n \t\t\t  > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n \t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n \t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n-#endif\n-#if WORD_REGISTER_OPERATIONS\n-\t\t  || ((GET_MODE_PRECISION (inmode)\n-\t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n+\t\t  || (WORD_REGISTER_OPERATIONS\n+\t\t      && (GET_MODE_PRECISION (inmode)\n+\t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n \t\t      && ((GET_MODE_SIZE (inmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1)\n-\t\t\t   / UNITS_PER_WORD)))\n-#endif\n-\t\t  ))\n+\t\t\t   / UNITS_PER_WORD)))))\n \t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n@@ -1111,13 +1107,14 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n #endif\n       inloc = &SUBREG_REG (in);\n       in = *inloc;\n-#if ! defined (LOAD_EXTEND_OP)\n+\n       if (!WORD_REGISTER_OPERATIONS\n+\t  && LOAD_EXTEND_OP (GET_MODE (in)) == UNKNOWN\n \t  && MEM_P (in))\n \t/* This is supposed to happen only for paradoxical subregs made by\n \t   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */\n \tgcc_assert (GET_MODE_SIZE (GET_MODE (in)) <= GET_MODE_SIZE (inmode));\n-#endif\n+\n       inmode = GET_MODE (in);\n     }\n \n@@ -1175,14 +1172,12 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       || MEM_P (SUBREG_REG (out)))\n \t      && ((GET_MODE_PRECISION (outmode)\n \t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n-#if WORD_REGISTER_OPERATIONS\n-\t\t  || ((GET_MODE_PRECISION (outmode)\n-\t\t       < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n+\t\t  || (WORD_REGISTER_OPERATIONS\n+\t\t      && (GET_MODE_PRECISION (outmode)\n+\t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n \t\t      && ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n-\t\t\t   / UNITS_PER_WORD)))\n-#endif\n-\t\t  ))\n+\t\t\t   / UNITS_PER_WORD)))))\n \t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      /* The case of a word mode subreg\n@@ -3139,24 +3134,21 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t      || ((MEM_P (operand)\n \t\t\t   || (REG_P (operand)\n \t\t\t       && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n-#if !WORD_REGISTER_OPERATIONS\n-\t\t\t  && (((GET_MODE_BITSIZE (GET_MODE (operand))\n-\t\t\t\t< BIGGEST_ALIGNMENT)\n-\t\t\t       && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t   > GET_MODE_SIZE (GET_MODE (operand))))\n+\t\t\t  && (WORD_REGISTER_OPERATIONS\n+\t\t\t      || ((GET_MODE_BITSIZE (GET_MODE (operand))\n+\t\t\t\t   < BIGGEST_ALIGNMENT)\n+\t\t\t\t && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t\t     > GET_MODE_SIZE (GET_MODE (operand))))\n \t\t\t      || BYTES_BIG_ENDIAN\n-#ifdef LOAD_EXTEND_OP\n-\t\t\t      || (GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t\t      || ((GET_MODE_SIZE (operand_mode[i])\n+\t\t\t\t   <= UNITS_PER_WORD)\n \t\t\t\t  && (GET_MODE_SIZE (GET_MODE (operand))\n \t\t\t\t      <= UNITS_PER_WORD)\n \t\t\t\t  && (GET_MODE_SIZE (operand_mode[i])\n \t\t\t\t      > GET_MODE_SIZE (GET_MODE (operand)))\n \t\t\t\t  && INTEGRAL_MODE_P (GET_MODE (operand))\n-\t\t\t\t  && LOAD_EXTEND_OP (GET_MODE (operand)) != UNKNOWN)\n-#endif\n-\t\t\t      )\n-#endif\n-\t\t\t  )\n+\t\t\t\t  && LOAD_EXTEND_OP (GET_MODE (operand))\n+\t\t\t\t     != UNKNOWN)))\n \t\t      )\n \t\t    force_reload = 1;\n \t\t}"}, {"sha": "4ee3840850eac5e70b1a4036977bb0f08b058a07", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -2819,18 +2819,16 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \n \t  if (MEM_P (new_rtx)\n \t      && ((x_size < new_size\n-#if WORD_REGISTER_OPERATIONS\n-\t\t   /* On these machines, combine can create rtl of the form\n+\t\t   /* On RISC machines, combine can create rtl of the form\n \t\t      (set (subreg:m1 (reg:m2 R) 0) ...)\n \t\t      where m1 < m2, and expects something interesting to\n \t\t      happen to the entire word.  Moreover, it will use the\n \t\t      (reg:m2 R) later, expecting all bits to be preserved.\n \t\t      So if the number of words is the same, preserve the\n \t\t      subreg so that push_reload can see it.  */\n-\t\t   && ! ((x_size - 1) / UNITS_PER_WORD\n-\t\t\t == (new_size -1 ) / UNITS_PER_WORD)\n-#endif\n-\t\t   )\n+\t\t   && !(WORD_REGISTER_OPERATIONS\n+\t\t\t&& (x_size - 1) / UNITS_PER_WORD\n+\t\t\t   == (new_size -1 ) / UNITS_PER_WORD))\n \t\t  || x_size == new_size)\n \t      )\n \t    return adjust_address_nv (new_rtx, GET_MODE (x), SUBREG_BYTE (x));"}, {"sha": "c98a7086981603abf5a885f54f5cfb845661940f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a4cf4188b2969680fe8e048da2d4a614cfebcc5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6a4cf4188b2969680fe8e048da2d4a614cfebcc5", "patch": "@@ -4361,13 +4361,11 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       return UINTVAL (x);\n \n     case MEM:\n-#ifdef LOAD_EXTEND_OP\n       /* In many, if not most, RISC machines, reading a byte from memory\n \t zeros the rest of the register.  Noticing that fact saves a lot\n \t of extra zero-extends.  */\n       if (LOAD_EXTEND_OP (GET_MODE (x)) == ZERO_EXTEND)\n \tnonzero &= GET_MODE_MASK (GET_MODE (x));\n-#endif\n       break;\n \n     case EQ:  case NE:\n@@ -4567,7 +4565,6 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n \n-#ifdef LOAD_EXTEND_OP\n           /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n@@ -4578,7 +4575,6 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t     ? val_signbit_known_set_p (inner_mode, nonzero)\n \t\t     : LOAD_EXTEND_OP (inner_mode) != ZERO_EXTEND)\n \t\t   || !MEM_P (SUBREG_REG (x))))\n-#endif\n \t    {\n \t      if (GET_MODE_PRECISION (GET_MODE (x))\n \t\t  > GET_MODE_PRECISION (inner_mode))\n@@ -4824,10 +4820,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t than a word and loads of that size don't sign extend, we can say\n \t nothing about the high order bits.  */\n       if (GET_MODE_PRECISION (GET_MODE (x)) < BITS_PER_WORD\n-#ifdef LOAD_EXTEND_OP\n-\t  && LOAD_EXTEND_OP (GET_MODE (x)) != SIGN_EXTEND\n-#endif\n-\t  )\n+\t  && LOAD_EXTEND_OP (GET_MODE (x)) != SIGN_EXTEND)\n \treturn 1;\n     }\n \n@@ -4868,12 +4861,10 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       break;\n \n     case MEM:\n-#ifdef LOAD_EXTEND_OP\n       /* Some RISC machines sign-extend all loads of smaller than a word.  */\n       if (LOAD_EXTEND_OP (GET_MODE (x)) == SIGN_EXTEND)\n \treturn MAX (1, ((int) bitwidth\n \t\t\t- (int) GET_MODE_PRECISION (GET_MODE (x)) + 1));\n-#endif\n       break;\n \n     case CONST_INT:\n@@ -4910,7 +4901,6 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t\t\t\t   - bitwidth)));\n \t}\n \n-#ifdef LOAD_EXTEND_OP\n       /* For paradoxical SUBREGs on machines where all register operations\n \t affect the entire register, just look inside.  Note that we are\n \t passing MODE to the recursive call, so the number of sign bit copies\n@@ -4927,7 +4917,6 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t  && MEM_P (SUBREG_REG (x)))\n \treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n \t\t\t\t\t   known_x, known_mode, known_ret);\n-#endif\n       break;\n \n     case SIGN_EXTRACT:"}]}