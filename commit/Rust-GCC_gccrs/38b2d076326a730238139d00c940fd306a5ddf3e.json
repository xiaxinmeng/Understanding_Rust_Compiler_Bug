{"sha": "38b2d076326a730238139d00c940fd306a5ddf3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMmQwNzYzMjZhNzMwMjM4MTM5ZDAwYzk0MGZkMzA2YTVkZGYzZQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2005-07-20T23:27:02Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2005-07-20T23:27:02Z"}, "message": "config.gcc: Add m32c-elf support.\n\n* config.gcc: Add m32c-elf support.\n\n* doc/contrib.texi: Mention m32c.\n* doc/extend.texi: Document m32c extensions.\n* doc/install.texi: Mention m32c.\n* doc/invoke.texi: Document m32c options.\n* doc/md.texi: Document m32c constraints.\n\n* config/m32c/addsub.md: New file.\n* config/m32c/bitops.md: New file.\n* config/m32c/cond.md: New file.\n* config/m32c/jump.md: New file.\n* config/m32c/m32c-lib1.S: New file.\n* config/m32c/m32c-lib2.c: New file.\n* config/m32c/m32c-modes.def: New file.\n* config/m32c/m32c-pragma.c: New file.\n* config/m32c/m32c-protos.h: New file.\n* config/m32c/m32c.abi: New file.\n* config/m32c/m32c.c: New file.\n* config/m32c/m32c.h: New file.\n* config/m32c/m32c.md: New file.\n* config/m32c/m32c.opt: New file.\n* config/m32c/minmax.md: New file.\n* config/m32c/mov.md: New file.\n* config/m32c/muldiv.md: New file.\n* config/m32c/predicates.md: New file.\n* config/m32c/prologue.md: New file.\n* config/m32c/shift.md: New file.\n* config/m32c/t-m32c: New file.\n\nFrom-SVN: r102207", "tree": {"sha": "49956253fc931fdfea43fb640512022daf032ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49956253fc931fdfea43fb640512022daf032ae2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b2d076326a730238139d00c940fd306a5ddf3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2d076326a730238139d00c940fd306a5ddf3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b2d076326a730238139d00c940fd306a5ddf3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2d076326a730238139d00c940fd306a5ddf3e/comments", "author": null, "committer": null, "parents": [{"sha": "50b69666aa028b3f643d69eda72bd3729428f8ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50b69666aa028b3f643d69eda72bd3729428f8ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50b69666aa028b3f643d69eda72bd3729428f8ed"}], "stats": {"total": 6540, "additions": 6534, "deletions": 6}, "files": [{"sha": "ddf350111040c79585bafec7fce2ecc6be85b9c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -1,3 +1,35 @@\n+2005-07-20  DJ Delorie  <dj@redhat.com>\n+\n+\t* config.gcc: Add m32c-elf support.\n+\n+\t* doc/contrib.texi: Mention m32c.\n+\t* doc/extend.texi: Document m32c extensions.\n+\t* doc/install.texi: Mention m32c.\n+\t* doc/invoke.texi: Document m32c options.\n+\t* doc/md.texi: Document m32c constraints.\n+\n+\t* config/m32c/addsub.md: New file.\n+\t* config/m32c/bitops.md: New file.\n+\t* config/m32c/cond.md: New file.\n+\t* config/m32c/jump.md: New file.\n+\t* config/m32c/m32c-lib1.S: New file.\n+\t* config/m32c/m32c-lib2.c: New file.\n+\t* config/m32c/m32c-modes.def: New file.\n+\t* config/m32c/m32c-pragma.c: New file.\n+\t* config/m32c/m32c-protos.h: New file.\n+\t* config/m32c/m32c.abi: New file.\n+\t* config/m32c/m32c.c: New file.\n+\t* config/m32c/m32c.h: New file.\n+\t* config/m32c/m32c.md: New file.\n+\t* config/m32c/m32c.opt: New file.\n+\t* config/m32c/minmax.md: New file.\n+\t* config/m32c/mov.md: New file.\n+\t* config/m32c/muldiv.md: New file.\n+\t* config/m32c/predicates.md: New file.\n+\t* config/m32c/prologue.md: New file.\n+\t* config/m32c/shift.md: New file.\n+\t* config/m32c/t-m32c: New file.\n+\n 2005-07-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.md (UNSPEC_SP_SET, UNSPEC_SP_TEST): New constants."}, {"sha": "408f33cfa9fbdb98669f7f708298c13c3d24fbb6", "filename": "gcc/config.gcc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -231,6 +231,10 @@ tm_p_file=\n cpu_type=`echo ${target} | sed 's/-.*$//'`\n cpu_is_64bit=\n case ${target} in\n+m32c*-*-*)\n+        cpu_type=m32c\n+\ttmake_file=m32c/t-m32c\n+        ;;\n alpha*-*-*)\n \tcpu_type=alpha\n \tneed_64bit_hwint=yes\n@@ -2255,6 +2259,12 @@ am33_2.0-*-linux*)\n \textra_parts=\"crtbegin.o crtend.o crtbeginS.o crtendS.o\"\n \tuse_collect2=no\n \t;;\n+m32c-*-elf*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n+\tc_target_objs=\"m32c-pragma.o\"\n+\tcxx_target_objs=\"m32c-pragma.o\"\n+\tuse_fixproto=yes\n+ \t;;\n *)\n \techo \"*** Configuration ${target} not supported\" 1>&2\n \texit 1"}, {"sha": "57f81acf75187f3e385e34f3d69cc8a2e343490a", "filename": "gcc/config/m32c/addsub.md", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Faddsub.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Faddsub.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Faddsub.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,178 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; add, sub\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"mra_or_sp_operand\"\n+\t\t  \"=SdRhl,SdRhl,??Rmm,??Rmm, Raa,Raa,SdRhl,??Rmm\")\n+\t(plus:QI (match_operand:QI 1 \"mra_operand\"\n+\t\t  \"%0,0,0,0, 0,0,0,0\")\n+\t\t (match_operand:QI 2 \"mrai_operand\"\n+\t\t  \"iSdRhl,?Rmm,iSdRhl,?Rmm, iSdRhl,?Rmm,Raa,Raa\")))]\n+  \"\"\n+  \"add.b\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n+\t \t  \"=SdRhi,SdRhi,??Rmm,??Rmm, SdRhi,??Rmm, Rhi, !Rsp\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\"\n+\t\t  \"%0,0,0,0, 0,0, Raw, 0\")\n+\t\t (match_operand:HI 2 \"general_operand\"\n+\t\t  \"IU2sSdRhi,?Rmm,IU2sSdRhi,?Rmm, IM2,IM2, IS2IU2, i\")))]\n+  \"\"\n+  \"@\n+   add.w\\t%2,%0\n+   add.w\\t%2,%0\n+   add.w\\t%2,%0\n+   add.w\\t%2,%0\n+   sub.w\\t%m2,%0\n+   sub.w\\t%m2,%0\n+   mova\\t%d2[%1],%0\n+   add.w\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc,oszc,oszc\")]\n+  )\n+\n+(define_insn \"addpsi3\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=SdRpi,SdRpi,Rsp*Rmm, Rpi,Rpi,Rhi,&Rhi\")\n+\t(plus:PSI (match_operand:PSI 1 \"nonimmediate_operand\" \"0,0,0, Raa,Rad,!Rcl,Rhi\")\n+\t\t  (match_operand:PSI 2 \"general_operand\" \"iSdRpi,?Rmm,i, i,IS2,i,!Rcl\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   add.%&\\t%2,%0\n+   add.%&\\t%2,%0\n+   add.%&\\t%2,%0\n+   mova\\t%d2[%1],%0\n+   mova\\t%D2[%1],%0\n+   #\n+   #\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,*,*,oszc,oszc\")]\n+  )\n+\n+; This is needed for reloading large frames.\n+(define_split\n+  [(set (match_operand:PSI 0 \"ra_operand\" \"\")\n+\t(plus:PSI (match_operand:PSI 1 \"cr_operand\" \"\")\n+\t\t (match_operand:PSI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0)\n+\t(plus:PSI (match_dup 0)\n+\t\t (match_dup 2)))]\n+  \"\"\n+  )\n+\n+; This is needed for reloading large frames.\n+(define_split\n+  [(set (match_operand:PSI 0 \"ra_operand\" \"\")\n+\t(plus:PSI (match_operand:PSI 1 \"ra_operand\" \"\")\n+\t\t (match_operand:PSI 2 \"cr_operand\" \"\")))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0)\n+\t(plus:PSI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"\"\n+  )\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"mra_or_sp_operand\"\n+\t\t   \"=SdRhl,SdRhl,??Rmm,??Rmm, Raa,Raa,SdRhl,??Rmm, *Rsp\")\n+\t(minus:QI (match_operand:QI 1 \"mra_operand\"\n+\t\t   \"0,0,0,0, 0,0,0,0, 0\")\n+\t\t  (match_operand:QI 2 \"mrai_operand\"\n+\t\t   \"iSdRhl,?Rmm,iSdRhl,?Rmm, iSdRhl,?Rmm,Raa,Raa, i\")))]\n+  \"\"\n+  \"sub.b\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\"\n+\t\t   \"=SdRhi,SdRhi,??Rmm,??Rmm, SdRhi,??Rmm\")\n+\t(minus:HI (match_operand:HI 1 \"mras_operand\"\n+\t\t   \"0,0,0,0, 0,0\")\n+\t\t  (match_operand:HI 2 \"mrai_operand\"\n+\t\t   \"IU2SdRhi,?Rmm,IU2SdRhi,?Rmm, IM2,IM2\")))]\n+  \"\"\n+  \"@\n+   sub.w\\t%2,%0\n+   sub.w\\t%2,%0\n+   sub.w\\t%2,%0\n+   sub.w\\t%2,%0\n+   add.w\\t%m2,%0\n+   add.w\\t%m2,%0\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc\")]\n+  )\n+\n+(define_insn \"subpsi3\"\n+  [(set (match_operand:PSI 0 \"mra_operand\" \"=RpiSd,RpiSd,??Rmm,??Rmm\")\n+\t(minus:PSI (match_operand:PSI 1 \"mra_operand\" \"0,0,0,0\")\n+\t\t   (match_operand:PSI 2 \"mrai_operand\" \"iRpiSd,?Rmm,iRpiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"sub.%&\\t%2,%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=SdRhl,??Rmm\")\n+\t(neg:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"neg.b\\t%0\"\n+  [(set_attr \"flags\" \"oszc,oszc\")]\n+  )\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=SdRhi,??Rmm\")\n+\t(neg:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"neg.w\\t%0\"\n+  [(set_attr \"flags\" \"oszc,oszc\")]\n+  )\n+\n+; We can negate an SImode by operating on the subparts.  GCC deals\n+; with this itself for larger modes, but not SI.\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=SdR03,??Rmm\")\n+\t(neg:SI (match_operand:SI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"not.w %h0 | not.w %H0 | add.w #1,%h0 | adcf.w %H0\"\n+  [(set_attr \"flags\" \"oszc,oszc\")]\n+  )\n+\n+(define_insn \"absqi2\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,??Rmm\")\n+\t(abs:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"abs.b\\t%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )\n+\n+(define_insn \"abshi2\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm\")\n+\t(abs:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"abs.w\\t%0\"\n+  [(set_attr \"flags\" \"oszc\")]\n+  )"}, {"sha": "e6c269b175bfe1454faf3f4a6a0dc659b3d3423c", "filename": "gcc/config/m32c/bitops.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fbitops.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fbitops.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fbitops.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,93 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; Bit-wise operations (and, ior, xor, shift)\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm\")\n+\t(and:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"iRhlSd,?Rmm,iRhlSd,?Rmm\")))]\n+  \"\"\n+  \"and.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm,RhiSd,??Rmm\")\n+\t(and:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,?Rmm,iRhiSd\")))]\n+  \"\"\n+  \"and.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RqiSd,??Rmm,RqiSd,??Rmm\")\n+\t(ior:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"iRhlSd,iRhlSd,?Rmm,?Rmm\")))]\n+  \"\"\n+  \"or.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(ior:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"\"\n+  \"or.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm\")\n+\t(xor:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:QI 2 \"mrai_operand\" \"iRhlSd,?Rmm,iRhlSd,?Rmm\")))]\n+  \"\"\n+  \"xor.b\\t%x2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(xor:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t(match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"\"\n+  \"xor.w\\t%X2,%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,sz\")]\n+  )\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,??Rmm\")\n+\t(not:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"not.b\\t%0\"\n+  [(set_attr \"flags\" \"sz,sz\")]\n+  )\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm\")\n+\t(not:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")))]\n+  \"\"\n+  \"not.w\\t%0\"\n+  [(set_attr \"flags\" \"sz,sz\")]\n+  )"}, {"sha": "7ef695fa8b65bcd09ef0a59376e1f082b7c445c2", "filename": "gcc/config/m32c/cond.md", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fcond.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fcond.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fcond.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,72 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+; conditionals - cmp, jcc, setcc, etc.\n+\n+; Until support for relaxing is supported in gas, we must assume that\n+; short labels won't reach, so we must use long labels.\n+; Unfortunately, there aren't any conditional jumps with long labels,\n+; so instead we invert the conditional and jump around a regular jump.\n+\n+; Note that we can, at some point in the future, add code to omit the\n+; \"cmp\" portion of the insn if the preceeding insn happened to set the\n+; right flags already.  For example, a mov followed by a \"cmp *,0\" is\n+; redundant; the move already set the Z flag.\n+\n+(define_insn \"cbranchqi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"m32c_cmp_operator\"\n+\t\t\t      [(match_operand:QI 1 \"mrai_operand\" \"RqiSd,RqiSd,?Rmm,?Rmm\")\n+\t\t\t       (match_operand:QI 2 \"mrai_operand\" \"iRqiSd,?Rmm,iRqiSd,?Rmm\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+  \"cmp.b\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n+;  \"cmp.b\\t%2,%1\\n\\tj%c0\\t%l3\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc\")]\n+  )\n+\n+(define_insn \"cbranchhi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"m32c_cmp_operator\"\n+\t\t\t      [(match_operand:HI 1 \"mrai_operand\" \"Rhi,?Sd,Rhi,?Sd,?Rmm,?Rmm\")\n+\t\t\t       (match_operand:HI 2 \"mrai_operand\" \"iRhiSd,iRhiSd,?Rmm,?Rmm,iRhiSd,?Rmm\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"\"\n+  \"cmp.w\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n+;  \"cmp.w\\t%2,%1\\n\\tj%c0\\t%l3\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc,oszc,oszc\")]\n+  )\n+\n+(define_insn \"cbranchpsi4\"\n+  [(set (pc) (if_then_else\n+\t      (match_operator 0 \"m32c_cmp_operator\"\n+\t\t\t      [(match_operand:PSI 1 \"mrai_operand\" \"RsiSd,RsiSd,?Rmm,?Rmm\")\n+\t\t\t       (match_operand:PSI 2 \"mrai_operand\" \"iRsiSd,?Rmm,iRsiSd,?Rmm\")])\n+              (label_ref (match_operand 3 \"\" \"\"))\n+\t      (pc)))]\n+  \"TARGET_A24\"\n+  \"cmp.l\\t%2,%1\\n\\tj%C0\\t1f\\n\\tjmp.a\\t%l3\\n1:\"\n+;  \"cmp.l\\t%2,%1\\n\\tj%c0\\t%l3\"\n+  [(set_attr \"flags\" \"oszc,oszc,oszc,oszc\")]\n+  )"}, {"sha": "705bb32b985f89b6b47a688a0f0c6628835793c5", "filename": "gcc/config/m32c/jump.md", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fjump.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fjump.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fjump.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,87 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; jump, conditionals, calls, etc\n+\n+(define_insn \"indirect_jump_16\"\n+  [(set (pc)\n+       (match_operand:HI 0 \"register_operand\" \"Rhi\"))]\n+  \"TARGET_A16\"\n+;  \"jmpi.a\\t%0\"\n+  ; no 16 bit jmpi in r8c\n+  \"push.b #0 | push.w\\t%0 | rts\"\n+  )\n+\n+(define_insn \"indirect_jump_24\"\n+  [(set (pc)\n+       (match_operand:PSI 0 \"register_operand\" \"Rpi\"))]\n+  \"TARGET_A24\"\n+  \"jmpi.a\\t%0\"\n+  )\n+\n+(define_expand \"indirect_jump\"\n+  [(match_operand 0 \"register_operand\" \"\")]\n+  \"\"\n+  \"if (TARGET_A16)\n+     emit_jump_insn (gen_indirect_jump_16(operands[0]));\n+   else\n+     emit_jump_insn (gen_indirect_jump_24(operands[0]));\n+   DONE;\"\n+  )\n+\n+; We can replace this with jmp.s when gas supports relaxing.  m32c\n+; opcodes are too complicated to try to compute their sizes here, it's\n+; far easier (and more reliable) to let gas worry about it.\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"jmp.a\\t%l0\"\n+)\n+\n+; No 16 bit indirect calls on r8c/m16c.  */\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"Si,SaSb,?Rmm\")\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"immediate_operand\" \"\"))]\n+  \"\"\n+  \"*\n+switch (which_alternative) {\n+  case 0: return \\\"jsr.a\\t%0\\\";\n+  case 1: return TARGET_A16 ? \\\"push.w %a0 | jsr.a\\tm32c_jsri16\\\" : \\\"jsri.a\\t%a0\\\";\n+  case 2: return \\\"jsri.a\\t%a0\\\";\n+}\"\n+  )\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"m32c_return_operand\" \"=RdiRmmRpa,RdiRmmRpa,RdiRmmRpa\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"Si,SaSb,?Rmm\")\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"immediate_operand\" \"\"))]\n+  \"\"\n+  \"*\n+switch (which_alternative) {\n+  case 0: return \\\"jsr.a\\t%1\\\";\n+  case 1: return TARGET_A16 ? \\\"push.w %a1 | jsr.a\\tm32c_jsri16\\\" : \\\"jsri.a\\t%a1\\\";\n+  case 2: return \\\"jsri.a\\t%a1\\\";\n+}\"\n+  )"}, {"sha": "b7f597719427280d11982d5465f786d59b079e19", "filename": "gcc/config/m32c/m32c-lib1.S", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-lib1.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-lib1.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-lib1.S?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,227 @@\n+/* libgcc routines for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#if defined(__r8c_cpu__) || defined(__m16c_cpu__)\n+#define A16\n+#define A(n,w) n\n+#define W w\n+#else\n+#define A24\n+#define A(n,w) w\n+#define W l\n+#endif\n+\n+\n+#ifdef L__m32c_memregs\n+\n+/* Warning: these memory locations are used as a register bank.  They\n+   *must* end up consecutive in any final executable, so you may *not*\n+   use the otherwise obvious \".comm\" directive to allocate space for\n+   them. */\n+\n+\t.bss\n+\t.global\tmem0\n+mem0:\t.space\t1\n+\t.global\tmem1\n+mem1:\t.space\t1\n+\t.global\tmem2\n+mem2:\t.space\t1\n+\t.global\tmem3\n+mem3:\t.space\t1\n+\t.global\tmem4\n+mem4:\t.space\t1\n+\t.global\tmem5\n+mem5:\t.space\t1\n+\t.global\tmem6\n+mem6:\t.space\t1\n+\t.global\tmem7\n+mem7:\t.space\t1\n+\t.global\tmem8\n+mem8:\t.space\t1\n+\t.global\tmem9\n+mem9:\t.space\t1\n+\t.global\tmem10\n+mem10:\t.space\t1\n+\t.global\tmem11\n+mem11:\t.space\t1\n+\t.global\tmem12\n+mem12:\t.space\t1\n+\t.global\tmem13\n+mem13:\t.space\t1\n+\t.global\tmem14\n+mem14:\t.space\t1\n+\t.global\tmem15\n+mem15:\t.space\t1\n+\n+#endif\n+\n+#ifdef L__m32c_eh_return\n+\t.text\n+\t.global __m32c_eh_return\n+__m32c_eh_return:\t\n+\n+\t/* At this point, r0 has the stack adjustment, r1r3 has the\n+\t   address to return to.  The stack looks like this:\n+\n+\t   old_ra\n+\t   old_fp\n+\t   <- unwound sp\n+\t   ...\n+\t   fb\n+\t   through\n+\t   r0\n+\t   <- sp\n+\n+\t   What we need to do is restore all the registers, update the\n+\t   stack, and return to the right place.\n+\t*/\n+\n+\tstc\tsp,a0\n+\t\n+\tadd.W\tA(#16,#24),a0\n+\t/* a0 points to the current stack, just above the register\n+\t   save areas */\n+\n+\tmov.w\ta0,a1\n+\texts.w\tr0\n+\tsub.W\tA(r0,r0r2),a1\n+\tsub.W\tA(#3,#4),a1\n+\t/* a1 points to the new stack.  */\n+\n+\t/* This is for the \"rts\" below.  */\n+\tmov.w\tr1,[a1]\n+#ifdef A16\n+\tmov.w\tr2,r1\n+\tmov.b\tr1l,2[a1]\n+#else\n+\tmov.w\tr2,2[a1]\n+#endif\n+\n+\t/* This is for the \"popc sp\" below.  */\n+\tmov.W\ta1,[a0]\t\n+\n+\tpopm    r0,r1,r2,r3,a0,a1,sb,fb\n+\tpopc\tsp\n+\trts\n+#endif\n+\n+/* SImode arguments for SI foo(SI,SI) functions.  */\n+#ifdef A16\n+#define SAL  5[fb]\n+#define SAH  7[fb]\n+#define SBL  9[fb]\n+#define SBH 11[fb]\n+#else\n+#define SAL  8[fb]\n+#define SAH 10[fb]\n+#define SBL 12[fb]\n+#define SBH 14[fb]\n+#endif\n+\n+#ifdef L__m32c_mulsi3\n+\t.text\n+\t.global ___mulsi3\n+___mulsi3:\n+\tenter\t#0\n+\tpush.w\tr2\n+\tmov.w\tSAL,mem0\n+\tmov.w\tSAH,mem2\n+\tmulu.w\tSBL,mem0\t/* writes to r2r0 */\n+\tmov.w\tSAL,r0\n+\tmulu.w\tSBH,r0\t\t/* writes to r2r0 */\n+\tadd.w\tr0,mem2\n+\tmov.w\tSAH,r0\n+\tmulu.w\tSBL,r0\n+\tadd.w\tr0,mem2\n+\tpop.w\tr2\n+\texitd\n+#endif\n+\n+#ifdef L__m32c_cmpsi2\n+\t.text\n+\t.global ___cmpsi2\n+___cmpsi2:\n+\tenter\t#0\n+\tcmp.w\tSBH,SAH\n+\tjgt\tcmpsi_gt\n+\tjlt\tcmpsi_lt\n+\tcmp.w\tSBL,SAL\n+\tjgt\tcmpsi_gt\n+\tjlt\tcmpsi_lt\n+\tmov.w\t#1,r0\n+\texitd\n+cmpsi_gt:\n+\tmov.w\t#2,r0\n+\texitd\n+cmpsi_lt:\n+\tmov.w\t#0,r0\n+\texitd\n+#endif\n+\n+#ifdef L__m32c_ucmpsi2\n+\t.text\n+\t.global ___ucmpsi2\n+___ucmpsi2:\n+\tenter\t#0\n+\tcmp.w\tSBH,SAH\n+\tjgtu\tcmpsi_gt\n+\tjltu\tcmpsi_lt\n+\tcmp.w\tSBL,SAL\n+\tjgtu\tcmpsi_gt\n+\tjltu\tcmpsi_lt\n+\tmov.w\t#1,r0\n+\texitd\n+cmpsi_gt:\n+\tmov.w\t#2,r0\n+\texitd\n+cmpsi_lt:\n+\tmov.w\t#0,r0\n+\texitd\n+#endif\n+\n+#ifdef L__m32c_jsri16\n+\t.data\n+m32c_jsri_addr:\n+\t.byte\t0, 0, 0\n+m32c_jsri_ret:\n+\t.byte\t0, 0, 0\n+\n+\t.text\n+\t.global\tm32c_jsri16\n+m32c_jsri16:\n+\tpop.w\tm32c_jsri_ret\n+\tpop.b\tm32c_jsri_ret+2\n+\tpop.w\tm32c_jsri_addr\n+\tpush.b\tm32c_jsri_ret+2\n+\tpush.w\tm32c_jsri_ret\n+\tjmpi.a\tm32c_jsri_addr\n+\n+#endif"}, {"sha": "492e6c8362c7e53331d34667e71c1919c56cf4e6", "filename": "gcc/config/m32c/m32c-lib2.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-lib2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-lib2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-lib2.c?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,139 @@\n+/* libgcc routines for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   In addition to the permissions in the GNU General Public License,\n+   the Free Software Foundation gives you unlimited permission to link\n+   the compiled version of this file into combinations with other\n+   programs, and to distribute those combinations without any\n+   restriction coming from the use of this file.  (The General Public\n+   License restrictions do apply in other respects; for example, they\n+   cover modification of the file, and distribution when not linked\n+   into a combine executable.)\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+typedef          int  HItype __attribute__ ((mode (HI)));\n+typedef unsigned int UHItype __attribute__ ((mode (HI)));\n+typedef          int  SItype __attribute__ ((mode (SI)));\n+typedef unsigned int USItype __attribute__ ((mode (SI)));\n+\n+typedef int word_type __attribute__ ((mode (__word__)));\n+\n+USItype udivmodsi4 (USItype num, USItype den, word_type modwanted);\n+SItype __divsi3 (SItype a, SItype b);\n+SItype __modsi3 (SItype a, SItype b);\n+SItype __udivsi3 (SItype a, SItype b);\n+SItype __umodsi3 (SItype a, SItype b);\n+\n+USItype\n+udivmodsi4 (USItype num, USItype den, word_type modwanted)\n+{\n+  USItype bit = 1;\n+  USItype res = 0;\n+\n+  while (den < num && bit && !(den & (1L << 31)))\n+    {\n+      den <<= 1;\n+      bit <<= 1;\n+    }\n+  while (bit)\n+    {\n+      if (num >= den)\n+\t{\n+\t  num -= den;\n+\t  res |= bit;\n+\t}\n+      bit >>= 1;\n+      den >>= 1;\n+    }\n+  if (modwanted)\n+    return num;\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__divsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = !neg;\n+    }\n+\n+  if (b < 0)\n+    {\n+      b = -b;\n+      neg = !neg;\n+    }\n+\n+  res = udivmodsi4 (a, b, 0);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+SItype\n+__modsi3 (SItype a, SItype b)\n+{\n+  word_type neg = 0;\n+  SItype res;\n+\n+  if (a < 0)\n+    {\n+      a = -a;\n+      neg = 1;\n+    }\n+\n+  if (b < 0)\n+    b = -b;\n+\n+  res = udivmodsi4 (a, b, 1);\n+\n+  if (neg)\n+    res = -res;\n+\n+  return res;\n+}\n+\n+\n+\n+\n+SItype\n+__udivsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 0);\n+}\n+\n+\n+\n+SItype\n+__umodsi3 (SItype a, SItype b)\n+{\n+  return udivmodsi4 (a, b, 1);\n+}"}, {"sha": "efefd886d9a42d328cc33017e368d4b073ecd1eb", "filename": "gcc/config/m32c/m32c-modes.def", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-modes.def?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,30 @@\n+/* Target-Specific Modes for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* 24-bit pointers, whole */\n+/*INT_MODE (PI, 3);*/\n+\n+/* 24-bit pointers, in 32-bit units */\n+PARTIAL_INT_MODE (SI);\n+\n+/* 48-bit MULEX result */\n+/* INT_MODE (MI, 6); */"}, {"sha": "236087867cffd05ebb585611a6f9f7fd9f5440a8", "filename": "gcc/config/m32c/m32c-pragma.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-pragma.c?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,97 @@\n+/* M32C Pragma support\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   Contributed by Red Hat, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"toplev.h\"\n+#include \"c-pragma.h\"\n+#include \"cpplib.h\"\n+#include \"hard-reg-set.h\"\n+#include \"output.h\"\n+#include \"m32c-protos.h\"\n+#include \"function.h\"\n+#define MAX_RECOG_OPERANDS 10\n+#include \"reload.h\"\n+#include \"target.h\"\n+\n+/* Implements the \"GCC memregs\" pragma.  This pragma takes only an\n+   integer, and is semantically identical to the -memregs= command\n+   line option.  The only catch is, the programmer should only use\n+   this pragma at the beginning of the file (preferably, in some\n+   project-wide header) to avoid ABI changes related to changing the\n+   list of available \"registers\".  */\n+static void\n+m32c_pragma_memregs (cpp_reader * reader ATTRIBUTE_UNUSED)\n+{\n+  /* on off */\n+  tree val;\n+  enum cpp_ttype type;\n+  HOST_WIDE_INT i;\n+  static char new_number[3];\n+\n+  type = c_lex (&val);\n+  if (type == CPP_NUMBER)\n+    {\n+      if (host_integerp (val, 1))\n+\t{\n+\t  i = tree_low_cst (val, 1);\n+\n+\t  type = c_lex (&val);\n+\t  if (type != CPP_EOF)\n+\t    warning (0, \"junk at end of #pragma GCC memregs [0..16]\");\n+\n+\t  if (0 <= i && i <= 16)\n+\t    {\n+\t      if (!ok_to_change_target_memregs)\n+\t\t{\n+\t\t  warning (0,\n+\t\t\t   \"#pragma GCC memregs must precede any function decls\");\n+\t\t  return;\n+\t\t}\n+\t      new_number[0] = (i / 10) + '0';\n+\t      new_number[1] = (i % 10) + '0';\n+\t      new_number[2] = 0;\n+\t      target_memregs = new_number;\n+\t      m32c_conditional_register_usage ();\n+\t    }\n+\t  else\n+\t    {\n+\t      warning (0, \"#pragma GCC memregs takes a number [0..16]\");\n+\t    }\n+\n+\t  return;\n+\t}\n+    }\n+\n+  error (\"#pragma GCC memregs takes a number [0..16]\");\n+}\n+\n+/* Implements REGISTER_TARGET_PRAGMAS.  */\n+void\n+m32c_register_pragmas (void)\n+{\n+  c_register_pragma (\"GCC\", \"memregs\", m32c_pragma_memregs);\n+}"}, {"sha": "ebc4526eef8f704aa2b4a21795dc980c47c272c4", "filename": "gcc/config/m32c/m32c-protos.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,105 @@\n+/* Target Prototypes for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#define MM enum machine_mode\n+#define UINT unsigned int\n+\n+int  m32c_class_likely_spilled_p (int);\n+void m32c_conditional_register_usage (void);\n+int  m32c_const_ok_for_constraint_p (HOST_WIDE_INT, char, const char *);\n+UINT m32c_dwarf_frame_regnum (int);\n+int  m32c_eh_return_data_regno (int);\n+void m32c_emit_epilogue (void);\n+void m32c_emit_prologue (void);\n+int  m32c_epilogue_uses (int);\n+int  m32c_extra_address_constraint (char, const char *);\n+int  m32c_extra_memory_constraint (char, const char *);\n+int  m32c_function_arg_regno_p (int);\n+void m32c_init_expanders (void);\n+int  m32c_initial_elimination_offset (int, int);\n+void m32c_output_reg_pop (FILE *, int);\n+void m32c_output_reg_push (FILE *, int);\n+void m32c_override_options (void);\n+int  m32c_print_operand_punct_valid_p (int);\n+int  m32c_push_rounding (int);\n+int  m32c_reg_class_from_constraint (char, const char *);\n+void m32c_register_pragmas (void);\n+int  m32c_regno_ok_for_base_p (int);\n+int  m32c_trampoline_alignment (void);\n+int  m32c_trampoline_size (void);\n+\n+#if defined(RTX_CODE) && defined(TREE_CODE)\n+\n+rtx  m32c_function_arg (CUMULATIVE_ARGS *, MM, tree, int);\n+rtx  m32c_function_value (tree, tree);\n+\n+#endif\n+\n+#ifdef RTX_CODE\n+\n+int  m32c_cannot_change_mode_class (MM, MM, int);\n+int  m32c_class_max_nregs (int, MM);\n+rtx  m32c_eh_return_stackadj_rtx (void);\n+void m32c_emit_eh_epilogue (rtx);\n+int  m32c_extra_constraint_p (rtx, char, const char *);\n+int  m32c_extra_constraint_p2 (rtx, char, const char *);\n+int  m32c_hard_regno_nregs (int, MM);\n+int  m32c_hard_regno_ok (int, MM);\n+rtx  m32c_incoming_return_addr_rtx (void);\n+void m32c_initialize_trampoline (rtx, rtx, rtx);\n+int  m32c_legitimate_address_p (MM, rtx, int);\n+int  m32c_legitimate_constant_p (rtx);\n+int  m32c_legitimize_address (rtx *, rtx, MM);\n+int  m32c_legitimize_reload_address (rtx *, MM, int, int, int);\n+rtx  m32c_libcall_value (MM);\n+int  m32c_limit_reload_class (MM, int);\n+int  m32c_memory_move_cost (MM, int, int);\n+int  m32c_mode_dependent_address (rtx);\n+int  m32c_modes_tieable_p (MM, MM);\n+bool m32c_mov_ok (rtx *, MM);\n+int  m32c_preferred_output_reload_class (rtx, int);\n+int  m32c_preferred_reload_class (rtx, int);\n+int  m32c_prepare_move (rtx *, MM);\n+int  m32c_prepare_shift (rtx *, int, int);\n+void m32c_print_operand (FILE *, rtx, int);\n+void m32c_print_operand_address (FILE *, rtx);\n+int  m32c_reg_ok_for_base_p (rtx, int);\n+int  m32c_register_move_cost (MM, int, int);\n+MM   m32c_regno_reg_class (int);\n+rtx  m32c_return_addr_rtx (int);\n+int  m32c_secondary_reload_class (int, MM, rtx);\n+int  m32c_split_move (rtx *, MM, int);\n+int  m32c_split_psi_p (rtx *);\n+\n+#endif\n+\n+#ifdef TREE_CODE\n+\n+void m32c_function_arg_advance (CUMULATIVE_ARGS *, MM, tree, int);\n+tree m32c_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n+void m32c_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n+bool m32c_promote_function_return (tree);\n+\n+#endif\n+\n+#undef MM\n+#undef UINT"}, {"sha": "21f61f9d9548299f6c5e5e10df0a355ecf0eed89", "filename": "gcc/config/m32c/m32c.abi", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.abi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.abi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.abi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,133 @@\n+   Target Definitions for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.\n+\n+\n+These are just some random notes I used during development of this\n+port.  Please don't consider these to be \"official\" specifications,\n+just additional information to help make the code easier to\n+understand.\n+\n+\n+Frame\n+=====\n+\n+\t+--------------------\n+\t| incoming args\n+\t+--------------------\n+\t| return Address\n+osp ->\t+--------------------\n+\t| saved fp\n+fp ->\t+--------------------\n+\t| local data\n+\t+--------------------\n+\t| saved regs\n+\t+--------------------\n+\t| outgoing args (opt)\n+sp ->\t+--------------------\n+\n+Argument Passing\n+================\n+\n+r8c, m16c\n+---------\n+\n+First arg may be passed in r1l or r1 if it (1) fits (QImode or\n+HImode), (2) is named, and (3) is an integer or pointer type (no\n+structs, floats, etc).  Otherwise, it's passed on the stack.\n+\n+Second arg may be passed in r2, same restrictions (but not QImode),\n+even if the first arg is passed on the stack.\n+\n+Third and further args are passed on the stack.  No padding is used,\n+stack \"alignment\" is 8 bits.\n+\n+m32cm, m32c\n+-----------\n+First arg may be passed in r0l or r0, same restrictions as above.\n+\n+Second and further args are passed on the stack.  Padding is used\n+after QImode parameters (i.e. lower-addressed byte is the value,\n+higher-addressed byte is the padding), stack \"alignment\" is 16 bits.\n+\n+\n+Return Value\n+============\n+\n+r8c, m16c\n+---------\n+\n+QImode in r0l\n+HImode in r0\n+near pointer in r0\n+(desired)\n+SImode in r2r0\n+far pointer in r2r0\n+(actual)\n+Anything bigger than 16 bits is returned in memory, at mem0 (mem0\n+through mem15 are provided by libgcc.a)\n+\n+Aggregate values (regardless of size) are returned by pushing a\n+pointer to a temporary area on the stack after the args are pushed.\n+The function fills in this area with the value.  Note that this\n+pointer on the stack does not affect how register arguments, if any,\n+are configured.\n+\n+m32cm, m32c\n+-----------\n+Same.\n+\n+\n+Registers Preserved Across Calls\n+================================\n+\n+r8c, m16c\n+---------\n+sb, fb, sp (i.e. nearly all registers are call clobbered)\n+\n+m32cm, m32c\n+-----------\n+r1, r2, r3, a0, a1, sb, fb, sp\n+(except when used for return values)\n+\n+\n+Interrupt Handlers\n+==================\n+\n+The stack frame is slightly different for interrupt handlers, because\n+(1) we don't have a usable parent frame, and (2) we have to use\n+special instructions to return and thus must save/restore everything\n+differently.\n+\n+\t+--------------------\n+\t| program state\n+osp ->\t+--------------------\n+\t| return address\n+\t+--------------------\n+\t| saved r0..fp (pushm)\n+fp ->\t+--------------------\n+\t| local data\n+\t+--------------------\n+\t| saved regs mem0..mem15\n+\t+--------------------\n+\t| outgoing args (opt)\n+sp ->\t+--------------------\n+"}, {"sha": "bc4727e7496cd1e1b84c69ea88bc8b3c757dc40c", "filename": "gcc/config/m32c/m32c.c", "status": "added", "additions": 2958, "deletions": 0, "changes": 2958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,2958 @@\n+/* Target Code for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"reload.h\"\n+#include \"toplev.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"tm_p.h\"\n+#include \"langhooks.h\"\n+#include \"tree-gimple.h\"\n+\n+/* Prototypes */\n+\n+/* Used by m32c_pushm_popm.  */\n+typedef enum\n+{\n+  PP_pushm,\n+  PP_popm,\n+  PP_justcount\n+} Push_Pop_Type;\n+\n+static tree interrupt_handler (tree *, tree, tree, int, bool *);\n+static int interrupt_p (tree node);\n+static bool m32c_asm_integer (rtx, unsigned int, int);\n+static int m32c_comp_type_attributes (tree, tree);\n+static bool m32c_fixed_condition_code_regs (unsigned int *, unsigned int *);\n+static struct machine_function *m32c_init_machine_status (void);\n+static void m32c_insert_attributes (tree, tree *);\n+static bool m32c_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n+\t\t\t\t    tree, bool);\n+static bool m32c_promote_prototypes (tree);\n+static int m32c_pushm_popm (Push_Pop_Type);\n+static bool m32c_strict_argument_naming (CUMULATIVE_ARGS *);\n+static rtx m32c_struct_value_rtx (tree, int);\n+static rtx m32c_subreg (enum machine_mode, rtx, enum machine_mode, int);\n+static int need_to_save (int);\n+\n+#define streq(a,b) (strcmp ((a), (b)) == 0)\n+\n+/* Internal support routines */\n+\n+/* Debugging statements are tagged with DEBUG0 only so that they can\n+   be easily enabled individually, by replacing the '0' with '1' as\n+   needed.  */\n+#define DEBUG0 0\n+#define DEBUG1 1\n+\n+#if DEBUG0\n+/* This is needed by some of the commented-out debug statements\n+   below.  */\n+static char const *class_names[LIM_REG_CLASSES] = REG_CLASS_NAMES;\n+#endif\n+static int class_contents[LIM_REG_CLASSES][1] = REG_CLASS_CONTENTS;\n+\n+/* These are all to support encode_pattern().  */\n+static char pattern[30], *patternp;\n+static GTY(()) rtx patternr[30];\n+#define RTX_IS(x) (streq (pattern, x))\n+\n+/* Some macros to simplify the logic throughout this file.  */\n+#define IS_MEM_REGNO(regno) ((regno) >= MEM0_REGNO && (regno) <= MEM7_REGNO)\n+#define IS_MEM_REG(rtx) (GET_CODE (rtx) == REG && IS_MEM_REGNO (REGNO (rtx)))\n+\n+#define IS_CR_REGNO(regno) ((regno) >= SB_REGNO && (regno) <= PC_REGNO)\n+#define IS_CR_REG(rtx) (GET_CODE (rtx) == REG && IS_CR_REGNO (REGNO (rtx)))\n+\n+/* We do most RTX matching by converting the RTX into a string, and\n+   using string compares.  This vastly simplifies the logic in many of\n+   the functions in this file.\n+\n+   On exit, pattern[] has the encoded string (use RTX_IS(\"...\") to\n+   compare it) and patternr[] has pointers to the nodes in the RTX\n+   corresponding to each character in the encoded string.  The latter\n+   is mostly used by print_operand().\n+\n+   Unrecognized patterns have '?' in them; this shows up when the\n+   assembler complains about syntax errors.\n+*/\n+\n+static void\n+encode_pattern_1 (rtx x)\n+{\n+  int i;\n+\n+  if (patternp == pattern + sizeof (pattern) - 2)\n+    {\n+      patternp[-1] = '?';\n+      return;\n+    }\n+\n+  patternr[patternp - pattern] = x;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      *patternp++ = 'r';\n+      break;\n+    case SUBREG:\n+      if (GET_MODE_SIZE (GET_MODE (x)) !=\n+\t  GET_MODE_SIZE (GET_MODE (XEXP (x, 0))))\n+\t*patternp++ = 'S';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case MEM:\n+      *patternp++ = 'm';\n+    case CONST:\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case PLUS:\n+      *patternp++ = '+';\n+      encode_pattern_1 (XEXP (x, 0));\n+      encode_pattern_1 (XEXP (x, 1));\n+      break;\n+    case PRE_DEC:\n+      *patternp++ = '>';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case POST_INC:\n+      *patternp++ = '<';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case LO_SUM:\n+      *patternp++ = 'L';\n+      encode_pattern_1 (XEXP (x, 0));\n+      encode_pattern_1 (XEXP (x, 1));\n+      break;\n+    case HIGH:\n+      *patternp++ = 'H';\n+      encode_pattern_1 (XEXP (x, 0));\n+      break;\n+    case SYMBOL_REF:\n+      *patternp++ = 's';\n+      break;\n+    case LABEL_REF:\n+      *patternp++ = 'l';\n+      break;\n+    case CODE_LABEL:\n+      *patternp++ = 'c';\n+      break;\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      *patternp++ = 'i';\n+      break;\n+    case UNSPEC:\n+      *patternp++ = 'u';\n+      *patternp++ = '0' + XCINT (x, 1, UNSPEC);\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\tencode_pattern_1 (XVECEXP (x, 0, i));\n+      break;\n+    case USE:\n+      *patternp++ = 'U';\n+      break;\n+    case PARALLEL:\n+      *patternp++ = '|';\n+      for (i = 0; i < XVECLEN (x, 0); i++)\n+\tencode_pattern_1 (XVECEXP (x, 0, i));\n+      break;\n+    case EXPR_LIST:\n+      *patternp++ = 'E';\n+      encode_pattern_1 (XEXP (x, 0));\n+      if (XEXP (x, 1))\n+\tencode_pattern_1 (XEXP (x, 1));\n+      break;\n+    default:\n+      *patternp++ = '?';\n+#if DEBUG0\n+      fprintf (stderr, \"can't encode pattern %s\\n\",\n+\t       GET_RTX_NAME (GET_CODE (x)));\n+      debug_rtx (x);\n+      gcc_unreachable ();\n+#endif\n+      break;\n+    }\n+}\n+\n+static void\n+encode_pattern (rtx x)\n+{\n+  patternp = pattern;\n+  encode_pattern_1 (x);\n+  *patternp = 0;\n+}\n+\n+/* Since register names indicate the mode they're used in, we need a\n+   way to determine which name to refer to the register with.  Called\n+   by print_operand().  */\n+\n+static const char *\n+reg_name_with_mode (int regno, enum machine_mode mode)\n+{\n+  int mlen = GET_MODE_SIZE (mode);\n+  if (regno == R0_REGNO && mlen == 1)\n+    return \"r0l\";\n+  if (regno == R0_REGNO && (mlen == 3 || mlen == 4))\n+    return \"r2r0\";\n+  if (regno == R0_REGNO && mlen == 6)\n+    return \"r2r1r0\";\n+  if (regno == R0_REGNO && mlen == 8)\n+    return \"r3r1r2r0\";\n+  if (regno == R1_REGNO && mlen == 1)\n+    return \"r1l\";\n+  if (regno == R1_REGNO && (mlen == 3 || mlen == 4))\n+    return \"r3r1\";\n+  if (regno == A0_REGNO && TARGET_A16 && (mlen == 3 || mlen == 4))\n+    return \"a1a0\";\n+  return reg_names[regno];\n+}\n+\n+/* How many bytes a register uses on stack when it's pushed.  We need\n+   to know this because the push opcode needs to explicitly indicate\n+   the size of the register, even though the name of the register\n+   already tells it that.  Used by m32c_output_reg_{push,pop}, which\n+   is only used through calls to ASM_OUTPUT_REG_{PUSH,POP}.  */\n+\n+static int\n+reg_push_size (int regno)\n+{\n+  switch (regno)\n+    {\n+    case R0_REGNO:\n+    case R1_REGNO:\n+      return 2;\n+    case R2_REGNO:\n+    case R3_REGNO:\n+    case FLG_REGNO:\n+      return 2;\n+    case A0_REGNO:\n+    case A1_REGNO:\n+    case SB_REGNO:\n+    case FB_REGNO:\n+    case SP_REGNO:\n+      if (TARGET_A16)\n+\treturn 2;\n+      else\n+\treturn 3;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static int *class_sizes = 0;\n+\n+/* Given two register classes, find the largest intersection between\n+   them.  If there is no intersection, return RETURNED_IF_EMPTY\n+   instead.  */\n+static int\n+reduce_class (int original_class, int limiting_class, int returned_if_empty)\n+{\n+  int cc = class_contents[original_class][0];\n+  int i, best = NO_REGS;\n+  int best_size = 0;\n+\n+  if (original_class == limiting_class)\n+    return original_class;\n+\n+  if (!class_sizes)\n+    {\n+      int r;\n+      class_sizes = (int *) xmalloc (LIM_REG_CLASSES * sizeof (int));\n+      for (i = 0; i < LIM_REG_CLASSES; i++)\n+\t{\n+\t  class_sizes[i] = 0;\n+\t  for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\t    if (class_contents[i][0] & (1 << r))\n+\t      class_sizes[i]++;\n+\t}\n+    }\n+\n+  cc &= class_contents[limiting_class][0];\n+  for (i = 0; i < LIM_REG_CLASSES; i++)\n+    {\n+      int ic = class_contents[i][0];\n+\n+      if ((~cc & ic) == 0)\n+\tif (best_size < class_sizes[i])\n+\t  {\n+\t    best = i;\n+\t    best_size = class_sizes[i];\n+\t  }\n+\n+    }\n+  if (best == NO_REGS)\n+    return returned_if_empty;\n+  return best;\n+}\n+\n+/* Returns TRUE If there are any registers that exist in both register\n+   classes.  */\n+static int\n+classes_intersect (int class1, int class2)\n+{\n+  return class_contents[class1][0] & class_contents[class2][0];\n+}\n+\n+/* Used by m32c_register_move_cost to determine if a move is\n+   impossibly expensive.  */\n+static int\n+class_can_hold_mode (int class, enum machine_mode mode)\n+{\n+  /* Cache the results:  0=untested  1=no  2=yes */\n+  static char results[LIM_REG_CLASSES][MAX_MACHINE_MODE];\n+  if (results[class][mode] == 0)\n+    {\n+      int r, n, i;\n+      results[class][mode] = 1;\n+      for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n+\tif (class_contents[class][0] & (1 << r)\n+\t    && HARD_REGNO_MODE_OK (r, mode))\n+\t  {\n+\t    int ok = 1;\n+\t    n = HARD_REGNO_NREGS (r, mode);\n+\t    for (i = 1; i < n; i++)\n+\t      if (!(class_contents[class][0] & (1 << (r + i))))\n+\t\tok = 0;\n+\t    if (ok)\n+\t      {\n+\t\tresults[class][mode] = 2;\n+\t\tbreak;\n+\t      }\n+\t  }\n+    }\n+#if DEBUG0\n+  fprintf (stderr, \"class %s can hold %s? %s\\n\",\n+\t   class_names[class], mode_name[mode],\n+\t   (results[class][mode] == 2) ? \"yes\" : \"no\");\n+#endif\n+  return results[class][mode] == 2;\n+}\n+\n+/* Run-time Target Specification.  */\n+\n+/* Memregs are memory locations that gcc treats like general\n+   registers, as there are a limited number of true registers and the\n+   m32c families can use memory in most places that registers can be\n+   used.\n+\n+   However, since memory accesses are more expensive than registers,\n+   we allow the user to limit the number of memregs available, in\n+   order to try to persuade gcc to try harder to use real registers.\n+\n+   Memregs are provided by m32c-lib1.S.\n+*/\n+\n+int target_memregs = 16;\n+static bool target_memregs_set = FALSE;\n+int ok_to_change_target_memregs = TRUE;\n+\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION m32c_handle_option\n+static bool\n+m32c_handle_option (size_t code,\n+\t\t    const char *arg ATTRIBUTE_UNUSED,\n+\t\t    int value ATTRIBUTE_UNUSED)\n+{\n+  if (code == OPT_memregs_)\n+    {\n+      target_memregs_set = TRUE;\n+      target_memregs = atoi (arg);\n+    }\n+  return TRUE;\n+}\n+\n+/* Implements OVERRIDE_OPTIONS.  We limit memregs to 0..16, and\n+   provide a default.  */\n+void\n+m32c_override_options (void)\n+{\n+  if (target_memregs_set)\n+    {\n+      if (target_memregs < 0 || target_memregs > 16)\n+\terror (\"invalid target memregs value '%d'\", target_memregs);\n+    }\n+  else\n+    target_memregs = \"16\";\n+}\n+\n+/* Defining data structures for per-function information */\n+\n+/* The usual; we set up our machine_function data.  */\n+static struct machine_function *\n+m32c_init_machine_status (void)\n+{\n+  struct machine_function *machine;\n+  machine =\n+    (machine_function *) ggc_alloc_cleared (sizeof (machine_function));\n+\n+  return machine;\n+}\n+\n+/* Implements INIT_EXPANDERS.  We just set up to call the above\n+   function.  */\n+void\n+m32c_init_expanders (void)\n+{\n+  init_machine_status = m32c_init_machine_status;\n+}\n+\n+/* Storage Layout */\n+\n+#undef TARGET_PROMOTE_FUNCTION_RETURN\n+#define TARGET_PROMOTE_FUNCTION_RETURN m32c_promote_function_return\n+bool\n+m32c_promote_function_return (tree fntype ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n+/* Register Basics */\n+\n+/* Basic Characteristics of Registers */\n+\n+/* Whether a mode fits in a register is complex enough to warrant a\n+   table.  */\n+static struct\n+{\n+  char qi_regs;\n+  char hi_regs;\n+  char pi_regs;\n+  char si_regs;\n+  char di_regs;\n+} nregs_table[FIRST_PSEUDO_REGISTER] =\n+{\n+  { 1, 1, 2, 2, 4 },\t\t/* r0 */\n+  { 0, 1, 0, 0, 0 },\t\t/* r2 */\n+  { 1, 1, 2, 2, 0 },\t\t/* r1 */\n+  { 0, 1, 0, 0, 0 },\t\t/* r3 */\n+  { 0, 1, 1, 0, 0 },\t\t/* a0 */\n+  { 0, 1, 1, 0, 0 },\t\t/* a1 */\n+  { 0, 1, 1, 0, 0 },\t\t/* sb */\n+  { 0, 1, 1, 0, 0 },\t\t/* fb */\n+  { 0, 1, 1, 0, 0 },\t\t/* sp */\n+  { 1, 1, 1, 0, 0 },\t\t/* pc */\n+  { 0, 0, 0, 0, 0 },\t\t/* fl */\n+  { 1, 1, 1, 0, 0 },\t\t/* ap */\n+  { 1, 1, 2, 2, 4 },\t\t/* mem0 */\n+  { 1, 1, 2, 2, 4 },\t\t/* mem1 */\n+  { 1, 1, 2, 2, 4 },\t\t/* mem2 */\n+  { 1, 1, 2, 2, 4 },\t\t/* mem3 */\n+  { 1, 1, 2, 2, 4 },\t\t/* mem4 */\n+  { 1, 1, 2, 2, 0 },\t\t/* mem5 */\n+  { 1, 1, 2, 2, 0 },\t\t/* mem6 */\n+  { 1, 1, 0, 0, 0 },\t\t/* mem7 */\n+};\n+\n+/* Implements CONDITIONAL_REGISTER_USAGE.  We adjust the number of\n+   available memregs, and select which registers need to be preserved\n+   across calls based on the chip family.  */\n+\n+void\n+m32c_conditional_register_usage (void)\n+{\n+  int memregs;\n+  int i;\n+\n+  if (0 <= target_memregs && target_memregs <= 16)\n+    {\n+      /* The command line option is bytes, but our \"registers\" are\n+\t 16-bit words.  */\n+      for (i = target_memregs/2; i < 8; i++)\n+\t{\n+\t  fixed_regs[MEM0_REGNO + i] = 1;\n+\t  CLEAR_HARD_REG_BIT (reg_class_contents[MEM_REGS], MEM0_REGNO + i);\n+\t}\n+    }\n+\n+  /* M32CM and M32C preserve more registers across function calls.  */\n+  if (TARGET_A24)\n+    {\n+      call_used_regs[R1_REGNO] = 0;\n+      call_used_regs[R2_REGNO] = 0;\n+      call_used_regs[R3_REGNO] = 0;\n+      call_used_regs[A0_REGNO] = 0;\n+      call_used_regs[A1_REGNO] = 0;\n+    }\n+}\n+\n+/* How Values Fit in Registers */\n+\n+/* Implements HARD_REGNO_NREGS.  This is complicated by the fact that\n+   different registers are different sizes from each other, *and* may\n+   be different sizes in different chip families.  */\n+int\n+m32c_hard_regno_nregs (int regno, enum machine_mode mode)\n+{\n+  if (regno == FLG_REGNO && mode == CCmode)\n+    return 1;\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+\n+  if (regno >= MEM0_REGNO && regno <= MEM7_REGNO)\n+    return (GET_MODE_SIZE (mode) + 1) / 2;\n+\n+  if (GET_MODE_SIZE (mode) <= 1)\n+    return nregs_table[regno].qi_regs;\n+  if (GET_MODE_SIZE (mode) <= 2)\n+    return nregs_table[regno].hi_regs;\n+  if (regno == A0_REGNO && mode == PSImode && TARGET_A16)\n+    return 2;\n+  if ((GET_MODE_SIZE (mode) <= 3 || mode == PSImode) && TARGET_A24)\n+    return nregs_table[regno].pi_regs;\n+  if (GET_MODE_SIZE (mode) <= 4)\n+    return nregs_table[regno].si_regs;\n+  if (GET_MODE_SIZE (mode) <= 8)\n+    return nregs_table[regno].di_regs;\n+  return 0;\n+}\n+\n+/* Implements HARD_REGNO_MODE_OK.  The above function does the work\n+   already; just test its return value.  */\n+int\n+m32c_hard_regno_ok (int regno, enum machine_mode mode)\n+{\n+  return m32c_hard_regno_nregs (regno, mode) != 0;\n+}\n+\n+/* Implements MODES_TIEABLE_P.  In general, modes aren't tieable since\n+   registers are all different sizes.  However, since most modes are\n+   bigger than our registers anyway, it's easier to implement this\n+   function that way, leaving QImode as the only unique case.  */\n+int\n+m32c_modes_tieable_p (enum machine_mode m1, enum machine_mode m2)\n+{\n+  if (GET_MODE_SIZE (m1) == GET_MODE_SIZE (m2))\n+    return 1;\n+\n+  if (m1 == QImode || m2 == QImode)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Register Classes */\n+\n+/* Implements REGNO_REG_CLASS.  */\n+enum machine_mode\n+m32c_regno_reg_class (int regno)\n+{\n+  switch (regno)\n+    {\n+    case R0_REGNO:\n+      return R0_REGS;\n+    case R1_REGNO:\n+      return R1_REGS;\n+    case R2_REGNO:\n+      return R2_REGS;\n+    case R3_REGNO:\n+      return R3_REGS;\n+    case A0_REGNO:\n+    case A1_REGNO:\n+      return A_REGS;\n+    case SB_REGNO:\n+      return SB_REGS;\n+    case FB_REGNO:\n+      return FB_REGS;\n+    case SP_REGNO:\n+      return SP_REGS;\n+    case FLG_REGNO:\n+      return FLG_REGS;\n+    default:\n+      if (IS_MEM_REGNO (regno))\n+\treturn MEM_REGS;\n+      return ALL_REGS;\n+    }\n+}\n+\n+/* Implements REG_CLASS_FROM_CONSTRAINT.  Note that some constraints only match\n+   for certain chip families.  */\n+int\n+m32c_reg_class_from_constraint (char c ATTRIBUTE_UNUSED, const char *s)\n+{\n+  if (memcmp (s, \"Rsp\", 3) == 0)\n+    return SP_REGS;\n+  if (memcmp (s, \"Rfb\", 3) == 0)\n+    return FB_REGS;\n+  if (memcmp (s, \"Rsb\", 3) == 0)\n+    return SB_REGS;\n+  if (memcmp (s, \"Rcr\", 3) == 0 && TARGET_A16)\n+    return CR_REGS;\n+  if (memcmp (s, \"Rcl\", 3) == 0 && TARGET_A24)\n+    return CR_REGS;\n+  if (memcmp (s, \"R0w\", 3) == 0)\n+    return R0_REGS;\n+  if (memcmp (s, \"R1w\", 3) == 0)\n+    return R1_REGS;\n+  if (memcmp (s, \"R2w\", 3) == 0)\n+    return R2_REGS;\n+  if (memcmp (s, \"R3w\", 3) == 0)\n+    return R3_REGS;\n+  if (memcmp (s, \"R02\", 3) == 0)\n+    return R02_REGS;\n+  if (memcmp (s, \"R03\", 3) == 0)\n+    return R03_REGS;\n+  if (memcmp (s, \"Rdi\", 3) == 0)\n+    return DI_REGS;\n+  if (memcmp (s, \"Rhl\", 3) == 0)\n+    return HL_REGS;\n+  if (memcmp (s, \"R23\", 3) == 0)\n+    return R23_REGS;\n+  if (memcmp (s, \"Raa\", 3) == 0)\n+    return A_REGS;\n+  if (memcmp (s, \"Raw\", 3) == 0 && TARGET_A16)\n+    return A_REGS;\n+  if (memcmp (s, \"Ral\", 3) == 0 && TARGET_A24)\n+    return A_REGS;\n+  if (memcmp (s, \"Rqi\", 3) == 0)\n+    return QI_REGS;\n+  if (memcmp (s, \"Rad\", 3) == 0)\n+    return AD_REGS;\n+  if (memcmp (s, \"Rsi\", 3) == 0)\n+    return SI_REGS;\n+  if (memcmp (s, \"Rhi\", 3) == 0)\n+    return HI_REGS;\n+  if (memcmp (s, \"Rhc\", 3) == 0)\n+    return HC_REGS;\n+  if (memcmp (s, \"Rra\", 3) == 0)\n+    return RA_REGS;\n+  if (memcmp (s, \"Rfl\", 3) == 0)\n+    return FLG_REGS;\n+  if (memcmp (s, \"Rmm\", 3) == 0)\n+    {\n+      if (fixed_regs[MEM0_REGNO])\n+\treturn NO_REGS;\n+      return MEM_REGS;\n+    }\n+\n+  /* PSImode registers - i.e. whatever can hold a pointer.  */\n+  if (memcmp (s, \"Rpi\", 3) == 0)\n+    {\n+      if (TARGET_A16)\n+\treturn HI_REGS;\n+      else\n+\treturn RA_REGS; /* r2r0 and r3r1 can hold pointers.  */\n+    }\n+\n+  /* We handle this one as an EXTRA_CONSTRAINT.  */\n+  if (memcmp (s, \"Rpa\", 3) == 0)\n+    return NO_REGS;\n+\n+  return NO_REGS;\n+}\n+\n+/* Implements REGNO_OK_FOR_BASE_P.  */\n+int\n+m32c_regno_ok_for_base_p (int regno)\n+{\n+  if (regno == A0_REGNO\n+      || regno == A1_REGNO || regno >= FIRST_PSEUDO_REGISTER)\n+    return 1;\n+  return 0;\n+}\n+\n+#define DEBUG_RELOAD 0\n+\n+/* Implements PREFERRED_RELOAD_CLASS.  In general, prefer general\n+   registers of the appropriate size.  */\n+int\n+m32c_preferred_reload_class (rtx x, int rclass)\n+{\n+  int newclass = rclass;\n+\n+#if DEBUG_RELOAD\n+  fprintf (stderr, \"\\npreferred_reload_class for %s is \",\n+\t   class_names[rclass]);\n+#endif\n+  if (rclass == NO_REGS)\n+    rclass = GET_MODE (x) == QImode ? HL_REGS : R03_REGS;\n+\n+  if (classes_intersect (rclass, CR_REGS))\n+    {\n+      switch (GET_MODE (x))\n+\t{\n+\tcase QImode:\n+\t  newclass = HL_REGS;\n+\t  break;\n+\tdefault:\n+\t  /*      newclass = HI_REGS; */\n+\t  break;\n+\t}\n+    }\n+\n+  else if (newclass == QI_REGS && GET_MODE_SIZE (GET_MODE (x)) > 2)\n+    newclass = SI_REGS;\n+  else if (GET_MODE_SIZE (GET_MODE (x)) > 4\n+\t   && ~class_contents[rclass][0] & 0x000f)\n+    newclass = DI_REGS;\n+\n+  rclass = reduce_class (rclass, newclass, rclass);\n+\n+  if (GET_MODE (x) == QImode)\n+    rclass = reduce_class (rclass, HL_REGS, rclass);\n+\n+#if DEBUG_RELOAD\n+  fprintf (stderr, \"%s\\n\", class_names[rclass]);\n+  debug_rtx (x);\n+\n+  if (GET_CODE (x) == MEM\n+      && GET_CODE (XEXP (x, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS)\n+    fprintf (stderr, \"Glorm!\\n\");\n+#endif\n+  return rclass;\n+}\n+\n+/* Implements PREFERRED_OUTPUT_RELOAD_CLASS.  */\n+int\n+m32c_preferred_output_reload_class (rtx x, int rclass)\n+{\n+  return m32c_preferred_reload_class (x, rclass);\n+}\n+\n+/* Implements LIMIT_RELOAD_CLASS.  We basically want to avoid using\n+   address registers for reloads since they're needed for address\n+   reloads.  */\n+int\n+m32c_limit_reload_class (enum machine_mode mode, int rclass)\n+{\n+#if DEBUG_RELOAD\n+  fprintf (stderr, \"limit_reload_class for %s: %s ->\",\n+\t   mode_name[mode], class_names[rclass]);\n+#endif\n+\n+  if (mode == QImode)\n+    rclass = reduce_class (rclass, HL_REGS, rclass);\n+  else if (mode == HImode)\n+    rclass = reduce_class (rclass, HI_REGS, rclass);\n+  else if (mode == SImode)\n+    rclass = reduce_class (rclass, SI_REGS, rclass);\n+\n+  if (rclass != A_REGS)\n+    rclass = reduce_class (rclass, DI_REGS, rclass);\n+\n+#if DEBUG_RELOAD\n+  fprintf (stderr, \" %s\\n\", class_names[rclass]);\n+#endif\n+  return rclass;\n+}\n+\n+/* Implements SECONDARY_RELOAD_CLASS.  QImode have to be reloaded in\n+   r0 or r1, as those are the only real QImode registers.  CR regs get\n+   reloaded through appropriately sized general or address\n+   registers.  */\n+int\n+m32c_secondary_reload_class (int rclass, enum machine_mode mode, rtx x)\n+{\n+  int cc = class_contents[rclass][0];\n+#if DEBUG0\n+  fprintf (stderr, \"\\nsecondary reload class %s %s\\n\",\n+\t   class_names[rclass], mode_name[mode]);\n+  debug_rtx (x);\n+#endif\n+  if (mode == QImode\n+      && GET_CODE (x) == MEM && (cc & ~class_contents[R23_REGS][0]) == 0)\n+    return QI_REGS;\n+  if (classes_intersect (rclass, CR_REGS)\n+      && GET_CODE (x) == REG\n+      && REGNO (x) >= SB_REGNO && REGNO (x) <= SP_REGNO)\n+    return TARGET_A16 ? HI_REGS : A_REGS;\n+  return NO_REGS;\n+}\n+\n+/* Implements CLASS_LIKELY_SPILLED_P.  A_REGS is needed for address\n+   reloads.  */\n+int\n+m32c_class_likely_spilled_p (int regclass)\n+{\n+  if (regclass == A_REGS)\n+    return 1;\n+  return reg_class_size[regclass] == 1;\n+}\n+\n+/* Implements CLASS_MAX_NREGS.  We calculate this according to its\n+   documented meaning, to avoid potential inconsistencies with actual\n+   class definitions.  */\n+int\n+m32c_class_max_nregs (int regclass, enum machine_mode mode)\n+{\n+  int rn, max = 0;\n+\n+  for (rn = 0; rn < FIRST_PSEUDO_REGISTER; rn++)\n+    if (class_contents[regclass][0] & (1 << rn))\n+      {\n+\tint n = m32c_hard_regno_nregs (rn, mode);\n+\tif (max < n)\n+\t  max = n;\n+      }\n+  return max;\n+}\n+\n+/* Implements CANNOT_CHANGE_MODE_CLASS.  Only r0 and r1 can change to\n+   QI (r0l, r1l) because the chip doesn't support QI ops on other\n+   registers (well, it does on a0/a1 but if we let gcc do that, reload\n+   suffers).  Otherwise, we allow changes to larger modes.  */\n+int\n+m32c_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t       enum machine_mode to, int rclass)\n+{\n+#if DEBUG0\n+  fprintf (stderr, \"cannot change from %s to %s in %s\\n\",\n+\t   mode_name[from], mode_name[to], class_names[rclass]);\n+#endif\n+\n+  if (to == QImode)\n+    return (class_contents[rclass][0] & 0x1ffa);\n+\n+  if (class_contents[rclass][0] & 0x0005\t/* r0, r1 */\n+      && GET_MODE_SIZE (from) > 1)\n+    return 0;\n+  if (GET_MODE_SIZE (from) > 2)\t/* all other regs */\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Helpers for the rest of the file.  */\n+/* TRUE if the rtx is a REG rtx for the given register.  */\n+#define IS_REG(rtx,regno) (GET_CODE (rtx) == REG \\\n+\t\t\t   && REGNO (rtx) == regno)\n+/* TRUE if the rtx is a pseudo - specifically, one we can use as a\n+   base register in address calculations (hence the \"strict\"\n+   argument).  */\n+#define IS_PSEUDO(rtx,strict) (!strict && GET_CODE (rtx) == REG \\\n+\t\t\t       && (REGNO (rtx) == AP_REGNO \\\n+\t\t\t\t   || REGNO (rtx) >= FIRST_PSEUDO_REGISTER))\n+\n+/* Implements CONST_OK_FOR_CONSTRAINT_P.  Currently, all constant\n+   constraints start with 'I', with the next two characters indicating\n+   the type and size of the range allowed.  */\n+int\n+m32c_const_ok_for_constraint_p (HOST_WIDE_INT value,\n+\t\t\t\tchar c ATTRIBUTE_UNUSED, const char *str)\n+{\n+  /* s=signed u=unsigned n=nonzero m=minus l=log2able,\n+     [sun] bits [SUN] bytes, p=pointer size\n+     I[-0-9][0-9] matches that number */\n+  if (memcmp (str, \"Is3\", 3) == 0)\n+    {\n+      return (-8 <= value && value <= 7);\n+    }\n+  if (memcmp (str, \"IS1\", 3) == 0)\n+    {\n+      return (-128 <= value && value <= 127);\n+    }\n+  if (memcmp (str, \"IS2\", 3) == 0)\n+    {\n+      return (-32768 <= value && value <= 32767);\n+    }\n+  if (memcmp (str, \"IU2\", 3) == 0)\n+    {\n+      return (0 <= value && value <= 65535);\n+    }\n+  if (memcmp (str, \"IU3\", 3) == 0)\n+    {\n+      return (0 <= value && value <= 0x00ffffff);\n+    }\n+  if (memcmp (str, \"In4\", 3) == 0)\n+    {\n+      return (-8 <= value && value && value <= 8);\n+    }\n+  if (memcmp (str, \"In5\", 3) == 0)\n+    {\n+      return (-16 <= value && value && value <= 16);\n+    }\n+  if (memcmp (str, \"IM2\", 3) == 0)\n+    {\n+      return (-65536 <= value && value && value <= -1);\n+    }\n+  if (memcmp (str, \"Ilb\", 3) == 0)\n+    {\n+      int b = exact_log2 (value);\n+      return (b >= 1 && b <= 8);\n+    }\n+  if (memcmp (str, \"Ilw\", 3) == 0)\n+    {\n+      int b = exact_log2 (value);\n+      return (b >= 1 && b <= 16);\n+    }\n+  return 0;\n+}\n+\n+/* Implements EXTRA_CONSTRAINT_STR (see next function too).  'S' is\n+   for memory constraints, plus \"Rpa\" for PARALLEL rtx's we use for\n+   call return values.  */\n+int\n+m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n+{\n+  encode_pattern (value);\n+  if (memcmp (str, \"Sd\", 2) == 0)\n+    {\n+      /* This is the common \"src/dest\" address */\n+      rtx r;\n+      if (GET_CODE (value) == MEM && CONSTANT_P (XEXP (value, 0)))\n+\treturn 1;\n+      if (RTX_IS (\"ms\") || RTX_IS (\"m+si\"))\n+\treturn 1;\n+      if (RTX_IS (\"mr\"))\n+\tr = patternr[1];\n+      else if (RTX_IS (\"m+ri\") || RTX_IS (\"m+rs\") || RTX_IS (\"m+r+si\"))\n+\tr = patternr[2];\n+      else\n+\treturn 0;\n+      if (REGNO (r) == SP_REGNO)\n+\treturn 0;\n+      return m32c_legitimate_address_p (GET_MODE (value), XEXP (value, 0), 1);\n+    }\n+  else if (memcmp (str, \"Sa\", 2) == 0)\n+    {\n+      rtx r;\n+      if (RTX_IS (\"mr\"))\n+\tr = patternr[1];\n+      else if (RTX_IS (\"m+ri\"))\n+\tr = patternr[2];\n+      else\n+\treturn 0;\n+      return (IS_REG (r, A0_REGNO) || IS_REG (r, A1_REGNO));\n+    }\n+  else if (memcmp (str, \"Si\", 2) == 0)\n+    {\n+      return (RTX_IS (\"mi\") || RTX_IS (\"ms\") || RTX_IS (\"m+si\"));\n+    }\n+  else if (memcmp (str, \"Ss\", 2) == 0)\n+    {\n+      return ((RTX_IS (\"mr\")\n+\t       && (IS_REG (patternr[1], SP_REGNO)))\n+\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SP_REGNO))));\n+    }\n+  else if (memcmp (str, \"Sf\", 2) == 0)\n+    {\n+      return ((RTX_IS (\"mr\")\n+\t       && (IS_REG (patternr[1], FB_REGNO)))\n+\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], FB_REGNO))));\n+    }\n+  else if (memcmp (str, \"Sb\", 2) == 0)\n+    {\n+      return ((RTX_IS (\"mr\")\n+\t       && (IS_REG (patternr[1], SB_REGNO)))\n+\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SB_REGNO))));\n+    }\n+  else if (memcmp (str, \"S1\", 2) == 0)\n+    {\n+      return r1h_operand (value, QImode);\n+    }\n+\n+  gcc_assert (str[0] != 'S');\n+\n+  if (memcmp (str, \"Rpa\", 2) == 0)\n+    return GET_CODE (value) == PARALLEL;\n+\n+  return 0;\n+}\n+\n+/* This is for when we're debugging the above.  */\n+int\n+m32c_extra_constraint_p (rtx value, char c, const char *str)\n+{\n+  int rv = m32c_extra_constraint_p2 (value, c, str);\n+#if DEBUG0\n+  fprintf (stderr, \"\\nconstraint %.*s: %d\\n\", CONSTRAINT_LEN (c, str), str,\n+\t   rv);\n+  debug_rtx (value);\n+#endif\n+  return rv;\n+}\n+\n+/* Implements EXTRA_MEMORY_CONSTRAINT.  Currently, we only use strings\n+   starting with 'S'.  */\n+int\n+m32c_extra_memory_constraint (char c, const char *str ATTRIBUTE_UNUSED)\n+{\n+  return c == 'S';\n+}\n+\n+/* Implements EXTRA_ADDRESS_CONSTRAINT.  We reserve 'A' strings for these,\n+   but don't currently define any.  */\n+int\n+m32c_extra_address_constraint (char c, const char *str ATTRIBUTE_UNUSED)\n+{\n+  return c == 'A';\n+}\n+\n+/* STACK AND CALLING */\n+\n+/* Frame Layout */\n+\n+/* Implements RETURN_ADDR_RTX.  Note that R8C and M16C push 24 bits\n+   (yes, THREE bytes) onto the stack for the return address, but we\n+   don't support pointers bigger than 16 bits on those chips.  This\n+   will likely wreak havoc with exception unwinding.  FIXME.  */\n+rtx\n+m32c_return_addr_rtx (int count)\n+{\n+  enum machine_mode mode;\n+  int offset;\n+  rtx ra_mem;\n+\n+  if (count)\n+    return NULL_RTX;\n+  /* we want 2[$fb] */\n+\n+  if (TARGET_A24)\n+    {\n+      mode = SImode;\n+      offset = 4;\n+    }\n+  else\n+    {\n+      /* FIXME: it's really 3 bytes */\n+      mode = HImode;\n+      offset = 2;\n+    }\n+\n+  ra_mem =\n+    gen_rtx_MEM (mode, plus_constant (gen_rtx_REG (Pmode, FP_REGNO), offset));\n+  return copy_to_mode_reg (mode, ra_mem);\n+}\n+\n+/* Implements INCOMING_RETURN_ADDR_RTX.  See comment above.  */\n+rtx\n+m32c_incoming_return_addr_rtx (void)\n+{\n+  /* we want [sp] */\n+  return gen_rtx_MEM (PSImode, gen_rtx_REG (PSImode, SP_REGNO));\n+}\n+\n+/* Exception Handling Support */\n+\n+/* Implements EH_RETURN_DATA_REGNO.  Choose registers able to hold\n+   pointers.  */\n+int\n+m32c_eh_return_data_regno (int n)\n+{\n+  switch (n)\n+    {\n+    case 0:\n+      return A0_REGNO;\n+    case 1:\n+      return A1_REGNO;\n+    default:\n+      return INVALID_REGNUM;\n+    }\n+}\n+\n+/* Implements EH_RETURN_STACKADJ_RTX.  Saved and used later in\n+   m32c_emit_eh_epilogue.  */\n+rtx\n+m32c_eh_return_stackadj_rtx (void)\n+{\n+  if (!cfun->machine->eh_stack_adjust)\n+    {\n+      rtx sa;\n+\n+      sa = gen_reg_rtx (Pmode);\n+      cfun->machine->eh_stack_adjust = sa;\n+    }\n+  return cfun->machine->eh_stack_adjust;\n+}\n+\n+/* Registers That Address the Stack Frame */\n+\n+/* Implements DWARF_FRAME_REGNUM and DBX_REGISTER_NUMBER.  Note that\n+   the original spec called for dwarf numbers to vary with register\n+   width as well, for example, r0l, r0, and r2r0 would each have\n+   different dwarf numbers.  GCC doesn't support this, and we don't do\n+   it, and gdb seems to like it this way anyway.  */\n+unsigned int\n+m32c_dwarf_frame_regnum (int n)\n+{\n+  switch (n)\n+    {\n+    case R0_REGNO:\n+      return 5;\n+    case R1_REGNO:\n+      return 6;\n+    case R2_REGNO:\n+      return 7;\n+    case R3_REGNO:\n+      return 8;\n+    case A0_REGNO:\n+      return 9;\n+    case A1_REGNO:\n+      return 10;\n+    case FB_REGNO:\n+      return 11;\n+    case SB_REGNO:\n+      return 19;\n+\n+    case SP_REGNO:\n+      return 12;\n+    case PC_REGNO:\n+      return 13;\n+    default:\n+      return DWARF_FRAME_REGISTERS + 1;\n+    }\n+}\n+\n+/* The frame looks like this:\n+\n+   ap -> +------------------------------\n+         | Return address (3 or 4 bytes)\n+\t | Saved FB (2 or 4 bytes)\n+   fb -> +------------------------------\n+\t | local vars\n+         | register saves fb\n+\t |        through r0 as needed\n+   sp -> +------------------------------\n+*/\n+\n+/* We use this to wrap all emitted insns in the prologue.  */\n+static rtx\n+F (rtx x)\n+{\n+  RTX_FRAME_RELATED_P (x) = 1;\n+  return x;\n+}\n+\n+/* This maps register numbers to the PUSHM/POPM bitfield, and tells us\n+   how much the stack pointer moves for each, for each cpu family.  */\n+static struct\n+{\n+  int reg1;\n+  int bit;\n+  int a16_bytes;\n+  int a24_bytes;\n+} pushm_info[] =\n+{\n+  /* These are in push order.  */\n+  { FB_REGNO, 0x01, 2, 4 },\n+  { SB_REGNO, 0x02, 2, 4 },\n+  { A1_REGNO, 0x04, 2, 4 },\n+  { A0_REGNO, 0x08, 2, 4 },\n+  { R3_REGNO, 0x10, 2, 2 },\n+  { R2_REGNO, 0x20, 2, 2 },\n+  { R1_REGNO, 0x40, 2, 2 },\n+  { R0_REGNO, 0x80, 2, 2 }\n+};\n+\n+#define PUSHM_N (sizeof(pushm_info)/sizeof(pushm_info[0]))\n+\n+/* Returns TRUE if we need to save/restore the given register.  We\n+   save everything for exception handlers, so that any register can be\n+   unwound.  For interrupt handlers, we save everything if the handler\n+   calls something else (because we don't know what *that* function\n+   might do), but try to be a bit smarter if the handler is a leaf\n+   function.  We always save $a0, though, because we use that in the\n+   epilog to copy $fb to $sp.  */\n+static int\n+need_to_save (int regno)\n+{\n+  if (fixed_regs[regno])\n+    return 0;\n+  if (cfun->calls_eh_return)\n+    return 1;\n+  if (regno == FP_REGNO)\n+    return 0;\n+  if (cfun->machine->is_interrupt\n+      && (!cfun->machine->is_leaf || regno == A0_REGNO))\n+    return 1;\n+  if (regs_ever_live[regno]\n+      && (!call_used_regs[regno] || cfun->machine->is_interrupt))\n+    return 1;\n+  return 0;\n+}\n+\n+/* This function contains all the intelligence about saving and\n+   restoring registers.  It always figures out the register save set.\n+   When called with PP_justcount, it merely returns the size of the\n+   save set (for eliminating the frame pointer, for example).  When\n+   called with PP_pushm or PP_popm, it emits the appropriate\n+   instructions for saving (pushm) or restoring (popm) the\n+   registers.  */\n+static int\n+m32c_pushm_popm (Push_Pop_Type ppt)\n+{\n+  int reg_mask = 0;\n+  int byte_count = 0, bytes;\n+  int i;\n+  rtx dwarf_set[PUSHM_N];\n+  int n_dwarfs = 0;\n+  int nosave_mask = 0;\n+\n+  if (cfun->return_rtx\n+      && GET_CODE (cfun->return_rtx) == PARALLEL\n+      && !(cfun->calls_eh_return || cfun->machine->is_interrupt))\n+    {\n+      rtx exp = XVECEXP (cfun->return_rtx, 0, 0);\n+      rtx rv = XEXP (exp, 0);\n+      int rv_bytes = GET_MODE_SIZE (GET_MODE (rv));\n+\n+      if (rv_bytes > 2)\n+\tnosave_mask |= 0x20;\t/* PSI, SI */\n+      else\n+\tnosave_mask |= 0xf0;\t/* DF */\n+      if (rv_bytes > 4)\n+\tnosave_mask |= 0x50;\t/* DI */\n+    }\n+\n+  for (i = 0; i < (int) PUSHM_N; i++)\n+    {\n+      /* Skip if neither register needs saving.  */\n+      if (!need_to_save (pushm_info[i].reg1))\n+\tcontinue;\n+\n+      if (pushm_info[i].bit & nosave_mask)\n+\tcontinue;\n+\n+      reg_mask |= pushm_info[i].bit;\n+      bytes = TARGET_A16 ? pushm_info[i].a16_bytes : pushm_info[i].a24_bytes;\n+\n+      if (ppt == PP_pushm)\n+\t{\n+\t  enum machine_mode mode = (bytes == 2) ? HImode : SImode;\n+\t  rtx addr;\n+\n+\t  /* Always use stack_pointer_rtx instead of calling\n+\t     rtx_gen_REG ourselves.  Code elsewhere in GCC assumes\n+\t     that there is a single rtx representing the stack pointer,\n+\t     namely stack_pointer_rtx, and uses == to recognize it.  */\n+\t  addr = stack_pointer_rtx;\n+\n+\t  if (byte_count != 0)\n+\t    addr = gen_rtx_PLUS (GET_MODE (addr), addr, GEN_INT (byte_count));\n+\n+\t  dwarf_set[n_dwarfs++] =\n+\t    gen_rtx_SET (VOIDmode,\n+\t\t\t gen_rtx_MEM (mode, addr),\n+\t\t\t gen_rtx_REG (mode, pushm_info[i].reg1));\n+\t  F (dwarf_set[n_dwarfs - 1]);\n+\n+\t}\n+      byte_count += bytes;\n+    }\n+\n+  if (cfun->machine->is_interrupt)\n+    {\n+      cfun->machine->intr_pushm = reg_mask & 0xfe;\n+      reg_mask = 0;\n+      byte_count = 0;\n+    }\n+\n+  if (cfun->machine->is_interrupt)\n+    for (i = MEM0_REGNO; i <= MEM7_REGNO; i++)\n+      if (need_to_save (i))\n+\t{\n+\t  byte_count += 2;\n+\t  cfun->machine->intr_pushmem[i - MEM0_REGNO] = 1;\n+\t}\n+\n+  if (ppt == PP_pushm && byte_count)\n+    {\n+      rtx note = gen_rtx_SEQUENCE (VOIDmode, rtvec_alloc (n_dwarfs + 1));\n+      rtx pushm;\n+\n+      if (reg_mask)\n+\t{\n+\t  XVECEXP (note, 0, 0)\n+\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t   stack_pointer_rtx,\n+\t\t\t   gen_rtx_PLUS (GET_MODE (stack_pointer_rtx),\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (-byte_count)));\n+\t  F (XVECEXP (note, 0, 0));\n+\n+\t  for (i = 0; i < n_dwarfs; i++)\n+\t    XVECEXP (note, 0, i + 1) = dwarf_set[i];\n+\n+\t  pushm = F (emit_insn (gen_pushm (GEN_INT (reg_mask))));\n+\n+\t  REG_NOTES (pushm) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, note,\n+\t\t\t\t\t\t REG_NOTES (pushm));\n+\t}\n+\n+      if (cfun->machine->is_interrupt)\n+\tfor (i = MEM0_REGNO; i <= MEM7_REGNO; i++)\n+\t  if (cfun->machine->intr_pushmem[i - MEM0_REGNO])\n+\t    {\n+\t      if (TARGET_A16)\n+\t\tpushm = emit_insn (gen_pushhi_16 (gen_rtx_REG (HImode, i)));\n+\t      else\n+\t\tpushm = emit_insn (gen_pushhi_24 (gen_rtx_REG (HImode, i)));\n+\t      F (pushm);\n+\t    }\n+    }\n+  if (ppt == PP_popm && byte_count)\n+    {\n+      rtx insn;\n+\n+      if (cfun->machine->is_interrupt)\n+\tfor (i = MEM7_REGNO; i >= MEM0_REGNO; i--)\n+\t  if (cfun->machine->intr_pushmem[i - MEM0_REGNO])\n+\t    {\n+\t      if (TARGET_A16)\n+\t\tinsn = emit_insn (gen_pophi_16 (gen_rtx_REG (HImode, i)));\n+\t      else\n+\t\tinsn = emit_insn (gen_pophi_24 (gen_rtx_REG (HImode, i)));\n+\t      F (insn);\n+\t    }\n+      if (reg_mask)\n+\temit_insn (gen_popm (GEN_INT (reg_mask)));\n+    }\n+\n+  return byte_count;\n+}\n+\n+/* Implements INITIAL_ELIMINATION_OFFSET.  See the comment above that\n+   diagrams our call frame.  */\n+int\n+m32c_initial_elimination_offset (int from, int to)\n+{\n+  int ofs = 0;\n+\n+  if (from == AP_REGNO)\n+    {\n+      if (TARGET_A16)\n+\tofs += 5;\n+      else\n+\tofs += 8;\n+    }\n+\n+  if (to == SP_REGNO)\n+    {\n+      ofs += m32c_pushm_popm (PP_justcount);\n+      ofs += get_frame_size ();\n+    }\n+\n+  /* Account for push rounding.  */\n+  if (TARGET_A24)\n+    ofs = (ofs + 1) & ~1;\n+#if DEBUG0\n+  fprintf (stderr, \"initial_elimination_offset from=%d to=%d, ofs=%d\\n\", from,\n+\t   to, ofs);\n+#endif\n+  return ofs;\n+}\n+\n+/* Passing Function Arguments on the Stack */\n+\n+#undef TARGET_PROMOTE_PROTOTYPES\n+#define TARGET_PROMOTE_PROTOTYPES m32c_promote_prototypes\n+static bool\n+m32c_promote_prototypes (tree fntype ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+/* Implements PUSH_ROUNDING.  The R8C and M16C have byte stacks, the\n+   M32C has word stacks.  */\n+int\n+m32c_push_rounding (int n)\n+{\n+  if (TARGET_R8C || TARGET_M16C)\n+    return n;\n+  return (n + 1) & ~1;\n+}\n+\n+/* Passing Arguments in Registers */\n+\n+/* Implements FUNCTION_ARG.  Arguments are passed partly in registers,\n+   partly on stack.  If our function returns a struct, a pointer to a\n+   buffer for it is at the top of the stack (last thing pushed).  The\n+   first few real arguments may be in registers as follows:\n+\n+   R8C/M16C:\targ1 in r1 if it's QI or HI (else it's pushed on stack)\n+\t\targ2 in r2 if it's HI (else pushed on stack)\n+\t\trest on stack\n+   M32C:        arg1 in r0 if it's QI or HI (else it's pushed on stack)\n+\t\trest on stack\n+\n+   Structs are not passed in registers, even if they fit.  Only\n+   integer and pointer types are passed in registers.\n+\n+   Note that when arg1 doesn't fit in r1, arg2 may still be passed in\n+   r2 if it fits.  */\n+rtx\n+m32c_function_arg (CUMULATIVE_ARGS * ca,\n+\t\t   enum machine_mode mode, tree type, int named)\n+{\n+  /* Can return a reg, parallel, or 0 for stack */\n+  rtx rv = NULL_RTX;\n+#if DEBUG0\n+  fprintf (stderr, \"func_arg %d (%s, %d)\\n\",\n+\t   ca->parm_num, mode_name[mode], named);\n+  debug_tree (type);\n+#endif\n+\n+  if (mode == VOIDmode)\n+    return GEN_INT (0);\n+\n+  if (ca->force_mem || !named)\n+    {\n+#if DEBUG0\n+      fprintf (stderr, \"func arg: force %d named %d, mem\\n\", ca->force_mem,\n+\t       named);\n+#endif\n+      return NULL_RTX;\n+    }\n+\n+  if (type && INTEGRAL_TYPE_P (type) && POINTER_TYPE_P (type))\n+    return NULL_RTX;\n+\n+  switch (ca->parm_num)\n+    {\n+    case 1:\n+      if (GET_MODE_SIZE (mode) == 1 || GET_MODE_SIZE (mode) == 2)\n+\trv = gen_rtx_REG (mode, TARGET_A16 ? R1_REGNO : R0_REGNO);\n+      break;\n+\n+    case 2:\n+      if (TARGET_A16 && GET_MODE_SIZE (mode) == 2)\n+\trv = gen_rtx_REG (mode, R2_REGNO);\n+      break;\n+    }\n+\n+#if DEBUG0\n+  debug_rtx (rv);\n+#endif\n+  return rv;\n+}\n+\n+#undef TARGET_PASS_BY_REFERENCE\n+#define TARGET_PASS_BY_REFERENCE m32c_pass_by_reference\n+static bool\n+m32c_pass_by_reference (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\ttree type ATTRIBUTE_UNUSED,\n+\t\t\tbool named ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+/* Implements INIT_CUMULATIVE_ARGS.  */\n+void\n+m32c_init_cumulative_args (CUMULATIVE_ARGS * ca,\n+\t\t\t   tree fntype ATTRIBUTE_UNUSED,\n+\t\t\t   rtx libname ATTRIBUTE_UNUSED,\n+\t\t\t   tree fndecl ATTRIBUTE_UNUSED,\n+\t\t\t   int n_named_args ATTRIBUTE_UNUSED)\n+{\n+  ca->force_mem = 0;\n+  ca->parm_num = 1;\n+}\n+\n+/* Implements FUNCTION_ARG_ADVANCE.  force_mem is set for functions\n+   returning structures, so we always reset that.  Otherwise, we only\n+   need to know the sequence number of the argument to know what to do\n+   with it.  */\n+void\n+m32c_function_arg_advance (CUMULATIVE_ARGS * ca,\n+\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   tree type ATTRIBUTE_UNUSED,\n+\t\t\t   int named ATTRIBUTE_UNUSED)\n+{\n+  if (ca->force_mem)\n+    ca->force_mem = 0;\n+  ca->parm_num++;\n+}\n+\n+/* Implements FUNCTION_ARG_REGNO_P.  */\n+int\n+m32c_function_arg_regno_p (int r)\n+{\n+  if (TARGET_A24)\n+    return (r == R0_REGNO);\n+  return (r == R1_REGNO || r == R2_REGNO);\n+}\n+\n+/* How Scalar Function Values Are Returned */\n+\n+/* Implements LIBCALL_VALUE.  Most values are returned in $r0, or some\n+   combination of registers starting there (r2r0 for longs, r3r1r2r0\n+   for long long, r3r2r1r0 for doubles), except that that ABI\n+   currently doesn't work because it ends up using all available\n+   general registers and gcc often can't compile it.  So, instead, we\n+   return anything bigger than 16 bits in \"mem0\" (effectively, a\n+   memory location).  */\n+rtx\n+m32c_libcall_value (enum machine_mode mode)\n+{\n+  /* return reg or parallel */\n+#if 0\n+  /* FIXME: GCC has difficulty returning large values in registers,\n+     because that ties up most of the general registers and gives the\n+     register allocator little to work with.  Until we can resolve\n+     this, large values are returned in memory.  */\n+  if (mode == DFmode)\n+    {\n+      rtx rv;\n+\n+      rv = gen_rtx_PARALLEL (mode, rtvec_alloc (4));\n+      XVECEXP (rv, 0, 0) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (HImode,\n+\t\t\t\t\t\t\t   R0_REGNO),\n+\t\t\t\t\t      GEN_INT (0));\n+      XVECEXP (rv, 0, 1) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (HImode,\n+\t\t\t\t\t\t\t   R1_REGNO),\n+\t\t\t\t\t      GEN_INT (2));\n+      XVECEXP (rv, 0, 2) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (HImode,\n+\t\t\t\t\t\t\t   R2_REGNO),\n+\t\t\t\t\t      GEN_INT (4));\n+      XVECEXP (rv, 0, 3) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (HImode,\n+\t\t\t\t\t\t\t   R3_REGNO),\n+\t\t\t\t\t      GEN_INT (6));\n+      return rv;\n+    }\n+\n+  if (TARGET_A24 && GET_MODE_SIZE (mode) > 2)\n+    {\n+      rtx rv;\n+\n+      rv = gen_rtx_PARALLEL (mode, rtvec_alloc (1));\n+      XVECEXP (rv, 0, 0) = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (mode,\n+\t\t\t\t\t\t\t   R0_REGNO),\n+\t\t\t\t\t      GEN_INT (0));\n+      return rv;\n+    }\n+#endif\n+\n+  if (GET_MODE_SIZE (mode) > 2)\n+    return gen_rtx_REG (mode, MEM0_REGNO);\n+  return gen_rtx_REG (mode, R0_REGNO);\n+}\n+\n+/* Implements FUNCTION_VALUE.  Functions and libcalls have the same\n+   conventions.  */\n+rtx\n+m32c_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n+{\n+  /* return reg or parallel */\n+  enum machine_mode mode = TYPE_MODE (valtype);\n+  return m32c_libcall_value (mode);\n+}\n+\n+/* How Large Values Are Returned */\n+\n+/* We return structures by pushing the address on the stack, even if\n+   we use registers for the first few \"real\" arguments.  */\n+#undef TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX m32c_struct_value_rtx\n+static rtx\n+m32c_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n+\t\t       int incoming ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+/* Function Entry and Exit */\n+\n+/* Implements EPILOGUE_USES.  Interrupts restore all registers.  */\n+int\n+m32c_epilogue_uses (int regno ATTRIBUTE_UNUSED)\n+{\n+  if (cfun->machine->is_interrupt)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Implementing the Varargs Macros */\n+\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING m32c_strict_argument_naming\n+static bool\n+m32c_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+/* Trampolines for Nested Functions */\n+\n+/*\n+   m16c:\n+   1 0000 75C43412              mov.w   #0x1234,a0\n+   2 0004 FC000000              jmp.a   label\n+\n+   m32c:\n+   1 0000 BC563412              mov.l:s #0x123456,a0\n+   2 0004 CC000000              jmp.a   label\n+*/\n+\n+/* Implements TRAMPOLINE_SIZE.  */\n+int\n+m32c_trampoline_size (void)\n+{\n+  /* Allocate extra space so we can avoid the messy shifts when we\n+     initialize the trampoline; we just write past the end of the\n+     opcode.  */\n+  return TARGET_A16 ? 8 : 10;\n+}\n+\n+/* Implements TRAMPOLINE_ALIGNMENT.  */\n+int\n+m32c_trampoline_alignment (void)\n+{\n+  return 2;\n+}\n+\n+/* Implements INITIALIZE_TRAMPOLINE.  */\n+void\n+m32c_initialize_trampoline (rtx tramp, rtx function, rtx chainval)\n+{\n+#define A0(m,i) gen_rtx_MEM (m, plus_constant (tramp, i))\n+  if (TARGET_A16)\n+    {\n+      /* Note: we subtract a \"word\" because the moves want signed\n+\t constants, not unsigned constants.  */\n+      emit_move_insn (A0 (HImode, 0), GEN_INT (0xc475 - 0x10000));\n+      emit_move_insn (A0 (HImode, 2), chainval);\n+      emit_move_insn (A0 (QImode, 4), GEN_INT (0xfc - 0x100));\n+      /* We use 16 bit addresses here, but store the zero to turn it\n+\t into a 24 bit offset.  */\n+      emit_move_insn (A0 (HImode, 5), function);\n+      emit_move_insn (A0 (QImode, 7), GEN_INT (0x00));\n+    }\n+  else\n+    {\n+      /* Note that the PSI moves actually write 4 bytes.  Make sure we\n+\t write stuff out in the right order, and leave room for the\n+\t extra byte at the end.  */\n+      emit_move_insn (A0 (QImode, 0), GEN_INT (0xbc - 0x100));\n+      emit_move_insn (A0 (PSImode, 1), chainval);\n+      emit_move_insn (A0 (QImode, 4), GEN_INT (0xcc - 0x100));\n+      emit_move_insn (A0 (PSImode, 5), function);\n+    }\n+#undef A0\n+}\n+\n+/* Addressing Modes */\n+\n+/* Used by GO_IF_LEGITIMATE_ADDRESS.  The r8c/m32c family supports a\n+   wide range of non-orthogonal addressing modes, including the\n+   ability to double-indirect on *some* of them.  Not all insns\n+   support all modes, either, but we rely on predicates and\n+   constraints to deal with that.  */\n+int\n+m32c_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+{\n+  int mode_adjust;\n+  if (CONSTANT_P (x))\n+    return 1;\n+\n+  /* Wide references to memory will be split after reload, so we must\n+     ensure that all parts of such splits remain legitimate\n+     addresses.  */\n+  mode_adjust = GET_MODE_SIZE (mode) - 1;\n+\n+  /* allowing PLUS yields mem:HI(plus:SI(mem:SI(plus:SI in m32c_split_move */\n+  if (GET_CODE (x) == PRE_DEC\n+      || GET_CODE (x) == POST_INC || GET_CODE (x) == PRE_MODIFY)\n+    {\n+      return (GET_CODE (XEXP (x, 0)) == REG\n+\t      && REGNO (XEXP (x, 0)) == SP_REGNO);\n+    }\n+\n+#if 0\n+  /* This is the double indirection detection, but it currently\n+     doesn't work as cleanly as this code implies, so until we've had\n+     a chance to debug it, leave it disabled.  */\n+  if (TARGET_A24 && GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) != PLUS)\n+    {\n+#if DEBUG_DOUBLE\n+      fprintf (stderr, \"double indirect\\n\");\n+#endif\n+      x = XEXP (x, 0);\n+    }\n+#endif\n+\n+  encode_pattern (x);\n+  if (RTX_IS (\"r\"))\n+    {\n+      /* Most indexable registers can be used without displacements,\n+\t although some of them will be emitted with an explicit zero\n+\t to please the assembler.  */\n+      switch (REGNO (patternr[0]))\n+\t{\n+\tcase A0_REGNO:\n+\tcase A1_REGNO:\n+\tcase SB_REGNO:\n+\tcase FB_REGNO:\n+\tcase SP_REGNO:\n+\t  return 1;\n+\n+\tdefault:\n+\t  if (IS_PSEUDO (patternr[0], strict))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+    }\n+  if (RTX_IS (\"+ri\"))\n+    {\n+      /* This is more interesting, because different base registers\n+\t allow for different displacements - both range and signedness\n+\t - and it differs from chip series to chip series too.  */\n+      int rn = REGNO (patternr[1]);\n+      HOST_WIDE_INT offs = INTVAL (patternr[2]);\n+      switch (rn)\n+\t{\n+\tcase A0_REGNO:\n+\tcase A1_REGNO:\n+\tcase SB_REGNO:\n+\t  /* The syntax only allows positive offsets, but when the\n+\t     offsets span the entire memory range, we can simulate\n+\t     negative offsets by wrapping.  */\n+\t  if (TARGET_A16)\n+\t    return (offs >= -65536 && offs <= 65535 - mode_adjust);\n+\t  if (rn == SB_REGNO)\n+\t    return (offs >= 0 && offs <= 65535 - mode_adjust);\n+\t  /* A0 or A1 */\n+\t  return (offs >= -16777216 && offs <= 16777215);\n+\n+\tcase FB_REGNO:\n+\t  if (TARGET_A16)\n+\t    return (offs >= -128 && offs <= 127 - mode_adjust);\n+\t  return (offs >= -65536 && offs <= 65535 - mode_adjust);\n+\n+\tcase SP_REGNO:\n+\t  return (offs >= -128 && offs <= 127 - mode_adjust);\n+\n+\tdefault:\n+\t  if (IS_PSEUDO (patternr[1], strict))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+    }\n+  if (RTX_IS (\"+rs\") || RTX_IS (\"+r+si\"))\n+    {\n+      rtx reg = patternr[1];\n+\n+      /* We don't know where the symbol is, so only allow base\n+\t registers which support displacements spanning the whole\n+\t address range.  */\n+      switch (REGNO (reg))\n+\t{\n+\tcase A0_REGNO:\n+\tcase A1_REGNO:\n+\t  /* $sb needs a secondary reload, but since it's involved in\n+\t     memory address reloads too, we don't deal with it very\n+\t     well.  */\n+\t  /*    case SB_REGNO: */\n+\t  return 1;\n+\tdefault:\n+\t  if (IS_PSEUDO (reg, strict))\n+\t    return 1;\n+\t  return 0;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Implements REG_OK_FOR_BASE_P.  */\n+int\n+m32c_reg_ok_for_base_p (rtx x, int strict)\n+{\n+  if (GET_CODE (x) != REG)\n+    return 0;\n+  switch (REGNO (x))\n+    {\n+    case A0_REGNO:\n+    case A1_REGNO:\n+    case SB_REGNO:\n+    case FB_REGNO:\n+    case SP_REGNO:\n+      return 1;\n+    default:\n+      if (IS_PSEUDO (x, strict))\n+\treturn 1;\n+      return 0;\n+    }\n+}\n+\n+/* Implements LEGITIMIZE_ADDRESS.  The only address we really have to\n+   worry about is frame base offsets, as $fb has a limited\n+   displacement range.  We deal with this by attempting to reload $fb\n+   itself into an address register; that seems to result in the best\n+   code.  */\n+int\n+m32c_legitimize_address (rtx * x ATTRIBUTE_UNUSED,\n+\t\t\t rtx oldx ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+#if DEBUG0\n+  fprintf (stderr, \"m32c_legitimize_address for mode %s\\n\", mode_name[mode]);\n+  debug_rtx (*x);\n+  fprintf (stderr, \"\\n\");\n+#endif\n+\n+  if (GET_CODE (*x) == PLUS\n+      && GET_CODE (XEXP (*x, 0)) == REG\n+      && REGNO (XEXP (*x, 0)) == FB_REGNO\n+      && GET_CODE (XEXP (*x, 1)) == CONST_INT\n+      && (INTVAL (XEXP (*x, 1)) < -128\n+\t  || INTVAL (XEXP (*x, 1)) > (128 - GET_MODE_SIZE (mode))))\n+    {\n+      /* reload FB to A_REGS */\n+      rtx foo;\n+      rtx temp = gen_reg_rtx (Pmode);\n+      *x = copy_rtx (*x);\n+      foo = emit_insn (gen_rtx_SET (VOIDmode, temp, XEXP (*x, 0)));\n+      XEXP (*x, 0) = temp;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Implements LEGITIMIZE_RELOAD_ADDRESS.  See comment above.  */\n+int\n+m32c_legitimize_reload_address (rtx * x,\n+\t\t\t\tenum machine_mode mode,\n+\t\t\t\tint opnum,\n+\t\t\t\tint type, int ind_levels ATTRIBUTE_UNUSED)\n+{\n+#if DEBUG0\n+  fprintf (stderr, \"\\nm32c_legitimize_reload_address for mode %s\\n\",\n+\t   mode_name[mode]);\n+  debug_rtx (*x);\n+#endif\n+\n+  /* At one point, this function tried to get $fb copied to an address\n+     register, which in theory would maximize sharing, but gcc was\n+     *also* still trying to reload the whole address, and we'd run out\n+     of address registers.  So we let gcc do the naive (but safe)\n+     reload instead, when the above function doesn't handle it for\n+     us.  */\n+\n+  return 0;\n+}\n+\n+/* Used in GO_IF_MODE_DEPENDENT_ADDRESS.  */\n+int\n+m32c_mode_dependent_address (rtx addr)\n+{\n+  if (GET_CODE (addr) == POST_INC || GET_CODE (addr) == PRE_DEC)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Implements LEGITIMATE_CONSTANT_P.  We split large constants anyway,\n+   so we can allow anything.  */\n+int\n+m32c_legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+\n+/* Condition Code Status */\n+\n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS m32c_fixed_condition_code_regs\n+static bool\n+m32c_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = FLG_REGNO;\n+  *p2 = INVALID_REGNUM;\n+  return true;\n+}\n+\n+/* Describing Relative Costs of Operations */\n+\n+/* Implements REGISTER_MOVE_COST.  We make impossible moves\n+   prohibitively expensive, like trying to put QIs in r2/r3 (there are\n+   no opcodes to do that).  We also discourage use of mem* registers\n+   since they're really memory.  */\n+int\n+m32c_register_move_cost (enum machine_mode mode, int from, int to)\n+{\n+  int cost = COSTS_N_INSNS (3);\n+  int cc = class_contents[from][0] | class_contents[to][0];\n+  /* FIXME: pick real values, but not 2 for now.  */\n+  if (mode == QImode && (cc & class_contents[R23_REGS][0]))\n+    {\n+      if (!(cc & ~class_contents[R23_REGS][0]))\n+\tcost = COSTS_N_INSNS (1000);\n+      else\n+\tcost = COSTS_N_INSNS (80);\n+    }\n+\n+  if (!class_can_hold_mode (from, mode) || !class_can_hold_mode (to, mode))\n+    cost = COSTS_N_INSNS (1000);\n+\n+  if (classes_intersect (from, CR_REGS))\n+    cost += COSTS_N_INSNS (5);\n+\n+  if (classes_intersect (to, CR_REGS))\n+    cost += COSTS_N_INSNS (5);\n+\n+  if (from == MEM_REGS || to == MEM_REGS)\n+    cost += COSTS_N_INSNS (50);\n+  else if (classes_intersect (from, MEM_REGS)\n+\t   || classes_intersect (to, MEM_REGS))\n+    cost += COSTS_N_INSNS (10);\n+\n+#if DEBUG0\n+  fprintf (stderr, \"register_move_cost %s from %s to %s = %d\\n\",\n+\t   mode_name[mode], class_names[from], class_names[to], cost);\n+#endif\n+  return cost;\n+}\n+\n+/*  Implements MEMORY_MOVE_COST.  */\n+int\n+m32c_memory_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       int reg_class ATTRIBUTE_UNUSED,\n+\t\t       int in ATTRIBUTE_UNUSED)\n+{\n+  /* FIXME: pick real values.  */\n+  return COSTS_N_INSNS (10);\n+}\n+\n+/* Defining the Output Assembler Language */\n+\n+/* The Overall Framework of an Assembler File */\n+\n+#undef TARGET_HAVE_NAMED_SECTIONS\n+#define TARGET_HAVE_NAMED_SECTIONS true\n+\n+/* Output of Data */\n+\n+/* We may have 24 bit sizes, which is the native address size.\n+   Currently unused, but provided for completeness.  */\n+#undef TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER m32c_asm_integer\n+static bool\n+m32c_asm_integer (rtx x, unsigned int size, int aligned_p)\n+{\n+  switch (size)\n+    {\n+    case 3:\n+      fprintf (asm_out_file, \"\\t.3byte\\t\");\n+      output_addr_const (asm_out_file, x);\n+      fputc ('\\n', asm_out_file);\n+      return true;\n+    }\n+  return default_assemble_integer (x, size, aligned_p);\n+}\n+\n+/* Output of Assembler Instructions */\n+\n+/* We use a lookup table because the addressing modes are non-orthagonal.  */\n+\n+static struct\n+{\n+  char code;\n+  char const *pattern;\n+  char const *format;\n+}\n+const conversions[] = {\n+  { 0, \"r\", \"0\" },\n+\n+  { 0, \"mr\", \"z[1]\" },\n+  { 0, \"m+ri\", \"3[2]\" },\n+  { 0, \"m+rs\", \"3[2]\" },\n+  { 0, \"m+r+si\", \"4+5[2]\" },\n+  { 0, \"ms\", \"1\" },\n+  { 0, \"mi\", \"1\" },\n+  { 0, \"m+si\", \"2+3\" },\n+\n+  { 0, \"mmr\", \"[z[2]]\" },\n+  { 0, \"mm+ri\", \"[4[3]]\" },\n+  { 0, \"mm+rs\", \"[4[3]]\" },\n+  { 0, \"mm+r+si\", \"[5+6[3]]\" },\n+  { 0, \"mms\", \"[[2]]\" },\n+  { 0, \"mmi\", \"[[2]]\" },\n+  { 0, \"mm+si\", \"[4[3]]\" },\n+\n+  { 0, \"i\", \"#0\" },\n+  { 0, \"s\", \"#0\" },\n+  { 0, \"+si\", \"#1+2\" },\n+  { 0, \"l\", \"#0\" },\n+\n+  { 'l', \"l\", \"0\" },\n+  { 'd', \"i\", \"0\" },\n+  { 'd', \"s\", \"0\" },\n+  { 'd', \"+si\", \"1+2\" },\n+  { 'D', \"i\", \"0\" },\n+  { 'D', \"s\", \"0\" },\n+  { 'D', \"+si\", \"1+2\" },\n+  { 'x', \"i\", \"#0\" },\n+  { 'X', \"i\", \"#0\" },\n+  { 'm', \"i\", \"#0\" },\n+  { 'b', \"i\", \"#0\" },\n+  { 'p', \"i\", \"0\" },\n+\n+  { 0, 0, 0 }\n+};\n+\n+/* This is in order according to the bitfield that pushm/popm use.  */\n+static char const *pushm_regs[] = {\n+  \"fb\", \"sb\", \"a1\", \"a0\", \"r3\", \"r2\", \"r1\", \"r0\"\n+};\n+\n+/* Implements PRINT_OPERAND.  */\n+void\n+m32c_print_operand (FILE * file, rtx x, int code)\n+{\n+  int i, j, b;\n+  const char *comma;\n+  HOST_WIDE_INT ival;\n+  int unsigned_const = 0;\n+\n+  /* Multiplies; constants are converted to sign-extended format but\n+   we need unsigned, so 'u' and 'U' tell us what size unsigned we\n+   need.  */\n+  if (code == 'u')\n+    {\n+      unsigned_const = 2;\n+      code = 0;\n+    }\n+  if (code == 'U')\n+    {\n+      unsigned_const = 1;\n+      code = 0;\n+    }\n+  /* This one is only for debugging; you can put it in a pattern to\n+     force this error.  */\n+  if (code == '!')\n+    {\n+      fprintf (stderr, \"dj: unreviewed pattern:\");\n+      if (current_output_insn)\n+\tdebug_rtx (current_output_insn);\n+      gcc_unreachable ();\n+    }\n+  /* PSImode operations are either .w or .l depending on the target.  */\n+  if (code == '&')\n+    {\n+      if (TARGET_A16)\n+\tfprintf (file, \"w\");\n+      else\n+\tfprintf (file, \"l\");\n+      return;\n+    }\n+  /* Inverted conditionals.  */\n+  if (code == 'C')\n+    {\n+      switch (GET_CODE (x))\n+\t{\n+\tcase LE:\n+\t  fputs (\"gt\", file);\n+\t  break;\n+\tcase LEU:\n+\t  fputs (\"gtu\", file);\n+\t  break;\n+\tcase LT:\n+\t  fputs (\"ge\", file);\n+\t  break;\n+\tcase LTU:\n+\t  fputs (\"geu\", file);\n+\t  break;\n+\tcase GT:\n+\t  fputs (\"le\", file);\n+\t  break;\n+\tcase GTU:\n+\t  fputs (\"leu\", file);\n+\t  break;\n+\tcase GE:\n+\t  fputs (\"lt\", file);\n+\t  break;\n+\tcase GEU:\n+\t  fputs (\"ltu\", file);\n+\t  break;\n+\tcase NE:\n+\t  fputs (\"eq\", file);\n+\t  break;\n+\tcase EQ:\n+\t  fputs (\"ne\", file);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      return;\n+    }\n+  /* Regular conditionals.  */\n+  if (code == 'c')\n+    {\n+      switch (GET_CODE (x))\n+\t{\n+\tcase LE:\n+\t  fputs (\"le\", file);\n+\t  break;\n+\tcase LEU:\n+\t  fputs (\"leu\", file);\n+\t  break;\n+\tcase LT:\n+\t  fputs (\"lt\", file);\n+\t  break;\n+\tcase LTU:\n+\t  fputs (\"ltu\", file);\n+\t  break;\n+\tcase GT:\n+\t  fputs (\"gt\", file);\n+\t  break;\n+\tcase GTU:\n+\t  fputs (\"gtu\", file);\n+\t  break;\n+\tcase GE:\n+\t  fputs (\"ge\", file);\n+\t  break;\n+\tcase GEU:\n+\t  fputs (\"geu\", file);\n+\t  break;\n+\tcase NE:\n+\t  fputs (\"ne\", file);\n+\t  break;\n+\tcase EQ:\n+\t  fputs (\"eq\", file);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      return;\n+    }\n+  /* Used in negsi2 to do HImode ops on the two parts of an SImode\n+     operand.  */\n+  if (code == 'h' && GET_MODE (x) == SImode)\n+    {\n+      x = m32c_subreg (HImode, x, SImode, 0);\n+      code = 0;\n+    }\n+  if (code == 'H' && GET_MODE (x) == SImode)\n+    {\n+      x = m32c_subreg (HImode, x, SImode, 2);\n+      code = 0;\n+    }\n+  /* 'x' and 'X' need to be ignored for non-immediates.  */\n+  if ((code == 'x' || code == 'X') && GET_CODE (x) != CONST_INT)\n+    code = 0;\n+\n+  encode_pattern (x);\n+  for (i = 0; conversions[i].pattern; i++)\n+    if (conversions[i].code == code\n+\t&& streq (conversions[i].pattern, pattern))\n+      {\n+\tfor (j = 0; conversions[i].format[j]; j++)\n+\t  /* backslash quotes the next character in the output pattern.  */\n+\t  if (conversions[i].format[j] == '\\\\')\n+\t    {\n+\t      fputc (conversions[i].format[j + 1], file);\n+\t      j++;\n+\t    }\n+\t  /* Digits in the output pattern indicate that the\n+\t     corresponding RTX is to be output at that point.  */\n+\t  else if (ISDIGIT (conversions[i].format[j]))\n+\t    {\n+\t      rtx r = patternr[conversions[i].format[j] - '0'];\n+\t      switch (GET_CODE (r))\n+\t\t{\n+\t\tcase REG:\n+\t\t  fprintf (file, \"%s\",\n+\t\t\t   reg_name_with_mode (REGNO (r), GET_MODE (r)));\n+\t\t  break;\n+\t\tcase CONST_INT:\n+\t\t  switch (code)\n+\t\t    {\n+\t\t    case 'b':\n+\t\t      /* Bit position.  */\n+\t\t      fprintf (file, \"%d\", (int) exact_log2 (INTVAL (r)));\n+\t\t      break;\n+\t\t    case 'x':\n+\t\t      /* Unsigned byte.  */\n+\t\t      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+\t\t\t       INTVAL (r) & 0xff);\n+\t\t      break;\n+\t\t    case 'X':\n+\t\t      /* Unsigned word.  */\n+\t\t      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+\t\t\t       INTVAL (r) & 0xffff);\n+\t\t      break;\n+\t\t    case 'p':\n+\t\t      /* pushm and popm encode a register set into a single byte.  */\n+\t\t      comma = \"\";\n+\t\t      for (b = 7; b >= 0; b--)\n+\t\t\tif (INTVAL (r) & (1 << b))\n+\t\t\t  {\n+\t\t\t    fprintf (file, \"%s%s\", comma, pushm_regs[b]);\n+\t\t\t    comma = \",\";\n+\t\t\t  }\n+\t\t      break;\n+\t\t    case 'm':\n+\t\t      /* \"Minus\".  Output -X  */\n+\t\t      ival = (-INTVAL (r) & 0xffff);\n+\t\t      if (ival & 0x8000)\n+\t\t\tival = ival - 0x10000;\n+\t\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ival);\n+\t\t      break;\n+\t\t    default:\n+\t\t      ival = INTVAL (r);\n+\t\t      if (conversions[i].format[j + 1] == '[' && ival < 0)\n+\t\t\t{\n+\t\t\t  /* We can simulate negative displacements by\n+\t\t\t     taking advantage of address space\n+\t\t\t     wrapping when the offset can span the\n+\t\t\t     entire address range.  */\n+\t\t\t  rtx base =\n+\t\t\t    patternr[conversions[i].format[j + 2] - '0'];\n+\t\t\t  if (GET_CODE (base) == REG)\n+\t\t\t    switch (REGNO (base))\n+\t\t\t      {\n+\t\t\t      case A0_REGNO:\n+\t\t\t      case A1_REGNO:\n+\t\t\t\tif (TARGET_A24)\n+\t\t\t\t  ival = 0x1000000 + ival;\n+\t\t\t\telse\n+\t\t\t\t  ival = 0x10000 + ival;\n+\t\t\t\tbreak;\n+\t\t\t      case SB_REGNO:\n+\t\t\t\tif (TARGET_A16)\n+\t\t\t\t  ival = 0x10000 + ival;\n+\t\t\t\tbreak;\n+\t\t\t      }\n+\t\t\t}\n+\t\t      else if (code == 'd' && ival < 0 && j == 0)\n+\t\t\t/* The \"mova\" opcode is used to do addition by\n+\t\t\t   computing displacements, but again, we need\n+\t\t\t   displacements to be unsigned *if* they're\n+\t\t\t   the only component of the displacement\n+\t\t\t   (i.e. no \"symbol-4\" type displacement).  */\n+\t\t\tival = (TARGET_A24 ? 0x1000000 : 0x10000) + ival;\n+\n+\t\t      if (conversions[i].format[j] == '0')\n+\t\t\t{\n+\t\t\t  /* More conversions to unsigned.  */\n+\t\t\t  if (unsigned_const == 2)\n+\t\t\t    ival &= 0xffff;\n+\t\t\t  if (unsigned_const == 1)\n+\t\t\t    ival &= 0xff;\n+\t\t\t}\n+\t\t      if (streq (conversions[i].pattern, \"mi\")\n+\t\t\t  || streq (conversions[i].pattern, \"mmi\"))\n+\t\t\t{\n+\t\t\t  /* Integers used as addresses are unsigned.  */\n+\t\t\t  ival &= (TARGET_A24 ? 0xffffff : 0xffff);\n+\t\t\t}\n+\t\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ival);\n+\t\t      break;\n+\t\t    }\n+\t\t  break;\n+\t\tcase CONST_DOUBLE:\n+\t\t  /* We don't have const_double constants.  If it\n+\t\t     happens, make it obvious.  */\n+\t\t  fprintf (file, \"[const_double 0x%lx]\",\n+\t\t\t   (unsigned long) CONST_DOUBLE_HIGH (r));\n+\t\t  break;\n+\t\tcase SYMBOL_REF:\n+\t\t  assemble_name (file, XSTR (r, 0));\n+\t\t  break;\n+\t\tcase LABEL_REF:\n+\t\t  output_asm_label (r);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  fprintf (stderr, \"don't know how to print this operand:\");\n+\t\t  debug_rtx (r);\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (conversions[i].format[j] == 'z')\n+\t\t{\n+\t\t  /* Some addressing modes *must* have a displacement,\n+\t\t     so insert a zero here if needed.  */\n+\t\t  int k;\n+\t\t  for (k = j + 1; conversions[i].format[k]; k++)\n+\t\t    if (ISDIGIT (conversions[i].format[k]))\n+\t\t      {\n+\t\t\trtx reg = patternr[conversions[i].format[k] - '0'];\n+\t\t\tif (GET_CODE (reg) == REG\n+\t\t\t    && (REGNO (reg) == SB_REGNO\n+\t\t\t\t|| REGNO (reg) == FB_REGNO\n+\t\t\t\t|| REGNO (reg) == SP_REGNO))\n+\t\t\t  fputc ('0', file);\n+\t\t      }\n+\t\t  continue;\n+\t\t}\n+\t      /* Signed displacements off symbols need to have signs\n+\t\t blended cleanly.  */\n+\t      if (conversions[i].format[j] == '+'\n+\t\t  && (!code || code == 'I')\n+\t\t  && ISDIGIT (conversions[i].format[j + 1])\n+\t\t  && GET_CODE (patternr[conversions[i].format[j + 1] - '0'])\n+\t\t  == CONST_INT\n+\t\t  && INTVAL (patternr[conversions[i].format[j + 1] - '0']) <\n+\t\t  0)\n+\t\tcontinue;\n+\t      fputc (conversions[i].format[j], file);\n+\t    }\n+\tbreak;\n+      }\n+  if (!conversions[i].pattern)\n+    {\n+      fprintf (stderr, \"unconvertible operand %c `%s'\", code ? code : '-',\n+\t       pattern);\n+      debug_rtx (x);\n+      fprintf (file, \"[%c.%s]\", code ? code : '-', pattern);\n+    }\n+\n+  return;\n+}\n+\n+/* Implements PRINT_OPERAND_PUNCT_VALID_P.  See m32c_print_operand\n+   above for descriptions of what these do.  */\n+int\n+m32c_print_operand_punct_valid_p (int c)\n+{\n+  if (c == '&' || c == '!')\n+    return 1;\n+  return 0;\n+}\n+\n+/* Implements PRINT_OPERAND_ADDRESS.  Nothing unusual here.  */\n+void\n+m32c_print_operand_address (FILE * stream, rtx address)\n+{\n+  gcc_assert (GET_CODE (address) == MEM);\n+  m32c_print_operand (stream, XEXP (address, 0), 0);\n+}\n+\n+/* Implements ASM_OUTPUT_REG_PUSH.  Control registers are pushed\n+   differently than general registers.  */\n+void\n+m32c_output_reg_push (FILE * s, int regno)\n+{\n+  if (regno == FLG_REGNO)\n+    fprintf (s, \"\\tpushc\\tflg\\n\");\n+  else\n+    fprintf (s, \"\\tpush.%c\\t%s\",\n+\t     \" bwll\"[reg_push_size (regno)], reg_names[regno]);\n+}\n+\n+/* Likewise for ASM_OUTPUT_REG_POP.  */\n+void\n+m32c_output_reg_pop (FILE * s, int regno)\n+{\n+  if (regno == FLG_REGNO)\n+    fprintf (s, \"\\tpopc\\tflg\\n\");\n+  else\n+    fprintf (s, \"\\tpop.%c\\t%s\",\n+\t     \" bwll\"[reg_push_size (regno)], reg_names[regno]);\n+}\n+\n+/* Defining target-specific uses of `__attribute__' */\n+\n+/* Used to simplify the logic below.  Find the attributes wherever\n+   they may be.  */\n+#define M32C_ATTRIBUTES(decl) \\\n+  (TYPE_P (decl)) ? TYPE_ATTRIBUTES (decl) \\\n+                : DECL_ATTRIBUTES (decl) \\\n+                  ? (DECL_ATTRIBUTES (decl)) \\\n+\t\t  : TYPE_ATTRIBUTES (TREE_TYPE (decl))\n+\n+/* Returns TRUE if the given tree has the \"interrupt\" attribute.  */\n+static int\n+interrupt_p (tree node ATTRIBUTE_UNUSED)\n+{\n+  tree list = M32C_ATTRIBUTES (node);\n+  while (list)\n+    {\n+      if (is_attribute_p (\"interrupt\", TREE_PURPOSE (list)))\n+\treturn 1;\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n+static tree\n+interrupt_handler (tree * node ATTRIBUTE_UNUSED,\n+\t\t   tree name ATTRIBUTE_UNUSED,\n+\t\t   tree args ATTRIBUTE_UNUSED,\n+\t\t   int flags ATTRIBUTE_UNUSED,\n+\t\t   bool * no_add_attrs ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n+#undef TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE m32c_attribute_table\n+static const struct attribute_spec m32c_attribute_table[] = {\n+  {\"interrupt\", 0, 0, false, false, false, interrupt_handler},\n+  {0, 0, 0, 0, 0, 0, 0}\n+};\n+\n+#undef TARGET_COMP_TYPE_ATTRIBUTES\n+#define TARGET_COMP_TYPE_ATTRIBUTES m32c_comp_type_attributes\n+static int\n+m32c_comp_type_attributes (tree type1 ATTRIBUTE_UNUSED,\n+\t\t\t   tree type2 ATTRIBUTE_UNUSED)\n+{\n+  /* 0=incompatible 1=compatible 2=warning */\n+  return 1;\n+}\n+\n+#undef TARGET_INSERT_ATTRIBUTES\n+#define TARGET_INSERT_ATTRIBUTES m32c_insert_attributes\n+static void\n+m32c_insert_attributes (tree node ATTRIBUTE_UNUSED,\n+\t\t\ttree * attr_ptr ATTRIBUTE_UNUSED)\n+{\n+  /* Nothing to do here.  */\n+}\n+\n+/* Predicates */\n+\n+/* Returns TRUE if we support a move between the first two operands.\n+   At the moment, we just want to discourage mem to mem moves until\n+   after reload, because reload has a hard time with our limited\n+   number of address registers, and we can get into a situation where\n+   we need three of them when we only have two.  */\n+bool\n+m32c_mov_ok (rtx * operands, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (TARGET_A24)\n+    return true;\n+\n+#define DEBUG_MOV_OK 0\n+#if DEBUG_MOV_OK\n+  fprintf (stderr, \"m32c_mov_ok %s\\n\", mode_name[mode]);\n+  debug_rtx (op0);\n+  debug_rtx (op1);\n+#endif\n+\n+  if (GET_CODE (op0) == SUBREG)\n+    op0 = XEXP (op0, 0);\n+  if (GET_CODE (op1) == SUBREG)\n+    op1 = XEXP (op1, 0);\n+\n+  if (GET_CODE (op0) == MEM\n+      && GET_CODE (op1) == MEM\n+      && ! reload_completed)\n+    {\n+#if DEBUG_MOV_OK\n+      fprintf (stderr, \" - no, mem to mem\\n\");\n+#endif\n+      return false;\n+    }\n+\n+#if DEBUG_MOV_OK\n+  fprintf (stderr, \" - ok\\n\");\n+#endif\n+  return true;\n+}\n+\n+/* Expanders */\n+\n+/* Subregs are non-orthogonal for us, because our registers are all\n+   different sizes.  */\n+static rtx\n+m32c_subreg (enum machine_mode outer,\n+\t     rtx x, enum machine_mode inner, int byte)\n+{\n+  int r, nr = -1;\n+\n+  /* Converting MEMs to different types that are the same size, we\n+     just rewrite them.  */\n+  if (GET_CODE (x) == SUBREG\n+      && SUBREG_BYTE (x) == 0\n+      && GET_CODE (SUBREG_REG (x)) == MEM\n+      && (GET_MODE_SIZE (GET_MODE (x))\n+\t  == GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+    {\n+      rtx oldx = x;\n+      x = gen_rtx_MEM (GET_MODE (x), XEXP (SUBREG_REG (x), 0));\n+      MEM_COPY_ATTRIBUTES (x, SUBREG_REG (oldx));\n+    }\n+\n+  /* Push/pop get done as smaller push/pops.  */\n+  if (GET_CODE (x) == MEM\n+      && (GET_CODE (XEXP (x, 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (x, 0)) == POST_INC))\n+    return gen_rtx_MEM (outer, XEXP (x, 0));\n+  if (GET_CODE (x) == SUBREG\n+      && GET_CODE (XEXP (x, 0)) == MEM\n+      && (GET_CODE (XEXP (XEXP (x, 0), 0)) == PRE_DEC\n+\t  || GET_CODE (XEXP (XEXP (x, 0), 0)) == POST_INC))\n+    return gen_rtx_MEM (outer, XEXP (XEXP (x, 0), 0));\n+\n+  if (GET_CODE (x) != REG)\n+    return simplify_gen_subreg (outer, x, inner, byte);\n+\n+  r = REGNO (x);\n+  if (r >= FIRST_PSEUDO_REGISTER || r == AP_REGNO)\n+    return simplify_gen_subreg (outer, x, inner, byte);\n+\n+  if (IS_MEM_REGNO (r))\n+    return simplify_gen_subreg (outer, x, inner, byte);\n+\n+  /* This is where the complexities of our register layout are\n+     described.  */\n+  if (byte == 0)\n+    nr = r;\n+  else if (outer == HImode)\n+    {\n+      if (r == R0_REGNO && byte == 2)\n+\tnr = R2_REGNO;\n+      else if (r == R0_REGNO && byte == 4)\n+\tnr = R1_REGNO;\n+      else if (r == R0_REGNO && byte == 6)\n+\tnr = R3_REGNO;\n+      else if (r == R1_REGNO && byte == 2)\n+\tnr = R3_REGNO;\n+      else if (r == A0_REGNO && byte == 2)\n+\tnr = A1_REGNO;\n+    }\n+  else if (outer == SImode)\n+    {\n+      if (r == R0_REGNO && byte == 0)\n+\tnr = R0_REGNO;\n+      else if (r == R0_REGNO && byte == 4)\n+\tnr = R1_REGNO;\n+    }\n+  if (nr == -1)\n+    {\n+      fprintf (stderr, \"m32c_subreg %s %s %d\\n\",\n+\t       mode_name[outer], mode_name[inner], byte);\n+      debug_rtx (x);\n+      gcc_unreachable ();\n+    }\n+  return gen_rtx_REG (outer, nr);\n+}\n+\n+/* Used to emit move instructions.  We split some moves,\n+   and avoid mem-mem moves.  */\n+int\n+m32c_prepare_move (rtx * operands, enum machine_mode mode)\n+{\n+  if (TARGET_A16 && mode == PSImode)\n+    return m32c_split_move (operands, mode, 1);\n+  if ((GET_CODE (operands[0]) == MEM)\n+      && (GET_CODE (XEXP (operands[0], 0)) == PRE_MODIFY))\n+    {\n+      rtx pmv = XEXP (operands[0], 0);\n+      rtx dest_reg = XEXP (pmv, 0);\n+      rtx dest_mod = XEXP (pmv, 1);\n+\n+      emit_insn (gen_rtx_SET (Pmode, dest_reg, dest_mod));\n+      operands[0] = gen_rtx_MEM (mode, dest_reg);\n+    }\n+  if (!no_new_pseudos && MEM_P (operands[0]) && MEM_P (operands[1]))\n+    operands[1] = copy_to_mode_reg (mode, operands[1]);\n+  return 0;\n+}\n+\n+#define DEBUG_SPLIT 0\n+\n+/* Returns TRUE if the given PSImode move should be split.  We split\n+   for all r8c/m16c moves, since it doesn't support them, and for\n+   POP.L as we can only *push* SImode.  */\n+int\n+m32c_split_psi_p (rtx * operands)\n+{\n+#if DEBUG_SPLIT\n+  fprintf (stderr, \"\\nm32c_split_psi_p\\n\");\n+  debug_rtx (operands[0]);\n+  debug_rtx (operands[1]);\n+#endif\n+  if (TARGET_A16)\n+    {\n+#if DEBUG_SPLIT\n+      fprintf (stderr, \"yes, A16\\n\");\n+#endif\n+      return 1;\n+    }\n+  if (GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    {\n+#if DEBUG_SPLIT\n+      fprintf (stderr, \"yes, pop.l\\n\");\n+#endif\n+      return 1;\n+    }\n+#if DEBUG_SPLIT\n+  fprintf (stderr, \"no, default\\n\");\n+#endif\n+  return 0;\n+}\n+\n+/* Split the given move.  SPLIT_ALL is 0 if splitting is optional\n+   (define_expand), 1 if it is not optional (define_insn_and_split),\n+   and 3 for define_split (alternate api). */\n+int\n+m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n+{\n+  rtx s[4], d[4];\n+  int parts, si, di, rev = 0;\n+  int rv = 0, opi = 2;\n+  enum machine_mode submode = HImode;\n+  rtx *ops, local_ops[10];\n+\n+  /* define_split modifies the existing operands, but the other two\n+     emit new insns.  OPS is where we store the operand pairs, which\n+     we emit later.  */\n+  if (split_all == 3)\n+    ops = operands;\n+  else\n+    ops = local_ops;\n+\n+  /* Else HImode.  */\n+  if (mode == DImode)\n+    submode = SImode;\n+\n+  /* Before splitting mem-mem moves, force one operand into a\n+     register.  */\n+  if (!no_new_pseudos && MEM_P (operands[0]) && MEM_P (operands[1]))\n+    {\n+#if DEBUG0\n+      fprintf (stderr, \"force_reg...\\n\");\n+      debug_rtx (operands[1]);\n+#endif\n+      operands[1] = force_reg (mode, operands[1]);\n+#if DEBUG0\n+      debug_rtx (operands[1]);\n+#endif\n+    }\n+\n+  parts = 2;\n+\n+#if DEBUG_SPLIT\n+  fprintf (stderr, \"\\nsplit_move %d all=%d\\n\", no_new_pseudos, split_all);\n+  debug_rtx (operands[0]);\n+  debug_rtx (operands[1]);\n+#endif\n+\n+  /* We don't need to split these.  */\n+  if (TARGET_A24\n+      && split_all != 3\n+      && (mode == SImode || mode == PSImode)\n+      && !(GET_CODE (operands[1]) == MEM\n+\t   && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n+    return 0;\n+\n+  /* First, enumerate the subregs we'll be dealing with.  */\n+  for (si = 0; si < parts; si++)\n+    {\n+      d[si] =\n+\tm32c_subreg (submode, operands[0], mode,\n+\t\t     si * GET_MODE_SIZE (submode));\n+      s[si] =\n+\tm32c_subreg (submode, operands[1], mode,\n+\t\t     si * GET_MODE_SIZE (submode));\n+    }\n+\n+  /* Split pushes by emitting a sequence of smaller pushes.  */\n+  if (GET_CODE (d[0]) == MEM && GET_CODE (XEXP (d[0], 0)) == PRE_DEC)\n+    {\n+      for (si = parts - 1; si >= 0; si--)\n+\t{\n+\t  ops[opi++] = gen_rtx_MEM (submode,\n+\t\t\t\t    gen_rtx_PRE_DEC (Pmode,\n+\t\t\t\t\t\t     gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t\t\t  SP_REGNO)));\n+\t  ops[opi++] = s[si];\n+\t}\n+\n+      rv = 1;\n+    }\n+  /* Likewise for pops.  */\n+  else if (GET_CODE (s[0]) == MEM && GET_CODE (XEXP (s[0], 0)) == POST_INC)\n+    {\n+      for (di = 0; di < parts; di++)\n+\t{\n+\t  ops[opi++] = d[di];\n+\t  ops[opi++] = gen_rtx_MEM (submode,\n+\t\t\t\t    gen_rtx_POST_INC (Pmode,\n+\t\t\t\t\t\t      gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t\t\t   SP_REGNO)));\n+\t}\n+      rv = 1;\n+    }\n+  else if (split_all)\n+    {\n+      /* if d[di] == s[si] for any di < si, we'll early clobber. */\n+      for (di = 0; di < parts - 1; di++)\n+\tfor (si = di + 1; si < parts; si++)\n+\t  if (reg_mentioned_p (d[di], s[si]))\n+\t    rev = 1;\n+\n+      if (rev)\n+\tfor (si = 0; si < parts; si++)\n+\t  {\n+\t    ops[opi++] = d[si];\n+\t    ops[opi++] = s[si];\n+\t  }\n+      else\n+\tfor (si = parts - 1; si >= 0; si--)\n+\t  {\n+\t    ops[opi++] = d[si];\n+\t    ops[opi++] = s[si];\n+\t  }\n+      rv = 1;\n+    }\n+  /* Now emit any moves we may have accumulated.  */\n+  if (rv && split_all != 3)\n+    {\n+      int i;\n+      for (i = 2; i < opi; i += 2)\n+\temit_move_insn (ops[i], ops[i + 1]);\n+    }\n+  return rv;\n+}\n+\n+/* The m32c only has one shift, but it takes a signed count.  GCC\n+   doesn't want this, so we fake it by negating any shift count when\n+   we're pretending to shift the other way.  */\n+int\n+m32c_prepare_shift (rtx * operands, int scale, int bits)\n+{\n+  rtx temp;\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) <= (1 << (bits - 1))\n+      && INTVAL (operands[2]) >= -(1 << (bits - 1)))\n+    {\n+      operands[2] = GEN_INT (scale * INTVAL (operands[2]));\n+      return 0;\n+    }\n+  if (scale < 0)\n+    {\n+      temp = gen_reg_rtx (QImode);\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\ttemp = GEN_INT (-INTVAL (operands[2]));\n+      else\n+\temit_move_insn (temp, gen_rtx_NEG (QImode, operands[2]));\n+    }\n+  else\n+    temp = operands[2];\n+  operands[2] = temp;\n+  return 0;\n+}\n+\n+/* Pattern Output Functions */\n+\n+/* Returns TRUE if the current function is a leaf, and thus we can\n+   determine which registers an interrupt function really needs to\n+   save.  The logic below is mostly about finding the insn sequence\n+   that's the function, versus any sequence that might be open for the\n+   current insn.  */\n+static int\n+m32c_leaf_function_p (void)\n+{\n+  rtx saved_first, saved_last;\n+  struct sequence_stack *seq;\n+  int rv;\n+\n+  saved_first = cfun->emit->x_first_insn;\n+  saved_last = cfun->emit->x_last_insn;\n+  for (seq = cfun->emit->sequence_stack; seq && seq->next; seq = seq->next)\n+    ;\n+  if (seq)\n+    {\n+      cfun->emit->x_first_insn = seq->first;\n+      cfun->emit->x_last_insn = seq->last;\n+    }\n+\n+  rv = leaf_function_p ();\n+\n+  cfun->emit->x_first_insn = saved_first;\n+  cfun->emit->x_last_insn = saved_last;\n+  return rv;\n+}\n+\n+/* Returns TRUE if the current function needs to use the ENTER/EXIT\n+   opcodes.  If the function doesn't need the frame base or stack\n+   pointer, it can use the simpler RTS opcode.  */\n+static bool\n+m32c_function_needs_enter (void)\n+{\n+  rtx insn;\n+  struct sequence_stack *seq;\n+  rtx sp = gen_rtx_REG (Pmode, SP_REGNO);\n+  rtx fb = gen_rtx_REG (Pmode, FB_REGNO);\n+\n+  insn = get_insns ();\n+  for (seq = cfun->emit->sequence_stack;\n+       seq;\n+       insn = seq->first, seq = seq->next);\n+\n+  while (insn)\n+    {\n+      if (reg_mentioned_p (sp, insn))\n+\treturn true;\n+      if (reg_mentioned_p (fb, insn))\n+\treturn true;\n+      insn = NEXT_INSN (insn);\n+    }\n+  return false;\n+}\n+\n+/* Mark all the subexpressions of the PARALLEL rtx PAR as\n+   frame-related.  Return PAR.\n+\n+   dwarf2out.c:dwarf2out_frame_debug_expr ignores sub-expressions of a\n+   PARALLEL rtx other than the first if they do not have the\n+   FRAME_RELATED flag set on them.  So this function is handy for\n+   marking up 'enter' instructions.  */\n+static rtx\n+m32c_all_frame_related (rtx par)\n+{\n+  int len = XVECLEN (par, 0);\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    F (XVECEXP (par, 0, i));\n+\n+  return par;\n+}\n+\n+/* Emits the prologue.  See the frame layout comment earlier in this\n+   file.  We can reserve up to 256 bytes with the ENTER opcode, beyond\n+   that we manually update sp.  */\n+void\n+m32c_emit_prologue (void)\n+{\n+  int frame_size, extra_frame_size = 0, reg_save_size;\n+  int complex_prologue = 0;\n+\n+  cfun->machine->is_leaf = m32c_leaf_function_p ();\n+  if (interrupt_p (cfun->decl))\n+    {\n+      cfun->machine->is_interrupt = 1;\n+      complex_prologue = 1;\n+    }\n+\n+  reg_save_size = m32c_pushm_popm (PP_justcount);\n+\n+  if (interrupt_p (cfun->decl))\n+    emit_insn (gen_pushm (GEN_INT (cfun->machine->intr_pushm)));\n+\n+  frame_size =\n+    m32c_initial_elimination_offset (FB_REGNO, SP_REGNO) - reg_save_size;\n+  if (frame_size == 0\n+      && !cfun->machine->is_interrupt\n+      && !m32c_function_needs_enter ())\n+    cfun->machine->use_rts = 1;\n+\n+  if (frame_size > 254)\n+    {\n+      extra_frame_size = frame_size - 254;\n+      frame_size = 254;\n+    }\n+  if (cfun->machine->use_rts == 0)\n+    F (emit_insn (m32c_all_frame_related\n+\t\t  (TARGET_A16\n+\t\t   ? gen_prologue_enter_16 (GEN_INT (frame_size))\n+\t\t   : gen_prologue_enter_24 (GEN_INT (frame_size)))));\n+\n+  if (extra_frame_size)\n+    {\n+      complex_prologue = 1;\n+      if (TARGET_A16)\n+\tF (emit_insn (gen_addhi3 (gen_rtx_REG (HImode, SP_REGNO),\n+\t\t\t\t  gen_rtx_REG (HImode, SP_REGNO),\n+\t\t\t\t  GEN_INT (-extra_frame_size))));\n+      else\n+\tF (emit_insn (gen_addpsi3 (gen_rtx_REG (PSImode, SP_REGNO),\n+\t\t\t\t   gen_rtx_REG (PSImode, SP_REGNO),\n+\t\t\t\t   GEN_INT (-extra_frame_size))));\n+    }\n+\n+  complex_prologue += m32c_pushm_popm (PP_pushm);\n+\n+  /* This just emits a comment into the .s file for debugging.  */\n+  if (complex_prologue)\n+    emit_insn (gen_prologue_end ());\n+}\n+\n+/* Likewise, for the epilogue.  The only exception is that, for\n+   interrupts, we must manually unwind the frame as the REIT opcode\n+   doesn't do that.  */\n+void\n+m32c_emit_epilogue (void)\n+{\n+  /* This just emits a comment into the .s file for debugging.  */\n+  if (m32c_pushm_popm (PP_justcount) > 0 || cfun->machine->is_interrupt)\n+    emit_insn (gen_epilogue_start ());\n+\n+  m32c_pushm_popm (PP_popm);\n+\n+  if (cfun->machine->is_interrupt)\n+    {\n+      enum machine_mode spmode = TARGET_A16 ? HImode : PSImode;\n+\n+      emit_move_insn (gen_rtx_REG (spmode, A0_REGNO),\n+\t\t      gen_rtx_REG (spmode, FP_REGNO));\n+      emit_move_insn (gen_rtx_REG (spmode, SP_REGNO),\n+\t\t      gen_rtx_REG (spmode, A0_REGNO));\n+      if (TARGET_A16)\n+\temit_insn (gen_pophi_16 (gen_rtx_REG (HImode, FP_REGNO)));\n+      else\n+\temit_insn (gen_poppsi (gen_rtx_REG (PSImode, FP_REGNO)));\n+      emit_insn (gen_popm (GEN_INT (cfun->machine->intr_pushm)));\n+      emit_jump_insn (gen_epilogue_reit (GEN_INT (TARGET_A16 ? 4 : 6)));\n+    }\n+  else if (cfun->machine->use_rts)\n+    emit_jump_insn (gen_epilogue_rts ());\n+  else\n+    emit_jump_insn (gen_epilogue_exitd (GEN_INT (TARGET_A16 ? 2 : 4)));\n+  emit_barrier ();\n+}\n+\n+void\n+m32c_emit_eh_epilogue (rtx ret_addr)\n+{\n+  /* R0[R2] has the stack adjustment.  R1[R3] has the address to\n+     return to.  We have to fudge the stack, pop everything, pop SP\n+     (fudged), and return (fudged).  This is actually easier to do in\n+     assembler, so punt to libgcc.  */\n+  emit_jump_insn (gen_eh_epilogue (ret_addr, cfun->machine->eh_stack_adjust));\n+  /*  emit_insn (gen_rtx_CLOBBER (HImode, gen_rtx_REG (HImode, R0L_REGNO))); */\n+  emit_barrier ();\n+}\n+\n+/* The Global `targetm' Variable. */\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+#include \"gt-m32c.h\""}, {"sha": "cc73852754a0ec5522416207fc89b20501225ef9", "filename": "gcc/config/m32c/m32c.h", "status": "added", "additions": 649, "deletions": 0, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,649 @@\n+/* Target Definitions for R8C/M16C/M32C\n+   Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+#ifndef GCC_M32C_H\n+#define GCC_M32C_H\n+\n+/* Controlling the Compilation Driver, `gcc'.  */\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0.o%s crtbegin.o%s\"\n+\n+/* There are four CPU series we support, but they basically break down\n+   into two families - the R8C/M16C families, with 16 bit address\n+   registers and one set of opcodes, and the M32CM/M32C group, with 24\n+   bit address registers and a different set of opcodes.  The\n+   assembler doesn't care except for which opcode set is needed; the\n+   big difference is in the memory maps, which we cover in\n+   LIB_SPEC.  */\n+\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mcpu=r8c:--m16c} \\\n+%{mcpu=m16c:--m16c} \\\n+%{mcpu=m32cm:--m32c} \\\n+%{mcpu=m32c:--m32c} \"\n+\n+/* The default is R8C hardware.  We support a simulator, which has its\n+   own libgloss and link map, plus one default link map for each chip\n+   family.  Most of the logic here is making sure we do the right\n+   thing when no CPU is specified, which defaults to R8C.  */\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"-( -lc %{msim*:-lsim}%{!msim*:-lnosys} -) \\\n+%{msim*:%{!T*: %{mcpu=m32cm:-Tsim24.ld}%{mcpu=m32c:-Tsim24.ld} \\\n+\t%{!mcpu=m32cm:%{!mcpu=m32c:-Tsim16.ld}}}} \\\n+%{!T*:%{!msim*: %{mcpu=m16c:-Tm16c.ld} \\\n+\t\t%{mcpu=m32cm:-Tm32cm.ld} \\\n+\t\t%{mcpu=m32c:-Tm32c.ld} \\\n+\t\t%{!mcpu=m16c:%{!mcpu=m32cm:%{!mcpu=m32c:-Tr8c.ld}}}}} \\\n+\"\n+\n+/* Run-time Target Specification */\n+\n+/* Nothing unusual here.  */\n+#define TARGET_CPU_CPP_BUILTINS() \\\n+  { \\\n+    builtin_assert (\"cpu=m32c\"); \\\n+    builtin_assert (\"machine=m32c\"); \\\n+    builtin_define (\"__m32c__=1\"); \\\n+    if (TARGET_R8C) \\\n+      builtin_define (\"__r8c_cpu__=1\"); \\\n+    if (TARGET_M16C) \\\n+      builtin_define (\"__m16c_cpu__=1\"); \\\n+    if (TARGET_M32CM) \\\n+      builtin_define (\"__m32cm_cpu__=1\"); \\\n+    if (TARGET_M32C) \\\n+      builtin_define (\"__m32c_cpu__=1\"); \\\n+  }\n+\n+/* The pragma handlers need to know if we've started processing\n+   functions yet, as the memregs pragma should only be given at the\n+   beginning of the file.  This variable starts off TRUE and later\n+   becomes FALSE.  */\n+extern int ok_to_change_target_memregs;\n+extern int target_memregs;\n+\n+/* TARGET_CPU is a multi-way option set in m32c.opt.  While we could\n+   use enums or defines for this, this and m32c.opt are the only\n+   places that know (or care) what values are being used.  */\n+#define TARGET_R8C\t(target_cpu == 'r')\n+#define TARGET_M16C\t(target_cpu == '6')\n+#define TARGET_M32CM\t(target_cpu == 'm')\n+#define TARGET_M32C\t(target_cpu == '3')\n+\n+/* Address register sizes.  Warning: these are used all over the place\n+   to select between the two CPU families in general.  */\n+#define TARGET_A16\t(TARGET_R8C || TARGET_M16C)\n+#define TARGET_A24\t(TARGET_M32CM || TARGET_M32C)\n+\n+#define TARGET_VERSION fprintf (stderr, \" (m32c)\");\n+\n+#define OVERRIDE_OPTIONS m32c_override_options ();\n+\n+/* Defining data structures for per-function information */\n+\n+typedef struct machine_function GTY (())\n+{\n+  /* How much we adjust the stack when returning from an exception\n+     handler.  */\n+  rtx eh_stack_adjust;\n+\n+  /* TRUE if the current function is an interrupt handler.  */\n+  int is_interrupt;\n+\n+  /* TRUE if the current function is a leaf function.  Currently, this\n+     only affects saving $a0 in interrupt functions.  */\n+  int is_leaf;\n+\n+  /* Bitmask that keeps track of which registers are used in an\n+     interrupt function, so we know which ones need to be saved and\n+     restored.  */\n+  int intr_pushm;\n+  /* Likewise, one element for each memreg that needs to be saved.  */\n+  char intr_pushmem[16];\n+\n+  /* TRUE if the current function can use a simple RTS to return, instead\n+     of the longer ENTER/EXIT pair.  */\n+  int use_rts;\n+}\n+machine_function;\n+\n+#define INIT_EXPANDERS m32c_init_expanders ()\n+\n+/* Storage Layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* We can do QI, HI, and SI operations pretty much equally well, but\n+   GCC expects us to have a \"native\" format, so we pick the one that\n+   matches \"int\".  Pointers are 16 bits for R8C/M16C (when TARGET_A16\n+   is true) and 24 bits for M32CM/M32C (when TARGET_A24 is true), but\n+   24 bit pointers are stored in 32 bit words.  */\n+#define BITS_PER_UNIT 8\n+#define UNITS_PER_WORD 2\n+#define POINTER_SIZE (TARGET_A16 ? 16 : 32)\n+#define POINTERS_EXTEND_UNSIGNED 1\n+\n+/* These match the alignment enforced by the two types of stack operations.  */\n+#define PARM_BOUNDARY (TARGET_A16 ? 8 : 16)\n+#define STACK_BOUNDARY (TARGET_A16 ? 8 : 16)\n+\n+/* We do this because we care more about space than about speed.  For\n+   the chips with 16 bit busses, we could set these to 16 if\n+   desired.  */\n+#define FUNCTION_BOUNDARY 8\n+#define BIGGEST_ALIGNMENT 8\n+\n+#define STRICT_ALIGNMENT 0\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Layout of Source Language Data Types */\n+\n+#define INT_TYPE_SIZE 16\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* REGISTER USAGE */\n+\n+/* Register Basics */\n+\n+/* Register layout:\n+\n+        [r0h][r0l]  $r0  (16 bits, or two 8 bit halves)\n+        [--------]  $r2  (16 bits)\n+        [r1h][r1l]  $r1  (16 bits, or two 8 bit halves)\n+        [--------]  $r3  (16 bits)\n+   [---][--------]  $a0  (might be 24 bits)\n+   [---][--------]  $a1  (might be 24 bits)\n+   [---][--------]  $sb  (might be 24 bits)\n+   [---][--------]  $fb  (might be 24 bits)\n+   [---][--------]  $sp  (might be 24 bits)\n+   [-------------]  $pc  (20 or 24 bits)\n+             [---]  $flg (CPU flags)\n+   [---][--------]  $argp (virtual)\n+        [--------]  $mem0 (all 16 bits)\n+          . . .\n+        [--------]  $mem14\n+*/\n+\n+#define FIRST_PSEUDO_REGISTER   20\n+\n+/* Note that these two tables are modified based on which CPU family\n+   you select; see m32c_conditional_register_usage for details.  */\n+\n+/* r0 r2 r1 r3 - a0 a1 sb fb - sp pc flg argp - mem0..mem14 */\n+#define FIXED_REGISTERS     { 0, 0, 0, 0, \\\n+\t\t\t      0, 0, 1, 0, \\\n+\t\t\t      1, 1, 0, 1, \\\n+\t\t\t      0, 0, 0, 0, 0, 0, 0, 0 }\n+#define CALL_USED_REGISTERS { 1, 1, 1, 1, \\\n+\t\t\t      1, 1, 1, 0, \\\n+\t\t\t      1, 1, 1, 1, \\\n+\t\t\t      1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+#define CONDITIONAL_REGISTER_USAGE m32c_conditional_register_usage ();\n+\n+/* The *_REGNO theme matches m32c.md and most register number\n+   arguments; the PC_REGNUM is the odd one out.  */\n+#ifndef PC_REGNO\n+#define PC_REGNO 9\n+#endif\n+#define PC_REGNUM PC_REGNO\n+\n+/* How Values Fit in Registers */\n+\n+#define HARD_REGNO_NREGS(R,M) m32c_hard_regno_nregs (R, M)\n+#define HARD_REGNO_MODE_OK(R,M) m32c_hard_regno_ok (R, M)\n+#define MODES_TIEABLE_P(M1,M2) m32c_modes_tieable_p (M1, M2)\n+#define AVOID_CCMODE_COPIES\n+\n+/* Register Classes */\n+\n+/* Most registers are special purpose in some form or another, so this\n+   table is pretty big.  Class names are used for constraints also;\n+   for example the HL_REGS class (HL below) is \"Rhl\" in the md files.\n+   See m32c_reg_class_from_constraint for the mapping.  There's some\n+   duplication so that we can better isolate the reason for using\n+   constraints in the md files from the actual registers used; for\n+   example we may want to exclude a1a0 from SI_REGS in the future,\n+   without precluding their use as HImode registers.  */\n+\n+/* m7654 - m3210 - argp flg pc sp - fb sb a1 a0 - r3 r1 r2 r0 */\n+/*       mmPAR */\n+#define REG_CLASS_CONTENTS \\\n+{ { 0x00000000 }, /* NO */\\\n+  { 0x00000100 }, /* SP  - sp */\\\n+  { 0x00000080 }, /* FB  - fb */\\\n+  { 0x00000040 }, /* SB  - sb */\\\n+  { 0x000001c0 }, /* CR  - sb fb sp */\\\n+  { 0x00000001 }, /* R0  - r0 */\\\n+  { 0x00000004 }, /* R1  - r1 */\\\n+  { 0x00000002 }, /* R2  - r2 */\\\n+  { 0x00000008 }, /* R3  - r3 */\\\n+  { 0x00000003 }, /* R02 - r0r2 */\\\n+  { 0x00000005 }, /* HL  - r0 r1 */\\\n+  { 0x00000005 }, /* QI  - r0 r1 */\\\n+  { 0x0000000a }, /* R23 - r2 r3 */\\\n+  { 0x0000000f }, /* R03 - r0r2 r1r3 */\\\n+  { 0x0000000f }, /* DI  - r0r2r1r3 + mems */\\\n+  { 0x00000030 }, /* A   - a0 a1 */\\\n+  { 0x000000f0 }, /* AD  - a0 a1 sb fp */\\\n+  { 0x000001f0 }, /* PS  - a0 a1 sb fp sp */\\\n+  { 0x0000003f }, /* SI  - r0r2 r1r3 a0a1 */\\\n+  { 0x0000003f }, /* HI  - r0 r1 r2 r3 a0 a1 */\\\n+  { 0x0000003f }, /* RA  - r0..r3 a0 a1 */\\\n+  { 0x0000007f }, /* GENERAL */\\\n+  { 0x00000400 }, /* FLG */\\\n+  { 0x000001ff }, /* HC  - r0l r1 r2 r3 a0 a1 sb fb sp */\\\n+  { 0x000ff000 }, /* MEM */\\\n+  { 0x000ff003 }, /* R02_A_MEM */\\\n+  { 0x000ff005 }, /* A_HL_MEM */\\\n+  { 0x000ff00c }, /* R1_R3_A_MEM */\\\n+  { 0x000ff00f }, /* R03_MEM */\\\n+  { 0x000ff03f }, /* A_HI_MEM */\\\n+  { 0x000ff0ff }, /* A_AD_CR_MEM_SI */\\\n+  { 0x000ff1ff }, /* ALL */\\\n+}\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  SP_REGS,\n+  FB_REGS,\n+  SB_REGS,\n+  CR_REGS,\n+  R0_REGS,\n+  R1_REGS,\n+  R2_REGS,\n+  R3_REGS,\n+  R02_REGS,\n+  HL_REGS,\n+  QI_REGS,\n+  R23_REGS,\n+  R03_REGS,\n+  DI_REGS,\n+  A_REGS,\n+  AD_REGS,\n+  PS_REGS,\n+  SI_REGS,\n+  HI_REGS,\n+  RA_REGS,\n+  GENERAL_REGS,\n+  FLG_REGS,\n+  HC_REGS,\n+  MEM_REGS,\n+  R02_A_MEM_REGS,\n+  A_HL_MEM_REGS,\n+  R1_R3_A_MEM_REGS,\n+  R03_MEM_REGS,\n+  A_HI_MEM_REGS,\n+  A_AD_CR_MEM_SI_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\\\n+\"NO_REGS\", \\\n+\"SP_REGS\", \\\n+\"FB_REGS\", \\\n+\"SB_REGS\", \\\n+\"CR_REGS\", \\\n+\"R0_REGS\", \\\n+\"R1_REGS\", \\\n+\"R2_REGS\", \\\n+\"R3_REGS\", \\\n+\"R02_REGS\", \\\n+\"HL_REGS\", \\\n+\"QI_REGS\", \\\n+\"R23_REGS\", \\\n+\"R03_REGS\", \\\n+\"DI_REGS\", \\\n+\"A_REGS\", \\\n+\"AD_REGS\", \\\n+\"PS_REGS\", \\\n+\"SI_REGS\", \\\n+\"HI_REGS\", \\\n+\"RA_REGS\", \\\n+\"GENERAL_REGS\", \\\n+\"FLG_REGS\", \\\n+\"HC_REGS\", \\\n+\"MEM_REGS\", \\\n+\"R02_A_MEM_REGS\", \\\n+\"A_HL_MEM_REGS\", \\\n+\"R1_R3_A_MEM_REGS\", \\\n+\"R03_MEM_REGS\", \\\n+\"A_HI_MEM_REGS\", \\\n+\"A_AD_CR_MEM_SI_REGS\", \\\n+\"ALL_REGS\", \\\n+}\n+\n+#define REGNO_REG_CLASS(R) m32c_regno_reg_class (R)\n+\n+/* We support simple displacements off address registers, nothing else.  */\n+#define BASE_REG_CLASS A_REGS\n+#define INDEX_REG_CLASS NO_REGS\n+\n+/* We primarily use the new \"long\" constraint names, with the intial\n+   letter classifying the constraint type and following letters\n+   specifying which.  The types are:\n+\n+   I - integer values\n+   R - register classes\n+   S - memory references (M was used)\n+   A - addresses (currently unused)\n+*/\n+\n+#define CONSTRAINT_LEN(CHAR,STR) \\\n+\t((CHAR) == 'I' ? 3 \\\n+\t : (CHAR) == 'R' ? 3 \\\n+\t : (CHAR) == 'S' ? 2 \\\n+\t : (CHAR) == 'A' ? 2 \\\n+\t : DEFAULT_CONSTRAINT_LEN(CHAR,STR))\n+#define REG_CLASS_FROM_CONSTRAINT(CHAR,STR) \\\n+\tm32c_reg_class_from_constraint (CHAR, STR)\n+\n+#define REGNO_OK_FOR_BASE_P(NUM) m32c_regno_ok_for_base_p (NUM)\n+#define REGNO_OK_FOR_INDEX_P(NUM) 0\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) m32c_preferred_reload_class (X, CLASS)\n+#define PREFERRED_OUTPUT_RELOAD_CLASS(X,CLASS) m32c_preferred_output_reload_class (X, CLASS)\n+#define LIMIT_RELOAD_CLASS(MODE,CLASS) m32c_limit_reload_class (MODE, CLASS)\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,X) m32c_secondary_reload_class (CLASS, MODE, X)\n+\n+#define SMALL_REGISTER_CLASSES 1\n+\n+#define CLASS_LIKELY_SPILLED_P(C) m32c_class_likely_spilled_p (C)\n+\n+#define CLASS_MAX_NREGS(C,M) m32c_class_max_nregs (C, M)\n+\n+#define CANNOT_CHANGE_MODE_CLASS(F,T,C) m32c_cannot_change_mode_class(F,T,C)\n+\n+#define CONST_OK_FOR_CONSTRAINT_P(VALUE,C,STR) \\\n+\tm32c_const_ok_for_constraint_p (VALUE, C, STR)\n+#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(VALUE,C,STR) 0\n+#define EXTRA_CONSTRAINT_STR(VALUE,C,STR) \\\n+\tm32c_extra_constraint_p (VALUE, C, STR)\n+#define EXTRA_MEMORY_CONSTRAINT(C,STR) \\\n+\tm32c_extra_memory_constraint (C, STR)\n+#define EXTRA_ADDRESS_CONSTRAINT(C,STR) \\\n+\tm32c_extra_address_constraint (C, STR)\n+\n+/* STACK AND CALLING */\n+\n+/* Frame Layout */\n+\n+/* Standard push/pop stack, no surprises here.  */\n+\n+#define STACK_GROWS_DOWNWARD 1\n+#define STACK_PUSH_CODE PRE_DEC\n+#define FRAME_GROWS_DOWNWARD 1\n+\n+#define STARTING_FRAME_OFFSET 0\n+#define FIRST_PARM_OFFSET(F) 0\n+\n+#define RETURN_ADDR_RTX(COUNT,FA) m32c_return_addr_rtx (COUNT)\n+\n+#define INCOMING_RETURN_ADDR_RTX m32c_incoming_return_addr_rtx()\n+#define INCOMING_FRAME_SP_OFFSET 3\n+\n+/* Exception Handling Support */\n+\n+#define EH_RETURN_DATA_REGNO(N) m32c_eh_return_data_regno (N)\n+#define EH_RETURN_STACKADJ_RTX m32c_eh_return_stackadj_rtx ()\n+\n+/* Registers That Address the Stack Frame */\n+\n+#ifndef FP_REGNO\n+#define FP_REGNO 7\n+#endif\n+#ifndef SP_REGNO\n+#define SP_REGNO 8\n+#endif\n+#define AP_REGNO 11\n+\n+#define STACK_POINTER_REGNUM\tSP_REGNO\n+#define FRAME_POINTER_REGNUM\tFP_REGNO\n+#define ARG_POINTER_REGNUM\tAP_REGNO\n+\n+/* The static chain must be pointer-capable.  */\n+#define STATIC_CHAIN_REGNUM A0_REGNO\n+\n+#define DWARF_FRAME_REGISTERS 20\n+#define DWARF_FRAME_REGNUM(N) m32c_dwarf_frame_regnum (N)\n+#define DBX_REGISTER_NUMBER(N) m32c_dwarf_frame_regnum (N)\n+\n+/* Eliminating Frame Pointer and Arg Pointer */\n+\n+/* If the frame pointer isn't used, we detect it manually.  But the\n+   stack pointer doesn't have as flexible addressing as the frame\n+   pointer, so we always assume we have it.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+#define ELIMINABLE_REGS \\\n+  {{AP_REGNO, SP_REGNO}, \\\n+   {AP_REGNO, FB_REGNO}, \\\n+   {FB_REGNO, SP_REGNO}}\n+\n+#define CAN_ELIMINATE(FROM,TO) 1\n+#define INITIAL_ELIMINATION_OFFSET(FROM,TO,VAR) \\\n+\t(VAR) = m32c_initial_elimination_offset(FROM,TO)\n+\n+/* Passing Function Arguments on the Stack */\n+\n+#define PUSH_ARGS 1\n+#define PUSH_ROUNDING(N) m32c_push_rounding (N)\n+#define RETURN_POPS_ARGS(D,T,S) 0\n+#define CALL_POPS_ARGS(C) 0\n+\n+/* Passing Arguments in Registers */\n+\n+#define FUNCTION_ARG(CA,MODE,TYPE,NAMED) \\\n+\tm32c_function_arg (&(CA),MODE,TYPE,NAMED)\n+\n+typedef struct m32c_cumulative_args\n+{\n+  /* For address of return value buffer (structures are returned by\n+     passing the address of a buffer as an invisible first argument.\n+     This identifies it).  If set, the current parameter will be put\n+     on the stack, regardless of type.  */\n+  int force_mem;\n+  /* First parm is 1, parm 0 is hidden pointer for returning\n+     aggregates.  */\n+  int parm_num;\n+} m32c_cumulative_args;\n+\n+#define CUMULATIVE_ARGS m32c_cumulative_args\n+#define INIT_CUMULATIVE_ARGS(CA,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n+\tm32c_init_cumulative_args (&(CA),FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS)\n+#define FUNCTION_ARG_ADVANCE(CA,MODE,TYPE,NAMED) \\\n+\tm32c_function_arg_advance (&(CA),MODE,TYPE,NAMED)\n+#define FUNCTION_ARG_BOUNDARY(MODE,TYPE) (TARGET_A16 ? 8 : 16)\n+#define FUNCTION_ARG_REGNO_P(r) m32c_function_arg_regno_p (r)\n+\n+/* How Scalar Function Values Are Returned */\n+\n+#define FUNCTION_VALUE(VT,F) m32c_function_value (VT, F)\n+#define LIBCALL_VALUE(MODE) m32c_libcall_value (MODE)\n+\n+#define FUNCTION_VALUE_REGNO_P(r) ((r) == R0_REGNO || (r) == MEM0_REGNO)\n+\n+/* How Large Values Are Returned */\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 1\n+\n+/* Function Entry and Exit */\n+\n+#define EXIT_IGNORE_STACK 0\n+#define EPILOGUE_USES(REGNO) m32c_epilogue_uses(REGNO)\n+#define EH_USES(REGNO) 0\t/* FIXME */\n+\n+/* Generating Code for Profiling */\n+\n+#define FUNCTION_PROFILER(FILE,LABELNO)\n+\n+/* Implementing the Varargs Macros */\n+\n+/* Trampolines for Nested Functions */\n+\n+#define TRAMPOLINE_SIZE m32c_trampoline_size ()\n+#define TRAMPOLINE_ALIGMNENT m32c_trampoline_alignment ()\n+#define INITIALIZE_TRAMPOLINE(a,fn,sc) m32c_initialize_trampoline (a, fn, sc)\n+\n+/* Addressing Modes */\n+\n+#define HAVE_PRE_DECREMENT 1\n+#define HAVE_POST_INCREMENT 1\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P(X)\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* This is passed to the macros below, so that they can be implemented\n+   in m32c.c.  */\n+#ifdef REG_OK_STRICT\n+#define REG_OK_STRICT_V 1\n+#else\n+#define REG_OK_STRICT_V 0\n+#endif\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE,X,LABEL) \\\n+\tif (m32c_legitimate_address_p (MODE, X, REG_OK_STRICT_V)) \\\n+\t  goto LABEL;\n+\n+#define REG_OK_FOR_BASE_P(X) m32c_reg_ok_for_base_p (X, REG_OK_STRICT_V)\n+#define REG_OK_FOR_INDEX_P(X) 0\n+\n+/* #define FIND_BASE_TERM(X) when we do unspecs for symrefs */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) \\\n+\tif (m32c_legitimize_address(&(X),OLDX,MODE)) \\\n+\t  goto win;\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN) \\\n+\tif (m32c_legitimize_reload_address(&(X),MODE,OPNUM,TYPE,IND_LEVELS)) \\\n+\t  goto win;\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) \\\n+\tif (m32c_mode_dependent_address (ADDR)) \\\n+\t  goto LABEL;\n+\n+#define LEGITIMATE_CONSTANT_P(X) m32c_legitimate_constant_p (X)\n+\n+/* Condition Code Status */\n+\n+#define REVERSIBLE_CC_MODE(MODE) 1\n+\n+/* Describing Relative Costs of Operations */\n+\n+#define REGISTER_MOVE_COST(MODE,FROM,TO) \\\n+\tm32c_register_move_cost (MODE, FROM, TO)\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n+\tm32c_memory_move_cost (MODE, CLASS, IN)\n+\n+/* Dividing the Output into Sections (Texts, Data, ...) */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+#define DATA_SECTION_ASM_OP \".data\"\n+#define BSS_SECTION_ASM_OP \".bss\"\n+\n+/* The Overall Framework of an Assembler File */\n+\n+#define ASM_COMMENT_START \";\"\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+\n+/* Output and Generation of Labels */\n+\n+#define GLOBAL_ASM_OP \"\\t.global\\t\"\n+\n+/* Output of Assembler Instructions */\n+\n+#define REGISTER_NAMES {\t\\\n+  \"r0\", \"r2\", \"r1\", \"r3\", \\\n+  \"a0\", \"a1\", \"sb\", \"fb\", \"sp\", \\\n+  \"pc\", \"flg\", \"argp\", \\\n+  \"mem0\",  \"mem2\",  \"mem4\",  \"mem6\",  \"mem8\",  \"mem10\",  \"mem12\",  \"mem14\", \\\n+}\n+\n+#define ADDITIONAL_REGISTER_NAMES { \\\n+  {\"r0l\", 0}, \\\n+  {\"r1l\", 2}, \\\n+  {\"r0r2\", 0}, \\\n+  {\"r1r3\", 2}, \\\n+  {\"a0a1\", 4}, \\\n+  {\"r0r2r1r3\", 0} }\n+\n+#define PRINT_OPERAND(S,X,C) m32c_print_operand (S, X, C)\n+#define PRINT_OPERAND_PUNCT_VALID_P(C) m32c_print_operand_punct_valid_p (C)\n+#define PRINT_OPERAND_ADDRESS(S,X) m32c_print_operand_address (S, X)\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+#define ASM_OUTPUT_REG_PUSH(S,R) m32c_output_reg_push (S, R)\n+#define ASM_OUTPUT_REG_POP(S,R) m32c_output_reg_pop (S, R)\n+\n+/* Output of Dispatch Tables */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(S,V) \\\n+\tfprintf (S, \"\\t.word L%d\\n\", V)\n+\n+/* Assembler Commands for Exception Regions */\n+\n+#define DWARF_CIE_DATA_ALIGNMENT -1\n+\n+/* Assembler Commands for Alignment */\n+\n+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \\\n+\tfprintf (STREAM, \"\\t.p2align\\t%d\\n\", POWER);\n+\n+/* Controlling Debugging Information Format */\n+\n+#define DWARF2_ADDR_SIZE\t4\n+\n+/* Miscellaneous Parameters */\n+\n+#define HAS_LONG_COND_BRANCH false\n+#define HAS_LONG_UNCOND_BRANCH true\n+#define CASE_VECTOR_MODE SImode\n+#define LOAD_EXTEND_OP(MEM) ZERO_EXTEND\n+\n+#define MOVE_MAX 4\n+#define TRULY_NOOP_TRUNCATION(op,ip) 1\n+\n+/* 16 or 24 bit pointers */\n+#define Pmode (TARGET_A16 ? HImode : PSImode)\n+#define FUNCTION_MODE QImode\n+\n+#define REGISTER_TARGET_PRAGMAS() m32c_register_pragmas()\n+\n+#endif"}, {"sha": "aa6d3d7ca27d13cf3fef9d417637e325b510079b", "filename": "gcc/config/m32c/m32c.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,57 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+(define_constants\n+  [(R0_REGNO 0)\n+   (R2_REGNO 1)\n+   (R1_REGNO 2)\n+   (R3_REGNO 3)\n+\n+   (A0_REGNO 4)\n+   (A1_REGNO 5)\n+   (SB_REGNO 6)\n+   (FB_REGNO 7)\n+\n+   (SP_REGNO 8)\n+   (PC_REGNO 9)\n+   (FLG_REGNO 10)\n+   (MEM0_REGNO 12)\n+   (MEM7_REGNO 19)\n+   ])\n+\n+(define_constants\n+  [(UNS_PROLOGUE_END 1)\n+   (UNS_EPILOGUE_START 2)\n+   (UNS_EH_EPILOGUE 3)\n+   (UNS_PUSHM 4)\n+   (UNS_POPM 5)\n+   ])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+;; n = no change, x = clobbered.  The first 16 values are chosen such\n+;; that the enum has one bit set for each flag.\n+(define_attr \"flags\" \"x,c,z,zc,s,sc,sz,szc,o,oc,oz,ozc,os,osc,osz,oszc,n\" (const_string \"n\"))\n+(define_asm_attributes [(set_attr \"flags\" \"x\")])"}, {"sha": "33a5ba30069bdcf5e7aeafc65ab3d137b4e20f03", "filename": "gcc/config/m32c/m32c.opt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fm32c.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.opt?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,45 @@\n+; Target Options for R8C/M16C/M32C\n+; Copyright (C) 2005\n+; Free Software Foundation, Inc.\n+; Contributed by Red Hat.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it\n+; under the terms of the GNU General Public License as published\n+; by the Free Software Foundation; either version 2, or (at your\n+; option) any later version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+; License for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+; 02110-1301, USA.\n+\n+msim\n+Target\n+-msim\tUse simulator runtime\n+\n+mcpu=r8c\n+Target RejectNegative Var(target_cpu,'r') Init('r')\n+-mcpu=r8c\tCompile code for R8C variants\n+\n+mcpu=m16c\n+Target RejectNegative Var(target_cpu,'6')\n+-mcpu=m16c\tCompile code for M16C variants\n+\n+mcpu=m32cm\n+Target RejectNegative Var(target_cpu,'m')\n+-mcpu=m32cm\tCompile code for M32CM variants\n+\n+mcpu=m32c\n+Target RejectNegative Var(target_cpu,'3')\n+-mcpu=m32c\tCompile code for M32C variants\n+\n+memregs=\n+Target RejectNegative Joined Var(target_memregs_string)\n+-memregs=\tNumber of memreg bytes (default: 16, range: 0..16)"}, {"sha": "de0ea4f20df208f2182b83d77031c3293b7d48a4", "filename": "gcc/config/m32c/minmax.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fminmax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fminmax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fminmax.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,55 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; min, max\n+\n+(define_insn \"sminqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm,Raa,Raa\")\n+\t(smin:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:QI 2 \"mrai_operand\" \"iRhlSdRaa,?Rmm,iRhlSdRaa,?Rmm,iRhlSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"min.b\\t%2,%0\"\n+  )\n+\n+(define_insn \"sminhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(smin:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"min.w\\t%2,%0\"\n+  )\n+\n+(define_insn \"smaxqi3\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RhlSd,RhlSd,??Rmm,??Rmm,Raa,Raa\")\n+\t(smax:QI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:QI 2 \"mrai_operand\" \"iRhlSdRaa,?Rmm,iRhlSdRaa,?Rmm,iRhlSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"max.b\\t%2,%0\"\n+  )\n+\n+(define_insn \"smaxhi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm\")\n+\t(smax:HI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"mrai_operand\" \"iRhiSd,?Rmm,iRhiSd,?Rmm\")))]\n+  \"TARGET_A24\"\n+  \"max.w\\t%2,%0\"\n+  )"}, {"sha": "2e18ea3c23e539fe8ebe1f19245ff548381c054a", "filename": "gcc/config/m32c/mov.md", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fmov.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fmov.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmov.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,429 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; move, push, extend, etc.\n+\n+;; Be careful to never create an alternative that has memory as both\n+;; src and dest, as that makes gcc think that mem-mem moves in general\n+;; are supported.  While the chip does support this, it only has two\n+;; address registers and sometimes gcc requires more than that.  One\n+;; example is code like this: a = *b where both a and b are spilled to\n+;; the stack.\n+\n+;; Match push/pop before mov.b for passing char as arg,\n+;; e.g. stdlib/efgcvt.c.\n+(define_insn \"movqi_op\"\n+  [(set (match_operand:QI 0 \"mra_qi_operand\"\n+\t\t\t  \"=Rqi*Rmm, <,          RqiSd*Rmm, SdSs,     Rqi*Rmm, Sd\")\n+\t(match_operand:QI 1 \"mrai_qi_operand\"\n+\t\t\t  \"iRqi*Rmm, iRqiSd*Rmm, >,         iRqi*Rmm, SdSs,    i\"))]\n+  \"m32c_mov_ok (operands, QImode)\"\n+  \"@\n+    mov.b\\t%1,%0\n+    push.b\\t%1\n+    pop.b\\t%0\n+    mov.b\\t%1,%0\n+    mov.b\\t%1,%0\n+    mov.b\\t%1,%0\"\n+  [(set_attr \"flags\" \"sz,*,*,sz,sz,sz\")]\n+  )\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"mra_qi_operand\" \"=RqiSd*Rmm\")\n+\t(match_operand:QI 1 \"mrai_qi_operand\" \"iRqiSd*Rmm\"))]\n+  \"\"\n+  \"if (m32c_prepare_move (operands, QImode)) DONE;\"\n+  )\n+\n+\n+(define_insn \"movhi_op\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\"\n+\t\t\t  \"=Rhi*Rmm,     Sd, SdSs,   *Rcr, RhiSd*Rmm, <, RhiSd*Rmm, <, *Rcr\")\n+\t(match_operand:HI 1 \"general_operand\"\n+\t\t\t  \"iRhi*RmmSdSs, i, Rhi*Rmm, RhiSd*Rmm, *Rcr, iRhiSd*Rmm, >, *Rcr, >\"))]\n+  \"m32c_mov_ok (operands, HImode)\"\n+  \"@\n+   mov.w\\t%1,%0\n+   mov.w\\t%1,%0\n+   mov.w\\t%1,%0\n+   ldc\\t%1,%0\n+   stc\\t%1,%0\n+   push.w\\t%1\n+   pop.w\\t%0\n+   pushc\\t%1\n+   popc\\t%0\"\n+  [(set_attr \"flags\" \"sz,sz,sz,*,*,*,*,*,*\")]\n+  )\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=RhiSd*Rmm\")\n+\t(match_operand:HI 1 \"general_operand\" \"iRhiSd*Rmm\"))]\n+  \"\"\n+  \"if (m32c_prepare_move (operands, HImode)) DONE;\"\n+  )\n+\n+\n+(define_insn \"movpsi_op\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\"\n+\t\t\t   \"=Raa, SdRmmRpi,  Rcl,  RpiSd*Rmm, <,       <, Rcl, Rsi*Rmm\")\n+\t(match_operand:PSI 1 \"general_operand\"\n+\t\t\t   \"sIU3, iSdRmmRpi, iRpiSd*Rmm, Rcl, Rsi*Rmm, Rcl, >, >\"))]\n+  \"TARGET_A24 && m32c_mov_ok (operands, PSImode)\"\n+  \"@\n+   mov.l:s\\t%1,%0\n+   mov.l\\t%1,%0\n+   ldc\\t%1,%0\n+   stc\\t%1,%0\n+   push.l\\t%1\n+   pushc\\t%1\n+   popc\\t%0\n+   #\"\n+  [(set_attr \"flags\" \"sz,sz,*,*,*,*,*,*\")]\n+  )\n+\n+\n+;; The intention here is to combine the add with the move to create an\n+;; indexed move.  GCC doesn't always figure this out itself.\n+\n+(define_mode_macro QHSI [QI HI SI])\n+(define_mode_macro HPSI [(HI \"TARGET_A16\") (PSI \"TARGET_A24\")])\n+\n+(define_peephole2\n+  [(set (match_operand:HPSI 0 \"register_operand\" \"\")\n+\t(plus:HPSI (match_operand:HPSI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:HPSI 2 \"immediate_operand\" \"\")))\n+   (set (match_operand:QHSI 3 \"nonimmediate_operand\" \"\")\n+\t(mem:QHSI (match_operand:HPSI 4 \"register_operand\" \"\")))]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[4])\n+   && dead_or_set_p (peep2_next_insn (1), operands[4])\n+   && ! reg_mentioned_p (operands[0], operands[3])\"\n+  [(set (match_dup 3)\n+\t(mem:QHSI (plus:HPSI (match_dup 1)\n+\t\t\t     (match_dup 2))))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:HPSI 0 \"register_operand\" \"\")\n+\t(plus:HPSI (match_operand:HPSI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:HPSI 2 \"immediate_operand\" \"\")))\n+   (set (mem:QHSI (match_operand:HPSI 4 \"register_operand\" \"\"))\n+\t(match_operand:QHSI 3 \"general_operand\" \"\"))]\n+  \"REGNO (operands[0]) == REGNO (operands[1])\n+   && REGNO (operands[0]) == REGNO (operands[4])\n+   && dead_or_set_p (peep2_next_insn (1), operands[4])\n+   && ! reg_mentioned_p (operands[0], operands[3])\"\n+  [(set (mem:QHSI (plus:HPSI (match_dup 1)\n+\t\t\t     (match_dup 2)))\n+\t(match_dup 3))]\n+  \"\")\n+\n+\n+; Some PSI moves must be split.\n+(define_split\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n+  \"reload_completed && m32c_split_psi_p (operands)\"\n+  [(set (match_dup 2)\n+\t(match_dup 3))\n+   (set (match_dup 4)\n+\t(match_dup 5))]\n+  \"m32c_split_move (operands, PSImode, 3);\"\n+  )\n+\n+(define_expand \"movpsi\"\n+  [(set (match_operand:PSI 0 \"mras_operand\" \"\")\n+\t(match_operand:PSI 1 \"mrasi_operand\" \"\"))]\n+  \"\"\n+  \"if (m32c_prepare_move (operands, PSImode)) DONE;\"\n+  )\n+\n+\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"mras_operand\" \"=RsiSd*Rmm\")\n+\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm\"))]\n+  \"\"\n+  \"if (m32c_split_move (operands, SImode, 0)) DONE;\"\n+  )\n+\n+; All SI moves are split if TARGET_A16\n+(define_insn_and_split \"movsi_splittable\"\n+  [(set (match_operand:SI 0 \"mras_operand\" \"=Rsi<*Rmm,RsiSd*Rmm\")\n+\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm,iRsi>*Rmm\"))]\n+  \"TARGET_A16\"\n+  \"#\"\n+  \"TARGET_A16 && reload_completed\"\n+  [(pc)]\n+  \"m32c_split_move (operands, SImode, 1); DONE;\"\n+  )\n+\n+; The movsi pattern doesn't always match because sometimes the modes\n+; don't match.\n+(define_insn \"push_a01_l\"\n+  [(set (mem:SI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+\t(match_operand 0 \"a_operand\" \"\"))]\n+  \"\"\n+  \"push.l\\t%0\"\n+  )\n+\n+(define_insn \"movsi_24\"\n+  [(set (match_operand:SI 0 \"mras_operand\"  \"=Rsi*Rmm,   Sd,       RsiSd*Rmm,     <\")\n+\t(match_operand:SI 1 \"mrasi_operand\" \"iRsiSd*Rmm, iRsi*Rmm, >, iRsiRaaSd*Rmm\"))]\n+  \"TARGET_A24\"\n+  \"@\n+   mov.l\\t%1,%0\n+   mov.l\\t%1,%0\n+   #\n+   push.l\\t%1\"\n+  )\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"mras_operand\" \"=RdiSd*Rmm\")\n+\t(match_operand:DI 1 \"mrasi_operand\" \"iRdiSd*Rmm\"))]\n+  \"\"\n+  \"if (m32c_split_move (operands, DImode, 0)) DONE;\"\n+  )\n+\n+(define_insn_and_split \"movdi_splittable\"\n+  [(set (match_operand:DI 0 \"mras_operand\" \"=Rdi<*Rmm,RdiSd*Rmm\")\n+\t(match_operand:DI 1 \"mrasi_operand\" \"iRdiSd*Rmm,iRdi>*Rmm\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(pc)]\n+  \"m32c_split_move (operands, DImode, 1); DONE;\"\n+  )\n+\n+\n+\n+\n+(define_insn \"pushqi\"\n+  [(set (mem:QI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+        (match_operand:QI 0 \"mrai_operand\" \"iRqiSd*Rmm\"))]\n+  \"\"\n+  \"push.b\\t%0\"\n+  )\n+\n+(define_expand \"pushhi\"\n+  [(set (mem:HI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+        (match_operand:HI 0 \"\" \"\"))]\n+  \"\"\n+  \"if (TARGET_A16)\n+     gen_pushhi_16 (operands[0]);\n+   else\n+     gen_pushhi_24 (operands[0]);\n+   DONE;\"\n+  )\n+\n+(define_insn \"pushhi_16\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNO)))\n+        (match_operand:HI 0 \"mrai_operand\" \"iRhiSd*Rmm,Rcr\"))]\n+  \"TARGET_A16\"\n+  \"@\n+   push.w\\t%0\n+   pushc\\t%0\"\n+  )\n+\n+(define_insn \"pushhi_24\"\n+  [(set (mem:HI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+        (match_operand:HI 0 \"mrai_operand\" \"iRhiSd*Rmm\"))]\n+  \"TARGET_A24\"\n+  \"push.w\\t%0\"\n+  )\n+\n+;(define_insn \"pushpi\"\n+;  [(set (mem:PSI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+;        (match_operand:PI 0 \"mrai_operand\" \"iRaa,Rcr\"))]\n+;  \"TARGET_A24\"\n+;  \"@\n+;   push.l\\t%0\n+;   pushc\\t%0\"\n+;  )\n+\n+(define_insn \"pushsi\"\n+  [(set (mem:SI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+        (match_operand:SI 0 \"mrai_operand\" \"iRsiSd*Rmm\"))]\n+  \"TARGET_A24\"\n+  \"push.l\\t%0\"\n+  )\n+\n+(define_expand \"pophi\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd*Rmm,Rcr\")\n+        (mem:HI (post_inc:HI (reg:HI SP_REGNO))))]\n+  \"\"\n+  \"if (TARGET_A16)\n+     gen_pophi_16 (operands[0]);\n+   else\n+     gen_pophi_24 (operands[0]);\n+   DONE;\"\n+  )\n+\n+(define_insn \"pophi_16\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd*Rmm,Rcr\")\n+        (mem:HI (post_inc:HI (reg:HI SP_REGNO))))]\n+  \"TARGET_A16\"\n+  \"@\n+   pop.w\\t%0\n+   popc\\t%0\"\n+  )\n+\n+(define_insn \"pophi_24\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd*Rmm\")\n+        (mem:HI (post_inc:PSI (reg:PSI SP_REGNO))))]\n+  \"TARGET_A24\"\n+  \"pop.w\\t%0\"\n+  )\n+\n+(define_insn \"poppsi\"\n+  [(set (match_operand:PSI 0 \"cr_operand\" \"=Rcl\")\n+        (mem:PSI (post_inc:PSI (reg:PSI SP_REGNO))))]\n+  \"TARGET_A24\"\n+  \"popc\\t%0\"\n+  )\n+\n+\n+;; Rhl used here as an HI-mode Rxl\n+(define_insn \"extendqihi2\"\n+[(set (match_operand:HI 0 \"mra_operand\" \"=RhlSd*Rmm\")\n+\t(sign_extend:HI (match_operand:QI 1 \"mra_operand\" \"0\")))]\n+  \"\"\n+  \"exts.b\\t%1\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"r0123_operand\" \"=R03\")\n+\t(sign_extend:SI (match_operand:HI 1 \"r0123_operand\" \"0\")))]\n+  \"\"\n+  \"*\n+   if (REGNO(operands[0]) == 0) return \\\"exts.w\\t%1\\\";\n+   else return \\\"mov.w r1,r3 | sha.w #-8,r3 | sha.w #-7,r3\\\";\"\n+  [(set_attr \"flags\" \"sz\")]\n+  )\n+\n+(define_insn \"extendpsisi2\"\n+  [(set (match_operand:SI 0 \"mr_operand\" \"=R03Sd*Rmm\")\n+\t(sign_extend:SI (match_operand:PSI 1 \"mr_operand\" \"0\")))]\n+  \"\"\n+  \"; expand psi %1 to si %0\"\n+  )\n+\n+(define_insn \"zero_extendpsisi2\"\n+  [(set (match_operand:SI 0 \"mr_operand\" \"=R03Sd*Rmm\")\n+\t(zero_extend:SI (match_operand:PSI 1 \"mr_operand\" \"0\")))]\n+  \"\"\n+  \"; expand psi %1 to si %0\"\n+  )\n+\n+(define_insn \"zero_extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=Raa\")\n+\t(truncate:PSI (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"Rhi\"))))]\n+  \"\"\n+  \"mov.w\\t%1,%0\"\n+  )\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=RsiSd\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"\"\n+  \"mov.w\\t#0,%H0\"\n+  )\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=RsiRaaSd*Rmm\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"\"\n+  \"and.w\\t#255,%0\"\n+  )\n+\n+(define_insn \"truncsipsi2_16\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n+\t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,Rcr\")))]\n+  \"TARGET_A16\"\n+  \"@\n+   ; no-op trunc si %1 to psi %0\n+   #\n+   ldc\\t%1,%0\n+   stc\\t%1,%0\"\n+  )\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"mra_qi_operand\" \"=RqiRmmSd\")\n+\t(truncate:QI (match_operand:HI 1 \"mra_qi_operand\" \"0\")))]\n+  \"\"\n+  \"; no-op trunc hi %1 to qi %0\"\n+  )\n+\n+(define_insn \"truncsipsi2_24\"\n+  [(set (match_operand:PSI 0              \"nonimmediate_operand\" \"=RsiSd*Rmm,Raa,!Rcl,RsiSd*Rmm\")\n+\t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,!Rcl\")))]\n+  \"TARGET_A24\"\n+  \"@\n+   ; no-op trunc si %1 to psi %0\n+   mov.l\\t%1,%0\n+   ldc\\t%1,%0\n+   stc\\t%1,%0\"\n+  )\n+\n+(define_expand \"truncsipsi2\"\n+  [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=RsiRadSd*Rmm,Raa,Rcr,RsiSd*Rmm\")\n+\t(truncate:PSI (match_operand:SI 1 \"nonimmediate_operand\" \"0,RsiSd*Rmm,RsiSd*Rmm,Rcr\")))]\n+  \"\"\n+  \"\"\n+  )\n+\n+(define_expand \"reload_inqi\"\n+  [(set (match_operand:QI 2 \"\" \"=&Rqi\")\n+\t(match_operand:QI 1 \"\" \"\"))\n+   (set (match_operand:QI 0 \"\" \"\")\n+\t(match_dup 2))\n+   ]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outqi\"\n+  [(set (match_operand:QI 2 \"\" \"=&Rqi\")\n+\t(match_operand:QI 1 \"\" \"\"))\n+   (set (match_operand:QI 0 \"\" \"\")\n+\t(match_dup 2))\n+   ]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_inhi\"\n+  [(set (match_operand:HI 2 \"\" \"=&Rhi\")\n+\t(match_operand:HI 1 \"\" \"\"))\n+   (set (match_operand:HI 0 \"\" \"\")\n+\t(match_dup 2))\n+   ]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outhi\"\n+  [(set (match_operand:HI 2 \"\" \"=&Rhi\")\n+\t(match_operand:HI 1 \"\" \"\"))\n+   (set (match_operand:HI 0 \"\" \"\")\n+\t(match_dup 2))\n+   ]\n+  \"\"\n+  \"\")"}, {"sha": "e80d4dc763ae1e5b2c739d54ef4b1d10579d7754", "filename": "gcc/config/m32c/muldiv.md", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fmuldiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fmuldiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fmuldiv.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,236 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; multiply and divide\n+\n+; Here is the pattern for the const_int.\n+(define_insn \"mulqihi3_c\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0\"))\n+                 (match_operand 2 \"immediate_operand\" \"i,i\")))]\n+  \"\"\n+  \"mul.b\\t%2,%1\"\n+)\n+\n+; Here is the pattern for registers and such.\n+(define_insn \"mulqihi3_r\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm,Raa,Raa\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\"))\n+                 (sign_extend:HI (match_operand:QI 2 \"mra_operand\" \"RqiSd,?Rmm,RqiSd,?Rmm,RhlSd,?Rmm\"))))]\n+  \"\"\n+  \"mul.b\\t%2,%1\"\n+)\n+\n+; Don't try to sign_extend a const_int.  Same for all other multiplies.\n+(define_expand \"mulqihi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm,Raa,Raa\")\n+        (mult:HI (sign_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\"))\n+                 (match_operand:QI 2 \"mra_operand\" \"RqiSd,?Rmm,RqiSd,?Rmm,RhlSd,?Rmm\")))]\n+  \"\"\n+  \"{ if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]); }\"\n+)\n+\n+(define_insn \"umulqihi3_c\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,??Rmm\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0\"))\n+                 (match_operand 2 \"immediate_operand\" \"i,i\")))]\n+  \"\"\n+  \"mulu.b\\t%U2,%1\"\n+)\n+\n+(define_insn \"umulqihi3_r\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm,Raa,Raa\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\"))\n+                 (zero_extend:HI (match_operand:QI 2 \"mra_operand\" \"RqiSd,?Rmm,RqiSd,?Rmm,RhlSd,?Rmm\"))))]\n+  \"\"\n+  \"mulu.b\\t%U2,%1\"\n+)\n+\n+(define_expand \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd,RhiSd,??Rmm,??Rmm,Raa,Raa\")\n+        (mult:HI (zero_extend:HI (match_operand:QI 1 \"mra_operand\" \"%0,0,0,0,0,0\"))\n+                 (match_operand:QI 2 \"mra_operand\" \"RqiSd,?Rmm,RqiSd,?Rmm,RhlSd,?Rmm\")))]\n+  \"\"\n+  \"{ if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]); }\"\n+)\n+\n+(define_insn \"mulhisi3_c\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,??Rmm\")\n+        (mult:SI (sign_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0\"))\n+                 (match_operand 2 \"immediate_operand\" \"i,i\")))]\n+  \"\"\n+  \"mul.w\\t%2,%1\"\n+)\n+\n+(define_insn \"mulhisi3_r\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (mult:SI (sign_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\"))\n+                 (sign_extend:SI (match_operand:HI 2 \"mra_operand\" \"RhiSd,?Rmm,RhiSd,?Rmm\"))))]\n+  \"\"\n+  \"mul.w\\t%2,%1\"\n+)\n+\n+(define_expand \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (mult:SI (sign_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\"))\n+                 (match_operand:HI 2 \"mra_operand\" \"RhiSd,?Rmm,RhiSd,?Rmm\")))]\n+  \"\"\n+  \"{ if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]); }\"\n+)\n+\n+(define_insn \"umulhisi3_c\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,??Rmm\")\n+        (mult:SI (zero_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0\"))\n+                 (match_operand 2 \"immediate_operand\" \"i,i\")))]\n+  \"\"\n+  \"mulu.w\\t%u2,%1\"\n+)\n+\n+(define_insn \"umulhisi3_r\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (mult:SI (zero_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\"))\n+                 (zero_extend:SI (match_operand:HI 2 \"mra_operand\" \"RhiSd,?Rmm,RhiSd,?Rmm\"))))]\n+  \"\"\n+  \"mulu.w\\t%u2,%1\"\n+)\n+\n+(define_expand \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"mra_operand\" \"=RsiSd,RsiSd,??Rmm,??Rmm\")\n+        (mult:SI (zero_extend:SI (match_operand:HI 1 \"mra_operand\" \"%0,0,0,0\"))\n+                 (match_operand:HI 2 \"mra_operand\" \"RhiSd,?Rmm,RhiSd,?Rmm\")))]\n+  \"\"\n+  \"{ if (GET_MODE (operands[2]) != VOIDmode)\n+      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]); }\"\n+)\n+\n+\n+; GCC expects to be able to multiply pointer-sized integers too, but\n+; fortunately it only multiplies by powers of two.\n+(define_insn \"mulpsi3\"\n+  [(set (match_operand:PSI 0 \"mra_operand\" \"=RsiSd\")\n+\t(mult:PSI (match_operand:PSI 1 \"mra_operand\" \"%0\")\n+\t\t  (match_operand 2 \"const_int_operand\" \"Ilb\")))]\n+  \"TARGET_A24\"\n+  \"shl.l\\t%b2,%0\"\n+  [(set_attr \"flags\" \"szc\")]\n+  )\n+\n+\n+\n+(define_expand \"divmodqi4\"\n+  [(set (match_dup 4)\n+\t(sign_extend:HI (match_operand:QI 1 \"register_operand\" \"0,0\")))\n+   (parallel [(set (match_operand:QI 0 \"register_operand\" \"=R0w,R0w\")\n+\t\t   (div:QI (match_dup 4)\n+\t\t\t   (match_operand:QI 2 \"general_operand\" \"iRqiSd,?Rmm\")))\n+\t      (set (match_operand:QI 3 \"register_operand\" \"=&R0h,&R0h\")\n+\t\t   (mod:QI (match_dup 4) (match_dup 2)))\n+\t      ])]\n+  \"0\"\n+  \"operands[4] = gen_reg_rtx (HImode);\"\n+  )\n+\n+(define_insn \"divmodqi4_n\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=R0l,R0l\")\n+\t(div:QI (match_operand:HI 1 \"register_operand\" \"R0w,R0w\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"iRqiSd,?Rmm\")))\n+   (set (match_operand:QI 3 \"register_operand\" \"=R0h,R0h\")\n+\t(mod:QI (match_dup 1) (match_dup 2)))\n+   ]\n+  \"0\"\n+  \"div.b\\t%2\"\n+  )\n+\n+(define_expand \"udivmodqi4\"\n+  [(set (match_dup 4)\n+\t(zero_extend:HI (match_operand:QI 1 \"register_operand\" \"0,0\")))\n+   (parallel [(set (match_operand:QI 0 \"register_operand\" \"=R0l,R0l\")\n+\t\t   (udiv:QI (match_dup 4)\n+\t\t\t   (match_operand:QI 2 \"general_operand\" \"iRqiSd,?Rmm\")))\n+\t      (set (match_operand:QI 3 \"register_operand\" \"=&R0h,&R0h\")\n+\t\t   (umod:QI (match_dup 4) (match_dup 2)))\n+\t      ])]\n+  \"0\"\n+  \"operands[4] = gen_reg_rtx (HImode);\"\n+  )\n+\n+(define_insn \"udivmodqi4_n\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=R0l,R0l\")\n+\t(udiv:QI (match_operand:HI 1 \"register_operand\" \"R0w,R0w\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"iRqiSd,?Rmm\")))\n+   (set (match_operand:QI 3 \"register_operand\" \"=R0h,R0h\")\n+\t(umod:QI (match_dup 1) (match_dup 2)))\n+   ]\n+  \"0\"\n+  \"divu.b\\t%2\"\n+  )\n+\n+(define_expand \"divmodhi4\"\n+  [(set (match_dup 4)\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0,0\")))\n+   (parallel [(set (match_operand:HI 0 \"register_operand\" \"=R0w,R0w\")\n+\t\t   (div:HI (match_dup 4)\n+\t\t\t   (match_operand:HI 2 \"general_operand\" \"iRhiSd,?Rmm\")))\n+\t      (set (match_operand:HI 3 \"register_operand\" \"=R2w,R2w\")\n+\t\t   (mod:HI (match_dup 4) (match_dup 2)))\n+\t      ])]\n+  \"\"\n+  \"operands[4] = gen_reg_rtx (SImode);\"\n+  )\n+\n+(define_insn \"divmodhi4_n\"\n+  [(set (match_operand:HI 0 \"m32c_r0_operand\" \"=R0w,R0w\")\n+\t(div:HI (match_operand:SI 1 \"m32c_r0_operand\" \"R02,R02\")\n+\t\t(match_operand:HI 2 \"m32c_notr2_operand\" \"iR1wR3wRaaSd,?Rmm\")))\n+   (set (match_operand:HI 3 \"m32c_r2_operand\" \"=R2w,R2w\")\n+\t(mod:HI (match_dup 1) (match_dup 2)))\n+   ]\n+  \"\"\n+  \"div.w\\t%2\"\n+  )\n+\n+(define_expand \"udivmodhi4\"\n+  [(set (match_dup 4)\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"0,0\")))\n+   (parallel [(set (match_operand:HI 0 \"register_operand\" \"=R0w,R0w\")\n+\t\t   (udiv:HI (match_dup 4)\n+\t\t\t   (match_operand:HI 2 \"general_operand\" \"iRhiSd,?Rmm\")))\n+\t      (set (match_operand:HI 3 \"register_operand\" \"=R2w,R2w\")\n+\t\t   (umod:HI (match_dup 4) (match_dup 2)))\n+\t      ])]\n+  \"\"\n+  \"operands[4] = gen_reg_rtx (SImode);\"\n+  )\n+\n+(define_insn \"udivmodhi4_n\"\n+  [(set (match_operand:HI 0 \"m32c_r0_operand\" \"=R0w,R0w\")\n+\t(udiv:HI (match_operand:SI 1 \"m32c_r0_operand\" \"R02,R02\")\n+\t\t(match_operand:HI 2 \"m32c_notr2_operand\" \"iR1wR3wRaaSd,?Rmm\")))\n+   (set (match_operand:HI 3 \"m32c_r2_operand\" \"=R2w,R2w\")\n+\t(umod:HI (match_dup 1) (match_dup 2)))\n+   ]\n+  \"\"\n+  \"divu.w\\t%2\"\n+  )"}, {"sha": "362f20d1118ff9fe91e5f13e6491d8d65fcf1a98", "filename": "gcc/config/m32c/predicates.md", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,197 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; Predicates\n+\n+; TRUE if the operand is a pseudo-register.\n+(define_predicate \"m32c_pseudo\"\n+  (ior (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) >= FIRST_PSEUDO_REGISTER\"))\n+       (and (match_code \"subreg\")\n+\t    (and (match_test \"GET_CODE (XEXP (op, 0)) == REG\")\n+\t\t (match_test \"REGNO(XEXP (op,0)) >= FIRST_PSEUDO_REGISTER\")))))\n+       \n+\n+; Returning true causes many predicates to NOT match.  We allow\n+; subregs for type changing, but not for size changing.\n+(define_predicate \"m32c_wide_subreg\"\n+  (and (match_code \"subreg\")\n+       (not (match_operand 0 \"m32c_pseudo\")))\n+  {\n+    unsigned int sizeo = GET_MODE_SIZE (GET_MODE (op));\n+    unsigned int sizei = GET_MODE_SIZE (GET_MODE (XEXP (op, 0)));\n+    sizeo = (sizeo + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+    sizei = (sizei + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+    return sizeo != sizei;\n+  })\n+\n+; TRUE for r0 through r3, or a pseudo that reload could put in r0\n+; through r3 (likewise for the next couple too)\n+(define_predicate \"r0123_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) <= R3_REGNO\"))))\n+\n+; TRUE for r0\n+(define_predicate \"m32c_r0_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == R0_REGNO\"))))\n+\n+; TRUE for r1\n+(define_predicate \"m32c_r1_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == R1_REGNO\"))))\n+\n+; TRUE for r2\n+(define_predicate \"m32c_r2_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == R2_REGNO\"))))\n+\n+; TRUE for any general operand except r2.\n+(define_predicate \"m32c_notr2_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (ior (not (match_code \"reg\"))\n+\t    (match_test \"REGNO(op) != R2_REGNO\"))))\n+\n+; TRUE for the stack pointer.\n+(define_predicate \"m32c_sp_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == SP_REGNO\"))))\n+\n+; TRUE for control registers.\n+(define_predicate \"cr_operand\"\n+  (match_code \"reg\")\n+  \"return (REGNO (op) >= SB_REGNO\n+           && REGNO (op) <= FLG_REGNO);\")\n+\n+; TRUE for $a0 or $a1.\n+(define_predicate \"a_operand\"\n+  (match_code \"reg\")\n+  \"return (REGNO (op) == A0_REGNO\n+           || REGNO (op) == A1_REGNO);\")\n+\n+; TRUE for r0 through r3, or a0 or a1.\n+(define_predicate \"ra_operand\"\n+  (and (and (match_operand 0 \"register_operand\" \"\")\n+\t    (not (match_operand 1 \"cr_operand\" \"\")))\n+       (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n+\n+; Likewise, plus TRUE for memory references.\n+(define_predicate \"mra_operand\"\n+  (and (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+\t    (not (match_operand 1 \"cr_operand\" \"\")))\n+       (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n+\n+; Likewise, plus TRUE for subregs.\n+(define_predicate \"mras_operand\"\n+  (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+       (not (match_operand 1 \"cr_operand\" \"\"))))\n+\n+; TRUE for memory, r0..r3, a0..a1, or immediates.\n+(define_predicate \"mrai_operand\"\n+  (and (and (match_operand 0 \"general_operand\" \"\")\n+\t    (not (match_operand 1 \"cr_operand\" \"\")))\n+       (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n+\n+; Likewise, plus true for subregs.\n+(define_predicate \"mrasi_operand\"\n+  (and (match_operand 0 \"general_operand\" \"\")\n+       (not (match_operand 1 \"cr_operand\" \"\"))))\n+\n+; TRUE for r0..r3 or memory.\n+(define_predicate \"mr_operand\"\n+  (and (match_operand 0 \"mra_operand\" \"\")\n+       (not (match_operand 1 \"a_operand\" \"\"))))\n+\n+; TRUE for r1h.  This complicated since r1h isn't a register GCC\n+; normally knows about.\n+(define_predicate \"r1h_operand\"\n+  (match_code \"zero_extract\")\n+  {\n+    rtx reg = XEXP (op, 0);\n+    rtx size = XEXP (op, 1);\n+    rtx pos = XEXP (op, 2);\n+    return (GET_CODE (reg) == REG\n+\t    && REGNO (reg) == R1_REGNO\n+\t    && GET_CODE (size) == CONST_INT\n+\t    && INTVAL (size) == 8\n+\t    && GET_CODE (pos) == CONST_INT\n+\t    && INTVAL (pos) == 8);\n+  })\n+\n+; TRUE if we can shift by this amount.  Constant shift counts have a\n+; limited range.\n+(define_predicate \"shiftcount_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_operand 2 \"const_int_operand\" \"\")\n+\t    (match_test \"-8 <= INTVAL (op) && INTVAL (op) && INTVAL (op) <= 8\"))))\n+\n+; TRUE for r0..r3, a0..a1, or sp.\n+(define_predicate \"mra_or_sp_operand\"\n+  (and (ior (match_operand 0 \"mra_operand\")\n+\t    (match_operand 1 \"m32c_sp_operand\"))\n+       (not (match_operand 2 \"m32c_wide_subreg\" \"\"))))\n+\n+\n+; TRUE for r2 or r3.\n+(define_predicate \"m32c_r2r3_operand\"\n+  (ior (and (match_code \"reg\")\n+\t    (ior (match_test \"REGNO(op) == R2_REGNO\")\n+\t\t (match_test \"REGNO(op) == R3_REGNO\")))\n+       (and (match_code \"subreg\")\n+\t    (match_test \"GET_CODE (XEXP (op, 0)) == REG && (REGNO (XEXP (op, 0)) == R2_REGNO || REGNO (XEXP (op, 0)) == R3_REGNO)\"))))\n+\n+; Likewise, plus TRUE for a0..a1.\n+(define_predicate \"m32c_r2r3a_operand\"\n+  (ior (match_operand 0 \"m32c_r2r3_operand\" \"\")\n+       (match_operand 0 \"a_operand\" \"\")))\n+\n+; These two are only for movqi - no subreg limit\n+(define_predicate \"mra_qi_operand\"\n+  (and (and (match_operand 0 \"nonimmediate_operand\" \"\")\n+\t    (not (match_operand 1 \"cr_operand\" \"\")))\n+       (not (match_operand 1 \"m32c_r2r3a_operand\" \"\"))))\n+\n+(define_predicate \"mrai_qi_operand\"\n+  (and (and (match_operand 0 \"general_operand\" \"\")\n+\t    (not (match_operand 1 \"cr_operand\" \"\")))\n+       (not (match_operand 1 \"m32c_r2r3a_operand\" \"\"))))\n+\n+; TRUE for comparisons we support.\n+(define_predicate \"m32c_cmp_operator\"\n+  (match_code \"eq,ne,gt,gtu,lt,ltu,ge,geu,le,leu\"))\n+\n+; TRUE for mem0\n+(define_predicate \"m32c_mem0_operand\"\n+  (ior (match_operand 0 \"m32c_pseudo\" \"\")\n+       (and (match_code \"reg\")\n+\t    (match_test \"REGNO(op) == MEM0_REGNO\"))))\n+\n+; TRUE for things the call patterns can return.\n+(define_predicate \"m32c_return_operand\"\n+  (ior (match_operand 0 \"m32c_r0_operand\")\n+       (ior (match_operand 0 \"m32c_mem0_operand\")\n+\t    (match_code \"parallel\"))))"}, {"sha": "7e78594badd99a1ccf04d2d71c4ad79789491076", "filename": "gcc/config/m32c/prologue.md", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fprologue.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fprologue.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fprologue.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,139 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; Prologue and epilogue patterns\n+\n+(define_expand \"prologue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"m32c_emit_prologue(); DONE;\"\n+  )\n+\n+; For the next two, operands[0] is the amount of stack space we want\n+; to reserve.\n+\n+; We assume dwarf2out will process each set in sequence.\n+(define_insn \"prologue_enter_16\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNO)))\n+\t(reg:HI FB_REGNO))\n+   (set (reg:HI FB_REGNO)\n+\t(reg:HI SP_REGNO))\n+   (set (reg:HI SP_REGNO)\n+\t(minus:HI (reg:HI SP_REGNO)\n+\t           (match_operand 0 \"const_int_operand\" \"i\")))\n+   ]\n+  \"TARGET_A16\"\n+  \"enter\\t%0\"\n+  )\n+\n+(define_insn \"prologue_enter_24\"\n+  [(set (mem:SI (pre_dec:PSI (reg:PSI SP_REGNO)))\n+\t(reg:SI FB_REGNO))\n+   (set (reg:PSI FB_REGNO)\n+\t(reg:PSI SP_REGNO))\n+   (set (reg:PSI SP_REGNO)\n+\t(minus:PSI (reg:PSI SP_REGNO)\n+\t           (match_operand 0 \"const_int_operand\" \"i\")))\n+   ]\n+  \"TARGET_A24\"\n+  \"enter\\t%0\"\n+  )\n+\n+; Just a comment, for debugging the assembler output.\n+(define_insn \"prologue_end\"\n+  [(unspec_volatile [(const_int 0)] UNS_PROLOGUE_END)]\n+  \"\"\n+  \"; end of prologue\"\n+  )\n+\n+\n+\n+(define_expand \"epilogue\"\n+  [(const_int 1)]\n+  \"\"\n+  \"m32c_emit_epilogue(); DONE;\"\n+  )\n+\n+(define_expand \"eh_return\"\n+  [(match_operand:PSI 0 \"\" \"\")]\n+  \"\"\n+  \"m32c_emit_eh_epilogue(operands[0]); DONE;\"\n+  )\n+\n+(define_insn \"eh_epilogue\"\n+  [(set (pc)\n+\t(unspec_volatile [(match_operand 0 \"m32c_r1_operand\" \"\")\n+\t\t\t  (match_operand 1 \"m32c_r0_operand\" \"\")\n+\t\t\t  ] UNS_EH_EPILOGUE))]\n+  \"\"\n+  \"jmp.a\\t__m32c_eh_return\"\n+  )\n+\n+(define_insn \"epilogue_exitd\"\n+  [(set (reg:PSI SP_REGNO)\n+\t(reg:PSI FB_REGNO))\n+   (set (reg:PSI FB_REGNO)\n+\t(mem:PSI (reg:PSI SP_REGNO)))\n+   (set (reg:PSI SP_REGNO)\n+\t(plus:PSI (reg:PSI SP_REGNO)\n+\t      (match_operand 0 \"const_int_operand\" \"i\")))\n+   (return)\n+   ]\n+  \"\"\n+  \"exitd\"\n+  )\n+\n+(define_insn \"epilogue_reit\"\n+  [(set (reg:PSI SP_REGNO)\n+\t(plus:PSI (reg:PSI SP_REGNO)\n+\t      (match_operand 0 \"const_int_operand\" \"i\")))\n+   (return)\n+   ]\n+  \"\"\n+  \"reit\"\n+  )\n+\n+(define_insn \"epilogue_rts\"\n+  [(return)\n+   ]\n+  \"\"\n+  \"rts\"\n+  )\n+\n+(define_insn \"epilogue_start\"\n+  [(unspec_volatile [(const_int 0)] UNS_EPILOGUE_START)]\n+  \"\"\n+  \"; start of epilogue\"\n+  )\n+\n+\n+; These are used by the prologue/epilogue code.\n+\n+(define_insn \"pushm\"\n+  [(unspec [(match_operand 0 \"const_int_operand\" \"i\")] UNS_PUSHM)]\n+  \"\"\n+  \"pushm\\t%p0\")\n+\n+(define_insn \"popm\"\n+  [(unspec [(match_operand 0 \"const_int_operand\" \"i\")] UNS_POPM)]\n+  \"\"\n+  \"popm\\t%p0\")"}, {"sha": "95b298c02ea7378a8d45cc78fd4587452ef5413f", "filename": "gcc/config/m32c/shift.md", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fshift.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Fshift.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fshift.md?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,299 @@\n+;; Machine Descriptions for R8C/M16C/M32C\n+;; Copyright (C) 2005\n+;; Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+;; 02110-1301, USA.\n+\n+;; bit shifting\n+\n+; Shifts are unusual for m32c.  We only support shifting in one\n+; \"direction\" but the shift count is signed.  Also, immediate shift\n+; counts have a limited range, and variable shift counts have to be in\n+; $r1h which GCC normally doesn't even know about.\n+\n+; Other than compensating for the above, the patterns below are pretty\n+; straightforward.\n+\n+(define_insn \"ashlqi3_i\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RqiSd*Rmm,RqiSd*Rmm\")\n+\t(ashift:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\")))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.b\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.b\\tr1h,%0\"\n+  )\n+\n+(define_insn \"ashrqi3_i\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RqiSd*Rmm,RqiSd*Rmm\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.b\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.b\\tr1h,%0\"\n+  )\n+\n+(define_insn \"lshlqi3_i\"\n+  [(set (match_operand:QI 0 \"mra_operand\" \"=RqiSd*Rmm,RqiSd*Rmm\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"mra_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   shl.b\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tshl.b\\tr1h,%0\"\n+  )\n+\n+\n+(define_expand \"ashlqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"mra_operand\" \"\")\n+\t(ashift:QI (match_operand:QI 1 \"mra_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"\")))\n+   (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, 1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"ashrqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"mra_operand\" \"\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"mra_operand\" \"\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"\"))))\n+   (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"lshrqi3\"\n+  [(parallel [(set (match_operand:QI 0 \"mra_operand\" \"\")\n+\t\t   (lshiftrt:QI (match_operand:QI 1 \"mra_operand\" \"\")\n+\t\t\t\t(neg:QI (match_operand:QI 2 \"general_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+(define_insn \"ashlhi3_i\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=SdRhi*Rmm,SdRhi*Rmm\")\n+\t(ashift:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\")))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.w\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.w\\tr1h,%0\"\n+  )\n+\n+(define_insn \"ashrhi3_i\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=SdRhi*Rmm,SdRhi*Rmm\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.w\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.w\\tr1h,%0\"\n+  )\n+\n+(define_insn \"lshlhi3_i\"\n+  [(set (match_operand:HI 0 \"mra_operand\" \"=RhiSd*Rmm,RhiSd*Rmm\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"mra_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   shl.w\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tshl.w\\tr1h,%0\"\n+  )\n+\n+\n+(define_expand \"ashlhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+\t\t   (ashift:HI (match_operand:HI 1 \"mra_operand\" \"\")\n+\t\t\t      (match_operand:QI 2 \"general_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, 1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"ashrhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+\t\t   (ashiftrt:HI (match_operand:HI 1 \"mra_operand\" \"\")\n+\t\t\t\t(neg:QI (match_operand:QI 2 \"general_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"lshrhi3\"\n+  [(parallel [(set (match_operand:HI 0 \"mra_operand\" \"\")\n+\t\t   (lshiftrt:HI (match_operand:HI 1 \"mra_operand\" \"\")\n+\t\t\t\t(neg:QI (match_operand:QI 2 \"general_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+\n+\n+\n+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+\n+(define_insn \"ashlpsi3_i\"\n+  [(set (match_operand:PSI 0 \"mra_operand\" \"=R02RaaSd*Rmm,R02RaaSd*Rmm\")\n+\t(ashift:PSI (match_operand:PSI 1 \"mra_operand\" \"0,0\")\n+\t\t    (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\")))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"TARGET_A24\"\n+  \"@\n+   sha.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.l\\tr1h,%0\"\n+  )\n+\n+(define_insn \"ashrpsi3_i\"\n+  [(set (match_operand:PSI 0 \"mra_operand\" \"=R02RaaSd*Rmm,R02RaaSd*Rmm\")\n+\t(ashiftrt:PSI (match_operand:PSI 1 \"mra_operand\" \"0,0\")\n+\t\t      (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"TARGET_A24\"\n+  \"@\n+   sha.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.l\\tr1h,%0\"\n+  )\n+\n+(define_insn \"lshlpsi3_i\"\n+  [(set (match_operand:PSI 0 \"mra_operand\" \"=R02RaaSd,??Rmm\")\n+\t(lshiftrt:PSI (match_operand:PSI 1 \"mra_operand\" \"0,0\")\n+\t\t      (neg:QI (match_operand:QI 2 \"shiftcount_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"TARGET_A24\"\n+  \"@\n+   shl.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tshl.l\\tr1h,%0\"\n+  )\n+\n+\n+(define_expand \"ashlpsi3\"\n+  [(parallel [(set (match_operand:PSI 0 \"mra_operand\" \"\")\n+\t\t   (ashift:PSI (match_operand:PSI 1 \"mra_operand\" \"\")\n+\t\t\t       (match_operand:QI 2 \"mrai_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"TARGET_A24\"\n+  \"if (m32c_prepare_shift (operands, 1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"ashrpsi3\"\n+  [(parallel [(set (match_operand:PSI 0 \"mra_operand\" \"\")\n+\t\t   (ashiftrt:PSI (match_operand:PSI 1 \"mra_operand\" \"\")\n+\t\t\t\t (neg:QI (match_operand:QI 2 \"mrai_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"TARGET_A24\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"lshrpsi3\"\n+  [(parallel [(set (match_operand:PSI 0 \"mra_operand\" \"\")\n+\t\t   (lshiftrt:PSI (match_operand:PSI 1 \"mra_operand\" \"\")\n+\t\t\t\t (neg:QI (match_operand:QI 2 \"mrai_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"TARGET_A24\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+\n+\n+(define_insn \"ashlsi3_i\"\n+  [(set (match_operand:SI 0 \"r0123_operand\" \"=R03,R03\")\n+\t(ashift:SI (match_operand:SI 1 \"r0123_operand\" \"0,0\")\n+\t\t   (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\")))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.l\\tr1h,%0\"\n+  )\n+\n+(define_insn \"ashrsi3_i\"\n+  [(set (match_operand:SI 0 \"r0123_operand\" \"=R03,R03\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"r0123_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   sha.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tsha.l\\tr1h,%0\"\n+  )\n+\n+(define_insn \"lshlsi3_i\"\n+  [(set (match_operand:SI 0 \"r0123_operand\" \"=R03,R03\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"r0123_operand\" \"0,0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"mrai_operand\" \"In4,R1w\"))))\n+   (clobber (match_scratch:HI 3 \"=X,R1w\"))]\n+  \"\"\n+  \"@\n+   shl.l\\t%2,%0\n+   mov.b\\tr1l,r1h\\n\\tshl.l\\tr1h,%0\"\n+  )\n+\n+\n+(define_expand \"ashlsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"r0123_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"r0123_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"mrai_operand\" \"\")))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, 1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"ashrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"r0123_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_operand:SI 1 \"r0123_operand\" \"\")\n+\t\t\t\t(neg:QI (match_operand:QI 2 \"mrai_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 4))\n+     DONE;\"\n+  )\n+\n+(define_expand \"lshrsi3\"\n+  [(parallel [(set (match_operand:SI 0 \"r0123_operand\" \"\")\n+\t\t   (lshiftrt:SI (match_operand:SI 1 \"r0123_operand\" \"\")\n+\t\t\t\t(neg:QI (match_operand:QI 2 \"mrai_operand\" \"\"))))\n+\t      (clobber (match_scratch:HI 3 \"\"))])]\n+  \"\"\n+  \"if (m32c_prepare_shift (operands, -1, 5))\n+     DONE;\"\n+  )"}, {"sha": "a7b8ec7dc1bfedb971a6cfe4ee0dd40800653b6a", "filename": "gcc/config/m32c/t-m32c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Ft-m32c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fconfig%2Fm32c%2Ft-m32c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Ft-m32c?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -0,0 +1,70 @@\n+# Target Makefile Fragment for R8C/M16C/M32C\n+# Copyright (C) 2005\n+# Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 2, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+# License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to the Free\n+# Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+# 02110-1301, USA.\n+\n+LIB1ASMSRC = m32c/m32c-lib1.S\n+\n+LIB1ASMFUNCS = \\\n+\t__m32c_memregs \\\n+\t__m32c_eh_return \\\n+\t__m32c_mulsi3 \\\n+\t__m32c_cmpsi2 \\\n+\t__m32c_ucmpsi2 \\\n+\t__m32c_jsri16\n+\n+LIB2FUNCS_EXTRA = $(srcdir)/config/m32c/m32c-lib2.c\n+\n+# floating point emulation libraries\n+\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'\t\t\t\t> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c\t\t\t>> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+# target-specific files\n+\n+md_file = md\n+\n+MD_FILES = m32c predicates addsub bitops cond jump minmax mov muldiv prologue shift\n+\n+# Doing it this way lets the gen* programs report the right line numbers.\n+\n+md : $(MD_FILES:%=$(srcdir)/config/m32c/%.md) $(srcdir)/config/m32c/t-m32c\n+\tfor md in $(MD_FILES); do \\\n+\t  echo \"(include \\\"$(srcdir)/config/m32c/$$md.md\\\")\"; \\\n+\tdone > md\n+\n+m32c-pragma.o: $(srcdir)/config/m32c/m32c-pragma.c $(RTL_H) $(TREE_H) $(CONFIG_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+\n+# We support four CPU series, but R8C and M16C share one multilib, and\n+# M32C and M32CM share another.\n+\n+MULTILIB_OPTIONS = mcpu=m32cm\n+MULTILIB_DIRNAMES = m32cm\n+MULTILIB_MATCHES = mcpu?m32cm=mcpu?m32c mcpu?r8c=mcpu?m16c\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o"}, {"sha": "d4c71ecd76a5aa08da3136b9ff26175f465f7207", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -206,8 +206,8 @@ Bud Davis for work on the G77 and gfortran compilers.\n Mo DeJong for GCJ and libgcj bug fixes.\n \n @item\n-DJ Delorie for the DJGPP port, build and libiberty maintenance, and\n-various bug fixes.\n+DJ Delorie for the DJGPP port, build and libiberty maintenance,\n+various bug fixes, and the M32C port.\n \n @item\n Arnaud Desitter for helping to debug gfortran."}, {"sha": "69bd151f84b681053686af4c9310f2408389cd66", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -1887,10 +1887,10 @@ this attribute to work correctly.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, C4x, M32R/D and Xstormy16 ports to indicate\n-that the specified function is an interrupt handler.  The compiler will\n-generate function entry and exit sequences suitable for use in an\n-interrupt handler when this attribute is present.\n+Use this attribute on the ARM, AVR, C4x, M32C, M32R/D and Xstormy16\n+ports to indicate that the specified function is an interrupt handler.\n+The compiler will generate function entry and exit sequences suitable\n+for use in an interrupt handler when this attribute is present.\n \n Note, interrupt handlers for the Blackfin, m68k, H8/300, H8/300H, H8S, and\n SH processors can be specified via the @code{interrupt_handler} attribute.\n@@ -8953,6 +8953,7 @@ for further explanation.\n \n @menu\n * ARM Pragmas::\n+* M32C Pragmas::\n * RS/6000 and PowerPC Pragmas::\n * Darwin Pragmas::\n * Solaris Pragmas::\n@@ -8984,6 +8985,21 @@ Do not affect the @code{long_call} or @code{short_call} attributes of\n subsequent functions.\n @end table\n \n+@node M32C Pragmas\n+@subsection M32C Pragmas\n+\n+@table @code\n+@item memregs @var{number}\n+@cindex pragma, memregs\n+Overrides the command line option @code{-memregs=} for the current\n+file.  Use with care!  This pragma must be before any function in the\n+file, and mixing different memregs values in different objects may\n+make them incompatible.  This pragma is useful when a\n+performance-critical function uses a memreg for temporary values,\n+as it may allow you to reduce the number of memregs used.\n+\n+@end table\n+\n @node RS/6000 and PowerPC Pragmas\n @subsection RS/6000 and PowerPC Pragmas\n "}, {"sha": "ac046c7a7fade65a6f8a1343bb6e64a723e62c18", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -2246,6 +2246,8 @@ GNU Compiler Collection on your machine.\n @item\n @uref{#iq2000-x-elf,,iq2000-*-elf}\n @item\n+@uref{#m32c-x-elf,,m32c-*-elf}\n+@item\n @uref{#m32r-x-elf,,m32r-*-elf}\n @item\n @uref{#m6811-elf,,m6811-elf}\n@@ -3180,6 +3182,13 @@ switch and using the configure option @option{--with-cpu-@var{cpu_type}}.\n Vitesse IQ2000 processors.  These are used in embedded\n applications.  There are no standard Unix configurations.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{m32c-x-elf}m32c-*-elf\n+Renesas M32C processor.\n+This configuration is intended for embedded systems.\n+\n @html\n <hr />\n @end html"}, {"sha": "45e2a25dc7298e03923cc4958507f69001269d75", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -544,6 +544,9 @@ Objective-C and Objective-C++ Dialects}.\n -mno-flush-trap -mflush-trap=@var{number} @gol\n -G @var{num}}\n \n+@emph{M32C Options}\n+@gccoptlist{-mcpu=@var{cpu} -msim -memregs=@var{number}}\n+\n @emph{M680x0 Options}\n @gccoptlist{-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 @gol\n -m68060  -mcpu32  -m5200  -m68881  -mbitfield  -mc68000  -mc68020   @gol\n@@ -6957,6 +6960,7 @@ platform.\n * HPPA Options::\n * i386 and x86-64 Options::\n * IA-64 Options::\n+* M32C Options::\n * M32R/D Options::\n * M680x0 Options::\n * M68hc1x Options::\n@@ -9371,6 +9375,39 @@ to 64 bits.  These are HP-UX specific flags.\n \n @end table\n \n+@node M32C Options\n+@subsection M32C Options\n+@cindex M32C options\n+\n+@table @gcctabopt\n+@item -mcpu=@var{name}\n+@opindex mcpu=\n+Select the CPU for which code is generated.  @var{name} may be one of\n+@samp{r8c} for the R8C/Tiny series, @samp{m16c} for the M16C (up to\n+/60) series, @samp{m32cm} for the M16C/80 series, or @samp{m32c} for\n+the M32C/80 series.\n+\n+@item -msim\n+@opindex msim\n+Specifies that the program will be run on the simulator.  This causes\n+an alternate runtime library to be linked in which supports, for\n+example, file I/O.  You must not use this option when generating\n+programs that will run on real hardware; you must provide your own\n+runtime library for whatever I/O functions are needed.\n+\n+@item -memregs=@var{number}\n+@opindex memregs=\n+Specifies the number of memory-based pseudo-registers GCC will use\n+during code generation.  These pseudo-registers will be used like real\n+registers, so there is a tradeoff between GCC's ability to fit the\n+code into available registers, and the performance penalty of using\n+memory instead of registers.  Note that all modules in a program must\n+be compiled with the same value for this option.  Because of that, you\n+must not use this option with the default runtime libraries gcc\n+builds.\n+\n+@end table\n+\n @node M32R/D Options\n @subsection M32R/D Options\n @cindex M32R/D options"}, {"sha": "682269b0d16d73505ec108908447af61f3f22020", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2d076326a730238139d00c940fd306a5ddf3e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=38b2d076326a730238139d00c940fd306a5ddf3e", "patch": "@@ -2165,6 +2165,135 @@ An integer constant with all bits set except exactly one.\n Any SYMBOL_REF.\n @end table\n \n+@item M32C---@file{m32c.c}\n+\n+@item Rsp\n+@itemx Rfb\n+@itemx Rsb\n+@samp{$sp}, @samp{$fb}, @samp{$sb}.\n+\n+@item Rcr\n+Any control register, when they're 16 bits wide (nothing if control\n+registers are 24 bits wide)\n+\n+@item Rcl\n+Any control register, when they're 24 bits wide.\n+\n+@item R0w\n+@itemx R1w\n+@itemx R2w\n+@itemx R3w\n+$r0, $r1, $r2, $r3.\n+\n+@item R02\n+$r0 or $r2, or $r2r0 for 32 bit values.\n+\n+@item R13\n+$r1 or $r3, or $r3r1 for 32 bit values.\n+\n+@item Rdi\n+A register that can hold a 64 bit value.\n+\n+@item Rhl\n+$r0 or $r1 (registers with addressable high/low bytes)\n+\n+@item R23\n+$r2 or $r3\n+\n+@item Raa\n+Address registers\n+\n+@item Raw\n+Address registers when they're 16 bits wide.\n+\n+@item Ral\n+Address registers when they're 24 bits wide.\n+\n+@item Rqi\n+Registers that can hold QI values.\n+\n+@item Rad\n+Registers that can be used with displacements ($a0, $a1, $sb).\n+\n+@item Rsi\n+Registers that can hold 32 bit values.\n+\n+@item Rhi\n+Registers that can hold 16 bit values.\n+\n+@item Rhc\n+Registers chat can hold 16 bit values, including all control\n+registers.\n+\n+@item Rra\n+$r0 through R1, plus $a0 and $a1.\n+\n+@item Rfl\n+The flags register.\n+\n+@item Rmm\n+The memory-based pseudo-registers $mem0 through $mem15.\n+\n+@item Rpi\n+Registers that can hold pointers (16 bit registers for r8c, m16c; 24\n+bit registers for m32cm, m32c).\n+\n+@item Rpa\n+Matches multiple registers in a PARALLEL to form a larger register.\n+Used to match function return values.\n+\n+@item Is3\n+-8 @dots{} 7\n+\n+@item IS1\n+-128 @dots{} 127\n+\n+@item IS2\n+-32768 @dots{} 32767\n+\n+@item IU2\n+0 @dots{} 65535\n+\n+@item In4\n+-8 @dots{} -1 or 1 @dots{} 8\n+\n+@item In5\n+-16 @dots{} -1 or 1 @dots{} 16\n+\n+@item In4\n+-8 @dots{} -1 or 1 @dots{} 8\n+\n+@item IM2\n+-65536 @dots{} -1\n+\n+@item Ilb\n+An 8 bit value with exactly one bit set.\n+\n+@item Ilw\n+A 16 bit value with exactly one bit set.\n+\n+@item Sd\n+The common src/dest memory addressing modes.\n+\n+@item Sa\n+Memory addressed using $a0 or $a1.\n+\n+@item Si\n+Memory addressed with immediate addresses.\n+\n+@item Ss\n+Memory addressed using the stack pointer ($sp).\n+\n+@item Sf\n+Memory addressed using the frame base register ($fb).\n+\n+@item Ss\n+Memory addressed using the small base register ($sb).\n+\n+@item S1\n+$r1h\n+\n+\n @item MIPS---@file{mips.h}\n @table @code\n @item d"}]}