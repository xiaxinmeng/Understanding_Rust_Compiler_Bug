{"sha": "0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2NmM1NjI2MTdlMzFjOTFmNzA0OGRhNzYxZWQwZWFmOWQ1YzFiYg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-16T23:19:45Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-16T23:19:45Z"}, "message": "re PR target/54236 ([SH] Improve addc and subc insn utilization)\n\n\tPR target/54236\n\t* config/sh/sh.md (addc): Add commutative modifier.\n\t(*addc, *minus_plus_one, *subc, *negc): New insns and splits.\n\n\tPR target/54236\n\t* gcc.target/sh/pr54236-1.c: New.\n\nFrom-SVN: r190459", "tree": {"sha": "4e1cabf9877a8b6fbc1ec3c14a08cbf72706a59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e1cabf9877a8b6fbc1ec3c14a08cbf72706a59c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/comments", "author": null, "committer": null, "parents": [{"sha": "9839afaf5e6f9271f902f50ed2827a4faa274894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839afaf5e6f9271f902f50ed2827a4faa274894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9839afaf5e6f9271f902f50ed2827a4faa274894"}], "stats": {"total": 231, "additions": 229, "deletions": 2}, "files": [{"sha": "e25ed3c6fc19fabd064af6eaaf5052c712b48c2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "patch": "@@ -1,3 +1,9 @@\n+2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* config/sh/sh.md (addc): Add commutative modifier.\n+\t(*addc, *minus_plus_one, *subc, *negc): New insns and splits.\n+\n 2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/39423"}, {"sha": "26d3e636d9144740f4c65cba3866daf7cb468712", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "patch": "@@ -1686,7 +1686,7 @@\n \n (define_insn \"addc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n \t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))\n \t\t (reg:SI T_REG)))\n    (set (reg:SI T_REG)\n@@ -1695,6 +1695,76 @@\n   \"addc\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; A simplified version of the addc insn, where the exact value of the\n+;; T bit doesn't matter.  This is easier for combine to pick up.\n+;; We allow a reg or 0 for one of the operands in order to be able to\n+;; do 'reg + T' sequences.  Reload will load the constant 0 into the reg\n+;; as needed.\n+(define_insn \"*addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_or_0_operand\" \"r\"))\n+\t\t (match_operand:SI 3 \"t_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"addc\t%2,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;; Split 'reg + reg + 1' into a sett addc sequence, as it can be scheduled\n+;; better, if the sett insn can be done early.\n+(define_insn_and_split \"*addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(plus:SI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n+\t\t (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (const_int 1))\n+   (parallel [(set (match_dup 0) (plus:SI (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t          (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+;; Sometimes combine will try to do 'reg + (0-reg) + 1' if the *addc pattern\n+;; matched.  Split this up into a simple sub add sequence, as this will save\n+;; us one sett insn.\n+(define_insn_and_split \"*minus_plus_one\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(plus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t   (match_operand:SI 2 \"arith_reg_operand\" \"\"))\n+\t\t (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (const_int 1)))])\n+\n+;; Split 'reg + T' into 'reg + 0 + T' to utilize the addc insn.\n+;; If the 0 constant can be CSE-ed, this becomes a one instruction\n+;; operation, as opposed to sequences such as\n+;;\tmovt\tr2\n+;;\tadd\tr2,r3\n+;;\n+;; Even if the constant is not CSE-ed, a sequence such as\n+;;\tmov\t#0,r2\n+;;\taddc\tr2,r3\n+;; can be scheduled much better since the load of the constant can be\n+;; done earlier, before any comparison insns that store the result in\n+;; the T bit.\n+(define_insn_and_split \"*addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"t_reg_operand\" \"\")\n+\t\t (match_operand:SI 2 \"arith_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:SI (plus:SI (match_dup 2) (const_int 0))\n+\t\t\t    (match_dup 1)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"arith_operand\" \"\")\n@@ -1805,6 +1875,63 @@\n   \"subc\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; A simplified version of the subc insn, where the exact value of the\n+;; T bit doesn't matter.  This is easier for combine to pick up.\n+;; We allow a reg or 0 for one of the operands in order to be able to\n+;; do 'reg - T' sequences.  Reload will load the constant 0 into the reg\n+;; as needed.\n+(define_insn \"*subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(minus:SI (minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t\t    (match_operand:SI 2 \"arith_reg_or_0_operand\" \"r\"))\n+\t\t  (match_operand:SI 3 \"t_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"subc\t%2,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n+;; Split reg - reg - 1 into a sett subc sequence, as it can be scheduled\n+;; better, if the sett insn can be done early.\n+;; Notice that combine turns 'a - b - 1' into 'a + (~b)'.\n+(define_insn_and_split \"*subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(plus:SI (not:SI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n+\t\t (match_operand:SI 2 \"arith_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:SI T_REG) (const_int 1))\n+   (parallel [(set (match_dup 0)\n+\t\t   (minus:SI (minus:SI (match_dup 2) (match_dup 1))\n+\t\t\t     (reg:SI T_REG)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n+;; Split 'reg - T' into 'reg - 0 - T' to utilize the subc insn.\n+;; If the 0 constant can be CSE-ed, this becomes a one instruction\n+;; operation, as opposed to sequences such as\n+;;\tmovt\tr2\n+;;\tsub\tr2,r3\n+;;\n+;; Even if the constant is not CSE-ed, a sequence such as\n+;;\tmov\t#0,r2\n+;;\tsubc\tr2,r3\n+;; can be scheduled much better since the load of the constant can be\n+;; done earlier, before any comparison insns that store the result in\n+;; the T bit.\n+(define_insn_and_split \"*subc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"t_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:SI (minus:SI (match_dup 1) (const_int 0))\n+\t\t\t     (match_dup 2)))\n+\t      (clobber (reg:SI T_REG))])])\n+\n (define_insn \"*subsi3_internal\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n@@ -4530,6 +4657,19 @@ label:\n   \"negc\t%1,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; A simplified version of the negc insn, where the exact value of the\n+;; T bit doesn't matter.  This is easier for combine to pick up.\n+;; Notice that '0 - x - 1' is the same as '~x', thus we don't specify\n+;; extra patterns for this case.\n+(define_insn \"*negc\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(minus:SI (neg:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t  (match_operand:SI 2 \"t_reg_operand\" \"\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH1\"\n+  \"negc\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"*negdi_media\"\n   [(set (match_operand:DI 0 \"arith_reg_dest\" \"=r\")\n \t(neg:DI (match_operand:DI 1 \"arith_reg_operand\" \"r\")))]"}, {"sha": "b70fec5aff8e867d4b93485a56a029f5204a56a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "patch": "@@ -1,4 +1,9 @@\n-2012-08-17  Hans-Peter Nilsson  <hp@axis.com>\n+2012-08-16  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54236\n+\t* gcc.target/sh/pr54236-1.c: New.\n+\n+2012-08-16  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* lib/target-supports.exp (check_effective_target_sync_int_long)\n \t(check_effective_target_sync_char_short): Enable for crisv32-*"}, {"sha": "3a7453c0d74af0959be5518351c823a3daec7108", "filename": "gcc/testsuite/gcc.target/sh/pr54236-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c66c562617e31c91f7048da761ed0eaf9d5c1bb/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54236-1.c?ref=0c66c562617e31c91f7048da761ed0eaf9d5c1bb", "patch": "@@ -0,0 +1,76 @@\n+/* Tests to check the utilization of addc, subc and negc instructions in\n+   special cases.  If everything works as expected we won't see any\n+   movt instructions in these cases.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } } */\n+/* { dg-final { scan-assembler-times \"addc\" 3 } } */\n+/* { dg-final { scan-assembler-times \"subc\" 3 } } */\n+/* { dg-final { scan-assembler-times \"sett\" 4 } } */\n+/* { dg-final { scan-assembler-times \"negc\" 1 } } */\n+/* { dg-final { scan-assembler-not \"movt\" } } */\n+\n+int\n+test_00 (int a, int b, int c, int d)\n+{\n+  /* 1x addc, 1x sett  */\n+  return a + b + 1;\n+}\n+\n+int\n+test_01 (int a, int b, int c, int d)\n+{\n+  /* 1x addc  */\n+  return a + (c == d);\n+}\n+\n+int\n+test_02 (int a, int b, int c, int d)\n+{\n+  /* 1x subc, 1x sett  */\n+  return a - b - 1;\n+}\n+\n+int\n+test_03 (int a, int b, int c, int d)\n+{\n+  /* 1x subc  */\n+  return a - (c == d);\n+}\n+\n+int\n+test_04 (int a, int b, int c, int d)\n+{\n+  /* 1x addc, 1x sett  */\n+  return a + b + c + 1;\n+}\n+\n+int\n+test_05 (int a, int b, int c, int d)\n+{\n+  /* 1x subc, 1x sett  */\n+  return a - b - c - 1;\n+}\n+\n+int\n+test_06 (int a, int b, int c, int d)\n+{\n+  /* 1x negc  */\n+  return 0 - a - (b == c);\n+}\n+\n+int\n+test_07 (int *vec)\n+{\n+  /* Must not see a 'sett' or 'addc' here.\n+     This is a case where combine tries to produce\n+     'a + (0 - b) + 1' out of 'a - b + 1'.  */\n+  int z = vec[0];\n+  int vi = vec[1];\n+  int zi = vec[2];\n+\n+  if (zi != 0 && z < -1)\n+    vi -= (((vi >> 7) & 0x01) << 1) - 1;\n+\n+  return vi;\n+}"}]}