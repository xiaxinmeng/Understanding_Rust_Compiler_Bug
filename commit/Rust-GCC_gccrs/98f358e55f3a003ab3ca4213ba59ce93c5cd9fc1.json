{"sha": "98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmMzU4ZTU1ZjNhMDAzYWIzY2E0MjEzYmE1OWNlOTNjNWNkOWZjMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-29T13:20:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-29T13:20:20Z"}, "message": "except.c (verify_eh_tree): Fix handling of fun!=cfun; be ready for removed regions.\n\n\t* except.c (verify_eh_tree): Fix handling of fun!=cfun; be ready\n\tfor removed regions.\n\nFrom-SVN: r145232", "tree": {"sha": "a1a35a096649c19b4a8776f5298d39f97494074d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1a35a096649c19b4a8776f5298d39f97494074d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1/comments", "author": null, "committer": null, "parents": [{"sha": "13a9fa4483a31c1b7f35fdc83720f75fdc94231c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a9fa4483a31c1b7f35fdc83720f75fdc94231c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a9fa4483a31c1b7f35fdc83720f75fdc94231c"}], "stats": {"total": 78, "additions": 44, "deletions": 34}, "files": [{"sha": "738c87effb33d08f618e51558438bfff0383e500", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "patch": "@@ -1,3 +1,8 @@\n+2009-03-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (verify_eh_tree): Fix handling of fun!=cfun; be ready\n+\tfor removed regions.\n+\n 2009-03-29  Jan Hubicka  <jh@suse.cz>\n \n \t* except.c (dump_eh_tree): Dump all datastructures."}, {"sha": "c6a5ca51c1c224b39b40facff91c458f318c2050", "filename": "gcc/except.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=98f358e55f3a003ab3ca4213ba59ce93c5cd9fc1", "patch": "@@ -3968,23 +3968,25 @@ verify_eh_tree (struct function *fun)\n   int j;\n   int depth = 0;\n \n-  i = fun->eh->region_tree;\n-  if (! i)\n+  if (!fun->eh->region_tree)\n     return;\n   for (j = fun->eh->last_region_number; j > 0; --j)\n-    if ((i = VEC_index (eh_region, cfun->eh->region_array, j)))\n+    if ((i = VEC_index (eh_region, fun->eh->region_array, j)))\n       {\n-\tcount++;\n-\tif (i->region_number != j)\n+\tif (i->region_number == j)\n+\t  count++;\n+\tif (i->region_number != j && (!i->aka || !bitmap_bit_p (i->aka, j)))\n \t  {\n-\t    error (\"region_array is corrupted for region %i\", i->region_number);\n+\t    error (\"region_array is corrupted for region %i\",\n+\t\t   i->region_number);\n \t    err = true;\n \t  }\n       }\n+  i = fun->eh->region_tree;\n \n   while (1)\n     {\n-      if (VEC_index (eh_region, cfun->eh->region_array, i->region_number) != i)\n+      if (VEC_index (eh_region, fun->eh->region_array, i->region_number) != i)\n \t{\n \t  error (\"region_array is corrupted for region %i\", i->region_number);\n \t  err = true;\n@@ -3996,16 +3998,17 @@ verify_eh_tree (struct function *fun)\n \t}\n       if (i->may_contain_throw && outer && !outer->may_contain_throw)\n \t{\n-\t  error (\"region %i may contain throw and is contained in region that may not\",\n-\t\t i->region_number);\n+\t  error\n+\t    (\"region %i may contain throw and is contained in region that may not\",\n+\t     i->region_number);\n \t  err = true;\n \t}\n       if (depth < 0)\n \t{\n \t  error (\"negative nesting depth of region %i\", i->region_number);\n \t  err = true;\n \t}\n-      nvisited ++;\n+      nvisited++;\n       /* If there are sub-regions, process them.  */\n       if (i->inner)\n \touter = i, i = i->inner, depth++;\n@@ -4015,30 +4018,32 @@ verify_eh_tree (struct function *fun)\n       /* Otherwise, step back up the tree to the next peer.  */\n       else\n \t{\n-\t  do {\n-\t    i = i->outer;\n-\t    depth--;\n-\t    if (i == NULL)\n-\t      {\n-\t\tif (depth != -1)\n-\t\t  {\n-\t\t    error (\"tree list ends on depth %i\", depth + 1);\n-\t\t    err = true;\n-\t\t  }\n-\t\tif (count != nvisited)\n-\t\t  {\n-\t\t    error (\"array does not match the region tree\");\n-\t\t    err = true;\n-\t\t  }\n-\t\tif (err)\n-\t\t  {\n-\t\t    dump_eh_tree (stderr, fun);\n-\t\t    internal_error (\"verify_eh_tree failed\");\n-\t\t  }\n-\t        return;\n-\t      }\n-\t    outer = i->outer;\n-\t  } while (i->next_peer == NULL);\n+\t  do\n+\t    {\n+\t      i = i->outer;\n+\t      depth--;\n+\t      if (i == NULL)\n+\t\t{\n+\t\t  if (depth != -1)\n+\t\t    {\n+\t\t      error (\"tree list ends on depth %i\", depth + 1);\n+\t\t      err = true;\n+\t\t    }\n+\t\t  if (count != nvisited)\n+\t\t    {\n+\t\t      error (\"array does not match the region tree\");\n+\t\t      err = true;\n+\t\t    }\n+\t\t  if (err)\n+\t\t    {\n+\t\t      dump_eh_tree (stderr, fun);\n+\t\t      internal_error (\"verify_eh_tree failed\");\n+\t\t    }\n+\t\t  return;\n+\t\t}\n+\t      outer = i->outer;\n+\t    }\n+\t  while (i->next_peer == NULL);\n \t  i = i->next_peer;\n \t}\n     }"}]}