{"sha": "243cae0a5108e18638c9c4844baaf392171130d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQzY2FlMGE1MTA4ZTE4NjM4YzljNDg0NGJhYWYzOTIxNzExMzBkNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T14:52:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T14:52:04Z"}, "message": "[multiple changes]\n\n2011-08-03  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cfdlli.adb, bindgen.adb, exp_ch4.adb, exp_ch13.adb, sem_warn.adb,\n\texp_ch3.adb, exp_ch3.ads: Minor reformatting.\n\n2011-08-03  Pascal Obry  <obry@adacore.com>\n\n\t* g-awk.ads: Minor comment fix.\n\n2011-08-03  Sergey Rybin  <rybin@adacore.com>\n\n\t* tree_io.ads (ASIS_Version_Number): Update because of the changes in\n\tthe tree structure related to discriminant constraints.\n\tOriginal_Discriminant cannot be used any more for computing the\n\tdefining name for the reference to a discriminant.\n\n2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_disp.adb (Is_Tag_Indeterminate): If the return type of the\n\tfunction is not visibly tagged, this is not a dispatching call and\n\ttherfore is not Tag_Indeterminate, even if the function is marked as\n\tdispatching on result.\n\nFrom-SVN: r177281", "tree": {"sha": "b9ab9bb1336eeba18a505aac48dfff903488077f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ab9bb1336eeba18a505aac48dfff903488077f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/243cae0a5108e18638c9c4844baaf392171130d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243cae0a5108e18638c9c4844baaf392171130d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243cae0a5108e18638c9c4844baaf392171130d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243cae0a5108e18638c9c4844baaf392171130d4/comments", "author": null, "committer": null, "parents": [{"sha": "f553e7bc12de8a7d47f51cc5ea0c3d2a22de487e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f553e7bc12de8a7d47f51cc5ea0c3d2a22de487e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f553e7bc12de8a7d47f51cc5ea0c3d2a22de487e"}], "stats": {"total": 395, "additions": 217, "deletions": 178}, "files": [{"sha": "66c9f5ad8fb165f6cb3ab760d927e6e5dcfa2d3c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -1,3 +1,26 @@\n+2011-08-03  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cfdlli.adb, bindgen.adb, exp_ch4.adb, exp_ch13.adb, sem_warn.adb,\n+\texp_ch3.adb, exp_ch3.ads: Minor reformatting.\n+\n+2011-08-03  Pascal Obry  <obry@adacore.com>\n+\n+\t* g-awk.ads: Minor comment fix.\n+\n+2011-08-03  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* tree_io.ads (ASIS_Version_Number): Update because of the changes in\n+\tthe tree structure related to discriminant constraints.\n+\tOriginal_Discriminant cannot be used any more for computing the\n+\tdefining name for the reference to a discriminant.\n+\n+2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_disp.adb (Is_Tag_Indeterminate): If the return type of the\n+\tfunction is not visibly tagged, this is not a dispatching call and\n+\ttherfore is not Tag_Indeterminate, even if the function is marked as\n+\tdispatching on result.\n+\n 2011-08-03  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch13.adb: Add with and use clauses for Restrict and Rident."}, {"sha": "93a88a725d635ddbfeb3584c96126261ce009b0d", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -234,24 +234,28 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       C : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n       N : Count_Type := 1;\n       P : List (C);\n+\n    begin\n       while N <= Source.Capacity loop\n          P.Nodes (N).Prev := Source.Nodes (N).Prev;\n          P.Nodes (N).Next := Source.Nodes (N).Next;\n          P.Nodes (N).Element := Source.Nodes (N).Element;\n          N := N + 1;\n       end loop;\n+\n       P.Free := Source.Free;\n       P.Length := Source.Length;\n       P.First := Source.First;\n       P.Last := Source.Last;\n+\n       if P.Free >= 0 then\n          N := Source.Capacity + 1;\n          while N <= C loop\n             Free (P, N);\n             N := N + 1;\n          end loop;\n       end if;\n+\n       return P;\n    end Copy;\n \n@@ -269,7 +273,8 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    begin\n       if not Has_Element (Container => Container,\n-                          Position  => Position) then\n+                          Position  => Position)\n+      then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n@@ -349,7 +354,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n            \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.First;\n          pragma Assert (N (N (X).Next).Prev = Container.First);\n \n@@ -388,7 +393,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n            \"attempt to tamper with elements (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.Last;\n          pragma Assert (N (N (X).Prev).Next = Container.Last);\n \n@@ -407,7 +412,8 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    function Element\n      (Container : List;\n-      Position  : Cursor) return Element_Type is\n+      Position  : Cursor) return Element_Type\n+   is\n    begin\n       if not Has_Element (Container => Container, Position  => Position) then\n          raise Constraint_Error with\n@@ -427,15 +433,19 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Position  : Cursor := No_Element) return Cursor\n    is\n       From : Count_Type := Position.Node;\n+\n    begin\n       if From = 0 and Container.Length = 0 then\n          return No_Element;\n       end if;\n+\n       if From = 0 then\n          From := Container.First;\n       end if;\n+\n       if Position.Node /= 0 and then\n-        not Has_Element (Container, Position) then\n+        not Has_Element (Container, Position)\n+      then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n       end if;\n@@ -444,6 +454,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          if Container.Nodes (From).Element = Item then\n             return (Node => From);\n          end if;\n+\n          From := Container.Nodes (From).Next;\n       end loop;\n \n@@ -459,6 +470,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Container.First = 0 then\n          return No_Element;\n       end if;\n+\n       return (Node => Container.First);\n    end First;\n \n@@ -507,8 +519,8 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n             Container.Free := 0;\n \n          else\n-            for I in Container.Free .. Container.Capacity - 1 loop\n-               N (I).Next := I + 1;\n+            for J in Container.Free .. Container.Capacity - 1 loop\n+               N (J).Next := J + 1;\n             end loop;\n \n             N (Container.Capacity).Next := 0;\n@@ -532,6 +544,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       function Is_Sorted (Container : List) return Boolean is\n          Nodes : Node_Array renames Container.Nodes;\n          Node  : Count_Type := Container.First;\n+\n       begin\n          for I in 2 .. Container.Length loop\n             if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n@@ -618,9 +631,10 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          ---------------\n \n          procedure Partition (Pivot, Back : Count_Type) is\n-            Node : Count_Type := N (Pivot).Next;\n+            Node : Count_Type;\n \n          begin\n+            Node := N (Pivot).Next;\n             while Node /= Back loop\n                if N (Node).Element < N (Pivot).Element then\n                   declare\n@@ -709,6 +723,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Position.Node = 0 then\n          return False;\n       end if;\n+\n       return Container.Nodes (Position.Node).Prev /= -1;\n    end Has_Element;\n \n@@ -763,7 +778,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Count     : Count_Type := 1)\n    is\n       Position : Cursor;\n-\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;\n@@ -893,6 +907,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n             Process (Container, (Node => Node));\n             Node := Container.Nodes (Node).Next;\n          end loop;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -934,12 +949,14 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    function Left (Container : List; Position : Cursor) return List is\n       Curs : Cursor := Position;\n-      C : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          return C;\n       end if;\n+\n       if not Has_Element (Container, Curs) then\n          raise Constraint_Error;\n       end if;\n@@ -949,6 +966,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Left;\n \n@@ -1015,9 +1033,11 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if Position.Node = 0 then\n          return No_Element;\n       end if;\n+\n       if not Has_Element (Container, Position) then\n          raise Program_Error with \"Position cursor has no element\";\n       end if;\n+\n       return (Node => Container.Nodes (Position.Node).Next);\n    end Next;\n \n@@ -1052,6 +1072,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       if not Has_Element (Container, Position) then\n          raise Program_Error with \"Position cursor has no element\";\n       end if;\n+\n       return (Node => Container.Nodes (Position.Node).Prev);\n    end Previous;\n \n@@ -1316,13 +1337,15 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    function Right (Container : List; Position : Cursor) return List is\n       Curs : Cursor := First (Container);\n-      C : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n       Node : Count_Type;\n+\n    begin\n       if Curs = No_Element then\n          Clear (C);\n          return C;\n       end if;\n+\n       if Position /= No_Element and not Has_Element (Container, Position) then\n          raise Constraint_Error;\n       end if;\n@@ -1332,6 +1355,7 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n          Delete (C, Curs);\n          Curs := Next (Container, (Node => Node));\n       end loop;\n+\n       return C;\n    end Right;\n \n@@ -1537,15 +1561,19 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n    function Strict_Equal (Left, Right : List) return Boolean is\n       CL : Count_Type := Left.First;\n       CR : Count_Type := Right.First;\n+\n    begin\n       while CL /= 0 or CR /= 0 loop\n          if CL /= CR or else\n-           Left.Nodes (CL).Element /= Right.Nodes (CL).Element then\n+           Left.Nodes (CL).Element /= Right.Nodes (CL).Element\n+         then\n             return False;\n          end if;\n+\n          CL := Left.Nodes (CL).Next;\n          CR := Right.Nodes (CR).Next;\n       end loop;\n+\n       return True;\n    end Strict_Equal;\n \n@@ -1558,7 +1586,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       I, J      : Cursor)\n    is\n    begin\n-\n       if I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -1603,7 +1630,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       I_Next, J_Next : Cursor;\n \n    begin\n-\n       if I.Node = 0 then\n          raise Constraint_Error with \"I cursor has no element\";\n       end if;\n@@ -1653,7 +1679,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-\n       if Position.Node = 0 then\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;"}, {"sha": "b88ed0019f7a9b2812d46b2325dc274f9e11e08d", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -2125,7 +2125,8 @@ package body Bindgen is\n \n    procedure Gen_Main_C is\n       Needs_Library_Finalization : constant Boolean :=\n-        not Configurable_Run_Time_On_Target and then Has_Finalizer;\n+                                     not Configurable_Run_Time_On_Target\n+                                       and then Has_Finalizer;\n       --  For restricted run-time libraries (ZFP and Ravenscar) tasks are\n       --  non-terminating, so we do not want library-level finalization.\n \n@@ -2649,7 +2650,8 @@ package body Bindgen is\n       --  function Get_Ada_Main_Name for details on the form of the name.\n \n       Needs_Library_Finalization : constant Boolean :=\n-        not Configurable_Run_Time_On_Target and then Has_Finalizer;\n+                                     not Configurable_Run_Time_On_Target\n+                                       and then Has_Finalizer;\n       --  For restricted run-time libraries (ZFP and Ravenscar) tasks are\n       --  non-terminating, so we do not want finalization.\n \n@@ -3004,7 +3006,9 @@ package body Bindgen is\n    procedure Gen_Output_File_C (Filename : String) is\n \n       Needs_Library_Finalization : constant Boolean :=\n-        not Configurable_Run_Time_On_Target and then Has_Finalizer;\n+                                     not Configurable_Run_Time_On_Target\n+                                       and then Has_Finalizer;\n+      --  ??? seems like we repeat this cantation often, should it be global?\n \n       Bfile : Name_Id;\n       pragma Warnings (Off, Bfile);"}, {"sha": "9f182357ee79ad81a014c10f7d72e3a4f4796bd6", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -214,7 +214,7 @@ package body Exp_Ch13 is\n \n    procedure Expand_N_Free_Statement (N : Node_Id) is\n       Expr : constant Node_Id := Expression (N);\n-      Typ  : Entity_Id := Etype (Expr);\n+      Typ  : Entity_Id;\n \n    begin\n       --  Certain run-time configurations and targets do not provide support\n@@ -232,6 +232,8 @@ package body Exp_Ch13 is\n \n       --  Use the base type to perform the collection check\n \n+      Typ := Etype (Expr);\n+\n       if Ekind (Typ) = E_Access_Subtype then\n          Typ := Etype (Typ);\n       end if;"}, {"sha": "0e4094660835eb5792a53fc4bebc5ad83536bdfa", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 59, "deletions": 68, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -841,10 +841,10 @@ package body Exp_Ch3 is\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier =>\n                   Make_Defining_Identifier (Loc, Name_uMaster),\n-                Constant_Present => True,\n-                Object_Definition =>\n+                Constant_Present    => True,\n+                Object_Definition   =>\n                   New_Reference_To (Standard_Integer, Loc),\n-                Expression =>\n+                Expression          =>\n                   Make_Explicit_Dereference (Loc,\n                     New_Reference_To (RTE (RE_Current_Master), Loc)));\n \n@@ -1659,9 +1659,9 @@ package body Exp_Ch3 is\n       then\n          if Chars (Selector_Name (Id_Ref)) /= Name_uParent then\n             Append_To (Res,\n-              Make_Init_Call (\n-                Obj_Ref => New_Copy_Tree (First_Arg),\n-                Typ     => Typ));\n+              Make_Init_Call\n+                (Obj_Ref => New_Copy_Tree (First_Arg),\n+                 Typ     => Typ));\n          end if;\n       end if;\n \n@@ -1852,7 +1852,7 @@ package body Exp_Ch3 is\n          then\n             Exp :=\n               Make_Attribute_Reference (Loc,\n-                Prefix =>\n+                Prefix         =>\n                   Make_Identifier (Loc, Name_uInit),\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n@@ -1880,9 +1880,9 @@ package body Exp_Ch3 is\n          then\n             Append_To (Res,\n               Make_Assignment_Statement (Loc,\n-                Name =>\n+                Name       =>\n                   Make_Selected_Component (Loc,\n-                    Prefix =>\n+                    Prefix        =>\n                       New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n                     Selector_Name =>\n                       New_Reference_To (First_Tag_Component (Typ), Loc)),\n@@ -1908,9 +1908,9 @@ package body Exp_Ch3 is\n            and then not Is_Immutably_Limited_Type (Typ)\n          then\n             Append_To (Res,\n-              Make_Adjust_Call (\n-                Obj_Ref => New_Copy_Tree (Lhs),\n-                Typ     => Etype (Id)));\n+              Make_Adjust_Call\n+                (Obj_Ref => New_Copy_Tree (Lhs),\n+                 Typ     => Etype (Id)));\n          end if;\n \n          return Res;\n@@ -2069,7 +2069,7 @@ package body Exp_Ch3 is\n          Res :=\n            New_List (\n              Make_Procedure_Call_Statement (Loc,\n-               Name =>\n+               Name                   =>\n                  New_Occurrence_Of (Parent_Proc, Loc),\n                Parameter_Associations => Args));\n \n@@ -2111,8 +2111,8 @@ package body Exp_Ch3 is\n               Make_Parameter_Specification (Loc,\n                 Defining_Identifier =>\n                   Make_Defining_Identifier (Loc, Name_uO),\n-                In_Present => True,\n-                Parameter_Type =>\n+                In_Present          => True,\n+                Parameter_Type      =>\n                   New_Reference_To (Rec_Type, Loc))));\n             Set_Result_Definition (Spec_Node,\n               New_Reference_To (RTE (RE_Storage_Offset), Loc));\n@@ -2128,7 +2128,7 @@ package body Exp_Ch3 is\n             Set_Declarations (Body_Node, New_List);\n             Set_Handled_Statement_Sequence (Body_Node,\n               Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => New_List (\n+                Statements     => New_List (\n                   Make_Simple_Return_Statement (Loc,\n                     Expression =>\n                       Make_Attribute_Reference (Loc,\n@@ -2684,14 +2684,11 @@ package body Exp_Ch3 is\n \n             Append_To (Stmts,\n               Make_Assignment_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (Counter_Id, Loc),\n+                Name       => New_Reference_To (Counter_Id, Loc),\n                 Expression =>\n                   Make_Op_Add (Loc,\n-                    Left_Opnd =>\n-                      New_Reference_To (Counter_Id, Loc),\n-                    Right_Opnd =>\n-                      Make_Integer_Literal (Loc, 1))));\n+                    Left_Opnd  => New_Reference_To (Counter_Id, Loc),\n+                    Right_Opnd => Make_Integer_Literal (Loc, 1))));\n          end Increment_Counter;\n \n          ------------------\n@@ -2716,9 +2713,9 @@ package body Exp_Ch3 is\n             Append_To (Decls,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Counter_Id,\n-                Object_Definition =>\n+                Object_Definition   =>\n                   New_Reference_To (Standard_Integer, Loc),\n-                Expression =>\n+                Expression          =>\n                   Make_Integer_Literal (Loc, 0)));\n          end Make_Counter;\n \n@@ -2831,10 +2828,8 @@ package body Exp_Ch3 is\n                     Build_Initialization_Call\n                       (Loc,\n                        Make_Selected_Component (Loc,\n-                         Prefix =>\n-                           Make_Identifier (Loc, Name_uInit),\n-                         Selector_Name =>\n-                           New_Occurrence_Of (Id, Loc)),\n+                         Prefix        => Make_Identifier (Loc, Name_uInit),\n+                         Selector_Name => New_Occurrence_Of (Id, Loc)),\n                        Typ,\n                        In_Init_Proc => True,\n                        Enclos_Type  => Rec_Type,\n@@ -2896,13 +2891,13 @@ package body Exp_Ch3 is\n             if Restricted_Profile then\n                Append_To (Stmts,\n                  Make_Assignment_Statement (Loc,\n-                   Name =>\n+                   Name       =>\n                      Make_Selected_Component (Loc,\n                        Prefix        => Make_Identifier (Loc, Name_uInit),\n                        Selector_Name => Make_Identifier (Loc, Name_uTask_Id)),\n                    Expression =>\n                      Make_Attribute_Reference (Loc,\n-                       Prefix =>\n+                       Prefix         =>\n                          Make_Selected_Component (Loc,\n                            Prefix        => Make_Identifier (Loc, Name_uInit),\n                            Selector_Name => Make_Identifier (Loc, Name_uATCB)),\n@@ -3245,7 +3240,6 @@ package body Exp_Ch3 is\n \n          De := First_Discriminant (Rec_Ent);\n          Dp := First_Discriminant (Etype (Rec_Ent));\n-\n          while Present (De) loop\n             pragma Assert (Present (Dp));\n \n@@ -4657,9 +4651,9 @@ package body Exp_Ch3 is\n            or else not Comes_From_Source (N)\n          then\n             Insert_Action_After (Init_After,\n-              Make_Init_Call (\n-                Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                Typ     => Base_Type (Typ)));\n+              Make_Init_Call\n+                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                 Typ     => Base_Type (Typ)));\n \n          --  Abort allowed\n \n@@ -4680,9 +4674,9 @@ package body Exp_Ch3 is\n \n             declare\n                L   : constant List_Id := New_List (\n-                       Make_Init_Call (\n-                         Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                         Typ     => Base_Type (Typ)));\n+                       Make_Init_Call\n+                         (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                          Typ     => Base_Type (Typ)));\n \n                Blk : constant Node_Id :=\n                        Make_Block_Statement (Loc,\n@@ -4748,11 +4742,13 @@ package body Exp_Ch3 is\n             declare\n                Init_Expr : constant Node_Id :=\n                              Static_Initialization (Base_Init_Proc (Typ));\n+\n             begin\n                if Present (Init_Expr) then\n                   Set_Expression\n                     (N, New_Copy_Tree (Init_Expr, New_Scope => Current_Scope));\n                   return;\n+\n                else\n                   Initialization_Warning (Id_Ref);\n \n@@ -6647,11 +6643,11 @@ package body Exp_Ch3 is\n                null;\n \n             elsif (Needs_Finalization (Desig_Type)\n-                     and then Convention (Desig_Type) /= Convention_Java\n-                     and then Convention (Desig_Type) /= Convention_CIL)\n+                    and then Convention (Desig_Type) /= Convention_Java\n+                    and then Convention (Desig_Type) /= Convention_CIL)\n               or else\n                 (Is_Incomplete_Or_Private_Type (Desig_Type)\n-                   and then No (Full_View (Desig_Type))\n+                  and then No (Full_View (Desig_Type))\n \n                   --  An exception is made for types defined in the run-time\n                   --  because Ada.Tags.Tag itself is such a type and cannot\n@@ -6670,8 +6666,8 @@ package body Exp_Ch3 is\n \n               or else\n                 (Is_Array_Type (Desig_Type)\n-                   and then not Is_Frozen (Desig_Type)\n-                   and then Needs_Finalization (Component_Type (Desig_Type)))\n+                  and then not Is_Frozen (Desig_Type)\n+                  and then Needs_Finalization (Component_Type (Desig_Type)))\n             then\n                Build_Finalization_Collection (Def_Id);\n             end if;\n@@ -8533,12 +8529,10 @@ package body Exp_Ch3 is\n \n       Formals := New_List (\n         Make_Parameter_Specification (Loc,\n-          Defining_Identifier =>\n-            Make_Defining_Identifier (Loc, Name_V),\n-          In_Present  => True,\n-          Out_Present => True,\n-          Parameter_Type =>\n-            New_Reference_To (Tag_Typ, Loc)));\n+          Defining_Identifier => Make_Defining_Identifier (Loc, Name_V),\n+          In_Present          => True,\n+          Out_Present         => True,\n+          Parameter_Type      => New_Reference_To (Tag_Typ, Loc)));\n \n       --  F : Boolean := True\n \n@@ -8547,12 +8541,9 @@ package body Exp_Ch3 is\n       then\n          Append_To (Formals,\n            Make_Parameter_Specification (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_F),\n-             Parameter_Type =>\n-               New_Reference_To (Standard_Boolean, Loc),\n-             Expression =>\n-               New_Reference_To (Standard_True, Loc)));\n+             Defining_Identifier => Make_Defining_Identifier (Loc, Name_F),\n+             Parameter_Type      => New_Reference_To (Standard_Boolean, Loc),\n+             Expression          => New_Reference_To (Standard_True, Loc)));\n       end if;\n \n       return\n@@ -8607,8 +8598,7 @@ package body Exp_Ch3 is\n            Make_Function_Specification (Loc,\n              Defining_Unit_Name       => Id,\n              Parameter_Specifications => Profile,\n-             Result_Definition        =>\n-               New_Reference_To (Ret_Type, Loc));\n+             Result_Definition        => New_Reference_To (Ret_Type, Loc));\n       end if;\n \n       if Is_Interface (Tag_Typ) then\n@@ -8658,12 +8648,14 @@ package body Exp_Ch3 is\n          Ret_Type := Empty;\n       end if;\n \n-      return Predef_Spec_Or_Body (Loc,\n-        Name     => Make_TSS_Name (Tag_Typ, Name),\n-        Tag_Typ  => Tag_Typ,\n-        Profile  => Build_Stream_Attr_Profile (Loc, Tag_Typ, Name),\n-        Ret_Type => Ret_Type,\n-        For_Body => For_Body);\n+      return\n+        Predef_Spec_Or_Body\n+          (Loc,\n+           Name     => Make_TSS_Name (Tag_Typ, Name),\n+           Tag_Typ  => Tag_Typ,\n+           Profile  => Build_Stream_Attr_Profile (Loc, Tag_Typ, Name),\n+           Ret_Type => Ret_Type,\n+           For_Body => For_Body);\n    end Predef_Stream_Attr_Spec;\n \n    ---------------------------------\n@@ -8931,14 +8923,13 @@ package body Exp_Ch3 is\n             Set_Handled_Statement_Sequence (Decl,\n               Make_Handled_Sequence_Of_Statements (Loc,\n                 Statements => New_List (\n-                  Make_Final_Call (\n-                    Obj_Ref => Make_Identifier (Loc, Name_V),\n-                    Typ     => Tag_Typ))));\n+                  Make_Final_Call\n+                    (Obj_Ref => Make_Identifier (Loc, Name_V),\n+                     Typ     => Tag_Typ))));\n          else\n             Set_Handled_Statement_Sequence (Decl,\n               Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => New_List (\n-                  Make_Null_Statement (Loc))));\n+                Statements => New_List (Make_Null_Statement (Loc))));\n          end if;\n \n          Append_To (Res, Decl);\n@@ -8954,7 +8945,7 @@ package body Exp_Ch3 is\n    function Predefined_Primitive_Freeze\n      (Tag_Typ : Entity_Id) return List_Id\n    is\n-      Res     : constant List_Id    := New_List;\n+      Res     : constant List_Id := New_List;\n       Prim    : Elmt_Id;\n       Frnodes : List_Id;\n "}, {"sha": "7b67e23a8cfa5048065930f8b86d0915ef2f0bd8", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -113,22 +113,6 @@ package Exp_Ch3 is\n    --  want Gigi to see the node. This function can't delete the node itself\n    --  since it would confuse any remaining processing of the freeze node.\n \n-   function Get_Simple_Init_Val\n-     (T    : Entity_Id;\n-      N    : Node_Id;\n-      Size : Uint := No_Uint) return Node_Id;\n-   --  For a type which Needs_Simple_Initialization (see above), prepares the\n-   --  tree for an expression representing the required initial value. N is a\n-   --  node whose source location used in constructing this tree which is\n-   --  returned as the result of the call. The Size parameter indicates the\n-   --  target size of the object if it is known (indicated by a value that is\n-   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n-   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n-   --  the Size. The object size is needed to prepare a known invalid value for\n-   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n-   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n-   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n-\n    procedure Init_Secondary_Tags\n      (Typ            : Entity_Id;\n       Target         : Node_Id;\n@@ -155,4 +139,20 @@ package Exp_Ch3 is\n    --  set to False, but if Consider_IS is set to True, then the cases above\n    --  mentioning Normalize_Scalars also apply for Initialize_Scalars mode.\n \n+   function Get_Simple_Init_Val\n+     (T    : Entity_Id;\n+      N    : Node_Id;\n+      Size : Uint := No_Uint) return Node_Id;\n+   --  For a type which Needs_Simple_Initialization (see above), prepares the\n+   --  tree for an expression representing the required initial value. N is a\n+   --  node whose source location used in constructing this tree which is\n+   --  returned as the result of the call. The Size parameter indicates the\n+   --  target size of the object if it is known (indicated by a value that is\n+   --  not No_Uint and is greater than zero). If Size is not given (Size set to\n+   --  No_Uint, or non-positive), then the Esize of T is used as an estimate of\n+   --  the Size. The object size is needed to prepare a known invalid value for\n+   --  use by Normalize_Scalars. A call to this routine where T is a scalar\n+   --  type is only valid if we are in Normalize_Scalars or Initialize_Scalars\n+   --  mode, or if N is the node for a 'Invalid_Value attribute node.\n+\n end Exp_Ch3;"}, {"sha": "e340fee75a17d496af9e73f223ba79daf650c6fd", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -660,14 +660,13 @@ package body Exp_Ch4 is\n               Make_Raise_Program_Error (Loc,\n                 Condition =>\n                   Make_Op_Gt (Loc,\n-                    Left_Opnd =>\n+                    Left_Opnd  =>\n                       Build_Get_Access_Level (Loc,\n                         Make_Attribute_Reference (Loc,\n-                          Prefix => Ref_Node,\n+                          Prefix         => Ref_Node,\n                           Attribute_Name => Name_Tag)),\n                     Right_Opnd =>\n-                      Make_Integer_Literal (Loc,\n-                        Type_Access_Level (PtrT))),\n+                      Make_Integer_Literal (Loc, Type_Access_Level (PtrT))),\n                 Reason => PE_Accessibility_Check_Failed));\n          end if;\n       end Apply_Accessibility_Check;\n@@ -974,11 +973,9 @@ package body Exp_Ch4 is\n \n                New_Decl :=\n                  Make_Object_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Temporary (Loc, 'P'),\n-                   Object_Definition =>\n-                     New_Reference_To (PtrT, Loc),\n-                   Expression =>\n+                   Defining_Identifier => Make_Temporary (Loc, 'P'),\n+                   Object_Definition   => New_Reference_To (PtrT, Loc),\n+                   Expression          =>\n                      Unchecked_Convert_To (PtrT,\n                        New_Reference_To (Temp, Loc)));\n \n@@ -1085,10 +1082,10 @@ package body Exp_Ch4 is\n               and then Present (Associated_Collection (PtrT))\n             then\n                Insert_Action (N,\n-                 Make_Set_Finalize_Address_Ptr_Call (\n-                   Loc     => Loc,\n-                   Typ     => T,\n-                   Ptr_Typ => PtrT));\n+                 Make_Set_Finalize_Address_Ptr_Call\n+                   (Loc     => Loc,\n+                    Typ     => T,\n+                    Ptr_Typ => PtrT));\n             end if;\n          end if;\n \n@@ -1111,8 +1108,7 @@ package body Exp_Ch4 is\n              Object_Definition   => New_Reference_To (PtrT, Loc),\n              Expression          =>\n                Make_Allocator (Loc,\n-                 Expression =>\n-                   New_Reference_To (Etype (Exp), Loc)));\n+                 Expression => New_Reference_To (Etype (Exp), Loc)));\n \n          --  Copy the Comes_From_Source flag for the allocator we just built,\n          --  since logically this allocator is a replacement of the original\n@@ -1138,10 +1134,9 @@ package body Exp_Ch4 is\n            and then Present (Associated_Collection (PtrT))\n          then\n             Insert_Action (N,\n-              Make_Attach_Call (\n-                Obj_Ref =>\n-                  New_Reference_To (Temp, Loc),\n-                Ptr_Typ => PtrT));\n+              Make_Attach_Call\n+                (Obj_Ref => New_Reference_To (Temp, Loc),\n+                 Ptr_Typ => PtrT));\n          end if;\n \n          Rewrite (N, New_Reference_To (Temp, Loc));\n@@ -1215,8 +1210,7 @@ package body Exp_Ch4 is\n                Insert_Action (Exp,\n                  Make_Subtype_Declaration (Loc,\n                    Defining_Identifier => ConstrT,\n-                   Subtype_Indication  =>\n-                     Make_Subtype_From_Expr (Exp, T)));\n+                   Subtype_Indication  => Make_Subtype_From_Expr (Exp, T)));\n                Freeze_Itype (ConstrT, Exp);\n                Rewrite (Exp, OK_Convert_To (ConstrT, Internal_Exp));\n             end;\n@@ -3269,9 +3263,8 @@ package body Exp_Ch4 is\n          Temp_Decl :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp_Id,\n-             Aliased_Present => True,\n-             Object_Definition =>\n-               New_Occurrence_Of (Etyp, Loc));\n+             Aliased_Present     => True,\n+             Object_Definition   => New_Occurrence_Of (Etyp, Loc));\n \n          if Nkind (Expression (N)) = N_Qualified_Expression then\n             Set_Expression (Temp_Decl, Expression (Expression (N)));\n@@ -3294,8 +3287,7 @@ package body Exp_Ch4 is\n \n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n-             Prefix =>\n-               New_Occurrence_Of (Temp_Id, Loc),\n+             Prefix         => New_Occurrence_Of (Temp_Id, Loc),\n              Attribute_Name => Name_Unrestricted_Access));\n \n          Analyze_And_Resolve (N, PtrT);\n@@ -3332,8 +3324,7 @@ package body Exp_Ch4 is\n                  Make_Attribute_Reference (Loc,\n                    Prefix         => New_Occurrence_Of (E, Loc),\n                    Attribute_Name => Name_Length,\n-                   Expressions    => New_List (\n-                     Make_Integer_Literal (Loc, J)));\n+                   Expressions    => New_List (Make_Integer_Literal (Loc, J)));\n \n                if J = 1 then\n                   Res := Len;\n@@ -3400,8 +3391,8 @@ package body Exp_Ch4 is\n       if Is_Access_Constant (PtrT)\n         and then Nkind (Expression (N)) = N_Qualified_Expression\n         and then Compile_Time_Known_Value (Expression (Expression (N)))\n-        and then Size_Known_At_Compile_Time (Etype (Expression\n-                                                    (Expression (N))))\n+        and then Size_Known_At_Compile_Time\n+                   (Etype (Expression (Expression (N))))\n         and then not Is_Record_Type (Current_Scope)\n       then\n          --  Here we can do the optimization. For the allocator\n@@ -3436,7 +3427,7 @@ package body Exp_Ch4 is\n \n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n-             Prefix => New_Occurrence_Of (Temp, Loc),\n+             Prefix         => New_Occurrence_Of (Temp, Loc),\n              Attribute_Name => Name_Unrestricted_Access));\n \n          Analyze_And_Resolve (N, PtrT);\n@@ -3488,8 +3479,7 @@ package body Exp_Ch4 is\n                   Make_Op_Gt (Loc,\n                     Left_Opnd  => Size_In_Storage_Elements (Etyp),\n                     Right_Opnd =>\n-                      Make_Integer_Literal (Loc,\n-                        Intval => Uint_7 * (Uint_2 ** 29))),\n+                      Make_Integer_Literal (Loc, Uint_7 * (Uint_2 ** 29))),\n                 Reason    => SE_Object_Too_Large));\n          end if;\n       end if;\n@@ -3603,8 +3593,7 @@ package body Exp_Ch4 is\n                --  type whose definition is a concurrent type, the first\n                --  argument in the Init routine has to be unchecked conversion\n                --  to the corresponding record type. If the designated type is\n-               --  a derived type, we also convert the argument to its root\n-               --  type.\n+               --  a derived type, also convert the argument to its root type.\n \n                if Is_Concurrent_Type (T) then\n                   Init_Arg1 :=\n@@ -3672,8 +3661,8 @@ package body Exp_Ch4 is\n                                 New_Occurrence_Of\n                                   (Entity (Nam), Sloc (Nam)), T);\n \n-                        elsif Nkind_In\n-                          (Nam, N_Indexed_Component, N_Selected_Component)\n+                        elsif Nkind_In (Nam, N_Indexed_Component,\n+                                             N_Selected_Component)\n                           and then Is_Entity_Name (Prefix (Nam))\n                         then\n                            Decls :=\n@@ -3821,8 +3810,7 @@ package body Exp_Ch4 is\n                else\n                   Insert_Action (N,\n                     Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Reference_To (Init, Loc),\n+                      Name                   => New_Reference_To (Init, Loc),\n                       Parameter_Associations => Args));\n                end if;\n \n@@ -3832,9 +3820,9 @@ package body Exp_Ch4 is\n                   --    [Deep_]Initialize (Init_Arg1);\n \n                   Insert_Action (N,\n-                    Make_Init_Call (\n-                      Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                      Typ     => T));\n+                    Make_Init_Call\n+                      (Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                       Typ     => T));\n \n                   if Present (Associated_Collection (PtrT)) then\n \n@@ -3849,9 +3837,9 @@ package body Exp_Ch4 is\n                      if VM_Target /= No_VM then\n                         if Is_Controlled (T) then\n                            Insert_Action (N,\n-                             Make_Attach_Call (\n-                               Obj_Ref => New_Copy_Tree (Init_Arg1),\n-                               Ptr_Typ => PtrT));\n+                             Make_Attach_Call\n+                               (Obj_Ref => New_Copy_Tree (Init_Arg1),\n+                                Ptr_Typ => PtrT));\n                         end if;\n \n                      --  Default case, generate:\n@@ -3861,10 +3849,10 @@ package body Exp_Ch4 is\n \n                      else\n                         Insert_Action (N,\n-                          Make_Set_Finalize_Address_Ptr_Call (\n-                            Loc     => Loc,\n-                            Typ     => T,\n-                            Ptr_Typ => PtrT));\n+                          Make_Set_Finalize_Address_Ptr_Call\n+                            (Loc     => Loc,\n+                             Typ     => T,\n+                             Ptr_Typ => PtrT));\n                      end if;\n                   end if;\n                end if;\n@@ -4135,9 +4123,8 @@ package body Exp_Ch4 is\n                Make_Temporary (Loc, 'A'),\n              Type_Definition =>\n                Make_Access_To_Object_Definition (Loc,\n-                 All_Present => True,\n-                 Subtype_Indication =>\n-                   New_Reference_To (Typ, Loc)));\n+                 All_Present        => True,\n+                 Subtype_Indication => New_Reference_To (Typ, Loc)));\n \n          Insert_Action (N, P_Decl);\n \n@@ -4153,19 +4140,19 @@ package body Exp_Ch4 is\n \n              Then_Statements => New_List (\n                Make_Assignment_Statement (Sloc (Thenx),\n-                 Name => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n+                 Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n                  Expression =>\n                    Make_Attribute_Reference (Loc,\n                      Attribute_Name => Name_Unrestricted_Access,\n-                     Prefix =>  Relocate_Node (Thenx)))),\n+                     Prefix         =>  Relocate_Node (Thenx)))),\n \n              Else_Statements => New_List (\n                Make_Assignment_Statement (Sloc (Elsex),\n-                 Name => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n+                 Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n                  Expression =>\n                    Make_Attribute_Reference (Loc,\n                      Attribute_Name => Name_Unrestricted_Access,\n-                     Prefix => Relocate_Node (Elsex)))));\n+                     Prefix         => Relocate_Node (Elsex)))));\n \n          New_N :=\n            Make_Explicit_Dereference (Loc,\n@@ -9209,7 +9196,6 @@ package body Exp_Ch4 is\n \n       Result := New_Reference_To (Standard_True, Loc);\n       C := Suitable_Element (First_Entity (Typ));\n-\n       while Present (C) loop\n          declare\n             New_Lhs : Node_Id;"}, {"sha": "a8604a7631782ae8de1a35e87b46868e5a8e0553", "filename": "gcc/ada/g-awk.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fg-awk.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fg-awk.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-awk.ads?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2010, AdaCore                     --\n+--                     Copyright (C) 2000-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -215,7 +215,7 @@ package GNAT.AWK is\n    --  a full AWK run. The state comprises a list of files, the current file,\n    --  the number of line processed, the current line, the number of fields in\n    --  the current line... A default session is provided (see Set_Current,\n-   --  Current_Session and Default_Session above).\n+   --  Current_Session and Default_Session below).\n \n    ----------------------------\n    -- Package initialization --"}, {"sha": "369d75ef84274a2f6cc56a2612f6a996009f18d4", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -1500,17 +1500,16 @@ package body Sem_Disp is\n          if Present (Tagged_Type) and then Is_Tagged_Type (Tagged_Type) then\n             Append_Unique_Elmt (Old_Subp, Primitive_Operations (Tagged_Type));\n \n-            --  If Old_Subp isn't already marked as dispatching then\n-            --  this is the case of an operation of an untagged private\n-            --  type fulfilled by a tagged type that overrides an\n-            --  inherited dispatching operation, so we set the necessary\n-            --  dispatching attributes here.\n+            --  If Old_Subp isn't already marked as dispatching then this is\n+            --  the case of an operation of an untagged private type fulfilled\n+            --  by a tagged type that overrides an inherited dispatching\n+            --  operation, so we set the necessary dispatching attributes here.\n \n             if not Is_Dispatching_Operation (Old_Subp) then\n \n                --  If the untagged type has no discriminants, and the full\n-               --  view is constrained, there will be a spurious mismatch\n-               --  of subtypes on the controlling arguments, because the tagged\n+               --  view is constrained, there will be a spurious mismatch of\n+               --  subtypes on the controlling arguments, because the tagged\n                --  type is the internal base type introduced in the derivation.\n                --  Use the original type to verify conformance, rather than the\n                --  base type.\n@@ -1758,9 +1757,9 @@ package body Sem_Disp is\n \n             begin\n                --  The original corresponding operation of Prim must be an\n-               --  operation of a visible ancestor of the dispatching type\n-               --  S, and the original corresponding operation of S2 must\n-               --  be visible.\n+               --  operation of a visible ancestor of the dispatching type S,\n+               --  and the original corresponding operation of S2 must be\n+               --  visible.\n \n                Orig_Prim := Original_Corresponding_Operation (Prim);\n \n@@ -2026,6 +2025,14 @@ package body Sem_Disp is\n          if not Has_Controlling_Result (Nam) then\n             return False;\n \n+         --  The function may have a controlling result, but if the return type\n+         --  is not visibly tagged, then this is not tag-indeterminate.\n+\n+         elsif Is_Access_Type (Etype (Nam))\n+           and then not Is_Tagged_Type (Designated_Type (Etype (Nam)))\n+         then\n+            return False;\n+\n          --  An explicit dereference means that the call has already been\n          --  expanded and there is no tag to propagate.\n \n@@ -2043,7 +2050,9 @@ package body Sem_Disp is\n                if Is_Controlling_Actual (Actual)\n                  and then not Is_Tag_Indeterminate (Actual)\n                then\n-                  return False; -- one operand is dispatching\n+                  --  One operand is dispatching\n+\n+                  return False;\n                end if;\n \n                Next_Actual (Actual);\n@@ -2066,9 +2075,9 @@ package body Sem_Disp is\n       then\n          return True;\n \n-      --  In Ada 2005 a function that returns an anonymous access type can\n-      --  dispatching, and the dereference of a call to such a function\n-      --  is also tag-indeterminate.\n+      --  In Ada 2005, a function that returns an anonymous access type can be\n+      --  dispatching, and the dereference of a call to such a function can\n+      --  also be tag-indeterminate if the call itself is.\n \n       elsif Nkind (Orig_Node) = N_Explicit_Dereference\n         and then Ada_Version >= Ada_2005"}, {"sha": "fe5f38b125fd98f82cbdd915bd8360a9e13a2282", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -3379,7 +3379,6 @@ package body Sem_Warn is\n                                  Act1, Form);\n \n                            else\n-\n                               --  For greater clarity, give name of formal.\n \n                               Error_Msg_Node_2 := Form;"}, {"sha": "fd7fa29cc0602c013afb9a4403f897ee21d61990", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cae0a5108e18638c9c4844baaf392171130d4/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=243cae0a5108e18638c9c4844baaf392171130d4", "patch": "@@ -47,7 +47,7 @@ package Tree_IO is\n    Tree_Format_Error : exception;\n    --  Raised if a format error is detected in the input file\n \n-   ASIS_Version_Number : constant := 24;\n+   ASIS_Version_Number : constant := 25;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees and an ASIS application that is reading the\n    --  trees. It must be incremented whenever a change is made to the tree"}]}