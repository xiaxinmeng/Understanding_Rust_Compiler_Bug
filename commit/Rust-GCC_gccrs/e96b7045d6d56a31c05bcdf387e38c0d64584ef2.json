{"sha": "e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk2YjcwNDVkNmQ1NmEzMWMwNWJjZGYzODdlMzhjMGQ2NDU4NGVmMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T10:12:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T10:12:40Z"}, "message": "[multiple changes]\n\n2015-10-26  Gary Dismukes  <dismukes@adacore.com>\n        \n        * a-reatim.adb, contracts.adb, contracts.ads: Minor reformatting and\n        typo corrections.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n        \n        * sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): Do not\n        recheck the consistency betwen the freeze point and the end of\n        declarations for the expression in an aspect specification,\n        because it was done already in the analysis of the generic.\n        Furthermore, the delayed analysis of an aspect of the instance\n        may produce spurious errors when the generic is a child unit\n        that references entities in the parent (which might not be in\n        scope at the freeze point of the instance).\n\n2015-10-26  Yannick Moy  <moy@adacore.com>\n        \n        * sem_res.adb (Resolve_Call): Issue info message\n        instead of warning when call cannot be inlined in GNATprove mode.\n\n2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n        \n        * exp_ch6.adb (Build_Procedure_Form): Use _result as the\n        name of the extra parameter, cleaner than a random temp name.\n        * gnat1drv.adb (Gnat1drv): Code clean up.\n\nFrom-SVN: r229314", "tree": {"sha": "74efbf5686f1ccd60a2ecaee965ac294fe866253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74efbf5686f1ccd60a2ecaee965ac294fe866253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/comments", "author": null, "committer": null, "parents": [{"sha": "c1fffdf1fb2ebce24620195c4add32eb90daa598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1fffdf1fb2ebce24620195c4add32eb90daa598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1fffdf1fb2ebce24620195c4add32eb90daa598"}], "stats": {"total": 172, "additions": 107, "deletions": 65}, "files": [{"sha": "936a924f31600929ba8bba6456138edb7b0b64bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -1,3 +1,30 @@\n+2015-10-26  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* a-reatim.adb, contracts.adb, contracts.ads: Minor reformatting and\n+\ttypo corrections.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Check_Aspect_At_End_Of_Declarations): Do not\n+\trecheck the consistency betwen the freeze point and the end of\n+\tdeclarations for the expression in an aspect specification,\n+\tbecause it was done already in the analysis of the generic.\n+\tFurthermore, the delayed analysis of an aspect of the instance\n+\tmay produce spurious errors when the generic is a child unit\n+\tthat references entities in the parent (which might not be in\n+\tscope at the freeze point of the instance).\n+\n+2015-10-26  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Call): Issue info message\n+\tinstead of warning when call cannot be inlined in GNATprove mode.\n+\n+2015-10-26  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch6.adb (Build_Procedure_Form): Use _result as the\n+\tname of the extra parameter, cleaner than a random temp name.\n+\t* gnat1drv.adb (Gnat1drv): Code clean up.\n+\n 2015-10-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (build_binary_op): Tweak formatting."}, {"sha": "57fcd00bf31152d6c99b0cec9fdd914374fbcb8f", "filename": "gcc/ada/a-reatim.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fa-reatim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fa-reatim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-reatim.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -123,15 +123,15 @@ is\n       --  rounding of the division operator in particular, to be the same as\n       --  effects on integer types. To get the correct rounding we first\n       --  convert Time_Span to its root type Duration, which is represented as\n-      --  an 64-bit signed integer, and then use integer division.\n+      --  a 64-bit signed integer, and then use integer division.\n \n       type Duration_Rep is range -(2 ** 63) .. +((2 ** 63 - 1));\n \n       function To_Integer is\n         new Unchecked_Conversion (Duration, Duration_Rep);\n    begin\n       return Integer\n-        (To_Integer (Duration (Left)) / To_Integer (Duration (Right)));\n+               (To_Integer (Duration (Left)) / To_Integer (Duration (Right)));\n    end \"/\";\n \n    function \"/\" (Left : Time_Span; Right : Integer) return Time_Span is"}, {"sha": "e8409b5f7eea278368329f3e5c89ef158f214cc7", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -268,7 +268,7 @@ package body Contracts is\n \n    begin\n       --  Climb the parent chain looking for an enclosing body. Do not use the\n-      --  scope stack as a body uses the entity of its corresponding spec.\n+      --  scope stack, as a body uses the entity of its corresponding spec.\n \n       Par := Parent (Body_Decl);\n       while Present (Par) loop\n@@ -300,13 +300,13 @@ package body Contracts is\n \n    begin\n       --  The loop parameter in an element iterator over a formal container\n-      --  is declared with an object declaration but no contracts apply.\n+      --  is declared with an object declaration, but no contracts apply.\n \n       if Ekind (Obj_Id) = E_Loop_Parameter then\n          return;\n       end if;\n \n-      --  Do not analyze a contract mutiple times\n+      --  Do not analyze a contract multiple times\n \n       Items := Contract (Obj_Id);\n \n@@ -318,13 +318,13 @@ package body Contracts is\n          end if;\n       end if;\n \n-      --  Constant related checks\n+      --  Constant-related checks\n \n       if Ekind (Obj_Id) = E_Constant then\n \n          --  A constant cannot be effectively volatile (SPARK RM 7.1.3(4)).\n-         --  This check is relevant only when SPARK_Mode is on as it is not a\n-         --  standard Ada legality rule. Internally-generated constants that\n+         --  This check is relevant only when SPARK_Mode is on, as it is not\n+         --  a standard Ada legality rule. Internally-generated constants that\n          --  map generic formals to actuals in instantiations are allowed to\n          --  be volatile.\n \n@@ -336,11 +336,11 @@ package body Contracts is\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n          end if;\n \n-      --  Variable related checks\n+      --  Variable-related checks\n \n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n \n-         --  The following checks are relevant only when SPARK_Mode is on as\n+         --  The following checks are relevant only when SPARK_Mode is on, as\n          --  they are not standard Ada legality rules. Internally generated\n          --  temporaries are ignored.\n \n@@ -452,7 +452,7 @@ package body Contracts is\n \n       --  A ghost object cannot be imported or exported (SPARK RM 6.9(8)). One\n       --  exception to this is the object that represents the dispatch table of\n-      --  a Ghost tagged type as the symbol needs to be exported.\n+      --  a Ghost tagged type, as the symbol needs to be exported.\n \n       if Comes_From_Source (Obj_Id) and then Is_Ghost_Entity (Obj_Id) then\n          if Is_Exported (Obj_Id) then\n@@ -479,7 +479,7 @@ package body Contracts is\n       Ref_State : Node_Id;\n \n    begin\n-      --  Do not analyze a contract mutiple times\n+      --  Do not analyze a contract multiple times\n \n       if Present (Items) then\n          if Analyzed (Items) then\n@@ -506,7 +506,7 @@ package body Contracts is\n \n       --  State refinement is required when the package declaration defines at\n       --  least one abstract state. Null states are not considered. Refinement\n-      --  is not envorced when SPARK checks are turned off.\n+      --  is not enforced when SPARK checks are turned off.\n \n       elsif SPARK_Mode /= Off\n         and then Requires_State_Refinement (Spec_Id, Body_Id)\n@@ -543,7 +543,7 @@ package body Contracts is\n       Prag_Nam  : Name_Id;\n \n    begin\n-      --  Do not analyze a contract mutiple times\n+      --  Do not analyze a contract multiple times\n \n       if Present (Items) then\n          if Analyzed (Items) then\n@@ -562,7 +562,7 @@ package body Contracts is\n \n       if Present (Items) then\n \n-         --  Locate and store pragmas Initial_Condition and Initializes since\n+         --  Locate and store pragmas Initial_Condition and Initializes, since\n          --  their order of analysis matters.\n \n          Prag := Classifications (Items);\n@@ -579,7 +579,7 @@ package body Contracts is\n             Prag := Next_Pragma (Prag);\n          end loop;\n \n-         --  Analyze the initialization related pragmas. Initializes must come\n+         --  Analyze the initialization-related pragmas. Initializes must come\n          --  before Initial_Condition due to item dependencies.\n \n          if Present (Init) then\n@@ -639,7 +639,7 @@ package body Contracts is\n       if Ekind (Body_Id) = E_Void then\n          return;\n \n-      --  Do not analyze a contract mutiple times\n+      --  Do not analyze a contract multiple times\n \n       elsif Present (Items) then\n          if Analyzed (Items) then\n@@ -663,12 +663,12 @@ package body Contracts is\n          null;\n \n       --  The subprogram body is a completion, analyze all delayed pragmas that\n-      --  apply. Note that when the body is stand alone, the pragmas are always\n+      --  apply. Note that when the body is stand-alone, the pragmas are always\n       --  analyzed on the spot.\n \n       elsif Present (Items) then\n \n-         --  Locate and store pragmas Refined_Depends and Refined_Global since\n+         --  Locate and store pragmas Refined_Depends and Refined_Global, since\n          --  their order of analysis matters.\n \n          Prag := Classifications (Items);\n@@ -685,7 +685,7 @@ package body Contracts is\n             Prag := Next_Pragma (Prag);\n          end loop;\n \n-         --  Analyze Refined_Global first as Refined_Depends may mention items\n+         --  Analyze Refined_Global first, as Refined_Depends may mention items\n          --  classified in the global refinement.\n \n          if Present (Ref_Global) then\n@@ -705,9 +705,9 @@ package body Contracts is\n \n       Check_Result_And_Post_State (Body_Id);\n \n-      --  A stand alone non-volatile function body cannot have an effectively\n+      --  A stand-alone nonvolatile function body cannot have an effectively\n       --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n-      --  check is relevant only when SPARK_Mode is on as it is not a standard\n+      --  check is relevant only when SPARK_Mode is on, as it is not a standard\n       --  legality rule. The check is performed here because Volatile_Function\n       --  is processed after the analysis of the related subprogram body.\n \n@@ -755,7 +755,7 @@ package body Contracts is\n       Prag_Nam  : Name_Id;\n \n    begin\n-      --  Do not analyze a contract mutiple times\n+      --  Do not analyze a contract multiple times\n \n       if Present (Items) then\n          if Analyzed (Items) then\n@@ -820,7 +820,7 @@ package body Contracts is\n             Prag := Next_Pragma (Prag);\n          end loop;\n \n-         --  Analyze Global first as Depends may mention items classified in\n+         --  Analyze Global first, as Depends may mention items classified in\n          --  the global categorization.\n \n          if Present (Global) then\n@@ -840,11 +840,11 @@ package body Contracts is\n          Check_Result_And_Post_State (Subp_Id);\n       end if;\n \n-      --  A non-volatile function cannot have an effectively volatile formal\n+      --  A nonvolatile function cannot have an effectively volatile formal\n       --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n-      --  only when SPARK_Mode is on as it is not a standard legality rule. The\n-      --  check is performed here because pragma Volatile_Function is processed\n-      --  after the analysis of the related subprogram declaration.\n+      --  only when SPARK_Mode is on, as it is not a standard legality rule.\n+      --  The check is performed here because pragma Volatile_Function is\n+      --  processed after the analysis of the related subprogram declaration.\n \n       if SPARK_Mode = On\n         and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n@@ -1368,7 +1368,7 @@ package body Contracts is\n \n             --  If the pragma is a conjunct in a composite postcondition, it\n             --  has been processed in reverse order. In the postcondition body\n-            --  if must appear before the others.\n+            --  it must appear before the others.\n \n             if Nkind (Item) = N_Pragma\n               and then From_Aspect_Specification (Item)\n@@ -1451,7 +1451,7 @@ package body Contracts is\n          Set_Debug_Info_Needed   (Proc_Id);\n          Set_Postconditions_Proc (Subp_Id, Proc_Id);\n \n-         --  The related subprogram is a function, create the specification of\n+         --  The related subprogram is a function: create the specification of\n          --  parameter _Result.\n \n          if Present (Result) then\n@@ -1464,7 +1464,7 @@ package body Contracts is\n \n          --  Insert _Postconditions before the first source declaration of the\n          --  body. This ensures that the body will not cause any premature\n-         --  freezing as it may mention types:\n+         --  freezing, as it may mention types:\n \n          --    procedure Proc (Obj : Array_Typ) is\n          --       procedure _postconditions is\n@@ -1476,14 +1476,14 @@ package body Contracts is\n          --    begin\n \n          --  In the example above, Obj is of type T but the incorrect placement\n-         --  of _Postconditions will cause a crash in gigi due to an out of\n+         --  of _Postconditions will cause a crash in gigi due to an out-of-\n          --  order reference. The body of _Postconditions must be placed after\n          --  the declaration of Temp to preserve correct visibility.\n \n-         --  Set an explicit End_Lavel to override the sloc of the implicit\n+         --  Set an explicit End_Label to override the sloc of the implicit\n          --  RETURN statement, and prevent it from inheriting the sloc of one\n-         --  the postconditions: this would cause confusing debug into to be\n-         --  produced, interfering with coverage analysis tools.\n+         --  the postconditions: this would cause confusing debug info to be\n+         --  produced, interfering with coverage-analysis tools.\n \n          Proc_Bod :=\n            Make_Subprogram_Body (Loc,\n@@ -1701,11 +1701,11 @@ package body Contracts is\n       procedure Process_Postconditions (Stmts : in out List_Id) is\n          procedure Process_Body_Postconditions (Post_Nam : Name_Id);\n          --  Collect all [refined] postconditions of a specific kind denoted\n-         --  by Post_Nam that belong to the body and generate pragma Check\n+         --  by Post_Nam that belong to the body, and generate pragma Check\n          --  equivalents in list Stmts.\n \n          procedure Process_Spec_Postconditions;\n-         --  Collect all [inherited] postconditions of the spec and generate\n+         --  Collect all [inherited] postconditions of the spec, and generate\n          --  pragma Check equivalents in list Stmts.\n \n          ---------------------------------\n@@ -1736,7 +1736,7 @@ package body Contracts is\n \n             --  The subprogram body being processed is actually the proper body\n             --  of a stub with a corresponding spec. The subprogram stub may\n-            --  carry a postcondition pragma in which case it must be taken\n+            --  carry a postcondition pragma, in which case it must be taken\n             --  into account. The pragma appears after the stub.\n \n             if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n@@ -1867,8 +1867,8 @@ package body Contracts is\n          --  Prepend a single item to the declarations of the subprogram body\n \n          procedure Prepend_To_Decls_Or_Save (Prag : Node_Id);\n-         --  Save a class-wide precondition into Class_Pre or prepend a normal\n-         --  precondition ot the declarations of the body and analyze it.\n+         --  Save a class-wide precondition into Class_Pre, or prepend a normal\n+         --  precondition to the declarations of the body and analyze it.\n \n          procedure Process_Inherited_Preconditions;\n          --  Collect all inherited class-wide preconditions and merge them into\n@@ -1885,7 +1885,7 @@ package body Contracts is\n          procedure Merge_Preconditions (From : Node_Id; Into : Node_Id) is\n             function Expression_Arg (Prag : Node_Id) return Node_Id;\n             --  Return the boolean expression argument of a precondition while\n-            --  updating its parenteses count for the subsequent merge.\n+            --  updating its parentheses count for the subsequent merge.\n \n             function Message_Arg (Prag : Node_Id) return Node_Id;\n             --  Return the message argument of a precondition\n@@ -1979,7 +1979,7 @@ package body Contracts is\n             Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n \n             --  Save the sole class-wide precondition (if any) for the next\n-            --  step where it will be merged with inherited preconditions.\n+            --  step, where it will be merged with inherited preconditions.\n \n             if Class_Present (Prag) then\n                pragma Assert (No (Class_Pre));\n@@ -2032,7 +2032,7 @@ package body Contracts is\n                              Subp_Id  => Spec_Id,\n                              Inher_Id => Subp_Id);\n \n-                        --  The spec or an inherited subprogram already yielded\n+                        --  The spec of an inherited subprogram already yielded\n                         --  a class-wide precondition. Merge the existing\n                         --  precondition with the current one using \"or else\".\n \n@@ -2081,8 +2081,9 @@ package body Contracts is\n             end if;\n \n             --  The subprogram declaration being processed is actually a body\n-            --  stub. The stub may carry a precondition pragma in which case it\n-            --  must be taken into account. The pragma appears after the stub.\n+            --  stub. The stub may carry a precondition pragma, in which case\n+            --  it must be taken into account. The pragma appears after the\n+            --  stub.\n \n             Subp_Decl := Unit_Declaration_Node (Subp_Id);\n \n@@ -2125,7 +2126,7 @@ package body Contracts is\n       --  Start of processing for Process_Preconditions\n \n       begin\n-         --  Find the last internally generate declaration starting from the\n+         --  Find the last internally generated declaration, starting from the\n          --  top of the body declarations. This ensures that discriminals and\n          --  subtypes are properly visible to the pragma Check equivalents.\n \n@@ -2139,7 +2140,7 @@ package body Contracts is\n          end if;\n \n          --  The processing of preconditions is done in reverse order (body\n-         --  first) because each pragma Check equivalent is inserted at the\n+         --  first), because each pragma Check equivalent is inserted at the\n          --  top of the declarations. This ensures that the final order is\n          --  consistent with following diagram:\n \n@@ -2189,7 +2190,7 @@ package body Contracts is\n          return;\n \n       --  The contract of a generic subprogram or one declared in a generic\n-      --  context is not expanded as the corresponding instance will provide\n+      --  context is not expanded, as the corresponding instance will provide\n       --  the executable semantics of the contract.\n \n       elsif Is_Generic_Subprogram (Subp_Id) or else Inside_A_Generic then\n@@ -2201,7 +2202,7 @@ package body Contracts is\n       elsif not Has_Significant_Contract (Subp_Id) then\n          return;\n \n-      --  The contract of an ignored Ghost subprogram does not need expansion\n+      --  The contract of an ignored Ghost subprogram does not need expansion,\n       --  because the subprogram and all calls to it will be removed.\n \n       elsif Is_Ignored_Ghost_Entity (Subp_Id) then\n@@ -2281,7 +2282,7 @@ package body Contracts is\n \n       --  Step 3: Handle pragma Contract_Cases. This action must come before\n       --  the processing of invariants and predicates because those append\n-      --  items to list Smts.\n+      --  items to list Stmts.\n \n       Process_Contract_Cases (Stmts);\n \n@@ -2322,7 +2323,7 @@ package body Contracts is\n       begin\n          --  A pragma cannot be part of more than one First_Pragma/Next_Pragma\n          --  chains, therefore the node must be replicated. The new pragma is\n-         --  flagged is inherited for distrinction purposes.\n+         --  flagged as inherited for distinction purposes.\n \n          if Present (Prag) then\n             New_Prag := New_Copy_Tree (Prag);\n@@ -2352,7 +2353,7 @@ package body Contracts is\n \n    procedure Instantiate_Subprogram_Contract (Templ : Node_Id; L : List_Id) is\n       procedure Instantiate_Pragmas (First_Prag : Node_Id);\n-      --  Instantiate all contract-related source pragmas found in the list\n+      --  Instantiate all contract-related source pragmas found in the list,\n       --  starting with pragma First_Prag. Each instantiated pragma is added\n       --  to list L.\n \n@@ -2403,7 +2404,7 @@ package body Contracts is\n    is\n       procedure Save_Global_References_In_List (First_Prag : Node_Id);\n       --  Save all global references in contract-related source pragmas found\n-      --  in the list starting with pragma First_Prag.\n+      --  in the list, starting with pragma First_Prag.\n \n       ------------------------------------\n       -- Save_Global_References_In_List --"}, {"sha": "6f911a36fc2f3cefb9479a06fb366fa4341043a1", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -32,7 +32,7 @@ package Contracts is\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n    --  Add pragma Prag to the contract of a constant, entry, package [body],\n-   --  subprogram [body] or variable denoted by Id. The following are valid\n+   --  subprogram [body], or variable denoted by Id. The following are valid\n    --  pragmas:\n    --    Abstract_State\n    --    Async_Readers\n@@ -57,7 +57,7 @@ package Contracts is\n    --    Volatile_Function\n \n    procedure Analyze_Enclosing_Package_Body_Contract (Body_Decl : Node_Id);\n-   --  Analyze the contract of the nearest package body (if any) which encloses\n+   --  Analyze the contract of the nearest package body (if any) enclosing\n    --  package or subprogram body Body_Decl.\n \n    procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n@@ -79,7 +79,7 @@ package Contracts is\n    --    Refined_State\n    --\n    --  Freeze_Id is the entity of a [generic] package body or a [generic]\n-   --  subprogram body which \"feezes\" the contract of Body_Id.\n+   --  subprogram body which \"freezes\" the contract of Body_Id.\n \n    procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of package Pack_Id\n@@ -129,7 +129,7 @@ package Contracts is\n    --    Test_Case\n \n    procedure Create_Generic_Contract (Unit : Node_Id);\n-   --  Create a contract node for a generic package, generic subprogram or a\n+   --  Create a contract node for a generic package, generic subprogram, or a\n    --  generic body denoted by Unit by collecting all source contract-related\n    --  pragmas in the contract of the unit.\n "}, {"sha": "07003a4dc599d2c1bca0794d1ce219258275c5a3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -5495,7 +5495,7 @@ package body Exp_Ch6 is\n \n       procedure Build_Procedure_Form;\n       --  Create a procedure declaration which emulates the behavior of\n-      --  function Subp, for SPARK_To_C.\n+      --  function Subp, for C-compatible generation.\n \n       --------------------------\n       -- Build_Procedure_Form --\n@@ -5525,9 +5525,12 @@ package body Exp_Ch6 is\n \n          --  Add an extra out parameter to carry the function result\n \n+         Name_Len := 7;\n+         Name_Buffer (1 .. Name_Len) := \"_result\";\n          Append_To (Proc_Formals,\n            Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Make_Temporary (Loc, 'R'),\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, Chars => Name_Find),\n              Out_Present         => True,\n              Parameter_Type      => New_Occurrence_Of (Etype (Subp), Loc)));\n "}, {"sha": "727e90a44013eb1aab7adf430c6a0511bee48fbe", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -1180,8 +1180,9 @@ begin\n \n       --  It is not an error to analyze in CodePeer mode a spec which requires\n       --  a body, in order to generate SCIL for this spec.\n+      --  Ditto for Generate_C_Code mode and generate a C header for a spec.\n \n-      elsif CodePeer_Mode then\n+      elsif CodePeer_Mode or Generate_C_Code then\n          Back_End_Mode := Generate_Object;\n \n       --  It is not an error to analyze in GNATprove mode a spec which requires"}, {"sha": "9f7794f61c7039e857b92a91dd7df47607de5105", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -9103,9 +9103,19 @@ package body Sem_Ch13 is\n    --  Start of processing for Check_Aspect_At_End_Of_Declarations\n \n    begin\n+      --  In an instance we do not perform the consistency check between freeze\n+      --  point and end of declarations, because it was done already in the\n+      --  analysis of the generic. Furthermore, the delayed analysis of an\n+      --  aspect of the instance may produce spurious errors when the generic\n+      --  is a child unit that references entities in the parent (which might\n+      --  not be in scope at the freeze point of the instance).\n+\n+      if In_Instance then\n+         return;\n+\n       --  Case of aspects Dimension, Dimension_System and Synchronization\n \n-      if A_Id = Aspect_Synchronization then\n+      elsif A_Id = Aspect_Synchronization then\n          return;\n \n       --  Case of stream attributes, just have to compare entities. However,"}, {"sha": "b2d3ca0a5f055621aec4cf3ae43e795c05b0a038", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e96b7045d6d56a31c05bcdf387e38c0d64584ef2/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e96b7045d6d56a31c05bcdf387e38c0d64584ef2", "patch": "@@ -6409,14 +6409,14 @@ package body Sem_Res is\n             --  assertions as logic expressions.\n \n             elsif In_Assertion_Expr /= 0 then\n-               Error_Msg_NE (\"?no contextual analysis of &\", N, Nam);\n+               Error_Msg_NE (\"info: no contextual analysis of &?\", N, Nam);\n                Error_Msg_N (\"\\call appears in assertion expression\", N);\n                Set_Is_Inlined_Always (Nam_UA, False);\n \n             --  Calls cannot be inlined inside default expressions\n \n             elsif In_Default_Expr then\n-               Error_Msg_NE (\"?no contextual analysis of &\", N, Nam);\n+               Error_Msg_NE (\"info: no contextual analysis of &?\", N, Nam);\n                Error_Msg_N (\"\\call appears in default expression\", N);\n                Set_Is_Inlined_Always (Nam_UA, False);\n \n@@ -6429,7 +6429,7 @@ package body Sem_Res is\n \n                if No (Body_Id) then\n                   Error_Msg_NE\n-                    (\"?no contextual analysis of & (body not seen yet)\",\n+                    (\"info: no contextual analysis of & (body not seen yet)?\",\n                      N, Nam);\n                   Set_Is_Inlined_Always (Nam_UA, False);\n \n@@ -6445,7 +6445,7 @@ package body Sem_Res is\n                --  expressions, that are not handled by GNATprove.\n \n                elsif Is_Potentially_Unevaluated (N) then\n-                  Error_Msg_NE (\"?no contextual analysis of &\", N, Nam);\n+                  Error_Msg_NE (\"info: no contextual analysis of &?\", N, Nam);\n                   Error_Msg_N\n                     (\"\\call appears in potentially unevaluated context\", N);\n                   Set_Is_Inlined_Always (Nam_UA, False);"}]}