{"sha": "92344ed0caa6b9364cd66c12e36b572106d43de4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzNDRlZDBjYWE2YjkzNjRjZDY2YzEyZTM2YjU3MjEwNmQ0M2RlNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-21T20:42:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-11-21T20:42:20Z"}, "message": "re PR target/63848 (FAIL: c-c++-common/torture/builtin-arith-overflow-17.c   -O0  execution test)\n\n\tPR target/63848\n\tPR target/63975\n\t* internal-fn.c (expand_arith_overflow_result_store,\n\texpand_addsub_overflow, expand_neg_overflow, expand_mul_overflow): Use\n\tdo_compare_rtx_and_jump instead of emit_cmp_and_jump_insns everywhere,\n\tadjust arguments to those functions.  Use unsignedp = true for\n\tEQ, NE, GEU, LEU, LTU and GTU comparisons.\n\nFrom-SVN: r217946", "tree": {"sha": "bc593417979704067e812c117678ad3ae68c146d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc593417979704067e812c117678ad3ae68c146d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92344ed0caa6b9364cd66c12e36b572106d43de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92344ed0caa6b9364cd66c12e36b572106d43de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92344ed0caa6b9364cd66c12e36b572106d43de4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92344ed0caa6b9364cd66c12e36b572106d43de4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09877e133f3ca9c11a4334707d780a7b1a018bca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09877e133f3ca9c11a4334707d780a7b1a018bca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09877e133f3ca9c11a4334707d780a7b1a018bca"}], "stats": {"total": 198, "additions": 108, "deletions": 90}, "files": [{"sha": "cf542cacaa24f4f9d547eed8745e80635139a6f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92344ed0caa6b9364cd66c12e36b572106d43de4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92344ed0caa6b9364cd66c12e36b572106d43de4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92344ed0caa6b9364cd66c12e36b572106d43de4", "patch": "@@ -1,5 +1,13 @@\n 2014-11-21  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/63848\n+\tPR target/63975\n+\t* internal-fn.c (expand_arith_overflow_result_store,\n+\texpand_addsub_overflow, expand_neg_overflow, expand_mul_overflow): Use\n+\tdo_compare_rtx_and_jump instead of emit_cmp_and_jump_insns everywhere,\n+\tadjust arguments to those functions.  Use unsignedp = true for\n+\tEQ, NE, GEU, LEU, LTU and GTU comparisons.\n+\n \tPR tree-optimization/64006\n \t* tree-vrp.c (stmt_interesting_for_vrp): Return true\n \tfor {ADD,SUB,MUL}_OVERFLOW internal calls."}, {"sha": "0bd24396c2e17308c2ff6c83bf921c6968d45323", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92344ed0caa6b9364cd66c12e36b572106d43de4/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92344ed0caa6b9364cd66c12e36b572106d43de4/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=92344ed0caa6b9364cd66c12e36b572106d43de4", "patch": "@@ -386,8 +386,8 @@ expand_arith_overflow_result_store (tree lhs, rtx target,\n       int uns = TYPE_UNSIGNED (TREE_TYPE (TREE_TYPE (lhs)));\n       lres = convert_modes (tgtmode, mode, res, uns);\n       gcc_assert (GET_MODE_PRECISION (tgtmode) < GET_MODE_PRECISION (mode));\n-      emit_cmp_and_jump_insns (res, convert_modes (mode, tgtmode, lres, uns),\n-\t\t\t       EQ, NULL_RTX, mode, false, done_label,\n+      do_compare_rtx_and_jump (res, convert_modes (mode, tgtmode, lres, uns),\n+\t\t\t       EQ, true, mode, NULL_RTX, NULL_RTX, done_label,\n \t\t\t       PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n       emit_label (done_label);\n@@ -533,8 +533,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t      ? (CONST_SCALAR_INT_P (op0) && REG_P (op1))\n \t      : CONST_SCALAR_INT_P (op1)))\n \ttem = op1;\n-      emit_cmp_and_jump_insns (res, tem, code == PLUS_EXPR ? GEU : LEU,\n-\t\t\t       NULL_RTX, mode, false, done_label,\n+      do_compare_rtx_and_jump (res, tem, code == PLUS_EXPR ? GEU : LEU,\n+\t\t\t       true, mode, NULL_RTX, NULL_RTX, done_label,\n \t\t\t       PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -549,7 +549,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       rtx tem = expand_binop (mode, add_optab,\n \t\t\t      code == PLUS_EXPR ? res : op0, sgn,\n \t\t\t      NULL_RTX, false, OPTAB_LIB_WIDEN);\n-      emit_cmp_and_jump_insns (tem, op1, GEU, NULL_RTX, mode, false,\n+      do_compare_rtx_and_jump (tem, op1, GEU, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -591,9 +591,9 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \temit_jump (do_error);\n       else if (pos_neg == 3)\n \t/* If ARG0 is not known to be always positive, check at runtime.  */\n-\temit_cmp_and_jump_insns (op0, const0_rtx, LT, NULL_RTX, mode, false,\n-\t\t\t\t do_error, PROB_VERY_UNLIKELY);\n-      emit_cmp_and_jump_insns (op1, op0, LEU, NULL_RTX, mode, false,\n+\tdo_compare_rtx_and_jump (op0, const0_rtx, LT, false, mode, NULL_RTX,\n+\t\t\t\t NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (op1, op0, LEU, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -607,7 +607,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\t  OPTAB_LIB_WIDEN);\n       rtx tem = expand_binop (mode, add_optab, op1, sgn, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n-      emit_cmp_and_jump_insns (op0, tem, LTU, NULL_RTX, mode, false,\n+      do_compare_rtx_and_jump (op0, tem, LTU, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -619,8 +619,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t unsigned.  */\n       res = expand_binop (mode, add_optab, op0, op1, NULL_RTX, false,\n \t\t\t  OPTAB_LIB_WIDEN);\n-      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n-\t\t\t       do_error, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n       rtx tem = op1;\n       /* The operation is commutative, so we can pick operand to compare\n \t against.  For prec <= BITS_PER_WORD, I think preferring REG operand\n@@ -633,7 +633,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  ? (CONST_SCALAR_INT_P (op1) && REG_P (op0))\n \t  : CONST_SCALAR_INT_P (op0))\n \ttem = op0;\n-      emit_cmp_and_jump_insns (res, tem, GEU, NULL_RTX, mode, false,\n+      do_compare_rtx_and_jump (res, tem, GEU, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n@@ -663,25 +663,26 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t  tem = expand_binop (mode, ((pos_neg == 1) ^ (code == MINUS_EXPR))\n \t\t\t\t    ? and_optab : ior_optab,\n \t\t\t      op0, res, NULL_RTX, false, OPTAB_LIB_WIDEN);\n-\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n \t}\n       else\n \t{\n \t  rtx_code_label *do_ior_label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (op1, const0_rtx,\n-\t\t\t\t   code == MINUS_EXPR ? GE : LT, NULL_RTX,\n-\t\t\t\t   mode, false, do_ior_label, PROB_EVEN);\n+\t  do_compare_rtx_and_jump (op1, const0_rtx,\n+\t\t\t\t   code == MINUS_EXPR ? GE : LT, false, mode,\n+\t\t\t\t   NULL_RTX, NULL_RTX, do_ior_label,\n+\t\t\t\t   PROB_EVEN);\n \t  tem = expand_binop (mode, and_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n-\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n \t  emit_jump (do_error);\n \t  emit_label (do_ior_label);\n \t  tem = expand_binop (mode, ior_optab, op0, res, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n-\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n \t}\n       goto do_error_label;\n     }\n@@ -694,14 +695,14 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n       res = expand_binop (mode, sub_optab, op0, op1, NULL_RTX, false,\n \t\t\t  OPTAB_LIB_WIDEN);\n       rtx_code_label *op0_geu_op1 = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (op0, op1, GEU, NULL_RTX, mode, false,\n+      do_compare_rtx_and_jump (op0, op1, GEU, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       op0_geu_op1, PROB_EVEN);\n-      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode, false,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+      do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, done_label, PROB_VERY_LIKELY);\n       emit_jump (do_error);\n       emit_label (op0_geu_op1);\n-      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t       done_label, PROB_VERY_LIKELY);\n+      do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, done_label, PROB_VERY_LIKELY);\n       goto do_error_label;\n     }\n \n@@ -754,7 +755,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t and conditional jump instead of 2 at runtime, 3 present in the\n \t emitted code.  If one of the arguments is CONST_INT, all we\n \t need is to make sure it is op1, then the first\n-\t emit_cmp_and_jump_insns will be just folded.  Otherwise try\n+\t do_compare_rtx_and_jump will be just folded.  Otherwise try\n \t to use range info if available.  */\n       if (code == PLUS_EXPR && CONST_INT_P (op0))\n \t{\n@@ -779,13 +780,13 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \n       /* If the op1 is negative, we have to use a different check.  */\n       if (pos_neg == 3)\n-\temit_cmp_and_jump_insns (op1, const0_rtx, LT, NULL_RTX, mode,\n-\t\t\t\t false, sub_check, PROB_EVEN);\n+\tdo_compare_rtx_and_jump (op1, const0_rtx, LT, false, mode, NULL_RTX,\n+\t\t\t\t NULL_RTX, sub_check, PROB_EVEN);\n \n       /* Compare the result of the operation with one of the operands.  */\n       if (pos_neg & 1)\n-\temit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? GE : LE,\n-\t\t\t\t NULL_RTX, mode, false, done_label,\n+\tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? GE : LE,\n+\t\t\t\t false, mode, NULL_RTX, NULL_RTX, done_label,\n \t\t\t\t PROB_VERY_LIKELY);\n \n       /* If we get here, we have to print the error.  */\n@@ -798,8 +799,8 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \n       /* We have k = a + b for b < 0 here.  k <= a must hold.  */\n       if (pos_neg & 2)\n-\temit_cmp_and_jump_insns (res, op0, code == PLUS_EXPR ? LE : GE,\n-\t\t\t\t NULL_RTX, mode, false, done_label,\n+\tdo_compare_rtx_and_jump (res, op0, code == PLUS_EXPR ? LE : GE,\n+\t\t\t\t false, mode, NULL_RTX, NULL_RTX, done_label,\n \t\t\t\t PROB_VERY_LIKELY);\n     }\n \n@@ -895,7 +896,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan)\n \n       /* Compare the operand with the most negative value.  */\n       rtx minv = expand_normal (TYPE_MIN_VALUE (TREE_TYPE (arg1)));\n-      emit_cmp_and_jump_insns (op1, minv, NE, NULL_RTX, mode, false,\n+      do_compare_rtx_and_jump (op1, minv, NE, true, mode, NULL_RTX, NULL_RTX,\n \t\t\t       done_label, PROB_VERY_LIKELY);\n     }\n \n@@ -1031,16 +1032,16 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.op2 = NULL_TREE;\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n-\t  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n \t  goto do_error_label;\n \tcase 3:\n \t  rtx_code_label *do_main_label;\n \t  do_main_label = gen_label_rtx ();\n-\t  emit_cmp_and_jump_insns (op0, const0_rtx, GE, NULL_RTX, mode,\n-\t\t\t\t   false, do_main_label, PROB_VERY_LIKELY);\n-\t  emit_cmp_and_jump_insns (op1, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t\t   false, do_main_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (op0, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n \t  write_complex_part (target, const1_rtx, true);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1076,16 +1077,16 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  ops.op2 = NULL_TREE;\n \t  ops.location = loc;\n \t  res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n-\t  emit_cmp_and_jump_insns (op0, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n-\t  emit_cmp_and_jump_insns (op0, constm1_rtx, NE, NULL_RTX, mode,\n-\t\t\t\t   false, do_error, PROB_VERY_UNLIKELY);\n+\t  do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, do_error, PROB_VERY_UNLIKELY);\n \t  int prec;\n \t  prec = GET_MODE_PRECISION (mode);\n \t  rtx sgn;\n \t  sgn = immed_wide_int_const (wi::min_value (prec, SIGNED), mode);\n-\t  emit_cmp_and_jump_insns (op1, sgn, EQ, NULL_RTX, mode,\n-\t\t\t\t   false, done_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (op1, sgn, EQ, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, done_label, PROB_VERY_LIKELY);\n \t  goto do_error_label;\n \tcase 3:\n \t  /* Rest of handling of this case after res is computed.  */\n@@ -1130,8 +1131,9 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);\n \t      tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n \t\t\t\t  OPTAB_LIB_WIDEN);\n-\t      emit_cmp_and_jump_insns (tem, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t\t       false, done_label, PROB_VERY_LIKELY);\n+\t      do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode,\n+\t\t\t\t       NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t       PROB_VERY_LIKELY);\n \t      goto do_error_label;\n \t    }\n \t  /* The general case, do all the needed comparisons at runtime.  */\n@@ -1147,8 +1149,9 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  after_negate_label = gen_label_rtx ();\n \t  tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,\n \t\t\t      OPTAB_LIB_WIDEN);\n-\t  emit_cmp_and_jump_insns (tem, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   after_negate_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, after_negate_label,\n+\t\t\t\t   PROB_VERY_LIKELY);\n \t  /* Both arguments negative here, negate them and continue with\n \t     normal unsigned overflow checking multiplication.  */\n \t  emit_move_insn (op0, expand_unop (mode, neg_optab, op0,\n@@ -1163,14 +1166,14 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  emit_label (after_negate_label);\n \t  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,\n \t\t\t       OPTAB_LIB_WIDEN);\n-\t  emit_cmp_and_jump_insns (tem2, const0_rtx, GE, NULL_RTX, mode, false,\n-\t\t\t\t   do_main_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem2, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n \t  /* One argument is negative here, the other positive.  This\n \t     overflows always, unless one of the arguments is 0.  But\n \t     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1\n \t     is, thus we can keep do_main code oring in overflow as is.  */\n-\t  emit_cmp_and_jump_insns (tem, const0_rtx, EQ, NULL_RTX, mode, false,\n-\t\t\t\t   do_main_label, PROB_VERY_LIKELY);\n+\t  do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode, NULL_RTX,\n+\t\t\t\t   NULL_RTX, do_main_label, PROB_VERY_LIKELY);\n \t  write_complex_part (target, const1_rtx, true);\n \t  emit_label (do_main_label);\n \t  goto do_main;\n@@ -1235,17 +1238,19 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  if (uns)\n \t    /* For the unsigned multiplication, there was overflow if\n \t       HIPART is non-zero.  */\n-\t    emit_cmp_and_jump_insns (hipart, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t\t     false, done_label, PROB_VERY_LIKELY);\n+\t    do_compare_rtx_and_jump (hipart, const0_rtx, EQ, true, mode,\n+\t\t\t\t     NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t     PROB_VERY_LIKELY);\n \t  else\n \t    {\n \t      rtx signbit = expand_shift (RSHIFT_EXPR, mode, res, prec - 1,\n \t\t\t\t\t  NULL_RTX, 0);\n \t      /* RES is low half of the double width result, HIPART\n \t\t the high half.  There was overflow if\n \t\t HIPART is different from RES < 0 ? -1 : 0.  */\n-\t      emit_cmp_and_jump_insns (signbit, hipart, EQ, NULL_RTX, mode,\n-\t\t\t\t       false, done_label, PROB_VERY_LIKELY);\n+\t      do_compare_rtx_and_jump (signbit, hipart, EQ, true, mode,\n+\t\t\t\t       NULL_RTX, NULL_RTX, done_label,\n+\t\t\t\t       PROB_VERY_LIKELY);\n \t    }\n \t}\n       else if (hmode != BLKmode && 2 * GET_MODE_PRECISION (hmode) == prec)\n@@ -1336,12 +1341,13 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t    }\n \n \t  if (!op0_small_p)\n-\t    emit_cmp_and_jump_insns (signbit0, hipart0, NE, NULL_RTX, hmode,\n-\t\t\t\t     false, large_op0, PROB_UNLIKELY);\n+\t    do_compare_rtx_and_jump (signbit0, hipart0, NE, true, hmode,\n+\t\t\t\t     NULL_RTX, NULL_RTX, large_op0,\n+\t\t\t\t     PROB_UNLIKELY);\n \n \t  if (!op1_small_p)\n-\t    emit_cmp_and_jump_insns (signbit1, hipart1, NE, NULL_RTX, hmode,\n-\t\t\t\t     false, small_op0_large_op1,\n+\t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n+\t\t\t\t     NULL_RTX, NULL_RTX, small_op0_large_op1,\n \t\t\t\t     PROB_UNLIKELY);\n \n \t  /* If both op0 and op1 are sign (!uns) or zero (uns) extended from\n@@ -1386,8 +1392,9 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t  emit_label (large_op0);\n \n \t  if (!op1_small_p)\n-\t    emit_cmp_and_jump_insns (signbit1, hipart1, NE, NULL_RTX, hmode,\n-\t\t\t\t     false, both_ops_large, PROB_UNLIKELY);\n+\t    do_compare_rtx_and_jump (signbit1, hipart1, NE, true, hmode,\n+\t\t\t\t     NULL_RTX, NULL_RTX, both_ops_large,\n+\t\t\t\t     PROB_UNLIKELY);\n \n \t  /* If op1 is sign (!uns) or zero (uns) extended from hmode to mode,\n \t     but op0 is not, prepare larger, hipart and lopart pseudos and\n@@ -1422,8 +1429,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      if (larger_sign == 0)\n \t\temit_jump (after_hipart_neg);\n \t      else if (larger_sign != -1)\n-\t\temit_cmp_and_jump_insns (hipart, const0_rtx, GE, NULL_RTX,\n-\t\t\t\t\t hmode, false, after_hipart_neg,\n+\t\tdo_compare_rtx_and_jump (hipart, const0_rtx, GE, false, hmode,\n+\t\t\t\t\t NULL_RTX, NULL_RTX, after_hipart_neg,\n \t\t\t\t\t PROB_EVEN);\n \n \t      tem = convert_modes (mode, hmode, lopart, 1);\n@@ -1438,8 +1445,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      if (smaller_sign == 0)\n \t\temit_jump (after_lopart_neg);\n \t      else if (smaller_sign != -1)\n-\t\temit_cmp_and_jump_insns (lopart, const0_rtx, GE, NULL_RTX,\n-\t\t\t\t\t hmode, false, after_lopart_neg,\n+\t\tdo_compare_rtx_and_jump (lopart, const0_rtx, GE, false, hmode,\n+\t\t\t\t\t NULL_RTX, NULL_RTX, after_lopart_neg,\n \t\t\t\t\t PROB_EVEN);\n \n \t      tem = expand_simple_binop (mode, MINUS, loxhi, larger, NULL_RTX,\n@@ -1467,8 +1474,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t\t\t\t gen_lowpart (hmode, loxhi),\n \t\t\t\t\t hprec - 1, NULL_RTX, 0);\n \n-\t  emit_cmp_and_jump_insns (signbitloxhi, hipartloxhi, NE, NULL_RTX,\n-\t\t\t\t   hmode, false, do_overflow,\n+\t  do_compare_rtx_and_jump (signbitloxhi, hipartloxhi, NE, true, hmode,\n+\t\t\t\t   NULL_RTX, NULL_RTX, do_overflow,\n \t\t\t\t   PROB_VERY_UNLIKELY);\n \n \t  /* res = (loxhi << (bitsize / 2)) | (hmode) lo0xlo1;  */\n@@ -1503,17 +1510,17 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t\t{\n \t\t  tem = expand_simple_binop (hmode, PLUS, hipart0, const1_rtx,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n-\t\t  emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX,\n-\t\t\t\t\t   hmode, true, do_error,\n+\t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n+\t\t\t\t\t   NULL_RTX, NULL_RTX, do_error,\n \t\t\t\t\t   PROB_VERY_UNLIKELY);\n \t\t}\n \n \t      if (!op1_medium_p)\n \t\t{\n \t\t  tem = expand_simple_binop (hmode, PLUS, hipart1, const1_rtx,\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n-\t\t  emit_cmp_and_jump_insns (tem, const1_rtx, GTU, NULL_RTX,\n-\t\t\t\t\t   hmode, true, do_error,\n+\t\t  do_compare_rtx_and_jump (tem, const1_rtx, GTU, true, hmode,\n+\t\t\t\t\t   NULL_RTX, NULL_RTX, do_error,\n \t\t\t\t\t   PROB_VERY_UNLIKELY);\n \t\t}\n \n@@ -1523,17 +1530,20 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n \t      if (op0_sign != 1 && op1_sign != 1 && op0_sign != op1_sign)\n \t\temit_jump (hipart_different);\n \t      else if (op0_sign == 1 || op1_sign == 1)\n-\t\temit_cmp_and_jump_insns (hipart0, hipart1, NE, NULL_RTX, hmode,\n-\t\t\t\t\t true, hipart_different, PROB_EVEN);\n+\t\tdo_compare_rtx_and_jump (hipart0, hipart1, NE, true, hmode,\n+\t\t\t\t\t NULL_RTX, NULL_RTX, hipart_different,\n+\t\t\t\t\t PROB_EVEN);\n \n-\t      emit_cmp_and_jump_insns (res, const0_rtx, LT, NULL_RTX, mode,\n-\t\t\t\t       false, do_error, PROB_VERY_UNLIKELY);\n+\t      do_compare_rtx_and_jump (res, const0_rtx, LT, false, mode,\n+\t\t\t\t       NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t       PROB_VERY_UNLIKELY);\n \t      emit_jump (done_label);\n \n \t      emit_label (hipart_different);\n \n-\t      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode,\n-\t\t\t\t       false, do_error, PROB_VERY_UNLIKELY);\n+\t      do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode,\n+\t\t\t\t       NULL_RTX, NULL_RTX, do_error,\n+\t\t\t\t       PROB_VERY_UNLIKELY);\n \t      emit_jump (done_label);\n \t    }\n \n@@ -1577,8 +1587,8 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n   if (uns0_p && uns1_p && !unsr_p)\n     {\n       rtx_code_label *all_done_label = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (res, const0_rtx, GE, NULL_RTX, mode,\n-\t\t\t       false, all_done_label, PROB_VERY_LIKELY);\n+      do_compare_rtx_and_jump (res, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, all_done_label, PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n       emit_label (all_done_label);\n     }\n@@ -1588,15 +1598,15 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       rtx_code_label *all_done_label = gen_label_rtx ();\n       rtx_code_label *set_noovf = gen_label_rtx ();\n-      emit_cmp_and_jump_insns (op1, const0_rtx, GE, NULL_RTX, mode,\n-\t\t\t       false, all_done_label, PROB_VERY_LIKELY);\n+      do_compare_rtx_and_jump (op1, const0_rtx, GE, false, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, all_done_label, PROB_VERY_LIKELY);\n       write_complex_part (target, const1_rtx, true);\n-      emit_cmp_and_jump_insns (op0, const0_rtx, EQ, NULL_RTX, mode,\n-\t\t\t       false, set_noovf, PROB_VERY_LIKELY);\n-      emit_cmp_and_jump_insns (op0, constm1_rtx, NE, NULL_RTX, mode,\n-\t\t\t       false, all_done_label, PROB_VERY_UNLIKELY);\n-      emit_cmp_and_jump_insns (op1, res, NE, NULL_RTX, mode,\n-\t\t\t       false, all_done_label, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, set_noovf, PROB_VERY_LIKELY);\n+      do_compare_rtx_and_jump (op0, constm1_rtx, NE, true, mode, NULL_RTX,\n+\t\t\t       NULL_RTX, all_done_label, PROB_VERY_UNLIKELY);\n+      do_compare_rtx_and_jump (op1, res, NE, true, mode, NULL_RTX, NULL_RTX,\n+\t\t\t       all_done_label, PROB_VERY_UNLIKELY);\n       emit_label (set_noovf);\n       write_complex_part (target, const0_rtx, true);\n       emit_label (all_done_label);"}]}