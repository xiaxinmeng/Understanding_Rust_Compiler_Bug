{"sha": "866e32ad336f1698809cc03c48f884379d6b39e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2ZTMyYWQzMzZmMTY5ODgwOWNjMDNjNDhmODg0Mzc5ZDZiMzllMA==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2014-09-23T17:59:53Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2014-09-23T17:59:53Z"}, "message": "[libsanitizer merge from upstream r218156]\n\nFrom-SVN: r215527", "tree": {"sha": "dfe8acd36f160811afc54c8eaf16e8160ba8bd70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe8acd36f160811afc54c8eaf16e8160ba8bd70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/866e32ad336f1698809cc03c48f884379d6b39e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866e32ad336f1698809cc03c48f884379d6b39e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866e32ad336f1698809cc03c48f884379d6b39e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866e32ad336f1698809cc03c48f884379d6b39e0/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8ee40544aef309d4225852dda191bf0f986f761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ee40544aef309d4225852dda191bf0f986f761", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ee40544aef309d4225852dda191bf0f986f761"}], "stats": {"total": 10106, "additions": 6355, "deletions": 3751}, "files": [{"sha": "5f50f383272034c896d7ac220ce0709d1674f2ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -1,3 +1,12 @@\n+2014-09-23  Kostya Serebryany  <kcc@google.com>\n+\n+\tUpdate to match the changed asan API.\n+\t* asan.c (asan_global_struct): Update the __asan_global definition\n+\tto match the new API.\n+\t(asan_add_global): Ditto.\n+\t* sanitizer.def (BUILT_IN_ASAN_INIT): Rename __asan_init_v3\n+\tto __asan_init_v4.\n+\n 2014-09-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.md (f32_vsx): New mode attributes to"}, {"sha": "6917950477d2302bc2feb1430e7ca4a62332ac7e", "filename": "gcc/asan.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -230,6 +230,9 @@ along with GCC; see the file COPYING3.  If not see\n \n        // 1 if it has dynamic initialization, 0 otherwise.\n        uptr __has_dynamic_init;\n+\n+       // A pointer to struct that contains source location, could be NULL.\n+       __asan_global_source_location *__location;\n      }\n \n    A destructor function that calls the runtime asan library function\n@@ -2136,19 +2139,20 @@ asan_dynamic_init_call (bool after_p)\n      const void *__name;\n      const void *__module_name;\n      uptr __has_dynamic_init;\n+     __asan_global_source_location *__location;\n    } type.  */\n \n static tree\n asan_global_struct (void)\n {\n-  static const char *field_names[6]\n+  static const char *field_names[7]\n     = { \"__beg\", \"__size\", \"__size_with_redzone\",\n-\t\"__name\", \"__module_name\", \"__has_dynamic_init\" };\n-  tree fields[6], ret;\n+\t\"__name\", \"__module_name\", \"__has_dynamic_init\", \"__location\"};\n+  tree fields[7], ret;\n   int i;\n \n   ret = make_node (RECORD_TYPE);\n-  for (i = 0; i < 6; i++)\n+  for (i = 0; i < 7; i++)\n     {\n       fields[i]\n \t= build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n@@ -2220,6 +2224,8 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n   int has_dynamic_init = vnode ? vnode->dynamically_initialized : 0;\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  build_int_cst (uptr, has_dynamic_init));\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n+\t\t\t  build_int_cst (uptr, 0));\n   init = build_constructor (type, vinner);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n }"}, {"sha": "722311a7868d5e5b6e8b0633149719c59fe6613a", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n    for other FEs by asan.c.  */\n \n /* Address Sanitizer */\n-DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v3\",\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_INIT, \"__asan_init_v4\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n /* Do not reorder the BUILT_IN_ASAN_{REPORT,CHECK}* builtins, e.g. cfgcleanup.c\n    relies on this order.  */"}, {"sha": "75c24b4756ba96a72346edf6e514787800b0fce6", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -1,3 +1,17 @@\n+2014-09-19  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r218156.\n+\t* asan/Makefile.am (asan_files): Added new files.\n+\t* asan/Makefile.in: Regenerate.\n+\t* ubsan/Makefile.am (ubsan_files): Added new files.\n+\t* ubsan/Makefile.in: Regenerate.\n+\t* tsan/Makefile.am (tsan_files): Added new files.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Added new\n+\t  files.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\t* asan/libtool-version: Bump the libasan SONAME.\n+\n 2014-09-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* ubsan/ubsan_handlers.cc, ubsan/ubsan_handlers.h: Cherry pick"}, {"sha": "48a7f26d32ddb7641acaca80a1ae61f842409e53", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -1,4 +1,4 @@\n-209283\n+218156\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "12f20ae6d2704943f9a84eeea8094f681169d4ef", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,7 +17,7 @@ nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n \tasan_activation.cc \\\n \tasan_allocator2.cc \\\n-\tasan_dll_thunk.cc \\\n+\tasan_debugging.cc \\\n \tasan_fake_stack.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n@@ -34,7 +34,9 @@ asan_files = \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n \tasan_thread.cc \\\n-\tasan_win.cc\n+\tasan_win.cc \\\n+\tasan_win_dll_thunk.cc \\\n+\tasan_win_dynamic_runtime_thunk.cc\n \n libasan_la_SOURCES = $(asan_files)\n libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/lsan/libsanitizer_lsan.la"}, {"sha": "862eec4cea1c1ca0d3b3802099cfaeb5d8d97a17", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -89,12 +89,13 @@ libasan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/lsan/libsanitizer_lsan.la $(am__append_2) \\\n \t$(am__append_3) $(am__DEPENDENCIES_1)\n am__objects_1 = asan_activation.lo asan_allocator2.lo \\\n-\tasan_dll_thunk.lo asan_fake_stack.lo asan_globals.lo \\\n+\tasan_debugging.lo asan_fake_stack.lo asan_globals.lo \\\n \tasan_interceptors.lo asan_linux.lo asan_mac.lo \\\n \tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n \tasan_new_delete.lo asan_poisoning.lo asan_posix.lo \\\n \tasan_report.lo asan_rtl.lo asan_stack.lo asan_stats.lo \\\n-\tasan_thread.lo asan_win.lo\n+\tasan_thread.lo asan_win.lo asan_win_dll_thunk.lo \\\n+\tasan_win_dynamic_runtime_thunk.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -275,7 +276,7 @@ nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n \tasan_activation.cc \\\n \tasan_allocator2.cc \\\n-\tasan_dll_thunk.cc \\\n+\tasan_debugging.cc \\\n \tasan_fake_stack.cc \\\n \tasan_globals.cc \\\n \tasan_interceptors.cc \\\n@@ -292,7 +293,9 @@ asan_files = \\\n \tasan_stack.cc \\\n \tasan_stats.cc \\\n \tasan_thread.cc \\\n-\tasan_win.cc\n+\tasan_win.cc \\\n+\tasan_win_dll_thunk.cc \\\n+\tasan_win_dynamic_runtime_thunk.cc\n \n libasan_la_SOURCES = $(asan_files)\n libasan_la_LIBADD =  \\\n@@ -416,7 +419,7 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator2.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_dll_thunk.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_debugging.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n@@ -434,6 +437,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dll_thunk.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo@am__quote@\n \n .cc.o:\n @am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<"}, {"sha": "567b36867ab7436d7b6b30f6b01edc036b3721e9", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -140,6 +140,8 @@ struct AsanThreadLocalMallocStorage {\n void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n                     AllocType alloc_type);\n void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type);\n+void asan_sized_free(void *ptr, uptr size, StackTrace *stack,\n+                     AllocType alloc_type);\n \n void *asan_malloc(uptr size, StackTrace *stack);\n void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack);"}, {"sha": "78c1ec113a65b0196b3105da38df962628aca025", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -19,6 +19,7 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n@@ -165,23 +166,6 @@ struct AsanChunk: ChunkBase {\n     }\n     return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n   }\n-  // If we don't use stack depot, we store the alloc/free stack traces\n-  // in the chunk itself.\n-  u32 *AllocStackBeg() {\n-    return (u32*)(Beg() - RZLog2Size(rz_log));\n-  }\n-  uptr AllocStackSize() {\n-    CHECK_LE(RZLog2Size(rz_log), kChunkHeaderSize);\n-    return (RZLog2Size(rz_log) - kChunkHeaderSize) / sizeof(u32);\n-  }\n-  u32 *FreeStackBeg() {\n-    return (u32*)(Beg() + kChunkHeader2Size);\n-  }\n-  uptr FreeStackSize() {\n-    if (user_requested_size < kChunkHeader2Size) return 0;\n-    uptr available = RoundUpTo(user_requested_size, SHADOW_GRANULARITY);\n-    return (available - kChunkHeader2Size) / sizeof(u32);\n-  }\n   bool AddrIsInside(uptr addr, bool locked_version = false) {\n     return (addr >= Beg()) && (addr < Beg() + UsedSize(locked_version));\n   }\n@@ -461,12 +445,17 @@ static void QuarantineChunk(AsanChunk *m, void *ptr,\n   }\n }\n \n-static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n+static void Deallocate(void *ptr, uptr delete_size, StackTrace *stack,\n+                       AllocType alloc_type) {\n   uptr p = reinterpret_cast<uptr>(ptr);\n   if (p == 0) return;\n \n   uptr chunk_beg = p - kChunkHeaderSize;\n   AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+  if (delete_size && flags()->new_delete_type_mismatch &&\n+      delete_size != m->UsedSize()) {\n+    ReportNewDeleteSizeMismatch(p, delete_size, stack);\n+  }\n   ASAN_FREE_HOOK(ptr);\n   // Must mark the chunk as quarantined before any changes to its metadata.\n   AtomicallySetQuarantineFlag(m, ptr, stack);\n@@ -493,7 +482,7 @@ static void *Reallocate(void *old_ptr, uptr new_size, StackTrace *stack) {\n     // If realloc() races with free(), we may start copying freed memory.\n     // However, we will report racy double-free later anyway.\n     REAL(memcpy)(new_ptr, old_ptr, memcpy_size);\n-    Deallocate(old_ptr, stack, FROM_MALLOC);\n+    Deallocate(old_ptr, 0, stack, FROM_MALLOC);\n   }\n   return new_ptr;\n }\n@@ -592,7 +581,12 @@ void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n }\n \n void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type) {\n-  Deallocate(ptr, stack, alloc_type);\n+  Deallocate(ptr, 0, stack, alloc_type);\n+}\n+\n+void asan_sized_free(void *ptr, uptr size, StackTrace *stack,\n+                     AllocType alloc_type) {\n+  Deallocate(ptr, size, stack, alloc_type);\n }\n \n void *asan_malloc(uptr size, StackTrace *stack) {\n@@ -614,7 +608,7 @@ void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n   if (p == 0)\n     return Allocate(size, 8, stack, FROM_MALLOC, true);\n   if (size == 0) {\n-    Deallocate(p, stack, FROM_MALLOC);\n+    Deallocate(p, 0, stack, FROM_MALLOC);\n     return 0;\n   }\n   return Reallocate(p, size, stack);\n@@ -758,23 +752,23 @@ using namespace __asan;  // NOLINT\n \n // ASan allocator doesn't reserve extra bytes, so normally we would\n // just return \"size\". We don't want to expose our redzone sizes, etc here.\n-uptr __asan_get_estimated_allocated_size(uptr size) {\n+uptr __sanitizer_get_estimated_allocated_size(uptr size) {\n   return size;\n }\n \n-int __asan_get_ownership(const void *p) {\n+int __sanitizer_get_ownership(const void *p) {\n   uptr ptr = reinterpret_cast<uptr>(p);\n   return (AllocationSize(ptr) > 0);\n }\n \n-uptr __asan_get_allocated_size(const void *p) {\n+uptr __sanitizer_get_allocated_size(const void *p) {\n   if (p == 0) return 0;\n   uptr ptr = reinterpret_cast<uptr>(p);\n   uptr allocated_size = AllocationSize(ptr);\n   // Die if p is not malloced or if it is already freed.\n   if (allocated_size == 0) {\n     GET_STACK_TRACE_FATAL_HERE;\n-    ReportAsanGetAllocatedSizeNotOwned(ptr, &stack);\n+    ReportSanitizerGetAllocatedSizeNotOwned(ptr, &stack);\n   }\n   return allocated_size;\n }\n@@ -783,12 +777,12 @@ uptr __asan_get_allocated_size(const void *p) {\n // Provide default (no-op) implementation of malloc hooks.\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __asan_malloc_hook(void *ptr, uptr size) {\n+void __sanitizer_malloc_hook(void *ptr, uptr size) {\n   (void)ptr;\n   (void)size;\n }\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-void __asan_free_hook(void *ptr) {\n+void __sanitizer_free_hook(void *ptr) {\n   (void)ptr;\n }\n }  // extern \"C\""}, {"sha": "36a9d0b5e9753d5041ebefaca94a986dc8df6beb", "filename": "libsanitizer/asan/asan_asm_instrumentation.S", "status": "removed", "additions": 0, "deletions": 599, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ee40544aef309d4225852dda191bf0f986f761/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ee40544aef309d4225852dda191bf0f986f761/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_asm_instrumentation.S?ref=e8ee40544aef309d4225852dda191bf0f986f761", "patch": "@@ -1,599 +0,0 @@\n-// This file was generated by gen_asm_instrumentation.sh. Please, do not edit\n-.section .text\n-#if defined(__x86_64__) || defined(__i386__)\n-.globl __asan_report_store1\n-.globl __asan_report_load1\n-.globl __asan_report_store2\n-.globl __asan_report_load2\n-.globl __asan_report_store4\n-.globl __asan_report_load4\n-.globl __asan_report_store8\n-.globl __asan_report_load8\n-.globl __asan_report_store16\n-.globl __asan_report_load16\n-#endif //  defined(__x86_64__) || defined(__i386__)\n-#if defined(__i386__)\n-// Sanitize 1-byte store. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_store1\n-.type __sanitizer_sanitize_store1, @function\n-__sanitizer_sanitize_store1:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_store1_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_store1_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_store1@PLT\n-.sanitize_store1_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 1-byte load. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_load1\n-.type __sanitizer_sanitize_load1, @function\n-__sanitizer_sanitize_load1:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_load1_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_load1_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_load1@PLT\n-.sanitize_load1_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 2-byte store. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_store2\n-.type __sanitizer_sanitize_store2, @function\n-__sanitizer_sanitize_store2:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_store2_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  incl %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_store2_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_store2@PLT\n-.sanitize_store2_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 2-byte load. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_load2\n-.type __sanitizer_sanitize_load2, @function\n-__sanitizer_sanitize_load2:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_load2_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  incl %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_load2_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_load2@PLT\n-.sanitize_load2_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 4-byte store. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_store4\n-.type __sanitizer_sanitize_store4, @function\n-__sanitizer_sanitize_store4:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_store4_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  addl $0x3, %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_store4_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_store4@PLT\n-.sanitize_store4_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 4-byte load. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_load4\n-.type __sanitizer_sanitize_load4, @function\n-__sanitizer_sanitize_load4:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushl %edx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  movb 0x20000000(%ecx), %cl\n-  testb %cl, %cl\n-  je .sanitize_load4_done\n-  movl %eax, %edx\n-  andl $0x7, %edx\n-  addl $0x3, %edx\n-  movsbl %cl, %ecx\n-  cmpl %ecx, %edx\n-  jl .sanitize_load4_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_load4@PLT\n-.sanitize_load4_done:\n-  popfl\n-  popl %edx\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 8-byte store. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_store8\n-.type __sanitizer_sanitize_store8, @function\n-__sanitizer_sanitize_store8:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  cmpb $0x0, 0x20000000(%ecx)\n-  je .sanitize_store8_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_store8@PLT\n-.sanitize_store8_done:\n-  popfl\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 8-byte load. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_load8\n-.type __sanitizer_sanitize_load8, @function\n-__sanitizer_sanitize_load8:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  cmpb $0x0, 0x20000000(%ecx)\n-  je .sanitize_load8_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_load8@PLT\n-.sanitize_load8_done:\n-  popfl\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 16-byte store. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_store16\n-.type __sanitizer_sanitize_store16, @function\n-__sanitizer_sanitize_store16:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  cmpw $0x0, 0x20000000(%ecx)\n-  je .sanitize_store16_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_store16@PLT\n-.sanitize_store16_done:\n-  popfl\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-// Sanitize 16-byte load. Takes one 4-byte address as an argument on\n-// stack, nothing is returned.\n-.globl __sanitizer_sanitize_load16\n-.type __sanitizer_sanitize_load16, @function\n-__sanitizer_sanitize_load16:\n-  pushl %ebp\n-  movl %esp, %ebp\n-  pushl %eax\n-  pushl %ecx\n-  pushfl\n-  movl 8(%ebp), %eax\n-  movl %eax, %ecx\n-  shrl $0x3, %ecx\n-  cmpw $0x0, 0x20000000(%ecx)\n-  je .sanitize_load16_done\n-  pushl %eax\n-  cld\n-  emms\n-  call __asan_report_load16@PLT\n-.sanitize_load16_done:\n-  popfl\n-  popl %ecx\n-  popl %eax\n-  leave\n-  ret\n-#endif // defined(__i386__)\n-#if defined(__x86_64__)\n-// Sanitize 1-byte store. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_store1\n-.type __sanitizer_sanitize_store1, @function\n-__sanitizer_sanitize_store1:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_store1_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_store1_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_store1@PLT\n-.sanitize_store1_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 1-byte load. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_load1\n-.type __sanitizer_sanitize_load1, @function\n-__sanitizer_sanitize_load1:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_load1_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_load1_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_load1@PLT\n-.sanitize_load1_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 2-byte store. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_store2\n-.type __sanitizer_sanitize_store2, @function\n-__sanitizer_sanitize_store2:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_store2_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  incl %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_store2_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_store2@PLT\n-.sanitize_store2_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 2-byte load. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_load2\n-.type __sanitizer_sanitize_load2, @function\n-__sanitizer_sanitize_load2:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_load2_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  incl %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_load2_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_load2@PLT\n-.sanitize_load2_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 4-byte store. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_store4\n-.type __sanitizer_sanitize_store4, @function\n-__sanitizer_sanitize_store4:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_store4_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  addl $0x3, %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_store4_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_store4@PLT\n-.sanitize_store4_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 4-byte load. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_load4\n-.type __sanitizer_sanitize_load4, @function\n-__sanitizer_sanitize_load4:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushq %rcx\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  movb 0x7fff8000(%rax), %al\n-  test %al, %al\n-  je .sanitize_load4_done\n-  movl %edi, %ecx\n-  andl $0x7, %ecx\n-  addl $0x3, %ecx\n-  movsbl %al, %eax\n-  cmpl %eax, %ecx\n-  jl .sanitize_load4_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_load4@PLT\n-.sanitize_load4_done:\n-  popfq\n-  popq %rcx\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 8-byte store. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_store8\n-.type __sanitizer_sanitize_store8, @function\n-__sanitizer_sanitize_store8:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  cmpb $0x0, 0x7fff8000(%rax)\n-  je .sanitize_store8_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_store8@PLT\n-.sanitize_store8_done:\n-  popfq\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 8-byte load. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_load8\n-.type __sanitizer_sanitize_load8, @function\n-__sanitizer_sanitize_load8:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  cmpb $0x0, 0x7fff8000(%rax)\n-  je .sanitize_load8_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_load8@PLT\n-.sanitize_load8_done:\n-  popfq\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 16-byte store. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_store16\n-.type __sanitizer_sanitize_store16, @function\n-__sanitizer_sanitize_store16:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  cmpw $0x0, 0x7fff8000(%rax)\n-  je .sanitize_store16_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_store16@PLT\n-.sanitize_store16_done:\n-  popfq\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-// Sanitize 16-byte load. Takes one 8-byte address as an argument in %rdi,\n-// nothing is returned.\n-.globl __sanitizer_sanitize_load16\n-.type __sanitizer_sanitize_load16, @function\n-__sanitizer_sanitize_load16:\n-  leaq -128(%rsp), %rsp\n-  pushq %rax\n-  pushfq\n-  movq %rdi, %rax\n-  shrq $0x3, %rax\n-  cmpw $0x0, 0x7fff8000(%rax)\n-  je .sanitize_load16_done\n-  subq $8, %rsp\n-  andq $-16, %rsp\n-  cld\n-  emms\n-  call __asan_report_load16@PLT\n-.sanitize_load16_done:\n-  popfq\n-  popq %rax\n-  leaq 128(%rsp), %rsp\n-  ret\n-#endif // defined(__x86_64__)\n-/* We do not need executable stack. */\n-#if defined(__arm__)\n-  .section .note.GNU-stack,\"\",%progbits\n-#else\n-  .section .note.GNU-stack,\"\",@progbits\n-#endif // defined(__arm__)\n-#endif // __linux__"}, {"sha": "302574d9dd83863baa632583df9f1123cfa9346b", "filename": "libsanitizer/asan/asan_debugging.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,72 @@\n+//===-- asan_debugging.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This file contains various functions that are generally useful to call when\n+// using a debugger (LLDB, GDB).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_flags.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_thread.h\"\n+\n+namespace __asan {\n+\n+uptr AsanGetStack(uptr addr, uptr *trace, uptr size, u32 *thread_id,\n+                  bool alloc_stack) {\n+  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n+  if (!chunk.IsValid()) return 0;\n+\n+  StackTrace stack;\n+  if (alloc_stack) {\n+    if (chunk.AllocTid() == kInvalidTid) return 0;\n+    chunk.GetAllocStack(&stack);\n+    if (thread_id) *thread_id = chunk.AllocTid();\n+  } else {\n+    if (chunk.FreeTid() == kInvalidTid) return 0;\n+    chunk.GetFreeStack(&stack);\n+    if (thread_id) *thread_id = chunk.FreeTid();\n+  }\n+\n+  if (trace && size) {\n+    if (size > kStackTraceMax)\n+      size = kStackTraceMax;\n+    if (size > stack.size)\n+      size = stack.size;\n+    for (uptr i = 0; i < size; i++)\n+      trace[i] = StackTrace::GetPreviousInstructionPc(stack.trace[i]);\n+\n+    return size;\n+  }\n+\n+  return 0;\n+}\n+\n+}  // namespace __asan\n+\n+using namespace __asan;\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __asan_get_alloc_stack(uptr addr, uptr *trace, uptr size, u32 *thread_id) {\n+  return AsanGetStack(addr, trace, size, thread_id, /* alloc_stack */ true);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __asan_get_free_stack(uptr addr, uptr *trace, uptr size, u32 *thread_id) {\n+  return AsanGetStack(addr, trace, size, thread_id, /* alloc_stack */ false);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_get_shadow_mapping(uptr *shadow_scale, uptr *shadow_offset) {\n+  if (shadow_scale)\n+    *shadow_scale = SHADOW_SCALE;\n+  if (shadow_offset)\n+    *shadow_offset = SHADOW_OFFSET;\n+}"}, {"sha": "2f155eb5cbc879507790c6e943d65b37beee4893", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -50,12 +50,13 @@ struct Flags {\n   bool print_stats;\n   bool print_legend;\n   bool atexit;\n-  bool disable_core;\n   bool allow_reexec;\n   bool print_full_thread_history;\n   bool poison_heap;\n   bool poison_partial;\n+  bool poison_array_cookie;\n   bool alloc_dealloc_mismatch;\n+  bool new_delete_type_mismatch;\n   bool strict_memcmp;\n   bool strict_init_order;\n   bool start_deactivated;"}, {"sha": "15c1886af0eb5d1d0f5830eb5576ea1beda3e93a", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,6 +20,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n namespace __asan {\n \n@@ -43,6 +44,14 @@ typedef InternalMmapVector<DynInitGlobal> VectorOfGlobals;\n // Lazy-initialized and never deleted.\n static VectorOfGlobals *dynamic_init_globals;\n \n+// We want to remember where a certain range of globals was registered.\n+struct GlobalRegistrationSite {\n+  u32 stack_id;\n+  Global *g_first, *g_last;\n+};\n+typedef InternalMmapVector<GlobalRegistrationSite> GlobalRegistrationSiteVector;\n+static GlobalRegistrationSiteVector *global_registration_site_vector;\n+\n ALWAYS_INLINE void PoisonShadowForGlobal(const Global *g, u8 value) {\n   FastPoisonShadow(g->beg, g->size_with_redzone, value);\n }\n@@ -61,9 +70,14 @@ ALWAYS_INLINE void PoisonRedZones(const Global &g) {\n }\n \n static void ReportGlobal(const Global &g, const char *prefix) {\n-  Report(\"%s Global: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu\\n\",\n-         prefix, (void*)g.beg, g.size, g.size_with_redzone, g.name,\n+  Report(\"%s Global[%p]: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu\\n\",\n+         prefix, &g, (void *)g.beg, g.size, g.size_with_redzone, g.name,\n          g.module_name, g.has_dynamic_init);\n+  if (g.location) {\n+    Report(\"  location (%p): name=%s[%p], %d %d\\n\", g.location,\n+           g.location->filename, g.location->filename, g.location->line_no,\n+           g.location->column_no);\n+  }\n }\n \n bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n@@ -79,6 +93,16 @@ bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n   return res;\n }\n \n+u32 FindRegistrationSite(const Global *g) {\n+  CHECK(global_registration_site_vector);\n+  for (uptr i = 0, n = global_registration_site_vector->size(); i < n; i++) {\n+    GlobalRegistrationSite &grs = (*global_registration_site_vector)[i];\n+    if (g >= grs.g_first && g <= grs.g_last)\n+      return grs.stack_id;\n+  }\n+  return 0;\n+}\n+\n // Register a global variable.\n // This function may be called more than once for every global\n // so we store the globals in a map.\n@@ -99,7 +123,8 @@ static void RegisterGlobal(const Global *g) {\n       for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n         if (g->beg == l->g->beg &&\n             (flags()->detect_odr_violation >= 2 || g->size != l->g->size))\n-          ReportODRViolation(g, l->g);\n+          ReportODRViolation(g, FindRegistrationSite(g),\n+                             l->g, FindRegistrationSite(l->g));\n       }\n     }\n   }\n@@ -155,7 +180,18 @@ using namespace __asan;  // NOLINT\n // Register an array of globals.\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n+  GET_STACK_TRACE_FATAL_HERE;\n+  u32 stack_id = StackDepotPut(stack.trace, stack.size);\n   BlockingMutexLock lock(&mu_for_globals);\n+  if (!global_registration_site_vector)\n+    global_registration_site_vector =\n+        new(allocator_for_globals) GlobalRegistrationSiteVector(128);\n+  GlobalRegistrationSite site = {stack_id, &globals[0], &globals[n - 1]};\n+  global_registration_site_vector->push_back(site);\n+  if (flags()->report_globals >= 2) {\n+    PRINT_CURRENT_STACK();\n+    Printf(\"=== ID %d; %p %p\\n\", stack_id, &globals[0], &globals[n - 1]);\n+  }\n   for (uptr i = 0; i < n; i++) {\n     RegisterGlobal(&globals[i]);\n   }"}, {"sha": "da232513a096cf425b0111d60a3c4639fd06377e", "filename": "libsanitizer/asan/asan_init_version.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_init_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_init_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_init_version.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,30 @@\n+//===-- asan_init_version.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This header defines a versioned __asan_init function to be called at the\n+// startup of the instrumented program.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_INIT_VERSION_H\n+#define ASAN_INIT_VERSION_H\n+\n+extern \"C\" {\n+  // Every time the ASan ABI changes we also change the version number in the\n+  // __asan_init function name.  Objects built with incompatible ASan ABI\n+  // versions will not link with run-time.\n+  // Changes between ABI versions:\n+  // v1=>v2: added 'module_name' to __asan_global\n+  // v2=>v3: stack frame description (created by the compiler)\n+  //         contains the function PC as the 3-rd field (see\n+  //         DescribeAddressIfStack).\n+  // v3=>v4: added '__asan_global_source_location' to __asan_global.\n+  #define __asan_init __asan_init_v4\n+  #define __asan_init_name \"__asan_init_v4\"\n+}\n+\n+#endif  // ASAN_INIT_VERSION_H"}, {"sha": "182b7842ed95eddf8ad1e1b8924c0d5345412655", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -144,6 +144,9 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   } while (false)\n #define COMMON_INTERCEPTOR_BLOCK_REAL(name) REAL(name)\n #define COMMON_INTERCEPTOR_ON_EXIT(ctx) OnExit()\n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res) CovUpdateMapping()\n+#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() CovUpdateMapping()\n+#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (!asan_inited)\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n #define COMMON_SYSCALL_PRE_READ_RANGE(p, s) ASAN_READ_RANGE(p, s)\n@@ -291,37 +294,29 @@ INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n }\n #endif\n \n-// intercept mlock and friends.\n-// Since asan maps 16T of RAM, mlock is completely unfriendly to asan.\n-// All functions return 0 (success).\n-static void MlockIsUnsupported() {\n-  static bool printed = false;\n-  if (printed) return;\n-  printed = true;\n-  VPrintf(1,\n-          \"INFO: AddressSanitizer ignores \"\n-          \"mlock/mlockall/munlock/munlockall\\n\");\n-}\n-\n-INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n-  MlockIsUnsupported();\n-  return 0;\n-}\n-\n-INTERCEPTOR(int, munlock, const void *addr, uptr len) {\n-  MlockIsUnsupported();\n-  return 0;\n+#if SANITIZER_WINDOWS\n+INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(RaiseException));\n+  __asan_handle_no_return();\n+  REAL(RaiseException)(a, b, c, d);\n }\n \n-INTERCEPTOR(int, mlockall, int flags) {\n-  MlockIsUnsupported();\n-  return 0;\n+INTERCEPTOR(int, _except_handler3, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(_except_handler3));\n+  __asan_handle_no_return();\n+  return REAL(_except_handler3)(a, b, c, d);\n }\n \n-INTERCEPTOR(int, munlockall, void) {\n-  MlockIsUnsupported();\n-  return 0;\n+#if ASAN_DYNAMIC\n+// This handler is named differently in -MT and -MD CRTs.\n+#define _except_handler4 _except_handler4_common\n+#endif\n+INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n+  CHECK(REAL(_except_handler4));\n+  __asan_handle_no_return();\n+  return REAL(_except_handler4)(a, b, c, d);\n }\n+#endif\n \n static inline int CharCmp(unsigned char c1, unsigned char c2) {\n   return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n@@ -523,23 +518,23 @@ INTERCEPTOR(char*, strdup, const char *s) {\n }\n #endif\n \n-INTERCEPTOR(uptr, strlen, const char *s) {\n+INTERCEPTOR(SIZE_T, strlen, const char *s) {\n   if (UNLIKELY(!asan_inited)) return internal_strlen(s);\n   // strlen is called from malloc_default_purgeable_zone()\n   // in __asan::ReplaceSystemAlloc() on Mac.\n   if (asan_init_is_running) {\n     return REAL(strlen)(s);\n   }\n   ENSURE_ASAN_INITED();\n-  uptr length = REAL(strlen)(s);\n+  SIZE_T length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n     ASAN_READ_RANGE(s, length + 1);\n   }\n   return length;\n }\n \n-INTERCEPTOR(uptr, wcslen, const wchar_t *s) {\n-  uptr length = REAL(wcslen)(s);\n+INTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n+  SIZE_T length = REAL(wcslen)(s);\n   if (!asan_init_is_running) {\n     ENSURE_ASAN_INITED();\n     ASAN_READ_RANGE(s, (length + 1) * sizeof(wchar_t));\n@@ -691,6 +686,16 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n \n+#if ASAN_INTERCEPT_FORK\n+INTERCEPTOR(int, fork, void) {\n+  ENSURE_ASAN_INITED();\n+  if (common_flags()->coverage) CovBeforeFork();\n+  int pid = REAL(fork)();\n+  if (common_flags()->coverage) CovAfterFork(pid);\n+  return pid;\n+}\n+#endif  // ASAN_INTERCEPT_FORK\n+\n #if SANITIZER_WINDOWS\n INTERCEPTOR_WINAPI(DWORD, CreateThread,\n                    void* security, uptr stack_size,\n@@ -712,6 +717,9 @@ INTERCEPTOR_WINAPI(DWORD, CreateThread,\n namespace __asan {\n void InitializeWindowsInterceptors() {\n   ASAN_INTERCEPT_FUNC(CreateThread);\n+  ASAN_INTERCEPT_FUNC(RaiseException);\n+  ASAN_INTERCEPT_FUNC(_except_handler3);\n+  ASAN_INTERCEPT_FUNC(_except_handler4);\n }\n \n }  // namespace __asan\n@@ -759,14 +767,6 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(strtoll);\n #endif\n \n-#if ASAN_INTERCEPT_MLOCKX\n-  // Intercept mlock/munlock.\n-  ASAN_INTERCEPT_FUNC(mlock);\n-  ASAN_INTERCEPT_FUNC(munlock);\n-  ASAN_INTERCEPT_FUNC(mlockall);\n-  ASAN_INTERCEPT_FUNC(munlockall);\n-#endif\n-\n   // Intecept signal- and jump-related functions.\n   ASAN_INTERCEPT_FUNC(longjmp);\n #if ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n@@ -789,7 +789,7 @@ void InitializeAsanInterceptors() {\n \n   // Intercept exception handling functions.\n #if ASAN_INTERCEPT___CXA_THROW\n-  INTERCEPT_FUNCTION(__cxa_throw);\n+  ASAN_INTERCEPT_FUNC(__cxa_throw);\n #endif\n \n   // Intercept threading-related functions\n@@ -802,6 +802,10 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(__cxa_atexit);\n #endif\n \n+#if ASAN_INTERCEPT_FORK\n+  ASAN_INTERCEPT_FUNC(fork);\n+#endif\n+\n   // Some Windows-specific interceptors.\n #if SANITIZER_WINDOWS\n   InitializeWindowsInterceptors();"}, {"sha": "95a75db4e02255b60c5496ecfe49093be03be470", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -24,14 +24,14 @@\n # define ASAN_INTERCEPT_STRDUP 1\n # define ASAN_INTERCEPT_INDEX 1\n # define ASAN_INTERCEPT_PTHREAD_CREATE 1\n-# define ASAN_INTERCEPT_MLOCKX 1\n+# define ASAN_INTERCEPT_FORK 1\n #else\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n # define ASAN_INTERCEPT__LONGJMP 0\n # define ASAN_INTERCEPT_STRDUP 0\n # define ASAN_INTERCEPT_INDEX 0\n # define ASAN_INTERCEPT_PTHREAD_CREATE 0\n-# define ASAN_INTERCEPT_MLOCKX 0\n+# define ASAN_INTERCEPT_FORK 0\n #endif\n \n #if SANITIZER_FREEBSD || SANITIZER_LINUX\n@@ -64,7 +64,9 @@\n # define ASAN_INTERCEPT_SIGLONGJMP 0\n #endif\n \n-#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS\n+// Android bug: https://code.google.com/p/android/issues/detail?id=61799\n+#if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && \\\n+    !(SANITIZER_ANDROID && defined(__i386))\n # define ASAN_INTERCEPT___CXA_THROW 1\n #else\n # define ASAN_INTERCEPT___CXA_THROW 0\n@@ -80,7 +82,7 @@ DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n DECLARE_REAL(void*, memset, void *block, int c, uptr size)\n DECLARE_REAL(char*, strchr, const char *str, int c)\n-DECLARE_REAL(uptr, strlen, const char *s)\n+DECLARE_REAL(SIZE_T, strlen, const char *s)\n DECLARE_REAL(char*, strncpy, char *to, const char *from, uptr size)\n DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n DECLARE_REAL(char*, strstr, const char *s1, const char *s2)"}, {"sha": "1a3b33fed0bd76b2b89a5e40259b2930b96a1714", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -15,21 +15,24 @@\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n+#include \"asan_init_version.h\"\n+\n using __sanitizer::uptr;\n \n extern \"C\" {\n   // This function should be called at the very beginning of the process,\n   // before any instrumented code is executed and before any call to malloc.\n-  // Every time the asan ABI changes we also change the version number in this\n-  // name. Objects build with incompatible asan ABI version\n-  // will not link with run-time.\n-  // Changes between ABI versions:\n-  // v1=>v2: added 'module_name' to __asan_global\n-  // v2=>v3: stack frame description (created by the compiler)\n-  //         contains the function PC as the 3-rd field (see\n-  //         DescribeAddressIfStack).\n-  SANITIZER_INTERFACE_ATTRIBUTE void __asan_init_v3();\n-  #define __asan_init __asan_init_v3\n+  // Please note that __asan_init is a macro that is replaced with\n+  // __asan_init_vXXX at compile-time.\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_init();\n+\n+  // This structure is used to describe the source location of a place where\n+  // global was defined.\n+  struct __asan_global_source_location {\n+    const char *filename;\n+    int line_no;\n+    int column_no;\n+  };\n \n   // This structure describes an instrumented global variable.\n   struct __asan_global {\n@@ -40,6 +43,8 @@ extern \"C\" {\n     const char *module_name; // Module name as a C string. This pointer is a\n                              // unique identifier of a module.\n     uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n+    __asan_global_source_location *location;  // Source location of a global,\n+                                              // or NULL if it is unknown.\n   };\n \n   // These two functions should be called by the instrumented code.\n@@ -83,6 +88,17 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_describe_address(uptr addr);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_alloc_stack(uptr addr, uptr *trace, uptr size,\n+                              u32 *thread_id);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_free_stack(uptr addr, uptr *trace, uptr size,\n+                             u32 *thread_id);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_get_shadow_mapping(uptr *shadow_scale, uptr *shadow_offset);\n+\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_report_error(uptr pc, uptr bp, uptr sp,\n                            uptr addr, int is_write, uptr access_size);\n@@ -97,25 +113,11 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   /* OPTIONAL */ void __asan_on_error();\n \n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  uptr __asan_get_estimated_allocated_size(uptr size);\n-\n-  SANITIZER_INTERFACE_ATTRIBUTE int __asan_get_ownership(const void *p);\n-  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_allocated_size(const void *p);\n-  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_current_allocated_bytes();\n-  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_heap_size();\n-  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_free_bytes();\n-  SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_get_unmapped_bytes();\n   SANITIZER_INTERFACE_ATTRIBUTE void __asan_print_accumulated_stats();\n \n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   /* OPTIONAL */ const char* __asan_default_options();\n \n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  /* OPTIONAL */ void __asan_malloc_hook(void *ptr, uptr size);\n-  SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n-  /* OPTIONAL */ void __asan_free_hook(void *ptr);\n-\n   // Global flag, copy of ASAN_OPTIONS=detect_stack_use_after_return\n   SANITIZER_INTERFACE_ATTRIBUTE\n   extern int __asan_option_detect_stack_use_after_return;\n@@ -142,6 +144,11 @@ extern \"C\" {\n       void* __asan_memset(void *s, int c, uptr n);\n   SANITIZER_INTERFACE_ATTRIBUTE\n       void* __asan_memmove(void* dest, const void* src, uptr n);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_poison_cxx_array_cookie(uptr p);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_load_cxx_array_cookie(uptr *p);\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "9473bf6a2ca41285e7fb3011496cd3e62904ad30", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -43,10 +43,6 @@\n # endif\n #endif\n \n-#ifndef ASAN_USE_PREINIT_ARRAY\n-# define ASAN_USE_PREINIT_ARRAY (SANITIZER_LINUX && !SANITIZER_ANDROID)\n-#endif\n-\n #ifndef ASAN_DYNAMIC\n # ifdef PIC\n #  define ASAN_DYNAMIC 1\n@@ -96,6 +92,8 @@ void AppendToErrorMessageBuffer(const char *buffer);\n \n void ParseExtraActivationFlags();\n \n+void *AsanDlSymNext(const char *sym);\n+\n // Platform-specific options.\n #if SANITIZER_MAC\n bool PlatformHasDifferentMemcpyAndMemmove();\n@@ -108,9 +106,9 @@ bool PlatformHasDifferentMemcpyAndMemmove();\n // Add convenient macro for interface functions that may be represented as\n // weak hooks.\n #define ASAN_MALLOC_HOOK(ptr, size) \\\n-  if (&__asan_malloc_hook) __asan_malloc_hook(ptr, size)\n+  if (&__sanitizer_malloc_hook) __sanitizer_malloc_hook(ptr, size)\n #define ASAN_FREE_HOOK(ptr) \\\n-  if (&__asan_free_hook) __asan_free_hook(ptr)\n+  if (&__sanitizer_free_hook) __sanitizer_free_hook(ptr)\n #define ASAN_ON_ERROR() \\\n   if (&__asan_on_error) __asan_on_error()\n \n@@ -134,6 +132,7 @@ const int kAsanContiguousContainerOOBMagic = 0xfc;\n const int kAsanStackUseAfterScopeMagic = 0xf8;\n const int kAsanGlobalRedzoneMagic = 0xf9;\n const int kAsanInternalHeapMagic = 0xfe;\n+const int kAsanArrayCookieMagic = 0xac;\n \n static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n static const uptr kRetiredStackFrameMagic = 0x45E0360E;"}, {"sha": "c504168b614207b8e8b60e201578e17c7a75e673", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,6 +17,7 @@\n #include \"asan_internal.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_freebsd.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n \n@@ -25,6 +26,7 @@\n #include <sys/mman.h>\n #include <sys/syscall.h>\n #include <sys/types.h>\n+#include <dlfcn.h>\n #include <fcntl.h>\n #include <pthread.h>\n #include <stdio.h>\n@@ -40,19 +42,14 @@\n extern \"C\" void* _DYNAMIC;\n #else\n #include <sys/ucontext.h>\n-#include <dlfcn.h>\n #include <link.h>\n #endif\n \n-// x86_64 FreeBSD 9.2 and older define 64-bit register names in both 64-bit\n-// and 32-bit modes.\n-#if SANITIZER_FREEBSD\n-#include <sys/param.h>\n-# if __FreeBSD_version <= 902001  // v9.2\n-#  define mc_eip mc_rip\n-#  define mc_ebp mc_rbp\n-#  define mc_esp mc_rsp\n-# endif\n+// x86-64 FreeBSD 9.2 and older define 'ucontext_t' incorrectly in\n+// 32-bit mode.\n+#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32) && \\\n+  __FreeBSD_version <= 902001  // v9.2\n+#define ucontext_t xucontext_t\n #endif\n \n typedef enum {\n@@ -241,6 +238,10 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n }\n #endif\n \n+void *AsanDlSymNext(const char *sym) {\n+  return dlsym(RTLD_NEXT, sym);\n+}\n+\n }  // namespace __asan\n \n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "e4c71cedd31a2e2b0da1851369fea6516b7faf36", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -372,32 +372,44 @@ void dispatch_source_set_event_handler(dispatch_source_t ds, void(^work)(void));\n     work(); \\\n   }\n \n+// Forces the compiler to generate a frame pointer in the function.\n+#define ENABLE_FRAME_POINTER                                       \\\n+  do {                                                             \\\n+    volatile uptr enable_fp;                                       \\\n+    enable_fp = GET_CURRENT_FRAME();                               \\\n+  } while (0)\n+\n INTERCEPTOR(void, dispatch_async,\n             dispatch_queue_t dq, void(^work)(void)) {\n+  ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_async)(dq, asan_block);\n }\n \n INTERCEPTOR(void, dispatch_group_async,\n             dispatch_group_t dg, dispatch_queue_t dq, void(^work)(void)) {\n+  ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_group_async)(dg, dq, asan_block);\n }\n \n INTERCEPTOR(void, dispatch_after,\n             dispatch_time_t when, dispatch_queue_t queue, void(^work)(void)) {\n+  ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_after)(when, queue, asan_block);\n }\n \n INTERCEPTOR(void, dispatch_source_set_cancel_handler,\n             dispatch_source_t ds, void(^work)(void)) {\n+  ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_source_set_cancel_handler)(ds, asan_block);\n }\n \n INTERCEPTOR(void, dispatch_source_set_event_handler,\n             dispatch_source_t ds, void(^work)(void)) {\n+  ENABLE_FRAME_POINTER;\n   GET_ASAN_BLOCK(work);\n   REAL(dispatch_source_set_event_handler)(ds, asan_block);\n }"}, {"sha": "d03f1bb89c8cbaac4036f4d8b9cd32bcdcaa1966", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 65, "deletions": 35, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -21,41 +21,6 @@\n #include \"asan_internal.h\"\n #include \"asan_stack.h\"\n \n-#if SANITIZER_ANDROID\n-DECLARE_REAL_AND_INTERCEPTOR(void*, malloc, uptr size)\n-DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n-DECLARE_REAL_AND_INTERCEPTOR(void*, calloc, uptr nmemb, uptr size)\n-DECLARE_REAL_AND_INTERCEPTOR(void*, realloc, void *ptr, uptr size)\n-DECLARE_REAL_AND_INTERCEPTOR(void*, memalign, uptr boundary, uptr size)\n-\n-struct MallocDebug {\n-  void* (*malloc)(uptr bytes);\n-  void  (*free)(void* mem);\n-  void* (*calloc)(uptr n_elements, uptr elem_size);\n-  void* (*realloc)(void* oldMem, uptr bytes);\n-  void* (*memalign)(uptr alignment, uptr bytes);\n-};\n-\n-const MallocDebug asan_malloc_dispatch ALIGNED(32) = {\n-  WRAP(malloc), WRAP(free), WRAP(calloc), WRAP(realloc), WRAP(memalign)\n-};\n-\n-extern \"C\" const MallocDebug* __libc_malloc_dispatch;\n-\n-namespace __asan {\n-void ReplaceSystemMalloc() {\n-  __libc_malloc_dispatch = &asan_malloc_dispatch;\n-}\n-}  // namespace __asan\n-\n-#else  // ANDROID\n-\n-namespace __asan {\n-void ReplaceSystemMalloc() {\n-}\n-}  // namespace __asan\n-#endif  // ANDROID\n-\n // ---------------------- Replacement functions ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n@@ -100,6 +65,11 @@ INTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n   return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n }\n \n+INTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_memalign(boundary, size, &stack, FROM_MALLOC);\n+}\n+\n INTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   void *res = asan_memalign(boundary, size, &stack, FROM_MALLOC);\n@@ -151,4 +121,64 @@ INTERCEPTOR(void, malloc_stats, void) {\n   __asan_print_accumulated_stats();\n }\n \n+#if SANITIZER_ANDROID\n+// Format of __libc_malloc_dispatch has changed in Android L.\n+// While we are moving towards a solution that does not depend on bionic\n+// internals, here is something to support both K* and L releases.\n+struct MallocDebugK {\n+  void *(*malloc)(uptr bytes);\n+  void (*free)(void *mem);\n+  void *(*calloc)(uptr n_elements, uptr elem_size);\n+  void *(*realloc)(void *oldMem, uptr bytes);\n+  void *(*memalign)(uptr alignment, uptr bytes);\n+  uptr (*malloc_usable_size)(void *mem);\n+};\n+\n+struct MallocDebugL {\n+  void *(*calloc)(uptr n_elements, uptr elem_size);\n+  void (*free)(void *mem);\n+  fake_mallinfo (*mallinfo)(void);\n+  void *(*malloc)(uptr bytes);\n+  uptr (*malloc_usable_size)(void *mem);\n+  void *(*memalign)(uptr alignment, uptr bytes);\n+  int (*posix_memalign)(void **memptr, uptr alignment, uptr size);\n+  void* (*pvalloc)(uptr size);\n+  void *(*realloc)(void *oldMem, uptr bytes);\n+  void* (*valloc)(uptr size);\n+};\n+\n+ALIGNED(32) const MallocDebugK asan_malloc_dispatch_k = {\n+    WRAP(malloc),  WRAP(free),     WRAP(calloc),\n+    WRAP(realloc), WRAP(memalign), WRAP(malloc_usable_size)};\n+\n+ALIGNED(32) const MallocDebugL asan_malloc_dispatch_l = {\n+    WRAP(calloc),         WRAP(free),               WRAP(mallinfo),\n+    WRAP(malloc),         WRAP(malloc_usable_size), WRAP(memalign),\n+    WRAP(posix_memalign), WRAP(pvalloc),            WRAP(realloc),\n+    WRAP(valloc)};\n+\n+namespace __asan {\n+void ReplaceSystemMalloc() {\n+  void **__libc_malloc_dispatch_p =\n+      (void **)AsanDlSymNext(\"__libc_malloc_dispatch\");\n+  if (__libc_malloc_dispatch_p) {\n+    // Decide on K vs L dispatch format by the presence of\n+    // __libc_malloc_default_dispatch export in libc.\n+    void *default_dispatch_p = AsanDlSymNext(\"__libc_malloc_default_dispatch\");\n+    if (default_dispatch_p)\n+      *__libc_malloc_dispatch_p = (void *)&asan_malloc_dispatch_k;\n+    else\n+      *__libc_malloc_dispatch_p = (void *)&asan_malloc_dispatch_l;\n+  }\n+}\n+}  // namespace __asan\n+\n+#else  // SANITIZER_ANDROID\n+\n+namespace __asan {\n+void ReplaceSystemMalloc() {\n+}\n+}  // namespace __asan\n+#endif  // SANITIZER_ANDROID\n+\n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "bbcf80e96ba9791aa0b587c012a64bac1f2b1250", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -21,71 +21,77 @@\n \n #include <stddef.h>\n \n-// ---------------------- Replacement functions ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n-// FIXME: Simply defining functions with the same signature in *.obj\n-// files overrides the standard functions in *.lib\n-// This works well for simple helloworld-like tests but might need to be\n-// revisited in the future.\n+// MT: Simply defining functions with the same signature in *.obj\n+// files overrides the standard functions in the CRT.\n+// MD: Memory allocation functions are defined in the CRT .dll,\n+// so we have to intercept them before they are called for the first time.\n+\n+#if ASAN_DYNAMIC\n+# define ALLOCATION_FUNCTION_ATTRIBUTE\n+#else\n+# define ALLOCATION_FUNCTION_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+#endif\n \n extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void free(void *ptr) {\n   GET_STACK_TRACE_FREE;\n   return asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n-void _free_dbg(void* ptr, int) {\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void _free_dbg(void *ptr, int) {\n   free(ptr);\n }\n \n+ALLOCATION_FUNCTION_ATTRIBUTE\n void cfree(void *ptr) {\n-  CHECK(!\"cfree() should not be used on Windows?\");\n+  CHECK(!\"cfree() should not be used on Windows\");\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *malloc(size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_malloc(size, &stack);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n-void* _malloc_dbg(size_t size, int , const char*, int) {\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_malloc_dbg(size_t size, int, const char *, int) {\n   return malloc(size);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *calloc(size_t nmemb, size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_calloc(nmemb, size, &stack);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n-void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {\n-  return calloc(n, size);\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_calloc_dbg(size_t nmemb, size_t size, int, const char *, int) {\n+  return calloc(nmemb, size);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *_calloc_impl(size_t nmemb, size_t size, int *errno_tmp) {\n   return calloc(nmemb, size);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *realloc(void *ptr, size_t size) {\n   GET_STACK_TRACE_MALLOC;\n   return asan_realloc(ptr, size, &stack);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *_realloc_dbg(void *ptr, size_t size, int) {\n   CHECK(!\"_realloc_dbg should not exist!\");\n   return 0;\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n-void* _recalloc(void* p, size_t n, size_t elem_size) {\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_recalloc(void *p, size_t n, size_t elem_size) {\n   if (!p)\n     return calloc(n, elem_size);\n   const size_t size = n * elem_size;\n@@ -94,23 +100,23 @@ void* _recalloc(void* p, size_t n, size_t elem_size) {\n   return realloc(p, size);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n size_t _msize(void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n   (void)sp;\n   return asan_malloc_usable_size(ptr, pc, bp);\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *_expand(void *memblock, size_t size) {\n   // _expand is used in realloc-like functions to resize the buffer if possible.\n   // We don't want memory to stand still while resizing buffers, so return 0.\n   return 0;\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n+ALLOCATION_FUNCTION_ATTRIBUTE\n void *_expand_dbg(void *memblock, size_t size) {\n-  return 0;\n+  return _expand(memblock, size);\n }\n \n // TODO(timurrrr): Might want to add support for _aligned_* allocation\n@@ -131,37 +137,38 @@ int _CrtSetReportMode(int, int) {\n }\n }  // extern \"C\"\n \n-using __interception::GetRealFunctionAddress;\n-\n-// We don't want to include \"windows.h\" in this file to avoid extra attributes\n-// set on malloc/free etc (e.g. dllimport), so declare a few things manually:\n-extern \"C\" int __stdcall VirtualProtect(void* addr, size_t size,\n-                                        DWORD prot, DWORD *old_prot);\n-const int PAGE_EXECUTE_READWRITE = 0x40;\n-\n namespace __asan {\n void ReplaceSystemMalloc() {\n-#if defined(_DLL)\n-# ifdef _WIN64\n-#  error ReplaceSystemMalloc was not tested on x64\n-# endif\n-  char *crt_malloc;\n-  if (GetRealFunctionAddress(\"malloc\", (void**)&crt_malloc)) {\n-    // Replace malloc in the CRT dll with a jump to our malloc.\n-    DWORD old_prot, unused;\n-    CHECK(VirtualProtect(crt_malloc, 16, PAGE_EXECUTE_READWRITE, &old_prot));\n-    REAL(memset)(crt_malloc, 0xCC /* int 3 */, 16);  // just in case.\n-\n-    ptrdiff_t jmp_offset = (char*)malloc - (char*)crt_malloc - 5;\n-    crt_malloc[0] = 0xE9;  // jmp, should be followed by an offset.\n-    REAL(memcpy)(crt_malloc + 1, &jmp_offset, sizeof(jmp_offset));\n-\n-    CHECK(VirtualProtect(crt_malloc, 16, old_prot, &unused));\n-\n-    // FYI: FlushInstructionCache is needed on Itanium etc but not on x86/x64.\n-  }\n-\n-  // FIXME: investigate whether anything else is needed.\n+#if defined(ASAN_DYNAMIC)\n+  // We don't check the result because CRT might not be used in the process.\n+  __interception::OverrideFunction(\"free\", (uptr)free);\n+  __interception::OverrideFunction(\"malloc\", (uptr)malloc);\n+  __interception::OverrideFunction(\"_malloc_crt\", (uptr)malloc);\n+  __interception::OverrideFunction(\"calloc\", (uptr)calloc);\n+  __interception::OverrideFunction(\"_calloc_crt\", (uptr)calloc);\n+  __interception::OverrideFunction(\"realloc\", (uptr)realloc);\n+  __interception::OverrideFunction(\"_realloc_crt\", (uptr)realloc);\n+  __interception::OverrideFunction(\"_recalloc\", (uptr)_recalloc);\n+  __interception::OverrideFunction(\"_recalloc_crt\", (uptr)_recalloc);\n+  __interception::OverrideFunction(\"_msize\", (uptr)_msize);\n+  __interception::OverrideFunction(\"_expand\", (uptr)_expand);\n+\n+  // Override different versions of 'operator new' and 'operator delete'.\n+  // No need to override the nothrow versions as they just wrap the throw\n+  // versions.\n+  // FIXME: Unfortunately, MSVC miscompiles the statements that take the\n+  // addresses of the array versions of these operators,\n+  // see https://connect.microsoft.com/VisualStudio/feedbackdetail/view/946992\n+  // We might want to try to work around this by [inline] assembly or compiling\n+  // parts of the RTL with Clang.\n+  void *(*op_new)(size_t sz) = operator new;\n+  void (*op_delete)(void *p) = operator delete;\n+  void *(*op_array_new)(size_t sz) = operator new[];\n+  void (*op_array_delete)(void *p) = operator delete[];\n+  __interception::OverrideFunction(\"??2@YAPAXI@Z\", (uptr)op_new);\n+  __interception::OverrideFunction(\"??3@YAXPAX@Z\", (uptr)op_delete);\n+  __interception::OverrideFunction(\"??_U@YAPAXI@Z\", (uptr)op_array_new);\n+  __interception::OverrideFunction(\"??_V@YAXPAX@Z\", (uptr)op_array_delete);\n #endif\n }\n }  // namespace __asan"}, {"sha": "9d6660ec7b491e256f399cb762016d85b1db7fa2", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -18,6 +18,13 @@\n \n #include <stddef.h>\n \n+// C++ operators can't have visibility attributes on Windows.\n+#if SANITIZER_WINDOWS\n+# define CXX_OPERATOR_ATTRIBUTE\n+#else\n+# define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n+#endif\n+\n using namespace __asan;  // NOLINT\n \n // This code has issues on OSX.\n@@ -49,14 +56,14 @@ struct nothrow_t {};\n #endif  // __FreeBSD_version\n #endif  // SANITIZER_FREEBSD && SANITIZER_WORDSIZE == 32\n \n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size) { OPERATOR_NEW_BODY(FROM_NEW); }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size) { OPERATOR_NEW_BODY(FROM_NEW_BR); }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void *operator new(size_t size, std::nothrow_t const&)\n { OPERATOR_NEW_BODY(FROM_NEW); }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void *operator new[](size_t size, std::nothrow_t const&)\n { OPERATOR_NEW_BODY(FROM_NEW_BR); }\n \n@@ -80,22 +87,32 @@ INTERCEPTOR(void *, _ZnamRKSt9nothrow_t, size_t size, std::nothrow_t const&) {\n   asan_free(ptr, &stack, type);\n \n #if !SANITIZER_MAC\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void operator delete(void *ptr) throw() {\n   OPERATOR_DELETE_BODY(FROM_NEW);\n }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void operator delete[](void *ptr) throw() {\n   OPERATOR_DELETE_BODY(FROM_NEW_BR);\n }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void operator delete(void *ptr, std::nothrow_t const&) {\n   OPERATOR_DELETE_BODY(FROM_NEW);\n }\n-INTERCEPTOR_ATTRIBUTE\n+CXX_OPERATOR_ATTRIBUTE\n void operator delete[](void *ptr, std::nothrow_t const&) {\n   OPERATOR_DELETE_BODY(FROM_NEW_BR);\n }\n+CXX_OPERATOR_ATTRIBUTE\n+void operator delete(void *ptr, size_t size) throw() {\n+  GET_STACK_TRACE_FREE;\n+  asan_sized_free(ptr, size, &stack, FROM_NEW);\n+}\n+CXX_OPERATOR_ATTRIBUTE\n+void operator delete[](void *ptr, size_t size) throw() {\n+  GET_STACK_TRACE_FREE;\n+  asan_sized_free(ptr, size, &stack, FROM_NEW_BR);\n+}\n \n #else  // SANITIZER_MAC\n INTERCEPTOR(void, _ZdlPv, void *ptr) {"}, {"sha": "65f6cf0046e32b362903a19cf004413a3430e623", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -225,6 +225,35 @@ void __sanitizer_unaligned_store64(uu64 *p, u64 x) {\n   *p = x;\n }\n \n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_poison_cxx_array_cookie(uptr p) {\n+  if (SANITIZER_WORDSIZE != 64) return;\n+  if (!flags()->poison_array_cookie) return;\n+  uptr s = MEM_TO_SHADOW(p);\n+  *reinterpret_cast<u8*>(s) = kAsanArrayCookieMagic;\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __asan_load_cxx_array_cookie(uptr *p) {\n+  if (SANITIZER_WORDSIZE != 64) return *p;\n+  if (!flags()->poison_array_cookie) return *p;\n+  uptr s = MEM_TO_SHADOW(reinterpret_cast<uptr>(p));\n+  u8 sval = *reinterpret_cast<u8*>(s);\n+  if (sval == kAsanArrayCookieMagic) return *p;\n+  // If sval is not kAsanArrayCookieMagic it can only be freed memory,\n+  // which means that we are going to get double-free. So, return 0 to avoid\n+  // infinite loop of destructors. We don't want to report a double-free here\n+  // though, so print a warning just in case.\n+  // CHECK_EQ(sval, kAsanHeapFreeMagic);\n+  if (sval == kAsanHeapFreeMagic) {\n+    Report(\"AddressSanitizer: loaded array cookie from free-d memory; \"\n+           \"expect a double-free report\\n\");\n+    return 0;\n+  }\n+  // FIXME: apparently it can be something else; need to find a reproducer.\n+  return *p;\n+}\n+\n // This is a simplified version of __asan_(un)poison_memory_region, which\n // assumes that left border of region to be poisoned is properly aligned.\n static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {"}, {"sha": "9644b7d840ec41d1f13d7e822eddcf1c026116cc", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -33,7 +33,6 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n                                     u8 value) {\n   DCHECK(flags()->poison_heap);\n-  uptr PageSize = GetPageSizeCached();\n   uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n   uptr shadow_end = MEM_TO_SHADOW(\n       aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n@@ -46,8 +45,9 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n       shadow_end - shadow_beg < common_flags()->clear_shadow_mmap_threshold) {\n     REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n   } else {\n-    uptr page_beg = RoundUpTo(shadow_beg, PageSize);\n-    uptr page_end = RoundDownTo(shadow_end, PageSize);\n+    uptr page_size = GetPageSizeCached();\n+    uptr page_beg = RoundUpTo(shadow_beg, page_size);\n+    uptr page_end = RoundDownTo(shadow_end, page_size);\n \n     if (page_beg >= page_end) {\n       REAL(memset)((void *)shadow_beg, 0, shadow_end - shadow_beg);"}, {"sha": "4eabb74ba800cd7662d897a2579d6caa5218f7e4", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -48,7 +48,7 @@ void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n       (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n     ReportStackOverflow(pc, sp, bp, context, addr);\n   else\n-    ReportSIGSEGV(pc, sp, bp, context, addr);\n+    ReportSIGSEGV(\"SEGV\", pc, sp, bp, context, addr);\n }\n \n // ---------------------- TSD ---------------- {{{1"}, {"sha": "2ce1fb9b666e38f70bb38aef47e84e425551ebab", "filename": "libsanitizer/asan/asan_preinit.cc", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_preinit.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -8,22 +8,12 @@\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n // Call __asan_init at the very early stage of process startup.\n-// On Linux we use .preinit_array section (unless PIC macro is defined).\n //===----------------------------------------------------------------------===//\n #include \"asan_internal.h\"\n \n-#if ASAN_USE_PREINIT_ARRAY && !defined(PIC)\n-  // On Linux, we force __asan_init to be called before anyone else\n-  // by placing it into .preinit_array section.\n-  // FIXME: do we have anything like this on Mac?\n+#if SANITIZER_CAN_USE_PREINIT_ARRAY\n   // The symbol is called __local_asan_preinit, because it's not intended to be\n   // exported.\n   __attribute__((section(\".preinit_array\"), used))\n   void (*__local_asan_preinit)(void) = __asan_init;\n-#elif SANITIZER_WINDOWS && defined(_DLL)\n-  // On Windows, when using dynamic CRT (/MD), we can put a pointer\n-  // to __asan_init into the global list of C initializers.\n-  // See crt0dat.c in the CRT sources for the details.\n-  #pragma section(\".CRT$XIB\", long, read)  // NOLINT\n-  __declspec(allocate(\".CRT$XIB\")) void (*__asan_preinit)() = __asan_init;\n #endif"}, {"sha": "05622a12518ba05cc6744c48be7841c1240563f3", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 130, "deletions": 48, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -57,6 +57,7 @@ class Decorator: public __sanitizer::SanitizerCommonDecorator {\n     switch (byte) {\n       case kAsanHeapLeftRedzoneMagic:\n       case kAsanHeapRightRedzoneMagic:\n+      case kAsanArrayCookieMagic:\n         return Red();\n       case kAsanHeapFreeMagic:\n         return Magenta();\n@@ -141,6 +142,8 @@ static void PrintLegend(InternalScopedString *str) {\n                   kAsanUserPoisonedMemoryMagic);\n   PrintShadowByte(str, \"  Container overflow:      \",\n                   kAsanContiguousContainerOOBMagic);\n+  PrintShadowByte(str, \"  Array cookie:            \",\n+                  kAsanArrayCookieMagic);\n   PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n }\n \n@@ -195,7 +198,7 @@ static const char *MaybeDemangleGlobalName(const char *name) {\n   else if (SANITIZER_WINDOWS && name[0] == '\\01' && name[1] == '?')\n     should_demangle = true;\n \n-  return should_demangle ? Symbolizer::Get()->Demangle(name) : name;\n+  return should_demangle ? Symbolizer::GetOrInit()->Demangle(name) : name;\n }\n \n // Check if the global is a zero-terminated ASCII string. If so, print it.\n@@ -210,6 +213,26 @@ static void PrintGlobalNameIfASCII(InternalScopedString *str,\n               (char *)g.beg);\n }\n \n+static const char *GlobalFilename(const __asan_global &g) {\n+  const char *res = g.module_name;\n+  // Prefer the filename from source location, if is available.\n+  if (g.location)\n+    res = g.location->filename;\n+  CHECK(res);\n+  return res;\n+}\n+\n+static void PrintGlobalLocation(InternalScopedString *str,\n+                                const __asan_global &g) {\n+  str->append(\"%s\", GlobalFilename(g));\n+  if (!g.location)\n+    return;\n+  if (g.location->line_no)\n+    str->append(\":%d\", g.location->line_no);\n+  if (g.location->column_no)\n+    str->append(\":%d\", g.location->column_no);\n+}\n+\n bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n                                      const __asan_global &g) {\n   static const uptr kMinimalDistanceFromAnotherGlobal = 64;\n@@ -230,8 +253,10 @@ bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n     // Can it happen?\n     str.append(\"%p is located %zd bytes inside\", (void *)addr, addr - g.beg);\n   }\n-  str.append(\" of global variable '%s' from '%s' (0x%zx) of size %zu\\n\",\n-             MaybeDemangleGlobalName(g.name), g.module_name, g.beg, g.size);\n+  str.append(\" of global variable '%s' defined in '\",\n+             MaybeDemangleGlobalName(g.name));\n+  PrintGlobalLocation(&str, g);\n+  str.append(\"' (0x%zx) of size %zu\\n\", g.beg, g.size);\n   str.append(\"%s\", d.EndLocation());\n   PrintGlobalNameIfASCII(&str, g);\n   Printf(\"%s\", str.data());\n@@ -317,12 +342,27 @@ void PrintAccessAndVarIntersection(const char *var_name,\n   Printf(\"%s\", str.data());\n }\n \n-struct StackVarDescr {\n-  uptr beg;\n-  uptr size;\n-  const char *name_pos;\n-  uptr name_len;\n-};\n+bool ParseFrameDescription(const char *frame_descr,\n+                           InternalMmapVector<StackVarDescr> *vars) {\n+  char *p;\n+  uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n+  CHECK_GT(n_objects, 0);\n+\n+  for (uptr i = 0; i < n_objects; i++) {\n+    uptr beg  = (uptr)internal_simple_strtoll(p, &p, 10);\n+    uptr size = (uptr)internal_simple_strtoll(p, &p, 10);\n+    uptr len  = (uptr)internal_simple_strtoll(p, &p, 10);\n+    if (beg == 0 || size == 0 || *p != ' ') {\n+      return false;\n+    }\n+    p++;\n+    StackVarDescr var = {beg, size, p, len};\n+    vars->push_back(var);\n+    p += len;\n+  }\n+\n+  return true;\n+}\n \n bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n   AsanThread *t = FindThreadByStackAddress(addr);\n@@ -364,32 +404,19 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n   alloca_stack.size = 1;\n   Printf(\"%s\", d.EndLocation());\n   alloca_stack.Print();\n+\n+  InternalMmapVector<StackVarDescr> vars(16);\n+  if (!ParseFrameDescription(frame_descr, &vars)) {\n+    Printf(\"AddressSanitizer can't parse the stack frame \"\n+           \"descriptor: |%s|\\n\", frame_descr);\n+    // 'addr' is a stack address, so return true even if we can't parse frame\n+    return true;\n+  }\n+  uptr n_objects = vars.size();\n   // Report the number of stack objects.\n-  char *p;\n-  uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n-  CHECK_GT(n_objects, 0);\n   Printf(\"  This frame has %zu object(s):\\n\", n_objects);\n \n   // Report all objects in this frame.\n-  InternalScopedBuffer<StackVarDescr> vars(n_objects);\n-  for (uptr i = 0; i < n_objects; i++) {\n-    uptr beg, size;\n-    uptr len;\n-    beg  = (uptr)internal_simple_strtoll(p, &p, 10);\n-    size = (uptr)internal_simple_strtoll(p, &p, 10);\n-    len  = (uptr)internal_simple_strtoll(p, &p, 10);\n-    if (beg == 0 || size == 0 || *p != ' ') {\n-      Printf(\"AddressSanitizer can't parse the stack frame \"\n-                 \"descriptor: |%s|\\n\", frame_descr);\n-      break;\n-    }\n-    p++;\n-    vars[i].beg = beg;\n-    vars[i].size = size;\n-    vars[i].name_pos = p;\n-    vars[i].name_len = len;\n-    p += len;\n-  }\n   for (uptr i = 0; i < n_objects; i++) {\n     buf[0] = 0;\n     internal_strncat(buf, vars[i].name_pos,\n@@ -401,8 +428,12 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n                                   prev_var_end, next_var_beg);\n   }\n   Printf(\"HINT: this may be a false positive if your program uses \"\n-             \"some custom stack unwind mechanism or swapcontext\\n\"\n-             \"      (longjmp and C++ exceptions *are* supported)\\n\");\n+         \"some custom stack unwind mechanism or swapcontext\\n\");\n+  if (SANITIZER_WINDOWS)\n+    Printf(\"      (longjmp, SEH and C++ exceptions *are* supported)\\n\");\n+  else\n+    Printf(\"      (longjmp and C++ exceptions *are* supported)\\n\");\n+\n   DescribeThread(t);\n   return true;\n }\n@@ -531,7 +562,7 @@ class ScopedInErrorReport {\n       // Do not print more than one report, otherwise they will mix up.\n       // Error reporting functions shouldn't return at this situation, as\n       // they are defined as no-return.\n-      Report(\"AddressSanitizer: while reporting a bug found another one.\"\n+      Report(\"AddressSanitizer: while reporting a bug found another one. \"\n                  \"Ignoring.\\n\");\n       u32 current_tid = GetCurrentTidOrInvalid();\n       if (current_tid != reporting_thread_tid) {\n@@ -578,24 +609,28 @@ void ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr) {\n   Printf(\"%s\", d.Warning());\n   Report(\n       \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n-      \" (pc %p sp %p bp %p T%d)\\n\",\n-      (void *)addr, (void *)pc, (void *)sp, (void *)bp,\n+      \" (pc %p bp %p sp %p T%d)\\n\",\n+      (void *)addr, (void *)pc, (void *)bp, (void *)sp,\n       GetCurrentTidOrInvalid());\n   Printf(\"%s\", d.EndWarning());\n   GET_STACK_TRACE_SIGNAL(pc, bp, context);\n   stack.Print();\n   ReportErrorSummary(\"stack-overflow\", &stack);\n }\n \n-void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, void *context, uptr addr) {\n+void ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n+                   void *context, uptr addr) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\n-      \"ERROR: AddressSanitizer: SEGV on unknown address %p\"\n-      \" (pc %p sp %p bp %p T%d)\\n\",\n-      (void *)addr, (void *)pc, (void *)sp, (void *)bp,\n+      \"ERROR: AddressSanitizer: %s on unknown address %p\"\n+      \" (pc %p bp %p sp %p T%d)\\n\",\n+      description, (void *)addr, (void *)pc, (void *)bp, (void *)sp,\n       GetCurrentTidOrInvalid());\n+  if (pc < GetPageSizeCached()) {\n+    Report(\"Hint: pc points to the zero page.\\n\");\n+  }\n   Printf(\"%s\", d.EndWarning());\n   GET_STACK_TRACE_SIGNAL(pc, bp, context);\n   stack.Print();\n@@ -621,6 +656,30 @@ void ReportDoubleFree(uptr addr, StackTrace *free_stack) {\n   ReportErrorSummary(\"double-free\", &stack);\n }\n \n+void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n+                                 StackTrace *free_stack) {\n+  ScopedInErrorReport in_report;\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  char tname[128];\n+  u32 curr_tid = GetCurrentTidOrInvalid();\n+  Report(\"ERROR: AddressSanitizer: new-delete-type-mismatch on %p in \"\n+         \"thread T%d%s:\\n\",\n+         addr, curr_tid,\n+         ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n+  Printf(\"%s  object passed to delete has wrong type:\\n\", d.EndWarning());\n+  Printf(\"  size of the allocated type:   %zd bytes;\\n\"\n+         \"  size of the deallocated type: %zd bytes.\\n\",\n+         asan_mz_size(reinterpret_cast<void*>(addr)), delete_size);\n+  CHECK_GT(free_stack->size, 0);\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  stack.Print();\n+  DescribeHeapAddress(addr, 1);\n+  ReportErrorSummary(\"new-delete-type-mismatch\", &stack);\n+  Report(\"HINT: if you don't care about these warnings you may set \"\n+         \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n+}\n+\n void ReportFreeNotMalloced(uptr addr, StackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n@@ -674,17 +733,17 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n   ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n }\n \n-void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n+void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\"ERROR: AddressSanitizer: attempting to call \"\n-             \"__asan_get_allocated_size() for pointer which is \"\n+             \"__sanitizer_get_allocated_size() for pointer which is \"\n              \"not owned: %p\\n\", addr);\n   Printf(\"%s\", d.EndWarning());\n   stack->Print();\n   DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"bad-__asan_get_allocated_size\", stack);\n+  ReportErrorSummary(\"bad-__sanitizer_get_allocated_size\", stack);\n }\n \n void ReportStringFunctionMemoryRangesOverlap(\n@@ -733,17 +792,36 @@ void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n   ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n }\n \n-void ReportODRViolation(const __asan_global *g1, const __asan_global *g2) {\n+void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n+                        const __asan_global *g2, u32 stack_id2) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\"ERROR: AddressSanitizer: odr-violation (%p):\\n\", g1->beg);\n   Printf(\"%s\", d.EndWarning());\n-  Printf(\"  [1] size=%zd %s %s\\n\", g1->size, g1->name, g1->module_name);\n-  Printf(\"  [2] size=%zd %s %s\\n\", g2->size, g2->name, g2->module_name);\n+  InternalScopedString g1_loc(256), g2_loc(256);\n+  PrintGlobalLocation(&g1_loc, *g1);\n+  PrintGlobalLocation(&g2_loc, *g2);\n+  Printf(\"  [1] size=%zd '%s' %s\\n\", g1->size,\n+         MaybeDemangleGlobalName(g1->name), g1_loc.data());\n+  Printf(\"  [2] size=%zd '%s' %s\\n\", g2->size,\n+         MaybeDemangleGlobalName(g2->name), g2_loc.data());\n+  if (stack_id1 && stack_id2) {\n+    Printf(\"These globals were registered at these points:\\n\");\n+    Printf(\"  [1]:\\n\");\n+    uptr stack_size;\n+    const uptr *stack_trace = StackDepotGet(stack_id1, &stack_size);\n+    StackTrace::PrintStack(stack_trace, stack_size);\n+    Printf(\"  [2]:\\n\");\n+    stack_trace = StackDepotGet(stack_id2, &stack_size);\n+    StackTrace::PrintStack(stack_trace, stack_size);\n+  }\n   Report(\"HINT: if you don't care about these warnings you may set \"\n          \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n-  ReportErrorSummary(\"odr-violation\", g1->module_name, 0, g1->name);\n+  InternalScopedString error_msg(256);\n+  error_msg.append(\"odr-violation: global '%s' at %s\",\n+                   MaybeDemangleGlobalName(g1->name), g1_loc.data());\n+  ReportErrorSummary(error_msg.data());\n }\n \n // ----------------------- CheckForInvalidPointerPair ----------- {{{1\n@@ -831,6 +909,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n     switch (*shadow_addr) {\n       case kAsanHeapLeftRedzoneMagic:\n       case kAsanHeapRightRedzoneMagic:\n+      case kAsanArrayCookieMagic:\n         bug_descr = \"heap-buffer-overflow\";\n         break;\n       case kAsanHeapFreeMagic:\n@@ -867,7 +946,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\"ERROR: AddressSanitizer: %s on address \"\n-             \"%p at pc 0x%zx bp 0x%zx sp 0x%zx\\n\",\n+             \"%p at pc %p bp %p sp %p\\n\",\n              bug_descr, (void*)addr, pc, bp, sp);\n   Printf(\"%s\", d.EndWarning());\n \n@@ -899,7 +978,10 @@ void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n }\n \n void __asan_describe_address(uptr addr) {\n+  // Thread registry must be locked while we're describing an address.\n+  asanThreadRegistry().Lock();\n   DescribeAddress(addr, 1);\n+  asanThreadRegistry().Unlock();\n }\n \n extern \"C\" {"}, {"sha": "4e81b9ca3a8e3a4b9e0d81cc02c67365ac4b4b6c", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -16,13 +16,22 @@\n \n namespace __asan {\n \n+struct StackVarDescr {\n+  uptr beg;\n+  uptr size;\n+  const char *name_pos;\n+  uptr name_len;\n+};\n+\n // The following functions prints address description depending\n // on the memory type (shadow/heap/stack/global).\n void DescribeHeapAddress(uptr addr, uptr access_size);\n bool DescribeAddressIfGlobal(uptr addr, uptr access_size);\n bool DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n                                      const __asan_global &g);\n bool DescribeAddressIfShadow(uptr addr);\n+bool ParseFrameDescription(const char *frame_descr,\n+                           InternalMmapVector<StackVarDescr> *vars);\n bool DescribeAddressIfStack(uptr addr, uptr access_size);\n // Determines memory type on its own.\n void DescribeAddress(uptr addr, uptr access_size);\n@@ -32,17 +41,19 @@ void DescribeThread(AsanThreadContext *context);\n // Different kinds of error reports.\n void NORETURN\n     ReportStackOverflow(uptr pc, uptr sp, uptr bp, void *context, uptr addr);\n-void NORETURN\n-    ReportSIGSEGV(uptr pc, uptr sp, uptr bp, void *context, uptr addr);\n+void NORETURN ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n+                            void *context, uptr addr);\n+void NORETURN ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n+                                          StackTrace *free_stack);\n void NORETURN ReportDoubleFree(uptr addr, StackTrace *free_stack);\n void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *free_stack);\n void NORETURN ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n                                       AllocType alloc_type,\n                                       AllocType dealloc_type);\n void NORETURN ReportMallocUsableSizeNotOwned(uptr addr,\n                                              StackTrace *stack);\n-void NORETURN ReportAsanGetAllocatedSizeNotOwned(uptr addr,\n-                                                 StackTrace *stack);\n+void NORETURN\n+ReportSanitizerGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack);\n void NORETURN ReportStringFunctionMemoryRangesOverlap(\n     const char *function, const char *offset1, uptr length1,\n     const char *offset2, uptr length2, StackTrace *stack);\n@@ -53,7 +64,8 @@ ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end, uptr old_mid,\n                                              uptr new_mid, StackTrace *stack);\n \n void NORETURN\n-ReportODRViolation(const __asan_global *g1, const __asan_global *g2);\n+ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n+                   const __asan_global *g2, u32 stack_id2);\n \n // Mac-specific errors and warnings.\n void WarnMacFreeUnallocated("}, {"sha": "8fccc8da967b415c044cce28284ff90d0d745d5e", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -171,11 +171,6 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n       \"If set, prints ASan exit stats even after program terminates \"\n       \"successfully.\");\n \n-  ParseFlag(str, &f->disable_core, \"disable_core\",\n-      \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n-      \"dumping a 16T+ core file. \"\n-      \"Ignored on OSes that don't dump core by default.\");\n-\n   ParseFlag(str, &f->allow_reexec, \"allow_reexec\",\n       \"Allow the tool to re-exec the program. This may interfere badly with \"\n       \"the debugger.\");\n@@ -189,13 +184,20 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n       \"Poison (or not) the heap memory on [de]allocation. Zero value is useful \"\n       \"for benchmarking the allocator or instrumentator.\");\n \n+  ParseFlag(str, &f->poison_array_cookie, \"poison_array_cookie\",\n+      \"Poison (or not) the array cookie after operator new[].\");\n+\n   ParseFlag(str, &f->poison_partial, \"poison_partial\",\n       \"If true, poison partially addressable 8-byte aligned words \"\n       \"(default=true). This flag affects heap and global buffers, but not \"\n       \"stack buffers.\");\n \n   ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\",\n       \"Report errors on malloc/delete, new/free, new/delete[], etc.\");\n+\n+  ParseFlag(str, &f->new_delete_type_mismatch, \"new_delete_type_mismatch\",\n+      \"Report errors on mismatch betwen size of new and delete.\");\n+\n   ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\",\n       \"If true, assume that memcmp(p1, p2, n) always reads n bytes before \"\n       \"comparing p1 and p2.\");\n@@ -262,21 +264,23 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->print_stats = false;\n   f->print_legend = true;\n   f->atexit = false;\n-  f->disable_core = (SANITIZER_WORDSIZE == 64);\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;\n   f->poison_heap = true;\n+  f->poison_array_cookie = true;\n   f->poison_partial = true;\n   // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=131\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=309\n   // TODO(glider,timurrrr): Fix known issues and enable this back.\n   f->alloc_dealloc_mismatch = (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0);\n+  f->new_delete_type_mismatch = true;\n   f->strict_memcmp = true;\n   f->strict_init_order = false;\n   f->start_deactivated = false;\n   f->detect_invalid_pointer_pairs = 0;\n   f->detect_container_overflow = true;\n+  f->detect_odr_violation = 2;\n \n   // Override from compile definition.\n   ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefinition());\n@@ -456,13 +460,6 @@ static NOINLINE void force_interface_symbols() {\n     case 15: __asan_set_error_report_callback(0); break;\n     case 16: __asan_handle_no_return(); break;\n     case 17: __asan_address_is_poisoned(0); break;\n-    case 18: __asan_get_allocated_size(0); break;\n-    case 19: __asan_get_current_allocated_bytes(); break;\n-    case 20: __asan_get_estimated_allocated_size(0); break;\n-    case 21: __asan_get_free_bytes(); break;\n-    case 22: __asan_get_heap_size(); break;\n-    case 23: __asan_get_ownership(0); break;\n-    case 24: __asan_get_unmapped_bytes(); break;\n     case 25: __asan_poison_memory_region(0, 0); break;\n     case 26: __asan_unpoison_memory_region(0, 0); break;\n     case 27: __asan_set_error_exit_code(0); break;\n@@ -593,6 +590,11 @@ static void AsanInitInternal() {\n \n   InitializeAsanInterceptors();\n \n+  // Enable system log (\"adb logcat\") on Android.\n+  // Doing this before interceptors are initialized crashes in:\n+  // AsanInitInternal -> android_log_write -> __interceptor_strcmp\n+  AndroidLogInit();\n+\n   ReplaceSystemMalloc();\n \n   uptr shadow_start = kLowShadowBeg;\n@@ -601,7 +603,8 @@ static void AsanInitInternal() {\n   bool full_shadow_is_available =\n       MemoryRangeIsAvailable(shadow_start, kHighShadowEnd);\n \n-#if SANITIZER_LINUX && defined(__x86_64__) && !ASAN_FIXED_MAPPING\n+#if SANITIZER_LINUX && defined(__x86_64__) && defined(_LP64) &&                \\\n+    !ASAN_FIXED_MAPPING\n   if (!full_shadow_is_available) {\n     kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n     kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x4fffffffffULL : 0;\n@@ -611,9 +614,7 @@ static void AsanInitInternal() {\n   if (common_flags()->verbosity)\n     PrintAddressSpaceLayout();\n \n-  if (flags()->disable_core) {\n-    DisableCoreDumper();\n-  }\n+  DisableCoreDumperIfNecessary();\n \n   if (full_shadow_is_available) {\n     // mmap the low shadow plus at least one page at the left.\n@@ -648,12 +649,8 @@ static void AsanInitInternal() {\n   AsanTSDInit(PlatformTSDDtor);\n   InstallDeadlySignalHandlers(AsanOnSIGSEGV);\n \n-  // Allocator should be initialized before starting external symbolizer, as\n-  // fork() on Mac locks the allocator.\n   InitializeAllocator();\n \n-  Symbolizer::Init(common_flags()->external_symbolizer_path);\n-\n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n   asan_inited = 1;\n@@ -682,7 +679,7 @@ static void AsanInitInternal() {\n   SanitizerInitializeUnwinder();\n \n #if CAN_SANITIZE_LEAKS\n-  __lsan::InitCommonLsan();\n+  __lsan::InitCommonLsan(false);\n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n     Atexit(__lsan::DoLeakCheck);\n   }"}, {"sha": "fbd636ea5587e1839ebbff3f09ccdd9ed1a542b3", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -13,6 +13,7 @@\n #include \"asan_internal.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n \n@@ -127,8 +128,8 @@ static void PrintAccumulatedStats() {\n   BlockingMutexLock lock(&print_lock);\n   stats.Print();\n   StackDepotStats *stack_depot_stats = StackDepotGetStats();\n-  Printf(\"Stats: StackDepot: %zd ids; %zdM mapped\\n\",\n-         stack_depot_stats->n_uniq_ids, stack_depot_stats->mapped >> 20);\n+  Printf(\"Stats: StackDepot: %zd ids; %zdM allocated\\n\",\n+         stack_depot_stats->n_uniq_ids, stack_depot_stats->allocated >> 20);\n   PrintInternalAllocatorStats();\n }\n \n@@ -137,7 +138,7 @@ static void PrintAccumulatedStats() {\n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n-uptr __asan_get_current_allocated_bytes() {\n+uptr __sanitizer_get_current_allocated_bytes() {\n   AsanStats stats;\n   GetAccumulatedStats(&stats);\n   uptr malloced = stats.malloced;\n@@ -147,13 +148,13 @@ uptr __asan_get_current_allocated_bytes() {\n   return (malloced > freed) ? malloced - freed : 1;\n }\n \n-uptr __asan_get_heap_size() {\n+uptr __sanitizer_get_heap_size() {\n   AsanStats stats;\n   GetAccumulatedStats(&stats);\n   return stats.mmaped - stats.munmaped;\n }\n \n-uptr __asan_get_free_bytes() {\n+uptr __sanitizer_get_free_bytes() {\n   AsanStats stats;\n   GetAccumulatedStats(&stats);\n   uptr total_free = stats.mmaped\n@@ -167,7 +168,7 @@ uptr __asan_get_free_bytes() {\n   return (total_free > total_used) ? total_free - total_used : 1;\n }\n \n-uptr __asan_get_unmapped_bytes() {\n+uptr __sanitizer_get_unmapped_bytes() {\n   return 0;\n }\n "}, {"sha": "8707406563321da7f451891a397cf8803c1292bf", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -139,15 +139,17 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n }\n \n void AsanThread::Init() {\n+  fake_stack_ = 0;  // Will be initialized lazily if needed.\n+  CHECK_EQ(this->stack_size(), 0U);\n   SetThreadStackAndTls();\n+  CHECK_GT(this->stack_size(), 0U);\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n   ClearShadowForThreadStackAndTLS();\n   int local = 0;\n   VReport(1, \"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\", tid(),\n           (void *)stack_bottom_, (void *)stack_top_, stack_top_ - stack_bottom_,\n           &local);\n-  fake_stack_ = 0;  // Will be initialized lazily if needed.\n   AsanPlatformThreadInit();\n }\n "}, {"sha": "b0028763b11f3c11a1e9aee631a037bf611044bf", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -19,6 +19,7 @@\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n+#include \"asan_report.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n@@ -68,7 +69,7 @@ void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n }\n \n-void AsanCheckDynamicRTPrereqs() { UNIMPLEMENTED(); }\n+void AsanCheckDynamicRTPrereqs() {}\n \n void AsanCheckIncompatibleRT() {}\n \n@@ -84,6 +85,67 @@ void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n   UNIMPLEMENTED();\n }\n \n+static LPTOP_LEVEL_EXCEPTION_FILTER default_seh_handler;\n+\n+static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n+  EXCEPTION_RECORD *exception_record = info->ExceptionRecord;\n+  CONTEXT *context = info->ContextRecord;\n+  uptr pc = (uptr)exception_record->ExceptionAddress;\n+#ifdef _WIN64\n+  uptr bp = (uptr)context->Rbp, sp = (uptr)context->Rsp;\n+#else\n+  uptr bp = (uptr)context->Ebp, sp = (uptr)context->Esp;\n+#endif\n+\n+  if (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||\n+      exception_record->ExceptionCode == EXCEPTION_IN_PAGE_ERROR) {\n+    const char *description =\n+        (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)\n+            ? \"access-violation\"\n+            : \"in-page-error\";\n+    uptr access_addr = exception_record->ExceptionInformation[1];\n+    ReportSIGSEGV(description, pc, sp, bp, context, access_addr);\n+  }\n+\n+  // FIXME: Handle EXCEPTION_STACK_OVERFLOW here.\n+\n+  return default_seh_handler(info);\n+}\n+\n+// We want to install our own exception handler (EH) to print helpful reports\n+// on access violations and whatnot.  Unfortunately, the CRT initializers assume\n+// they are run before any user code and drop any previously-installed EHs on\n+// the floor, so we can't install our handler inside __asan_init.\n+// (See crt0dat.c in the CRT sources for the details)\n+//\n+// Things get even more complicated with the dynamic runtime, as it finishes its\n+// initialization before the .exe module CRT begins to initialize.\n+//\n+// For the static runtime (-MT), it's enough to put a callback to\n+// __asan_set_seh_filter in the last section for C initializers.\n+//\n+// For the dynamic runtime (-MD), we want link the same\n+// asan_dynamic_runtime_thunk.lib to all the modules, thus __asan_set_seh_filter\n+// will be called for each instrumented module.  This ensures that at least one\n+// __asan_set_seh_filter call happens after the .exe module CRT is initialized.\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+int __asan_set_seh_filter() {\n+  // We should only store the previous handler if it's not our own handler in\n+  // order to avoid loops in the EH chain.\n+  auto prev_seh_handler = SetUnhandledExceptionFilter(SEHHandler);\n+  if (prev_seh_handler != &SEHHandler)\n+    default_seh_handler = prev_seh_handler;\n+  return 0;\n+}\n+\n+#if !ASAN_DYNAMIC\n+// Put a pointer to __asan_set_seh_filter at the end of the global list\n+// of C initializers, after the default EH is set by the CRT.\n+#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n+static __declspec(allocate(\".CRT$XIZ\"))\n+    int (*__intercept_seh)() = __asan_set_seh_filter;\n+#endif\n+\n }  // namespace __asan\n \n #endif  // _WIN32"}, {"sha": "6adb7d2e942c131eb39cb54f82a15a8671329f58", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "renamed", "additions": 163, "deletions": 59, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -1,4 +1,4 @@\n-//===-- asan_dll_thunk.cc -------------------------------------------------===//\n+//===-- asan_win_dll_thunk.cc ---------------------------------------------===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n@@ -18,9 +18,10 @@\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DLL_THUNK\n+#include \"asan_init_version.h\"\n #include \"sanitizer_common/sanitizer_interception.h\"\n \n-// ----------------- Helper functions and macros --------------------- {{{1\n+// ---------- Function interception helper functions and macros ----------- {{{1\n extern \"C\" {\n void *__stdcall GetModuleHandleA(const char *module_name);\n void *__stdcall GetProcAddress(void *module, const char *proc_name);\n@@ -34,125 +35,161 @@ static void *getRealProcAddressOrDie(const char *name) {\n   return ret;\n }\n \n+// We need to intercept some functions (e.g. ASan interface, memory allocator --\n+// let's call them \"hooks\") exported by the DLL thunk and forward the hooks to\n+// the runtime in the main module.\n+// However, we don't want to keep two lists of these hooks.\n+// To avoid that, the list of hooks should be defined using the\n+// INTERCEPT_WHEN_POSSIBLE macro. Then, all these hooks can be intercepted\n+// at once by calling INTERCEPT_HOOKS().\n+\n+// Use macro+template magic to automatically generate the list of hooks.\n+// Each hook at line LINE defines a template class with a static\n+// FunctionInterceptor<LINE>::Execute() method intercepting the hook.\n+// The default implementation of FunctionInterceptor<LINE> is to call\n+// the Execute() method corresponding to the previous line.\n+template<int LINE>\n+struct FunctionInterceptor {\n+  static void Execute() { FunctionInterceptor<LINE-1>::Execute(); }\n+};\n+\n+// There shouldn't be any hooks with negative definition line number.\n+template<>\n+struct FunctionInterceptor<0> {\n+  static void Execute() {}\n+};\n+\n+#define INTERCEPT_WHEN_POSSIBLE(main_function, dll_function)                   \\\n+  template<> struct FunctionInterceptor<__LINE__> {                            \\\n+    static void Execute() {                                                    \\\n+      void *wrapper = getRealProcAddressOrDie(main_function);                  \\\n+      if (!__interception::OverrideFunction((uptr)dll_function,                \\\n+                                            (uptr)wrapper, 0))                 \\\n+        abort();                                                               \\\n+      FunctionInterceptor<__LINE__-1>::Execute();                              \\\n+    }                                                                          \\\n+  };\n+\n+// Special case of hooks -- ASan own interface functions.  Those are only called\n+// after __asan_init, thus an empty implementation is sufficient.\n+#define INTERFACE_FUNCTION(name)                                               \\\n+  extern \"C\" __declspec(noinline) void name() {                                \\\n+    volatile int prevent_icf = (__LINE__ << 8); (void)prevent_icf;             \\\n+    __debugbreak();                                                            \\\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name)\n+\n+// INTERCEPT_HOOKS must be used after the last INTERCEPT_WHEN_POSSIBLE.\n+#define INTERCEPT_HOOKS FunctionInterceptor<__LINE__>::Execute\n+\n+// We can't define our own version of strlen etc. because that would lead to\n+// link-time or even type mismatch errors.  Instead, we can declare a function\n+// just to be able to get its address.  Me may miss the first few calls to the\n+// functions since it can be called before __asan_init, but that would lead to\n+// false negatives in the startup code before user's global initializers, which\n+// isn't a big deal.\n+#define INTERCEPT_LIBRARY_FUNCTION(name)                                       \\\n+  extern \"C\" void name();                                                      \\\n+  INTERCEPT_WHEN_POSSIBLE(WRAPPER_NAME(name), name)\n+\n+// Disable compiler warnings that show up if we declare our own version\n+// of a compiler intrinsic (e.g. strlen).\n+#pragma warning(disable: 4391)\n+#pragma warning(disable: 4392)\n+\n+static void InterceptHooks();\n+// }}}\n+\n+// ---------- Function wrapping helpers ----------------------------------- {{{1\n #define WRAP_V_V(name)                                                         \\\n   extern \"C\" void name() {                                                     \\\n     typedef void (*fntype)();                                                  \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     fn();                                                                      \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_V_W(name)                                                         \\\n   extern \"C\" void name(void *arg) {                                            \\\n     typedef void (*fntype)(void *arg);                                         \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     fn(arg);                                                                   \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_V_WW(name)                                                        \\\n   extern \"C\" void name(void *arg1, void *arg2) {                               \\\n     typedef void (*fntype)(void *, void *);                                    \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     fn(arg1, arg2);                                                            \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_V_WWW(name)                                                       \\\n   extern \"C\" void name(void *arg1, void *arg2, void *arg3) {                   \\\n     typedef void *(*fntype)(void *, void *, void *);                           \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     fn(arg1, arg2, arg3);                                                      \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_V(name)                                                         \\\n   extern \"C\" void *name() {                                                    \\\n     typedef void *(*fntype)();                                                 \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn();                                                               \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_W(name)                                                         \\\n   extern \"C\" void *name(void *arg) {                                           \\\n     typedef void *(*fntype)(void *arg);                                        \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg);                                                            \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_WW(name)                                                        \\\n   extern \"C\" void *name(void *arg1, void *arg2) {                              \\\n     typedef void *(*fntype)(void *, void *);                                   \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg1, arg2);                                                     \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_WWW(name)                                                       \\\n   extern \"C\" void *name(void *arg1, void *arg2, void *arg3) {                  \\\n     typedef void *(*fntype)(void *, void *, void *);                           \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg1, arg2, arg3);                                               \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_WWWW(name)                                                      \\\n   extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4) {      \\\n     typedef void *(*fntype)(void *, void *, void *, void *);                   \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg1, arg2, arg3, arg4);                                         \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_WWWWW(name)                                                     \\\n   extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n                         void *arg5) {                                          \\\n     typedef void *(*fntype)(void *, void *, void *, void *, void *);           \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg1, arg2, arg3, arg4, arg5);                                   \\\n-  }\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n \n #define WRAP_W_WWWWWW(name)                                                    \\\n   extern \"C\" void *name(void *arg1, void *arg2, void *arg3, void *arg4,        \\\n                         void *arg5, void *arg6) {                              \\\n     typedef void *(*fntype)(void *, void *, void *, void *, void *, void *);   \\\n     static fntype fn = (fntype)getRealProcAddressOrDie(#name);                 \\\n     return fn(arg1, arg2, arg3, arg4, arg5, arg6);                             \\\n-  }\n-// }}}\n-\n-// --------- Interface interception helper functions and macros ----------- {{{1\n-// We need to intercept the ASan interface exported by the DLL thunk and forward\n-// all the functions to the runtime in the main module.\n-// However, we don't want to keep two lists of interface functions.\n-// To avoid that, the list of interface functions should be defined using the\n-// INTERFACE_FUNCTION macro. Then, all the interface can be intercepted at once\n-// by calling INTERCEPT_ASAN_INTERFACE().\n-\n-// Use macro+template magic to automatically generate the list of interface\n-// functions.  Each interface function at line LINE defines a template class\n-// with a static InterfaceInteceptor<LINE>::Execute() method intercepting the\n-// function.  The default implementation of InterfaceInteceptor<LINE> is to call\n-// the Execute() method corresponding to the previous line.\n-template<int LINE>\n-struct InterfaceInteceptor {\n-  static void Execute() { InterfaceInteceptor<LINE-1>::Execute(); }\n-};\n-\n-// There shouldn't be any interface function with negative line number.\n-template<>\n-struct InterfaceInteceptor<0> {\n-  static void Execute() {}\n-};\n-\n-#define INTERFACE_FUNCTION(name)                                               \\\n-  extern \"C\" void name() { __debugbreak(); }                                   \\\n-  template<> struct InterfaceInteceptor<__LINE__> {                            \\\n-    static void Execute() {                                                    \\\n-      void *wrapper = getRealProcAddressOrDie(#name);                          \\\n-      if (!__interception::OverrideFunction((uptr)name, (uptr)wrapper, 0))     \\\n-        abort();                                                               \\\n-      InterfaceInteceptor<__LINE__-1>::Execute();                              \\\n-    }                                                                          \\\n-  };\n-\n-// INTERCEPT_ASAN_INTERFACE must be used after the last INTERFACE_FUNCTION.\n-#define INTERCEPT_ASAN_INTERFACE InterfaceInteceptor<__LINE__>::Execute\n-\n-static void InterceptASanInterface();\n+  }                                                                            \\\n+  INTERCEPT_WHEN_POSSIBLE(#name, name);\n // }}}\n \n // ----------------- ASan own interface functions --------------------\n@@ -165,17 +202,18 @@ extern \"C\" {\n \n   // Manually wrap __asan_init as we need to initialize\n   // __asan_option_detect_stack_use_after_return afterwards.\n-  void __asan_init_v3() {\n+  void __asan_init() {\n     typedef void (*fntype)();\n     static fntype fn = 0;\n+    // __asan_init is expected to be called by only one thread.\n     if (fn) return;\n \n-    fn = (fntype)getRealProcAddressOrDie(\"__asan_init_v3\");\n+    fn = (fntype)getRealProcAddressOrDie(__asan_init_name);\n     fn();\n     __asan_option_detect_stack_use_after_return =\n         (__asan_should_detect_stack_use_after_return() != 0);\n \n-    InterceptASanInterface();\n+    InterceptHooks();\n   }\n }\n \n@@ -195,6 +233,20 @@ INTERFACE_FUNCTION(__asan_report_load8)\n INTERFACE_FUNCTION(__asan_report_load16)\n INTERFACE_FUNCTION(__asan_report_load_n)\n \n+INTERFACE_FUNCTION(__asan_store1)\n+INTERFACE_FUNCTION(__asan_store2)\n+INTERFACE_FUNCTION(__asan_store4)\n+INTERFACE_FUNCTION(__asan_store8)\n+INTERFACE_FUNCTION(__asan_store16)\n+INTERFACE_FUNCTION(__asan_storeN)\n+\n+INTERFACE_FUNCTION(__asan_load1)\n+INTERFACE_FUNCTION(__asan_load2)\n+INTERFACE_FUNCTION(__asan_load4)\n+INTERFACE_FUNCTION(__asan_load8)\n+INTERFACE_FUNCTION(__asan_load16)\n+INTERFACE_FUNCTION(__asan_loadN)\n+\n INTERFACE_FUNCTION(__asan_memcpy);\n INTERFACE_FUNCTION(__asan_memset);\n INTERFACE_FUNCTION(__asan_memmove);\n@@ -211,6 +263,9 @@ INTERFACE_FUNCTION(__asan_unpoison_stack_memory)\n INTERFACE_FUNCTION(__asan_poison_memory_region)\n INTERFACE_FUNCTION(__asan_unpoison_memory_region)\n \n+INTERFACE_FUNCTION(__asan_address_is_poisoned)\n+INTERFACE_FUNCTION(__asan_region_is_poisoned)\n+\n INTERFACE_FUNCTION(__asan_get_current_fake_stack)\n INTERFACE_FUNCTION(__asan_addr_is_in_fake_stack)\n \n@@ -237,6 +292,8 @@ INTERFACE_FUNCTION(__asan_stack_free_8)\n INTERFACE_FUNCTION(__asan_stack_free_9)\n INTERFACE_FUNCTION(__asan_stack_free_10)\n \n+INTERFACE_FUNCTION(__sanitizer_cov_module_init)\n+\n // TODO(timurrrr): Add more interface functions on the as-needed basis.\n \n // ----------------- Memory allocation functions ---------------------\n@@ -263,8 +320,55 @@ WRAP_W_W(_expand_dbg)\n \n // TODO(timurrrr): Do we need to add _Crt* stuff here? (see asan_malloc_win.cc).\n \n-void InterceptASanInterface() {\n-  INTERCEPT_ASAN_INTERFACE();\n+INTERCEPT_LIBRARY_FUNCTION(atoi);\n+INTERCEPT_LIBRARY_FUNCTION(atol);\n+INTERCEPT_LIBRARY_FUNCTION(_except_handler3);\n+\n+// _except_handler4 checks -GS cookie which is different for each module, so we\n+// can't use INTERCEPT_LIBRARY_FUNCTION(_except_handler4).\n+INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n+  __asan_handle_no_return();\n+  return REAL(_except_handler4)(a, b, c, d);\n+}\n+\n+INTERCEPT_LIBRARY_FUNCTION(frexp);\n+INTERCEPT_LIBRARY_FUNCTION(longjmp);\n+INTERCEPT_LIBRARY_FUNCTION(memchr);\n+INTERCEPT_LIBRARY_FUNCTION(memcmp);\n+INTERCEPT_LIBRARY_FUNCTION(memcpy);\n+INTERCEPT_LIBRARY_FUNCTION(memmove);\n+INTERCEPT_LIBRARY_FUNCTION(memset);\n+INTERCEPT_LIBRARY_FUNCTION(strcat);  // NOLINT\n+INTERCEPT_LIBRARY_FUNCTION(strchr);\n+INTERCEPT_LIBRARY_FUNCTION(strcmp);\n+INTERCEPT_LIBRARY_FUNCTION(strcpy);  // NOLINT\n+INTERCEPT_LIBRARY_FUNCTION(strlen);\n+INTERCEPT_LIBRARY_FUNCTION(strncat);\n+INTERCEPT_LIBRARY_FUNCTION(strncmp);\n+INTERCEPT_LIBRARY_FUNCTION(strncpy);\n+INTERCEPT_LIBRARY_FUNCTION(strnlen);\n+INTERCEPT_LIBRARY_FUNCTION(strtol);\n+INTERCEPT_LIBRARY_FUNCTION(wcslen);\n+\n+// Must be after all the interceptor declarations due to the way INTERCEPT_HOOKS\n+// is defined.\n+void InterceptHooks() {\n+  INTERCEPT_HOOKS();\n+  INTERCEPT_FUNCTION(_except_handler4);\n+}\n+\n+// We want to call __asan_init before C/C++ initializers/constructors are\n+// executed, otherwise functions like memset might be invoked.\n+// For some strange reason, merely linking in asan_preinit.cc doesn't work\n+// as the callback is never called...  Is link.exe doing something too smart?\n+\n+// In DLLs, the callbacks are expected to return 0,\n+// otherwise CRT initialization fails.\n+static int call_asan_init() {\n+  __asan_init();\n+  return 0;\n }\n+#pragma section(\".CRT$XIB\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XIB\")) int (*__asan_preinit)() = call_asan_init;\n \n #endif // ASAN_DLL_THUNK", "previous_filename": "libsanitizer/asan/asan_dll_thunk.cc"}, {"sha": "1b59677eeffcd1fcff6c5db9ca18b1c31e2348de", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,50 @@\n+//===-- asan_win_uar_thunk.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This file defines things that need to be present in the application modules\n+// to interact with the ASan DLL runtime correctly and can't be implemented\n+// using the default \"import library\" generated when linking the DLL RTL.\n+//\n+// This includes:\n+//  - forwarding the detect_stack_use_after_return runtime option\n+//  - installing a custom SEH handler\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Only compile this code when buidling asan_dynamic_runtime_thunk.lib\n+// Using #ifdef rather than relying on Makefiles etc.\n+// simplifies the build procedure.\n+#ifdef ASAN_DYNAMIC_RUNTIME_THUNK\n+extern \"C\" {\n+__declspec(dllimport) int __asan_set_seh_filter();\n+__declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n+\n+// Define a copy of __asan_option_detect_stack_use_after_return that should be\n+// used when linking an MD runtime with a set of object files on Windows.\n+//\n+// The ASan MD runtime dllexports '__asan_option_detect_stack_use_after_return',\n+// so normally we would just dllimport it.  Unfortunately, the dllimport\n+// attribute adds __imp_ prefix to the symbol name of a variable.\n+// Since in general we don't know if a given TU is going to be used\n+// with a MT or MD runtime and we don't want to use ugly __imp_ names on Windows\n+// just to work around this issue, let's clone the a variable that is\n+// constant after initialization anyways.\n+int __asan_option_detect_stack_use_after_return =\n+    __asan_should_detect_stack_use_after_return();\n+\n+// Set the ASan-specific SEH handler at the end of CRT initialization of each\n+// module (see asan_win.cc for the details).\n+//\n+// Unfortunately, putting a pointer to __asan_set_seh_filter into\n+// __asan_intercept_seh gets optimized out, so we have to use an extra function.\n+static int SetSEHFilter() { return __asan_set_seh_filter(); }\n+#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XIZ\")) int (*__asan_seh_interceptor)() = SetSEHFilter;\n+}\n+#endif // ASAN_DYNAMIC_RUNTIME_THUNK"}, {"sha": "f18f40737c75659e814c4ab64a7de7420a193eca", "filename": "libsanitizer/asan/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-1:0:0\n+2:0:0"}, {"sha": "97a72a258eb597254f6d47cfdc6cb986003df2cf", "filename": "libsanitizer/include/sanitizer/allocator_interface.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,64 @@\n+//===-- allocator_interface.h ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Public interface header for allocator used in sanitizers (ASan/TSan/MSan).\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_INTERFACE_H\n+#define SANITIZER_ALLOCATOR_INTERFACE_H\n+\n+#include <stddef.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+  /* Returns the estimated number of bytes that will be reserved by allocator\n+     for request of \"size\" bytes. If allocator can't allocate that much\n+     memory, returns the maximal possible allocation size, otherwise returns\n+     \"size\". */\n+  size_t __sanitizer_get_estimated_allocated_size(size_t size);\n+\n+  /* Returns true if p was returned by the allocator and\n+     is not yet freed. */\n+  int __sanitizer_get_ownership(const volatile void *p);\n+\n+  /* Returns the number of bytes reserved for the pointer p.\n+     Requires (get_ownership(p) == true) or (p == 0). */\n+  size_t __sanitizer_get_allocated_size(const volatile void *p);\n+\n+  /* Number of bytes, allocated and not yet freed by the application. */\n+  size_t __sanitizer_get_current_allocated_bytes();\n+\n+  /* Number of bytes, mmaped by the allocator to fulfill allocation requests.\n+     Generally, for request of X bytes, allocator can reserve and add to free\n+     lists a large number of chunks of size X to use them for future requests.\n+     All these chunks count toward the heap size. Currently, allocator never\n+     releases memory to OS (instead, it just puts freed chunks to free\n+     lists). */\n+  size_t __sanitizer_get_heap_size();\n+\n+  /* Number of bytes, mmaped by the allocator, which can be used to fulfill\n+     allocation requests. When a user program frees memory chunk, it can first\n+     fall into quarantine and will count toward __sanitizer_get_free_bytes()\n+     later. */\n+  size_t __sanitizer_get_free_bytes();\n+\n+  /* Number of bytes in unmapped pages, that are released to OS. Currently,\n+     always returns 0. */\n+  size_t __sanitizer_get_unmapped_bytes();\n+\n+  /* Malloc hooks that may be optionally provided by user.\n+     __sanitizer_malloc_hook(ptr, size) is called immediately after\n+       allocation of \"size\" bytes, which returned \"ptr\".\n+     __sanitizer_free_hook(ptr) is called immediately before\n+       deallocation of \"ptr\". */\n+  void __sanitizer_malloc_hook(const volatile void *ptr, size_t size);\n+  void __sanitizer_free_hook(const volatile void *ptr);\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif"}, {"sha": "d1d452991b0f4a11df84d97b080ff58840979ea7", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -60,6 +60,22 @@ extern \"C\" {\n   // Print the description of addr (useful when debugging in gdb).\n   void __asan_describe_address(void *addr);\n \n+  // Useful for calling from the debugger to get the allocation stack trace\n+  // and thread ID for a heap address. Stores up to 'size' frames into 'trace',\n+  // returns the number of stored frames or 0 on error.\n+  size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,\n+                                int *thread_id);\n+\n+  // Useful for calling from the debugger to get the free stack trace\n+  // and thread ID for a heap address. Stores up to 'size' frames into 'trace',\n+  // returns the number of stored frames or 0 on error.\n+  size_t __asan_get_free_stack(void *addr, void **trace, size_t size,\n+                               int *thread_id);\n+\n+  // Useful for calling from the debugger to get the current shadow memory\n+  // mapping.\n+  void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);\n+\n   // This is an internal function that is called to report an error.\n   // However it is still a part of the interface because users may want to\n   // set a breakpoint on this function in a debugger.\n@@ -81,47 +97,13 @@ extern \"C\" {\n   // the program crashes before ASan report is printed.\n   void __asan_on_error();\n \n-  // Returns the estimated number of bytes that will be reserved by allocator\n-  // for request of \"size\" bytes. If ASan allocator can't allocate that much\n-  // memory, returns the maximal possible allocation size, otherwise returns\n-  // \"size\".\n-  size_t __asan_get_estimated_allocated_size(size_t size);\n-  // Returns 1 if p was returned by the ASan allocator and is not yet freed.\n-  // Otherwise returns 0.\n-  int __asan_get_ownership(const void *p);\n-  // Returns the number of bytes reserved for the pointer p.\n-  // Requires (get_ownership(p) == true) or (p == 0).\n-  size_t __asan_get_allocated_size(const void *p);\n-  // Number of bytes, allocated and not yet freed by the application.\n-  size_t __asan_get_current_allocated_bytes();\n-  // Number of bytes, mmaped by asan allocator to fulfill allocation requests.\n-  // Generally, for request of X bytes, allocator can reserve and add to free\n-  // lists a large number of chunks of size X to use them for future requests.\n-  // All these chunks count toward the heap size. Currently, allocator never\n-  // releases memory to OS (instead, it just puts freed chunks to free lists).\n-  size_t __asan_get_heap_size();\n-  // Number of bytes, mmaped by asan allocator, which can be used to fulfill\n-  // allocation requests. When a user program frees memory chunk, it can first\n-  // fall into quarantine and will count toward __asan_get_free_bytes() later.\n-  size_t __asan_get_free_bytes();\n-  // Number of bytes in unmapped pages, that are released to OS. Currently,\n-  // always returns 0.\n-  size_t __asan_get_unmapped_bytes();\n   // Prints accumulated stats to stderr. Used for debugging.\n   void __asan_print_accumulated_stats();\n \n   // This function may be optionally provided by user and should return\n   // a string containing ASan runtime options. See asan_flags.h for details.\n   const char* __asan_default_options();\n \n-  // Malloc hooks that may be optionally provided by user.\n-  // __asan_malloc_hook(ptr, size) is called immediately after\n-  //   allocation of \"size\" bytes, which returned \"ptr\".\n-  // __asan_free_hook(ptr) is called immediately before\n-  //   deallocation of \"ptr\".\n-  void __asan_malloc_hook(void *ptr, size_t size);\n-  void __asan_free_hook(void *ptr);\n-\n   // The following 2 functions facilitate garbage collection in presence of\n   // asan's fake stack.\n "}, {"sha": "43e0c30ee8a98ca918e573c16bd8731079007766", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -64,6 +64,10 @@ extern \"C\" {\n   void __sanitizer_cov_init();\n   // Record and dump coverage info.\n   void __sanitizer_cov_dump();\n+  // Open <name>.sancov.packed in the coverage directory and return the file\n+  // descriptor. Returns -1 on failure, or if coverage dumping is disabled.\n+  // This is intended for use by sandboxing code.\n+  intptr_t __sanitizer_maybe_open_cov_file(const char *name);\n \n   // Annotate the current state of a contiguous container, such as\n   // std::vector, std::string or similar."}, {"sha": "ea7ad1d7c9b908a571d1573a4b6f1fa93d581d5c", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,10 +17,6 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-  /* Returns a string describing a stack origin.\n-     Return NULL if the origin is invalid, or is not a stack origin. */\n-  const char *__msan_get_origin_descr_if_stack(uint32_t id);\n-\n   /* Set raw origin for the memory range. */\n   void __msan_set_origin(const volatile void *a, size_t size, uint32_t origin);\n \n@@ -91,55 +87,10 @@ extern \"C\" {\n      a string containing Msan runtime options. See msan_flags.h for details. */\n   const char* __msan_default_options();\n \n-  // Sets the callback to be called right before death on error.\n-  // Passing 0 will unset the callback.\n+  /* Sets the callback to be called right before death on error.\n+     Passing 0 will unset the callback. */\n   void __msan_set_death_callback(void (*callback)(void));\n \n-  /***********************************/\n-  /* Allocator statistics interface. */\n-\n-  /* Returns the estimated number of bytes that will be reserved by allocator\n-     for request of \"size\" bytes. If Msan allocator can't allocate that much\n-     memory, returns the maximal possible allocation size, otherwise returns\n-     \"size\". */\n-  size_t __msan_get_estimated_allocated_size(size_t size);\n-\n-  /* Returns true if p was returned by the Msan allocator and\n-     is not yet freed. */\n-  int __msan_get_ownership(const volatile void *p);\n-\n-  /* Returns the number of bytes reserved for the pointer p.\n-     Requires (get_ownership(p) == true) or (p == 0). */\n-  size_t __msan_get_allocated_size(const volatile void *p);\n-\n-  /* Number of bytes, allocated and not yet freed by the application. */\n-  size_t __msan_get_current_allocated_bytes();\n-\n-  /* Number of bytes, mmaped by msan allocator to fulfill allocation requests.\n-     Generally, for request of X bytes, allocator can reserve and add to free\n-     lists a large number of chunks of size X to use them for future requests.\n-     All these chunks count toward the heap size. Currently, allocator never\n-     releases memory to OS (instead, it just puts freed chunks to free\n-     lists). */\n-  size_t __msan_get_heap_size();\n-\n-  /* Number of bytes, mmaped by msan allocator, which can be used to fulfill\n-     allocation requests. When a user program frees memory chunk, it can first\n-     fall into quarantine and will count toward __msan_get_free_bytes()\n-     later. */\n-  size_t __msan_get_free_bytes();\n-\n-  /* Number of bytes in unmapped pages, that are released to OS. Currently,\n-     always returns 0. */\n-  size_t __msan_get_unmapped_bytes();\n-\n-  /* Malloc hooks that may be optionally provided by user.\n-     __msan_malloc_hook(ptr, size) is called immediately after\n-       allocation of \"size\" bytes, which returned \"ptr\".\n-     __msan_free_hook(ptr) is called immediately before\n-       deallocation of \"ptr\". */\n-  void __msan_malloc_hook(const volatile void *ptr, size_t size);\n-  void __msan_free_hook(const volatile void *ptr);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "458928f14b177576490d7bc959b8681dcfb953c0", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -120,19 +120,23 @@ const interpose_substitution substitution_##func_name[] \\\n # define DECLARE_WRAPPER(ret_type, func, ...)\n \n #elif defined(_WIN32)\n-# if defined(_DLL)  // DLL CRT\n-#  define WRAP(x) x\n-#  define WRAPPER_NAME(x) #x\n-#  define INTERCEPTOR_ATTRIBUTE\n-# else  // Static CRT\n-#  define WRAP(x) wrap_##x\n-#  define WRAPPER_NAME(x) \"wrap_\"#x\n-#  define INTERCEPTOR_ATTRIBUTE\n-# endif\n+# define WRAP(x) __asan_wrap_##x\n+# define WRAPPER_NAME(x) \"__asan_wrap_\"#x\n+# define INTERCEPTOR_ATTRIBUTE __declspec(dllexport)\n # define DECLARE_WRAPPER(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n # define DECLARE_WRAPPER_WINAPI(ret_type, func, ...) \\\n     extern \"C\" __declspec(dllimport) ret_type __stdcall func(__VA_ARGS__);\n+#elif defined(__FreeBSD__)\n+# define WRAP(x) __interceptor_ ## x\n+# define WRAPPER_NAME(x) \"__interceptor_\" #x\n+# define INTERCEPTOR_ATTRIBUTE __attribute__((visibility(\"default\")))\n+// FreeBSD's dynamic linker (incompliantly) gives non-weak symbols higher\n+// priority than weak ones so weak aliases won't work for indirect calls\n+// in position-independent (-fPIC / -fPIE) mode.\n+# define DECLARE_WRAPPER(ret_type, func, ...) \\\n+     extern \"C\" ret_type func(__VA_ARGS__) \\\n+     __attribute__((alias(\"__interceptor_\" #func), visibility(\"default\")));\n #else\n # define WRAP(x) __interceptor_ ## x\n # define WRAPPER_NAME(x) \"__interceptor_\" #x"}, {"sha": "1642bd116cfafdd9e2d1f15eb999163c35b512e8", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,20 +17,6 @@\n \n namespace __interception {\n \n-bool GetRealFunctionAddress(const char *func_name, uptr *func_addr) {\n-  const char *DLLS[] = {\n-    \"msvcr80.dll\",\n-    \"msvcr90.dll\",\n-    \"kernel32.dll\",\n-    NULL\n-  };\n-  *func_addr = 0;\n-  for (size_t i = 0; *func_addr == 0 && DLLS[i]; ++i) {\n-    *func_addr = (uptr)GetProcAddress(GetModuleHandleA(DLLS[i]), func_name);\n-  }\n-  return (*func_addr != 0);\n-}\n-\n // FIXME: internal_str* and internal_mem* functions should be moved from the\n // ASan sources into interception/.\n \n@@ -108,9 +94,11 @@ static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n       case 0x458B:  // 8B 45 XX = mov eax, dword ptr [ebp+XXh]\n       case 0x5D8B:  // 8B 5D XX = mov ebx, dword ptr [ebp+XXh]\n       case 0xEC83:  // 83 EC XX = sub esp, XX\n+      case 0x75FF:  // FF 75 XX = push dword ptr [ebp+XXh]\n         cursor += 3;\n         continue;\n       case 0xC1F7:  // F7 C1 XX YY ZZ WW = test ecx, WWZZYYXX\n+      case 0x25FF:  // FF 25 XX YY ZZ WW = jmp dword ptr ds:[WWZZYYXX]\n         cursor += 6;\n         continue;\n       case 0x3D83:  // 83 3D XX YY ZZ WW TT = cmp TT, WWZZYYXX\n@@ -119,6 +107,7 @@ static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n     }\n     switch (0x00FFFFFF & *(unsigned int*)(code + cursor)) {\n       case 0x24448A:  // 8A 44 24 XX = mov eal, dword ptr [esp+XXh]\n+      case 0x24448B:  // 8B 44 24 XX = mov eax, dword ptr [esp+XXh]\n       case 0x244C8B:  // 8B 4C 24 XX = mov ecx, dword ptr [esp+XXh]\n       case 0x24548B:  // 8B 54 24 XX = mov edx, dword ptr [esp+XXh]\n       case 0x24748B:  // 8B 74 24 XX = mov esi, dword ptr [esp+XXh]\n@@ -131,8 +120,9 @@ static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n     // FIXME: Unknown instruction failures might happen when we add a new\n     // interceptor or a new compiler version. In either case, they should result\n     // in visible and readable error messages. However, merely calling abort()\n-    // or __debugbreak() leads to an infinite recursion in CheckFailed.\n+    // leads to an infinite recursion in CheckFailed.\n     // Do we have a good way to abort with an error message here?\n+    __debugbreak();\n     return 0;\n   }\n \n@@ -189,6 +179,33 @@ bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n   return true;\n }\n \n+static const void **InterestingDLLsAvailable() {\n+  const char *InterestingDLLs[] = { \"kernel32.dll\", \"msvcr120.dll\", NULL };\n+  static void *result[ARRAY_SIZE(InterestingDLLs)] = { 0 };\n+  if (!result[0]) {\n+    for (size_t i = 0, j = 0; InterestingDLLs[i]; ++i) {\n+      if (HMODULE h = GetModuleHandleA(InterestingDLLs[i]))\n+        result[j++] = (void *)h;\n+    }\n+  }\n+  return (const void **)&result[0];\n+}\n+\n+static bool GetFunctionAddressInDLLs(const char *func_name, uptr *func_addr) {\n+  *func_addr = 0;\n+  const void **DLLs = InterestingDLLsAvailable();\n+  for (size_t i = 0; *func_addr == 0 && DLLs[i]; ++i)\n+    *func_addr = (uptr)GetProcAddress((HMODULE)DLLs[i], func_name);\n+  return (*func_addr != 0);\n+}\n+\n+bool OverrideFunction(const char *name, uptr new_func, uptr *orig_old_func) {\n+  uptr orig_func;\n+  if (!GetFunctionAddressInDLLs(name, &orig_func))\n+    return false;\n+  return OverrideFunction(orig_func, new_func, orig_old_func);\n+}\n+\n }  // namespace __interception\n \n #endif  // _WIN32"}, {"sha": "e9c6200d1b2c2931ded459704a64e4a6558c00da", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,27 +20,29 @@\n #define INTERCEPTION_WIN_H\n \n namespace __interception {\n-// returns true if a function with the given name was found.\n-bool GetRealFunctionAddress(const char *func_name, uptr *func_addr);\n+// All the functions in the OverrideFunction() family return true on success,\n+// false on failure (including \"couldn't find the function\").\n \n-// returns true if the old function existed, false on failure.\n-bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func);\n+// Overrides a function by its address.\n+bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func = 0);\n+\n+// Overrides a function in a system DLL or DLL CRT by its exported name.\n+bool OverrideFunction(const char *name, uptr new_func, uptr *orig_old_func = 0);\n }  // namespace __interception\n \n-#if defined(_DLL)\n-# define INTERCEPT_FUNCTION_WIN(func) \\\n-    ::__interception::GetRealFunctionAddress( \\\n-        #func, (::__interception::uptr*)&REAL(func))\n+#if defined(INTERCEPTION_DYNAMIC_CRT)\n+#define INTERCEPT_FUNCTION_WIN(func)                                           \\\n+  ::__interception::OverrideFunction(#func,                                    \\\n+                                     (::__interception::uptr)WRAP(func),       \\\n+                                     (::__interception::uptr *)&REAL(func))\n #else\n-# define INTERCEPT_FUNCTION_WIN(func) \\\n-    ::__interception::OverrideFunction( \\\n-        (::__interception::uptr)func, \\\n-        (::__interception::uptr)WRAP(func), \\\n-        (::__interception::uptr*)&REAL(func))\n+#define INTERCEPT_FUNCTION_WIN(func)                                           \\\n+  ::__interception::OverrideFunction((::__interception::uptr)func,             \\\n+                                     (::__interception::uptr)WRAP(func),       \\\n+                                     (::__interception::uptr *)&REAL(func))\n #endif\n \n-#define INTERCEPT_FUNCTION_VER_WIN(func, symver) \\\n-    INTERCEPT_FUNCTION_WIN(func)\n+#define INTERCEPT_FUNCTION_VER_WIN(func, symver) INTERCEPT_FUNCTION_WIN(func)\n \n #endif  // INTERCEPTION_WIN_H\n #endif  // _WIN32"}, {"sha": "61792d9c9ea08c0b678bb39631442fa78b8961f1", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -23,16 +23,6 @@ bool lsan_init_is_running;\n \n namespace __lsan {\n \n-static void InitializeCommonFlags() {\n-  CommonFlags *cf = common_flags();\n-  SetCommonFlagsDefaults(cf);\n-  cf->external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n-  cf->malloc_context_size = 30;\n-  cf->detect_leaks = true;\n-\n-  ParseCommonFlagsFromString(cf, GetEnv(\"LSAN_OPTIONS\"));\n-}\n-\n ///// Interface to the common LSan module. /////\n bool WordIsPoisoned(uptr addr) {\n   return false;\n@@ -48,7 +38,7 @@ extern \"C\" void __lsan_init() {\n     return;\n   lsan_init_is_running = true;\n   SanitizerToolName = \"LeakSanitizer\";\n-  InitializeCommonFlags();\n+  InitCommonLsan(true);\n   InitializeAllocator();\n   InitTlsSize();\n   InitializeInterceptors();\n@@ -58,11 +48,14 @@ extern \"C\" void __lsan_init() {\n   ThreadStart(tid, GetTid());\n   SetCurrentThread(tid);\n \n-  Symbolizer::Init(common_flags()->external_symbolizer_path);\n-\n-  InitCommonLsan();\n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)\n     Atexit(DoLeakCheck);\n   lsan_inited = true;\n   lsan_init_is_running = false;\n }\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_print_stack_trace() {\n+  GET_STACK_TRACE_FATAL;\n+  stack.Print();\n+}"}, {"sha": "57888e3421d471983b0ed64c45d88aa5a3079b42", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -13,6 +13,26 @@\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n \n+#define GET_STACK_TRACE(max_size, fast)                                     \\\n+  StackTrace stack;                                                         \\\n+  {                                                                         \\\n+    uptr stack_top = 0, stack_bottom = 0;                                   \\\n+    ThreadContext *t;                                                       \\\n+    if (fast && (t = CurrentThreadContext())) {                             \\\n+      stack_top = t->stack_end();                                           \\\n+      stack_bottom = t->stack_begin();                                      \\\n+    }                                                                       \\\n+    stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(), \\\n+                 /* context */ 0, stack_top, stack_bottom, fast);           \\\n+  }\n+\n+#define GET_STACK_TRACE_FATAL \\\n+  GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n+\n+#define GET_STACK_TRACE_MALLOC                                      \\\n+  GET_STACK_TRACE(__sanitizer::common_flags()->malloc_context_size, \\\n+                  common_flags()->fast_unwind_on_malloc)\n+\n namespace __lsan {\n \n void InitializeInterceptors();"}, {"sha": "cda2b86ef67e908c5b695c5731312a100f1fc435", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -13,6 +13,7 @@\n #include \"lsan_allocator.h\"\n \n #include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n@@ -51,7 +52,7 @@ void AllocatorThreadFinish() {\n   allocator.SwallowCache(&cache);\n }\n \n-static ChunkMetadata *Metadata(void *p) {\n+static ChunkMetadata *Metadata(const void *p) {\n   return reinterpret_cast<ChunkMetadata *>(allocator.GetMetaData(p));\n }\n \n@@ -85,10 +86,12 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n   if (cleared && allocator.FromPrimary(p))\n     memset(p, 0, size);\n   RegisterAllocation(stack, p, size);\n+  if (&__sanitizer_malloc_hook) __sanitizer_malloc_hook(p, size);\n   return p;\n }\n \n void Deallocate(void *p) {\n+  if (&__sanitizer_free_hook) __sanitizer_free_hook(p);\n   RegisterDeallocation(p);\n   allocator.Deallocate(&cache, p);\n }\n@@ -111,7 +114,7 @@ void GetAllocatorCacheRange(uptr *begin, uptr *end) {\n   *end = *begin + sizeof(cache);\n }\n \n-uptr GetMallocUsableSize(void *p) {\n+uptr GetMallocUsableSize(const void *p) {\n   ChunkMetadata *m = Metadata(p);\n   if (!m) return 0;\n   return m->requested_size;\n@@ -198,3 +201,38 @@ IgnoreObjectResult IgnoreObjectLocked(const void *p) {\n   }\n }\n }  // namespace __lsan\n+\n+using namespace __lsan;\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_current_allocated_bytes() {\n+  uptr stats[AllocatorStatCount];\n+  allocator.GetStats(stats);\n+  return stats[AllocatorStatAllocated];\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_heap_size() {\n+  uptr stats[AllocatorStatCount];\n+  allocator.GetStats(stats);\n+  return stats[AllocatorStatMapped];\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_free_bytes() { return 0; }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_unmapped_bytes() { return 0; }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_estimated_allocated_size(uptr size) { return size; }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __sanitizer_get_ownership(const void *p) { return Metadata(p) != 0; }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_allocated_size(const void *p) {\n+  return GetMallocUsableSize(p);\n+}\n+}  // extern \"C\""}, {"sha": "aae0d28dc4a88a3026a0b04240707f2969c5c0fe", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -23,7 +23,7 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n void Deallocate(void *p);\n void *Reallocate(const StackTrace &stack, void *p, uptr new_size,\n                  uptr alignment);\n-uptr GetMallocUsableSize(void *p);\n+uptr GetMallocUsableSize(const void *p);\n \n template<typename Callable>\n void ForEachChunk(const Callable &callback);"}, {"sha": "e340b8953e1f821a97347fe3797708e249ce3279", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -34,15 +34,13 @@ bool DisabledInThisThread() { return disable_counter > 0; }\n \n Flags lsan_flags;\n \n-static void InitializeFlags() {\n+static void InitializeFlags(bool standalone) {\n   Flags *f = flags();\n   // Default values.\n   f->report_objects = false;\n   f->resolution = 0;\n   f->max_leaks = 0;\n   f->exitcode = 23;\n-  f->print_suppressions = true;\n-  f->suppressions=\"\";\n   f->use_registers = true;\n   f->use_globals = true;\n   f->use_stacks = true;\n@@ -70,9 +68,18 @@ static void InitializeFlags() {\n     ParseFlag(options, &f->log_pointers, \"log_pointers\", \"\");\n     ParseFlag(options, &f->log_threads, \"log_threads\", \"\");\n     ParseFlag(options, &f->exitcode, \"exitcode\", \"\");\n-    ParseFlag(options, &f->print_suppressions, \"print_suppressions\", \"\");\n-    ParseFlag(options, &f->suppressions, \"suppressions\", \"\");\n   }\n+\n+  // Set defaults for common flags (only in standalone mode) and parse\n+  // them from LSAN_OPTIONS.\n+  CommonFlags *cf = common_flags();\n+  if (standalone) {\n+    SetCommonFlagsDefaults(cf);\n+    cf->external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n+    cf->malloc_context_size = 30;\n+    cf->detect_leaks = true;\n+  }\n+  ParseCommonFlagsFromString(cf, options);\n }\n \n #define LOG_POINTERS(...)                           \\\n@@ -85,24 +92,14 @@ static void InitializeFlags() {\n     if (flags()->log_threads) Report(__VA_ARGS__); \\\n   } while (0);\n \n-SuppressionContext *suppression_ctx;\n+static bool suppressions_inited = false;\n \n void InitializeSuppressions() {\n-  CHECK(!suppression_ctx);\n-  ALIGNED(64) static char placeholder[sizeof(SuppressionContext)];\n-  suppression_ctx = new(placeholder) SuppressionContext;\n-  char *suppressions_from_file;\n-  uptr buffer_size;\n-  if (ReadFileToBuffer(flags()->suppressions, &suppressions_from_file,\n-                       &buffer_size, 1 << 26 /* max_len */))\n-    suppression_ctx->Parse(suppressions_from_file);\n-  if (flags()->suppressions[0] && !buffer_size) {\n-    Printf(\"LeakSanitizer: failed to read suppressions file '%s'\\n\",\n-           flags()->suppressions);\n-    Die();\n-  }\n+  CHECK(!suppressions_inited);\n+  SuppressionContext::InitIfNecessary();\n   if (&__lsan_default_suppressions)\n-    suppression_ctx->Parse(__lsan_default_suppressions());\n+    SuppressionContext::Get()->Parse(__lsan_default_suppressions());\n+  suppressions_inited = true;\n }\n \n struct RootRegion {\n@@ -118,8 +115,8 @@ void InitializeRootRegions() {\n   root_regions = new(placeholder) InternalMmapVector<RootRegion>(1);\n }\n \n-void InitCommonLsan() {\n-  InitializeFlags();\n+void InitCommonLsan(bool standalone) {\n+  InitializeFlags(standalone);\n   InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n     // Initialization which can fail or print warnings should only be done if\n@@ -129,9 +126,9 @@ void InitCommonLsan() {\n   }\n }\n \n-class Decorator: private __sanitizer::AnsiColorDecorator {\n+class Decorator: public __sanitizer::SanitizerCommonDecorator {\n  public:\n-  Decorator() : __sanitizer::AnsiColorDecorator(PrintsToTtyCached()) { }\n+  Decorator() : SanitizerCommonDecorator() { }\n   const char *Error() { return Red(); }\n   const char *Leak() { return Blue(); }\n   const char *End() { return Default(); }\n@@ -387,7 +384,7 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n \n static void PrintMatchedSuppressions() {\n   InternalMmapVector<Suppression *> matched(1);\n-  suppression_ctx->GetMatched(&matched);\n+  SuppressionContext::Get()->GetMatched(&matched);\n   if (!matched.size())\n     return;\n   const char *line = \"-----------------------------------------------------\";\n@@ -448,7 +445,7 @@ void DoLeakCheck() {\n     Printf(\"%s\", d.End());\n     param.leak_report.ReportTopLeaks(flags()->max_leaks);\n   }\n-  if (flags()->print_suppressions)\n+  if (common_flags()->print_suppressions)\n     PrintMatchedSuppressions();\n   if (unsuppressed_count > 0) {\n     param.leak_report.PrintSummary();\n@@ -463,20 +460,22 @@ static Suppression *GetSuppressionForAddr(uptr addr) {\n   // Suppress by module name.\n   const char *module_name;\n   uptr module_offset;\n-  if (Symbolizer::Get()->GetModuleNameAndOffsetForPC(addr, &module_name,\n-                                                     &module_offset) &&\n-      suppression_ctx->Match(module_name, SuppressionLeak, &s))\n+  if (Symbolizer::GetOrInit()\n+          ->GetModuleNameAndOffsetForPC(addr, &module_name, &module_offset) &&\n+      SuppressionContext::Get()->Match(module_name, SuppressionLeak, &s))\n     return s;\n \n   // Suppress by file or function name.\n   static const uptr kMaxAddrFrames = 16;\n   InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n   for (uptr i = 0; i < kMaxAddrFrames; i++) new (&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num = Symbolizer::Get()->SymbolizePC(\n+  uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n       addr, addr_frames.data(), kMaxAddrFrames);\n   for (uptr i = 0; i < addr_frames_num; i++) {\n-    if (suppression_ctx->Match(addr_frames[i].function, SuppressionLeak, &s) ||\n-        suppression_ctx->Match(addr_frames[i].file, SuppressionLeak, &s))\n+    if (SuppressionContext::Get()->Match(addr_frames[i].function,\n+                                         SuppressionLeak, &s) ||\n+        SuppressionContext::Get()->Match(addr_frames[i].file, SuppressionLeak,\n+                                         &s))\n       return s;\n   }\n   return 0;"}, {"sha": "72523d9ff5ca889445479604a49702b20c75f3a7", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -49,10 +49,6 @@ struct Flags {\n   int max_leaks;\n   // If nonzero kill the process with this exit code upon finding leaks.\n   int exitcode;\n-  // Print matched suppressions after leak checking.\n-  bool print_suppressions;\n-  // Suppressions file name.\n-  const char* suppressions;\n \n   // Flags controlling the root set of reachable memory.\n   // Global variables (.data and .bss).\n@@ -133,7 +129,7 @@ enum IgnoreObjectResult {\n };\n \n // Functions called from the parent tool.\n-void InitCommonLsan();\n+void InitCommonLsan(bool standalone);\n void DoLeakCheck();\n bool DisabledInThisThread();\n "}, {"sha": "ac05dfaa54fc3ad278a8eba771917fa5fb0232c1", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -32,21 +32,6 @@ int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n int pthread_setspecific(unsigned key, const void *v);\n }\n \n-#define GET_STACK_TRACE                                              \\\n-  StackTrace stack;                                                  \\\n-  {                                                                  \\\n-    uptr stack_top = 0, stack_bottom = 0;                            \\\n-    ThreadContext *t;                                                \\\n-    bool fast = common_flags()->fast_unwind_on_malloc;               \\\n-    if (fast && (t = CurrentThreadContext())) {                      \\\n-      stack_top = t->stack_end();                                    \\\n-      stack_bottom = t->stack_begin();                               \\\n-    }                                                                \\\n-    stack.Unwind(__sanitizer::common_flags()->malloc_context_size,   \\\n-                 StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(), 0, \\\n-                 stack_top, stack_bottom, fast);                     \\\n-  }\n-\n #define ENSURE_LSAN_INITED do {   \\\n   CHECK(!lsan_init_is_running);   \\\n   if (!lsan_inited)               \\\n@@ -63,7 +48,7 @@ namespace std {\n \n INTERCEPTOR(void*, malloc, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   return Allocate(stack, size, 1, kAlwaysClearMemory);\n }\n \n@@ -86,34 +71,40 @@ INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n   }\n   if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   size *= nmemb;\n   return Allocate(stack, size, 1, true);\n }\n \n INTERCEPTOR(void*, realloc, void *q, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   return Reallocate(stack, q, size, 1);\n }\n \n INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n+  return Allocate(stack, size, alignment, kAlwaysClearMemory);\n+}\n+\n+INTERCEPTOR(void*, aligned_alloc, uptr alignment, uptr size) {\n+  ENSURE_LSAN_INITED;\n+  GET_STACK_TRACE_MALLOC;\n   return Allocate(stack, size, alignment, kAlwaysClearMemory);\n }\n \n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   *memptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n   // FIXME: Return ENOMEM if user requested more than max alloc size.\n   return 0;\n }\n \n INTERCEPTOR(void*, valloc, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   if (size == 0)\n     size = GetPageSizeCached();\n   return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n@@ -140,7 +131,7 @@ INTERCEPTOR(int, mallopt, int cmd, int value) {\n \n INTERCEPTOR(void*, pvalloc, uptr size) {\n   ENSURE_LSAN_INITED;\n-  GET_STACK_TRACE;\n+  GET_STACK_TRACE_MALLOC;\n   uptr PageSize = GetPageSizeCached();\n   size = RoundUpTo(size, PageSize);\n   if (size == 0) {\n@@ -154,7 +145,7 @@ INTERCEPTOR(void, cfree, void *p) ALIAS(WRAPPER_NAME(free));\n \n #define OPERATOR_NEW_BODY                              \\\n   ENSURE_LSAN_INITED;                                  \\\n-  GET_STACK_TRACE;                                     \\\n+  GET_STACK_TRACE_MALLOC;                              \\\n   return Allocate(stack, size, 1, kAlwaysClearMemory);\n \n INTERCEPTOR_ATTRIBUTE"}, {"sha": "d1efd31406b5a5cfd7e61cf930680d7bf657ff5f", "filename": "libsanitizer/lsan/lsan_preinit.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Flsan%2Flsan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_preinit.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,11 +12,7 @@\n \n #include \"lsan.h\"\n \n-#ifndef LSAN_USE_PREINIT_ARRAY\n-#define LSAN_USE_PREINIT_ARRAY 1\n-#endif\n-\n-#if LSAN_USE_PREINIT_ARRAY && !defined(PIC)\n+#if SANITIZER_CAN_USE_PREINIT_ARRAY\n   // We force __lsan_init to be called before anyone else by placing it into\n   // .preinit_array section.\n   __attribute__((section(\".preinit_array\"), used))"}, {"sha": "bc1f18c2a18acad076fb1393818e01fba1446a16", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -21,7 +21,8 @@ sanitizer_common_files = \\\n \tsanitizer_allocator.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage.cc \\\n+\tsanitizer_coverage_libcdep.cc \\\n+\tsanitizer_coverage_mapping_libcdep.cc \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n@@ -30,11 +31,14 @@ sanitizer_common_files = \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_mac.cc \\\n+\tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n \tsanitizer_posix.cc \\\n \tsanitizer_posix_libcdep.cc \\\n \tsanitizer_printf.cc \\\n+\tsanitizer_procmaps_common.cc \\\n+\tsanitizer_procmaps_freebsd.cc \\\n \tsanitizer_procmaps_linux.cc \\\n \tsanitizer_procmaps_mac.cc \\\n \tsanitizer_stackdepot.cc \\\n@@ -49,8 +53,10 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n+\tsanitizer_unwind_posix_libcdep.cc \\\n \tsanitizer_win.cc\n \n+\n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "d82b4834efc2daca3bb5f1d03ea6d95d33a34d18", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -64,14 +64,17 @@ CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libsanitizer_common_la_LIBADD =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n-\tsanitizer_common_libcdep.lo sanitizer_coverage.lo \\\n+\tsanitizer_common_libcdep.lo sanitizer_coverage_libcdep.lo \\\n+\tsanitizer_coverage_mapping_libcdep.lo \\\n \tsanitizer_deadlock_detector1.lo \\\n \tsanitizer_deadlock_detector2.lo sanitizer_flags.lo \\\n \tsanitizer_libc.lo sanitizer_libignore.lo sanitizer_linux.lo \\\n \tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n+\tsanitizer_persistent_allocator.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n \tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n \tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n+\tsanitizer_procmaps_common.lo sanitizer_procmaps_freebsd.lo \\\n \tsanitizer_procmaps_linux.lo sanitizer_procmaps_mac.lo \\\n \tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n \tsanitizer_stacktrace_libcdep.lo \\\n@@ -81,7 +84,8 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_symbolizer_libcdep.lo \\\n \tsanitizer_symbolizer_posix_libcdep.lo \\\n \tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n-\tsanitizer_tls_get_addr.lo sanitizer_win.lo\n+\tsanitizer_tls_get_addr.lo sanitizer_unwind_posix_libcdep.lo \\\n+\tsanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n@@ -256,7 +260,8 @@ sanitizer_common_files = \\\n \tsanitizer_allocator.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage.cc \\\n+\tsanitizer_coverage_libcdep.cc \\\n+\tsanitizer_coverage_mapping_libcdep.cc \\\n \tsanitizer_deadlock_detector1.cc \\\n \tsanitizer_deadlock_detector2.cc \\\n \tsanitizer_flags.cc \\\n@@ -265,11 +270,14 @@ sanitizer_common_files = \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_mac.cc \\\n+\tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n \tsanitizer_posix.cc \\\n \tsanitizer_posix_libcdep.cc \\\n \tsanitizer_printf.cc \\\n+\tsanitizer_procmaps_common.cc \\\n+\tsanitizer_procmaps_freebsd.cc \\\n \tsanitizer_procmaps_linux.cc \\\n \tsanitizer_procmaps_mac.cc \\\n \tsanitizer_stackdepot.cc \\\n@@ -284,6 +292,7 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_win.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n+\tsanitizer_unwind_posix_libcdep.cc \\\n \tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n@@ -382,7 +391,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_mapping_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n@@ -391,11 +401,14 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_freebsd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n@@ -410,6 +423,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n \n .cc.o:"}, {"sha": "fb3941292027ffca3e1f524112c9d3124ced29af", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -271,9 +271,9 @@ class AllocatorGlobalStats : public AllocatorStats {\n       if (stats == this)\n         break;\n     }\n-    // All stats must be positive.\n+    // All stats must be non-negative.\n     for (int i = 0; i < AllocatorStatCount; i++)\n-      s[i] = ((sptr)s[i]) > 0 ? s[i] : 1;\n+      s[i] = ((sptr)s[i]) >= 0 ? s[i] : 0;\n   }\n \n  private:"}, {"sha": "fd5bed30c4b3417c8ca2de3405506958ff77d59d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_interface.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,36 @@\n+//===-- sanitizer_allocator_interface.h ------------------------- C++ -----===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Re-declaration of functions from public sanitizer allocator interface.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ALLOCATOR_INTERFACE_H\n+#define SANITIZER_ALLOCATOR_INTERFACE_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+using __sanitizer::uptr;\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __sanitizer_get_estimated_allocated_size(uptr size);\n+SANITIZER_INTERFACE_ATTRIBUTE int __sanitizer_get_ownership(const void *p);\n+SANITIZER_INTERFACE_ATTRIBUTE uptr\n+__sanitizer_get_allocated_size(const void *p);\n+SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_current_allocated_bytes();\n+SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_heap_size();\n+SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_free_bytes();\n+SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_unmapped_bytes();\n+\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+    /* OPTIONAL */ void __sanitizer_malloc_hook(void *ptr, uptr size);\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+    /* OPTIONAL */ void __sanitizer_free_hook(void *ptr);\n+}  // extern \"C\"\n+\n+#endif  // SANITIZER_ALLOCATOR_INTERFACE_H"}, {"sha": "5e8cc1077061ee633d3176219247448d75a5de9d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -23,38 +23,25 @@ typedef CompactSizeClassMap InternalSizeClassMap;\n \n static const uptr kInternalAllocatorSpace = 0;\n static const u64 kInternalAllocatorSize = SANITIZER_MMAP_RANGE_SIZE;\n-#if SANITIZER_WORDSIZE == 32\n static const uptr kInternalAllocatorRegionSizeLog = 20;\n+#if SANITIZER_WORDSIZE == 32\n static const uptr kInternalAllocatorNumRegions =\n     kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n typedef FlatByteMap<kInternalAllocatorNumRegions> ByteMap;\n #else\n-static const uptr kInternalAllocatorRegionSizeLog = 24;\n static const uptr kInternalAllocatorNumRegions =\n     kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n typedef TwoLevelByteMap<(kInternalAllocatorNumRegions >> 12), 1 << 12> ByteMap;\n #endif\n typedef SizeClassAllocator32<\n-    kInternalAllocatorSpace, kInternalAllocatorSize, 16, InternalSizeClassMap,\n+    kInternalAllocatorSpace, kInternalAllocatorSize, 0, InternalSizeClassMap,\n     kInternalAllocatorRegionSizeLog, ByteMap> PrimaryInternalAllocator;\n \n typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n     InternalAllocatorCache;\n \n-// We don't want our internal allocator to do any map/unmap operations from\n-// LargeMmapAllocator.\n-struct CrashOnMapUnmap {\n-  void OnMap(uptr p, uptr size) const {\n-    RAW_CHECK_MSG(0, \"Unexpected mmap in InternalAllocator!\\n\");\n-  }\n-  void OnUnmap(uptr p, uptr size) const {\n-    RAW_CHECK_MSG(0, \"Unexpected munmap in InternalAllocator!\\n\");\n-  }\n-};\n-\n typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n-                          LargeMmapAllocator<CrashOnMapUnmap> >\n-    InternalAllocator;\n+                          LargeMmapAllocator<> > InternalAllocator;\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache = 0);\n void InternalFree(void *p, InternalAllocatorCache *cache = 0);"}, {"sha": "1198dec3e976d7ceb891f8e17366caa061c68f20", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -31,33 +31,20 @@ long long _InterlockedCompareExchange64(  // NOLINT\n     long long volatile *Destination,              // NOLINT\n     long long Exchange, long long Comparand);     // NOLINT\n #pragma intrinsic(_InterlockedCompareExchange64)\n-\n-#ifdef _WIN64\n-extern \"C\" long long _InterlockedExchangeAdd64(     // NOLINT\n-    long long volatile * Addend, long long Value);  // NOLINT\n-#pragma intrinsic(_InterlockedExchangeAdd64)\n extern \"C\" void *_InterlockedCompareExchangePointer(\n     void *volatile *Destination,\n     void *Exchange, void *Comparand);\n #pragma intrinsic(_InterlockedCompareExchangePointer)\n-#else\n-// There's no _InterlockedCompareExchangePointer intrinsic on x86,\n-// so call _InterlockedCompareExchange instead.\n extern \"C\"\n long __cdecl _InterlockedCompareExchange(  // NOLINT\n     long volatile *Destination,            // NOLINT\n     long Exchange, long Comparand);        // NOLINT\n #pragma intrinsic(_InterlockedCompareExchange)\n \n-inline static void *_InterlockedCompareExchangePointer(\n-    void *volatile *Destination,\n-    void *Exchange, void *Comparand) {\n-  return reinterpret_cast<void*>(\n-      _InterlockedCompareExchange(\n-          reinterpret_cast<long volatile*>(Destination),  // NOLINT\n-          reinterpret_cast<long>(Exchange),               // NOLINT\n-          reinterpret_cast<long>(Comparand)));            // NOLINT\n-}\n+#ifdef _WIN64\n+extern \"C\" long long _InterlockedExchangeAdd64(     // NOLINT\n+    long long volatile * Addend, long long Value);  // NOLINT\n+#pragma intrinsic(_InterlockedExchangeAdd64)\n #endif\n \n namespace __sanitizer {"}, {"sha": "d4da3206e130f3753a9fb4279e9ed6a0437087ef", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,8 +12,6 @@\n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n@@ -195,31 +193,17 @@ void ReportErrorSummary(const char *error_type, const char *file,\n   ReportErrorSummary(buff.data());\n }\n \n-void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n-  if (!common_flags()->print_summary)\n-    return;\n-  AddressInfo ai;\n-#if !SANITIZER_GO\n-  if (stack->size > 0 && Symbolizer::Get()->CanReturnFileLineInfo()) {\n-    // Currently, we include the first stack frame into the report summary.\n-    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n-    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n-    Symbolizer::Get()->SymbolizePC(pc, &ai, 1);\n-  }\n-#endif\n-  ReportErrorSummary(error_type, ai.file, ai.line, ai.function);\n-}\n-\n LoadedModule::LoadedModule(const char *module_name, uptr base_address) {\n   full_name_ = internal_strdup(module_name);\n   base_address_ = base_address;\n   n_ranges_ = 0;\n }\n \n-void LoadedModule::addAddressRange(uptr beg, uptr end) {\n+void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {\n   CHECK_LT(n_ranges_, kMaxNumberOfAddressRanges);\n   ranges_[n_ranges_].beg = beg;\n   ranges_[n_ranges_].end = end;\n+  exec_[n_ranges_] = executable;\n   n_ranges_++;\n }\n \n@@ -261,11 +245,6 @@ void DecreaseTotalMmap(uptr size) {\n   atomic_fetch_sub(&g_total_mmaped, size, memory_order_relaxed);\n }\n \n-static void (*sandboxing_callback)();\n-void SetSandboxingCallback(void (*f)()) {\n-  sandboxing_callback = f;\n-}\n-\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT\n@@ -298,13 +277,6 @@ void __sanitizer_set_report_path(const char *path) {\n   }\n }\n \n-void NOINLINE\n-__sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args) {\n-  PrepareForSandboxing(args);\n-  if (sandboxing_callback)\n-    sandboxing_callback();\n-}\n-\n void __sanitizer_report_error_summary(const char *error_summary) {\n   Printf(\"%s\\n\", error_summary);\n }"}, {"sha": "a9db1082f48f4e0e4edcea9d7c1cdb451441d3e2", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -163,6 +163,9 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n // (or NULL if the mapping failes). Stores the size of mmaped region\n // in '*buff_size'.\n void *MapFileToMemory(const char *file_name, uptr *buff_size);\n+void *MapWritableFileToMemory(void *addr, uptr size, uptr fd, uptr offset);\n+\n+bool IsAccessibleMemoryRange(uptr beg, uptr size);\n \n // Error report formatting.\n const char *StripPathPrefix(const char *filepath,\n@@ -173,7 +176,7 @@ void PrintModuleAndOffset(InternalScopedString *buffer,\n                           const char *module, uptr offset);\n \n // OS\n-void DisableCoreDumper();\n+void DisableCoreDumperIfNecessary();\n void DumpProcessMap();\n bool FileExists(const char *filename);\n const char *GetEnv(const char *name);\n@@ -184,11 +187,17 @@ u32 GetUid();\n void ReExec();\n bool StackSizeIsUnlimited();\n void SetStackSizeLimitInBytes(uptr limit);\n+bool AddressSpaceIsUnlimited();\n+void SetAddressSpaceUnlimited();\n void AdjustStackSize(void *attr);\n void PrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args);\n void SetSandboxingCallback(void (*f)());\n \n+void CovUpdateMapping(uptr caller_pc = 0);\n+void CovBeforeFork();\n+void CovAfterFork(int child_pid);\n+\n void InitTlsSize();\n uptr GetTlsSize();\n \n@@ -239,7 +248,7 @@ const int kMaxSummaryLength = 1024;\n // and pass it to __sanitizer_report_error_summary.\n void ReportErrorSummary(const char *error_message);\n // Same as above, but construct error_message as:\n-//   error_type: file:line function\n+//   error_type file:line function\n void ReportErrorSummary(const char *error_type, const char *file,\n                         int line, const char *function);\n void ReportErrorSummary(const char *error_type, StackTrace *trace);\n@@ -475,12 +484,17 @@ uptr InternalBinarySearch(const Container &v, uptr first, uptr last,\n class LoadedModule {\n  public:\n   LoadedModule(const char *module_name, uptr base_address);\n-  void addAddressRange(uptr beg, uptr end);\n+  void addAddressRange(uptr beg, uptr end, bool executable);\n   bool containsAddress(uptr address) const;\n \n   const char *full_name() const { return full_name_; }\n   uptr base_address() const { return base_address_; }\n \n+  uptr n_ranges() const { return n_ranges_; }\n+  uptr address_range_start(int i) const { return ranges_[i].beg; }\n+  uptr address_range_end(int i) const { return ranges_[i].end; }\n+  bool address_range_executable(int i) const { return exec_[i]; }\n+\n  private:\n   struct AddressRange {\n     uptr beg;\n@@ -490,6 +504,7 @@ class LoadedModule {\n   uptr base_address_;\n   static const uptr kMaxNumberOfAddressRanges = 6;\n   AddressRange ranges_[kMaxNumberOfAddressRanges];\n+  bool exec_[kMaxNumberOfAddressRanges];\n   uptr n_ranges_;\n };\n \n@@ -529,10 +544,13 @@ F IndirectExternCall(F f) {\n #endif\n \n #if SANITIZER_ANDROID\n+// Initialize Android logging. Any writes before this are silently lost.\n+void AndroidLogInit();\n void AndroidLogWrite(const char *buffer);\n void GetExtraActivationFlags(char *buf, uptr size);\n void SanitizerInitializeUnwinder();\n #else\n+INLINE void AndroidLogInit() {}\n INLINE void AndroidLogWrite(const char *buffer_unused) {}\n INLINE void GetExtraActivationFlags(char *buf, uptr size) { *buf = '\\0'; }\n INLINE void SanitizerInitializeUnwinder() {}\n@@ -544,4 +562,9 @@ inline void *operator new(__sanitizer::operator_new_size_type size,\n   return alloc.Allocate(size);\n }\n \n+struct StackDepotStats {\n+  uptr n_uniq_ids;\n+  uptr allocated;\n+};\n+\n #endif  // SANITIZER_COMMON_H"}, {"sha": "f55a31de77e0ee6273cab7de146b4dd4aab41002", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 765, "deletions": 52, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -11,6 +11,7 @@\n // This file should be included into the tool's interceptor file,\n // which has to define it's own macros:\n //   COMMON_INTERCEPTOR_ENTER\n+//   COMMON_INTERCEPTOR_ENTER_NOIGNORE\n //   COMMON_INTERCEPTOR_READ_RANGE\n //   COMMON_INTERCEPTOR_WRITE_RANGE\n //   COMMON_INTERCEPTOR_INITIALIZE_RANGE\n@@ -24,6 +25,7 @@\n //   COMMON_INTERCEPTOR_MUTEX_REPAIR\n //   COMMON_INTERCEPTOR_SET_PTHREAD_NAME\n //   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n+//   COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n //===----------------------------------------------------------------------===//\n #include \"interception/interception.h\"\n #include \"sanitizer_addrhashmap.h\"\n@@ -73,6 +75,23 @@\n #define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) {}\n #endif\n \n+#ifndef COMMON_INTERCEPTOR_LIBRARY_LOADED\n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, map) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_LIBRARY_UNLOADED\n+#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_ENTER_NOIGNORE\n+#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, ...) \\\n+  COMMON_INTERCEPTOR_ENTER(ctx, __VA_ARGS__)\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n+#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (0)\n+#endif\n+\n struct FileMetadata {\n   // For open_memstream().\n   char **addr;\n@@ -158,6 +177,8 @@ INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n }\n \n INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n+  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n+    return internal_strncmp(s1, s2, size);\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strncmp, s1, s2, size);\n   unsigned char c1 = 0, c2 = 0;\n@@ -255,8 +276,9 @@ INTERCEPTOR(void*, memrchr, const void *s, int c, SIZE_T n) {\n INTERCEPTOR(double, frexp, double x, int *exp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, frexp, x, exp);\n-  double res = REAL(frexp)(x, exp);\n+  // Assuming frexp() always writes to |exp|.\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n+  double res = REAL(frexp)(x, exp);\n   return res;\n }\n \n@@ -269,6 +291,9 @@ INTERCEPTOR(double, frexp, double x, int *exp) {\n INTERCEPTOR(float, frexpf, float x, int *exp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, frexpf, x, exp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   float res = REAL(frexpf)(x, exp);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n   return res;\n@@ -277,6 +302,9 @@ INTERCEPTOR(float, frexpf, float x, int *exp) {\n INTERCEPTOR(long double, frexpl, long double x, int *exp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, frexpl, x, exp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   long double res = REAL(frexpl)(x, exp);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n   return res;\n@@ -315,6 +343,9 @@ INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n   COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(read)(fd, ptr, count);\n   if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n@@ -330,6 +361,9 @@ INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n   COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n   if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n@@ -345,6 +379,9 @@ INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n   COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n   if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n@@ -523,9 +560,11 @@ INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n INTERCEPTOR(unsigned long, time, unsigned long *t) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, time, t);\n-  unsigned long res = REAL(time)(t);\n+  unsigned long local_t;\n+  unsigned long res = REAL(time)(&local_t);\n   if (t && res != (unsigned long)-1) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, t, sizeof(*t));\n+    *t = local_t;\n   }\n   return res;\n }\n@@ -587,6 +626,9 @@ INTERCEPTOR(__sanitizer_tm *, gmtime_r, unsigned long *timep, void *result) {\n INTERCEPTOR(char *, ctime, unsigned long *timep) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ctime, timep);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(ctime)(timep);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n@@ -597,6 +639,9 @@ INTERCEPTOR(char *, ctime, unsigned long *timep) {\n INTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ctime_r, timep, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(ctime_r)(timep, result);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n@@ -607,6 +652,9 @@ INTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n INTERCEPTOR(char *, asctime, __sanitizer_tm *tm) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, asctime, tm);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(asctime)(tm);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n@@ -617,6 +665,9 @@ INTERCEPTOR(char *, asctime, __sanitizer_tm *tm) {\n INTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, asctime_r, tm, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(asctime_r)(tm, result);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n@@ -658,6 +709,9 @@ INTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n   COMMON_INTERCEPTOR_ENTER(ctx, strptime, s, format, tm);\n   if (format)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, format, REAL(strlen)(format) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(strptime)(s, format, tm);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, s, res - s);\n@@ -792,6 +846,9 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n     return res;                                                                \\\n   }\n \n+// FIXME: under ASan the REAL() call below may write to freed memory and\n+// corrupt its metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n #define VSPRINTF_INTERCEPTOR_IMPL(vname, str, ...)                             \\\n   {                                                                            \\\n     VPRINTF_INTERCEPTOR_ENTER(vname, str, __VA_ARGS__)                         \\\n@@ -806,6 +863,9 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n     return res;                                                                \\\n   }\n \n+// FIXME: under ASan the REAL() call below may write to freed memory and\n+// corrupt its metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n #define VSNPRINTF_INTERCEPTOR_IMPL(vname, str, size, ...)                      \\\n   {                                                                            \\\n     VPRINTF_INTERCEPTOR_ENTER(vname, str, size, __VA_ARGS__)                   \\\n@@ -820,6 +880,9 @@ FORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n     return res;                                                                \\\n   }\n \n+// FIXME: under ASan the REAL() call below may write to freed memory and\n+// corrupt its metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n #define VASPRINTF_INTERCEPTOR_IMPL(vname, strp, ...)                           \\\n   {                                                                            \\\n     VPRINTF_INTERCEPTOR_ENTER(vname, strp, __VA_ARGS__)                        \\\n@@ -972,7 +1035,8 @@ INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n #endif\n \n #if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS || \\\n-    SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT\n+    SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT || \\\n+    SANITIZER_INTERCEPT_GETPWENT_R || SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n static void unpoison_passwd(void *ctx, __sanitizer_passwd *pwd) {\n   if (pwd) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, sizeof(*pwd));\n@@ -1019,7 +1083,9 @@ static void unpoison_group(void *ctx, __sanitizer_group *grp) {\n   }\n }\n #endif  // SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS ||\n-        // SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT\n+        // SANITIZER_INTERCEPT_GETPWENT || SANITIZER_INTERCEPT_FGETPWENT ||\n+        // SANITIZER_INTERCEPT_GETPWENT_R ||\n+        // SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n \n #if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n INTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n@@ -1067,6 +1133,9 @@ INTERCEPTOR(int, getpwnam_r, const char *name, __sanitizer_passwd *pwd,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getpwnam_r)(name, pwd, buf, buflen, result);\n   if (!res) {\n     if (result && *result) unpoison_passwd(ctx, *result);\n@@ -1079,6 +1148,9 @@ INTERCEPTOR(int, getpwuid_r, u32 uid, __sanitizer_passwd *pwd, char *buf,\n             SIZE_T buflen, __sanitizer_passwd **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n   if (!res) {\n     if (result && *result) unpoison_passwd(ctx, *result);\n@@ -1092,6 +1164,9 @@ INTERCEPTOR(int, getgrnam_r, const char *name, __sanitizer_group *grp,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getgrnam_r)(name, grp, buf, buflen, result);\n   if (!res) {\n     if (result && *result) unpoison_group(ctx, *result);\n@@ -1104,6 +1179,9 @@ INTERCEPTOR(int, getgrgid_r, u32 gid, __sanitizer_group *grp, char *buf,\n             SIZE_T buflen, __sanitizer_group **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n   if (!res) {\n     if (result && *result) unpoison_group(ctx, *result);\n@@ -1170,6 +1248,9 @@ INTERCEPTOR(int, getpwent_r, __sanitizer_passwd *pwbuf, char *buf,\n             SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwent_r, pwbuf, buf, buflen, pwbufp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getpwent_r)(pwbuf, buf, buflen, pwbufp);\n   if (!res) {\n     if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n@@ -1182,6 +1263,9 @@ INTERCEPTOR(int, fgetpwent_r, void *fp, __sanitizer_passwd *pwbuf, char *buf,\n             SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent_r, fp, pwbuf, buf, buflen, pwbufp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fgetpwent_r)(fp, pwbuf, buf, buflen, pwbufp);\n   if (!res) {\n     if (pwbufp && *pwbufp) unpoison_passwd(ctx, *pwbufp);\n@@ -1194,6 +1278,9 @@ INTERCEPTOR(int, getgrent_r, __sanitizer_group *pwbuf, char *buf, SIZE_T buflen,\n             __sanitizer_group **pwbufp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrent_r, pwbuf, buf, buflen, pwbufp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getgrent_r)(pwbuf, buf, buflen, pwbufp);\n   if (!res) {\n     if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n@@ -1206,6 +1293,9 @@ INTERCEPTOR(int, fgetgrent_r, void *fp, __sanitizer_group *pwbuf, char *buf,\n             SIZE_T buflen, __sanitizer_group **pwbufp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent_r, fp, pwbuf, buf, buflen, pwbufp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fgetgrent_r)(fp, pwbuf, buf, buflen, pwbufp);\n   if (!res) {\n     if (pwbufp && *pwbufp) unpoison_group(ctx, *pwbufp);\n@@ -1260,6 +1350,9 @@ INTERCEPTOR(void, endgrent, int dummy) {\n INTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, clock_getres, clk_id, tp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(clock_getres)(clk_id, tp);\n   if (!res && tp) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n@@ -1269,6 +1362,9 @@ INTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n INTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, clock_gettime, clk_id, tp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(clock_gettime)(clk_id, tp);\n   if (!res) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n@@ -1293,6 +1389,9 @@ INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n INTERCEPTOR(int, getitimer, int which, void *curr_value) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getitimer, which, curr_value);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getitimer)(which, curr_value);\n   if (!res && curr_value) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerval_sz);\n@@ -1304,6 +1403,9 @@ INTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n   COMMON_INTERCEPTOR_ENTER(ctx, setitimer, which, new_value, old_value);\n   if (new_value)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerval_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(setitimer)(which, new_value, old_value);\n   if (!res && old_value) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerval_sz);\n@@ -1433,15 +1535,27 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n INTERCEPTOR_WITH_SUFFIX(int, wait, int *status) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wait, status);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(wait)(status);\n   if (res != -1 && status)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n   return res;\n }\n+// On FreeBSD id_t is always 64-bit wide.\n+#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n+INTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, long long id, void *infop,\n+                        int options) {\n+#else\n INTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n                         int options) {\n+#endif\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, waitid, idtype, id, infop, options);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(waitid)(idtype, id, infop, options);\n   if (res != -1 && infop)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, infop, siginfo_t_sz);\n@@ -1450,6 +1564,9 @@ INTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n INTERCEPTOR_WITH_SUFFIX(int, waitpid, int pid, int *status, int options) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, waitpid, pid, status, options);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(waitpid)(pid, status, options);\n   if (res != -1 && status)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n@@ -1458,6 +1575,9 @@ INTERCEPTOR_WITH_SUFFIX(int, waitpid, int pid, int *status, int options) {\n INTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wait3, status, options, rusage);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(wait3)(status, options, rusage);\n   if (res != -1) {\n     if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n@@ -1469,6 +1589,9 @@ INTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n INTERCEPTOR(int, __wait4, int pid, int *status, int options, void *rusage) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, __wait4, pid, status, options, rusage);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(__wait4)(pid, status, options, rusage);\n   if (res != -1) {\n     if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n@@ -1481,6 +1604,9 @@ INTERCEPTOR(int, __wait4, int pid, int *status, int options, void *rusage) {\n INTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(wait4)(pid, status, options, rusage);\n   if (res != -1) {\n     if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n@@ -1507,6 +1633,9 @@ INTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n   uptr sz = __sanitizer_in_addr_sz(af);\n   if (sz) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sz);\n   // FIXME: figure out read size based on the address family.\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(inet_ntop)(af, src, dst, size);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n@@ -1515,6 +1644,9 @@ INTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, inet_pton, af, src, dst);\n   // FIXME: figure out read size based on the address family.\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(inet_pton)(af, src, dst);\n   if (res == 1) {\n     uptr sz = __sanitizer_in_addr_sz(af);\n@@ -1534,6 +1666,9 @@ INTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, inet_aton, cp, dst);\n   if (cp) COMMON_INTERCEPTOR_READ_RANGE(ctx, cp, REAL(strlen)(cp) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(inet_aton)(cp, dst);\n   if (res != 0) {\n     uptr sz = __sanitizer_in_addr_sz(af_inet);\n@@ -1550,6 +1685,9 @@ INTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n INTERCEPTOR(int, pthread_getschedparam, uptr thread, int *policy, int *param) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_getschedparam, thread, policy, param);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(pthread_getschedparam)(thread, policy, param);\n   if (res == 0) {\n     if (policy) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, policy, sizeof(*policy));\n@@ -1574,6 +1712,9 @@ INTERCEPTOR(int, getaddrinfo, char *node, char *service,\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, service, REAL(strlen)(service) + 1);\n   if (hints)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, hints, sizeof(__sanitizer_addrinfo));\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getaddrinfo)(node, service, hints, out);\n   if (res == 0 && out) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, out, sizeof(*out));\n@@ -1603,6 +1744,9 @@ INTERCEPTOR(int, getnameinfo, void *sockaddr, unsigned salen, char *host,\n                            serv, servlen, flags);\n   // FIXME: consider adding READ_RANGE(sockaddr, salen)\n   // There is padding in in_addr that may make this too noisy\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res =\n       REAL(getnameinfo)(sockaddr, salen, host, hostlen, serv, servlen, flags);\n   if (res == 0) {\n@@ -1624,6 +1768,9 @@ INTERCEPTOR(int, getsockname, int sock_fd, void *addr, int *addrlen) {\n   COMMON_INTERCEPTOR_ENTER(ctx, getsockname, sock_fd, addr, addrlen);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n   int addrlen_in = *addrlen;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getsockname)(sock_fd, addr, addrlen);\n   if (res == 0) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addrlen_in, *addrlen));\n@@ -1701,11 +1848,38 @@ INTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n #endif\n \n #if SANITIZER_INTERCEPT_GETHOSTBYNAME_R\n+INTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n+            char *buf, SIZE_T buflen, __sanitizer_hostent **result,\n+            int *h_errnop) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n+                           h_errnop);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n+  int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n+  if (result) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+    if (res == 0 && *result) write_hostent(ctx, *result);\n+  }\n+  if (h_errnop)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n+  return res;\n+}\n+#define INIT_GETHOSTBYNAME_R COMMON_INTERCEPT_FUNCTION(gethostbyname_r);\n+#else\n+#define INIT_GETHOSTBYNAME_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETHOSTENT_R\n INTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n             SIZE_T buflen, __sanitizer_hostent **result, int *h_errnop) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostent_r, ret, buf, buflen, result,\n                            h_errnop);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(gethostent_r)(ret, buf, buflen, result, h_errnop);\n   if (result) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n@@ -1715,14 +1889,23 @@ INTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n+#define INIT_GETHOSTENT_R                  \\\n+  COMMON_INTERCEPT_FUNCTION(gethostent_r);\n+#else\n+#define INIT_GETHOSTENT_R\n+#endif\n \n+#if SANITIZER_INTERCEPT_GETHOSTBYADDR_R\n INTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n             struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n             __sanitizer_hostent **result, int *h_errnop) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr_r, addr, len, type, ret, buf,\n                            buflen, result, h_errnop);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(gethostbyaddr_r)(addr, len, type, ret, buf, buflen, result,\n                                   h_errnop);\n   if (result) {\n@@ -1733,29 +1916,22 @@ INTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n+#define INIT_GETHOSTBYADDR_R                  \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyaddr_r);\n+#else\n+#define INIT_GETHOSTBYADDR_R\n+#endif\n \n-INTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n-            char *buf, SIZE_T buflen, __sanitizer_hostent **result,\n-            int *h_errnop) {\n-  void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n-                           h_errnop);\n-  int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n-  if (result) {\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n-    if (res == 0 && *result) write_hostent(ctx, *result);\n-  }\n-  if (h_errnop)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n-  return res;\n-}\n-\n+#if SANITIZER_INTERCEPT_GETHOSTBYNAME2_R\n INTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n             struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n             __sanitizer_hostent **result, int *h_errnop) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2_r, name, af, ret, buf, buflen,\n                            result, h_errnop);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res =\n       REAL(gethostbyname2_r)(name, af, ret, buf, buflen, result, h_errnop);\n   if (result) {\n@@ -1766,13 +1942,10 @@ INTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n   return res;\n }\n-#define INIT_GETHOSTBYNAME_R                  \\\n-  COMMON_INTERCEPT_FUNCTION(gethostent_r);    \\\n-  COMMON_INTERCEPT_FUNCTION(gethostbyaddr_r); \\\n-  COMMON_INTERCEPT_FUNCTION(gethostbyname_r); \\\n+#define INIT_GETHOSTBYNAME2_R                  \\\n   COMMON_INTERCEPT_FUNCTION(gethostbyname2_r);\n #else\n-#define INIT_GETHOSTBYNAME_R\n+#define INIT_GETHOSTBYNAME2_R\n #endif\n \n #if SANITIZER_INTERCEPT_GETSOCKOPT\n@@ -1782,6 +1955,9 @@ INTERCEPTOR(int, getsockopt, int sockfd, int level, int optname, void *optval,\n   COMMON_INTERCEPTOR_ENTER(ctx, getsockopt, sockfd, level, optname, optval,\n                            optlen);\n   if (optlen) COMMON_INTERCEPTOR_READ_RANGE(ctx, optlen, sizeof(*optlen));\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getsockopt)(sockfd, level, optname, optval, optlen);\n   if (res == 0)\n     if (optval && optlen) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, optval, *optlen);\n@@ -1823,6 +1999,9 @@ INTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n     addrlen0 = *addrlen;\n   }\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int fd2 = REAL(accept4)(fd, addr, addrlen, f);\n   if (fd2 >= 0) {\n     if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n@@ -1840,6 +2019,9 @@ INTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n INTERCEPTOR(double, modf, double x, double *iptr) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, modf, x, iptr);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   double res = REAL(modf)(x, iptr);\n   if (iptr) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n@@ -1849,6 +2031,9 @@ INTERCEPTOR(double, modf, double x, double *iptr) {\n INTERCEPTOR(float, modff, float x, float *iptr) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, modff, x, iptr);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   float res = REAL(modff)(x, iptr);\n   if (iptr) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n@@ -1858,6 +2043,9 @@ INTERCEPTOR(float, modff, float x, float *iptr) {\n INTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, modfl, x, iptr);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   long double res = REAL(modfl)(x, iptr);\n   if (iptr) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n@@ -1890,6 +2078,9 @@ INTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n             int flags) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, recvmsg, fd, msg, flags);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(recvmsg)(fd, msg, flags);\n   if (res >= 0) {\n     if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n@@ -1911,6 +2102,9 @@ INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n   COMMON_INTERCEPTOR_ENTER(ctx, getpeername, sockfd, addr, addrlen);\n   unsigned addr_sz;\n   if (addrlen) addr_sz = *addrlen;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getpeername)(sockfd, addr, addrlen);\n   if (!res && addr && addrlen)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addr_sz, *addrlen));\n@@ -1924,6 +2118,9 @@ INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n #if SANITIZER_INTERCEPT_SYSINFO\n INTERCEPTOR(int, sysinfo, void *info) {\n   void *ctx;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   COMMON_INTERCEPTOR_ENTER(ctx, sysinfo, info);\n   int res = REAL(sysinfo)(info);\n   if (!res && info)\n@@ -1939,6 +2136,9 @@ INTERCEPTOR(int, sysinfo, void *info) {\n INTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_dirent *res = REAL(readdir)(dirp);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n   return res;\n@@ -1948,6 +2148,9 @@ INTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n             __sanitizer_dirent **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir_r, dirp, entry, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(readdir_r)(dirp, entry, result);\n   if (!res) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n@@ -1968,6 +2171,9 @@ INTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n INTERCEPTOR(__sanitizer_dirent64 *, readdir64, void *dirp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir64, dirp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_dirent64 *res = REAL(readdir64)(dirp);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n   return res;\n@@ -1977,6 +2183,9 @@ INTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n             __sanitizer_dirent64 **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir64_r, dirp, entry, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(readdir64_r)(dirp, entry, result);\n   if (!res) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n@@ -2012,10 +2221,13 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n     }\n   }\n \n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   uptr res = REAL(ptrace)(request, pid, addr, data);\n \n   if (!res && data) {\n-    // Note that PEEK* requests assing different meaning to the return value.\n+    // Note that PEEK* requests assign different meaning to the return value.\n     // This function does not handle them (nor does it need to).\n     if (request == ptrace_getregs)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_regs_struct_sz);\n@@ -2025,6 +2237,8 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n     else if (request == ptrace_getsiginfo)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n+    else if (request == ptrace_geteventmsg)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(unsigned long));\n     else if (request == ptrace_getregset) {\n       __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iov->iov_base, iov->iov_len);\n@@ -2058,6 +2272,9 @@ INTERCEPTOR(char *, setlocale, int category, char *locale) {\n INTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getcwd, buf, size);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(getcwd)(buf, size);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n@@ -2071,6 +2288,9 @@ INTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n INTERCEPTOR(char *, get_current_dir_name, int fake) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name, fake);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(get_current_dir_name)(fake);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n@@ -2086,6 +2306,9 @@ INTERCEPTOR(char *, get_current_dir_name, int fake) {\n INTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strtoimax, nptr, endptr, base);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   INTMAX_T res = REAL(strtoimax)(nptr, endptr, base);\n   if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n   return res;\n@@ -2094,6 +2317,9 @@ INTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strtoumax, nptr, endptr, base);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   INTMAX_T res = REAL(strtoumax)(nptr, endptr, base);\n   if (endptr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n   return res;\n@@ -2110,6 +2336,9 @@ INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n INTERCEPTOR(SIZE_T, mbstowcs, wchar_t *dest, const char *src, SIZE_T len) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, mbstowcs, dest, src, len);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(mbstowcs)(dest, src, len);\n   if (res != (SIZE_T) - 1 && dest) {\n     SIZE_T write_cnt = res + (res < len);\n@@ -2124,6 +2353,9 @@ INTERCEPTOR(SIZE_T, mbsrtowcs, wchar_t *dest, const char **src, SIZE_T len,\n   COMMON_INTERCEPTOR_ENTER(ctx, mbsrtowcs, dest, src, len, ps);\n   if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n   if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(mbsrtowcs)(dest, src, len, ps);\n   if (res != (SIZE_T)(-1) && dest && src) {\n     // This function, and several others, may or may not write the terminating\n@@ -2151,6 +2383,9 @@ INTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n     if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n   }\n   if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(mbsnrtowcs)(dest, src, nms, len, ps);\n   if (res != (SIZE_T)(-1) && dest && src) {\n     SIZE_T write_cnt = res + !*src;\n@@ -2168,6 +2403,9 @@ INTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n INTERCEPTOR(SIZE_T, wcstombs, char *dest, const wchar_t *src, SIZE_T len) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wcstombs, dest, src, len);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(wcstombs)(dest, src, len);\n   if (res != (SIZE_T) - 1 && dest) {\n     SIZE_T write_cnt = res + (res < len);\n@@ -2182,6 +2420,9 @@ INTERCEPTOR(SIZE_T, wcsrtombs, char *dest, const wchar_t **src, SIZE_T len,\n   COMMON_INTERCEPTOR_ENTER(ctx, wcsrtombs, dest, src, len, ps);\n   if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n   if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(wcsrtombs)(dest, src, len, ps);\n   if (res != (SIZE_T) - 1 && dest && src) {\n     SIZE_T write_cnt = res + !*src;\n@@ -2207,6 +2448,9 @@ INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n     if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n   }\n   if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(wcsnrtombs)(dest, src, nms, len, ps);\n   if (res != (SIZE_T) - 1 && dest && src) {\n     SIZE_T write_cnt = res + !*src;\n@@ -2224,6 +2468,9 @@ INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n INTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, tcgetattr, fd, termios_p);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(tcgetattr)(fd, termios_p);\n   if (!res && termios_p)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, termios_p, struct_termios_sz);\n@@ -2278,6 +2525,9 @@ INTERCEPTOR(char *, canonicalize_file_name, const char *path) {\n INTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, confstr, name, buf, len);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(confstr)(name, buf, len);\n   if (buf && res)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res < len ? res : len);\n@@ -2292,6 +2542,9 @@ INTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n INTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sched_getaffinity, pid, cpusetsize, mask);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sched_getaffinity)(pid, cpusetsize, mask);\n   if (mask && !res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n   return res;\n@@ -2318,6 +2571,9 @@ INTERCEPTOR(char *, strerror, int errnum) {\n INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(strerror_r)(errnum, buf, buflen);\n   // There are 2 versions of strerror_r:\n   //  * POSIX version returns 0 on success, negative error code on failure,\n@@ -2346,6 +2602,9 @@ INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n INTERCEPTOR(int, __xpg_strerror_r, int errnum, char *buf, SIZE_T buflen) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, __xpg_strerror_r, errnum, buf, buflen);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(__xpg_strerror_r)(errnum, buf, buflen);\n   // This version always returns a null-terminated string.\n   if (buf && buflen)\n@@ -2388,6 +2647,9 @@ INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n   if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n   scandir_filter = filter;\n   scandir_compar = compar;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(scandir)(dirp, namelist, filter ? wrapped_scandir_filter : 0,\n                           compar ? wrapped_scandir_compar : 0);\n   scandir_filter = 0;\n@@ -2437,6 +2699,9 @@ INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n   if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n   scandir64_filter = filter;\n   scandir64_compar = compar;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res =\n       REAL(scandir64)(dirp, namelist, filter ? wrapped_scandir64_filter : 0,\n                       compar ? wrapped_scandir64_compar : 0);\n@@ -2460,6 +2725,9 @@ INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n INTERCEPTOR(int, getgroups, int size, u32 *lst) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgroups, size, lst);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getgroups)(size, lst);\n   if (res && lst) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n   return res;\n@@ -2523,6 +2791,9 @@ INTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, wordexp, s, p, flags);\n   if (s) COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(wordexp)(s, p, flags);\n   if (!res && p) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n@@ -2546,6 +2817,9 @@ INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigwait, set, sig);\n   // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigwait)(set, sig);\n   if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n   return res;\n@@ -2560,6 +2834,9 @@ INTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigwaitinfo, set, info);\n   // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigwaitinfo)(set, info);\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n@@ -2576,6 +2853,9 @@ INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n   COMMON_INTERCEPTOR_ENTER(ctx, sigtimedwait, set, info, timeout);\n   if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n   // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigtimedwait)(set, info, timeout);\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n@@ -2589,6 +2869,9 @@ INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n INTERCEPTOR(int, sigemptyset, __sanitizer_sigset_t *set) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigemptyset, set);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigemptyset)(set);\n   if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n   return res;\n@@ -2597,6 +2880,9 @@ INTERCEPTOR(int, sigemptyset, __sanitizer_sigset_t *set) {\n INTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigfillset, set);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigfillset)(set);\n   if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n   return res;\n@@ -2612,6 +2898,9 @@ INTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n INTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigpending, set);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigpending)(set);\n   if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n   return res;\n@@ -2627,6 +2916,9 @@ INTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sigprocmask, how, set, oldset);\n   // FIXME: read sigset_t when all of sigemptyset, etc are intercepted\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(sigprocmask)(how, set, oldset);\n   if (!res && oldset)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n@@ -2641,6 +2933,9 @@ INTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n INTERCEPTOR(int, backtrace, void **buffer, int size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, backtrace, buffer, size);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(backtrace)(buffer, size);\n   if (res && buffer)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buffer, res * sizeof(*buffer));\n@@ -2652,6 +2947,9 @@ INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n   COMMON_INTERCEPTOR_ENTER(ctx, backtrace_symbols, buffer, size);\n   if (buffer && size)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, size * sizeof(*buffer));\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char **res = REAL(backtrace_symbols)(buffer, size);\n   if (res && size) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, size * sizeof(*res));\n@@ -2757,13 +3055,19 @@ INTERCEPTOR(int, statfs, char *path, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, statfs, path, buf);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(statfs)(path, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n   return res;\n }\n INTERCEPTOR(int, fstatfs, int fd, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fstatfs, fd, buf);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fstatfs)(fd, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n   return res;\n@@ -2780,13 +3084,19 @@ INTERCEPTOR(int, statfs64, char *path, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, statfs64, path, buf);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(statfs64)(path, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n   return res;\n }\n INTERCEPTOR(int, fstatfs64, int fd, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fstatfs64, fd, buf);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fstatfs64)(fd, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n   return res;\n@@ -2803,13 +3113,19 @@ INTERCEPTOR(int, statvfs, char *path, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, statvfs, path, buf);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(statvfs)(path, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n   return res;\n }\n INTERCEPTOR(int, fstatvfs, int fd, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs, fd, buf);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fstatvfs)(fd, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n   return res;\n@@ -2826,13 +3142,19 @@ INTERCEPTOR(int, statvfs64, char *path, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, statvfs64, path, buf);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(statvfs64)(path, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n   return res;\n }\n INTERCEPTOR(int, fstatvfs64, int fd, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs64, fd, buf);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(fstatvfs64)(fd, buf);\n   if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n   return res;\n@@ -2857,7 +3179,7 @@ INTERCEPTOR(int, initgroups, char *user, u32 group) {\n #define INIT_INITGROUPS\n #endif\n \n-#if SANITIZER_INTERCEPT_ETHER\n+#if SANITIZER_INTERCEPT_ETHER_NTOA_ATON\n INTERCEPTOR(char *, ether_ntoa, __sanitizer_ether_addr *addr) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa, addr);\n@@ -2874,10 +3196,21 @@ INTERCEPTOR(__sanitizer_ether_addr *, ether_aton, char *buf) {\n   if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, sizeof(*res));\n   return res;\n }\n+#define INIT_ETHER_NTOA_ATON             \\\n+  COMMON_INTERCEPT_FUNCTION(ether_ntoa); \\\n+  COMMON_INTERCEPT_FUNCTION(ether_aton);\n+#else\n+#define INIT_ETHER_NTOA_ATON\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ETHER_HOST\n INTERCEPTOR(int, ether_ntohost, char *hostname, __sanitizer_ether_addr *addr) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_ntohost, hostname, addr);\n   if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(ether_ntohost)(hostname, addr);\n   if (!res && hostname)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n@@ -2888,6 +3221,9 @@ INTERCEPTOR(int, ether_hostton, char *hostname, __sanitizer_ether_addr *addr) {\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_hostton, hostname, addr);\n   if (hostname)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(ether_hostton)(hostname, addr);\n   if (!res && addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n   return res;\n@@ -2897,6 +3233,9 @@ INTERCEPTOR(int, ether_line, char *line, __sanitizer_ether_addr *addr,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_line, line, addr, hostname);\n   if (line) COMMON_INTERCEPTOR_READ_RANGE(ctx, line, REAL(strlen)(line) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(ether_line)(line, addr, hostname);\n   if (!res) {\n     if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n@@ -2905,21 +3244,22 @@ INTERCEPTOR(int, ether_line, char *line, __sanitizer_ether_addr *addr,\n   }\n   return res;\n }\n-#define INIT_ETHER                          \\\n-  COMMON_INTERCEPT_FUNCTION(ether_ntoa);    \\\n-  COMMON_INTERCEPT_FUNCTION(ether_aton);    \\\n+#define INIT_ETHER_HOST                     \\\n   COMMON_INTERCEPT_FUNCTION(ether_ntohost); \\\n   COMMON_INTERCEPT_FUNCTION(ether_hostton); \\\n   COMMON_INTERCEPT_FUNCTION(ether_line);\n #else\n-#define INIT_ETHER\n+#define INIT_ETHER_HOST\n #endif\n \n #if SANITIZER_INTERCEPT_ETHER_R\n INTERCEPTOR(char *, ether_ntoa_r, __sanitizer_ether_addr *addr, char *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa_r, addr, buf);\n   if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(ether_ntoa_r)(addr, buf);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n@@ -2929,6 +3269,9 @@ INTERCEPTOR(__sanitizer_ether_addr *, ether_aton_r, char *buf,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ether_aton_r, buf, addr);\n   if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_ether_addr *res = REAL(ether_aton_r)(buf, addr);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(*res));\n   return res;\n@@ -2944,6 +3287,9 @@ INTERCEPTOR(__sanitizer_ether_addr *, ether_aton_r, char *buf,\n INTERCEPTOR(int, shmctl, int shmid, int cmd, void *buf) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, shmctl, shmid, cmd, buf);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(shmctl)(shmid, cmd, buf);\n   if (res >= 0) {\n     unsigned sz = 0;\n@@ -2966,6 +3312,9 @@ INTERCEPTOR(int, shmctl, int shmid, int cmd, void *buf) {\n INTERCEPTOR(int, random_r, void *buf, u32 *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, random_r, buf, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(random_r)(buf, result);\n   if (!res && result)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n@@ -2976,16 +3325,33 @@ INTERCEPTOR(int, random_r, void *buf, u32 *result) {\n #define INIT_RANDOM_R\n #endif\n \n-#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET || \\\n-    SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED\n-#define INTERCEPTOR_PTHREAD_ATTR_GET(what, sz)                      \\\n-  INTERCEPTOR(int, pthread_attr_get##what, void *attr, void *r) {   \\\n-    void *ctx;                                                      \\\n-    COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_get##what, attr, r); \\\n-    int res = REAL(pthread_attr_get##what)(attr, r);                \\\n-    if (!res && r) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, r, sz);      \\\n-    return res;                                                     \\\n+// FIXME: under ASan the REAL() call below may write to freed memory and corrupt\n+// its metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET ||              \\\n+    SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED || \\\n+    SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GET ||         \\\n+    SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GET ||        \\\n+    SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GET ||          \\\n+    SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GET\n+#define INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(fn, sz)            \\\n+  INTERCEPTOR(int, fn, void *attr, void *r) {                  \\\n+    void *ctx;                                                 \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, fn, attr, r);                \\\n+    int res = REAL(fn)(attr, r);                               \\\n+    if (!res && r) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, r, sz); \\\n+    return res;                                                \\\n   }\n+#define INTERCEPTOR_PTHREAD_ATTR_GET(what, sz) \\\n+  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_attr_get##what, sz)\n+#define INTERCEPTOR_PTHREAD_MUTEXATTR_GET(what, sz) \\\n+  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_mutexattr_get##what, sz)\n+#define INTERCEPTOR_PTHREAD_RWLOCKATTR_GET(what, sz) \\\n+  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_rwlockattr_get##what, sz)\n+#define INTERCEPTOR_PTHREAD_CONDATTR_GET(what, sz) \\\n+  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_condattr_get##what, sz)\n+#define INTERCEPTOR_PTHREAD_BARRIERATTR_GET(what, sz) \\\n+  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_barrierattr_get##what, sz)\n #endif\n \n #if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET\n@@ -2998,6 +3364,9 @@ INTERCEPTOR_PTHREAD_ATTR_GET(stacksize, sizeof(SIZE_T))\n INTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getstack, attr, addr, size);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(pthread_attr_getstack)(attr, addr, size);\n   if (!res) {\n     if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n@@ -3044,6 +3413,9 @@ INTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getaffinity_np, attr, cpusetsize,\n                            cpuset);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(pthread_attr_getaffinity_np)(attr, cpusetsize, cpuset);\n   if (!res && cpusetsize && cpuset)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cpuset, cpusetsize);\n@@ -3056,13 +3428,104 @@ INTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n #define INIT_PTHREAD_ATTR_GETAFFINITY_NP\n #endif\n \n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(pshared, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETPSHARED \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getpshared);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETPSHARED\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(type, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETTYPE \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_gettype);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETTYPE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(protocol, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprotocol);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(prioceiling, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprioceiling);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETROBUST \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETROBUST\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP\n+INTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust_np, sizeof(int))\n+#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust_np);\n+#else\n+#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED\n+INTERCEPTOR_PTHREAD_RWLOCKATTR_GET(pshared, sizeof(int))\n+#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getpshared);\n+#else\n+#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP\n+INTERCEPTOR_PTHREAD_RWLOCKATTR_GET(kind_np, sizeof(int))\n+#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getkind_np);\n+#else\n+#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED\n+INTERCEPTOR_PTHREAD_CONDATTR_GET(pshared, sizeof(int))\n+#define INIT_PTHREAD_CONDATTR_GETPSHARED \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getpshared);\n+#else\n+#define INIT_PTHREAD_CONDATTR_GETPSHARED\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK\n+INTERCEPTOR_PTHREAD_CONDATTR_GET(clock, sizeof(int))\n+#define INIT_PTHREAD_CONDATTR_GETCLOCK \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getclock);\n+#else\n+#define INIT_PTHREAD_CONDATTR_GETCLOCK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED\n+INTERCEPTOR_PTHREAD_BARRIERATTR_GET(pshared, sizeof(int)) // !mac !android\n+#define INIT_PTHREAD_BARRIERATTR_GETPSHARED \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_barrierattr_getpshared);\n+#else\n+#define INIT_PTHREAD_BARRIERATTR_GETPSHARED\n+#endif\n+\n #if SANITIZER_INTERCEPT_TMPNAM\n INTERCEPTOR(char *, tmpnam, char *s) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, tmpnam, s);\n   char *res = REAL(tmpnam)(s);\n   if (res) {\n     if (s)\n+      // FIXME: under ASan the call below may write to freed memory and corrupt\n+      // its metadata. See\n+      // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n     else\n       COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n@@ -3078,6 +3541,9 @@ INTERCEPTOR(char *, tmpnam, char *s) {\n INTERCEPTOR(char *, tmpnam_r, char *s) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, tmpnam_r, s);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(tmpnam_r)(s);\n   if (res && s) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n   return res;\n@@ -3118,20 +3584,29 @@ INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n INTERCEPTOR(void, sincos, double x, double *sin, double *cos) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sincos, x, sin, cos);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   REAL(sincos)(x, sin, cos);\n   if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n   if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n }\n INTERCEPTOR(void, sincosf, float x, float *sin, float *cos) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sincosf, x, sin, cos);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   REAL(sincosf)(x, sin, cos);\n   if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n   if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n }\n INTERCEPTOR(void, sincosl, long double x, long double *sin, long double *cos) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sincosl, x, sin, cos);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   REAL(sincosl)(x, sin, cos);\n   if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n   if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n@@ -3148,20 +3623,29 @@ INTERCEPTOR(void, sincosl, long double x, long double *sin, long double *cos) {\n INTERCEPTOR(double, remquo, double x, double y, int *quo) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, remquo, x, y, quo);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   double res = REAL(remquo)(x, y, quo);\n   if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n   return res;\n }\n INTERCEPTOR(float, remquof, float x, float y, int *quo) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, remquof, x, y, quo);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   float res = REAL(remquof)(x, y, quo);\n   if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n   return res;\n }\n INTERCEPTOR(long double, remquol, long double x, long double y, int *quo) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, remquol, x, y, quo);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   long double res = REAL(remquol)(x, y, quo);\n   if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n   return res;\n@@ -3209,43 +3693,63 @@ INTERCEPTOR(long double, lgammal, long double x) {\n INTERCEPTOR(double, lgamma_r, double x, int *signp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, lgamma_r, x, signp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   double res = REAL(lgamma_r)(x, signp);\n   if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n   return res;\n }\n INTERCEPTOR(float, lgammaf_r, float x, int *signp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, lgammaf_r, x, signp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   float res = REAL(lgammaf_r)(x, signp);\n   if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n   return res;\n }\n+#define INIT_LGAMMA_R                   \\\n+  COMMON_INTERCEPT_FUNCTION(lgamma_r);  \\\n+  COMMON_INTERCEPT_FUNCTION(lgammaf_r);\n+#else\n+#define INIT_LGAMMA_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LGAMMAL_R\n INTERCEPTOR(long double, lgammal_r, long double x, int *signp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, lgammal_r, x, signp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   long double res = REAL(lgammal_r)(x, signp);\n   if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n   return res;\n }\n-#define INIT_LGAMMA_R                   \\\n-  COMMON_INTERCEPT_FUNCTION(lgamma_r);  \\\n-  COMMON_INTERCEPT_FUNCTION(lgammaf_r); \\\n-  COMMON_INTERCEPT_FUNCTION(lgammal_r);\n+#define INIT_LGAMMAL_R COMMON_INTERCEPT_FUNCTION(lgammal_r);\n #else\n-#define INIT_LGAMMA_R\n+#define INIT_LGAMMAL_R\n #endif\n \n #if SANITIZER_INTERCEPT_DRAND48_R\n INTERCEPTOR(int, drand48_r, void *buffer, double *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, drand48_r, buffer, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(drand48_r)(buffer, result);\n   if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n }\n INTERCEPTOR(int, lrand48_r, void *buffer, long *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, lrand48_r, buffer, result);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(lrand48_r)(buffer, result);\n   if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n   return res;\n@@ -3273,6 +3777,9 @@ INTERCEPTOR(int, rand_r, unsigned *seedp) {\n INTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getline, lineptr, n, stream);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(getline)(lineptr, n, stream);\n   if (res > 0) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n@@ -3281,20 +3788,28 @@ INTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n   }\n   return res;\n }\n-INTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n+INTERCEPTOR(SSIZE_T, __getdelim, char **lineptr, SIZE_T *n, int delim,\n             void *stream) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, getdelim, lineptr, n, delim, stream);\n-  SSIZE_T res = REAL(getdelim)(lineptr, n, delim, stream);\n+  COMMON_INTERCEPTOR_ENTER(ctx, __getdelim, lineptr, n, delim, stream);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n+  SSIZE_T res = REAL(__getdelim)(lineptr, n, delim, stream);\n   if (res > 0) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n   }\n   return res;\n }\n-#define INIT_GETLINE                  \\\n-  COMMON_INTERCEPT_FUNCTION(getline); \\\n+INTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n+            void *stream) {\n+  return __getdelim(lineptr, n, delim, stream);\n+}\n+#define INIT_GETLINE                     \\\n+  COMMON_INTERCEPT_FUNCTION(getline);    \\\n+  COMMON_INTERCEPT_FUNCTION(__getdelim); \\\n   COMMON_INTERCEPT_FUNCTION(getdelim);\n #else\n #define INIT_GETLINE\n@@ -3313,6 +3828,9 @@ INTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n   if (outbytesleft)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, outbytesleft, sizeof(*outbytesleft));\n   void *outbuf_orig = outbuf ? *outbuf : 0;\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SIZE_T res = REAL(iconv)(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n   if (res != (SIZE_T) - 1 && outbuf && *outbuf > outbuf_orig) {\n     SIZE_T sz = (char *)*outbuf - (char *)outbuf_orig;\n@@ -3329,6 +3847,9 @@ INTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n INTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, times, tms);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_clock_t res = REAL(times)(tms);\n   if (res != (__sanitizer_clock_t)-1 && tms)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tms, struct_tms_sz);\n@@ -3345,7 +3866,11 @@ INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr, arg);\n   void *res = REAL(__tls_get_addr)(arg);\n-  DTLS_on_tls_get_addr(arg, res);\n+  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res);\n+  if (dtv) {\n+    // New DTLS block has been allocated.\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n+  }\n   return res;\n }\n #else\n@@ -3357,6 +3882,9 @@ INTERCEPTOR(SSIZE_T, listxattr, const char *path, char *list, SIZE_T size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, listxattr, path, list, size);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(listxattr)(path, list, size);\n   // Here and below, size == 0 is a special case where nothing is written to the\n   // buffer, and res contains the desired buffer size.\n@@ -3367,13 +3895,19 @@ INTERCEPTOR(SSIZE_T, llistxattr, const char *path, char *list, SIZE_T size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, llistxattr, path, list, size);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(llistxattr)(path, list, size);\n   if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n   return res;\n }\n INTERCEPTOR(SSIZE_T, flistxattr, int fd, char *list, SIZE_T size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, flistxattr, fd, list, size);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(flistxattr)(fd, list, size);\n   if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n   return res;\n@@ -3393,6 +3927,9 @@ INTERCEPTOR(SSIZE_T, getxattr, const char *path, const char *name, char *value,\n   COMMON_INTERCEPTOR_ENTER(ctx, getxattr, path, name, value, size);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n   if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(getxattr)(path, name, value, size);\n   if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n   return res;\n@@ -3403,6 +3940,9 @@ INTERCEPTOR(SSIZE_T, lgetxattr, const char *path, const char *name, char *value,\n   COMMON_INTERCEPTOR_ENTER(ctx, lgetxattr, path, name, value, size);\n   if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n   if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(lgetxattr)(path, name, value, size);\n   if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n   return res;\n@@ -3412,6 +3952,9 @@ INTERCEPTOR(SSIZE_T, fgetxattr, int fd, const char *name, char *value,\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fgetxattr, fd, name, value, size);\n   if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   SSIZE_T res = REAL(fgetxattr)(fd, name, value, size);\n   if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n   return res;\n@@ -3428,6 +3971,9 @@ INTERCEPTOR(SSIZE_T, fgetxattr, int fd, const char *name, char *value,\n INTERCEPTOR(int, getresuid, void *ruid, void *euid, void *suid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getresuid, ruid, euid, suid);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getresuid)(ruid, euid, suid);\n   if (res >= 0) {\n     if (ruid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ruid, uid_t_sz);\n@@ -3439,6 +3985,9 @@ INTERCEPTOR(int, getresuid, void *ruid, void *euid, void *suid) {\n INTERCEPTOR(int, getresgid, void *rgid, void *egid, void *sgid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getresgid, rgid, egid, sgid);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getresgid)(rgid, egid, sgid);\n   if (res >= 0) {\n     if (rgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rgid, gid_t_sz);\n@@ -3461,6 +4010,9 @@ INTERCEPTOR(int, getresgid, void *rgid, void *egid, void *sgid) {\n INTERCEPTOR(int, getifaddrs, __sanitizer_ifaddrs **ifap) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getifaddrs, ifap);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(getifaddrs)(ifap);\n   if (res == 0 && ifap) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifap, sizeof(void *));\n@@ -3494,6 +4046,9 @@ INTERCEPTOR(int, getifaddrs, __sanitizer_ifaddrs **ifap) {\n INTERCEPTOR(char *, if_indextoname, unsigned int ifindex, char* ifname) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, if_indextoname, ifindex, ifname);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   char *res = REAL(if_indextoname)(ifindex, ifname);\n   if (res && ifname)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n@@ -3519,6 +4074,9 @@ INTERCEPTOR(int, capget, void *hdrp, void *datap) {\n   COMMON_INTERCEPTOR_ENTER(ctx, capget, hdrp, datap);\n   if (hdrp)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(capget)(hdrp, datap);\n   if (res == 0 && datap)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datap, __user_cap_data_struct_sz);\n@@ -3617,6 +4175,9 @@ INTERCEPTOR(void *, __bzero, void *block, uptr size) {\n INTERCEPTOR(int, ftime, __sanitizer_timeb *tp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, ftime, tp);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(ftime)(tp);\n   if (tp)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, sizeof(*tp));\n@@ -3632,6 +4193,9 @@ INTERCEPTOR(void, xdrmem_create, __sanitizer_XDR *xdrs, uptr addr,\n             unsigned size, int op) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, xdrmem_create, xdrs, addr, size, op);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   REAL(xdrmem_create)(xdrs, addr, size, op);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n   if (op == __sanitizer_XDR_ENCODE) {\n@@ -3644,10 +4208,16 @@ INTERCEPTOR(void, xdrmem_create, __sanitizer_XDR *xdrs, uptr addr,\n INTERCEPTOR(void, xdrstdio_create, __sanitizer_XDR *xdrs, void *file, int op) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, xdrstdio_create, xdrs, file, op);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   REAL(xdrstdio_create)(xdrs, file, op);\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n }\n \n+// FIXME: under ASan the call below may write to freed memory and corrupt\n+// its metadata. See\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n #define XDR_INTERCEPTOR(F, T)                             \\\n   INTERCEPTOR(int, F, __sanitizer_XDR *xdrs, T *p) {      \\\n     void *ctx;                                            \\\n@@ -3699,6 +4269,9 @@ INTERCEPTOR(int, xdr_bytes, __sanitizer_XDR *xdrs, char **p, unsigned *sizep,\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, sizep, sizeof(*sizep));\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, *sizep);\n   }\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(xdr_bytes)(xdrs, p, sizep, maxsize);\n   if (p && sizep && xdrs->x_op == __sanitizer_XDR_DECODE) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n@@ -3716,6 +4289,9 @@ INTERCEPTOR(int, xdr_string, __sanitizer_XDR *xdrs, char **p,\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n   }\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   int res = REAL(xdr_string)(xdrs, p, maxsize);\n   if (p && xdrs->x_op == __sanitizer_XDR_DECODE) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n@@ -3765,6 +4341,9 @@ INTERCEPTOR(void *, tsearch, void *key, void **rootp,\n             int (*compar)(const void *, const void *)) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, tsearch, key, rootp, compar);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   void *res = REAL(tsearch)(key, rootp, compar);\n   if (res && *(void **)res == key)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(void *));\n@@ -3915,6 +4494,9 @@ INTERCEPTOR(__sanitizer_FILE *, freopen64, const char *path, const char *mode,\n INTERCEPTOR(__sanitizer_FILE *, open_memstream, char **ptr, SIZE_T *sizeloc) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, open_memstream, ptr, sizeloc);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_FILE *res = REAL(open_memstream)(ptr, sizeloc);\n   if (res) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n@@ -3943,6 +4525,9 @@ INTERCEPTOR(__sanitizer_FILE *, fmemopen, void *buf, SIZE_T size,\n             const char *mode) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, fmemopen, buf, size, mode);\n+  // FIXME: under ASan the call below may write to freed memory and corrupt\n+  // its metadata. See\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=321.\n   __sanitizer_FILE *res = REAL(fmemopen)(buf, size, mode);\n   if (res) unpoison_file(res);\n   return res;\n@@ -4034,6 +4619,114 @@ INTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n #define INIT_FCLOSE\n #endif\n \n+#if SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\n+INTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlopen, filename, flag);\n+  void *res = REAL(dlopen)(filename, flag);\n+  COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, dlclose, void *handle) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlclose, handle);\n+  int res = REAL(dlclose)(handle);\n+  COMMON_INTERCEPTOR_LIBRARY_UNLOADED();\n+  return res;\n+}\n+#define INIT_DLOPEN_DLCLOSE          \\\n+  COMMON_INTERCEPT_FUNCTION(dlopen); \\\n+  COMMON_INTERCEPT_FUNCTION(dlclose);\n+#else\n+#define INIT_DLOPEN_DLCLOSE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETPASS\n+INTERCEPTOR(char *, getpass, const char *prompt) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getpass, prompt);\n+  if (prompt)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, prompt, REAL(strlen)(prompt)+1);\n+  char *res = REAL(getpass)(prompt);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res)+1);\n+  return res;\n+}\n+\n+#define INIT_GETPASS COMMON_INTERCEPT_FUNCTION(getpass);\n+#else\n+#define INIT_GETPASS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TIMERFD\n+INTERCEPTOR(int, timerfd_settime, int fd, int flags, void *new_value,\n+            void *old_value) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_settime, fd, flags, new_value,\n+                           old_value);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerspec_sz);\n+  int res = REAL(timerfd_settime)(fd, flags, new_value, old_value);\n+  if (res != -1 && old_value)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerspec_sz);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, timerfd_gettime, int fd, void *curr_value) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_gettime, fd, curr_value);\n+  int res = REAL(timerfd_gettime)(fd, curr_value);\n+  if (res != -1 && curr_value)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerspec_sz);\n+  return res;\n+}\n+#define INIT_TIMERFD                          \\\n+  COMMON_INTERCEPT_FUNCTION(timerfd_settime); \\\n+  COMMON_INTERCEPT_FUNCTION(timerfd_gettime);\n+#else\n+#define INIT_TIMERFD\n+#endif\n+\n+#if SANITIZER_INTERCEPT_MLOCKX\n+// Linux kernel has a bug that leads to kernel deadlock if a process\n+// maps TBs of memory and then calls mlock().\n+static void MlockIsUnsupported() {\n+  static atomic_uint8_t printed;\n+  if (atomic_exchange(&printed, 1, memory_order_relaxed))\n+    return;\n+  VPrintf(1, \"INFO: %s ignores mlock/mlockall/munlock/munlockall\\n\",\n+          SanitizerToolName);\n+}\n+\n+INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, munlock, const void *addr, uptr len) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, mlockall, int flags) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+INTERCEPTOR(int, munlockall, void) {\n+  MlockIsUnsupported();\n+  return 0;\n+}\n+\n+#define INIT_MLOCKX                                                            \\\n+  COMMON_INTERCEPT_FUNCTION(mlock);                                            \\\n+  COMMON_INTERCEPT_FUNCTION(munlock);                                          \\\n+  COMMON_INTERCEPT_FUNCTION(mlockall);                                         \\\n+  COMMON_INTERCEPT_FUNCTION(munlockall);\n+\n+#else\n+#define INIT_MLOCKX\n+#endif  // SANITIZER_INTERCEPT_MLOCKX\n+\n static void InitializeCommonInterceptors() {\n   static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n   interceptor_metadata_map = new((void *)&metadata_mem) MetadataHashMap();\n@@ -4085,6 +4778,9 @@ static void InitializeCommonInterceptors() {\n   INIT_GETSOCKNAME;\n   INIT_GETHOSTBYNAME;\n   INIT_GETHOSTBYNAME_R;\n+  INIT_GETHOSTBYNAME2_R;\n+  INIT_GETHOSTBYADDR_R;\n+  INIT_GETHOSTENT_R;\n   INIT_GETSOCKOPT;\n   INIT_ACCEPT;\n   INIT_ACCEPT4;\n@@ -4136,13 +4832,25 @@ static void InitializeCommonInterceptors() {\n   INIT_STATVFS;\n   INIT_STATVFS64;\n   INIT_INITGROUPS;\n-  INIT_ETHER;\n+  INIT_ETHER_NTOA_ATON;\n+  INIT_ETHER_HOST;\n   INIT_ETHER_R;\n   INIT_SHMCTL;\n   INIT_RANDOM_R;\n   INIT_PTHREAD_ATTR_GET;\n   INIT_PTHREAD_ATTR_GETINHERITSCHED;\n   INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n+  INIT_PTHREAD_MUTEXATTR_GETPSHARED;\n+  INIT_PTHREAD_MUTEXATTR_GETTYPE;\n+  INIT_PTHREAD_MUTEXATTR_GETPROTOCOL;\n+  INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING;\n+  INIT_PTHREAD_MUTEXATTR_GETROBUST;\n+  INIT_PTHREAD_MUTEXATTR_GETROBUST_NP;\n+  INIT_PTHREAD_RWLOCKATTR_GETPSHARED;\n+  INIT_PTHREAD_RWLOCKATTR_GETKIND_NP;\n+  INIT_PTHREAD_CONDATTR_GETPSHARED;\n+  INIT_PTHREAD_CONDATTR_GETCLOCK;\n+  INIT_PTHREAD_BARRIERATTR_GETPSHARED;\n   INIT_TMPNAM;\n   INIT_TMPNAM_R;\n   INIT_TEMPNAM;\n@@ -4151,6 +4859,7 @@ static void InitializeCommonInterceptors() {\n   INIT_REMQUO;\n   INIT_LGAMMA;\n   INIT_LGAMMA_R;\n+  INIT_LGAMMAL_R;\n   INIT_DRAND48_R;\n   INIT_RAND_R;\n   INIT_GETLINE;\n@@ -4175,4 +4884,8 @@ static void InitializeCommonInterceptors() {\n   INIT_OBSTACK;\n   INIT_FFLUSH;\n   INIT_FCLOSE;\n+  INIT_DLOPEN_DLCLOSE;\n+  INIT_GETPASS;\n+  INIT_TIMERFD;\n+  INIT_MLOCKX;\n }"}, {"sha": "26cbe68dc993a9651d79a419955f0bba020cd245", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -457,6 +457,9 @@ static int printf_get_value_size(PrintfDirective *dir) {\n       case 8:                                                      \\\n         va_arg(*aq, double);                                       \\\n         break;                                                     \\\n+      case 12:                                                     \\\n+        va_arg(*aq, long double);                                  \\\n+        break;                                                     \\\n       case 16:                                                     \\\n         va_arg(*aq, long double);                                  \\\n         break;                                                     \\"}, {"sha": "ca264d899a72c05f18d31a1a83bd11e368bc2139", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -527,7 +527,7 @@ static bool ioctl_decode(unsigned req, ioctl_desc *desc) {\n   desc->name = \"<DECODED_IOCTL>\";\n   desc->size = IOC_SIZE(req);\n   // Sanity check.\n-  if (desc->size > 1024) return false;\n+  if (desc->size > 0xFFFF) return false;\n   unsigned dir = IOC_DIR(req);\n   switch (dir) {\n     case IOC_NONE:\n@@ -545,10 +545,10 @@ static bool ioctl_decode(unsigned req, ioctl_desc *desc) {\n     default:\n       return false;\n   }\n-  if (desc->type != IOC_NONE && desc->size == 0) return false;\n-  char id = IOC_TYPE(req);\n+  // Size can be 0 iff type is NONE.\n+  if ((desc->type == IOC_NONE) != (desc->size == 0)) return false;\n   // Sanity check.\n-  if (!(id >= 'a' && id <= 'z') && !(id >= 'A' && id <= 'Z')) return false;\n+  if (IOC_TYPE(req) == 0) return false;\n   return true;\n }\n "}, {"sha": "b5251444f0fa6f4ed070f57b34278a7408f4b87f", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -11,6 +11,8 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n@@ -39,4 +41,32 @@ bool ColorizeReports() {\n   return internal_strcmp(flag, \"always\") == 0 ||\n          (internal_strcmp(flag, \"auto\") == 0 && PrintsToTtyCached());\n }\n+\n+static void (*sandboxing_callback)();\n+void SetSandboxingCallback(void (*f)()) {\n+  sandboxing_callback = f;\n+}\n+\n+void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n+  if (!common_flags()->print_summary)\n+    return;\n+  AddressInfo ai;\n+#if !SANITIZER_GO\n+  if (stack->size > 0 && Symbolizer::GetOrInit()->CanReturnFileLineInfo()) {\n+    // Currently, we include the first stack frame into the report summary.\n+    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n+    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n+    Symbolizer::GetOrInit()->SymbolizePC(pc, &ai, 1);\n+  }\n+#endif\n+  ReportErrorSummary(error_type, ai.file, ai.line, ai.function);\n+}\n+\n }  // namespace __sanitizer\n+\n+void NOINLINE\n+__sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args) {\n+  PrepareForSandboxing(args);\n+  if (sandboxing_callback)\n+    sandboxing_callback();\n+}"}, {"sha": "24e1b7ec45294795e7ad38614deb973935064e59", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -829,6 +829,7 @@ POST_SYSCALL(stat)(long res, const void *filename, void *statbuf) {\n   }\n }\n \n+#if !SANITIZER_ANDROID\n PRE_SYSCALL(statfs)(const void *path, void *buf) {\n   if (path)\n     PRE_READ(path, __sanitizer::internal_strlen((const char *)path) + 1);\n@@ -866,6 +867,7 @@ POST_SYSCALL(fstatfs64)(long res, long fd, long sz, void *buf) {\n     if (buf) POST_WRITE(buf, struct_statfs64_sz);\n   }\n }\n+#endif // !SANITIZER_ANDROID\n \n PRE_SYSCALL(lstat)(const void *filename, void *statbuf) {\n   if (filename)\n@@ -1322,13 +1324,13 @@ PRE_SYSCALL(io_submit)(long ctx_id, long nr, __sanitizer_iocb **iocbpp) {\n     } else if (op == iocb_cmd_pread && buf && len) {\n       POST_WRITE(buf, len);\n     } else if (op == iocb_cmd_pwritev) {\n-      __sanitizer_iovec *iovec = (__sanitizer_iovec*)iocbpp[i]->aio_buf;\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)buf;\n       for (uptr v = 0; v < len; v++)\n-        PRE_READ(iovec[i].iov_base, iovec[i].iov_len);\n+        PRE_READ(iovec[v].iov_base, iovec[v].iov_len);\n     } else if (op == iocb_cmd_preadv) {\n-      __sanitizer_iovec *iovec = (__sanitizer_iovec*)iocbpp[i]->aio_buf;\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)buf;\n       for (uptr v = 0; v < len; v++)\n-        POST_WRITE(iovec[i].iov_base, iovec[i].iov_len);\n+        POST_WRITE(iovec[v].iov_base, iovec[v].iov_len);\n     }\n     // See comment in io_getevents.\n     COMMON_SYSCALL_RELEASE(data);\n@@ -2293,7 +2295,7 @@ PRE_SYSCALL(ni_syscall)() {}\n POST_SYSCALL(ni_syscall)(long res) {}\n \n PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n-#if defined(__i386) || defined (__x86_64)\n+#if !SANITIZER_ANDROID && (defined(__i386) || defined (__x86_64))\n   if (data) {\n     if (request == ptrace_setregs) {\n       PRE_READ((void *)data, struct_user_regs_struct_sz);\n@@ -2312,7 +2314,7 @@ PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n }\n \n POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {\n-#if defined(__i386) || defined (__x86_64)\n+#if !SANITIZER_ANDROID && (defined(__i386) || defined (__x86_64))\n   if (res >= 0 && data) {\n     // Note that this is different from the interceptor in\n     // sanitizer_common_interceptors.inc."}, {"sha": "b88e9e7ed0a8eef9ed66bb1440c0e4db5b92d3af", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage.cc", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8ee40544aef309d4225852dda191bf0f986f761/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8ee40544aef309d4225852dda191bf0f986f761/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc?ref=e8ee40544aef309d4225852dda191bf0f986f761", "patch": "@@ -1,214 +0,0 @@\n-//===-- sanitizer_coverage.cc ---------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Sanitizer Coverage.\n-// This file implements run-time support for a poor man's coverage tool.\n-//\n-// Compiler instrumentation:\n-// For every interesting basic block the compiler injects the following code:\n-// if (*Guard) {\n-//    __sanitizer_cov();\n-//    *Guard = 1;\n-// }\n-// It's fine to call __sanitizer_cov more than once for a given block.\n-//\n-// Run-time:\n-//  - __sanitizer_cov(): record that we've executed the PC (GET_CALLER_PC).\n-//  - __sanitizer_cov_dump: dump the coverage data to disk.\n-//  For every module of the current process that has coverage data\n-//  this will create a file module_name.PID.sancov. The file format is simple:\n-//  it's just a sorted sequence of 4-byte offsets in the module.\n-//\n-// Eventually, this coverage implementation should be obsoleted by a more\n-// powerful general purpose Clang/LLVM coverage instrumentation.\n-// Consider this implementation as prototype.\n-//\n-// FIXME: support (or at least test with) dlclose.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_allocator_internal.h\"\n-#include \"sanitizer_common.h\"\n-#include \"sanitizer_libc.h\"\n-#include \"sanitizer_mutex.h\"\n-#include \"sanitizer_procmaps.h\"\n-#include \"sanitizer_stacktrace.h\"\n-#include \"sanitizer_flags.h\"\n-\n-atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n-\n-// pc_array is the array containing the covered PCs.\n-// To make the pc_array thread- and async-signal-safe it has to be large enough.\n-// 128M counters \"ought to be enough for anybody\" (4M on 32-bit).\n-// pc_array is allocated with MmapNoReserveOrDie and so it uses only as\n-// much RAM as it really needs.\n-static const uptr kPcArraySize = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n-static uptr *pc_array;\n-static atomic_uintptr_t pc_array_index;\n-\n-static bool cov_sandboxed = false;\n-static int cov_fd = kInvalidFd;\n-static unsigned int cov_max_block_size = 0;\n-\n-namespace __sanitizer {\n-\n-// Simply add the pc into the vector under lock. If the function is called more\n-// than once for a given PC it will be inserted multiple times, which is fine.\n-static void CovAdd(uptr pc) {\n-  if (!pc_array) return;\n-  uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n-  CHECK_LT(idx, kPcArraySize);\n-  pc_array[idx] = pc;\n-}\n-\n-void CovInit() {\n-  pc_array = reinterpret_cast<uptr *>(\n-      MmapNoReserveOrDie(sizeof(uptr) * kPcArraySize, \"CovInit\"));\n-}\n-\n-static inline bool CompareLess(const uptr &a, const uptr &b) {\n-  return a < b;\n-}\n-\n-// Block layout for packed file format: header, followed by module name (no\n-// trailing zero), followed by data blob.\n-struct CovHeader {\n-  int pid;\n-  unsigned int module_name_length;\n-  unsigned int data_length;\n-};\n-\n-static void CovWritePacked(int pid, const char *module, const void *blob,\n-                           unsigned int blob_size) {\n-  CHECK_GE(cov_fd, 0);\n-  unsigned module_name_length = internal_strlen(module);\n-  CovHeader header = {pid, module_name_length, blob_size};\n-\n-  if (cov_max_block_size == 0) {\n-    // Writing to a file. Just go ahead.\n-    internal_write(cov_fd, &header, sizeof(header));\n-    internal_write(cov_fd, module, module_name_length);\n-    internal_write(cov_fd, blob, blob_size);\n-  } else {\n-    // Writing to a socket. We want to split the data into appropriately sized\n-    // blocks.\n-    InternalScopedBuffer<char> block(cov_max_block_size);\n-    CHECK_EQ((uptr)block.data(), (uptr)(CovHeader *)block.data());\n-    uptr header_size_with_module = sizeof(header) + module_name_length;\n-    CHECK_LT(header_size_with_module, cov_max_block_size);\n-    unsigned int max_payload_size =\n-        cov_max_block_size - header_size_with_module;\n-    char *block_pos = block.data();\n-    internal_memcpy(block_pos, &header, sizeof(header));\n-    block_pos += sizeof(header);\n-    internal_memcpy(block_pos, module, module_name_length);\n-    block_pos += module_name_length;\n-    char *block_data_begin = block_pos;\n-    char *blob_pos = (char *)blob;\n-    while (blob_size > 0) {\n-      unsigned int payload_size = Min(blob_size, max_payload_size);\n-      blob_size -= payload_size;\n-      internal_memcpy(block_data_begin, blob_pos, payload_size);\n-      blob_pos += payload_size;\n-      ((CovHeader *)block.data())->data_length = payload_size;\n-      internal_write(cov_fd, block.data(),\n-                     header_size_with_module + payload_size);\n-    }\n-  }\n-}\n-\n-// Dump the coverage on disk.\n-static void CovDump() {\n-  if (!common_flags()->coverage) return;\n-#if !SANITIZER_WINDOWS\n-  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n-    return;\n-  uptr size = atomic_load(&pc_array_index, memory_order_relaxed);\n-  InternalSort(&pc_array, size, CompareLess);\n-  InternalMmapVector<u32> offsets(size);\n-  const uptr *vb = pc_array;\n-  const uptr *ve = vb + size;\n-  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n-  uptr mb, me, off, prot;\n-  InternalScopedBuffer<char> module(4096);\n-  InternalScopedBuffer<char> path(4096 * 2);\n-  for (int i = 0;\n-       proc_maps.Next(&mb, &me, &off, module.data(), module.size(), &prot);\n-       i++) {\n-    if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n-      continue;\n-    while (vb < ve && *vb < mb) vb++;\n-    if (vb >= ve) break;\n-    if (*vb < me) {\n-      offsets.clear();\n-      const uptr *old_vb = vb;\n-      CHECK_LE(off, *vb);\n-      for (; vb < ve && *vb < me; vb++) {\n-        uptr diff = *vb - (i ? mb : 0) + off;\n-        CHECK_LE(diff, 0xffffffffU);\n-        offsets.push_back(static_cast<u32>(diff));\n-      }\n-      char *module_name = StripModuleName(module.data());\n-      if (cov_sandboxed) {\n-        CovWritePacked(internal_getpid(), module_name, offsets.data(),\n-                       offsets.size() * sizeof(u32));\n-        VReport(1, \" CovDump: %zd PCs written to packed file\\n\", vb - old_vb);\n-      } else {\n-        // One file per module per process.\n-        internal_snprintf((char *)path.data(), path.size(), \"%s.%zd.sancov\",\n-                          module_name, internal_getpid());\n-        uptr fd = OpenFile(path.data(), true);\n-        if (internal_iserror(fd)) {\n-          Report(\" CovDump: failed to open %s for writing\\n\", path.data());\n-        } else {\n-          internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n-          internal_close(fd);\n-          VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(),\n-                  vb - old_vb);\n-        }\n-      }\n-      InternalFree(module_name);\n-    }\n-  }\n-  if (cov_fd >= 0)\n-    internal_close(cov_fd);\n-#endif  // !SANITIZER_WINDOWS\n-}\n-\n-static void OpenPackedFileForWriting() {\n-  CHECK(cov_fd == kInvalidFd);\n-  InternalScopedBuffer<char> path(1024);\n-  internal_snprintf((char *)path.data(), path.size(), \"%zd.sancov.packed\",\n-                    internal_getpid());\n-  uptr fd = OpenFile(path.data(), true);\n-  if (internal_iserror(fd)) {\n-    Report(\" Coverage: failed to open %s for writing\\n\", path.data());\n-    Die();\n-  }\n-  cov_fd = fd;\n-}\n-\n-void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n-  if (!args) return;\n-  if (!common_flags()->coverage) return;\n-  cov_sandboxed = args->coverage_sandboxed;\n-  if (!cov_sandboxed) return;\n-  cov_fd = args->coverage_fd;\n-  cov_max_block_size = args->coverage_max_block_size;\n-  if (cov_fd < 0)\n-    // Pre-open the file now. The sandbox won't allow us to do it later.\n-    OpenPackedFileForWriting();\n-}\n-\n-}  // namespace __sanitizer\n-\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov() {\n-  CovAdd(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()));\n-}\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n-SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() { CovInit(); }\n-}  // extern \"C\""}, {"sha": "9b02cd75017ce35a08c020e1ff9151ec02d7e566", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,377 @@\n+//===-- sanitizer_coverage.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage.\n+// This file implements run-time support for a poor man's coverage tool.\n+//\n+// Compiler instrumentation:\n+// For every interesting basic block the compiler injects the following code:\n+// if (*Guard) {\n+//    __sanitizer_cov();\n+//    *Guard = 1;\n+// }\n+// It's fine to call __sanitizer_cov more than once for a given block.\n+//\n+// Run-time:\n+//  - __sanitizer_cov(): record that we've executed the PC (GET_CALLER_PC).\n+//  - __sanitizer_cov_dump: dump the coverage data to disk.\n+//  For every module of the current process that has coverage data\n+//  this will create a file module_name.PID.sancov. The file format is simple:\n+//  it's just a sorted sequence of 4-byte offsets in the module.\n+//\n+// Eventually, this coverage implementation should be obsoleted by a more\n+// powerful general purpose Clang/LLVM coverage instrumentation.\n+// Consider this implementation as prototype.\n+//\n+// FIXME: support (or at least test with) dlclose.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_flags.h\"\n+\n+atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n+\n+// pc_array is the array containing the covered PCs.\n+// To make the pc_array thread- and async-signal-safe it has to be large enough.\n+// 128M counters \"ought to be enough for anybody\" (4M on 32-bit).\n+\n+// With coverage_direct=1 in ASAN_OPTIONS, pc_array memory is mapped to a file.\n+// In this mode, __sanitizer_cov_dump does nothing, and CovUpdateMapping()\n+// dump current memory layout to another file.\n+\n+static bool cov_sandboxed = false;\n+static int cov_fd = kInvalidFd;\n+static unsigned int cov_max_block_size = 0;\n+\n+namespace __sanitizer {\n+\n+class CoverageData {\n+ public:\n+  void Init();\n+  void BeforeFork();\n+  void AfterFork(int child_pid);\n+  void Extend(uptr npcs);\n+  void Add(uptr pc);\n+\n+  uptr *data();\n+  uptr size();\n+\n+ private:\n+  // Maximal size pc array may ever grow.\n+  // We MmapNoReserve this space to ensure that the array is contiguous.\n+  static const uptr kPcArrayMaxSize = FIRST_32_SECOND_64(1 << 22, 1 << 27);\n+  // The amount file mapping for the pc array is grown by.\n+  static const uptr kPcArrayMmapSize = 64 * 1024;\n+\n+  // pc_array is allocated with MmapNoReserveOrDie and so it uses only as\n+  // much RAM as it really needs.\n+  uptr *pc_array;\n+  // Index of the first available pc_array slot.\n+  atomic_uintptr_t pc_array_index;\n+  // Array size.\n+  atomic_uintptr_t pc_array_size;\n+  // Current file mapped size of the pc array.\n+  uptr pc_array_mapped_size;\n+  // Descriptor of the file mapped pc array.\n+  int pc_fd;\n+  StaticSpinMutex mu;\n+\n+  void DirectOpen();\n+  void ReInit();\n+};\n+\n+static CoverageData coverage_data;\n+\n+void CoverageData::DirectOpen() {\n+  InternalScopedString path(1024);\n+  internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.raw\",\n+                    common_flags()->coverage_dir, internal_getpid());\n+  pc_fd = OpenFile(path.data(), true);\n+  if (internal_iserror(pc_fd)) {\n+    Report(\" Coverage: failed to open %s for writing\\n\", path.data());\n+    Die();\n+  }\n+\n+  pc_array_mapped_size = 0;\n+  CovUpdateMapping();\n+}\n+\n+void CoverageData::Init() {\n+  pc_array = reinterpret_cast<uptr *>(\n+      MmapNoReserveOrDie(sizeof(uptr) * kPcArrayMaxSize, \"CovInit\"));\n+  pc_fd = kInvalidFd;\n+  if (common_flags()->coverage_direct) {\n+    atomic_store(&pc_array_size, 0, memory_order_relaxed);\n+    atomic_store(&pc_array_index, 0, memory_order_relaxed);\n+  } else {\n+    atomic_store(&pc_array_size, kPcArrayMaxSize, memory_order_relaxed);\n+    atomic_store(&pc_array_index, 0, memory_order_relaxed);\n+  }\n+}\n+\n+void CoverageData::ReInit() {\n+  internal_munmap(pc_array, sizeof(uptr) * kPcArrayMaxSize);\n+  if (pc_fd != kInvalidFd) internal_close(pc_fd);\n+  if (common_flags()->coverage_direct) {\n+    // In memory-mapped mode we must extend the new file to the known array\n+    // size.\n+    uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n+    Init();\n+    if (size) Extend(size);\n+  } else {\n+    Init();\n+  }\n+}\n+\n+void CoverageData::BeforeFork() {\n+  mu.Lock();\n+}\n+\n+void CoverageData::AfterFork(int child_pid) {\n+  // We are single-threaded so it's OK to release the lock early.\n+  mu.Unlock();\n+  if (child_pid == 0) ReInit();\n+}\n+\n+// Extend coverage PC array to fit additional npcs elements.\n+void CoverageData::Extend(uptr npcs) {\n+  if (!common_flags()->coverage_direct) return;\n+  SpinMutexLock l(&mu);\n+\n+  if (pc_fd == kInvalidFd) DirectOpen();\n+  CHECK_NE(pc_fd, kInvalidFd);\n+\n+  uptr size = atomic_load(&pc_array_size, memory_order_relaxed);\n+  size += npcs * sizeof(uptr);\n+\n+  if (size > pc_array_mapped_size) {\n+    uptr new_mapped_size = pc_array_mapped_size;\n+    while (size > new_mapped_size) new_mapped_size += kPcArrayMmapSize;\n+\n+    // Extend the file and map the new space at the end of pc_array.\n+    uptr res = internal_ftruncate(pc_fd, new_mapped_size);\n+    int err;\n+    if (internal_iserror(res, &err)) {\n+      Printf(\"failed to extend raw coverage file: %d\\n\", err);\n+      Die();\n+    }\n+    void *p = MapWritableFileToMemory(pc_array + pc_array_mapped_size,\n+                                      new_mapped_size - pc_array_mapped_size,\n+                                      pc_fd, pc_array_mapped_size);\n+    CHECK_EQ(p, pc_array + pc_array_mapped_size);\n+    pc_array_mapped_size = new_mapped_size;\n+  }\n+\n+  atomic_store(&pc_array_size, size, memory_order_release);\n+}\n+\n+// Simply add the pc into the vector under lock. If the function is called more\n+// than once for a given PC it will be inserted multiple times, which is fine.\n+void CoverageData::Add(uptr pc) {\n+  if (!pc_array) return;\n+  uptr idx = atomic_fetch_add(&pc_array_index, 1, memory_order_relaxed);\n+  CHECK_LT(idx * sizeof(uptr),\n+           atomic_load(&pc_array_size, memory_order_acquire));\n+  pc_array[idx] = pc;\n+}\n+\n+uptr *CoverageData::data() {\n+  return pc_array;\n+}\n+\n+uptr CoverageData::size() {\n+  return atomic_load(&pc_array_index, memory_order_relaxed);\n+}\n+\n+// Block layout for packed file format: header, followed by module name (no\n+// trailing zero), followed by data blob.\n+struct CovHeader {\n+  int pid;\n+  unsigned int module_name_length;\n+  unsigned int data_length;\n+};\n+\n+static void CovWritePacked(int pid, const char *module, const void *blob,\n+                           unsigned int blob_size) {\n+  if (cov_fd < 0) return;\n+  unsigned module_name_length = internal_strlen(module);\n+  CovHeader header = {pid, module_name_length, blob_size};\n+\n+  if (cov_max_block_size == 0) {\n+    // Writing to a file. Just go ahead.\n+    internal_write(cov_fd, &header, sizeof(header));\n+    internal_write(cov_fd, module, module_name_length);\n+    internal_write(cov_fd, blob, blob_size);\n+  } else {\n+    // Writing to a socket. We want to split the data into appropriately sized\n+    // blocks.\n+    InternalScopedBuffer<char> block(cov_max_block_size);\n+    CHECK_EQ((uptr)block.data(), (uptr)(CovHeader *)block.data());\n+    uptr header_size_with_module = sizeof(header) + module_name_length;\n+    CHECK_LT(header_size_with_module, cov_max_block_size);\n+    unsigned int max_payload_size =\n+        cov_max_block_size - header_size_with_module;\n+    char *block_pos = block.data();\n+    internal_memcpy(block_pos, &header, sizeof(header));\n+    block_pos += sizeof(header);\n+    internal_memcpy(block_pos, module, module_name_length);\n+    block_pos += module_name_length;\n+    char *block_data_begin = block_pos;\n+    char *blob_pos = (char *)blob;\n+    while (blob_size > 0) {\n+      unsigned int payload_size = Min(blob_size, max_payload_size);\n+      blob_size -= payload_size;\n+      internal_memcpy(block_data_begin, blob_pos, payload_size);\n+      blob_pos += payload_size;\n+      ((CovHeader *)block.data())->data_length = payload_size;\n+      internal_write(cov_fd, block.data(),\n+                     header_size_with_module + payload_size);\n+    }\n+  }\n+}\n+\n+// If packed = false: <name>.<pid>.<sancov> (name = module name).\n+// If packed = true and name == 0: <pid>.<sancov>.<packed>.\n+// If packed = true and name != 0: <name>.<sancov>.<packed> (name is\n+// user-supplied).\n+static int CovOpenFile(bool packed, const char* name) {\n+  InternalScopedBuffer<char> path(1024);\n+  if (!packed) {\n+    CHECK(name);\n+    internal_snprintf((char *)path.data(), path.size(), \"%s/%s.%zd.sancov\",\n+                      common_flags()->coverage_dir, name, internal_getpid());\n+  } else {\n+    if (!name)\n+      internal_snprintf((char *)path.data(), path.size(),\n+                        \"%s/%zd.sancov.packed\", common_flags()->coverage_dir,\n+                        internal_getpid());\n+    else\n+      internal_snprintf((char *)path.data(), path.size(), \"%s/%s.sancov.packed\",\n+                        common_flags()->coverage_dir, name);\n+  }\n+  uptr fd = OpenFile(path.data(), true);\n+  if (internal_iserror(fd)) {\n+    Report(\" SanitizerCoverage: failed to open %s for writing\\n\", path.data());\n+    return -1;\n+  }\n+  return fd;\n+}\n+\n+// Dump the coverage on disk.\n+static void CovDump() {\n+  if (!common_flags()->coverage || common_flags()->coverage_direct) return;\n+#if !SANITIZER_WINDOWS\n+  if (atomic_fetch_add(&dump_once_guard, 1, memory_order_relaxed))\n+    return;\n+  uptr size = coverage_data.size();\n+  InternalMmapVector<u32> offsets(size);\n+  uptr *vb = coverage_data.data();\n+  uptr *ve = vb + size;\n+  SortArray(vb, size);\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  uptr mb, me, off, prot;\n+  InternalScopedBuffer<char> module(4096);\n+  InternalScopedBuffer<char> path(4096 * 2);\n+  for (int i = 0;\n+       proc_maps.Next(&mb, &me, &off, module.data(), module.size(), &prot);\n+       i++) {\n+    if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n+      continue;\n+    while (vb < ve && *vb < mb) vb++;\n+    if (vb >= ve) break;\n+    if (*vb < me) {\n+      offsets.clear();\n+      const uptr *old_vb = vb;\n+      CHECK_LE(off, *vb);\n+      for (; vb < ve && *vb < me; vb++) {\n+        uptr diff = *vb - (i ? mb : 0) + off;\n+        CHECK_LE(diff, 0xffffffffU);\n+        offsets.push_back(static_cast<u32>(diff));\n+      }\n+      char *module_name = StripModuleName(module.data());\n+      if (cov_sandboxed) {\n+        if (cov_fd >= 0) {\n+          CovWritePacked(internal_getpid(), module_name, offsets.data(),\n+                         offsets.size() * sizeof(u32));\n+          VReport(1, \" CovDump: %zd PCs written to packed file\\n\", vb - old_vb);\n+        }\n+      } else {\n+        // One file per module per process.\n+        internal_snprintf((char *)path.data(), path.size(), \"%s/%s.%zd.sancov\",\n+                          common_flags()->coverage_dir, module_name,\n+                          internal_getpid());\n+        int fd = CovOpenFile(false /* packed */, module_name);\n+        if (fd > 0) {\n+          internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n+          internal_close(fd);\n+          VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(),\n+                  vb - old_vb);\n+        }\n+      }\n+      InternalFree(module_name);\n+    }\n+  }\n+  if (cov_fd >= 0)\n+    internal_close(cov_fd);\n+#endif  // !SANITIZER_WINDOWS\n+}\n+\n+void CovPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  if (!args) return;\n+  if (!common_flags()->coverage) return;\n+  cov_sandboxed = args->coverage_sandboxed;\n+  if (!cov_sandboxed) return;\n+  cov_fd = args->coverage_fd;\n+  cov_max_block_size = args->coverage_max_block_size;\n+  if (cov_fd < 0)\n+    // Pre-open the file now. The sandbox won't allow us to do it later.\n+    cov_fd = CovOpenFile(true /* packed */, 0);\n+}\n+\n+int MaybeOpenCovFile(const char *name) {\n+  CHECK(name);\n+  if (!common_flags()->coverage) return -1;\n+  return CovOpenFile(true /* packed */, name);\n+}\n+\n+void CovBeforeFork() {\n+  coverage_data.BeforeFork();\n+}\n+\n+void CovAfterFork(int child_pid) {\n+  coverage_data.AfterFork(child_pid);\n+}\n+\n+}  // namespace __sanitizer\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov() {\n+  coverage_data.Add(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()));\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() {\n+  coverage_data.Init();\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_module_init(uptr npcs) {\n+  if (!common_flags()->coverage || !common_flags()->coverage_direct) return;\n+  if (SANITIZER_ANDROID) {\n+    // dlopen/dlclose interceptors do not work on Android, so we rely on\n+    // Extend() calls to update .sancov.map.\n+    CovUpdateMapping(GET_CALLER_PC());\n+  }\n+  coverage_data.Extend(npcs);\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE\n+sptr __sanitizer_maybe_open_cov_file(const char *name) {\n+  return MaybeOpenCovFile(name);\n+}\n+}  // extern \"C\""}, {"sha": "a134053a719b96c08b140de0c67e53056148ea1c", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_mapping_libcdep.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,126 @@\n+//===-- sanitizer_coverage_mapping.cc -------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Mmap-based implementation of sanitizer coverage.\n+//\n+// This is part of the implementation of code coverage that does not require\n+// __sanitizer_cov_dump() call. Data is stored in 2 files per process.\n+//\n+// $pid.sancov.map describes process memory layout in the following text-based\n+// format:\n+// <pointer size in bits>  // 1 line, 32 or 64\n+// <mapping start> <mapping end> <base address> <dso name> // repeated\n+// ...\n+// Mapping lines are NOT sorted. This file is updated every time memory layout\n+// is changed (i.e. in dlopen() and dlclose() interceptors).\n+//\n+// $pid.sancov.raw is a binary dump of PC values, sizeof(uptr) each. Again, not\n+// sorted. This file is extended by 64Kb at a time and mapped into memory. It\n+// contains one or more 0 words at the end, up to the next 64Kb aligned offset.\n+//\n+// To convert these 2 files to the usual .sancov format, run sancov.py rawunpack\n+// $pid.sancov.raw.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+namespace __sanitizer {\n+\n+static const uptr kMaxNumberOfModules = 1 << 14;\n+static const uptr kMaxTextSize = 64 * 1024;\n+\n+struct CachedMapping {\n+ public:\n+  bool NeedsUpdate(uptr pc) {\n+    int new_pid = internal_getpid();\n+    if (last_pid == new_pid && pc && pc >= last_range_start &&\n+        pc < last_range_end)\n+      return false;\n+    last_pid = new_pid;\n+    return true;\n+  }\n+\n+  void SetModuleRange(uptr start, uptr end) {\n+    last_range_start = start;\n+    last_range_end = end;\n+  }\n+\n+ private:\n+  uptr last_range_start, last_range_end;\n+  int last_pid;\n+};\n+\n+static CachedMapping cached_mapping;\n+static StaticSpinMutex mapping_mu;\n+\n+void CovUpdateMapping(uptr caller_pc) {\n+  if (!common_flags()->coverage || !common_flags()->coverage_direct) return;\n+\n+  SpinMutexLock l(&mapping_mu);\n+\n+  if (!cached_mapping.NeedsUpdate(caller_pc))\n+    return;\n+\n+  InternalScopedString text(kMaxTextSize);\n+  InternalScopedBuffer<char> modules_data(kMaxNumberOfModules *\n+                                          sizeof(LoadedModule));\n+  LoadedModule *modules = (LoadedModule *)modules_data.data();\n+  CHECK(modules);\n+  int n_modules = GetListOfModules(modules, kMaxNumberOfModules,\n+                                   /* filter */ 0);\n+\n+  text.append(\"%d\\n\", sizeof(uptr) * 8);\n+  for (int i = 0; i < n_modules; ++i) {\n+    char *module_name = StripModuleName(modules[i].full_name());\n+    for (unsigned j = 0; j < modules[i].n_ranges(); ++j) {\n+      if (modules[i].address_range_executable(j)) {\n+        uptr start = modules[i].address_range_start(j);\n+        uptr end = modules[i].address_range_end(j);\n+        uptr base = modules[i].base_address();\n+        text.append(\"%zx %zx %zx %s\\n\", start, end, base, module_name);\n+        if (caller_pc && caller_pc >= start && caller_pc < end)\n+          cached_mapping.SetModuleRange(start, end);\n+      }\n+    }\n+    InternalFree(module_name);\n+  }\n+\n+  int err;\n+  InternalScopedString tmp_path(64 +\n+                                internal_strlen(common_flags()->coverage_dir));\n+  uptr res = internal_snprintf((char *)tmp_path.data(), tmp_path.size(),\n+                    \"%s/%zd.sancov.map.tmp\", common_flags()->coverage_dir,\n+                    internal_getpid());\n+  CHECK_LE(res, tmp_path.size());\n+  uptr map_fd = OpenFile(tmp_path.data(), true);\n+  if (internal_iserror(map_fd)) {\n+    Report(\" Coverage: failed to open %s for writing\\n\", tmp_path.data());\n+    Die();\n+  }\n+\n+  res = internal_write(map_fd, text.data(), text.length());\n+  if (internal_iserror(res, &err)) {\n+    Printf(\"sancov.map write failed: %d\\n\", err);\n+    Die();\n+  }\n+  internal_close(map_fd);\n+\n+  InternalScopedString path(64 + internal_strlen(common_flags()->coverage_dir));\n+  res = internal_snprintf((char *)path.data(), path.size(), \"%s/%zd.sancov.map\",\n+                    common_flags()->coverage_dir, internal_getpid());\n+  CHECK_LE(res, path.size());\n+  res = internal_rename(tmp_path.data(), path.data());\n+  if (internal_iserror(res, &err)) {\n+    Printf(\"sancov.map rename failed: %d\\n\", err);\n+    Die();\n+  }\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "bc96ad230db7c7f30210f773d58a476734eb0b72", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -185,8 +185,7 @@ u32 DD::allocateId(DDCallback *cb) {\n     id = id_gen++;\n   }\n   CHECK_LE(id, kMaxMutex);\n-  VPrintf(3, \"#%llu: DD::allocateId assign id %d\\n\",\n-      cb->lt->ctx, id);\n+  VPrintf(3, \"#%llu: DD::allocateId assign id %d\\n\", cb->lt->ctx, id);\n   return id;\n }\n "}, {"sha": "476f793c27d686265b0e8f6e18e7377be9f376ce", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -27,6 +27,11 @@ struct FlagDescription {\n \n IntrusiveList<FlagDescription> flag_descriptions;\n \n+// If set, the tool will install its own SEGV signal handler by default.\n+#ifndef SANITIZER_NEEDS_SEGV\n+# define SANITIZER_NEEDS_SEGV 1\n+#endif\n+\n void SetCommonFlagsDefaults(CommonFlags *f) {\n   f->symbolize = true;\n   f->external_symbolizer_path = 0;\n@@ -53,7 +58,12 @@ void SetCommonFlagsDefaults(CommonFlags *f) {\n   f->legacy_pthread_cond = false;\n   f->intercept_tls_get_addr = false;\n   f->coverage = false;\n+  f->coverage_direct = SANITIZER_ANDROID;\n+  f->coverage_dir = \".\";\n   f->full_address_space = false;\n+  f->suppressions = \"\";\n+  f->print_suppressions = true;\n+  f->disable_coredump = (SANITIZER_WORDSIZE == 64);\n }\n \n void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n@@ -125,9 +135,23 @@ void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n   ParseFlag(str, &f->coverage, \"coverage\",\n       \"If set, coverage information will be dumped at program shutdown (if the \"\n       \"coverage instrumentation was enabled at compile time).\");\n+  ParseFlag(str, &f->coverage_direct, \"coverage_direct\",\n+            \"If set, coverage information will be dumped directly to a memory \"\n+            \"mapped file. This way data is not lost even if the process is \"\n+            \"suddenly killed.\");\n+  ParseFlag(str, &f->coverage_dir, \"coverage_dir\",\n+            \"Target directory for coverage dumps. Defaults to the current \"\n+            \"directory.\");\n   ParseFlag(str, &f->full_address_space, \"full_address_space\",\n             \"Sanitize complete address space; \"\n             \"by default kernel area on 32-bit platforms will not be sanitized\");\n+  ParseFlag(str, &f->suppressions, \"suppressions\", \"Suppressions file name.\");\n+  ParseFlag(str, &f->print_suppressions, \"print_suppressions\",\n+            \"Print matched suppressions at exit.\");\n+  ParseFlag(str, &f->disable_coredump, \"disable_coredump\",\n+      \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n+      \"dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n+      \"default and for sanitizers that don't reserve lots of virtual memory.\");\n \n   // Do a sanity check for certain flags.\n   if (f->malloc_context_size < 1)\n@@ -143,14 +167,17 @@ static bool GetFlagValue(const char *env, const char *name,\n     pos = internal_strstr(env, name);\n     if (pos == 0)\n       return false;\n-    if (pos != env && ((pos[-1] >= 'a' && pos[-1] <= 'z') || pos[-1] == '_')) {\n+    const char *name_end = pos + internal_strlen(name);\n+    if ((pos != env &&\n+         ((pos[-1] >= 'a' && pos[-1] <= 'z') || pos[-1] == '_')) ||\n+        *name_end != '=') {\n       // Seems to be middle of another flag name or value.\n       env = pos + 1;\n       continue;\n     }\n+    pos = name_end;\n     break;\n   }\n-  pos += internal_strlen(name);\n   const char *end;\n   if (pos[0] != '=') {\n     end = pos;"}, {"sha": "a906c9e4535743560dfc3c0a8373a1bf26c7e96f", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -52,7 +52,12 @@ struct CommonFlags {\n   bool help;\n   uptr mmap_limit_mb;\n   bool coverage;\n+  bool coverage_direct;\n+  const char *coverage_dir;\n   bool full_address_space;\n+  const char *suppressions;\n+  bool print_suppressions;\n+  bool disable_coredump;\n };\n \n inline CommonFlags *common_flags() {"}, {"sha": "47bb1313e6f454f242239bc8034b7478dd2cab56", "filename": "libsanitizer/sanitizer_common/sanitizer_freebsd.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,135 @@\n+//===-- sanitizer_freebsd.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer runtime. It contains FreeBSD-specific\n+// definitions.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_FREEBSD_H\n+#define SANITIZER_FREEBSD_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+// x86-64 FreeBSD 9.2 and older define 'ucontext_t' incorrectly in\n+// 32-bit mode.\n+#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n+# include <osreldate.h>\n+# if __FreeBSD_version <= 902001  // v9.2\n+#  include <link.h>\n+#  include <sys/param.h>\n+#  include <ucontext.h>\n+\n+namespace __sanitizer {\n+\n+typedef unsigned long long __xuint64_t;\n+\n+typedef __int32_t __xregister_t;\n+\n+typedef struct __xmcontext {\n+  __xregister_t mc_onstack;\n+  __xregister_t mc_gs;\n+  __xregister_t mc_fs;\n+  __xregister_t mc_es;\n+  __xregister_t mc_ds;\n+  __xregister_t mc_edi;\n+  __xregister_t mc_esi;\n+  __xregister_t mc_ebp;\n+  __xregister_t mc_isp;\n+  __xregister_t mc_ebx;\n+  __xregister_t mc_edx;\n+  __xregister_t mc_ecx;\n+  __xregister_t mc_eax;\n+  __xregister_t mc_trapno;\n+  __xregister_t mc_err;\n+  __xregister_t mc_eip;\n+  __xregister_t mc_cs;\n+  __xregister_t mc_eflags;\n+  __xregister_t mc_esp;\n+  __xregister_t mc_ss;\n+\n+  int mc_len;\n+  int mc_fpformat;\n+  int mc_ownedfp;\n+  __xregister_t mc_flags;\n+\n+  int mc_fpstate[128] __aligned(16);\n+  __xregister_t mc_fsbase;\n+  __xregister_t mc_gsbase;\n+  __xregister_t mc_xfpustate;\n+  __xregister_t mc_xfpustate_len;\n+\n+  int mc_spare2[4];\n+} xmcontext_t;\n+\n+typedef struct __xucontext {\n+  sigset_t  uc_sigmask;\n+  xmcontext_t  uc_mcontext;\n+\n+  struct __ucontext *uc_link;\n+  stack_t uc_stack;\n+  int uc_flags;\n+  int __spare__[4];\n+} xucontext_t;\n+\n+struct xkinfo_vmentry {\n+  int kve_structsize;\n+  int kve_type;\n+  __xuint64_t kve_start;\n+  __xuint64_t kve_end;\n+  __xuint64_t kve_offset;\n+  __xuint64_t kve_vn_fileid;\n+  __uint32_t kve_vn_fsid;\n+  int kve_flags;\n+  int kve_resident;\n+  int kve_private_resident;\n+  int kve_protection;\n+  int kve_ref_count;\n+  int kve_shadow_count;\n+  int kve_vn_type;\n+  __xuint64_t kve_vn_size;\n+  __uint32_t kve_vn_rdev;\n+  __uint16_t kve_vn_mode;\n+  __uint16_t kve_status;\n+  int _kve_ispare[12];\n+  char kve_path[PATH_MAX];\n+};\n+\n+typedef struct {\n+  __uint32_t p_type;\n+  __uint32_t p_offset;\n+  __uint32_t p_vaddr;\n+  __uint32_t p_paddr;\n+  __uint32_t p_filesz;\n+  __uint32_t p_memsz;\n+  __uint32_t p_flags;\n+  __uint32_t p_align;\n+} XElf32_Phdr;\n+\n+struct xdl_phdr_info {\n+  Elf_Addr dlpi_addr;\n+  const char *dlpi_name;\n+  const XElf32_Phdr *dlpi_phdr;\n+  Elf_Half dlpi_phnum;\n+  unsigned long long int dlpi_adds;\n+  unsigned long long int dlpi_subs;\n+  size_t dlpi_tls_modid;\n+  void *dlpi_tls_data;\n+};\n+\n+typedef int (*__xdl_iterate_hdr_callback)(struct xdl_phdr_info*, size_t, void*);\n+typedef int xdl_iterate_phdr_t(__xdl_iterate_hdr_callback, void*);\n+\n+#define xdl_iterate_phdr(callback, param) \\\n+  (((xdl_iterate_phdr_t*) dl_iterate_phdr)((callback), (param)))\n+\n+}  // namespace __sanitizer\n+\n+# endif  // __FreeBSD_version <= 902001\n+#endif  // SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n+\n+#endif  // SANITIZER_FREEBSD_H"}, {"sha": "f1f243c17e2740de37c9286acad9c407fd613016", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -32,9 +32,13 @@\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n #endif\n \n-// If set, the tool will install its own SEGV signal handler.\n-#ifndef SANITIZER_NEEDS_SEGV\n-# define SANITIZER_NEEDS_SEGV 1\n+// We can use .preinit_array section on Linux to call sanitizer initialization\n+// functions very early in the process startup (unless PIC macro is defined).\n+// FIXME: do we have anything like this on Mac?\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID && !defined(PIC)\n+# define SANITIZER_CAN_USE_PREINIT_ARRAY 1\n+#else\n+# define SANITIZER_CAN_USE_PREINIT_ARRAY 0\n #endif\n \n // GCC does not understand __has_feature"}, {"sha": "680b888e219124b33d3932e3a49ed46b5c7ee045", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -72,6 +72,7 @@ uptr internal_open(const char *filename, int flags, u32 mode);\n \n uptr internal_read(fd_t fd, void *buf, uptr count);\n uptr internal_write(fd_t fd, const void *buf, uptr count);\n+uptr internal_ftruncate(fd_t fd, uptr size);\n \n // OS\n uptr internal_filesize(fd_t fd);  // -1 on error.\n@@ -81,6 +82,7 @@ uptr internal_fstat(fd_t fd, void *buf);\n uptr internal_dup2(int oldfd, int newfd);\n uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n uptr internal_unlink(const char *path);\n+uptr internal_rename(const char *oldpath, const char *newpath);\n void NORETURN internal__exit(int exitcode);\n uptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n "}, {"sha": "9877d6686580b719a45e774a98843640d72f446c", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -6,7 +6,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n \n #include \"sanitizer_libignore.h\"\n #include \"sanitizer_flags.h\"\n@@ -101,4 +101,4 @@ void LibIgnore::OnLibraryUnloaded() {\n \n }  // namespace __sanitizer\n \n-#endif  // #if SANITIZER_LINUX\n+#endif  // #if SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "8c7979fc6b56405005cc83f1e8e8afd6bf1201a2", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -44,15 +44,16 @@\n #include <sys/time.h>\n #include <sys/types.h>\n #include <unistd.h>\n-#include <unwind.h>\n \n #if SANITIZER_FREEBSD\n+#include <sys/sysctl.h>\n #include <machine/atomic.h>\n extern \"C\" {\n // <sys/umtx.h> must be included after <errno.h> and <sys/types.h> on\n // FreeBSD 9.2 and 10.0.\n #include <sys/umtx.h>\n }\n+extern char **environ;  // provided by crt1\n #endif  // SANITIZER_FREEBSD\n \n #if !SANITIZER_ANDROID\n@@ -132,7 +133,7 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n \n uptr OpenFile(const char *filename, bool write) {\n   return internal_open(filename,\n-      write ? O_WRONLY | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n+      write ? O_RDWR | O_CREAT /*| O_CLOEXEC*/ : O_RDONLY, 0660);\n }\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n@@ -149,6 +150,12 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n   return res;\n }\n \n+uptr internal_ftruncate(fd_t fd, uptr size) {\n+  sptr res;\n+  HANDLE_EINTR(res, (sptr)internal_syscall(SYSCALL(ftruncate), fd, size));\n+  return res;\n+}\n+\n #if !SANITIZER_LINUX_USES_64BIT_SYSCALLS && !SANITIZER_FREEBSD\n static void stat64_to_stat(struct stat64 *in, struct stat *out) {\n   internal_memset(out, 0, sizeof(*out));\n@@ -244,6 +251,15 @@ uptr internal_unlink(const char *path) {\n #endif\n }\n \n+uptr internal_rename(const char *oldpath, const char *newpath) {\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(renameat), AT_FDCWD, (uptr)oldpath, AT_FDCWD,\n+                          (uptr)newpath);\n+#else\n+  return internal_syscall(SYSCALL(rename), (uptr)oldpath, (uptr)newpath);\n+#endif\n+}\n+\n uptr internal_sched_yield() {\n   return internal_syscall(SYSCALL(sched_yield));\n }\n@@ -297,9 +313,20 @@ u64 NanoTime() {\n   return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n \n-// Like getenv, but reads env directly from /proc and does not use libc.\n-// This function should be called first inside __asan_init.\n+// Like getenv, but reads env directly from /proc (on Linux) or parses the\n+// 'environ' array (on FreeBSD) and does not use libc. This function should be\n+// called first inside __asan_init.\n const char *GetEnv(const char *name) {\n+#if SANITIZER_FREEBSD\n+  if (::environ != 0) {\n+    uptr NameLen = internal_strlen(name);\n+    for (char **Env = ::environ; *Env != 0; Env++) {\n+      if (internal_strncmp(*Env, name, NameLen) == 0 && (*Env)[NameLen] == '=')\n+        return (*Env) + NameLen + 1;\n+    }\n+  }\n+  return 0;  // Not found.\n+#elif SANITIZER_LINUX\n   static char *environ;\n   static uptr len;\n   static bool inited;\n@@ -323,6 +350,9 @@ const char *GetEnv(const char *name) {\n     p = endp + 1;\n   }\n   return 0;  // Not found.\n+#else\n+#error \"Unsupported platform\"\n+#endif\n }\n \n extern \"C\" {\n@@ -388,20 +418,6 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n }\n #endif  // SANITIZER_GO\n \n-void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n-  // Some kinds of sandboxes may forbid filesystem access, so we won't be able\n-  // to read the file mappings from /proc/self/maps. Luckily, neither the\n-  // process will be able to load additional libraries, so it's fine to use the\n-  // cached mappings.\n-  MemoryMappingLayout::CacheMemoryMappings();\n-  // Same for /proc/self/exe in the symbolizer.\n-#if !SANITIZER_GO\n-  if (Symbolizer *sym = Symbolizer::GetOrNull())\n-    sym->PrepareForSandboxing();\n-  CovPrepareForSandboxing(args);\n-#endif\n-}\n-\n enum MutexState {\n   MtxUnlocked = 0,\n   MtxLocked = 1,\n@@ -506,7 +522,11 @@ uptr internal_sigaltstack(const struct sigaltstack *ss,\n }\n \n int internal_fork() {\n+#if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n+  return internal_syscall(SYSCALL(clone), SIGCHLD, 0);\n+#else\n   return internal_syscall(SYSCALL(fork));\n+#endif\n }\n \n #if SANITIZER_LINUX\n@@ -660,24 +680,32 @@ static char proc_self_exe_cache_str[kMaxPathLength];\n static uptr proc_self_exe_cache_len = 0;\n \n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n+  if (proc_self_exe_cache_len > 0) {\n+    // If available, use the cached module name.\n+    uptr module_name_len =\n+        internal_snprintf(buf, buf_len, \"%s\", proc_self_exe_cache_str);\n+    CHECK_LT(module_name_len, buf_len);\n+    return module_name_len;\n+  }\n+#if SANITIZER_FREEBSD\n+  const int Mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };\n+  size_t Size = buf_len;\n+  bool IsErr = (sysctl(Mib, 4, buf, &Size, NULL, 0) != 0);\n+  int readlink_error = IsErr ? errno : 0;\n+  uptr module_name_len = Size;\n+#else\n   uptr module_name_len = internal_readlink(\n       \"/proc/self/exe\", buf, buf_len);\n   int readlink_error;\n-  if (internal_iserror(module_name_len, &readlink_error)) {\n-    if (proc_self_exe_cache_len) {\n-      // If available, use the cached module name.\n-      CHECK_LE(proc_self_exe_cache_len, buf_len);\n-      internal_strncpy(buf, proc_self_exe_cache_str, buf_len);\n-      module_name_len = internal_strlen(proc_self_exe_cache_str);\n-    } else {\n-      // We can't read /proc/self/exe for some reason, assume the name of the\n-      // binary is unknown.\n-      Report(\"WARNING: readlink(\\\"/proc/self/exe\\\") failed with errno %d, \"\n-             \"some stack frames may not be symbolized\\n\", readlink_error);\n-      module_name_len = internal_snprintf(buf, buf_len, \"/proc/self/exe\");\n-    }\n+  bool IsErr = internal_iserror(module_name_len, &readlink_error);\n+#endif\n+  if (IsErr) {\n+    // We can't read /proc/self/exe for some reason, assume the name of the\n+    // binary is unknown.\n+    Report(\"WARNING: readlink(\\\"/proc/self/exe\\\") failed with errno %d, \"\n+           \"some stack frames may not be symbolized\\n\", readlink_error);\n+    module_name_len = internal_snprintf(buf, buf_len, \"/proc/self/exe\");\n     CHECK_LT(module_name_len, buf_len);\n-    buf[module_name_len] = '\\0';\n   }\n   return module_name_len;\n }\n@@ -806,11 +834,19 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n #endif  // defined(__x86_64__) && SANITIZER_LINUX\n \n #if SANITIZER_ANDROID\n+static atomic_uint8_t android_log_initialized;\n+\n+void AndroidLogInit() {\n+  atomic_store(&android_log_initialized, 1, memory_order_release);\n+}\n // This thing is not, strictly speaking, async signal safe, but it does not seem\n // to cause any issues. Alternative is writing to log devices directly, but\n // their location and message format might change in the future, so we'd really\n // like to avoid that.\n void AndroidLogWrite(const char *buffer) {\n+  if (!atomic_load(&android_log_initialized, memory_order_acquire))\n+    return;\n+\n   char *copy = internal_strdup(buffer);\n   char *p = copy;\n   char *q;"}, {"sha": "36aaafdcc4b35859506f48b2e5cc5969396d23fa", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 27, "deletions": 128, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -15,23 +15,25 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_flags.h\"\n+#include \"sanitizer_freebsd.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_atomic.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+#if SANITIZER_ANDROID || SANITIZER_FREEBSD\n+#include <dlfcn.h>  // for dlsym()\n+#endif\n \n-#include <dlfcn.h>\n #include <pthread.h>\n #include <signal.h>\n #include <sys/resource.h>\n-#if SANITIZER_FREEBSD\n-#define _GNU_SOURCE  // to declare _Unwind_Backtrace() from <unwind.h>\n-#endif\n-#include <unwind.h>\n \n #if SANITIZER_FREEBSD\n #include <pthread_np.h>\n+#include <osreldate.h>\n #define pthread_getattr_np pthread_attr_get_np\n #endif\n \n@@ -147,127 +149,6 @@ bool SanitizerGetThreadName(char *name, int max_len) {\n #endif\n }\n \n-//------------------------- SlowUnwindStack -----------------------------------\n-\n-typedef struct {\n-  uptr absolute_pc;\n-  uptr stack_top;\n-  uptr stack_size;\n-} backtrace_frame_t;\n-\n-extern \"C\" {\n-typedef void *(*acquire_my_map_info_list_func)();\n-typedef void (*release_my_map_info_list_func)(void *map);\n-typedef sptr (*unwind_backtrace_signal_arch_func)(\n-    void *siginfo, void *sigcontext, void *map_info_list,\n-    backtrace_frame_t *backtrace, uptr ignore_depth, uptr max_depth);\n-acquire_my_map_info_list_func acquire_my_map_info_list;\n-release_my_map_info_list_func release_my_map_info_list;\n-unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n-} // extern \"C\"\n-\n-#if SANITIZER_ANDROID\n-void SanitizerInitializeUnwinder() {\n-  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n-  if (!p) {\n-    VReport(1,\n-            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n-            \"in SEGV reports.\");\n-    return;\n-  }\n-  acquire_my_map_info_list =\n-      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n-  release_my_map_info_list =\n-      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n-  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n-      p, \"unwind_backtrace_signal_arch\");\n-  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n-      !unwind_backtrace_signal_arch) {\n-    VReport(1,\n-            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n-            \"You may see broken stack traces in SEGV reports.\");\n-    acquire_my_map_info_list = NULL;\n-    unwind_backtrace_signal_arch = NULL;\n-    release_my_map_info_list = NULL;\n-  }\n-}\n-#endif\n-\n-#ifdef __arm__\n-#define UNWIND_STOP _URC_END_OF_STACK\n-#define UNWIND_CONTINUE _URC_NO_REASON\n-#else\n-#define UNWIND_STOP _URC_NORMAL_STOP\n-#define UNWIND_CONTINUE _URC_NO_REASON\n-#endif\n-\n-uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n-#ifdef __arm__\n-  uptr val;\n-  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n-      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n-  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n-  // Clear the Thumb bit.\n-  return val & ~(uptr)1;\n-#else\n-  return _Unwind_GetIP(ctx);\n-#endif\n-}\n-\n-struct UnwindTraceArg {\n-  StackTrace *stack;\n-  uptr max_depth;\n-};\n-\n-_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n-  UnwindTraceArg *arg = (UnwindTraceArg*)param;\n-  CHECK_LT(arg->stack->size, arg->max_depth);\n-  uptr pc = Unwind_GetIP(ctx);\n-  arg->stack->trace[arg->stack->size++] = pc;\n-  if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n-  return UNWIND_CONTINUE;\n-}\n-\n-void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n-  CHECK_GE(max_depth, 2);\n-  size = 0;\n-  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n-  _Unwind_Backtrace(Unwind_Trace, &arg);\n-  // We need to pop a few frames so that pc is on top.\n-  uptr to_pop = LocatePcInTrace(pc);\n-  // trace[0] belongs to the current function so we always pop it.\n-  if (to_pop == 0)\n-    to_pop = 1;\n-  PopStackFrames(to_pop);\n-  trace[0] = pc;\n-}\n-\n-void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                            uptr max_depth) {\n-  CHECK_GE(max_depth, 2);\n-  if (!unwind_backtrace_signal_arch) {\n-    SlowUnwindStack(pc, max_depth);\n-    return;\n-  }\n-\n-  void *map = acquire_my_map_info_list();\n-  CHECK(map);\n-  InternalScopedBuffer<backtrace_frame_t> frames(kStackTraceMax);\n-  // siginfo argument appears to be unused.\n-  sptr res = unwind_backtrace_signal_arch(/* siginfo */ NULL, context, map,\n-                                          frames.data(),\n-                                          /* ignore_depth */ 0, max_depth);\n-  release_my_map_info_list(map);\n-  if (res < 0) return;\n-  CHECK_LE((uptr)res, kStackTraceMax);\n-\n-  size = 0;\n-  // +2 compensate for libcorkscrew unwinder returning addresses of call\n-  // instructions instead of raw return addresses.\n-  for (sptr i = 0; i < res; ++i)\n-    trace[size++] = frames[i].absolute_pc + 2;\n-}\n-\n #if !SANITIZER_FREEBSD\n static uptr g_tls_size;\n #endif\n@@ -299,11 +180,11 @@ void InitTlsSize() {\n static atomic_uintptr_t kThreadDescriptorSize;\n \n uptr ThreadDescriptorSize() {\n-  char buf[64];\n   uptr val = atomic_load(&kThreadDescriptorSize, memory_order_relaxed);\n   if (val)\n     return val;\n #ifdef _CS_GNU_LIBC_VERSION\n+  char buf[64];\n   uptr len = confstr(_CS_GNU_LIBC_VERSION, buf, sizeof(buf));\n   if (len < sizeof(buf) && internal_strncmp(buf, \"glibc 2.\", 8) == 0) {\n     char *end;\n@@ -468,6 +349,10 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n #else  // SANITIZER_ANDROID\n # if !SANITIZER_FREEBSD\n typedef ElfW(Phdr) Elf_Phdr;\n+# elif SANITIZER_WORDSIZE == 32 && __FreeBSD_version <= 902001  // v9.2\n+#  define Elf_Phdr XElf32_Phdr\n+#  define dl_phdr_info xdl_phdr_info\n+#  define dl_iterate_phdr(c, b) xdl_iterate_phdr((c), (b))\n # endif\n \n struct DlIteratePhdrData {\n@@ -504,7 +389,8 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n     if (phdr->p_type == PT_LOAD) {\n       uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n       uptr cur_end = cur_beg + phdr->p_memsz;\n-      cur_module->addAddressRange(cur_beg, cur_end);\n+      bool executable = phdr->p_flags & PF_X;\n+      cur_module->addAddressRange(cur_beg, cur_end, executable);\n     }\n   }\n   return 0;\n@@ -527,6 +413,19 @@ void SetIndirectCallWrapper(uptr wrapper) {\n   indirect_call_wrapper = wrapper;\n }\n \n+void PrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n+  // Some kinds of sandboxes may forbid filesystem access, so we won't be able\n+  // to read the file mappings from /proc/self/maps. Luckily, neither the\n+  // process will be able to load additional libraries, so it's fine to use the\n+  // cached mappings.\n+  MemoryMappingLayout::CacheMemoryMappings();\n+  // Same for /proc/self/exe in the symbolizer.\n+#if !SANITIZER_GO\n+  Symbolizer::GetOrInit()->PrepareForSandboxing();\n+  CovPrepareForSandboxing(args);\n+#endif\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "2c2a1d74be702d27650320e41104e9a13f28ecb1", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -129,6 +129,14 @@ int internal_fork() {\n   return fork();\n }\n \n+uptr internal_rename(const char *oldpath, const char *newpath) {\n+  return rename(oldpath, newpath);\n+}\n+\n+uptr internal_ftruncate(fd_t fd, uptr size) {\n+  return ftruncate(fd, size);\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   struct stat st;"}, {"sha": "b989ed0c90f52f90745509e0bd4fc32121803a76", "filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.cc", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,17 @@\n+//===-- sanitizer_persistent_allocator.cc -----------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_persistent_allocator.h\"\n+\n+namespace __sanitizer {\n+\n+PersistentAllocator thePersistentAllocator;\n+\n+}  // namespace __sanitizer"}, {"sha": "e29b7bd57aa5c379588760896bf79d050779c151", "filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,69 @@\n+//===-- sanitizer_persistent_allocator.h ------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// A fast memory allocator that does not support free() nor realloc().\n+// All allocations are forever.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_PERSISTENT_ALLOCATOR_H\n+#define SANITIZER_PERSISTENT_ALLOCATOR_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_common.h\"\n+\n+namespace __sanitizer {\n+\n+class PersistentAllocator {\n+ public:\n+  void *alloc(uptr size);\n+\n+ private:\n+  void *tryAlloc(uptr size);\n+  StaticSpinMutex mtx;  // Protects alloc of new blocks for region allocator.\n+  atomic_uintptr_t region_pos;  // Region allocator for Node's.\n+  atomic_uintptr_t region_end;\n+};\n+\n+inline void *PersistentAllocator::tryAlloc(uptr size) {\n+  // Optimisic lock-free allocation, essentially try to bump the region ptr.\n+  for (;;) {\n+    uptr cmp = atomic_load(&region_pos, memory_order_acquire);\n+    uptr end = atomic_load(&region_end, memory_order_acquire);\n+    if (cmp == 0 || cmp + size > end) return 0;\n+    if (atomic_compare_exchange_weak(&region_pos, &cmp, cmp + size,\n+                                     memory_order_acquire))\n+      return (void *)cmp;\n+  }\n+}\n+\n+inline void *PersistentAllocator::alloc(uptr size) {\n+  // First, try to allocate optimisitically.\n+  void *s = tryAlloc(size);\n+  if (s) return s;\n+  // If failed, lock, retry and alloc new superblock.\n+  SpinMutexLock l(&mtx);\n+  for (;;) {\n+    s = tryAlloc(size);\n+    if (s) return s;\n+    atomic_store(&region_pos, 0, memory_order_relaxed);\n+    uptr allocsz = 64 * 1024;\n+    if (allocsz < size) allocsz = size;\n+    uptr mem = (uptr)MmapOrDie(allocsz, \"stack depot\");\n+    atomic_store(&region_end, mem + allocsz, memory_order_release);\n+    atomic_store(&region_pos, mem, memory_order_release);\n+  }\n+}\n+\n+extern PersistentAllocator thePersistentAllocator;\n+inline void *PersistentAlloc(uptr sz) {\n+  return thePersistentAllocator.alloc(sz);\n+}\n+\n+} // namespace __sanitizer\n+\n+#endif  // SANITIZER_PERSISTENT_ALLOCATOR_H"}, {"sha": "81a09927d7946765d02c3089f9505df310ff035b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -27,6 +27,12 @@\n # define SI_LINUX_NOT_ANDROID 0\n #endif\n \n+#if SANITIZER_FREEBSD\n+# define SI_FREEBSD 1\n+#else\n+# define SI_FREEBSD 0\n+#endif\n+\n #if SANITIZER_LINUX\n # define SI_LINUX 1\n #else\n@@ -73,11 +79,11 @@\n #define SANITIZER_INTERCEPT_STRPTIME SI_NOT_WINDOWS\n \n #define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX\n+#define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX_NOT_ANDROID\n \n #ifndef SANITIZER_INTERCEPT_PRINTF\n # define SANITIZER_INTERCEPT_PRINTF SI_NOT_WINDOWS\n-# define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX\n+# define SANITIZER_INTERCEPT_ISOC99_PRINTF SI_LINUX_NOT_ANDROID\n #endif\n \n #define SANITIZER_INTERCEPT_FREXP 1\n@@ -86,10 +92,10 @@\n #define SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS \\\n   SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_GETPWENT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_GETPWENT SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETPWENT_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SETPWENT SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SETPWENT SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_CLOCK_GETTIME SI_LINUX\n #define SANITIZER_INTERCEPT_GETITIMER SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_TIME SI_NOT_WINDOWS\n@@ -102,9 +108,12 @@\n #define SANITIZER_INTERCEPT_GETSOCKNAME SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETHOSTBYNAME SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETHOSTBYNAME_R SI_LINUX\n+#define SANITIZER_INTERCEPT_GETHOSTBYNAME2_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETHOSTBYADDR_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_GETHOSTENT_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETSOCKOPT SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_ACCEPT SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX\n+#define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n@@ -117,13 +126,13 @@\n    (defined(__i386) || defined (__x86_64))  // NOLINT\n #define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX\n+#define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRTOIMAX SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MBSTOWCS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MBSNRTOWCS SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSTOMBS SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_WCSNRTOMBS SI_MAC || SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX\n+#define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_REALPATH SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_CONFSTR SI_MAC || SI_LINUX_NOT_ANDROID\n@@ -140,19 +149,21 @@\n #define SANITIZER_INTERCEPT_SIGWAIT SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SIGWAITINFO SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGTIMEDWAIT SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_SIGSETOPS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SIGSETOPS \\\n+  SI_FREEBSD || SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n #define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_STATFS SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STATFS SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATFS64 \\\n   (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATVFS SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_ETHER SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ETHER_NTOA_ATON SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_ETHER_HOST SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_ETHER_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_SHMCTL \\\n   (SI_LINUX_NOT_ANDROID && SANITIZER_WORDSIZE == 64)\n@@ -161,13 +172,27 @@\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n   SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n+  SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n+  SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n #define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_LGAMMA_R SI_LINUX\n+#define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_RAND_R SI_MAC || SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_ICONV SI_LINUX_NOT_ANDROID\n@@ -176,7 +201,7 @@\n // FIXME: getline seems to be available on OSX 10.7\n #define SANITIZER_INTERCEPT_GETLINE SI_LINUX_NOT_ANDROID\n \n-#define SANITIZER_INTERCEPT__EXIT SI_LINUX\n+#define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD\n \n #define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP SI_LINUX_NOT_ANDROID\n@@ -201,5 +226,10 @@\n #define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FFLUSH SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_FCLOSE SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_GETPASS SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n+\n+#define SANITIZER_INTERCEPT_MLOCKX SI_NOT_WINDOWS\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "8779d8adf7274ac09d530f3577a203468f12d1b4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -27,7 +27,7 @@\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n // fine with newer headers, too.\n #include <asm/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t\n@@ -48,21 +48,19 @@\n \n #include <linux/aio_abi.h>\n \n-#if SANITIZER_ANDROID\n-#include <asm/statfs.h>\n-#else\n-#include <sys/statfs.h>\n-#endif\n-\n #if !SANITIZER_ANDROID\n+#include <sys/statfs.h>\n #include <linux/perf_event.h>\n #endif\n \n namespace __sanitizer {\n+#if !SANITIZER_ANDROID\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n+#endif\n }  // namespace __sanitizer\n \n-#if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\n+#if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\\\n+                            && !defined(__mips__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "f5678dceccc8e7e7d87cd1ff6581251c68703380", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -33,7 +33,6 @@\n #include <sys/socket.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n-#include <sys/timeb.h>\n #include <sys/times.h>\n #include <sys/types.h>\n #include <sys/utsname.h>\n@@ -43,6 +42,7 @@\n \n #if !SANITIZER_ANDROID\n #include <sys/mount.h>\n+#include <sys/timeb.h>\n #endif\n \n #if SANITIZER_LINUX\n@@ -189,13 +189,14 @@ namespace __sanitizer {\n   unsigned struct_tms_sz = sizeof(struct tms);\n   unsigned struct_sigevent_sz = sizeof(struct sigevent);\n   unsigned struct_sched_param_sz = sizeof(struct sched_param);\n-  unsigned struct_statfs_sz = sizeof(struct statfs);\n+\n \n #if SANITIZER_MAC && !SANITIZER_IOS\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n #endif // SANITIZER_MAC && !SANITIZER_IOS\n \n #if !SANITIZER_ANDROID\n+  unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n   unsigned ucontext_t_sz = sizeof(ucontext_t);\n #endif // !SANITIZER_ANDROID\n@@ -287,6 +288,7 @@ namespace __sanitizer {\n   int ptrace_setfpregs = PTRACE_SETFPREGS;\n   int ptrace_getfpxregs = PTRACE_GETFPXREGS;\n   int ptrace_setfpxregs = PTRACE_SETFPXREGS;\n+  int ptrace_geteventmsg = PTRACE_GETEVENTMSG;\n #if (defined(PTRACE_GETSIGINFO) && defined(PTRACE_SETSIGINFO)) ||              \\\n     (defined(PT_GETSIGINFO) && defined(PT_SETSIGINFO))\n   int ptrace_getsiginfo = PTRACE_GETSIGINFO;\n@@ -396,7 +398,7 @@ namespace __sanitizer {\n   unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n #endif\n \n-  unsigned IOCTL_NOT_PRESENT = 0;\n+  const unsigned IOCTL_NOT_PRESENT = 0;\n \n   unsigned IOCTL_FIOASYNC = FIOASYNC;\n   unsigned IOCTL_FIOCLEX = FIOCLEX;\n@@ -1056,6 +1058,10 @@ CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n \n CHECK_TYPE_SIZE(clock_t);\n \n+#if SANITIZER_LINUX\n+CHECK_TYPE_SIZE(clockid_t);\n+#endif\n+\n #if !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(ifaddrs);\n CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_next);\n@@ -1086,11 +1092,13 @@ CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n COMPILER_CHECK(sizeof(__sanitizer_mallinfo) == sizeof(struct mallinfo));\n #endif\n \n+#if !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(timeb);\n CHECK_SIZE_AND_OFFSET(timeb, time);\n CHECK_SIZE_AND_OFFSET(timeb, millitm);\n CHECK_SIZE_AND_OFFSET(timeb, timezone);\n CHECK_SIZE_AND_OFFSET(timeb, dstflag);\n+#endif\n \n CHECK_TYPE_SIZE(passwd);\n CHECK_SIZE_AND_OFFSET(passwd, pw_name);"}, {"sha": "caa36a4071b09d92bce82c6f94d6c10a6b1db367", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -37,11 +37,11 @@ namespace __sanitizer {\n   extern unsigned struct_itimerspec_sz;\n   extern unsigned struct_sigevent_sz;\n   extern unsigned struct_sched_param_sz;\n-  extern unsigned struct_statfs_sz;\n   extern unsigned struct_statfs64_sz;\n-  extern unsigned struct_sockaddr_sz;\n \n #if !SANITIZER_ANDROID\n+  extern unsigned struct_statfs_sz;\n+  extern unsigned struct_sockaddr_sz;\n   extern unsigned ucontext_t_sz;\n #endif // !SANITIZER_ANDROID\n \n@@ -65,6 +65,13 @@ namespace __sanitizer {\n #elif defined(__powerpc64__)\n   const unsigned struct_kernel_stat_sz = 144;\n   const unsigned struct_kernel_stat64_sz = 104;\n+#elif defined(__mips__)\n+  #if SANITIZER_WORDSIZE == 64\n+  const unsigned struct_kernel_stat_sz = 216;\n+  #else\n+  const unsigned struct_kernel_stat_sz = 144;\n+  #endif\n+  const unsigned struct_kernel_stat64_sz = 104;\n #endif\n   struct __sanitizer_perf_event_attr {\n     unsigned type;\n@@ -160,6 +167,12 @@ namespace __sanitizer {\n     unsigned __seq;\n     u64 __unused1;\n     u64 __unused2;\n+#elif defined(__mips__)\n+    unsigned int mode;\n+    unsigned short __seq;\n+    unsigned short __pad1;\n+    unsigned long __unused1;\n+    unsigned long __unused2;\n #else\n     unsigned short mode;\n     unsigned short __pad1;\n@@ -188,15 +201,15 @@ namespace __sanitizer {\n     u64 shm_ctime;\n   #else\n     uptr shm_atime;\n-  #ifndef _LP64\n+  #if !defined(_LP64) && !defined(__mips__)\n     uptr __unused1;\n   #endif\n     uptr shm_dtime;\n-  #ifndef _LP64\n+  #if !defined(_LP64) && !defined(__mips__)\n     uptr __unused2;\n   #endif\n     uptr shm_ctime;\n-  #ifndef _LP64\n+  #if !defined(_LP64) && !defined(__mips__)\n     uptr __unused3;\n   #endif\n   #endif\n@@ -438,8 +451,13 @@ namespace __sanitizer {\n   typedef long __sanitizer_clock_t;\n #endif\n \n+#if SANITIZER_LINUX\n+  typedef int __sanitizer_clockid_t;\n+#endif\n+\n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n-#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\n+#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\\\n+                   || defined(__mips__)\n   typedef unsigned __sanitizer___kernel_uid_t;\n   typedef unsigned __sanitizer___kernel_gid_t;\n #else\n@@ -452,7 +470,7 @@ namespace __sanitizer {\n   typedef long __sanitizer___kernel_off_t;\n #endif\n \n-#if defined(__powerpc__) || defined(__aarch64__)\n+#if defined(__powerpc__) || defined(__aarch64__) || defined(__mips__)\n   typedef unsigned int __sanitizer___kernel_old_uid_t;\n   typedef unsigned int __sanitizer___kernel_old_gid_t;\n #else\n@@ -492,6 +510,9 @@ namespace __sanitizer {\n \n   // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n   struct __sanitizer_sigaction {\n+#if defined(__mips__) && !SANITIZER_FREEBSD\n+    unsigned int sa_flags;\n+#endif\n     union {\n       void (*sigaction)(int sig, void *siginfo, void *uctx);\n       void (*handler)(int sig);\n@@ -501,10 +522,15 @@ namespace __sanitizer {\n     __sanitizer_sigset_t sa_mask;\n #else\n     __sanitizer_sigset_t sa_mask;\n+#ifndef __mips__\n     int sa_flags;\n #endif\n+#endif\n #if SANITIZER_LINUX\n     void (*sa_restorer)();\n+#endif\n+#if defined(__mips__) && (SANITIZER_WORDSIZE == 32)\n+    int sa_resv[1];\n #endif\n   };\n \n@@ -676,6 +702,7 @@ namespace __sanitizer {\n   extern int ptrace_setsiginfo;\n   extern int ptrace_getregset;\n   extern int ptrace_setregset;\n+  extern int ptrace_geteventmsg;\n #endif\n \n #if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n@@ -718,7 +745,7 @@ struct __sanitizer_obstack {\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n-#if defined(__powerpc__) || defined(__powerpc64__)\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n #define IOC_SIZEBITS 13\n #define IOC_DIRBITS 3\n #define IOC_NONE 1U\n@@ -832,7 +859,7 @@ struct __sanitizer_obstack {\n \n   // A special value to mark ioctls that are not present on the target platform,\n   // when it can not be determined without including any system headers.\n-  extern unsigned IOCTL_NOT_PRESENT;\n+  extern const unsigned IOCTL_NOT_PRESENT;\n \n   extern unsigned IOCTL_FIOASYNC;\n   extern unsigned IOCTL_FIOCLEX;"}, {"sha": "24e99f9472df6c559fa568a3cc2055a70e36f59b", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -204,6 +204,17 @@ void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n   return internal_iserror(map) ? 0 : (void *)map;\n }\n \n+void *MapWritableFileToMemory(void *addr, uptr size, uptr fd, uptr offset) {\n+  uptr flags = MAP_SHARED;\n+  if (addr) flags |= MAP_FIXED;\n+  uptr p = internal_mmap(addr, size, PROT_READ | PROT_WRITE, flags, fd, offset);\n+  if (internal_iserror(p)) {\n+    Printf(\"could not map writable file (%zd, %zu, %zu): %zd\\n\", fd, offset,\n+           size, p);\n+    return 0;\n+  }\n+  return (void *)p;\n+}\n \n static inline bool IntervalsAreSeparate(uptr start1, uptr end1,\n                                         uptr start2, uptr end2) {"}, {"sha": "b4e42c724625055fe3bdfcbf97193c9bb5c992f4", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -42,30 +42,49 @@ void FlushUnneededShadowMemory(uptr addr, uptr size) {\n   madvise((void*)addr, size, MADV_DONTNEED);\n }\n \n-void DisableCoreDumper() {\n-  struct rlimit nocore;\n-  nocore.rlim_cur = 0;\n-  nocore.rlim_max = 0;\n-  setrlimit(RLIMIT_CORE, &nocore);\n+static rlim_t getlim(int res) {\n+  rlimit rlim;\n+  CHECK_EQ(0, getrlimit(res, &rlim));\n+  return rlim.rlim_cur;\n+}\n+\n+static void setlim(int res, rlim_t lim) {\n+  // The following magic is to prevent clang from replacing it with memset.\n+  volatile struct rlimit rlim;\n+  rlim.rlim_cur = lim;\n+  rlim.rlim_max = lim;\n+  if (setrlimit(res, (struct rlimit*)&rlim)) {\n+    Report(\"ERROR: %s setrlimit() failed %d\\n\", SanitizerToolName, errno);\n+    Die();\n+  }\n+}\n+\n+void DisableCoreDumperIfNecessary() {\n+  if (common_flags()->disable_coredump) {\n+    setlim(RLIMIT_CORE, 0);\n+  }\n }\n \n bool StackSizeIsUnlimited() {\n-  struct rlimit rlim;\n-  CHECK_EQ(0, getrlimit(RLIMIT_STACK, &rlim));\n-  return ((uptr)rlim.rlim_cur == (uptr)-1);\n+  rlim_t stack_size = getlim(RLIMIT_STACK);\n+  return (stack_size == RLIM_INFINITY);\n }\n \n void SetStackSizeLimitInBytes(uptr limit) {\n-  struct rlimit rlim;\n-  rlim.rlim_cur = limit;\n-  rlim.rlim_max = limit;\n-  if (setrlimit(RLIMIT_STACK, &rlim)) {\n-    Report(\"ERROR: %s setrlimit() failed %d\\n\", SanitizerToolName, errno);\n-    Die();\n-  }\n+  setlim(RLIMIT_STACK, (rlim_t)limit);\n   CHECK(!StackSizeIsUnlimited());\n }\n \n+bool AddressSpaceIsUnlimited() {\n+  rlim_t as_size = getlim(RLIMIT_AS);\n+  return (as_size == RLIM_INFINITY);\n+}\n+\n+void SetAddressSpaceUnlimited() {\n+  setlim(RLIMIT_AS, RLIM_INFINITY);\n+  CHECK(AddressSpaceIsUnlimited());\n+}\n+\n void SleepForSeconds(int seconds) {\n   sleep(seconds);\n }\n@@ -127,7 +146,9 @@ static void MaybeInstallSigaction(int signum,\n   struct sigaction sigact;\n   internal_memset(&sigact, 0, sizeof(sigact));\n   sigact.sa_sigaction = (sa_sigaction_t)handler;\n-  sigact.sa_flags = SA_SIGINFO;\n+  // Do not block the signal from being received in that signal's handler.\n+  // Clients are responsible for handling this correctly.\n+  sigact.sa_flags = SA_SIGINFO | SA_NODEFER;\n   if (common_flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n   CHECK_EQ(0, internal_sigaction(signum, &sigact, 0));\n   VReport(1, \"Installed the sigaction for signal %d\\n\", signum);\n@@ -143,6 +164,28 @@ void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n }\n #endif  // SANITIZER_GO\n \n+bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n+  uptr page_size = GetPageSizeCached();\n+  // Checking too large memory ranges is slow.\n+  CHECK_LT(size, page_size * 10);\n+  int sock_pair[2];\n+  if (pipe(sock_pair))\n+    return false;\n+  uptr bytes_written =\n+      internal_write(sock_pair[1], reinterpret_cast<void *>(beg), size);\n+  int write_errno;\n+  bool result;\n+  if (internal_iserror(bytes_written, &write_errno)) {\n+    CHECK_EQ(EFAULT, write_errno);\n+    result = false;\n+  } else {\n+    result = (bytes_written == size);\n+  }\n+  internal_close(sock_pair[0]);\n+  internal_close(sock_pair[1]);\n+  return result;\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_POSIX"}, {"sha": "fc0c357ba86cca243d8956c4bad4a28466aa546f", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,7 +20,8 @@\n #include <stdio.h>\n #include <stdarg.h>\n \n-#if SANITIZER_WINDOWS && !defined(va_copy)\n+#if SANITIZER_WINDOWS && defined(_MSC_VER) && _MSC_VER < 1800 &&               \\\n+      !defined(va_copy)\n # define va_copy(dst, src) ((dst) = (src))\n #endif\n "}, {"sha": "7477abf30b67e2c8a0537bdf6be4389a93197225", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -24,6 +24,9 @@ struct ProcSelfMapsBuff {\n   uptr mmaped_size;\n   uptr len;\n };\n+\n+// Reads process memory map in an OS-specific way.\n+void ReadProcMaps(ProcSelfMapsBuff *proc_maps);\n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n \n class MemoryMappingLayout {\n@@ -55,7 +58,7 @@ class MemoryMappingLayout {\n   // platform-specific files.\n # if SANITIZER_FREEBSD || SANITIZER_LINUX\n   ProcSelfMapsBuff proc_self_maps_;\n-  char *current_;\n+  const char *current_;\n \n   // Static mappings cache.\n   static ProcSelfMapsBuff cached_proc_self_maps_;\n@@ -84,6 +87,11 @@ void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size);\n // Returns code range for the specified module.\n bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end);\n \n+bool IsDecimal(char c);\n+uptr ParseDecimal(const char **p);\n+bool IsHex(char c);\n+uptr ParseHex(const char **p);\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_PROCMAPS_H"}, {"sha": "ca9900fe9ee9b08fb4c5fd2469d2c7a10cd69198", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,176 @@\n+//===-- sanitizer_procmaps_common.cc --------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Information about the process mappings (common parts).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+namespace __sanitizer {\n+\n+// Linker initialized.\n+ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n+StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n+\n+static int TranslateDigit(char c) {\n+  if (c >= '0' && c <= '9')\n+    return c - '0';\n+  if (c >= 'a' && c <= 'f')\n+    return c - 'a' + 10;\n+  if (c >= 'A' && c <= 'F')\n+    return c - 'A' + 10;\n+  return -1;\n+}\n+\n+// Parse a number and promote 'p' up to the first non-digit character.\n+static uptr ParseNumber(const char **p, int base) {\n+  uptr n = 0;\n+  int d;\n+  CHECK(base >= 2 && base <= 16);\n+  while ((d = TranslateDigit(**p)) >= 0 && d < base) {\n+    n = n * base + d;\n+    (*p)++;\n+  }\n+  return n;\n+}\n+\n+bool IsDecimal(char c) {\n+  int d = TranslateDigit(c);\n+  return d >= 0 && d < 10;\n+}\n+\n+uptr ParseDecimal(const char **p) {\n+  return ParseNumber(p, 10);\n+}\n+\n+bool IsHex(char c) {\n+  int d = TranslateDigit(c);\n+  return d >= 0 && d < 16;\n+}\n+\n+uptr ParseHex(const char **p) {\n+  return ParseNumber(p, 16);\n+}\n+\n+MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n+  ReadProcMaps(&proc_self_maps_);\n+  if (cache_enabled) {\n+    if (proc_self_maps_.mmaped_size == 0) {\n+      LoadFromCache();\n+      CHECK_GT(proc_self_maps_.len, 0);\n+    }\n+  } else {\n+    CHECK_GT(proc_self_maps_.mmaped_size, 0);\n+  }\n+  Reset();\n+  // FIXME: in the future we may want to cache the mappings on demand only.\n+  if (cache_enabled)\n+    CacheMemoryMappings();\n+}\n+\n+MemoryMappingLayout::~MemoryMappingLayout() {\n+  // Only unmap the buffer if it is different from the cached one. Otherwise\n+  // it will be unmapped when the cache is refreshed.\n+  if (proc_self_maps_.data != cached_proc_self_maps_.data) {\n+    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);\n+  }\n+}\n+\n+void MemoryMappingLayout::Reset() {\n+  current_ = proc_self_maps_.data;\n+}\n+\n+// static\n+void MemoryMappingLayout::CacheMemoryMappings() {\n+  SpinMutexLock l(&cache_lock_);\n+  // Don't invalidate the cache if the mappings are unavailable.\n+  ProcSelfMapsBuff old_proc_self_maps;\n+  old_proc_self_maps = cached_proc_self_maps_;\n+  ReadProcMaps(&cached_proc_self_maps_);\n+  if (cached_proc_self_maps_.mmaped_size == 0) {\n+    cached_proc_self_maps_ = old_proc_self_maps;\n+  } else {\n+    if (old_proc_self_maps.mmaped_size) {\n+      UnmapOrDie(old_proc_self_maps.data,\n+                 old_proc_self_maps.mmaped_size);\n+    }\n+  }\n+}\n+\n+void MemoryMappingLayout::LoadFromCache() {\n+  SpinMutexLock l(&cache_lock_);\n+  if (cached_proc_self_maps_.data) {\n+    proc_self_maps_ = cached_proc_self_maps_;\n+  }\n+}\n+\n+uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n+                                            uptr max_modules,\n+                                            string_predicate_t filter) {\n+  Reset();\n+  uptr cur_beg, cur_end, cur_offset, prot;\n+  InternalScopedBuffer<char> module_name(kMaxPathLength);\n+  uptr n_modules = 0;\n+  for (uptr i = 0; n_modules < max_modules &&\n+                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n+                            module_name.size(), &prot);\n+       i++) {\n+    const char *cur_name = module_name.data();\n+    if (cur_name[0] == '\\0')\n+      continue;\n+    if (filter && !filter(cur_name))\n+      continue;\n+    void *mem = &modules[n_modules];\n+    // Don't subtract 'cur_beg' from the first entry:\n+    // * If a binary is compiled w/o -pie, then the first entry in\n+    //   process maps is likely the binary itself (all dynamic libs\n+    //   are mapped higher in address space). For such a binary,\n+    //   instruction offset in binary coincides with the actual\n+    //   instruction address in virtual memory (as code section\n+    //   is mapped to a fixed memory range).\n+    // * If a binary is compiled with -pie, all the modules are\n+    //   mapped high at address space (in particular, higher than\n+    //   shadow memory of the tool), so the module can't be the\n+    //   first entry.\n+    uptr base_address = (i ? cur_beg : 0) - cur_offset;\n+    LoadedModule *cur_module = new(mem) LoadedModule(cur_name, base_address);\n+    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n+    n_modules++;\n+  }\n+  return n_modules;\n+}\n+\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n+  char *smaps = 0;\n+  uptr smaps_cap = 0;\n+  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n+      &smaps, &smaps_cap, 64<<20);\n+  uptr start = 0;\n+  bool file = false;\n+  const char *pos = smaps;\n+  while (pos < smaps + smaps_len) {\n+    if (IsHex(pos[0])) {\n+      start = ParseHex(&pos);\n+      for (; *pos != '/' && *pos > '\\n'; pos++) {}\n+      file = *pos == '/';\n+    } else if (internal_strncmp(pos, \"Rss:\", 4) == 0) {\n+      while (!IsDecimal(*pos)) pos++;\n+      uptr rss = ParseDecimal(&pos) * 1024;\n+      cb(start, rss, file, stats, stats_size);\n+    }\n+    while (*pos++ != '\\n') {}\n+  }\n+  UnmapOrDie(smaps, smaps_cap);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "fbc55203ab4dc7b721e01dafdc01ef3858b7718c", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_freebsd.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_freebsd.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,86 @@\n+//===-- sanitizer_procmaps_freebsd.cc -------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Information about the process mappings (FreeBSD-specific parts).\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_FREEBSD\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_freebsd.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+#include <unistd.h>\n+#include <sys/sysctl.h>\n+#include <sys/user.h>\n+\n+// Fix 'kinfo_vmentry' definition on FreeBSD prior v9.2 in 32-bit mode.\n+#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\n+# include <osreldate.h>\n+# if __FreeBSD_version <= 902001  // v9.2\n+#  define kinfo_vmentry xkinfo_vmentry\n+# endif\n+#endif\n+\n+namespace __sanitizer {\n+\n+void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n+  const int Mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_VMMAP, getpid() };\n+  size_t Size = 0;\n+  int Err = sysctl(Mib, 4, NULL, &Size, NULL, 0);\n+  CHECK_EQ(Err, 0);\n+  CHECK_GT(Size, 0);\n+\n+  size_t MmapedSize = Size * 4 / 3;\n+  void *VmMap = MmapOrDie(MmapedSize, \"ReadProcMaps()\");\n+  Size = MmapedSize;\n+  Err = sysctl(Mib, 4, VmMap, &Size, NULL, 0);\n+  CHECK_EQ(Err, 0);\n+\n+  proc_maps->data = (char*)VmMap;\n+  proc_maps->mmaped_size = MmapedSize;\n+  proc_maps->len = Size;\n+}\n+\n+bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n+                               char filename[], uptr filename_size,\n+                               uptr *protection) {\n+  char *last = proc_self_maps_.data + proc_self_maps_.len;\n+  if (current_ >= last) return false;\n+  uptr dummy;\n+  if (!start) start = &dummy;\n+  if (!end) end = &dummy;\n+  if (!offset) offset = &dummy;\n+  if (!protection) protection = &dummy;\n+  struct kinfo_vmentry *VmEntry = (struct kinfo_vmentry*)current_;\n+\n+  *start = (uptr)VmEntry->kve_start;\n+  *end = (uptr)VmEntry->kve_end;\n+  *offset = (uptr)VmEntry->kve_offset;\n+\n+  *protection = 0;\n+  if ((VmEntry->kve_protection & KVME_PROT_READ) != 0)\n+    *protection |= kProtectionRead;\n+  if ((VmEntry->kve_protection & KVME_PROT_WRITE) != 0)\n+    *protection |= kProtectionWrite;\n+  if ((VmEntry->kve_protection & KVME_PROT_EXEC) != 0)\n+    *protection |= kProtectionExecute;\n+\n+  if (filename != NULL && filename_size > 0) {\n+    internal_snprintf(filename,\n+                      Min(filename_size, (uptr)PATH_MAX),\n+                      \"%s\", VmEntry->kve_path);\n+  }\n+\n+  current_ += VmEntry->kve_structsize;\n+\n+  return true;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_FREEBSD"}, {"sha": "43babf89319d61e5318e7eeb8315ed9ac64ec965", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "modified", "additions": 3, "deletions": 217, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -9,151 +9,20 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_platform.h\"\n-#if SANITIZER_FREEBSD || SANITIZER_LINUX\n+#if SANITIZER_LINUX\n #include \"sanitizer_common.h\"\n-#include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n \n-#if SANITIZER_FREEBSD\n-#include <unistd.h>\n-#include <sys/sysctl.h>\n-#include <sys/user.h>\n-#endif\n-\n namespace __sanitizer {\n \n-// Linker initialized.\n-ProcSelfMapsBuff MemoryMappingLayout::cached_proc_self_maps_;\n-StaticSpinMutex MemoryMappingLayout::cache_lock_;  // Linker initialized.\n-\n-static void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n-#if SANITIZER_FREEBSD\n-  const int Mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_VMMAP, getpid() };\n-  size_t Size = 0;\n-  int Err = sysctl(Mib, 4, NULL, &Size, NULL, 0);\n-  CHECK_EQ(Err, 0);\n-  CHECK_GT(Size, 0);\n-\n-  size_t MmapedSize = Size * 4 / 3;\n-  void *VmMap = MmapOrDie(MmapedSize, \"ReadProcMaps()\");\n-  Size = MmapedSize;\n-  Err = sysctl(Mib, 4, VmMap, &Size, NULL, 0);\n-  CHECK_EQ(Err, 0);\n-\n-  proc_maps->data = (char*)VmMap;\n-  proc_maps->mmaped_size = MmapedSize;\n-  proc_maps->len = Size;\n-#else\n+void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n   proc_maps->len = ReadFileToBuffer(\"/proc/self/maps\", &proc_maps->data,\n                                     &proc_maps->mmaped_size, 1 << 26);\n-#endif\n-}\n-\n-MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n-  ReadProcMaps(&proc_self_maps_);\n-  if (cache_enabled) {\n-    if (proc_self_maps_.mmaped_size == 0) {\n-      LoadFromCache();\n-      CHECK_GT(proc_self_maps_.len, 0);\n-    }\n-  } else {\n-    CHECK_GT(proc_self_maps_.mmaped_size, 0);\n-  }\n-  Reset();\n-  // FIXME: in the future we may want to cache the mappings on demand only.\n-  if (cache_enabled)\n-    CacheMemoryMappings();\n-}\n-\n-MemoryMappingLayout::~MemoryMappingLayout() {\n-  // Only unmap the buffer if it is different from the cached one. Otherwise\n-  // it will be unmapped when the cache is refreshed.\n-  if (proc_self_maps_.data != cached_proc_self_maps_.data) {\n-    UnmapOrDie(proc_self_maps_.data, proc_self_maps_.mmaped_size);\n-  }\n-}\n-\n-void MemoryMappingLayout::Reset() {\n-  current_ = proc_self_maps_.data;\n-}\n-\n-// static\n-void MemoryMappingLayout::CacheMemoryMappings() {\n-  SpinMutexLock l(&cache_lock_);\n-  // Don't invalidate the cache if the mappings are unavailable.\n-  ProcSelfMapsBuff old_proc_self_maps;\n-  old_proc_self_maps = cached_proc_self_maps_;\n-  ReadProcMaps(&cached_proc_self_maps_);\n-  if (cached_proc_self_maps_.mmaped_size == 0) {\n-    cached_proc_self_maps_ = old_proc_self_maps;\n-  } else {\n-    if (old_proc_self_maps.mmaped_size) {\n-      UnmapOrDie(old_proc_self_maps.data,\n-                 old_proc_self_maps.mmaped_size);\n-    }\n-  }\n-}\n-\n-void MemoryMappingLayout::LoadFromCache() {\n-  SpinMutexLock l(&cache_lock_);\n-  if (cached_proc_self_maps_.data) {\n-    proc_self_maps_ = cached_proc_self_maps_;\n-  }\n-}\n-\n-#if !SANITIZER_FREEBSD\n-// Parse a hex value in str and update str.\n-static uptr ParseHex(char **str) {\n-  uptr x = 0;\n-  char *s;\n-  for (s = *str; ; s++) {\n-    char c = *s;\n-    uptr v = 0;\n-    if (c >= '0' && c <= '9')\n-      v = c - '0';\n-    else if (c >= 'a' && c <= 'f')\n-      v = c - 'a' + 10;\n-    else if (c >= 'A' && c <= 'F')\n-      v = c - 'A' + 10;\n-    else\n-      break;\n-    x = x * 16 + v;\n-  }\n-  *str = s;\n-  return x;\n }\n \n static bool IsOneOf(char c, char c1, char c2) {\n   return c == c1 || c == c2;\n }\n-#endif\n-\n-static bool IsDecimal(char c) {\n-  return c >= '0' && c <= '9';\n-}\n-\n-static bool IsHex(char c) {\n-  return (c >= '0' && c <= '9')\n-      || (c >= 'a' && c <= 'f');\n-}\n-\n-static uptr ReadHex(const char *p) {\n-  uptr v = 0;\n-  for (; IsHex(p[0]); p++) {\n-    if (p[0] >= '0' && p[0] <= '9')\n-      v = v * 16 + p[0] - '0';\n-    else\n-      v = v * 16 + p[0] - 'a' + 10;\n-  }\n-  return v;\n-}\n-\n-static uptr ReadDecimal(const char *p) {\n-  uptr v = 0;\n-  for (; IsDecimal(p[0]); p++)\n-    v = v * 10 + p[0] - '0';\n-  return v;\n-}\n \n bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n                                char filename[], uptr filename_size,\n@@ -165,29 +34,6 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n   if (!end) end = &dummy;\n   if (!offset) offset = &dummy;\n   if (!protection) protection = &dummy;\n-#if SANITIZER_FREEBSD\n-  struct kinfo_vmentry *VmEntry = (struct kinfo_vmentry*)current_;\n-\n-  *start = (uptr)VmEntry->kve_start;\n-  *end = (uptr)VmEntry->kve_end;\n-  *offset = (uptr)VmEntry->kve_offset;\n-\n-  *protection = 0;\n-  if ((VmEntry->kve_protection & KVME_PROT_READ) != 0)\n-    *protection |= kProtectionRead;\n-  if ((VmEntry->kve_protection & KVME_PROT_WRITE) != 0)\n-    *protection |= kProtectionWrite;\n-  if ((VmEntry->kve_protection & KVME_PROT_EXEC) != 0)\n-    *protection |= kProtectionExecute;\n-\n-  if (filename != NULL && filename_size > 0) {\n-    internal_snprintf(filename,\n-                      Min(filename_size, (uptr)PATH_MAX),\n-                      \"%s\", VmEntry->kve_path);\n-  }\n-\n-  current_ += VmEntry->kve_structsize;\n-#else  // !SANITIZER_FREEBSD\n   char *next_line = (char*)internal_memchr(current_, '\\n', last - current_);\n   if (next_line == 0)\n     next_line = last;\n@@ -234,69 +80,9 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n   if (filename && i < filename_size)\n     filename[i] = 0;\n   current_ = next_line + 1;\n-#endif  // !SANITIZER_FREEBSD\n   return true;\n }\n \n-uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n-                                            uptr max_modules,\n-                                            string_predicate_t filter) {\n-  Reset();\n-  uptr cur_beg, cur_end, cur_offset;\n-  InternalScopedBuffer<char> module_name(kMaxPathLength);\n-  uptr n_modules = 0;\n-  for (uptr i = 0; n_modules < max_modules &&\n-                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n-                            module_name.size(), 0);\n-       i++) {\n-    const char *cur_name = module_name.data();\n-    if (cur_name[0] == '\\0')\n-      continue;\n-    if (filter && !filter(cur_name))\n-      continue;\n-    void *mem = &modules[n_modules];\n-    // Don't subtract 'cur_beg' from the first entry:\n-    // * If a binary is compiled w/o -pie, then the first entry in\n-    //   process maps is likely the binary itself (all dynamic libs\n-    //   are mapped higher in address space). For such a binary,\n-    //   instruction offset in binary coincides with the actual\n-    //   instruction address in virtual memory (as code section\n-    //   is mapped to a fixed memory range).\n-    // * If a binary is compiled with -pie, all the modules are\n-    //   mapped high at address space (in particular, higher than\n-    //   shadow memory of the tool), so the module can't be the\n-    //   first entry.\n-    uptr base_address = (i ? cur_beg : 0) - cur_offset;\n-    LoadedModule *cur_module = new(mem) LoadedModule(cur_name, base_address);\n-    cur_module->addAddressRange(cur_beg, cur_end);\n-    n_modules++;\n-  }\n-  return n_modules;\n-}\n-\n-void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {\n-  char *smaps = 0;\n-  uptr smaps_cap = 0;\n-  uptr smaps_len = ReadFileToBuffer(\"/proc/self/smaps\",\n-      &smaps, &smaps_cap, 64<<20);\n-  uptr start = 0;\n-  bool file = false;\n-  const char *pos = smaps;\n-  while (pos < smaps + smaps_len) {\n-    if (IsHex(pos[0])) {\n-      start = ReadHex(pos);\n-      for (; *pos != '/' && *pos > '\\n'; pos++) {}\n-      file = *pos == '/';\n-    } else if (internal_strncmp(pos, \"Rss:\", 4) == 0) {\n-      for (; *pos < '0' || *pos > '9'; pos++) {}\n-      uptr rss = ReadDecimal(pos) * 1024;\n-      cb(start, rss, file, stats, stats_size);\n-    }\n-    while (*pos++ != '\\n') {}\n-  }\n-  UnmapOrDie(smaps, smaps_cap);\n-}\n-\n }  // namespace __sanitizer\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX"}, {"sha": "81874c21b1fdac5c8399a320afe96e1b804d3b59", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -73,14 +73,16 @@ template<u32 kLCSegment, typename SegmentCommand>\n bool MemoryMappingLayout::NextSegmentLoad(\n     uptr *start, uptr *end, uptr *offset,\n     char filename[], uptr filename_size, uptr *protection) {\n-  if (protection)\n-    UNIMPLEMENTED();\n   const char* lc = current_load_cmd_addr_;\n   current_load_cmd_addr_ += ((const load_command *)lc)->cmdsize;\n   if (((const load_command *)lc)->cmd == kLCSegment) {\n     const sptr dlloff = _dyld_get_image_vmaddr_slide(current_image_);\n     const SegmentCommand* sc = (const SegmentCommand *)lc;\n     if (start) *start = sc->vmaddr + dlloff;\n+    if (protection) {\n+      // Return the initial protection.\n+      *protection = sc->initprot;\n+    }\n     if (end) *end = sc->vmaddr + sc->vmsize + dlloff;\n     if (offset) {\n       if (current_filetype_ == /*MH_EXECUTE*/ 0x2) {\n@@ -155,12 +157,12 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n                                             uptr max_modules,\n                                             string_predicate_t filter) {\n   Reset();\n-  uptr cur_beg, cur_end;\n+  uptr cur_beg, cur_end, prot;\n   InternalScopedBuffer<char> module_name(kMaxPathLength);\n   uptr n_modules = 0;\n   for (uptr i = 0; n_modules < max_modules &&\n                        Next(&cur_beg, &cur_end, 0, module_name.data(),\n-                            module_name.size(), 0);\n+                            module_name.size(), &prot);\n        i++) {\n     const char *cur_name = module_name.data();\n     if (cur_name[0] == '\\0')\n@@ -176,7 +178,7 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n       cur_module = new(mem) LoadedModule(cur_name, cur_beg);\n       n_modules++;\n     }\n-    cur_module->addAddressRange(cur_beg, cur_end);\n+    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n   }\n   return n_modules;\n }"}, {"sha": "e9be29fb3d50a4776a6917fb2504bf3173453b38", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -18,12 +18,16 @@\n #include \"sanitizer_common.h\"\n \n namespace __sanitizer {\n-class AnsiColorDecorator {\n+class SanitizerCommonDecorator {\n   // FIXME: This is not portable. It assumes the special strings are printed to\n   // stdout, which is not the case on Windows (see SetConsoleTextAttribute()).\n  public:\n-  explicit AnsiColorDecorator(bool use_ansi_colors) : ansi_(use_ansi_colors) { }\n+  SanitizerCommonDecorator() : ansi_(ColorizeReports()) {}\n   const char *Bold()    const { return ansi_ ? \"\\033[1m\" : \"\"; }\n+  const char *Default() const { return ansi_ ? \"\\033[1m\\033[0m\"  : \"\"; }\n+  const char *Warning()    { return Red(); }\n+  const char *EndWarning() { return Default(); }\n+ protected:\n   const char *Black()   const { return ansi_ ? \"\\033[1m\\033[30m\" : \"\"; }\n   const char *Red()     const { return ansi_ ? \"\\033[1m\\033[31m\" : \"\"; }\n   const char *Green()   const { return ansi_ ? \"\\033[1m\\033[32m\" : \"\"; }\n@@ -32,19 +36,10 @@ class AnsiColorDecorator {\n   const char *Magenta() const { return ansi_ ? \"\\033[1m\\033[35m\" : \"\"; }\n   const char *Cyan()    const { return ansi_ ? \"\\033[1m\\033[36m\" : \"\"; }\n   const char *White()   const { return ansi_ ? \"\\033[1m\\033[37m\" : \"\"; }\n-  const char *Default() const { return ansi_ ? \"\\033[1m\\033[0m\"  : \"\"; }\n  private:\n   bool ansi_;\n };\n \n-class SanitizerCommonDecorator: protected AnsiColorDecorator {\n- public:\n-  SanitizerCommonDecorator()\n-      : __sanitizer::AnsiColorDecorator(ColorizeReports()) { }\n-  const char *Warning()    { return Red(); }\n-  const char *EndWarning() { return Default(); }\n-};\n-\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_REPORT_DECORATOR_H"}, {"sha": "e1915cb808f35d0568a1a63696b32df32b61ff0e", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 101, "deletions": 166, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -10,193 +10,128 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_stackdepot.h\"\n+\n #include \"sanitizer_common.h\"\n-#include \"sanitizer_internal_defs.h\"\n-#include \"sanitizer_mutex.h\"\n-#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_stackdepotbase.h\"\n \n namespace __sanitizer {\n \n-const int kTabSize = 1024 * 1024;  // Hash table size.\n-const int kPartBits = 8;\n-const int kPartShift = sizeof(u32) * 8 - kPartBits - 1;\n-const int kPartCount = 1 << kPartBits;  // Number of subparts in the table.\n-const int kPartSize = kTabSize / kPartCount;\n-const int kMaxId = 1 << kPartShift;\n+struct StackDepotDesc {\n+  const uptr *stack;\n+  uptr size;\n+  u32 hash() const {\n+    // murmur2\n+    const u32 m = 0x5bd1e995;\n+    const u32 seed = 0x9747b28c;\n+    const u32 r = 24;\n+    u32 h = seed ^ (size * sizeof(uptr));\n+    for (uptr i = 0; i < size; i++) {\n+      u32 k = stack[i];\n+      k *= m;\n+      k ^= k >> r;\n+      k *= m;\n+      h *= m;\n+      h ^= k;\n+    }\n+    h ^= h >> 13;\n+    h *= m;\n+    h ^= h >> 15;\n+    return h;\n+  }\n+  bool is_valid() { return size > 0 && stack; }\n+};\n \n-struct StackDesc {\n-  StackDesc *link;\n+struct StackDepotNode {\n+  StackDepotNode *link;\n   u32 id;\n-  u32 hash;\n+  atomic_uint32_t hash_and_use_count; // hash_bits : 12; use_count : 20;\n   uptr size;\n   uptr stack[1];  // [size]\n-};\n \n-static struct {\n-  StaticSpinMutex mtx;  // Protects alloc of new blocks for region allocator.\n-  atomic_uintptr_t region_pos;  // Region allocator for StackDesc's.\n-  atomic_uintptr_t region_end;\n-  atomic_uintptr_t tab[kTabSize];  // Hash table of StackDesc's.\n-  atomic_uint32_t seq[kPartCount];  // Unique id generators.\n-} depot;\n+  static const u32 kTabSizeLog = 20;\n+  // Lower kTabSizeLog bits are equal for all items in one bucket.\n+  // We use these bits to store the per-stack use counter.\n+  static const u32 kUseCountBits = kTabSizeLog;\n+  static const u32 kMaxUseCount = 1 << kUseCountBits;\n+  static const u32 kUseCountMask = (1 << kUseCountBits) - 1;\n+  static const u32 kHashMask = ~kUseCountMask;\n+\n+  typedef StackDepotDesc args_type;\n+  bool eq(u32 hash, const args_type &args) const {\n+    u32 hash_bits =\n+        atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;\n+    if ((hash & kHashMask) != hash_bits || args.size != size) return false;\n+    uptr i = 0;\n+    for (; i < size; i++) {\n+      if (stack[i] != args.stack[i]) return false;\n+    }\n+    return true;\n+  }\n+  static uptr storage_size(const args_type &args) {\n+    return sizeof(StackDepotNode) + (args.size - 1) * sizeof(uptr);\n+  }\n+  void store(const args_type &args, u32 hash) {\n+    atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);\n+    size = args.size;\n+    internal_memcpy(stack, args.stack, size * sizeof(uptr));\n+  }\n+  args_type load() const {\n+    args_type ret = {&stack[0], size};\n+    return ret;\n+  }\n+  StackDepotHandle get_handle() { return StackDepotHandle(this); }\n \n-static StackDepotStats stats;\n+  typedef StackDepotHandle handle_type;\n+};\n \n-StackDepotStats *StackDepotGetStats() {\n-  return &stats;\n-}\n+COMPILER_CHECK(StackDepotNode::kMaxUseCount == (u32)kStackDepotMaxUseCount);\n \n-static u32 hash(const uptr *stack, uptr size) {\n-  // murmur2\n-  const u32 m = 0x5bd1e995;\n-  const u32 seed = 0x9747b28c;\n-  const u32 r = 24;\n-  u32 h = seed ^ (size * sizeof(uptr));\n-  for (uptr i = 0; i < size; i++) {\n-    u32 k = stack[i];\n-    k *= m;\n-    k ^= k >> r;\n-    k *= m;\n-    h *= m;\n-    h ^= k;\n-  }\n-  h ^= h >> 13;\n-  h *= m;\n-  h ^= h >> 15;\n-  return h;\n+u32 StackDepotHandle::id() { return node_->id; }\n+int StackDepotHandle::use_count() {\n+  return atomic_load(&node_->hash_and_use_count, memory_order_relaxed) &\n+         StackDepotNode::kUseCountMask;\n }\n-\n-static StackDesc *tryallocDesc(uptr memsz) {\n-  // Optimisic lock-free allocation, essentially try to bump the region ptr.\n-  for (;;) {\n-    uptr cmp = atomic_load(&depot.region_pos, memory_order_acquire);\n-    uptr end = atomic_load(&depot.region_end, memory_order_acquire);\n-    if (cmp == 0 || cmp + memsz > end)\n-      return 0;\n-    if (atomic_compare_exchange_weak(\n-        &depot.region_pos, &cmp, cmp + memsz,\n-        memory_order_acquire))\n-      return (StackDesc*)cmp;\n-  }\n+void StackDepotHandle::inc_use_count_unsafe() {\n+  u32 prev =\n+      atomic_fetch_add(&node_->hash_and_use_count, 1, memory_order_relaxed) &\n+      StackDepotNode::kUseCountMask;\n+  CHECK_LT(prev + 1, StackDepotNode::kMaxUseCount);\n }\n+uptr StackDepotHandle::size() { return node_->size; }\n+uptr *StackDepotHandle::stack() { return &node_->stack[0]; }\n \n-static StackDesc *allocDesc(uptr size) {\n-  // First, try to allocate optimisitically.\n-  uptr memsz = sizeof(StackDesc) + (size - 1) * sizeof(uptr);\n-  StackDesc *s = tryallocDesc(memsz);\n-  if (s)\n-    return s;\n-  // If failed, lock, retry and alloc new superblock.\n-  SpinMutexLock l(&depot.mtx);\n-  for (;;) {\n-    s = tryallocDesc(memsz);\n-    if (s)\n-      return s;\n-    atomic_store(&depot.region_pos, 0, memory_order_relaxed);\n-    uptr allocsz = 64 * 1024;\n-    if (allocsz < memsz)\n-      allocsz = memsz;\n-    uptr mem = (uptr)MmapOrDie(allocsz, \"stack depot\");\n-    stats.mapped += allocsz;\n-    atomic_store(&depot.region_end, mem + allocsz, memory_order_release);\n-    atomic_store(&depot.region_pos, mem, memory_order_release);\n-  }\n+// FIXME(dvyukov): this single reserved bit is used in TSan.\n+typedef StackDepotBase<StackDepotNode, 1, StackDepotNode::kTabSizeLog>\n+    StackDepot;\n+static StackDepot theDepot;\n+\n+StackDepotStats *StackDepotGetStats() {\n+  return theDepot.GetStats();\n }\n \n-static u32 find(StackDesc *s, const uptr *stack, uptr size, u32 hash) {\n-  // Searches linked list s for the stack, returns its id.\n-  for (; s; s = s->link) {\n-    if (s->hash == hash && s->size == size) {\n-      uptr i = 0;\n-      for (; i < size; i++) {\n-        if (stack[i] != s->stack[i])\n-          break;\n-      }\n-      if (i == size)\n-        return s->id;\n-    }\n-  }\n-  return 0;\n+u32 StackDepotPut(const uptr *stack, uptr size) {\n+  StackDepotDesc desc = {stack, size};\n+  StackDepotHandle h = theDepot.Put(desc);\n+  return h.valid() ? h.id() : 0;\n }\n \n-static StackDesc *lock(atomic_uintptr_t *p) {\n-  // Uses the pointer lsb as mutex.\n-  for (int i = 0;; i++) {\n-    uptr cmp = atomic_load(p, memory_order_relaxed);\n-    if ((cmp & 1) == 0\n-        && atomic_compare_exchange_weak(p, &cmp, cmp | 1,\n-                                        memory_order_acquire))\n-      return (StackDesc*)cmp;\n-    if (i < 10)\n-      proc_yield(10);\n-    else\n-      internal_sched_yield();\n-  }\n+StackDepotHandle StackDepotPut_WithHandle(const uptr *stack, uptr size) {\n+  StackDepotDesc desc = {stack, size};\n+  return theDepot.Put(desc);\n }\n \n-static void unlock(atomic_uintptr_t *p, StackDesc *s) {\n-  DCHECK_EQ((uptr)s & 1, 0);\n-  atomic_store(p, (uptr)s, memory_order_release);\n+const uptr *StackDepotGet(u32 id, uptr *size) {\n+  StackDepotDesc desc = theDepot.Get(id);\n+  *size = desc.size;\n+  return desc.stack;\n }\n \n-u32 StackDepotPut(const uptr *stack, uptr size) {\n-  if (stack == 0 || size == 0)\n-    return 0;\n-  uptr h = hash(stack, size);\n-  atomic_uintptr_t *p = &depot.tab[h % kTabSize];\n-  uptr v = atomic_load(p, memory_order_consume);\n-  StackDesc *s = (StackDesc*)(v & ~1);\n-  // First, try to find the existing stack.\n-  u32 id = find(s, stack, size, h);\n-  if (id)\n-    return id;\n-  // If failed, lock, retry and insert new.\n-  StackDesc *s2 = lock(p);\n-  if (s2 != s) {\n-    id = find(s2, stack, size, h);\n-    if (id) {\n-      unlock(p, s2);\n-      return id;\n-    }\n-  }\n-  uptr part = (h % kTabSize) / kPartSize;\n-  id = atomic_fetch_add(&depot.seq[part], 1, memory_order_relaxed) + 1;\n-  stats.n_uniq_ids++;\n-  CHECK_LT(id, kMaxId);\n-  id |= part << kPartShift;\n-  CHECK_NE(id, 0);\n-  CHECK_EQ(id & (1u << 31), 0);\n-  s = allocDesc(size);\n-  s->id = id;\n-  s->hash = h;\n-  s->size = size;\n-  internal_memcpy(s->stack, stack, size * sizeof(uptr));\n-  s->link = s2;\n-  unlock(p, s);\n-  return id;\n+void StackDepotLockAll() {\n+  theDepot.LockAll();\n }\n \n-const uptr *StackDepotGet(u32 id, uptr *size) {\n-  if (id == 0)\n-    return 0;\n-  CHECK_EQ(id & (1u << 31), 0);\n-  // High kPartBits contain part id, so we need to scan at most kPartSize lists.\n-  uptr part = id >> kPartShift;\n-  for (int i = 0; i != kPartSize; i++) {\n-    uptr idx = part * kPartSize + i;\n-    CHECK_LT(idx, kTabSize);\n-    atomic_uintptr_t *p = &depot.tab[idx];\n-    uptr v = atomic_load(p, memory_order_consume);\n-    StackDesc *s = (StackDesc*)(v & ~1);\n-    for (; s; s = s->link) {\n-      if (s->id == id) {\n-        *size = s->size;\n-        return s->stack;\n-      }\n-    }\n-  }\n-  *size = 0;\n-  return 0;\n+void StackDepotUnlockAll() {\n+  theDepot.UnlockAll();\n }\n \n bool StackDepotReverseMap::IdDescPair::IdComparator(\n@@ -207,10 +142,10 @@ bool StackDepotReverseMap::IdDescPair::IdComparator(\n \n StackDepotReverseMap::StackDepotReverseMap()\n     : map_(StackDepotGetStats()->n_uniq_ids + 100) {\n-  for (int idx = 0; idx < kTabSize; idx++) {\n-    atomic_uintptr_t *p = &depot.tab[idx];\n+  for (int idx = 0; idx < StackDepot::kTabSize; idx++) {\n+    atomic_uintptr_t *p = &theDepot.tab[idx];\n     uptr v = atomic_load(p, memory_order_consume);\n-    StackDesc *s = (StackDesc*)(v & ~1);\n+    StackDepotNode *s = (StackDepotNode*)(v & ~1);\n     for (; s; s = s->link) {\n       IdDescPair pair = {s->id, s};\n       map_.push_back(pair);\n@@ -228,7 +163,7 @@ const uptr *StackDepotReverseMap::Get(u32 id, uptr *size) {\n     *size = 0;\n     return 0;\n   }\n-  StackDesc *desc = map_[idx].desc;\n+  StackDepotNode *desc = map_[idx].desc;\n   *size = desc->size;\n   return desc->stack;\n }"}, {"sha": "2b1da4ee14f8a8d48e77ad002a00c3f62305a6ac", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,20 +17,29 @@\n namespace __sanitizer {\n \n // StackDepot efficiently stores huge amounts of stack traces.\n+struct StackDepotNode;\n+struct StackDepotHandle {\n+  StackDepotNode *node_;\n+  StackDepotHandle() : node_(0) {}\n+  explicit StackDepotHandle(StackDepotNode *node) : node_(node) {}\n+  bool valid() { return node_; }\n+  u32 id();\n+  int use_count();\n+  void inc_use_count_unsafe();\n+  uptr size();\n+  uptr *stack();\n+};\n+\n+const int kStackDepotMaxUseCount = 1U << 20;\n \n-// Maps stack trace to an unique id.\n+StackDepotStats *StackDepotGetStats();\n u32 StackDepotPut(const uptr *stack, uptr size);\n+StackDepotHandle StackDepotPut_WithHandle(const uptr *stack, uptr size);\n // Retrieves a stored stack trace by the id.\n const uptr *StackDepotGet(u32 id, uptr *size);\n \n-struct StackDepotStats {\n-  uptr n_uniq_ids;\n-  uptr mapped;\n-};\n-\n-StackDepotStats *StackDepotGetStats();\n-\n-struct StackDesc;\n+void StackDepotLockAll();\n+void StackDepotUnlockAll();\n \n // Instantiating this class creates a snapshot of StackDepot which can be\n // efficiently queried with StackDepotGet(). You can use it concurrently with\n@@ -44,7 +53,7 @@ class StackDepotReverseMap {\n  private:\n   struct IdDescPair {\n     u32 id;\n-    StackDesc *desc;\n+    StackDepotNode *desc;\n \n     static bool IdComparator(const IdDescPair &a, const IdDescPair &b);\n   };\n@@ -55,6 +64,7 @@ class StackDepotReverseMap {\n   StackDepotReverseMap(const StackDepotReverseMap&);\n   void operator=(const StackDepotReverseMap&);\n };\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_STACKDEPOT_H"}, {"sha": "b9dedec2621a032c794377cd02cb0a47ac6f0281", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,174 @@\n+//===-- sanitizer_stackdepotbase.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implementation of a mapping from arbitrary values to unique 32-bit\n+// identifiers.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_STACKDEPOTBASE_H\n+#define SANITIZER_STACKDEPOTBASE_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_persistent_allocator.h\"\n+\n+namespace __sanitizer {\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+class StackDepotBase {\n+ public:\n+  typedef typename Node::args_type args_type;\n+  typedef typename Node::handle_type handle_type;\n+  // Maps stack trace to an unique id.\n+  handle_type Put(args_type args, bool *inserted = 0);\n+  // Retrieves a stored stack trace by the id.\n+  args_type Get(u32 id);\n+\n+  StackDepotStats *GetStats() { return &stats; }\n+\n+  void LockAll();\n+  void UnlockAll();\n+\n+ private:\n+  static Node *find(Node *s, args_type args, u32 hash);\n+  static Node *lock(atomic_uintptr_t *p);\n+  static void unlock(atomic_uintptr_t *p, Node *s);\n+\n+  static const int kTabSize = 1 << kTabSizeLog;  // Hash table size.\n+  static const int kPartBits = 8;\n+  static const int kPartShift = sizeof(u32) * 8 - kPartBits - kReservedBits;\n+  static const int kPartCount =\n+      1 << kPartBits;  // Number of subparts in the table.\n+  static const int kPartSize = kTabSize / kPartCount;\n+  static const int kMaxId = 1 << kPartShift;\n+\n+  atomic_uintptr_t tab[kTabSize];   // Hash table of Node's.\n+  atomic_uint32_t seq[kPartCount];  // Unique id generators.\n+\n+  StackDepotStats stats;\n+\n+  friend class StackDepotReverseMap;\n+};\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::find(Node *s,\n+                                                             args_type args,\n+                                                             u32 hash) {\n+  // Searches linked list s for the stack, returns its id.\n+  for (; s; s = s->link) {\n+    if (s->eq(hash, args)) {\n+      return s;\n+    }\n+  }\n+  return 0;\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+Node *StackDepotBase<Node, kReservedBits, kTabSizeLog>::lock(\n+    atomic_uintptr_t *p) {\n+  // Uses the pointer lsb as mutex.\n+  for (int i = 0;; i++) {\n+    uptr cmp = atomic_load(p, memory_order_relaxed);\n+    if ((cmp & 1) == 0 &&\n+        atomic_compare_exchange_weak(p, &cmp, cmp | 1, memory_order_acquire))\n+      return (Node *)cmp;\n+    if (i < 10)\n+      proc_yield(10);\n+    else\n+      internal_sched_yield();\n+  }\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+void StackDepotBase<Node, kReservedBits, kTabSizeLog>::unlock(\n+    atomic_uintptr_t *p, Node *s) {\n+  DCHECK_EQ((uptr)s & 1, 0);\n+  atomic_store(p, (uptr)s, memory_order_release);\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::handle_type\n+StackDepotBase<Node, kReservedBits, kTabSizeLog>::Put(args_type args,\n+                                                      bool *inserted) {\n+  if (inserted) *inserted = false;\n+  if (!args.is_valid()) return handle_type();\n+  uptr h = args.hash();\n+  atomic_uintptr_t *p = &tab[h % kTabSize];\n+  uptr v = atomic_load(p, memory_order_consume);\n+  Node *s = (Node *)(v & ~1);\n+  // First, try to find the existing stack.\n+  Node *node = find(s, args, h);\n+  if (node) return node->get_handle();\n+  // If failed, lock, retry and insert new.\n+  Node *s2 = lock(p);\n+  if (s2 != s) {\n+    node = find(s2, args, h);\n+    if (node) {\n+      unlock(p, s2);\n+      return node->get_handle();\n+    }\n+  }\n+  uptr part = (h % kTabSize) / kPartSize;\n+  u32 id = atomic_fetch_add(&seq[part], 1, memory_order_relaxed) + 1;\n+  stats.n_uniq_ids++;\n+  CHECK_LT(id, kMaxId);\n+  id |= part << kPartShift;\n+  CHECK_NE(id, 0);\n+  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);\n+  uptr memsz = Node::storage_size(args);\n+  s = (Node *)PersistentAlloc(memsz);\n+  stats.allocated += memsz;\n+  s->id = id;\n+  s->store(args, h);\n+  s->link = s2;\n+  unlock(p, s);\n+  if (inserted) *inserted = true;\n+  return s->get_handle();\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::args_type\n+StackDepotBase<Node, kReservedBits, kTabSizeLog>::Get(u32 id) {\n+  if (id == 0) {\n+    return args_type();\n+  }\n+  CHECK_EQ(id & (((u32)-1) >> kReservedBits), id);\n+  // High kPartBits contain part id, so we need to scan at most kPartSize lists.\n+  uptr part = id >> kPartShift;\n+  for (int i = 0; i != kPartSize; i++) {\n+    uptr idx = part * kPartSize + i;\n+    CHECK_LT(idx, kTabSize);\n+    atomic_uintptr_t *p = &tab[idx];\n+    uptr v = atomic_load(p, memory_order_consume);\n+    Node *s = (Node *)(v & ~1);\n+    for (; s; s = s->link) {\n+      if (s->id == id) {\n+        return s->load();\n+      }\n+    }\n+  }\n+  return args_type();\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+void StackDepotBase<Node, kReservedBits, kTabSizeLog>::LockAll() {\n+  for (int i = 0; i < kTabSize; ++i) {\n+    lock(&tab[i]);\n+  }\n+}\n+\n+template <class Node, int kReservedBits, int kTabSizeLog>\n+void StackDepotBase<Node, kReservedBits, kTabSizeLog>::UnlockAll() {\n+  for (int i = 0; i < kTabSize; ++i) {\n+    atomic_uintptr_t *p = &tab[i];\n+    uptr s = atomic_load(p, memory_order_relaxed);\n+    unlock(p, (Node *)(s & ~1UL));\n+  }\n+}\n+\n+}  // namespace __sanitizer\n+#endif  // SANITIZER_STACKDEPOTBASE_H"}, {"sha": "0ce5ae475f6c4c0216eb1ea0cada302065f6d8e1", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -19,7 +19,8 @@ uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n #if defined(__arm__)\n   // Cancel Thumb bit.\n   pc = pc & (~1);\n-#elif defined(__powerpc__) || defined(__powerpc64__)\n+#endif\n+#if defined(__powerpc__) || defined(__powerpc64__)\n   // PCs are always 4 byte aligned.\n   return pc - 4;\n #elif defined(__sparc__)\n@@ -33,27 +34,47 @@ uptr StackTrace::GetCurrentPc() {\n   return GET_CALLER_PC();\n }\n \n+// Check if given pointer points into allocated stack area.\n+static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n+  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);\n+}\n+\n+// In GCC on ARM bp points to saved lr, not fp, so we should check the next\n+// cell in stack to be a saved frame pointer. GetCanonicFrame returns the\n+// pointer to saved frame pointer in any case.\n+static inline uhwptr *GetCanonicFrame(uptr bp,\n+                                      uptr stack_top,\n+                                      uptr stack_bottom) {\n+#ifdef __arm__\n+  if (!IsValidFrame(bp, stack_top, stack_bottom)) return 0;\n+  uhwptr *bp_prev = (uhwptr *)bp;\n+  if (IsValidFrame((uptr)bp_prev[0], stack_top, stack_bottom)) return bp_prev;\n+  return bp_prev - 1;\n+#else\n+  return (uhwptr*)bp;\n+#endif\n+}\n+\n void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n                                  uptr stack_top, uptr stack_bottom,\n                                  uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n   trace[0] = pc;\n   size = 1;\n-  uhwptr *frame = (uhwptr *)bp;\n-  uhwptr *prev_frame = frame - 1;\n   if (stack_top < 4096) return;  // Sanity check for stack top.\n+  uhwptr *frame = GetCanonicFrame(bp, stack_top, stack_bottom);\n+  uhwptr *prev_frame = 0;\n   // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.\n   while (frame > prev_frame &&\n-         frame < (uhwptr *)stack_top - 2 &&\n-         frame > (uhwptr *)stack_bottom &&\n+         IsValidFrame((uptr)frame, stack_top, stack_bottom) &&\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n     uhwptr pc1 = frame[1];\n     if (pc1 != pc) {\n       trace[size++] = (uptr) pc1;\n     }\n     prev_frame = frame;\n-    frame = (uhwptr *)frame[0];\n+    frame = GetCanonicFrame((uptr)frame[0], stack_top, stack_bottom);\n   }\n }\n "}, {"sha": "0e0f17022282150d749fcfe70d7278d80ecd632e", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -50,9 +50,12 @@ struct StackTrace {\n \n   static bool WillUseFastUnwind(bool request_fast_unwind) {\n     // Check if fast unwind is available. Fast unwind is the only option on Mac.\n+    // It is also the only option on FreeBSD as the slow unwinding that\n+    // leverages _Unwind_Backtrace() yields the call stack of the signal's\n+    // handler and not of the code that raised the signal (as it does on Linux).\n     if (!SANITIZER_CAN_FAST_UNWIND)\n       return false;\n-    else if (SANITIZER_MAC)\n+    else if (SANITIZER_MAC != 0 || SANITIZER_FREEBSD != 0)\n       return true;\n     return request_fast_unwind;\n   }\n@@ -83,6 +86,10 @@ struct StackTrace {\n   uptr local_stack;                           \\\n   uptr sp = (uptr)&local_stack\n \n+#define GET_CALLER_PC_BP \\\n+  uptr bp = GET_CURRENT_FRAME();              \\\n+  uptr pc = GET_CALLER_PC();\n+\n // Use this macro if you want to print stack trace with the current\n // function in the top frame.\n #define GET_CURRENT_PC_BP_SP \\"}, {"sha": "5dcc0e9ed1540c1082ad717ea9f46600cccde7af", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -35,6 +35,14 @@ void StackTrace::PrintStack(const uptr *addr, uptr size) {\n     uptr pc = GetPreviousInstructionPc(addr[i]);\n     uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n         pc, addr_frames.data(), addr_frames.size());\n+    if (addr_frames_num == 0) {\n+      frame_desc.clear();\n+      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n+      frame_desc.append(\" (<unknown module>)\");\n+      Printf(\"%s\\n\", frame_desc.data());\n+      frame_num++;\n+      continue;\n+    }\n     for (uptr j = 0; j < addr_frames_num; j++) {\n       AddressInfo &info = addr_frames[j];\n       frame_desc.clear();"}, {"sha": "ab40598ae8ee4330e36c27bd775e7909667add75", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -13,13 +13,15 @@\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n \n namespace __sanitizer {\n \n static const char *const kTypeStrings[SuppressionTypeCount] = {\n-    \"none\",   \"race\", \"mutex\",           \"thread\",\n-    \"signal\", \"leak\", \"called_from_lib\", \"deadlock\"};\n+    \"none\", \"race\",            \"mutex\",    \"thread\",    \"signal\",\n+    \"leak\", \"called_from_lib\", \"deadlock\", \"vptr_check\"};\n \n bool TemplateMatch(char *templ, const char *str) {\n   if (str == 0 || str[0] == 0)\n@@ -63,6 +65,33 @@ bool TemplateMatch(char *templ, const char *str) {\n   return true;\n }\n \n+ALIGNED(64) static char placeholder[sizeof(SuppressionContext)];\n+static SuppressionContext *suppression_ctx = 0;\n+\n+SuppressionContext *SuppressionContext::Get() {\n+  CHECK(suppression_ctx);\n+  return suppression_ctx;\n+}\n+\n+void SuppressionContext::InitIfNecessary() {\n+  if (suppression_ctx)\n+    return;\n+  suppression_ctx = new(placeholder) SuppressionContext;\n+  if (common_flags()->suppressions[0] == '\\0')\n+    return;\n+  char *suppressions_from_file;\n+  uptr buffer_size;\n+  uptr contents_size =\n+      ReadFileToBuffer(common_flags()->suppressions, &suppressions_from_file,\n+                       &buffer_size, 1 << 26 /* max_len */);\n+  if (contents_size == 0) {\n+    Printf(\"%s: failed to read suppressions file '%s'\\n\", SanitizerToolName,\n+           common_flags()->suppressions);\n+    Die();\n+  }\n+  suppression_ctx->Parse(suppressions_from_file);\n+}\n+\n bool SuppressionContext::Match(const char *str, SuppressionType type,\n                                Suppression **s) {\n   can_parse_ = false;"}, {"sha": "84ee834a9fdd6bdf506e952bf576e6d5f066af07", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -25,6 +25,7 @@ enum SuppressionType {\n   SuppressionLeak,\n   SuppressionLib,\n   SuppressionDeadlock,\n+  SuppressionVptrCheck,\n   SuppressionTypeCount\n };\n \n@@ -37,14 +38,21 @@ struct Suppression {\n \n class SuppressionContext {\n  public:\n-  SuppressionContext() : suppressions_(1), can_parse_(true) {}\n   void Parse(const char *str);\n   bool Match(const char* str, SuppressionType type, Suppression **s);\n   uptr SuppressionCount() const;\n   const Suppression *SuppressionAt(uptr i) const;\n   void GetMatched(InternalMmapVector<Suppression *> *matched);\n \n+  // Create a SuppressionContext singleton if it hasn't been created earlier.\n+  // Not thread safe. Must be called early during initialization (but after\n+  // runtime flags are parsed).\n+  static void InitIfNecessary();\n+  // Returns a SuppressionContext singleton.\n+  static SuppressionContext *Get();\n+\n  private:\n+  SuppressionContext() : suppressions_(1), can_parse_(true) {}\n   InternalMmapVector<Suppression> suppressions_;\n   bool can_parse_;\n "}, {"sha": "6821e5a326272a170340c79d178c8b092c2b9897", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,17 +20,6 @@ Symbolizer *Symbolizer::symbolizer_;\n StaticSpinMutex Symbolizer::init_mu_;\n LowLevelAllocator Symbolizer::symbolizer_allocator_;\n \n-Symbolizer *Symbolizer::GetOrNull() {\n-  SpinMutexLock l(&init_mu_);\n-  return symbolizer_;\n-}\n-\n-Symbolizer *Symbolizer::Get() {\n-  SpinMutexLock l(&init_mu_);\n-  RAW_CHECK_MSG(symbolizer_ != 0, \"Using uninitialized symbolizer!\");\n-  return symbolizer_;\n-}\n-\n Symbolizer *Symbolizer::Disable() {\n   CHECK_EQ(0, symbolizer_);\n   // Initialize a dummy symbolizer."}, {"sha": "73a68b2ee11809fde84e12411bba9f2f19af2c5c", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -70,20 +70,9 @@ struct DataInfo {\n \n class Symbolizer {\n  public:\n-  /// Returns platform-specific implementation of Symbolizer. The symbolizer\n-  /// must be initialized (with init or disable) before calling this function.\n-  static Symbolizer *Get();\n-  /// Returns platform-specific implementation of Symbolizer, or null if not\n-  /// initialized.\n-  static Symbolizer *GetOrNull();\n-  /// Returns platform-specific implementation of Symbolizer.  Will\n-  /// automatically initialize symbolizer as if by calling Init(0) if needed.\n+  /// Initialize and return platform-specific implementation of symbolizer\n+  /// (if it wasn't already initialized).\n   static Symbolizer *GetOrInit();\n-  /// Initialize and return the symbolizer, given an optional path to an\n-  /// external symbolizer.  The path argument is only required for legacy\n-  /// reasons as this function will check $PATH for an external symbolizer.  Not\n-  /// thread safe.\n-  static Symbolizer *Init(const char* path_to_external = 0);\n   // Fills at most \"max_frames\" elements of \"frames\" with descriptions\n   // for a given address (in all inlined functions). Returns the number\n   // of descriptions actually filled.\n@@ -120,10 +109,7 @@ class Symbolizer {\n \n  private:\n   /// Platform-specific function for creating a Symbolizer object.\n-  static Symbolizer *PlatformInit(const char *path_to_external);\n-  /// Create a symbolizer and store it to symbolizer_ without checking if one\n-  /// already exists.  Not thread safe.\n-  static Symbolizer *CreateAndStore(const char *path_to_external);\n+  static Symbolizer *PlatformInit();\n   /// Initialize the symbolizer in a disabled state.  Not thread safe.\n   static Symbolizer *Disable();\n "}, {"sha": "9afd805a82cc14570329215d7bbc1581530bcb32", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -14,24 +14,13 @@\n \n namespace __sanitizer {\n \n-Symbolizer *Symbolizer::CreateAndStore(const char *path_to_external) {\n-  Symbolizer *platform_symbolizer = PlatformInit(path_to_external);\n-  if (!platform_symbolizer)\n-    return Disable();\n-  symbolizer_ = platform_symbolizer;\n-  return platform_symbolizer;\n-}\n-\n-Symbolizer *Symbolizer::Init(const char *path_to_external) {\n-  CHECK_EQ(0, symbolizer_);\n-  return CreateAndStore(path_to_external);\n-}\n-\n Symbolizer *Symbolizer::GetOrInit() {\n   SpinMutexLock l(&init_mu_);\n-  if (symbolizer_ == 0)\n-    return CreateAndStore(0);\n-  return symbolizer_;\n+  if (symbolizer_)\n+    return symbolizer_;\n+  if ((symbolizer_ = PlatformInit()))\n+    return symbolizer_;\n+  return Disable();\n }\n \n }  // namespace __sanitizer"}, {"sha": "4f30225a4c897ce3250b9ad3f89af3b3882364aa", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -253,7 +253,7 @@ class SymbolizerProcess : public ExternalSymbolizerInterface {\n       internal_close(outfd[1]);\n       internal_close(infd[0]);\n       internal_close(infd[1]);\n-      for (int fd = getdtablesize(); fd > 2; fd--)\n+      for (int fd = sysconf(_SC_OPEN_MAX); fd > 2; fd--)\n         internal_close(fd);\n       ExecuteWithDefaultArgs(path_);\n       internal__exit(1);\n@@ -714,7 +714,7 @@ class POSIXSymbolizer : public Symbolizer {\n   LibbacktraceSymbolizer *libbacktrace_symbolizer_;   // Leaked.\n };\n \n-Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n+Symbolizer *Symbolizer::PlatformInit() {\n   if (!common_flags()->symbolize) {\n     return new(symbolizer_allocator_) POSIXSymbolizer(0, 0, 0);\n   }\n@@ -727,6 +727,7 @@ Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n     libbacktrace_symbolizer =\n         LibbacktraceSymbolizer::get(&symbolizer_allocator_);\n     if (!libbacktrace_symbolizer) {\n+      const char *path_to_external = common_flags()->external_symbolizer_path;\n       if (path_to_external && path_to_external[0] == '\\0') {\n         // External symbolizer is explicitly disabled. Do nothing.\n       } else {"}, {"sha": "a1ed4e9a7b7f65f75e2eaf4026ad4b0a19f1d439", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -30,11 +30,22 @@ class WinSymbolizer : public Symbolizer {\n \n     BlockingMutexLock l(&dbghelp_mu_);\n     if (!initialized_) {\n-      SymSetOptions(SYMOPT_DEFERRED_LOADS |\n-                    SYMOPT_UNDNAME |\n-                    SYMOPT_LOAD_LINES);\n-      CHECK(SymInitialize(GetCurrentProcess(), 0, TRUE));\n-      // FIXME: We don't call SymCleanup() on exit yet - should we?\n+      if (!TrySymInitialize()) {\n+        // OK, maybe the client app has called SymInitialize already.\n+        // That's a bit unfortunate for us as all the DbgHelp functions are\n+        // single-threaded and we can't coordinate with the app.\n+        // FIXME: Can we stop the other threads at this point?\n+        // Anyways, we have to reconfigure stuff to make sure that SymInitialize\n+        // has all the appropriate options set.\n+        // Cross our fingers and reinitialize DbgHelp.\n+        Report(\"*** WARNING: Failed to initialize DbgHelp!              ***\\n\");\n+        Report(\"*** Most likely this means that the app is already      ***\\n\");\n+        Report(\"*** using DbgHelp, possibly with incompatible flags.    ***\\n\");\n+        Report(\"*** Due to technical reasons, symbolization might crash ***\\n\");\n+        Report(\"*** or produce wrong results.                           ***\\n\");\n+        SymCleanup(GetCurrentProcess());\n+        TrySymInitialize();\n+      }\n       initialized_ = true;\n     }\n \n@@ -90,13 +101,19 @@ class WinSymbolizer : public Symbolizer {\n   // FIXME: Implement GetModuleNameAndOffsetForPC().\n \n  private:\n+  bool TrySymInitialize() {\n+    SymSetOptions(SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES);\n+    return SymInitialize(GetCurrentProcess(), 0, TRUE);\n+    // FIXME: We don't call SymCleanup() on exit yet - should we?\n+  }\n+\n   // All DbgHelp functions are single threaded, so we should use a mutex to\n   // serialize accesses.\n   BlockingMutex dbghelp_mu_;\n   bool initialized_;\n };\n \n-Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n+Symbolizer *Symbolizer::PlatformInit() {\n   static bool called_once = false;\n   CHECK(!called_once && \"Shouldn't create more than one symbolizer\");\n   called_once = true;"}, {"sha": "bfa610443c1aa7a216b5ef51604a8f91a5be00d7", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -216,7 +216,7 @@ void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {\n   }\n }\n \n-void ThreadRegistry::DetachThread(u32 tid) {\n+void ThreadRegistry::DetachThread(u32 tid, void *arg) {\n   BlockingMutexLock l(&mtx_);\n   CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n@@ -225,6 +225,7 @@ void ThreadRegistry::DetachThread(u32 tid) {\n     Report(\"%s: Detach of non-existent thread\\n\", SanitizerToolName);\n     return;\n   }\n+  tctx->OnDetached(arg);\n   if (tctx->status == ThreadStatusFinished) {\n     tctx->SetDead();\n     QuarantinePush(tctx);"}, {"sha": "d5a741bbfc4aeba73c4a009c8cc5059c5c8fa6f7", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -66,6 +66,7 @@ class ThreadContextBase {\n   virtual void OnStarted(void *arg) {}\n   virtual void OnCreated(void *arg) {}\n   virtual void OnReset() {}\n+  virtual void OnDetached(void *arg) {}\n };\n \n typedef ThreadContextBase* (*ThreadContextFactory)(u32 tid);\n@@ -108,7 +109,7 @@ class ThreadRegistry {\n \n   void SetThreadName(u32 tid, const char *name);\n   void SetThreadNameByUserId(uptr user_id, const char *name);\n-  void DetachThread(u32 tid);\n+  void DetachThread(u32 tid, void *arg);\n   void JoinThread(u32 tid, void *arg);\n   void FinishThread(u32 tid);\n   void StartThread(u32 tid, uptr os_id, void *arg);"}, {"sha": "af828045b59a000bb0c706a11b5d1145cb85409d", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -76,14 +76,13 @@ void DTLS_Destroy() {\n   DTLS_Deallocate(dtls.dtv, s);\n }\n \n-void DTLS_on_tls_get_addr(void *arg_void, void *res) {\n-  if (!common_flags()->intercept_tls_get_addr) return;\n+DTLS::DTV *DTLS_on_tls_get_addr(void *arg_void, void *res) {\n+  if (!common_flags()->intercept_tls_get_addr) return 0;\n   TlsGetAddrParam *arg = reinterpret_cast<TlsGetAddrParam *>(arg_void);\n   uptr dso_id = arg->dso_id;\n-  if (dtls.dtv_size == kDestroyedThread) return;\n+  if (dtls.dtv_size == kDestroyedThread) return 0;\n   DTLS_Resize(dso_id + 1);\n-  if (dtls.dtv[dso_id].beg)\n-    return;\n+  if (dtls.dtv[dso_id].beg) return 0;\n   uptr tls_size = 0;\n   uptr tls_beg = reinterpret_cast<uptr>(res) - arg->offset;\n   VPrintf(2, \"__tls_get_addr: %p {%p,%p} => %p; tls_beg: %p; sp: %p \"\n@@ -108,6 +107,7 @@ void DTLS_on_tls_get_addr(void *arg_void, void *res) {\n   }\n   dtls.dtv[dso_id].beg = tls_beg;\n   dtls.dtv[dso_id].size = tls_size;\n+  return dtls.dtv + dso_id;\n }\n \n void DTLS_on_libc_memalign(void *ptr, uptr size) {\n@@ -121,7 +121,7 @@ DTLS *DTLS_Get() { return &dtls; }\n \n #else\n void DTLS_on_libc_memalign(void *ptr, uptr size) {}\n-void DTLS_on_tls_get_addr(void *arg, void *res) {}\n+DTLS::DTV *DTLS_on_tls_get_addr(void *arg, void *res) { return 0; }\n DTLS *DTLS_Get() { return 0; }\n void DTLS_Destroy() {}\n #endif  // SANITIZER_INTERCEPT_TLS_GET_ADDR"}, {"sha": "8dc629f630eea498351f7884ea9aff5f804970b5", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -46,7 +46,9 @@ struct DTLS {\n   uptr last_memalign_ptr;\n };\n \n-void DTLS_on_tls_get_addr(void *arg, void *res);\n+// Returns pointer and size of a linker-allocated TLS block.\n+// Each block is returned exactly once.\n+DTLS::DTV *DTLS_on_tls_get_addr(void *arg, void *res);\n void DTLS_on_libc_memalign(void *ptr, uptr size);\n DTLS *DTLS_Get();\n void DTLS_Destroy();  // Make sure to call this before the thread is destroyed."}, {"sha": "c49113e1d0b835ed8db4094e70ee788505dcec07", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_posix_libcdep.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,151 @@\n+//===-- sanitizer_unwind_posix.cc ----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file contains the unwind.h-based (aka \"slow\") stack unwinding routines\n+// available to the tools on Linux, Android, FreeBSD and OS X.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_POSIX\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_stacktrace.h\"\n+\n+#if SANITIZER_ANDROID\n+#include <dlfcn.h>  // for dlopen()\n+#endif\n+\n+#if SANITIZER_FREEBSD\n+#define _GNU_SOURCE  // to declare _Unwind_Backtrace() from <unwind.h>\n+#endif\n+#include <unwind.h>\n+\n+namespace __sanitizer {\n+\n+//------------------------- SlowUnwindStack -----------------------------------\n+\n+typedef struct {\n+  uptr absolute_pc;\n+  uptr stack_top;\n+  uptr stack_size;\n+} backtrace_frame_t;\n+\n+extern \"C\" {\n+typedef void *(*acquire_my_map_info_list_func)();\n+typedef void (*release_my_map_info_list_func)(void *map);\n+typedef sptr (*unwind_backtrace_signal_arch_func)(\n+    void *siginfo, void *sigcontext, void *map_info_list,\n+    backtrace_frame_t *backtrace, uptr ignore_depth, uptr max_depth);\n+acquire_my_map_info_list_func acquire_my_map_info_list;\n+release_my_map_info_list_func release_my_map_info_list;\n+unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n+} // extern \"C\"\n+\n+#if SANITIZER_ANDROID\n+void SanitizerInitializeUnwinder() {\n+  void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n+  if (!p) {\n+    VReport(1,\n+            \"Failed to open libcorkscrew.so. You may see broken stack traces \"\n+            \"in SEGV reports.\");\n+    return;\n+  }\n+  acquire_my_map_info_list =\n+      (acquire_my_map_info_list_func)(uptr)dlsym(p, \"acquire_my_map_info_list\");\n+  release_my_map_info_list =\n+      (release_my_map_info_list_func)(uptr)dlsym(p, \"release_my_map_info_list\");\n+  unwind_backtrace_signal_arch = (unwind_backtrace_signal_arch_func)(uptr)dlsym(\n+      p, \"unwind_backtrace_signal_arch\");\n+  if (!acquire_my_map_info_list || !release_my_map_info_list ||\n+      !unwind_backtrace_signal_arch) {\n+    VReport(1,\n+            \"Failed to find one of the required symbols in libcorkscrew.so. \"\n+            \"You may see broken stack traces in SEGV reports.\");\n+    acquire_my_map_info_list = 0;\n+    unwind_backtrace_signal_arch = 0;\n+    release_my_map_info_list = 0;\n+  }\n+}\n+#endif\n+\n+#ifdef __arm__\n+#define UNWIND_STOP _URC_END_OF_STACK\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#else\n+#define UNWIND_STOP _URC_NORMAL_STOP\n+#define UNWIND_CONTINUE _URC_NO_REASON\n+#endif\n+\n+uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n+#ifdef __arm__\n+  uptr val;\n+  _Unwind_VRS_Result res = _Unwind_VRS_Get(ctx, _UVRSC_CORE,\n+      15 /* r15 = PC */, _UVRSD_UINT32, &val);\n+  CHECK(res == _UVRSR_OK && \"_Unwind_VRS_Get failed\");\n+  // Clear the Thumb bit.\n+  return val & ~(uptr)1;\n+#else\n+  return _Unwind_GetIP(ctx);\n+#endif\n+}\n+\n+struct UnwindTraceArg {\n+  StackTrace *stack;\n+  uptr max_depth;\n+};\n+\n+_Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n+  UnwindTraceArg *arg = (UnwindTraceArg*)param;\n+  CHECK_LT(arg->stack->size, arg->max_depth);\n+  uptr pc = Unwind_GetIP(ctx);\n+  arg->stack->trace[arg->stack->size++] = pc;\n+  if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n+  return UNWIND_CONTINUE;\n+}\n+\n+void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+  CHECK_GE(max_depth, 2);\n+  size = 0;\n+  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n+  _Unwind_Backtrace(Unwind_Trace, &arg);\n+  // We need to pop a few frames so that pc is on top.\n+  uptr to_pop = LocatePcInTrace(pc);\n+  // trace[0] belongs to the current function so we always pop it.\n+  if (to_pop == 0)\n+    to_pop = 1;\n+  PopStackFrames(to_pop);\n+  trace[0] = pc;\n+}\n+\n+void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                            uptr max_depth) {\n+  CHECK_GE(max_depth, 2);\n+  if (!unwind_backtrace_signal_arch) {\n+    SlowUnwindStack(pc, max_depth);\n+    return;\n+  }\n+\n+  void *map = acquire_my_map_info_list();\n+  CHECK(map);\n+  InternalScopedBuffer<backtrace_frame_t> frames(kStackTraceMax);\n+  // siginfo argument appears to be unused.\n+  sptr res = unwind_backtrace_signal_arch(/* siginfo */ 0, context, map,\n+                                          frames.data(),\n+                                          /* ignore_depth */ 0, max_depth);\n+  release_my_map_info_list(map);\n+  if (res < 0) return;\n+  CHECK_LE((uptr)res, kStackTraceMax);\n+\n+  size = 0;\n+  // +2 compensate for libcorkscrew unwinder returning addresses of call\n+  // instructions instead of raw return addresses.\n+  for (sptr i = 0; i < res; ++i)\n+    trace[size++] = frames[i].absolute_pc + 2;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_POSIX"}, {"sha": "9f24510dbd045af80b879e1df9cb54bba2cdec24", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -15,9 +15,10 @@\n \n #define WIN32_LEAN_AND_MEAN\n #define NOGDI\n-#include <stdlib.h>\n-#include <io.h>\n #include <windows.h>\n+#include <dbghelp.h>\n+#include <io.h>\n+#include <stdlib.h>\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n@@ -62,6 +63,7 @@ uptr GetThreadSelf() {\n   return GetTid();\n }\n \n+#if !SANITIZER_GO\n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n                                 uptr *stack_bottom) {\n   CHECK(stack_top);\n@@ -74,6 +76,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   *stack_top = (uptr)mbi.BaseAddress + mbi.RegionSize;\n   *stack_bottom = (uptr)mbi.AllocationBase;\n }\n+#endif  // #if !SANITIZER_GO\n \n void *MmapOrDie(uptr size, const char *mem_type) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n@@ -135,6 +138,10 @@ void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n   UNIMPLEMENTED();\n }\n \n+void *MapWritableFileToMemory(void *addr, uptr size, uptr fd, uptr offset) {\n+  UNIMPLEMENTED();\n+}\n+\n static const int kMaxEnvNameLength = 128;\n static const DWORD kMaxEnvValueLength = 32767;\n \n@@ -182,7 +189,7 @@ void DumpProcessMap() {\n   UNIMPLEMENTED();\n }\n \n-void DisableCoreDumper() {\n+void DisableCoreDumperIfNecessary() {\n   // Do nothing.\n }\n \n@@ -203,6 +210,14 @@ void SetStackSizeLimitInBytes(uptr limit) {\n   UNIMPLEMENTED();\n }\n \n+bool AddressSpaceIsUnlimited() {\n+  UNIMPLEMENTED();\n+}\n+\n+void SetAddressSpaceUnlimited() {\n+  UNIMPLEMENTED();\n+}\n+\n char *FindPathToBinary(const char *name) {\n   // Nothing here for now.\n   return 0;\n@@ -350,6 +365,14 @@ void internal__exit(int exitcode) {\n   ExitProcess(exitcode);\n }\n \n+uptr internal_ftruncate(fd_t fd, uptr size) {\n+  UNIMPLEMENTED();\n+}\n+\n+uptr internal_rename(const char *oldpath, const char *newpath) {\n+  UNIMPLEMENTED();\n+}\n+\n // ---------------------- BlockingMutex ---------------- {{{1\n const uptr LOCK_UNINITIALIZED = 0;\n const uptr LOCK_READY = (uptr)-1;\n@@ -418,6 +441,7 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif\n }\n \n+#if !SANITIZER_GO\n void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n@@ -435,8 +459,32 @@ void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n \n void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n                                             uptr max_depth) {\n-  UNREACHABLE(\"no signal context on windows\");\n+  CONTEXT ctx = *(CONTEXT *)context;\n+  STACKFRAME64 stack_frame;\n+  memset(&stack_frame, 0, sizeof(stack_frame));\n+  size = 0;\n+#if defined(_WIN64)\n+  int machine_type = IMAGE_FILE_MACHINE_AMD64;\n+  stack_frame.AddrPC.Offset = ctx.Rip;\n+  stack_frame.AddrFrame.Offset = ctx.Rbp;\n+  stack_frame.AddrStack.Offset = ctx.Rsp;\n+#else\n+  int machine_type = IMAGE_FILE_MACHINE_I386;\n+  stack_frame.AddrPC.Offset = ctx.Eip;\n+  stack_frame.AddrFrame.Offset = ctx.Ebp;\n+  stack_frame.AddrStack.Offset = ctx.Esp;\n+#endif\n+  stack_frame.AddrPC.Mode = AddrModeFlat;\n+  stack_frame.AddrFrame.Mode = AddrModeFlat;\n+  stack_frame.AddrStack.Mode = AddrModeFlat;\n+  while (StackWalk64(machine_type, GetCurrentProcess(), GetCurrentThread(),\n+                     &stack_frame, &ctx, NULL, &SymFunctionTableAccess64,\n+                     &SymGetModuleBase64, NULL) &&\n+         size < Min(max_depth, kStackTraceMax)) {\n+    trace[size++] = (uptr)stack_frame.AddrPC.Offset;\n+  }\n }\n+#endif  // #if !SANITIZER_GO\n \n void MaybeOpenReportFile() {\n   // Windows doesn't have native fork, and we don't support Cygwin or other\n@@ -472,6 +520,11 @@ bool IsDeadlySignal(int signum) {\n   return false;\n }\n \n+bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n+  // FIXME: Actually implement this function.\n+  return true;\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // _WIN32"}, {"sha": "ab4748e0878542cee63ad00f1305e8b6e48eafc2", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -32,6 +32,7 @@ tsan_files = \\\n \ttsan_rtl_mutex.cc \\\n \ttsan_rtl_report.cc \\\n \ttsan_rtl_thread.cc \\\n+\ttsan_stack_trace.cc \\\n \ttsan_stat.cc \\\n \ttsan_suppressions.cc \\\n \ttsan_symbolize.cc \\"}, {"sha": "c6f1ecffa75eb4edf4fc851e777f23a0175eaa65", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -91,8 +91,8 @@ am__objects_1 = tsan_clock.lo tsan_fd.lo tsan_flags.lo \\\n \ttsan_mutexset.lo tsan_platform_linux.lo tsan_platform_mac.lo \\\n \ttsan_platform_windows.lo tsan_report.lo tsan_rtl.lo \\\n \ttsan_rtl_mutex.lo tsan_rtl_report.lo tsan_rtl_thread.lo \\\n-\ttsan_stat.lo tsan_suppressions.lo tsan_symbolize.lo \\\n-\ttsan_sync.lo tsan_rtl_amd64.lo\n+\ttsan_stack_trace.lo tsan_stat.lo tsan_suppressions.lo \\\n+\ttsan_symbolize.lo tsan_sync.lo tsan_rtl_amd64.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n libtsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -301,6 +301,7 @@ tsan_files = \\\n \ttsan_rtl_mutex.cc \\\n \ttsan_rtl_report.cc \\\n \ttsan_rtl_thread.cc \\\n+\ttsan_stack_trace.cc \\\n \ttsan_stat.cc \\\n \ttsan_suppressions.cc \\\n \ttsan_symbolize.cc \\\n@@ -449,6 +450,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_report.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_thread.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stack_trace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stat.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_suppressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_symbolize.Plo@am__quote@"}, {"sha": "a84caa952a6d2eb97e4863e826aa4ca8df7ad9ae", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 133, "deletions": 54, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -10,6 +10,7 @@\n //===----------------------------------------------------------------------===//\n #include \"tsan_clock.h\"\n #include \"tsan_rtl.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n \n // SyncClock and ThreadClock implement vector clocks for sync variables\n // (mutexes, atomic variables, file descriptors, etc) and threads, respectively.\n@@ -100,13 +101,13 @@ ThreadClock::ThreadClock(unsigned tid, unsigned reused)\n   clk_[tid_].reused = reused_;\n }\n \n-void ThreadClock::acquire(const SyncClock *src) {\n+void ThreadClock::acquire(ClockCache *c, const SyncClock *src) {\n   DCHECK(nclk_ <= kMaxTid);\n-  DCHECK(src->clk_.Size() <= kMaxTid);\n+  DCHECK(src->size_ <= kMaxTid);\n   CPP_STAT_INC(StatClockAcquire);\n \n   // Check if it's empty -> no need to do anything.\n-  const uptr nclk = src->clk_.Size();\n+  const uptr nclk = src->size_;\n   if (nclk == 0) {\n     CPP_STAT_INC(StatClockAcquireEmpty);\n     return;\n@@ -116,12 +117,12 @@ void ThreadClock::acquire(const SyncClock *src) {\n   bool acquired = false;\n   if (nclk > tid_) {\n     CPP_STAT_INC(StatClockAcquireLarge);\n-    if (src->clk_[tid_].reused == reused_) {\n+    if (src->elem(tid_).reused == reused_) {\n       CPP_STAT_INC(StatClockAcquireRepeat);\n       for (unsigned i = 0; i < kDirtyTids; i++) {\n         unsigned tid = src->dirty_tids_[i];\n         if (tid != kInvalidTid) {\n-          u64 epoch = src->clk_[tid].epoch;\n+          u64 epoch = src->elem(tid).epoch;\n           if (clk_[tid].epoch < epoch) {\n             clk_[tid].epoch = epoch;\n             acquired = true;\n@@ -140,7 +141,7 @@ void ThreadClock::acquire(const SyncClock *src) {\n   CPP_STAT_INC(StatClockAcquireFull);\n   nclk_ = max(nclk_, nclk);\n   for (uptr i = 0; i < nclk; i++) {\n-    u64 epoch = src->clk_[i].epoch;\n+    u64 epoch = src->elem(i).epoch;\n     if (clk_[i].epoch < epoch) {\n       clk_[i].epoch = epoch;\n       acquired = true;\n@@ -149,36 +150,34 @@ void ThreadClock::acquire(const SyncClock *src) {\n \n   // Remember that this thread has acquired this clock.\n   if (nclk > tid_)\n-    src->clk_[tid_].reused = reused_;\n+    src->elem(tid_).reused = reused_;\n \n   if (acquired) {\n     CPP_STAT_INC(StatClockAcquiredSomething);\n     last_acquire_ = clk_[tid_].epoch;\n   }\n }\n \n-void ThreadClock::release(SyncClock *dst) const {\n+void ThreadClock::release(ClockCache *c, SyncClock *dst) const {\n   DCHECK_LE(nclk_, kMaxTid);\n-  DCHECK_LE(dst->clk_.Size(), kMaxTid);\n+  DCHECK_LE(dst->size_, kMaxTid);\n \n-  if (dst->clk_.Size() == 0) {\n+  if (dst->size_ == 0) {\n     // ReleaseStore will correctly set release_store_tid_,\n     // which can be important for future operations.\n-    ReleaseStore(dst);\n+    ReleaseStore(c, dst);\n     return;\n   }\n \n   CPP_STAT_INC(StatClockRelease);\n   // Check if we need to resize dst.\n-  if (dst->clk_.Size() < nclk_) {\n-    CPP_STAT_INC(StatClockReleaseResize);\n-    dst->clk_.Resize(nclk_);\n-  }\n+  if (dst->size_ < nclk_)\n+    dst->Resize(c, nclk_);\n \n   // Check if we had not acquired anything from other threads\n   // since the last release on dst. If so, we need to update\n-  // only dst->clk_[tid_].\n-  if (dst->clk_[tid_].epoch > last_acquire_) {\n+  // only dst->elem(tid_).\n+  if (dst->elem(tid_).epoch > last_acquire_) {\n     UpdateCurrentThread(dst);\n     if (dst->release_store_tid_ != tid_ ||\n         dst->release_store_reused_ != reused_)\n@@ -194,38 +193,37 @@ void ThreadClock::release(SyncClock *dst) const {\n     CPP_STAT_INC(StatClockReleaseAcquired);\n   // Update dst->clk_.\n   for (uptr i = 0; i < nclk_; i++) {\n-    dst->clk_[i].epoch = max(dst->clk_[i].epoch, clk_[i].epoch);\n-    dst->clk_[i].reused = 0;\n+    ClockElem &ce = dst->elem(i);\n+    ce.epoch = max(ce.epoch, clk_[i].epoch);\n+    ce.reused = 0;\n   }\n   // Clear 'acquired' flag in the remaining elements.\n-  if (nclk_ < dst->clk_.Size())\n+  if (nclk_ < dst->size_)\n     CPP_STAT_INC(StatClockReleaseClearTail);\n-  for (uptr i = nclk_; i < dst->clk_.Size(); i++)\n-    dst->clk_[i].reused = 0;\n+  for (uptr i = nclk_; i < dst->size_; i++)\n+    dst->elem(i).reused = 0;\n   for (unsigned i = 0; i < kDirtyTids; i++)\n     dst->dirty_tids_[i] = kInvalidTid;\n   dst->release_store_tid_ = kInvalidTid;\n   dst->release_store_reused_ = 0;\n   // If we've acquired dst, remember this fact,\n   // so that we don't need to acquire it on next acquire.\n   if (acquired)\n-    dst->clk_[tid_].reused = reused_;\n+    dst->elem(tid_).reused = reused_;\n }\n \n-void ThreadClock::ReleaseStore(SyncClock *dst) const {\n+void ThreadClock::ReleaseStore(ClockCache *c, SyncClock *dst) const {\n   DCHECK(nclk_ <= kMaxTid);\n-  DCHECK(dst->clk_.Size() <= kMaxTid);\n+  DCHECK(dst->size_ <= kMaxTid);\n   CPP_STAT_INC(StatClockStore);\n \n   // Check if we need to resize dst.\n-  if (dst->clk_.Size() < nclk_) {\n-    CPP_STAT_INC(StatClockStoreResize);\n-    dst->clk_.Resize(nclk_);\n-  }\n+  if (dst->size_ < nclk_)\n+    dst->Resize(c, nclk_);\n \n   if (dst->release_store_tid_ == tid_ &&\n       dst->release_store_reused_ == reused_ &&\n-      dst->clk_[tid_].epoch > last_acquire_) {\n+      dst->elem(tid_).epoch > last_acquire_) {\n     CPP_STAT_INC(StatClockStoreFast);\n     UpdateCurrentThread(dst);\n     return;\n@@ -234,33 +232,37 @@ void ThreadClock::ReleaseStore(SyncClock *dst) const {\n   // O(N) release-store.\n   CPP_STAT_INC(StatClockStoreFull);\n   for (uptr i = 0; i < nclk_; i++) {\n-    dst->clk_[i].epoch = clk_[i].epoch;\n-    dst->clk_[i].reused = 0;\n+    ClockElem &ce = dst->elem(i);\n+    ce.epoch = clk_[i].epoch;\n+    ce.reused = 0;\n   }\n   // Clear the tail of dst->clk_.\n-  if (nclk_ < dst->clk_.Size()) {\n-    internal_memset(&dst->clk_[nclk_], 0,\n-        (dst->clk_.Size() - nclk_) * sizeof(dst->clk_[0]));\n+  if (nclk_ < dst->size_) {\n+    for (uptr i = nclk_; i < dst->size_; i++) {\n+      ClockElem &ce = dst->elem(i);\n+      ce.epoch = 0;\n+      ce.reused = 0;\n+    }\n     CPP_STAT_INC(StatClockStoreTail);\n   }\n   for (unsigned i = 0; i < kDirtyTids; i++)\n     dst->dirty_tids_[i] = kInvalidTid;\n   dst->release_store_tid_ = tid_;\n   dst->release_store_reused_ = reused_;\n   // Rememeber that we don't need to acquire it in future.\n-  dst->clk_[tid_].reused = reused_;\n+  dst->elem(tid_).reused = reused_;\n }\n \n-void ThreadClock::acq_rel(SyncClock *dst) {\n+void ThreadClock::acq_rel(ClockCache *c, SyncClock *dst) {\n   CPP_STAT_INC(StatClockAcquireRelease);\n-  acquire(dst);\n-  ReleaseStore(dst);\n+  acquire(c, dst);\n+  ReleaseStore(c, dst);\n }\n \n // Updates only single element related to the current thread in dst->clk_.\n void ThreadClock::UpdateCurrentThread(SyncClock *dst) const {\n   // Update the threads time, but preserve 'acquired' flag.\n-  dst->clk_[tid_].epoch = clk_[tid_].epoch;\n+  dst->elem(tid_).epoch = clk_[tid_].epoch;\n \n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     if (dst->dirty_tids_[i] == tid_) {\n@@ -275,27 +277,73 @@ void ThreadClock::UpdateCurrentThread(SyncClock *dst) const {\n   }\n   // Reset all 'acquired' flags, O(N).\n   CPP_STAT_INC(StatClockReleaseSlow);\n-  for (uptr i = 0; i < dst->clk_.Size(); i++) {\n-    dst->clk_[i].reused = 0;\n-  }\n+  for (uptr i = 0; i < dst->size_; i++)\n+    dst->elem(i).reused = 0;\n   for (unsigned i = 0; i < kDirtyTids; i++)\n     dst->dirty_tids_[i] = kInvalidTid;\n }\n \n // Checks whether the current threads has already acquired src.\n bool ThreadClock::IsAlreadyAcquired(const SyncClock *src) const {\n-  if (src->clk_[tid_].reused != reused_)\n+  if (src->elem(tid_).reused != reused_)\n     return false;\n   for (unsigned i = 0; i < kDirtyTids; i++) {\n     unsigned tid = src->dirty_tids_[i];\n     if (tid != kInvalidTid) {\n-      if (clk_[tid].epoch < src->clk_[tid].epoch)\n+      if (clk_[tid].epoch < src->elem(tid).epoch)\n         return false;\n     }\n   }\n   return true;\n }\n \n+void SyncClock::Resize(ClockCache *c, uptr nclk) {\n+  CPP_STAT_INC(StatClockReleaseResize);\n+  if (RoundUpTo(nclk, ClockBlock::kClockCount) <=\n+      RoundUpTo(size_, ClockBlock::kClockCount)) {\n+    // Growing within the same block.\n+    // Memory is already allocated, just increase the size.\n+    size_ = nclk;\n+    return;\n+  }\n+  if (nclk <= ClockBlock::kClockCount) {\n+    // Grow from 0 to one-level table.\n+    CHECK_EQ(size_, 0);\n+    CHECK_EQ(tab_, 0);\n+    CHECK_EQ(tab_idx_, 0);\n+    size_ = nclk;\n+    tab_idx_ = ctx->clock_alloc.Alloc(c);\n+    tab_ = ctx->clock_alloc.Map(tab_idx_);\n+    internal_memset(tab_, 0, sizeof(*tab_));\n+    return;\n+  }\n+  // Growing two-level table.\n+  if (size_ == 0) {\n+    // Allocate first level table.\n+    tab_idx_ = ctx->clock_alloc.Alloc(c);\n+    tab_ = ctx->clock_alloc.Map(tab_idx_);\n+    internal_memset(tab_, 0, sizeof(*tab_));\n+  } else if (size_ <= ClockBlock::kClockCount) {\n+    // Transform one-level table to two-level table.\n+    u32 old = tab_idx_;\n+    tab_idx_ = ctx->clock_alloc.Alloc(c);\n+    tab_ = ctx->clock_alloc.Map(tab_idx_);\n+    internal_memset(tab_, 0, sizeof(*tab_));\n+    tab_->table[0] = old;\n+  }\n+  // At this point we have first level table allocated.\n+  // Add second level tables as necessary.\n+  for (uptr i = RoundUpTo(size_, ClockBlock::kClockCount);\n+      i < nclk; i += ClockBlock::kClockCount) {\n+    u32 idx = ctx->clock_alloc.Alloc(c);\n+    ClockBlock *cb = ctx->clock_alloc.Map(idx);\n+    internal_memset(cb, 0, sizeof(*cb));\n+    CHECK_EQ(tab_->table[i/ClockBlock::kClockCount], 0);\n+    tab_->table[i/ClockBlock::kClockCount] = idx;\n+  }\n+  size_ = nclk;\n+}\n+\n // Sets a single element in the vector clock.\n // This function is called only from weird places like AcquireGlobal.\n void ThreadClock::set(unsigned tid, u64 v) {\n@@ -319,28 +367,59 @@ void ThreadClock::DebugDump(int(*printf)(const char *s, ...)) {\n }\n \n SyncClock::SyncClock()\n-    : clk_(MBlockClock) {\n-  release_store_tid_ = kInvalidTid;\n-  release_store_reused_ = 0;\n+    : release_store_tid_(kInvalidTid)\n+    , release_store_reused_()\n+    , tab_()\n+    , tab_idx_()\n+    , size_() {\n   for (uptr i = 0; i < kDirtyTids; i++)\n     dirty_tids_[i] = kInvalidTid;\n }\n \n-void SyncClock::Reset() {\n-  clk_.Reset();\n+SyncClock::~SyncClock() {\n+  // Reset must be called before dtor.\n+  CHECK_EQ(size_, 0);\n+  CHECK_EQ(tab_, 0);\n+  CHECK_EQ(tab_idx_, 0);\n+}\n+\n+void SyncClock::Reset(ClockCache *c) {\n+  if (size_ == 0) {\n+    // nothing\n+  } else if (size_ <= ClockBlock::kClockCount) {\n+    // One-level table.\n+    ctx->clock_alloc.Free(c, tab_idx_);\n+  } else {\n+    // Two-level table.\n+    for (uptr i = 0; i < size_; i += ClockBlock::kClockCount)\n+      ctx->clock_alloc.Free(c, tab_->table[i / ClockBlock::kClockCount]);\n+    ctx->clock_alloc.Free(c, tab_idx_);\n+  }\n+  tab_ = 0;\n+  tab_idx_ = 0;\n+  size_ = 0;\n   release_store_tid_ = kInvalidTid;\n   release_store_reused_ = 0;\n   for (uptr i = 0; i < kDirtyTids; i++)\n     dirty_tids_[i] = kInvalidTid;\n }\n \n+ClockElem &SyncClock::elem(unsigned tid) const {\n+  DCHECK_LT(tid, size_);\n+  if (size_ <= ClockBlock::kClockCount)\n+    return tab_->clock[tid];\n+  u32 idx = tab_->table[tid / ClockBlock::kClockCount];\n+  ClockBlock *cb = ctx->clock_alloc.Map(idx);\n+  return cb->clock[tid % ClockBlock::kClockCount];\n+}\n+\n void SyncClock::DebugDump(int(*printf)(const char *s, ...)) {\n   printf(\"clock=[\");\n-  for (uptr i = 0; i < clk_.Size(); i++)\n-    printf(\"%s%llu\", i == 0 ? \"\" : \",\", clk_[i].epoch);\n+  for (uptr i = 0; i < size_; i++)\n+    printf(\"%s%llu\", i == 0 ? \"\" : \",\", elem(i).epoch);\n   printf(\"] reused=[\");\n-  for (uptr i = 0; i < clk_.Size(); i++)\n-    printf(\"%s%llu\", i == 0 ? \"\" : \",\", clk_[i].reused);\n+  for (uptr i = 0; i < size_; i++)\n+    printf(\"%s%llu\", i == 0 ? \"\" : \",\", elem(i).reused);\n   printf(\"] release_store_tid=%d/%d dirty_tids=%d/%d\",\n       release_store_tid_, release_store_reused_,\n       dirty_tids_[0], dirty_tids_[1]);"}, {"sha": "3deb7f5198cf9c79725d0416fdd5ba0b774273eb", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,7 +12,7 @@\n #define TSAN_CLOCK_H\n \n #include \"tsan_defs.h\"\n-#include \"tsan_vector.h\"\n+#include \"tsan_dense_alloc.h\"\n \n namespace __tsan {\n \n@@ -21,36 +21,65 @@ struct ClockElem {\n   u64 reused : 64 - kClkBits;\n };\n \n+struct ClockBlock {\n+  static const uptr kSize = 512;\n+  static const uptr kTableSize = kSize / sizeof(u32);\n+  static const uptr kClockCount = kSize / sizeof(ClockElem);\n+\n+  union {\n+    u32       table[kTableSize];\n+    ClockElem clock[kClockCount];\n+  };\n+\n+  ClockBlock() {\n+  }\n+};\n+\n+typedef DenseSlabAlloc<ClockBlock, 1<<16, 1<<10> ClockAlloc;\n+typedef DenseSlabAllocCache ClockCache;\n+\n // The clock that lives in sync variables (mutexes, atomics, etc).\n class SyncClock {\n  public:\n   SyncClock();\n+  ~SyncClock();\n \n   uptr size() const {\n-    return clk_.Size();\n+    return size_;\n   }\n \n   u64 get(unsigned tid) const {\n-    DCHECK_LT(tid, clk_.Size());\n-    return clk_[tid].epoch;\n+    return elem(tid).epoch;\n   }\n \n-  void Reset();\n+  void Resize(ClockCache *c, uptr nclk);\n+  void Reset(ClockCache *c);\n \n   void DebugDump(int(*printf)(const char *s, ...));\n \n  private:\n+  friend struct ThreadClock;\n+  static const uptr kDirtyTids = 2;\n+\n   unsigned release_store_tid_;\n   unsigned release_store_reused_;\n-  static const uptr kDirtyTids = 2;\n   unsigned dirty_tids_[kDirtyTids];\n-  mutable Vector<ClockElem> clk_;\n-  friend struct ThreadClock;\n+  // tab_ contains indirect pointer to a 512b block using DenseSlabAlloc.\n+  // If size_ <= 64, then tab_ points to an array with 64 ClockElem's.\n+  // Otherwise, tab_ points to an array with 128 u32 elements,\n+  // each pointing to the second-level 512b block with 64 ClockElem's.\n+  ClockBlock *tab_;\n+  u32 tab_idx_;\n+  u32 size_;\n+\n+  ClockElem &elem(unsigned tid) const;\n };\n \n // The clock that lives in threads.\n struct ThreadClock {\n  public:\n+  typedef DenseSlabAllocCache Cache;\n+\n   explicit ThreadClock(unsigned tid, unsigned reused = 0);\n \n   u64 get(unsigned tid) const {\n@@ -73,10 +102,10 @@ struct ThreadClock {\n     return nclk_;\n   }\n \n-  void acquire(const SyncClock *src);\n-  void release(SyncClock *dst) const;\n-  void acq_rel(SyncClock *dst);\n-  void ReleaseStore(SyncClock *dst) const;\n+  void acquire(ClockCache *c, const SyncClock *src);\n+  void release(ClockCache *c, SyncClock *dst) const;\n+  void acq_rel(ClockCache *c, SyncClock *dst);\n+  void ReleaseStore(ClockCache *c, SyncClock *dst) const;\n \n   void DebugReset();\n   void DebugDump(int(*printf)(const char *s, ...));"}, {"sha": "a8528cbb44a87b9b2fd733ca850263f7ba63f3c8", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -52,6 +52,7 @@ const uptr kShadowCnt = TSAN_SHADOW_COUNT;\n # endif\n #else\n // Count of shadow values in a shadow cell.\n+#define TSAN_SHADOW_COUNT 4\n const uptr kShadowCnt = 4;\n #endif\n \n@@ -64,6 +65,13 @@ const uptr kShadowSize = 8;\n // Shadow memory is kShadowMultiplier times larger than user memory.\n const uptr kShadowMultiplier = kShadowSize * kShadowCnt / kShadowCell;\n \n+// That many user bytes are mapped onto a single meta shadow cell.\n+// Must be less or equal to minimal memory allocator alignment.\n+const uptr kMetaShadowCell = 8;\n+\n+// Size of a single meta shadow value (u32).\n+const uptr kMetaShadowSize = 4;\n+\n #if defined(TSAN_NO_HISTORY) && TSAN_NO_HISTORY\n const bool kCollectHistory = false;\n #else\n@@ -165,7 +173,15 @@ struct ReportStack;\n class ReportDesc;\n class RegionAlloc;\n class StackTrace;\n-struct MBlock;\n+\n+// Descriptor of user's memory block.\n+struct MBlock {\n+  u64  siz;\n+  u32  stk;\n+  u16  tid;\n+};\n+\n+COMPILER_CHECK(sizeof(MBlock) == 16);\n \n }  // namespace __tsan\n "}, {"sha": "651c112c78aece4468cc2d086b220597ebb020a1", "filename": "libsanitizer/tsan/tsan_dense_alloc.h", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,135 @@\n+//===-- tsan_dense_alloc.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// A DenseSlabAlloc is a freelist-based allocator of fixed-size objects.\n+// DenseSlabAllocCache is a thread-local cache for DenseSlabAlloc.\n+// The only difference with traditional slab allocators is that DenseSlabAlloc\n+// allocates/free indices of objects and provide a functionality to map\n+// the index onto the real pointer. The index is u32, that is, 2 times smaller\n+// than uptr (hense the Dense prefix).\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_DENSE_ALLOC_H\n+#define TSAN_DENSE_ALLOC_H\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_mutex.h\"\n+\n+namespace __tsan {\n+\n+class DenseSlabAllocCache {\n+  static const uptr kSize = 128;\n+  typedef u32 IndexT;\n+  uptr pos;\n+  IndexT cache[kSize];\n+  template<typename T, uptr kL1Size, uptr kL2Size> friend class DenseSlabAlloc;\n+};\n+\n+template<typename T, uptr kL1Size, uptr kL2Size>\n+class DenseSlabAlloc {\n+ public:\n+  typedef DenseSlabAllocCache Cache;\n+  typedef typename Cache::IndexT IndexT;\n+\n+  DenseSlabAlloc() {\n+    // Check that kL1Size and kL2Size are sane.\n+    CHECK_EQ(kL1Size & (kL1Size - 1), 0);\n+    CHECK_EQ(kL2Size & (kL2Size - 1), 0);\n+    CHECK_GE(1ull << (sizeof(IndexT) * 8), kL1Size * kL2Size);\n+    // Check that it makes sense to use the dense alloc.\n+    CHECK_GE(sizeof(T), sizeof(IndexT));\n+    internal_memset(map_, 0, sizeof(map_));\n+    freelist_ = 0;\n+    fillpos_ = 0;\n+  }\n+\n+  ~DenseSlabAlloc() {\n+    for (uptr i = 0; i < kL1Size; i++) {\n+      if (map_[i] != 0)\n+        UnmapOrDie(map_[i], kL2Size * sizeof(T));\n+    }\n+  }\n+\n+  IndexT Alloc(Cache *c) {\n+    if (c->pos == 0)\n+      Refill(c);\n+    return c->cache[--c->pos];\n+  }\n+\n+  void Free(Cache *c, IndexT idx) {\n+    DCHECK_NE(idx, 0);\n+    if (c->pos == Cache::kSize)\n+      Drain(c);\n+    c->cache[c->pos++] = idx;\n+  }\n+\n+  T *Map(IndexT idx) {\n+    DCHECK_NE(idx, 0);\n+    DCHECK_LE(idx, kL1Size * kL2Size);\n+    return &map_[idx / kL2Size][idx % kL2Size];\n+  }\n+\n+  void FlushCache(Cache *c) {\n+    SpinMutexLock lock(&mtx_);\n+    while (c->pos) {\n+      IndexT idx = c->cache[--c->pos];\n+      *(IndexT*)Map(idx) = freelist_;\n+      freelist_ = idx;\n+    }\n+  }\n+\n+  void InitCache(Cache *c) {\n+    c->pos = 0;\n+    internal_memset(c->cache, 0, sizeof(c->cache));\n+  }\n+\n+ private:\n+  T *map_[kL1Size];\n+  SpinMutex mtx_;\n+  IndexT freelist_;\n+  uptr fillpos_;\n+\n+  void Refill(Cache *c) {\n+    SpinMutexLock lock(&mtx_);\n+    if (freelist_ == 0) {\n+      if (fillpos_ == kL1Size) {\n+        Printf(\"ThreadSanitizer: DenseSlabAllocator overflow. Dying.\\n\");\n+        Die();\n+      }\n+      T *batch = (T*)MmapOrDie(kL2Size * sizeof(T), \"DenseSlabAllocator\");\n+      // Reserve 0 as invalid index.\n+      IndexT start = fillpos_ == 0 ? 1 : 0;\n+      for (IndexT i = start; i < kL2Size; i++) {\n+        new(batch + i) T();\n+        *(IndexT*)(batch + i) = i + 1 + fillpos_ * kL2Size;\n+      }\n+      *(IndexT*)(batch + kL2Size - 1) = 0;\n+      freelist_ = fillpos_ * kL2Size + start;\n+      map_[fillpos_++] = batch;\n+    }\n+    for (uptr i = 0; i < Cache::kSize / 2 && freelist_ != 0; i++) {\n+      IndexT idx = freelist_;\n+      c->cache[c->pos++] = idx;\n+      freelist_ = *(IndexT*)Map(idx);\n+    }\n+  }\n+\n+  void Drain(Cache *c) {\n+    SpinMutexLock lock(&mtx_);\n+    for (uptr i = 0; i < Cache::kSize / 2; i++) {\n+      IndexT idx = c->cache[--c->pos];\n+      *(IndexT*)Map(idx) = freelist_;\n+      freelist_ = idx;\n+    }\n+  }\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_DENSE_ALLOC_H"}, {"sha": "a74a668c13b40a83f912f81e40f83f0497cea1b6", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -45,8 +45,8 @@ static bool bogusfd(int fd) {\n   return fd < 0 || fd >= kTableSize;\n }\n \n-static FdSync *allocsync() {\n-  FdSync *s = (FdSync*)internal_alloc(MBlockFD, sizeof(FdSync));\n+static FdSync *allocsync(ThreadState *thr, uptr pc) {\n+  FdSync *s = (FdSync*)user_alloc(thr, pc, sizeof(FdSync));\n   atomic_store(&s->rc, 1, memory_order_relaxed);\n   return s;\n }\n@@ -63,10 +63,7 @@ static void unref(ThreadState *thr, uptr pc, FdSync *s) {\n       CHECK_NE(s, &fdctx.globsync);\n       CHECK_NE(s, &fdctx.filesync);\n       CHECK_NE(s, &fdctx.socksync);\n-      SyncVar *v = ctx->synctab.GetAndRemove(thr, pc, (uptr)s);\n-      if (v)\n-        DestroyAndFree(v);\n-      internal_free(s);\n+      user_free(thr, pc, s);\n     }\n   }\n }\n@@ -217,7 +214,7 @@ void FdDup(ThreadState *thr, uptr pc, int oldfd, int newfd) {\n \n void FdPipeCreate(ThreadState *thr, uptr pc, int rfd, int wfd) {\n   DPrintf(\"#%d: FdCreatePipe(%d, %d)\\n\", thr->tid, rfd, wfd);\n-  FdSync *s = allocsync();\n+  FdSync *s = allocsync(thr, pc);\n   init(thr, pc, rfd, ref(s));\n   init(thr, pc, wfd, ref(s));\n   unref(thr, pc, s);\n@@ -227,7 +224,7 @@ void FdEventCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdEventCreate(%d)\\n\", thr->tid, fd);\n   if (bogusfd(fd))\n     return;\n-  init(thr, pc, fd, allocsync());\n+  init(thr, pc, fd, allocsync(thr, pc));\n }\n \n void FdSignalCreate(ThreadState *thr, uptr pc, int fd) {\n@@ -248,7 +245,7 @@ void FdPollCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdPollCreate(%d)\\n\", thr->tid, fd);\n   if (bogusfd(fd))\n     return;\n-  init(thr, pc, fd, allocsync());\n+  init(thr, pc, fd, allocsync(thr, pc));\n }\n \n void FdSocketCreate(ThreadState *thr, uptr pc, int fd) {"}, {"sha": "02bf6527e6aba9839c598ca1c83a2838014519cc", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -35,16 +35,13 @@ static void ParseFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->enable_annotations, \"enable_annotations\", \"\");\n   ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\", \"\");\n   ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\", \"\");\n-  ParseFlag(env, &f->suppress_java, \"suppress_java\", \"\");\n   ParseFlag(env, &f->report_bugs, \"report_bugs\", \"\");\n   ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\", \"\");\n   ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\", \"\");\n   ParseFlag(env, &f->report_mutex_bugs, \"report_mutex_bugs\", \"\");\n   ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\", \"\");\n   ParseFlag(env, &f->report_atomic_races, \"report_atomic_races\", \"\");\n   ParseFlag(env, &f->force_seq_cst_atomics, \"force_seq_cst_atomics\", \"\");\n-  ParseFlag(env, &f->suppressions, \"suppressions\", \"\");\n-  ParseFlag(env, &f->print_suppressions, \"print_suppressions\", \"\");\n   ParseFlag(env, &f->print_benign, \"print_benign\", \"\");\n   ParseFlag(env, &f->exitcode, \"exitcode\", \"\");\n   ParseFlag(env, &f->halt_on_error, \"halt_on_error\", \"\");\n@@ -70,16 +67,13 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->enable_annotations = true;\n   f->suppress_equal_stacks = true;\n   f->suppress_equal_addresses = true;\n-  f->suppress_java = false;\n   f->report_bugs = true;\n   f->report_thread_leaks = true;\n   f->report_destroy_locked = true;\n   f->report_mutex_bugs = true;\n   f->report_signal_unsafe = true;\n   f->report_atomic_races = true;\n   f->force_seq_cst_atomics = false;\n-  f->suppressions = \"\";\n-  f->print_suppressions = false;\n   f->print_benign = false;\n   f->exitcode = 66;\n   f->halt_on_error = false;\n@@ -97,19 +91,19 @@ void InitializeFlags(Flags *f, const char *env) {\n   // DDFlags\n   f->second_deadlock_stack = false;\n \n-  SetCommonFlagsDefaults(f);\n+  CommonFlags *cf = common_flags();\n+  SetCommonFlagsDefaults(cf);\n   // Override some common flags defaults.\n-  f->allow_addr2line = true;\n+  cf->allow_addr2line = true;\n+  cf->detect_deadlocks = true;\n+  cf->print_suppressions = false;\n \n   // Let a frontend override.\n   ParseFlags(f, __tsan_default_options());\n-  ParseCommonFlagsFromString(f, __tsan_default_options());\n+  ParseCommonFlagsFromString(cf, __tsan_default_options());\n   // Override from command line.\n   ParseFlags(f, env);\n-  ParseCommonFlagsFromString(f, env);\n-\n-  // Copy back to common flags.\n-  *common_flags() = *f;\n+  ParseCommonFlagsFromString(cf, env);\n \n   // Sanity check.\n   if (!f->report_bugs) {\n@@ -118,7 +112,7 @@ void InitializeFlags(Flags *f, const char *env) {\n     f->report_signal_unsafe = false;\n   }\n \n-  if (f->help) PrintFlagDescriptions();\n+  if (cf->help) PrintFlagDescriptions();\n \n   if (f->history_size < 0 || f->history_size > 7) {\n     Printf(\"ThreadSanitizer: incorrect value for history_size\""}, {"sha": "182d9b298af85128f59bd9e8a05675072fe12ebe", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,7 +17,7 @@\n \n namespace __tsan {\n \n-struct Flags : CommonFlags, DDFlags {\n+struct Flags : DDFlags {\n   // Enable dynamic annotations, otherwise they are no-ops.\n   bool enable_annotations;\n   // Suppress a race report if we've already output another race report\n@@ -26,9 +26,6 @@ struct Flags : CommonFlags, DDFlags {\n   // Suppress a race report if we've already output another race report\n   // on the same address.\n   bool suppress_equal_addresses;\n-  // Suppress weird race reports that can be seen if JVM is embed\n-  // into the process.\n-  bool suppress_java;\n   // Turns off bug reporting entirely (useful for benchmarking).\n   bool report_bugs;\n   // Report thread leaks at exit?\n@@ -45,10 +42,6 @@ struct Flags : CommonFlags, DDFlags {\n   // If set, all atomics are effectively sequentially consistent (seq_cst),\n   // regardless of what user actually specified.\n   bool force_seq_cst_atomics;\n-  // Suppressions filename.\n-  const char *suppressions;\n-  // Print matched suppressions at exit.\n-  bool print_suppressions;\n   // Print matched \"benign\" races at exit.\n   bool print_benign;\n   // Override exit status if something was reported."}, {"sha": "b49622b3ad4186059f343f031f39c8bb762f0a8d", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 161, "deletions": 126, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -45,7 +45,7 @@ DECLARE_REAL(int, pthread_attr_getdetachstate, void *, void *)\n extern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\n extern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n extern \"C\" int pthread_setspecific(unsigned key, const void *v);\n-extern \"C\" int pthread_mutexattr_gettype(void *a, int *type);\n+DECLARE_REAL(int, pthread_mutexattr_gettype, void *, void *)\n extern \"C\" int pthread_yield();\n extern \"C\" int pthread_sigmask(int how, const __sanitizer_sigset_t *set,\n                                __sanitizer_sigset_t *oldset);\n@@ -91,6 +91,11 @@ typedef void (*sighandler_t)(int sig);\n \n #define errno (*__errno_location())\n \n+// 16K loaded modules should be enough for everyone.\n+static const uptr kMaxModules = 1 << 14;\n+static LoadedModule *modules;\n+static uptr nmodules;\n+\n struct sigaction_t {\n   union {\n     sighandler_t sa_handler;\n@@ -122,9 +127,9 @@ struct SignalDesc {\n };\n \n struct SignalContext {\n-  int in_blocking_func;\n   int int_signal_send;\n-  int pending_signal_count;\n+  atomic_uintptr_t in_blocking_func;\n+  atomic_uintptr_t have_pending_signals;\n   SignalDesc pending_signals[kSigCount];\n };\n \n@@ -136,15 +141,15 @@ static LibIgnore *libignore() {\n }\n \n void InitializeLibIgnore() {\n-  libignore()->Init(*GetSuppressionContext());\n+  libignore()->Init(*SuppressionContext::Get());\n   libignore()->OnLibraryLoaded(0);\n }\n \n }  // namespace __tsan\n \n static SignalContext *SigCtx(ThreadState *thr) {\n   SignalContext *ctx = (SignalContext*)thr->signal_ctx;\n-  if (ctx == 0 && thr->is_alive) {\n+  if (ctx == 0 && !thr->is_dead) {\n     ctx = (SignalContext*)MmapOrDie(sizeof(*ctx), \"SignalContext\");\n     MemoryResetRange(thr, (uptr)&SigCtx, (uptr)ctx, sizeof(*ctx));\n     thr->signal_ctx = ctx;\n@@ -189,6 +194,7 @@ ScopedInterceptor::~ScopedInterceptor() {\n   if (!thr_->ignore_interceptors) {\n     ProcessPendingSignals(thr_);\n     FuncExit(thr_);\n+    CheckNoLocks(thr_);\n   }\n }\n \n@@ -205,7 +211,7 @@ ScopedInterceptor::~ScopedInterceptor() {\n     if (REAL(func) == 0) { \\\n       Report(\"FATAL: ThreadSanitizer: failed to intercept %s\\n\", #func); \\\n       Die(); \\\n-    } \\\n+    }                                                    \\\n     if (thr->ignore_interceptors || thr->in_ignored_lib) \\\n       return REAL(func)(__VA_ARGS__); \\\n /**/\n@@ -218,22 +224,30 @@ ScopedInterceptor::~ScopedInterceptor() {\n \n struct BlockingCall {\n   explicit BlockingCall(ThreadState *thr)\n-      : ctx(SigCtx(thr)) {\n-    ctx->in_blocking_func++;\n+      : thr(thr)\n+      , ctx(SigCtx(thr)) {\n+    for (;;) {\n+      atomic_store(&ctx->in_blocking_func, 1, memory_order_relaxed);\n+      if (atomic_load(&ctx->have_pending_signals, memory_order_relaxed) == 0)\n+        break;\n+      atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n+      ProcessPendingSignals(thr);\n+    }\n+    // When we are in a \"blocking call\", we process signals asynchronously\n+    // (right when they arrive). In this context we do not expect to be\n+    // executing any user/runtime code. The known interceptor sequence when\n+    // this is not true is: pthread_join -> munmap(stack). It's fine\n+    // to ignore munmap in this case -- we handle stack shadow separately.\n+    thr->ignore_interceptors++;\n   }\n \n   ~BlockingCall() {\n-    ctx->in_blocking_func--;\n+    thr->ignore_interceptors--;\n+    atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n   }\n \n+  ThreadState *thr;\n   SignalContext *ctx;\n-\n-  // When we are in a \"blocking call\", we process signals asynchronously\n-  // (right when they arrive). In this context we do not expect to be\n-  // executing any user/runtime code. The known interceptor sequence when\n-  // this is not true is: pthread_join -> munmap(stack). It's fine\n-  // to ignore munmap in this case -- we handle stack shadow separately.\n-  ScopedIgnoreInterceptors ignore_interceptors;\n };\n \n TSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n@@ -257,74 +271,60 @@ TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n-  SCOPED_INTERCEPTOR_RAW(dlopen, filename, flag);\n-  void *res = REAL(dlopen)(filename, flag);\n-  libignore()->OnLibraryLoaded(filename);\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(int, dlclose, void *handle) {\n-  SCOPED_INTERCEPTOR_RAW(dlclose, handle);\n-  int res = REAL(dlclose)(handle);\n-  libignore()->OnLibraryUnloaded();\n-  return res;\n-}\n-\n class AtExitContext {\n  public:\n   AtExitContext()\n     : mtx_(MutexTypeAtExit, StatMtxAtExit)\n-    , pos_() {\n+    , stack_(MBlockAtExit) {\n   }\n \n-  typedef void(*atexit_t)();\n+  typedef void(*atexit_cb_t)();\n \n   int atexit(ThreadState *thr, uptr pc, bool is_on_exit,\n-             atexit_t f, void *arg) {\n+             atexit_cb_t f, void *arg, void *dso) {\n     Lock l(&mtx_);\n-    if (pos_ == kMaxAtExit)\n-      return 1;\n     Release(thr, pc, (uptr)this);\n-    stack_[pos_] = f;\n-    args_[pos_] = arg;\n-    is_on_exits_[pos_] = is_on_exit;\n-    pos_++;\n+    atexit_t *a = stack_.PushBack();\n+    a->cb = f;\n+    a->arg = arg;\n+    a->dso = dso;\n+    a->is_on_exit = is_on_exit;\n     return 0;\n   }\n \n   void exit(ThreadState *thr, uptr pc) {\n     for (;;) {\n-      atexit_t f = 0;\n-      void *arg = 0;\n-      bool is_on_exit = false;\n+      atexit_t a = {};\n       {\n         Lock l(&mtx_);\n-        if (pos_) {\n-          pos_--;\n-          f = stack_[pos_];\n-          arg = args_[pos_];\n-          is_on_exit = is_on_exits_[pos_];\n+        if (stack_.Size() != 0) {\n+          a = stack_[stack_.Size() - 1];\n+          stack_.PopBack();\n           Acquire(thr, pc, (uptr)this);\n         }\n       }\n-      if (f == 0)\n+      if (a.cb == 0)\n         break;\n-      DPrintf(\"#%d: executing atexit func %p\\n\", thr->tid, f);\n-      if (is_on_exit)\n-        ((void(*)(int status, void *arg))f)(0, arg);\n+      VPrintf(2, \"#%d: executing atexit func %p(%p) dso=%p\\n\",\n+          thr->tid, a.cb, a.arg, a.dso);\n+      if (a.is_on_exit)\n+        ((void(*)(int status, void *arg))a.cb)(0, a.arg);\n       else\n-        ((void(*)(void *arg, void *dso))f)(arg, 0);\n+        ((void(*)(void *arg, void *dso))a.cb)(a.arg, a.dso);\n     }\n   }\n \n  private:\n-  static const int kMaxAtExit = 128;\n+  struct atexit_t {\n+    atexit_cb_t cb;\n+    void *arg;\n+    void *dso;\n+    bool is_on_exit;\n+  };\n+\n+  static const int kMaxAtExit = 1024;\n   Mutex mtx_;\n-  atexit_t stack_[kMaxAtExit];\n-  void *args_[kMaxAtExit];\n-  bool is_on_exits_[kMaxAtExit];\n-  int pos_;\n+  Vector<atexit_t> stack_;\n };\n \n static AtExitContext *atexit_ctx;\n@@ -335,29 +335,42 @@ TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n   // We want to setup the atexit callback even if we are in ignored lib\n   // or after fork.\n   SCOPED_INTERCEPTOR_RAW(atexit, f);\n-  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, 0);\n+  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, 0, 0);\n }\n \n TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n   if (cur_thread()->in_symbolizer)\n     return 0;\n   SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n-  return atexit_ctx->atexit(thr, pc, true, (void(*)())f, arg);\n+  return atexit_ctx->atexit(thr, pc, true, (void(*)())f, arg, 0);\n+}\n+\n+bool IsSaticModule(void *dso) {\n+  if (modules == 0)\n+    return false;\n+  for (uptr i = 0; i < nmodules; i++) {\n+    if (modules[i].containsAddress((uptr)dso))\n+      return true;\n+  }\n+  return false;\n }\n \n TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n   if (cur_thread()->in_symbolizer)\n     return 0;\n   SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n-  if (dso) {\n-    // Memory allocation in __cxa_atexit will race with free during exit,\n-    // because we do not see synchronization around atexit callback list.\n-    ThreadIgnoreBegin(thr, pc);\n-    int res = REAL(__cxa_atexit)(f, arg, dso);\n-    ThreadIgnoreEnd(thr, pc);\n-    return res;\n-  }\n-  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, arg);\n+  // If it's the main executable or a statically loaded library,\n+  // we will call the callback.\n+  if (dso == 0 || IsSaticModule(dso))\n+    return atexit_ctx->atexit(thr, pc, false, (void(*)())f, arg, dso);\n+\n+  // Dynamically load module, don't know when to call the callback for it.\n+  // Memory allocation in __cxa_atexit will race with free during exit,\n+  // because we do not see synchronization around atexit callback list.\n+  ThreadIgnoreBegin(thr, pc);\n+  int res = REAL(__cxa_atexit)(f, arg, dso);\n+  ThreadIgnoreEnd(thr, pc);\n+  return res;\n }\n \n // Cleanup old bufs.\n@@ -383,6 +396,13 @@ static void SetJmp(ThreadState *thr, uptr sp, uptr mangled_sp) {\n   buf->sp = sp;\n   buf->mangled_sp = mangled_sp;\n   buf->shadow_stack_pos = thr->shadow_stack_pos;\n+  SignalContext *sctx = SigCtx(thr);\n+  buf->int_signal_send = sctx ? sctx->int_signal_send : 0;\n+  buf->in_blocking_func = sctx ?\n+      atomic_load(&sctx->in_blocking_func, memory_order_relaxed) :\n+      false;\n+  buf->in_signal_handler = atomic_load(&thr->in_signal_handler,\n+      memory_order_relaxed);\n }\n \n static void LongJmp(ThreadState *thr, uptr *env) {\n@@ -395,6 +415,14 @@ static void LongJmp(ThreadState *thr, uptr *env) {\n       // Unwind the stack.\n       while (thr->shadow_stack_pos > buf->shadow_stack_pos)\n         FuncExit(thr);\n+      SignalContext *sctx = SigCtx(thr);\n+      if (sctx) {\n+        sctx->int_signal_send = buf->int_signal_send;\n+        atomic_store(&sctx->in_blocking_func, buf->in_blocking_func,\n+            memory_order_relaxed);\n+      }\n+      atomic_store(&thr->in_signal_handler, buf->in_signal_handler,\n+          memory_order_relaxed);\n       JmpBufGarbageCollect(thr, buf->sp - 1);  // do not collect buf->sp\n       return;\n     }\n@@ -531,7 +559,7 @@ TSAN_INTERCEPTOR(void, cfree, void *p) {\n \n TSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n   SCOPED_INTERCEPTOR_RAW(malloc_usable_size, p);\n-  return user_alloc_usable_size(thr, pc, p);\n+  return user_alloc_usable_size(p);\n }\n \n #define OPERATOR_NEW_BODY(mangled_name) \\\n@@ -749,6 +777,11 @@ TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n   return user_alloc(thr, pc, sz, align);\n }\n \n+TSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n+  SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n+  return user_alloc(thr, pc, sz, align);\n+}\n+\n TSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(valloc, sz);\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n@@ -1040,7 +1073,7 @@ TSAN_INTERCEPTOR(int, pthread_mutex_init, void *m, void *a) {\n     bool recursive = false;\n     if (a) {\n       int type = 0;\n-      if (pthread_mutexattr_gettype(a, &type) == 0)\n+      if (REAL(pthread_mutexattr_gettype)(a, &type) == 0)\n         recursive = (type == PTHREAD_MUTEX_RECURSIVE\n             || type == PTHREAD_MUTEX_RECURSIVE_NP);\n     }\n@@ -1151,7 +1184,7 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_tryrdlock, m);\n   int res = REAL(pthread_rwlock_tryrdlock)(m);\n   if (res == 0) {\n-    MutexLock(thr, pc, (uptr)m, /*rec=*/1, /*try_lock=*/true);\n+    MutexReadLock(thr, pc, (uptr)m, /*try_lock=*/true);\n   }\n   return res;\n }\n@@ -1689,8 +1722,10 @@ TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n \n namespace __tsan {\n \n-static void CallUserSignalHandler(ThreadState *thr, bool sync, bool sigact,\n-    int sig, my_siginfo_t *info, void *uctx) {\n+static void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,\n+    bool sigact, int sig, my_siginfo_t *info, void *uctx) {\n+  if (acquire)\n+    Acquire(thr, 0, (uptr)&sigactions[sig]);\n   // Ensure that the handler does not spoil errno.\n   const int saved_errno = errno;\n   errno = 99;\n@@ -1716,19 +1751,20 @@ static void CallUserSignalHandler(ThreadState *thr, bool sync, bool sigact,\n     ThreadRegistryLock l(ctx->thread_registry);\n     ScopedReport rep(ReportTypeErrnoInSignal);\n     if (!IsFiredSuppression(ctx, rep, stack)) {\n-      rep.AddStack(&stack);\n-      OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+      rep.AddStack(&stack, true);\n+      OutputReport(thr, rep);\n     }\n   }\n   errno = saved_errno;\n }\n \n void ProcessPendingSignals(ThreadState *thr) {\n   SignalContext *sctx = SigCtx(thr);\n-  if (sctx == 0 || sctx->pending_signal_count == 0 || thr->in_signal_handler)\n+  if (sctx == 0 ||\n+      atomic_load(&sctx->have_pending_signals, memory_order_relaxed) == 0)\n     return;\n-  thr->in_signal_handler = true;\n-  sctx->pending_signal_count = 0;\n+  atomic_store(&sctx->have_pending_signals, 0, memory_order_relaxed);\n+  atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n   // These are too big for stack.\n   static THREADLOCAL __sanitizer_sigset_t emptyset, oldset;\n   REAL(sigfillset)(&emptyset);\n@@ -1739,14 +1775,13 @@ void ProcessPendingSignals(ThreadState *thr) {\n       signal->armed = false;\n       if (sigactions[sig].sa_handler != SIG_DFL\n           && sigactions[sig].sa_handler != SIG_IGN) {\n-        CallUserSignalHandler(thr, false, signal->sigaction,\n+        CallUserSignalHandler(thr, false, true, signal->sigaction,\n             sig, &signal->siginfo, &signal->ctx);\n       }\n     }\n   }\n   pthread_sigmask(SIG_SETMASK, &oldset, 0);\n-  CHECK_EQ(thr->in_signal_handler, true);\n-  thr->in_signal_handler = false;\n+  atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n }\n \n }  // namespace __tsan\n@@ -1772,21 +1807,27 @@ void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n       // If we are in blocking function, we can safely process it now\n       // (but check if we are in a recursive interceptor,\n       // i.e. pthread_join()->munmap()).\n-      (sctx && sctx->in_blocking_func == 1)) {\n-    CHECK_EQ(thr->in_signal_handler, false);\n-    thr->in_signal_handler = true;\n-    if (sctx && sctx->in_blocking_func == 1) {\n+      (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed))) {\n+    atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n+    if (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed)) {\n       // We ignore interceptors in blocking functions,\n       // temporary enbled them again while we are calling user function.\n       int const i = thr->ignore_interceptors;\n       thr->ignore_interceptors = 0;\n-      CallUserSignalHandler(thr, sync, sigact, sig, info, ctx);\n+      atomic_store(&sctx->in_blocking_func, 0, memory_order_relaxed);\n+      CallUserSignalHandler(thr, sync, true, sigact, sig, info, ctx);\n       thr->ignore_interceptors = i;\n+      atomic_store(&sctx->in_blocking_func, 1, memory_order_relaxed);\n     } else {\n-      CallUserSignalHandler(thr, sync, sigact, sig, info, ctx);\n+      // Be very conservative with when we do acquire in this case.\n+      // It's unsafe to do acquire in async handlers, because ThreadState\n+      // can be in inconsistent state.\n+      // SIGSYS looks relatively safe -- it's synchronous and can actually\n+      // need some global state.\n+      bool acq = (sig == SIGSYS);\n+      CallUserSignalHandler(thr, sync, acq, sigact, sig, info, ctx);\n     }\n-    CHECK_EQ(thr->in_signal_handler, true);\n-    thr->in_signal_handler = false;\n+    atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n     return;\n   }\n \n@@ -1800,7 +1841,7 @@ void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n       internal_memcpy(&signal->siginfo, info, sizeof(*info));\n     if (ctx)\n       internal_memcpy(&signal->ctx, ctx, sizeof(signal->ctx));\n-    sctx->pending_signal_count++;\n+    atomic_store(&sctx->have_pending_signals, 1, memory_order_relaxed);\n   }\n }\n \n@@ -1828,6 +1869,7 @@ TSAN_INTERCEPTOR(int, sigaction, int sig, sigaction_t *act, sigaction_t *old) {\n     else\n       newact.sa_handler = rtl_sighandler;\n   }\n+  ReleaseStore(thr, pc, (uptr)&sigactions[sig]);\n   int res = REAL(sigaction)(sig, &newact, 0);\n   return res;\n }\n@@ -1911,35 +1953,6 @@ TSAN_INTERCEPTOR(int, getaddrinfo, void *node, void *service,\n   return res;\n }\n \n-// Linux kernel has a bug that leads to kernel deadlock if a process\n-// maps TBs of memory and then calls mlock().\n-static void MlockIsUnsupported() {\n-  static atomic_uint8_t printed;\n-  if (atomic_exchange(&printed, 1, memory_order_relaxed))\n-    return;\n-  VPrintf(1, \"INFO: ThreadSanitizer ignores mlock/munlock[all]\\n\");\n-}\n-\n-TSAN_INTERCEPTOR(int, mlock, const void *addr, uptr len) {\n-  MlockIsUnsupported();\n-  return 0;\n-}\n-\n-TSAN_INTERCEPTOR(int, munlock, const void *addr, uptr len) {\n-  MlockIsUnsupported();\n-  return 0;\n-}\n-\n-TSAN_INTERCEPTOR(int, mlockall, int flags) {\n-  MlockIsUnsupported();\n-  return 0;\n-}\n-\n-TSAN_INTERCEPTOR(int, munlockall, void) {\n-  MlockIsUnsupported();\n-  return 0;\n-}\n-\n TSAN_INTERCEPTOR(int, fork, int fake) {\n   if (cur_thread()->in_symbolizer)\n     return REAL(fork)(fake);\n@@ -2000,6 +2013,18 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n // Causes interceptor recursion (getaddrinfo() and fopen())\n #undef SANITIZER_INTERCEPT_GETADDRINFO\n+// There interceptors do not seem to be strictly necessary for tsan.\n+// But we see cases where the interceptors consume 70% of execution time.\n+// Memory blocks passed to fgetgrent_r are \"written to\" by tsan several times.\n+// First, there is some recursion (getgrnam_r calls fgetgrent_r), and each\n+// function \"writes to\" the buffer. Then, the same memory is \"written to\"\n+// twice, first as buf and then as pwbufp (both of them refer to the same\n+// addresses).\n+#undef SANITIZER_INTERCEPT_GETPWENT\n+#undef SANITIZER_INTERCEPT_GETPWENT_R\n+#undef SANITIZER_INTERCEPT_FGETPWENT\n+#undef SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n+#undef SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n \n #define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n \n@@ -2019,6 +2044,12 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n   ctx = (void *)&_ctx;                                \\\n   (void) ctx;\n \n+#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, func, ...) \\\n+  SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__);              \\\n+  TsanInterceptorContext _ctx = {thr, caller_pc, pc};     \\\n+  ctx = (void *)&_ctx;                                    \\\n+  (void) ctx;\n+\n #define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) \\\n   Acquire(thr, pc, File2addr(path));                  \\\n   if (file) {                                         \\\n@@ -2032,6 +2063,12 @@ static void HandleRecvmsg(ThreadState *thr, uptr pc,\n     if (fd >= 0) FdClose(thr, pc, fd);           \\\n   }\n \n+#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res)  \\\n+  libignore()->OnLibraryLoaded(filename)\n+\n+#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() \\\n+  libignore()->OnLibraryUnloaded()\n+\n #define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n   FdAcquire(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n \n@@ -2367,15 +2404,8 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(gettimeofday);\n   TSAN_INTERCEPT(getaddrinfo);\n \n-  TSAN_INTERCEPT(mlock);\n-  TSAN_INTERCEPT(munlock);\n-  TSAN_INTERCEPT(mlockall);\n-  TSAN_INTERCEPT(munlockall);\n-\n   TSAN_INTERCEPT(fork);\n   TSAN_INTERCEPT(vfork);\n-  TSAN_INTERCEPT(dlopen);\n-  TSAN_INTERCEPT(dlclose);\n   TSAN_INTERCEPT(on_exit);\n   TSAN_INTERCEPT(__cxa_atexit);\n   TSAN_INTERCEPT(_exit);\n@@ -2397,6 +2427,11 @@ void InitializeInterceptors() {\n   }\n \n   FdInit();\n+\n+  // Remember list of loaded libraries for atexit interceptors.\n+  modules = (LoadedModule*)MmapOrDie(sizeof(*modules)*kMaxModules,\n+      \"LoadedModule\");\n+  nmodules = GetListOfModules(modules, kMaxModules, 0);\n }\n \n void *internal_start_thread(void(*func)(void *arg), void *arg) {"}, {"sha": "85de2e6221f1dcb2bcd9c9bbeb1005aceaab805f", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -38,6 +38,7 @@ class ScopedAnnotation {\n \n   ~ScopedAnnotation() {\n     FuncExit(thr_);\n+    CheckNoLocks(thr_);\n   }\n  private:\n   ThreadState *const thr_;\n@@ -123,8 +124,6 @@ static ExpectRace *FindRace(ExpectRace *list, uptr addr, uptr size) {\n \n static bool CheckContains(ExpectRace *list, uptr addr, uptr size) {\n   ExpectRace *race = FindRace(list, addr, size);\n-  if (race == 0 && AlternativeAddress(addr))\n-    race = FindRace(list, AlternativeAddress(addr), size);\n   if (race == 0)\n     return false;\n   DPrintf(\"Hit expected/benign race: %s addr=%zx:%d %s:%d\\n\","}, {"sha": "316614dd486eec74875dd06a82dd05de084c5b9b", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 156, "deletions": 53, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -25,33 +25,23 @@\n \n using namespace __tsan;  // NOLINT\n \n-#define SCOPED_ATOMIC(func, ...) \\\n-    const uptr callpc = (uptr)__builtin_return_address(0); \\\n-    uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n-    mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n-    ThreadState *const thr = cur_thread(); \\\n-    if (thr->ignore_interceptors) \\\n-      return NoTsanAtomic##func(__VA_ARGS__); \\\n-    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n-    ScopedAtomic sa(thr, callpc, a, mo, __func__); \\\n-    return Atomic##func(thr, pc, __VA_ARGS__); \\\n-/**/\n-\n // These should match declarations from public tsan_interface_atomic.h header.\n typedef unsigned char      a8;\n typedef unsigned short     a16;  // NOLINT\n typedef unsigned int       a32;\n typedef unsigned long long a64;  // NOLINT\n-#if defined(__SIZEOF_INT128__) \\\n-    || (__clang_major__ * 100 + __clang_minor__ >= 302)\n+#if !defined(TSAN_GO) && (defined(__SIZEOF_INT128__) \\\n+    || (__clang_major__ * 100 + __clang_minor__ >= 302))\n __extension__ typedef __int128 a128;\n # define __TSAN_HAS_INT128 1\n #else\n # define __TSAN_HAS_INT128 0\n #endif\n \n+#ifndef TSAN_GO\n // Protects emulation of 128-bit atomic operations.\n static StaticSpinMutex mutex128;\n+#endif\n \n // Part of ABI, do not change.\n // http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/atomic?view=markup\n@@ -64,38 +54,6 @@ typedef enum {\n   mo_seq_cst\n } morder;\n \n-class ScopedAtomic {\n- public:\n-  ScopedAtomic(ThreadState *thr, uptr pc, const volatile void *a,\n-               morder mo, const char *func)\n-      : thr_(thr) {\n-    FuncEntry(thr_, pc);\n-    DPrintf(\"#%d: %s(%p, %d)\\n\", thr_->tid, func, a, mo);\n-  }\n-  ~ScopedAtomic() {\n-    ProcessPendingSignals(thr_);\n-    FuncExit(thr_);\n-  }\n- private:\n-  ThreadState *thr_;\n-};\n-\n-static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {\n-  StatInc(thr, StatAtomic);\n-  StatInc(thr, t);\n-  StatInc(thr, size == 1 ? StatAtomic1\n-             : size == 2 ? StatAtomic2\n-             : size == 4 ? StatAtomic4\n-             : size == 8 ? StatAtomic8\n-             :             StatAtomic16);\n-  StatInc(thr, mo == mo_relaxed ? StatAtomicRelaxed\n-             : mo == mo_consume ? StatAtomicConsume\n-             : mo == mo_acquire ? StatAtomicAcquire\n-             : mo == mo_release ? StatAtomicRelease\n-             : mo == mo_acq_rel ? StatAtomicAcq_Rel\n-             :                    StatAtomicSeq_Cst);\n-}\n-\n static bool IsLoadOrder(morder mo) {\n   return mo == mo_relaxed || mo == mo_consume\n       || mo == mo_acquire || mo == mo_seq_cst;\n@@ -165,7 +123,7 @@ template<typename T> T func_cas(volatile T *v, T cmp, T xch) {\n // Atomic ops are executed under tsan internal mutex,\n // here we assume that the atomic variables are not accessed\n // from non-instrumented code.\n-#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16\n+#if !defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16) && !defined(TSAN_GO)\n a128 func_xchg(volatile a128 *v, a128 op) {\n   SpinMutexLock lock(&mutex128);\n   a128 cmp = *v;\n@@ -238,13 +196,15 @@ static int SizeLog() {\n   // this leads to false negatives only in very obscure cases.\n }\n \n+#ifndef TSAN_GO\n static atomic_uint8_t *to_atomic(const volatile a8 *a) {\n   return (atomic_uint8_t*)a;\n }\n \n static atomic_uint16_t *to_atomic(const volatile a16 *a) {\n   return (atomic_uint16_t*)a;\n }\n+#endif\n \n static atomic_uint32_t *to_atomic(const volatile a32 *a) {\n   return (atomic_uint32_t*)a;\n@@ -272,10 +232,12 @@ static T NoTsanAtomicLoad(const volatile T *a, morder mo) {\n   return atomic_load(to_atomic(a), to_mo(mo));\n }\n \n+#if __TSAN_HAS_INT128 && !defined(TSAN_GO)\n static a128 NoTsanAtomicLoad(const volatile a128 *a, morder mo) {\n   SpinMutexLock lock(&mutex128);\n   return *a;\n }\n+#endif\n \n template<typename T>\n static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n@@ -287,7 +249,7 @@ static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n     MemoryReadAtomic(thr, pc, (uptr)a, SizeLog<T>());\n     return NoTsanAtomicLoad(a, mo);\n   }\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, false);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, (uptr)a, false);\n   AcquireImpl(thr, pc, &s->clock);\n   T v = NoTsanAtomicLoad(a, mo);\n   s->mtx.ReadUnlock();\n@@ -300,10 +262,12 @@ static void NoTsanAtomicStore(volatile T *a, T v, morder mo) {\n   atomic_store(to_atomic(a), v, to_mo(mo));\n }\n \n+#if __TSAN_HAS_INT128 && !defined(TSAN_GO)\n static void NoTsanAtomicStore(volatile a128 *a, a128 v, morder mo) {\n   SpinMutexLock lock(&mutex128);\n   *a = v;\n }\n+#endif\n \n template<typename T>\n static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n@@ -319,7 +283,7 @@ static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n     return;\n   }\n   __sync_synchronize();\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n   thr->fast_state.IncrementEpoch();\n   // Can't increment epoch w/o writing to the trace as well.\n   TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n@@ -333,7 +297,7 @@ static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {\n   MemoryWriteAtomic(thr, pc, (uptr)a, SizeLog<T>());\n   SyncVar *s = 0;\n   if (mo != mo_relaxed) {\n-    s = ctx->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n+    s = ctx->metamap.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n     TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n@@ -432,6 +396,7 @@ static bool NoTsanAtomicCAS(volatile T *a, T *c, T v, morder mo, morder fmo) {\n   return atomic_compare_exchange_strong(to_atomic(a), c, v, to_mo(mo));\n }\n \n+#if __TSAN_HAS_INT128\n static bool NoTsanAtomicCAS(volatile a128 *a, a128 *c, a128 v,\n     morder mo, morder fmo) {\n   a128 old = *c;\n@@ -441,10 +406,12 @@ static bool NoTsanAtomicCAS(volatile a128 *a, a128 *c, a128 v,\n   *c = cur;\n   return false;\n }\n+#endif\n \n template<typename T>\n-static bool NoTsanAtomicCAS(volatile T *a, T c, T v, morder mo, morder fmo) {\n-  return NoTsanAtomicCAS(a, &c, v, mo, fmo);\n+static T NoTsanAtomicCAS(volatile T *a, T c, T v, morder mo, morder fmo) {\n+  NoTsanAtomicCAS(a, &c, v, mo, fmo);\n+  return c;\n }\n \n template<typename T>\n@@ -455,7 +422,7 @@ static bool AtomicCAS(ThreadState *thr, uptr pc,\n   SyncVar *s = 0;\n   bool write_lock = mo != mo_acquire && mo != mo_consume;\n   if (mo != mo_relaxed) {\n-    s = ctx->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, write_lock);\n+    s = ctx->metamap.GetOrCreateAndLock(thr, pc, (uptr)a, write_lock);\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n     TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n@@ -487,6 +454,7 @@ static T AtomicCAS(ThreadState *thr, uptr pc,\n   return c;\n }\n \n+#ifndef TSAN_GO\n static void NoTsanAtomicFence(morder mo) {\n   __sync_synchronize();\n }\n@@ -495,6 +463,56 @@ static void AtomicFence(ThreadState *thr, uptr pc, morder mo) {\n   // FIXME(dvyukov): not implemented.\n   __sync_synchronize();\n }\n+#endif\n+\n+// Interface functions follow.\n+#ifndef TSAN_GO\n+\n+// C/C++\n+\n+#define SCOPED_ATOMIC(func, ...) \\\n+    const uptr callpc = (uptr)__builtin_return_address(0); \\\n+    uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+    mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n+    ThreadState *const thr = cur_thread(); \\\n+    if (thr->ignore_interceptors) \\\n+      return NoTsanAtomic##func(__VA_ARGS__); \\\n+    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n+    ScopedAtomic sa(thr, callpc, a, mo, __func__); \\\n+    return Atomic##func(thr, pc, __VA_ARGS__); \\\n+/**/\n+\n+class ScopedAtomic {\n+ public:\n+  ScopedAtomic(ThreadState *thr, uptr pc, const volatile void *a,\n+               morder mo, const char *func)\n+      : thr_(thr) {\n+    FuncEntry(thr_, pc);\n+    DPrintf(\"#%d: %s(%p, %d)\\n\", thr_->tid, func, a, mo);\n+  }\n+  ~ScopedAtomic() {\n+    ProcessPendingSignals(thr_);\n+    FuncExit(thr_);\n+  }\n+ private:\n+  ThreadState *thr_;\n+};\n+\n+static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {\n+  StatInc(thr, StatAtomic);\n+  StatInc(thr, t);\n+  StatInc(thr, size == 1 ? StatAtomic1\n+             : size == 2 ? StatAtomic2\n+             : size == 4 ? StatAtomic4\n+             : size == 8 ? StatAtomic8\n+             :             StatAtomic16);\n+  StatInc(thr, mo == mo_relaxed ? StatAtomicRelaxed\n+             : mo == mo_consume ? StatAtomicConsume\n+             : mo == mo_acquire ? StatAtomicAcquire\n+             : mo == mo_release ? StatAtomicRelease\n+             : mo == mo_acq_rel ? StatAtomicAcq_Rel\n+             :                    StatAtomicSeq_Cst);\n+}\n \n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -846,3 +864,88 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __tsan_atomic_signal_fence(morder mo) {\n }\n }  // extern \"C\"\n+\n+#else  // #ifndef TSAN_GO\n+\n+// Go\n+\n+#define ATOMIC(func, ...) \\\n+    if (thr->ignore_sync) { \\\n+      NoTsanAtomic##func(__VA_ARGS__); \\\n+    } else { \\\n+      FuncEntry(thr, cpc); \\\n+      Atomic##func(thr, pc, __VA_ARGS__); \\\n+      FuncExit(thr); \\\n+    } \\\n+/**/\n+\n+#define ATOMIC_RET(func, ret, ...) \\\n+    if (thr->ignore_sync) { \\\n+      (ret) = NoTsanAtomic##func(__VA_ARGS__); \\\n+    } else { \\\n+      FuncEntry(thr, cpc); \\\n+      (ret) = Atomic##func(thr, pc, __VA_ARGS__); \\\n+      FuncExit(thr); \\\n+    } \\\n+/**/\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic32_load(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(Load, *(a32*)(a+8), *(a32**)a, mo_acquire);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic64_load(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(Load, *(a64*)(a+8), *(a64**)a, mo_acquire);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic32_store(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC(Store, *(a32**)a, *(a32*)(a+8), mo_release);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic64_store(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC(Store, *(a64**)a, *(a64*)(a+8), mo_release);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic32_fetch_add(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(FetchAdd, *(a32*)(a+16), *(a32**)a, *(a32*)(a+8), mo_acq_rel);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic64_fetch_add(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(FetchAdd, *(a64*)(a+16), *(a64**)a, *(a64*)(a+8), mo_acq_rel);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic32_exchange(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(Exchange, *(a32*)(a+16), *(a32**)a, *(a32*)(a+8), mo_acq_rel);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic64_exchange(ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  ATOMIC_RET(Exchange, *(a64*)(a+16), *(a64**)a, *(a64*)(a+8), mo_acq_rel);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic32_compare_exchange(\n+    ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  a32 cur = 0;\n+  a32 cmp = *(a32*)(a+8);\n+  ATOMIC_RET(CAS, cur, *(a32**)a, cmp, *(a32*)(a+12), mo_acq_rel, mo_acquire);\n+  *(bool*)(a+16) = (cur == cmp);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __tsan_go_atomic64_compare_exchange(\n+    ThreadState *thr, uptr cpc, uptr pc, u8 *a) {\n+  a64 cur = 0;\n+  a64 cmp = *(a64*)(a+8);\n+  ATOMIC_RET(CAS, cur, *(a64**)a, cmp, *(a64*)(a+16), mo_acq_rel, mo_acquire);\n+  *(bool*)(a+24) = (cur == cmp);\n+}\n+}  // extern \"C\"\n+#endif  // #ifndef TSAN_GO"}, {"sha": "03a9e280ddcd201053177cac5c777c59a42e0a6d", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 27, "deletions": 133, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,54 +20,17 @@\n \n using namespace __tsan;  // NOLINT\n \n-namespace __tsan {\n-\n-const uptr kHeapShadow = 0x300000000000ull;\n-const uptr kHeapAlignment = 8;\n+const jptr kHeapAlignment = 8;\n \n-struct BlockDesc {\n-  bool begin;\n-  Mutex mtx;\n-  SyncVar *head;\n-\n-  BlockDesc()\n-      : mtx(MutexTypeJavaMBlock, StatMtxJavaMBlock)\n-      , head() {\n-    CHECK_EQ(begin, false);\n-    begin = true;\n-  }\n-\n-  ~BlockDesc() {\n-    CHECK_EQ(begin, true);\n-    begin = false;\n-    ThreadState *thr = cur_thread();\n-    SyncVar *s = head;\n-    while (s) {\n-      SyncVar *s1 = s->next;\n-      StatInc(thr, StatSyncDestroyed);\n-      s->mtx.Lock();\n-      s->mtx.Unlock();\n-      thr->mset.Remove(s->GetId());\n-      DestroyAndFree(s);\n-      s = s1;\n-    }\n-  }\n-};\n+namespace __tsan {\n \n struct JavaContext {\n   const uptr heap_begin;\n   const uptr heap_size;\n-  BlockDesc *heap_shadow;\n \n   JavaContext(jptr heap_begin, jptr heap_size)\n       : heap_begin(heap_begin)\n       , heap_size(heap_size) {\n-    uptr size = heap_size / kHeapAlignment * sizeof(BlockDesc);\n-    heap_shadow = (BlockDesc*)MmapFixedNoReserve(kHeapShadow, size);\n-    if ((uptr)heap_shadow != kHeapShadow) {\n-      Printf(\"ThreadSanitizer: failed to mmap Java heap shadow\\n\");\n-      Die();\n-    }\n   }\n };\n \n@@ -91,63 +54,6 @@ class ScopedJavaFunc {\n static u64 jctx_buf[sizeof(JavaContext) / sizeof(u64) + 1];\n static JavaContext *jctx;\n \n-static BlockDesc *getblock(uptr addr) {\n-  uptr i = (addr - jctx->heap_begin) / kHeapAlignment;\n-  return &jctx->heap_shadow[i];\n-}\n-\n-static uptr USED getmem(BlockDesc *b) {\n-  uptr i = b - jctx->heap_shadow;\n-  uptr p = jctx->heap_begin + i * kHeapAlignment;\n-  CHECK_GE(p, jctx->heap_begin);\n-  CHECK_LT(p, jctx->heap_begin + jctx->heap_size);\n-  return p;\n-}\n-\n-static BlockDesc *getblockbegin(uptr addr) {\n-  for (BlockDesc *b = getblock(addr);; b--) {\n-    CHECK_GE(b, jctx->heap_shadow);\n-    if (b->begin)\n-      return b;\n-  }\n-  return 0;\n-}\n-\n-SyncVar* GetJavaSync(ThreadState *thr, uptr pc, uptr addr,\n-                     bool write_lock, bool create) {\n-  if (jctx == 0 || addr < jctx->heap_begin\n-      || addr >= jctx->heap_begin + jctx->heap_size)\n-    return 0;\n-  BlockDesc *b = getblockbegin(addr);\n-  DPrintf(\"#%d: GetJavaSync %p->%p\\n\", thr->tid, addr, b);\n-  Lock l(&b->mtx);\n-  SyncVar *s = b->head;\n-  for (; s; s = s->next) {\n-    if (s->addr == addr) {\n-      DPrintf(\"#%d: found existing sync for %p\\n\", thr->tid, addr);\n-      break;\n-    }\n-  }\n-  if (s == 0 && create) {\n-    DPrintf(\"#%d: creating new sync for %p\\n\", thr->tid, addr);\n-    s = ctx->synctab.Create(thr, pc, addr);\n-    s->next = b->head;\n-    b->head = s;\n-  }\n-  if (s) {\n-    if (write_lock)\n-      s->mtx.Lock();\n-    else\n-      s->mtx.ReadLock();\n-  }\n-  return s;\n-}\n-\n-SyncVar* GetAndRemoveJavaSync(ThreadState *thr, uptr pc, uptr addr) {\n-  // We do not destroy Java mutexes other than in __tsan_java_free().\n-  return 0;\n-}\n-\n }  // namespace __tsan\n \n #define SCOPED_JAVA_FUNC(func) \\\n@@ -190,8 +96,7 @@ void __tsan_java_alloc(jptr ptr, jptr size) {\n   CHECK_GE(ptr, jctx->heap_begin);\n   CHECK_LE(ptr + size, jctx->heap_begin + jctx->heap_size);\n \n-  BlockDesc *b = getblock(ptr);\n-  new(b) BlockDesc();\n+  OnUserAlloc(thr, pc, ptr, size, false);\n }\n \n void __tsan_java_free(jptr ptr, jptr size) {\n@@ -204,12 +109,7 @@ void __tsan_java_free(jptr ptr, jptr size) {\n   CHECK_GE(ptr, jctx->heap_begin);\n   CHECK_LE(ptr + size, jctx->heap_begin + jctx->heap_size);\n \n-  BlockDesc *beg = getblock(ptr);\n-  BlockDesc *end = getblock(ptr + size);\n-  for (BlockDesc *b = beg; b != end; b++) {\n-    if (b->begin)\n-      b->~BlockDesc();\n-  }\n+  ctx->metamap.FreeRange(thr, pc, ptr, size);\n }\n \n void __tsan_java_move(jptr src, jptr dst, jptr size) {\n@@ -224,42 +124,36 @@ void __tsan_java_move(jptr src, jptr dst, jptr size) {\n   CHECK_LE(src + size, jctx->heap_begin + jctx->heap_size);\n   CHECK_GE(dst, jctx->heap_begin);\n   CHECK_LE(dst + size, jctx->heap_begin + jctx->heap_size);\n-  CHECK(dst >= src + size || src >= dst + size);\n+  CHECK_NE(dst, src);\n+  CHECK_NE(size, 0);\n \n   // Assuming it's not running concurrently with threads that do\n   // memory accesses and mutex operations (stop-the-world phase).\n-  {  // NOLINT\n-    BlockDesc *s = getblock(src);\n-    BlockDesc *d = getblock(dst);\n-    BlockDesc *send = getblock(src + size);\n-    for (; s != send; s++, d++) {\n-      CHECK_EQ(d->begin, false);\n-      if (s->begin) {\n-        DPrintf(\"#%d: moving block %p->%p\\n\", thr->tid, getmem(s), getmem(d));\n-        new(d) BlockDesc;\n-        d->head = s->head;\n-        for (SyncVar *sync = d->head; sync; sync = sync->next) {\n-          uptr newaddr = sync->addr - src + dst;\n-          DPrintf(\"#%d: moving sync %p->%p\\n\", thr->tid, sync->addr, newaddr);\n-          sync->addr = newaddr;\n-        }\n-        s->head = 0;\n-        s->~BlockDesc();\n-      }\n-    }\n+  ctx->metamap.MoveMemory(src, dst, size);\n+\n+  // Move shadow.\n+  u64 *s = (u64*)MemToShadow(src);\n+  u64 *d = (u64*)MemToShadow(dst);\n+  u64 *send = (u64*)MemToShadow(src + size);\n+  uptr inc = 1;\n+  if (dst > src) {\n+    s = (u64*)MemToShadow(src + size) - 1;\n+    d = (u64*)MemToShadow(dst + size) - 1;\n+    send = (u64*)MemToShadow(src) - 1;\n+    inc = -1;\n   }\n-\n-  {  // NOLINT\n-    u64 *s = (u64*)MemToShadow(src);\n-    u64 *d = (u64*)MemToShadow(dst);\n-    u64 *send = (u64*)MemToShadow(src + size);\n-    for (; s != send; s++, d++) {\n-      *d = *s;\n-      *s = 0;\n-    }\n+  for (; s != send; s += inc, d += inc) {\n+    *d = *s;\n+    *s = 0;\n   }\n }\n \n+void __tsan_java_finalize() {\n+  SCOPED_JAVA_FUNC(__tsan_java_finalize);\n+  DPrintf(\"#%d: java_mutex_finalize()\\n\", thr->tid);\n+  AcquireGlobal(thr, 0);\n+}\n+\n void __tsan_java_mutex_lock(jptr addr) {\n   SCOPED_JAVA_FUNC(__tsan_java_mutex_lock);\n   DPrintf(\"#%d: java_mutex_lock(%p)\\n\", thr->tid, addr);"}, {"sha": "9af1f3fe21a8765a48e043f265712b58761d3f3b", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -48,8 +48,13 @@ void __tsan_java_alloc(jptr ptr, jptr size) INTERFACE_ATTRIBUTE;\n void __tsan_java_free(jptr ptr, jptr size) INTERFACE_ATTRIBUTE;\n // Callback for memory move by GC.\n // Can be aggregated for several objects (preferably).\n-// The ranges must not overlap.\n+// The ranges can overlap.\n void __tsan_java_move(jptr src, jptr dst, jptr size) INTERFACE_ATTRIBUTE;\n+// This function must be called on the finalizer thread\n+// before executing a batch of finalizers.\n+// It ensures necessary synchronization between\n+// java object creation and finalization.\n+void __tsan_java_finalize() INTERFACE_ATTRIBUTE;\n \n // Mutex lock.\n // Addr is any unique address associated with the mutex."}, {"sha": "2eae60de512f09dff4199f3ccdf5c65e87cd0276", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 44, "deletions": 91, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -8,6 +8,7 @@\n // This file is a part of ThreadSanitizer (TSan), a race detector.\n //\n //===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"tsan_mman.h\"\n@@ -16,43 +17,17 @@\n #include \"tsan_flags.h\"\n \n // May be overriden by front-end.\n-extern \"C\" void WEAK __tsan_malloc_hook(void *ptr, uptr size) {\n+extern \"C\" void WEAK __sanitizer_malloc_hook(void *ptr, uptr size) {\n   (void)ptr;\n   (void)size;\n }\n \n-extern \"C\" void WEAK __tsan_free_hook(void *ptr) {\n+extern \"C\" void WEAK __sanitizer_free_hook(void *ptr) {\n   (void)ptr;\n }\n \n namespace __tsan {\n \n-COMPILER_CHECK(sizeof(MBlock) == 16);\n-\n-void MBlock::Lock() {\n-  atomic_uintptr_t *a = reinterpret_cast<atomic_uintptr_t*>(this);\n-  uptr v = atomic_load(a, memory_order_relaxed);\n-  for (int iter = 0;; iter++) {\n-    if (v & 1) {\n-      if (iter < 10)\n-        proc_yield(20);\n-      else\n-        internal_sched_yield();\n-      v = atomic_load(a, memory_order_relaxed);\n-      continue;\n-    }\n-    if (atomic_compare_exchange_weak(a, &v, v | 1, memory_order_acquire))\n-      break;\n-  }\n-}\n-\n-void MBlock::Unlock() {\n-  atomic_uintptr_t *a = reinterpret_cast<atomic_uintptr_t*>(this);\n-  uptr v = atomic_load(a, memory_order_relaxed);\n-  DCHECK(v & 1);\n-  atomic_store(a, v & ~1, memory_order_relaxed);\n-}\n-\n struct MapUnmapCallback {\n   void OnMap(uptr p, uptr size) const { }\n   void OnUnmap(uptr p, uptr size) const {\n@@ -86,15 +61,16 @@ void AllocatorPrintStats() {\n }\n \n static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n-  if (!thr->in_signal_handler || !flags()->report_signal_unsafe)\n+  if (atomic_load(&thr->in_signal_handler, memory_order_relaxed) == 0 ||\n+      !flags()->report_signal_unsafe)\n     return;\n   StackTrace stack;\n   stack.ObtainCurrent(thr, pc);\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(ReportTypeSignalUnsafe);\n   if (!IsFiredSuppression(ctx, rep, stack)) {\n-    rep.AddStack(&stack);\n-    OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+    rep.AddStack(&stack, true);\n+    OutputReport(thr, rep);\n   }\n }\n \n@@ -104,43 +80,36 @@ void *user_alloc(ThreadState *thr, uptr pc, uptr sz, uptr align) {\n   void *p = allocator()->Allocate(&thr->alloc_cache, sz, align);\n   if (p == 0)\n     return 0;\n-  MBlock *b = new(allocator()->GetMetaData(p)) MBlock;\n-  b->Init(sz, thr->tid, CurrentStackId(thr, pc));\n-  if (ctx && ctx->initialized) {\n-    if (thr->ignore_reads_and_writes == 0)\n-      MemoryRangeImitateWrite(thr, pc, (uptr)p, sz);\n-    else\n-      MemoryResetRange(thr, pc, (uptr)p, sz);\n-  }\n-  DPrintf(\"#%d: alloc(%zu) = %p\\n\", thr->tid, sz, p);\n+  if (ctx && ctx->initialized)\n+    OnUserAlloc(thr, pc, (uptr)p, sz, true);\n   SignalUnsafeCall(thr, pc);\n   return p;\n }\n \n void user_free(ThreadState *thr, uptr pc, void *p) {\n-  CHECK_NE(p, (void*)0);\n-  DPrintf(\"#%d: free(%p)\\n\", thr->tid, p);\n-  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n-  if (b->ListHead()) {\n-    MBlock::ScopedLock l(b);\n-    for (SyncVar *s = b->ListHead(); s;) {\n-      SyncVar *res = s;\n-      s = s->next;\n-      StatInc(thr, StatSyncDestroyed);\n-      res->mtx.Lock();\n-      res->mtx.Unlock();\n-      DestroyAndFree(res);\n-    }\n-    b->ListReset();\n-  }\n-  if (ctx && ctx->initialized) {\n-    if (thr->ignore_reads_and_writes == 0)\n-      MemoryRangeFreed(thr, pc, (uptr)p, b->Size());\n-  }\n+  if (ctx && ctx->initialized)\n+    OnUserFree(thr, pc, (uptr)p, true);\n   allocator()->Deallocate(&thr->alloc_cache, p);\n   SignalUnsafeCall(thr, pc);\n }\n \n+void OnUserAlloc(ThreadState *thr, uptr pc, uptr p, uptr sz, bool write) {\n+  DPrintf(\"#%d: alloc(%zu) = %p\\n\", thr->tid, sz, p);\n+  ctx->metamap.AllocBlock(thr, pc, p, sz);\n+  if (write && thr->ignore_reads_and_writes == 0)\n+    MemoryRangeImitateWrite(thr, pc, (uptr)p, sz);\n+  else\n+    MemoryResetRange(thr, pc, (uptr)p, sz);\n+}\n+\n+void OnUserFree(ThreadState *thr, uptr pc, uptr p, bool write) {\n+  CHECK_NE(p, (void*)0);\n+  uptr sz = ctx->metamap.FreeBlock(thr, pc, p);\n+  DPrintf(\"#%d: free(%p, %zu)\\n\", thr->tid, p, sz);\n+  if (write && thr->ignore_reads_and_writes == 0)\n+    MemoryRangeFreed(thr, pc, (uptr)p, sz);\n+}\n+\n void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz) {\n   void *p2 = 0;\n   // FIXME: Handle \"shrinking\" more efficiently,\n@@ -150,49 +119,38 @@ void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz) {\n     if (p2 == 0)\n       return 0;\n     if (p) {\n-      MBlock *b = user_mblock(thr, p);\n-      CHECK_NE(b, 0);\n-      internal_memcpy(p2, p, min(b->Size(), sz));\n+      uptr oldsz = user_alloc_usable_size(p);\n+      internal_memcpy(p2, p, min(oldsz, sz));\n     }\n   }\n   if (p)\n     user_free(thr, pc, p);\n   return p2;\n }\n \n-uptr user_alloc_usable_size(ThreadState *thr, uptr pc, void *p) {\n+uptr user_alloc_usable_size(const void *p) {\n   if (p == 0)\n     return 0;\n-  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n-  return b ? b->Size() : 0;\n-}\n-\n-MBlock *user_mblock(ThreadState *thr, void *p) {\n-  CHECK_NE(p, 0);\n-  Allocator *a = allocator();\n-  void *b = a->GetBlockBegin(p);\n-  if (b == 0)\n-    return 0;\n-  return (MBlock*)a->GetMetaData(b);\n+  MBlock *b = ctx->metamap.GetBlock((uptr)p);\n+  return b ? b->siz : 0;\n }\n \n void invoke_malloc_hook(void *ptr, uptr size) {\n   ThreadState *thr = cur_thread();\n   if (ctx == 0 || !ctx->initialized || thr->ignore_interceptors)\n     return;\n-  __tsan_malloc_hook(ptr, size);\n+  __sanitizer_malloc_hook(ptr, size);\n }\n \n void invoke_free_hook(void *ptr) {\n   ThreadState *thr = cur_thread();\n   if (ctx == 0 || !ctx->initialized || thr->ignore_interceptors)\n     return;\n-  __tsan_free_hook(ptr);\n+  __sanitizer_free_hook(ptr);\n }\n \n void *internal_alloc(MBlockType typ, uptr sz) {\n   ThreadState *thr = cur_thread();\n-  CHECK_LE(sz, InternalSizeClassMap::kMaxSize);\n   if (thr->nomalloc) {\n     thr->nomalloc = 0;  // CHECK calls internal_malloc().\n     CHECK(0);\n@@ -214,47 +172,42 @@ void internal_free(void *p) {\n using namespace __tsan;\n \n extern \"C\" {\n-uptr __tsan_get_current_allocated_bytes() {\n+uptr __sanitizer_get_current_allocated_bytes() {\n   uptr stats[AllocatorStatCount];\n   allocator()->GetStats(stats);\n   return stats[AllocatorStatAllocated];\n }\n \n-uptr __tsan_get_heap_size() {\n+uptr __sanitizer_get_heap_size() {\n   uptr stats[AllocatorStatCount];\n   allocator()->GetStats(stats);\n   return stats[AllocatorStatMapped];\n }\n \n-uptr __tsan_get_free_bytes() {\n+uptr __sanitizer_get_free_bytes() {\n   return 1;\n }\n \n-uptr __tsan_get_unmapped_bytes() {\n+uptr __sanitizer_get_unmapped_bytes() {\n   return 1;\n }\n \n-uptr __tsan_get_estimated_allocated_size(uptr size) {\n+uptr __sanitizer_get_estimated_allocated_size(uptr size) {\n   return size;\n }\n \n-bool __tsan_get_ownership(void *p) {\n+int __sanitizer_get_ownership(const void *p) {\n   return allocator()->GetBlockBegin(p) != 0;\n }\n \n-uptr __tsan_get_allocated_size(void *p) {\n-  if (p == 0)\n-    return 0;\n-  p = allocator()->GetBlockBegin(p);\n-  if (p == 0)\n-    return 0;\n-  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n-  return b->Size();\n+uptr __sanitizer_get_allocated_size(const void *p) {\n+  return user_alloc_usable_size(p);\n }\n \n void __tsan_on_thread_idle() {\n   ThreadState *thr = cur_thread();\n   allocator()->SwallowCache(&thr->alloc_cache);\n   internal_allocator()->SwallowCache(&thr->internal_alloc_cache);\n+  ctx->metamap.OnThreadIdle(thr);\n }\n }  // extern \"C\""}, {"sha": "ab8eb83f9194aba38e32ec48f8a94abc1ff3a6a9", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -29,10 +29,7 @@ void *user_alloc(ThreadState *thr, uptr pc, uptr sz,\n void user_free(ThreadState *thr, uptr pc, void *p);\n void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz);\n void *user_alloc_aligned(ThreadState *thr, uptr pc, uptr sz, uptr align);\n-uptr user_alloc_usable_size(ThreadState *thr, uptr pc, void *p);\n-// Given the pointer p into a valid allocated block,\n-// returns the descriptor of the block.\n-MBlock *user_mblock(ThreadState *thr, void *p);\n+uptr user_alloc_usable_size(const void *p);\n \n // Invoking malloc/free hooks that may be installed by the user.\n void invoke_malloc_hook(void *ptr, uptr size);\n@@ -60,7 +57,6 @@ enum MBlockType {\n   MBlockSuppression,\n   MBlockExpectRace,\n   MBlockSignal,\n-  MBlockFD,\n   MBlockJmpBuf,\n \n   // This must be the last."}, {"sha": "2e49b9d2de9d4b42b3cbc628a4face9f655e7635", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -29,13 +29,13 @@ static MutexType CanLockTab[MutexTypeCount][MutexTypeCount] = {\n   /*0  MutexTypeInvalid*/     {},\n   /*1  MutexTypeTrace*/       {MutexTypeLeaf},\n   /*2  MutexTypeThreads*/     {MutexTypeReport},\n-  /*3  MutexTypeReport*/      {MutexTypeSyncTab, MutexTypeSyncVar,\n+  /*3  MutexTypeReport*/      {MutexTypeSyncVar,\n                                MutexTypeMBlock, MutexTypeJavaMBlock},\n   /*4  MutexTypeSyncVar*/     {MutexTypeDDetector},\n-  /*5  MutexTypeSyncTab*/     {MutexTypeSyncVar},\n+  /*5  MutexTypeSyncTab*/     {},  // unused\n   /*6  MutexTypeSlab*/        {MutexTypeLeaf},\n   /*7  MutexTypeAnnotations*/ {},\n-  /*8  MutexTypeAtExit*/      {MutexTypeSyncTab},\n+  /*8  MutexTypeAtExit*/      {MutexTypeSyncVar},\n   /*9  MutexTypeMBlock*/      {MutexTypeSyncVar},\n   /*10 MutexTypeJavaMBlock*/  {MutexTypeSyncVar},\n   /*11 MutexTypeDDetector*/   {},\n@@ -159,7 +159,19 @@ void InternalDeadlockDetector::Unlock(MutexType t) {\n   CHECK(locked_[t]);\n   locked_[t] = 0;\n }\n+\n+void InternalDeadlockDetector::CheckNoLocks() {\n+  for (int i = 0; i != MutexTypeCount; i++) {\n+    CHECK_EQ(locked_[i], 0);\n+  }\n+}\n+#endif\n+\n+void CheckNoLocks(ThreadState *thr) {\n+#if TSAN_DEBUG && !TSAN_GO\n+  thr->internal_deadlock_detector.CheckNoLocks();\n #endif\n+}\n \n const uptr kUnlocked = 0;\n const uptr kWriteLock = 1;\n@@ -220,7 +232,7 @@ void Mutex::Lock() {\n       cmp = kUnlocked;\n       if (atomic_compare_exchange_weak(&state_, &cmp, kWriteLock,\n                                        memory_order_acquire)) {\n-#if TSAN_COLLECT_STATS\n+#if TSAN_COLLECT_STATS && !TSAN_GO\n         StatInc(cur_thread(), stat_type_, backoff.Contention());\n #endif\n         return;\n@@ -248,7 +260,7 @@ void Mutex::ReadLock() {\n   for (Backoff backoff; backoff.Do();) {\n     prev = atomic_load(&state_, memory_order_acquire);\n     if ((prev & kWriteLock) == 0) {\n-#if TSAN_COLLECT_STATS\n+#if TSAN_COLLECT_STATS && !TSAN_GO\n       StatInc(cur_thread(), stat_type_, backoff.Contention());\n #endif\n       return;"}, {"sha": "c27bc2b4459c24e99d4cbae5d675a1707efe42b0", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -69,13 +69,18 @@ class InternalDeadlockDetector {\n   InternalDeadlockDetector();\n   void Lock(MutexType t);\n   void Unlock(MutexType t);\n+  void CheckNoLocks();\n  private:\n   u64 seq_;\n   u64 locked_[MutexTypeCount];\n };\n \n void InitializeMutex();\n \n+// Checks that the current thread does not hold any runtime locks\n+// (e.g. when returning from an interceptor).\n+void CheckNoLocks(ThreadState *thr);\n+\n }  // namespace __tsan\n \n #endif  // TSAN_MUTEX_H"}, {"sha": "b7a6376e8ed05d4e443a2359fdba6e002b75e14c", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 29, "deletions": 44, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -14,31 +14,23 @@\n C++ linux memory layout:\n 0000 0000 0000 - 03c0 0000 0000: protected\n 03c0 0000 0000 - 1000 0000 0000: shadow\n-1000 0000 0000 - 6000 0000 0000: protected\n+1000 0000 0000 - 3000 0000 0000: protected\n+3000 0000 0000 - 4000 0000 0000: metainfo (memory blocks and sync objects)\n+4000 0000 0000 - 6000 0000 0000: protected\n 6000 0000 0000 - 6200 0000 0000: traces\n 6200 0000 0000 - 7d00 0000 0000: -\n 7d00 0000 0000 - 7e00 0000 0000: heap\n 7e00 0000 0000 - 7fff ffff ffff: modules and main thread stack\n \n-C++ COMPAT linux memory layout:\n-0000 0000 0000 - 0400 0000 0000: protected\n-0400 0000 0000 - 1000 0000 0000: shadow\n-1000 0000 0000 - 2900 0000 0000: protected\n-2900 0000 0000 - 2c00 0000 0000: modules\n-2c00 0000 0000 - 6000 0000 0000: -\n-6000 0000 0000 - 6200 0000 0000: traces\n-6200 0000 0000 - 7d00 0000 0000: -\n-7d00 0000 0000 - 7e00 0000 0000: heap\n-7e00 0000 0000 - 7f00 0000 0000: -\n-7f00 0000 0000 - 7fff ffff ffff: main thread stack\n-\n Go linux and darwin memory layout:\n 0000 0000 0000 - 0000 1000 0000: executable\n 0000 1000 0000 - 00f8 0000 0000: -\n 00c0 0000 0000 - 00e0 0000 0000: heap\n 00e0 0000 0000 - 1000 0000 0000: -\n 1000 0000 0000 - 1380 0000 0000: shadow\n-1460 0000 0000 - 6000 0000 0000: -\n+1460 0000 0000 - 2000 0000 0000: -\n+3000 0000 0000 - 4000 0000 0000: metainfo (memory blocks and sync objects)\n+4000 0000 0000 - 6000 0000 0000: -\n 6000 0000 0000 - 6200 0000 0000: traces\n 6200 0000 0000 - 7fff ffff ffff: -\n \n@@ -49,7 +41,8 @@ Go windows memory layout:\n 00e0 0000 0000 - 0100 0000 0000: -\n 0100 0000 0000 - 0560 0000 0000: shadow\n 0560 0000 0000 - 0760 0000 0000: traces\n-0760 0000 0000 - 07ff ffff ffff: -\n+0760 0000 0000 - 07d0 0000 0000: metainfo (memory blocks and sync objects)\n+07d0 0000 0000 - 07ff ffff ffff: -\n */\n \n #ifndef TSAN_PLATFORM_H\n@@ -66,18 +59,16 @@ static const uptr kLinuxAppMemBeg = 0x000000000000ULL;\n static const uptr kLinuxAppMemEnd = 0x04dfffffffffULL;\n # if SANITIZER_WINDOWS\n static const uptr kLinuxShadowMsk = 0x010000000000ULL;\n-# else\n+static const uptr kMetaShadow     = 0x076000000000ULL;\n+static const uptr kMetaSize       = 0x007000000000ULL;\n+# else  // if SANITIZER_WINDOWS\n static const uptr kLinuxShadowMsk = 0x200000000000ULL;\n-# endif\n-// TSAN_COMPAT_SHADOW is intended for COMPAT virtual memory layout,\n-// when memory addresses are of the 0x2axxxxxxxxxx form.\n-// The option is enabled with 'setarch x86_64 -L'.\n-#elif defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n-static const uptr kLinuxAppMemBeg = 0x290000000000ULL;\n-static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n-static const uptr kAppMemGapBeg   = 0x2c0000000000ULL;\n-static const uptr kAppMemGapEnd   = 0x7d0000000000ULL;\n-#else\n+static const uptr kMetaShadow     = 0x300000000000ULL;\n+static const uptr kMetaSize       = 0x100000000000ULL;\n+# endif  // if SANITIZER_WINDOWS\n+#else  // defined(TSAN_GO)\n+static const uptr kMetaShadow     = 0x300000000000ULL;\n+static const uptr kMetaSize       = 0x100000000000ULL;\n static const uptr kLinuxAppMemBeg = 0x7cf000000000ULL;\n static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n #endif\n@@ -94,20 +85,25 @@ const uptr kTraceMemSize = 0x020000000000ULL;\n // This has to be a macro to allow constant initialization of constants below.\n #ifndef TSAN_GO\n #define MemToShadow(addr) \\\n-    (((addr) & ~(kLinuxAppMemMsk | (kShadowCell - 1))) * kShadowCnt)\n+    ((((uptr)addr) & ~(kLinuxAppMemMsk | (kShadowCell - 1))) * kShadowCnt)\n+#define MemToMeta(addr) \\\n+    (u32*)(((((uptr)addr) & ~(kLinuxAppMemMsk | (kMetaShadowCell - 1))) \\\n+    / kMetaShadowCell * kMetaShadowSize) | kMetaShadow)\n #else\n #define MemToShadow(addr) \\\n-    ((((addr) & ~(kShadowCell - 1)) * kShadowCnt) | kLinuxShadowMsk)\n+    (((((uptr)addr) & ~(kShadowCell - 1)) * kShadowCnt) | kLinuxShadowMsk)\n+#define MemToMeta(addr) \\\n+    (u32*)(((((uptr)addr) & ~(kMetaShadowCell - 1)) \\\n+    / kMetaShadowCell * kMetaShadowSize) | kMetaShadow)\n #endif\n \n static const uptr kLinuxShadowBeg = MemToShadow(kLinuxAppMemBeg);\n static const uptr kLinuxShadowEnd =\n     MemToShadow(kLinuxAppMemEnd) | 0xff;\n \n static inline bool IsAppMem(uptr mem) {\n-#if defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n-  return (mem >= kLinuxAppMemBeg && mem < kAppMemGapBeg) ||\n-         (mem >= kAppMemGapEnd   && mem <= kLinuxAppMemEnd);\n+#if defined(TSAN_GO)\n+  return mem <= kLinuxAppMemEnd;\n #else\n   return mem >= kLinuxAppMemBeg && mem <= kLinuxAppMemEnd;\n #endif\n@@ -126,22 +122,11 @@ static inline uptr ShadowToMem(uptr shadow) {\n #endif\n }\n \n-// For COMPAT mapping returns an alternative address\n-// that mapped to the same shadow address.\n-// COMPAT mapping is not quite one-to-one.\n-static inline uptr AlternativeAddress(uptr addr) {\n-#if defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n-  return (addr & ~kLinuxAppMemMsk) | 0x280000000000ULL;\n-#else\n-  return 0;\n-#endif\n-}\n-\n void FlushShadowMemory();\n-void WriteMemoryProfile(char *buf, uptr buf_size);\n+void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive);\n uptr GetRSS();\n \n-const char *InitializePlatform();\n+void InitializePlatform();\n void FinalizePlatform();\n \n // The additional page is to catch shadow stack overflow as paging fault."}, {"sha": "ba81fd242e34970b19facbecaea3612f32f1da9e", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 122, "deletions": 68, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,7 +12,7 @@\n \n \n #include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD\n \n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n@@ -30,7 +30,6 @@\n #include <string.h>\n #include <stdarg.h>\n #include <sys/mman.h>\n-#include <sys/prctl.h>\n #include <sys/syscall.h>\n #include <sys/socket.h>\n #include <sys/time.h>\n@@ -41,9 +40,10 @@\n #include <errno.h>\n #include <sched.h>\n #include <dlfcn.h>\n+#if SANITIZER_LINUX\n #define __need_res_state\n #include <resolv.h>\n-#include <malloc.h>\n+#endif\n \n #ifdef sa_handler\n # undef sa_handler\n@@ -53,61 +53,98 @@\n # undef sa_sigaction\n #endif\n \n-extern \"C\" struct mallinfo __libc_mallinfo();\n+#if SANITIZER_FREEBSD\n+extern \"C\" void *__libc_stack_end;\n+void *__libc_stack_end = 0;\n+#endif\n \n namespace __tsan {\n \n const uptr kPageSize = 4096;\n \n+enum {\n+  MemTotal  = 0,\n+  MemShadow = 1,\n+  MemMeta   = 2,\n+  MemFile   = 3,\n+  MemMmap   = 4,\n+  MemTrace  = 5,\n+  MemHeap   = 6,\n+  MemOther  = 7,\n+  MemCount  = 8,\n+};\n+\n void FillProfileCallback(uptr start, uptr rss, bool file,\n                          uptr *mem, uptr stats_size) {\n-  CHECK_EQ(7, stats_size);\n-  mem[6] += rss;  // total\n+  mem[MemTotal] += rss;\n   start >>= 40;\n-  if (start < 0x10)  // shadow\n-    mem[0] += rss;\n-  else if (start >= 0x20 && start < 0x30)  // compat modules\n-    mem[file ? 1 : 2] += rss;\n-  else if (start >= 0x7e)  // modules\n-    mem[file ? 1 : 2] += rss;\n-  else if (start >= 0x60 && start < 0x62)  // traces\n-    mem[3] += rss;\n-  else if (start >= 0x7d && start < 0x7e)  // heap\n-    mem[4] += rss;\n-  else  // other\n-    mem[5] += rss;\n+  if (start < 0x10)\n+    mem[MemShadow] += rss;\n+  else if (start >= 0x20 && start < 0x30)\n+    mem[file ? MemFile : MemMmap] += rss;\n+  else if (start >= 0x30 && start < 0x40)\n+    mem[MemMeta] += rss;\n+  else if (start >= 0x7e)\n+    mem[file ? MemFile : MemMmap] += rss;\n+  else if (start >= 0x60 && start < 0x62)\n+    mem[MemTrace] += rss;\n+  else if (start >= 0x7d && start < 0x7e)\n+    mem[MemHeap] += rss;\n+  else\n+    mem[MemOther] += rss;\n }\n \n-void WriteMemoryProfile(char *buf, uptr buf_size) {\n-  uptr mem[7] = {};\n+void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {\n+  uptr mem[MemCount] = {};\n   __sanitizer::GetMemoryProfile(FillProfileCallback, mem, 7);\n-  char *buf_pos = buf;\n-  char *buf_end = buf + buf_size;\n-  buf_pos += internal_snprintf(buf_pos, buf_end - buf_pos,\n-      \"RSS %zd MB: shadow:%zd file:%zd mmap:%zd trace:%zd heap:%zd other:%zd\\n\",\n-      mem[6] >> 20, mem[0] >> 20, mem[1] >> 20, mem[2] >> 20,\n-      mem[3] >> 20, mem[4] >> 20, mem[5] >> 20);\n-  struct mallinfo mi = __libc_mallinfo();\n-  buf_pos += internal_snprintf(buf_pos, buf_end - buf_pos,\n-      \"mallinfo: arena=%d mmap=%d fordblks=%d keepcost=%d\\n\",\n-      mi.arena >> 20, mi.hblkhd >> 20, mi.fordblks >> 20, mi.keepcost >> 20);\n+  internal_snprintf(buf, buf_size,\n+      \"RSS %zd MB: shadow:%zd meta:%zd file:%zd mmap:%zd\"\n+      \" trace:%zd heap:%zd other:%zd nthr=%zd/%zd\\n\",\n+      mem[MemTotal] >> 20, mem[MemShadow] >> 20, mem[MemMeta] >> 20,\n+      mem[MemFile] >> 20, mem[MemMmap] >> 20, mem[MemTrace] >> 20,\n+      mem[MemHeap] >> 20, mem[MemOther] >> 20,\n+      nlive, nthread);\n }\n \n uptr GetRSS() {\n-  uptr mem[7] = {};\n-  __sanitizer::GetMemoryProfile(FillProfileCallback, mem, 7);\n-  return mem[6];\n+  uptr fd = OpenFile(\"/proc/self/statm\", false);\n+  if ((sptr)fd < 0)\n+    return 0;\n+  char buf[64];\n+  uptr len = internal_read(fd, buf, sizeof(buf) - 1);\n+  internal_close(fd);\n+  if ((sptr)len <= 0)\n+    return 0;\n+  buf[len] = 0;\n+  // The format of the file is:\n+  // 1084 89 69 11 0 79 0\n+  // We need the second number which is RSS in 4K units.\n+  char *pos = buf;\n+  // Skip the first number.\n+  while (*pos >= '0' && *pos <= '9')\n+    pos++;\n+  // Skip whitespaces.\n+  while (!(*pos >= '0' && *pos <= '9') && *pos != 0)\n+    pos++;\n+  // Read the number.\n+  uptr rss = 0;\n+  while (*pos >= '0' && *pos <= '9')\n+    rss = rss * 10 + *pos++ - '0';\n+  return rss * 4096;\n }\n \n-\n+#if SANITIZER_LINUX\n void FlushShadowMemoryCallback(\n     const SuspendedThreadsList &suspended_threads_list,\n     void *argument) {\n   FlushUnneededShadowMemory(kLinuxShadowBeg, kLinuxShadowEnd - kLinuxShadowBeg);\n }\n+#endif\n \n void FlushShadowMemory() {\n+#if SANITIZER_LINUX\n   StopTheWorld(FlushShadowMemoryCallback, 0);\n+#endif\n }\n \n #ifndef TSAN_GO\n@@ -121,9 +158,7 @@ static void ProtectRange(uptr beg, uptr end) {\n     Die();\n   }\n }\n-#endif\n \n-#ifndef TSAN_GO\n // Mark shadow for .rodata sections with the special kShadowRodata marker.\n // Accesses to .rodata can't race, so this saves time, memory and trace space.\n static void MapRodata() {\n@@ -182,6 +217,7 @@ static void MapRodata() {\n }\n \n void InitializeShadowMemory() {\n+  // Map memory shadow.\n   uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n     kLinuxShadowEnd - kLinuxShadowBeg);\n   if (shadow != kLinuxShadowBeg) {\n@@ -190,23 +226,56 @@ void InitializeShadowMemory() {\n                \"to link with -pie (%p, %p).\\n\", shadow, kLinuxShadowBeg);\n     Die();\n   }\n+  // This memory range is used for thread stacks and large user mmaps.\n+  // Frequently a thread uses only a small part of stack and similarly\n+  // a program uses a small part of large mmap. On some programs\n+  // we see 20% memory usage reduction without huge pages for this range.\n+#ifdef MADV_NOHUGEPAGE\n+  madvise((void*)MemToShadow(0x7f0000000000ULL),\n+      0x10000000000ULL * kShadowMultiplier, MADV_NOHUGEPAGE);\n+#endif\n+  DPrintf(\"memory shadow: %zx-%zx (%zuGB)\\n\",\n+      kLinuxShadowBeg, kLinuxShadowEnd,\n+      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n+\n+  // Map meta shadow.\n+  if (MemToMeta(kLinuxAppMemBeg) < (u32*)kMetaShadow) {\n+    Printf(\"ThreadSanitizer: bad meta shadow (%p -> %p < %p)\\n\",\n+        kLinuxAppMemBeg, MemToMeta(kLinuxAppMemBeg), kMetaShadow);\n+    Die();\n+  }\n+  if (MemToMeta(kLinuxAppMemEnd) >= (u32*)(kMetaShadow + kMetaSize)) {\n+    Printf(\"ThreadSanitizer: bad meta shadow (%p -> %p >= %p)\\n\",\n+        kLinuxAppMemEnd, MemToMeta(kLinuxAppMemEnd), kMetaShadow + kMetaSize);\n+    Die();\n+  }\n+  uptr meta = (uptr)MmapFixedNoReserve(kMetaShadow, kMetaSize);\n+  if (meta != kMetaShadow) {\n+    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n+               \"to link with -pie (%p, %p).\\n\", meta, kMetaShadow);\n+    Die();\n+  }\n+  DPrintf(\"meta shadow: %zx-%zx (%zuGB)\\n\",\n+      kMetaShadow, kMetaShadow + kMetaSize, kMetaSize >> 30);\n+\n+  // Protect gaps.\n   const uptr kClosedLowBeg  = 0x200000;\n   const uptr kClosedLowEnd  = kLinuxShadowBeg - 1;\n   const uptr kClosedMidBeg = kLinuxShadowEnd + 1;\n-  const uptr kClosedMidEnd = min(kLinuxAppMemBeg, kTraceMemBegin);\n+  const uptr kClosedMidEnd = min(min(kLinuxAppMemBeg, kTraceMemBegin),\n+      kMetaShadow);\n+\n   ProtectRange(kClosedLowBeg, kClosedLowEnd);\n   ProtectRange(kClosedMidBeg, kClosedMidEnd);\n-  DPrintf(\"kClosedLow   %zx-%zx (%zuGB)\\n\",\n+  VPrintf(2, \"kClosedLow   %zx-%zx (%zuGB)\\n\",\n       kClosedLowBeg, kClosedLowEnd, (kClosedLowEnd - kClosedLowBeg) >> 30);\n-  DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n-      kLinuxShadowBeg, kLinuxShadowEnd,\n-      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n-  DPrintf(\"kClosedMid   %zx-%zx (%zuGB)\\n\",\n+  VPrintf(2, \"kClosedMid   %zx-%zx (%zuGB)\\n\",\n       kClosedMidBeg, kClosedMidEnd, (kClosedMidEnd - kClosedMidBeg) >> 30);\n-  DPrintf(\"kLinuxAppMem %zx-%zx (%zuGB)\\n\",\n+  VPrintf(2, \"app mem: %zx-%zx (%zuGB)\\n\",\n       kLinuxAppMemBeg, kLinuxAppMemEnd,\n       (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n-  DPrintf(\"stack        %zx\\n\", (uptr)&shadow);\n+  VPrintf(2, \"stack: %zx\\n\", (uptr)&shadow);\n \n   MapRodata();\n }\n@@ -261,26 +330,8 @@ static void InitDataSeg() {\n \n #endif  // #ifndef TSAN_GO\n \n-static rlim_t getlim(int res) {\n-  rlimit rlim;\n-  CHECK_EQ(0, getrlimit(res, &rlim));\n-  return rlim.rlim_cur;\n-}\n-\n-static void setlim(int res, rlim_t lim) {\n-  // The following magic is to prevent clang from replacing it with memset.\n-  volatile rlimit rlim;\n-  rlim.rlim_cur = lim;\n-  rlim.rlim_max = lim;\n-  setrlimit(res, (rlimit*)&rlim);\n-}\n-\n-const char *InitializePlatform() {\n-  void *p = 0;\n-  if (sizeof(p) == 8) {\n-    // Disable core dumps, dumping of 16TB usually takes a bit long.\n-    setlim(RLIMIT_CORE, 0);\n-  }\n+void InitializePlatform() {\n+  DisableCoreDumperIfNecessary();\n \n   // Go maps shadow memory lazily and works fine with limited address space.\n   // Unlimited stack is not a problem as well, because the executable\n@@ -290,7 +341,7 @@ const char *InitializePlatform() {\n     // TSan doesn't play well with unlimited stack size (as stack\n     // overlaps with shadow memory). If we detect unlimited stack size,\n     // we re-exec the program with limited stack size as a best effort.\n-    if (getlim(RLIMIT_STACK) == (rlim_t)-1) {\n+    if (StackSizeIsUnlimited()) {\n       const uptr kMaxStackSize = 32 * 1024 * 1024;\n       VReport(1, \"Program is run with unlimited stack size, which wouldn't \"\n                  \"work with ThreadSanitizer.\\n\"\n@@ -300,11 +351,11 @@ const char *InitializePlatform() {\n       reexec = true;\n     }\n \n-    if (getlim(RLIMIT_AS) != (rlim_t)-1) {\n+    if (!AddressSpaceIsUnlimited()) {\n       Report(\"WARNING: Program is run with limited virtual address space,\"\n              \" which wouldn't work with ThreadSanitizer.\\n\");\n       Report(\"Re-execing with unlimited virtual address space.\\n\");\n-      setlim(RLIMIT_AS, -1);\n+      SetAddressSpaceUnlimited();\n       reexec = true;\n     }\n     if (reexec)\n@@ -316,7 +367,6 @@ const char *InitializePlatform() {\n   InitTlsSize();\n   InitDataSeg();\n #endif\n-  return GetEnv(kTsanOptionsEnv);\n }\n \n bool IsGlobalVar(uptr addr) {\n@@ -328,13 +378,17 @@ bool IsGlobalVar(uptr addr) {\n // This is required to properly \"close\" the fds, because we do not see internal\n // closes within glibc. The code is a pure hack.\n int ExtractResolvFDs(void *state, int *fds, int nfd) {\n+#if SANITIZER_LINUX\n   int cnt = 0;\n   __res_state *statp = (__res_state*)state;\n   for (int i = 0; i < MAXNS && cnt < nfd; i++) {\n     if (statp->_u._ext.nsaddrs[i] && statp->_u._ext.nssocks[i] != -1)\n       fds[cnt++] = statp->_u._ext.nssocks[i];\n   }\n   return cnt;\n+#else\n+  return 0;\n+#endif\n }\n \n // Extract file descriptors passed via UNIX domain sockets."}, {"sha": "95527c794318ce472ef8765808f50ff59c3a86bc", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -45,7 +45,7 @@ uptr GetShadowMemoryConsumption() {\n void FlushShadowMemory() {\n }\n \n-void WriteMemoryProfile(char *buf, uptr buf_size) {\n+void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {\n }\n \n uptr GetRSS() {\n@@ -71,18 +71,8 @@ void InitializeShadowMemory() {\n }\n #endif\n \n-const char *InitializePlatform() {\n-  void *p = 0;\n-  if (sizeof(p) == 8) {\n-    // Disable core dumps, dumping of 16TB usually takes a bit long.\n-    // The following magic is to prevent clang from replacing it with memset.\n-    volatile rlimit lim;\n-    lim.rlim_cur = 0;\n-    lim.rlim_max = 0;\n-    setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n-  }\n-\n-  return GetEnv(kTsanOptionsEnv);\n+void InitializePlatform() {\n+  DisableCoreDumperIfNecessary();\n }\n \n void FinalizePlatform() {"}, {"sha": "d6e9e6d33f45ba807ab50772a19540312dce3aaa", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -26,15 +26,14 @@ uptr GetShadowMemoryConsumption() {\n void FlushShadowMemory() {\n }\n \n-void WriteMemoryProfile(char *buf, uptr buf_size) {\n+void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {\n }\n \n uptr GetRSS() {\n   return 0;\n }\n \n-const char *InitializePlatform() {\n-  return GetEnv(kTsanOptionsEnv);\n+void InitializePlatform() {\n }\n \n void FinalizePlatform() {"}, {"sha": "b14856cd153e71eb03d34aa5e21d0fb17bcf587c", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -15,9 +15,9 @@\n \n namespace __tsan {\n \n-class Decorator: private __sanitizer::AnsiColorDecorator {\n+class Decorator: public __sanitizer::SanitizerCommonDecorator {\n  public:\n-  Decorator() : __sanitizer::AnsiColorDecorator(PrintsToTtyCached()) { }\n+  Decorator() : SanitizerCommonDecorator() { }\n   const char *Warning()    { return Red(); }\n   const char *EndWarning() { return Default(); }\n   const char *Access()     { return Blue(); }"}, {"sha": "0bde59b16754eb650c05a06d0bc9a1530530db4f", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -40,6 +40,7 @@ struct ReportStack {\n   char *file;\n   int line;\n   int col;\n+  bool suppressable;\n };\n \n struct ReportMopMutex {\n@@ -78,6 +79,7 @@ struct ReportLocation {\n   char *name;\n   char *file;\n   int line;\n+  bool suppressable;\n   ReportStack *stack;\n };\n "}, {"sha": "f5942bcaa3ed024c3fafa659b9dc6c9a746a0d09", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 230, "deletions": 68, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -23,6 +23,16 @@\n #include \"tsan_suppressions.h\"\n #include \"tsan_symbolize.h\"\n \n+#ifdef __SSE3__\n+// <emmintrin.h> transitively includes <stdlib.h>,\n+// and it's prohibited to include std headers into tsan runtime.\n+// So we do this dirty trick.\n+#define _MM_MALLOC_H_INCLUDED\n+#define __MM_MALLOC_H\n+#include <emmintrin.h>\n+typedef __m128i m128;\n+#endif\n+\n volatile int __tsan_resumed = 0;\n \n extern \"C\" void __tsan_resume() {\n@@ -110,10 +120,7 @@ static void MemoryProfiler(Context *ctx, fd_t fd, int i) {\n   uptr n_running_threads;\n   ctx->thread_registry->GetNumberOfThreads(&n_threads, &n_running_threads);\n   InternalScopedBuffer<char> buf(4096);\n-  internal_snprintf(buf.data(), buf.size(), \"%d: nthr=%d nlive=%d\\n\",\n-      i, n_threads, n_running_threads);\n-  internal_write(fd, buf.data(), internal_strlen(buf.data()));\n-  WriteMemoryProfile(buf.data(), buf.size());\n+  WriteMemoryProfile(buf.data(), buf.size(), n_threads, n_running_threads);\n   internal_write(fd, buf.data(), internal_strlen(buf.data()));\n }\n \n@@ -129,15 +136,21 @@ static void BackgroundThread(void *arg) {\n \n   fd_t mprof_fd = kInvalidFd;\n   if (flags()->profile_memory && flags()->profile_memory[0]) {\n-    InternalScopedBuffer<char> filename(4096);\n-    internal_snprintf(filename.data(), filename.size(), \"%s.%d\",\n-        flags()->profile_memory, (int)internal_getpid());\n-    uptr openrv = OpenFile(filename.data(), true);\n-    if (internal_iserror(openrv)) {\n-      Printf(\"ThreadSanitizer: failed to open memory profile file '%s'\\n\",\n-          &filename[0]);\n+    if (internal_strcmp(flags()->profile_memory, \"stdout\") == 0) {\n+      mprof_fd = 1;\n+    } else if (internal_strcmp(flags()->profile_memory, \"stderr\") == 0) {\n+      mprof_fd = 2;\n     } else {\n-      mprof_fd = openrv;\n+      InternalScopedBuffer<char> filename(4096);\n+      internal_snprintf(filename.data(), filename.size(), \"%s.%d\",\n+          flags()->profile_memory, (int)internal_getpid());\n+      uptr openrv = OpenFile(filename.data(), true);\n+      if (internal_iserror(openrv)) {\n+        Printf(\"ThreadSanitizer: failed to open memory profile file '%s'\\n\",\n+            &filename[0]);\n+      } else {\n+        mprof_fd = openrv;\n+      }\n     }\n   }\n \n@@ -152,27 +165,23 @@ static void BackgroundThread(void *arg) {\n     // Flush memory if requested.\n     if (flags()->flush_memory_ms > 0) {\n       if (last_flush + flags()->flush_memory_ms * kMs2Ns < now) {\n-        if (flags()->verbosity > 0)\n-          Printf(\"ThreadSanitizer: periodic memory flush\\n\");\n+        VPrintf(1, \"ThreadSanitizer: periodic memory flush\\n\");\n         FlushShadowMemory();\n         last_flush = NanoTime();\n       }\n     }\n+    // GetRSS can be expensive on huge programs, so don't do it every 100ms.\n     if (flags()->memory_limit_mb > 0) {\n       uptr rss = GetRSS();\n       uptr limit = uptr(flags()->memory_limit_mb) << 20;\n-      if (flags()->verbosity > 0) {\n-        Printf(\"ThreadSanitizer: memory flush check\"\n-               \" RSS=%llu LAST=%llu LIMIT=%llu\\n\",\n-               (u64)rss>>20, (u64)last_rss>>20, (u64)limit>>20);\n-      }\n+      VPrintf(1, \"ThreadSanitizer: memory flush check\"\n+                 \" RSS=%llu LAST=%llu LIMIT=%llu\\n\",\n+              (u64)rss >> 20, (u64)last_rss >> 20, (u64)limit >> 20);\n       if (2 * rss > limit + last_rss) {\n-        if (flags()->verbosity > 0)\n-          Printf(\"ThreadSanitizer: flushing memory due to RSS\\n\");\n+        VPrintf(1, \"ThreadSanitizer: flushing memory due to RSS\\n\");\n         FlushShadowMemory();\n         rss = GetRSS();\n-        if (flags()->verbosity > 0)\n-          Printf(\"ThreadSanitizer: memory flushed RSS=%llu\\n\", (u64)rss>>20);\n+        VPrintf(1, \"ThreadSanitizer: memory flushed RSS=%llu\\n\", (u64)rss>>20);\n       }\n       last_rss = rss;\n     }\n@@ -201,11 +210,13 @@ static void StartBackgroundThread() {\n   ctx->background_thread = internal_start_thread(&BackgroundThread, 0);\n }\n \n+#ifndef TSAN_GO\n static void StopBackgroundThread() {\n   atomic_store(&ctx->stop_background_thread, 1, memory_order_relaxed);\n   internal_join_thread(ctx->background_thread);\n   ctx->background_thread = 0;\n }\n+#endif\n \n void DontNeedShadowFor(uptr addr, uptr size) {\n   uptr shadow_beg = MemToShadow(addr);\n@@ -218,6 +229,32 @@ void MapShadow(uptr addr, uptr size) {\n   // so we can get away with unaligned mapping.\n   // CHECK_EQ(addr, addr & ~((64 << 10) - 1));  // windows wants 64K alignment\n   MmapFixedNoReserve(MemToShadow(addr), size * kShadowMultiplier);\n+\n+  // Meta shadow is 2:1, so tread carefully.\n+  static bool data_mapped = false;\n+  static uptr mapped_meta_end = 0;\n+  uptr meta_begin = (uptr)MemToMeta(addr);\n+  uptr meta_end = (uptr)MemToMeta(addr + size);\n+  meta_begin = RoundDownTo(meta_begin, 64 << 10);\n+  meta_end = RoundUpTo(meta_end, 64 << 10);\n+  if (!data_mapped) {\n+    // First call maps data+bss.\n+    data_mapped = true;\n+    MmapFixedNoReserve(meta_begin, meta_end - meta_begin);\n+  } else {\n+    // Mapping continous heap.\n+    // Windows wants 64K alignment.\n+    meta_begin = RoundDownTo(meta_begin, 64 << 10);\n+    meta_end = RoundUpTo(meta_end, 64 << 10);\n+    if (meta_end <= mapped_meta_end)\n+      return;\n+    if (meta_begin < mapped_meta_end)\n+      meta_begin = mapped_meta_end;\n+    MmapFixedNoReserve(meta_begin, meta_end - meta_begin);\n+    mapped_meta_end = meta_end;\n+  }\n+  VPrintf(2, \"mapped meta shadow for (%p-%p) at (%p-%p)\\n\",\n+      addr, addr+size, meta_begin, meta_end);\n }\n \n void MapThreadTrace(uptr addr, uptr size) {\n@@ -245,34 +282,35 @@ void Initialize(ThreadState *thr) {\n   // Install tool-specific callbacks in sanitizer_common.\n   SetCheckFailedCallback(TsanCheckFailed);\n \n+  ctx = new(ctx_placeholder) Context;\n+  const char *options = GetEnv(kTsanOptionsEnv);\n+  InitializeFlags(&ctx->flags, options);\n #ifndef TSAN_GO\n   InitializeAllocator();\n #endif\n   InitializeInterceptors();\n-  const char *env = InitializePlatform();\n+  InitializePlatform();\n   InitializeMutex();\n   InitializeDynamicAnnotations();\n-  ctx = new(ctx_placeholder) Context;\n #ifndef TSAN_GO\n   InitializeShadowMemory();\n #endif\n-  InitializeFlags(&ctx->flags, env);\n   // Setup correct file descriptor for error reports.\n-  __sanitizer_set_report_path(flags()->log_path);\n+  __sanitizer_set_report_path(common_flags()->log_path);\n   InitializeSuppressions();\n #ifndef TSAN_GO\n   InitializeLibIgnore();\n-  Symbolizer::Init(common_flags()->external_symbolizer_path);\n-  Symbolizer::Get()->AddHooks(EnterSymbolizer, ExitSymbolizer);\n+  Symbolizer::GetOrInit()->AddHooks(EnterSymbolizer, ExitSymbolizer);\n #endif\n   StartBackgroundThread();\n+#ifndef TSAN_GO\n   SetSandboxingCallback(StopBackgroundThread);\n-  if (flags()->detect_deadlocks)\n+#endif\n+  if (common_flags()->detect_deadlocks)\n     ctx->dd = DDetector::Create(flags());\n \n-  if (ctx->flags.verbosity)\n-    Printf(\"***** Running under ThreadSanitizer v2 (pid %d) *****\\n\",\n-           (int)internal_getpid());\n+  VPrintf(1, \"***** Running under ThreadSanitizer v2 (pid %d) *****\\n\",\n+          (int)internal_getpid());\n \n   // Initialize thread 0.\n   int tid = ThreadCreate(thr, 0, 0, true);\n@@ -291,7 +329,6 @@ void Initialize(ThreadState *thr) {\n }\n \n int Finalize(ThreadState *thr) {\n-  Context *ctx = __tsan::ctx;\n   bool failed = false;\n \n   if (flags()->atexit_sleep_ms > 0 && ThreadCount(thr) > 1)\n@@ -304,7 +341,7 @@ int Finalize(ThreadState *thr) {\n   ctx->report_mtx.Unlock();\n \n #ifndef TSAN_GO\n-  if (ctx->flags.verbosity)\n+  if (common_flags()->verbosity)\n     AllocatorPrintStats();\n #endif\n \n@@ -325,7 +362,7 @@ int Finalize(ThreadState *thr) {\n         ctx->nmissed_expected);\n   }\n \n-  if (flags()->print_suppressions)\n+  if (common_flags()->print_suppressions)\n     PrintMatchedSuppressions();\n #ifndef TSAN_GO\n   if (flags()->print_benign)\n@@ -372,16 +409,37 @@ void ForkChildAfter(ThreadState *thr, uptr pc) {\n }\n #endif\n \n+#ifdef TSAN_GO\n+NOINLINE\n+void GrowShadowStack(ThreadState *thr) {\n+  const int sz = thr->shadow_stack_end - thr->shadow_stack;\n+  const int newsz = 2 * sz;\n+  uptr *newstack = (uptr*)internal_alloc(MBlockShadowStack,\n+      newsz * sizeof(uptr));\n+  internal_memcpy(newstack, thr->shadow_stack, sz * sizeof(uptr));\n+  internal_free(thr->shadow_stack);\n+  thr->shadow_stack = newstack;\n+  thr->shadow_stack_pos = newstack + sz;\n+  thr->shadow_stack_end = newstack + newsz;\n+}\n+#endif\n+\n u32 CurrentStackId(ThreadState *thr, uptr pc) {\n   if (thr->shadow_stack_pos == 0)  // May happen during bootstrap.\n     return 0;\n-  if (pc) {\n+  if (pc != 0) {\n+#ifndef TSAN_GO\n+    DCHECK_LT(thr->shadow_stack_pos, thr->shadow_stack_end);\n+#else\n+    if (thr->shadow_stack_pos == thr->shadow_stack_end)\n+      GrowShadowStack(thr);\n+#endif\n     thr->shadow_stack_pos[0] = pc;\n     thr->shadow_stack_pos++;\n   }\n   u32 id = StackDepotPut(thr->shadow_stack,\n                          thr->shadow_stack_pos - thr->shadow_stack);\n-  if (pc)\n+  if (pc != 0)\n     thr->shadow_stack_pos--;\n   return id;\n }\n@@ -443,7 +501,8 @@ void StoreIfNotYetStored(u64 *sp, u64 *s) {\n   *s = 0;\n }\n \n-static inline void HandleRace(ThreadState *thr, u64 *shadow_mem,\n+ALWAYS_INLINE\n+void HandleRace(ThreadState *thr, u64 *shadow_mem,\n                               Shadow cur, Shadow old) {\n   thr->racy_state[0] = cur.raw();\n   thr->racy_state[1] = old.raw();\n@@ -455,16 +514,12 @@ static inline void HandleRace(ThreadState *thr, u64 *shadow_mem,\n #endif\n }\n \n-static inline bool OldIsInSameSynchEpoch(Shadow old, ThreadState *thr) {\n-  return old.epoch() >= thr->fast_synch_epoch;\n-}\n-\n static inline bool HappensBefore(Shadow old, ThreadState *thr) {\n   return thr->clock.get(old.TidWithIgnore()) >= old.epoch();\n }\n \n-ALWAYS_INLINE USED\n-void MemoryAccessImpl(ThreadState *thr, uptr addr,\n+ALWAYS_INLINE\n+void MemoryAccessImpl1(ThreadState *thr, uptr addr,\n     int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic,\n     u64 *shadow_mem, Shadow cur) {\n   StatInc(thr, StatMop);\n@@ -542,13 +597,13 @@ void UnalignedMemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   while (size) {\n     int size1 = 1;\n     int kAccessSizeLog = kSizeLog1;\n-    if (size >= 8 && (addr & ~7) == ((addr + 8) & ~7)) {\n+    if (size >= 8 && (addr & ~7) == ((addr + 7) & ~7)) {\n       size1 = 8;\n       kAccessSizeLog = kSizeLog8;\n-    } else if (size >= 4 && (addr & ~7) == ((addr + 4) & ~7)) {\n+    } else if (size >= 4 && (addr & ~7) == ((addr + 3) & ~7)) {\n       size1 = 4;\n       kAccessSizeLog = kSizeLog4;\n-    } else if (size >= 2 && (addr & ~7) == ((addr + 2) & ~7)) {\n+    } else if (size >= 2 && (addr & ~7) == ((addr + 1) & ~7)) {\n       size1 = 2;\n       kAccessSizeLog = kSizeLog2;\n     }\n@@ -558,6 +613,90 @@ void UnalignedMemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   }\n }\n \n+ALWAYS_INLINE\n+bool ContainsSameAccessSlow(u64 *s, u64 a, u64 sync_epoch, bool is_write) {\n+  Shadow cur(a);\n+  for (uptr i = 0; i < kShadowCnt; i++) {\n+    Shadow old(LoadShadow(&s[i]));\n+    if (Shadow::Addr0AndSizeAreEqual(cur, old) &&\n+        old.TidWithIgnore() == cur.TidWithIgnore() &&\n+        old.epoch() > sync_epoch &&\n+        old.IsAtomic() == cur.IsAtomic() &&\n+        old.IsRead() <= cur.IsRead())\n+      return true;\n+  }\n+  return false;\n+}\n+\n+#if defined(__SSE3__) && TSAN_SHADOW_COUNT == 4\n+#define SHUF(v0, v1, i0, i1, i2, i3) _mm_castps_si128(_mm_shuffle_ps( \\\n+    _mm_castsi128_ps(v0), _mm_castsi128_ps(v1), \\\n+    (i0)*1 + (i1)*4 + (i2)*16 + (i3)*64))\n+ALWAYS_INLINE\n+bool ContainsSameAccessFast(u64 *s, u64 a, u64 sync_epoch, bool is_write) {\n+  // This is an optimized version of ContainsSameAccessSlow.\n+  // load current access into access[0:63]\n+  const m128 access     = _mm_cvtsi64_si128(a);\n+  // duplicate high part of access in addr0:\n+  // addr0[0:31]        = access[32:63]\n+  // addr0[32:63]       = access[32:63]\n+  // addr0[64:95]       = access[32:63]\n+  // addr0[96:127]      = access[32:63]\n+  const m128 addr0      = SHUF(access, access, 1, 1, 1, 1);\n+  // load 4 shadow slots\n+  const m128 shadow0    = _mm_load_si128((__m128i*)s);\n+  const m128 shadow1    = _mm_load_si128((__m128i*)s + 1);\n+  // load high parts of 4 shadow slots into addr_vect:\n+  // addr_vect[0:31]    = shadow0[32:63]\n+  // addr_vect[32:63]   = shadow0[96:127]\n+  // addr_vect[64:95]   = shadow1[32:63]\n+  // addr_vect[96:127]  = shadow1[96:127]\n+  m128 addr_vect        = SHUF(shadow0, shadow1, 1, 3, 1, 3);\n+  if (!is_write) {\n+    // set IsRead bit in addr_vect\n+    const m128 rw_mask1 = _mm_cvtsi64_si128(1<<15);\n+    const m128 rw_mask  = SHUF(rw_mask1, rw_mask1, 0, 0, 0, 0);\n+    addr_vect           = _mm_or_si128(addr_vect, rw_mask);\n+  }\n+  // addr0 == addr_vect?\n+  const m128 addr_res   = _mm_cmpeq_epi32(addr0, addr_vect);\n+  // epoch1[0:63]       = sync_epoch\n+  const m128 epoch1     = _mm_cvtsi64_si128(sync_epoch);\n+  // epoch[0:31]        = sync_epoch[0:31]\n+  // epoch[32:63]       = sync_epoch[0:31]\n+  // epoch[64:95]       = sync_epoch[0:31]\n+  // epoch[96:127]      = sync_epoch[0:31]\n+  const m128 epoch      = SHUF(epoch1, epoch1, 0, 0, 0, 0);\n+  // load low parts of shadow cell epochs into epoch_vect:\n+  // epoch_vect[0:31]   = shadow0[0:31]\n+  // epoch_vect[32:63]  = shadow0[64:95]\n+  // epoch_vect[64:95]  = shadow1[0:31]\n+  // epoch_vect[96:127] = shadow1[64:95]\n+  const m128 epoch_vect = SHUF(shadow0, shadow1, 0, 2, 0, 2);\n+  // epoch_vect >= sync_epoch?\n+  const m128 epoch_res  = _mm_cmpgt_epi32(epoch_vect, epoch);\n+  // addr_res & epoch_res\n+  const m128 res        = _mm_and_si128(addr_res, epoch_res);\n+  // mask[0] = res[7]\n+  // mask[1] = res[15]\n+  // ...\n+  // mask[15] = res[127]\n+  const int mask        = _mm_movemask_epi8(res);\n+  return mask != 0;\n+}\n+#endif\n+\n+ALWAYS_INLINE\n+bool ContainsSameAccess(u64 *s, u64 a, u64 sync_epoch, bool is_write) {\n+#if defined(__SSE3__) && TSAN_SHADOW_COUNT == 4\n+  bool res = ContainsSameAccessFast(s, a, sync_epoch, is_write);\n+  DCHECK_EQ(res, ContainsSameAccessSlow(s, a, sync_epoch, is_write));\n+  return res;\n+#else\n+  return ContainsSameAccessSlow(s, a, sync_epoch, is_write);\n+#endif\n+}\n+\n ALWAYS_INLINE USED\n void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n     int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic) {\n@@ -579,7 +718,7 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   }\n #endif\n \n-  if (*shadow_mem == kShadowRodata) {\n+  if (kCppMode && *shadow_mem == kShadowRodata) {\n     // Access to .rodata section, no races here.\n     // Measurements show that it can be 10-20% of all memory accesses.\n     StatInc(thr, StatMop);\n@@ -590,22 +729,54 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   }\n \n   FastState fast_state = thr->fast_state;\n-  if (fast_state.GetIgnoreBit())\n+  if (fast_state.GetIgnoreBit()) {\n+    StatInc(thr, StatMop);\n+    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n+    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n+    StatInc(thr, StatMopIgnored);\n     return;\n-  if (kCollectHistory) {\n-    fast_state.IncrementEpoch();\n-    thr->fast_state = fast_state;\n-    // We must not store to the trace if we do not store to the shadow.\n-    // That is, this call must be moved somewhere below.\n-    TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n   }\n \n   Shadow cur(fast_state);\n   cur.SetAddr0AndSizeLog(addr & 7, kAccessSizeLog);\n   cur.SetWrite(kAccessIsWrite);\n   cur.SetAtomic(kIsAtomic);\n \n-  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite, kIsAtomic,\n+  if (LIKELY(ContainsSameAccess(shadow_mem, cur.raw(),\n+      thr->fast_synch_epoch, kAccessIsWrite))) {\n+    StatInc(thr, StatMop);\n+    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n+    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n+    StatInc(thr, StatMopSame);\n+    return;\n+  }\n+\n+  if (kCollectHistory) {\n+    fast_state.IncrementEpoch();\n+    thr->fast_state = fast_state;\n+    TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n+    cur.IncrementEpoch();\n+  }\n+\n+  MemoryAccessImpl1(thr, addr, kAccessSizeLog, kAccessIsWrite, kIsAtomic,\n+      shadow_mem, cur);\n+}\n+\n+// Called by MemoryAccessRange in tsan_rtl_thread.cc\n+ALWAYS_INLINE USED\n+void MemoryAccessImpl(ThreadState *thr, uptr addr,\n+    int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic,\n+    u64 *shadow_mem, Shadow cur) {\n+  if (LIKELY(ContainsSameAccess(shadow_mem, cur.raw(),\n+      thr->fast_synch_epoch, kAccessIsWrite))) {\n+    StatInc(thr, StatMop);\n+    StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n+    StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n+    StatInc(thr, StatMopSame);\n+    return;\n+  }\n+\n+  MemoryAccessImpl1(thr, addr, kAccessSizeLog, kAccessIsWrite, kIsAtomic,\n       shadow_mem, cur);\n }\n \n@@ -723,17 +894,8 @@ void FuncEntry(ThreadState *thr, uptr pc) {\n #ifndef TSAN_GO\n   DCHECK_LT(thr->shadow_stack_pos, thr->shadow_stack_end);\n #else\n-  if (thr->shadow_stack_pos == thr->shadow_stack_end) {\n-    const int sz = thr->shadow_stack_end - thr->shadow_stack;\n-    const int newsz = 2 * sz;\n-    uptr *newstack = (uptr*)internal_alloc(MBlockShadowStack,\n-        newsz * sizeof(uptr));\n-    internal_memcpy(newstack, thr->shadow_stack, sz * sizeof(uptr));\n-    internal_free(thr->shadow_stack);\n-    thr->shadow_stack = newstack;\n-    thr->shadow_stack_pos = newstack + sz;\n-    thr->shadow_stack_end = newstack + newsz;\n-  }\n+  if (thr->shadow_stack_pos == thr->shadow_stack_end)\n+    GrowShadowStack(thr);\n #endif\n   thr->shadow_stack_pos[0] = pc;\n   thr->shadow_stack_pos++;"}, {"sha": "c7ea94dfbde980eb194d9688e90960b790345bef", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 58, "deletions": 138, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -42,94 +42,20 @@\n #include \"tsan_platform.h\"\n #include \"tsan_mutexset.h\"\n #include \"tsan_ignoreset.h\"\n+#include \"tsan_stack_trace.h\"\n \n #if SANITIZER_WORDSIZE != 64\n # error \"ThreadSanitizer is supported only on 64-bit platforms\"\n #endif\n \n namespace __tsan {\n \n-// Descriptor of user's memory block.\n-struct MBlock {\n-  /*\n-  u64 mtx : 1;  // must be first\n-  u64 lst : 44;\n-  u64 stk : 31;  // on word boundary\n-  u64 tid : kTidBits;\n-  u64 siz : 128 - 1 - 31 - 44 - kTidBits;  // 39\n-  */\n-  u64 raw[2];\n-\n-  void Init(uptr siz, u32 tid, u32 stk) {\n-    raw[0] = raw[1] = 0;\n-    raw[1] |= (u64)siz << ((1 + 44 + 31 + kTidBits) % 64);\n-    raw[1] |= (u64)tid << ((1 + 44 + 31) % 64);\n-    raw[0] |= (u64)stk << (1 + 44);\n-    raw[1] |= (u64)stk >> (64 - 44 - 1);\n-    DCHECK_EQ(Size(), siz);\n-    DCHECK_EQ(Tid(), tid);\n-    DCHECK_EQ(StackId(), stk);\n-  }\n-\n-  u32 Tid() const {\n-    return GetLsb(raw[1] >> ((1 + 44 + 31) % 64), kTidBits);\n-  }\n-\n-  uptr Size() const {\n-    return raw[1] >> ((1 + 31 + 44 + kTidBits) % 64);\n-  }\n-\n-  u32 StackId() const {\n-    return (raw[0] >> (1 + 44)) | GetLsb(raw[1] << (64 - 44 - 1), 31);\n-  }\n-\n-  SyncVar *ListHead() const {\n-    return (SyncVar*)(GetLsb(raw[0] >> 1, 44) << 3);\n-  }\n-\n-  void ListPush(SyncVar *v) {\n-    SyncVar *lst = ListHead();\n-    v->next = lst;\n-    u64 x = (u64)v ^ (u64)lst;\n-    x = (x >> 3) << 1;\n-    raw[0] ^= x;\n-    DCHECK_EQ(ListHead(), v);\n-  }\n-\n-  SyncVar *ListPop() {\n-    SyncVar *lst = ListHead();\n-    SyncVar *nxt = lst->next;\n-    lst->next = 0;\n-    u64 x = (u64)lst ^ (u64)nxt;\n-    x = (x >> 3) << 1;\n-    raw[0] ^= x;\n-    DCHECK_EQ(ListHead(), nxt);\n-    return lst;\n-  }\n-\n-  void ListReset() {\n-    SyncVar *lst = ListHead();\n-    u64 x = (u64)lst;\n-    x = (x >> 3) << 1;\n-    raw[0] ^= x;\n-    DCHECK_EQ(ListHead(), 0);\n-  }\n-\n-  void Lock();\n-  void Unlock();\n-  typedef GenericScopedLock<MBlock> ScopedLock;\n-};\n-\n #ifndef TSAN_GO\n-#if defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n-const uptr kAllocatorSpace = 0x7d0000000000ULL;\n-#else\n const uptr kAllocatorSpace = 0x7d0000000000ULL;\n-#endif\n const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n \n struct MapUnmapCallback;\n-typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, sizeof(MBlock),\n+typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0,\n     DefaultSizeClassMap, MapUnmapCallback> PrimaryAllocator;\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<MapUnmapCallback> SecondaryAllocator;\n@@ -146,14 +72,14 @@ const u64 kShadowRodata = (u64)-1;  // .rodata shadow marker\n // FastState (from most significant bit):\n //   ignore          : 1\n //   tid             : kTidBits\n-//   epoch           : kClkBits\n //   unused          : -\n //   history_size    : 3\n+//   epoch           : kClkBits\n class FastState {\n  public:\n   FastState(u64 tid, u64 epoch) {\n     x_ = tid << kTidShift;\n-    x_ |= epoch << kClkShift;\n+    x_ |= epoch;\n     DCHECK_EQ(tid, this->tid());\n     DCHECK_EQ(epoch, this->epoch());\n     DCHECK_EQ(GetIgnoreBit(), false);\n@@ -178,13 +104,13 @@ class FastState {\n   }\n \n   u64 epoch() const {\n-    u64 res = (x_ << (kTidBits + 1)) >> (64 - kClkBits);\n+    u64 res = x_ & ((1ull << kClkBits) - 1);\n     return res;\n   }\n \n   void IncrementEpoch() {\n     u64 old_epoch = epoch();\n-    x_ += 1 << kClkShift;\n+    x_ += 1;\n     DCHECK_EQ(old_epoch + 1, epoch());\n     (void)old_epoch;\n   }\n@@ -196,17 +122,19 @@ class FastState {\n   void SetHistorySize(int hs) {\n     CHECK_GE(hs, 0);\n     CHECK_LE(hs, 7);\n-    x_ = (x_ & ~7) | hs;\n+    x_ = (x_ & ~(kHistoryMask << kHistoryShift)) | (u64(hs) << kHistoryShift);\n   }\n \n+  ALWAYS_INLINE\n   int GetHistorySize() const {\n-    return (int)(x_ & 7);\n+    return (int)((x_ >> kHistoryShift) & kHistoryMask);\n   }\n \n   void ClearHistorySize() {\n-    x_ &= ~7;\n+    SetHistorySize(0);\n   }\n \n+  ALWAYS_INLINE\n   u64 GetTracePos() const {\n     const int hs = GetHistorySize();\n     // When hs == 0, the trace consists of 2 parts.\n@@ -217,20 +145,21 @@ class FastState {\n  private:\n   friend class Shadow;\n   static const int kTidShift = 64 - kTidBits - 1;\n-  static const int kClkShift = kTidShift - kClkBits;\n   static const u64 kIgnoreBit = 1ull << 63;\n   static const u64 kFreedBit = 1ull << 63;\n+  static const u64 kHistoryShift = kClkBits;\n+  static const u64 kHistoryMask = 7;\n   u64 x_;\n };\n \n // Shadow (from most significant bit):\n //   freed           : 1\n //   tid             : kTidBits\n-//   epoch           : kClkBits\n //   is_atomic       : 1\n //   is_read         : 1\n //   size_log        : 2\n //   addr0           : 3\n+//   epoch           : kClkBits\n class Shadow : public FastState {\n  public:\n   explicit Shadow(u64 x)\n@@ -243,10 +172,10 @@ class Shadow : public FastState {\n   }\n \n   void SetAddr0AndSizeLog(u64 addr0, unsigned kAccessSizeLog) {\n-    DCHECK_EQ(x_ & 31, 0);\n+    DCHECK_EQ((x_ >> kClkBits) & 31, 0);\n     DCHECK_LE(addr0, 7);\n     DCHECK_LE(kAccessSizeLog, 3);\n-    x_ |= (kAccessSizeLog << 3) | addr0;\n+    x_ |= ((kAccessSizeLog << 3) | addr0) << kClkBits;\n     DCHECK_EQ(kAccessSizeLog, size_log());\n     DCHECK_EQ(addr0, this->addr0());\n   }\n@@ -279,47 +208,34 @@ class Shadow : public FastState {\n     return shifted_xor == 0;\n   }\n \n-  static inline bool Addr0AndSizeAreEqual(const Shadow s1, const Shadow s2) {\n-    u64 masked_xor = (s1.x_ ^ s2.x_) & 31;\n+  static ALWAYS_INLINE\n+  bool Addr0AndSizeAreEqual(const Shadow s1, const Shadow s2) {\n+    u64 masked_xor = ((s1.x_ ^ s2.x_) >> kClkBits) & 31;\n     return masked_xor == 0;\n   }\n \n-  static inline bool TwoRangesIntersect(Shadow s1, Shadow s2,\n+  static ALWAYS_INLINE bool TwoRangesIntersect(Shadow s1, Shadow s2,\n       unsigned kS2AccessSize) {\n     bool res = false;\n     u64 diff = s1.addr0() - s2.addr0();\n     if ((s64)diff < 0) {  // s1.addr0 < s2.addr0  // NOLINT\n       // if (s1.addr0() + size1) > s2.addr0()) return true;\n-      if (s1.size() > -diff)  res = true;\n+      if (s1.size() > -diff)\n+        res = true;\n     } else {\n       // if (s2.addr0() + kS2AccessSize > s1.addr0()) return true;\n-      if (kS2AccessSize > diff) res = true;\n+      if (kS2AccessSize > diff)\n+        res = true;\n     }\n-    DCHECK_EQ(res, TwoRangesIntersectSLOW(s1, s2));\n-    DCHECK_EQ(res, TwoRangesIntersectSLOW(s2, s1));\n+    DCHECK_EQ(res, TwoRangesIntersectSlow(s1, s2));\n+    DCHECK_EQ(res, TwoRangesIntersectSlow(s2, s1));\n     return res;\n   }\n \n-  // The idea behind the offset is as follows.\n-  // Consider that we have 8 bool's contained within a single 8-byte block\n-  // (mapped to a single shadow \"cell\"). Now consider that we write to the bools\n-  // from a single thread (which we consider the common case).\n-  // W/o offsetting each access will have to scan 4 shadow values at average\n-  // to find the corresponding shadow value for the bool.\n-  // With offsetting we start scanning shadow with the offset so that\n-  // each access hits necessary shadow straight off (at least in an expected\n-  // optimistic case).\n-  // This logic works seamlessly for any layout of user data. For example,\n-  // if user data is {int, short, char, char}, then accesses to the int are\n-  // offsetted to 0, short - 4, 1st char - 6, 2nd char - 7. Hopefully, accesses\n-  // from a single thread won't need to scan all 8 shadow values.\n-  unsigned ComputeSearchOffset() {\n-    return x_ & 7;\n-  }\n-  u64 addr0() const { return x_ & 7; }\n-  u64 size() const { return 1ull << size_log(); }\n-  bool IsWrite() const { return !IsRead(); }\n-  bool IsRead() const { return x_ & kReadBit; }\n+  u64 ALWAYS_INLINE addr0() const { return (x_ >> kClkBits) & 7; }\n+  u64 ALWAYS_INLINE size() const { return 1ull << size_log(); }\n+  bool ALWAYS_INLINE IsWrite() const { return !IsRead(); }\n+  bool ALWAYS_INLINE IsRead() const { return x_ & kReadBit; }\n \n   // The idea behind the freed bit is as follows.\n   // When the memory is freed (or otherwise unaccessible) we write to the shadow\n@@ -344,23 +260,22 @@ class Shadow : public FastState {\n     return res;\n   }\n \n-  bool IsBothReadsOrAtomic(bool kIsWrite, bool kIsAtomic) const {\n-    // analyzes 5-th bit (is_read) and 6-th bit (is_atomic)\n-    bool v = x_ & u64(((kIsWrite ^ 1) << kReadShift)\n-        | (kIsAtomic << kAtomicShift));\n+  bool ALWAYS_INLINE IsBothReadsOrAtomic(bool kIsWrite, bool kIsAtomic) const {\n+    bool v = x_ & ((u64(kIsWrite ^ 1) << kReadShift)\n+        | (u64(kIsAtomic) << kAtomicShift));\n     DCHECK_EQ(v, (!IsWrite() && !kIsWrite) || (IsAtomic() && kIsAtomic));\n     return v;\n   }\n \n-  bool IsRWNotWeaker(bool kIsWrite, bool kIsAtomic) const {\n+  bool ALWAYS_INLINE IsRWNotWeaker(bool kIsWrite, bool kIsAtomic) const {\n     bool v = ((x_ >> kReadShift) & 3)\n         <= u64((kIsWrite ^ 1) | (kIsAtomic << 1));\n     DCHECK_EQ(v, (IsAtomic() < kIsAtomic) ||\n         (IsAtomic() == kIsAtomic && !IsWrite() <= !kIsWrite));\n     return v;\n   }\n \n-  bool IsRWWeakerOrEqual(bool kIsWrite, bool kIsAtomic) const {\n+  bool ALWAYS_INLINE IsRWWeakerOrEqual(bool kIsWrite, bool kIsAtomic) const {\n     bool v = ((x_ >> kReadShift) & 3)\n         >= u64((kIsWrite ^ 1) | (kIsAtomic << 1));\n     DCHECK_EQ(v, (IsAtomic() > kIsAtomic) ||\n@@ -369,14 +284,14 @@ class Shadow : public FastState {\n   }\n \n  private:\n-  static const u64 kReadShift   = 5;\n+  static const u64 kReadShift   = 5 + kClkBits;\n   static const u64 kReadBit     = 1ull << kReadShift;\n-  static const u64 kAtomicShift = 6;\n+  static const u64 kAtomicShift = 6 + kClkBits;\n   static const u64 kAtomicBit   = 1ull << kAtomicShift;\n \n-  u64 size_log() const { return (x_ >> 3) & 3; }\n+  u64 size_log() const { return (x_ >> (3 + kClkBits)) & 3; }\n \n-  static bool TwoRangesIntersectSLOW(const Shadow s1, const Shadow s2) {\n+  static bool TwoRangesIntersectSlow(const Shadow s1, const Shadow s2) {\n     if (s1.addr0() == s2.addr0()) return true;\n     if (s1.addr0() < s2.addr0() && s1.addr0() + s1.size() > s2.addr0())\n       return true;\n@@ -391,6 +306,9 @@ struct SignalContext;\n struct JmpBuf {\n   uptr sp;\n   uptr mangled_sp;\n+  int int_signal_send;\n+  bool in_blocking_func;\n+  uptr in_signal_handler;\n   uptr *shadow_stack_pos;\n };\n \n@@ -439,7 +357,7 @@ struct ThreadState {\n   const int unique_id;\n   bool in_symbolizer;\n   bool in_ignored_lib;\n-  bool is_alive;\n+  bool is_dead;\n   bool is_freeing;\n   bool is_vptr_access;\n   const uptr stk_addr;\n@@ -452,9 +370,13 @@ struct ThreadState {\n   DDPhysicalThread *dd_pt;\n   DDLogicalThread *dd_lt;\n \n-  bool in_signal_handler;\n+  atomic_uintptr_t in_signal_handler;\n   SignalContext *signal_ctx;\n \n+  DenseSlabAllocCache block_cache;\n+  DenseSlabAllocCache sync_cache;\n+  DenseSlabAllocCache clock_cache;\n+\n #ifndef TSAN_GO\n   u32 last_sleep_stack_id;\n   ThreadClock last_sleep_clock;\n@@ -498,6 +420,7 @@ class ThreadContext : public ThreadContextBase {\n   void OnStarted(void *arg);\n   void OnCreated(void *arg);\n   void OnReset();\n+  void OnDetached(void *arg);\n };\n \n struct RacyStacks {\n@@ -528,7 +451,7 @@ struct Context {\n   bool initialized;\n   bool after_multithreaded_fork;\n \n-  SyncTab synctab;\n+  MetaMap metamap;\n \n   Mutex report_mtx;\n   int nreported;\n@@ -546,6 +469,8 @@ struct Context {\n   InternalMmapVector<FiredSuppression> fired_suppressions;\n   DDetector *dd;\n \n+  ClockAlloc clock_alloc;\n+\n   Flags flags;\n \n   u64 stat[StatCnt];\n@@ -574,11 +499,11 @@ class ScopedReport {\n   explicit ScopedReport(ReportType typ);\n   ~ScopedReport();\n \n-  void AddStack(const StackTrace *stack);\n   void AddMemoryAccess(uptr addr, Shadow s, const StackTrace *stack,\n                        const MutexSet *mset);\n-  void AddThread(const ThreadContext *tctx);\n-  void AddThread(int unique_tid);\n+  void AddStack(const StackTrace *stack, bool suppressable = false);\n+  void AddThread(const ThreadContext *tctx, bool suppressable = false);\n+  void AddThread(int unique_tid, bool suppressable = false);\n   void AddUniqueTid(int unique_tid);\n   void AddMutex(const SyncVar *s);\n   u64 AddMutex(u64 id);\n@@ -626,11 +551,7 @@ void ForkParentAfter(ThreadState *thr, uptr pc);\n void ForkChildAfter(ThreadState *thr, uptr pc);\n \n void ReportRace(ThreadState *thr);\n-bool OutputReport(Context *ctx,\n-                  const ScopedReport &srep,\n-                  const ReportStack *suppress_stack1,\n-                  const ReportStack *suppress_stack2 = 0,\n-                  const ReportLocation *suppress_loc = 0);\n+bool OutputReport(ThreadState *thr, const ScopedReport &srep);\n bool IsFiredSuppression(Context *ctx,\n                         const ScopedReport &srep,\n                         const StackTrace &trace);\n@@ -659,9 +580,8 @@ void PrintCurrentStackSlow();  // uses libunwind\n void Initialize(ThreadState *thr);\n int Finalize(ThreadState *thr);\n \n-SyncVar* GetJavaSync(ThreadState *thr, uptr pc, uptr addr,\n-                     bool write_lock, bool create);\n-SyncVar* GetAndRemoveJavaSync(ThreadState *thr, uptr pc, uptr addr);\n+void OnUserAlloc(ThreadState *thr, uptr pc, uptr p, uptr sz, bool write);\n+void OnUserFree(ThreadState *thr, uptr pc, uptr p, bool write);\n \n void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n     int kAccessSizeLog, bool kAccessIsWrite, bool kIsAtomic);"}, {"sha": "cc183138abaf522b8b76c09798ef5dd6861a264d", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 68, "deletions": 46, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -50,14 +50,18 @@ void DDMutexInit(ThreadState *thr, uptr pc, SyncVar *s) {\n \n static void ReportMutexMisuse(ThreadState *thr, uptr pc, ReportType typ,\n     uptr addr, u64 mid) {\n+  // In Go, these misuses are either impossible, or detected by std lib,\n+  // or false positives (e.g. unlock in a different thread).\n+  if (kGoMode)\n+    return;\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(typ);\n   rep.AddMutex(mid);\n   StackTrace trace;\n   trace.ObtainCurrent(thr, pc);\n-  rep.AddStack(&trace);\n+  rep.AddStack(&trace, true);\n   rep.AddLocation(addr, 1);\n-  OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+  OutputReport(thr, rep);\n }\n \n void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n@@ -70,10 +74,12 @@ void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n     MemoryWrite(thr, pc, addr, kSizeLog1);\n     thr->is_freeing = false;\n   }\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   s->is_rw = rw;\n   s->is_recursive = recursive;\n   s->is_linker_init = linker_init;\n+  if (kCppMode && s->creation_stack_id == 0)\n+    s->creation_stack_id = CurrentStackId(thr, pc);\n   s->mtx.Unlock();\n }\n \n@@ -86,45 +92,62 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {\n   if (IsGlobalVar(addr))\n     return;\n #endif\n-  SyncVar *s = ctx->synctab.GetAndRemove(thr, pc, addr);\n-  if (s == 0)\n-    return;\n-  if (flags()->detect_deadlocks) {\n-    Callback cb(thr, pc);\n-    ctx->dd->MutexDestroy(&cb, &s->dd);\n-  }\n   if (IsAppMem(addr)) {\n     CHECK(!thr->is_freeing);\n     thr->is_freeing = true;\n     MemoryWrite(thr, pc, addr, kSizeLog1);\n     thr->is_freeing = false;\n   }\n+  SyncVar *s = ctx->metamap.GetIfExistsAndLock(addr);\n+  if (s == 0)\n+    return;\n+  if (common_flags()->detect_deadlocks) {\n+    Callback cb(thr, pc);\n+    ctx->dd->MutexDestroy(&cb, &s->dd);\n+    ctx->dd->MutexInit(&cb, &s->dd);\n+  }\n+  bool unlock_locked = false;\n   if (flags()->report_destroy_locked\n       && s->owner_tid != SyncVar::kInvalidTid\n       && !s->is_broken) {\n     s->is_broken = true;\n+    unlock_locked = true;\n+  }\n+  u64 mid = s->GetId();\n+  u32 last_lock = s->last_lock;\n+  if (!unlock_locked)\n+    s->Reset(thr);  // must not reset it before the report is printed\n+  s->mtx.Unlock();\n+  if (unlock_locked) {\n     ThreadRegistryLock l(ctx->thread_registry);\n     ScopedReport rep(ReportTypeMutexDestroyLocked);\n-    rep.AddMutex(s);\n+    rep.AddMutex(mid);\n     StackTrace trace;\n     trace.ObtainCurrent(thr, pc);\n     rep.AddStack(&trace);\n-    FastState last(s->last_lock);\n+    FastState last(last_lock);\n     RestoreStack(last.tid(), last.epoch(), &trace, 0);\n-    rep.AddStack(&trace);\n-    rep.AddLocation(s->addr, 1);\n-    OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+    rep.AddStack(&trace, true);\n+    rep.AddLocation(addr, 1);\n+    OutputReport(thr, rep);\n+  }\n+  if (unlock_locked) {\n+    SyncVar *s = ctx->metamap.GetIfExistsAndLock(addr);\n+    if (s != 0) {\n+      s->Reset(thr);\n+      s->mtx.Unlock();\n+    }\n   }\n-  thr->mset.Remove(s->GetId());\n-  DestroyAndFree(s);\n+  thr->mset.Remove(mid);\n+  // s will be destroyed and freed in MetaMap::FreeBlock.\n }\n \n void MutexLock(ThreadState *thr, uptr pc, uptr addr, int rec, bool try_lock) {\n   DPrintf(\"#%d: MutexLock %zx rec=%d\\n\", thr->tid, addr, rec);\n   CHECK_GT(rec, 0);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeLock, s->GetId());\n   bool report_double_lock = false;\n@@ -147,7 +170,7 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr, int rec, bool try_lock) {\n   }\n   s->recursion += rec;\n   thr->mset.Add(s->GetId(), true, thr->fast_state.epoch());\n-  if (flags()->detect_deadlocks && s->recursion == 1) {\n+  if (common_flags()->detect_deadlocks && (s->recursion - rec) == 0) {\n     Callback cb(thr, pc);\n     if (!try_lock)\n       ctx->dd->MutexBeforeLock(&cb, &s->dd, true);\n@@ -158,7 +181,7 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr, int rec, bool try_lock) {\n   // Can't touch s after this point.\n   if (report_double_lock)\n     ReportMutexMisuse(thr, pc, ReportTypeMutexDoubleLock, addr, mid);\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     Callback cb(thr, pc);\n     ReportDeadlock(thr, pc, ctx->dd->GetReport(&cb));\n   }\n@@ -168,12 +191,12 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all) {\n   DPrintf(\"#%d: MutexUnlock %zx all=%d\\n\", thr->tid, addr, all);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeUnlock, s->GetId());\n   int rec = 0;\n   bool report_bad_unlock = false;\n-  if (s->recursion == 0 || s->owner_tid != thr->tid) {\n+  if (kCppMode && (s->recursion == 0 || s->owner_tid != thr->tid)) {\n     if (flags()->report_mutex_bugs && !s->is_broken) {\n       s->is_broken = true;\n       report_bad_unlock = true;\n@@ -190,7 +213,8 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all) {\n     }\n   }\n   thr->mset.Del(s->GetId(), true);\n-  if (flags()->detect_deadlocks && s->recursion == 0) {\n+  if (common_flags()->detect_deadlocks && s->recursion == 0 &&\n+      !report_bad_unlock) {\n     Callback cb(thr, pc);\n     ctx->dd->MutexBeforeUnlock(&cb, &s->dd, true);\n   }\n@@ -199,7 +223,7 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all) {\n   // Can't touch s after this point.\n   if (report_bad_unlock)\n     ReportMutexMisuse(thr, pc, ReportTypeMutexBadUnlock, addr, mid);\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks && !report_bad_unlock) {\n     Callback cb(thr, pc);\n     ReportDeadlock(thr, pc, ctx->dd->GetReport(&cb));\n   }\n@@ -211,7 +235,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr, bool trylock) {\n   StatInc(thr, StatMutexReadLock);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, false);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, false);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRLock, s->GetId());\n   bool report_bad_lock = false;\n@@ -224,7 +248,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr, bool trylock) {\n   AcquireImpl(thr, pc, &s->clock);\n   s->last_lock = thr->fast_state.raw();\n   thr->mset.Add(s->GetId(), false, thr->fast_state.epoch());\n-  if (flags()->detect_deadlocks && s->recursion == 0) {\n+  if (common_flags()->detect_deadlocks && s->recursion == 0) {\n     Callback cb(thr, pc);\n     if (!trylock)\n       ctx->dd->MutexBeforeLock(&cb, &s->dd, false);\n@@ -235,7 +259,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr, bool trylock) {\n   // Can't touch s after this point.\n   if (report_bad_lock)\n     ReportMutexMisuse(thr, pc, ReportTypeMutexBadReadLock, addr, mid);\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     Callback cb(thr, pc);\n     ReportDeadlock(thr, pc, ctx->dd->GetReport(&cb));\n   }\n@@ -246,7 +270,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   StatInc(thr, StatMutexReadUnlock);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, s->GetId());\n   bool report_bad_unlock = false;\n@@ -257,7 +281,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     }\n   }\n   ReleaseImpl(thr, pc, &s->read_clock);\n-  if (flags()->detect_deadlocks && s->recursion == 0) {\n+  if (common_flags()->detect_deadlocks && s->recursion == 0) {\n     Callback cb(thr, pc);\n     ctx->dd->MutexBeforeUnlock(&cb, &s->dd, false);\n   }\n@@ -267,7 +291,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   thr->mset.Del(mid, false);\n   if (report_bad_unlock)\n     ReportMutexMisuse(thr, pc, ReportTypeMutexBadReadUnlock, addr, mid);\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     Callback cb(thr, pc);\n     ReportDeadlock(thr, pc, ctx->dd->GetReport(&cb));\n   }\n@@ -277,7 +301,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexReadOrWriteUnlock %zx\\n\", thr->tid, addr);\n   if (IsAppMem(addr))\n     MemoryReadAtomic(thr, pc, addr, kSizeLog1);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   bool write = true;\n   bool report_bad_unlock = false;\n   if (s->owner_tid == SyncVar::kInvalidTid) {\n@@ -305,7 +329,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     report_bad_unlock = true;\n   }\n   thr->mset.Del(s->GetId(), write);\n-  if (flags()->detect_deadlocks && s->recursion == 0) {\n+  if (common_flags()->detect_deadlocks && s->recursion == 0) {\n     Callback cb(thr, pc);\n     ctx->dd->MutexBeforeUnlock(&cb, &s->dd, write);\n   }\n@@ -314,15 +338,15 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   // Can't touch s after this point.\n   if (report_bad_unlock)\n     ReportMutexMisuse(thr, pc, ReportTypeMutexBadUnlock, addr, mid);\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     Callback cb(thr, pc);\n     ReportDeadlock(thr, pc, ctx->dd->GetReport(&cb));\n   }\n }\n \n void MutexRepair(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: MutexRepair %zx\\n\", thr->tid, addr);\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   s->owner_tid = SyncVar::kInvalidTid;\n   s->recursion = 0;\n   s->mtx.Unlock();\n@@ -332,7 +356,7 @@ void Acquire(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: Acquire %zx\\n\", thr->tid, addr);\n   if (thr->ignore_sync)\n     return;\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, false);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, false);\n   AcquireImpl(thr, pc, &s->clock);\n   s->mtx.ReadUnlock();\n }\n@@ -359,7 +383,7 @@ void Release(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: Release %zx\\n\", thr->tid, addr);\n   if (thr->ignore_sync)\n     return;\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   // Can't increment epoch w/o writing to the trace as well.\n   TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n@@ -371,7 +395,7 @@ void ReleaseStore(ThreadState *thr, uptr pc, uptr addr) {\n   DPrintf(\"#%d: ReleaseStore %zx\\n\", thr->tid, addr);\n   if (thr->ignore_sync)\n     return;\n-  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  SyncVar *s = ctx->metamap.GetOrCreateAndLock(thr, pc, addr, true);\n   thr->fast_state.IncrementEpoch();\n   // Can't increment epoch w/o writing to the trace as well.\n   TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n@@ -404,7 +428,7 @@ void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n   if (thr->ignore_sync)\n     return;\n   thr->clock.set(thr->fast_state.epoch());\n-  thr->clock.acquire(c);\n+  thr->clock.acquire(&thr->clock_cache, c);\n   StatInc(thr, StatSyncAcquire);\n }\n \n@@ -413,7 +437,7 @@ void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n     return;\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n-  thr->clock.release(c);\n+  thr->clock.release(&thr->clock_cache, c);\n   StatInc(thr, StatSyncRelease);\n }\n \n@@ -422,7 +446,7 @@ void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n     return;\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n-  thr->clock.ReleaseStore(c);\n+  thr->clock.ReleaseStore(&thr->clock_cache, c);\n   StatInc(thr, StatSyncRelease);\n }\n \n@@ -431,7 +455,7 @@ void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n     return;\n   thr->clock.set(thr->fast_state.epoch());\n   thr->fast_synch_epoch = thr->fast_state.epoch();\n-  thr->clock.acq_rel(c);\n+  thr->clock.acq_rel(&thr->clock_cache, c);\n   StatInc(thr, StatSyncAcquire);\n   StatInc(thr, StatSyncRelease);\n }\n@@ -446,7 +470,7 @@ void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {\n     rep.AddUniqueTid((int)r->loop[i].thr_ctx);\n     rep.AddThread((int)r->loop[i].thr_ctx);\n   }\n-  StackTrace stacks[2 * DDReport::kMaxLoopSize];\n+  InternalScopedBuffer<StackTrace> stacks(2 * DDReport::kMaxLoopSize);\n   uptr dummy_pc = 0x42;\n   for (int i = 0; i < r->n; i++) {\n     uptr size;\n@@ -460,12 +484,10 @@ void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {\n         // but we should still produce some stack trace in the report.\n         stacks[i].Init(&dummy_pc, 1);\n       }\n-      rep.AddStack(&stacks[i]);\n+      rep.AddStack(&stacks[i], true);\n     }\n   }\n-  // FIXME: use all stacks for suppressions, not just the second stack of the\n-  // first edge.\n-  OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+  OutputReport(thr, rep);\n }\n \n }  // namespace __tsan"}, {"sha": "eafd1f4dfcdf76c19f25d0b365f5d572c5c6bae9", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 46, "deletions": 70, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -59,7 +59,7 @@ static void StackStripMain(ReportStack *stack) {\n   ReportStack *last_frame2 = 0;\n   const char *prefix = \"__interceptor_\";\n   uptr prefix_len = internal_strlen(prefix);\n-  const char *path_prefix = flags()->strip_path_prefix;\n+  const char *path_prefix = common_flags()->strip_path_prefix;\n   uptr path_prefix_len = internal_strlen(path_prefix);\n   char *pos;\n   for (ReportStack *ent = stack; ent; ent = ent->next) {\n@@ -160,9 +160,10 @@ ScopedReport::~ScopedReport() {\n   DestroyAndFree(rep_);\n }\n \n-void ScopedReport::AddStack(const StackTrace *stack) {\n+void ScopedReport::AddStack(const StackTrace *stack, bool suppressable) {\n   ReportStack **rs = rep_->stacks.PushBack();\n   *rs = SymbolizeStack(*stack);\n+  (*rs)->suppressable = suppressable;\n }\n \n void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n@@ -176,6 +177,8 @@ void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n   mop->write = s.IsWrite();\n   mop->atomic = s.IsAtomic();\n   mop->stack = SymbolizeStack(*stack);\n+  if (mop->stack)\n+    mop->stack->suppressable = true;\n   for (uptr i = 0; i < mset->Size(); i++) {\n     MutexSet::Desc d = mset->Get(i);\n     u64 mid = this->AddMutex(d.id);\n@@ -188,7 +191,7 @@ void ScopedReport::AddUniqueTid(int unique_tid) {\n   rep_->unique_tids.PushBack(unique_tid);\n }\n \n-void ScopedReport::AddThread(const ThreadContext *tctx) {\n+void ScopedReport::AddThread(const ThreadContext *tctx, bool suppressable) {\n   for (uptr i = 0; i < rep_->threads.Size(); i++) {\n     if ((u32)rep_->threads[i]->id == tctx->tid)\n       return;\n@@ -203,6 +206,8 @@ void ScopedReport::AddThread(const ThreadContext *tctx) {\n   rt->parent_tid = tctx->parent_tid;\n   rt->stack = 0;\n   rt->stack = SymbolizeStackId(tctx->creation_stack_id);\n+  if (rt->stack)\n+    rt->stack->suppressable = suppressable;\n }\n \n #ifndef TSAN_GO\n@@ -249,9 +254,9 @@ ThreadContext *IsThreadStackOrTls(uptr addr, bool *is_stack) {\n }\n #endif\n \n-void ScopedReport::AddThread(int unique_tid) {\n+void ScopedReport::AddThread(int unique_tid, bool suppressable) {\n #ifndef TSAN_GO\n-  AddThread(FindThreadByUidLocked(unique_tid));\n+  AddThread(FindThreadByUidLocked(unique_tid), suppressable);\n #endif\n }\n \n@@ -273,7 +278,7 @@ u64 ScopedReport::AddMutex(u64 id) {\n   u64 uid = 0;\n   u64 mid = id;\n   uptr addr = SyncVar::SplitId(id, &uid);\n-  SyncVar *s = ctx->synctab.GetIfExistsAndLock(addr, false);\n+  SyncVar *s = ctx->metamap.GetIfExistsAndLock(addr);\n   // Check that the mutex is still alive.\n   // Another mutex can be created at the same address,\n   // so check uid as well.\n@@ -284,7 +289,7 @@ u64 ScopedReport::AddMutex(u64 id) {\n     AddDeadMutex(id);\n   }\n   if (s)\n-    s->mtx.ReadUnlock();\n+    s->mtx.Unlock();\n   return mid;\n }\n \n@@ -309,8 +314,7 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n   int fd = -1;\n   int creat_tid = -1;\n   u32 creat_stack = 0;\n-  if (FdLocation(addr, &fd, &creat_tid, &creat_stack)\n-      || FdLocation(AlternativeAddress(addr), &fd, &creat_tid, &creat_stack)) {\n+  if (FdLocation(addr, &fd, &creat_tid, &creat_stack)) {\n     void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n     ReportLocation *loc = new(mem) ReportLocation();\n     rep_->locs.PushBack(loc);\n@@ -324,21 +328,26 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n     return;\n   }\n   MBlock *b = 0;\n-  if (allocator()->PointerIsMine((void*)addr)\n-      && (b = user_mblock(0, (void*)addr))) {\n-    ThreadContext *tctx = FindThreadByTidLocked(b->Tid());\n+  Allocator *a = allocator();\n+  if (a->PointerIsMine((void*)addr)) {\n+    void *block_begin = a->GetBlockBegin((void*)addr);\n+    if (block_begin)\n+      b = ctx->metamap.GetBlock((uptr)block_begin);\n+  }\n+  if (b != 0) {\n+    ThreadContext *tctx = FindThreadByTidLocked(b->tid);\n     void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n     ReportLocation *loc = new(mem) ReportLocation();\n     rep_->locs.PushBack(loc);\n     loc->type = ReportLocationHeap;\n     loc->addr = (uptr)allocator()->GetBlockBegin((void*)addr);\n-    loc->size = b->Size();\n-    loc->tid = tctx ? tctx->tid : b->Tid();\n+    loc->size = b->siz;\n+    loc->tid = tctx ? tctx->tid : b->tid;\n     loc->name = 0;\n     loc->file = 0;\n     loc->line = 0;\n     loc->stack = 0;\n-    loc->stack = SymbolizeStackId(b->StackId());\n+    loc->stack = SymbolizeStackId(b->stk);\n     if (tctx)\n       AddThread(tctx);\n     return;\n@@ -354,6 +363,7 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n   }\n   ReportLocation *loc = SymbolizeData(addr);\n   if (loc) {\n+    loc->suppressable = true;\n     rep_->locs.PushBack(loc);\n     return;\n   }\n@@ -493,25 +503,31 @@ static void AddRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n   }\n }\n \n-bool OutputReport(Context *ctx,\n-                  const ScopedReport &srep,\n-                  const ReportStack *suppress_stack1,\n-                  const ReportStack *suppress_stack2,\n-                  const ReportLocation *suppress_loc) {\n+bool OutputReport(ThreadState *thr, const ScopedReport &srep) {\n   atomic_store(&ctx->last_symbolize_time_ns, NanoTime(), memory_order_relaxed);\n   const ReportDesc *rep = srep.GetReport();\n   Suppression *supp = 0;\n-  uptr suppress_pc = IsSuppressed(rep->typ, suppress_stack1, &supp);\n-  if (suppress_pc == 0)\n-    suppress_pc = IsSuppressed(rep->typ, suppress_stack2, &supp);\n-  if (suppress_pc == 0)\n-    suppress_pc = IsSuppressed(rep->typ, suppress_loc, &supp);\n+  uptr suppress_pc = 0;\n+  for (uptr i = 0; suppress_pc == 0 && i < rep->mops.Size(); i++)\n+    suppress_pc = IsSuppressed(rep->typ, rep->mops[i]->stack, &supp);\n+  for (uptr i = 0; suppress_pc == 0 && i < rep->stacks.Size(); i++)\n+    suppress_pc = IsSuppressed(rep->typ, rep->stacks[i], &supp);\n+  for (uptr i = 0; suppress_pc == 0 && i < rep->threads.Size(); i++)\n+    suppress_pc = IsSuppressed(rep->typ, rep->threads[i]->stack, &supp);\n+  for (uptr i = 0; suppress_pc == 0 && i < rep->locs.Size(); i++)\n+    suppress_pc = IsSuppressed(rep->typ, rep->locs[i], &supp);\n   if (suppress_pc != 0) {\n     FiredSuppression s = {srep.GetReport()->typ, suppress_pc, supp};\n     ctx->fired_suppressions.push_back(s);\n   }\n-  if (OnReport(rep, suppress_pc != 0))\n-    return false;\n+  {\n+    bool old_is_freeing = thr->is_freeing;\n+    thr->is_freeing = false;\n+    bool suppressed = OnReport(rep, suppress_pc != 0);\n+    thr->is_freeing = old_is_freeing;\n+    if (suppressed)\n+      return false;\n+  }\n   PrintReport(rep);\n   ctx->nreported++;\n   if (flags()->halt_on_error)\n@@ -560,41 +576,6 @@ bool FrameIsInternal(const ReportStack *frame) {\n           internal_strstr(frame->file, \"tsan_interface_\"));\n }\n \n-// On programs that use Java we see weird reports like:\n-// WARNING: ThreadSanitizer: data race (pid=22512)\n-//   Read of size 8 at 0x7d2b00084318 by thread 100:\n-//     #0 memcpy tsan_interceptors.cc:406 (foo+0x00000d8dfae3)\n-//     #1 <null> <null>:0 (0x7f7ad9b40193)\n-//   Previous write of size 8 at 0x7d2b00084318 by thread 105:\n-//     #0 strncpy tsan_interceptors.cc:501 (foo+0x00000d8e0919)\n-//     #1 <null> <null>:0 (0x7f7ad9b42707)\n-static bool IsJavaNonsense(const ReportDesc *rep) {\n-#ifndef TSAN_GO\n-  for (uptr i = 0; i < rep->mops.Size(); i++) {\n-    ReportMop *mop = rep->mops[i];\n-    ReportStack *frame = mop->stack;\n-    if (frame == 0\n-        || (frame->func == 0 && frame->file == 0 && frame->line == 0\n-          && frame->module == 0)) {\n-      return true;\n-    }\n-    if (FrameIsInternal(frame)) {\n-      frame = frame->next;\n-      if (frame == 0\n-          || (frame->func == 0 && frame->file == 0 && frame->line == 0\n-          && frame->module == 0)) {\n-        if (frame) {\n-          FiredSuppression supp = {rep->typ, frame->pc, 0};\n-          ctx->fired_suppressions.push_back(supp);\n-        }\n-        return true;\n-      }\n-    }\n-  }\n-#endif\n-  return false;\n-}\n-\n static bool RaceBetweenAtomicAndFree(ThreadState *thr) {\n   Shadow s0(thr->racy_state[0]);\n   Shadow s1(thr->racy_state[1]);\n@@ -609,6 +590,8 @@ static bool RaceBetweenAtomicAndFree(ThreadState *thr) {\n }\n \n void ReportRace(ThreadState *thr) {\n+  CheckNoLocks(thr);\n+\n   // Symbolizer makes lots of intercepted calls. If we try to process them,\n   // at best it will cause deadlocks on internal mutexes.\n   ScopedIgnoreInterceptors ignore;\n@@ -671,9 +654,6 @@ void ReportRace(ThreadState *thr) {\n                         i == 0 ? &thr->mset : mset2.data());\n   }\n \n-  if (flags()->suppress_java && IsJavaNonsense(rep.GetReport()))\n-    return;\n-\n   for (uptr i = 0; i < kMop; i++) {\n     FastState s(thr->racy_state[i]);\n     ThreadContext *tctx = static_cast<ThreadContext*>(\n@@ -693,11 +673,7 @@ void ReportRace(ThreadState *thr) {\n   }\n #endif\n \n-  ReportLocation *suppress_loc = rep.GetReport()->locs.Size() ?\n-                                 rep.GetReport()->locs[0] : 0;\n-  if (!OutputReport(ctx, rep, rep.GetReport()->mops[0]->stack,\n-                              rep.GetReport()->mops[1]->stack,\n-                              suppress_loc))\n+  if (!OutputReport(thr, rep))\n     return;\n \n   AddRacyStacks(thr, traces, addr_min, addr_max);"}, {"sha": "0c0acc2787f81f3f440a73f5c3d1d2ac46fb3e0c", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -34,13 +34,13 @@ ThreadContext::~ThreadContext() {\n #endif\n \n void ThreadContext::OnDead() {\n-  sync.Reset();\n+  CHECK_EQ(sync.size(), 0);\n }\n \n void ThreadContext::OnJoined(void *arg) {\n   ThreadState *caller_thr = static_cast<ThreadState *>(arg);\n   AcquireImpl(caller_thr, 0, &sync);\n-  sync.Reset();\n+  sync.Reset(&caller_thr->clock_cache);\n }\n \n struct OnCreatedArgs {\n@@ -63,11 +63,16 @@ void ThreadContext::OnCreated(void *arg) {\n }\n \n void ThreadContext::OnReset() {\n-  sync.Reset();\n+  CHECK_EQ(sync.size(), 0);\n   FlushUnneededShadowMemory(GetThreadTrace(tid), TraceSize() * sizeof(Event));\n   //!!! FlushUnneededShadowMemory(GetThreadTraceHeader(tid), sizeof(Trace));\n }\n \n+void ThreadContext::OnDetached(void *arg) {\n+  ThreadState *thr1 = static_cast<ThreadState*>(arg);\n+  sync.Reset(&thr1->clock_cache);\n+}\n+\n struct OnStartedArgs {\n   ThreadState *thr;\n   uptr stk_addr;\n@@ -100,7 +105,7 @@ void ThreadContext::OnStarted(void *arg) {\n #ifndef TSAN_GO\n   AllocatorThreadStart(thr);\n #endif\n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     thr->dd_pt = ctx->dd->CreatePhysicalThread();\n     thr->dd_lt = ctx->dd->CreateLogicalThread(unique_id);\n   }\n@@ -111,12 +116,11 @@ void ThreadContext::OnStarted(void *arg) {\n   Trace *thr_trace = ThreadTrace(thr->tid);\n   thr_trace->headers[trace].epoch0 = epoch0;\n   StatInc(thr, StatSyncAcquire);\n-  sync.Reset();\n+  sync.Reset(&thr->clock_cache);\n   DPrintf(\"#%d: ThreadStart epoch=%zu stk_addr=%zx stk_size=%zx \"\n           \"tls_addr=%zx tls_size=%zx\\n\",\n           tid, (uptr)epoch0, args->stk_addr, args->stk_size,\n           args->tls_addr, args->tls_size);\n-  thr->is_alive = true;\n }\n \n void ThreadContext::OnFinished() {\n@@ -128,10 +132,12 @@ void ThreadContext::OnFinished() {\n   }\n   epoch1 = thr->fast_state.epoch();\n \n-  if (flags()->detect_deadlocks) {\n+  if (common_flags()->detect_deadlocks) {\n     ctx->dd->DestroyPhysicalThread(thr->dd_pt);\n     ctx->dd->DestroyLogicalThread(thr->dd_lt);\n   }\n+  ctx->clock_alloc.FlushCache(&thr->clock_cache);\n+  ctx->metamap.OnThreadIdle(thr);\n #ifndef TSAN_GO\n   AllocatorThreadFinish(thr);\n #endif\n@@ -203,9 +209,9 @@ void ThreadFinalize(ThreadState *thr) {\n       MaybeReportThreadLeak, &leaks);\n   for (uptr i = 0; i < leaks.Size(); i++) {\n     ScopedReport rep(ReportTypeThreadLeak);\n-    rep.AddThread(leaks[i].tctx);\n+    rep.AddThread(leaks[i].tctx, true);\n     rep.SetCount(leaks[i].count);\n-    OutputReport(ctx, rep, rep.GetReport()->threads[0]->stack);\n+    OutputReport(thr, rep);\n   }\n #endif\n }\n@@ -275,7 +281,7 @@ void ThreadFinish(ThreadState *thr) {\n     DontNeedShadowFor(thr->stk_addr, thr->stk_size);\n   if (thr->tls_addr && thr->tls_size)\n     DontNeedShadowFor(thr->tls_addr, thr->tls_size);\n-  thr->is_alive = false;\n+  thr->is_dead = true;\n   ctx->thread_registry->FinishThread(thr->tid);\n }\n \n@@ -304,7 +310,7 @@ void ThreadJoin(ThreadState *thr, uptr pc, int tid) {\n void ThreadDetach(ThreadState *thr, uptr pc, int tid) {\n   CHECK_GT(tid, 0);\n   CHECK_LT(tid, kMaxTid);\n-  ctx->thread_registry->DetachThread(tid);\n+  ctx->thread_registry->DetachThread(tid, thr);\n }\n \n void ThreadSetName(ThreadState *thr, const char *name) {"}, {"sha": "45bd2517837261384aa04228f929f126d44cc1c5", "filename": "libsanitizer/tsan/tsan_stack_trace.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,110 @@\n+//===-- tsan_stack_trace.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+//#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_stack_trace.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+\n+namespace __tsan {\n+\n+StackTrace::StackTrace()\n+    : n_()\n+    , s_()\n+    , c_() {\n+}\n+\n+StackTrace::StackTrace(uptr *buf, uptr cnt)\n+    : n_()\n+    , s_(buf)\n+    , c_(cnt) {\n+  CHECK_NE(buf, 0);\n+  CHECK_NE(cnt, 0);\n+}\n+\n+StackTrace::~StackTrace() {\n+  Reset();\n+}\n+\n+void StackTrace::Reset() {\n+  if (s_ && !c_) {\n+    CHECK_NE(n_, 0);\n+    internal_free(s_);\n+    s_ = 0;\n+  }\n+  n_ = 0;\n+}\n+\n+void StackTrace::Init(const uptr *pcs, uptr cnt) {\n+  Reset();\n+  if (cnt == 0)\n+    return;\n+  if (c_) {\n+    CHECK_NE(s_, 0);\n+    CHECK_LE(cnt, c_);\n+  } else {\n+    s_ = (uptr*)internal_alloc(MBlockStackTrace, cnt * sizeof(s_[0]));\n+  }\n+  n_ = cnt;\n+  internal_memcpy(s_, pcs, cnt * sizeof(s_[0]));\n+}\n+\n+void StackTrace::ObtainCurrent(ThreadState *thr, uptr toppc) {\n+  Reset();\n+  n_ = thr->shadow_stack_pos - thr->shadow_stack;\n+  if (n_ + !!toppc == 0)\n+    return;\n+  uptr start = 0;\n+  if (c_) {\n+    CHECK_NE(s_, 0);\n+    if (n_ + !!toppc > c_) {\n+      start = n_ - c_ + !!toppc;\n+      n_ = c_ - !!toppc;\n+    }\n+  } else {\n+    // Cap potentially huge stacks.\n+    if (n_ + !!toppc > kTraceStackSize) {\n+      start = n_ - kTraceStackSize + !!toppc;\n+      n_ = kTraceStackSize - !!toppc;\n+    }\n+    s_ = (uptr*)internal_alloc(MBlockStackTrace,\n+                               (n_ + !!toppc) * sizeof(s_[0]));\n+  }\n+  for (uptr i = 0; i < n_; i++)\n+    s_[i] = thr->shadow_stack[start + i];\n+  if (toppc) {\n+    s_[n_] = toppc;\n+    n_++;\n+  }\n+}\n+\n+void StackTrace::CopyFrom(const StackTrace& other) {\n+  Reset();\n+  Init(other.Begin(), other.Size());\n+}\n+\n+bool StackTrace::IsEmpty() const {\n+  return n_ == 0;\n+}\n+\n+uptr StackTrace::Size() const {\n+  return n_;\n+}\n+\n+uptr StackTrace::Get(uptr i) const {\n+  CHECK_LT(i, n_);\n+  return s_[i];\n+}\n+\n+const uptr *StackTrace::Begin() const {\n+  return s_;\n+}\n+\n+}  // namespace __tsan"}, {"sha": "ce0cb8859d2a61d639fd4ec13a22bdb64cb40c4b", "filename": "libsanitizer/tsan/tsan_stack_trace.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,52 @@\n+//===-- tsan_stack_trace.h --------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_STACK_TRACE_H\n+#define TSAN_STACK_TRACE_H\n+\n+//#include \"sanitizer_common/sanitizer_atomic.h\"\n+//#include \"sanitizer_common/sanitizer_common.h\"\n+//#include \"sanitizer_common/sanitizer_deadlock_detector_interface.h\"\n+#include \"tsan_defs.h\"\n+//#include \"tsan_clock.h\"\n+//#include \"tsan_mutex.h\"\n+//#include \"tsan_dense_alloc.h\"\n+\n+namespace __tsan {\n+\n+class StackTrace {\n+ public:\n+  StackTrace();\n+  // Initialized the object in \"static mode\",\n+  // in this mode it never calls malloc/free but uses the provided buffer.\n+  StackTrace(uptr *buf, uptr cnt);\n+  ~StackTrace();\n+  void Reset();\n+\n+  void Init(const uptr *pcs, uptr cnt);\n+  void ObtainCurrent(ThreadState *thr, uptr toppc);\n+  bool IsEmpty() const;\n+  uptr Size() const;\n+  uptr Get(uptr i) const;\n+  const uptr *Begin() const;\n+  void CopyFrom(const StackTrace& other);\n+\n+ private:\n+  uptr n_;\n+  uptr *s_;\n+  const uptr c_;\n+\n+  StackTrace(const StackTrace&);\n+  void operator = (const StackTrace&);\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_STACK_TRACE_H"}, {"sha": "cdb483585514631614599338e4b912a9cfdf32c0", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -35,6 +35,7 @@ void StatOutput(u64 *stat) {\n   name[StatMop4]                         = \"            size 4                \";\n   name[StatMop8]                         = \"            size 8                \";\n   name[StatMopSame]                      = \"  Including same                  \";\n+  name[StatMopIgnored]                   = \"  Including ignored               \";\n   name[StatMopRange]                     = \"  Including range                 \";\n   name[StatMopRodata]                    = \"  Including .rodata               \";\n   name[StatMopRangeRodata]               = \"  Including .rodata range         \";"}, {"sha": "132656f035f9d40afadf32888fc80277e6392a61", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -24,6 +24,7 @@ enum StatType {\n   StatMop4,\n   StatMop8,\n   StatMopSame,\n+  StatMopIgnored,\n   StatMopRange,\n   StatMopRodata,\n   StatMopRangeRodata,"}, {"sha": "6b42d3a67b83af8c12278e806c911ee2b3f4af7e", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 18, "deletions": 58, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -39,55 +39,16 @@ extern \"C\" const char *WEAK __tsan_default_suppressions() {\n \n namespace __tsan {\n \n-static SuppressionContext* g_ctx;\n-\n-static char *ReadFile(const char *filename) {\n-  if (filename == 0 || filename[0] == 0)\n-    return 0;\n-  InternalScopedBuffer<char> tmp(4*1024);\n-  if (filename[0] == '/' || GetPwd() == 0)\n-    internal_snprintf(tmp.data(), tmp.size(), \"%s\", filename);\n-  else\n-    internal_snprintf(tmp.data(), tmp.size(), \"%s/%s\", GetPwd(), filename);\n-  uptr openrv = OpenFile(tmp.data(), false);\n-  if (internal_iserror(openrv)) {\n-    Printf(\"ThreadSanitizer: failed to open suppressions file '%s'\\n\",\n-               tmp.data());\n-    Die();\n-  }\n-  fd_t fd = openrv;\n-  const uptr fsize = internal_filesize(fd);\n-  if (fsize == (uptr)-1) {\n-    Printf(\"ThreadSanitizer: failed to stat suppressions file '%s'\\n\",\n-               tmp.data());\n-    Die();\n-  }\n-  char *buf = (char*)internal_alloc(MBlockSuppression, fsize + 1);\n-  if (fsize != internal_read(fd, buf, fsize)) {\n-    Printf(\"ThreadSanitizer: failed to read suppressions file '%s'\\n\",\n-               tmp.data());\n-    Die();\n-  }\n-  internal_close(fd);\n-  buf[fsize] = 0;\n-  return buf;\n-}\n+static bool suppressions_inited = false;\n \n void InitializeSuppressions() {\n-  ALIGNED(64) static char placeholder_[sizeof(SuppressionContext)];\n-  g_ctx = new(placeholder_) SuppressionContext;\n-  const char *supp = ReadFile(flags()->suppressions);\n-  g_ctx->Parse(supp);\n+  CHECK(!suppressions_inited);\n+  SuppressionContext::InitIfNecessary();\n #ifndef TSAN_GO\n-  supp = __tsan_default_suppressions();\n-  g_ctx->Parse(supp);\n-  g_ctx->Parse(std_suppressions);\n+  SuppressionContext::Get()->Parse(__tsan_default_suppressions());\n+  SuppressionContext::Get()->Parse(std_suppressions);\n #endif\n-}\n-\n-SuppressionContext *GetSuppressionContext() {\n-  CHECK_NE(g_ctx, 0);\n-  return g_ctx;\n+  suppressions_inited = true;\n }\n \n SuppressionType conv(ReportType typ) {\n@@ -120,16 +81,17 @@ SuppressionType conv(ReportType typ) {\n }\n \n uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp) {\n-  CHECK(g_ctx);\n-  if (!g_ctx->SuppressionCount() || stack == 0) return 0;\n+  if (!SuppressionContext::Get()->SuppressionCount() || stack == 0 ||\n+      !stack->suppressable)\n+    return 0;\n   SuppressionType stype = conv(typ);\n   if (stype == SuppressionNone)\n     return 0;\n   Suppression *s;\n   for (const ReportStack *frame = stack; frame; frame = frame->next) {\n-    if (g_ctx->Match(frame->func, stype, &s) ||\n-        g_ctx->Match(frame->file, stype, &s) ||\n-        g_ctx->Match(frame->module, stype, &s)) {\n+    if (SuppressionContext::Get()->Match(frame->func, stype, &s) ||\n+        SuppressionContext::Get()->Match(frame->file, stype, &s) ||\n+        SuppressionContext::Get()->Match(frame->module, stype, &s)) {\n       DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", s->templ);\n       s->hit_count++;\n       *sp = s;\n@@ -140,17 +102,16 @@ uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp) {\n }\n \n uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp) {\n-  CHECK(g_ctx);\n-  if (!g_ctx->SuppressionCount() || loc == 0 ||\n-      loc->type != ReportLocationGlobal)\n+  if (!SuppressionContext::Get()->SuppressionCount() || loc == 0 ||\n+      loc->type != ReportLocationGlobal || !loc->suppressable)\n     return 0;\n   SuppressionType stype = conv(typ);\n   if (stype == SuppressionNone)\n     return 0;\n   Suppression *s;\n-  if (g_ctx->Match(loc->name, stype, &s) ||\n-      g_ctx->Match(loc->file, stype, &s) ||\n-      g_ctx->Match(loc->module, stype, &s)) {\n+  if (SuppressionContext::Get()->Match(loc->name, stype, &s) ||\n+      SuppressionContext::Get()->Match(loc->file, stype, &s) ||\n+      SuppressionContext::Get()->Match(loc->module, stype, &s)) {\n       DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", s->templ);\n       s->hit_count++;\n       *sp = s;\n@@ -160,9 +121,8 @@ uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp) {\n }\n \n void PrintMatchedSuppressions() {\n-  CHECK(g_ctx);\n   InternalMmapVector<Suppression *> matched(1);\n-  g_ctx->GetMatched(&matched);\n+  SuppressionContext::Get()->GetMatched(&matched);\n   if (!matched.size())\n     return;\n   int hit_count = 0;"}, {"sha": "e38d81ece85c7f19587ec24db9253a31b74f5926", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -20,7 +20,6 @@ void InitializeSuppressions();\n void PrintMatchedSuppressions();\n uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp);\n uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp);\n-SuppressionContext *GetSuppressionContext();\n \n }  // namespace __tsan\n "}, {"sha": "49ae3dffa47adcf1081f31dd17bc17d2d92430cd", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -109,7 +109,7 @@ ReportStack *SymbolizeCode(uptr addr) {\n   InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n   for (uptr i = 0; i < kMaxAddrFrames; i++)\n     new(&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num = Symbolizer::Get()->SymbolizePC(\n+  uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n       addr, addr_frames.data(), kMaxAddrFrames);\n   if (addr_frames_num == 0)\n     return NewReportStackEntry(addr);\n@@ -130,7 +130,7 @@ ReportStack *SymbolizeCode(uptr addr) {\n \n ReportLocation *SymbolizeData(uptr addr) {\n   DataInfo info;\n-  if (!Symbolizer::Get()->SymbolizeData(addr, &info))\n+  if (!Symbolizer::GetOrInit()->SymbolizeData(addr, &info))\n     return 0;\n   ReportLocation *ent = (ReportLocation*)internal_alloc(MBlockReportStack,\n                                                         sizeof(ReportLocation));\n@@ -146,7 +146,7 @@ ReportLocation *SymbolizeData(uptr addr) {\n }\n \n void SymbolizeFlush() {\n-  Symbolizer::Get()->Flush();\n+  Symbolizer::GetOrInit()->Flush();\n }\n \n }  // namespace __tsan"}, {"sha": "2209199ac483eeac5603234ce1dc14ab0928504c", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 167, "deletions": 253, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,293 +17,207 @@ namespace __tsan {\n \n void DDMutexInit(ThreadState *thr, uptr pc, SyncVar *s);\n \n-SyncVar::SyncVar(uptr addr, u64 uid)\n-  : mtx(MutexTypeSyncVar, StatMtxSyncVar)\n-  , addr(addr)\n-  , uid(uid)\n-  , creation_stack_id()\n-  , owner_tid(kInvalidTid)\n-  , last_lock()\n-  , recursion()\n-  , is_rw()\n-  , is_recursive()\n-  , is_broken()\n-  , is_linker_init() {\n+SyncVar::SyncVar()\n+    : mtx(MutexTypeSyncVar, StatMtxSyncVar) {\n+  Reset(0);\n+}\n+\n+void SyncVar::Init(ThreadState *thr, uptr pc, uptr addr, u64 uid) {\n+  this->addr = addr;\n+  this->uid = uid;\n+  this->next = 0;\n+\n+  creation_stack_id = 0;\n+  if (kCppMode)  // Go does not use them\n+    creation_stack_id = CurrentStackId(thr, pc);\n+  if (common_flags()->detect_deadlocks)\n+    DDMutexInit(thr, pc, this);\n+}\n+\n+void SyncVar::Reset(ThreadState *thr) {\n+  uid = 0;\n+  creation_stack_id = 0;\n+  owner_tid = kInvalidTid;\n+  last_lock = 0;\n+  recursion = 0;\n+  is_rw = 0;\n+  is_recursive = 0;\n+  is_broken = 0;\n+  is_linker_init = 0;\n+\n+  if (thr == 0) {\n+    CHECK_EQ(clock.size(), 0);\n+    CHECK_EQ(read_clock.size(), 0);\n+  } else {\n+    clock.Reset(&thr->clock_cache);\n+    read_clock.Reset(&thr->clock_cache);\n+  }\n }\n \n-SyncTab::Part::Part()\n-  : mtx(MutexTypeSyncTab, StatMtxSyncTab)\n-  , val() {\n+MetaMap::MetaMap() {\n+  atomic_store(&uid_gen_, 0, memory_order_relaxed);\n }\n \n-SyncTab::SyncTab() {\n+void MetaMap::AllocBlock(ThreadState *thr, uptr pc, uptr p, uptr sz) {\n+  u32 idx = block_alloc_.Alloc(&thr->block_cache);\n+  MBlock *b = block_alloc_.Map(idx);\n+  b->siz = sz;\n+  b->tid = thr->tid;\n+  b->stk = CurrentStackId(thr, pc);\n+  u32 *meta = MemToMeta(p);\n+  DCHECK_EQ(*meta, 0);\n+  *meta = idx | kFlagBlock;\n }\n \n-SyncTab::~SyncTab() {\n-  for (int i = 0; i < kPartCount; i++) {\n-    while (tab_[i].val) {\n-      SyncVar *tmp = tab_[i].val;\n-      tab_[i].val = tmp->next;\n-      DestroyAndFree(tmp);\n+uptr MetaMap::FreeBlock(ThreadState *thr, uptr pc, uptr p) {\n+  MBlock* b = GetBlock(p);\n+  if (b == 0)\n+    return 0;\n+  uptr sz = RoundUpTo(b->siz, kMetaShadowCell);\n+  FreeRange(thr, pc, p, sz);\n+  return sz;\n+}\n+\n+void MetaMap::FreeRange(ThreadState *thr, uptr pc, uptr p, uptr sz) {\n+  u32 *meta = MemToMeta(p);\n+  u32 *end = MemToMeta(p + sz);\n+  if (end == meta)\n+    end++;\n+  for (; meta < end; meta++) {\n+    u32 idx = *meta;\n+    *meta = 0;\n+    for (;;) {\n+      if (idx == 0)\n+        break;\n+      if (idx & kFlagBlock) {\n+        block_alloc_.Free(&thr->block_cache, idx & ~kFlagMask);\n+        break;\n+      } else if (idx & kFlagSync) {\n+        DCHECK(idx & kFlagSync);\n+        SyncVar *s = sync_alloc_.Map(idx & ~kFlagMask);\n+        u32 next = s->next;\n+        s->Reset(thr);\n+        sync_alloc_.Free(&thr->sync_cache, idx & ~kFlagMask);\n+        idx = next;\n+      } else {\n+        CHECK(0);\n+      }\n     }\n   }\n }\n \n-SyncVar* SyncTab::GetOrCreateAndLock(ThreadState *thr, uptr pc,\n-                                     uptr addr, bool write_lock) {\n-  return GetAndLock(thr, pc, addr, write_lock, true);\n+MBlock* MetaMap::GetBlock(uptr p) {\n+  u32 *meta = MemToMeta(p);\n+  u32 idx = *meta;\n+  for (;;) {\n+    if (idx == 0)\n+      return 0;\n+    if (idx & kFlagBlock)\n+      return block_alloc_.Map(idx & ~kFlagMask);\n+    DCHECK(idx & kFlagSync);\n+    SyncVar * s = sync_alloc_.Map(idx & ~kFlagMask);\n+    idx = s->next;\n+  }\n }\n \n-SyncVar* SyncTab::GetIfExistsAndLock(uptr addr, bool write_lock) {\n-  return GetAndLock(0, 0, addr, write_lock, false);\n+SyncVar* MetaMap::GetOrCreateAndLock(ThreadState *thr, uptr pc,\n+                              uptr addr, bool write_lock) {\n+  return GetAndLock(thr, pc, addr, write_lock, true);\n }\n \n-SyncVar* SyncTab::Create(ThreadState *thr, uptr pc, uptr addr) {\n-  StatInc(thr, StatSyncCreated);\n-  void *mem = internal_alloc(MBlockSync, sizeof(SyncVar));\n-  const u64 uid = atomic_fetch_add(&uid_gen_, 1, memory_order_relaxed);\n-  SyncVar *res = new(mem) SyncVar(addr, uid);\n-  res->creation_stack_id = 0;\n-  if (!kGoMode)  // Go does not use them\n-    res->creation_stack_id = CurrentStackId(thr, pc);\n-  if (flags()->detect_deadlocks)\n-    DDMutexInit(thr, pc, res);\n-  return res;\n+SyncVar* MetaMap::GetIfExistsAndLock(uptr addr) {\n+  return GetAndLock(0, 0, addr, true, false);\n }\n \n-SyncVar* SyncTab::GetAndLock(ThreadState *thr, uptr pc,\n+SyncVar* MetaMap::GetAndLock(ThreadState *thr, uptr pc,\n                              uptr addr, bool write_lock, bool create) {\n-#ifndef TSAN_GO\n-  {  // NOLINT\n-    SyncVar *res = GetJavaSync(thr, pc, addr, write_lock, create);\n-    if (res)\n-      return res;\n-  }\n-\n-  // Here we ask only PrimaryAllocator, because\n-  // SecondaryAllocator::PointerIsMine() is slow and we have fallback on\n-  // the hashmap anyway.\n-  if (PrimaryAllocator::PointerIsMine((void*)addr)) {\n-    MBlock *b = user_mblock(thr, (void*)addr);\n-    CHECK_NE(b, 0);\n-    MBlock::ScopedLock l(b);\n-    SyncVar *res = 0;\n-    for (res = b->ListHead(); res; res = res->next) {\n-      if (res->addr == addr)\n+  u32 *meta = MemToMeta(addr);\n+  u32 idx0 = *meta;\n+  u32 myidx = 0;\n+  SyncVar *mys = 0;\n+  for (;;) {\n+    u32 idx = idx0;\n+    for (;;) {\n+      if (idx == 0)\n         break;\n-    }\n-    if (res == 0) {\n-      if (!create)\n-        return 0;\n-      res = Create(thr, pc, addr);\n-      b->ListPush(res);\n-    }\n-    if (write_lock)\n-      res->mtx.Lock();\n-    else\n-      res->mtx.ReadLock();\n-    return res;\n-  }\n-#endif\n-\n-  Part *p = &tab_[PartIdx(addr)];\n-  {\n-    ReadLock l(&p->mtx);\n-    for (SyncVar *res = p->val; res; res = res->next) {\n-      if (res->addr == addr) {\n+      if (idx & kFlagBlock)\n+        break;\n+      DCHECK(idx & kFlagSync);\n+      SyncVar * s = sync_alloc_.Map(idx & ~kFlagMask);\n+      if (s->addr == addr) {\n+        if (myidx != 0) {\n+          mys->Reset(thr);\n+          sync_alloc_.Free(&thr->sync_cache, myidx);\n+        }\n         if (write_lock)\n-          res->mtx.Lock();\n+          s->mtx.Lock();\n         else\n-          res->mtx.ReadLock();\n-        return res;\n+          s->mtx.ReadLock();\n+        return s;\n       }\n+      idx = s->next;\n     }\n-  }\n-  if (!create)\n-    return 0;\n-  {\n-    Lock l(&p->mtx);\n-    SyncVar *res = p->val;\n-    for (; res; res = res->next) {\n-      if (res->addr == addr)\n-        break;\n-    }\n-    if (res == 0) {\n-      res = Create(thr, pc, addr);\n-      res->next = p->val;\n-      p->val = res;\n+    if (!create)\n+      return 0;\n+    if (*meta != idx0) {\n+      idx0 = *meta;\n+      continue;\n     }\n-    if (write_lock)\n-      res->mtx.Lock();\n-    else\n-      res->mtx.ReadLock();\n-    return res;\n-  }\n-}\n \n-SyncVar* SyncTab::GetAndRemove(ThreadState *thr, uptr pc, uptr addr) {\n-#ifndef TSAN_GO\n-  {  // NOLINT\n-    SyncVar *res = GetAndRemoveJavaSync(thr, pc, addr);\n-    if (res)\n-      return res;\n-  }\n-  if (PrimaryAllocator::PointerIsMine((void*)addr)) {\n-    MBlock *b = user_mblock(thr, (void*)addr);\n-    CHECK_NE(b, 0);\n-    SyncVar *res = 0;\n-    {\n-      MBlock::ScopedLock l(b);\n-      res = b->ListHead();\n-      if (res) {\n-        if (res->addr == addr) {\n-          if (res->is_linker_init)\n-            return 0;\n-          b->ListPop();\n-        } else {\n-          SyncVar **prev = &res->next;\n-          res = *prev;\n-          while (res) {\n-            if (res->addr == addr) {\n-              if (res->is_linker_init)\n-                return 0;\n-              *prev = res->next;\n-              break;\n-            }\n-            prev = &res->next;\n-            res = *prev;\n-          }\n-        }\n-        if (res) {\n-          StatInc(thr, StatSyncDestroyed);\n-          res->mtx.Lock();\n-          res->mtx.Unlock();\n-        }\n-      }\n+    if (myidx == 0) {\n+      const u64 uid = atomic_fetch_add(&uid_gen_, 1, memory_order_relaxed);\n+      myidx = sync_alloc_.Alloc(&thr->sync_cache);\n+      mys = sync_alloc_.Map(myidx);\n+      mys->Init(thr, pc, addr, uid);\n     }\n-    return res;\n-  }\n-#endif\n-\n-  Part *p = &tab_[PartIdx(addr)];\n-  SyncVar *res = 0;\n-  {\n-    Lock l(&p->mtx);\n-    SyncVar **prev = &p->val;\n-    res = *prev;\n-    while (res) {\n-      if (res->addr == addr) {\n-        if (res->is_linker_init)\n-          return 0;\n-        *prev = res->next;\n-        break;\n-      }\n-      prev = &res->next;\n-      res = *prev;\n+    mys->next = idx0;\n+    if (atomic_compare_exchange_strong((atomic_uint32_t*)meta, &idx0,\n+        myidx | kFlagSync, memory_order_release)) {\n+      if (write_lock)\n+        mys->mtx.Lock();\n+      else\n+        mys->mtx.ReadLock();\n+      return mys;\n     }\n   }\n-  if (res) {\n-    StatInc(thr, StatSyncDestroyed);\n-    res->mtx.Lock();\n-    res->mtx.Unlock();\n-  }\n-  return res;\n-}\n-\n-int SyncTab::PartIdx(uptr addr) {\n-  return (addr >> 3) % kPartCount;\n-}\n-\n-StackTrace::StackTrace()\n-    : n_()\n-    , s_()\n-    , c_() {\n }\n \n-StackTrace::StackTrace(uptr *buf, uptr cnt)\n-    : n_()\n-    , s_(buf)\n-    , c_(cnt) {\n-  CHECK_NE(buf, 0);\n-  CHECK_NE(cnt, 0);\n-}\n-\n-StackTrace::~StackTrace() {\n-  Reset();\n-}\n-\n-void StackTrace::Reset() {\n-  if (s_ && !c_) {\n-    CHECK_NE(n_, 0);\n-    internal_free(s_);\n-    s_ = 0;\n-  }\n-  n_ = 0;\n-}\n-\n-void StackTrace::Init(const uptr *pcs, uptr cnt) {\n-  Reset();\n-  if (cnt == 0)\n-    return;\n-  if (c_) {\n-    CHECK_NE(s_, 0);\n-    CHECK_LE(cnt, c_);\n-  } else {\n-    s_ = (uptr*)internal_alloc(MBlockStackTrace, cnt * sizeof(s_[0]));\n+void MetaMap::MoveMemory(uptr src, uptr dst, uptr sz) {\n+  // src and dst can overlap,\n+  // there are no concurrent accesses to the regions (e.g. stop-the-world).\n+  CHECK_NE(src, dst);\n+  CHECK_NE(sz, 0);\n+  uptr diff = dst - src;\n+  u32 *src_meta = MemToMeta(src);\n+  u32 *dst_meta = MemToMeta(dst);\n+  u32 *src_meta_end = MemToMeta(src + sz);\n+  uptr inc = 1;\n+  if (dst > src) {\n+    src_meta = MemToMeta(src + sz) - 1;\n+    dst_meta = MemToMeta(dst + sz) - 1;\n+    src_meta_end = MemToMeta(src) - 1;\n+    inc = -1;\n   }\n-  n_ = cnt;\n-  internal_memcpy(s_, pcs, cnt * sizeof(s_[0]));\n-}\n-\n-void StackTrace::ObtainCurrent(ThreadState *thr, uptr toppc) {\n-  Reset();\n-  n_ = thr->shadow_stack_pos - thr->shadow_stack;\n-  if (n_ + !!toppc == 0)\n-    return;\n-  uptr start = 0;\n-  if (c_) {\n-    CHECK_NE(s_, 0);\n-    if (n_ + !!toppc > c_) {\n-      start = n_ - c_ + !!toppc;\n-      n_ = c_ - !!toppc;\n-    }\n-  } else {\n-    // Cap potentially huge stacks.\n-    if (n_ + !!toppc > kTraceStackSize) {\n-      start = n_ - kTraceStackSize + !!toppc;\n-      n_ = kTraceStackSize - !!toppc;\n+  for (; src_meta != src_meta_end; src_meta += inc, dst_meta += inc) {\n+    CHECK_EQ(*dst_meta, 0);\n+    u32 idx = *src_meta;\n+    *src_meta = 0;\n+    *dst_meta = idx;\n+    // Patch the addresses in sync objects.\n+    while (idx != 0) {\n+      if (idx & kFlagBlock)\n+        break;\n+      CHECK(idx & kFlagSync);\n+      SyncVar *s = sync_alloc_.Map(idx & ~kFlagMask);\n+      s->addr += diff;\n+      idx = s->next;\n     }\n-    s_ = (uptr*)internal_alloc(MBlockStackTrace,\n-                               (n_ + !!toppc) * sizeof(s_[0]));\n-  }\n-  for (uptr i = 0; i < n_; i++)\n-    s_[i] = thr->shadow_stack[start + i];\n-  if (toppc) {\n-    s_[n_] = toppc;\n-    n_++;\n   }\n }\n \n-void StackTrace::CopyFrom(const StackTrace& other) {\n-  Reset();\n-  Init(other.Begin(), other.Size());\n-}\n-\n-bool StackTrace::IsEmpty() const {\n-  return n_ == 0;\n-}\n-\n-uptr StackTrace::Size() const {\n-  return n_;\n-}\n-\n-uptr StackTrace::Get(uptr i) const {\n-  CHECK_LT(i, n_);\n-  return s_[i];\n-}\n-\n-const uptr *StackTrace::Begin() const {\n-  return s_;\n+void MetaMap::OnThreadIdle(ThreadState *thr) {\n+  block_alloc_.FlushCache(&thr->block_cache);\n+  sync_alloc_.FlushCache(&thr->sync_cache);\n }\n \n }  // namespace __tsan"}, {"sha": "6ed3715ee0a53cb1e8c6c951ba0b94a0bccf5805", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 32, "deletions": 55, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -14,46 +14,21 @@\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_deadlock_detector_interface.h\"\n-#include \"tsan_clock.h\"\n #include \"tsan_defs.h\"\n+#include \"tsan_clock.h\"\n #include \"tsan_mutex.h\"\n+#include \"tsan_dense_alloc.h\"\n \n namespace __tsan {\n \n-class StackTrace {\n- public:\n-  StackTrace();\n-  // Initialized the object in \"static mode\",\n-  // in this mode it never calls malloc/free but uses the provided buffer.\n-  StackTrace(uptr *buf, uptr cnt);\n-  ~StackTrace();\n-  void Reset();\n-\n-  void Init(const uptr *pcs, uptr cnt);\n-  void ObtainCurrent(ThreadState *thr, uptr toppc);\n-  bool IsEmpty() const;\n-  uptr Size() const;\n-  uptr Get(uptr i) const;\n-  const uptr *Begin() const;\n-  void CopyFrom(const StackTrace& other);\n-\n- private:\n-  uptr n_;\n-  uptr *s_;\n-  const uptr c_;\n-\n-  StackTrace(const StackTrace&);\n-  void operator = (const StackTrace&);\n-};\n-\n struct SyncVar {\n-  explicit SyncVar(uptr addr, u64 uid);\n+  SyncVar();\n \n   static const int kInvalidTid = -1;\n \n+  uptr addr;  // overwritten by DenseSlabAlloc freelist\n   Mutex mtx;\n-  uptr addr;\n-  const u64 uid;  // Globally unique id.\n+  u64 uid;  // Globally unique id.\n   u32 creation_stack_id;\n   int owner_tid;  // Set only by exclusive owners.\n   u64 last_lock;\n@@ -62,13 +37,16 @@ struct SyncVar {\n   bool is_recursive;\n   bool is_broken;\n   bool is_linker_init;\n-  SyncVar *next;  // In SyncTab hashtable.\n+  u32 next;  // in MetaMap\n   DDMutex dd;\n   SyncClock read_clock;  // Used for rw mutexes only.\n   // The clock is placed last, so that it is situated on a different cache line\n   // with the mtx. This reduces contention for hot sync objects.\n   SyncClock clock;\n \n+  void Init(ThreadState *thr, uptr pc, uptr addr, u64 uid);\n+  void Reset(ThreadState *thr);\n+\n   u64 GetId() const {\n     // 47 lsb is addr, then 14 bits is low part of uid, then 3 zero bits.\n     return GetLsb((u64)addr | (uid << 47), 61);\n@@ -83,40 +61,39 @@ struct SyncVar {\n   }\n };\n \n-class SyncTab {\n+/* MetaMap allows to map arbitrary user pointers onto various descriptors.\n+   Currently it maps pointers to heap block descriptors and sync var descs.\n+   It uses 1/2 direct shadow, see tsan_platform.h.\n+*/\n+class MetaMap {\n  public:\n-  SyncTab();\n-  ~SyncTab();\n+  MetaMap();\n+\n+  void AllocBlock(ThreadState *thr, uptr pc, uptr p, uptr sz);\n+  uptr FreeBlock(ThreadState *thr, uptr pc, uptr p);\n+  void FreeRange(ThreadState *thr, uptr pc, uptr p, uptr sz);\n+  MBlock* GetBlock(uptr p);\n \n   SyncVar* GetOrCreateAndLock(ThreadState *thr, uptr pc,\n                               uptr addr, bool write_lock);\n-  SyncVar* GetIfExistsAndLock(uptr addr, bool write_lock);\n+  SyncVar* GetIfExistsAndLock(uptr addr);\n \n-  // If the SyncVar does not exist, returns 0.\n-  SyncVar* GetAndRemove(ThreadState *thr, uptr pc, uptr addr);\n+  void MoveMemory(uptr src, uptr dst, uptr sz);\n \n-  SyncVar* Create(ThreadState *thr, uptr pc, uptr addr);\n+  void OnThreadIdle(ThreadState *thr);\n \n  private:\n-  struct Part {\n-    Mutex mtx;\n-    SyncVar *val;\n-    char pad[kCacheLineSize - sizeof(Mutex) - sizeof(SyncVar*)];  // NOLINT\n-    Part();\n-  };\n-\n-  // FIXME: Implement something more sane.\n-  static const int kPartCount = 1009;\n-  Part tab_[kPartCount];\n+  static const u32 kFlagMask  = 3 << 30;\n+  static const u32 kFlagBlock = 1 << 30;\n+  static const u32 kFlagSync  = 2 << 30;\n+  typedef DenseSlabAlloc<MBlock, 1<<16, 1<<12> BlockAlloc;\n+  typedef DenseSlabAlloc<SyncVar, 1<<16, 1<<10> SyncAlloc;\n+  BlockAlloc block_alloc_;\n+  SyncAlloc sync_alloc_;\n   atomic_uint64_t uid_gen_;\n \n-  int PartIdx(uptr addr);\n-\n-  SyncVar* GetAndLock(ThreadState *thr, uptr pc,\n-                      uptr addr, bool write_lock, bool create);\n-\n-  SyncTab(const SyncTab&);  // Not implemented.\n-  void operator = (const SyncTab&);  // Not implemented.\n+  SyncVar* GetAndLock(ThreadState *thr, uptr pc, uptr addr, bool write_lock,\n+                      bool create);\n };\n \n }  // namespace __tsan"}, {"sha": "af140686f5d43d7df9d8bf53b05a8db3934c89fb", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -13,7 +13,7 @@\n \n #include \"tsan_defs.h\"\n #include \"tsan_mutex.h\"\n-#include \"tsan_sync.h\"\n+#include \"tsan_stack_trace.h\"\n #include \"tsan_mutexset.h\"\n \n namespace __tsan {"}, {"sha": "91def7bb1e845608cd4142c6cb0133f59c85d26f", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -14,8 +14,7 @@\n do {\n   StatInc(thr, StatShadowProcessed);\n   const unsigned kAccessSize = 1 << kAccessSizeLog;\n-  unsigned off = cur.ComputeSearchOffset();\n-  u64 *sp = &shadow_mem[(idx + off) % kShadowCnt];\n+  u64 *sp = &shadow_mem[idx];\n   old = LoadShadow(sp);\n   if (old.IsZero()) {\n     StatInc(thr, StatShadowZero);\n@@ -31,16 +30,6 @@ do {\n     // same thread?\n     if (Shadow::TidsAreEqual(old, cur)) {\n       StatInc(thr, StatShadowSameThread);\n-      if (OldIsInSameSynchEpoch(old, thr)) {\n-        if (old.IsRWNotWeaker(kAccessIsWrite, kIsAtomic)) {\n-          // found a slot that holds effectively the same info\n-          // (that is, same tid, same sync epoch and same size)\n-          StatInc(thr, StatMopSame);\n-          return;\n-        }\n-        StoreIfNotYetStored(sp, &store_word);\n-        break;\n-      }\n       if (old.IsRWWeakerOrEqual(kAccessIsWrite, kIsAtomic))\n         StoreIfNotYetStored(sp, &store_word);\n       break;"}, {"sha": "c0485513ee27445cf62a37774d8d0c4090172a2b", "filename": "libsanitizer/tsan/tsan_vector.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Ftsan%2Ftsan_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_vector.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -76,6 +76,10 @@ class Vector {\n   }\n \n   void Resize(uptr size) {\n+    if (size == 0) {\n+      end_ = begin_;\n+      return;\n+    }\n     uptr old_size = Size();\n     EnsureSize(size);\n     if (old_size < size) {\n@@ -98,7 +102,7 @@ class Vector {\n       return;\n     }\n     uptr cap0 = last_ - begin_;\n-    uptr cap = 2 * cap0;\n+    uptr cap = cap0 * 5 / 4;  // 25% growth\n     if (cap == 0)\n       cap = 16;\n     if (cap < size)"}, {"sha": "d010b91681deb565d290da7ee210d0dd44306a61", "filename": "libsanitizer/ubsan/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.am?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,8 +12,10 @@ toolexeclib_LTLIBRARIES = libubsan.la\n \n ubsan_files = \\\n \tubsan_diag.cc \\\n+\tubsan_flags.cc \\\n \tubsan_handlers.cc \\\n \tubsan_handlers_cxx.cc \\\n+\tubsan_init.cc \\\n \tubsan_type_hash.cc \\\n \tubsan_value.cc\n "}, {"sha": "102eff6138eb3fb68d22286e5db5a041bfc39615", "filename": "libsanitizer/ubsan/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -84,8 +84,9 @@ am__DEPENDENCIES_1 =\n libubsan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(am__append_1) $(am__append_2) $(am__DEPENDENCIES_1)\n-am__objects_1 = ubsan_diag.lo ubsan_handlers.lo ubsan_handlers_cxx.lo \\\n-\tubsan_type_hash.lo ubsan_value.lo\n+am__objects_1 = ubsan_diag.lo ubsan_flags.lo ubsan_handlers.lo \\\n+\tubsan_handlers_cxx.lo ubsan_init.lo ubsan_type_hash.lo \\\n+\tubsan_value.lo\n am_libubsan_la_OBJECTS = $(am__objects_1)\n libubsan_la_OBJECTS = $(am_libubsan_la_OBJECTS)\n libubsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -260,8 +261,10 @@ ACLOCAL_AMFLAGS = -I m4\n toolexeclib_LTLIBRARIES = libubsan.la\n ubsan_files = \\\n \tubsan_diag.cc \\\n+\tubsan_flags.cc \\\n \tubsan_handlers.cc \\\n \tubsan_handlers_cxx.cc \\\n+\tubsan_init.cc \\\n \tubsan_type_hash.cc \\\n \tubsan_value.cc\n \n@@ -385,8 +388,10 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_diag.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_handlers.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_handlers_cxx.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_init.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_type_hash.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ubsan_value.Plo@am__quote@\n "}, {"sha": "828127ab84d95b5e711acdd73aef834ad2185ffb", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 98, "deletions": 35, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -10,30 +10,57 @@\n //===----------------------------------------------------------------------===//\n \n #include \"ubsan_diag.h\"\n-#include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_flags.h\"\n-#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"ubsan_init.h\"\n+#include \"ubsan_flags.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include <stdio.h>\n \n using namespace __ubsan;\n \n-static void InitializeSanitizerCommon() {\n-  static StaticSpinMutex init_mu;\n-  SpinMutexLock l(&init_mu);\n-  static bool initialized;\n-  if (initialized)\n-   return;\n-  if (0 == internal_strcmp(SanitizerToolName, \"SanitizerTool\")) {\n-    // UBSan is run in a standalone mode. Initialize it now.\n-    SanitizerToolName = \"UndefinedBehaviorSanitizer\";\n-    CommonFlags *cf = common_flags();\n-    SetCommonFlagsDefaults(cf);\n-    cf->print_summary = false;\n+static void MaybePrintStackTrace(uptr pc, uptr bp) {\n+  // We assume that flags are already parsed: InitIfNecessary\n+  // will definitely be called when we print the first diagnostics message.\n+  if (!flags()->print_stacktrace)\n+    return;\n+  // We can only use slow unwind, as we don't have any information about stack\n+  // top/bottom.\n+  // FIXME: It's better to respect \"fast_unwind_on_fatal\" runtime flag and\n+  // fetch stack top/bottom information if we have it (e.g. if we're running\n+  // under ASan).\n+  if (StackTrace::WillUseFastUnwind(false))\n+    return;\n+  StackTrace stack;\n+  stack.Unwind(kStackTraceMax, pc, bp, 0, 0, 0, false);\n+  stack.Print();\n+}\n+\n+static void MaybeReportErrorSummary(Location Loc) {\n+  if (!common_flags()->print_summary)\n+    return;\n+  // Don't try to unwind the stack trace in UBSan summaries: just use the\n+  // provided location.\n+  if (Loc.isSourceLocation()) {\n+    SourceLocation SLoc = Loc.getSourceLocation();\n+    if (!SLoc.isInvalid()) {\n+      ReportErrorSummary(\"runtime-error\", SLoc.getFilename(), SLoc.getLine(),\n+                         \"\");\n+      return;\n+    }\n   }\n-  initialized = true;\n+  ReportErrorSummary(\"runtime-error\");\n+}\n+\n+namespace {\n+class Decorator : public SanitizerCommonDecorator {\n+ public:\n+  Decorator() : SanitizerCommonDecorator() {}\n+  const char *Highlight() const { return Green(); }\n+  const char *EndHighlight() const { return Default(); }\n+  const char *Note() const { return Black(); }\n+  const char *EndNote() const { return Default(); }\n+};\n }\n \n Location __ubsan::getCallerLocation(uptr CallerLoc) {\n@@ -47,12 +74,11 @@ Location __ubsan::getCallerLocation(uptr CallerLoc) {\n Location __ubsan::getFunctionLocation(uptr Loc, const char **FName) {\n   if (!Loc)\n     return Location();\n-  // FIXME: We may need to run initialization earlier.\n-  InitializeSanitizerCommon();\n+  InitIfNecessary();\n \n   AddressInfo Info;\n-  if (!Symbolizer::GetOrInit()->SymbolizePC(Loc, &Info, 1) ||\n-      !Info.module || !*Info.module)\n+  if (!Symbolizer::GetOrInit()->SymbolizePC(Loc, &Info, 1) || !Info.module ||\n+      !*Info.module)\n     return Location(Loc);\n \n   if (FName && Info.function)\n@@ -181,36 +207,49 @@ static Range *upperBound(MemoryLocation Loc, Range *Ranges,\n   return Best;\n }\n \n+static inline uptr subtractNoOverflow(uptr LHS, uptr RHS) {\n+  return (LHS < RHS) ? 0 : LHS - RHS;\n+}\n+\n+static inline uptr addNoOverflow(uptr LHS, uptr RHS) {\n+  const uptr Limit = (uptr)-1;\n+  return (LHS > Limit - RHS) ? Limit : LHS + RHS;\n+}\n+\n /// Render a snippet of the address space near a location.\n-static void renderMemorySnippet(const __sanitizer::AnsiColorDecorator &Decor,\n-                                MemoryLocation Loc,\n+static void renderMemorySnippet(const Decorator &Decor, MemoryLocation Loc,\n                                 Range *Ranges, unsigned NumRanges,\n                                 const Diag::Arg *Args) {\n-  const unsigned BytesToShow = 32;\n-  const unsigned MinBytesNearLoc = 4;\n-\n   // Show at least the 8 bytes surrounding Loc.\n-  MemoryLocation Min = Loc - MinBytesNearLoc, Max = Loc + MinBytesNearLoc;\n+  const unsigned MinBytesNearLoc = 4;\n+  MemoryLocation Min = subtractNoOverflow(Loc, MinBytesNearLoc);\n+  MemoryLocation Max = addNoOverflow(Loc, MinBytesNearLoc);\n+  MemoryLocation OrigMin = Min;\n   for (unsigned I = 0; I < NumRanges; ++I) {\n     Min = __sanitizer::Min(Ranges[I].getStart().getMemoryLocation(), Min);\n     Max = __sanitizer::Max(Ranges[I].getEnd().getMemoryLocation(), Max);\n   }\n \n   // If we have too many interesting bytes, prefer to show bytes after Loc.\n+  const unsigned BytesToShow = 32;\n   if (Max - Min > BytesToShow)\n-    Min = __sanitizer::Min(Max - BytesToShow, Loc - MinBytesNearLoc);\n-  Max = Min + BytesToShow;\n+    Min = __sanitizer::Min(Max - BytesToShow, OrigMin);\n+  Max = addNoOverflow(Min, BytesToShow);\n+\n+  if (!IsAccessibleMemoryRange(Min, Max - Min)) {\n+    Printf(\"<memory cannot be printed>\\n\");\n+    return;\n+  }\n \n   // Emit data.\n   for (uptr P = Min; P != Max; ++P) {\n-    // FIXME: Check that the address is readable before printing it.\n     unsigned char C = *reinterpret_cast<const unsigned char*>(P);\n     Printf(\"%s%02x\", (P % 8 == 0) ? \"  \" : \" \", C);\n   }\n   Printf(\"\\n\");\n \n   // Emit highlights.\n-  Printf(Decor.Green());\n+  Printf(Decor.Highlight());\n   Range *InRange = upperBound(Min, Ranges, NumRanges);\n   for (uptr P = Min; P != Max; ++P) {\n     char Pad = ' ', Byte = ' ';\n@@ -225,7 +264,7 @@ static void renderMemorySnippet(const __sanitizer::AnsiColorDecorator &Decor,\n     char Buffer[] = { Pad, Pad, P == Loc ? '^' : Byte, Byte, 0 };\n     Printf((P % 8 == 0) ? Buffer : &Buffer[1]);\n   }\n-  Printf(\"%s\\n\", Decor.Default());\n+  Printf(\"%s\\n\", Decor.EndHighlight());\n \n   // Go over the line again, and print names for the ranges.\n   InRange = 0;\n@@ -263,20 +302,21 @@ static void renderMemorySnippet(const __sanitizer::AnsiColorDecorator &Decor,\n }\n \n Diag::~Diag() {\n-  __sanitizer::AnsiColorDecorator Decor(PrintsToTty());\n-  SpinMutexLock l(&CommonSanitizerReportMutex);\n+  // All diagnostics should be printed under report mutex.\n+  CommonSanitizerReportMutex.CheckLocked();\n+  Decorator Decor;\n   Printf(Decor.Bold());\n \n   renderLocation(Loc);\n \n   switch (Level) {\n   case DL_Error:\n     Printf(\"%s runtime error: %s%s\",\n-           Decor.Red(), Decor.Default(), Decor.Bold());\n+           Decor.Warning(), Decor.EndWarning(), Decor.Bold());\n     break;\n \n   case DL_Note:\n-    Printf(\"%s note: %s\", Decor.Black(), Decor.Default());\n+    Printf(\"%s note: %s\", Decor.Note(), Decor.EndNote());\n     break;\n   }\n \n@@ -288,3 +328,26 @@ Diag::~Diag() {\n     renderMemorySnippet(Decor, Loc.getMemoryLocation(), Ranges,\n                         NumRanges, Args);\n }\n+\n+ScopedReport::ScopedReport(ReportOptions Opts, Location SummaryLoc)\n+    : Opts(Opts), SummaryLoc(SummaryLoc) {\n+  InitIfNecessary();\n+  CommonSanitizerReportMutex.Lock();\n+}\n+\n+ScopedReport::~ScopedReport() {\n+  MaybePrintStackTrace(Opts.pc, Opts.bp);\n+  MaybeReportErrorSummary(SummaryLoc);\n+  CommonSanitizerReportMutex.Unlock();\n+  if (Opts.DieAfterReport || flags()->halt_on_error)\n+    Die();\n+}\n+\n+bool __ubsan::MatchSuppression(const char *Str, SuppressionType Type) {\n+  Suppression *s;\n+  // If .preinit_array is not used, it is possible that the UBSan runtime is not\n+  // initialized.\n+  if (!SANITIZER_CAN_USE_PREINIT_ARRAY)\n+    InitIfNecessary();\n+  return SuppressionContext::Get()->Match(Str, Type, &s);\n+}"}, {"sha": "fbb3f1ff9d4f80a12fd4ecf243e0be9424cf9d5a", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -12,6 +12,8 @@\n #define UBSAN_DIAG_H\n \n #include \"ubsan_value.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_suppressions.h\"\n \n namespace __ubsan {\n \n@@ -201,6 +203,33 @@ class Diag {\n   Diag &operator<<(const Range &R) { return AddRange(R); }\n };\n \n+struct ReportOptions {\n+  /// If DieAfterReport is specified, UBSan will terminate the program after the\n+  /// report is printed.\n+  bool DieAfterReport;\n+  /// pc/bp are used to unwind the stack trace.\n+  uptr pc;\n+  uptr bp;\n+};\n+\n+#define GET_REPORT_OPTIONS(die_after_report) \\\n+    GET_CALLER_PC_BP; \\\n+    ReportOptions Opts = {die_after_report, pc, bp}\n+\n+/// \\brief Instantiate this class before printing diagnostics in the error\n+/// report. This class ensures that reports from different threads and from\n+/// different sanitizers won't be mixed.\n+class ScopedReport {\n+  ReportOptions Opts;\n+  Location SummaryLoc;\n+\n+public:\n+  ScopedReport(ReportOptions Opts, Location SummaryLoc);\n+  ~ScopedReport();\n+};\n+\n+bool MatchSuppression(const char *Str, SuppressionType Type);\n+\n } // namespace __ubsan\n \n #endif // UBSAN_DIAG_H"}, {"sha": "9645a8572608704f4b954bd4ac32754c04b60850", "filename": "libsanitizer/ubsan/ubsan_flags.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,61 @@\n+//===-- ubsan_flags.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Runtime flags for UndefinedBehaviorSanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_flags.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+\n+namespace __ubsan {\n+\n+static const char *MaybeCallUbsanDefaultOptions() {\n+  return (&__ubsan_default_options) ? __ubsan_default_options() : \"\";\n+}\n+\n+void InitializeCommonFlags() {\n+  CommonFlags *cf = common_flags();\n+  SetCommonFlagsDefaults(cf);\n+  cf->print_summary = false;\n+  // Override from user-specified string.\n+  ParseCommonFlagsFromString(cf, MaybeCallUbsanDefaultOptions());\n+  // Override from environment variable.\n+  ParseCommonFlagsFromString(cf, GetEnv(\"UBSAN_OPTIONS\"));\n+}\n+\n+Flags ubsan_flags;\n+\n+static void ParseFlagsFromString(Flags *f, const char *str) {\n+  if (!str)\n+    return;\n+  ParseFlag(str, &f->halt_on_error, \"halt_on_error\",\n+            \"Crash the program after printing the first error report\");\n+  ParseFlag(str, &f->print_stacktrace, \"print_stacktrace\",\n+            \"Include full stacktrace into an error report\");\n+}\n+\n+void InitializeFlags() {\n+  Flags *f = flags();\n+  // Default values.\n+  f->halt_on_error = false;\n+  f->print_stacktrace = false;\n+  // Override from user-specified string.\n+  ParseFlagsFromString(f, MaybeCallUbsanDefaultOptions());\n+  // Override from environment variable.\n+  ParseFlagsFromString(f, GetEnv(\"UBSAN_OPTIONS\"));\n+}\n+\n+}  // namespace __ubsan\n+\n+#if !SANITIZER_SUPPORTS_WEAK_HOOKS\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__ubsan_default_options() { return \"\"; }\n+}  // extern \"C\"\n+#endif"}, {"sha": "00be9b004f43117594f5f74cb04ff08b476b0cf6", "filename": "libsanitizer/ubsan/ubsan_flags.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,38 @@\n+//===-- ubsan_flags.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Runtime flags for UndefinedBehaviorSanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_FLAGS_H\n+#define UBSAN_FLAGS_H\n+\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+\n+namespace __ubsan {\n+\n+struct Flags {\n+  bool halt_on_error;\n+  bool print_stacktrace;\n+};\n+\n+extern Flags ubsan_flags;\n+inline Flags *flags() { return &ubsan_flags; }\n+\n+void InitializeCommonFlags();\n+void InitializeFlags();\n+\n+}  // namespace __ubsan\n+\n+extern \"C\" {\n+// Users may provide their own implementation of __ubsan_default_options to\n+// override the default flag values.\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+const char *__ubsan_default_options();\n+}  // extern \"C\"\n+\n+#endif  // UBSAN_FLAGS_H"}, {"sha": "bb9322f068ffbd6691e00350998a7a07358a296d", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 185, "deletions": 94, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -17,6 +17,16 @@\n using namespace __sanitizer;\n using namespace __ubsan;\n \n+static bool ignoreReport(SourceLocation SLoc, ReportOptions Opts) {\n+  // If source location is already acquired, we don't need to print an error\n+  // report for the second time. However, if we're in an unrecoverable handler,\n+  // it's possible that location was required by concurrently running thread.\n+  // In this case, we should continue the execution to ensure that any of\n+  // threads will grab the report mutex and print the report before\n+  // crashing the program.\n+  return SLoc.isDisabled() && !Opts.DieAfterReport;\n+}\n+\n namespace __ubsan {\n   const char *TypeCheckKinds[] = {\n     \"load of\", \"store to\", \"reference binding to\", \"member access within\",\n@@ -25,15 +35,17 @@ namespace __ubsan {\n }\n \n static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,\n-                                   Location FallbackLoc) {\n+                                   Location FallbackLoc, ReportOptions Opts) {\n   Location Loc = Data->Loc.acquire();\n-\n   // Use the SourceLocation from Data to track deduplication, even if 'invalid'\n-  if (Loc.getSourceLocation().isDisabled())\n+  if (ignoreReport(Loc.getSourceLocation(), Opts))\n     return;\n+\n   if (Data->Loc.isInvalid())\n     Loc = FallbackLoc;\n \n+  ScopedReport R(Opts, Loc);\n+\n   if (!Pointer)\n     Diag(Loc, DL_Error, \"%0 null pointer of type %1\")\n       << TypeCheckKinds[Data->TypeCheckKind] << Data->Type;\n@@ -49,70 +61,59 @@ static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,\n   if (Pointer)\n     Diag(Pointer, DL_Note, \"pointer points here\");\n }\n+\n void __ubsan::__ubsan_handle_type_mismatch(TypeMismatchData *Data,\n                                            ValueHandle Pointer) {\n-  handleTypeMismatchImpl(Data, Pointer, getCallerLocation());\n+  GET_REPORT_OPTIONS(false);\n+  handleTypeMismatchImpl(Data, Pointer, getCallerLocation(), Opts);\n }\n void __ubsan::__ubsan_handle_type_mismatch_abort(TypeMismatchData *Data,\n                                                  ValueHandle Pointer) {\n-  handleTypeMismatchImpl(Data, Pointer, getCallerLocation());\n+  GET_REPORT_OPTIONS(true);\n+  handleTypeMismatchImpl(Data, Pointer, getCallerLocation(), Opts);\n   Die();\n }\n \n /// \\brief Common diagnostic emission for various forms of integer overflow.\n-template<typename T> static void HandleIntegerOverflow(OverflowData *Data,\n-                                                       ValueHandle LHS,\n-                                                       const char *Operator,\n-                                                       T RHS) {\n+template <typename T>\n+static void handleIntegerOverflowImpl(OverflowData *Data, ValueHandle LHS,\n+                                      const char *Operator, T RHS,\n+                                      ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error, \"%0 integer overflow: \"\n                       \"%1 %2 %3 cannot be represented in type %4\")\n     << (Data->Type.isSignedIntegerTy() ? \"signed\" : \"unsigned\")\n     << Value(Data->Type, LHS) << Operator << RHS << Data->Type;\n }\n \n-void __ubsan::__ubsan_handle_add_overflow(OverflowData *Data,\n-                                          ValueHandle LHS, ValueHandle RHS) {\n-  HandleIntegerOverflow(Data, LHS, \"+\", Value(Data->Type, RHS));\n-}\n-void __ubsan::__ubsan_handle_add_overflow_abort(OverflowData *Data,\n-                                                 ValueHandle LHS,\n-                                                 ValueHandle RHS) {\n-  __ubsan_handle_add_overflow(Data, LHS, RHS);\n-  Die();\n-}\n+#define UBSAN_OVERFLOW_HANDLER(handler_name, op, abort)                        \\\n+  void __ubsan::handler_name(OverflowData *Data, ValueHandle LHS,              \\\n+                             ValueHandle RHS) {                                \\\n+    GET_REPORT_OPTIONS(abort);                                                 \\\n+    handleIntegerOverflowImpl(Data, LHS, op, Value(Data->Type, RHS), Opts);    \\\n+    if (abort) Die();                                                          \\\n+  }\n \n-void __ubsan::__ubsan_handle_sub_overflow(OverflowData *Data,\n-                                          ValueHandle LHS, ValueHandle RHS) {\n-  HandleIntegerOverflow(Data, LHS, \"-\", Value(Data->Type, RHS));\n-}\n-void __ubsan::__ubsan_handle_sub_overflow_abort(OverflowData *Data,\n-                                                 ValueHandle LHS,\n-                                                 ValueHandle RHS) {\n-  __ubsan_handle_sub_overflow(Data, LHS, RHS);\n-  Die();\n-}\n-\n-void __ubsan::__ubsan_handle_mul_overflow(OverflowData *Data,\n-                                          ValueHandle LHS, ValueHandle RHS) {\n-  HandleIntegerOverflow(Data, LHS, \"*\", Value(Data->Type, RHS));\n-}\n-void __ubsan::__ubsan_handle_mul_overflow_abort(OverflowData *Data,\n-                                                 ValueHandle LHS,\n-                                                 ValueHandle RHS) {\n-  __ubsan_handle_mul_overflow(Data, LHS, RHS);\n-  Die();\n-}\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_add_overflow, \"+\", false)\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_add_overflow_abort, \"+\", true)\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_sub_overflow, \"-\", false)\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_sub_overflow_abort, \"-\", true)\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_mul_overflow, \"*\", false)\n+UBSAN_OVERFLOW_HANDLER(__ubsan_handle_mul_overflow_abort, \"*\", true)\n \n-void __ubsan::__ubsan_handle_negate_overflow(OverflowData *Data,\n-                                             ValueHandle OldVal) {\n+static void handleNegateOverflowImpl(OverflowData *Data, ValueHandle OldVal,\n+                                     ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   if (Data->Type.isSignedIntegerTy())\n     Diag(Loc, DL_Error,\n          \"negation of %0 cannot be represented in type %1; \"\n@@ -123,18 +124,27 @@ void __ubsan::__ubsan_handle_negate_overflow(OverflowData *Data,\n          \"negation of %0 cannot be represented in type %1\")\n       << Value(Data->Type, OldVal) << Data->Type;\n }\n+\n+void __ubsan::__ubsan_handle_negate_overflow(OverflowData *Data,\n+                                             ValueHandle OldVal) {\n+  GET_REPORT_OPTIONS(false);\n+  handleNegateOverflowImpl(Data, OldVal, Opts);\n+}\n void __ubsan::__ubsan_handle_negate_overflow_abort(OverflowData *Data,\n                                                     ValueHandle OldVal) {\n-  __ubsan_handle_negate_overflow(Data, OldVal);\n+  GET_REPORT_OPTIONS(true);\n+  handleNegateOverflowImpl(Data, OldVal, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_divrem_overflow(OverflowData *Data,\n-                                             ValueHandle LHS, ValueHandle RHS) {\n+static void handleDivremOverflowImpl(OverflowData *Data, ValueHandle LHS,\n+                                     ValueHandle RHS, ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Value LHSVal(Data->Type, LHS);\n   Value RHSVal(Data->Type, RHS);\n   if (RHSVal.isMinusOne())\n@@ -144,20 +154,29 @@ void __ubsan::__ubsan_handle_divrem_overflow(OverflowData *Data,\n   else\n     Diag(Loc, DL_Error, \"division by zero\");\n }\n+\n+void __ubsan::__ubsan_handle_divrem_overflow(OverflowData *Data,\n+                                             ValueHandle LHS, ValueHandle RHS) {\n+  GET_REPORT_OPTIONS(false);\n+  handleDivremOverflowImpl(Data, LHS, RHS, Opts);\n+}\n void __ubsan::__ubsan_handle_divrem_overflow_abort(OverflowData *Data,\n                                                     ValueHandle LHS,\n                                                     ValueHandle RHS) {\n-  __ubsan_handle_divrem_overflow(Data, LHS, RHS);\n+  GET_REPORT_OPTIONS(true);\n+  handleDivremOverflowImpl(Data, LHS, RHS, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_shift_out_of_bounds(ShiftOutOfBoundsData *Data,\n-                                                 ValueHandle LHS,\n-                                                 ValueHandle RHS) {\n+static void handleShiftOutOfBoundsImpl(ShiftOutOfBoundsData *Data,\n+                                       ValueHandle LHS, ValueHandle RHS,\n+                                       ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Value LHSVal(Data->LHSType, LHS);\n   Value RHSVal(Data->RHSType, RHS);\n   if (RHSVal.isNegative())\n@@ -173,147 +192,219 @@ void __ubsan::__ubsan_handle_shift_out_of_bounds(ShiftOutOfBoundsData *Data,\n          \"left shift of %0 by %1 places cannot be represented in type %2\")\n       << LHSVal << RHSVal << Data->LHSType;\n }\n+\n+void __ubsan::__ubsan_handle_shift_out_of_bounds(ShiftOutOfBoundsData *Data,\n+                                                 ValueHandle LHS,\n+                                                 ValueHandle RHS) {\n+  GET_REPORT_OPTIONS(false);\n+  handleShiftOutOfBoundsImpl(Data, LHS, RHS, Opts);\n+}\n void __ubsan::__ubsan_handle_shift_out_of_bounds_abort(\n                                                      ShiftOutOfBoundsData *Data,\n                                                      ValueHandle LHS,\n                                                      ValueHandle RHS) {\n-  __ubsan_handle_shift_out_of_bounds(Data, LHS, RHS);\n+  GET_REPORT_OPTIONS(true);\n+  handleShiftOutOfBoundsImpl(Data, LHS, RHS, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_out_of_bounds(OutOfBoundsData *Data,\n-                                           ValueHandle Index) {\n+static void handleOutOfBoundsImpl(OutOfBoundsData *Data, ValueHandle Index,\n+                                  ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Value IndexVal(Data->IndexType, Index);\n   Diag(Loc, DL_Error, \"index %0 out of bounds for type %1\")\n     << IndexVal << Data->ArrayType;\n }\n+\n+void __ubsan::__ubsan_handle_out_of_bounds(OutOfBoundsData *Data,\n+                                           ValueHandle Index) {\n+  GET_REPORT_OPTIONS(false);\n+  handleOutOfBoundsImpl(Data, Index, Opts);\n+}\n void __ubsan::__ubsan_handle_out_of_bounds_abort(OutOfBoundsData *Data,\n                                                  ValueHandle Index) {\n-  __ubsan_handle_out_of_bounds(Data, Index);\n+  GET_REPORT_OPTIONS(true);\n+  handleOutOfBoundsImpl(Data, Index, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_builtin_unreachable(UnreachableData *Data) {\n+static void handleBuiltinUnreachableImpl(UnreachableData *Data,\n+                                         ReportOptions Opts) {\n+  ScopedReport R(Opts, Data->Loc);\n   Diag(Data->Loc, DL_Error, \"execution reached a __builtin_unreachable() call\");\n+}\n+\n+void __ubsan::__ubsan_handle_builtin_unreachable(UnreachableData *Data) {\n+  GET_REPORT_OPTIONS(true);\n+  handleBuiltinUnreachableImpl(Data, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_missing_return(UnreachableData *Data) {\n+static void handleMissingReturnImpl(UnreachableData *Data, ReportOptions Opts) {\n+  ScopedReport R(Opts, Data->Loc);\n   Diag(Data->Loc, DL_Error,\n        \"execution reached the end of a value-returning function \"\n        \"without returning a value\");\n+}\n+\n+void __ubsan::__ubsan_handle_missing_return(UnreachableData *Data) {\n+  GET_REPORT_OPTIONS(true);\n+  handleMissingReturnImpl(Data, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_vla_bound_not_positive(VLABoundData *Data,\n-                                                    ValueHandle Bound) {\n+static void handleVLABoundNotPositive(VLABoundData *Data, ValueHandle Bound,\n+                                      ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error, \"variable length array bound evaluates to \"\n                       \"non-positive value %0\")\n     << Value(Data->Type, Bound);\n }\n+\n+void __ubsan::__ubsan_handle_vla_bound_not_positive(VLABoundData *Data,\n+                                                    ValueHandle Bound) {\n+  GET_REPORT_OPTIONS(false);\n+  handleVLABoundNotPositive(Data, Bound, Opts);\n+}\n void __ubsan::__ubsan_handle_vla_bound_not_positive_abort(VLABoundData *Data,\n-                                                           ValueHandle Bound) {\n-  __ubsan_handle_vla_bound_not_positive(Data, Bound);\n+                                                          ValueHandle Bound) {\n+  GET_REPORT_OPTIONS(true);\n+  handleVLABoundNotPositive(Data, Bound, Opts);\n   Die();\n }\n \n-\n-void __ubsan::__ubsan_handle_float_cast_overflow(FloatCastOverflowData *Data,\n-                                                 ValueHandle From) {\n+static void handleFloatCastOverflow(FloatCastOverflowData *Data,\n+                                    ValueHandle From, ReportOptions Opts) {\n   // TODO: Add deduplication once a SourceLocation is generated for this check.\n-  Diag(getCallerLocation(), DL_Error,\n+  Location Loc = getCallerLocation();\n+  ScopedReport R(Opts, Loc);\n+\n+  Diag(Loc, DL_Error,\n        \"value %0 is outside the range of representable values of type %2\")\n-    << Value(Data->FromType, From) << Data->FromType << Data->ToType;\n+      << Value(Data->FromType, From) << Data->FromType << Data->ToType;\n }\n-void __ubsan::__ubsan_handle_float_cast_overflow_abort(\n-                                                    FloatCastOverflowData *Data,\n-                                                    ValueHandle From) {\n-  Diag(getCallerLocation(), DL_Error,\n-       \"value %0 is outside the range of representable values of type %2\")\n-    << Value(Data->FromType, From) << Data->FromType << Data->ToType;\n+\n+void __ubsan::__ubsan_handle_float_cast_overflow(FloatCastOverflowData *Data,\n+                                                 ValueHandle From) {\n+  GET_REPORT_OPTIONS(false);\n+  handleFloatCastOverflow(Data, From, Opts);\n+}\n+void\n+__ubsan::__ubsan_handle_float_cast_overflow_abort(FloatCastOverflowData *Data,\n+                                                  ValueHandle From) {\n+  GET_REPORT_OPTIONS(true);\n+  handleFloatCastOverflow(Data, From, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_load_invalid_value(InvalidValueData *Data,\n-                                                ValueHandle Val) {\n+static void handleLoadInvalidValue(InvalidValueData *Data, ValueHandle Val,\n+                                   ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error,\n        \"load of value %0, which is not a valid value for type %1\")\n     << Value(Data->Type, Val) << Data->Type;\n }\n+\n+void __ubsan::__ubsan_handle_load_invalid_value(InvalidValueData *Data,\n+                                                ValueHandle Val) {\n+  GET_REPORT_OPTIONS(false);\n+  handleLoadInvalidValue(Data, Val, Opts);\n+}\n void __ubsan::__ubsan_handle_load_invalid_value_abort(InvalidValueData *Data,\n                                                       ValueHandle Val) {\n-  __ubsan_handle_load_invalid_value(Data, Val);\n+  GET_REPORT_OPTIONS(true);\n+  handleLoadInvalidValue(Data, Val, Opts);\n   Die();\n }\n \n-void __ubsan::__ubsan_handle_function_type_mismatch(\n-    FunctionTypeMismatchData *Data,\n-    ValueHandle Function) {\n+static void handleFunctionTypeMismatch(FunctionTypeMismatchData *Data,\n+                                       ValueHandle Function,\n+                                       ReportOptions Opts) {\n   const char *FName = \"(unknown)\";\n \n   Location Loc = getFunctionLocation(Function, &FName);\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Data->Loc, DL_Error,\n        \"call to function %0 through pointer to incorrect function type %1\")\n     << FName << Data->Type;\n   Diag(Loc, DL_Note, \"%0 defined here\") << FName;\n }\n \n+void\n+__ubsan::__ubsan_handle_function_type_mismatch(FunctionTypeMismatchData *Data,\n+                                               ValueHandle Function) {\n+  GET_REPORT_OPTIONS(false);\n+  handleFunctionTypeMismatch(Data, Function, Opts);\n+}\n+\n void __ubsan::__ubsan_handle_function_type_mismatch_abort(\n-    FunctionTypeMismatchData *Data,\n-    ValueHandle Function) {\n-  __ubsan_handle_function_type_mismatch(Data, Function);\n+    FunctionTypeMismatchData *Data, ValueHandle Function) {\n+  GET_REPORT_OPTIONS(true);\n+  handleFunctionTypeMismatch(Data, Function, Opts);\n   Die();\n }\n \n-static void handleNonnullReturn(NonNullReturnData *Data) {\n+static void handleNonNullReturn(NonNullReturnData *Data, ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error, \"null pointer returned from function declared to never \"\n                       \"return null\");\n   if (!Data->AttrLoc.isInvalid())\n     Diag(Data->AttrLoc, DL_Note, \"returns_nonnull attribute specified here\");\n }\n \n void __ubsan::__ubsan_handle_nonnull_return(NonNullReturnData *Data) {\n-  handleNonnullReturn(Data);\n+  GET_REPORT_OPTIONS(false);\n+  handleNonNullReturn(Data, Opts);\n }\n \n void __ubsan::__ubsan_handle_nonnull_return_abort(NonNullReturnData *Data) {\n-  handleNonnullReturn(Data);\n+  GET_REPORT_OPTIONS(true);\n+  handleNonNullReturn(Data, Opts);\n   Die();\n }\n \n-static void handleNonNullArg(NonNullArgData *Data) {\n+static void handleNonNullArg(NonNullArgData *Data, ReportOptions Opts) {\n   SourceLocation Loc = Data->Loc.acquire();\n-  if (Loc.isDisabled())\n+  if (ignoreReport(Loc, Opts))\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error, \"null pointer passed as argument %0, which is declared to \"\n        \"never be null\") << Data->ArgIndex;\n   if (!Data->AttrLoc.isInvalid())\n     Diag(Data->AttrLoc, DL_Note, \"nonnull attribute specified here\");\n }\n \n void __ubsan::__ubsan_handle_nonnull_arg(NonNullArgData *Data) {\n-  handleNonNullArg(Data);\n+  GET_REPORT_OPTIONS(false);\n+  handleNonNullArg(Data, Opts);\n }\n \n void __ubsan::__ubsan_handle_nonnull_arg_abort(NonNullArgData *Data) {\n-  handleNonNullArg(Data);\n+  GET_REPORT_OPTIONS(true);\n+  handleNonNullArg(Data, Opts);\n   Die();\n }"}, {"sha": "92365d81893a2a609b61c6d93d76bab4a559cc7c", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -22,10 +22,14 @@ struct TypeMismatchData {\n   unsigned char TypeCheckKind;\n };\n \n+#define UNRECOVERABLE(checkname, ...) \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE NORETURN \\\n+    void __ubsan_handle_ ## checkname( __VA_ARGS__ );\n+\n #define RECOVERABLE(checkname, ...) \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE \\\n     void __ubsan_handle_ ## checkname( __VA_ARGS__ ); \\\n-  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE NORETURN \\\n     void __ubsan_handle_ ## checkname ## _abort( __VA_ARGS__ );\n \n /// \\brief Handle a runtime type check failure, caused by either a misaligned\n@@ -79,11 +83,9 @@ struct UnreachableData {\n };\n \n /// \\brief Handle a __builtin_unreachable which is reached.\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n-void __ubsan_handle_builtin_unreachable(UnreachableData *Data);\n+UNRECOVERABLE(builtin_unreachable, UnreachableData *Data)\n /// \\brief Handle reaching the end of a value-returning function.\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n-void __ubsan_handle_missing_return(UnreachableData *Data);\n+UNRECOVERABLE(missing_return, UnreachableData *Data)\n \n struct VLABoundData {\n   SourceLocation Loc;"}, {"sha": "86f3e57a8bcfba7b4199411c7df584cdb54f1de7", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -16,6 +16,7 @@\n #include \"ubsan_type_hash.h\"\n \n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_suppressions.h\"\n \n using namespace __sanitizer;\n using namespace __ubsan;\n@@ -26,47 +27,54 @@ namespace __ubsan {\n \n static void HandleDynamicTypeCacheMiss(\n     DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash,\n-    bool Abort) {\n+    ReportOptions Opts) {\n   if (checkDynamicType((void*)Pointer, Data->TypeInfo, Hash))\n     // Just a cache miss. The type matches after all.\n     return;\n \n+  // Check if error report should be suppressed.\n+  DynamicTypeInfo DTI = getDynamicTypeInfo((void*)Pointer);\n+  if (DTI.isValid() &&\n+      MatchSuppression(DTI.getMostDerivedTypeName(), SuppressionVptrCheck))\n+    return;\n+\n   SourceLocation Loc = Data->Loc.acquire();\n   if (Loc.isDisabled())\n     return;\n \n+  ScopedReport R(Opts, Loc);\n+\n   Diag(Loc, DL_Error,\n        \"%0 address %1 which does not point to an object of type %2\")\n     << TypeCheckKinds[Data->TypeCheckKind] << (void*)Pointer << Data->Type;\n \n   // If possible, say what type it actually points to.\n-  DynamicTypeInfo DTI = getDynamicTypeInfo((void*)Pointer);\n   if (!DTI.isValid())\n     Diag(Pointer, DL_Note, \"object has invalid vptr\")\n-      << MangledName(DTI.getMostDerivedTypeName())\n-      << Range(Pointer, Pointer + sizeof(uptr), \"invalid vptr\");\n+        << MangledName(DTI.getMostDerivedTypeName())\n+        << Range(Pointer, Pointer + sizeof(uptr), \"invalid vptr\");\n   else if (!DTI.getOffset())\n     Diag(Pointer, DL_Note, \"object is of type %0\")\n-      << MangledName(DTI.getMostDerivedTypeName())\n-      << Range(Pointer, Pointer + sizeof(uptr), \"vptr for %0\");\n+        << MangledName(DTI.getMostDerivedTypeName())\n+        << Range(Pointer, Pointer + sizeof(uptr), \"vptr for %0\");\n   else\n     // FIXME: Find the type at the specified offset, and include that\n     //        in the note.\n     Diag(Pointer - DTI.getOffset(), DL_Note,\n          \"object is base class subobject at offset %0 within object of type %1\")\n-      << DTI.getOffset() << MangledName(DTI.getMostDerivedTypeName())\n-      << MangledName(DTI.getSubobjectTypeName())\n-      << Range(Pointer, Pointer + sizeof(uptr), \"vptr for %2 base class of %1\");\n-\n-  if (Abort)\n-    Die();\n+        << DTI.getOffset() << MangledName(DTI.getMostDerivedTypeName())\n+        << MangledName(DTI.getSubobjectTypeName())\n+        << Range(Pointer, Pointer + sizeof(uptr),\n+                 \"vptr for %2 base class of %1\");\n }\n \n void __ubsan::__ubsan_handle_dynamic_type_cache_miss(\n     DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash) {\n-  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, false);\n+  GET_REPORT_OPTIONS(false);\n+  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, Opts);\n }\n void __ubsan::__ubsan_handle_dynamic_type_cache_miss_abort(\n     DynamicTypeCacheMissData *Data, ValueHandle Pointer, ValueHandle Hash) {\n-  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, true);\n+  GET_REPORT_OPTIONS(true);\n+  HandleDynamicTypeCacheMiss(Data, Pointer, Hash, Opts);\n }"}, {"sha": "f28fc811f50e952568b00592443c12a5168d7317", "filename": "libsanitizer/ubsan/ubsan_init.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cc?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,59 @@\n+//===-- ubsan_init.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Initialization of UBSan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"ubsan_init.h\"\n+#include \"ubsan_flags.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n+#include \"sanitizer_common/sanitizer_suppressions.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+\n+using namespace __ubsan;\n+\n+static bool ubsan_inited;\n+\n+void __ubsan::InitIfNecessary() {\n+#if !SANITIZER_CAN_USE_PREINIT_ARRAY\n+  // No need to lock mutex if we're initializing from preinit array.\n+  static StaticSpinMutex init_mu;\n+  SpinMutexLock l(&init_mu);\n+#endif\n+  if (LIKELY(ubsan_inited))\n+   return;\n+  if (0 == internal_strcmp(SanitizerToolName, \"SanitizerTool\")) {\n+    // WARNING: If this condition holds, then either UBSan runs in a standalone\n+    // mode, or initializer for another sanitizer hasn't run yet. In a latter\n+    // case, another sanitizer will overwrite \"SanitizerToolName\" and reparse\n+    // common flags. It means, that we are not allowed to *use* common flags\n+    // in this function.\n+    SanitizerToolName = \"UndefinedBehaviorSanitizer\";\n+    InitializeCommonFlags();\n+  }\n+  // Initialize UBSan-specific flags.\n+  InitializeFlags();\n+  SuppressionContext::InitIfNecessary();\n+  ubsan_inited = true;\n+}\n+\n+#if SANITIZER_CAN_USE_PREINIT_ARRAY\n+__attribute__((section(\".preinit_array\"), used))\n+void (*__local_ubsan_preinit)(void) = __ubsan::InitIfNecessary;\n+#else\n+// Use a dynamic initializer.\n+class UbsanInitializer {\n+ public:\n+  UbsanInitializer() {\n+    InitIfNecessary();\n+  }\n+};\n+static UbsanInitializer ubsan_initializer;\n+#endif  // SANITIZER_CAN_USE_PREINIT_ARRAY"}, {"sha": "b76bbfe7bb7140a9faef8afa4a17271ef4cc587a", "filename": "libsanitizer/ubsan/ubsan_init.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_init.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e32ad336f1698809cc03c48f884379d6b39e0/libsanitizer%2Fubsan%2Fubsan_init.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.h?ref=866e32ad336f1698809cc03c48f884379d6b39e0", "patch": "@@ -0,0 +1,22 @@\n+//===-- ubsan_init.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Initialization function for UBSan runtime.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef UBSAN_INIT_H\n+#define UBSAN_INIT_H\n+\n+namespace __ubsan {\n+\n+// NOTE: This function might take a lock (if .preinit_array initialization is\n+// not used). It's generally a bad idea to call it on a fast path.\n+void InitIfNecessary();\n+\n+}  // namespace __ubsan\n+\n+#endif  // UBSAN_INIT_H"}]}