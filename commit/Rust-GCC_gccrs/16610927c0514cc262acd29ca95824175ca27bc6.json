{"sha": "16610927c0514cc262acd29ca95824175ca27bc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY2MTA5MjdjMDUxNGNjMjYyYWNkMjljYTk1ODI0MTc1Y2EyN2JjNg==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-01T16:02:11Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-01T16:02:11Z"}, "message": "genattrtab.c (copy_rtx_unchanging): Remove #if 0'ed code.\n\n        * genattrtab.c (copy_rtx_unchanging): Remove #if 0'ed code.\n        Remove #if 0'ed function simplify_by_alternatives.\n        (optimize_attrs): Remove #if 0'ed code.\n        Remove ^L.\n        Use ISO C90 prototypes.\n        (make_canonical): Remove #if 0'ed code.\n        (convert_const_symbol_ref): Remove #if 0'ed function.\n\nFrom-SVN: r67298", "tree": {"sha": "23fc1e6e3674976d6e87619e42826d8f1115522b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23fc1e6e3674976d6e87619e42826d8f1115522b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16610927c0514cc262acd29ca95824175ca27bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16610927c0514cc262acd29ca95824175ca27bc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16610927c0514cc262acd29ca95824175ca27bc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16610927c0514cc262acd29ca95824175ca27bc6/comments", "author": null, "committer": null, "parents": [{"sha": "3d7aafde11a808a69874f94903bb045882b66c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7aafde11a808a69874f94903bb045882b66c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7aafde11a808a69874f94903bb045882b66c11"}], "stats": {"total": 783, "additions": 248, "deletions": 535}, "files": [{"sha": "86bf972f972978f98d79411cc458702ad59eebd7", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 248, "deletions": 535, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16610927c0514cc262acd29ca95824175ca27bc6/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16610927c0514cc262acd29ca95824175ca27bc6/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=16610927c0514cc262acd29ca95824175ca27bc6", "patch": "@@ -1,6 +1,6 @@\n /* Generate code from machine description to compute values of attributes.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GCC.\n@@ -370,103 +370,97 @@ int optimize = 0;\n rtx global_rtl[GR_MAX];\n rtx pic_offset_table_rtx;\n \n-static void attr_hash_add_rtx\tPARAMS ((int, rtx));\n-static void attr_hash_add_string PARAMS ((int, char *));\n-static rtx attr_rtx\t\tPARAMS ((enum rtx_code, ...));\n-static rtx attr_rtx_1\t\tPARAMS ((enum rtx_code, va_list));\n-static char *attr_string        PARAMS ((const char *, int));\n-static rtx check_attr_value\tPARAMS ((rtx, struct attr_desc *));\n-static rtx convert_set_attr_alternative PARAMS ((rtx, struct insn_def *));\n-static rtx convert_set_attr\tPARAMS ((rtx, struct insn_def *));\n-static void check_defs\t\tPARAMS ((void));\n-#if 0\n-static rtx convert_const_symbol_ref PARAMS ((rtx, struct attr_desc *));\n-#endif\n-static rtx make_canonical\tPARAMS ((struct attr_desc *, rtx));\n-static struct attr_value *get_attr_value PARAMS ((rtx, struct attr_desc *, int));\n-static rtx copy_rtx_unchanging\tPARAMS ((rtx));\n-static rtx copy_boolean\t\tPARAMS ((rtx));\n-static void expand_delays\tPARAMS ((void));\n-static rtx operate_exp\t\tPARAMS ((enum operator, rtx, rtx));\n-static void expand_units\tPARAMS ((void));\n-static rtx simplify_knowing\tPARAMS ((rtx, rtx));\n-static rtx encode_units_mask\tPARAMS ((rtx));\n-static void fill_attr\t\tPARAMS ((struct attr_desc *));\n-static rtx substitute_address\tPARAMS ((rtx, rtx (*) (rtx), rtx (*) (rtx)));\n-static void make_length_attrs\tPARAMS ((void));\n-static rtx identity_fn\t\tPARAMS ((rtx));\n-static rtx zero_fn\t\tPARAMS ((rtx));\n-static rtx one_fn\t\tPARAMS ((rtx));\n-static rtx max_fn\t\tPARAMS ((rtx));\n-static void write_length_unit_log PARAMS ((void));\n-static rtx simplify_cond\tPARAMS ((rtx, int, int));\n-#if 0\n-static rtx simplify_by_alternatives PARAMS ((rtx, int, int));\n-#endif\n-static rtx simplify_by_exploding PARAMS ((rtx));\n-static int find_and_mark_used_attributes PARAMS ((rtx, rtx *, int *));\n-static void unmark_used_attributes PARAMS ((rtx, struct dimension *, int));\n-static int add_values_to_cover\tPARAMS ((struct dimension *));\n-static int increment_current_value PARAMS ((struct dimension *, int));\n-static rtx test_for_current_value PARAMS ((struct dimension *, int));\n-static rtx simplify_with_current_value PARAMS ((rtx, struct dimension *, int));\n-static rtx simplify_with_current_value_aux PARAMS ((rtx));\n-static void clear_struct_flag PARAMS ((rtx));\n-static int count_sub_rtxs    PARAMS ((rtx, int));\n-static void remove_insn_ent  PARAMS ((struct attr_value *, struct insn_ent *));\n-static void insert_insn_ent  PARAMS ((struct attr_value *, struct insn_ent *));\n-static rtx insert_right_side\tPARAMS ((enum rtx_code, rtx, rtx, int, int));\n-static rtx make_alternative_compare PARAMS ((int));\n-static int compute_alternative_mask PARAMS ((rtx, enum rtx_code));\n-static rtx evaluate_eq_attr\tPARAMS ((rtx, rtx, int, int));\n-static rtx simplify_and_tree\tPARAMS ((rtx, rtx *, int, int));\n-static rtx simplify_or_tree\tPARAMS ((rtx, rtx *, int, int));\n-static rtx simplify_test_exp\tPARAMS ((rtx, int, int));\n-static rtx simplify_test_exp_in_temp PARAMS ((rtx, int, int));\n-static void optimize_attrs\tPARAMS ((void));\n-static void gen_attr\t\tPARAMS ((rtx, int));\n-static int count_alternatives\tPARAMS ((rtx));\n-static int compares_alternatives_p PARAMS ((rtx));\n-static int contained_in_p\tPARAMS ((rtx, rtx));\n-static void gen_insn\t\tPARAMS ((rtx, int));\n-static void gen_delay\t\tPARAMS ((rtx, int));\n-static void gen_unit\t\tPARAMS ((rtx, int));\n-static void write_test_expr\tPARAMS ((rtx, int));\n-static int max_attr_value\tPARAMS ((rtx, int*));\n-static int or_attr_value\tPARAMS ((rtx, int*));\n-static void walk_attr_value\tPARAMS ((rtx));\n-static void write_attr_get\tPARAMS ((struct attr_desc *));\n-static rtx eliminate_known_true PARAMS ((rtx, rtx, int, int));\n-static void write_attr_set\tPARAMS ((struct attr_desc *, int, rtx,\n-\t\t\t\t       const char *, const char *, rtx,\n-\t\t\t\t       int, int));\n-static void write_attr_case\tPARAMS ((struct attr_desc *, struct attr_value *,\n-\t\t\t\t       int, const char *, const char *, int, rtx));\n-static void write_unit_name\tPARAMS ((const char *, int, const char *));\n-static void write_attr_valueq\tPARAMS ((struct attr_desc *, const char *));\n-static void write_attr_value\tPARAMS ((struct attr_desc *, rtx));\n-static void write_upcase\tPARAMS ((const char *));\n-static void write_indent\tPARAMS ((int));\n-static void write_eligible_delay PARAMS ((const char *));\n-static void write_function_unit_info PARAMS ((void));\n-static void write_complex_function PARAMS ((struct function_unit *, const char *,\n-\t\t\t\t\t  const char *));\n-static int write_expr_attr_cache PARAMS ((rtx, struct attr_desc *));\n-static void write_toplevel_expr\tPARAMS ((rtx));\n-static void write_const_num_delay_slots PARAMS ((void));\n-static char *next_comma_elt\tPARAMS ((const char **));\n-static struct attr_desc *find_attr PARAMS ((const char *, int));\n-static struct attr_value *find_most_used  PARAMS ((struct attr_desc *));\n-static rtx find_single_value\tPARAMS ((struct attr_desc *));\n-static void extend_range\tPARAMS ((struct range *, int, int));\n-static rtx attr_eq\t\tPARAMS ((const char *, const char *));\n-static const char *attr_numeral\tPARAMS ((int));\n-static int attr_equal_p\t\tPARAMS ((rtx, rtx));\n-static rtx attr_copy_rtx\tPARAMS ((rtx));\n-static int attr_rtx_cost \tPARAMS ((rtx));\n+static void attr_hash_add_rtx\t(int, rtx);\n+static void attr_hash_add_string (int, char *);\n+static rtx attr_rtx\t\t(enum rtx_code, ...);\n+static rtx attr_rtx_1\t\t(enum rtx_code, va_list);\n+static char *attr_string        (const char *, int);\n+static rtx check_attr_value\t(rtx, struct attr_desc *);\n+static rtx convert_set_attr_alternative (rtx, struct insn_def *);\n+static rtx convert_set_attr\t(rtx, struct insn_def *);\n+static void check_defs\t\t(void);\n+static rtx make_canonical\t(struct attr_desc *, rtx);\n+static struct attr_value *get_attr_value (rtx, struct attr_desc *, int);\n+static rtx copy_rtx_unchanging\t(rtx);\n+static rtx copy_boolean\t\t(rtx);\n+static void expand_delays\t(void);\n+static rtx operate_exp\t\t(enum operator, rtx, rtx);\n+static void expand_units\t(void);\n+static rtx simplify_knowing\t(rtx, rtx);\n+static rtx encode_units_mask\t(rtx);\n+static void fill_attr\t\t(struct attr_desc *);\n+static rtx substitute_address\t(rtx, rtx (*) (rtx), rtx (*) (rtx));\n+static void make_length_attrs\t(void);\n+static rtx identity_fn\t\t(rtx);\n+static rtx zero_fn\t\t(rtx);\n+static rtx one_fn\t\t(rtx);\n+static rtx max_fn\t\t(rtx);\n+static void write_length_unit_log (void);\n+static rtx simplify_cond\t(rtx, int, int);\n+static rtx simplify_by_exploding (rtx);\n+static int find_and_mark_used_attributes (rtx, rtx *, int *);\n+static void unmark_used_attributes (rtx, struct dimension *, int);\n+static int add_values_to_cover\t(struct dimension *);\n+static int increment_current_value (struct dimension *, int);\n+static rtx test_for_current_value (struct dimension *, int);\n+static rtx simplify_with_current_value (rtx, struct dimension *, int);\n+static rtx simplify_with_current_value_aux (rtx);\n+static void clear_struct_flag (rtx);\n+static int count_sub_rtxs    (rtx, int);\n+static void remove_insn_ent  (struct attr_value *, struct insn_ent *);\n+static void insert_insn_ent  (struct attr_value *, struct insn_ent *);\n+static rtx insert_right_side\t(enum rtx_code, rtx, rtx, int, int);\n+static rtx make_alternative_compare (int);\n+static int compute_alternative_mask (rtx, enum rtx_code);\n+static rtx evaluate_eq_attr\t(rtx, rtx, int, int);\n+static rtx simplify_and_tree\t(rtx, rtx *, int, int);\n+static rtx simplify_or_tree\t(rtx, rtx *, int, int);\n+static rtx simplify_test_exp\t(rtx, int, int);\n+static rtx simplify_test_exp_in_temp (rtx, int, int);\n+static void optimize_attrs\t(void);\n+static void gen_attr\t\t(rtx, int);\n+static int count_alternatives\t(rtx);\n+static int compares_alternatives_p (rtx);\n+static int contained_in_p\t(rtx, rtx);\n+static void gen_insn\t\t(rtx, int);\n+static void gen_delay\t\t(rtx, int);\n+static void gen_unit\t\t(rtx, int);\n+static void write_test_expr\t(rtx, int);\n+static int max_attr_value\t(rtx, int*);\n+static int or_attr_value\t(rtx, int*);\n+static void walk_attr_value\t(rtx);\n+static void write_attr_get\t(struct attr_desc *);\n+static rtx eliminate_known_true (rtx, rtx, int, int);\n+static void write_attr_set\t(struct attr_desc *, int, rtx,\n+\t\t\t\t const char *, const char *, rtx,\n+\t\t\t\t int, int);\n+static void write_attr_case\t(struct attr_desc *, struct attr_value *,\n+\t\t\t\t int, const char *, const char *, int, rtx);\n+static void write_unit_name\t(const char *, int, const char *);\n+static void write_attr_valueq\t(struct attr_desc *, const char *);\n+static void write_attr_value\t(struct attr_desc *, rtx);\n+static void write_upcase\t(const char *);\n+static void write_indent\t(int);\n+static void write_eligible_delay (const char *);\n+static void write_function_unit_info (void);\n+static void write_complex_function (struct function_unit *, const char *,\n+\t\t\t\t    const char *);\n+static int write_expr_attr_cache (rtx, struct attr_desc *);\n+static void write_toplevel_expr\t(rtx);\n+static void write_const_num_delay_slots (void);\n+static char *next_comma_elt\t(const char **);\n+static struct attr_desc *find_attr (const char *, int);\n+static struct attr_value *find_most_used  (struct attr_desc *);\n+static rtx find_single_value\t(struct attr_desc *);\n+static void extend_range\t(struct range *, int, int);\n+static rtx attr_eq\t\t(const char *, const char *);\n+static const char *attr_numeral\t(int);\n+static int attr_equal_p\t\t(rtx, rtx);\n+static rtx attr_copy_rtx\t(rtx);\n+static int attr_rtx_cost\t(rtx);\n \n #define oballoc(size) obstack_alloc (hash_obstack, size)\n-\f\n+\n /* Hash table for sharing RTL and strings.  */\n \n /* Each hash table slot is a bucket containing a chain of these structures.\n@@ -501,9 +495,7 @@ struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n /* Add an entry to the hash table for RTL with hash code HASHCODE.  */\n \n static void\n-attr_hash_add_rtx (hashcode, rtl)\n-     int hashcode;\n-     rtx rtl;\n+attr_hash_add_rtx (int hashcode, rtx rtl)\n {\n   struct attr_hash *h;\n \n@@ -518,9 +510,7 @@ attr_hash_add_rtx (hashcode, rtl)\n /* Add an entry to the hash table for STRING with hash code HASHCODE.  */\n \n static void\n-attr_hash_add_string (hashcode, str)\n-     int hashcode;\n-     char *str;\n+attr_hash_add_string (int hashcode, char *str)\n {\n   struct attr_hash *h;\n \n@@ -543,9 +533,7 @@ attr_hash_add_string (hashcode, str)\n    rtx attr_rtx (code, [element1, ..., elementn])  */\n \n static rtx\n-attr_rtx_1 (code, p)\n-     enum rtx_code code;\n-     va_list p;\n+attr_rtx_1 (enum rtx_code code, va_list p)\n {\n   rtx rt_val = NULL_RTX;/* RTX to return to caller...\t\t*/\n   int hashcode;\n@@ -723,7 +711,7 @@ attr_rtx (enum rtx_code code, ...)\n {\n   rtx result;\n   va_list p;\n-  \n+\n   va_start (p, code);\n   result = attr_rtx_1 (code, p);\n   va_end (p);\n@@ -740,9 +728,9 @@ attr_printf (unsigned int len, const char *fmt, ...)\n {\n   char str[256];\n   va_list p;\n-  \n+\n   va_start (p, fmt);\n-  \n+\n   if (len > sizeof str - 1) /* Leave room for \\0.  */\n     abort ();\n \n@@ -753,16 +741,14 @@ attr_printf (unsigned int len, const char *fmt, ...)\n }\n \n static rtx\n-attr_eq (name, value)\n-     const char *name, *value;\n+attr_eq (const char *name, const char *value)\n {\n   return attr_rtx (EQ_ATTR, attr_string (name, strlen (name)),\n \t\t   attr_string (value, strlen (value)));\n }\n \n static const char *\n-attr_numeral (n)\n-     int n;\n+attr_numeral (int n)\n {\n   return XSTR (make_numeric_value (n), 0);\n }\n@@ -771,9 +757,7 @@ attr_numeral (n)\n    to be null terminated) with LEN bytes.  */\n \n static char *\n-attr_string (str, len)\n-     const char *str;\n-     int len;\n+attr_string (const char *str, int len)\n {\n   struct attr_hash *h;\n   int hashcode;\n@@ -807,20 +791,18 @@ attr_string (str, len)\n    then they can't be equal unless they are the same object.  */\n \n static int\n-attr_equal_p (x, y)\n-     rtx x, y;\n+attr_equal_p (rtx x, rtx y)\n {\n   return (x == y || (! (ATTR_PERMANENT_P (x) && ATTR_PERMANENT_P (y))\n \t\t     && rtx_equal_p (x, y)));\n }\n-\f\n+\n /* Copy an attribute value expression,\n    descending to all depths, but not copying any\n    permanent hashed subexpressions.  */\n \n static rtx\n-attr_copy_rtx (orig)\n-     rtx orig;\n+attr_copy_rtx (rtx orig)\n {\n   rtx copy;\n   int i, j;\n@@ -900,7 +882,7 @@ attr_copy_rtx (orig)\n     }\n   return copy;\n }\n-\f\n+\n /* Given a test expression for an attribute, ensure it is validly formed.\n    IS_CONST indicates whether the expression is constant for each compiler\n    run (a constant expression may not test any particular insn).\n@@ -916,10 +898,7 @@ attr_copy_rtx (orig)\n    Return the new expression, if any.  */\n \n rtx\n-check_attr_test (exp, is_const, lineno)\n-     rtx exp;\n-     int is_const;\n-     int lineno;\n+check_attr_test (rtx exp, int is_const, int lineno)\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -1057,17 +1036,15 @@ check_attr_test (exp, is_const, lineno)\n \n   return exp;\n }\n-\f\n+\n /* Given an expression, ensure that it is validly formed and that all named\n    attribute values are valid for the given attribute.  Issue a fatal error\n    if not.  If no attribute is specified, assume a numeric attribute.\n \n    Return a perhaps modified replacement expression for the value.  */\n \n static rtx\n-check_attr_value (exp, attr)\n-     rtx exp;\n-     struct attr_desc *attr;\n+check_attr_value (rtx exp, struct attr_desc *attr)\n {\n   struct attr_value *av;\n   const char *p;\n@@ -1233,14 +1210,12 @@ check_attr_value (exp, attr)\n \n   return exp;\n }\n-\f\n+\n /* Given an SET_ATTR_ALTERNATIVE expression, convert to the canonical SET.\n    It becomes a COND with each test being (eq_attr \"alternative \"n\") */\n \n static rtx\n-convert_set_attr_alternative (exp, id)\n-     rtx exp;\n-     struct insn_def *id;\n+convert_set_attr_alternative (rtx exp, struct insn_def *id)\n {\n   int num_alt = id->num_alternatives;\n   rtx condexp;\n@@ -1272,14 +1247,12 @@ convert_set_attr_alternative (exp, id)\n \n   return attr_rtx (SET, attr_rtx (ATTR, XSTR (exp, 0)), condexp);\n }\n-\f\n+\n /* Given a SET_ATTR, convert to the appropriate SET.  If a comma-separated\n    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */\n \n static rtx\n-convert_set_attr (exp, id)\n-     rtx exp;\n-     struct insn_def *id;\n+convert_set_attr (rtx exp, struct insn_def *id)\n {\n   rtx newexp;\n   const char *name_ptr;\n@@ -1305,13 +1278,13 @@ convert_set_attr (exp, id)\n \n   return convert_set_attr_alternative (newexp, id);\n }\n-\f\n+\n /* Scan all definitions, checking for validity.  Also, convert any SET_ATTR\n    and SET_ATTR_ALTERNATIVE expressions to the corresponding SET\n    expressions.  */\n \n static void\n-check_defs ()\n+check_defs (void)\n {\n   struct insn_def *id;\n   struct attr_desc *attr;\n@@ -1367,68 +1340,14 @@ check_defs ()\n \t}\n     }\n }\n-\f\n-#if 0\n-/* Given a constant SYMBOL_REF expression, convert to a COND that\n-   explicitly tests each enumerated value.  */\n-\n-static rtx\n-convert_const_symbol_ref (exp, attr)\n-     rtx exp;\n-     struct attr_desc *attr;\n-{\n-  rtx condexp;\n-  struct attr_value *av;\n-  int i;\n-  int num_alt = 0;\n-\n-  for (av = attr->first_value; av; av = av->next)\n-    num_alt++;\n-\n-  /* Make a COND with all tests but the last, and in the original order.\n-     Select the last value via the default.  Note that the attr values\n-     are constructed in reverse order.  */\n-\n-  condexp = rtx_alloc (COND);\n-  XVEC (condexp, 0) = rtvec_alloc ((num_alt - 1) * 2);\n-  av = attr->first_value;\n-  XEXP (condexp, 1) = av->value;\n-\n-  for (i = num_alt - 2; av = av->next, i >= 0; i--)\n-    {\n-      char *p, *string;\n-      rtx value;\n-\n-      string = p = (char *) oballoc (2\n-\t\t\t\t     + strlen (attr->name)\n-\t\t\t\t     + strlen (XSTR (av->value, 0)));\n-      strcpy (p, attr->name);\n-      strcat (p, \"_\");\n-      strcat (p, XSTR (av->value, 0));\n-      for (; *p != '\\0'; p++)\n-\t*p = TOUPPER (*p);\n-\n-      value = attr_rtx (SYMBOL_REF, string);\n-      ATTR_IND_SIMPLIFIED_P (value) = 1;\n-\n-      XVECEXP (condexp, 0, 2 * i) = attr_rtx (EQ, exp, value);\n-\n-      XVECEXP (condexp, 0, 2 * i + 1) = av->value;\n-    }\n \n-  return condexp;\n-}\n-#endif\n-\f\n /* Given a valid expression for an attribute value, remove any IF_THEN_ELSE\n    expressions by converting them into a COND.  This removes cases from this\n    program.  Also, replace an attribute value of \"*\" with the default attribute\n    value.  */\n \n static rtx\n-make_canonical (attr, exp)\n-     struct attr_desc *attr;\n-     rtx exp;\n+make_canonical (struct attr_desc *attr, rtx exp)\n {\n   int i;\n   rtx newexp;\n@@ -1456,21 +1375,8 @@ make_canonical (attr, exp)\n \t This makes the COND something that won't be considered an arbitrary\n \t expression by walk_attr_value.  */\n       ATTR_IND_SIMPLIFIED_P (exp) = 1;\n-#if 0\n-      /* ??? Why do we do this?  With attribute values { A B C D E }, this\n-         tends to generate (!(x==A) && !(x==B) && !(x==C) && !(x==D)) rather\n-\t than (x==E).  */\n-      exp = convert_const_symbol_ref (exp, attr);\n-      ATTR_IND_SIMPLIFIED_P (exp) = 1;\n-      exp = check_attr_value (exp, attr);\n-      /* Goto COND case since this is now a COND.  Note that while the\n-         new expression is rescanned, all symbol_ref notes are marked as\n-\t unchanging.  */\n-      goto cond;\n-#else\n       exp = check_attr_value (exp, attr);\n       break;\n-#endif\n \n     case IF_THEN_ELSE:\n       newexp = rtx_alloc (COND);\n@@ -1514,15 +1420,14 @@ make_canonical (attr, exp)\n }\n \n static rtx\n-copy_boolean (exp)\n-     rtx exp;\n+copy_boolean (rtx exp)\n {\n   if (GET_CODE (exp) == AND || GET_CODE (exp) == IOR)\n     return attr_rtx (GET_CODE (exp), copy_boolean (XEXP (exp, 0)),\n \t\t     copy_boolean (XEXP (exp, 1)));\n   return exp;\n }\n-\f\n+\n /* Given a value and an attribute description, return a `struct attr_value *'\n    that represents that value.  This is either an existing structure, if the\n    value has been previously encountered, or a newly-created structure.\n@@ -1533,10 +1438,7 @@ copy_boolean (exp)\n    alternatives.  */\n \n static struct attr_value *\n-get_attr_value (value, attr, insn_code)\n-     rtx value;\n-     struct attr_desc *attr;\n-     int insn_code;\n+get_attr_value (rtx value, struct attr_desc *attr, int insn_code)\n {\n   struct attr_value *av;\n   int num_alt = 0;\n@@ -1566,7 +1468,7 @@ get_attr_value (value, attr, insn_code)\n \n   return av;\n }\n-\f\n+\n /* After all DEFINE_DELAYs have been read in, create internal attributes\n    to generate the required routines.\n \n@@ -1582,7 +1484,7 @@ get_attr_value (value, attr, insn_code)\n    information needed to handle delay slots.  */\n \n static void\n-expand_delays ()\n+expand_delays (void)\n {\n   struct delay_desc *delay;\n   rtx condexp;\n@@ -1664,7 +1566,7 @@ expand_delays ()\n \t}\n     }\n }\n-\f\n+\n /* This function is given a left and right side expression and an operator.\n    Each side is a conditional expression, each alternative of which has a\n    numerical value.  The function returns another conditional expression\n@@ -1674,9 +1576,7 @@ expand_delays ()\n    Since this is called early, it must also support IF_THEN_ELSE.  */\n \n static rtx\n-operate_exp (op, left, right)\n-     enum operator op;\n-     rtx left, right;\n+operate_exp (enum operator op, rtx left, rtx right)\n {\n   int left_value, right_value;\n   rtx newexp;\n@@ -1836,7 +1736,7 @@ operate_exp (op, left, right)\n   /* NOTREACHED */\n   return NULL;\n }\n-\f\n+\n /* Once all attributes and DEFINE_FUNCTION_UNITs have been read, we\n    construct a number of attributes.\n \n@@ -1870,7 +1770,7 @@ operate_exp (op, left, right)\n    half gives the maximum value.  */\n \n static void\n-expand_units ()\n+expand_units (void)\n {\n   struct function_unit *unit, **unit_num;\n   struct function_unit_op *op, **op_array, ***unit_ops;\n@@ -2231,8 +2131,7 @@ expand_units ()\n /* Simplify EXP given KNOWN_TRUE.  */\n \n static rtx\n-simplify_knowing (exp, known_true)\n-     rtx exp, known_true;\n+simplify_knowing (rtx exp, rtx known_true)\n {\n   if (GET_CODE (exp) != CONST_STRING)\n     {\n@@ -2254,8 +2153,7 @@ simplify_knowing (exp, known_true)\n    and only one unit is used or the one's complement of the bitmask.  */\n \n static rtx\n-encode_units_mask (x)\n-     rtx x;\n+encode_units_mask (rtx x)\n {\n   int i;\n   int j;\n@@ -2316,14 +2214,13 @@ encode_units_mask (x)\n     }\n   return x;\n }\n-\f\n+\n /* Once all attributes and insns have been read and checked, we construct for\n    each attribute value a list of all the insns that have that value for\n    the attribute.  */\n \n static void\n-fill_attr (attr)\n-     struct attr_desc *attr;\n+fill_attr (struct attr_desc *attr)\n {\n   struct attr_value *av;\n   struct insn_ent *ie;\n@@ -2358,7 +2255,7 @@ fill_attr (attr)\n       insert_insn_ent (av, ie);\n     }\n }\n-\f\n+\n /* Given an expression EXP, see if it is a COND or IF_THEN_ELSE that has a\n    test that checks relative positions of insns (uses MATCH_DUP or PC).\n    If so, replace it with what is obtained by passing the expression to\n@@ -2367,10 +2264,8 @@ fill_attr (attr)\n    return the value returned by NO_ADDRESS_FN applied to EXP.  */\n \n static rtx\n-substitute_address (exp, no_address_fn, address_fn)\n-     rtx exp;\n-     rtx (*no_address_fn) PARAMS ((rtx));\n-     rtx (*address_fn) PARAMS ((rtx));\n+substitute_address (rtx exp, rtx (*no_address_fn) (rtx),\n+\t\t    rtx (*address_fn) (rtx))\n {\n   int i;\n   rtx newexp;\n@@ -2420,7 +2315,7 @@ substitute_address (exp, no_address_fn, address_fn)\n \n   return (*no_address_fn) (exp);\n }\n-\f\n+\n /* Make new attributes from the `length' attribute.  The following are made,\n    each corresponding to a function called from `shorten_branches' or\n    `get_attr_length':\n@@ -2441,13 +2336,13 @@ substitute_address (exp, no_address_fn, address_fn)\n   */\n \n static void\n-make_length_attrs ()\n+make_length_attrs (void)\n {\n   static const char *const new_names[] = {\"*insn_default_length\",\n \t\t\t\t      \"*insn_variable_length_p\",\n \t\t\t\t      \"*insn_current_length\"};\n-  static rtx (*const no_address_fn[]) PARAMS ((rtx)) = {identity_fn, zero_fn, zero_fn};\n-  static rtx (*const address_fn[]) PARAMS ((rtx)) = {max_fn, one_fn, identity_fn};\n+  static rtx (*const no_address_fn[]) (rtx) = {identity_fn, zero_fn, zero_fn};\n+  static rtx (*const address_fn[]) (rtx) = {max_fn, one_fn, identity_fn};\n   size_t i;\n   struct attr_desc *length_attr, *new_attr;\n   struct attr_value *av, *new_av;\n@@ -2491,36 +2386,32 @@ make_length_attrs ()\n /* Utility functions called from above routine.  */\n \n static rtx\n-identity_fn (exp)\n-     rtx exp;\n+identity_fn (rtx exp)\n {\n   return exp;\n }\n \n static rtx\n-zero_fn (exp)\n-     rtx exp ATTRIBUTE_UNUSED;\n+zero_fn (rtx exp ATTRIBUTE_UNUSED)\n {\n   return make_numeric_value (0);\n }\n \n static rtx\n-one_fn (exp)\n-     rtx exp ATTRIBUTE_UNUSED;\n+one_fn (rtx exp ATTRIBUTE_UNUSED)\n {\n   return make_numeric_value (1);\n }\n \n static rtx\n-max_fn (exp)\n-     rtx exp;\n+max_fn (rtx exp)\n {\n   int unknown;\n   return make_numeric_value (max_attr_value (exp, &unknown));\n }\n \n static void\n-write_length_unit_log ()\n+write_length_unit_log (void)\n {\n   struct attr_desc *length_attr = find_attr (\"length\", 0);\n   struct attr_value *av;\n@@ -2545,7 +2436,7 @@ write_length_unit_log ()\n     }\n   printf (\"int length_unit_log = %u;\\n\", length_unit_log);\n }\n-\f\n+\n /* Take a COND expression and see if any of the conditions in it can be\n    simplified.  If any are known true or known false for the particular insn\n    code, the COND can be further simplified.\n@@ -2555,9 +2446,7 @@ write_length_unit_log ()\n    We do not modify EXP; rather, we make and return a new rtx.  */\n \n static rtx\n-simplify_cond (exp, insn_code, insn_index)\n-     rtx exp;\n-     int insn_code, insn_index;\n+simplify_cond (rtx exp, int insn_code, int insn_index)\n {\n   int i, j;\n   /* We store the desired contents here,\n@@ -2668,13 +2557,11 @@ simplify_cond (exp, insn_code, insn_index)\n   free (tests);\n   return ret;\n }\n-\f\n+\n /* Remove an insn entry from an attribute value.  */\n \n static void\n-remove_insn_ent (av, ie)\n-     struct attr_value *av;\n-     struct insn_ent *ie;\n+remove_insn_ent (struct attr_value *av, struct insn_ent *ie)\n {\n   struct insn_ent *previe;\n \n@@ -2697,9 +2584,7 @@ remove_insn_ent (av, ie)\n /* Insert an insn entry in an attribute value list.  */\n \n static void\n-insert_insn_ent (av, ie)\n-     struct attr_value *av;\n-     struct insn_ent *ie;\n+insert_insn_ent (struct attr_value *av, struct insn_ent *ie)\n {\n   ie->next = av->first_insn;\n   av->first_insn = ie;\n@@ -2709,7 +2594,7 @@ insert_insn_ent (av, ie)\n \n   num_insn_ents++;\n }\n-\f\n+\n /* This is a utility routine to take an expression that is a tree of either\n    AND or IOR expressions and insert a new term.  The new term will be\n    inserted at the right side of the first node whose code does not match\n@@ -2720,11 +2605,7 @@ insert_insn_ent (av, ie)\n    If the `term' is itself a tree, all its leaves will be inserted.  */\n \n static rtx\n-insert_right_side (code, exp, term, insn_code, insn_index)\n-     enum rtx_code code;\n-     rtx exp;\n-     rtx term;\n-     int insn_code, insn_index;\n+insert_right_side (enum rtx_code code, rtx exp, rtx term, int insn_code, int insn_index)\n {\n   rtx newexp;\n \n@@ -2776,7 +2657,7 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n \n   return simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n }\n-\f\n+\n /* If we have an expression which AND's a bunch of\n \t(not (eq_attrq \"alternative\" \"n\"))\n    terms, we may have covered all or all but one of the possible alternatives.\n@@ -2786,9 +2667,7 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n    bitmask indicating which alternatives are mentioned within EXP.  */\n \n static int\n-compute_alternative_mask (exp, code)\n-     rtx exp;\n-     enum rtx_code code;\n+compute_alternative_mask (rtx exp, enum rtx_code code)\n {\n   const char *string;\n   if (GET_CODE (exp) == code)\n@@ -2816,8 +2695,7 @@ compute_alternative_mask (exp, code)\n    attribute with the value represented by that bit.  */\n \n static rtx\n-make_alternative_compare (mask)\n-     int mask;\n+make_alternative_compare (int mask)\n {\n   rtx newexp;\n   int i;\n@@ -2831,7 +2709,7 @@ make_alternative_compare (mask)\n \n   return newexp;\n }\n-\f\n+\n /* If we are processing an (eq_attr \"attr\" \"value\") test, we find the value\n    of \"attr\" for this insn code.  From that value, we can compute a test\n    showing when the EQ_ATTR will be true.  This routine performs that\n@@ -2842,10 +2720,7 @@ make_alternative_compare (mask)\n    for the insn corresponding to INSN_CODE and INSN_INDEX.  */\n \n static rtx\n-evaluate_eq_attr (exp, value, insn_code, insn_index)\n-     rtx exp;\n-     rtx value;\n-     int insn_code, insn_index;\n+evaluate_eq_attr (rtx exp, rtx value, int insn_code, int insn_index)\n {\n   rtx orexp, andexp;\n   rtx right;\n@@ -2950,7 +2825,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n   else\n     return newexp;\n }\n-\f\n+\n /* This routine is called when an AND of a term with a tree of AND's is\n    encountered.  If the term or its complement is present in the tree, it\n    can be replaced with TRUE or FALSE, respectively.\n@@ -2966,10 +2841,7 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n    the term.  */\n \n static rtx\n-simplify_and_tree (exp, pterm, insn_code, insn_index)\n-     rtx exp;\n-     rtx *pterm;\n-     int insn_code, insn_index;\n+simplify_and_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n {\n   rtx left, right;\n   rtx newexp;\n@@ -3081,14 +2953,11 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \n   return exp;\n }\n-\f\n+\n /* Similar to `simplify_and_tree', but for IOR trees.  */\n \n static rtx\n-simplify_or_tree (exp, pterm, insn_code, insn_index)\n-     rtx exp;\n-     rtx *pterm;\n-     int insn_code, insn_index;\n+simplify_or_tree (rtx exp, rtx *pterm, int insn_code, int insn_index)\n {\n   rtx left, right;\n   rtx newexp;\n@@ -3151,11 +3020,11 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \n   return exp;\n }\n+\n /* Compute approximate cost of the expression.  Used to decide whether\n    expression is cheap enough for inline.  */\n static int\n-attr_rtx_cost (x)\n-     rtx x;\n+attr_rtx_cost (rtx x)\n {\n   int cost = 0;\n   enum rtx_code code;\n@@ -3198,16 +3067,13 @@ attr_rtx_cost (x)\n     }\n   return cost;\n }\n-\f\n \n /* Simplify test expression and use temporary obstack in order to avoid\n    memory bloat.  Use ATTR_IND_SIMPLIFIED to avoid unnecessary simplifications\n    and avoid unnecessary copying if possible.  */\n \n static rtx\n-simplify_test_exp_in_temp (exp, insn_code, insn_index)\n-  rtx exp;\n-  int insn_code, insn_index;\n+simplify_test_exp_in_temp (rtx exp, int insn_code, int insn_index)\n {\n   rtx x;\n   struct obstack *old;\n@@ -3232,9 +3098,7 @@ simplify_test_exp_in_temp (exp, insn_code, insn_index)\n    it occurs here!  */\n \n static rtx\n-simplify_test_exp (exp, insn_code, insn_index)\n-     rtx exp;\n-     int insn_code, insn_index;\n+simplify_test_exp (rtx exp, int insn_code, int insn_index)\n {\n   rtx left, right;\n   struct attr_desc *attr;\n@@ -3499,13 +3363,13 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n   return newexp;\n }\n-\f\n+\n /* Optimize the attribute lists by seeing if we can determine conditional\n    values from the known values of other attributes.  This will save subroutine\n    calls during the compilation.  */\n \n static void\n-optimize_attrs ()\n+optimize_attrs (void)\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -3578,13 +3442,6 @@ optimize_attrs ()\n \t    continue;\n \n \t  rtl_obstack = temp_obstack;\n-#if 0 /* This was intended as a speed up, but it was slower.  */\n-\t  if (insn_n_alternatives[ie->insn_code] > 6\n-\t      && count_sub_rtxs (av->value, 200) >= 200)\n-\t    newexp = simplify_by_alternatives (av->value, ie->insn_code,\n-\t\t\t\t\t       ie->insn_index);\n-\t  else\n-#endif\n \t  newexp = av->value;\n \t  while (GET_CODE (newexp) == COND)\n \t    {\n@@ -3611,46 +3468,12 @@ optimize_attrs ()\n   free (insn_code_values - 2);\n }\n \n-#if 0\n-static rtx\n-simplify_by_alternatives (exp, insn_code, insn_index)\n-     rtx exp;\n-     int insn_code, insn_index;\n-{\n-  int i;\n-  int len = insn_n_alternatives[insn_code];\n-  rtx newexp = rtx_alloc (COND);\n-  rtx ultimate;\n-\n-  XVEC (newexp, 0) = rtvec_alloc (len * 2);\n-\n-  /* It will not matter what value we use as the default value\n-     of the new COND, since that default will never be used.\n-     Choose something of the right type.  */\n-  for (ultimate = exp; GET_CODE (ultimate) == COND;)\n-    ultimate = XEXP (ultimate, 1);\n-  XEXP (newexp, 1) = ultimate;\n-\n-  for (i = 0; i < insn_n_alternatives[insn_code]; i++)\n-    {\n-      current_alternative_string = attr_numeral (i);\n-      XVECEXP (newexp, 0, i * 2) = make_alternative_compare (1 << i);\n-      XVECEXP (newexp, 0, i * 2 + 1)\n-\t= simplify_cond (exp, insn_code, insn_index);\n-    }\n-\n-  current_alternative_string = 0;\n-  return simplify_cond (newexp, insn_code, insn_index);\n-}\n-#endif\n-\f\n /* If EXP is a suitable expression, reorganize it by constructing an\n    equivalent expression that is a COND with the tests being all combinations\n    of attribute values and the values being simple constants.  */\n \n static rtx\n-simplify_by_exploding (exp)\n-     rtx exp;\n+simplify_by_exploding (rtx exp)\n {\n   rtx list = 0, link, condexp, defval = NULL_RTX;\n   struct dimension *space;\n@@ -3772,7 +3595,7 @@ simplify_by_exploding (exp)\n   /* Give up if nothing is constant.  */\n   if (num_marks == 0)\n     ret = exp;\n-  \n+\n   /* If all values are the default, use that.  */\n   else if (total == most_tests)\n     ret = defval;\n@@ -3804,9 +3627,7 @@ simplify_by_exploding (exp)\n    tests have known value.  */\n \n static int\n-find_and_mark_used_attributes (exp, terms, nterms)\n-     rtx exp, *terms;\n-     int *nterms;\n+find_and_mark_used_attributes (rtx exp, rtx *terms, int *nterms)\n {\n   int i;\n \n@@ -3857,10 +3678,7 @@ find_and_mark_used_attributes (exp, terms, nterms)\n    in the values of the NDIM-dimensional attribute space SPACE.  */\n \n static void\n-unmark_used_attributes (list, space, ndim)\n-     rtx list;\n-     struct dimension *space;\n-     int ndim;\n+unmark_used_attributes (rtx list, struct dimension *space, int ndim)\n {\n   rtx link, exp;\n   int i;\n@@ -3880,8 +3698,7 @@ unmark_used_attributes (list, space, ndim)\n    are tested.  Return the updated number of values.  */\n \n static int\n-add_values_to_cover (dim)\n-     struct dimension *dim;\n+add_values_to_cover (struct dimension *dim)\n {\n   struct attr_value *av;\n   rtx exp, link, *prev;\n@@ -3945,9 +3762,7 @@ add_values_to_cover (dim)\n    and return FALSE if the increment overflowed.  */\n \n static int\n-increment_current_value (space, ndim)\n-     struct dimension *space;\n-     int ndim;\n+increment_current_value (struct dimension *space, int ndim)\n {\n   int i;\n \n@@ -3965,9 +3780,7 @@ increment_current_value (space, ndim)\n    NDIM-dimensional attribute space SPACE.  */\n \n static rtx\n-test_for_current_value (space, ndim)\n-     struct dimension *space;\n-     int ndim;\n+test_for_current_value (struct dimension *space, int ndim)\n {\n   int i;\n   rtx exp = true_rtx;\n@@ -3985,10 +3798,7 @@ test_for_current_value (space, ndim)\n    known EQ_ATTR expressions are set to FALSE.  */\n \n static rtx\n-simplify_with_current_value (exp, space, ndim)\n-     rtx exp;\n-     struct dimension *space;\n-     int ndim;\n+simplify_with_current_value (rtx exp, struct dimension *space, int ndim)\n {\n   int i;\n   rtx x;\n@@ -4018,8 +3828,7 @@ simplify_with_current_value (exp, space, ndim)\n    all EQ_ATTR expressions.  */\n \n static rtx\n-simplify_with_current_value_aux (exp)\n-     rtx exp;\n+simplify_with_current_value_aux (rtx exp)\n {\n   int i;\n   rtx cond;\n@@ -4093,12 +3902,11 @@ simplify_with_current_value_aux (exp)\n       abort ();\n     }\n }\n-\f\n+\n /* Clear the ATTR_CURR_SIMPLIFIED_P flag in EXP and its subexpressions.  */\n \n static void\n-clear_struct_flag (x)\n-     rtx x;\n+clear_struct_flag (rtx x)\n {\n   int i;\n   int j;\n@@ -4155,9 +3963,7 @@ clear_struct_flag (x)\n    But if we count more than MAX objects, stop counting.  */\n \n static int\n-count_sub_rtxs (x, max)\n-     rtx x;\n-     int max;\n+count_sub_rtxs (rtx x, int max)\n {\n   int i;\n   int j;\n@@ -4211,13 +4017,11 @@ count_sub_rtxs (x, max)\n   return total;\n \n }\n-\f\n+\n /* Create table entries for DEFINE_ATTR.  */\n \n static void\n-gen_attr (exp, lineno)\n-     rtx exp;\n-     int lineno;\n+gen_attr (rtx exp, int lineno)\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -4279,14 +4083,13 @@ gen_attr (exp, lineno)\n   XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n   attr->default_val = get_attr_value (XEXP (exp, 2), attr, -2);\n }\n-\f\n+\n /* Given a pattern for DEFINE_PEEPHOLE or DEFINE_INSN, return the number of\n    alternatives in the constraints.  Assume all MATCH_OPERANDs have the same\n    number of alternatives as this should be checked elsewhere.  */\n \n static int\n-count_alternatives (exp)\n-     rtx exp;\n+count_alternatives (rtx exp)\n {\n   int i, j, n;\n   const char *fmt;\n@@ -4318,13 +4121,12 @@ count_alternatives (exp)\n \n   return 0;\n }\n-\f\n+\n /* Returns nonzero if the given expression contains an EQ_ATTR with the\n    `alternative' attribute.  */\n \n static int\n-compares_alternatives_p (exp)\n-     rtx exp;\n+compares_alternatives_p (rtx exp)\n {\n   int i, j;\n   const char *fmt;\n@@ -4351,13 +4153,11 @@ compares_alternatives_p (exp)\n \n   return 0;\n }\n-\f\n+\n /* Returns nonzero is INNER is contained in EXP.  */\n \n static int\n-contained_in_p (inner, exp)\n-     rtx inner;\n-     rtx exp;\n+contained_in_p (rtx inner, rtx exp)\n {\n   int i, j;\n   const char *fmt;\n@@ -4384,13 +4184,11 @@ contained_in_p (inner, exp)\n \n   return 0;\n }\n-\f\n+\n /* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */\n \n static void\n-gen_insn (exp, lineno)\n-     rtx exp;\n-     int lineno;\n+gen_insn (rtx exp, int lineno)\n {\n   struct insn_def *id;\n \n@@ -4432,14 +4230,12 @@ gen_insn (exp, lineno)\n       abort ();\n     }\n }\n-\f\n+\n /* Process a DEFINE_DELAY.  Validate the vector length, check if annul\n    true or annul false is specified, and make a `struct delay_desc'.  */\n \n static void\n-gen_delay (def, lineno)\n-     rtx def;\n-     int lineno;\n+gen_delay (rtx def, int lineno)\n {\n   struct delay_desc *delay;\n   int i;\n@@ -4467,17 +4263,15 @@ gen_delay (def, lineno)\n   delay->lineno = lineno;\n   delays = delay;\n }\n-\f\n+\n /* Process a DEFINE_FUNCTION_UNIT.\n \n    This gives information about a function unit contained in the CPU.\n    We fill in a `struct function_unit_op' and a `struct function_unit'\n    with information used later by `expand_unit'.  */\n \n static void\n-gen_unit (def, lineno)\n-     rtx def;\n-     int lineno;\n+gen_unit (rtx def, int lineno)\n {\n   struct function_unit *unit;\n   struct function_unit_op *op;\n@@ -4558,7 +4352,7 @@ gen_unit (def, lineno)\n      which insns are used by the function unit.  */\n   unit->condexp = insert_right_side (IOR, unit->condexp, op->condexp, -2, -2);\n }\n-\f\n+\n /* Given a piece of RTX, print a C expression to test its truth value.\n    We use AND and IOR both for logical and bit-wise operations, so\n    interpret them as logical unless they are inside a comparison expression.\n@@ -4568,9 +4362,7 @@ gen_unit (def, lineno)\n    a cached local variable instead of calling a function.  */\n \n static void\n-write_test_expr (exp, flags)\n-     rtx exp;\n-     int flags;\n+write_test_expr (rtx exp, int flags)\n {\n   int comparison_operator = 0;\n   RTX_CODE code;\n@@ -4810,14 +4602,12 @@ write_test_expr (exp, flags)\n \n   printf (\")\");\n }\n-\f\n+\n /* Given an attribute value, return the maximum CONST_STRING argument\n    encountered.  Set *UNKNOWNP and return INT_MAX if the value is unknown.  */\n \n static int\n-max_attr_value (exp, unknownp)\n-     rtx exp;\n-     int *unknownp;\n+max_attr_value (rtx exp, int *unknownp)\n {\n   int current_max;\n   int i, n;\n@@ -4859,9 +4649,7 @@ max_attr_value (exp, unknownp)\n    if the numeric value is not known.  */\n \n static int\n-or_attr_value (exp, unknownp)\n-     rtx exp;\n-     int *unknownp;\n+or_attr_value (rtx exp, int *unknownp)\n {\n   int current_or;\n   int i;\n@@ -4891,7 +4679,7 @@ or_attr_value (exp, unknownp)\n \n   return current_or;\n }\n-\f\n+\n /* Scan an attribute value, possibly a conditional, and record what actions\n    will be required to do any conditional tests in it.\n \n@@ -4903,8 +4691,7 @@ or_attr_value (exp, unknownp)\n  */\n \n static void\n-walk_attr_value (exp)\n-     rtx exp;\n+walk_attr_value (rtx exp)\n {\n   int i, j;\n   const char *fmt;\n@@ -4966,12 +4753,11 @@ walk_attr_value (exp)\n \tbreak;\n       }\n }\n-\f\n+\n /* Write out a function to obtain the attribute for a given INSN.  */\n \n static void\n-write_attr_get (attr)\n-     struct attr_desc *attr;\n+write_attr_get (struct attr_desc *attr)\n {\n   struct attr_value *av, *common_av;\n \n@@ -4989,9 +4775,9 @@ write_attr_get (attr)\n   /* If the attribute name starts with a star, the remainder is the name of\n      the subroutine to use, instead of `get_attr_...'.  */\n   if (attr->name[0] == '*')\n-    printf (\"%s PARAMS ((rtx));\\n\", &attr->name[1]);\n+    printf (\"%s (rtx);\\n\", &attr->name[1]);\n   else\n-    printf (\"get_attr_%s PARAMS ((%s));\\n\", attr->name,\n+    printf (\"get_attr_%s (%s);\\n\", attr->name,\n \t    (attr->is_const ? \"void\" : \"rtx\"));\n \n   /* Write out start of function, then all values with explicit `case' lines,\n@@ -5058,17 +4844,14 @@ write_attr_get (attr)\n       printf (\"    }\\n}\\n\\n\");\n     }\n }\n-\f\n+\n /* Given an AND tree of known true terms (because we are inside an `if' with\n    that as the condition or are in an `else' clause) and an expression,\n    replace any known true terms with TRUE.  Use `simplify_and_tree' to do\n    the bulk of the work.  */\n \n static rtx\n-eliminate_known_true (known_true, exp, insn_code, insn_index)\n-     rtx known_true;\n-     rtx exp;\n-     int insn_code, insn_index;\n+eliminate_known_true (rtx known_true, rtx exp, int insn_code, int insn_index)\n {\n   rtx term;\n \n@@ -5089,22 +4872,16 @@ eliminate_known_true (known_true, exp, insn_code, insn_index)\n \n   return exp;\n }\n-\f\n+\n /* Write out a series of tests and assignment statements to perform tests and\n    sets of an attribute value.  We are passed an indentation amount and prefix\n    and suffix strings to write around each attribute value (e.g., \"return\"\n    and \";\").  */\n \n static void\n-write_attr_set (attr, indent, value, prefix, suffix, known_true,\n-\t\tinsn_code, insn_index)\n-     struct attr_desc *attr;\n-     int indent;\n-     rtx value;\n-     const char *prefix;\n-     const char *suffix;\n-     rtx known_true;\n-     int insn_code, insn_index;\n+write_attr_set (struct attr_desc *attr, int indent, rtx value,\n+\t\tconst char *prefix, const char *suffix, rtx known_true,\n+\t\tint insn_code, int insn_index)\n {\n   if (GET_CODE (value) == COND)\n     {\n@@ -5187,18 +4964,13 @@ write_attr_set (attr, indent, value, prefix, suffix, known_true,\n       printf (\"%s\\n\", suffix);\n     }\n }\n-\f\n+\n /* Write out the computation for one attribute value.  */\n \n static void\n-write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n-\t\t known_true)\n-     struct attr_desc *attr;\n-     struct attr_value *av;\n-     int write_case_lines;\n-     const char *prefix, *suffix;\n-     int indent;\n-     rtx known_true;\n+write_attr_case (struct attr_desc *attr, struct attr_value *av,\n+\t\t int write_case_lines, const char *prefix, const char *suffix,\n+\t\t int indent, rtx known_true)\n {\n   struct insn_ent *ie;\n \n@@ -5258,13 +5030,11 @@ write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n     }\n   printf (\"\\n\");\n }\n-\f\n+\n /* Search for uses of non-const attributes and write code to cache them.  */\n \n static int\n-write_expr_attr_cache (p, attr)\n-     rtx p;\n-     struct attr_desc *attr;\n+write_expr_attr_cache (rtx p, struct attr_desc *attr)\n {\n   const char *fmt;\n   int i, ie, j, je;\n@@ -5313,8 +5083,7 @@ write_expr_attr_cache (p, attr)\n    expressions to cater to older compilers.  */\n \n static void\n-write_toplevel_expr (p)\n-     rtx p;\n+write_toplevel_expr (rtx p)\n {\n   struct attr_desc *attr;\n   int i;\n@@ -5342,14 +5111,11 @@ write_toplevel_expr (p)\n   write_test_expr (p, 3);\n   printf (\";\\n\");\n }\n-\f\n+\n /* Utilities to write names in various forms.  */\n \n static void\n-write_unit_name (prefix, num, suffix)\n-     const char *prefix;\n-     int num;\n-     const char *suffix;\n+write_unit_name (const char *prefix, int num, const char *suffix)\n {\n   struct function_unit *unit;\n \n@@ -5364,9 +5130,7 @@ write_unit_name (prefix, num, suffix)\n }\n \n static void\n-write_attr_valueq (attr, s)\n-     struct attr_desc *attr;\n-     const char *s;\n+write_attr_valueq (struct attr_desc *attr, const char *s)\n {\n   if (attr->is_numeric)\n     {\n@@ -5411,9 +5175,7 @@ write_attr_valueq (attr, s)\n }\n \n static void\n-write_attr_value (attr, value)\n-     struct attr_desc *attr;\n-     rtx value;\n+write_attr_value (struct attr_desc *attr, rtx value)\n {\n   int op;\n \n@@ -5469,8 +5231,7 @@ write_attr_value (attr, value)\n }\n \n static void\n-write_upcase (str)\n-     const char *str;\n+write_upcase (const char *str)\n {\n   while (*str)\n     {\n@@ -5481,16 +5242,15 @@ write_upcase (str)\n }\n \n static void\n-write_indent (indent)\n-     int indent;\n+write_indent (int indent)\n {\n   for (; indent > 8; indent -= 8)\n     printf (\"\\t\");\n \n   for (; indent; indent--)\n     printf (\" \");\n }\n-\f\n+\n /* Write a subroutine that is given an insn that requires a delay slot, a\n    delay slot ordinal, and a candidate insn.  It returns nonzero if the\n    candidate can be placed in the specified delay slot of the insn.\n@@ -5504,8 +5264,7 @@ write_indent (indent)\n    or \"annul_false\").  */\n \n static void\n-write_eligible_delay (kind)\n-     const char *kind;\n+write_eligible_delay (const char *kind)\n {\n   struct delay_desc *delay;\n   int max_slots;\n@@ -5621,12 +5380,12 @@ write_eligible_delay (kind)\n \n   printf (\"}\\n\\n\");\n }\n-\f\n+\n /* Write routines to compute conflict cost for function units.  Then write a\n    table describing the available function units.  */\n \n static void\n-write_function_unit_info ()\n+write_function_unit_info (void)\n {\n   struct function_unit *unit;\n   int i;\n@@ -5697,9 +5456,9 @@ write_function_unit_info ()\n }\n \n static void\n-write_complex_function (unit, name, connection)\n-     struct function_unit *unit;\n-     const char *name, *connection;\n+write_complex_function (struct function_unit *unit,\n+\t\t\tconst char *name,\n+\t\t\tconst char *connection)\n {\n   struct attr_desc *case_attr, *attr;\n   struct attr_value *av, *common_av;\n@@ -5708,7 +5467,7 @@ write_complex_function (unit, name, connection)\n   int using_case;\n   int i;\n \n-  printf (\"static int %s_unit_%s PARAMS ((rtx, rtx));\\n\", unit->name, name);\n+  printf (\"static int %s_unit_%s (rtx, rtx);\\n\", unit->name, name);\n   printf (\"static int\\n\");\n   printf (\"%s_unit_%s (executing_insn, candidate_insn)\\n\", unit->name, name);\n   printf (\"     rtx executing_insn;\\n\");\n@@ -5789,16 +5548,15 @@ write_complex_function (unit, name, connection)\n   printf (\"    default:\\n      abort ();\\n\");\n   printf (\"    }\\n}\\n\\n\");\n }\n-\f\n+\n /* This page contains miscellaneous utility routines.  */\n \n /* Given a pointer to a (char *), return a malloc'ed string containing the\n    next comma-separated element.  Advance the pointer to after the string\n    scanned, or the end-of-string.  Return NULL if at end of string.  */\n \n static char *\n-next_comma_elt (pstr)\n-     const char **pstr;\n+next_comma_elt (const char **pstr)\n {\n   const char *start;\n \n@@ -5814,9 +5572,7 @@ next_comma_elt (pstr)\n    is nonzero, build a new attribute, if one does not exist.  */\n \n static struct attr_desc *\n-find_attr (name, create)\n-     const char *name;\n-     int create;\n+find_attr (const char *name, int create)\n {\n   struct attr_desc *attr;\n   int index;\n@@ -5853,10 +5609,7 @@ find_attr (name, create)\n /* Create internal attribute with the given default value.  */\n \n void\n-make_internal_attr (name, value, special)\n-     const char *name;\n-     rtx value;\n-     int special;\n+make_internal_attr (const char *name, rtx value, int special)\n {\n   struct attr_desc *attr;\n \n@@ -5877,8 +5630,7 @@ make_internal_attr (name, value, special)\n /* Find the most used value of an attribute.  */\n \n static struct attr_value *\n-find_most_used (attr)\n-     struct attr_desc *attr;\n+find_most_used (struct attr_desc *attr)\n {\n   struct attr_value *av;\n   struct attr_value *most_used;\n@@ -5898,8 +5650,7 @@ find_most_used (attr)\n    return NULL.  */\n \n static rtx\n-find_single_value (attr)\n-     struct attr_desc *attr;\n+find_single_value (struct attr_desc *attr)\n {\n   struct attr_value *av;\n   rtx unique_value;\n@@ -5920,8 +5671,7 @@ find_single_value (attr)\n /* Return (attr_value \"n\") */\n \n rtx\n-make_numeric_value (n)\n-     int n;\n+make_numeric_value (int n)\n {\n   static rtx int_values[20];\n   rtx exp;\n@@ -5941,12 +5691,9 @@ make_numeric_value (n)\n \n   return exp;\n }\n-\f\n+\n static void\n-extend_range (range, min, max)\n-     struct range *range;\n-     int min;\n-     int max;\n+extend_range (struct range *range, int min, int max)\n {\n   if (range->min > min)\n     range->min = min;\n@@ -5955,49 +5702,20 @@ extend_range (range, min, max)\n }\n \n static rtx\n-copy_rtx_unchanging (orig)\n-     rtx orig;\n+copy_rtx_unchanging (rtx orig)\n {\n-#if 0\n-  rtx copy;\n-  RTX_CODE code;\n-#endif\n-\n   if (ATTR_IND_SIMPLIFIED_P (orig) || ATTR_CURR_SIMPLIFIED_P (orig))\n     return orig;\n \n   ATTR_CURR_SIMPLIFIED_P (orig) = 1;\n   return orig;\n-\n-#if 0\n-  code = GET_CODE (orig);\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-      return orig;\n-\n-    default:\n-      break;\n-    }\n-\n-  copy = rtx_alloc (code);\n-  PUT_MODE (copy, GET_MODE (orig));\n-  ATTR_IND_SIMPLIFIED_P (copy) = 1;\n-\n-  memcpy (&XEXP (copy, 0), &XEXP (orig, 0),\n-\t  GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));\n-  return copy;\n-#endif\n }\n \n /* Determine if an insn has a constant number of delay slots, i.e., the\n    number of delay slots is not a function of the length of the insn.  */\n \n static void\n-write_const_num_delay_slots ()\n+write_const_num_delay_slots (void)\n {\n   struct attr_desc *attr = find_attr (\"*num_delay_slots\", 0);\n   struct attr_value *av;\n@@ -6029,13 +5747,9 @@ write_const_num_delay_slots ()\n       printf (\"    }\\n}\\n\\n\");\n     }\n }\n-\f\n-extern int main PARAMS ((int, char **));\n \n int\n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   rtx desc;\n   struct attr_desc *attr;\n@@ -6101,47 +5815,47 @@ from the machine description file `md'.  */\\n\\n\");\n \tcase DEFINE_CPU_UNIT:\n \t  gen_cpu_unit (desc);\n \t  break;\n-\t  \n+\n \tcase DEFINE_QUERY_CPU_UNIT:\n \t  gen_query_cpu_unit (desc);\n \t  break;\n-\t  \n+\n \tcase DEFINE_BYPASS:\n \t  gen_bypass (desc);\n \t  break;\n-\t  \n+\n \tcase EXCLUSION_SET:\n \t  gen_excl_set (desc);\n \t  break;\n-\t  \n+\n \tcase PRESENCE_SET:\n \t  gen_presence_set (desc);\n \t  break;\n-\t  \n+\n \tcase FINAL_PRESENCE_SET:\n \t  gen_final_presence_set (desc);\n \t  break;\n-\t  \n+\n \tcase ABSENCE_SET:\n \t  gen_absence_set (desc);\n \t  break;\n-\t  \n+\n \tcase FINAL_ABSENCE_SET:\n \t  gen_final_absence_set (desc);\n \t  break;\n-\t  \n+\n \tcase DEFINE_AUTOMATON:\n \t  gen_automaton (desc);\n \t  break;\n-\t  \n+\n \tcase AUTOMATA_OPTION:\n \t  gen_automata_option (desc);\n \t  break;\n-\t  \n+\n \tcase DEFINE_RESERVATION:\n \t  gen_reserv (desc);\n \t  break;\n-\t  \n+\n \tcase DEFINE_INSN_RESERVATION:\n \t  gen_insn_reserv (desc);\n \t  break;\n@@ -6286,8 +6000,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n const char *\n-get_insn_name (code)\n-     int code ATTRIBUTE_UNUSED;\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }"}]}