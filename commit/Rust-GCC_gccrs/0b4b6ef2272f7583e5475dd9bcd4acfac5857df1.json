{"sha": "0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0YjZlZjIyNzJmNzU4M2U1NDc1ZGQ5YmNkNGFjZmFjNTg1N2RmMQ==", "commit": {"author": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2016-01-13T15:51:33Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2016-01-13T15:51:33Z"}, "message": "Fix infinite recursion in create_variable_info_for_1\n\n\tPR tree-optimization/69169\n\t* tree-ssa-structalias.c (create_variable_info_for_1): Add and handle\n\thandled_struct_type param.\n\t(create_variable_info_for, intra_create_variable_infos): Call\n\tcreate_variable_info_for_1 with extra arg.\n\n\t* gcc.dg/pr69169.c: New test.\n\nFrom-SVN: r232326", "tree": {"sha": "66c7aec7d48b31c82fa66f3ab6031cfdf8731b00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66c7aec7d48b31c82fa66f3ab6031cfdf8731b00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/comments", "author": null, "committer": null, "parents": [{"sha": "4e3999a75b7f128650a139b581911f104a177fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3999a75b7f128650a139b581911f104a177fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3999a75b7f128650a139b581911f104a177fd4"}], "stats": {"total": 63, "additions": 55, "deletions": 8}, "files": [{"sha": "26bdba1ca0cac08f5fa4c6d0dfa3bd7256599a3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "patch": "@@ -1,3 +1,11 @@\n+\tPR tree-optimization/69169\n+\t* tree-ssa-structalias.c (create_variable_info_for_1): Add and handle\n+\thandled_struct_type param.\n+\t(create_variable_info_for, intra_create_variable_infos): Call\n+\tcreate_variable_info_for_1 with extra arg.\n+\n+\t* gcc.dg/pr69169.c: New test.\n+\n 2016-01-13  Alexander Fomin <alexander.fomin@intel.com>\n \n \tPR target/69228"}, {"sha": "ecf847cba1bfe7c32e1f71b7050e31d2537f576a", "filename": "gcc/testsuite/gcc.dg/pr69169.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69169.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69169.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69169.c?ref=0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+struct pgm_slist_t\n+{\n+  struct pgm_slist_t *__restrict next;\n+};\n+\n+void\n+fn1 (struct pgm_slist_t p1)\n+{\n+\n+}"}, {"sha": "e7d07975638fc5472fe4b2ad989e16fcf1e76120", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b6ef2272f7583e5475dd9bcd4acfac5857df1/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0b4b6ef2272f7583e5475dd9bcd4acfac5857df1", "patch": "@@ -5769,11 +5769,13 @@ check_for_overlaps (vec<fieldoff_s> fieldstack)\n \n /* Create a varinfo structure for NAME and DECL, and add it to VARMAP.\n    This will also create any varinfo structures necessary for fields\n-   of DECL.  DECL is a function parameter if HANDLE_PARAM is set.  */\n+   of DECL.  DECL is a function parameter if HANDLE_PARAM is set.\n+   HANDLED_STRUCT_TYPE is used to register struct types reached by following\n+   restrict pointers.  This is needed to prevent infinite recursion.  */\n \n static varinfo_t\n create_variable_info_for_1 (tree decl, const char *name, bool add_id,\n-\t\t\t    bool handle_param)\n+\t\t\t    bool handle_param, bitmap handled_struct_type)\n {\n   varinfo_t vi, newvi;\n   tree decl_type = TREE_TYPE (decl);\n@@ -5851,13 +5853,21 @@ create_variable_info_for_1 (tree decl, const char *name, bool add_id,\n \tvi->only_restrict_pointers = 1;\n       if (vi->only_restrict_pointers\n \t  && !type_contains_placeholder_p (TREE_TYPE (decl_type))\n-\t  && handle_param)\n+\t  && handle_param\n+\t  && !bitmap_bit_p (handled_struct_type,\n+\t\t\t    TYPE_UID (TREE_TYPE (decl_type))))\n \t{\n \t  varinfo_t rvi;\n \t  tree heapvar = build_fake_var_decl (TREE_TYPE (decl_type));\n \t  DECL_EXTERNAL (heapvar) = 1;\n+\t  if (var_can_have_subvars (heapvar))\n+\t    bitmap_set_bit (handled_struct_type,\n+\t\t\t    TYPE_UID (TREE_TYPE (decl_type)));\n \t  rvi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\", true,\n-\t\t\t\t\t    true);\n+\t\t\t\t\t    true, handled_struct_type);\n+\t  if (var_can_have_subvars (heapvar))\n+\t    bitmap_clear_bit (handled_struct_type,\n+\t\t\t      TYPE_UID (TREE_TYPE (decl_type)));\n \t  rvi->is_restrict_var = 1;\n \t  insert_vi_for_tree (heapvar, rvi);\n \t  make_constraint_from (vi, rvi->id);\n@@ -5902,13 +5912,21 @@ create_variable_info_for_1 (tree decl, const char *name, bool add_id,\n       newvi->only_restrict_pointers = fo->only_restrict_pointers;\n       if (handle_param\n \t  && newvi->only_restrict_pointers\n-\t  && !type_contains_placeholder_p (fo->restrict_pointed_type))\n+\t  && !type_contains_placeholder_p (fo->restrict_pointed_type)\n+\t  && !bitmap_bit_p (handled_struct_type,\n+\t\t\t    TYPE_UID (fo->restrict_pointed_type)))\n \t{\n \t  varinfo_t rvi;\n \t  tree heapvar = build_fake_var_decl (fo->restrict_pointed_type);\n \t  DECL_EXTERNAL (heapvar) = 1;\n+\t  if (var_can_have_subvars (heapvar))\n+\t    bitmap_set_bit (handled_struct_type,\n+\t\t\t    TYPE_UID (fo->restrict_pointed_type));\n \t  rvi = create_variable_info_for_1 (heapvar, \"PARM_NOALIAS\", true,\n-\t\t\t\t\t    true);\n+\t\t\t\t\t    true, handled_struct_type);\n+\t  if (var_can_have_subvars (heapvar))\n+\t    bitmap_clear_bit (handled_struct_type,\n+\t\t\t      TYPE_UID (fo->restrict_pointed_type));\n \t  rvi->is_restrict_var = 1;\n \t  insert_vi_for_tree (heapvar, rvi);\n \t  make_constraint_from (newvi, rvi->id);\n@@ -5928,7 +5946,7 @@ create_variable_info_for_1 (tree decl, const char *name, bool add_id,\n static unsigned int\n create_variable_info_for (tree decl, const char *name, bool add_id)\n {\n-  varinfo_t vi = create_variable_info_for_1 (decl, name, add_id, false);\n+  varinfo_t vi = create_variable_info_for_1 (decl, name, add_id, false, NULL);\n   unsigned int id = vi->id;\n \n   insert_vi_for_tree (decl, vi);\n@@ -6059,19 +6077,27 @@ static void\n intra_create_variable_infos (struct function *fn)\n {\n   tree t;\n+  bitmap handled_struct_type = NULL;\n \n   /* For each incoming pointer argument arg, create the constraint ARG\n      = NONLOCAL or a dummy variable if it is a restrict qualified\n      passed-by-reference argument.  */\n   for (t = DECL_ARGUMENTS (fn->decl); t; t = DECL_CHAIN (t))\n     {\n+      if (handled_struct_type == NULL)\n+\thandled_struct_type = BITMAP_ALLOC (NULL);\n+\n       varinfo_t p\n-\t= create_variable_info_for_1 (t, alias_get_name (t), false, true);\n+\t= create_variable_info_for_1 (t, alias_get_name (t), false, true,\n+\t\t\t\t      handled_struct_type);\n       insert_vi_for_tree (t, p);\n \n       make_param_constraints (p);\n     }\n \n+  if (handled_struct_type != NULL)\n+    BITMAP_FREE (handled_struct_type);\n+\n   /* Add a constraint for a result decl that is passed by reference.  */\n   if (DECL_RESULT (fn->decl)\n       && DECL_BY_REFERENCE (DECL_RESULT (fn->decl)))"}]}