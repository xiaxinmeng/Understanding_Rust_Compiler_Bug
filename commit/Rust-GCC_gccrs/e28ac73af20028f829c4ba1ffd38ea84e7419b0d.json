{"sha": "e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4YWM3M2FmMjAwMjhmODI5YzRiYTFmZmQzOGVhODRlNzQxOWIwZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-26T14:57:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-26T14:57:46Z"}, "message": "Improve handling of modref params.\n\nthis patch makes insertion to modref access tree smarter when --param\nmodref-max-bases and moredref-max-refs are hit.  Instead of giving up\nwe either give up on base alias set (make it equal to ref) or turn the\nalias set to 0.  This lets us to track useful info on quite large\nfunctions, such as ggc_free.\n\ngcc/ChangeLog:\n\n\t* ipa-modref-tree.c (test_insert_search_collapse): Update test.\n\t* ipa-modref-tree.h (modref_base_node::insert): Be smarter when\n\thiting --param modref-max-refs limit.\n\t(modref_tree:insert_base): Be smarter when hitting\n\t--param modref-max-bases limit. Add new parameter REF.\n\t(modref_tree:insert): Update.\n\t(modref_tree:merge): Update.\n\t* ipa-modref.c (read_modref_records): Update.", "tree": {"sha": "ca72244b2ac18f42d96931b4c06afbbd349947e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca72244b2ac18f42d96931b4c06afbbd349947e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/comments", "author": null, "committer": null, "parents": [{"sha": "c80d7230fba64097e4a2f1c88b189ba46b984519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80d7230fba64097e4a2f1c88b189ba46b984519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80d7230fba64097e4a2f1c88b189ba46b984519"}], "stats": {"total": 114, "additions": 63, "deletions": 51}, "files": [{"sha": "8d147a18aedbcfe4d77c8dcfe26ebce36e44d9eb", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "patch": "@@ -101,7 +101,7 @@ test_insert_search_collapse ()\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Insert base to trigger base list collapse.  */\n-  t->insert (5, 6, a, false);\n+  t->insert (5, 0, a, false);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);"}, {"sha": "97934a91adaf95a6b61a06abb60db1fe966c8c0f", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "patch": "@@ -463,18 +463,23 @@ struct GTY((user)) modref_base_node\n     if (ref_node)\n       return ref_node;\n \n-    if (changed)\n-      *changed = true;\n-\n-    /* Collapse the node if too full already.  */\n-    if (refs && refs->length () >= max_refs)\n+    /* We always allow inserting ref 0.  For non-0 refs there is upper\n+       limit on number of entries and if exceeded,\n+       drop ref conservatively to 0.  */\n+    if (ref && refs && refs->length () >= max_refs)\n       {\n \tif (dump_file)\n-\t  fprintf (dump_file, \"--param param=modref-max-refs limit reached\\n\");\n-\tcollapse ();\n-\treturn NULL;\n+\t  fprintf (dump_file, \"--param param=modref-max-refs limit reached;\"\n+\t\t   \" using 0\\n\");\n+\tref = 0;\n+\tref_node = search (ref);\n+\tif (ref_node)\n+\t  return ref_node;\n       }\n \n+    if (changed)\n+      *changed = true;\n+\n     ref_node = new (ggc_alloc <modref_ref_node <T> > ())modref_ref_node <T>\n \t\t\t\t\t\t\t\t (ref);\n     vec_safe_push (refs, ref_node);\n@@ -532,9 +537,10 @@ struct GTY((user)) modref_tree\n \n   /* Insert BASE; collapse tree if there are more than MAX_REFS.\n      Return inserted base and if CHANGED is non-null set it to true if\n-     something changed.  */\n+     something changed.\n+     If table gets full, try to insert REF instead.  */\n \n-  modref_base_node <T> *insert_base (T base, bool *changed = NULL)\n+  modref_base_node <T> *insert_base (T base, T ref, bool *changed = NULL)\n   {\n     modref_base_node <T> *base_node;\n \n@@ -547,18 +553,31 @@ struct GTY((user)) modref_tree\n     if (base_node)\n       return base_node;\n \n-    if (changed)\n-      *changed = true;\n-\n-    /* Collapse the node if too full already.  */\n-    if (bases && bases->length () >= max_bases)\n+    /* We always allow inserting base 0.  For non-0 base there is upper\n+       limit on number of entries and if exceeded,\n+       drop base conservatively to ref and if it still does not fit to 0.  */\n+    if (base && bases && bases->length () >= max_bases)\n       {\n+\tbase_node = search (ref);\n+\tif (base_node)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"--param param=modref-max-bases\"\n+\t\t       \" limit reached; using ref\\n\");\n+\t    return base_node;\n+\t  }\n \tif (dump_file)\n-\t  fprintf (dump_file, \"--param param=modref-max-bases limit reached\\n\");\n-\tcollapse ();\n-\treturn NULL;\n+\t  fprintf (dump_file, \"--param param=modref-max-bases\"\n+\t\t   \" limit reached; using 0\\n\");\n+\tbase = 0;\n+\tbase_node = search (base);\n+\tif (base_node)\n+\t  return base_node;\n       }\n \n+    if (changed)\n+      *changed = true;\n+\n     base_node = new (ggc_alloc <modref_base_node <T> > ())\n \t\t\t modref_base_node <T> (base);\n     vec_safe_push (bases, base_node);\n@@ -582,8 +601,15 @@ struct GTY((user)) modref_tree\n \treturn true;\n       }\n \n-    modref_base_node <T> *base_node = insert_base (base, &changed);\n-    if (!base_node || base_node->every_ref)\n+    modref_base_node <T> *base_node = insert_base (base, ref, &changed);\n+    base = base_node->base;\n+    /* If table got full we may end up with useless base.  */\n+    if (!base && !ref && !a.useful_p ())\n+      {\n+\tcollapse ();\n+\treturn true;\n+      }\n+    if (base_node->every_ref)\n       return changed;\n     gcc_checking_assert (search (base) != NULL);\n \n@@ -596,40 +622,26 @@ struct GTY((user)) modref_tree\n \n     modref_ref_node <T> *ref_node = base_node->insert_ref (ref, max_refs,\n \t\t\t\t\t\t\t   &changed);\n+    ref = ref_node->ref;\n \n-    /* If we failed to insert ref, just see if there is a cleanup possible.  */\n-    if (!ref_node)\n+    if (ref_node->every_access)\n+      return changed;\n+    changed |= ref_node->insert_access (a, max_accesses,\n+\t\t\t\t\trecord_adjustments);\n+    /* See if we failed to add useful access.  */\n+    if (ref_node->every_access)\n       {\n-\t/* No useful ref information and no useful base; collapse everything.  */\n-\tif (!base && base_node->every_ref)\n+\t/* Collapse everything if there is no useful base and ref.  */\n+\tif (!base && !ref)\n \t  {\n \t    collapse ();\n \t    gcc_checking_assert (changed);\n \t  }\n-\telse if (changed)\n-\t  cleanup ();\n-      }\n-    else\n-      {\n-\tif (ref_node->every_access)\n-\t  return changed;\n-\tchanged |= ref_node->insert_access (a, max_accesses,\n-\t\t\t\t\t    record_adjustments);\n-\t/* See if we failed to add useful access.  */\n-\tif (ref_node->every_access)\n+\t/* Collapse base if there is no useful ref.  */\n+\telse if (!ref)\n \t  {\n-\t    /* Collapse everything if there is no useful base and ref.  */\n-\t    if (!base && !ref)\n-\t      {\n-\t\tcollapse ();\n-\t\tgcc_checking_assert (changed);\n-\t      }\n-\t    /* Collapse base if there is no useful ref.  */\n-\t    else if (!ref)\n-\t      {\n-\t\tbase_node->collapse ();\n-\t\tgcc_checking_assert (changed);\n-\t      }\n+\t    base_node->collapse ();\n+\t    gcc_checking_assert (changed);\n \t  }\n       }\n     return changed;\n@@ -714,7 +726,7 @@ struct GTY((user)) modref_tree\n       {\n \tif (base_node->every_ref)\n \t  {\n-\t    my_base_node = insert_base (base_node->base, &changed);\n+\t    my_base_node = insert_base (base_node->base, 0, &changed);\n \t    if (my_base_node && !my_base_node->every_ref)\n \t      {\n \t\tmy_base_node->collapse ();"}, {"sha": "6e7788efb01acc382d43147afe2f7e95b59585e7", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28ac73af20028f829c4ba1ffd38ea84e7419b0d/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=e28ac73af20028f829c4ba1ffd38ea84e7419b0d", "patch": "@@ -2445,9 +2445,9 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n       if (nolto_ret)\n \tnolto_base_node = (*nolto_ret)->insert_base (base_tree\n \t\t\t\t\t\t     ? get_alias_set (base_tree)\n-\t\t\t\t\t\t     : 0);\n+\t\t\t\t\t\t     : 0, 0);\n       if (lto_ret)\n-\tlto_base_node = (*lto_ret)->insert_base (base_tree);\n+\tlto_base_node = (*lto_ret)->insert_base (base_tree, 0);\n       size_t every_ref = streamer_read_uhwi (ib);\n       size_t nref = streamer_read_uhwi (ib);\n "}]}