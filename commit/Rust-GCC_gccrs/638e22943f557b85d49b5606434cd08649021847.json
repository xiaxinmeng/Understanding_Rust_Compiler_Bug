{"sha": "638e22943f557b85d49b5606434cd08649021847", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4ZTIyOTQzZjU1N2I4NWQ0OWI1NjA2NDM0Y2QwODY0OTAyMTg0Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-20T03:26:54Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-20T03:26:54Z"}, "message": "entered into RCS\n\nFrom-SVN: r1639", "tree": {"sha": "21f95004f8d246af4f5ac2dd2638006e66d787f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21f95004f8d246af4f5ac2dd2638006e66d787f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/638e22943f557b85d49b5606434cd08649021847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638e22943f557b85d49b5606434cd08649021847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638e22943f557b85d49b5606434cd08649021847", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638e22943f557b85d49b5606434cd08649021847/comments", "author": null, "committer": null, "parents": [{"sha": "18a53b787cd3fa67d7e9aaf695c975a632558c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18a53b787cd3fa67d7e9aaf695c975a632558c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18a53b787cd3fa67d7e9aaf695c975a632558c3e"}], "stats": {"total": 401, "additions": 400, "deletions": 1}, "files": [{"sha": "7abbbeab41d3c56d69ffc7a27be323df9308b62d", "filename": "gcc/config/sparc/gmon-sol2.c", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638e22943f557b85d49b5606434cd08649021847/gcc%2Fconfig%2Fsparc%2Fgmon-sol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638e22943f557b85d49b5606434cd08649021847/gcc%2Fconfig%2Fsparc%2Fgmon-sol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fgmon-sol2.c?ref=638e22943f557b85d49b5606434cd08649021847", "patch": "@@ -0,0 +1,399 @@\n+/*-\n+ * Copyright (c) 1991 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. All advertising materials mentioning features or use of this software\n+ *    must display the following acknowledgement:\n+ *\tThis product includes software developed by the University of\n+ *\tCalifornia, Berkeley and its contributors.\n+ * 4. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+/* Mangled into a form that works on Sparc Solaris 2 by Mark Eichin\n+ * for Cygnus Support, July 1992.\n+ */\n+\n+#ifndef lint\n+static char sccsid[] = \"@(#)gmon.c\t5.3 (Berkeley) 5/22/91\";\n+#endif /* not lint */\n+\n+#include <unistd.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#if 0\n+#include \"gmon.h\"\n+#else\n+struct phdr {\n+  char *lpc;\n+  char *hpc;\n+  int ncnt;\n+};\n+#define HISTFRACTION 2\n+#define HISTCOUNTER unsigned short\n+#define HASHFRACTION 1\n+#define ARCDENSITY 2\n+#define MINARCS 50\n+struct tostruct {\n+  char *selfpc;\n+  long count;\n+  unsigned short link;\n+};\n+struct rawarc {\n+    unsigned long       raw_frompc;\n+    unsigned long       raw_selfpc;\n+    long                raw_count;\n+};\n+#define ROUNDDOWN(x,y)  (((x)/(y))*(y))\n+#define ROUNDUP(x,y)    ((((x)+(y)-1)/(y))*(y))\n+\n+#endif\n+\n+/* extern mcount() asm (\"mcount\"); */\n+/*extern*/ char *minbrk /* asm (\"minbrk\") */;\n+\n+    /*\n+     *\tfroms is actually a bunch of unsigned shorts indexing tos\n+     */\n+static int\t\tprofiling = 3;\n+static unsigned short\t*froms;\n+static struct tostruct\t*tos = 0;\n+static long\t\ttolimit = 0;\n+static char\t\t*s_lowpc = 0;\n+static char\t\t*s_highpc = 0;\n+static unsigned long\ts_textsize = 0;\n+\n+static int\tssiz;\n+static char\t*sbuf;\n+static int\ts_scale;\n+    /* see profil(2) where this is describe (incorrectly) */\n+#define\t\tSCALE_1_TO_1\t0x10000L\n+\n+#define\tMSG \"No space for profiling buffer(s)\\n\"\n+\n+monstartup(lowpc, highpc)\n+    char\t*lowpc;\n+    char\t*highpc;\n+{\n+    int\t\t\tmonsize;\n+    char\t\t*buffer;\n+    register int\to;\n+\n+\t/*\n+\t *\tround lowpc and highpc to multiples of the density we're using\n+\t *\tso the rest of the scaling (here and in gprof) stays in ints.\n+\t */\n+    lowpc = (char *)\n+\t    ROUNDDOWN((unsigned)lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_lowpc = lowpc;\n+    highpc = (char *)\n+\t    ROUNDUP((unsigned)highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+    s_highpc = highpc;\n+    s_textsize = highpc - lowpc;\n+    monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n+    buffer = sbrk( monsize );\n+    if ( buffer == (char *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\treturn;\n+    }\n+    froms = (unsigned short *) sbrk( s_textsize / HASHFRACTION );\n+    if ( froms == (unsigned short *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\treturn;\n+    }\n+    tolimit = s_textsize * ARCDENSITY / 100;\n+    if ( tolimit < MINARCS ) {\n+\ttolimit = MINARCS;\n+    } else if ( tolimit > 65534 ) {\n+\ttolimit = 65534;\n+    }\n+    tos = (struct tostruct *) sbrk( tolimit * sizeof( struct tostruct ) );\n+    if ( tos == (struct tostruct *) -1 ) {\n+\twrite( 2 , MSG , sizeof(MSG) );\n+\tfroms = 0;\n+\ttos = 0;\n+\treturn;\n+    }\n+    minbrk = sbrk(0);\n+    tos[0].link = 0;\n+    sbuf = buffer;\n+    ssiz = monsize;\n+    ( (struct phdr *) buffer ) -> lpc = lowpc;\n+    ( (struct phdr *) buffer ) -> hpc = highpc;\n+    ( (struct phdr *) buffer ) -> ncnt = ssiz;\n+    monsize -= sizeof(struct phdr);\n+    if ( monsize <= 0 )\n+\treturn;\n+    o = highpc - lowpc;\n+    if( monsize < o )\n+#ifndef hp300\n+\ts_scale = ( (float) monsize / o ) * SCALE_1_TO_1;\n+#else /* avoid floating point */\n+    {\n+\tint quot = o / monsize;\n+\n+\tif (quot >= 0x10000)\n+\t\ts_scale = 1;\n+\telse if (quot >= 0x100)\n+\t\ts_scale = 0x10000 / quot;\n+\telse if (o >= 0x800000)\n+\t\ts_scale = 0x1000000 / (o / (monsize >> 8));\n+\telse\n+\t\ts_scale = 0x1000000 / ((o << 8) / monsize);\n+    }\n+#endif\n+    else\n+\ts_scale = SCALE_1_TO_1;\n+    moncontrol(1);\n+}\n+\n+_mcleanup()\n+{\n+    int\t\t\tfd;\n+    int\t\t\tfromindex;\n+    int\t\t\tendfrom;\n+    char\t\t*frompc;\n+    int\t\t\ttoindex;\n+    struct rawarc\trawarc;\n+\n+    moncontrol(0);\n+    fd = creat( \"gmon.out\" , 0666 );\n+    if ( fd < 0 ) {\n+\tperror( \"mcount: gmon.out\" );\n+\treturn;\n+    }\n+#   ifdef DEBUG\n+\tfprintf( stderr , \"[mcleanup] sbuf 0x%x ssiz %d\\n\" , sbuf , ssiz );\n+#   endif DEBUG\n+    write( fd , sbuf , ssiz );\n+    endfrom = s_textsize / (HASHFRACTION * sizeof(*froms));\n+    for ( fromindex = 0 ; fromindex < endfrom ; fromindex++ ) {\n+\tif ( froms[fromindex] == 0 ) {\n+\t    continue;\n+\t}\n+\tfrompc = s_lowpc + (fromindex * HASHFRACTION * sizeof(*froms));\n+\tfor (toindex=froms[fromindex]; toindex!=0; toindex=tos[toindex].link) {\n+#\t    ifdef DEBUG\n+\t\tfprintf( stderr ,\n+\t\t\t\"[mcleanup] frompc 0x%x selfpc 0x%x count %d\\n\" ,\n+\t\t\tfrompc , tos[toindex].selfpc , tos[toindex].count );\n+#\t    endif DEBUG\n+\t    rawarc.raw_frompc = (unsigned long) frompc;\n+\t    rawarc.raw_selfpc = (unsigned long) tos[toindex].selfpc;\n+\t    rawarc.raw_count = tos[toindex].count;\n+\t    write( fd , &rawarc , sizeof rawarc );\n+\t}\n+    }\n+    close( fd );\n+}\n+\n+/*\n+ * The Sparc stack frame is only held together by the frame pointers\n+ * in the register windows. According to the SVR4 SPARC ABI\n+ * Supplement, Low Level System Information/Operating System\n+ * Interface/Software Trap Types, a type 3 trap will flush all of the\n+ * register windows to the stack, which will make it possible to walk\n+ * the frames and find the return addresses.\n+ * \tHowever, it seems awfully expensive to incur a trap (system\n+ * call) for every function call. It turns out that \"call\" simply puts\n+ * the return address in %o7 expecting the \"save\" in the procedure to\n+ * shift it into %i7; this means that before the \"save\" occurs, %o7\n+ * contains the address of the call to mcount, and %i7 still contains\n+ * the caller above that. The asm mcount here simply saves those\n+ * registers in argument registers and branches to internal_mcount,\n+ * simulating a call with arguments.\n+ * \tKludges:\n+ * \t1) the branch to internal_mcount is hard coded; it should be\n+ * possible to tell asm to use the assembler-name of a symbol.\n+ * \t2) in theory, the function calling mcount could have saved %i7\n+ * somewhere and reused the register; in practice, I *think* this will\n+ * break longjmp (and maybe the debugger) but I'm not certain. (I take\n+ * some comfort in the knowledge that it will break the native mcount\n+ * as well.)\n+ * \t3) if builtin_return_address worked, this could be portable.\n+ * However, it would really have to be optimized for arguments of 0\n+ * and 1 and do something like what we have here in order to avoid the\n+ * trap per function call performance hit. \n+ * \t4) the atexit and monsetup calls prevent this from simply\n+ * being a leaf routine that doesn't do a \"save\" (and would thus have\n+ * access to %o7 and %i7 directly) but the call to write() at the end\n+ * would have also prevented this.\n+ *\n+ * -- [eichin:19920702.1107EST]\n+ */\n+\n+/* i7 == last ret, -> frompcindex */\n+/* o7 == current ret, -> selfpc */\n+asm(\".global mcount; mcount: mov %i7,%o1; mov %o7,%o0;b,a internal_mcount\");\n+\n+static internal_mcount(selfpc, frompcindex)\n+\tregister char\t\t\t*selfpc;\n+\tregister unsigned short\t\t*frompcindex;\n+{\n+\tregister char\t\t\t*nextframe;\n+\tregister struct tostruct\t*top;\n+\tregister struct tostruct\t*prevtop;\n+\tregister long\t\t\ttoindex;\n+\tstatic char already_setup;\n+\n+\t/*\n+\t *\tfind the return address for mcount,\n+\t *\tand the return address for mcount's caller.\n+\t */\n+\n+\tif(!already_setup) {\n+          extern etext();\n+\t  already_setup = 1;\n+\t  monstartup(0, etext);\n+#ifdef USE_ONEXIT\n+\t  on_exit(_mcleanup, 0);\n+#else\n+\t  atexit(_mcleanup);\n+#endif\n+\t}\n+\t/*\n+\t *\tcheck that we are profiling\n+\t *\tand that we aren't recursively invoked.\n+\t */\n+\tif (profiling) {\n+\t\tgoto out;\n+\t}\n+\tprofiling++;\n+\t/*\n+\t *\tcheck that frompcindex is a reasonable pc value.\n+\t *\tfor example:\tsignal catchers get called from the stack,\n+\t *\t\t\tnot from text space.  too bad.\n+\t */\n+\tfrompcindex = (unsigned short *)((long)frompcindex - (long)s_lowpc);\n+\tif ((unsigned long)frompcindex > s_textsize) {\n+\t\tgoto done;\n+\t}\n+\tfrompcindex =\n+\t    &froms[((long)frompcindex) / (HASHFRACTION * sizeof(*froms))];\n+\ttoindex = *frompcindex;\n+\tif (toindex == 0) {\n+\t\t/*\n+\t\t *\tfirst time traversing this arc\n+\t\t */\n+\t\ttoindex = ++tos[0].link;\n+\t\tif (toindex >= tolimit) {\n+\t\t\tgoto overflow;\n+\t\t}\n+\t\t*frompcindex = toindex;\n+\t\ttop = &tos[toindex];\n+\t\ttop->selfpc = selfpc;\n+\t\ttop->count = 1;\n+\t\ttop->link = 0;\n+\t\tgoto done;\n+\t}\n+\ttop = &tos[toindex];\n+\tif (top->selfpc == selfpc) {\n+\t\t/*\n+\t\t *\tarc at front of chain; usual case.\n+\t\t */\n+\t\ttop->count++;\n+\t\tgoto done;\n+\t}\n+\t/*\n+\t *\thave to go looking down chain for it.\n+\t *\ttop points to what we are looking at,\n+\t *\tprevtop points to previous top.\n+\t *\twe know it is not at the head of the chain.\n+\t */\n+\tfor (; /* goto done */; ) {\n+\t\tif (top->link == 0) {\n+\t\t\t/*\n+\t\t\t *\ttop is end of the chain and none of the chain\n+\t\t\t *\thad top->selfpc == selfpc.\n+\t\t\t *\tso we allocate a new tostruct\n+\t\t\t *\tand link it to the head of the chain.\n+\t\t\t */\n+\t\t\ttoindex = ++tos[0].link;\n+\t\t\tif (toindex >= tolimit) {\n+\t\t\t\tgoto overflow;\n+\t\t\t}\n+\t\t\ttop = &tos[toindex];\n+\t\t\ttop->selfpc = selfpc;\n+\t\t\ttop->count = 1;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\t\t/*\n+\t\t *\totherwise, check the next arc on the chain.\n+\t\t */\n+\t\tprevtop = top;\n+\t\ttop = &tos[top->link];\n+\t\tif (top->selfpc == selfpc) {\n+\t\t\t/*\n+\t\t\t *\tthere it is.\n+\t\t\t *\tincrement its count\n+\t\t\t *\tmove it to the head of the chain.\n+\t\t\t */\n+\t\t\ttop->count++;\n+\t\t\ttoindex = prevtop->link;\n+\t\t\tprevtop->link = top->link;\n+\t\t\ttop->link = *frompcindex;\n+\t\t\t*frompcindex = toindex;\n+\t\t\tgoto done;\n+\t\t}\n+\n+\t}\n+done:\n+\tprofiling--;\n+\t/* and fall through */\n+out:\n+\treturn;\t\t/* normal return restores saved registers */\n+\n+overflow:\n+\tprofiling++; /* halt further profiling */\n+#   define\tTOLIMIT\t\"mcount: tos overflow\\n\"\n+\twrite(2, TOLIMIT, sizeof(TOLIMIT));\n+\tgoto out;\n+}\n+\n+/*\n+ * Control profiling\n+ *\tprofiling is what mcount checks to see if\n+ *\tall the data structures are ready.\n+ */\n+moncontrol(mode)\n+    int mode;\n+{\n+    if (mode) {\n+\t/* start */\n+\tprofil((unsigned short *)(sbuf + sizeof(struct phdr)),\n+\t       ssiz - sizeof(struct phdr),\n+\t       (int)s_lowpc, s_scale);\n+\tprofiling = 0;\n+    } else {\n+\t/* stop */\n+\tprofil((unsigned short *)0, 0, 0, 0);\n+\tprofiling = 3;\n+    }\n+}"}, {"sha": "3c337bd1fe752900d9419b67fa6d70a0f0290f8a", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/638e22943f557b85d49b5606434cd08649021847/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/638e22943f557b85d49b5606434cd08649021847/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=638e22943f557b85d49b5606434cd08649021847", "patch": "@@ -950,7 +950,7 @@ sdbout_one_type (type)\n       TREE_ASM_WRITTEN (type) = 1;\n #if 1\n       /* This is reputed to cause trouble with the following case,\n-\t but perhaps checking TYPE_SIZE above will fix it.\n+\t but perhaps checking TYPE_SIZE above will fix it.  */\n \n       /* Here is a test case:\n "}]}