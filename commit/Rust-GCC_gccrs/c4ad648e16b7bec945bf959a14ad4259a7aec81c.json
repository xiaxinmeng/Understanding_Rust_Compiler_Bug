{"sha": "c4ad648e16b7bec945bf959a14ad4259a7aec81c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRhZDY0OGUxNmI3YmVjOTQ1YmY5NTlhMTRhZDQyNTlhN2FlYzgxYw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-10-05T12:43:58Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-10-05T12:43:58Z"}, "message": "linux.h: Formatting, whitespace.\n\n\t* config/rs6000/linux.h: Formatting, whitespace.\n\t* config/rs6000/linux64.h: Likewise.\n\t* config/rs6000/rs6000-protos.h: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t(easy_vector_splat_const): Add fall thru comments.\n\t(output_vec_const_move): Likewise.\n\nFrom-SVN: r88551", "tree": {"sha": "e14c82fc2413b33a4fea793810a37cb319034ced", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e14c82fc2413b33a4fea793810a37cb319034ced"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4ad648e16b7bec945bf959a14ad4259a7aec81c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ad648e16b7bec945bf959a14ad4259a7aec81c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ad648e16b7bec945bf959a14ad4259a7aec81c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ad648e16b7bec945bf959a14ad4259a7aec81c/comments", "author": null, "committer": null, "parents": [{"sha": "406176bedc8a0b67d7625ae4c8f896d22ef15fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406176bedc8a0b67d7625ae4c8f896d22ef15fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406176bedc8a0b67d7625ae4c8f896d22ef15fcf"}], "stats": {"total": 1306, "additions": 670, "deletions": 636}, "files": [{"sha": "0887fe276e914dab9a9b5d0fc2140585631f0c56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -1,3 +1,12 @@\n+2004-10-05  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/linux.h: Formatting, whitespace.\n+\t* config/rs6000/linux64.h: Likewise.\n+\t* config/rs6000/rs6000-protos.h: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t(easy_vector_splat_const): Add fall thru comments.\n+\t(output_vec_const_move): Likewise.\n+\n 2004-10-05  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.in: Update -Wno-error exceptions for move to build dir."}, {"sha": "d4ce10531fc59a3292c07757a1e97b1800f5c802", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -33,15 +33,15 @@\n #define TARGET_C99_FUNCTIONS 1\n \n #undef  TARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()          \\\n-  do                                      \\\n-    {                                     \\\n-      builtin_define_std (\"PPC\");         \\\n-      builtin_define_std (\"powerpc\");     \\\n-      builtin_assert (\"cpu=powerpc\");     \\\n-      builtin_assert (\"machine=powerpc\"); \\\n-      TARGET_OS_SYSV_CPP_BUILTINS ();\t  \\\n-    }                                     \\\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define_std (\"PPC\");\t\t\\\n+      builtin_define_std (\"powerpc\");\t\t\\\n+      builtin_assert (\"cpu=powerpc\");\t\t\\\n+      builtin_assert (\"machine=powerpc\");\t\\\n+      TARGET_OS_SYSV_CPP_BUILTINS ();\t\t\\\n+    }\t\t\t\t\t\t\\\n   while (0)\n \n #undef\tCPP_OS_DEFAULT_SPEC"}, {"sha": "c98a39059e39d512df3846de3d72df11fcaaced6", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -100,7 +100,7 @@ extern int dot_symbols;\n \t      target_flags &= ~MASK_PROTOTYPE;\t\t\t\\\n \t      error (INVALID_64BIT, \"prototype\");\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n-          if ((target_flags & MASK_POWERPC64) == 0)\t\t\\\n+\t  if ((target_flags & MASK_POWERPC64) == 0)\t\t\\\n \t    {\t\t\t\t\t\t\t\\\n \t      target_flags |= MASK_POWERPC64;\t\t\t\\\n \t      error (\"-m64 requires a PowerPC64 cpu\");\t\t\\\n@@ -134,16 +134,16 @@ extern int dot_symbols;\n \n #ifndef\tRS6000_BI_ARCH\n #define\tASM_DEFAULT_SPEC \"-mppc64\"\n-#define\tASM_SPEC         \"%(asm_spec64) %(asm_spec_common)\"\n+#define\tASM_SPEC\t \"%(asm_spec64) %(asm_spec_common)\"\n #define\tLINK_OS_LINUX_SPEC \"%(link_os_linux_spec64)\"\n #else\n #if DEFAULT_ARCH64_P\n #define\tASM_DEFAULT_SPEC \"-mppc%{!m32:64}\"\n-#define\tASM_SPEC         \"%{m32:%(asm_spec32)}%{!m32:%(asm_spec64)} %(asm_spec_common)\"\n+#define\tASM_SPEC\t \"%{m32:%(asm_spec32)}%{!m32:%(asm_spec64)} %(asm_spec_common)\"\n #define\tLINK_OS_LINUX_SPEC \"%{m32:%(link_os_linux_spec32)}%{!m32:%(link_os_linux_spec64)}\"\n #else\n #define\tASM_DEFAULT_SPEC \"-mppc%{m64:64}\"\n-#define\tASM_SPEC         \"%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)\"\n+#define\tASM_SPEC\t \"%{!m64:%(asm_spec32)}%{m64:%(asm_spec64)} %(asm_spec_common)\"\n #define\tLINK_OS_LINUX_SPEC \"%{!m64:%(link_os_linux_spec32)}%{m64:%(link_os_linux_spec64)}\"\n #endif\n #endif\n@@ -296,7 +296,7 @@ extern int dot_symbols;\n #define TARGET_C99_FUNCTIONS 1\n \n #undef  TARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()            \t\t\\\n+#define TARGET_OS_CPP_BUILTINS()\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if (TARGET_64BIT)\t\t\t\t\t\\"}, {"sha": "32034dedab79ab5015d12b11466a163328884a74", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -138,28 +138,29 @@ extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,\n-\t\t\t    int, int, int, int *);\n+\t\t\t\t\t     int, int, int, int *);\n extern int rs6000_legitimate_address (enum machine_mode, rtx, int);\n extern bool rs6000_mode_dependent_address (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n extern void rs6000_output_symbol_ref (FILE*, rtx);\n extern HOST_WIDE_INT rs6000_initial_elimination_offset (int, int);\n extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx, int);\n \n-extern rtx rs6000_machopic_legitimize_pic_address (rtx orig, \n-                            enum machine_mode mode, rtx reg);\n+extern rtx rs6000_machopic_legitimize_pic_address (rtx orig,\n+\t\t\t\t\t\t   enum machine_mode mode,\n+\t\t\t\t\t\t   rtx reg);\n \n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n extern unsigned int rs6000_special_round_type_align (tree, int, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t\t  tree, int);\n+\t\t\t\t  tree, int);\n extern int function_arg_boundary (enum machine_mode, tree);\n extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode, tree, int);\n+\t\t\t\t     enum machine_mode, tree, int);\n extern int function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode, tree, int);\n+\t\t\t\t       enum machine_mode, tree, int);\n extern rtx rs6000_function_value (tree, tree);\n extern rtx rs6000_libcall_value (enum machine_mode);\n extern struct rtx_def *rs6000_va_arg (tree, tree);\n@@ -199,7 +200,7 @@ extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n extern int vrsave_operation (rtx, enum machine_mode);\n extern int rs6000_register_move_cost (enum machine_mode,\n-\t\t\t\t\t      enum reg_class, enum reg_class);\n+\t\t\t\t      enum reg_class, enum reg_class);\n extern int rs6000_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern bool rs6000_tls_referenced_p (rtx);\n extern int rs6000_tls_symbol_ref (rtx, enum machine_mode);"}, {"sha": "be377ebf4400a57c471ec28f0fc09df6205900b1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 601, "deletions": 577, "changes": 1178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -62,8 +62,7 @@\n #endif\n \n #define EASY_VECTOR_15(n) ((n) >= -16 && (n) <= 15)\n-#define EASY_VECTOR_15_ADD_SELF(n) ((n) >= 0x10 && (n) <= 0x1e \\\n-                                          && !((n) & 1))\n+#define EASY_VECTOR_15_ADD_SELF(n) ((n) >= 0x10 && (n) <= 0x1e && !((n) & 1))\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n@@ -79,7 +78,7 @@ typedef struct rs6000_stack {\n   int toc_save_p;\t\t/* true if the TOC needs to be saved */\n   int push_p;\t\t\t/* true if we need to allocate stack space */\n   int calls_p;\t\t\t/* true if the function makes any calls */\n-  int world_save_p;             /* true if we're saving *everything*:\n+  int world_save_p;\t\t/* true if we're saving *everything*:\n \t\t\t\t   r13-r31, cr, f14-f31, vrsave, v20-v31  */\n   enum rs6000_abi abi;\t\t/* which ABI to use */\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n@@ -296,16 +295,16 @@ struct builtin_description\n /* Target cpu costs.  */\n \n struct processor_costs {\n-  const int mulsi;        /* cost of SImode multiplication.  */\n+  const int mulsi;\t  /* cost of SImode multiplication.  */\n   const int mulsi_const;  /* cost of SImode multiplication by constant.  */\n   const int mulsi_const9; /* cost of SImode mult by short constant.  */\n-  const int muldi;        /* cost of DImode multiplication.  */\n-  const int divsi;        /* cost of SImode division.  */\n-  const int divdi;        /* cost of DImode division.  */\n-  const int fp;           /* cost of simple SFmode and DFmode insns.  */\n-  const int dmul;         /* cost of DFmode multiplication (and fmadd).  */\n-  const int sdiv;         /* cost of SFmode division (fdivs).  */\n-  const int ddiv;         /* cost of DFmode division (fdiv).  */\n+  const int muldi;\t  /* cost of DImode multiplication.  */\n+  const int divsi;\t  /* cost of SImode division.  */\n+  const int divdi;\t  /* cost of DImode division.  */\n+  const int fp;\t\t  /* cost of simple SFmode and DFmode insns.  */\n+  const int dmul;\t  /* cost of DFmode multiplication (and fmadd).  */\n+  const int sdiv;\t  /* cost of SFmode division (fdivs).  */\n+  const int ddiv;\t  /* cost of DFmode division (fdiv).  */\n };\n \n const struct processor_costs *rs6000_cost;\n@@ -717,7 +716,7 @@ static rtx altivec_expand_st_builtin (tree, rtx, bool *);\n static rtx altivec_expand_dst_builtin (tree, rtx, bool *);\n static rtx altivec_expand_abs_builtin (enum insn_code, tree, rtx);\n static rtx altivec_expand_predicate_builtin (enum insn_code,\n-\t\t\t\t\t    const char *, tree, rtx);\n+\t\t\t\t\t     const char *, tree, rtx);\n static rtx altivec_expand_lv_builtin (enum insn_code, tree, rtx);\n static rtx altivec_expand_stv_builtin (enum insn_code, tree);\n static void rs6000_parse_abi_options (void);\n@@ -1158,7 +1157,7 @@ rs6000_override_options (const char *default_cpu)\n \n   rs6000_init_hard_regno_mode_ok ();\n \n- set_masks = POWER_MASKS | POWERPC_MASKS | MASK_SOFT_FLOAT;\n+  set_masks = POWER_MASKS | POWERPC_MASKS | MASK_SOFT_FLOAT;\n #ifdef OS_MISSING_POWERPC64\n   if (OS_MISSING_POWERPC64)\n     set_masks &= ~MASK_POWERPC64;\n@@ -1315,7 +1314,7 @@ rs6000_override_options (const char *default_cpu)\n \n       /* No SPE means 64-bit long doubles, even if an E500.  */\n       if (rs6000_spe_string != 0\n-          && !strcmp (rs6000_spe_string, \"no\"))\n+\t  && !strcmp (rs6000_spe_string, \"no\"))\n \trs6000_long_double_type_size = 64;\n     }\n   else if (rs6000_select[1].string != NULL)\n@@ -1380,15 +1379,15 @@ rs6000_override_options (const char *default_cpu)\n   if (rs6000_sched_costly_dep_str)\n     {\n       if (! strcmp (rs6000_sched_costly_dep_str, \"no\"))\n-        rs6000_sched_costly_dep = no_dep_costly;\n+\trs6000_sched_costly_dep = no_dep_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"all\"))\n-        rs6000_sched_costly_dep = all_deps_costly;\n+\trs6000_sched_costly_dep = all_deps_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"true_store_to_load\"))\n-        rs6000_sched_costly_dep = true_store_to_load_dep_costly;\n+\trs6000_sched_costly_dep = true_store_to_load_dep_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"store_to_load\"))\n-        rs6000_sched_costly_dep = store_to_load_dep_costly;\n+\trs6000_sched_costly_dep = store_to_load_dep_costly;\n       else\n-        rs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n+\trs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n     }\n \n   /* Handle -minsert-sched-nops option.  */\n@@ -1397,13 +1396,13 @@ rs6000_override_options (const char *default_cpu)\n   if (rs6000_sched_insert_nops_str)\n     {\n       if (! strcmp (rs6000_sched_insert_nops_str, \"no\"))\n-        rs6000_sched_insert_nops = sched_finish_none;\n+\trs6000_sched_insert_nops = sched_finish_none;\n       else if (! strcmp (rs6000_sched_insert_nops_str, \"pad\"))\n-        rs6000_sched_insert_nops = sched_finish_pad_groups;\n+\trs6000_sched_insert_nops = sched_finish_pad_groups;\n       else if (! strcmp (rs6000_sched_insert_nops_str, \"regroup_exact\"))\n-        rs6000_sched_insert_nops = sched_finish_regroup_exact;\n+\trs6000_sched_insert_nops = sched_finish_regroup_exact;\n       else\n-        rs6000_sched_insert_nops = atoi (rs6000_sched_insert_nops_str);\n+\trs6000_sched_insert_nops = atoi (rs6000_sched_insert_nops_str);\n     }\n \n #ifdef TARGET_REGNAMES\n@@ -1769,7 +1768,6 @@ count_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n altivec_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-\n   return (register_operand (op, mode)\n \t  && (GET_CODE (op) != REG\n \t      || REGNO (op) > FIRST_PSEUDO_REGISTER\n@@ -1794,7 +1792,7 @@ xer_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n int\n s8bit_cint_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  return ( GET_CODE (op) == CONST_INT\n+  return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) >= -128 && INTVAL (op) <= 127));\n }\n \n@@ -2077,7 +2075,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n #if HOST_BITS_PER_WIDE_INT == 64\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n \t  && mask64_operand (op, mode))\n-\t    return 2;\n+\treturn 2;\n       else\n #endif\n \treturn num_insns_constant_wide (INTVAL (op));\n@@ -2232,17 +2230,21 @@ easy_vector_splat_const (int cst, enum machine_mode mode)\n       if ((cst & 0xffff) != ((cst >> 16) & 0xffff))\n \tbreak;\n       cst = cst >> 16;\n+      /* Fall thru */\n+\n     case V8HImode:\n       if (EASY_VECTOR_15 (cst)\n \t  || EASY_VECTOR_15_ADD_SELF (cst))\n \treturn cst;\n       if ((cst & 0xff) != ((cst >> 8) & 0xff))\n \tbreak;\n       cst = cst >> 8;\n+      /* Fall thru */\n+\n     case V16QImode:\n-\t  if (EASY_VECTOR_15 (cst)\n-\t      || EASY_VECTOR_15_ADD_SELF (cst))\n-\t    return cst;\n+      if (EASY_VECTOR_15 (cst)\n+\t  || EASY_VECTOR_15_ADD_SELF (cst))\n+\treturn cst;\n     default:\n       break;\n     }\n@@ -2385,6 +2387,8 @@ output_vec_const_move (rtx *operands)\n \t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n \t\treturn \"#\";\n \t      cst = cst >> 16;\n+\t      /* Fall thru */\n+\n \t    case V8HImode:\n \t      if (EASY_VECTOR_15 (cst))\n \t\t{\n@@ -2394,6 +2398,8 @@ output_vec_const_move (rtx *operands)\n \t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n \t\treturn \"#\";\n \t      cst = cst >> 8;\n+\t      /* Fall thru */\n+\n \t    case V16QImode:\n \t      if (EASY_VECTOR_15 (cst))\n \t\t{\n@@ -2402,6 +2408,7 @@ output_vec_const_move (rtx *operands)\n \t\t}\n \t      else if (EASY_VECTOR_15_ADD_SELF (cst))\n \t\treturn \"#\";\n+\n \t    default:\n \t      abort ();\n \t    }\n@@ -2416,8 +2423,7 @@ output_vec_const_move (rtx *operands)\n \t pattern of V1DI, V4HI, and V2SF.\n \n \t FIXME: We should probably return # and add post reload\n-\t splitters for these, but this way is so easy ;-).\n-      */\n+\t splitters for these, but this way is so easy ;-).  */\n       operands[1] = GEN_INT (cst);\n       operands[2] = GEN_INT (cst2);\n       if (cst == cst2)\n@@ -2883,7 +2889,7 @@ call_operand (rtx op, enum machine_mode mode)\n \n int\n current_file_function_operand (rtx op,\n-                              enum machine_mode mode ATTRIBUTE_UNUSED)\n+\t\t\t       enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF\n \t  && (DEFAULT_ABI != ABI_AIX || SYMBOL_REF_FUNCTION_P (op))\n@@ -2997,7 +3003,7 @@ small_data_operand (rtx op ATTRIBUTE_UNUSED,\n       HOST_WIDE_INT summand;\n \n       /* We have to be careful here, because it is the referenced address\n-        that must be 32k from _SDA_BASE_, not just the symbol.  */\n+\t that must be 32k from _SDA_BASE_, not just the symbol.  */\n       summand = INTVAL (XEXP (sum, 1));\n       if (summand < 0 || (unsigned HOST_WIDE_INT) summand > g_switch_value)\n        return 0;\n@@ -3211,10 +3217,10 @@ legitimate_indirect_address_p (rtx x, int strict)\n static bool\n macho_lo_sum_memory_operand (rtx x, enum machine_mode mode)\n {\n-    if (!TARGET_MACHO || !flag_pic\n-        || mode != SImode || GET_CODE(x) != MEM)\n-      return false;\n-    x = XEXP (x, 0);\n+  if (!TARGET_MACHO || !flag_pic\n+      || mode != SImode || GET_CODE(x) != MEM)\n+    return false;\n+  x = XEXP (x, 0);\n \n   if (GET_CODE (x) != LO_SUM)\n     return false;\n@@ -3333,19 +3339,19 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       /* We accept [reg + reg] and [reg + OFFSET].  */\n \n       if (GET_CODE (x) == PLUS)\n-      {\n-        rtx op1 = XEXP (x, 0);\n-        rtx op2 = XEXP (x, 1);\n+\t{\n+\t  rtx op1 = XEXP (x, 0);\n+\t  rtx op2 = XEXP (x, 1);\n \n-        op1 = force_reg (Pmode, op1);\n+\t  op1 = force_reg (Pmode, op1);\n \n-        if (GET_CODE (op2) != REG\n-            && (GET_CODE (op2) != CONST_INT\n-                || !SPE_CONST_OFFSET_OK (INTVAL (op2))))\n-          op2 = force_reg (Pmode, op2);\n+\t  if (GET_CODE (op2) != REG\n+\t      && (GET_CODE (op2) != CONST_INT\n+\t\t  || !SPE_CONST_OFFSET_OK (INTVAL (op2))))\n+\t    op2 = force_reg (Pmode, op2);\n \n-        return gen_rtx_PLUS (Pmode, op1, op2);\n-      }\n+\t  return gen_rtx_PLUS (Pmode, op1, op2);\n+\t}\n \n       return force_reg (Pmode, x);\n     }\n@@ -3675,7 +3681,8 @@ rs6000_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n    machopic_function_base_name() defined.  */\n rtx\n rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n-\tint opnum, int type, int ind_levels ATTRIBUTE_UNUSED, int *win)\n+\t\t\t\t  int opnum, int type,\n+\t\t\t\t  int ind_levels ATTRIBUTE_UNUSED, int *win)\n {\n   /* We must recognize output that we have already generated ourselves.  */\n   if (GET_CODE (x) == PLUS\n@@ -3685,8 +3692,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     {\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-                   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-                   opnum, (enum reload_type)type);\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type)type);\n       *win = 1;\n       return x;\n     }\n@@ -3706,8 +3713,8 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       /* Result of previous invocation of this function on Darwin\n \t floating point constant.  */\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\tBASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\topnum, (enum reload_type)type);\n+\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type)type);\n       *win = 1;\n       return x;\n     }\n@@ -3723,26 +3730,26 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n       HOST_WIDE_INT high\n-        = (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \n       /* Check for 32-bit overflow.  */\n       if (high + low != val)\n-        {\n+\t{\n \t  *win = 0;\n \t  return x;\n \t}\n \n       /* Reload the high part into a base reg; leave the low part\n-         in the mem directly.  */\n+\t in the mem directly.  */\n \n       x = gen_rtx_PLUS (GET_MODE (x),\n-                        gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n-                                      GEN_INT (high)),\n-                        GEN_INT (low));\n+\t\t\tgen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n+\t\t\t\t      GEN_INT (high)),\n+\t\t\tGEN_INT (low));\n \n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-                   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-                   opnum, (enum reload_type)type);\n+\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n+\t\t   opnum, (enum reload_type)type);\n       *win = 1;\n       return x;\n     }\n@@ -3765,7 +3772,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t}\n       else\n \tx = gen_rtx_LO_SUM (GET_MODE (x),\n-              gen_rtx_HIGH (Pmode, x), x);\n+\t      gen_rtx_HIGH (Pmode, x), x);\n \n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n@@ -3833,7 +3840,7 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && (XEXP (x, 0) == virtual_stack_vars_rtx\n-         || XEXP (x, 0) == arg_pointer_rtx)\n+\t  || XEXP (x, 0) == arg_pointer_rtx)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     return 1;\n   if (rs6000_legitimate_offset_address_p (mode, x, reg_ok_strict))\n@@ -3938,7 +3945,7 @@ rs6000_conditional_register_usage (void)\n   if (TARGET_SOFT_FLOAT || !TARGET_FPRS)\n     for (i = 32; i < 64; i++)\n       fixed_regs[i] = call_used_regs[i]\n-        = call_really_used_regs[i] = 1;\n+\t= call_really_used_regs[i] = 1;\n \n   if (DEFAULT_ABI == ABI_V4\n       && PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM\n@@ -3970,7 +3977,7 @@ rs6000_conditional_register_usage (void)\n     {\n       global_regs[SPEFSCR_REGNO] = 1;\n       fixed_regs[FIXED_SCRATCH]\n-        = call_used_regs[FIXED_SCRATCH]\n+\t= call_used_regs[FIXED_SCRATCH]\n \t= call_really_used_regs[FIXED_SCRATCH] = 1;\n     }\n \n@@ -4002,7 +4009,7 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n   if (mode == QImode || mode == HImode)\n     {\n       if (dest == NULL)\n-        dest = gen_reg_rtx (mode);\n+\tdest = gen_reg_rtx (mode);\n       emit_insn (gen_rtx_SET (VOIDmode, dest, source));\n       return dest;\n     }\n@@ -4380,7 +4387,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t\t\t  operands[1], mode, operands[0]);\n \t\t  if (operands[0] != operands[1])\n \t\t    emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t\t            operands[0], operands[1]));\n+\t\t\t\t\t    operands[0], operands[1]));\n \t\t  return;\n \t\t}\n #endif\n@@ -4481,7 +4488,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t    {\n \t      operands[1]\n \t\t= gen_const_mem (mode,\n-\t\t\t         create_TOC_reference (XEXP (operands[1], 0)));\n+\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n \t      set_mem_alias_set (operands[1], get_TOC_alias_set ());\n \t    }\n \t}\n@@ -4616,15 +4623,15 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t       cum->prototype, cum->nargs_prototype);\n     }\n \n-    if (fntype\n-\t&& !TARGET_ALTIVEC\n-\t&& TARGET_ALTIVEC_ABI\n-        && ALTIVEC_VECTOR_MODE (TYPE_MODE (TREE_TYPE (fntype))))\n-      {\n-\terror (\"Cannot return value in vector register because\"\n-\t       \" altivec instructions are disabled, use -maltivec\"\n-\t       \" to enable them.\");\n-      }\n+  if (fntype\n+      && !TARGET_ALTIVEC\n+      && TARGET_ALTIVEC_ABI\n+      && ALTIVEC_VECTOR_MODE (TYPE_MODE (TREE_TYPE (fntype))))\n+    {\n+      error (\"Cannot return value in vector register because\"\n+\t     \" altivec instructions are disabled, use -maltivec\"\n+\t     \" to enable them.\");\n+    }\n }\n \f\n /* Return true if TYPE must be passed on the stack and not in registers.  */\n@@ -4752,7 +4759,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       bool stack = false;\n \n       if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n-        {\n+\t{\n \t  cum->vregno++;\n \t  if (!TARGET_ALTIVEC)\n \t    error (\"Cannot pass argument in vector register because\"\n@@ -4770,7 +4777,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \tstack = true;\n \n       if (stack)\n-        {\n+\t{\n \t  int align;\n \n \t  /* Vector parameters must be 16-byte aligned.  This places\n@@ -4810,7 +4817,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  else\n \t    {\n \t      if (mode == DFmode)\n-\t        cum->words += cum->words & 1;\n+\t\tcum->words += cum->words & 1;\n \t      cum->words += rs6000_arg_size (mode, type);\n \t    }\n \t}\n@@ -5026,27 +5033,27 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n     if (TARGET_64BIT && ! cum->prototype)\n       {\n-       /* Vector parameters get passed in vector register\n-          and also in GPRs or memory, in absence of prototype.  */\n-       int align_words;\n-       rtx slot;\n-       align_words = (cum->words + 1) & ~1;\n-\n-       if (align_words >= GP_ARG_NUM_REG)\n-         {\n-           slot = NULL_RTX;\n-         }\n-       else\n-         {\n-           slot = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n-         }\n-       return gen_rtx_PARALLEL (mode,\n-                gen_rtvec (2,\n-                           gen_rtx_EXPR_LIST (VOIDmode,\n-                                              slot, const0_rtx),\n-                           gen_rtx_EXPR_LIST (VOIDmode,\n-                                              gen_rtx_REG (mode, cum->vregno),\n-                                              const0_rtx)));\n+\t/* Vector parameters get passed in vector register\n+\t   and also in GPRs or memory, in absence of prototype.  */\n+\tint align_words;\n+\trtx slot;\n+\talign_words = (cum->words + 1) & ~1;\n+\n+\tif (align_words >= GP_ARG_NUM_REG)\n+\t  {\n+\t    slot = NULL_RTX;\n+\t  }\n+\telse\n+\t  {\n+\t    slot = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\t  }\n+\treturn gen_rtx_PARALLEL (mode,\n+\t\t gen_rtvec (2,\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       slot, const0_rtx),\n+\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t       gen_rtx_REG (mode, cum->vregno),\n+\t\t\t\t\t       const0_rtx)));\n       }\n     else\n       return gen_rtx_REG (mode, cum->vregno);\n@@ -5177,13 +5184,16 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n \t\t      rtx off;\n \t\t      int i=0;\n-                      if (align_words + n_words > GP_ARG_NUM_REG \n-                          && (TARGET_32BIT && TARGET_POWERPC64))\n-                      /* Not all of the arg fits in gprs.  Say that it goes in memory too,\n-                         using a magic NULL_RTX component. Also see comment in \n-\t\t\t rs6000_mixed_function_arg for why the normal \n-\t\t\t function_arg_partial_nregs scheme doesn't work in this case. */\n-                        rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+\t\t      if (align_words + n_words > GP_ARG_NUM_REG\n+\t\t\t  && (TARGET_32BIT && TARGET_POWERPC64))\n+\t\t\t/* Not all of the arg fits in gprs.  Say that it\n+\t\t\t   goes in memory too, using a magic NULL_RTX\n+\t\t\t   component.  Also see comment in\n+\t\t\t   rs6000_mixed_function_arg for why the normal\n+\t\t\t   function_arg_partial_nregs scheme doesn't work\n+\t\t\t   in this case. */\n+\t\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX,\n+\t\t\t\t\t\t       const0_rtx);\n \t\t      do\n \t\t\t{\n \t\t\t  r = gen_rtx_REG (rmode,\n@@ -5317,27 +5327,26 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n   if (nregs == 0)\n     return;\n \n-    for (i = 0; i < nregs; i++)\n+  for (i = 0; i < nregs; i++)\n     {\n       rtx tem = adjust_address_nv (x, reg_mode, i*GET_MODE_SIZE(reg_mode));\n       if (reload_completed)\n-      {\n-\tif (! strict_memory_address_p (reg_mode, XEXP (tem, 0)))\n-\t  tem = NULL_RTX;\n-\telse\n-\t  tem = simplify_gen_subreg (reg_mode, x, BLKmode,\n-\t\t\t\t     i * GET_MODE_SIZE(reg_mode));\n-      }\n+\t{\n+\t  if (! strict_memory_address_p (reg_mode, XEXP (tem, 0)))\n+\t    tem = NULL_RTX;\n+\t  else\n+\t    tem = simplify_gen_subreg (reg_mode, x, BLKmode,\n+\t\t\t\t       i * GET_MODE_SIZE(reg_mode));\n+\t}\n       else\n \ttem = replace_equiv_address (tem, XEXP (tem, 0));\n \n       if (tem == NULL_RTX)\n-        abort ();\n+\tabort ();\n \n       emit_move_insn (tem, gen_rtx_REG (reg_mode, regno + i));\n     }\n }\n-\n \f\n /* Perform any needed actions needed for a function that is receiving a\n    variable number of arguments.\n@@ -5355,7 +5364,8 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n \n static void\n setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n+\t\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED,\n+\t\t\tint no_rtl)\n {\n   CUMULATIVE_ARGS next_cum;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n@@ -5387,13 +5397,13 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (! no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n     {\n       mem = gen_rtx_MEM (BLKmode,\n-\t\t         plus_constant (save_area,\n+\t\t\t plus_constant (save_area,\n \t\t\t\t\tfirst_reg_offset * reg_size)),\n       set_mem_alias_set (mem, set);\n       set_mem_align (mem, BITS_PER_WORD);\n \n       rs6000_move_block_from_reg (GP_ARG_MIN_REG + first_reg_offset, mem,\n-\t\t\t          GP_ARG_NUM_REG - first_reg_offset);\n+\t\t\t\t  GP_ARG_NUM_REG - first_reg_offset);\n     }\n \n   /* Save FP registers if needed.  */\n@@ -5407,18 +5417,19 @@ setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       rtx lab = gen_label_rtx ();\n       int off = (GP_ARG_NUM_REG * reg_size) + ((fregno - FP_ARG_MIN_REG) * 8);\n \n-      emit_jump_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t\t   pc_rtx,\n-\t\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n+      emit_jump_insn\n+\t(gen_rtx_SET (VOIDmode,\n+\t\t      pc_rtx,\n+\t\t      gen_rtx_IF_THEN_ELSE (VOIDmode,\n \t\t\t\t\t    gen_rtx_NE (VOIDmode, cr1,\n-\t\t\t\t\t\t        const0_rtx),\n+\t\t\t\t\t\t\tconst0_rtx),\n \t\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, lab),\n \t\t\t\t\t    pc_rtx)));\n \n       while (fregno <= FP_ARG_V4_MAX_REG)\n \t{\n \t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n-          set_mem_alias_set (mem, set);\n+\t  set_mem_alias_set (mem, set);\n \t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n \t  fregno++;\n \t  off += 8;\n@@ -6371,24 +6382,24 @@ altivec_expand_predicate_builtin (enum insn_code icode, const char *opcode,\n      If you think this is disgusting, look at the specs for the\n      AltiVec predicates.  */\n \n-     switch (cr6_form_int)\n-       {\n-       case 0:\n-\t emit_insn (gen_cr6_test_for_zero (target));\n-\t break;\n-       case 1:\n-\t emit_insn (gen_cr6_test_for_zero_reverse (target));\n-\t break;\n-       case 2:\n-\t emit_insn (gen_cr6_test_for_lt (target));\n-\t break;\n-       case 3:\n-\t emit_insn (gen_cr6_test_for_lt_reverse (target));\n-\t break;\n-       default:\n-\t error (\"argument 1 of __builtin_altivec_predicate is out of range\");\n-\t break;\n-       }\n+  switch (cr6_form_int)\n+    {\n+    case 0:\n+      emit_insn (gen_cr6_test_for_zero (target));\n+      break;\n+    case 1:\n+      emit_insn (gen_cr6_test_for_zero_reverse (target));\n+      break;\n+    case 2:\n+      emit_insn (gen_cr6_test_for_lt (target));\n+      break;\n+    case 3:\n+      emit_insn (gen_cr6_test_for_lt_reverse (target));\n+      break;\n+    default:\n+      error (\"argument 1 of __builtin_altivec_predicate is out of range\");\n+      break;\n+    }\n \n   return target;\n }\n@@ -6846,7 +6857,7 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n     case ALTIVEC_BUILTIN_COMPILETIME_ERROR:\n       arg0 = TREE_VALUE (arglist);\n       while (TREE_CODE (arg0) == NOP_EXPR || TREE_CODE (arg0) == ADDR_EXPR\n-             || TREE_CODE (arg0) == ARRAY_REF)\n+\t     || TREE_CODE (arg0) == ARRAY_REF)\n \targ0 = TREE_OPERAND (arg0, 0);\n       error (\"invalid parameter combination for `%s' AltiVec intrinsic\",\n \t     TREE_STRING_POINTER (arg0));\n@@ -6864,32 +6875,33 @@ altivec_expand_builtin (tree exp, rtx target, bool *expandedp)\n   dp = (struct builtin_description_predicates *) bdesc_altivec_preds;\n   for (i = 0; i < ARRAY_SIZE (bdesc_altivec_preds); i++, dp++)\n     if (dp->code == fcode)\n-      return altivec_expand_predicate_builtin (dp->icode, dp->opcode, arglist, target);\n+      return altivec_expand_predicate_builtin (dp->icode, dp->opcode,\n+\t\t\t\t\t       arglist, target);\n \n   /* LV* are funky.  We initialized them differently.  */\n   switch (fcode)\n     {\n     case ALTIVEC_BUILTIN_LVSL:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvsl,\n-\t\t\t\t\t   arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVSR:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvsr,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVEBX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvebx,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVEHX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvehx,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVEWX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvewx,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVXL:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     case ALTIVEC_BUILTIN_LVX:\n       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx,\n-\t\t\t\t\t  arglist, target);\n+\t\t\t\t\targlist, target);\n     default:\n       break;\n       /* Fall through.  */\n@@ -7233,8 +7245,8 @@ spe_expand_evsel_builtin (enum insn_code icode, tree arglist, rtx target)\n \n static rtx\n rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t      enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t      int ignore ATTRIBUTE_UNUSED)\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -7269,7 +7281,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t  op = gen_reg_rtx (GET_MODE (addr));\n \t  emit_insn (gen_rtx_SET (VOIDmode, op,\n \t\t\t gen_rtx_NEG (GET_MODE (addr), addr)));\n-        }\n+\t}\n       op = gen_rtx_MEM (mode, op);\n \n       if (target == 0\n@@ -7880,7 +7892,7 @@ altivec_init_builtins (void)\n       def_builtin (d->mask, d->name, type, d->code);\n     }\n \n-  /* Initialize target builtin that implements \n+  /* Initialize target builtin that implements\n      targetm.vectorize.builtin_mask_for_load.  */\n   id = get_identifier (\"__builtin_altivec_mask_for_load\");\n   decl = build_decl (FUNCTION_DECL, id, v16qi_ftype_long_pcvoid);\n@@ -7889,7 +7901,7 @@ altivec_init_builtins (void)\n   /* Record the decl. Will be used by rs6000_builtin_mask_for_load.  */\n   altivec_builtin_mask_for_load = decl;\n \n-  /* Initialize target builtin that implements \n+  /* Initialize target builtin that implements\n      targetm.vectorize.builtin_mask_for_store.  */\n   id = get_identifier (\"__builtin_altivec_mask_for_store\");\n   decl = build_decl (FUNCTION_DECL, id, v16qi_ftype_long_pcvoid);\n@@ -8037,11 +8049,11 @@ rs6000_common_init_builtins (void)\n     = build_function_type_list (V8HI_type_node,\n \t\t\t\tV8HI_type_node, V8HI_type_node,\n \t\t\t\tV8HI_type_node, NULL_TREE);\n- tree v4si_ftype_v8hi_v8hi_v4si\n+  tree v4si_ftype_v8hi_v8hi_v4si\n     = build_function_type_list (V4SI_type_node,\n \t\t\t\tV8HI_type_node, V8HI_type_node,\n \t\t\t\tV4SI_type_node, NULL_TREE);\n- tree v4si_ftype_v16qi_v16qi_v4si\n+  tree v4si_ftype_v16qi_v16qi_v4si\n     = build_function_type_list (V4SI_type_node,\n \t\t\t\tV16QI_type_node, V16QI_type_node,\n \t\t\t\tV4SI_type_node, NULL_TREE);\n@@ -8125,7 +8137,7 @@ rs6000_common_init_builtins (void)\n \t    }\n \t}\n       else if (mode0 == mode1 && mode1 == mode2 && mode3 == V16QImode)\n-        {\n+\t{\n \t  switch (mode0)\n \t    {\n \t    case V4SImode:\n@@ -8330,11 +8342,11 @@ rs6000_common_init_builtins (void)\n       mode1 = insn_data[d->icode].operand[1].mode;\n \n       if (mode0 == V4SImode && mode1 == QImode)\n-        type = v4si_ftype_int;\n+\ttype = v4si_ftype_int;\n       else if (mode0 == V8HImode && mode1 == QImode)\n-        type = v8hi_ftype_int;\n+\ttype = v8hi_ftype_int;\n       else if (mode0 == V16QImode && mode1 == QImode)\n-        type = v16qi_ftype_int;\n+\ttype = v16qi_ftype_int;\n       else if (mode0 == V4SFmode && mode1 == V4SFmode)\n \ttype = v4sf_ftype_v4sf;\n       else if (mode0 == V8HImode && mode1 == V16QImode)\n@@ -9616,11 +9628,11 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n \treturn 0;\n       else\n \t{\n-          reg1 = REGNO (XEXP (addr1, 0));\n+\t  reg1 = REGNO (XEXP (addr1, 0));\n \t  /* The offset must be constant!  */\n \t  if (GET_CODE (XEXP (addr1, 1)) != CONST_INT)\n-            return 0;\n-          offset1 = INTVAL (XEXP (addr1, 1));\n+\t    return 0;\n+\t  offset1 = INTVAL (XEXP (addr1, 1));\n \t}\n     }\n   else if (GET_CODE (addr1) != REG)\n@@ -9669,23 +9681,23 @@ secondary_reload_class (enum reg_class class,\n \n   if (TARGET_ELF || (DEFAULT_ABI == ABI_DARWIN\n #if TARGET_MACHO\n-                    && MACHOPIC_INDIRECT\n+\t\t     && MACHOPIC_INDIRECT\n #endif\n-                    ))\n+\t\t     ))\n     {\n       /* We cannot copy a symbolic operand directly into anything\n-         other than BASE_REGS for TARGET_ELF.  So indicate that a\n-         register from BASE_REGS is needed as an intermediate\n-         register.\n+\t other than BASE_REGS for TARGET_ELF.  So indicate that a\n+\t register from BASE_REGS is needed as an intermediate\n+\t register.\n \n \t On Darwin, pic addresses require a load from memory, which\n \t needs a base register.  */\n       if (class != BASE_REGS\n-          && (GET_CODE (in) == SYMBOL_REF\n-              || GET_CODE (in) == HIGH\n-              || GET_CODE (in) == LABEL_REF\n-              || GET_CODE (in) == CONST))\n-        return BASE_REGS;\n+\t  && (GET_CODE (in) == SYMBOL_REF\n+\t      || GET_CODE (in) == HIGH\n+\t      || GET_CODE (in) == LABEL_REF\n+\t      || GET_CODE (in) == CONST))\n+\treturn BASE_REGS;\n     }\n \n   if (GET_CODE (in) == REG)\n@@ -10245,8 +10257,8 @@ print_operand (FILE *file, rtx x, int code)\n       /* This outputs the logical code corresponding to a boolean\n \t expression.  The expression may have one or both operands\n \t negated (if one, only the first one).  For condition register\n-         logical operations, it will also treat the negated\n-         CR codes as NOTs, but not handle NOTs of them.  */\n+\t logical operations, it will also treat the negated\n+\t CR codes as NOTs, but not handle NOTs of them.  */\n       {\n \tconst char *const *t = 0;\n \tconst char *s;\n@@ -10496,9 +10508,10 @@ print_operand (FILE *file, rtx x, int code)\n       if (GET_CODE (x) != SYMBOL_REF)\n \tabort ();\n \n-      /* Mark the decl as referenced so that cgraph will output the function.  */\n+      /* Mark the decl as referenced so that cgraph will output the\n+\t function.  */\n       if (SYMBOL_REF_DECL (x))\n-        mark_decl_referenced (SYMBOL_REF_DECL (x));\n+\tmark_decl_referenced (SYMBOL_REF_DECL (x));\n \n       /* For macho, check to see if we need a stub.  */\n       if (TARGET_MACHO)\n@@ -10649,15 +10662,15 @@ print_operand_address (FILE *file, rtx x)\n \t     INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n #if TARGET_ELF\n   else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n-           && CONSTANT_P (XEXP (x, 1)))\n+\t   && CONSTANT_P (XEXP (x, 1)))\n     {\n       output_addr_const (file, XEXP (x, 1));\n       fprintf (file, \"@l(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n #if TARGET_MACHO\n   else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n-           && CONSTANT_P (XEXP (x, 1)))\n+\t   && CONSTANT_P (XEXP (x, 1)))\n     {\n       fprintf (file, \"lo16(\");\n       output_addr_const (file, XEXP (x, 1));\n@@ -10780,7 +10793,7 @@ rs6000_assemble_visibility (tree decl, int vis)\n       && TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       static const char * const visibility_types[] = {\n-        NULL, \"internal\", \"hidden\", \"protected\"\n+\tNULL, \"internal\", \"hidden\", \"protected\"\n       };\n \n       const char *name, *type;\n@@ -10823,7 +10836,7 @@ rs6000_generate_compare (enum rtx_code code)\n   if (rs6000_compare_fp_p)\n     comp_mode = CCFPmode;\n   else if (code == GTU || code == LTU\n-\t  || code == GEU || code == LEU)\n+\t   || code == GEU || code == LEU)\n     comp_mode = CCUNSmode;\n   else\n     comp_mode = CCmode;\n@@ -11140,7 +11153,7 @@ output_cbranch (rtx op, const char *label, int reversed, rtx insn)\n \t{\n \t  if (abs (prob) > REG_BR_PROB_BASE / 20\n \t      && ((prob > 0) ^ need_longbranch))\n-              pred = \"+\";\n+\t    pred = \"+\";\n \t  else\n \t    pred = \"-\";\n \t}\n@@ -11477,17 +11490,17 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n       bool used_update = false;\n \n       if (MEM_P (src) && INT_REGNO_P (reg))\n-        {\n-          rtx breg;\n+\t{\n+\t  rtx breg;\n \n \t  if (GET_CODE (XEXP (src, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (src, 0)) == PRE_DEC)\n \t    {\n \t      rtx delta_rtx;\n \t      breg = XEXP (XEXP (src, 0), 0);\n-\t      delta_rtx =  GET_CODE (XEXP (src, 0)) == PRE_INC\n-\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n-\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (src)));\n+\t      delta_rtx = (GET_CODE (XEXP (src, 0)) == PRE_INC\n+\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n+\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))));\n \t      emit_insn (TARGET_32BIT\n \t\t\t ? gen_addsi3 (breg, breg, delta_rtx)\n \t\t\t : gen_adddi3 (breg, breg, delta_rtx));\n@@ -11513,7 +11526,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      && REGNO (breg) >= REGNO (dst)\n \t      && REGNO (breg) < REGNO (dst) + nregs)\n \t    j = REGNO (breg) - REGNO (dst);\n-        }\n+\t}\n \n       if (GET_CODE (dst) == MEM && INT_REGNO_P (reg))\n \t{\n@@ -11524,21 +11537,21 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t    {\n \t      rtx delta_rtx;\n \t      breg = XEXP (XEXP (dst, 0), 0);\n-\t      delta_rtx = GET_CODE (XEXP (dst, 0)) == PRE_INC\n-\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (dst)))\n-\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (dst)));\n+\t      delta_rtx = (GET_CODE (XEXP (dst, 0)) == PRE_INC\n+\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (dst)))\n+\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (dst))));\n \n \t      /* We have to update the breg before doing the store.\n \t\t Use store with update, if available.  */\n \n \t      if (TARGET_UPDATE)\n \t\t{\n \t\t  rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n-                  emit_insn (TARGET_32BIT\n-                             ? (TARGET_POWERPC64\n-                                ? gen_movdi_si_update (breg, breg, delta_rtx, nsrc)\n-                                : gen_movsi_update (breg, breg, delta_rtx, nsrc))\n-                             : gen_movdi_di_update (breg, breg, delta_rtx, nsrc));\n+\t\t  emit_insn (TARGET_32BIT\n+\t\t\t     ? (TARGET_POWERPC64\n+\t\t\t\t? gen_movdi_si_update (breg, breg, delta_rtx, nsrc)\n+\t\t\t\t: gen_movsi_update (breg, breg, delta_rtx, nsrc))\n+\t\t\t     : gen_movdi_di_update (breg, breg, delta_rtx, nsrc));\n \t\t  used_update = true;\n \t\t}\n \t      else\n@@ -11695,31 +11708,31 @@ compute_save_world_info(rs6000_stack_t *info_ptr)\n     {\n       rtx insn;\n       for ( insn = get_last_insn_anywhere (); insn; insn = PREV_INSN (insn))\n-        if ( GET_CODE (insn) == CALL_INSN\n-             && SIBLING_CALL_P (insn))\n-          {\n-            info_ptr->world_save_p = 0;\n-            break;\n-          }\n+\tif ( GET_CODE (insn) == CALL_INSN\n+\t     && SIBLING_CALL_P (insn))\n+\t  {\n+\t    info_ptr->world_save_p = 0;\n+\t    break;\n+\t  }\n     }\n \n   if (info_ptr->world_save_p)\n     {\n       /* Even if we're not touching VRsave, make sure there's room on the\n \t stack for it, if it looks like we're calling SAVE_WORLD, which\n-         will attempt to save it. */\n+\t will attempt to save it. */\n       info_ptr->vrsave_size  = 4;\n \n       /* \"Save\" the VRsave register too if we're saving the world.  */\n       if (info_ptr->vrsave_mask == 0)\n-        info_ptr->vrsave_mask = compute_vrsave_mask ();\n+\tinfo_ptr->vrsave_mask = compute_vrsave_mask ();\n \n       /* Because the Darwin register save/restore routines only handle\n-         F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency\n-         check and abort if there's something worng.  */\n+\t F14 .. F31 and V20 .. V31 as per the ABI, perform a consistency\n+\t check and abort if there's something worng.  */\n       if (info_ptr->first_fp_reg_save < FIRST_SAVED_FP_REGNO\n-          || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)\n-        abort ();\n+\t  || info_ptr->first_altivec_reg_save < FIRST_SAVED_ALTIVEC_REGNO)\n+\tabort ();\n     }\n   return;\n }\n@@ -11801,10 +11814,10 @@ is_altivec_return_reg (rtx reg, void *xyes)\n \t\t+---------------------------------------+\n \t\t| Save area for VRSAVE register (Z)\t| 8+P+A+V+L+X+W+Y\n \t\t+---------------------------------------+\n-                | SPE: area for 64-bit GP registers     |\n-                +---------------------------------------+\n-                | SPE alignment padding                 |\n-                +---------------------------------------+\n+\t\t| SPE: area for 64-bit GP registers\t|\n+\t\t+---------------------------------------+\n+\t\t| SPE alignment padding\t\t\t|\n+\t\t+---------------------------------------+\n \t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X+W+Y+Z\n \t\t+---------------------------------------+\n \t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+W+Y+Z+C\n@@ -12012,24 +12025,24 @@ rs6000_stack_info (void)\n       info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n \n       if (TARGET_SPE_ABI && info_ptr->spe_64bit_regs_used != 0)\n-      {\n-        /* Align stack so SPE GPR save area is aligned on a\n-           double-word boundary.  */\n-        if (info_ptr->spe_gp_size != 0)\n-          info_ptr->spe_padding_size\n-            = 8 - (-info_ptr->cr_save_offset % 8);\n-        else\n-          info_ptr->spe_padding_size = 0;\n-\n-        info_ptr->spe_gp_save_offset\n-          = info_ptr->cr_save_offset\n-          - info_ptr->spe_padding_size\n-          - info_ptr->spe_gp_size;\n-\n-        /* Adjust for SPE case.  */\n-        info_ptr->toc_save_offset\n-          = info_ptr->spe_gp_save_offset - info_ptr->toc_size;\n-      }\n+\t{\n+\t  /* Align stack so SPE GPR save area is aligned on a\n+\t     double-word boundary.  */\n+\t  if (info_ptr->spe_gp_size != 0)\n+\t    info_ptr->spe_padding_size\n+\t      = 8 - (-info_ptr->cr_save_offset % 8);\n+\t  else\n+\t    info_ptr->spe_padding_size = 0;\n+\n+\t  info_ptr->spe_gp_save_offset\n+\t    = info_ptr->cr_save_offset\n+\t    - info_ptr->spe_padding_size\n+\t    - info_ptr->spe_gp_size;\n+\n+\t  /* Adjust for SPE case.  */\n+\t  info_ptr->toc_save_offset\n+\t    = info_ptr->spe_gp_save_offset - info_ptr->toc_size;\n+\t}\n       else if (TARGET_ALTIVEC_ABI)\n \t{\n \t  info_ptr->vrsave_save_offset\n@@ -12355,14 +12368,14 @@ rs6000_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n   if (decl)\n     {\n       if (TARGET_ALTIVEC_VRSAVE)\n-        {\n+\t{\n \t  for (type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \t       type; type = TREE_CHAIN (type))\n \t    {\n \t      if (TREE_CODE (TREE_VALUE (type)) == VECTOR_TYPE)\n \t\treturn false;\n \t    }\n-        }\n+\t}\n       if (DEFAULT_ABI == ABI_DARWIN\n \t  || (*targetm.binds_local_p) (decl))\n \t{\n@@ -12737,7 +12750,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12)\n       insn = emit_insn (TARGET_32BIT\n \t\t\t? gen_movsi_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg)\n-\t\t\t: gen_movdi_di_update (stack_reg, stack_reg, \n+\t\t\t: gen_movdi_di_update (stack_reg, stack_reg,\n \t\t\t\t\t    todec, stack_reg));\n     }\n   else\n@@ -12985,7 +12998,7 @@ emit_frame_save (rtx frame_reg, rtx frame_ptr, enum machine_mode mode,\n \t  && !SPE_CONST_OFFSET_OK (offset)))\n     {\n       /* Whomever calls us must make sure r11 is available in the\n-         flow path of instructions in the prologue.  */\n+\t flow path of instructions in the prologue.  */\n       offset_rtx = gen_rtx_REG (Pmode, 11);\n       emit_move_insn (offset_rtx, int_rtx);\n \n@@ -13108,31 +13121,31 @@ rs6000_emit_prologue (void)\n \n       /* save_world expects lr in r0. */\n       if (info->lr_save_p)\n-        {\n-          insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n-\t\t\t         gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-        }\n+\t{\n+\t  insn = emit_move_insn (gen_rtx_REG (Pmode, 0),\n+\t\t\t\t gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n \n       /* The SAVE_WORLD and RESTORE_WORLD routines make a number of\n-         assumptions about the offsets of various bits of the stack\n-         frame.  Abort if things aren't what they should be.  */\n+\t assumptions about the offsets of various bits of the stack\n+\t frame.  Abort if things aren't what they should be.  */\n       if (info->gp_save_offset != -220\n-          || info->fp_save_offset != -144\n-          || info->lr_save_offset != 8\n-          || info->cr_save_offset != 4\n-          || !info->push_p\n-          || !info->lr_save_p\n-          || (current_function_calls_eh_return && info->ehrd_offset != -432)\n-          || (info->vrsave_save_offset != -224\n-              || info->altivec_save_offset != (-224 -16 -192)))\n-        abort ();\n+\t  || info->fp_save_offset != -144\n+\t  || info->lr_save_offset != 8\n+\t  || info->cr_save_offset != 4\n+\t  || !info->push_p\n+\t  || !info->lr_save_p\n+\t  || (current_function_calls_eh_return && info->ehrd_offset != -432)\n+\t  || (info->vrsave_save_offset != -224\n+\t      || info->altivec_save_offset != (-224 -16 -192)))\n+\tabort ();\n \n       treg = gen_rtx_REG (SImode, 11);\n       emit_move_insn (treg, GEN_INT (-info->total_size));\n \n       /* SAVE_WORLD takes the caller's LR in R0 and the frame size\n-         in R11.  It also clobbers R12, so beware!  */\n+\t in R11.  It also clobbers R12, so beware!  */\n \n       /* Preserve CR2 for save_world prologues */\n       sz = 6;\n@@ -13142,81 +13155,81 @@ rs6000_emit_prologue (void)\n       p = rtvec_alloc (sz);\n       j = 0;\n       RTVEC_ELT (p, j++) = gen_rtx_CLOBBER (VOIDmode,\n-                                            gen_rtx_REG (Pmode,\n-                                                         LINK_REGISTER_REGNUM));\n+\t\t\t\t\t    gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t\t LINK_REGISTER_REGNUM));\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n-                                        gen_rtx_SYMBOL_REF (Pmode,\n-                                                            \"*save_world\"));\n+\t\t\t\t\tgen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t\t    \"*save_world\"));\n       /* We do floats first so that the instruction pattern matches\n-         properly.  */\n-     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-        {\n-          rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->fp_save_offset\n-                                            + sp_offset + 8 * i));\n-          rtx mem = gen_rtx_MEM (DFmode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-        }\n+\t properly.  */\n+      for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n+\t{\n+\t  rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->fp_save_offset\n+\t\t\t\t\t    + sp_offset + 8 * i));\n+\t  rtx mem = gen_rtx_MEM (DFmode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+\t}\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n-        {\n-          rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->altivec_save_offset\n-                                            + sp_offset + 16 * i));\n-          rtx mem = gen_rtx_MEM (V4SImode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-        }\n+\t{\n+\t  rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->altivec_save_offset\n+\t\t\t\t\t    + sp_offset + 16 * i));\n+\t  rtx mem = gen_rtx_MEM (V4SImode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+\t}\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-        {\n-          rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->gp_save_offset\n-                                            + sp_offset + reg_size * i));\n-          rtx mem = gen_rtx_MEM (reg_mode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-        }\n-\n-        {\n-          /* CR register traditionally saved as CR2.  */\n-          rtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->cr_save_offset\n-                                            + sp_offset));\n-          rtx mem = gen_rtx_MEM (reg_mode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n-        }\n+\t{\n+\t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->gp_save_offset\n+\t\t\t\t\t    + sp_offset + reg_size * i));\n+\t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+\t}\n+\n+      {\n+\t/* CR register traditionally saved as CR2.  */\n+\trtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n+\trtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t GEN_INT (info->cr_save_offset\n+\t\t\t\t\t  + sp_offset));\n+\trtx mem = gen_rtx_MEM (reg_mode, addr);\n+\tset_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\tRTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, mem, reg);\n+      }\n       /* Prevent any attempt to delete the setting of r0 and treg!  */\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 0));\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode, treg);\n       RTVEC_ELT (p, j++) = gen_rtx_CLOBBER (VOIDmode, sp_reg_rtx);\n \n       insn = emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n       rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n-                            NULL_RTX, NULL_RTX);\n+\t\t\t    NULL_RTX, NULL_RTX);\n \n       if (current_function_calls_eh_return)\n-        {\n-          unsigned int i;\n-          for (i = 0; ; ++i)\n-            {\n-              unsigned int regno = EH_RETURN_DATA_REGNO (i);\n-              if (regno == INVALID_REGNUM)\n-                break;\n-              emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, regno,\n-                               info->ehrd_offset + sp_offset\n-                               + reg_size * (int) i,\n-                               info->total_size);\n-            }\n-        }\n+\t{\n+\t  unsigned int i;\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      unsigned int regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\t      emit_frame_save (frame_reg_rtx, frame_ptr_rtx, reg_mode, regno,\n+\t\t\t       info->ehrd_offset + sp_offset\n+\t\t\t       + reg_size * (int) i,\n+\t\t\t       info->total_size);\n+\t    }\n+\t}\n     }\n \n   /* Save AltiVec registers if needed.  */\n@@ -13546,33 +13559,33 @@ rs6000_emit_prologue (void)\n   if ((TARGET_TOC && TARGET_MINIMAL_TOC && get_pool_size () != 0)\n       || (DEFAULT_ABI == ABI_V4 && flag_pic == 1\n \t  && regs_ever_live[RS6000_PIC_OFFSET_TABLE_REGNUM]))\n-  {\n-    /* If emit_load_toc_table will use the link register, we need to save\n-       it.  We use R12 for this purpose because emit_load_toc_table\n-       can use register 0.  This allows us to use a plain 'blr' to return\n-       from the procedure more often.  */\n-    int save_LR_around_toc_setup = (TARGET_ELF\n-\t\t\t\t    && DEFAULT_ABI != ABI_AIX\n-\t\t\t\t    && flag_pic\n-\t\t\t\t    && ! info->lr_save_p\n-\t\t\t\t    && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0);\n-    if (save_LR_around_toc_setup)\n-      {\n-\trtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n+    {\n+      /* If emit_load_toc_table will use the link register, we need to save\n+\t it.  We use R12 for this purpose because emit_load_toc_table\n+\t can use register 0.  This allows us to use a plain 'blr' to return\n+\t from the procedure more often.  */\n+      int save_LR_around_toc_setup = (TARGET_ELF\n+\t\t\t\t      && DEFAULT_ABI != ABI_AIX\n+\t\t\t\t      && flag_pic\n+\t\t\t\t      && ! info->lr_save_p\n+\t\t\t\t      && EDGE_COUNT (EXIT_BLOCK_PTR->preds) > 0);\n+      if (save_LR_around_toc_setup)\n+\t{\n+\t  rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n \n-\tinsn = emit_move_insn (frame_ptr_rtx, lr);\n-\trs6000_maybe_dead (insn);\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_move_insn (frame_ptr_rtx, lr);\n+\t  rs6000_maybe_dead (insn);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \n-\trs6000_emit_load_toc_table (TRUE);\n+\t  rs6000_emit_load_toc_table (TRUE);\n \n-\tinsn = emit_move_insn (lr, frame_ptr_rtx);\n-\trs6000_maybe_dead (insn);\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n-      }\n-    else\n-      rs6000_emit_load_toc_table (TRUE);\n-  }\n+\t  insn = emit_move_insn (lr, frame_ptr_rtx);\n+\t  rs6000_maybe_dead (insn);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      else\n+\trs6000_emit_load_toc_table (TRUE);\n+    }\n \n #if TARGET_MACHO\n   if (DEFAULT_ABI == ABI_DARWIN\n@@ -13707,88 +13720,88 @@ rs6000_emit_epilogue (int sibcall)\n       rtvec p;\n \n       /* eh_rest_world_r10 will return to the location saved in the LR\n-         stack slot (which is not likely to be our caller.)\n-         Input: R10 -- stack adjustment.  Clobbers R0, R11, R12, R7, R8.\n-         rest_world is similar, except any R10 parameter is ignored.\n-         The exception-handling stuff that was here in 2.95 is no\n-         longer necessary.  */\n+\t stack slot (which is not likely to be our caller.)\n+\t Input: R10 -- stack adjustment.  Clobbers R0, R11, R12, R7, R8.\n+\t rest_world is similar, except any R10 parameter is ignored.\n+\t The exception-handling stuff that was here in 2.95 is no\n+\t longer necessary.  */\n \n       p = rtvec_alloc (9\n \t\t       + 1\n \t\t       + 32 - info->first_gp_reg_save\n-                       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n-                       + 63 + 1 - info->first_fp_reg_save);\n+\t\t       + LAST_ALTIVEC_REGNO + 1 - info->first_altivec_reg_save\n+\t\t       + 63 + 1 - info->first_fp_reg_save);\n \n-      strcpy (rname, (current_function_calls_eh_return) ?\n-                        \"*eh_rest_world_r10\" : \"*rest_world\");\n+      strcpy (rname, ((current_function_calls_eh_return) ?\n+\t\t      \"*eh_rest_world_r10\" : \"*rest_world\"));\n       alloc_rname = ggc_strdup (rname);\n \n       j = 0;\n       RTVEC_ELT (p, j++) = gen_rtx_RETURN (VOIDmode);\n       RTVEC_ELT (p, j++) = gen_rtx_USE (VOIDmode,\n-                                        gen_rtx_REG (Pmode,\n-                                                     LINK_REGISTER_REGNUM));\n+\t\t\t\t\tgen_rtx_REG (Pmode,\n+\t\t\t\t\t\t     LINK_REGISTER_REGNUM));\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n+\t= gen_rtx_USE (VOIDmode, gen_rtx_SYMBOL_REF (Pmode, alloc_rname));\n       /* The instruction pattern requires a clobber here;\n-         it is shared with the restVEC helper. */\n+\t it is shared with the restVEC helper. */\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 11));\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 11));\n \n       {\n-        /* CR register traditionally saved as CR2.  */\n-        rtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n-        rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                 GEN_INT (info->cr_save_offset));\n-        rtx mem = gen_rtx_MEM (reg_mode, addr);\n-        set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-        RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t/* CR register traditionally saved as CR2.  */\n+\trtx reg = gen_rtx_REG (reg_mode, CR2_REGNO);\n+\trtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t GEN_INT (info->cr_save_offset));\n+\trtx mem = gen_rtx_MEM (reg_mode, addr);\n+\tset_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\tRTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n       }\n \n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-        {\n-          rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->gp_save_offset\n-                                            + reg_size * i));\n-          rtx mem = gen_rtx_MEM (reg_mode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n-      }\n+\t{\n+\t  rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->gp_save_offset\n+\t\t\t\t\t    + reg_size * i));\n+\t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t}\n       for (i = 0; info->first_altivec_reg_save + i <= LAST_ALTIVEC_REGNO; i++)\n-        {\n-          rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->altivec_save_offset\n-                                            + 16 * i));\n-          rtx mem = gen_rtx_MEM (V4SImode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n-        }\n+\t{\n+\t  rtx reg = gen_rtx_REG (V4SImode, info->first_altivec_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->altivec_save_offset\n+\t\t\t\t\t    + 16 * i));\n+\t  rtx mem = gen_rtx_MEM (V4SImode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t}\n       for (i = 0; info->first_fp_reg_save + i <= 63; i++)\n-        {\n-          rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n-          rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-                                   GEN_INT (info->fp_save_offset\n-                                            + 8 * i));\n-          rtx mem = gen_rtx_MEM (DFmode, addr);\n-          set_mem_alias_set (mem, rs6000_sr_alias_set);\n-\n-          RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n-        }\n+\t{\n+\t  rtx reg = gen_rtx_REG (DFmode, info->first_fp_reg_save + i);\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (info->fp_save_offset\n+\t\t\t\t\t    + 8 * i));\n+\t  rtx mem = gen_rtx_MEM (DFmode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  RTVEC_ELT (p, j++) = gen_rtx_SET (VOIDmode, reg, mem);\n+\t}\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 0));\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 0));\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 12));\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 12));\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 7));\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 7));\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 8));\n+\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (SImode, 8));\n       RTVEC_ELT (p, j++)\n-        = gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, 10));\n+\t= gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, 10));\n       emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n \n       return;\n@@ -14065,7 +14078,7 @@ rs6000_emit_epilogue (int sibcall)\n       || current_function_calls_eh_return)\n     {\n       if (frame_reg_rtx != sp_reg_rtx)\n-\t  rs6000_emit_stack_tie ();\n+\trs6000_emit_stack_tie ();\n \n       if (use_backchain_to_restore_sp)\n \t{\n@@ -14735,7 +14748,7 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n       void * * found;\n \n       /* Create toc_hash_table.  This can't be done at OVERRIDE_OPTIONS\n-         time because GGC is not initialized at that point.  */\n+\t time because GGC is not initialized at that point.  */\n       if (toc_hash_table == NULL)\n \ttoc_hash_table = htab_create_ggc (1021, toc_hash_function,\n \t\t\t\t\t  toc_hash_eq, NULL);\n@@ -14887,8 +14900,8 @@ output_toc (FILE *file, rtx x, int labelno, enum machine_mode mode)\n \t}\n #else\n \t{\n-          low = INTVAL (x) & 0xffffffff;\n-          high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n+\t  low = INTVAL (x) & 0xffffffff;\n+\t  high = (HOST_WIDE_INT) INTVAL (x) >> 32;\n \t}\n #endif\n \n@@ -15086,7 +15099,7 @@ output_ascii (FILE *file, const char *p, int n)\n \n void\n rs6000_gen_section_name (char **buf, const char *filename,\n-\t\t         const char *section_desc)\n+\t\t\t const char *section_desc)\n {\n   const char *q, *after_last_slash, *last_period = 0;\n   char *p;\n@@ -15110,14 +15123,14 @@ rs6000_gen_section_name (char **buf, const char *filename,\n   for (q = after_last_slash; *q; q++)\n     {\n       if (q == last_period)\n-        {\n+\t{\n \t  strcpy (p, section_desc);\n \t  p += strlen (section_desc);\n \t  break;\n-        }\n+\t}\n \n       else if (ISALNUM (*q))\n-        *p++ = *q;\n+\t*p++ = *q;\n     }\n \n   if (last_period == 0)\n@@ -15287,9 +15300,9 @@ rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n   if (rs6000_sched_groups)\n     {\n       if (is_microcoded_insn (insn))\n-        return 0;\n+\treturn 0;\n       else if (is_cracked_insn (insn))\n-        return more > 2 ? more - 2 : 0;\n+\treturn more > 2 ? more - 2 : 0;\n     }\n \n   return more - 1;\n@@ -15372,7 +15385,7 @@ is_microcoded_insn (rtx insn)\n \t  || type == TYPE_LOAD_UX\n \t  || type == TYPE_STORE_UX\n \t  || type == TYPE_MFCR)\n-        return true;\n+\treturn true;\n     }\n \n   return false;\n@@ -15437,14 +15450,14 @@ is_cracked_insn (rtx insn)\n     {\n       enum attr_type type = get_attr_type (insn);\n       if (type == TYPE_LOAD_U || type == TYPE_STORE_U\n-\t       || type == TYPE_FPLOAD_U || type == TYPE_FPSTORE_U\n-\t       || type == TYPE_FPLOAD_UX || type == TYPE_FPSTORE_UX\n-\t       || type == TYPE_LOAD_EXT || type == TYPE_DELAYED_CR\n-\t       || type == TYPE_COMPARE || type == TYPE_DELAYED_COMPARE\n-\t       || type == TYPE_IMUL_COMPARE || type == TYPE_LMUL_COMPARE\n-\t       || type == TYPE_IDIV || type == TYPE_LDIV\n-\t       || type == TYPE_INSERT_WORD)\n-        return true;\n+\t  || type == TYPE_FPLOAD_U || type == TYPE_FPSTORE_U\n+\t  || type == TYPE_FPLOAD_UX || type == TYPE_FPSTORE_UX\n+\t  || type == TYPE_LOAD_EXT || type == TYPE_DELAYED_CR\n+\t  || type == TYPE_COMPARE || type == TYPE_DELAYED_COMPARE\n+\t  || type == TYPE_IMUL_COMPARE || type == TYPE_LMUL_COMPARE\n+\t  || type == TYPE_IDIV || type == TYPE_LDIV\n+\t  || type == TYPE_INSERT_WORD)\n+\treturn true;\n     }\n \n   return false;\n@@ -15517,16 +15530,17 @@ rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n       && rs6000_sched_restricted_insns_priority)\n     {\n \n-      /* Prioritize insns that can be dispatched only in the first dispatch slot.  */\n+      /* Prioritize insns that can be dispatched only in the first\n+\t dispatch slot.  */\n       if (rs6000_sched_restricted_insns_priority == 1)\n \t/* Attach highest priority to insn. This means that in\n \t   haifa-sched.c:ready_sort(), dispatch-slot restriction considerations\n \t   precede 'priority' (critical path) considerations.  */\n \treturn current_sched_info->sched_max_insns_priority;\n       else if (rs6000_sched_restricted_insns_priority == 2)\n \t/* Increase priority of insn by a minimal amount. This means that in\n-\t   haifa-sched.c:ready_sort(), only 'priority' (critical path) considerations\n-\t   precede dispatch-slot restriction considerations.  */\n+\t   haifa-sched.c:ready_sort(), only 'priority' (critical path)\n+\t   considerations precede dispatch-slot restriction considerations.  */\n \treturn (priority + 1);\n     }\n \n@@ -15681,7 +15695,8 @@ is_store_insn (rtx insn)\n    costly by the given target.  */\n \n static bool\n-rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distance)\n+rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost,\n+\t\t\t     int distance)\n {\n   /* If the flag is not enbled - no dependence is considered costly;\n      allow all dependent insns in the same group.\n@@ -15705,7 +15720,8 @@ rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distanc\n       && is_load_insn (next)\n       && is_store_insn (insn)\n       && (!link || (int) REG_NOTE_KIND (link) == 0))\n-     /* Prevent load after store in the same group if it is a true dependence.  */\n+     /* Prevent load after store in the same group if it is a true\n+\tdependence.  */\n      return true;\n \n   /* The flag is set to X; dependences with latency >= X are considered costly,\n@@ -15775,13 +15791,13 @@ insn_terminates_group_p (rtx insn, enum group_termination which_group)\n   if (which_group == current_group)\n     {\n       if (is_branch_slot_insn (insn))\n-        return true;\n+\treturn true;\n       return false;\n     }\n   else if (which_group == previous_group)\n     {\n       if (is_dispatch_slot_restricted (insn))\n-        return true;\n+\treturn true;\n       return false;\n     }\n \n@@ -15803,17 +15819,17 @@ is_costly_group (rtx *group_insns, rtx next_insn)\n     {\n       rtx insn = group_insns[i];\n       if (!insn)\n-        continue;\n+\tcontinue;\n       for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n-        {\n-          rtx next = XEXP (link, 0);\n-          if (next == next_insn)\n-            {\n-              cost = insn_cost (insn, link, next_insn);\n-              if (rs6000_is_costly_dependence (insn, next_insn, link, cost, 0))\n-                return true;\n-            }\n-        }\n+\t{\n+\t  rtx next = XEXP (link, 0);\n+\t  if (next == next_insn)\n+\t    {\n+\t      cost = insn_cost (insn, link, next_insn);\n+\t      if (rs6000_is_costly_dependence (insn, next_insn, link, cost, 0))\n+\t\treturn true;\n+\t    }\n+\t}\n     }\n \n   return false;\n@@ -15833,8 +15849,9 @@ is_costly_group (rtx *group_insns, rtx next_insn)\n    last group, and how many dispatch groups were encountered so far).  */\n \n static int\n-force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n-\t\t bool *group_end, int can_issue_more, int *group_count)\n+force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n+\t\t rtx next_insn, bool *group_end, int can_issue_more,\n+\t\t int *group_count)\n {\n   rtx nop;\n   bool force;\n@@ -15854,27 +15871,27 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n \n   if (sched_verbose > 6)\n     fprintf (dump,\"force: group count = %d, can_issue_more = %d\\n\",\n-\t\t\t*group_count ,can_issue_more);\n+\t     *group_count ,can_issue_more);\n \n   if (rs6000_sched_insert_nops == sched_finish_regroup_exact)\n     {\n       if (*group_end)\n-        can_issue_more = 0;\n+\tcan_issue_more = 0;\n \n       /* Since only a branch can be issued in the last issue_slot, it is\n \t sufficient to insert 'can_issue_more - 1' nops if next_insn is not\n \t a branch. If next_insn is a branch, we insert 'can_issue_more' nops;\n-\t in this case the last nop will start a new group and the branch will be\n-\t forced to the new group.  */\n+\t in this case the last nop will start a new group and the branch\n+\t will be forced to the new group.  */\n       if (can_issue_more && !is_branch_slot_insn (next_insn))\n-        can_issue_more--;\n+\tcan_issue_more--;\n \n       while (can_issue_more > 0)\n-        {\n-          nop = gen_nop();\n-          emit_insn_before (nop, next_insn);\n-          can_issue_more--;\n-        }\n+\t{\n+\t  nop = gen_nop();\n+\t  emit_insn_before (nop, next_insn);\n+\t  can_issue_more--;\n+\t}\n \n       *group_end = true;\n       return 0;\n@@ -15885,56 +15902,57 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n       int n_nops = rs6000_sched_insert_nops;\n \n       /* Nops can't be issued from the branch slot, so the effective\n-         issue_rate for nops is 'issue_rate - 1'.  */\n+\t issue_rate for nops is 'issue_rate - 1'.  */\n       if (can_issue_more == 0)\n-        can_issue_more = issue_rate;\n+\tcan_issue_more = issue_rate;\n       can_issue_more--;\n       if (can_issue_more == 0)\n-        {\n-          can_issue_more = issue_rate - 1;\n-          (*group_count)++;\n-          end = true;\n-          for (i = 0; i < issue_rate; i++)\n-            {\n-              group_insns[i] = 0;\n-            }\n-        }\n+\t{\n+\t  can_issue_more = issue_rate - 1;\n+\t  (*group_count)++;\n+\t  end = true;\n+\t  for (i = 0; i < issue_rate; i++)\n+\t    {\n+\t      group_insns[i] = 0;\n+\t    }\n+\t}\n \n       while (n_nops > 0)\n-        {\n-          nop = gen_nop ();\n-          emit_insn_before (nop, next_insn);\n-          if (can_issue_more == issue_rate - 1) /* new group begins */\n-            end = false;\n-          can_issue_more--;\n-          if (can_issue_more == 0)\n-            {\n-              can_issue_more = issue_rate - 1;\n-              (*group_count)++;\n-              end = true;\n-              for (i = 0; i < issue_rate; i++)\n-                {\n-                  group_insns[i] = 0;\n-                }\n-            }\n-          n_nops--;\n-        }\n+\t{\n+\t  nop = gen_nop ();\n+\t  emit_insn_before (nop, next_insn);\n+\t  if (can_issue_more == issue_rate - 1) /* new group begins */\n+\t    end = false;\n+\t  can_issue_more--;\n+\t  if (can_issue_more == 0)\n+\t    {\n+\t      can_issue_more = issue_rate - 1;\n+\t      (*group_count)++;\n+\t      end = true;\n+\t      for (i = 0; i < issue_rate; i++)\n+\t\t{\n+\t\t  group_insns[i] = 0;\n+\t\t}\n+\t    }\n+\t  n_nops--;\n+\t}\n \n       /* Scale back relative to 'issue_rate' (instead of 'issue_rate - 1').  */\n       can_issue_more++;\n \n-      *group_end = /* Is next_insn going to start a new group?  */\n-\t  (end\n+      /* Is next_insn going to start a new group?  */\n+      *group_end\n+\t= (end\n \t   || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n \t   || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n \t   || (can_issue_more < issue_rate &&\n-\t      insn_terminates_group_p (next_insn, previous_group)));\n+\t       insn_terminates_group_p (next_insn, previous_group)));\n       if (*group_end && end)\n-        (*group_count)--;\n+\t(*group_count)--;\n \n       if (sched_verbose > 6)\n-        fprintf (dump, \"done force: group count = %d, can_issue_more = %d\\n\",\n-\t\t\t*group_count, can_issue_more);\n+\tfprintf (dump, \"done force: group count = %d, can_issue_more = %d\\n\",\n+\t\t *group_count, can_issue_more);\n       return can_issue_more;\n     }\n \n@@ -15997,43 +16015,45 @@ redefine_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n       slot = (issue_rate - can_issue_more);\n       group_insns[slot] = insn;\n       can_issue_more =\n-        rs6000_variable_issue (dump, sched_verbose, insn, can_issue_more);\n+\trs6000_variable_issue (dump, sched_verbose, insn, can_issue_more);\n       if (insn_terminates_group_p (insn, current_group))\n-        can_issue_more = 0;\n+\tcan_issue_more = 0;\n \n       next_insn = get_next_active_insn (insn, tail);\n       if (next_insn == NULL_RTX)\n-        return group_count + 1;\n+\treturn group_count + 1;\n \n-      group_end = /* Is next_insn going to start a new group?  */\n-        (can_issue_more == 0\n-         || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n-         || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n-         || (can_issue_more < issue_rate &&\n-             insn_terminates_group_p (next_insn, previous_group)));\n+      /* Is next_insn going to start a new group?  */\n+      group_end\n+\t= (can_issue_more == 0\n+\t   || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n+\t   || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n+\t   || (can_issue_more < issue_rate &&\n+\t       insn_terminates_group_p (next_insn, previous_group)));\n \n       can_issue_more = force_new_group (sched_verbose, dump, group_insns,\n-\t\t\tnext_insn, &group_end, can_issue_more, &group_count);\n+\t\t\t\t\tnext_insn, &group_end, can_issue_more,\n+\t\t\t\t\t&group_count);\n \n       if (group_end)\n-        {\n-          group_count++;\n-          can_issue_more = 0;\n-          for (i = 0; i < issue_rate; i++)\n-            {\n-              group_insns[i] = 0;\n-            }\n-        }\n+\t{\n+\t  group_count++;\n+\t  can_issue_more = 0;\n+\t  for (i = 0; i < issue_rate; i++)\n+\t    {\n+\t      group_insns[i] = 0;\n+\t    }\n+\t}\n \n       if (GET_MODE (next_insn) == TImode && can_issue_more)\n-        PUT_MODE(next_insn, VOIDmode);\n+\tPUT_MODE(next_insn, VOIDmode);\n       else if (!can_issue_more && GET_MODE (next_insn) != TImode)\n-        PUT_MODE (next_insn, TImode);\n+\tPUT_MODE (next_insn, TImode);\n \n       insn = next_insn;\n       if (can_issue_more == 0)\n-        can_issue_more = issue_rate;\n-   } /* while */\n+\tcan_issue_more = issue_rate;\n+    } /* while */\n \n   return group_count;\n }\n@@ -16069,33 +16089,33 @@ pad_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n       group_end = (next_insn == NULL_RTX || GET_MODE (next_insn) == TImode);\n \n       if (next_insn == NULL_RTX)\n-        break;\n+\tbreak;\n \n       if (group_end)\n-        {\n-          /* If the scheduler had marked group termination at this location\n-             (between insn and next_indn), and neither insn nor next_insn will\n-             force group termination, pad the group with nops to force group\n-             termination.  */\n-          if (can_issue_more\n-              && (rs6000_sched_insert_nops == sched_finish_pad_groups)\n-              && !insn_terminates_group_p (insn, current_group)\n-              && !insn_terminates_group_p (next_insn, previous_group))\n-            {\n-              if (!is_branch_slot_insn(next_insn))\n-                can_issue_more--;\n-\n-              while (can_issue_more)\n-                {\n-                  nop = gen_nop ();\n-                  emit_insn_before (nop, next_insn);\n-                  can_issue_more--;\n-                }\n-            }\n-\n-          can_issue_more = issue_rate;\n-          group_count++;\n-        }\n+\t{\n+\t  /* If the scheduler had marked group termination at this location\n+\t     (between insn and next_indn), and neither insn nor next_insn will\n+\t     force group termination, pad the group with nops to force group\n+\t     termination.  */\n+\t  if (can_issue_more\n+\t      && (rs6000_sched_insert_nops == sched_finish_pad_groups)\n+\t      && !insn_terminates_group_p (insn, current_group)\n+\t      && !insn_terminates_group_p (next_insn, previous_group))\n+\t    {\n+\t      if (!is_branch_slot_insn(next_insn))\n+\t\tcan_issue_more--;\n+\n+\t      while (can_issue_more)\n+\t\t{\n+\t\t  nop = gen_nop ();\n+\t\t  emit_insn_before (nop, next_insn);\n+\t\t  can_issue_more--;\n+\t\t}\n+\t    }\n+\n+\t  can_issue_more = issue_rate;\n+\t  group_count++;\n+\t}\n \n       insn = next_insn;\n       next_insn = get_next_active_insn (insn, tail);\n@@ -16118,16 +16138,16 @@ rs6000_sched_finish (FILE *dump, int sched_verbose)\n   if (reload_completed && rs6000_sched_groups)\n     {\n       if (rs6000_sched_insert_nops == sched_finish_none)\n-        return;\n+\treturn;\n \n       if (rs6000_sched_insert_nops == sched_finish_pad_groups)\n-        n_groups = pad_groups (dump, sched_verbose,\n-\t\t\t\tcurrent_sched_info->prev_head,\n-  \t\t\t   \tcurrent_sched_info->next_tail);\n+\tn_groups = pad_groups (dump, sched_verbose,\n+\t\t\t       current_sched_info->prev_head,\n+\t\t\t       current_sched_info->next_tail);\n       else\n-        n_groups = redefine_groups (dump, sched_verbose,\n-\t\t\t\tcurrent_sched_info->prev_head,\n-  \t\t\t\tcurrent_sched_info->next_tail);\n+\tn_groups = redefine_groups (dump, sched_verbose,\n+\t\t\t\t    current_sched_info->prev_head,\n+\t\t\t\t    current_sched_info->next_tail);\n \n       if (sched_verbose >= 6)\n \t{\n@@ -16266,37 +16286,38 @@ rs6000_handle_altivec_attribute (tree *node, tree name, tree args,\n       unsigned_p = TYPE_UNSIGNED (type);\n       switch (mode)\n \t{\n-\t  case SImode:\n-\t    result = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n-\t    break;\n-\t  case HImode:\n-\t    result = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n-\t    break;\n-\t  case QImode:\n-\t    result = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n-\t    break;\n-\t  case SFmode: result = V4SF_type_node; break;\n-\t    /* If the user says 'vector int bool', we may be handed the 'bool'\n-\t       attribute _before_ the 'vector' attribute, and so select the proper\n-\t       type in the 'b' case below.  */\n-\t  case V4SImode: case V8HImode: case V16QImode: case V4SFmode: result = type;\n-\t  default: break;\n+\tcase SImode:\n+\t  result = (unsigned_p ? unsigned_V4SI_type_node : V4SI_type_node);\n+\t  break;\n+\tcase HImode:\n+\t  result = (unsigned_p ? unsigned_V8HI_type_node : V8HI_type_node);\n+\t  break;\n+\tcase QImode:\n+\t  result = (unsigned_p ? unsigned_V16QI_type_node : V16QI_type_node);\n+\t  break;\n+\tcase SFmode: result = V4SF_type_node; break;\n+\t  /* If the user says 'vector int bool', we may be handed the 'bool'\n+\t     attribute _before_ the 'vector' attribute, and so select the\n+\t     proper type in the 'b' case below.  */\n+\tcase V4SImode: case V8HImode: case V16QImode: case V4SFmode:\n+\t  result = type;\n+\tdefault: break;\n \t}\n       break;\n     case 'b':\n       switch (mode)\n \t{\n-\t  case SImode: case V4SImode: result = bool_V4SI_type_node; break;\n-\t  case HImode: case V8HImode: result = bool_V8HI_type_node; break;\n-\t  case QImode: case V16QImode: result = bool_V16QI_type_node;\n-\t  default: break;\n+\tcase SImode: case V4SImode: result = bool_V4SI_type_node; break;\n+\tcase HImode: case V8HImode: result = bool_V8HI_type_node; break;\n+\tcase QImode: case V16QImode: result = bool_V16QI_type_node;\n+\tdefault: break;\n \t}\n       break;\n     case 'p':\n       switch (mode)\n \t{\n-\t  case V8HImode: result = pixel_V8HI_type_node;\n-\t  default: break;\n+\tcase V8HImode: result = pixel_V8HI_type_node;\n+\tdefault: break;\n \t}\n     default: break;\n     }\n@@ -16576,7 +16597,8 @@ static tree branch_island_list = 0;\n    function.  */\n \n static void\n-add_compiler_branch_island (tree label_name, tree function_name, int line_number)\n+add_compiler_branch_island (tree label_name, tree function_name,\n+\t\t\t    int line_number)\n {\n   tree branch_island = build_tree_list (function_name, label_name);\n   TREE_TYPE (branch_island) = build_int_cst (NULL_TREE, line_number);\n@@ -16704,7 +16726,8 @@ get_prev_label (tree function_name)\n    CALL_DEST is the routine we are calling.  */\n \n char *\n-output_call (rtx insn, rtx *operands, int dest_operand_number, int cookie_operand_number)\n+output_call (rtx insn, rtx *operands, int dest_operand_number,\n+\t     int cookie_operand_number)\n {\n   static char buf[256];\n   if (GET_CODE (operands[dest_operand_number]) == SYMBOL_REF\n@@ -16906,10 +16929,10 @@ rs6000_elf_asm_out_constructor (rtx symbol, int priority)\n   if (priority != DEFAULT_INIT_PRIORITY)\n     {\n       sprintf (buf, \".ctors.%.5u\",\n-               /* Invert the numbering so the linker puts us in the proper\n-                  order; constructors are run from right to left, and the\n-                  linker sorts in increasing order.  */\n-               MAX_INIT_PRIORITY - priority);\n+\t       /* Invert the numbering so the linker puts us in the proper\n+\t\t  order; constructors are run from right to left, and the\n+\t\t  linker sorts in increasing order.  */\n+\t       MAX_INIT_PRIORITY - priority);\n       section = buf;\n     }\n \n@@ -16935,10 +16958,10 @@ rs6000_elf_asm_out_destructor (rtx symbol, int priority)\n   if (priority != DEFAULT_INIT_PRIORITY)\n     {\n       sprintf (buf, \".dtors.%.5u\",\n-               /* Invert the numbering so the linker puts us in the proper\n-                  order; constructors are run from right to left, and the\n-                  linker sorts in increasing order.  */\n-               MAX_INIT_PRIORITY - priority);\n+\t       /* Invert the numbering so the linker puts us in the proper\n+\t\t  order; constructors are run from right to left, and the\n+\t\t  linker sorts in increasing order.  */\n+\t       MAX_INIT_PRIORITY - priority);\n       section = buf;\n     }\n \n@@ -17061,21 +17084,21 @@ rs6000_xcoff_asm_named_section (const char *name, unsigned int flags,\n \n static void\n rs6000_xcoff_select_section (tree decl, int reloc,\n-\t\t\t    unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n+\t\t\t     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (decl_readonly_section_1 (decl, reloc, 1))\n     {\n       if (TREE_PUBLIC (decl))\n-        read_only_data_section ();\n+\tread_only_data_section ();\n       else\n-        read_only_private_data_section ();\n+\tread_only_private_data_section ();\n     }\n   else\n     {\n       if (TREE_PUBLIC (decl))\n-        data_section ();\n+\tdata_section ();\n       else\n-        private_data_section ();\n+\tprivate_data_section ();\n     }\n }\n \n@@ -17106,7 +17129,7 @@ rs6000_xcoff_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n \n static void\n rs6000_xcoff_select_rtx_section (enum machine_mode mode, rtx x,\n-\t\t\t\tunsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n+\t\t\t\t unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x, mode))\n     toc_section ();\n@@ -17367,7 +17390,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  *total += COSTS_N_INSNS (1);\n \t}\n       else\n-        *total = COSTS_N_INSNS (1);\n+\t*total = COSTS_N_INSNS (1);\n       return false;\n \n     case MULT:\n@@ -17415,7 +17438,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t    /* Shift */\n \t    *total = COSTS_N_INSNS (1);\n \t}\n-      else \n+      else\n \t{\n \t  if (GET_MODE (XEXP (x, 1)) == DImode)\n \t    *total = rs6000_cost->divdi;\n@@ -17547,20 +17570,21 @@ rs6000_register_move_cost (enum machine_mode mode,\n \treturn (rs6000_memory_move_cost (mode, from, 0)\n \t\t+ rs6000_memory_move_cost (mode, GENERAL_REGS, 0));\n \n-/* It's more expensive to move CR_REGS than CR0_REGS because of the shift....  */\n+      /* It's more expensive to move CR_REGS than CR0_REGS because of the\n+\t shift.  */\n       else if (from == CR_REGS)\n \treturn 4;\n \n       else\n-/* A move will cost one instruction per GPR moved.  */\n+\t/* A move will cost one instruction per GPR moved.  */\n \treturn 2 * HARD_REGNO_NREGS (0, mode);\n     }\n \n-/* Moving between two similar registers is just one instruction.  */\n+  /* Moving between two similar registers is just one instruction.  */\n   else if (reg_classes_intersect_p (to, from))\n     return mode == TFmode ? 4 : 2;\n \n-/* Everything else has to go through GENERAL_REGS.  */\n+  /* Everything else has to go through GENERAL_REGS.  */\n   else\n     return (rs6000_register_move_cost (mode, GENERAL_REGS, to)\n \t    + rs6000_register_move_cost (mode, from, GENERAL_REGS));"}, {"sha": "79a44a0ef5760ca08d3b22e78f2bfe5bcc18a465", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4ad648e16b7bec945bf959a14ad4259a7aec81c/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=c4ad648e16b7bec945bf959a14ad4259a7aec81c", "patch": "@@ -147,7 +147,7 @@ extern const char *rs6000_tls_size_string; /* For -mtls-size= */\n     N_(\"Link with libmvme.a, libc.a and crt0.o\") },\t\t\t\\\n   { \"emb\",\t\t 0,\t\t\t\t\t\t\\\n     N_(\"Set the PPC_EMB bit in the ELF flags header\") },\t\t\\\n-  { \"windiss\",           0, N_(\"Use the WindISS simulator\") },          \\\n+  { \"windiss\",\t\t 0, N_(\"Use the WindISS simulator\") },\t\t\\\n   { \"shlib\",\t\t 0, N_(\"no description yet\") },\t\t\t\\\n   { \"64\",\t\t MASK_64BIT | MASK_POWERPC64 | MASK_POWERPC,\t\\\n \t\t\t N_(\"Generate 64-bit code\") },\t\t\t\\\n@@ -420,9 +420,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n    usual way is COMPUTED and the alignment explicitly specified was\n    SPECIFIED.  */\n #define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED)\t\t\t\\\n-\t((TARGET_ALTIVEC  && TREE_CODE (TYPE) == VECTOR_TYPE)\t        \\\n-\t ? MAX (MAX ((COMPUTED), (SPECIFIED)), 128)                     \\\n-         : MAX (COMPUTED, SPECIFIED))\n+\t((TARGET_ALTIVEC  && TREE_CODE (TYPE) == VECTOR_TYPE)\t\t\\\n+\t ? MAX (MAX ((COMPUTED), (SPECIFIED)), 128)\t\t\t\\\n+\t : MAX (COMPUTED, SPECIFIED))\n \n #undef  BIGGEST_FIELD_ALIGNMENT\n \n@@ -776,38 +776,38 @@ extern int fixuplabelno;\n #define\tTARGET_VERSION fprintf (stderr, \" (PowerPC System V.4)\");\n #endif\n \f\n-#define TARGET_OS_SYSV_CPP_BUILTINS()\t  \\\n-  do                                      \\\n-    {                                     \\\n-      if (flag_pic == 1)\t\t  \\\n-        {\t\t\t\t  \\\n-\t  builtin_define (\"__pic__=1\");\t  \\\n-\t  builtin_define (\"__PIC__=1\");\t  \\\n-        }\t\t\t\t  \\\n-      else if (flag_pic == 2)\t\t  \\\n-        {\t\t\t\t  \\\n-\t  builtin_define (\"__pic__=2\");\t  \\\n-\t  builtin_define (\"__PIC__=2\");\t  \\\n-        }\t\t\t\t  \\\n-      if (target_flags_explicit\t\t  \\\n-\t  & MASK_RELOCATABLE)\t\t  \\\n-\tbuiltin_define (\"_RELOCATABLE\");  \\\n-    }                                     \\\n+#define TARGET_OS_SYSV_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (flag_pic == 1)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__pic__=1\");\t\t\\\n+\t  builtin_define (\"__PIC__=1\");\t\t\\\n+\t}\t\t\t\t\t\\\n+      else if (flag_pic == 2)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__pic__=2\");\t\t\\\n+\t  builtin_define (\"__PIC__=2\");\t\t\\\n+\t}\t\t\t\t\t\\\n+      if (target_flags_explicit\t\t\t\\\n+\t  & MASK_RELOCATABLE)\t\t\t\\\n+\tbuiltin_define (\"_RELOCATABLE\");\t\\\n+    }\t\t\t\t\t\t\\\n   while (0)\n \n #ifndef\tTARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()          \\\n-  do                                      \\\n-    {                                     \\\n-      builtin_define_std (\"PPC\");         \\\n-      builtin_define_std (\"unix\");        \\\n-      builtin_define (\"__svr4__\");        \\\n-      builtin_assert (\"system=unix\");     \\\n-      builtin_assert (\"system=svr4\");     \\\n-      builtin_assert (\"cpu=powerpc\");     \\\n-      builtin_assert (\"machine=powerpc\"); \\\n-      TARGET_OS_SYSV_CPP_BUILTINS ();\t  \\\n-    }                                     \\\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define_std (\"PPC\");\t\t\\\n+      builtin_define_std (\"unix\");\t\t\\\n+      builtin_define (\"__svr4__\");\t\t\\\n+      builtin_assert (\"system=unix\");\t\t\\\n+      builtin_assert (\"system=svr4\");\t\t\\\n+      builtin_assert (\"cpu=powerpc\");\t\t\\\n+      builtin_assert (\"machine=powerpc\");\t\\\n+      TARGET_OS_SYSV_CPP_BUILTINS ();\t\t\\\n+    }\t\t\t\t\t\t\\\n   while (0)\n #endif\n \n@@ -1239,7 +1239,7 @@ ncrtn.o%s\"\n /* Override rs6000.h definition.  */\n #undef\tSUBTARGET_EXTRA_SPECS\n #define\tSUBTARGET_EXTRA_SPECS\t\t\t\t\t\t\\\n-  { \"crtsavres_default\",        CRTSAVRES_DEFAULT_SPEC },              \\\n+  { \"crtsavres_default\",\tCRTSAVRES_DEFAULT_SPEC },\t\t\\\n   { \"lib_ads\",\t\t\tLIB_ADS_SPEC },\t\t\t\t\\\n   { \"lib_yellowknife\",\t\tLIB_YELLOWKNIFE_SPEC },\t\t\t\\\n   { \"lib_mvme\",\t\t\tLIB_MVME_SPEC },\t\t\t\\\n@@ -1249,7 +1249,7 @@ ncrtn.o%s\"\n   { \"lib_linux\",\t\tLIB_LINUX_SPEC },\t\t\t\\\n   { \"lib_netbsd\",\t\tLIB_NETBSD_SPEC },\t\t\t\\\n   { \"lib_openbsd\",\t\tLIB_OPENBSD_SPEC },\t\t\t\\\n-  { \"lib_windiss\",              LIB_WINDISS_SPEC },                     \\\n+  { \"lib_windiss\",\t\tLIB_WINDISS_SPEC },\t\t\t\\\n   { \"lib_default\",\t\tLIB_DEFAULT_SPEC },\t\t\t\\\n   { \"startfile_ads\",\t\tSTARTFILE_ADS_SPEC },\t\t\t\\\n   { \"startfile_yellowknife\",\tSTARTFILE_YELLOWKNIFE_SPEC },\t\t\\\n@@ -1260,7 +1260,7 @@ ncrtn.o%s\"\n   { \"startfile_linux\",\t\tSTARTFILE_LINUX_SPEC },\t\t\t\\\n   { \"startfile_netbsd\",\t\tSTARTFILE_NETBSD_SPEC },\t\t\\\n   { \"startfile_openbsd\",\tSTARTFILE_OPENBSD_SPEC },\t\t\\\n-  { \"startfile_windiss\",        STARTFILE_WINDISS_SPEC },               \\\n+  { \"startfile_windiss\",\tSTARTFILE_WINDISS_SPEC },\t\t\\\n   { \"startfile_default\",\tSTARTFILE_DEFAULT_SPEC },\t\t\\\n   { \"endfile_ads\",\t\tENDFILE_ADS_SPEC },\t\t\t\\\n   { \"endfile_yellowknife\",\tENDFILE_YELLOWKNIFE_SPEC },\t\t\\\n@@ -1271,7 +1271,7 @@ ncrtn.o%s\"\n   { \"endfile_linux\",\t\tENDFILE_LINUX_SPEC },\t\t\t\\\n   { \"endfile_netbsd\",\t\tENDFILE_NETBSD_SPEC },\t\t\t\\\n   { \"endfile_openbsd\",\t\tENDFILE_OPENBSD_SPEC },\t\t\t\\\n-  { \"endfile_windiss\",          ENDFILE_WINDISS_SPEC },                 \\\n+  { \"endfile_windiss\",\t\tENDFILE_WINDISS_SPEC },\t\t\t\\\n   { \"endfile_default\",\t\tENDFILE_DEFAULT_SPEC },\t\t\t\\\n   { \"link_path\",\t\tLINK_PATH_SPEC },\t\t\t\\\n   { \"link_shlib\",\t\tLINK_SHLIB_SPEC },\t\t\t\\\n@@ -1312,7 +1312,7 @@ ncrtn.o%s\"\n   { \"cpp_os_linux\",\t\tCPP_OS_LINUX_SPEC },\t\t\t\\\n   { \"cpp_os_netbsd\",\t\tCPP_OS_NETBSD_SPEC },\t\t\t\\\n   { \"cpp_os_openbsd\",\t\tCPP_OS_OPENBSD_SPEC },\t\t\t\\\n-  { \"cpp_os_windiss\",           CPP_OS_WINDISS_SPEC },                  \\\n+  { \"cpp_os_windiss\",\t\tCPP_OS_WINDISS_SPEC },\t\t\t\\\n   { \"cpp_os_default\",\t\tCPP_OS_DEFAULT_SPEC },\t\t\t\\\n   { \"fbsd_dynamic_linker\",\tFBSD_DYNAMIC_LINKER },\t\t\t\\\n   SUBSUBTARGET_EXTRA_SPECS"}]}