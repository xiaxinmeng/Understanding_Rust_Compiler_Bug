{"sha": "39d4e04a29fac028745290f6301f16e490bef9b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkNGUwNGEyOWZhYzAyODc0NTI5MGY2MzAxZjE2ZTQ5MGJlZjliNw==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2009-04-22T15:00:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-22T15:00:28Z"}, "message": "prj.adb, [...] (Project_Data.Unit_Based_Language_*): Two fields removed.\n\n2009-04-22  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb, prj.ads, prj-nmsc.adb (Project_Data.Unit_Based_Language_*):\n\tTwo fields removed.\n\nFrom-SVN: r146582", "tree": {"sha": "a2cd787cdc777852d748ed428007ccba8a434b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2cd787cdc777852d748ed428007ccba8a434b8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39d4e04a29fac028745290f6301f16e490bef9b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d4e04a29fac028745290f6301f16e490bef9b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d4e04a29fac028745290f6301f16e490bef9b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d4e04a29fac028745290f6301f16e490bef9b7/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09f2a1e4400d794035e6c4c6d54463ec731026bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09f2a1e4400d794035e6c4c6d54463ec731026bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09f2a1e4400d794035e6c4c6d54463ec731026bb"}], "stats": {"total": 502, "additions": 233, "deletions": 269}, "files": [{"sha": "af9861b7b1c68133dc9d7e756c0440c2dfd012d3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39d4e04a29fac028745290f6301f16e490bef9b7", "patch": "@@ -1,3 +1,8 @@\n+2009-04-22  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb, prj.ads, prj-nmsc.adb (Project_Data.Unit_Based_Language_*):\n+\tTwo fields removed.\n+\n 2009-04-22  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj-nmsc.adb (Check_Naming_Ada_Only): Properly initialize the"}, {"sha": "b9275a094fbe4c922600ba9992c8a80531010187", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 222, "deletions": 258, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=39d4e04a29fac028745290f6301f16e490bef9b7", "patch": "@@ -2807,12 +2807,6 @@ package body Prj.Nmsc is\n                     Util.Value_Of (Name_Naming, Data.Decl.Packages, In_Tree);\n       Naming    : Package_Element;\n \n-      procedure Get_Exceptions (Kind : Source_Kind);\n-      --  Comment required ???\n-\n-      procedure Get_Unit_Exceptions (Kind : Source_Kind);\n-      --  Comment required ???\n-\n       procedure Check_Naming_Ada_Only;\n       --  Does Check_Naming_Schemes processing in Ada_Only mode.\n       --  If there is a package Naming, puts in Data.Naming the contents of\n@@ -2829,6 +2823,15 @@ package body Prj.Nmsc is\n          Sep_Suffix_Loc  : out Source_Ptr);\n       --  Check attributes common to Ada_Only and Multi_Lang modes\n \n+      procedure Process_Exceptions_File_Based\n+        (Lang_Id        : Language_Index;\n+         Kind           : Source_Kind);\n+      procedure Process_Exceptions_Unit_Based\n+        (Lang_Id        : Language_Index;\n+         Kind           : Source_Kind);\n+      --  In Multi_Lang mode, process the naming exceptions for the two types\n+      --  of languages we can have.\n+\n       ------------------\n       -- Check_Common --\n       ------------------\n@@ -2970,183 +2973,158 @@ package body Prj.Nmsc is\n          end if;\n       end Check_Common;\n \n-      --------------------\n-      -- Get_Exceptions --\n-      --------------------\n+      -----------------------------------\n+      -- Process_Exceptions_File_Based --\n+      -----------------------------------\n \n-      procedure Get_Exceptions (Kind : Source_Kind) is\n+      procedure Process_Exceptions_File_Based\n+        (Lang_Id        : Language_Index;\n+         Kind           : Source_Kind)\n+      is\n+         Lang           : constant Name_Id :=\n+                            In_Tree.Languages_Data.Table (Lang_Id).Name;\n          Exceptions     : Array_Element_Id;\n          Exception_List : Variable_Value;\n          Element_Id     : String_List_Id;\n          Element        : String_Element;\n          File_Name      : File_Name_Type;\n-         Lang_Id        : Language_Index;\n-         Lang           : Name_Id;\n-         Lang_Kind      : Language_Kind;\n          Source         : Source_Id;\n-\n       begin\n-         if Kind = Impl then\n-            Exceptions :=\n-              Value_Of\n-                (Name_Implementation_Exceptions,\n-                 In_Arrays => Naming.Decl.Arrays,\n-                 In_Tree   => In_Tree);\n-\n-         else\n-            Exceptions :=\n-              Value_Of\n-                (Name_Specification_Exceptions,\n-                 In_Arrays => Naming.Decl.Arrays,\n-                 In_Tree   => In_Tree);\n-         end if;\n-\n-         Lang_Id := Data.First_Language_Processing;\n-         while Lang_Id /= No_Language_Index loop\n-            if In_Tree.Languages_Data.Table (Lang_Id).Config.Kind =\n-                                                               File_Based\n-            then\n-               Lang := In_Tree.Languages_Data.Table (Lang_Id).Name;\n-               Lang_Kind :=\n-                 In_Tree.Languages_Data.Table (Lang_Id).Config.Kind;\n-\n-               Exception_List := Value_Of\n-                 (Index    => Lang,\n-                  In_Array => Exceptions,\n-                  In_Tree  => In_Tree);\n+         case Kind is\n+            when Impl | Sep =>\n+               Exceptions :=\n+                 Value_Of\n+                   (Name_Implementation_Exceptions,\n+                    In_Arrays => Naming.Decl.Arrays,\n+                    In_Tree   => In_Tree);\n \n-               if Exception_List /= Nil_Variable_Value then\n-                  Element_Id := Exception_List.Values;\n-                  while Element_Id /= Nil_String loop\n-                     Element := In_Tree.String_Elements.Table (Element_Id);\n-                     File_Name := Canonical_Case_File_Name (Element.Value);\n+            when Spec =>\n+               Exceptions :=\n+                 Value_Of\n+                   (Name_Specification_Exceptions,\n+                    In_Arrays => Naming.Decl.Arrays,\n+                    In_Tree   => In_Tree);\n+         end case;\n \n-                     Source := Data.First_Source;\n-                     while Source /= No_Source\n-                       and then\n-                       In_Tree.Sources.Table (Source).File /= File_Name\n-                     loop\n-                        Source :=\n-                          In_Tree.Sources.Table (Source).Next_In_Project;\n-                     end loop;\n+         Exception_List := Value_Of\n+           (Index    => Lang,\n+            In_Array => Exceptions,\n+            In_Tree  => In_Tree);\n \n-                     if Source = No_Source then\n-                        Add_Source\n-                          (Id           => Source,\n-                           Data         => Data,\n-                           In_Tree      => In_Tree,\n-                           Project      => Project,\n-                           Lang         => Lang,\n-                           Lang_Id      => Lang_Id,\n-                           Kind         => Kind,\n-                           File_Name    => File_Name,\n-                           Display_File => File_Name_Type (Element.Value),\n-                           Naming_Exception => True,\n-                           Lang_Kind    => Lang_Kind);\n+         if Exception_List /= Nil_Variable_Value then\n+            Element_Id := Exception_List.Values;\n+            while Element_Id /= Nil_String loop\n+               Element   := In_Tree.String_Elements.Table (Element_Id);\n+               File_Name := Canonical_Case_File_Name (Element.Value);\n \n-                     else\n-                        --  Check if the file name is already recorded for\n-                        --  another language or another kind.\n+               Source := Data.First_Source;\n+               while Source /= No_Source\n+                 and then In_Tree.Sources.Table (Source).File /= File_Name\n+               loop\n+                  Source := In_Tree.Sources.Table (Source).Next_In_Project;\n+               end loop;\n \n-                        if\n-                          In_Tree.Sources.Table (Source).Language /= Lang_Id\n-                        then\n-                           Error_Msg\n-                             (Project,\n-                              In_Tree,\n-                              \"the same file cannot be a source \" &\n-                              \"of two languages\",\n-                              Element.Location);\n+               if Source = No_Source then\n+                  Add_Source\n+                    (Id               => Source,\n+                     Data             => Data,\n+                     In_Tree          => In_Tree,\n+                     Project          => Project,\n+                     Lang             => Lang,\n+                     Lang_Id          => Lang_Id,\n+                     Kind             => Kind,\n+                     File_Name        => File_Name,\n+                     Display_File     => File_Name_Type (Element.Value),\n+                     Naming_Exception => True,\n+                     Lang_Kind        => File_Based);\n \n-                        elsif In_Tree.Sources.Table (Source).Kind /= Kind then\n-                           Error_Msg\n-                             (Project,\n-                              In_Tree,\n-                              \"the same file cannot be a source \" &\n-                              \"and a template\",\n-                              Element.Location);\n-                        end if;\n+               else\n+                  --  Check if the file name is already recorded for another\n+                  --  language or another kind.\n \n-                        --  If the file is already recorded for the same\n-                        --  language and the same kind, it means that the file\n-                        --  name appears several times in the *_Exceptions\n-                        --  attribute; so there is nothing to do.\n+                  if In_Tree.Sources.Table (Source).Language /= Lang_Id then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"the same file cannot be a source of two languages\",\n+                        Element.Location);\n \n-                     end if;\n+                  elsif In_Tree.Sources.Table (Source).Kind /= Kind then\n+                     Error_Msg\n+                       (Project,\n+                        In_Tree,\n+                        \"the same file cannot be a source and a template\",\n+                        Element.Location);\n+                  end if;\n \n-                     Element_Id := Element.Next;\n-                  end loop;\n+                  --  If the file is already recorded for the same\n+                  --  language and the same kind, it means that the file\n+                  --  name appears several times in the *_Exceptions\n+                  --  attribute; so there is nothing to do.\n                end if;\n-            end if;\n \n-            Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n-         end loop;\n-      end Get_Exceptions;\n-\n-      -------------------------\n-      -- Get_Unit_Exceptions --\n-      -------------------------\n-\n-      procedure Get_Unit_Exceptions (Kind : Source_Kind) is\n-         Exceptions : Array_Element_Id;\n-         Element    : Array_Element;\n-         Unit       : Name_Id;\n-         Index      : Int;\n-         File_Name  : File_Name_Type;\n-         Lang_Id    : constant Language_Index :=\n-                        Data.Unit_Based_Language_Index;\n-         Lang       : constant Name_Id :=\n-                        Data.Unit_Based_Language_Name;\n+               Element_Id := Element.Next;\n+            end loop;\n+         end if;\n+      end Process_Exceptions_File_Based;\n \n+      -----------------------------------\n+      -- Process_Exceptions_Unit_Based --\n+      -----------------------------------\n+\n+      procedure Process_Exceptions_Unit_Based\n+        (Lang_Id        : Language_Index;\n+         Kind           : Source_Kind)\n+      is\n+         Lang              : constant Name_Id :=\n+                              In_Tree.Languages_Data.Table (Lang_Id).Name;\n+         Exceptions        : Array_Element_Id;\n+         Element           : Array_Element;\n+         Unit              : Name_Id;\n+         Index             : Int;\n+         File_Name         : File_Name_Type;\n          Source            : Source_Id;\n          Source_To_Replace : Source_Id := No_Source;\n-\n-         Other_Project : Project_Id;\n-         Other_Part    : Source_Id := No_Source;\n-\n+         Other_Project     : Project_Id;\n+         Other_Part        : Source_Id := No_Source;\n       begin\n-         if Lang_Id = No_Language_Index or else Lang = No_Name then\n-            return;\n-         end if;\n+         case Kind is\n+            when Impl | Sep =>\n+               Exceptions := Value_Of\n+                 (Name_Body,\n+                  In_Arrays => Naming.Decl.Arrays,\n+                  In_Tree   => In_Tree);\n \n-         if Kind = Impl then\n-            Exceptions := Value_Of\n-              (Name_Body,\n-               In_Arrays => Naming.Decl.Arrays,\n-               In_Tree   => In_Tree);\n+               if Exceptions = No_Array_Element then\n+                  Exceptions :=\n+                    Value_Of\n+                      (Name_Implementation,\n+                       In_Arrays => Naming.Decl.Arrays,\n+                       In_Tree   => In_Tree);\n+               end if;\n \n-            if Exceptions = No_Array_Element then\n+            when Spec =>\n                Exceptions :=\n                  Value_Of\n-                   (Name_Implementation,\n+                   (Name_Spec,\n                     In_Arrays => Naming.Decl.Arrays,\n                     In_Tree   => In_Tree);\n-            end if;\n-\n-         else\n-            Exceptions :=\n-              Value_Of\n-                (Name_Spec,\n-                 In_Arrays => Naming.Decl.Arrays,\n-                 In_Tree   => In_Tree);\n-\n-            if Exceptions = No_Array_Element then\n-               Exceptions := Value_Of\n-                 (Name_Specification,\n-                  In_Arrays => Naming.Decl.Arrays,\n-                  In_Tree   => In_Tree);\n-            end if;\n \n-         end if;\n+               if Exceptions = No_Array_Element then\n+                  Exceptions := Value_Of\n+                    (Name_Specification,\n+                     In_Arrays => Naming.Decl.Arrays,\n+                     In_Tree   => In_Tree);\n+               end if;\n+         end case;\n \n          while Exceptions /= No_Array_Element loop\n-            Element := In_Tree.Array_Elements.Table (Exceptions);\n+            Element   := In_Tree.Array_Elements.Table (Exceptions);\n             File_Name := Canonical_Case_File_Name (Element.Value.Value);\n \n             Get_Name_String (Element.Index);\n             To_Lower (Name_Buffer (1 .. Name_Len));\n-            Unit := Name_Find;\n-\n+            Unit  := Name_Find;\n             Index := Element.Value.Index;\n \n             --  For Ada, check if it is a valid unit name\n@@ -3240,7 +3218,7 @@ package body Prj.Nmsc is\n \n             Exceptions := Element.Next;\n          end loop;\n-      end Get_Unit_Exceptions;\n+      end Process_Exceptions_Unit_Based;\n \n       ---------------------------\n       -- Check_Naming_Ada_Only --\n@@ -3377,143 +3355,134 @@ package body Prj.Nmsc is\n       -----------------------------\n \n       procedure Check_Naming_Multi_Lang is\n+         Dot_Replacement : File_Name_Type := No_File;\n+         Separate_Suffix : File_Name_Type := No_File;\n+         Casing          : Casing_Type    := All_Lower_Case;\n+         Casing_Defined  : Boolean;\n+         Lang_Id         : Language_Index;\n+         Sep_Suffix_Loc  : Source_Ptr;\n+         Suffix          : Variable_Value;\n+         Lang            : Name_Id;\n       begin\n-         --  We are now checking if attribute Dot_Replacement, Casing, and/or\n-         --  Separate_Suffix exist.\n-\n-         --  For each attribute, if it does not exist, we do nothing, because\n-         --  we already have the default. Otherwise, for all unit-based\n-         --  languages, we put the declared value in the language config.\n+         Check_Common\n+           (Dot_Replacement => Dot_Replacement,\n+            Casing          => Casing,\n+            Casing_Defined  => Casing_Defined,\n+            Separate_Suffix => Separate_Suffix,\n+            Sep_Suffix_Loc  => Sep_Suffix_Loc);\n \n-         declare\n-            Dot_Replacement : File_Name_Type := No_File;\n-            Separate_Suffix : File_Name_Type := No_File;\n-            Casing          : Casing_Type    := All_Lower_Case;\n-            Casing_Defined  : Boolean;\n-            Lang_Id         : Language_Index;\n-            Sep_Suffix_Loc  : Source_Ptr;\n+         --  For all unit based languages, if any, set the specified\n+         --  value of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n+         --  systematically overwrite, since the defaults come from the\n+         --  configuration file\n \n-         begin\n-            Check_Common\n-              (Dot_Replacement => Dot_Replacement,\n-               Casing          => Casing,\n-               Casing_Defined  => Casing_Defined,\n-               Separate_Suffix => Separate_Suffix,\n-               Sep_Suffix_Loc  => Sep_Suffix_Loc);\n-\n-            --  For all unit based languages, if any, set the specified value\n-            --  of Dot_Replacement, Casing and/or Separate_Suffix. Do not\n-            --  systematically overwrite, since the defaults come from the\n-            --  configuration file\n-\n-            if Dot_Replacement /= No_File\n-              or else Casing_Defined\n-              or else Separate_Suffix /= No_File\n-            then\n-               Lang_Id := Data.First_Language_Processing;\n-               while Lang_Id /= No_Language_Index loop\n-                  if In_Tree.Languages_Data.Table\n-                    (Lang_Id).Config.Kind = Unit_Based\n-                  then\n-                     if Dot_Replacement /= No_File then\n-                        In_Tree.Languages_Data.Table\n-                          (Lang_Id).Config.Naming_Data.Dot_Replacement :=\n-                          Dot_Replacement;\n-                     end if;\n+         if Dot_Replacement /= No_File\n+           or else Casing_Defined\n+           or else Separate_Suffix /= No_File\n+         then\n+            Lang_Id := Data.First_Language_Processing;\n+            while Lang_Id /= No_Language_Index loop\n+               if In_Tree.Languages_Data.Table\n+                 (Lang_Id).Config.Kind = Unit_Based\n+               then\n+                  if Dot_Replacement /= No_File then\n+                     In_Tree.Languages_Data.Table\n+                       (Lang_Id).Config.Naming_Data.Dot_Replacement :=\n+                       Dot_Replacement;\n+                  end if;\n \n-                     if Casing_Defined then\n-                        In_Tree.Languages_Data.Table\n-                          (Lang_Id).Config.Naming_Data.Casing := Casing;\n-                     end if;\n+                  if Casing_Defined then\n+                     In_Tree.Languages_Data.Table\n+                       (Lang_Id).Config.Naming_Data.Casing := Casing;\n+                  end if;\n \n-                     if Separate_Suffix /= No_File then\n-                        In_Tree.Languages_Data.Table\n-                          (Lang_Id).Config.Naming_Data.Separate_Suffix :=\n-                          Separate_Suffix;\n-                     end if;\n+                  if Separate_Suffix /= No_File then\n+                     In_Tree.Languages_Data.Table\n+                       (Lang_Id).Config.Naming_Data.Separate_Suffix :=\n+                       Separate_Suffix;\n                   end if;\n+               end if;\n \n-                  Lang_Id :=\n-                    In_Tree.Languages_Data.Table (Lang_Id).Next;\n-               end loop;\n-            end if;\n-         end;\n+               Lang_Id :=\n+                 In_Tree.Languages_Data.Table (Lang_Id).Next;\n+            end loop;\n+         end if;\n \n          --  Next, get the spec and body suffixes\n \n-         declare\n-            Suffix  : Variable_Value;\n-            Lang_Id : Language_Index;\n-            Lang    : Name_Id;\n+         Lang_Id := Data.First_Language_Processing;\n+         while Lang_Id /= No_Language_Index loop\n+            Lang := In_Tree.Languages_Data.Table (Lang_Id).Name;\n \n-         begin\n-            Lang_Id := Data.First_Language_Processing;\n-            while Lang_Id /= No_Language_Index loop\n-               Lang := In_Tree.Languages_Data.Table (Lang_Id).Name;\n+            --  Spec_Suffix\n \n-               --  Spec_Suffix\n+            Suffix := Value_Of\n+              (Name                    => Lang,\n+               Attribute_Or_Array_Name => Name_Spec_Suffix,\n+               In_Package              => Naming_Id,\n+               In_Tree                 => In_Tree);\n \n+            if Suffix = Nil_Variable_Value then\n                Suffix := Value_Of\n                  (Name                    => Lang,\n-                  Attribute_Or_Array_Name => Name_Spec_Suffix,\n+                  Attribute_Or_Array_Name => Name_Specification_Suffix,\n                   In_Package              => Naming_Id,\n                   In_Tree                 => In_Tree);\n+            end if;\n \n-               if Suffix = Nil_Variable_Value then\n-                  Suffix := Value_Of\n-                    (Name                    => Lang,\n-                     Attribute_Or_Array_Name => Name_Specification_Suffix,\n-                     In_Package              => Naming_Id,\n-                     In_Tree                 => In_Tree);\n-               end if;\n+            if Suffix /= Nil_Variable_Value then\n+               In_Tree.Languages_Data.Table (Lang_Id).\n+                 Config.Naming_Data.Spec_Suffix :=\n+                   File_Name_Type (Suffix.Value);\n+            end if;\n \n-               if Suffix /= Nil_Variable_Value then\n-                  In_Tree.Languages_Data.Table (Lang_Id).\n-                    Config.Naming_Data.Spec_Suffix :=\n-                      File_Name_Type (Suffix.Value);\n-               end if;\n+            --  Body_Suffix\n \n-               --  Body_Suffix\n+            Suffix := Value_Of\n+              (Name                    => Lang,\n+               Attribute_Or_Array_Name => Name_Body_Suffix,\n+               In_Package              => Naming_Id,\n+               In_Tree                 => In_Tree);\n \n+            if Suffix = Nil_Variable_Value then\n                Suffix := Value_Of\n                  (Name                    => Lang,\n-                  Attribute_Or_Array_Name => Name_Body_Suffix,\n+                  Attribute_Or_Array_Name => Name_Implementation_Suffix,\n                   In_Package              => Naming_Id,\n                   In_Tree                 => In_Tree);\n+            end if;\n \n-               if Suffix = Nil_Variable_Value then\n-                  Suffix := Value_Of\n-                    (Name                    => Lang,\n-                     Attribute_Or_Array_Name => Name_Implementation_Suffix,\n-                     In_Package              => Naming_Id,\n-                     In_Tree                 => In_Tree);\n-               end if;\n-\n-               if Suffix /= Nil_Variable_Value then\n-                  In_Tree.Languages_Data.Table (Lang_Id).\n-                    Config.Naming_Data.Body_Suffix :=\n-                      File_Name_Type (Suffix.Value);\n-               end if;\n+            if Suffix /= Nil_Variable_Value then\n+               In_Tree.Languages_Data.Table (Lang_Id).\n+                 Config.Naming_Data.Body_Suffix :=\n+                   File_Name_Type (Suffix.Value);\n+            end if;\n \n-               --  ??? As opposed to what is done in Check_Naming_Ada_Only,\n-               --  we do not check whether spec_suffix=body_suffix, which\n-               --  should be illegal. Best would be to share this code into\n-               --  Check_Common, but we access the attributes from the project\n-               --  files slightly differently apparently.\n+            --  ??? As opposed to what is done in Check_Naming_Ada_Only,\n+            --  we do not check whether spec_suffix=body_suffix, which\n+            --  should be illegal. Best would be to share this code into\n+            --  Check_Common, but we access the attributes from the project\n+            --  files slightly differently apparently.\n \n-               Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n-            end loop;\n-         end;\n+            Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n+         end loop;\n \n-         --  Get the exceptions for file based languages\n+         --  Get the naming exceptions for all languages\n \n-         Get_Exceptions (Spec);\n-         Get_Exceptions (Impl);\n+         for Kind in Spec .. Impl loop\n+            Lang_Id := Data.First_Language_Processing;\n+            while Lang_Id /= No_Language_Index loop\n+               case In_Tree.Languages_Data.Table (Lang_Id).Config.Kind is\n+               when File_Based =>\n+                  Process_Exceptions_File_Based (Lang_Id, Kind);\n \n-         --  Get the exceptions for unit based languages\n+               when Unit_Based =>\n+                  Process_Exceptions_Unit_Based (Lang_Id, Kind);\n+               end case;\n \n-         Get_Unit_Exceptions (Spec);\n-         Get_Unit_Exceptions (Impl);\n+               Lang_Id := In_Tree.Languages_Data.Table (Lang_Id).Next;\n+            end loop;\n+         end loop;\n       end Check_Naming_Multi_Lang;\n \n    --  Start of processing for Check_Naming_Schemes\n@@ -4578,9 +4547,6 @@ package body Prj.Nmsc is\n                      In_Tree.Languages_Data.Table\n                        (Data.First_Language_Processing).Config.Dependency_Kind\n                        := ALI_File;\n-                     Data.Unit_Based_Language_Name := Name_Ada;\n-                     Data.Unit_Based_Language_Index :=\n-                       Data.First_Language_Processing;\n                   else\n                      In_Tree.Languages_Data.Table\n                        (Data.First_Language_Processing).Config.Kind\n@@ -4680,8 +4646,6 @@ package body Prj.Nmsc is\n                            if Lang_Name = Name_Ada then\n                               Lang_Data.Config.Kind := Unit_Based;\n                               Lang_Data.Config.Dependency_Kind := ALI_File;\n-                              Data.Unit_Based_Language_Name := Name_Ada;\n-                              Data.Unit_Based_Language_Index := Index;\n \n                            else\n                               Lang_Data.Config.Kind := File_Based;"}, {"sha": "db6ea7f81fafa8c6784cc6e81e13890cd235b385", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=39d4e04a29fac028745290f6301f16e490bef9b7", "patch": "@@ -113,8 +113,6 @@ package body Prj is\n                       First_Source                   => No_Source,\n                       Last_Source                    => No_Source,\n                       Interfaces_Defined             => False,\n-                      Unit_Based_Language_Name       => No_Name,\n-                      Unit_Based_Language_Index      => No_Language_Index,\n                       Imported_Directories_Switches  => null,\n                       Include_Path                   => null,\n                       Include_Data_Set               => False,"}, {"sha": "fad28e59bac17867bf99fa57d5353d548728ccc0", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d4e04a29fac028745290f6301f16e490bef9b7/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=39d4e04a29fac028745290f6301f16e490bef9b7", "patch": "@@ -888,11 +888,11 @@ package Prj is\n \n       Specs : Array_Element_Id := No_Array_Element;\n       --  An associative array mapping individual specs to source file names\n-      --  This is specific to Ada.\n+      --  This is specific to unit-based languages.\n \n       Bodies : Array_Element_Id := No_Array_Element;\n       --  An associative array mapping individual bodies to source file names\n-      --  This is specific to Ada.\n+      --  This is specific to unit-based languages.\n \n       Specification_Exceptions : Array_Element_Id := No_Array_Element;\n       --  An associative array listing spec file names that do not have the\n@@ -1179,17 +1179,14 @@ package Prj is\n \n       Languages : Name_List_Index := No_Name_List;\n       --  The list of languages of the sources of this project\n+      --  mode: Ada_Only\n \n       Include_Language : Language_Index := No_Language_Index;\n \n       First_Language_Processing : Language_Index := No_Language_Index;\n-      --  First index of the language data in the project\n-\n-      Unit_Based_Language_Name  : Name_Id := No_Name;\n-      Unit_Based_Language_Index : Language_Index := No_Language_Index;\n-      --  The name and index, if any, of the unit-based language of some\n-      --  sources of the project. There may be only one unit-based language\n-      --  in one project.\n+      --  First index of the language data in the project.\n+      --  This is an index into the project_tree_data.languages_data\n+      --  mode: Multi_Language\n \n       --------------\n       -- Projects --"}]}