{"sha": "156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2YjVjY2FlN2IxNTQyYTIzZDRkNDJiMGE2Y2Y5NjcyYzdiNmU3ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-11-01T00:41:30Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-11-01T00:41:30Z"}, "message": "vsx.md (VSX_EXTRACT_FL): New iterator for all binary floating point types supported by the hardware...\n\n[gcc]\n2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/vsx.md (VSX_EXTRACT_FL): New iterator for all\n\tbinary floating point types supported by the hardware except for\n\tdouble.\n\t(vsx_xvcvsxwdp_df): Provide scalar result alternative to the\n\tvector instruction for optimizing extracting a SImode from a\n\tV4SImode vector and converting it to floating point.\n\t(vsx_xvcvuxwdp_df): Likewise.\n\t(vsx_extract_si): On ISA 3.0, allow extract target and temporary\n\tregisters to be any VSX register.  Move stores to the end of the\n\tconstraints.\n\t(vsx_extract_si_<uns>float_df): New combiner pattern and splitter\n\tto optimize extracting a SImode from a V4SImode vector and\n\tconverting it to a binary floating point type supported by the\n\thardware.  Use the vector converts instead of extracting the\n\telement, sign extending it, and then converting it to double.\n\tOther floating point types  than double first convert to double,\n\tthen the double is converted to that type.\n\t(vsx_extract_si_<uns>float_<mode>): Likewise.\n\n[gcc/testsuite]\n2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/vsx-extract-4.c: New test.\n\t* gcc.target/powerpc/vsx-extract-5.c: Likewise.\n\nFrom-SVN: r241731", "tree": {"sha": "0b64ac057b25bef1487ad672b70544c9e0daf4ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b64ac057b25bef1487ad672b70544c9e0daf4ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/comments", "author": null, "committer": null, "parents": [{"sha": "fb4c92aabcbb34c33584d4c60df8d9baed3dca7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4c92aabcbb34c33584d4c60df8d9baed3dca7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4c92aabcbb34c33584d4c60df8d9baed3dca7a"}], "stats": {"total": 317, "additions": 312, "deletions": 5}, "files": [{"sha": "7dd239d012d15061bc87bbe54561e95ca9a31293", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "patch": "@@ -1,3 +1,24 @@\n+2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/vsx.md (VSX_EXTRACT_FL): New iterator for all\n+\tbinary floating point types supported by the hardware except for\n+\tdouble.\n+\t(vsx_xvcvsxwdp_df): Provide scalar result alternative to the\n+\tvector instruction for optimizing extracting a SImode from a\n+\tV4SImode vector and converting it to floating point.\n+\t(vsx_xvcvuxwdp_df): Likewise.\n+\t(vsx_extract_si): On ISA 3.0, allow extract target and temporary\n+\tregisters to be any VSX register.  Move stores to the end of the\n+\tconstraints.\n+\t(vsx_extract_si_<uns>float_df): New combiner pattern and splitter\n+\tto optimize extracting a SImode from a V4SImode vector and\n+\tconverting it to a binary floating point type supported by the\n+\thardware.  Use the vector converts instead of extracting the\n+\telement, sign extending it, and then converting it to double.\n+\tOther floating point types  than double first convert to double,\n+\tthen the double is converted to that type.\n+\t(vsx_extract_si_<uns>float_<mode>): Likewise.\n+\n 2016-10-31  Andrew Pinski  <apinski@cavium.com>\n \n \t* config/aarch64/driver-aarch64.c (host_detect_local_cpu):"}, {"sha": "505c270edfd27d1a9a77735ff90e11c558a55bf1", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 133, "deletions": 5, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "patch": "@@ -288,6 +288,16 @@\n \t\t\t  (V8HI  \"v\")\n \t\t\t  (V4SI  \"wa\")])\n \n+;; Mode iterator for binary floating types other than double to\n+;; optimize convert to that floating point type from an extract\n+;; of an integer type\n+(define_mode_iterator VSX_EXTRACT_FL [SF\n+\t\t\t\t      (IF \"FLOAT128_2REG_P (IFmode)\")\n+\t\t\t\t      (KF \"TARGET_FLOAT128_HW\")\n+\t\t\t\t      (TF \"FLOAT128_2REG_P (TFmode)\n+\t\t\t\t\t   || (FLOAT128_IEEE_P (TFmode)\n+\t\t\t\t\t       && TARGET_FLOAT128_HW)\")])\n+\n ;; Iterator for the 2 short vector types to do a splat from an integer\n (define_mode_iterator VSX_SPLAT_I [V16QI V8HI])\n \n@@ -1907,6 +1917,7 @@\n   [(set_attr \"type\" \"vecdouble\")])\n \n ;; Convert from 32-bit to 64-bit types\n+;; Provide both vector and scalar targets\n (define_insn \"vsx_xvcvsxwdp\"\n   [(set (match_operand:V2DF 0 \"vsx_register_operand\" \"=wd,?wa\")\n \t(unspec:V2DF [(match_operand:V4SI 1 \"vsx_register_operand\" \"wf,wa\")]\n@@ -1915,6 +1926,14 @@\n   \"xvcvsxwdp %x0,%x1\"\n   [(set_attr \"type\" \"vecdouble\")])\n \n+(define_insn \"vsx_xvcvsxwdp_df\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws\")\n+\t(unspec:DF [(match_operand:V4SI 1 \"vsx_register_operand\" \"wa\")]\n+\t\t   UNSPEC_VSX_CVSXWDP))]\n+  \"TARGET_VSX\"\n+  \"xvcvsxwdp %x0,%x1\"\n+  [(set_attr \"type\" \"vecdouble\")])\n+\n (define_insn \"vsx_xvcvuxwdp\"\n   [(set (match_operand:V2DF 0 \"vsx_register_operand\" \"=wd,?wa\")\n \t(unspec:V2DF [(match_operand:V4SI 1 \"vsx_register_operand\" \"wf,wa\")]\n@@ -1923,6 +1942,14 @@\n   \"xvcvuxwdp %x0,%x1\"\n   [(set_attr \"type\" \"vecdouble\")])\n \n+(define_insn \"vsx_xvcvuxwdp_df\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=ws\")\n+\t(unspec:DF [(match_operand:V4SI 1 \"vsx_register_operand\" \"wa\")]\n+\t\t   UNSPEC_VSX_CVUXWDP))]\n+  \"TARGET_VSX\"\n+  \"xvcvuxwdp %x0,%x1\"\n+  [(set_attr \"type\" \"vecdouble\")])\n+\n (define_insn \"vsx_xvcvspsxds\"\n   [(set (match_operand:V2DI 0 \"vsx_register_operand\" \"=v,?wa\")\n \t(unspec:V2DI [(match_operand:V4SF 1 \"vsx_register_operand\" \"wd,wa\")]\n@@ -2574,11 +2601,11 @@\n   [(set_attr \"type\" \"vecsimple\")])\n \n (define_insn_and_split  \"*vsx_extract_si\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Z,Z,wJwK\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,wHwI,Z\")\n \t(vec_select:SI\n-\t (match_operand:V4SI 1 \"gpc_reg_operand\" \"v,wJwK,v,v\")\n-\t (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n,n,n,n\")])))\n-   (clobber (match_scratch:V4SI 3 \"=v,wJwK,v,v\"))]\n+\t (match_operand:V4SI 1 \"gpc_reg_operand\" \"wJv,wJv,wJv\")\n+\t (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n,n,n\")])))\n+   (clobber (match_scratch:V4SI 3 \"=wJv,wJv,wJv\"))]\n   \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -2628,7 +2655,7 @@\n \n   DONE;\n }\n-  [(set_attr \"type\" \"mftgpr,fpstore,fpstore,vecsimple\")\n+  [(set_attr \"type\" \"mftgpr,vecperm,fpstore\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn_and_split  \"*vsx_extract_<mode>_p8\"\n@@ -2714,6 +2741,107 @@\n   DONE;\n })\n \n+;; VSX_EXTRACT optimizations\n+;; Optimize double d = (double) vec_extract (vi, <n>)\n+;; Get the element into the top position and use XVCVSWDP/XVCVUWDP\n+(define_insn_and_split \"*vsx_extract_si_<uns>float_df\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=ws\")\n+\t(any_float:DF\n+\t (vec_select:SI\n+\t  (match_operand:V4SI 1 \"gpc_reg_operand\" \"v\")\n+\t  (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n\")]))))\n+   (clobber (match_scratch:V4SI 3 \"=v\"))]\n+  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx element = operands[2];\n+  rtx v4si_tmp = operands[3];\n+  int value;\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    element = GEN_INT (GET_MODE_NUNITS (V4SImode) - 1 - INTVAL (element));\n+\n+  /* If the value is in the correct position, we can avoid doing the VSPLT<x>\n+     instruction.  */\n+  value = INTVAL (element);\n+  if (value != 0)\n+    {\n+      if (GET_CODE (v4si_tmp) == SCRATCH)\n+\tv4si_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_altivec_vspltw_direct (v4si_tmp, src, element));\n+    }\n+  else\n+    v4si_tmp = src;\n+\n+  emit_insn (gen_vsx_xvcv<su>xwdp_df (dest, v4si_tmp));\n+  DONE;\n+})\n+\n+;; Optimize <type> f = (<type>) vec_extract (vi, <n>)\n+;; where <type> is a floating point type that supported by the hardware that is\n+;; not double.  First convert the value to double, and then to the desired\n+;; type.\n+(define_insn_and_split \"*vsx_extract_si_<uns>float_<mode>\"\n+  [(set (match_operand:VSX_EXTRACT_FL 0 \"gpc_reg_operand\" \"=ww\")\n+\t(any_float:VSX_EXTRACT_FL\n+\t (vec_select:SI\n+\t  (match_operand:V4SI 1 \"gpc_reg_operand\" \"v\")\n+\t  (parallel [(match_operand:QI 2 \"const_0_to_3_operand\" \"n\")]))))\n+   (clobber (match_scratch:V4SI 3 \"=v\"))\n+   (clobber (match_scratch:DF 4 \"=ws\"))]\n+  \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx element = operands[2];\n+  rtx v4si_tmp = operands[3];\n+  rtx df_tmp = operands[4];\n+  int value;\n+\n+  if (!VECTOR_ELT_ORDER_BIG)\n+    element = GEN_INT (GET_MODE_NUNITS (V4SImode) - 1 - INTVAL (element));\n+\n+  /* If the value is in the correct position, we can avoid doing the VSPLT<x>\n+     instruction.  */\n+  value = INTVAL (element);\n+  if (value != 0)\n+    {\n+      if (GET_CODE (v4si_tmp) == SCRATCH)\n+\tv4si_tmp = gen_reg_rtx (V4SImode);\n+      emit_insn (gen_altivec_vspltw_direct (v4si_tmp, src, element));\n+    }\n+  else\n+    v4si_tmp = src;\n+\n+  if (GET_CODE (df_tmp) == SCRATCH)\n+    df_tmp = gen_reg_rtx (DFmode);\n+\n+  emit_insn (gen_vsx_xvcv<su>xwdp_df (df_tmp, v4si_tmp));\n+\n+  if (<MODE>mode == SFmode)\n+    emit_insn (gen_truncdfsf2 (dest, df_tmp));\n+  else if (<MODE>mode == TFmode && FLOAT128_IBM_P (TFmode))\n+    emit_insn (gen_extenddftf2_vsx (dest, df_tmp));\n+  else if (<MODE>mode == TFmode && FLOAT128_IEEE_P (TFmode)\n+\t   && TARGET_FLOAT128_HW)\n+    emit_insn (gen_extenddftf2_hw (dest, df_tmp));\n+  else if (<MODE>mode == IFmode && FLOAT128_IBM_P (IFmode))\n+    emit_insn (gen_extenddfif2 (dest, df_tmp));\n+  else if (<MODE>mode == KFmode && TARGET_FLOAT128_HW)\n+    emit_insn (gen_extenddfkf2_hw (dest, df_tmp));\n+  else\n+    gcc_unreachable ();\n+\n+  DONE;\n+})\n+\n ;; Expanders for builtins\n (define_expand \"vsx_mergel_<mode>\"\n   [(use (match_operand:VSX_D 0 \"vsx_register_operand\" \"\"))"}, {"sha": "aed8a662d5c6e501a9f8929be9e7e1816924d561", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "patch": "@@ -1,3 +1,8 @@\n+2016-10-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/vsx-extract-4.c: New test.\n+\t* gcc.target/powerpc/vsx-extract-5.c: Likewise.\n+\n 2016-10-31  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/54679"}, {"sha": "3b498f4bc2a742ec6d63d74e5a704894d8a4bd62", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-4.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-4.c?ref=156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+/* { dg-final { scan-assembler-times \"vspltw\"    6 } } */\n+/* { dg-final { scan-assembler-times \"xvcvsxwdp\" 4 } } */\n+/* { dg-final { scan-assembler-times \"xvcvuxwdp\" 4 } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrd\"      } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrwa\"     } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrwz\"     } } */\n+/* { dg-final { scan-assembler-not   \"mfvsrd\"      } } */\n+/* { dg-final { scan-assembler-not   \"mfvsrwz\"     } } */\n+\n+#include <altivec.h>\n+\n+#ifndef TYPE\n+#define TYPE double\n+#endif\n+\n+TYPE\n+foo_0s (vector int v)\n+{\n+  int i = vec_extract (v, 0);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_1s (vector int v)\n+{\n+  int i = vec_extract (v, 1);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_2s (vector int v)\n+{\n+  int i = vec_extract (v, 2);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_3s (vector int v)\n+{\n+  int i = vec_extract (v, 3);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_0u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 0);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_1u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 1);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_2u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 2);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_3u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 3);\n+  return (TYPE) u;\n+}"}, {"sha": "1338c6b1de51fba3ad0136de8f10b2be10265e36", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-5.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-5.c?ref=156b5ccae7b1542a23d4d42b0a6cf9672c7b6e7d", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-O2 -mcpu=power8\" } */\n+\n+/* { dg-final { scan-assembler-times \"vspltw\"      6 } } */\n+/* { dg-final { scan-assembler-times \"xvcvsxwdp\"   4 } } */\n+/* { dg-final { scan-assembler-times \"xvcvuxwdp\"   4 } } */\n+/* { dg-final { scan-assembler-times \"frsp\\|xsrsp\" 8 } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrd\"        } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrwa\"       } } */\n+/* { dg-final { scan-assembler-not   \"mtvsrwz\"       } } */\n+/* { dg-final { scan-assembler-not   \"mfvsrd\"        } } */\n+/* { dg-final { scan-assembler-not   \"mfvsrwz\"       } } */\n+\n+#include <altivec.h>\n+\n+#ifndef TYPE\n+#define TYPE float\n+#endif\n+\n+TYPE\n+foo_0s (vector int v)\n+{\n+  int i = vec_extract (v, 0);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_1s (vector int v)\n+{\n+  int i = vec_extract (v, 1);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_2s (vector int v)\n+{\n+  int i = vec_extract (v, 2);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_3s (vector int v)\n+{\n+  int i = vec_extract (v, 3);\n+  return (TYPE) i;\n+}\n+\n+TYPE\n+foo_0u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 0);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_1u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 1);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_2u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 2);\n+  return (TYPE) u;\n+}\n+\n+TYPE\n+foo_3u (vector unsigned int v)\n+{\n+  unsigned int u = vec_extract (v, 3);\n+  return (TYPE) u;\n+}"}]}