{"sha": "b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "node_id": "C_kwDOANBUbNoAKGI3ZmQ3ZmI1MDExMTA2YzA2MmRmOTI3NWNhOGZkZGNiY2U0ZWJkZWI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-22T16:20:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-23T08:52:21Z"}, "message": "frange: drop endpoints to min/max representable numbers for -ffinite-math-only.\n\nSimilarly to how we drop NANs to UNDEFINED when -ffinite-math-only, I\nthink we can drop the numbers outside of the min/max representable\nnumbers to the representable number.\n\nThis means the endpoings to VR_VARYING for -ffinite-math-only can now\nbe the min/max representable, instead of -INF and +INF.\n\nSaturating in the setter means that the upcoming implementation for\nbinary operators no longer have to worry about doing the right\nthing for -ffinite-math-only.  If the range goes outside the limits,\nit'll get chopped down.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (build_le): Use vrp_val_*.\n\t(build_lt): Same.\n\t(build_ge): Same.\n\t(build_gt): Same.\n\t* value-range.cc (frange::set): Chop ranges outside of the\n\trepresentable numbers for -ffinite-math-only.\n\t(frange::normalize_kind): Use vrp_val*.\n\t(frange::verify_range): Same.\n\t(frange::set_nonnegative): Same.\n\t(range_tests_floats): Remove tests that depend on -INF and +INF.\n\t* value-range.h (real_max_representable): Add prototype.\n\t(real_min_representable): Same.\n\t(vrp_val_max): Set max representable number for\n\t-ffinite-math-only.\n\t(vrp_val_min): Same but for min.\n\t(frange::set_varying): Use vrp_val*.", "tree": {"sha": "a42c03a68d1a2a8f16bee2a2b6957ea6a1cf3586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a42c03a68d1a2a8f16bee2a2b6957ea6a1cf3586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76dbbfe62c0d7f4548cb12e757f67a1b1f84c3df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76dbbfe62c0d7f4548cb12e757f67a1b1f84c3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76dbbfe62c0d7f4548cb12e757f67a1b1f84c3df"}], "stats": {"total": 139, "additions": 94, "deletions": 45}, "files": [{"sha": "6e9d51d3b4b9a421fa510da18d45ea60c0e5af49", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "patch": "@@ -200,8 +200,7 @@ frelop_early_resolve (irange &r, tree type,\n static inline void\n frange_drop_inf (frange &r, tree type)\n {\n-  REAL_VALUE_TYPE max;\n-  real_max_representable (&max, type);\n+  REAL_VALUE_TYPE max = real_max_representable (type);\n   frange tmp (type, r.lower_bound (), max);\n   r.intersect (tmp);\n }\n@@ -212,8 +211,7 @@ frange_drop_inf (frange &r, tree type)\n static inline void\n frange_drop_ninf (frange &r, tree type)\n {\n-  REAL_VALUE_TYPE min;\n-  real_min_representable (&min, type);\n+  REAL_VALUE_TYPE min = real_min_representable (type);\n   frange tmp (type, min, r.upper_bound ());\n   r.intersect (tmp);\n }\n@@ -242,7 +240,8 @@ build_le (frange &r, tree type, const frange &val)\n {\n   gcc_checking_assert (!val.known_isnan ());\n \n-  r.set (type, dconstninf, val.upper_bound ());\n+  REAL_VALUE_TYPE ninf = frange_val_min (type);\n+  r.set (type, ninf, val.upper_bound ());\n \n   // Add both zeros if there's the possibility of zero equality.\n   frange_add_zeros (r, type);\n@@ -267,7 +266,8 @@ build_lt (frange &r, tree type, const frange &val)\n       return false;\n     }\n   // We only support closed intervals.\n-  r.set (type, dconstninf, val.upper_bound ());\n+  REAL_VALUE_TYPE ninf = frange_val_min (type);\n+  r.set (type, ninf, val.upper_bound ());\n   return true;\n }\n \n@@ -278,7 +278,8 @@ build_ge (frange &r, tree type, const frange &val)\n {\n   gcc_checking_assert (!val.known_isnan ());\n \n-  r.set (type, val.lower_bound (), dconstinf);\n+  REAL_VALUE_TYPE inf = frange_val_max (type);\n+  r.set (type, val.lower_bound (), inf);\n \n   // Add both zeros if there's the possibility of zero equality.\n   frange_add_zeros (r, type);\n@@ -304,7 +305,8 @@ build_gt (frange &r, tree type, const frange &val)\n     }\n \n   // We only support closed intervals.\n-  r.set (type, val.lower_bound (), dconstinf);\n+  REAL_VALUE_TYPE inf = frange_val_max (type);\n+  r.set (type, val.lower_bound (), inf);\n   return true;\n }\n "}, {"sha": "43905ba4901a2f7828e5abf17df4ddaa6d5d8d6f", "filename": "gcc/value-range.cc", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "patch": "@@ -338,6 +338,18 @@ frange::set (tree min, tree max, value_range_kind kind)\n       m_neg_nan = false;\n     }\n \n+  // For -ffinite-math-only we can drop ranges outside the\n+  // representable numbers to min/max for the type.\n+  if (flag_finite_math_only)\n+    {\n+      REAL_VALUE_TYPE min_repr = frange_val_min (m_type);\n+      REAL_VALUE_TYPE max_repr = frange_val_max (m_type);\n+      if (real_less (&m_min, &min_repr))\n+\tm_min = min_repr;\n+      if (real_less (&max_repr, &m_max))\n+\tm_max = max_repr;\n+    }\n+\n   // Check for swapped ranges.\n   gcc_checking_assert (tree_compare (LE_EXPR, min, max));\n \n@@ -371,8 +383,8 @@ bool\n frange::normalize_kind ()\n {\n   if (m_kind == VR_RANGE\n-      && real_isinf (&m_min, 1)\n-      && real_isinf (&m_max, 0))\n+      && frange_val_is_min (m_min, m_type)\n+      && frange_val_is_max (m_max, m_type))\n     {\n       if (m_pos_nan && m_neg_nan)\n \t{\n@@ -385,8 +397,8 @@ frange::normalize_kind ()\n       if (!m_pos_nan || !m_neg_nan)\n \t{\n \t  m_kind = VR_RANGE;\n-\t  m_min = dconstninf;\n-\t  m_max = dconstinf;\n+\t  m_min = frange_val_min (m_type);\n+\t  m_max = frange_val_max (m_type);\n \t  return true;\n \t}\n     }\n@@ -706,8 +718,8 @@ frange::verify_range ()\n     case VR_VARYING:\n       gcc_checking_assert (m_type);\n       gcc_checking_assert (m_pos_nan && m_neg_nan);\n-      gcc_checking_assert (real_isinf (&m_min, 1));\n-      gcc_checking_assert (real_isinf (&m_max, 0));\n+      gcc_checking_assert (frange_val_is_min (m_min, m_type));\n+      gcc_checking_assert (frange_val_is_max (m_max, m_type));\n       return;\n     case VR_RANGE:\n       gcc_checking_assert (m_type);\n@@ -732,7 +744,8 @@ frange::verify_range ()\n   // If all the properties are clear, we better not span the entire\n   // domain, because that would make us varying.\n   if (m_pos_nan && m_neg_nan)\n-    gcc_checking_assert (!real_isinf (&m_min, 1) || !real_isinf (&m_max, 0));\n+    gcc_checking_assert (!frange_val_is_min (m_min, m_type)\n+\t\t\t || !frange_val_is_max (m_max, m_type));\n }\n \n // We can't do much with nonzeros yet.\n@@ -779,7 +792,7 @@ frange::zero_p () const\n void\n frange::set_nonnegative (tree type)\n {\n-  set (type, dconst0, dconstinf);\n+  set (type, dconst0, frange_val_max (type));\n \n   // Set +NAN as the only possibility.\n   if (HONOR_NANS (type))\n@@ -3886,23 +3899,6 @@ range_tests_floats ()\n   r0.clear_nan ();\n   ASSERT_FALSE (r0.varying_p ());\n \n-  // The endpoints of a VARYING are +-INF.\n-  r0.set_varying (float_type_node);\n-  ASSERT_TRUE (real_identical (&r0.lower_bound (), &dconstninf));\n-  ASSERT_TRUE (real_identical (&r0.upper_bound (), &dconstinf));\n-\n-  // The maximum representable range for a type is still a subset of VARYING.\n-  REAL_VALUE_TYPE q, r;\n-  real_min_representable (&q, float_type_node);\n-  real_max_representable (&r, float_type_node);\n-  r0 = frange (float_type_node, q, r);\n-  // r0 is not a varying, because it does not include -INF/+INF.\n-  ASSERT_FALSE (r0.varying_p ());\n-  // The upper bound of r0 must be less than +INF.\n-  ASSERT_TRUE (real_less (&r0.upper_bound (), &dconstinf));\n-  // The lower bound of r0 must be greater than -INF.\n-  ASSERT_TRUE (real_less (&dconstninf, &r0.lower_bound ()));\n-\n   // For most architectures, where float and double are different\n   // sizes, having the same endpoints does not necessarily mean the\n   // ranges are equal."}, {"sha": "413e54bda6f47358a55bf0fe0f5778683da4d186", "filename": "gcc/value-range.h", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fd7fb5011106c062df9275ca8fddcbce4ebdeb/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=b7fd7fb5011106c062df9275ca8fddcbce4ebdeb", "patch": "@@ -593,6 +593,8 @@ extern void dump_value_range (FILE *, const vrange *);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n extern bool vrp_operand_equal_p (const_tree, const_tree);\n+inline REAL_VALUE_TYPE frange_val_min (const_tree type);\n+inline REAL_VALUE_TYPE frange_val_max (const_tree type);\n \n inline value_range_kind\n vrange::kind () const\n@@ -1009,7 +1011,10 @@ vrp_val_max (const_tree type)\n       return wide_int_to_tree (const_cast<tree> (type), max);\n     }\n   if (frange::supports_p (type))\n-    return build_real (const_cast <tree> (type), dconstinf);\n+    {\n+      REAL_VALUE_TYPE r = frange_val_max (type);\n+      return build_real (const_cast <tree> (type), r);\n+    }\n   return NULL_TREE;\n }\n \n@@ -1023,7 +1028,10 @@ vrp_val_min (const_tree type)\n   if (POINTER_TYPE_P (type))\n     return build_zero_cst (const_cast<tree> (type));\n   if (frange::supports_p (type))\n-    return build_real (const_cast <tree> (type), dconstninf);\n+    {\n+      REAL_VALUE_TYPE r = frange_val_min (type);\n+      return build_real (const_cast <tree> (type), r);\n+    }\n   return NULL_TREE;\n }\n \n@@ -1073,8 +1081,8 @@ frange::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   m_type = type;\n-  m_min = dconstninf;\n-  m_max = dconstinf;\n+  m_min = frange_val_min (type);\n+  m_max = frange_val_max (type);\n   m_pos_nan = true;\n   m_neg_nan = true;\n }\n@@ -1132,23 +1140,66 @@ frange::clear_nan ()\n \n // Set R to maximum representable value for TYPE.\n \n-inline void\n-real_max_representable (REAL_VALUE_TYPE *r, tree type)\n+inline REAL_VALUE_TYPE\n+real_max_representable (const_tree type)\n {\n+  REAL_VALUE_TYPE r;\n   char buf[128];\n   get_max_float (REAL_MODE_FORMAT (TYPE_MODE (type)),\n \t\t buf, sizeof (buf), false);\n-  int res = real_from_string (r, buf);\n+  int res = real_from_string (&r, buf);\n   gcc_checking_assert (!res);\n+  return r;\n }\n \n-// Set R to minimum representable value for TYPE.\n+// Return the minimum representable value for TYPE.\n \n-inline void\n-real_min_representable (REAL_VALUE_TYPE *r, tree type)\n+inline REAL_VALUE_TYPE\n+real_min_representable (const_tree type)\n+{\n+  REAL_VALUE_TYPE r = real_max_representable (type);\n+  r = real_value_negate (&r);\n+  return r;\n+}\n+\n+// Return the minimum value for TYPE.\n+\n+inline REAL_VALUE_TYPE\n+frange_val_min (const_tree type)\n+{\n+  if (flag_finite_math_only)\n+    return real_min_representable (type);\n+  else\n+    return dconstninf;\n+}\n+\n+// Return the maximum value for TYPE.\n+\n+inline REAL_VALUE_TYPE\n+frange_val_max (const_tree type)\n+{\n+  if (flag_finite_math_only)\n+    return real_max_representable (type);\n+  else\n+    return dconstinf;\n+}\n+\n+// Return TRUE if R is the minimum value for TYPE.\n+\n+inline bool\n+frange_val_is_min (const REAL_VALUE_TYPE &r, const_tree type)\n+{\n+  REAL_VALUE_TYPE min = frange_val_min (type);\n+  return real_identical (&min, &r);\n+}\n+\n+// Return TRUE if R is the max value for TYPE.\n+\n+inline bool\n+frange_val_is_max (const REAL_VALUE_TYPE &r, const_tree type)\n {\n-  real_max_representable (r, type);\n-  *r = real_value_negate (r);\n+  REAL_VALUE_TYPE max = frange_val_max (type);\n+  return real_identical (&max, &r);\n }\n \n // Build a signless NAN of type TYPE."}]}