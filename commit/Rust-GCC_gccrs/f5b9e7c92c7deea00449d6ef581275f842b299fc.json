{"sha": "f5b9e7c92c7deea00449d6ef581275f842b299fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViOWU3YzkyYzdkZWVhMDA0NDlkNmVmNTgxMjc1Zjg0MmIyOTlmYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-09T11:24:17Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-09T11:24:17Z"}, "message": "sh.c (print_operand_address): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/sh/sh.c (print_operand_address): Use gcc_assert and\n\tgcc_unreachable as appropriate.\n\t(print_operand, prepare_move_operands, prepare_scc_operands,\n\toutput_movedouble, output_branch, shift_insns_rtx, gen_shifty_op,\n\tgen_shl_and, shl_sext_kind, gen_datalabel_ref, dump_table,\n\tfixup_mova, gen_far_branch, sh_reorg, split_branches,\n\tfinal_prescan_insn, output_stack_adjust, sh_expand_epilogue,\n\tsh_set_return_address, sh_setup_incoming_varargs,\n\tinitial_elimination_offset, sh_pch_valid_p, get_free_reg,\n\tsh_expand_builtin, sh_output_mi_thunk, extract_sfunc_addr,\n\tcheck_use_sfunc_addr): Likewise.\n\t* config/sh/netbsd-elf.h (FUNCTION_PROFILER): Likewise.\n\t* config/sh/sh.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n\t* config/sh/symbian.c (sh_symbian_mark_dllexport,\n\tsh_symbian_mark_dllimport): Likewise.\n\t* config/sh/sh.md: Likewise.\n\t(movdicc, call_pop, call_value_pop, casesi_worker_1,\n\tcasesi_worker_2, casesi_shift_media, casesi_load_media,\n\treturn_media): Likewise.\n\nFrom-SVN: r99425", "tree": {"sha": "1427f5aadf232d9d3b9382b46e5888869fdfea73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1427f5aadf232d9d3b9382b46e5888869fdfea73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5b9e7c92c7deea00449d6ef581275f842b299fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b9e7c92c7deea00449d6ef581275f842b299fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b9e7c92c7deea00449d6ef581275f842b299fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b9e7c92c7deea00449d6ef581275f842b299fc/comments", "author": null, "committer": null, "parents": [{"sha": "4581ba9d4f3767e4b0dea0bc101b0e865cfcd85d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4581ba9d4f3767e4b0dea0bc101b0e865cfcd85d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4581ba9d4f3767e4b0dea0bc101b0e865cfcd85d"}], "stats": {"total": 644, "additions": 326, "deletions": 318}, "files": [{"sha": "b40aca09c62ea43027c2311aafc997d9aaccedda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -1,3 +1,25 @@\n+2005-05-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/sh/sh.c (print_operand_address): Use gcc_assert and\n+\tgcc_unreachable as appropriate.\n+\t(print_operand, prepare_move_operands, prepare_scc_operands,\n+\toutput_movedouble, output_branch, shift_insns_rtx, gen_shifty_op,\n+\tgen_shl_and, shl_sext_kind, gen_datalabel_ref, dump_table,\n+\tfixup_mova, gen_far_branch, sh_reorg, split_branches,\n+\tfinal_prescan_insn, output_stack_adjust, sh_expand_epilogue,\n+\tsh_set_return_address, sh_setup_incoming_varargs,\n+\tinitial_elimination_offset, sh_pch_valid_p, get_free_reg,\n+\tsh_expand_builtin, sh_output_mi_thunk, extract_sfunc_addr,\n+\tcheck_use_sfunc_addr): Likewise.\n+\t* config/sh/netbsd-elf.h (FUNCTION_PROFILER): Likewise.\n+\t* config/sh/sh.h (ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n+\t* config/sh/symbian.c (sh_symbian_mark_dllexport,\n+\tsh_symbian_mark_dllimport): Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\t(movdicc, call_pop, call_value_pop, casesi_worker_1,\n+\tcasesi_worker_2, casesi_shift_media, casesi_load_media,\n+\treturn_media): Likewise.\n+\n 2005-05-08  Roger Sayle  <roger@eyesopen.com>\n \n \tPR inline-asm/8788"}, {"sha": "a6385466bb8344772f03d1b3369528114e34a803", "filename": "gcc/config/sh/netbsd-elf.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fnetbsd-elf.h?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -89,15 +89,10 @@ Boston, MA 02111-1307, USA.  */\n #define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_SHMEDIA32)\t\t\t\t\t\t\\\n+    if (TARGET_SHMEDIA32 || TARGET_SHMEDIA64)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \t/* FIXME */\t\t\t\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (TARGET_SHMEDIA64)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t/* FIXME */\t\t\t\t\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\t\\\n+\tsorry (\"unimplemented-shmedia profiling\");\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "8a6e1a6832f2a151c4c46cade6fd0753c867a930", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 166, "deletions": 172, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -518,8 +518,7 @@ print_operand_address (FILE *stream, rtx x)\n \t    }\n \n \t  default:\n-\t    debug_rtx (x);\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n       }\n       break;\n@@ -646,8 +645,7 @@ print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     case 'm':\n-      if (GET_CODE (x) != MEM)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == MEM);\n       x = XEXP (x, 0);\n       switch (GET_CODE (x))\n \t{\n@@ -664,13 +662,12 @@ print_operand (FILE *stream, rtx x, int code)\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       break;\n \n     case 'd':\n-      if (GET_CODE (x) != REG || GET_MODE (x) != V2SFmode)\n-\tabort ();\n+      gcc_assert (GET_CODE (x) == REG && GET_MODE (x) == V2SFmode);\n \n       fprintf ((stream), \"d%s\", reg_names[REGNO (x)] + 1);\n       break;\n@@ -700,9 +697,8 @@ print_operand (FILE *stream, rtx x, int code)\n \t     subreg:SI of the DImode register.  Maybe reload should be\n \t     fixed so as to apply alter_subreg to such loads?  */\n \tcase SUBREG:\n-\t  if (SUBREG_BYTE (x) != 0\n-\t      || GET_CODE (SUBREG_REG (x)) != REG)\n-\t    abort ();\n+\t  gcc_assert (SUBREG_BYTE (x) == 0\n+\t\t      && GET_CODE (SUBREG_REG (x)) == REG);\n \n \t  x = SUBREG_REG (x);\n \t  /* Fall through.  */\n@@ -1078,7 +1074,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  operands[1] = op1;\n \t}\n@@ -1101,7 +1097,7 @@ prepare_scc_operands (enum rtx_code code)\n     {\n     case NE:\n       /* It isn't possible to handle this case.  */\n-      abort ();\n+      gcc_unreachable ();\n     case LT:\n       code = GT;\n       break;\n@@ -1239,12 +1235,17 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n       int dreg = REGNO (dst);\n       rtx inside = XEXP (src, 0);\n \n-      if (GET_CODE (inside) == REG)\n-\tptrreg = REGNO (inside);\n-      else if (GET_CODE (inside) == SUBREG)\n-\tptrreg = subreg_regno (inside);\n-      else if (GET_CODE (inside) == PLUS)\n+      switch (GET_CODE (inside))\n \t{\n+\tcase REG:\n+\t  ptrreg = REGNO (inside);\n+\t  break;\n+\n+\tcase SUBREG:\n+\t  ptrreg = subreg_regno (inside);\n+\t  break;\n+\n+\tcase PLUS:\n \t  ptrreg = REGNO (XEXP (inside, 0));\n \t  /* ??? A r0+REG address shouldn't be possible here, because it isn't\n \t     an offsettable address.  Unfortunately, offsettable addresses use\n@@ -1253,15 +1254,16 @@ output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n \t     supported, so we can't use the 'o' constraint.\n \t     Thus we must check for and handle r0+REG addresses here.\n \t     We punt for now, since this is likely very rare.  */\n-\t  if (GET_CODE (XEXP (inside, 1)) == REG)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (XEXP (inside, 1)) != REG);\n+\t  break;\n+\t  \n+\tcase LABEL_REF:\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%T0\";\n+\tcase POST_INC:\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0\";\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (GET_CODE (inside) == LABEL_REF)\n-\treturn \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%T0\";\n-      else if (GET_CODE (inside) == POST_INC)\n-\treturn \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0\";\n-      else\n-\tabort ();\n \n       /* Work out the safe way to copy.  Copy into the second half first.  */\n       if (dreg == ptrreg)\n@@ -1430,9 +1432,9 @@ output_branch (int logic, rtx insn, rtx *operands)\n \t{\n \t  int label = lf++;\n \n-\t  if (final_sequence\n-\t      && INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n-\t    abort ();\n+\t  gcc_assert (!final_sequence\n+\t\t      || !(INSN_ANNULLED_BRANCH_P\n+\t\t\t   (XVECEXP (final_sequence, 0, 0))));\n \t  asm_fprintf (asm_out_file, \"b%s%ss\\t%LLF%d\\n\",\n \t\t       logic ? \"f\" : \"t\",\n \t\t       ASSEMBLER_DIALECT ? \"/\" : \".\", label);\n@@ -1459,7 +1461,7 @@ output_branch (int logic, rtx insn, rtx *operands)\n       /* There should be no longer branches now - that would\n \t indicate that something has destroyed the branches set\n \t up in machine_dependent_reorg.  */\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -1663,7 +1665,7 @@ shift_insns_rtx (rtx insn)\n     case ASHIFT:\n       return shift_insns[shift_count];\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -2023,7 +2025,7 @@ gen_shifty_op (int code, rtx *operands)\n   else if (value == 0)\n     {\n       /* This can happen when not optimizing.  We must output something here\n-\t to prevent the compiler from aborting in final.c after the try_split\n+\t to prevent the compiler from dying in final.c after the try_split\n \t call.  */\n       emit_insn (gen_nop ());\n       return;\n@@ -2389,8 +2391,7 @@ gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n \n \t  /* Cases 3 and 4 should be handled by this split\n \t     only while combining  */\n-\t  if (kind > 2)\n-\t    abort ();\n+\t  gcc_assert (kind <= 2);\n \t  if (right)\n \t    {\n \t      emit_insn (gen_lshrsi3 (dest, source, GEN_INT (right)));\n@@ -2457,8 +2458,7 @@ shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n   left = INTVAL (left_rtx);\n   size = INTVAL (size_rtx);\n   insize = size - left;\n-  if (insize <= 0)\n-    abort ();\n+  gcc_assert (insize > 0);\n   /* Default to left / right shift.  */\n   kind = 0;\n   best_cost = shift_insns[32 - insize] + ashiftrt_insns[32 - size];\n@@ -2686,8 +2686,7 @@ gen_datalabel_ref (rtx sym)\n \t\t\t\t\t  gen_rtvec (1, sym),\n \t\t\t\t\t  UNSPEC_DATALABEL));\n \n-  if (GET_CODE (sym) != SYMBOL_REF)\n-    abort ();\n+  gcc_assert (GET_CODE (sym) == SYMBOL_REF);\n \n   return sym;\n }\n@@ -2965,8 +2964,7 @@ dump_table (rtx start, rtx barrier)\n \t\t\t\t      scan);\n \t      break;\n \t    default:\n-\t      abort ();\n-\t      break;\n+\t      gcc_unreachable ();\n \t    }\n \n \t  if (p->mode != HImode)\n@@ -3018,8 +3016,7 @@ dump_table (rtx start, rtx barrier)\n \t\t\t\t  scan);\n \t  break;\n \tdefault:\n-\t  abort ();\n-\t  break;\n+\t  gcc_unreachable ();\n \t}\n \n       if (p->mode != HImode)\n@@ -3130,10 +3127,9 @@ fixup_mova (rtx mova)\n       do\n \t{\n \t  worker = NEXT_INSN (worker);\n-\t  if (! worker\n-\t      || GET_CODE (worker) == CODE_LABEL\n-\t      || GET_CODE (worker) == JUMP_INSN)\n-\t    abort ();\n+\t  gcc_assert (worker\n+\t\t      && GET_CODE (worker) != CODE_LABEL\n+\t\t      && GET_CODE (worker) != JUMP_INSN);\n \t} while (recog_memoized (worker) != CODE_FOR_casesi_worker_1);\n       wpat = PATTERN (worker);\n       wpat0 = XVECEXP (wpat, 0, 0);\n@@ -3772,6 +3768,7 @@ gen_far_branch (struct far_branch *bp)\n   rtx insn = bp->insert_place;\n   rtx jump;\n   rtx label = gen_label_rtx ();\n+  int ok;\n \n   emit_label_after (label, insn);\n   if (bp->far_label)\n@@ -3790,8 +3787,9 @@ gen_far_branch (struct far_branch *bp)\n     emit_barrier_after (jump);\n   emit_label_after (bp->near_label, insn);\n   JUMP_LABEL (jump) = bp->far_label;\n-  if (! invert_jump (insn, label, 1))\n-    abort ();\n+  ok = invert_jump (insn, label, 1);\n+  gcc_assert (ok);\n+  \n   /* If we are branching around a jump (rather than a return), prevent\n      reorg from using an insn from the jump target as the delay slot insn -\n      when reorg did this, it pessimized code (we rather hide the delay slot)\n@@ -4365,9 +4363,8 @@ sh_reorg (void)\n \t\t\t\t\t\t- 1);\n \t\t      rtx clobber = *clobberp;\n \n-\t\t      if (GET_CODE (clobber) != CLOBBER\n-\t\t\t  || ! rtx_equal_p (XEXP (clobber, 0), r0_rtx))\n-\t\t\tabort ();\n+\t\t      gcc_assert (GET_CODE (clobber) == CLOBBER\n+\t\t\t\t  && rtx_equal_p (XEXP (clobber, 0), r0_rtx));\n \n \t\t      if (last_float\n \t\t\t  && reg_set_between_p (r0_rtx, last_float_move, scan))\n@@ -4501,6 +4498,7 @@ split_branches (rtx first)\n   rtx insn;\n   struct far_branch **uid_branch, *far_branch_list = 0;\n   int max_uid = get_max_uid ();\n+  int ok;\n \n   /* Find out which branches are out of range.  */\n   shorten_branches (first);\n@@ -4590,8 +4588,8 @@ split_branches (rtx first)\n \t\t    bp->insert_place = insn;\n \t\t    bp->address = addr;\n \t\t  }\n-\t\tif (! redirect_jump (insn, label, 1))\n-\t\t  abort ();\n+\t\tok = redirect_jump (insn, label, 1);\n+\t\tgcc_assert (ok);\n \t      }\n \t    else\n \t      {\n@@ -4737,19 +4735,29 @@ final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n \t  rtx pattern;\n \n \t  pattern = PATTERN (insn);\n-\t  if (GET_CODE (pattern) == PARALLEL)\n-\t    pattern = XVECEXP (pattern, 0, 0);\n-\t  if (GET_CODE (pattern) == CALL\n-\t      || (GET_CODE (pattern) == SET\n-\t\t  && (GET_CODE (SET_SRC (pattern)) == CALL\n-\t\t      || get_attr_type (insn) == TYPE_SFUNC)))\n-\t    asm_fprintf (asm_out_file, \"\\t.uses %LL%d\\n\",\n-\t\t\t CODE_LABEL_NUMBER (XEXP (note, 0)));\n-\t  else if (GET_CODE (pattern) == SET)\n-\t    (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t       CODE_LABEL_NUMBER (XEXP (note, 0)));\n-\t  else\n-\t    abort ();\n+\t  switch (GET_CODE (pattern))\n+\t    {\n+\t    case PARALLEL:\n+\t      pattern = XVECEXP (pattern, 0, 0);\n+\t      break;\n+\n+\t    case SET:\n+\t      if (GET_CODE (SET_SRC (pattern)) != CALL\n+\t\t  && get_attr_type (insn) != TYPE_SFUNC)\n+\t\t{\n+\t\t  targetm.asm_out.internal_label\n+\t\t    (asm_out_file, \"L\", CODE_LABEL_NUMBER (XEXP (note, 0)));\n+\t\t  break;\n+\t\t}\n+\t      /* else FALLTHROUGH */\n+\t    case CALL:\n+\t      asm_fprintf (asm_out_file, \"\\t.uses %LL%d\\n\",\n+\t\t\t   CODE_LABEL_NUMBER (XEXP (note, 0)));\n+\t      break;\n+\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t}\n     }\n }\n@@ -4819,8 +4827,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n /* This test is bogus, as output_stack_adjust is used to re-align the\n    stack.  */\n #if 0\n-      if (size % align)\n-\tabort ();\n+      gcc_assert (!(size % align));\n #endif\n \n       if (CONST_OK_FOR_ADD (size))\n@@ -4843,7 +4850,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \n \t  /* If TEMP is invalid, we could temporarily save a general\n \t     register to MACL.  However, there is currently no need\n-\t     to handle this case, so just abort when we see it.  */\n+\t     to handle this case, so just die when we see it.  */\n \t  if (epilogue_p < 0\n \t      || current_function_interrupt\n \t      || ! call_really_used_regs[temp] || fixed_regs[temp])\n@@ -4890,53 +4897,53 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t    temp = scavenge_reg (live_regs_mask);\n \t  if (temp < 0)\n \t    {\n+\t      rtx adj_reg, tmp_reg, mem;\n+\t      \n \t      /* If we reached here, the most likely case is the (sibcall)\n \t\t epilogue for non SHmedia.  Put a special push/pop sequence\n \t\t for such case as the last resort.  This looks lengthy but\n-\t\t would not be problem because it seems to be very rare.  */\n-\t      if (! TARGET_SHMEDIA && epilogue_p)\n-\t\t{\n-\t\t  rtx adj_reg, tmp_reg, mem;\n-\n-\t\t  /* ??? There is still the slight possibility that r4 or r5\n-\t\t     have been reserved as fixed registers or assigned as\n-\t\t     global registers, and they change during an interrupt.\n-\t\t     There are possible ways to handle this:\n-\t\t     - If we are adjusting the frame pointer (r14), we can do\n-\t\t       with a single temp register and an ordinary push / pop\n-\t\t       on the stack.\n-\t\t     - Grab any call-used or call-saved registers (i.e. not\n-\t\t       fixed or globals) for the temps we need.  We might\n-\t\t       also grab r14 if we are adjusting the stack pointer.\n-\t\t       If we can't find enough available registers, issue\n-\t\t       a diagnostic and abort - the user must have reserved\n-\t\t       way too many registers.\n-\t\t     But since all this is rather unlikely to happen and\n-\t\t     would require extra testing, we just abort if r4 / r5\n-\t\t     are not available.  */\n-\t\t  if (fixed_regs[4] || fixed_regs[5]\n-\t\t      || global_regs[4] || global_regs[5])\n-\t\t    abort ();\n-\n-\t\t  adj_reg = gen_rtx_REG (GET_MODE (reg), 4);\n-\t\t  tmp_reg = gen_rtx_REG (GET_MODE (reg), 5);\n-\t\t  emit_move_insn (gen_rtx_MEM (Pmode, reg), adj_reg);\n-\t\t  emit_insn (GEN_MOV (adj_reg, GEN_INT (size)));\n-\t\t  emit_insn (GEN_ADD3 (adj_reg, adj_reg, reg));\n-\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n-\t\t  emit_move_insn (mem, tmp_reg);\n-\t\t  emit_move_insn (tmp_reg, gen_rtx_MEM (Pmode, reg));\n-\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n-\t\t  emit_move_insn (mem, tmp_reg);\n-\t\t  emit_move_insn (reg, adj_reg);\n-\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n-\t\t  emit_move_insn (adj_reg, mem);\n-\t\t  mem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n-\t\t  emit_move_insn (tmp_reg, mem);\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\tabort ();\n+\t\t would not be problem because it seems to be very\n+\t\t rare.  */\n+\t      \n+\t      gcc_assert (!TARGET_SHMEDIA && epilogue_p);\n+\t      \n+\n+\t       /* ??? There is still the slight possibility that r4 or\n+\t\t  r5 have been reserved as fixed registers or assigned\n+\t\t  as global registers, and they change during an\n+\t\t  interrupt.  There are possible ways to handle this:\n+\t\t     \n+\t\t  - If we are adjusting the frame pointer (r14), we can do\n+\t\t    with a single temp register and an ordinary push / pop\n+\t\t    on the stack.\n+\t\t  - Grab any call-used or call-saved registers (i.e. not\n+\t\t    fixed or globals) for the temps we need.  We might\n+\t\t    also grab r14 if we are adjusting the stack pointer.\n+\t\t    If we can't find enough available registers, issue\n+\t\t    a diagnostic and die - the user must have reserved\n+\t\t    way too many registers.\n+\t\t But since all this is rather unlikely to happen and\n+\t\t would require extra testing, we just die if r4 / r5\n+\t\t are not available.  */\n+\t      gcc_assert (!fixed_regs[4] && !fixed_regs[5]\n+\t\t\t  && !global_regs[4] && !global_regs[5]);\n+\n+\t      adj_reg = gen_rtx_REG (GET_MODE (reg), 4);\n+\t      tmp_reg = gen_rtx_REG (GET_MODE (reg), 5);\n+\t      emit_move_insn (gen_rtx_MEM (Pmode, reg), adj_reg);\n+\t      emit_insn (GEN_MOV (adj_reg, GEN_INT (size)));\n+\t      emit_insn (GEN_ADD3 (adj_reg, adj_reg, reg));\n+\t      mem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n+\t      emit_move_insn (mem, tmp_reg);\n+\t      \temit_move_insn (tmp_reg, gen_rtx_MEM (Pmode, reg));\n+\t\tmem = gen_rtx_MEM (Pmode, gen_rtx_PRE_DEC (Pmode, adj_reg));\n+\t\temit_move_insn (mem, tmp_reg);\n+\t\temit_move_insn (reg, adj_reg);\n+\t\tmem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n+\t\temit_move_insn (adj_reg, mem);\n+\t\tmem = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, reg));\n+\t\temit_move_insn (tmp_reg, mem);\n+\t\treturn;\n \t    }\n \t  const_reg = gen_rtx_REG (GET_MODE (reg), temp);\n \n@@ -5590,8 +5597,7 @@ sh_expand_prologue (void)\n \n \t  GO_IF_LEGITIMATE_ADDRESS (mode, XEXP (mem_rtx, 0), try_pre_dec);\n \n-\t  if (! r0)\n-\t    abort ();\n+\t  gcc_assert (r0);\n \t  mem_rtx = NULL_RTX;\n \n \ttry_pre_dec:\n@@ -5661,11 +5667,10 @@ sh_expand_prologue (void)\n \t     registers or for special registers without pre-dec\n \t     memory addresses, since we store their values in r0\n \t     first.  */\n-\t  if (TARGET_REGISTER_P (reg)\n-\t      || ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n-\t\t  && mem_rtx != pre_dec))\n-\t    abort ();\n-\n+\t  gcc_assert (!TARGET_REGISTER_P (reg)\n+\t\t      && ((reg != PR_REG && !SPECIAL_REGISTER_P (reg))\n+\t\t\t  || mem_rtx == pre_dec));\n+\t  \n \taddr_ok:\n \t  orig_reg_rtx = reg_rtx;\n \t  if (TARGET_REGISTER_P (reg)\n@@ -5680,8 +5685,8 @@ sh_expand_prologue (void)\n \t\t{\n \t\t  offset_in_r0 = -1;\n \t\t  sp_in_r0 = 0;\n-\t\t  if (refers_to_regno_p (R0_REG, R0_REG+1, mem_rtx, (rtx *) 0))\n-\t\t    abort ();\n+\t\t  gcc_assert (!refers_to_regno_p\n+\t\t\t      (R0_REG, R0_REG+1, mem_rtx, (rtx *) 0));\n \t\t}\n \n \t      if (*++tmp_pnt <= 0)\n@@ -5729,8 +5734,7 @@ sh_expand_prologue (void)\n \t  }\n \t}\n \n-      if (entry->offset != d_rounding)\n-\tabort ();\n+      gcc_assert (entry->offset == d_rounding);\n     }\n   else\n     push_regs (&live_regs_mask, current_function_interrupt);\n@@ -5974,9 +5978,8 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t\t\t\t\t stack_pointer_rtx,\n \t\t\t\t\t\t r0));\n \n-\t  if ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n-\t      && mem_rtx != post_inc)\n-\t    abort ();\n+\t  gcc_assert ((reg != PR_REG && !SPECIAL_REGISTER_P (reg))\n+\t\t      || mem_rtx == post_inc);\n \n \taddr_ok:\n \t  if ((reg == PR_REG || SPECIAL_REGISTER_P (reg))\n@@ -6005,8 +6008,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n \n-      if (entry->offset + offset_base != d + d_rounding)\n-\tabort ();\n+      gcc_assert (entry->offset + offset_base == d + d_rounding);\n     }\n   else /* ! TARGET_SH5 */\n     {\n@@ -6121,7 +6123,7 @@ sh_set_return_address (rtx ra, rtx tmp)\n \t  goto found;\n \n       /* We can't find pr register.  */\n-      abort ();\n+      gcc_unreachable ();\n \n     found:\n       offset = entry->offset - offset;\n@@ -6989,8 +6991,7 @@ sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca,\n \t\t\t   int *pretend_arg_size,\n \t\t\t   int second_time ATTRIBUTE_UNUSED)\n {\n-  if (! current_function_stdarg)\n-    abort ();\n+  gcc_assert (current_function_stdarg);\n   if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n     {\n       int named_parm_regs, anon_parm_regs;\n@@ -7064,38 +7065,34 @@ initial_elimination_offset (int from, int to)\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n     return 0;\n \n-  if (from == RETURN_ADDRESS_POINTER_REGNUM\n-      && (to == FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM))\n+  gcc_assert (from == RETURN_ADDRESS_POINTER_REGNUM\n+\t      && (to == FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM));\n+  if (TARGET_SH5)\n     {\n-      if (TARGET_SH5)\n-\t{\n-\t  int n = total_saved_regs_space;\n-\t  int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n-\t  save_schedule schedule;\n-\t  save_entry *entry;\n-\n-\t  n += total_auto_space;\n-\n-\t  /* If it wasn't saved, there's not much we can do.  */\n-\t  if (! TEST_HARD_REG_BIT (live_regs_mask, pr_reg))\n-\t    return n;\n-\n-\t  target_flags = copy_flags;\n-\n-\t  sh5_schedule_saves (&live_regs_mask, &schedule, n);\n-\t  for (entry = &schedule.entries[1]; entry->mode != VOIDmode; entry++)\n-\t    if (entry->reg == pr_reg)\n-\t      {\n-\t\ttarget_flags = save_flags;\n-\t\treturn entry->offset;\n-\t      }\n-\t  abort ();\n-\t}\n-      else\n-\treturn total_auto_space;\n+      int n = total_saved_regs_space;\n+      int pr_reg = TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG;\n+      save_schedule schedule;\n+      save_entry *entry;\n+      \n+      n += total_auto_space;\n+      \n+      /* If it wasn't saved, there's not much we can do.  */\n+      if (! TEST_HARD_REG_BIT (live_regs_mask, pr_reg))\n+\treturn n;\n+      \n+      target_flags = copy_flags;\n+      \n+      sh5_schedule_saves (&live_regs_mask, &schedule, n);\n+      for (entry = &schedule.entries[1]; entry->mode != VOIDmode; entry++)\n+\tif (entry->reg == pr_reg)\n+\t  {\n+\t    target_flags = save_flags;\n+\t    return entry->offset;\n+\t  }\n+      gcc_unreachable ();\n     }\n-\n-  abort ();\n+  else\n+    return total_auto_space;\n }\n \f\n /* Handle machine specific pragmas to be semi-compatible with Renesas\n@@ -7353,7 +7350,7 @@ sh_pch_valid_p (const void *data_p, size_t len)\n \t      goto make_message;\n \t    }\n \t}\n-      abort ();\n+      gcc_unreachable ();\n     }\n   data += sizeof (target_flags);\n   len -= sizeof (target_flags);\n@@ -8260,10 +8257,8 @@ get_free_reg (HARD_REG_SET regs_live)\n \n   /* Hard reg 1 is live; since this is a SMALL_REGISTER_CLASSES target,\n      there shouldn't be anything but a jump before the function end.  */\n-  if (! TEST_HARD_REG_BIT (regs_live, 7))\n-    return gen_rtx_REG (Pmode, 7);\n-\n-  abort ();\n+  gcc_assert (!TEST_HARD_REG_BIT (regs_live, 7));\n+  return gen_rtx_REG (Pmode, 7);\n }\n \n /* This function will set the fpscr from memory.\n@@ -9538,7 +9533,7 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       pat = (*insn_data[d->icode].genfun) (op[0], op[1], op[2], op[3]);\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (! pat)\n     return 0;\n@@ -9817,7 +9812,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t  offset_addr = scratch0;\n \t}\n       else\n-\tabort (); /* FIXME */\n+\tgcc_unreachable (); /* FIXME */\n       emit_load_ptr (scratch0, offset_addr);\n \n       if (Pmode != ptr_mode)\n@@ -9982,9 +9977,8 @@ extract_sfunc_addr (rtx insn)\n \t  && GENERAL_REGISTER_P (true_regnum (XEXP (part, 0))))\n \treturn XEXP (part, 0);\n     }\n-  if (GET_CODE (XVECEXP (pattern, 0, 0)) == UNSPEC_VOLATILE)\n-    return XVECEXP (XVECEXP (pattern, 0, 0), 0, 1);\n-  abort ();\n+  gcc_assert (GET_CODE (XVECEXP (pattern, 0, 0)) == UNSPEC_VOLATILE);\n+  return XVECEXP (XVECEXP (pattern, 0, 0), 0, 1);\n }\n \n /* Verify that the register in use_sfunc_addr still agrees with the address\n@@ -10010,7 +10004,7 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n \tcontinue;\n       return rtx_equal_p (extract_sfunc_addr (insn), reg);\n     }\n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Returns 1 if OP is a MEM that can be source of a simple move operation.  */"}, {"sha": "f550d6bf224745cc9924cfd13618189ccbf9e9f2", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -3475,8 +3475,7 @@ extern int rtx_equal_function_value_matters;\n     if (((ENCODING) & 0xf) != DW_EH_PE_sdata4 \\\n \t&& ((ENCODING) & 0xf) != DW_EH_PE_sdata8) \\\n       { \\\n-\tif (GET_CODE (ADDR) != SYMBOL_REF) \\\n-\t  abort (); \\\n+\tgcc_assert (GET_CODE (ADDR) == SYMBOL_REF); \\\n \tSYMBOL_REF_FLAGS (ADDR) |= SYMBOL_FLAG_FUNCTION; \\\n \tif (0) goto DONE; \\\n       } \\"}, {"sha": "a10774a06fbb073c0b038ce71df75087ccbba648", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 127, "deletions": 121, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -889,7 +889,7 @@\n \t  FAIL;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\")\n@@ -1950,7 +1950,7 @@\n   [(const_int 0)]\n   \"\n {\n-  if (INTVAL (operands[2]) == (unsigned) 0xffffffff)\n+  if ((unsigned)INTVAL (operands[2]) == (unsigned) 0xffffffff)\n     emit_insn (gen_mshflo_l_di (operands[0], operands[1], CONST0_RTX (DImode)));\n   else\n     emit_insn (gen_mshfhi_l_di (operands[0], CONST0_RTX (DImode), operands[1]));\n@@ -2022,8 +2022,7 @@\n       offset = SUBREG_BYTE (operands[0]);\n       operands[0] = SUBREG_REG (operands[0]);\n     }\n-  if (GET_CODE (operands[0]) != REG)\n-    abort ();\n+  gcc_assert (GET_CODE (operands[0]) == REG);\n   if (! TARGET_LITTLE_ENDIAN)\n     offset += 8 - GET_MODE_SIZE (inmode);\n   operands[5] = gen_rtx_SUBREG (inmode, operands[0], offset);\n@@ -3812,14 +3811,20 @@\n \t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n     FAIL;\n \n-  if (GET_CODE (operands[0]) == REG)\n-    regno = REGNO (operands[0]);\n-  else if (GET_CODE (operands[0]) == SUBREG)\n-    regno = subreg_regno (operands[0]);\n-  else if (GET_CODE (operands[0]) == MEM)\n-    regno = -1;\n-  else\n-    abort ();\n+  switch (GET_CODE (operands[0]))\n+    {\n+    case REG:\n+      regno = REGNO (operands[0]);\n+      break;\n+    case SUBREG:\n+      regno = subreg_regno (operands[0]);\n+      break;\n+    case MEM:\n+      regno = -1;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   if (regno == -1\n       || ! refers_to_regno_p (regno, regno + 1, operands[1], 0))\n@@ -4186,11 +4191,12 @@\n     operands[2] = immed_double_const ((unsigned long) values[endian]\n \t\t\t\t      | ((HOST_WIDE_INT) values[1 - endian]\n \t\t\t\t\t << 32), 0, DImode);\n-  else if (HOST_BITS_PER_WIDE_INT == 32)\n-    operands[2] = immed_double_const (values[endian], values[1 - endian],\n-\t\t\t\t      DImode);\n   else\n-    abort ();\n+    {\n+      gcc_assert (HOST_BITS_PER_WIDE_INT == 32);\n+      operands[2] = immed_double_const (values[endian], values[1 - endian],\n+\t  \t\t\t        DImode);\n+    }\n \n   operands[3] = gen_rtx_REG (DImode, true_regnum (operands[0]));\n }\")\n@@ -4558,14 +4564,20 @@\n \t  && GET_CODE (XEXP (operands[1], 0)) == POST_INC))\n     FAIL;\n \n-  if (GET_CODE (operands[0]) == REG)\n-    regno = REGNO (operands[0]);\n-  else if (GET_CODE (operands[0]) == SUBREG)\n-    regno = subreg_regno (operands[0]);\n-  else if (GET_CODE (operands[0]) == MEM)\n-    regno = -1;\n-  else\n-    abort ();\n+  switch (GET_CODE (operands[0]))\n+    {\n+    case REG:\n+      regno = REGNO (operands[0]);\n+      break;\n+    case SUBREG:\n+      regno = subreg_regno (operands[0]);\n+      break;\n+    case MEM:\n+      regno = -1;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   if (regno == -1\n       || ! refers_to_regno_p (regno, regno + 1, operands[1], 0))\n@@ -5959,58 +5971,57 @@\n   \"TARGET_SHCOMPACT\"\n   \"\n {\n-  if (operands[2] && INTVAL (operands[2]))\n-    {\n-      rtx cookie_rtx = operands[2];\n-      long cookie = INTVAL (cookie_rtx);\n-      rtx func = XEXP (operands[0], 0);\n-      rtx r0, r1;\n+  rtx cookie_rtx;\n+  long cookie;\n+  rtx func;\n+  rtx r0, r1;\n \n-      if (flag_pic)\n-\t{\n-\t  if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n-\t    {\n-\t      rtx reg = gen_reg_rtx (Pmode);\n+  gcc_assert (operands[2] && INTVAL (operands[2]));\n+  cookie_rtx = operands[2];\n+  cookie = INTVAL (cookie_rtx);\n+  func = XEXP (operands[0], 0);\n \n-\t      emit_insn (gen_symGOTPLT2reg (reg, func));\n-\t      func = reg;\n-\t    }\n-\t  else\n-\t    func = legitimize_pic_address (func, Pmode, 0);\n+  if (flag_pic)\n+    {\n+      if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n+        {\n+\t  rtx reg = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_symGOTPLT2reg (reg, func));\n+\t  func = reg;\n \t}\n+      else\n+        func = legitimize_pic_address (func, Pmode, 0);\n+    }\n \n-      r0 = gen_rtx_REG (SImode, R0_REG);\n-      r1 = gen_rtx_REG (SImode, R1_REG);\n-\n-      /* Since such a call function may use all call-clobbered\n-\t registers, we force a mode switch earlier, so that we don't\n-\t run out of registers when adjusting fpscr for the call.  */\n-      emit_insn (gen_force_mode_for_call ());\n+  r0 = gen_rtx_REG (SImode, R0_REG);\n+  r1 = gen_rtx_REG (SImode, R1_REG);\n \n-      operands[0] = function_symbol (\\\"__GCC_shcompact_call_trampoline\\\");\n-      if (flag_pic)\n-\t{\n-\t  rtx reg = gen_reg_rtx (Pmode);\n+  /* Since such a call function may use all call-clobbered\n+     registers, we force a mode switch earlier, so that we don't\n+     run out of registers when adjusting fpscr for the call.  */\n+  emit_insn (gen_force_mode_for_call ());\n \n-\t  emit_insn (gen_symGOTPLT2reg (reg, operands[0]));\n-\t  operands[0] = reg;\n-\t}\n-      operands[0] = force_reg (SImode, operands[0]);\n+  operands[0] = function_symbol (\\\"__GCC_shcompact_call_trampoline\\\");\n+  if (flag_pic)\n+    {\n+      rtx reg = gen_reg_rtx (Pmode);\n \n-      emit_move_insn (r0, func);\n-      emit_move_insn (r1, cookie_rtx);\n+      emit_insn (gen_symGOTPLT2reg (reg, operands[0]));\n+      operands[0] = reg;\n+    }\n+  operands[0] = force_reg (SImode, operands[0]);\n \n-      if (cookie & CALL_COOKIE_RET_TRAMP (1))\n-\temit_call_insn (gen_call_pop_compact_rettramp\n-\t\t\t(operands[0], operands[1], operands[2], operands[3]));\n-      else\n-\temit_call_insn (gen_call_pop_compact\n-\t\t\t(operands[0], operands[1], operands[2], operands[3]));\n+  emit_move_insn (r0, func);\n+  emit_move_insn (r1, cookie_rtx);\n \n-      DONE;\n-    }\n+  if (cookie & CALL_COOKIE_RET_TRAMP (1))\n+    emit_call_insn (gen_call_pop_compact_rettramp\n+\t   \t     (operands[0], operands[1], operands[2], operands[3]));\n+  else\n+    emit_call_insn (gen_call_pop_compact\n+\t  \t     (operands[0], operands[1], operands[2], operands[3]));\n \n-  abort ();\n+  DONE;\n }\")\n \n (define_expand \"call_value\"\n@@ -6430,60 +6441,60 @@\n   \"TARGET_SHCOMPACT\"\n   \"\n {\n-  if (TARGET_SHCOMPACT && operands[3] && INTVAL (operands[3]))\n-    {\n-      rtx cookie_rtx = operands[3];\n-      long cookie = INTVAL (cookie_rtx);\n-      rtx func = XEXP (operands[1], 0);\n-      rtx r0, r1;\n+  rtx cookie_rtx;\n+  long cookie;\n+  rtx func;\n+  rtx r0, r1;\n \n-      if (flag_pic)\n-\t{\n-\t  if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n-\t    {\n-\t      rtx reg = gen_reg_rtx (Pmode);\n+  gcc_assert (TARGET_SHCOMPACT && operands[3] && INTVAL (operands[3]));\n+  cookie_rtx = operands[3];\n+  cookie = INTVAL (cookie_rtx);\n+  func = XEXP (operands[1], 0);\n \n-\t      emit_insn (gen_symGOTPLT2reg (reg, func));\n-\t      func = reg;\n-\t    }\n-\t  else\n-\t    func = legitimize_pic_address (func, Pmode, 0);\n-\t}\n+  if (flag_pic)\n+    {\n+      if (GET_CODE (func) == SYMBOL_REF && ! SYMBOL_REF_LOCAL_P (func))\n+        {\n+          rtx reg = gen_reg_rtx (Pmode);\n \n-      r0 = gen_rtx_REG (SImode, R0_REG);\n-      r1 = gen_rtx_REG (SImode, R1_REG);\n+\t  emit_insn (gen_symGOTPLT2reg (reg, func));\n+          func = reg;\n+        }\n+      else\n+        func = legitimize_pic_address (func, Pmode, 0);\n+    }\n \n-      /* Since such a call function may use all call-clobbered\n-\t registers, we force a mode switch earlier, so that we don't\n-\t run out of registers when adjusting fpscr for the call.  */\n-      emit_insn (gen_force_mode_for_call ());\n+  r0 = gen_rtx_REG (SImode, R0_REG);\n+  r1 = gen_rtx_REG (SImode, R1_REG);\n \n-      operands[1] = function_symbol (\\\"__GCC_shcompact_call_trampoline\\\");\n-      if (flag_pic)\n-\t{\n-\t  rtx reg = gen_reg_rtx (Pmode);\n+  /* Since such a call function may use all call-clobbered\n+     registers, we force a mode switch earlier, so that we don't\n+     run out of registers when adjusting fpscr for the call.  */\n+  emit_insn (gen_force_mode_for_call ());\n \n-\t  emit_insn (gen_symGOTPLT2reg (reg, operands[1]));\n-\t  operands[1] = reg;\n-\t}\n-      operands[1] = force_reg (SImode, operands[1]);\n+  operands[1] = function_symbol (\\\"__GCC_shcompact_call_trampoline\\\");\n+  if (flag_pic)\n+    {\n+      rtx reg = gen_reg_rtx (Pmode);\n \n-      emit_move_insn (r0, func);\n-      emit_move_insn (r1, cookie_rtx);\n+      emit_insn (gen_symGOTPLT2reg (reg, operands[1]));\n+      operands[1] = reg;\n+    }\n+  operands[1] = force_reg (SImode, operands[1]);\n \n-      if (cookie & CALL_COOKIE_RET_TRAMP (1))\n-\temit_call_insn (gen_call_value_pop_compact_rettramp\n+  emit_move_insn (r0, func);\n+  emit_move_insn (r1, cookie_rtx);\n+\n+  if (cookie & CALL_COOKIE_RET_TRAMP (1))\n+    emit_call_insn (gen_call_value_pop_compact_rettramp\n \t\t\t(operands[0], operands[1], operands[2],\n \t\t\t operands[3], operands[4]));\n-      else\n-\temit_call_insn (gen_call_value_pop_compact\n+  else\n+    emit_call_insn (gen_call_value_pop_compact\n \t\t\t(operands[0], operands[1], operands[2],\n \t\t\t operands[3], operands[4]));\n \n-      DONE;\n-    }\n-\n-  abort ();\n+  DONE;\n }\")\n \n (define_expand \"sibcall_epilogue\"\n@@ -7145,8 +7156,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n {\n   rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n \n-  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n-    abort ();\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n   switch (GET_MODE (diff_vec))\n     {\n@@ -7159,7 +7169,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \treturn \\\"mov.b\t@(r0,%1),%0\\;extu.b\t%0,%0\\\";\n       return \\\"mov.b\t@(r0,%1),%0\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"length\" \"4\")])\n@@ -7177,8 +7187,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n   const char *load;\n \n-  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n-    abort ();\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n   switch (GET_MODE (diff_vec))\n     {\n@@ -7195,7 +7204,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \tload = \\\"mov.b\t@(r0,%1),%0\\\";\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   output_asm_insn (\\\"add\\tr0,%1\\;mova\\t%O3,r0\\\\n\\\", operands);\n   return load;\n@@ -7212,8 +7221,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n {\n   rtx diff_vec = PATTERN (next_real_insn (operands[2]));\n \n-  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n-    abort ();\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n   switch (GET_MODE (diff_vec))\n     {\n@@ -7226,7 +7234,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \treturn \\\"\\\";\n       return \\\"add\t%1, r63, %0\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"type\" \"arith_media\")])\n@@ -7241,8 +7249,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n {\n   rtx diff_vec = PATTERN (next_real_insn (operands[3]));\n \n-  if (GET_CODE (diff_vec) != ADDR_DIFF_VEC)\n-    abort ();\n+  gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n \n   switch (GET_MODE (diff_vec))\n     {\n@@ -7259,7 +7266,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \treturn \\\"ldx.ub\t%1, %2, %0\\\";\n       return \\\"ldx.b\t%1, %2, %0\\\";\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"type\" \"load_media\")])\n@@ -7348,8 +7355,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n     {\n       rtx r18 = gen_rtx_REG (DImode, PR_MEDIA_REG);\n \n-      if (! call_really_used_regs[TR0_REG] || fixed_regs[TR0_REG])\n-\tabort ();\n+      gcc_assert (call_really_used_regs[TR0_REG] && !fixed_regs[TR0_REG]);\n       tr_regno = TR0_REG;\n       tr = gen_rtx_REG (DImode, tr_regno);\n       emit_move_insn (tr, r18);"}, {"sha": "b3e8287a66b9fe0d6b5e502ddb3ac8c8957c2e7b", "filename": "gcc/config/sh/symbian.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsymbian.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b9e7c92c7deea00449d6ef581275f842b299fc/gcc%2Fconfig%2Fsh%2Fsymbian.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian.c?ref=f5b9e7c92c7deea00449d6ef581275f842b299fc", "patch": "@@ -216,14 +216,10 @@ sh_symbian_mark_dllexport (tree decl)\n   tree idp;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-\n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n \n   if (sh_symbian_dllimport_name_p (oldname))\n     {\n@@ -265,14 +261,10 @@ sh_symbian_mark_dllimport (tree decl)\n   rtx newrtl;\n \n   rtlname = XEXP (DECL_RTL (decl), 0);\n-\n-  if (GET_CODE (rtlname) == SYMBOL_REF)\n-    oldname = XSTR (rtlname, 0);\n-  else if (GET_CODE (rtlname) == MEM\n-\t   && GET_CODE (XEXP (rtlname, 0)) == SYMBOL_REF)\n-    oldname = XSTR (XEXP (rtlname, 0), 0);\n-  else\n-    abort ();\n+  if (GET_CODE (rtlname) == MEM)\n+    rtlname = XEXP (rtlname, 0);\n+  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n+  oldname = XSTR (rtlname, 0);\n \n   if (sh_symbian_dllexport_name_p (oldname))\n     {"}]}