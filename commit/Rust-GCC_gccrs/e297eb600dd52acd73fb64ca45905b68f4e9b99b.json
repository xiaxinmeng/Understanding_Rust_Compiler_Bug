{"sha": "e297eb600dd52acd73fb64ca45905b68f4e9b99b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI5N2ViNjAwZGQ1MmFjZDczZmI2NGNhNDU5MDViNjhmNGU5Yjk5Yg==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2012-11-23T14:46:25Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2012-11-23T14:46:25Z"}, "message": "[libsanitizer] merge from upstream r168514\n\nFrom-SVN: r193756", "tree": {"sha": "a354102cd1c27b09eefe0b04f517d4ecac5bc566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a354102cd1c27b09eefe0b04f517d4ecac5bc566"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e297eb600dd52acd73fb64ca45905b68f4e9b99b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e297eb600dd52acd73fb64ca45905b68f4e9b99b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e297eb600dd52acd73fb64ca45905b68f4e9b99b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e297eb600dd52acd73fb64ca45905b68f4e9b99b/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ddf5c28ea6be09213739c94f9765019be476bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ddf5c28ea6be09213739c94f9765019be476bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ddf5c28ea6be09213739c94f9765019be476bb0"}], "stats": {"total": 1481, "additions": 932, "deletions": 549}, "files": [{"sha": "74a120d1c0d1a0bc0b1b7cdbfbdedbcee87da907", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -1,3 +1,7 @@\n+2012-11-23  Kostya Serebryany  <kcc@google.com>\n+\n+\t* c-c++-common/asan/memcmp-1.c: Update to match the new libsanitizer.\n+\n 2012-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr40.ad[sb]: New test."}, {"sha": "a23ff236c0d19a4bf1ed2b2dfcdd3aaba42aa233", "filename": "gcc/testsuite/c-c++-common/asan/memcmp-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmemcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmemcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fmemcmp-1.c?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -13,6 +13,6 @@ main (int argc, char **argv)\n   return res;\n }\n \n-/* { dg-output \"ERROR: AddressSanitizer stack-buffer-overflow.*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"ERROR: AddressSanitizer: stack-buffer-overflow.*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ (in _*(interceptor_|)memcmp |\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #1 0x\\[0-9a-f\\]+ (in _*main|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "0c7e4b753f4cf2c69812ed1ce9ce24624b2e1875", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -1,6 +1,13 @@\n 2012-11-23  Kostya Serebryany  <kcc@google.com>\n         \n-\t* merge.sh: a script that will help merges from upstream.\n+\t* merge.sh: Support tsan, support added/removed files.\n+\t* tsan/Makefile.am: Remove tsan_printf.cc.\n+\t* tsan/Makefile.in: Regenerated.\n+\t* other files: Merge from upstream r168514.\n+\n+2012-11-23  Kostya Serebryany  <kcc@google.com>\n+        \n+\t* merge.sh: New file.\n \n 2012-11-23  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "05b4cf0d9b58744efa49d8f90adb8f0da6578f88", "filename": "libsanitizer/MERGE", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -0,0 +1,4 @@\n+168514\n+\n+The first line of this file holds the svn revision number of the\n+last merge done from the master library sources."}, {"sha": "63ff607f8589c14b3a3c4aff8ab4ea34d4a377c8", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -56,7 +56,7 @@ static const uptr kMallocSizeClassStepLog = 26;\n static const uptr kMallocSizeClassStep = 1UL << kMallocSizeClassStepLog;\n \n static const uptr kMaxAllowedMallocSize =\n-    (__WORDSIZE == 32) ? 3UL << 30 : 8UL << 30;\n+    (SANITIZER_WORDSIZE == 32) ? 3UL << 30 : 8UL << 30;\n \n static inline bool IsAligned(uptr a, uptr alignment) {\n   return (a & (alignment - 1)) == 0;\n@@ -83,7 +83,7 @@ static inline uptr RoundUpToPowerOfTwo(uptr size) {\n \n   unsigned long up;  // NOLINT\n #if !defined(_WIN32) || defined(__clang__)\n-  up = __WORDSIZE - 1 - __builtin_clzl(size);\n+  up = SANITIZER_WORDSIZE - 1 - __builtin_clzl(size);\n #elif defined(_WIN64)\n   _BitScanReverse64(&up, size);\n #else"}, {"sha": "62d1994130fc889dd649bb5f91b590c52086257e", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -49,6 +49,12 @@ using __sanitizer::uptr;\n # define ASAN_INTERCEPT_STRNLEN 0\n #endif\n \n+#if defined(__linux__) && !defined(ANDROID)\n+# define ASAN_INTERCEPT_SWAPCONTEXT 1\n+#else\n+# define ASAN_INTERCEPT_SWAPCONTEXT 0\n+#endif\n+\n #if !defined(ANDROID) && !defined(_WIN32)\n # define ASAN_INTERCEPT_SIGNAL_AND_SIGACTION 1\n #else"}, {"sha": "5b544c87fcb85adcae8f5ecfa31c14498545ff10", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -134,6 +134,28 @@ DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n     struct sigaction *oldact);\n #endif  // ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n \n+#if ASAN_INTERCEPT_SWAPCONTEXT\n+INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n+            struct ucontext_t *ucp) {\n+  static bool reported_warning = false;\n+  if (!reported_warning) {\n+    Report(\"WARNING: ASan doesn't fully support makecontext/swapcontext \"\n+           \"functions and may produce false positives in some cases!\\n\");\n+    reported_warning = true;\n+  }\n+  // Clear shadow memory for new context (it may share stack\n+  // with current context).\n+  ClearShadowMemoryForContext(ucp);\n+  int res = REAL(swapcontext)(oucp, ucp);\n+  // swapcontext technically does not return, but program may swap context to\n+  // \"oucp\" later, that would look as if swapcontext() returned 0.\n+  // We need to clear shadow for ucp once again, as it may be in arbitrary\n+  // state.\n+  ClearShadowMemoryForContext(ucp);\n+  return res;\n+}\n+#endif\n+\n INTERCEPTOR(void, longjmp, void *env, int val) {\n   __asan_handle_no_return();\n   REAL(longjmp)(env, val);\n@@ -237,13 +259,17 @@ INTERCEPTOR(void*, memcpy, void *to, const void *from, uptr size) {\n     ASAN_WRITE_RANGE(from, size);\n     ASAN_READ_RANGE(to, size);\n   }\n+#if MAC_INTERPOSE_FUNCTIONS\n+  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n+  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n+  return internal_memcpy(to, from, size);\n+#else\n   return REAL(memcpy)(to, from, size);\n+#endif\n }\n \n INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n-#if MAC_INTERPOSE_FUNCTIONS\n-  if (!asan_inited) return REAL(memmove)(to, from, size);\n-#endif\n+  if (!asan_inited) return internal_memmove(to, from, size);\n   if (asan_init_is_running) {\n     return REAL(memmove)(to, from, size);\n   }\n@@ -252,7 +278,13 @@ INTERCEPTOR(void*, memmove, void *to, const void *from, uptr size) {\n     ASAN_WRITE_RANGE(from, size);\n     ASAN_READ_RANGE(to, size);\n   }\n+#if MAC_INTERPOSE_FUNCTIONS\n+  // Interposing of resolver functions is broken on Mac OS 10.7 and 10.8.\n+  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=116.\n+  return internal_memmove(to, from, size);\n+#else\n   return REAL(memmove)(to, from, size);\n+#endif\n }\n \n INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n@@ -370,6 +402,14 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n \n #if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n+#if MAC_INTERPOSE_FUNCTIONS\n+  // FIXME: because internal_strdup() uses InternalAlloc(), which currently\n+  // just calls malloc() on Mac, we can't use internal_strdup() with the\n+  // dynamic runtime. We can remove the call to REAL(strdup) once InternalAlloc\n+  // starts using mmap() instead.\n+  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=123.\n+  if (!asan_inited) return REAL(strdup)(s);\n+#endif\n   if (!asan_inited) return internal_strdup(s);\n   ENSURE_ASAN_INITED();\n   if (flags()->replace_str) {\n@@ -669,6 +709,9 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(sigaction);\n   ASAN_INTERCEPT_FUNC(signal);\n #endif\n+#if ASAN_INTERCEPT_SWAPCONTEXT\n+  ASAN_INTERCEPT_FUNC(swapcontext);\n+#endif\n #if ASAN_INTERCEPT__LONGJMP\n   ASAN_INTERCEPT_FUNC(_longjmp);\n #endif"}, {"sha": "3a70ca44fd511e0620284ad6e6e5a7699daef8c8", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -114,6 +114,7 @@ bool AsanInterceptsSignal(int signum);\n void SetAlternateSignalStack();\n void UnsetAlternateSignalStack();\n void InstallSignalHandlers();\n+void ClearShadowMemoryForContext(void *context);\n void AsanPlatformThreadInit();\n \n // Wrapper for TLS/TSD."}, {"sha": "7295216b85d1ac5a7d958b39a8424c4a580e21a2", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -66,6 +66,13 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.gregs[REG_EIP];\n   *bp = ucontext->uc_mcontext.gregs[REG_EBP];\n   *sp = ucontext->uc_mcontext.gregs[REG_ESP];\n+# elif defined(__powerpc__) || defined(__powerpc64__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.regs->nip;\n+  *sp = ucontext->uc_mcontext.regs->gpr[PT_R1];\n+  // The powerpc{,64}-linux ABIs do not specify r31 as the frame\n+  // pointer, but GCC always uses r31 when we need a frame pointer.\n+  *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n # elif defined(__sparc__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   uptr *stk_ptr;\n@@ -149,8 +156,10 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n   stack->trace[0] = pc;\n   if ((max_s) > 1) {\n     stack->max_size = max_s;\n-#ifdef __arm__\n+#if defined(__arm__) || defined(__powerpc__) || defined(__powerpc64__)\n     _Unwind_Backtrace(Unwind_Trace, stack);\n+    // Pop off the two ASAN functions from the backtrace.\n+    stack->PopStackFrames(2);\n #else\n     if (!asan_inited) return;\n     if (AsanThread *t = asanThreadRegistry().GetCurrent())\n@@ -159,6 +168,23 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n   }\n }\n \n+#if !ASAN_ANDROID\n+void ClearShadowMemoryForContext(void *context) {\n+  ucontext_t *ucp = (ucontext_t*)context;\n+  uptr sp = (uptr)ucp->uc_stack.ss_sp;\n+  uptr size = ucp->uc_stack.ss_size;\n+  // Align to page size.\n+  uptr bottom = sp & ~(kPageSize - 1);\n+  size += sp - bottom;\n+  size = RoundUpTo(size, kPageSize);\n+  PoisonShadow(bottom, size, 0);\n+}\n+#else\n+void ClearShadowMemoryForContext(void *context) {\n+  UNIMPLEMENTED();\n+}\n+#endif\n+\n }  // namespace __asan\n \n #endif  // __linux__"}, {"sha": "ae5edd9716582d3e6d3ed4340aa4d33031b77afe", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -40,15 +40,15 @@ namespace __asan {\n \n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n-# if __WORDSIZE == 64\n+# if SANITIZER_WORDSIZE == 64\n   *pc = ucontext->uc_mcontext->__ss.__rip;\n   *bp = ucontext->uc_mcontext->__ss.__rbp;\n   *sp = ucontext->uc_mcontext->__ss.__rsp;\n # else\n   *pc = ucontext->uc_mcontext->__ss.__eip;\n   *bp = ucontext->uc_mcontext->__ss.__ebp;\n   *sp = ucontext->uc_mcontext->__ss.__esp;\n-# endif  // __WORDSIZE\n+# endif  // SANITIZER_WORDSIZE\n }\n \n int GetMacosVersion() {\n@@ -66,6 +66,7 @@ int GetMacosVersion() {\n       switch (version[1]) {\n         case '0': return MACOS_VERSION_SNOW_LEOPARD;\n         case '1': return MACOS_VERSION_LION;\n+        case '2': return MACOS_VERSION_MOUNTAIN_LION;\n         default: return MACOS_VERSION_UNKNOWN;\n       }\n     }\n@@ -128,7 +129,14 @@ bool AsanInterceptsSignal(int signum) {\n }\n \n void AsanPlatformThreadInit() {\n-  ReplaceCFAllocator();\n+  // For the first program thread, we can't replace the allocator before\n+  // __CFInitialize() has been called. If it hasn't, we'll call\n+  // MaybeReplaceCFAllocator() later on this thread.\n+  // For other threads __CFInitialize() has been called before their creation.\n+  // See also asan_malloc_mac.cc.\n+  if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n+    MaybeReplaceCFAllocator();\n+  }\n }\n \n AsanLock::AsanLock(LinkerInitialized) {\n@@ -161,6 +169,10 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n   }\n }\n \n+void ClearShadowMemoryForContext(void *context) {\n+  UNIMPLEMENTED();\n+}\n+\n // The range of pages to be used for escape islands.\n // TODO(glider): instead of mapping a fixed range we must find a range of\n // unmapped pages in vmmap and take them.\n@@ -169,7 +181,7 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp) {\n // kHighMemBeg or kHighMemEnd.\n static void *island_allocator_pos = 0;\n \n-#if __WORDSIZE == 32\n+#if SANITIZER_WORDSIZE == 32\n # define kIslandEnd (0xffdf0000 - kPageSize)\n # define kIslandBeg (kIslandEnd - 256 * kPageSize)\n #else"}, {"sha": "2c162fb0c397f58c2ad1384d896dc8d71d4bb5f8", "filename": "libsanitizer/asan/asan_mac.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -38,7 +38,8 @@ enum {\n   MACOS_VERSION_UNKNOWN = 0,\n   MACOS_VERSION_LEOPARD,\n   MACOS_VERSION_SNOW_LEOPARD,\n-  MACOS_VERSION_LION\n+  MACOS_VERSION_LION,\n+  MACOS_VERSION_MOUNTAIN_LION\n };\n \n // Used by asan_malloc_mac.cc and asan_mac.cc\n@@ -47,7 +48,7 @@ extern \"C\" void __CFInitialize();\n namespace __asan {\n \n int GetMacosVersion();\n-void ReplaceCFAllocator();\n+void MaybeReplaceCFAllocator();\n \n }  // namespace __asan\n "}, {"sha": "3f281c9cc3bf9e0d45da39c31507305d7c91df3d", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -95,10 +95,6 @@ INTERCEPTOR(void, free, void *ptr) {\n   }\n }\n \n-namespace __asan {\n-  void ReplaceCFAllocator();\n-}\n-\n // We can't always replace the default CFAllocator with cf_asan right in\n // ReplaceSystemMalloc(), because it is sometimes called before\n // __CFInitialize(), when the default allocator is invalid and replacing it may\n@@ -116,7 +112,7 @@ INTERCEPTOR(void, __CFInitialize, void) {\n   CHECK(asan_inited);\n #endif\n   REAL(__CFInitialize)();\n-  if (!cf_asan && asan_inited) ReplaceCFAllocator();\n+  if (!cf_asan && asan_inited) MaybeReplaceCFAllocator();\n }\n \n namespace {\n@@ -291,12 +287,10 @@ size_t mi_good_size(malloc_zone_t *zone, size_t size) {\n \n boolean_t mi_check(malloc_zone_t *zone) {\n   UNIMPLEMENTED();\n-  return true;\n }\n \n void mi_print(malloc_zone_t *zone, boolean_t verbose) {\n   UNIMPLEMENTED();\n-  return;\n }\n \n void mi_log(malloc_zone_t *zone, void *address) {\n@@ -331,7 +325,7 @@ boolean_t mi_zone_locked(malloc_zone_t *zone) {\n extern int __CFRuntimeClassTableSize;\n \n namespace __asan {\n-void ReplaceCFAllocator() {\n+void MaybeReplaceCFAllocator() {\n   static CFAllocatorContext asan_context = {\n         /*version*/ 0, /*info*/ &asan_zone,\n         /*retain*/ 0, /*release*/ 0,\n@@ -342,7 +336,7 @@ void ReplaceCFAllocator() {\n         /*preferredSize*/ 0 };\n   if (!cf_asan)\n     cf_asan = CFAllocatorCreate(kCFAllocatorUseContext, &asan_context);\n-  if (CFAllocatorGetDefault() != cf_asan)\n+  if (flags()->replace_cfallocator && CFAllocatorGetDefault() != cf_asan)\n     CFAllocatorSetDefault(cf_asan);\n }\n \n@@ -410,16 +404,14 @@ void ReplaceSystemMalloc() {\n   // Make sure the default allocator was replaced.\n   CHECK(malloc_default_zone() == &asan_zone);\n \n-  if (flags()->replace_cfallocator) {\n-    // If __CFInitialize() hasn't been called yet, cf_asan will be created and\n-    // installed as the default allocator after __CFInitialize() finishes (see\n-    // the interceptor for __CFInitialize() above). Otherwise install cf_asan\n-    // right now. On both Snow Leopard and Lion __CFInitialize() calls\n-    // __CFAllocatorInitialize(), which initializes the _base._cfisa field of\n-    // the default allocators we check here.\n-    if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n-      ReplaceCFAllocator();\n-    }\n+  // If __CFInitialize() hasn't been called yet, cf_asan will be created and\n+  // installed as the default allocator after __CFInitialize() finishes (see\n+  // the interceptor for __CFInitialize() above). Otherwise install cf_asan\n+  // right now. On both Snow Leopard and Lion __CFInitialize() calls\n+  // __CFAllocatorInitialize(), which initializes the _base._cfisa field of\n+  // the default allocators we check here.\n+  if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n+    MaybeReplaceCFAllocator();\n   }\n }\n }  // namespace __asan"}, {"sha": "c93280fdd6c7f07035607e36a99c5b87987c82bc", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -28,10 +28,14 @@ extern __attribute__((visibility(\"default\"))) uptr __asan_mapping_offset;\n #  define SHADOW_OFFSET (0)\n # else\n #  define SHADOW_SCALE (3)\n-#  if __WORDSIZE == 32\n+#  if SANITIZER_WORDSIZE == 32\n #   define SHADOW_OFFSET (1 << 29)\n #  else\n-#   define SHADOW_OFFSET (1ULL << 44)\n+#   if defined(__powerpc64__)\n+#    define SHADOW_OFFSET (1ULL << 41)\n+#   else\n+#    define SHADOW_OFFSET (1ULL << 44)\n+#   endif\n #  endif\n # endif\n #endif  // ASAN_FLEXIBLE_MAPPING_AND_OFFSET\n@@ -40,11 +44,15 @@ extern __attribute__((visibility(\"default\"))) uptr __asan_mapping_offset;\n #define MEM_TO_SHADOW(mem) (((mem) >> SHADOW_SCALE) | (SHADOW_OFFSET))\n #define SHADOW_TO_MEM(shadow) (((shadow) - SHADOW_OFFSET) << SHADOW_SCALE)\n \n-#if __WORDSIZE == 64\n+#if SANITIZER_WORDSIZE == 64\n+# if defined(__powerpc64__)\n+  static const uptr kHighMemEnd = 0x00000fffffffffffUL;\n+# else\n   static const uptr kHighMemEnd = 0x00007fffffffffffUL;\n-#else  // __WORDSIZE == 32\n+# endif\n+#else  // SANITIZER_WORDSIZE == 32\n   static const uptr kHighMemEnd = 0xffffffff;\n-#endif  // __WORDSIZE\n+#endif  // SANITIZER_WORDSIZE\n \n \n #define kLowMemBeg      0"}, {"sha": "8132e58b6e2e7b94ec26f1c311920f54b44aa718", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -15,7 +15,6 @@\n #include \"asan_stack.h\"\n \n #include <stddef.h>\n-#include <new>\n \n namespace __asan {\n // This function is a no-op. We need it to make sure that object file\n@@ -26,29 +25,40 @@ void ReplaceOperatorsNewAndDelete() { }\n \n using namespace __asan;  // NOLINT\n \n+// On Android new() goes through malloc interceptors.\n+#if !ASAN_ANDROID\n+\n+// Fake std::nothrow_t to avoid including <new>.\n+namespace std {\n+struct nothrow_t {};\n+}  // namespace std\n+\n #define OPERATOR_NEW_BODY \\\n   GET_STACK_TRACE_HERE_FOR_MALLOC;\\\n   return asan_memalign(0, size, &stack);\n \n-#if ASAN_ANDROID\n+INTERCEPTOR_ATTRIBUTE\n void *operator new(size_t size) { OPERATOR_NEW_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n void *operator new[](size_t size) { OPERATOR_NEW_BODY; }\n-#else\n-void *operator new(size_t size) throw(std::bad_alloc) { OPERATOR_NEW_BODY; }\n-void *operator new[](size_t size) throw(std::bad_alloc) { OPERATOR_NEW_BODY; }\n-void *operator new(size_t size, std::nothrow_t const&) throw()\n-{ OPERATOR_NEW_BODY; }\n-void *operator new[](size_t size, std::nothrow_t const&) throw()\n-{ OPERATOR_NEW_BODY; }\n-#endif\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new(size_t size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void *operator new[](size_t size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n \n #define OPERATOR_DELETE_BODY \\\n   GET_STACK_TRACE_HERE_FOR_FREE(ptr);\\\n   asan_free(ptr, &stack);\n \n-void operator delete(void *ptr) throw() { OPERATOR_DELETE_BODY; }\n-void operator delete[](void *ptr) throw() { OPERATOR_DELETE_BODY; }\n-void operator delete(void *ptr, std::nothrow_t const&) throw()\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr) { OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr) { OPERATOR_DELETE_BODY; }\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete(void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY; }\n-void operator delete[](void *ptr, std::nothrow_t const&) throw()\n+INTERCEPTOR_ATTRIBUTE\n+void operator delete[](void *ptr, std::nothrow_t const&)\n { OPERATOR_DELETE_BODY; }\n+\n+#endif"}, {"sha": "c35b4ec14f795a925bb69cea5ae3a8bb47290e64", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -42,7 +42,7 @@ void AppendToErrorMessageBuffer(const char *buffer) {\n \n static void PrintBytes(const char *before, uptr *a) {\n   u8 *bytes = (u8*)a;\n-  uptr byte_num = (__WORDSIZE) / 8;\n+  uptr byte_num = (SANITIZER_WORDSIZE) / 8;\n   Printf(\"%s%p:\", before, (void*)a);\n   for (uptr i = 0; i < byte_num; i++) {\n     Printf(\" %x%x\", bytes[i] >> 4, bytes[i] & 15);\n@@ -178,7 +178,7 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n     Printf(\"    [%zu, %zu) '%s'\\n\", beg, beg + size, buf);\n   }\n   Printf(\"HINT: this may be a false positive if your program uses \"\n-             \"some custom stack unwind mechanism\\n\"\n+             \"some custom stack unwind mechanism or swapcontext\\n\"\n              \"      (longjmp and C++ exceptions *are* supported)\\n\");\n   DescribeThread(t->summary());\n   return true;\n@@ -287,7 +287,9 @@ class ScopedInErrorReport {\n         // an error report will finish doing it.\n         SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n       }\n-      Die();\n+      // If we're still not dead for some reason, use raw Exit() instead of\n+      // Die() to bypass any additional checks.\n+      Exit(flags()->exitcode);\n     }\n     __asan_on_error();\n     reporting_thread_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n@@ -320,7 +322,7 @@ class ScopedInErrorReport {\n \n void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer crashed on unknown address %p\"\n+  Report(\"ERROR: AddressSanitizer: SEGV on unknown address %p\"\n              \" (pc %p sp %p bp %p T%d)\\n\",\n              (void*)addr, (void*)pc, (void*)sp, (void*)bp,\n              asanThreadRegistry().GetCurrentTidOrInvalid());\n@@ -331,22 +333,22 @@ void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n \n void ReportDoubleFree(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer attempting double-free on %p:\\n\", addr);\n+  Report(\"ERROR: AddressSanitizer: attempting double-free on %p:\\n\", addr);\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n }\n \n void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer attempting free on address \"\n+  Report(\"ERROR: AddressSanitizer: attempting free on address \"\n              \"which was not malloc()-ed: %p\\n\", addr);\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n }\n \n void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer attempting to call \"\n+  Report(\"ERROR: AddressSanitizer: attempting to call \"\n              \"malloc_usable_size() for pointer which is \"\n              \"not owned: %p\\n\", addr);\n   PrintStack(stack);\n@@ -355,7 +357,7 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n \n void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer attempting to call \"\n+  Report(\"ERROR: AddressSanitizer: attempting to call \"\n              \"__asan_get_allocated_size() for pointer which is \"\n              \"not owned: %p\\n\", addr);\n   PrintStack(stack);\n@@ -366,7 +368,7 @@ void ReportStringFunctionMemoryRangesOverlap(\n     const char *function, const char *offset1, uptr length1,\n     const char *offset2, uptr length2, StackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer %s-param-overlap: \"\n+  Report(\"ERROR: AddressSanitizer: %s-param-overlap: \"\n              \"memory ranges [%p,%p) and [%p, %p) overlap\\n\", \\\n              function, offset1, offset1 + length1, offset2, offset2 + length2);\n   PrintStack(stack);\n@@ -459,7 +461,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n     }\n   }\n \n-  Report(\"ERROR: AddressSanitizer %s on address \"\n+  Report(\"ERROR: AddressSanitizer: %s on address \"\n              \"%p at pc 0x%zx bp 0x%zx sp 0x%zx\\n\",\n              bug_descr, (void*)addr, pc, bp, sp);\n "}, {"sha": "7731c17a35118e1a8e9f0ef2ac6ec3d138305228", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -132,7 +132,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->unmap_shadow_on_exit = false;\n   f->abort_on_error = false;\n   f->atexit = false;\n-  f->disable_core = (__WORDSIZE == 64);\n+  f->disable_core = (SANITIZER_WORDSIZE == 64);\n   f->strip_path_prefix = \"\";\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;"}, {"sha": "ecdf5ffad09d6d119527e6f1aace4f771cac4038", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -54,7 +54,8 @@ void AsanStats::Print() {\n static AsanLock print_lock(LINKER_INITIALIZED);\n \n static void PrintAccumulatedStats() {\n-  AsanStats stats = asanThreadRegistry().GetAccumulatedStats();\n+  AsanStats stats;\n+  asanThreadRegistry().GetAccumulatedStats(&stats);\n   // Use lock to keep reports from mixing up.\n   ScopedLock lock(&print_lock);\n   stats.Print();"}, {"sha": "4ec98e5ed22717701855e9ddcc84b07b5ccb2b8d", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -116,25 +116,25 @@ void AsanThread::ClearShadowForThreadStack() {\n \n const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset) {\n   uptr bottom = 0;\n-  bool is_fake_stack = false;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();\n   } else {\n     bottom = fake_stack().AddrIsInFakeStack(addr);\n     CHECK(bottom);\n-    is_fake_stack = true;\n+    *offset = addr - bottom;\n+    return  (const char *)((uptr*)bottom)[1];\n   }\n-  uptr aligned_addr = addr & ~(__WORDSIZE/8 - 1);  // align addr.\n+  uptr aligned_addr = addr & ~(SANITIZER_WORDSIZE/8 - 1);  // align addr.\n   u8 *shadow_ptr = (u8*)MemToShadow(aligned_addr);\n   u8 *shadow_bottom = (u8*)MemToShadow(bottom);\n \n   while (shadow_ptr >= shadow_bottom &&\n-      *shadow_ptr != kAsanStackLeftRedzoneMagic) {\n+         *shadow_ptr != kAsanStackLeftRedzoneMagic) {\n     shadow_ptr--;\n   }\n \n   while (shadow_ptr >= shadow_bottom &&\n-      *shadow_ptr == kAsanStackLeftRedzoneMagic) {\n+         *shadow_ptr == kAsanStackLeftRedzoneMagic) {\n     shadow_ptr--;\n   }\n \n@@ -144,8 +144,7 @@ const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset) {\n   }\n \n   uptr* ptr = (uptr*)SHADOW_TO_MEM((uptr)(shadow_ptr + 1));\n-  CHECK((ptr[0] == kCurrentStackFrameMagic) ||\n-      (is_fake_stack && ptr[0] == kRetiredStackFrameMagic));\n+  CHECK(ptr[0] == kCurrentStackFrameMagic);\n   *offset = addr - (uptr)ptr;\n   return (const char*)ptr[1];\n }"}, {"sha": "9858cce22b076e60eefe8774e6187217cbc087b0", "filename": "libsanitizer/asan/asan_thread_registry.cc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -102,16 +102,20 @@ AsanStats &AsanThreadRegistry::GetCurrentThreadStats() {\n   return (t) ? t->stats() : main_thread_.stats();\n }\n \n-AsanStats AsanThreadRegistry::GetAccumulatedStats() {\n+void AsanThreadRegistry::GetAccumulatedStats(AsanStats *stats) {\n   ScopedLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n-  return accumulated_stats_;\n+  internal_memcpy(stats, &accumulated_stats_, sizeof(accumulated_stats_));\n }\n \n uptr AsanThreadRegistry::GetCurrentAllocatedBytes() {\n   ScopedLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n-  return accumulated_stats_.malloced - accumulated_stats_.freed;\n+  uptr malloced = accumulated_stats_.malloced;\n+  uptr freed = accumulated_stats_.freed;\n+  // Return sane value if malloced < freed due to racy\n+  // way we update accumulated stats.\n+  return (malloced > freed) ? malloced - freed : 1;\n }\n \n uptr AsanThreadRegistry::GetHeapSize() {\n@@ -123,11 +127,14 @@ uptr AsanThreadRegistry::GetHeapSize() {\n uptr AsanThreadRegistry::GetFreeBytes() {\n   ScopedLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n-  return accumulated_stats_.mmaped\n-         - accumulated_stats_.malloced\n-         - accumulated_stats_.malloced_redzones\n-         + accumulated_stats_.really_freed\n-         + accumulated_stats_.really_freed_redzones;\n+  uptr total_free = accumulated_stats_.mmaped\n+                  + accumulated_stats_.really_freed\n+                  + accumulated_stats_.really_freed_redzones;\n+  uptr total_used = accumulated_stats_.malloced\n+                  + accumulated_stats_.malloced_redzones;\n+  // Return sane value if total_free < total_used due to racy\n+  // way we update accumulated stats.\n+  return (total_free > total_used) ? total_free - total_used : 1;\n }\n \n // Return several stats counters with a single call to"}, {"sha": "bb6b2678faabaa49443d1bab51bee27e80363929", "filename": "libsanitizer/asan/asan_thread_registry.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -45,9 +45,9 @@ class AsanThreadRegistry {\n   // Returns stats for GetCurrent(), or stats for\n   // T0 if GetCurrent() returns 0.\n   AsanStats &GetCurrentThreadStats();\n-  // Flushes all thread-local stats to accumulated stats, and returns\n+  // Flushes all thread-local stats to accumulated stats, and makes\n   // a copy of accumulated stats.\n-  AsanStats GetAccumulatedStats();\n+  void GetAccumulatedStats(AsanStats *stats);\n   uptr GetCurrentAllocatedBytes();\n   uptr GetHeapSize();\n   uptr GetFreeBytes();"}, {"sha": "8b7f9ef0e38340d73cb1734d22537e3bb7b0acda", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -137,6 +137,10 @@ void AsanPlatformThreadInit() {\n   // Nothing here for now.\n }\n \n+void ClearShadowMemoryForContext(void *context) {\n+  UNIMPLEMENTED();\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1"}, {"sha": "f6e814df6f5f352a026d3988bd34e5541c73de1f", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -68,6 +68,11 @@ extern \"C\" {\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n   void __sanitizer_set_report_path(const char *path)\n       SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+  // Tell the tools to write their reports to given file descriptor instead of\n+  // stderr.\n+  void __sanitizer_set_report_fd(int fd)\n+      SANITIZER_INTERFACE_ATTRIBUTE;\n }  // extern \"C\"\n \n #endif  // SANITIZER_COMMON_INTERFACE_DEFS_H"}, {"sha": "297af56e790dee2b1cc087452bbc153bedfe5dfd", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -44,10 +44,11 @@ merge() {\n       cp -v $upstream_path/$f $local_path\n     elif [ -f $upstream_path/$f ]; then\n       echo \"FOUND IN UPSTREAM :\" $f\n-      echo \"UNSUPPORTED YET\" && exit 1\n+      cp -v $upstream_path/$f $local_path\n+      svn add $local_path/$f\n     elif [ -f $local_path/$f ]; then\n       echo \"FOUND IN LOCAL    :\" $f\n-      echo \"UNSUPPORTED YET\" && exit 1\n+      svn remove $local_path/$f\n     fi\n   done\n \n@@ -65,6 +66,7 @@ CUR_REV=$(get_current_rev)\n echo Current upstream revision: $CUR_REV\n merge include/sanitizer include/sanitizer\n merge lib/asan asan\n+merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception\n "}, {"sha": "7614aba52ac9122a205fdcb276835d9165d63215", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator64.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator64.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -16,7 +16,7 @@\n #define SANITIZER_ALLOCATOR_H\n \n #include \"sanitizer_internal_defs.h\"\n-#if __WORDSIZE != 64\n+#if SANITIZER_WORDSIZE != 64\n # error \"sanitizer_allocator64.h can only be used on 64-bit platforms\"\n #endif\n \n@@ -275,7 +275,12 @@ class SizeClassAllocator64 {\n     } while (idx < end_idx);\n     region->allocated_user += idx - beg_idx;\n     region->allocated_meta += i * kMetadataSize;\n-    CHECK_LT(region->allocated_user + region->allocated_meta, kRegionSize);\n+    if (region->allocated_user + region->allocated_meta > kRegionSize) {\n+      Printf(\"Out of memory. Dying.\\n\");\n+      Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n+          kRegionSize / 1024 / 1024, size);\n+      Die();\n+    }\n   }\n \n   void *AllocateBySizeClass(uptr class_id) {"}, {"sha": "fda67a542d50aea3fc813158450891e11e6ff9aa", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -14,7 +14,9 @@\n \n namespace __sanitizer {\n \n-static fd_t report_fd = 2;  // By default, dump to stderr.\n+// By default, dump to stderr. If report_fd is kInvalidFd, try to obtain file\n+// descriptor by opening file in report_path.\n+static fd_t report_fd = kStderrFd;\n static char report_path[4096];  // Set via __sanitizer_set_report_path.\n \n static void (*DieCallback)(void);\n@@ -44,18 +46,27 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n   Die();\n }\n \n+static void MaybeOpenReportFile() {\n+  if (report_fd != kInvalidFd)\n+    return;\n+  fd_t fd = internal_open(report_path, true);\n+  if (fd == kInvalidFd) {\n+    report_fd = kStderrFd;\n+    Report(\"ERROR: Can't open file: %s\\n\", report_path);\n+    Die();\n+  }\n+  report_fd = fd;\n+}\n+\n+bool PrintsToTty() {\n+  MaybeOpenReportFile();\n+  return internal_isatty(report_fd);\n+}\n+\n void RawWrite(const char *buffer) {\n   static const char *kRawWriteError = \"RawWrite can't output requested buffer!\";\n   uptr length = (uptr)internal_strlen(buffer);\n-  if (report_fd == kInvalidFd) {\n-    fd_t fd = internal_open(report_path, true);\n-    if (fd == kInvalidFd) {\n-      report_fd = 2;\n-      Report(\"ERROR: Can't open file: %s\\n\", report_path);\n-      Die();\n-    }\n-    report_fd = fd;\n-  }\n+  MaybeOpenReportFile();\n   if (length != internal_write(report_fd, buffer, length)) {\n     internal_write(report_fd, kRawWriteError, internal_strlen(kRawWriteError));\n     Die();\n@@ -136,16 +147,27 @@ void SortArray(uptr *array, uptr size) {\n \n }  // namespace __sanitizer\n \n+using namespace __sanitizer;  // NOLINT\n+\n+extern \"C\" {\n void __sanitizer_set_report_path(const char *path) {\n   if (!path) return;\n   uptr len = internal_strlen(path);\n-  if (len > sizeof(__sanitizer::report_path) - 100) {\n+  if (len > sizeof(report_path) - 100) {\n     Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n            path[0], path[1], path[2], path[3],\n            path[4], path[5], path[6], path[7]);\n     Die();\n   }\n-  internal_snprintf(__sanitizer::report_path,\n-                    sizeof(__sanitizer::report_path), \"%s.%d\", path, GetPid());\n-  __sanitizer::report_fd = kInvalidFd;\n+  internal_snprintf(report_path, sizeof(report_path), \"%s.%d\", path, GetPid());\n+  report_fd = kInvalidFd;\n+}\n+\n+void __sanitizer_set_report_fd(int fd) {\n+  if (report_fd != kStdoutFd &&\n+      report_fd != kStderrFd &&\n+      report_fd != kInvalidFd)\n+    internal_close(report_fd);\n+  report_fd = fd;\n }\n+}  // extern \"C\""}, {"sha": "e565b93af29f76ec3fee3012d98de8558945e894", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -19,14 +19,24 @@\n namespace __sanitizer {\n \n // Constants.\n-const uptr kWordSize = __WORDSIZE / 8;\n+const uptr kWordSize = SANITIZER_WORDSIZE / 8;\n const uptr kWordSizeInBits = 8 * kWordSize;\n-const uptr kPageSizeBits = 12;\n-const uptr kPageSize = 1UL << kPageSizeBits;\n+#if defined(__powerpc__) || defined(__powerpc64__)\n+// Current PPC64 kernels use 64K pages sizes, but they can be\n+// configured with 4K or even other sizes.\n+// We may want to use getpagesize() or sysconf(_SC_PAGESIZE) here rather than\n+// hardcoding the values, but today these values need to be compile-time\n+// constants.\n+const uptr kPageSize = 1UL << 16;\n+const uptr kCacheLineSize = 128;\n+const uptr kMmapGranularity = kPageSize;\n+#elif !defined(_WIN32)\n+const uptr kPageSize = 1UL << 12;\n const uptr kCacheLineSize = 64;\n-#ifndef _WIN32\n const uptr kMmapGranularity = kPageSize;\n #else\n+const uptr kPageSize = 1UL << 12;\n+const uptr kCacheLineSize = 64;\n const uptr kMmapGranularity = 1UL << 16;\n #endif\n \n@@ -96,6 +106,7 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n \n // IO\n void RawWrite(const char *buffer);\n+bool PrintsToTty();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n@@ -114,6 +125,7 @@ void *MapFileToMemory(const char *file_name, uptr *buff_size);\n // OS\n void DisableCoreDumper();\n void DumpProcessMap();\n+bool FileExists(const char *filename);\n const char *GetEnv(const char *name);\n const char *GetPwd();\n void ReExec();\n@@ -170,7 +182,7 @@ INLINE int ToLower(int c) {\n   return (c >= 'A' && c <= 'Z') ? (c + 'a' - 'A') : c;\n }\n \n-#if __WORDSIZE == 64\n+#if SANITIZER_WORDSIZE == 64\n # define FIRST_32_SECOND_64(a, b) (b)\n #else\n # define FIRST_32_SECOND_64(a, b) (a)"}, {"sha": "a6795c6720b3ed3e811b2ed0dd45d32d73f8df10", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -22,8 +22,7 @@ using namespace __sanitizer;  // NOLINT\n #define WEAK SANITIZER_WEAK_ATTRIBUTE\n \n // Platform-specific defs.\n-#if defined(_WIN32)\n-typedef unsigned long    DWORD;  // NOLINT\n+#if defined(_MSC_VER)\n # define ALWAYS_INLINE __declspec(forceinline)\n // FIXME(timurrrr): do we need this on Windows?\n # define ALIAS(x)\n@@ -33,30 +32,27 @@ typedef unsigned long    DWORD;  // NOLINT\n # define NORETURN __declspec(noreturn)\n # define THREADLOCAL   __declspec(thread)\n # define NOTHROW\n-#else  // _WIN32\n+# define LIKELY(x) (x)\n+# define UNLIKELY(x) (x)\n+# define UNUSED\n+# define USED\n+#else  // _MSC_VER\n # define ALWAYS_INLINE __attribute__((always_inline))\n # define ALIAS(x) __attribute__((alias(x)))\n # define ALIGNED(x) __attribute__((aligned(x)))\n # define FORMAT(f, a)  __attribute__((format(printf, f, a)))\n # define NOINLINE __attribute__((noinline))\n # define NORETURN  __attribute__((noreturn))\n # define THREADLOCAL   __thread\n-# ifdef __cplusplus\n-#   define NOTHROW throw()\n-# else\n-#   define NOTHROW __attribute__((__nothrow__))\n-#endif\n-#endif  // _WIN32\n-\n-// We have no equivalent of these on Windows.\n-#ifndef _WIN32\n+# define NOTHROW throw()\n # define LIKELY(x)     __builtin_expect(!!(x), 1)\n # define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n # define UNUSED __attribute__((unused))\n # define USED __attribute__((used))\n-#endif\n+#endif  // _MSC_VER\n \n #if defined(_WIN32)\n+typedef unsigned long DWORD;  // NOLINT\n typedef DWORD thread_return_t;\n # define THREAD_CALLING_CONV __stdcall\n #else  // _WIN32\n@@ -65,15 +61,11 @@ typedef void* thread_return_t;\n #endif  // _WIN32\n typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n \n-// If __WORDSIZE was undefined by the platform, define it in terms of the\n-// compiler built-ins __LP64__ and _WIN64.\n-#ifndef __WORDSIZE\n-# if __LP64__ || defined(_WIN64)\n-#  define __WORDSIZE 64\n-# else\n-#  define __WORDSIZE 32\n-#  endif\n-#endif  // __WORDSIZE\n+#if __LP64__ || defined(_WIN64)\n+#  define SANITIZER_WORDSIZE 64\n+#else\n+#  define SANITIZER_WORDSIZE 32\n+#endif\n \n // NOTE: Functions below must be defined in each run-time.\n namespace __sanitizer {\n@@ -128,7 +120,12 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n #define DCHECK_GE(a, b)\n #endif\n \n-#define UNIMPLEMENTED() CHECK(\"unimplemented\" && 0)\n+#define UNREACHABLE(msg) do { \\\n+  CHECK(0 && msg); \\\n+  Die(); \\\n+} while (0)\n+\n+#define UNIMPLEMENTED() UNREACHABLE(\"unimplemented\")\n \n #define COMPILER_CHECK(pred) IMPL_COMPILER_ASSERT(pred, __LINE__)\n \n@@ -142,13 +139,13 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n // have stdint.h (like in Visual Studio 9).\n #undef __INT64_C\n #undef __UINT64_C\n-#if __WORDSIZE == 64\n+#if SANITIZER_WORDSIZE == 64\n # define __INT64_C(c)  c ## L\n # define __UINT64_C(c) c ## UL\n #else\n # define __INT64_C(c)  c ## LL\n # define __UINT64_C(c) c ## ULL\n-#endif  // __WORDSIZE == 64\n+#endif  // SANITIZER_WORDSIZE == 64\n #undef INT32_MIN\n #define INT32_MIN              (-2147483647-1)\n #undef INT32_MAX"}, {"sha": "4d43cd7d013396fe4b568f4440e49b9b0f089d20", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -42,6 +42,23 @@ void *internal_memcpy(void *dest, const void *src, uptr n) {\n   return dest;\n }\n \n+void *internal_memmove(void *dest, const void *src, uptr n) {\n+  char *d = (char*)dest;\n+  char *s = (char*)src;\n+  sptr i, signed_n = (sptr)n;\n+  CHECK_GE(signed_n, 0);\n+  if (d < s) {\n+    for (i = 0; i < signed_n; ++i)\n+      d[i] = s[i];\n+  } else {\n+    if (d > s && signed_n > 0)\n+      for (i = signed_n - 1; i >= 0 ; --i) {\n+        d[i] = s[i];\n+      }\n+  }\n+  return dest;\n+}\n+\n void *internal_memset(void* s, int c, uptr n) {\n   // The next line prevents Clang from making a call to memset() instead of the\n   // loop below."}, {"sha": "4aa4a279d402a5e017365199f2fd9a192dcee446", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -27,6 +27,7 @@ s64 internal_atoll(const char *nptr);\n void *internal_memchr(const void *s, int c, uptr n);\n int internal_memcmp(const void* s1, const void* s2, uptr n);\n void *internal_memcpy(void *dest, const void *src, uptr n);\n+void *internal_memmove(void *dest, const void *src, uptr n);\n // Should not be used in performance-critical places.\n void *internal_memset(void *s, int c, uptr n);\n char* internal_strchr(const char *s, int c);\n@@ -52,7 +53,11 @@ int internal_munmap(void *addr, uptr length);\n // I/O\n typedef int fd_t;\n const fd_t kInvalidFd = -1;\n+const fd_t kStdinFd = 0;\n+const fd_t kStdoutFd = 1;\n+const fd_t kStderrFd = 2;\n int internal_close(fd_t fd);\n+int internal_isatty(fd_t fd);\n fd_t internal_open(const char *filename, bool write);\n uptr internal_read(fd_t fd, void *buf, uptr count);\n uptr internal_write(fd_t fd, const void *buf, uptr count);"}, {"sha": "2145aa04113d574873fcb24aa9b1026ad100f9d6", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -30,9 +30,9 @@\n #include <errno.h>\n \n // Are we using 32-bit or 64-bit syscalls?\n-// x32 (which defines __x86_64__) has __WORDSIZE == 32\n+// x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n // but it still needs to use 64-bit syscalls.\n-#if defined(__x86_64__) || __WORDSIZE == 64\n+#if defined(__x86_64__) || SANITIZER_WORDSIZE == 64\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 1\n #else\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 0\n@@ -101,6 +101,20 @@ int internal_sched_yield() {\n }\n \n // ----------------- sanitizer_common.h\n+bool FileExists(const char *filename) {\n+#if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+  struct stat st;\n+  if (syscall(__NR_stat, filename, &st))\n+    return false;\n+#else\n+  struct stat64 st;\n+  if (syscall(__NR_stat64, filename, &st))\n+    return false;\n+#endif\n+  // Sanity check: filename is a regular file.\n+  return S_ISREG(st.st_mode);\n+}\n+\n uptr GetTid() {\n   return syscall(__NR_gettid);\n }"}, {"sha": "aa313baff9254e52e781fd280236ddb4d60c64dc", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -78,6 +78,14 @@ int internal_sched_yield() {\n }\n \n // ----------------- sanitizer_common.h\n+bool FileExists(const char *filename) {\n+  struct stat st;\n+  if (stat(filename, &st))\n+    return false;\n+  // Sanity check: filename is a regular file.\n+  return S_ISREG(st.st_mode);\n+}\n+\n uptr GetTid() {\n   return reinterpret_cast<uptr>(pthread_self());\n }"}, {"sha": "e32d65702df07de10c95d7a262d5a65c7a4f64f4", "filename": "libsanitizer/sanitizer_common/sanitizer_placement_new.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -17,7 +17,7 @@\n #include \"sanitizer_internal_defs.h\"\n \n namespace __sanitizer {\n-#if (__WORDSIZE == 64) || defined(__APPLE__)\n+#if (SANITIZER_WORDSIZE == 64) || defined(__APPLE__)\n typedef uptr operator_new_ptr_type;\n #else\n typedef u32 operator_new_ptr_type;"}, {"sha": "bd9270ecaa42a8d6bf03028fd55d6526ab23ab9c", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -72,10 +72,15 @@ void UnmapOrDie(void *addr, uptr size) {\n }\n \n void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n-  return internal_mmap((void*)fixed_addr, size,\n-                      PROT_READ | PROT_WRITE,\n-                      MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n-                      -1, 0);\n+  void *p = internal_mmap((void*)(fixed_addr & ~(kPageSize - 1)),\n+      RoundUpTo(size, kPageSize),\n+      PROT_READ | PROT_WRITE,\n+      MAP_PRIVATE | MAP_ANON | MAP_FIXED | MAP_NORESERVE,\n+      -1, 0);\n+  if (p == (void*)-1)\n+    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes at address %p (%d)\\n\",\n+           size, size, fixed_addr, errno);\n+  return p;\n }\n \n void *Mprotect(uptr fixed_addr, uptr size) {\n@@ -182,6 +187,10 @@ int Atexit(void (*function)(void)) {\n #endif\n }\n \n+int internal_isatty(fd_t fd) {\n+  return isatty(fd);\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // __linux__ || __APPLE_"}, {"sha": "5876fef04f3b57d74c5bc27e3ac614be3f27db54", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -43,7 +43,12 @@ static int AppendUnsigned(char **buff, const char *buff_end, u64 num,\n     num_buffer[pos++] = num % base;\n     num /= base;\n   } while (num > 0);\n-  while (pos < minimal_num_length) num_buffer[pos++] = 0;\n+  if (pos < minimal_num_length) {\n+    // Make sure compiler doesn't insert call to memset here.\n+    internal_memset(&num_buffer[pos], 0,\n+                    sizeof(num_buffer[0]) * (minimal_num_length - pos));\n+    pos = minimal_num_length;\n+  }\n   int result = 0;\n   while (pos-- > 0) {\n     uptr digit = num_buffer[pos];\n@@ -53,13 +58,16 @@ static int AppendUnsigned(char **buff, const char *buff_end, u64 num,\n   return result;\n }\n \n-static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num) {\n+static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,\n+                               u8 minimal_num_length) {\n   int result = 0;\n   if (num < 0) {\n     result += AppendChar(buff, buff_end, '-');\n     num = -num;\n+    if (minimal_num_length)\n+      --minimal_num_length;\n   }\n-  result += AppendUnsigned(buff, buff_end, (u64)num, 10, 0);\n+  result += AppendUnsigned(buff, buff_end, (u64)num, 10, minimal_num_length);\n   return result;\n }\n \n@@ -77,14 +85,14 @@ static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n   int result = 0;\n   result += AppendString(buff, buff_end, \"0x\");\n   result += AppendUnsigned(buff, buff_end, ptr_value, 16,\n-                           (__WORDSIZE == 64) ? 12 : 8);\n+                           (SANITIZER_WORDSIZE == 64) ? 12 : 8);\n   return result;\n }\n \n int VSNPrintf(char *buff, int buff_length,\n               const char *format, va_list args) {\n-  static const char *kPrintfFormatsHelp = \"Supported Printf formats: \"\n-                                          \"%%[z]{d,u,x}; %%p; %%s; %%c\\n\";\n+  static const char *kPrintfFormatsHelp =\n+    \"Supported Printf formats: %%(0[0-9]*)?(z|ll)?{d,u,x}; %%p; %%s; %%c\\n\";\n   RAW_CHECK(format);\n   RAW_CHECK(buff_length > 0);\n   const char *buff_end = &buff[buff_length - 1];\n@@ -96,42 +104,55 @@ int VSNPrintf(char *buff, int buff_length,\n       continue;\n     }\n     cur++;\n+    bool have_width = (*cur == '0');\n+    int width = 0;\n+    if (have_width) {\n+      while (*cur >= '0' && *cur <= '9') {\n+        have_width = true;\n+        width = width * 10 + *cur++ - '0';\n+      }\n+    }\n     bool have_z = (*cur == 'z');\n     cur += have_z;\n+    bool have_ll = !have_z && (cur[0] == 'l' && cur[1] == 'l');\n+    cur += have_ll * 2;\n     s64 dval;\n     u64 uval;\n+    bool have_flags = have_width | have_z | have_ll;\n     switch (*cur) {\n       case 'd': {\n-        dval = have_z ? va_arg(args, sptr)\n-                      : va_arg(args, int);\n-        result += AppendSignedDecimal(&buff, buff_end, dval);\n+        dval = have_ll ? va_arg(args, s64)\n+             : have_z ? va_arg(args, sptr)\n+             : va_arg(args, int);\n+        result += AppendSignedDecimal(&buff, buff_end, dval, width);\n         break;\n       }\n       case 'u':\n       case 'x': {\n-        uval = have_z ? va_arg(args, uptr)\n-                      : va_arg(args, unsigned);\n+        uval = have_ll ? va_arg(args, u64)\n+             : have_z ? va_arg(args, uptr)\n+             : va_arg(args, unsigned);\n         result += AppendUnsigned(&buff, buff_end, uval,\n-                                 (*cur == 'u') ? 10 : 16, 0);\n+                                 (*cur == 'u') ? 10 : 16, width);\n         break;\n       }\n       case 'p': {\n-        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n         result += AppendPointer(&buff, buff_end, va_arg(args, uptr));\n         break;\n       }\n       case 's': {\n-        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n         result += AppendString(&buff, buff_end, va_arg(args, char*));\n         break;\n       }\n       case 'c': {\n-        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n         result += AppendChar(&buff, buff_end, va_arg(args, int));\n         break;\n       }\n       case '%' : {\n-        RAW_CHECK_MSG(!have_z, kPrintfFormatsHelp);\n+        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);\n         result += AppendChar(&buff, buff_end, '%');\n         break;\n       }\n@@ -151,7 +172,7 @@ void SetPrintfAndReportCallback(void (*callback)(const char *)) {\n }\n \n void Printf(const char *format, ...) {\n-  const int kLen = 1024 * 4;\n+  const int kLen = 16 * 1024;\n   InternalScopedBuffer<char> buffer(kLen);\n   va_list args;\n   va_start(args, format);\n@@ -177,7 +198,7 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n \n // Like Printf, but prints the current PID before the output string.\n void Report(const char *format, ...) {\n-  const int kLen = 1024 * 4;\n+  const int kLen = 16 * 1024;\n   InternalScopedBuffer<char> buffer(kLen);\n   int needed_length = internal_snprintf(buffer.data(),\n                                         kLen, \"==%d== \", GetPid());"}, {"sha": "5541cfc0c630b32febbb69be11a783d084302df7", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -23,7 +23,6 @@ class MemoryMappingLayout {\n   bool GetObjectNameAndOffset(uptr addr, uptr *offset,\n                               char filename[], uptr filename_size) {\n     UNIMPLEMENTED();\n-    return false;\n   }\n };\n "}, {"sha": "037a7c3f9c00b500c0f6554315c53fd22558a10e", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -31,7 +31,12 @@ static uptr patch_pc(uptr pc) {\n   // Cancel Thumb bit.\n   pc = pc & (~1);\n #endif\n+#if defined(__powerpc__) || defined(__powerpc64__)\n+  // PCs are always 4 byte aligned.\n+  return pc - 4;\n+#else\n   return pc - 1;\n+#endif\n }\n \n static void PrintStackFramePrefix(uptr frame_num, uptr pc) {\n@@ -75,7 +80,8 @@ void StackTrace::PrintStack(const uptr *addr, uptr size,\n         Printf(\" %s\\n\", StripPathPrefix(buff.data(), strip_file_prefix));\n         frame_num++;\n       }\n-    } else if (symbolize) {\n+    }\n+    if (symbolize && addr_frames_num == 0) {\n       // Use our own (online) symbolizer, if necessary.\n       addr_frames_num = SymbolizeCode(pc, addr_frames.data(),\n                                       addr_frames.size());\n@@ -135,12 +141,20 @@ void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n   }\n }\n \n+void StackTrace::PopStackFrames(uptr count) {\n+  CHECK(size >= count);\n+  size -= count;\n+  for (uptr i = 0; i < size; i++) {\n+    trace[i] = trace[i + count];\n+  }\n+}\n+\n // On 32-bits we don't compress stack traces.\n // On 64-bits we compress stack traces: if a given pc differes slightly from\n // the previous one, we record a 31-bit offset instead of the full pc.\n SANITIZER_INTERFACE_ATTRIBUTE\n uptr StackTrace::CompressStack(StackTrace *stack, u32 *compressed, uptr size) {\n-#if __WORDSIZE == 32\n+#if SANITIZER_WORDSIZE == 32\n   // Don't compress, just copy.\n   uptr res = 0;\n   for (uptr i = 0; i < stack->size && i < size; i++) {\n@@ -181,7 +195,7 @@ uptr StackTrace::CompressStack(StackTrace *stack, u32 *compressed, uptr size) {\n     compressed[c_index] = 0;\n   if (c_index + 1 < size)\n     compressed[c_index + 1] = 0;\n-#endif  // __WORDSIZE\n+#endif  // SANITIZER_WORDSIZE\n \n   // debug-only code\n #if 0\n@@ -204,7 +218,7 @@ uptr StackTrace::CompressStack(StackTrace *stack, u32 *compressed, uptr size) {\n SANITIZER_INTERFACE_ATTRIBUTE\n void StackTrace::UncompressStack(StackTrace *stack,\n                                  u32 *compressed, uptr size) {\n-#if __WORDSIZE == 32\n+#if SANITIZER_WORDSIZE == 32\n   // Don't uncompress, just copy.\n   stack->size = 0;\n   for (uptr i = 0; i < size && i < kStackTraceMax; i++) {\n@@ -239,7 +253,7 @@ void StackTrace::UncompressStack(StackTrace *stack,\n     stack->trace[stack->size++] = pc;\n     prev_pc = pc;\n   }\n-#endif  // __WORDSIZE\n+#endif  // SANITIZER_WORDSIZE\n }\n \n }  // namespace __sanitizer"}, {"sha": "b36a1a082c5ae54463eb0ae311e550e9ed5c8a35", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -43,6 +43,8 @@ struct StackTrace {\n \n   void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom);\n \n+  void PopStackFrames(uptr count);\n+\n   static uptr GetCurrentPc();\n \n   static uptr CompressStack(StackTrace *stack,"}, {"sha": "efd1e8168320f8332fc3f2c8a0577c73e093cc12", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -291,7 +291,8 @@ class Symbolizer {\n     }\n   }\n \n-  static const uptr kMaxNumberOfModuleContexts = 4096;\n+  // 16K loaded modules should be enough for everyone.\n+  static const uptr kMaxNumberOfModuleContexts = 1 << 14;\n   LoadedModule *modules_;  // Array of module descriptions is leaked.\n   uptr n_modules_;\n "}, {"sha": "13ec83f2cbf270f1d2863a69c47855fe308dbee0", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -77,7 +77,7 @@ class LoadedModule {\n   };\n   char *full_name_;\n   uptr base_address_;\n-  static const uptr kMaxNumberOfAddressRanges = 8;\n+  static const uptr kMaxNumberOfAddressRanges = 6;\n   AddressRange ranges_[kMaxNumberOfAddressRanges];\n   uptr n_ranges_;\n };"}, {"sha": "bb1c40f9613650901a12e9f8c208c70ecaa1f8e4", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_linux.cc", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -21,6 +21,7 @@\n #include <poll.h>\n #include <sys/socket.h>\n #include <sys/types.h>\n+#include <sys/wait.h>\n #include <unistd.h>\n \n #if !defined(__ANDROID__) && !defined(ANDROID)\n@@ -29,8 +30,15 @@\n \n namespace __sanitizer {\n \n+static const int kSymbolizerStartupTimeMillis = 10;\n+\n bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n                                int *input_fd, int *output_fd) {\n+  if (!FileExists(path_to_symbolizer)) {\n+    Report(\"WARNING: invalid path to external symbolizer!\\n\");\n+    return false;\n+  }\n+\n   int *infd = NULL;\n   int *outfd = NULL;\n   // The client program may close its stdin and/or stdout and/or stderr\n@@ -97,13 +105,23 @@ bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n   internal_close(infd[1]);\n   *input_fd = infd[0];\n   *output_fd = outfd[1];\n+\n+  // Check that symbolizer subprocess started successfully.\n+  int pid_status;\n+  SleepForMillis(kSymbolizerStartupTimeMillis);\n+  int exited_pid = waitpid(pid, &pid_status, WNOHANG);\n+  if (exited_pid != 0) {\n+    // Either waitpid failed, or child has already exited.\n+    Report(\"WARNING: external symbolizer didn't start up correctly!\\n\");\n+    return false;\n+  }\n+\n   return true;\n }\n \n #if defined(__ANDROID__) || defined(ANDROID)\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n #else  // ANDROID\n typedef ElfW(Phdr) Elf_Phdr;"}, {"sha": "a1b931b737e2f78b7b71b7dd63a559bc64e67710", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -18,12 +18,10 @@ namespace __sanitizer {\n bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n                                int *input_fd, int *output_fd) {\n   UNIMPLEMENTED();\n-  return false;\n }\n \n uptr GetListOfModules(LoadedModule *modules, uptr max_modules) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n }  // namespace __sanitizer"}, {"sha": "3b81e794e59516da3d55ff941cbd85e33b33725a", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -20,12 +20,10 @@ namespace __sanitizer {\n bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n                                int *input_fd, int *output_fd) {\n   UNIMPLEMENTED();\n-  return false;\n }\n \n uptr GetListOfModules(LoadedModule *modules, uptr max_modules) {\n   UNIMPLEMENTED();\n-  return 0;\n };\n \n }  // namespace __sanitizer"}, {"sha": "03a5c204c6674968c429c4ef6b30c3b4f3ad4413", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -10,6 +10,9 @@\n // sanitizer_libc.h.\n //===----------------------------------------------------------------------===//\n #ifdef _WIN32\n+#define WIN32_LEAN_AND_MEAN\n+#define NOGDI\n+#include <stdlib.h>\n #include <windows.h>\n \n #include \"sanitizer_common.h\"\n@@ -18,6 +21,10 @@\n namespace __sanitizer {\n \n // --------------------- sanitizer_common.h\n+bool FileExists(const char *filename) {\n+  UNIMPLEMENTED();\n+}\n+\n int GetPid() {\n   return GetProcessId(GetCurrentProcess());\n }\n@@ -39,7 +46,6 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   *stack_bottom = (uptr)mbi.AllocationBase;\n }\n \n-\n void *MmapOrDie(uptr size, const char *mem_type) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (rv == 0) {\n@@ -59,8 +65,12 @@ void UnmapOrDie(void *addr, uptr size) {\n }\n \n void *MmapFixedNoReserve(uptr fixed_addr, uptr size) {\n-  return VirtualAlloc((LPVOID)fixed_addr, size,\n-                      MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n+  void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n+      MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n+  if (p == 0)\n+    Report(\"ERROR: Failed to allocate 0x%zx (%zd) bytes at %p (%d)\\n\",\n+           size, size, fixed_addr, GetLastError());\n+  return p;\n }\n \n void *Mprotect(uptr fixed_addr, uptr size) {\n@@ -75,7 +85,6 @@ bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n \n void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n const char *GetEnv(const char *name) {\n@@ -96,7 +105,6 @@ const char *GetEnv(const char *name) {\n \n const char *GetPwd() {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n void DumpProcessMap() {\n@@ -113,7 +121,6 @@ void ReExec() {\n \n bool StackSizeIsUnlimited() {\n   UNIMPLEMENTED();\n-  return false;\n }\n \n void SetStackSizeLimitInBytes(uptr limit) {\n@@ -137,39 +144,40 @@ void Abort() {\n   _exit(-1);  // abort is not NORETURN on Windows.\n }\n \n+#ifndef SANITIZER_GO\n int Atexit(void (*function)(void)) {\n   return atexit(function);\n }\n+#endif\n \n // ------------------ sanitizer_libc.h\n void *internal_mmap(void *addr, uptr length, int prot, int flags,\n                     int fd, u64 offset) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n int internal_munmap(void *addr, uptr length) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n int internal_close(fd_t fd) {\n   UNIMPLEMENTED();\n-  return 0;\n+}\n+\n+int internal_isatty(fd_t fd) {\n+  UNIMPLEMENTED();\n }\n \n fd_t internal_open(const char *filename, bool write) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n uptr internal_read(fd_t fd, void *buf, uptr count) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n uptr internal_write(fd_t fd, const void *buf, uptr count) {\n-  if (fd != 2)\n+  if (fd != kStderrFd)\n     UNIMPLEMENTED();\n   HANDLE err = GetStdHandle(STD_ERROR_HANDLE);\n   if (err == 0)\n@@ -182,21 +190,18 @@ uptr internal_write(fd_t fd, const void *buf, uptr count) {\n \n uptr internal_filesize(fd_t fd) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n int internal_dup2(int oldfd, int newfd) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n uptr internal_readlink(const char *path, char *buf, uptr bufsize) {\n   UNIMPLEMENTED();\n-  return 0;\n }\n \n int internal_sched_yield() {\n-  UNIMPLEMENTED();\n+  Sleep(0);\n   return 0;\n }\n "}, {"sha": "c4fbad9b74df9949d495e5a4131e45197fb0b20c", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -26,7 +26,6 @@ tsan_files = \\\n         tsan_suppressions.cc \\\n         tsan_interface_ann.cc \\\n         tsan_mman.cc \\\n-        tsan_printf.cc \\\n         tsan_rtl_report.cc \\\n         tsan_symbolize_addr2line_linux.cc\n "}, {"sha": "b919969cf47429a3871ef310e6e3f374a0cecc90", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -84,7 +84,7 @@ am__objects_1 = tsan_clock.lo tsan_interface_atomic.lo tsan_mutex.lo \\\n \ttsan_rtl.lo tsan_stat.lo tsan_sync.lo tsan_interceptors.lo \\\n \ttsan_md5.lo tsan_platform_mac.lo tsan_rtl_mutex.lo \\\n \ttsan_suppressions.lo tsan_interface_ann.lo tsan_mman.lo \\\n-\ttsan_printf.lo tsan_rtl_report.lo \\\n+\ttsan_rtl_report.lo \\\n \ttsan_symbolize_addr2line_linux.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n@@ -261,7 +261,6 @@ tsan_files = \\\n         tsan_suppressions.cc \\\n         tsan_interface_ann.cc \\\n         tsan_mman.cc \\\n-        tsan_printf.cc \\\n         tsan_rtl_report.cc \\\n         tsan_symbolize_addr2line_linux.cc\n \n@@ -395,7 +394,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mutex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_printf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_report.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mutex.Plo@am__quote@"}, {"sha": "5d45a5d15fb49896caa7926803778c8c7b146301", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -103,13 +103,6 @@ void ThreadClock::acq_rel(SyncClock *dst) {\n   release(dst);\n }\n \n-void ThreadClock::Disable(unsigned tid) {\n-  u64 c0 = clk_[tid];\n-  for (uptr i = 0; i < kMaxTidInClock; i++)\n-    clk_[i] = (u64)-1;\n-  clk_[tid] = c0;\n-}\n-\n SyncClock::SyncClock()\n   : clk_(MBlockClock) {\n }"}, {"sha": "8e4bf99ca89629488c458ae9b7cfcb7255221d55", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -59,8 +59,6 @@ struct ThreadClock {\n       nclk_ = tid + 1;\n   }\n \n-  void Disable(unsigned tid);\n-\n   uptr size() const {\n     return nclk_;\n   }"}, {"sha": "6f3fd21e246d9d0733e9e9de7168261de71a1962", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -22,6 +22,12 @@\n \n namespace __tsan {\n \n+#ifdef TSAN_GO\n+const char *const kTsanOptionsEnv = \"GORACE\";\n+#else\n+const char *const kTsanOptionsEnv = \"TSAN_OPTIONS\";\n+#endif\n+\n const int kTidBits = 13;\n const unsigned kMaxTid = 1 << kTidBits;\n const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n@@ -34,20 +40,23 @@ const int kTraceStackSize = 256;\n #ifdef TSAN_SHADOW_COUNT\n # if TSAN_SHADOW_COUNT == 2 \\\n   || TSAN_SHADOW_COUNT == 4 || TSAN_SHADOW_COUNT == 8\n-const unsigned kShadowCnt = TSAN_SHADOW_COUNT;\n+const uptr kShadowCnt = TSAN_SHADOW_COUNT;\n # else\n #   error \"TSAN_SHADOW_COUNT must be one of 2,4,8\"\n # endif\n #else\n // Count of shadow values in a shadow cell.\n-const unsigned kShadowCnt = 8;\n+const uptr kShadowCnt = 4;\n #endif\n \n // That many user bytes are mapped onto a single shadow cell.\n-const unsigned kShadowCell = 8;\n+const uptr kShadowCell = 8;\n \n // Size of a single shadow value (u64).\n-const unsigned kShadowSize = 8;\n+const uptr kShadowSize = 8;\n+\n+// Shadow memory is kShadowMultiplier times larger than user memory.\n+const uptr kShadowMultiplier = kShadowSize * kShadowCnt / kShadowCell;\n \n #if defined(TSAN_COLLECT_STATS) && TSAN_COLLECT_STATS\n const bool kCollectStats = true;"}, {"sha": "a69c6a6b545e69d01cfc42ee9441f94d308140ed", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -38,14 +38,15 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->enable_annotations = true;\n   f->suppress_equal_stacks = true;\n   f->suppress_equal_addresses = true;\n+  f->report_bugs = true;\n   f->report_thread_leaks = true;\n   f->report_destroy_locked = true;\n   f->report_signal_unsafe = true;\n   f->force_seq_cst_atomics = false;\n   f->strip_path_prefix = \"\";\n   f->suppressions = \"\";\n   f->exitcode = 66;\n-  f->log_fileno = 2;\n+  f->log_fileno = kStderrFd;\n   f->atexit_sleep_ms = 1000;\n   f->verbosity = 0;\n   f->profile_memory = \"\";\n@@ -61,6 +62,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->enable_annotations, \"enable_annotations\");\n   ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\");\n   ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\");\n+  ParseFlag(env, &f->report_bugs, \"report_bugs\");\n   ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n   ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n   ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\");\n@@ -75,6 +77,12 @@ void InitializeFlags(Flags *f, const char *env) {\n   ParseFlag(env, &f->flush_memory_ms, \"flush_memory_ms\");\n   ParseFlag(env, &f->stop_on_start, \"stop_on_start\");\n   ParseFlag(env, &f->external_symbolizer_path, \"external_symbolizer_path\");\n+\n+  if (!f->report_bugs) {\n+    f->report_thread_leaks = false;\n+    f->report_destroy_locked = false;\n+    f->report_signal_unsafe = false;\n+  }\n }\n \n }  // namespace __tsan"}, {"sha": "451d3684729b89f7361e8cccd445f22b1ea6d3bd", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -29,6 +29,8 @@ struct Flags {\n   // Supress a race report if we've already output another race report\n   // on the same address.\n   bool suppress_equal_addresses;\n+  // Turns off bug reporting entirely (useful for benchmarking).\n+  bool report_bugs;\n   // Report thread leaks at exit?\n   bool report_thread_leaks;\n   // Report destruction of a locked mutex?"}, {"sha": "191dea7387a103dd1b673909e991dd9415ef3ac6", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -113,6 +113,7 @@ struct SignalDesc {\n };\n \n struct SignalContext {\n+  int in_blocking_func;\n   int int_signal_send;\n   int pending_signal_count;\n   SignalDesc pending_signals[kSigCount];\n@@ -134,8 +135,6 @@ static SignalContext *SigCtx(ThreadState *thr) {\n \n static unsigned g_thread_finalize_key;\n \n-static void process_pending_signals(ThreadState *thr);\n-\n ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                      uptr pc)\n     : thr_(thr)\n@@ -154,28 +153,43 @@ ScopedInterceptor::~ScopedInterceptor() {\n   thr_->in_rtl--;\n   if (thr_->in_rtl == 0) {\n     FuncExit(thr_);\n-    process_pending_signals(thr_);\n+    ProcessPendingSignals(thr_);\n   }\n   CHECK_EQ(in_rtl_, thr_->in_rtl);\n }\n \n+#define BLOCK_REAL(name) (BlockingCall(thr), REAL(name))\n+\n+struct BlockingCall {\n+  explicit BlockingCall(ThreadState *thr)\n+      : ctx(SigCtx(thr)) {\n+    ctx->in_blocking_func++;\n+  }\n+\n+  ~BlockingCall() {\n+    ctx->in_blocking_func--;\n+  }\n+\n+  SignalContext *ctx;\n+};\n+\n TSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n   SCOPED_TSAN_INTERCEPTOR(sleep, sec);\n-  unsigned res = sleep(sec);\n+  unsigned res = BLOCK_REAL(sleep)(sec);\n   AfterSleep(thr, pc);\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, usleep, long_t usec) {\n   SCOPED_TSAN_INTERCEPTOR(usleep, usec);\n-  int res = usleep(usec);\n+  int res = BLOCK_REAL(usleep)(usec);\n   AfterSleep(thr, pc);\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n   SCOPED_TSAN_INTERCEPTOR(nanosleep, req, rem);\n-  int res = nanosleep(req, rem);\n+  int res = BLOCK_REAL(nanosleep)(req, rem);\n   AfterSleep(thr, pc);\n   return res;\n }\n@@ -236,7 +250,6 @@ static void finalize(void *arg) {\n   {\n     ScopedInRtl in_rtl;\n     DestroyAndFree(atexit_ctx);\n-    REAL(usleep)(flags()->atexit_sleep_ms * 1000);\n   }\n   int status = Finalize(cur_thread());\n   if (status)\n@@ -251,13 +264,13 @@ TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n \n TSAN_INTERCEPTOR(void, longjmp, void *env, int val) {\n   SCOPED_TSAN_INTERCEPTOR(longjmp, env, val);\n-  TsanPrintf(\"ThreadSanitizer: longjmp() is not supported\\n\");\n+  Printf(\"ThreadSanitizer: longjmp() is not supported\\n\");\n   Die();\n }\n \n TSAN_INTERCEPTOR(void, siglongjmp, void *env, int val) {\n   SCOPED_TSAN_INTERCEPTOR(siglongjmp, env, val);\n-  TsanPrintf(\"ThreadSanitizer: siglongjmp() is not supported\\n\");\n+  Printf(\"ThreadSanitizer: siglongjmp() is not supported\\n\");\n   Die();\n }\n \n@@ -588,7 +601,7 @@ static void thread_finalize(void *v) {\n   uptr iter = (uptr)v;\n   if (iter > 1) {\n     if (pthread_setspecific(g_thread_finalize_key, (void*)(iter - 1))) {\n-      TsanPrintf(\"ThreadSanitizer: failed to set thread key\\n\");\n+      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n       Die();\n     }\n     return;\n@@ -621,7 +634,7 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n     ThreadState *thr = cur_thread();\n     ScopedInRtl in_rtl;\n     if (pthread_setspecific(g_thread_finalize_key, (void*)4)) {\n-      TsanPrintf(\"ThreadSanitizer: failed to set thread key\\n\");\n+      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n       Die();\n     }\n     while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n@@ -676,7 +689,7 @@ TSAN_INTERCEPTOR(int, pthread_create,\n TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_join, th, ret);\n   int tid = ThreadTid(thr, pc, (uptr)th);\n-  int res = REAL(pthread_join)(th, ret);\n+  int res = BLOCK_REAL(pthread_join)(th, ret);\n   if (res == 0) {\n     ThreadJoin(thr, pc, tid);\n   }\n@@ -979,7 +992,7 @@ TSAN_INTERCEPTOR(int, sem_destroy, void *s) {\n \n TSAN_INTERCEPTOR(int, sem_wait, void *s) {\n   SCOPED_TSAN_INTERCEPTOR(sem_wait, s);\n-  int res = REAL(sem_wait)(s);\n+  int res = BLOCK_REAL(sem_wait)(s);\n   if (res == 0) {\n     Acquire(thr, pc, (uptr)s);\n   }\n@@ -988,7 +1001,7 @@ TSAN_INTERCEPTOR(int, sem_wait, void *s) {\n \n TSAN_INTERCEPTOR(int, sem_trywait, void *s) {\n   SCOPED_TSAN_INTERCEPTOR(sem_trywait, s);\n-  int res = REAL(sem_trywait)(s);\n+  int res = BLOCK_REAL(sem_trywait)(s);\n   if (res == 0) {\n     Acquire(thr, pc, (uptr)s);\n   }\n@@ -997,7 +1010,7 @@ TSAN_INTERCEPTOR(int, sem_trywait, void *s) {\n \n TSAN_INTERCEPTOR(int, sem_timedwait, void *s, void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(sem_timedwait, s, abstime);\n-  int res = REAL(sem_timedwait)(s, abstime);\n+  int res = BLOCK_REAL(sem_timedwait)(s, abstime);\n   if (res == 0) {\n     Acquire(thr, pc, (uptr)s);\n   }\n@@ -1189,21 +1202,32 @@ TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n \n TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n-  int res = REAL(epoll_wait)(epfd, ev, cnt, timeout);\n+  int res = BLOCK_REAL(epoll_wait)(epfd, ev, cnt, timeout);\n   if (res > 0) {\n     Acquire(thr, pc, epollfd2addr(epfd));\n   }\n   return res;\n }\n \n+TSAN_INTERCEPTOR(int, poll, void *fds, long_t nfds, int timeout) {\n+  SCOPED_TSAN_INTERCEPTOR(poll, fds, nfds, timeout);\n+  int res = BLOCK_REAL(poll)(fds, nfds, timeout);\n+  return res;\n+}\n+\n static void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n     my_siginfo_t *info, void *ctx) {\n   ThreadState *thr = cur_thread();\n   SignalContext *sctx = SigCtx(thr);\n   // Don't mess with synchronous signals.\n   if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n       sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE ||\n-      (sctx && sig == sctx->int_signal_send)) {\n+      // If we are sending signal to ourselves, we must process it now.\n+      (sctx && sig == sctx->int_signal_send) ||\n+      // If we are in blocking function, we can safely process it now\n+      // (but check if we are in a recursive interceptor,\n+      // i.e. pthread_join()->munmap()).\n+      (sctx && sctx->in_blocking_func == 1 && thr->in_rtl == 1)) {\n     CHECK(thr->in_rtl == 0 || thr->in_rtl == 1);\n     int in_rtl = thr->in_rtl;\n     thr->in_rtl = 0;\n@@ -1317,7 +1341,15 @@ TSAN_INTERCEPTOR(int, pthread_kill, void *tid, int sig) {\n   return res;\n }\n \n-static void process_pending_signals(ThreadState *thr) {\n+TSAN_INTERCEPTOR(int, gettimeofday, void *tv, void *tz) {\n+  SCOPED_TSAN_INTERCEPTOR(gettimeofday, tv, tz);\n+  // It's intercepted merely to process pending signals.\n+  return REAL(gettimeofday)(tv, tz);\n+}\n+\n+namespace __tsan {\n+\n+void ProcessPendingSignals(ThreadState *thr) {\n   CHECK_EQ(thr->in_rtl, 0);\n   SignalContext *sctx = SigCtx(thr);\n   if (sctx == 0 || sctx->pending_signal_count == 0 || thr->in_signal_handler)\n@@ -1342,7 +1374,7 @@ static void process_pending_signals(ThreadState *thr) {\n           sigactions[sig].sa_sigaction(sig, &signal->siginfo, &signal->ctx);\n         else\n           sigactions[sig].sa_handler(sig);\n-        if (errno != 0) {\n+        if (flags()->report_bugs && errno != 0) {\n           ScopedInRtl in_rtl;\n           __tsan::StackTrace stack;\n           uptr pc = signal->sigaction ?\n@@ -1364,8 +1396,6 @@ static void process_pending_signals(ThreadState *thr) {\n   thr->in_signal_handler = false;\n }\n \n-namespace __tsan {\n-\n void InitializeInterceptors() {\n   CHECK_GT(cur_thread()->in_rtl, 0);\n \n@@ -1482,6 +1512,7 @@ void InitializeInterceptors() {\n \n   TSAN_INTERCEPT(epoll_ctl);\n   TSAN_INTERCEPT(epoll_wait);\n+  TSAN_INTERCEPT(poll);\n \n   TSAN_INTERCEPT(sigaction);\n   TSAN_INTERCEPT(signal);\n@@ -1491,17 +1522,18 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(sleep);\n   TSAN_INTERCEPT(usleep);\n   TSAN_INTERCEPT(nanosleep);\n+  TSAN_INTERCEPT(gettimeofday);\n \n   atexit_ctx = new(internal_alloc(MBlockAtExit, sizeof(AtExitContext)))\n       AtExitContext();\n \n   if (__cxa_atexit(&finalize, 0, 0)) {\n-    TsanPrintf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n+    Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n     Die();\n   }\n \n   if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n-    TsanPrintf(\"ThreadSanitizer: failed to create thread key\\n\");\n+    Printf(\"ThreadSanitizer: failed to create thread key\\n\");\n     Die();\n   }\n }"}, {"sha": "dede9be5f06d4358c3571adf63698dd60a98294b", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -14,7 +14,6 @@\n #ifndef TSAN_INTERFACE_H\n #define TSAN_INTERFACE_H\n \n-#include <sanitizer/common_interface_defs.h> \n // This header should NOT include any other headers.\n // All functions in this header are extern \"C\" and start with __tsan_.\n \n@@ -24,24 +23,24 @@ extern \"C\" {\n \n // This function should be called at the very beginning of the process,\n // before any instrumented code is executed and before any call to malloc.\n-void __tsan_init() SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_init();\n \n-void __tsan_read1(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_read2(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_read4(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_read8(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_read16(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read1(void *addr);\n+void __tsan_read2(void *addr);\n+void __tsan_read4(void *addr);\n+void __tsan_read8(void *addr);\n+void __tsan_read16(void *addr);\n \n-void __tsan_write1(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_write2(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_write4(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_write8(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_write16(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write1(void *addr);\n+void __tsan_write2(void *addr);\n+void __tsan_write4(void *addr);\n+void __tsan_write8(void *addr);\n+void __tsan_write16(void *addr);\n \n-void __tsan_vptr_update(void **vptr_p, void *new_val) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_vptr_update(void **vptr_p, void *new_val);\n \n-void __tsan_func_entry(void *call_pc) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_func_exit() SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_func_entry(void *call_pc);\n+void __tsan_func_exit();\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "b9e084b7327da7fb66229c0ee88f1307c959dfe7", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -157,57 +157,47 @@ bool IsExpectedReport(uptr addr, uptr size) {\n using namespace __tsan;  // NOLINT\n \n extern \"C\" {\n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateHappensBefore(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensBefore);\n   Release(cur_thread(), CALLERPC, addr);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateHappensAfter(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensAfter);\n   Acquire(cur_thread(), CALLERPC, addr);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateCondVarSignal(char *f, int l, uptr cv) {\n   SCOPED_ANNOTATION(AnnotateCondVarSignal);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateCondVarSignalAll(char *f, int l, uptr cv) {\n   SCOPED_ANNOTATION(AnnotateCondVarSignalAll);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateMutexIsNotPHB(char *f, int l, uptr mu) {\n   SCOPED_ANNOTATION(AnnotateMutexIsNotPHB);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateCondVarWait(char *f, int l, uptr cv, uptr lock) {\n   SCOPED_ANNOTATION(AnnotateCondVarWait);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateRWLockCreate(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockCreate);\n   MutexCreate(thr, pc, m, true, true, false);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateRWLockCreateStatic(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockCreateStatic);\n   MutexCreate(thr, pc, m, true, true, true);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateRWLockDestroy(char *f, int l, uptr m) {\n   SCOPED_ANNOTATION(AnnotateRWLockDestroy);\n   MutexDestroy(thr, pc, m);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateRWLockAcquired(char *f, int l, uptr m, uptr is_w) {\n   SCOPED_ANNOTATION(AnnotateRWLockAcquired);\n   if (is_w)\n@@ -216,7 +206,6 @@ void AnnotateRWLockAcquired(char *f, int l, uptr m, uptr is_w) {\n     MutexReadLock(thr, pc, m);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateRWLockReleased(char *f, int l, uptr m, uptr is_w) {\n   SCOPED_ANNOTATION(AnnotateRWLockReleased);\n   if (is_w)\n@@ -225,35 +214,30 @@ void AnnotateRWLockReleased(char *f, int l, uptr m, uptr is_w) {\n     MutexReadUnlock(thr, pc, m);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateTraceMemory(char *f, int l, uptr mem) {\n   SCOPED_ANNOTATION(AnnotateTraceMemory);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateFlushState(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateFlushState);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateNewMemory(char *f, int l, uptr mem, uptr size) {\n   SCOPED_ANNOTATION(AnnotateNewMemory);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateNoOp(char *f, int l, uptr mem) {\n   SCOPED_ANNOTATION(AnnotateNoOp);\n }\n \n static void ReportMissedExpectedRace(ExpectRace *race) {\n-  TsanPrintf(\"==================\\n\");\n-  TsanPrintf(\"WARNING: ThreadSanitizer: missed expected data race\\n\");\n-  TsanPrintf(\"  %s addr=%zx %s:%d\\n\",\n+  Printf(\"==================\\n\");\n+  Printf(\"WARNING: ThreadSanitizer: missed expected data race\\n\");\n+  Printf(\"  %s addr=%zx %s:%d\\n\",\n       race->desc, race->addr, race->file, race->line);\n-  TsanPrintf(\"==================\\n\");\n+  Printf(\"==================\\n\");\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateFlushExpectedRaces(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateFlushExpectedRaces);\n   Lock lock(&dyn_ann_ctx->mtx);\n@@ -269,38 +253,31 @@ void AnnotateFlushExpectedRaces(char *f, int l) {\n   }\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateEnableRaceDetection(char *f, int l, int enable) {\n   SCOPED_ANNOTATION(AnnotateEnableRaceDetection);\n   // FIXME: Reconsider this functionality later. It may be irrelevant.\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateMutexIsUsedAsCondVar(char *f, int l, uptr mu) {\n   SCOPED_ANNOTATION(AnnotateMutexIsUsedAsCondVar);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotatePCQGet(char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQGet);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotatePCQPut(char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQPut);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotatePCQDestroy(char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQDestroy);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotatePCQCreate(char *f, int l, uptr pcq) {\n   SCOPED_ANNOTATION(AnnotatePCQCreate);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateExpectRace(char *f, int l, uptr mem, char *desc) {\n   SCOPED_ANNOTATION(AnnotateExpectRace);\n   Lock lock(&dyn_ann_ctx->mtx);\n@@ -317,73 +294,60 @@ static void BenignRaceImpl(char *f, int l, uptr mem, uptr size, char *desc) {\n }\n \n // FIXME: Turn it off later. WTF is benign race?1?? Go talk to Hans Boehm.\n-// SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateBenignRaceSized(char *f, int l, uptr mem, uptr size, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n   BenignRaceImpl(f, l, mem, size, desc);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateBenignRace(char *f, int l, uptr mem, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRace);\n   BenignRaceImpl(f, l, mem, 1, desc);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateIgnoreReadsBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsBegin);\n   IgnoreCtl(cur_thread(), false, true);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateIgnoreReadsEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsEnd);\n   IgnoreCtl(cur_thread(), false, false);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateIgnoreWritesBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesBegin);\n   IgnoreCtl(cur_thread(), true, true);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateIgnoreWritesEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesEnd);\n   IgnoreCtl(cur_thread(), true, false);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotatePublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n   SCOPED_ANNOTATION(AnnotatePublishMemoryRange);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateUnpublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n   SCOPED_ANNOTATION(AnnotateUnpublishMemoryRange);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void AnnotateThreadName(char *f, int l, char *name) {\n   SCOPED_ANNOTATION(AnnotateThreadName);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void WTFAnnotateHappensBefore(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensBefore);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void WTFAnnotateHappensAfter(char *f, int l, uptr addr) {\n   SCOPED_ANNOTATION(AnnotateHappensAfter);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n void WTFAnnotateBenignRaceSized(char *f, int l, uptr mem, uptr sz, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n int RunningOnValgrind() {\n   return flags()->running_on_valgrind;\n }\n@@ -392,7 +356,6 @@ double __attribute__((weak)) ValgrindSlowdown(void) {\n   return 10.0;\n }\n \n-SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n const char *ThreadSanitizerQuery(const char *query) {\n   if (internal_strcmp(query, \"pure_happens_before\") == 0)\n     return \"1\";"}, {"sha": "037a080da67d9dfad66b8682d125de95d04fa8ab", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -37,12 +37,12 @@ typedef __tsan_atomic8 a8;\n typedef __tsan_atomic16 a16;\n typedef __tsan_atomic32 a32;\n typedef __tsan_atomic64 a64;\n-const int mo_relaxed = __tsan_memory_order_relaxed;\n-const int mo_consume = __tsan_memory_order_consume;\n-const int mo_acquire = __tsan_memory_order_acquire;\n-const int mo_release = __tsan_memory_order_release;\n-const int mo_acq_rel = __tsan_memory_order_acq_rel;\n-const int mo_seq_cst = __tsan_memory_order_seq_cst;\n+const morder mo_relaxed = __tsan_memory_order_relaxed;\n+const morder mo_consume = __tsan_memory_order_consume;\n+const morder mo_acquire = __tsan_memory_order_acquire;\n+const morder mo_release = __tsan_memory_order_release;\n+const morder mo_acq_rel = __tsan_memory_order_acq_rel;\n+const morder mo_seq_cst = __tsan_memory_order_seq_cst;\n \n static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {\n   StatInc(thr, StatAtomic);\n@@ -77,10 +77,32 @@ static bool IsAcquireOrder(morder mo) {\n       || mo == mo_acq_rel || mo == mo_seq_cst;\n }\n \n+static morder ConvertOrder(morder mo) {\n+  if (mo > (morder)100500) {\n+    mo = morder(mo - 100500);\n+    if (mo ==  morder(1 << 0))\n+      mo = mo_relaxed;\n+    else if (mo == morder(1 << 1))\n+      mo = mo_consume;\n+    else if (mo == morder(1 << 2))\n+      mo = mo_acquire;\n+    else if (mo == morder(1 << 3))\n+      mo = mo_release;\n+    else if (mo == morder(1 << 4))\n+      mo = mo_acq_rel;\n+    else if (mo == morder(1 << 5))\n+      mo = mo_seq_cst;\n+  }\n+  CHECK_GE(mo, mo_relaxed);\n+  CHECK_LE(mo, mo_seq_cst);\n+  return mo;\n+}\n+\n #define SCOPED_ATOMIC(func, ...) \\\n-    if ((u32)mo > 100500) mo = (morder)((u32)mo - 100500); \\\n+    mo = ConvertOrder(mo); \\\n     mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n     ThreadState *const thr = cur_thread(); \\\n+    ProcessPendingSignals(thr); \\\n     const uptr pc = (uptr)__builtin_return_address(0); \\\n     AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n     ScopedAtomic sa(thr, pc, __FUNCTION__); \\\n@@ -187,6 +209,13 @@ static bool AtomicCAS(ThreadState *thr, uptr pc,\n   return false;\n }\n \n+template<typename T>\n+static T AtomicCAS(ThreadState *thr, uptr pc,\n+    volatile T *a, T c, T v, morder mo) {\n+  AtomicCAS(thr, pc, a, &c, v, mo);\n+  return c;\n+}\n+\n static void AtomicFence(ThreadState *thr, uptr pc, morder mo) {\n   __sync_synchronize();\n }\n@@ -359,6 +388,25 @@ int __tsan_atomic64_compare_exchange_weak(volatile a64 *a, a64 *c, a64 v,\n   SCOPED_ATOMIC(CAS, a, c, v, mo);\n }\n \n+a8 __tsan_atomic8_compare_exchange_val(volatile a8 *a, a8 c, a8 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+a16 __tsan_atomic16_compare_exchange_val(volatile a16 *a, a16 c, a16 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+a32 __tsan_atomic32_compare_exchange_val(volatile a32 *a, a32 c, a32 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+a64 __tsan_atomic64_compare_exchange_val(volatile a64 *a, a64 c, a64 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n void __tsan_atomic_thread_fence(morder mo) {\n   char* a;\n   SCOPED_ATOMIC(Fence, mo);"}, {"sha": "fea97b69debf3826e5db95541c126f1a38a2c911", "filename": "libsanitizer/tsan/tsan_interface_atomic.h", "status": "modified", "additions": 63, "deletions": 92, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -23,148 +23,119 @@ typedef long  __tsan_atomic64;  // NOLINT\n // Part of ABI, do not change.\n // http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/atomic?view=markup\n typedef enum {\n-  __tsan_memory_order_relaxed = 1 << 0,\n-  __tsan_memory_order_consume = 1 << 1,\n-  __tsan_memory_order_acquire = 1 << 2,\n-  __tsan_memory_order_release = 1 << 3,\n-  __tsan_memory_order_acq_rel = 1 << 4,\n-  __tsan_memory_order_seq_cst = 1 << 5\n+  __tsan_memory_order_relaxed,\n+  __tsan_memory_order_consume,\n+  __tsan_memory_order_acquire,\n+  __tsan_memory_order_release,\n+  __tsan_memory_order_acq_rel,\n+  __tsan_memory_order_seq_cst\n } __tsan_memory_order;\n \n __tsan_atomic8 __tsan_atomic8_load(const volatile __tsan_atomic8 *a,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_load(const volatile __tsan_atomic16 *a,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_load(const volatile __tsan_atomic32 *a,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_load(const volatile __tsan_atomic64 *a,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n \n void __tsan_atomic8_store(volatile __tsan_atomic8 *a, __tsan_atomic8 v,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic16_store(volatile __tsan_atomic16 *a, __tsan_atomic16 v,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic32_store(volatile __tsan_atomic32 *a, __tsan_atomic32 v,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n void __tsan_atomic64_store(volatile __tsan_atomic64 *a, __tsan_atomic64 v,\n-    __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_exchange(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_exchange(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_exchange(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-__tsan_atomic64 __tsan_atomic64_exchange(volatile __tsan_atomic64 *a, \n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n+__tsan_atomic64 __tsan_atomic64_exchange(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_fetch_add(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_add(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_add(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_add(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_fetch_sub(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_sub(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_sub(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_sub(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_fetch_and(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_and(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_and(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_and(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_fetch_or(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_or(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_or(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_or(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n __tsan_atomic8 __tsan_atomic8_fetch_xor(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 v, __tsan_memory_order mo);\n __tsan_atomic16 __tsan_atomic16_fetch_xor(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 v, __tsan_memory_order mo);\n __tsan_atomic32 __tsan_atomic32_fetch_xor(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 v, __tsan_memory_order mo);\n __tsan_atomic64 __tsan_atomic64_fetch_xor(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 v, __tsan_memory_order mo);\n \n int __tsan_atomic8_compare_exchange_weak(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo);\n int __tsan_atomic16_compare_exchange_weak(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo);\n int __tsan_atomic32_compare_exchange_weak(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo);\n int __tsan_atomic64_compare_exchange_weak(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo);\n \n int __tsan_atomic8_compare_exchange_strong(volatile __tsan_atomic8 *a,\n-    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo);\n int __tsan_atomic16_compare_exchange_strong(volatile __tsan_atomic16 *a,\n-    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo);\n int __tsan_atomic32_compare_exchange_strong(volatile __tsan_atomic32 *a,\n-    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo);\n int __tsan_atomic64_compare_exchange_strong(volatile __tsan_atomic64 *a,\n-    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-\n-void __tsan_atomic_thread_fence(__tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n-void __tsan_atomic_signal_fence(__tsan_memory_order mo)\n-    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo);\n+\n+__tsan_atomic8 __tsan_atomic8_compare_exchange_val(\n+    volatile __tsan_atomic8 *a, __tsan_atomic8 c, __tsan_atomic8 v,\n+    __tsan_memory_order mo);\n+__tsan_atomic16 __tsan_atomic16_compare_exchange_val(\n+    volatile __tsan_atomic16 *a, __tsan_atomic16 c, __tsan_atomic16 v,\n+    __tsan_memory_order mo);\n+__tsan_atomic32 __tsan_atomic32_compare_exchange_val(\n+    volatile __tsan_atomic32 *a, __tsan_atomic32 c, __tsan_atomic32 v,\n+    __tsan_memory_order mo);\n+__tsan_atomic64 __tsan_atomic64_compare_exchange_val(\n+    volatile __tsan_atomic64 *a, __tsan_atomic64 c, __tsan_atomic64 v,\n+    __tsan_memory_order mo);\n+\n+void __tsan_atomic_thread_fence(__tsan_memory_order mo);\n+void __tsan_atomic_signal_fence(__tsan_memory_order mo);\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "6a1e0cec53ad48d576b42791f269cfcca5e63901", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -90,25 +90,25 @@ void InitializeMutex() {\n     }\n   }\n #if 0\n-  TsanPrintf(\"Can lock graph:\\n\");\n+  Printf(\"Can lock graph:\\n\");\n   for (int i = 0; i < N; i++) {\n     for (int j = 0; j < N; j++) {\n-      TsanPrintf(\"%d \", CanLockAdj[i][j]);\n+      Printf(\"%d \", CanLockAdj[i][j]);\n     }\n-    TsanPrintf(\"\\n\");\n+    Printf(\"\\n\");\n   }\n-  TsanPrintf(\"Can lock graph closure:\\n\");\n+  Printf(\"Can lock graph closure:\\n\");\n   for (int i = 0; i < N; i++) {\n     for (int j = 0; j < N; j++) {\n-      TsanPrintf(\"%d \", CanLockAdj2[i][j]);\n+      Printf(\"%d \", CanLockAdj2[i][j]);\n     }\n-    TsanPrintf(\"\\n\");\n+    Printf(\"\\n\");\n   }\n #endif\n   // Verify that the graph is acyclic.\n   for (int i = 0; i < N; i++) {\n     if (CanLockAdj2[i][i]) {\n-      TsanPrintf(\"Mutex %d participates in a cycle\\n\", i);\n+      Printf(\"Mutex %d participates in a cycle\\n\", i);\n       Die();\n     }\n   }\n@@ -119,7 +119,7 @@ DeadlockDetector::DeadlockDetector() {\n }\n \n void DeadlockDetector::Lock(MutexType t) {\n-  // TsanPrintf(\"LOCK %d @%zu\\n\", t, seq_ + 1);\n+  // Printf(\"LOCK %d @%zu\\n\", t, seq_ + 1);\n   u64 max_seq = 0;\n   u64 max_idx = MutexTypeInvalid;\n   for (int i = 0; i != MutexTypeCount; i++) {\n@@ -134,17 +134,17 @@ void DeadlockDetector::Lock(MutexType t) {\n   locked_[t] = ++seq_;\n   if (max_idx == MutexTypeInvalid)\n     return;\n-  // TsanPrintf(\"  last %d @%zu\\n\", max_idx, max_seq);\n+  // Printf(\"  last %d @%zu\\n\", max_idx, max_seq);\n   if (!CanLockAdj[max_idx][t]) {\n-    TsanPrintf(\"ThreadSanitizer: internal deadlock detected\\n\");\n-    TsanPrintf(\"ThreadSanitizer: can't lock %d while under %zu\\n\",\n+    Printf(\"ThreadSanitizer: internal deadlock detected\\n\");\n+    Printf(\"ThreadSanitizer: can't lock %d while under %zu\\n\",\n                t, (uptr)max_idx);\n     CHECK(0);\n   }\n }\n \n void DeadlockDetector::Unlock(MutexType t) {\n-  // TsanPrintf(\"UNLO %d @%zu #%zu\\n\", t, seq_, locked_[t]);\n+  // Printf(\"UNLO %d @%zu #%zu\\n\", t, seq_, locked_[t]);\n   CHECK(locked_[t]);\n   locked_[t] = 0;\n }"}, {"sha": "f849182503c900d639ac2442f73933bc4face161", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -15,13 +15,17 @@\n \n #include \"tsan_rtl.h\"\n \n-#if __LP64__\n+#if defined(__LP64__) || defined(_WIN64)\n namespace __tsan {\n \n #if defined(TSAN_GO)\n static const uptr kLinuxAppMemBeg = 0x000000000000ULL;\n static const uptr kLinuxAppMemEnd = 0x00fcffffffffULL;\n+# if defined(_WIN32)\n+static const uptr kLinuxShadowMsk = 0x010000000000ULL;\n+# else\n static const uptr kLinuxShadowMsk = 0x100000000000ULL;\n+# endif\n // TSAN_COMPAT_SHADOW is intended for COMPAT virtual memory layout,\n // when memory addresses are of the 0x2axxxxxxxxxx form.\n // The option is enabled with 'setarch x86_64 -L'.\n@@ -93,7 +97,7 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n \n }  // namespace __tsan\n \n-#else  // __LP64__\n+#else  // defined(__LP64__) || defined(_WIN64)\n # error \"Only 64-bit is supported\"\n #endif\n "}, {"sha": "b26065543fe520036f4c451d61e64678c525a7de", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -81,46 +81,42 @@ static void ProtectRange(uptr beg, uptr end) {\n   if (beg == end)\n     return;\n   if (beg != (uptr)Mprotect(beg, end - beg)) {\n-    TsanPrintf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n-    TsanPrintf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n+    Printf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n+    Printf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n     Die();\n   }\n }\n #endif\n \n+#ifndef TSAN_GO\n void InitializeShadowMemory() {\n   uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n     kLinuxShadowEnd - kLinuxShadowBeg);\n   if (shadow != kLinuxShadowBeg) {\n-    TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n-    TsanPrintf(\"FATAL: Make sure to compile with -fPIE and \"\n+    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n                \"to link with -pie (%p, %p).\\n\", shadow, kLinuxShadowBeg);\n     Die();\n   }\n-#ifndef TSAN_GO\n   const uptr kClosedLowBeg  = 0x200000;\n   const uptr kClosedLowEnd  = kLinuxShadowBeg - 1;\n   const uptr kClosedMidBeg = kLinuxShadowEnd + 1;\n   const uptr kClosedMidEnd = kLinuxAppMemBeg - 1;\n   ProtectRange(kClosedLowBeg, kClosedLowEnd);\n   ProtectRange(kClosedMidBeg, kClosedMidEnd);\n-#endif\n-#ifndef TSAN_GO\n   DPrintf(\"kClosedLow   %zx-%zx (%zuGB)\\n\",\n       kClosedLowBeg, kClosedLowEnd, (kClosedLowEnd - kClosedLowBeg) >> 30);\n-#endif\n   DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n       kLinuxShadowBeg, kLinuxShadowEnd,\n       (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n-#ifndef TSAN_GO\n   DPrintf(\"kClosedMid   %zx-%zx (%zuGB)\\n\",\n       kClosedMidBeg, kClosedMidEnd, (kClosedMidEnd - kClosedMidBeg) >> 30);\n-#endif\n   DPrintf(\"kLinuxAppMem %zx-%zx (%zuGB)\\n\",\n       kLinuxAppMemBeg, kLinuxAppMemEnd,\n       (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n   DPrintf(\"stack        %zx\\n\", (uptr)&shadow);\n }\n+#endif\n \n static uptr g_data_start;\n static uptr g_data_end;\n@@ -133,10 +129,10 @@ static void CheckPIE() {\n   if (proc_maps.Next(&start, &end,\n                      /*offset*/0, /*filename*/0, /*filename_size*/0)) {\n     if ((u64)start < kLinuxAppMemBeg) {\n-      TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory (\"\n+      Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory (\"\n              \"something is mapped at 0x%zx < 0x%zx)\\n\",\n              start, kLinuxAppMemBeg);\n-      TsanPrintf(\"FATAL: Make sure to compile with -fPIE\"\n+      Printf(\"FATAL: Make sure to compile with -fPIE\"\n              \" and to link with -pie.\\n\");\n       Die();\n     }\n@@ -221,7 +217,7 @@ const char *InitializePlatform() {\n   g_tls_size = (uptr)InitTlsSize();\n   InitDataSeg();\n #endif\n-  return getenv(\"TSAN_OPTIONS\");\n+  return getenv(kTsanOptionsEnv);\n }\n \n void FinalizePlatform() {"}, {"sha": "808d99c0207f90a3e3523e3bd53db5147565df19", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -50,13 +50,14 @@ uptr GetShadowMemoryConsumption() {\n void FlushShadowMemory() {\n }\n \n+#ifndef TSAN_GO\n void InitializeShadowMemory() {\n   uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n     kLinuxShadowEnd - kLinuxShadowBeg);\n   if (shadow != kLinuxShadowBeg) {\n-    TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n-    TsanPrintf(\"FATAL: Make sure to compile with -fPIE and \"\n-               \"to link with -pie.\\n\");\n+    Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    Printf(\"FATAL: Make sure to compile with -fPIE and \"\n+           \"to link with -pie.\\n\");\n     Die();\n   }\n   DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n@@ -66,6 +67,7 @@ void InitializeShadowMemory() {\n       kLinuxAppMemBeg, kLinuxAppMemEnd,\n       (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n }\n+#endif\n \n const char *InitializePlatform() {\n   void *p = 0;\n@@ -78,7 +80,7 @@ const char *InitializePlatform() {\n     setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n   }\n \n-  return getenv(\"TSAN_OPTIONS\");\n+  return getenv(kTsanOptionsEnv);\n }\n \n void FinalizePlatform() {"}, {"sha": "74b9020d07744e626667fe8d1f72bd6ba562ce6d", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -0,0 +1,56 @@\n+//===-- tsan_platform_windows.cc ------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Windows-specific code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef _WIN32\n+\n+#include \"tsan_platform.h\"\n+\n+#include <stdlib.h>\n+\n+namespace __tsan {\n+\n+ScopedInRtl::ScopedInRtl() {\n+}\n+\n+ScopedInRtl::~ScopedInRtl() {\n+}\n+\n+uptr GetShadowMemoryConsumption() {\n+  return 0;\n+}\n+\n+void FlushShadowMemory() {\n+}\n+\n+const char *InitializePlatform() {\n+  return getenv(kTsanOptionsEnv);\n+}\n+\n+void FinalizePlatform() {\n+  fflush(0);\n+}\n+\n+uptr GetTlsSize() {\n+  return 0;\n+}\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+}\n+\n+}  // namespace __tsan\n+\n+#endif  // #ifdef _WIN32"}, {"sha": "982e2925dc3d98b52ee4b11dabc99adf509ce859", "filename": "libsanitizer/tsan/tsan_printf.cc", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ddf5c28ea6be09213739c94f9765019be476bb0/libsanitizer%2Ftsan%2Ftsan_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ddf5c28ea6be09213739c94f9765019be476bb0/libsanitizer%2Ftsan%2Ftsan_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_printf.cc?ref=8ddf5c28ea6be09213739c94f9765019be476bb0", "patch": "@@ -1,38 +0,0 @@\n-//===-- tsan_printf.cc ----------------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of ThreadSanitizer (TSan), a race detector.\n-//\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_common/sanitizer_common.h\"\n-#include \"sanitizer_common/sanitizer_libc.h\"\n-#include \"tsan_defs.h\"\n-#include \"tsan_mman.h\"\n-#include \"tsan_platform.h\"\n-\n-#include <stdarg.h>  // va_list\n-\n-namespace __sanitizer {\n-int VSNPrintf(char *buff, int buff_length, const char *format, va_list args);\n-}  // namespace __sanitizer\n-\n-namespace __tsan {\n-\n-void TsanPrintf(const char *format, ...) {\n-  ScopedInRtl in_rtl;\n-  const uptr kMaxLen = 16 * 1024;\n-  InternalScopedBuffer<char> buffer(kMaxLen);\n-  va_list args;\n-  va_start(args, format);\n-  uptr len = VSNPrintf(buffer.data(), buffer.size(), format, args);\n-  va_end(args);\n-  internal_write(CTX() ? flags()->log_fileno : 2,\n-      buffer.data(), len < buffer.size() ? len : buffer.size() - 1);\n-}\n-\n-}  // namespace __tsan"}, {"sha": "62e0b0c331422b20384b7626d32ee5ab2e66f24e", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -29,98 +29,102 @@ ReportDesc::~ReportDesc() {\n #ifndef TSAN_GO\n \n static void PrintHeader(ReportType typ) {\n-  TsanPrintf(\"WARNING: ThreadSanitizer: \");\n+  Printf(\"WARNING: ThreadSanitizer: \");\n \n   if (typ == ReportTypeRace)\n-    TsanPrintf(\"data race\");\n+    Printf(\"data race\");\n   else if (typ == ReportTypeUseAfterFree)\n-    TsanPrintf(\"heap-use-after-free\");\n+    Printf(\"heap-use-after-free\");\n   else if (typ == ReportTypeThreadLeak)\n-    TsanPrintf(\"thread leak\");\n+    Printf(\"thread leak\");\n   else if (typ == ReportTypeMutexDestroyLocked)\n-    TsanPrintf(\"destroy of a locked mutex\");\n+    Printf(\"destroy of a locked mutex\");\n   else if (typ == ReportTypeSignalUnsafe)\n-    TsanPrintf(\"signal-unsafe call inside of a signal\");\n+    Printf(\"signal-unsafe call inside of a signal\");\n   else if (typ == ReportTypeErrnoInSignal)\n-    TsanPrintf(\"signal handler spoils errno\");\n+    Printf(\"signal handler spoils errno\");\n \n-  TsanPrintf(\" (pid=%d)\\n\", GetPid());\n+  Printf(\" (pid=%d)\\n\", GetPid());\n }\n \n void PrintStack(const ReportStack *ent) {\n+  if (ent == 0) {\n+    Printf(\"    [failed to restore the stack]\\n\\n\");\n+    return;\n+  }\n   for (int i = 0; ent; ent = ent->next, i++) {\n-    TsanPrintf(\"    #%d %s %s:%d\", i, ent->func, ent->file, ent->line);\n+    Printf(\"    #%d %s %s:%d\", i, ent->func, ent->file, ent->line);\n     if (ent->col)\n-      TsanPrintf(\":%d\", ent->col);\n+      Printf(\":%d\", ent->col);\n     if (ent->module && ent->offset)\n-      TsanPrintf(\" (%s+%p)\\n\", ent->module, (void*)ent->offset);\n+      Printf(\" (%s+%p)\\n\", ent->module, (void*)ent->offset);\n     else\n-      TsanPrintf(\" (%p)\\n\", (void*)ent->pc);\n+      Printf(\" (%p)\\n\", (void*)ent->pc);\n   }\n-  TsanPrintf(\"\\n\");\n+  Printf(\"\\n\");\n }\n \n static void PrintMop(const ReportMop *mop, bool first) {\n-  TsanPrintf(\"  %s of size %d at %p\",\n+  Printf(\"  %s of size %d at %p\",\n       (first ? (mop->write ? \"Write\" : \"Read\")\n              : (mop->write ? \"Previous write\" : \"Previous read\")),\n       mop->size, (void*)mop->addr);\n   if (mop->tid == 0)\n-    TsanPrintf(\" by main thread:\\n\");\n+    Printf(\" by main thread:\\n\");\n   else\n-    TsanPrintf(\" by thread %d:\\n\", mop->tid);\n+    Printf(\" by thread %d:\\n\", mop->tid);\n   PrintStack(mop->stack);\n }\n \n static void PrintLocation(const ReportLocation *loc) {\n   if (loc->type == ReportLocationGlobal) {\n-    TsanPrintf(\"  Location is global '%s' of size %zu at %zx %s:%d\\n\",\n+    Printf(\"  Location is global '%s' of size %zu at %zx %s:%d\\n\",\n                loc->name, loc->size, loc->addr, loc->file, loc->line);\n   } else if (loc->type == ReportLocationHeap) {\n-    TsanPrintf(\"  Location is heap block of size %zu at %p allocated\",\n+    Printf(\"  Location is heap block of size %zu at %p allocated\",\n         loc->size, loc->addr);\n     if (loc->tid == 0)\n-      TsanPrintf(\" by main thread:\\n\");\n+      Printf(\" by main thread:\\n\");\n     else\n-      TsanPrintf(\" by thread %d:\\n\", loc->tid);\n+      Printf(\" by thread %d:\\n\", loc->tid);\n     PrintStack(loc->stack);\n   } else if (loc->type == ReportLocationStack) {\n-    TsanPrintf(\"  Location is stack of thread %d:\\n\", loc->tid);\n+    Printf(\"  Location is stack of thread %d:\\n\", loc->tid);\n   }\n }\n \n static void PrintMutex(const ReportMutex *rm) {\n   if (rm->stack == 0)\n     return;\n-  TsanPrintf(\"  Mutex %d created at:\\n\", rm->id);\n+  Printf(\"  Mutex %d created at:\\n\", rm->id);\n   PrintStack(rm->stack);\n }\n \n static void PrintThread(const ReportThread *rt) {\n   if (rt->id == 0)  // Little sense in describing the main thread.\n     return;\n-  TsanPrintf(\"  Thread %d\", rt->id);\n+  Printf(\"  Thread %d\", rt->id);\n   if (rt->name)\n-    TsanPrintf(\" '%s'\", rt->name);\n-  TsanPrintf(\" (tid=%zu, %s)\", rt->pid, rt->running ? \"running\" : \"finished\");\n+    Printf(\" '%s'\", rt->name);\n+  Printf(\" (tid=%zu, %s)\", rt->pid, rt->running ? \"running\" : \"finished\");\n   if (rt->stack)\n-    TsanPrintf(\" created at:\");\n-  TsanPrintf(\"\\n\");\n+    Printf(\" created at:\");\n+  Printf(\"\\n\");\n   PrintStack(rt->stack);\n }\n \n static void PrintSleep(const ReportStack *s) {\n-  TsanPrintf(\"  As if synchronized via sleep:\\n\");\n+  Printf(\"  As if synchronized via sleep:\\n\");\n   PrintStack(s);\n }\n \n void PrintReport(const ReportDesc *rep) {\n-  TsanPrintf(\"==================\\n\");\n+  Printf(\"==================\\n\");\n   PrintHeader(rep->typ);\n \n   for (uptr i = 0; i < rep->stacks.Size(); i++) {\n     if (i)\n-      TsanPrintf(\"  and:\\n\");\n+      Printf(\"  and:\\n\");\n     PrintStack(rep->stacks[i]);\n   }\n \n@@ -139,21 +143,21 @@ void PrintReport(const ReportDesc *rep) {\n   for (uptr i = 0; i < rep->threads.Size(); i++)\n     PrintThread(rep->threads[i]);\n \n-  TsanPrintf(\"==================\\n\");\n+  Printf(\"==================\\n\");\n }\n \n #else\n \n void PrintStack(const ReportStack *ent) {\n   for (int i = 0; ent; ent = ent->next, i++) {\n-    TsanPrintf(\"  %s()\\n      %s:%d +0x%zx\\n\",\n+    Printf(\"  %s()\\n      %s:%d +0x%zx\\n\",\n         ent->func, ent->file, ent->line, (void*)ent->offset);\n   }\n-  TsanPrintf(\"\\n\");\n+  Printf(\"\\n\");\n }\n \n static void PrintMop(const ReportMop *mop, bool first) {\n-  TsanPrintf(\"%s by goroutine %d:\\n\",\n+  Printf(\"%s by goroutine %d:\\n\",\n       (first ? (mop->write ? \"Write\" : \"Read\")\n              : (mop->write ? \"Previous write\" : \"Previous read\")),\n       mop->tid);\n@@ -163,19 +167,19 @@ static void PrintMop(const ReportMop *mop, bool first) {\n static void PrintThread(const ReportThread *rt) {\n   if (rt->id == 0)  // Little sense in describing the main thread.\n     return;\n-  TsanPrintf(\"Goroutine %d (%s) created at:\\n\",\n+  Printf(\"Goroutine %d (%s) created at:\\n\",\n     rt->id, rt->running ? \"running\" : \"finished\");\n   PrintStack(rt->stack);\n }\n \n void PrintReport(const ReportDesc *rep) {\n-  TsanPrintf(\"==================\\n\");\n-  TsanPrintf(\"WARNING: DATA RACE\\n\");\n+  Printf(\"==================\\n\");\n+  Printf(\"WARNING: DATA RACE\\n\");\n   for (uptr i = 0; i < rep->mops.Size(); i++)\n     PrintMop(rep->mops[i], i == 0);\n   for (uptr i = 0; i < rep->threads.Size(); i++)\n     PrintThread(rep->threads[i]);\n-  TsanPrintf(\"==================\\n\");\n+  Printf(\"==================\\n\");\n }\n \n #endif"}, {"sha": "a3e82710d901e2657d704a4ff641e5194de1b231", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -137,7 +137,7 @@ static void InitializeMemoryProfile() {\n       flags()->profile_memory, GetPid());\n   fd_t fd = internal_open(filename.data(), true);\n   if (fd == kInvalidFd) {\n-    TsanPrintf(\"Failed to open memory profile file '%s'\\n\", &filename[0]);\n+    Printf(\"Failed to open memory profile file '%s'\\n\", &filename[0]);\n     Die();\n   }\n   internal_start_thread(&MemoryProfileThread, (void*)(uptr)fd);\n@@ -159,6 +159,10 @@ static void InitializeMemoryFlush() {\n   internal_start_thread(&MemoryFlushThread, 0);\n }\n \n+void MapShadow(uptr addr, uptr size) {\n+  MmapFixedNoReserve(MemToShadow(addr), size * kShadowMultiplier);\n+}\n+\n void Initialize(ThreadState *thr) {\n   // Thread safe because done before all threads exist.\n   static bool is_initialized = false;\n@@ -177,24 +181,32 @@ void Initialize(ThreadState *thr) {\n   InitializeMutex();\n   InitializeDynamicAnnotations();\n   ctx = new(ctx_placeholder) Context;\n+#ifndef TSAN_GO\n   InitializeShadowMemory();\n+#endif\n   ctx->dead_list_size = 0;\n   ctx->dead_list_head = 0;\n   ctx->dead_list_tail = 0;\n   InitializeFlags(&ctx->flags, env);\n+  // Setup correct file descriptor for error reports.\n+  __sanitizer_set_report_fd(flags()->log_fileno);\n   InitializeSuppressions();\n #ifndef TSAN_GO\n   // Initialize external symbolizer before internal threads are started.\n   const char *external_symbolizer = flags()->external_symbolizer_path;\n   if (external_symbolizer != 0 && external_symbolizer[0] != '\\0') {\n-    InitializeExternalSymbolizer(external_symbolizer);\n+    if (!InitializeExternalSymbolizer(external_symbolizer)) {\n+      Printf(\"Failed to start external symbolizer: '%s'\\n\",\n+             external_symbolizer);\n+      Die();\n+    }\n   }\n #endif\n   InitializeMemoryProfile();\n   InitializeMemoryFlush();\n \n   if (ctx->flags.verbosity)\n-    TsanPrintf(\"***** Running under ThreadSanitizer v2 (pid %d) *****\\n\",\n+    Printf(\"***** Running under ThreadSanitizer v2 (pid %d) *****\\n\",\n                GetPid());\n \n   // Initialize thread 0.\n@@ -206,7 +218,7 @@ void Initialize(ThreadState *thr) {\n   ctx->initialized = true;\n \n   if (flags()->stop_on_start) {\n-    TsanPrintf(\"ThreadSanitizer is suspended at startup (pid %d).\"\n+    Printf(\"ThreadSanitizer is suspended at startup (pid %d).\"\n            \" Call __tsan_resume().\\n\",\n            GetPid());\n     while (__tsan_resumed == 0);\n@@ -218,6 +230,9 @@ int Finalize(ThreadState *thr) {\n   Context *ctx = __tsan::ctx;\n   bool failed = false;\n \n+  if (flags()->atexit_sleep_ms > 0 && ThreadCount(thr) > 1)\n+    SleepForMillis(flags()->atexit_sleep_ms);\n+\n   // Wait for pending reports.\n   ctx->report_mtx.Lock();\n   ctx->report_mtx.Unlock();\n@@ -226,15 +241,20 @@ int Finalize(ThreadState *thr) {\n \n   if (ctx->nreported) {\n     failed = true;\n-    TsanPrintf(\"ThreadSanitizer: reported %d warnings\\n\", ctx->nreported);\n+#ifndef TSAN_GO\n+    Printf(\"ThreadSanitizer: reported %d warnings\\n\", ctx->nreported);\n+#else\n+    Printf(\"Found %d data race(s)\\n\", ctx->nreported);\n+#endif\n   }\n \n   if (ctx->nmissed_expected) {\n     failed = true;\n-    TsanPrintf(\"ThreadSanitizer: missed %d expected races\\n\",\n+    Printf(\"ThreadSanitizer: missed %d expected races\\n\",\n         ctx->nmissed_expected);\n   }\n \n+  StatAggregate(ctx->stat, thr->stat);\n   StatOutput(ctx->stat);\n   return failed ? flags()->exitcode : 0;\n }\n@@ -298,18 +318,22 @@ static inline void HandleRace(ThreadState *thr, u64 *shadow_mem,\n   thr->racy_state[0] = cur.raw();\n   thr->racy_state[1] = old.raw();\n   thr->racy_shadow_addr = shadow_mem;\n+#ifndef TSAN_GO\n+  HACKY_CALL(__tsan_report_race);\n+#else\n   ReportRace(thr);\n+#endif\n }\n \n static inline bool BothReads(Shadow s, int kAccessIsWrite) {\n   return !kAccessIsWrite && !s.is_write();\n }\n \n-static inline bool OldIsRWStronger(Shadow old, int kAccessIsWrite) {\n+static inline bool OldIsRWNotWeaker(Shadow old, int kAccessIsWrite) {\n   return old.is_write() || !kAccessIsWrite;\n }\n \n-static inline bool OldIsRWWeaker(Shadow old, int kAccessIsWrite) {\n+static inline bool OldIsRWWeakerOrEqual(Shadow old, int kAccessIsWrite) {\n   return !old.is_write() || kAccessIsWrite;\n }\n \n@@ -323,7 +347,7 @@ static inline bool HappensBefore(Shadow old, ThreadState *thr) {\n \n ALWAYS_INLINE\n void MemoryAccessImpl(ThreadState *thr, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite, FastState fast_state,\n+    int kAccessSizeLog, bool kAccessIsWrite,\n     u64 *shadow_mem, Shadow cur) {\n   StatInc(thr, StatMop);\n   StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n@@ -407,11 +431,11 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n       (uptr)shadow_mem[2], (uptr)shadow_mem[3]);\n #if TSAN_DEBUG\n   if (!IsAppMem(addr)) {\n-    TsanPrintf(\"Access to non app mem %zx\\n\", addr);\n+    Printf(\"Access to non app mem %zx\\n\", addr);\n     DCHECK(IsAppMem(addr));\n   }\n   if (!IsShadowMem((uptr)shadow_mem)) {\n-    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n+    Printf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n     DCHECK(IsShadowMem((uptr)shadow_mem));\n   }\n #endif\n@@ -429,7 +453,7 @@ void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n   // That is, this call must be moved somewhere below.\n   TraceAddEvent(thr, fast_state.epoch(), EventTypeMop, pc);\n \n-  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite, fast_state,\n+  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite,\n       shadow_mem, cur);\n }\n \n@@ -491,6 +515,7 @@ void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n   MemoryRangeSet(thr, pc, addr, size, s.raw());\n }\n \n+ALWAYS_INLINE\n void FuncEntry(ThreadState *thr, uptr pc) {\n   DCHECK_EQ(thr->in_rtl, 0);\n   StatInc(thr, StatFuncEnter);\n@@ -520,6 +545,7 @@ void FuncEntry(ThreadState *thr, uptr pc) {\n   thr->shadow_stack_pos++;\n }\n \n+ALWAYS_INLINE\n void FuncExit(ThreadState *thr) {\n   DCHECK_EQ(thr->in_rtl, 0);\n   StatInc(thr, StatFuncExit);"}, {"sha": "de357a5d5a0e86125ec32aaf209e618e42cdff15", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -25,11 +25,7 @@\n #define TSAN_RTL_H\n \n #include \"sanitizer_common/sanitizer_common.h\"\n-#if __WORDSIZE == 64\n #include \"sanitizer_common/sanitizer_allocator64.h\"\n-#else\n-#include \"sanitizer_common/sanitizer_allocator.h\"\n-#endif\n #include \"tsan_clock.h\"\n #include \"tsan_defs.h\"\n #include \"tsan_flags.h\"\n@@ -69,7 +65,6 @@ Allocator *allocator();\n \n void TsanCheckFailed(const char *file, int line, const char *cond,\n                      u64 v1, u64 v2);\n-void TsanPrintf(const char *format, ...);\n \n // FastState (from most significant bit):\n //   unused          : 1\n@@ -234,10 +229,6 @@ class Shadow : public FastState {\n   }\n };\n \n-// Freed memory.\n-// As if 8-byte write by thread 0xff..f at epoch 0xff..f, races with everything.\n-const u64 kShadowFreed = 0xfffffffffffffff8ull;\n-\n struct SignalContext;\n \n // This struct is stored in TLS.\n@@ -442,6 +433,7 @@ void ALWAYS_INLINE INLINE StatInc(ThreadState *thr, StatType typ, u64 n = 1) {\n     thr->stat[typ] += n;\n }\n \n+void MapShadow(uptr addr, uptr size);\n void InitializeShadowMemory();\n void InitializeInterceptors();\n void InitializeDynamicAnnotations();\n@@ -456,13 +448,13 @@ bool IsFiredSuppression(Context *ctx,\n bool IsExpectedReport(uptr addr, uptr size);\n \n #if defined(TSAN_DEBUG_OUTPUT) && TSAN_DEBUG_OUTPUT >= 1\n-# define DPrintf TsanPrintf\n+# define DPrintf Printf\n #else\n # define DPrintf(...)\n #endif\n \n #if defined(TSAN_DEBUG_OUTPUT) && TSAN_DEBUG_OUTPUT >= 2\n-# define DPrintf2 TsanPrintf\n+# define DPrintf2 Printf\n #else\n # define DPrintf2(...)\n #endif\n@@ -476,7 +468,7 @@ int Finalize(ThreadState *thr);\n void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n     int kAccessSizeLog, bool kAccessIsWrite);\n void MemoryAccessImpl(ThreadState *thr, uptr addr,\n-    int kAccessSizeLog, bool kAccessIsWrite, FastState fast_state,\n+    int kAccessSizeLog, bool kAccessIsWrite,\n     u64 *shadow_mem, Shadow cur);\n void MemoryRead1Byte(ThreadState *thr, uptr pc, uptr addr);\n void MemoryWrite1Byte(ThreadState *thr, uptr pc, uptr addr);\n@@ -499,7 +491,8 @@ int ThreadTid(ThreadState *thr, uptr pc, uptr uid);\n void ThreadJoin(ThreadState *thr, uptr pc, int tid);\n void ThreadDetach(ThreadState *thr, uptr pc, int tid);\n void ThreadFinalize(ThreadState *thr);\n-void ThreadFinalizerGoroutine(ThreadState *thr);\n+int ThreadCount(ThreadState *thr);\n+void ProcessPendingSignals(ThreadState *thr);\n \n void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n                  bool rw, bool recursive, bool linker_init);\n@@ -511,6 +504,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr);\n void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr);\n \n void Acquire(ThreadState *thr, uptr pc, uptr addr);\n+void AcquireGlobal(ThreadState *thr, uptr pc);\n void Release(ThreadState *thr, uptr pc, uptr addr);\n void ReleaseStore(ThreadState *thr, uptr pc, uptr addr);\n void AfterSleep(ThreadState *thr, uptr pc);\n@@ -521,7 +515,7 @@ void AfterSleep(ThreadState *thr, uptr pc);\n // The trick is that the call preserves all registers and the compiler\n // does not treat it as a call.\n // If it does not work for you, use normal call.\n-#if TSAN_DEBUG == 0\n+#if 0 && TSAN_DEBUG == 0\n // The caller may not create the stack frame for itself at all,\n // so we create a reserve stack frame for it (1024b must be enough).\n #define HACKY_CALL(f) \\\n@@ -542,7 +536,11 @@ void ALWAYS_INLINE INLINE TraceAddEvent(ThreadState *thr, u64 epoch,\n                                         EventType typ, uptr addr) {\n   StatInc(thr, StatEvents);\n   if (UNLIKELY((epoch % kTracePartSize) == 0)) {\n+#ifndef TSAN_GO\n+    HACKY_CALL(__tsan_trace_switch);\n+#else\n     TraceSwitch(thr);\n+#endif\n   }\n   Event *evp = &thr->trace.events[epoch % kTraceSize];\n   Event ev = (u64)addr | ((u64)typ << 61);"}, {"sha": "9ace430bc586234a68d72f1b07ff142ed4197a92", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -82,7 +82,7 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr) {\n   } else if (s->owner_tid == thr->tid) {\n     CHECK_GT(s->recursion, 0);\n   } else {\n-    TsanPrintf(\"ThreadSanitizer WARNING: double lock\\n\");\n+    Printf(\"ThreadSanitizer WARNING: double lock\\n\");\n     PrintCurrentStack(thr, pc);\n   }\n   if (s->recursion == 0) {\n@@ -110,13 +110,13 @@ void MutexUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   if (s->recursion == 0) {\n     if (!s->is_broken) {\n       s->is_broken = true;\n-      TsanPrintf(\"ThreadSanitizer WARNING: unlock of unlocked mutex\\n\");\n+      Printf(\"ThreadSanitizer WARNING: unlock of unlocked mutex\\n\");\n       PrintCurrentStack(thr, pc);\n     }\n   } else if (s->owner_tid != thr->tid) {\n     if (!s->is_broken) {\n       s->is_broken = true;\n-      TsanPrintf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n+      Printf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n       PrintCurrentStack(thr, pc);\n     }\n   } else {\n@@ -145,7 +145,7 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr) {\n   TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRLock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, false);\n   if (s->owner_tid != SyncVar::kInvalidTid) {\n-    TsanPrintf(\"ThreadSanitizer WARNING: read lock of a write locked mutex\\n\");\n+    Printf(\"ThreadSanitizer WARNING: read lock of a write locked mutex\\n\");\n     PrintCurrentStack(thr, pc);\n   }\n   thr->clock.set(thr->tid, thr->fast_state.epoch());\n@@ -165,7 +165,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRUnlock, addr);\n   SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n   if (s->owner_tid != SyncVar::kInvalidTid) {\n-    TsanPrintf(\"ThreadSanitizer WARNING: read unlock of a write \"\n+    Printf(\"ThreadSanitizer WARNING: read unlock of a write \"\n                \"locked mutex\\n\");\n     PrintCurrentStack(thr, pc);\n   }\n@@ -213,7 +213,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     }\n   } else if (!s->is_broken) {\n     s->is_broken = true;\n-    TsanPrintf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n+    Printf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n     PrintCurrentStack(thr, pc);\n   }\n   s->mtx.Unlock();\n@@ -229,6 +229,20 @@ void Acquire(ThreadState *thr, uptr pc, uptr addr) {\n   s->mtx.ReadUnlock();\n }\n \n+void AcquireGlobal(ThreadState *thr, uptr pc) {\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = ctx->threads[i];\n+    if (tctx == 0)\n+      continue;\n+    if (tctx->status == ThreadStatusRunning)\n+      thr->clock.set(i, tctx->thr->fast_state.epoch());\n+    else\n+      thr->clock.set(i, tctx->epoch1);\n+  }\n+}\n+\n void Release(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: Release %zx\\n\", thr->tid, addr);"}, {"sha": "24e29d25400c1dcbbdb48d1844668a2c87d89b02", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -26,9 +26,9 @@ namespace __tsan {\n void TsanCheckFailed(const char *file, int line, const char *cond,\n                      u64 v1, u64 v2) {\n   ScopedInRtl in_rtl;\n-  TsanPrintf(\"FATAL: ThreadSanitizer CHECK failed: \"\n-             \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n-             file, line, cond, (uptr)v1, (uptr)v2);\n+  Printf(\"FATAL: ThreadSanitizer CHECK failed: \"\n+         \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n+         file, line, cond, (uptr)v1, (uptr)v2);\n   Die();\n }\n \n@@ -383,6 +383,8 @@ bool IsFiredSuppression(Context *ctx,\n }\n \n void ReportRace(ThreadState *thr) {\n+  if (!flags()->report_bugs)\n+    return;\n   ScopedInRtl in_rtl;\n \n   bool freed = false;"}, {"sha": "bb7f35c24ed41eb97ae510b5ba8f0d331b40cec9", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -50,6 +50,23 @@ void ThreadFinalize(ThreadState *thr) {\n   }\n }\n \n+int ThreadCount(ThreadState *thr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  int cnt = 0;\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = ctx->threads[i];\n+    if (tctx == 0)\n+      continue;\n+    if (tctx->status != ThreadStatusCreated\n+        && tctx->status != ThreadStatusRunning)\n+      continue;\n+    cnt++;\n+  }\n+  return cnt;\n+}\n+\n static void ThreadDead(ThreadState *thr, ThreadContext *tctx) {\n   Context *ctx = CTX();\n   CHECK_GT(thr->in_rtl, 0);\n@@ -80,7 +97,7 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n   if (ctx->dead_list_size > kThreadQuarantineSize\n       || ctx->thread_seq >= kMaxTid) {\n     if (ctx->dead_list_size == 0) {\n-      TsanPrintf(\"ThreadSanitizer: %d thread limit exceeded. Dying.\\n\",\n+      Printf(\"ThreadSanitizer: %d thread limit exceeded. Dying.\\n\",\n                  kMaxTid);\n       Die();\n     }\n@@ -273,7 +290,7 @@ void ThreadJoin(ThreadState *thr, uptr pc, int tid) {\n   Lock l(&ctx->thread_mtx);\n   ThreadContext *tctx = ctx->threads[tid];\n   if (tctx->status == ThreadStatusInvalid) {\n-    TsanPrintf(\"ThreadSanitizer: join of non-existent thread\\n\");\n+    Printf(\"ThreadSanitizer: join of non-existent thread\\n\");\n     return;\n   }\n   CHECK_EQ(tctx->detached, false);\n@@ -291,7 +308,7 @@ void ThreadDetach(ThreadState *thr, uptr pc, int tid) {\n   Lock l(&ctx->thread_mtx);\n   ThreadContext *tctx = ctx->threads[tid];\n   if (tctx->status == ThreadStatusInvalid) {\n-    TsanPrintf(\"ThreadSanitizer: detach of non-existent thread\\n\");\n+    Printf(\"ThreadSanitizer: detach of non-existent thread\\n\");\n     return;\n   }\n   if (tctx->status == ThreadStatusFinished) {\n@@ -301,10 +318,6 @@ void ThreadDetach(ThreadState *thr, uptr pc, int tid) {\n   }\n }\n \n-void ThreadFinalizerGoroutine(ThreadState *thr) {\n-  thr->clock.Disable(thr->tid);\n-}\n-\n void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n                        uptr size, bool is_write) {\n   if (size == 0)\n@@ -317,19 +330,19 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n \n #if TSAN_DEBUG\n   if (!IsAppMem(addr)) {\n-    TsanPrintf(\"Access to non app mem %zx\\n\", addr);\n+    Printf(\"Access to non app mem %zx\\n\", addr);\n     DCHECK(IsAppMem(addr));\n   }\n   if (!IsAppMem(addr + size - 1)) {\n-    TsanPrintf(\"Access to non app mem %zx\\n\", addr + size - 1);\n+    Printf(\"Access to non app mem %zx\\n\", addr + size - 1);\n     DCHECK(IsAppMem(addr + size - 1));\n   }\n   if (!IsShadowMem((uptr)shadow_mem)) {\n-    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n+    Printf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n     DCHECK(IsShadowMem((uptr)shadow_mem));\n   }\n   if (!IsShadowMem((uptr)(shadow_mem + size * kShadowCnt / 8 - 1))) {\n-    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\",\n+    Printf(\"Bad shadow addr %p (%zx)\\n\",\n                shadow_mem + size * kShadowCnt / 8 - 1, addr + size - 1);\n     DCHECK(IsShadowMem((uptr)(shadow_mem + size * kShadowCnt / 8 - 1)));\n   }\n@@ -353,7 +366,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n         shadow_mem, cur);\n   }\n   if (unaligned)\n@@ -364,7 +377,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(0, kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n         shadow_mem, cur);\n     shadow_mem += kShadowCnt;\n   }\n@@ -374,7 +387,7 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     Shadow cur(fast_state);\n     cur.SetWrite(is_write);\n     cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n-    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write,\n         shadow_mem, cur);\n   }\n }"}, {"sha": "68acae81e666f5a53090d7337958ed61404a5bf1", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -194,7 +194,12 @@ void StatOutput(u64 *stat) {\n   name[StatInt_opendir]                  = \"  opendir                         \";\n   name[StatInt_epoll_ctl]                = \"  epoll_ctl                       \";\n   name[StatInt_epoll_wait]               = \"  epoll_wait                      \";\n+  name[StatInt_poll]                     = \"  poll                            \";\n   name[StatInt_sigaction]                = \"  sigaction                       \";\n+  name[StatInt_sleep]                    = \"  sleep                           \";\n+  name[StatInt_usleep]                   = \"  usleep                          \";\n+  name[StatInt_nanosleep]                = \"  nanosleep                       \";\n+  name[StatInt_gettimeofday]             = \"  gettimeofday                    \";\n \n   name[StatAnnotation]                   = \"Dynamic annotations               \";\n   name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";\n@@ -239,9 +244,9 @@ void StatOutput(u64 *stat) {\n   name[StatMtxAtExit]                    = \"  Atexit                          \";\n   name[StatMtxAnnotations]               = \"  Annotations                     \";\n \n-  TsanPrintf(\"Statistics:\\n\");\n+  Printf(\"Statistics:\\n\");\n   for (int i = 0; i < StatCnt; i++)\n-    TsanPrintf(\"%s: %zu\\n\", name[i], (uptr)stat[i]);\n+    Printf(\"%s: %zu\\n\", name[i], (uptr)stat[i]);\n }\n \n }  // namespace __tsan"}, {"sha": "25bff8b7080b92dd7e672c803a4e66d02840485f", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -193,6 +193,7 @@ enum StatType {\n   StatInt_opendir,\n   StatInt_epoll_ctl,\n   StatInt_epoll_wait,\n+  StatInt_poll,\n   StatInt_sigaction,\n   StatInt_signal,\n   StatInt_raise,\n@@ -201,6 +202,7 @@ enum StatType {\n   StatInt_sleep,\n   StatInt_usleep,\n   StatInt_nanosleep,\n+  StatInt_gettimeofday,\n \n   // Dynamic annotations.\n   StatAnnotation,"}, {"sha": "3f825a804a13eface726efce33bdf671cf8202c3", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -31,19 +31,19 @@ static char *ReadFile(const char *filename) {\n     internal_snprintf(tmp.data(), tmp.size(), \"%s/%s\", GetPwd(), filename);\n   fd_t fd = internal_open(tmp.data(), false);\n   if (fd == kInvalidFd) {\n-    TsanPrintf(\"ThreadSanitizer: failed to open suppressions file '%s'\\n\",\n+    Printf(\"ThreadSanitizer: failed to open suppressions file '%s'\\n\",\n                tmp.data());\n     Die();\n   }\n   const uptr fsize = internal_filesize(fd);\n   if (fsize == (uptr)-1) {\n-    TsanPrintf(\"ThreadSanitizer: failed to stat suppressions file '%s'\\n\",\n+    Printf(\"ThreadSanitizer: failed to stat suppressions file '%s'\\n\",\n                tmp.data());\n     Die();\n   }\n   char *buf = (char*)internal_alloc(MBlockSuppression, fsize + 1);\n   if (fsize != internal_read(fd, buf, fsize)) {\n-    TsanPrintf(\"ThreadSanitizer: failed to read suppressions file '%s'\\n\",\n+    Printf(\"ThreadSanitizer: failed to read suppressions file '%s'\\n\",\n                tmp.data());\n     Die();\n   }\n@@ -108,7 +108,7 @@ Suppression *SuppressionParse(const char* supp) {\n         stype = SuppressionSignal;\n         line += sizeof(\"signal:\") - 1;\n       } else {\n-        TsanPrintf(\"ThreadSanitizer: failed to parse suppressions file\\n\");\n+        Printf(\"ThreadSanitizer: failed to parse suppressions file\\n\");\n         Die();\n       }\n       Suppression *s = (Suppression*)internal_alloc(MBlockSuppression,"}, {"sha": "23540c07ca937fb99a79ca7fc6162a7913f67fe1", "filename": "libsanitizer/tsan/tsan_symbolize_addr2line_linux.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -48,17 +48,17 @@ struct DlIteratePhdrCtx {\n static void NOINLINE InitModule(ModuleDesc *m) {\n   int outfd[2] = {};\n   if (pipe(&outfd[0])) {\n-    TsanPrintf(\"ThreadSanitizer: outfd pipe() failed (%d)\\n\", errno);\n+    Printf(\"ThreadSanitizer: outfd pipe() failed (%d)\\n\", errno);\n     Die();\n   }\n   int infd[2] = {};\n   if (pipe(&infd[0])) {\n-    TsanPrintf(\"ThreadSanitizer: infd pipe() failed (%d)\\n\", errno);\n+    Printf(\"ThreadSanitizer: infd pipe() failed (%d)\\n\", errno);\n     Die();\n   }\n   int pid = fork();\n   if (pid == 0) {\n-    flags()->log_fileno = STDERR_FILENO;\n+    __sanitizer_set_report_fd(STDERR_FILENO);\n     internal_close(STDOUT_FILENO);\n     internal_close(STDIN_FILENO);\n     internal_dup2(outfd[0], STDIN_FILENO);\n@@ -72,7 +72,7 @@ static void NOINLINE InitModule(ModuleDesc *m) {\n     execl(\"/usr/bin/addr2line\", \"/usr/bin/addr2line\", \"-Cfe\", m->fullname, 0);\n     _exit(0);\n   } else if (pid < 0) {\n-    TsanPrintf(\"ThreadSanitizer: failed to fork symbolizer\\n\");\n+    Printf(\"ThreadSanitizer: failed to fork symbolizer\\n\");\n     Die();\n   }\n   internal_close(outfd[0]);\n@@ -153,14 +153,14 @@ ReportStack *SymbolizeCodeAddr2Line(uptr addr) {\n   char addrstr[32];\n   internal_snprintf(addrstr, sizeof(addrstr), \"%p\\n\", (void*)offset);\n   if (0 >= internal_write(m->out_fd, addrstr, internal_strlen(addrstr))) {\n-    TsanPrintf(\"ThreadSanitizer: can't write from symbolizer (%d, %d)\\n\",\n+    Printf(\"ThreadSanitizer: can't write from symbolizer (%d, %d)\\n\",\n         m->out_fd, errno);\n     Die();\n   }\n   InternalScopedBuffer<char> func(1024);\n   ssize_t len = internal_read(m->inp_fd, func.data(), func.size() - 1);\n   if (len <= 0) {\n-    TsanPrintf(\"ThreadSanitizer: can't read from symbolizer (%d, %d)\\n\",\n+    Printf(\"ThreadSanitizer: can't read from symbolizer (%d, %d)\\n\",\n         m->inp_fd, errno);\n     Die();\n   }"}, {"sha": "e22859c1ddeb6e80184f2143c3b82b0e23319eed", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e297eb600dd52acd73fb64ca45905b68f4e9b99b/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=e297eb600dd52acd73fb64ca45905b68f4e9b99b", "patch": "@@ -32,7 +32,7 @@ do {\n     if (Shadow::TidsAreEqual(old, cur)) {\n       StatInc(thr, StatShadowSameThread);\n       if (OldIsInSameSynchEpoch(old, thr)) {\n-        if (OldIsRWStronger(old, kAccessIsWrite)) {\n+        if (OldIsRWNotWeaker(old, kAccessIsWrite)) {\n           // found a slot that holds effectively the same info\n           // (that is, same tid, same sync epoch and same size)\n           StatInc(thr, StatMopSame);\n@@ -41,7 +41,7 @@ do {\n         StoreIfNotYetStored(sp, &store_word);\n         break;\n       }\n-      if (OldIsRWWeaker(old, kAccessIsWrite))\n+      if (OldIsRWWeakerOrEqual(old, kAccessIsWrite))\n         StoreIfNotYetStored(sp, &store_word);\n       break;\n     }"}]}