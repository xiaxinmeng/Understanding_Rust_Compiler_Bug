{"sha": "74d6b8ca6307ef057ba438f785f46eb9c911b184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkNmI4Y2E2MzA3ZWYwNTdiYTQzOGY3ODVmNDZlYjljOTExYjE4NA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@nerim.net", "date": "2002-08-02T18:10:38Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-08-02T18:10:38Z"}, "message": "valarray_meta.h (_UnFunBase<>): Remove.\n\n\t* include/bits/valarray_meta.h (_UnFunBase<>): Remove.\n\t(_UnFunClos<>): Same.\n\t(_UnBase<>): Reformat.  Make first template-parameter non\n\ttemplate.\n\t(_UnClos<>): Likewise.\n\t(_Expr<>): Reformate.  Adjust unary member operator return types.\n\t(_DEFINE_EXPR_UNARY_OPERATOR): Adjust definition.\n\t(_DEFINE_EXPR_UNARY_FUNCTION): Likewise.\n\t* include/std/std_valarray.h (_UnClos<>): Adjust declaration.\n\t(valarray<>::_UnaryOp<>):  New nested traits. Adjust unary member\n\toperator return types.  Reformat.\n\t(_Bitwise_not): Remove.\n\t(_DEFINE_VALARRAY_UNARY_OPERATOR): Adjust definition.\n\t* testsuite/26_numerics/valarray_name_lookup.C: New test.\n\nFrom-SVN: r55993", "tree": {"sha": "118bc7dda1e54abb95e3fce4fd92719b6411fa9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/118bc7dda1e54abb95e3fce4fd92719b6411fa9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74d6b8ca6307ef057ba438f785f46eb9c911b184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d6b8ca6307ef057ba438f785f46eb9c911b184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d6b8ca6307ef057ba438f785f46eb9c911b184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d6b8ca6307ef057ba438f785f46eb9c911b184/comments", "author": null, "committer": null, "parents": [{"sha": "41ab2ae207ddb60bb5b4966b6f45cc3f0017ba2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41ab2ae207ddb60bb5b4966b6f45cc3f0017ba2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41ab2ae207ddb60bb5b4966b6f45cc3f0017ba2d"}], "stats": {"total": 989, "additions": 551, "deletions": 438}, "files": [{"sha": "777f5e98ef83322b6731e81055822091c2cdaea8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=74d6b8ca6307ef057ba438f785f46eb9c911b184", "patch": "@@ -1,3 +1,20 @@\n+2002-08-02  Gabriel Dos Reis  <gdr@nerim.net>\n+\n+\t* include/bits/valarray_meta.h (_UnFunBase<>): Remove.\n+\t(_UnFunClos<>): Same.\n+\t(_UnBase<>): Reformat.  Make first template-parameter non\n+\ttemplate. \n+\t(_UnClos<>): Likewise.\n+\t(_Expr<>): Reformate.  Adjust unary member operator return types. \n+\t(_DEFINE_EXPR_UNARY_OPERATOR): Adjust definition.\n+\t(_DEFINE_EXPR_UNARY_FUNCTION): Likewise.\n+\t* include/std/std_valarray.h (_UnClos<>): Adjust declaration.\n+\t(valarray<>::_UnaryOp<>):  New nested traits. Adjust unary member\n+\toperator return types.  Reformat.\n+\t(_Bitwise_not): Remove.\n+\t(_DEFINE_VALARRAY_UNARY_OPERATOR): Adjust definition.\n+\t* testsuite/26_numerics/valarray_name_lookup.C: New test.\n+\n 2002-08-02  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config/os/newlib/ctype_inline.h (is): Don't offset _M_table."}, {"sha": "b077458035917e9b32fd805c26faccce1b8538fb", "filename": "libstdc++-v3/include/bits/valarray_meta.h", "status": "modified", "additions": 131, "deletions": 165, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h?ref=74d6b8ca6307ef057ba438f785f46eb9c911b184", "patch": "@@ -41,37 +41,18 @@\n \n namespace std\n {\n-\n-    //\n-    // Implementing a loosened valarray return value is tricky.\n-    // First we need to meet 26.3.1/3: we should not add more than\n-    // two levels of template nesting. Therefore we resort to template\n-    // template to \"flatten\" loosened return value types.\n-    // At some point we use partial specialization to remove one level\n-    // template nesting due to _Expr<>\n-    //\n-    \n-\n-    // This class is NOT defined. It doesn't need to.\n-    template<typename _Tp1, typename _Tp2> class _Constant;\n-\n-    //\n-    // Unary function application closure.\n-    //\n-    template<class _Dom, typename _Op> class _UnFunBase\n-    {\n-    public:\n-      typedef typename _Dom::value_type value_type;\n-      typedef value_type _Vt;\n-      \n-      explicit _UnFunBase (const _Dom& __e) : _M_expr(__e) {}\n-      \n-      _Vt operator[] (size_t __i) const { return _Op()(_M_expr[__i]); }\n-      size_t size () const { return _M_expr.size(); }\n-      \n-    private:\n-      const _Dom& _M_expr;\n-    };\n+  //\n+  // Implementing a loosened valarray return value is tricky.\n+  // First we need to meet 26.3.1/3: we should not add more than\n+  // two levels of template nesting. Therefore we resort to template\n+  // template to \"flatten\" loosened return value types.\n+  // At some point we use partial specialization to remove one level\n+  // template nesting due to _Expr<>\n+  //\n+  \n+  \n+  // This class is NOT defined. It doesn't need to.\n+  template<typename _Tp1, typename _Tp2> class _Constant;\n \n   // Implementations of unary functions applied to valarray<>s.\n   // I use hard-coded object functions here instead of a generic\n@@ -399,27 +380,6 @@ namespace std\n       typedef bool result_type;\n     };\n \n-  template<template<class, class> class _Meta, class _Dom, typename _Op>\n-    class _UnFunClos;\n-    \n-  template<class _Dom, typename _Op>\n-    struct _UnFunClos<_Expr,_Dom, _Op> : _UnFunBase<_Dom, _Op>\n-    {\n-      typedef _UnFunBase<_Dom, _Op> _Base;\n-      typedef typename _Base::value_type value_type;\n-\n-      explicit _UnFunClos (const _Dom& __e) : _Base (__e) {}\n-    };\n-    \n-  template<typename _Tp, typename _Op>\n-    struct _UnFunClos<_ValArray,_Tp, _Op> : _UnFunBase<valarray<_Tp>, _Op>\n-    {\n-      typedef _UnFunBase<valarray<_Tp>, _Op> _Base;\n-      typedef typename _Base::value_type value_type;\n-\n-      explicit _UnFunClos (const valarray<_Tp>& __v) : _Base (__v) {}\n-    };\n-\n     //\n     // Binary function application closure.\n     //\n@@ -637,41 +597,42 @@ namespace std\n     // Unary expression closure.\n     //\n \n-    template<template<class> class _Oper, typename _Arg>\n-    class _UnBase {\n+  template<class _Oper, class _Arg>\n+    class _UnBase\n+    {\n     public:\n-        typedef _Oper<typename _Arg::value_type> _Op;\n-        typedef typename _Op::result_type value_type;\n+      typedef typename _Arg::value_type _Vt;\n+      typedef typename __fun<_Oper, _Vt>::result_type value_type;\n \n-        _UnBase (const _Arg& __e) : _M_expr(__e) {}\n-        value_type operator[] (size_t) const;\n-        size_t size () const { return _M_expr.size (); }\n+      _UnBase(const _Arg& __e) : _M_expr(__e) {}\n+\n+      value_type operator[](size_t __i) const\n+      { return _M_expr[__i]; }\n+\n+      size_t size() const { return _M_expr.size(); }\n \n     private:\n-        const _Arg& _M_expr;\n+      const _Arg& _M_expr;\n     };\n \n-    template<template<class> class _Oper, typename _Arg>\n-    inline typename _UnBase<_Oper, _Arg>::value_type\n-    _UnBase<_Oper, _Arg>::operator[] (size_t __i) const\n-    { return _Op() (_M_expr[__i]); }\n-    \n-    template<template<class> class _Oper, class _Dom>\n-    struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom> {\n-        typedef _Dom _Arg;\n-        typedef _UnBase<_Oper, _Dom> _Base;\n-        typedef typename _Base::value_type value_type;\n-        \n-        _UnClos (const _Arg& __e) : _Base(__e) {}\n+  template<class _Oper, class _Dom>\n+    struct _UnClos<_Oper, _Expr, _Dom> :  _UnBase<_Oper, _Dom>\n+    {\n+      typedef _Dom _Arg;\n+      typedef _UnBase<_Oper, _Dom> _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _UnClos(const _Arg& __e) : _Base(__e) {}\n     };\n \n-    template<template<class> class _Oper, typename _Tp>\n-    struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> > {\n-        typedef valarray<_Tp> _Arg;\n-        typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n-        typedef typename _Base::value_type value_type;\n-\n-        _UnClos (const _Arg& __e) : _Base(__e) {}\n+  template<class _Oper, typename _Tp>\n+    struct _UnClos<_Oper, _ValArray, _Tp> : _UnBase<_Oper, valarray<_Tp> > \n+    {\n+      typedef valarray<_Tp> _Arg;\n+      typedef _UnBase<_Oper, valarray<_Tp> > _Base;\n+      typedef typename _Base::value_type value_type;\n+      \n+      _UnClos(const _Arg& __e) : _Base(__e) {}\n     };\n \n \n@@ -968,153 +929,158 @@ namespace std\n                 : _Base (__a, __i) {}\n     };\n \n-    //\n-    // class _Expr\n-    //      \n-    template<class _Clos, typename _Tp> class _Expr {\n+  //\n+  // class _Expr\n+  //      \n+  template<class _Clos, typename _Tp> \n+    class _Expr\n+    {\n     public:\n-        typedef _Tp value_type;\n-        \n-        _Expr (const _Clos&);\n-        \n-        const _Clos& operator() () const;\n+      typedef _Tp value_type;\n+      \n+      _Expr(const _Clos&);\n+      \n+      const _Clos& operator()() const;\n         \n-        value_type operator[] (size_t) const;\n-        valarray<value_type> operator[] (slice) const;\n-        valarray<value_type> operator[] (const gslice&) const;\n-        valarray<value_type> operator[] (const valarray<bool>&) const;\n-        valarray<value_type> operator[] (const valarray<size_t>&) const;\n+      value_type operator[](size_t) const;\n+      valarray<value_type> operator[](slice) const;\n+      valarray<value_type> operator[](const gslice&) const;\n+      valarray<value_type> operator[](const valarray<bool>&) const;\n+      valarray<value_type> operator[](const valarray<size_t>&) const;\n     \n-        _Expr<_UnClos<_Unary_plus,std::_Expr,_Clos>, value_type>\n-        operator+ () const;\n+      _Expr<_UnClos<__unary_plus,std::_Expr,_Clos>, value_type>\n+        operator+() const;\n \n-        _Expr<_UnClos<negate,std::_Expr,_Clos>, value_type>\n-        operator- () const;\n+      _Expr<_UnClos<__negate,std::_Expr,_Clos>, value_type>\n+        operator-() const;\n \n-        _Expr<_UnClos<_Bitwise_not,std::_Expr,_Clos>, value_type>\n-        operator~ () const;\n+      _Expr<_UnClos<__bitwise_not,std::_Expr,_Clos>, value_type>\n+        operator~() const;\n \n-        _Expr<_UnClos<logical_not,std::_Expr,_Clos>, bool>\n-        operator! () const;\n+      _Expr<_UnClos<__logical_not,std::_Expr,_Clos>, bool>\n+        operator!() const;\n \n-        size_t size () const;\n-        value_type sum () const;\n+      size_t size() const;\n+      value_type sum() const;\n         \n-        valarray<value_type> shift (int) const;\n-        valarray<value_type> cshift (int) const;\n+      valarray<value_type> shift(int) const;\n+      valarray<value_type> cshift(int) const;\n \n       value_type min() const;\n       value_type max() const;\n \n-      valarray<value_type> apply(value_type (*) (const value_type&)) const;\n-      valarray<value_type> apply(value_type (*) (value_type)) const;\n+      valarray<value_type> apply(value_type (*)(const value_type&)) const;\n+      valarray<value_type> apply(value_type (*)(value_type)) const;\n         \n     private:\n-        const _Clos _M_closure;\n+      const _Clos _M_closure;\n     };\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline\n-    _Expr<_Clos,_Tp>::_Expr (const _Clos& __c) : _M_closure(__c) {}\n+    _Expr<_Clos,_Tp>::_Expr(const _Clos& __c) : _M_closure(__c) {}\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline const _Clos&\n-    _Expr<_Clos,_Tp>::operator() () const\n+    _Expr<_Clos,_Tp>::operator()() const\n     { return _M_closure; }\n \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline _Tp\n-    _Expr<_Clos,_Tp>::operator[] (size_t __i) const\n+    _Expr<_Clos,_Tp>::operator[](size_t __i) const\n     { return _M_closure[__i]; }\n \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[] (slice __s) const\n+    _Expr<_Clos,_Tp>::operator[](slice __s) const\n     { return _M_closure[__s]; }\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[] (const gslice& __gs) const\n+    _Expr<_Clos,_Tp>::operator[](const gslice& __gs) const\n     { return _M_closure[__gs]; }\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[] (const valarray<bool>& __m) const\n+    _Expr<_Clos,_Tp>::operator[](const valarray<bool>& __m) const\n     { return _M_closure[__m]; }\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline valarray<_Tp>\n-    _Expr<_Clos,_Tp>::operator[] (const valarray<size_t>& __i) const\n+    _Expr<_Clos,_Tp>::operator[](const valarray<size_t>& __i) const\n     { return _M_closure[__i]; }\n     \n-    template<class _Clos, typename _Tp>\n+  template<class _Clos, typename _Tp>\n     inline size_t\n-    _Expr<_Clos,_Tp>::size () const  { return _M_closure.size (); }\n+    _Expr<_Clos,_Tp>::size() const  { return _M_closure.size (); }\n \n   template<class _Clos, typename _Tp>\n-  inline valarray<_Tp>\n-  _Expr<_Clos, _Tp>::shift(int __n) const\n-  { return valarray<_Tp>(_M_closure).shift(__n); }\n+    inline valarray<_Tp>\n+    _Expr<_Clos, _Tp>::shift(int __n) const\n+    { return valarray<_Tp>(_M_closure).shift(__n); }\n \n   template<class _Clos, typename _Tp>\n-  inline valarray<_Tp>\n-  _Expr<_Clos, _Tp>::cshift(int __n) const\n-  { return valarray<_Tp>(_M_closure).cshift(__n); }\n+    inline valarray<_Tp>\n+    _Expr<_Clos, _Tp>::cshift(int __n) const\n+    { return valarray<_Tp>(_M_closure).cshift(__n); }\n \n   template<class _Clos, typename _Tp>\n-  inline valarray<_Tp>\n-  _Expr<_Clos, _Tp>::apply(_Tp __f(const _Tp&)) const\n-  { return valarray<_Tp>(_M_closure).apply(__f); }\n+    inline valarray<_Tp>\n+    _Expr<_Clos, _Tp>::apply(_Tp __f(const _Tp&)) const\n+    { return valarray<_Tp>(_M_closure).apply(__f); }\n     \n   template<class _Clos, typename _Tp>\n-  inline valarray<_Tp>\n-  _Expr<_Clos, _Tp>::apply(_Tp __f(_Tp)) const\n-  { return valarray<_Tp>(_M_closure).apply(__f); }\n+    inline valarray<_Tp>\n+    _Expr<_Clos, _Tp>::apply(_Tp __f(_Tp)) const\n+    { return valarray<_Tp>(_M_closure).apply(__f); }\n \n-    // XXX: replace this with a more robust summation algorithm.\n-    template<class _Clos, typename _Tp>\n+  // XXX: replace this with a more robust summation algorithm.\n+  template<class _Clos, typename _Tp>\n     inline _Tp\n-    _Expr<_Clos,_Tp>::sum () const\n+    _Expr<_Clos,_Tp>::sum() const\n     {\n-        size_t __n = _M_closure.size();\n-        if (__n == 0) return _Tp();\n-        else {\n-            _Tp __s = _M_closure[--__n];\n-            while (__n != 0) __s += _M_closure[--__n];\n-            return __s;\n+      size_t __n = _M_closure.size();\n+      if (__n == 0) \n+\treturn _Tp();\n+      else \n+\t{\n+\t  _Tp __s = _M_closure[--__n];\n+\t  while (__n != 0)\n+\t    __s += _M_closure[--__n];\n+\t  return __s;\n         }\n     }\n \n   template<class _Clos, typename _Tp>\n-  inline _Tp\n-  _Expr<_Clos, _Tp>::min() const\n-  { return __valarray_min(_M_closure); }\n+    inline _Tp\n+    _Expr<_Clos, _Tp>::min() const\n+    { return __valarray_min(_M_closure); }\n \n   template<class _Clos, typename _Tp>\n-  inline _Tp\n-  _Expr<_Clos, _Tp>::max() const\n-  { return __valarray_max(_M_closure); }\n+    inline _Tp\n+    _Expr<_Clos, _Tp>::max() const\n+    { return __valarray_max(_M_closure); }\n     \n-    template<class _Dom, typename _Tp>\n-    inline _Expr<_UnClos<logical_not,_Expr,_Dom>, bool>\n-    _Expr<_Dom,_Tp>::operator! () const\n+  template<class _Dom, typename _Tp>\n+    inline _Expr<_UnClos<__logical_not,_Expr,_Dom>, bool>\n+    _Expr<_Dom,_Tp>::operator!() const\n     {\n-        typedef _UnClos<logical_not,std::_Expr,_Dom> _Closure;\n-        return _Expr<_Closure,_Tp> (_Closure(this->_M_closure));\n+        typedef _UnClos<__logical_not,std::_Expr,_Dom> _Closure;\n+        return _Expr<_Closure,_Tp>(_Closure(this->_M_closure));\n     }\n \n #define _DEFINE_EXPR_UNARY_OPERATOR(_Op, _Name)                         \\\n template<class _Dom, typename _Tp>                                      \\\n inline _Expr<_UnClos<_Name,std::_Expr,_Dom>,_Tp>                        \\\n-_Expr<_Dom,_Tp>::operator _Op () const                                 \\\n+_Expr<_Dom,_Tp>::operator _Op() const                                   \\\n {                                                                       \\\n     typedef _UnClos<_Name,std::_Expr,_Dom> _Closure;                    \\\n-    return _Expr<_Closure,_Tp> (_Closure (this->_M_closure));           \\\n+    return _Expr<_Closure,_Tp>(_Closure(this->_M_closure));             \\\n }\n \n-    _DEFINE_EXPR_UNARY_OPERATOR(+, _Unary_plus)\n-    _DEFINE_EXPR_UNARY_OPERATOR(-, negate)\n-    _DEFINE_EXPR_UNARY_OPERATOR(~, _Bitwise_not)\n+    _DEFINE_EXPR_UNARY_OPERATOR(+, __unary_plus)\n+    _DEFINE_EXPR_UNARY_OPERATOR(-, __negate)\n+    _DEFINE_EXPR_UNARY_OPERATOR(~, __bitwise_not)\n \n #undef _DEFINE_EXPR_UNARY_OPERATOR\n \n@@ -1263,19 +1229,19 @@ operator _Op (const valarray<typename _Dom::value_type>& __v,          \\\n \n #define _DEFINE_EXPR_UNARY_FUNCTION(_Name)                              \\\n template<class _Dom>                                                    \\\n-inline _Expr<_UnFunClos<_Expr,_Dom,__##_Name>,typename _Dom::value_type>\\\n+inline _Expr<_UnClos<__##_Name,_Expr,_Dom>,typename _Dom::value_type>   \\\n _Name(const _Expr<_Dom,typename _Dom::value_type>& __e)                 \\\n {                                                                       \\\n     typedef typename _Dom::value_type _Tp;                              \\\n-    typedef _UnFunClos<_Expr,_Dom,__##_Name> _Closure;                  \\\n+    typedef _UnClos<__##_Name,_Expr,_Dom> _Closure;                     \\\n     return _Expr<_Closure,_Tp>(_Closure(__e()));                        \\\n }                                                                       \\\n                                                                         \\\n template<typename _Tp>                                                  \\\n-inline _Expr<_UnFunClos<_ValArray,_Tp,__##_Name>,_Tp>                   \\\n+inline _Expr<_UnClos<__##_Name,_ValArray,_Tp>,_Tp>                      \\\n _Name(const valarray<_Tp>& __v)                                         \\\n {                                                                       \\\n-    typedef _UnFunClos<_ValArray,_Tp,__##_Name> _Closure;               \\\n+    typedef _UnClos<__##_Name,_ValArray,_Tp> _Closure;                  \\\n     return _Expr<_Closure,_Tp>(_Closure (__v));                         \\\n }\n "}, {"sha": "6a6e59ad0cf8c80c845b74a4154e7bb75a4129be", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 284, "deletions": 273, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=74d6b8ca6307ef057ba438f785f46eb9c911b184", "patch": "@@ -50,43 +50,49 @@\n \n namespace std\n {\n-    template<class _Clos, typename _Tp> class _Expr;\n+  template<class _Clos, typename _Tp> \n+    class _Expr;\n \n-    template<typename _Tp1, typename _Tp2> class _ValArray;    \n+  template<typename _Tp1, typename _Tp2> \n+    class _ValArray;    \n \n-    template<template<class> class _Oper,\n-        template<class, class> class _Meta, class _Dom> struct _UnClos;\n+  template<class _Oper, template<class, class> class _Meta, class _Dom>\n+    struct _UnClos;\n \n-    template<template<class> class _Oper,\n+  template<template<class> class _Oper,\n         template<class, class> class _Meta1,\n         template<class, class> class _Meta2,\n-        class _Dom1, class _Dom2> class _BinClos;\n+        class _Dom1, class _Dom2> \n+    class _BinClos;\n \n-    template<template<class, class> class _Meta, class _Dom> class _SClos;\n+  template<template<class, class> class _Meta, class _Dom> \n+    class _SClos;\n \n-    template<template<class, class> class _Meta, class _Dom> class _GClos;\n+  template<template<class, class> class _Meta, class _Dom> \n+    class _GClos;\n     \n-    template<template<class, class> class _Meta, class _Dom> class _IClos;\n+  template<template<class, class> class _Meta, class _Dom> \n+    class _IClos;\n     \n-    template<template<class, class> class _Meta, class _Dom> class _ValFunClos;\n-\n-    template<template<class, class> class _Meta, class _Dom> class _RefFunClos;\n-\n-    template<class _Tp> struct _Unary_plus;\n-    template<class _Tp> struct _Bitwise_and;\n-    template<class _Tp> struct _Bitwise_or;\n-    template<class _Tp> struct _Bitwise_xor;  \n-    template<class _Tp> struct _Bitwise_not;\n-    template<class _Tp> struct _Shift_left;\n-    template<class _Tp> struct _Shift_right;\n+  template<template<class, class> class _Meta, class _Dom> \n+    class _ValFunClos;\n   \n-    template<class _Tp> class valarray;   // An array of type _Tp\n-    class slice;                          // BLAS-like slice out of an array\n-    template<class _Tp> class slice_array;\n-    class gslice;                         // generalized slice out of an array\n-    template<class _Tp> class gslice_array;\n-    template<class _Tp> class mask_array;     // masked array\n-    template<class _Tp> class indirect_array; // indirected array\n+  template<template<class, class> class _Meta, class _Dom> \n+    class _RefFunClos;\n+\n+  template<class _Tp> struct _Bitwise_and;\n+  template<class _Tp> struct _Bitwise_or;\n+  template<class _Tp> struct _Bitwise_xor;  \n+  template<class _Tp> struct _Shift_left;\n+  template<class _Tp> struct _Shift_right;\n+  \n+  template<class _Tp> class valarray;   // An array of type _Tp\n+  class slice;                          // BLAS-like slice out of an array\n+  template<class _Tp> class slice_array;\n+  class gslice;                         // generalized slice out of an array\n+  template<class _Tp> class gslice_array;\n+  template<class _Tp> class mask_array;     // masked array\n+  template<class _Tp> class indirect_array; // indirected array\n \n } // namespace std\n \n@@ -95,12 +101,19 @@ namespace std\n   \n namespace std\n {\n-  template<class _Tp> class valarray\n-  {\n-  public:\n+  template<class _Tp> \n+    class valarray\n+    {\n+      template<class _Op>\n+\tstruct _UnaryOp \n+\t{\n+\t  typedef typename __fun<_Op, _Tp>::result_type __rt;\n+\t  typedef _Expr<_UnClos<_Op, _ValArray, _Tp>, __rt> _Rt;\n+\t};\n+    public:\n       typedef _Tp value_type;\n-\n-      // _lib.valarray.cons_ construct/destroy:\n+      \n+\t// _lib.valarray.cons_ construct/destroy:\n       valarray();\n       explicit valarray(size_t);\n       valarray(const _Tp&, size_t);\n@@ -111,8 +124,8 @@ namespace std\n       valarray(const mask_array<_Tp>&);\n       valarray(const indirect_array<_Tp>&);\n       template<class _Dom>\n-      valarray(const _Expr<_Dom,_Tp>& __e);\n-     ~valarray();\n+\tvalarray(const _Expr<_Dom,_Tp>& __e);\n+      ~valarray();\n \n       // _lib.valarray.assign_ assignment:\n       valarray<_Tp>& operator=(const valarray<_Tp>&);\n@@ -123,7 +136,7 @@ namespace std\n       valarray<_Tp>& operator=(const indirect_array<_Tp>&);\n \n       template<class _Dom> valarray<_Tp>&\n-      \toperator= (const _Expr<_Dom,_Tp>&);\n+\toperator= (const _Expr<_Dom,_Tp>&);\n \n       // _lib.valarray.access_ element access:\n       // XXX: LWG to be resolved.\n@@ -137,85 +150,80 @@ namespace std\n       valarray<_Tp>     \t operator[](const valarray<bool>&) const;\n       mask_array<_Tp>     operator[](const valarray<bool>&);\n       _Expr<_IClos<_ValArray, _Tp>, _Tp>\n-      \toperator[](const valarray<size_t>&) const;\n+        operator[](const valarray<size_t>&) const;\n       indirect_array<_Tp> operator[](const valarray<size_t>&);\n \n       // _lib.valarray.unary_ unary operators:\n-      _Expr<_UnClos<_Unary_plus,_ValArray,_Tp>,_Tp>  operator+ () const;\n-      _Expr<_UnClos<negate,_ValArray,_Tp>,_Tp> operator- () const;\n-      _Expr<_UnClos<_Bitwise_not,_ValArray,_Tp>,_Tp> operator~ () const;\n-      _Expr<_UnClos<logical_not,_ValArray,_Tp>,bool> operator! () const;\n-      \n+      typename _UnaryOp<__unary_plus>::_Rt  operator+() const;\n+      typename _UnaryOp<__negate>::_Rt      operator-() const;\n+      typename _UnaryOp<__bitwise_not>::_Rt operator~() const;\n+      typename _UnaryOp<__logical_not>::_Rt operator!() const;\n+\n       // _lib.valarray.cassign_ computed assignment:\n-      valarray<_Tp>& operator*= (const _Tp&);\n-      valarray<_Tp>& operator/= (const _Tp&);\n-      valarray<_Tp>& operator%= (const _Tp&);\n-      valarray<_Tp>& operator+= (const _Tp&);\n-      valarray<_Tp>& operator-= (const _Tp&);\n-      valarray<_Tp>& operator^= (const _Tp&);\n-      valarray<_Tp>& operator&= (const _Tp&);\n-      valarray<_Tp>& operator|= (const _Tp&);\n+      valarray<_Tp>& operator*=(const _Tp&);\n+      valarray<_Tp>& operator/=(const _Tp&);\n+      valarray<_Tp>& operator%=(const _Tp&);\n+      valarray<_Tp>& operator+=(const _Tp&);\n+      valarray<_Tp>& operator-=(const _Tp&);\n+      valarray<_Tp>& operator^=(const _Tp&);\n+      valarray<_Tp>& operator&=(const _Tp&);\n+      valarray<_Tp>& operator|=(const _Tp&);\n       valarray<_Tp>& operator<<=(const _Tp&);\n       valarray<_Tp>& operator>>=(const _Tp&);\n-      valarray<_Tp>& operator*= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator/= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator%= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator+= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator-= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator^= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator|= (const valarray<_Tp>&);\n-      valarray<_Tp>& operator&= (const valarray<_Tp>&);\n+      valarray<_Tp>& operator*=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator/=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator%=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator+=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator-=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator^=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator|=(const valarray<_Tp>&);\n+      valarray<_Tp>& operator&=(const valarray<_Tp>&);\n       valarray<_Tp>& operator<<=(const valarray<_Tp>&);\n       valarray<_Tp>& operator>>=(const valarray<_Tp>&);\n \n       template<class _Dom>\n-        valarray<_Tp>& operator*= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator*=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator/= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator/=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator%= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator%=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator+= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator+=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator-= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator-=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator^= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator^=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator|= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator|=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator&= (const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator&=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator<<=(const _Expr<_Dom,_Tp>&);\n+      valarray<_Tp>& operator<<=(const _Expr<_Dom,_Tp>&);\n       template<class _Dom>\n-        valarray<_Tp>& operator>>=(const _Expr<_Dom,_Tp>&);\n+\tvalarray<_Tp>& operator>>=(const _Expr<_Dom,_Tp>&);\n+\n \n-      \n       // _lib.valarray.members_ member functions:\n       size_t size() const;\n       _Tp    sum() const;\t\n       _Tp    min() const;\t\n       _Tp    max() const;\t\n \n-//           // FIXME: Extension\n-//       _Tp    product () const;\n+  //           // FIXME: Extension\n+  //       _Tp    product () const;\n \n       valarray<_Tp> shift (int) const;\n       valarray<_Tp> cshift(int) const;\n       _Expr<_ValFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(_Tp)) const;\n       _Expr<_RefFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(const _Tp&)) const;\n       void resize(size_t __size, _Tp __c = _Tp());\n \n-  private:\n+    private:\n       size_t _M_size;\n       _Tp* __restrict__ _M_data;\n-\n+      \n       friend class _Array<_Tp>;\n-  };\n-\n-\n-  template<typename _Tp> struct _Unary_plus : unary_function<_Tp,_Tp> {\n-      _Tp operator() (const _Tp& __t) const { return __t; }\n-  };\n+    };\n \n   template<typename _Tp> struct _Bitwise_and : binary_function<_Tp,_Tp,_Tp> {\n       _Tp operator() (_Tp __x, _Tp __y) const { return __x & __y; }\n@@ -229,10 +237,6 @@ namespace std\n       _Tp operator() (_Tp __x, _Tp __y) const { return __x ^ __y; }\n   };\n   \n-  template<typename _Tp> struct _Bitwise_not : unary_function<_Tp,_Tp> {\n-      _Tp operator() (_Tp __t) const { return ~__t; }\n-  };\n-\n   template<typename _Tp> struct _Shift_left : unary_function<_Tp,_Tp> {\n       _Tp operator() (_Tp __x, _Tp __y) const { return __x << __y; }\n   };\n@@ -243,14 +247,14 @@ namespace std\n \n   \n   template<typename _Tp>\n-  inline const _Tp&\n-  valarray<_Tp>::operator[] (size_t __i) const\n-  { return _M_data[__i]; }\n+    inline const _Tp&\n+    valarray<_Tp>::operator[](size_t __i) const\n+    { return _M_data[__i]; }\n \n   template<typename _Tp>\n-  inline _Tp&\n-  valarray<_Tp>::operator[] (size_t __i)\n-  { return _M_data[__i]; }\n+    inline _Tp&\n+    valarray<_Tp>::operator[](size_t __i)\n+    { return _M_data[__i]; }\n \n } // std::\n       \n@@ -263,214 +267,227 @@ namespace std\n namespace std\n {\n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray () : _M_size (0), _M_data (0) {}\n+    inline\n+    valarray<_Tp>::valarray() : _M_size(0), _M_data(0) {}\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (size_t __n) \n-      : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-  { __valarray_default_construct(_M_data, _M_data + __n); }\n+    inline \n+    valarray<_Tp>::valarray(size_t __n) \n+\t: _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    { __valarray_default_construct(_M_data, _M_data + __n); }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const _Tp& __t, size_t __n)\n-    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-  { __valarray_fill_construct (_M_data, _M_data + __n, __t); }\n+    inline\n+    valarray<_Tp>::valarray(const _Tp& __t, size_t __n)\n+      : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    { __valarray_fill_construct(_M_data, _M_data + __n, __t); }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const _Tp* __restrict__ __p, size_t __n)\n-    : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-  { __valarray_copy_construct (__p, __p + __n, _M_data); }\n+    inline\n+    valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)\n+      : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n+    { __valarray_copy_construct(__p, __p + __n, _M_data); }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const valarray<_Tp>& __v)\n-    : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n-  { __valarray_copy_construct (__v._M_data, __v._M_data + _M_size, _M_data); }\n+    inline\n+    valarray<_Tp>::valarray(const valarray<_Tp>& __v)\n+      : _M_size(__v._M_size), _M_data(__valarray_get_storage<_Tp>(__v._M_size))\n+    { __valarray_copy_construct(__v._M_data, __v._M_data + _M_size, _M_data); }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const slice_array<_Tp>& __sa)\n-    : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n-  {\n-    __valarray_copy\n-      (__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));\n-  }\n+    inline\n+    valarray<_Tp>::valarray(const slice_array<_Tp>& __sa)\n+      : _M_size(__sa._M_sz), _M_data(__valarray_get_storage<_Tp>(__sa._M_sz))\n+    {\n+      __valarray_copy\n+\t(__sa._M_array, __sa._M_sz, __sa._M_stride, _Array<_Tp>(_M_data));\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const gslice_array<_Tp>& __ga)\n-    : _M_size(__ga._M_index.size()),\n-      _M_data(__valarray_get_storage<_Tp>(_M_size))\n-  {\n-    __valarray_copy\n-      (__ga._M_array, _Array<size_t>(__ga._M_index),\n-       _Array<_Tp>(_M_data), _M_size);\n-  }\n+    inline\n+    valarray<_Tp>::valarray(const gslice_array<_Tp>& __ga)\n+      : _M_size(__ga._M_index.size()),\n+\t_M_data(__valarray_get_storage<_Tp>(_M_size))\n+    {\n+      __valarray_copy\n+\t(__ga._M_array, _Array<size_t>(__ga._M_index),\n+\t _Array<_Tp>(_M_data), _M_size);\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const mask_array<_Tp>& __ma)\n-    : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n-  {\n-    __valarray_copy\n-      (__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);\n-  }\n+    inline\n+    valarray<_Tp>::valarray(const mask_array<_Tp>& __ma)\n+      : _M_size(__ma._M_sz), _M_data(__valarray_get_storage<_Tp>(__ma._M_sz))\n+    {\n+      __valarray_copy\n+\t(__ma._M_array, __ma._M_mask, _Array<_Tp>(_M_data), _M_size);\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::valarray (const indirect_array<_Tp>& __ia)\n-    : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))\n-  {\n-    __valarray_copy\n-      (__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);\n-  }\n+    inline\n+    valarray<_Tp>::valarray(const indirect_array<_Tp>& __ia)\n+      : _M_size(__ia._M_sz), _M_data(__valarray_get_storage<_Tp>(__ia._M_sz))\n+    {\n+      __valarray_copy\n+\t(__ia._M_array, __ia._M_index, _Array<_Tp>(_M_data), _M_size);\n+    }\n \n   template<typename _Tp> template<class _Dom>\n-  inline valarray<_Tp>::valarray (const _Expr<_Dom, _Tp>& __e)\n-    : _M_size(__e.size ()), _M_data(__valarray_get_storage<_Tp>(_M_size))\n-  { __valarray_copy (__e, _M_size, _Array<_Tp>(_M_data)); }\n+    inline\n+    valarray<_Tp>::valarray(const _Expr<_Dom, _Tp>& __e)\n+      : _M_size(__e.size()), _M_data(__valarray_get_storage<_Tp>(_M_size))\n+    { __valarray_copy(__e, _M_size, _Array<_Tp>(_M_data)); }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>::~valarray ()\n-  {\n+    inline\n+    valarray<_Tp>::~valarray()\n+    {\n       __valarray_destroy_elements(_M_data, _M_data + _M_size);\n       __valarray_release_memory(_M_data);\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const valarray<_Tp>& __v)\n-  {\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const valarray<_Tp>& __v)\n+    {\n       __valarray_copy(__v._M_data, _M_size, _M_data);\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const _Tp& __t)\n-  {\n-      __valarray_fill (_M_data, _M_size, __t);\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const _Tp& __t)\n+    {\n+      __valarray_fill(_M_data, _M_size, __t);\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const slice_array<_Tp>& __sa)\n-  {\n-      __valarray_copy (__sa._M_array, __sa._M_sz,\n-              __sa._M_stride, _Array<_Tp>(_M_data));\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const slice_array<_Tp>& __sa)\n+    {\n+      __valarray_copy(__sa._M_array, __sa._M_sz,\n+\t\t      __sa._M_stride, _Array<_Tp>(_M_data));\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const gslice_array<_Tp>& __ga)\n-  {\n-      __valarray_copy (__ga._M_array, _Array<size_t>(__ga._M_index),\n-              _Array<_Tp>(_M_data), _M_size);\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const gslice_array<_Tp>& __ga)\n+    {\n+      __valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),\n+\t\t      _Array<_Tp>(_M_data), _M_size);\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const mask_array<_Tp>& __ma)\n-  {\n-      __valarray_copy (__ma._M_array, __ma._M_mask,\n-              _Array<_Tp>(_M_data), _M_size);\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const mask_array<_Tp>& __ma)\n+    {\n+      __valarray_copy(__ma._M_array, __ma._M_mask,\n+\t\t      _Array<_Tp>(_M_data), _M_size);\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const indirect_array<_Tp>& __ia)\n-  {\n-      __valarray_copy (__ia._M_array, __ia._M_index,\n-               _Array<_Tp>(_M_data), _M_size);\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const indirect_array<_Tp>& __ia)\n+    {\n+      __valarray_copy(__ia._M_array, __ia._M_index,\n+\t\t       _Array<_Tp>(_M_data), _M_size);\n       return *this;\n-  }\n+    }\n \n   template<typename _Tp> template<class _Dom>\n-  inline valarray<_Tp>&\n-  valarray<_Tp>::operator= (const _Expr<_Dom, _Tp>& __e)\n-  {\n-      __valarray_copy (__e, _M_size, _Array<_Tp>(_M_data));\n-      return *this;\n-  }\n+    inline valarray<_Tp>&\n+    valarray<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e)\n+    {\n+      __valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));\n+\treturn *this;\n+    }\n \n   template<typename _Tp>\n-  inline _Expr<_SClos<_ValArray,_Tp>, _Tp>\n-  valarray<_Tp>::operator[] (slice __s) const\n-  {\n+    inline _Expr<_SClos<_ValArray,_Tp>, _Tp>\n+    valarray<_Tp>::operator[](slice __s) const\n+    {\n       typedef _SClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure, _Tp> (_Closure (_Array<_Tp>(_M_data), __s));\n-  }\n+      return _Expr<_Closure, _Tp>(_Closure (_Array<_Tp>(_M_data), __s));\n+    }\n \n   template<typename _Tp>\n-  inline slice_array<_Tp>\n-  valarray<_Tp>::operator[] (slice __s)\n-  {\n-      return slice_array<_Tp> (_Array<_Tp>(_M_data), __s);\n-  }\n+    inline slice_array<_Tp>\n+    valarray<_Tp>::operator[](slice __s)\n+    {\n+      return slice_array<_Tp>(_Array<_Tp>(_M_data), __s);\n+    }\n \n   template<typename _Tp>\n-  inline _Expr<_GClos<_ValArray,_Tp>, _Tp>\n-  valarray<_Tp>::operator[] (const gslice& __gs) const\n-  {\n+    inline _Expr<_GClos<_ValArray,_Tp>, _Tp>\n+    valarray<_Tp>::operator[](const gslice& __gs) const\n+    {\n       typedef _GClos<_ValArray,_Tp> _Closure;\n       return _Expr<_Closure, _Tp>\n-          (_Closure (_Array<_Tp>(_M_data), __gs._M_index->_M_index));\n-  }\n+\t(_Closure(_Array<_Tp>(_M_data), __gs._M_index->_M_index));\n+    }\n \n   template<typename _Tp>\n-  inline gslice_array<_Tp>\n-  valarray<_Tp>::operator[] (const gslice& __gs)\n-  {\n+    inline gslice_array<_Tp>\n+    valarray<_Tp>::operator[](const gslice& __gs)\n+    {\n       return gslice_array<_Tp>\n-          (_Array<_Tp>(_M_data), __gs._M_index->_M_index);\n-  }\n+\t(_Array<_Tp>(_M_data), __gs._M_index->_M_index);\n+    }\n \n   template<typename _Tp>\n-  inline valarray<_Tp>\n-  valarray<_Tp>::operator[] (const valarray<bool>& __m) const\n-  {\n-      size_t __s (0);\n-      size_t __e (__m.size ());\n+    inline valarray<_Tp>\n+    valarray<_Tp>::operator[](const valarray<bool>& __m) const\n+    {\n+      size_t __s = 0;\n+      size_t __e = __m.size();\n       for (size_t __i=0; __i<__e; ++__i)\n-          if (__m[__i]) ++__s;\n-      return valarray<_Tp> (mask_array<_Tp> (_Array<_Tp>(_M_data), __s,\n-                                         _Array<bool> (__m)));\n-  }\n+\tif (__m[__i]) ++__s;\n+      return valarray<_Tp>(mask_array<_Tp>(_Array<_Tp>(_M_data), __s,\n+\t\t\t\t\t   _Array<bool> (__m)));\n+    }\n \n   template<typename _Tp>\n-  inline mask_array<_Tp>\n-  valarray<_Tp>::operator[] (const valarray<bool>& __m)\n-  {\n-      size_t __s (0);\n-      size_t __e (__m.size ());\n+    inline mask_array<_Tp>\n+    valarray<_Tp>::operator[](const valarray<bool>& __m)\n+    {\n+      size_t __s = 0;\n+      size_t __e = __m.size();\n       for (size_t __i=0; __i<__e; ++__i)\n-          if (__m[__i]) ++__s;\n-      return mask_array<_Tp> (_Array<_Tp>(_M_data), __s, _Array<bool> (__m));\n-  }\n+\tif (__m[__i]) ++__s;\n+      return mask_array<_Tp>(_Array<_Tp>(_M_data), __s, _Array<bool>(__m));\n+    }\n \n   template<typename _Tp>\n-  inline _Expr<_IClos<_ValArray,_Tp>, _Tp>\n-  valarray<_Tp>::operator[] (const valarray<size_t>& __i) const\n-  {\n+    inline _Expr<_IClos<_ValArray,_Tp>, _Tp>\n+    valarray<_Tp>::operator[](const valarray<size_t>& __i) const\n+    {\n       typedef _IClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure, _Tp> (_Closure (*this, __i));\n-  }\n+      return _Expr<_Closure, _Tp>(_Closure(*this, __i));\n+    }\n \n   template<typename _Tp>\n-  inline indirect_array<_Tp>\n-  valarray<_Tp>::operator[] (const valarray<size_t>& __i)\n-  {\n-      return indirect_array<_Tp> (_Array<_Tp>(_M_data), __i.size(),\n-                                _Array<size_t> (__i));\n-  }\n+    inline indirect_array<_Tp>\n+    valarray<_Tp>::operator[](const valarray<size_t>& __i)\n+    {\n+      return indirect_array<_Tp>(_Array<_Tp>(_M_data), __i.size(),\n+\t\t\t\t _Array<size_t>(__i));\n+    }\n \n   template<class _Tp>\n-  inline size_t valarray<_Tp>::size () const { return _M_size; }\n+    inline size_t \n+    valarray<_Tp>::size() const\n+    { return _M_size; }\n \n   template<class _Tp>\n-  inline _Tp\n-  valarray<_Tp>::sum () const\n-  {\n-      return __valarray_sum(_M_data, _M_data + _M_size);\n-  }\n+    inline _Tp\n+    valarray<_Tp>::sum() const\n+    {\n+\treturn __valarray_sum(_M_data, _M_data + _M_size);\n+    }\n \n //   template<typename _Tp>\n //   inline _Tp\n@@ -529,74 +546,68 @@ namespace std\n      }\n \n   template <class _Tp>\n-  inline void\n-  valarray<_Tp>::resize (size_t __n, _Tp __c)\n-  {\n-    // This complication is so to make valarray<valarray<T> > work\n-    // even though it is not required by the standard.  Nobody should\n-    // be saying valarray<valarray<T> > anyway.  See the specs.\n-    __valarray_destroy_elements(_M_data, _M_data + _M_size);\n-    if (_M_size != __n)\n-      {\n-        __valarray_release_memory(_M_data);\n-        _M_size = __n;\n-        _M_data = __valarray_get_storage<_Tp>(__n);\n-      }\n-    __valarray_fill_construct(_M_data, _M_data + __n, __c);\n-  }\n+    inline void\n+    valarray<_Tp>::resize (size_t __n, _Tp __c)\n+    {\n+      // This complication is so to make valarray<valarray<T> > work\n+      // even though it is not required by the standard.  Nobody should\n+      // be saying valarray<valarray<T> > anyway.  See the specs.\n+      __valarray_destroy_elements(_M_data, _M_data + _M_size);\n+      if (_M_size != __n)\n+\t{\n+\t  __valarray_release_memory(_M_data);\n+\t  _M_size = __n;\n+\t  _M_data = __valarray_get_storage<_Tp>(__n);\n+\t}\n+      __valarray_fill_construct(_M_data, _M_data + __n, __c);\n+    }\n     \n   template<typename _Tp>\n-  inline _Tp\n-  valarray<_Tp>::min() const\n-  {\n+    inline _Tp\n+    valarray<_Tp>::min() const\n+    {\n       return *min_element (_M_data, _M_data+_M_size);\n-  }\n+    }\n \n   template<typename _Tp>\n-  inline _Tp\n-  valarray<_Tp>::max() const\n-  {\n+    inline _Tp\n+    valarray<_Tp>::max() const\n+    {\n       return *max_element (_M_data, _M_data+_M_size);\n-  }\n+    }\n   \n   template<class _Tp>\n-  inline _Expr<_ValFunClos<_ValArray,_Tp>,_Tp>\n-  valarray<_Tp>::apply (_Tp func (_Tp)) const\n-  {\n+    inline _Expr<_ValFunClos<_ValArray,_Tp>,_Tp>\n+    valarray<_Tp>::apply(_Tp func(_Tp)) const\n+    {\n       typedef _ValFunClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure,_Tp> (_Closure (*this, func));\n-  }\n+      return _Expr<_Closure,_Tp>(_Closure(*this, func));\n+    }\n \n   template<class _Tp>\n-  inline _Expr<_RefFunClos<_ValArray,_Tp>,_Tp>\n-  valarray<_Tp>::apply (_Tp func (const _Tp &)) const\n-  {\n+    inline _Expr<_RefFunClos<_ValArray,_Tp>,_Tp>\n+    valarray<_Tp>::apply(_Tp func(const _Tp &)) const\n+    {\n       typedef _RefFunClos<_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure,_Tp> (_Closure (*this, func));\n-  }\n+      return _Expr<_Closure,_Tp>(_Closure(*this, func));\n+    }\n \n #define _DEFINE_VALARRAY_UNARY_OPERATOR(_Op, _Name)                     \\\n   template<typename _Tp>\t\t\t\t\t\t\\\n-  inline _Expr<_UnClos<_Name,_ValArray,_Tp>, _Tp>               \t\\\n+  inline typename valarray<_Tp>::template _UnaryOp<_Name>::_Rt         \t\\\n   valarray<_Tp>::operator _Op() const\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n-      typedef _UnClos<_Name,_ValArray,_Tp> _Closure;\t                \\\n-      return _Expr<_Closure, _Tp> (_Closure (*this));\t\t\t\\\n+    typedef _UnClos<_Name,_ValArray,_Tp> _Closure;\t                \\\n+    typedef typename __fun<_Name, _Tp>::result_type _Rt;                \\\n+    return _Expr<_Closure, _Rt>(_Closure(*this));\t\t\t\\\n   }\n \n-    _DEFINE_VALARRAY_UNARY_OPERATOR(+, _Unary_plus)\n-    _DEFINE_VALARRAY_UNARY_OPERATOR(-, negate)\n-    _DEFINE_VALARRAY_UNARY_OPERATOR(~, _Bitwise_not)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(+, __unary_plus)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(-, __negate)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR(~, __bitwise_not)\n+    _DEFINE_VALARRAY_UNARY_OPERATOR (!, __logical_not)\n \n #undef _DEFINE_VALARRAY_UNARY_OPERATOR\n-  \n-  template<typename _Tp>\n-  inline _Expr<_UnClos<logical_not,_ValArray,_Tp>, bool>\n-  valarray<_Tp>::operator!() const\n-  {\n-      typedef _UnClos<logical_not,_ValArray,_Tp> _Closure;\n-      return _Expr<_Closure, bool> (_Closure (*this));\n-  }\n \n #define _DEFINE_VALARRAY_AUGMENTED_ASSIGNMENT(_Op, _Name)               \\\n   template<class _Tp>\t\t\t\t\t\t\t\\"}, {"sha": "4958b366af44097fe5f117c2bb2eb24a06ebdf08", "filename": "libstdc++-v3/testsuite/26_numerics/valarray_name_lookup.C", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fvalarray_name_lookup.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d6b8ca6307ef057ba438f785f46eb9c911b184/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fvalarray_name_lookup.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fvalarray_name_lookup.C?ref=74d6b8ca6307ef057ba438f785f46eb9c911b184", "patch": "@@ -0,0 +1,119 @@\n+// 2002-08-02 gdr\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Test name lookup resolutions for standard functions applied to an\n+// array expression.\n+// { dg-do compile }\n+\n+#include <valarray>\n+\n+namespace My\n+{\n+  struct Number \n+  { \n+    operator bool() const;\n+  };\n+  \n+  Number operator+(Number);\n+  Number operator-(Number);\n+  Number operator~(Number);\n+\n+  bool operator!(Number);\n+  \n+  Number operator+(Number, Number);\n+  Number operator-(Number, Number);\n+  Number operator*(Number, Number);\n+  Number operator/(Number, Number);\n+  Number operator%(Number, Number);\n+\n+  Number operator^(Number, Number);\n+  Number operator&(Number, Number);\n+  Number operator|(Number, Number);\n+\n+  Number operator<<(Number, Number);\n+  Number operator>>(Number, Number);\n+\n+  bool operator==(Number, Number);\n+  bool operator!=(Number, Number);\n+  bool operator<(Number, Number);\n+  bool operator<=(Number, Number);\n+  bool operator>(Number, Number);\n+  bool operator>=(Number, Number);\n+\n+  Number abs(Number);\n+\n+  Number cos(Number);\n+  Number cosh(Number);\n+  Number acosh(Number);\n+\n+  Number sin(Number);\n+  Number sinh(Number);\n+  Number asin(Number);\n+  \n+  Number tan(Number);\n+  Number tanh(Number);\n+  Number atan(Number);\n+\n+  Number exp(Number);\n+  Number log(Number);\n+  Number log10(Number);\n+  Number sqrt(Number);\n+\n+  Number atan2(Number, Number);\n+  Number pow(Number, Number);\n+}\n+\n+int main()\n+{\n+  typedef std::valarray<My::Number> Array;\n+  Array u(10), v(10);\n+  v = +u;\n+  v = -u;\n+  v = ~u;\n+  std::valarray<bool> z = !u;\n+\n+  v = abs(u);\n+  \n+  v = cos(u);\n+  v = cosh(u);\n+  v = acos(u);\n+\n+  v = sin(u);\n+  v = sinh(u);\n+  v = asin(u);\n+\n+  v = tan(u);\n+  v = tanh(u);\n+  v = atan(u);\n+\n+  v = exp(u);\n+  v = log(u);\n+  v = log10(u);\n+  v = sqrt(u);  \n+}"}]}