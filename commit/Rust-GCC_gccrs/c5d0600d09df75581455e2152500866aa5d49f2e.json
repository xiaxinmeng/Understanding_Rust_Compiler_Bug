{"sha": "c5d0600d09df75581455e2152500866aa5d49f2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkMDYwMGQwOWRmNzU1ODE0NTVlMjE1MjUwMDg2NmFhNWQ0OWYyZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-11-10T20:23:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-11-10T20:23:09Z"}, "message": "re PR tree-optimization/46228 (code produced for STL container is worse in 4.5.1 than in 4.4.5)\n\n\tPR tree-optimize/46228\n\t* doc/invoke.texi (comdat-sharing-probability): Document.\n\t* ipa-inline.c (cgraph_estimate_growth): Handle COMDATs\n\t* params.def (PARAM_COMDAT_SHARING_PROBABILITY): New param.\n\t* g++.dg/tree-ssa/pr46228.C: New testcase.\n\nFrom-SVN: r166555", "tree": {"sha": "d022ce30fea75864afaa32f9c9554dbd2b710d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d022ce30fea75864afaa32f9c9554dbd2b710d9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d0600d09df75581455e2152500866aa5d49f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d0600d09df75581455e2152500866aa5d49f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d0600d09df75581455e2152500866aa5d49f2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d0600d09df75581455e2152500866aa5d49f2e/comments", "author": null, "committer": null, "parents": [{"sha": "d707fc773877a218f563042d5c26657c5d1bd736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d707fc773877a218f563042d5c26657c5d1bd736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d707fc773877a218f563042d5c26657c5d1bd736"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "dc79b8803aafba7765b540209287744a0798951f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c5d0600d09df75581455e2152500866aa5d49f2e", "patch": "@@ -8343,6 +8343,11 @@ Limit of iterations of early inliner.  This basically bounds number of nested\n indirect calls early inliner can resolve.  Deeper chains are still handled by\n late inlining.\n \n+@item comdat-sharing-probability\n+@itemx comdat-sharing-probability\n+Probability (in percent) that C++ inline function with comdat visibility\n+will be shared acroess multiple compilation units.  The default value is 20.\n+\n @item min-vect-loop-bound\n The minimum number of iterations under which a loop will not get vectorized\n when @option{-ftree-vectorize} is used.  The number of iterations after"}, {"sha": "d4109c5a21f110277c6d06f388fb64dfdeb13d7f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c5d0600d09df75581455e2152500866aa5d49f2e", "patch": "@@ -404,6 +404,12 @@ cgraph_estimate_growth (struct cgraph_node *node)\n   if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n       && !DECL_EXTERNAL (node->decl) && !self_recursive)\n     growth -= node->global.size;\n+  /* COMDAT functions are very often not shared across multiple units since they\n+     come from various template instantiations.  Take this into account.  */\n+  else  if (DECL_COMDAT (node->decl) && !self_recursive\n+\t    && cgraph_can_remove_if_no_direct_calls_p (node))\n+    growth -= (node->global.size\n+\t       * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n \n   node->global.estimated_growth = growth;\n   return growth;"}, {"sha": "6e55db63fcb55d7c8586309b8a4750e4ae8b2961", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=c5d0600d09df75581455e2152500866aa5d49f2e", "patch": "@@ -117,6 +117,12 @@ DEFPARAM (PARAM_EARLY_INLINER_MAX_ITERATIONS,\n \t  \"The maximum number of nested indirect inlining performed by early inliner\",\n \t  10, 0, 0)\n \n+/* Limit on probability of entry BB.  */\n+DEFPARAM (PARAM_COMDAT_SHARING_PROBABILITY,\n+\t  \"comdat-sharing-probability\",\n+\t  \"Probability that COMDAT function will be shared with different compilatoin unit\",\n+\t  20, 0, 0)\n+\n /* Limit on probability of entry BB.  */\n DEFPARAM (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY,\n \t  \"partial-inlining-entry-probability\","}, {"sha": "661e55bd7bc418308d94ad95824f993baafbb849", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5d0600d09df75581455e2152500866aa5d49f2e", "patch": "@@ -1,3 +1,8 @@\n+2010-11-10  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimize/46228\n+\t* g++.dg/tree-ssa/pr46228.C: New testcase.\n+\n 2010-11-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR tree-optimization/46414"}, {"sha": "a720dbe3b8c25cb66651e70a431723efbc5c6132", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr46228.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46228.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d0600d09df75581455e2152500866aa5d49f2e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46228.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr46228.C?ref=c5d0600d09df75581455e2152500866aa5d49f2e", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options \"-fdump-tree-optimized -Os\" }\n+#include <set>\n+#include <stdio.h>\n+\n+int main()\n+{\n+  static const int array[] = { 1,2,3,4,5,6,7,8,9,10,6 };\n+  std::set<int> the_set;\n+  int count = 0;\n+  for (unsigned i = 0; i < sizeof(array)/sizeof(*array); i++)\n+  {\n+    std::pair<std::set<int>::iterator, bool> result =\n+      the_set.insert(array[i]);\n+    if (result.second)\n+      count++;\n+  }\n+  printf(\"%d unique items in array.\\n\", count);\n+  return 0;\n+}\n+\n+// This function is small enough to be inlined even at -Os.\n+// { dg-final { scan-tree-dump-not \"_ZNSt8_Rb_treeIiiSt9_IdentityIiESt4lessIiESaIiEED2Ev\" \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}]}