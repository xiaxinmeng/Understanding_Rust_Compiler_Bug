{"sha": "83205b9b4a516a226e3b07ffb9dc534d93458381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyMDViOWI0YTUxNmEyMjZlM2IwN2ZmYjlkYzUzNGQ5MzQ1ODM4MQ==", "commit": {"author": {"name": "Wolfgang Bangerth", "email": "bangerth@ticam.utexas.edu", "date": "2003-02-07T23:12:03Z"}, "committer": {"name": "Gerald Pfeifer", "email": "gerald@gcc.gnu.org", "date": "2003-02-07T23:12:03Z"}, "message": "* doc/trouble.texi: Document pitfalls of two-stage name lookup.\n\nFrom-SVN: r62558", "tree": {"sha": "c6e527aa45da091543e8cba01afde68d314c24da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e527aa45da091543e8cba01afde68d314c24da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83205b9b4a516a226e3b07ffb9dc534d93458381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83205b9b4a516a226e3b07ffb9dc534d93458381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83205b9b4a516a226e3b07ffb9dc534d93458381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83205b9b4a516a226e3b07ffb9dc534d93458381/comments", "author": null, "committer": null, "parents": [{"sha": "710ee3ed76eeafcb4fe72a51448b7e396c436e14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710ee3ed76eeafcb4fe72a51448b7e396c436e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710ee3ed76eeafcb4fe72a51448b7e396c436e14"}], "stats": {"total": 95, "additions": 94, "deletions": 1}, "files": [{"sha": "80f94bc64bd391bc4b5ae2f6528bf4cf8f8feab8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83205b9b4a516a226e3b07ffb9dc534d93458381/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83205b9b4a516a226e3b07ffb9dc534d93458381/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83205b9b4a516a226e3b07ffb9dc534d93458381", "patch": "@@ -1,3 +1,7 @@\n+2003-02-07  Wolfgang Bangerth  <bangerth@ticam.utexas.edu>\n+\n+\t* doc/trouble.texi: Document pitfalls of two-stage name lookup.\n+\n 2003-02-07  Richard Henderson  <rth@redhat.com>\n \n \tPR 9226"}, {"sha": "90d012e0ecdecf15939104038320a26cb652365c", "filename": "gcc/doc/trouble.texi", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83205b9b4a516a226e3b07ffb9dc534d93458381/gcc%2Fdoc%2Ftrouble.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83205b9b4a516a226e3b07ffb9dc534d93458381/gcc%2Fdoc%2Ftrouble.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftrouble.texi?ref=83205b9b4a516a226e3b07ffb9dc534d93458381", "patch": "@@ -851,6 +851,7 @@ give rise to questions of this sort.\n \n @menu\n * Static Definitions::  Static member declarations are not definitions\n+* Name lookup::         Name lookup, templates, and accessing members of base classes\n * Temporaries::         Temporaries may vanish before you expect\n * Copy Assignment::     Copy Assignment operators copy virtual bases twice\n @end menu\n@@ -891,6 +892,94 @@ you may discover that a program that appeared to work correctly in fact\n does not conform to the standard: @command{g++} reports as undefined\n symbols any static data members that lack definitions.\n \n+\n+@node Name lookup\n+@subsection Name lookup, templates, and accessing members of base classes\n+\n+@cindex base class members\n+@cindex two-stage name lookup\n+@cindex dependent name lookup\n+\n+The C++ standard prescribes that all names that are not dependent on\n+template parameters are bound to their present definitions when parsing\n+a template function or class.@footnote{The C++ standard just uses the\n+term ``dependent'' for names that depend on the type or value of\n+template parameters.  This shorter term will also be used in the rest of\n+this section.}  Only names that are dependent are looked up at the point\n+of instantiation.  For example, consider\n+\n+@example\n+  void foo(double);\n+\n+  struct A @{\n+    template <typename T>\n+    void f () @{\n+      foo (1);        // 1\n+      int i = N;      // 2\n+      T t;\n+      t.bar();        // 3\n+      foo (t);        // 4\n+    @}\n+\n+    static const int N;\n+  @};\n+@end example\n+\n+Here, the names @code{foo} and @code{N} appear in a context that does\n+not depend on the type of @code{T}.  The compiler will thus require that\n+they are defined in the context of use in the template, not only before\n+the point of instantiation, and will here use @code{::foo(double)} and\n+@code{A::N}, respectively.  In particular, it will convert the integer\n+value to a @code{double} when passing it to @code{::foo(double)}.\n+\n+Conversely, @code{bar} and the call to @code{foo} in the fourth marked\n+line are used in contexts that do depend on the type of @code{T}, so\n+they are only looked up at the point of instantiation, and you can\n+provide declarations for them after declaring the template, but before\n+instantiating it.  In particular, if you instantiate @code{A::f<int>},\n+the last line will call an overloaded @code{::foo(int)} if one was\n+provided, even if after the declaration of @code{struct A}.\n+\n+This distinction between lookup of dependent and non-dependent names is\n+called two-stage (or dependent) name lookup. G++ implements some\n+features of it since version 3.4 and is moving towards full compliance\n+with the standard.\n+\n+Two-stage name lookup sometimes leads to situations with behavior\n+different from non-template codes. The most common is probably this:\n+\n+@example\n+  template <typename T> struct Base @{\n+    int i;\n+  @};\n+\n+  template <typename T> struct Derived : public Base<T> @{\n+    int get_i() @{ return i; @}\n+  @};\n+@end example\n+\n+In @code{get_i()}, @code{i} is not used in a dependent context, so the\n+compiler will look for a name declared at the enclosing namespace scope\n+(which is the global scope here).  It will not look into the base class,\n+since that is dependent and you may declare specializations of\n+@code{Base} even after declaring @code{Derived}, so the compiler can't\n+really know what @code{i} would refer to.  If there is no global\n+variable @code{i}, then you will get an error message.\n+\n+In order to make it clear that you want the member of the base class,\n+you need to defer lookup until instantiation time, at which the base\n+class is known.  For this, you need to access @code{i} in a dependent\n+context, by either using @code{this->i} (remember that @code{this} is of\n+type @code{Derived<T>*}, so is obviously dependent), or using\n+@code{Base<T>::i}. Alternatively, @code{Base<T>::i} might be brought\n+into scope by a @code{using}-declaration.\n+\n+Note that some compilers get this wrong and accept above code without an\n+error.  However, this is spurious, since they just don't implement\n+two-stage name lookup correctly.  This includes G++ versions prior to\n+3.4.\n+\n+\n @node Temporaries\n @subsection Temporaries May Vanish Before You Expect\n \n@@ -993,7 +1082,7 @@ inside @samp{func} in the example).\n \n g++ implements the ``intuitive'' algorithm for copy-assignment: assign all\n direct bases, then assign all members.  In that algorithm, the virtual\n-base subobject can be encountered many times.  In the example, copying\n+base subobject can be encountered more than once.  In the example, copying\n proceeds in the following order: @samp{val}, @samp{name} (via\n @code{strdup}), @samp{bval}, and @samp{name} again.\n "}]}