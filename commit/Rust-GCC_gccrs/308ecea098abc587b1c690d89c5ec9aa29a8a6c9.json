{"sha": "308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA4ZWNlYTA5OGFiYzU4N2IxYzY5MGQ4OWM1ZWM5YWEyOWE4YTZjOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-15T11:13:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-15T11:13:04Z"}, "message": "expmed.c (store_bit_field): Consider naturally aligned memory for direct reference.\n\n        * expmed.c (store_bit_field): Consider naturally aligned\n        memory for direct reference.\n\nFrom-SVN: r36431", "tree": {"sha": "5c3d481d792fb5e4774cbae90ba4d86701a9ca24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c3d481d792fb5e4774cbae90ba4d86701a9ca24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308ecea098abc587b1c690d89c5ec9aa29a8a6c9/comments", "author": null, "committer": null, "parents": [{"sha": "e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01acbb16e7207ef8aad5e3257c9f9dfc64795d6"}], "stats": {"total": 32, "additions": 20, "deletions": 12}, "files": [{"sha": "c80ffa859f3dbd4ad107ff3e0be95cd39e1b8850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308ecea098abc587b1c690d89c5ec9aa29a8a6c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308ecea098abc587b1c690d89c5ec9aa29a8a6c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "patch": "@@ -1,3 +1,8 @@\n+2000-09-15  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expmed.c (store_bit_field): Consider naturally aligned\n+\tmemory for direct reference.\n+\n 2000-09-15  Richard Henderson  <rth@cygnus.com>\n \n \t* config/alpha/alpha.c (alpha_expand_unaligned_load): Force all"}, {"sha": "e2ca70a13abf27b30b242431d57605154d8d22ae", "filename": "gcc/expmed.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308ecea098abc587b1c690d89c5ec9aa29a8a6c9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308ecea098abc587b1c690d89c5ec9aa29a8a6c9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=308ecea098abc587b1c690d89c5ec9aa29a8a6c9", "patch": "@@ -297,19 +297,22 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   if (flag_force_mem)\n     value = force_not_mem (value);\n \n-  if ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n-       || (GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode)\n-\t   && GET_MODE_SIZE (fieldmode) != 0))\n-      && (GET_CODE (op0) != MEM\n-\t  || ! SLOW_UNALIGNED_ACCESS (fieldmode, align)\n-\t  || (offset * BITS_PER_UNIT % bitsize == 0\n-\t      && align % GET_MODE_BITSIZE (fieldmode) == 0))\n-      && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n-      && bitsize == GET_MODE_BITSIZE (fieldmode))\n+  /* If the target is a register, overwriting the entire object, or storing\n+     a full-word or multi-word field can be done with just a SUBREG.\n+\n+     If the target is memory, storing any naturally aligned field can be\n+     done with a simple store.  For targets that support fast unaligned\n+     memory, any naturally sized, unit aligned field can be done directly.  */\n+     \n+  if (bitsize == GET_MODE_BITSIZE (fieldmode)\n+      && (GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n+\t  || GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode)\n+\t  || (GET_CODE (op0) == MEM\n+\t      && (! SLOW_UNALIGNED_ACCESS (fieldmode, align)\n+\t\t  || (offset * BITS_PER_UNIT % bitsize == 0\n+\t\t      && align % GET_MODE_BITSIZE (fieldmode) == 0))))\n+      && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0))\n     {\n-      /* Storing in a full-word or multi-word field in a register\n-\t can be done with just SUBREG.  Also, storing in the entire object\n-\t can be done with just SUBREG.  */\n       if (GET_MODE (op0) != fieldmode)\n \t{\n \t  if (GET_CODE (op0) == SUBREG)"}]}