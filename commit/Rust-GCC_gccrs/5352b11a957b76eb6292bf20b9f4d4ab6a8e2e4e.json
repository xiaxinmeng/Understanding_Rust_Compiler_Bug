{"sha": "5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1MmIxMWE5NTdiNzZlYjYyOTJiZjIwYjlmNGQ0YWI2YThlMmU0ZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-22T03:40:10Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-06-22T03:40:10Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1232", "tree": {"sha": "8565d33f161aa52aeac3d5fe4d5063c019a9fb0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8565d33f161aa52aeac3d5fe4d5063c019a9fb0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/comments", "author": null, "committer": null, "parents": [{"sha": "ab40ad2b6ad5769c8bcb4741c47b93622d1a8a09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab40ad2b6ad5769c8bcb4741c47b93622d1a8a09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab40ad2b6ad5769c8bcb4741c47b93622d1a8a09"}], "stats": {"total": 139, "additions": 119, "deletions": 20}, "files": [{"sha": "aaff89243992460a45f38887f15472df268ddf4c", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "patch": "@@ -2921,7 +2921,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t  break;\n \n \tcase FLOAT_TRUNCATE:\n-\t  d = (double) REAL_VALUE_TRUNCATE (mode, d);\n+\t  d = (double) real_value_truncate (mode, d);\n \t  break;\n \n \tcase FLOAT_EXTEND:\n@@ -3061,8 +3061,8 @@ simplify_binary_operation (code, mode, op0, op1)\n \n       REAL_VALUE_FROM_CONST_DOUBLE (f0, op0);\n       REAL_VALUE_FROM_CONST_DOUBLE (f1, op1);\n-      f0 = REAL_VALUE_TRUNCATE (mode, f0);\n-      f1 = REAL_VALUE_TRUNCATE (mode, f1);\n+      f0 = real_value_truncate (mode, f0);\n+      f1 = real_value_truncate (mode, f1);\n \n #ifdef REAL_ARITHMETIC\n       REAL_ARITHMETIC (value, code, f0, f1);\n@@ -3097,7 +3097,7 @@ simplify_binary_operation (code, mode, op0, op1)\n #endif\n \n       set_float_handler (0);\n-      value = REAL_VALUE_TRUNCATE (mode, value);\n+      value = real_value_truncate (mode, value);\n       return immed_real_const_1 (value, mode);\n     }\n "}, {"sha": "a8a3f370727ab7bea18bc6d81eda879e52c379da", "filename": "gcc/fold-const.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "patch": "@@ -699,6 +699,35 @@ div_and_round_double (code, uns,\n   add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n }\n \f\n+/* Effectively truncate a real value to represent\n+   the nearest possible value in a narrower mode.\n+   The result is actually represented in the same data type as the argument,\n+   but its value is usually different.  */\n+\n+REAL_VALUE_TYPE\n+real_value_truncate (mode, arg)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE arg;\n+{\n+#ifdef __STDC__\n+  /* Make sure the value is actually stored in memory before we turn off\n+     the handler.  */\n+  volatile\n+#endif\n+    REAL_VALUE_TYPE value;\n+  jmp_buf handler;\n+\n+  if (setjmp (handler))\n+    {\n+      error (\"floating overflow\");\n+      return dconst0;\n+    }\n+  set_float_handler (handler);\n+  value = REAL_VALUE_TRUNCATE (mode, arg);\n+  set_float_handler (0);\n+  return value;\n+}\n+\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n \n /* Check for infinity in an IEEE double precision number.  */\n@@ -1215,7 +1244,7 @@ const_binop (code, arg1, arg2)\n \t}\n #endif /* no REAL_ARITHMETIC */\n       t = build_real (TREE_TYPE (arg1),\n-\t\t      REAL_VALUE_TRUNCATE (TYPE_MODE (TREE_TYPE (arg1)), value));\n+\t\t      real_value_truncate (TYPE_MODE (TREE_TYPE (arg1)), value));\n       set_float_handler (0);\n       return t;\n     }\n@@ -1423,7 +1452,7 @@ fold_convert (t, arg1)\n \t    }\n \t  set_float_handler (float_error);\n \n-\t  t = build_real (type, REAL_VALUE_TRUNCATE (TYPE_MODE (type),\n+\t  t = build_real (type, real_value_truncate (TYPE_MODE (type),\n \t\t\t\t\t\t     TREE_REAL_CST (arg1)));\n \t  set_float_handler (0);\n \t  return t;"}, {"sha": "e191944cb2d3facb415b79255bba876f8cf95148", "filename": "gcc/real.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "patch": "@@ -154,6 +154,9 @@ extern double (atof) ();\n    for the most common case where the host and target have objects of the same\n    size and where `float' is SFmode.  */\n \n+/* Don't use REAL_VALUE_TRUNCATE directly--always call real_value_truncate.  */\n+extern REAL_VALUE_TYPE real_value_truncate ();\n+\n #ifndef REAL_VALUE_TRUNCATE\n #define REAL_VALUE_TRUNCATE(mode, x) \\\n  (GET_MODE_BITSIZE (mode) == sizeof (float) * HOST_BITS_PER_CHAR\t\\"}, {"sha": "4cf074c196389b5146ed2aa266da224a5ae67ac2", "filename": "gcc/reload1.c", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5352b11a957b76eb6292bf20b9f4d4ab6a8e2e4e", "patch": "@@ -319,6 +319,7 @@ static void reload_as_needed ();\n static int modes_equiv_for_class_p ();\n static void alter_reg ();\n static void delete_dead_insn ();\n+static void spill_failure ();\n static int new_spill_reg();\n static void set_label_offsets ();\n static int eliminate_regs_in_insn ();\n@@ -477,9 +478,12 @@ init_reload ()\n    DUMPFILE is the global-reg debugging dump file stream, or 0.\n    If it is nonzero, messages are written to it to describe\n    which registers are seized as reload regs, which pseudo regs\n-   are spilled from them, and where the pseudo regs are reallocated to.  */\n+   are spilled from them, and where the pseudo regs are reallocated to.\n \n-void\n+   Return value is nonzero if reload failed\n+   and we must not do any more for this function.  */\n+\n+int\n reload (first, global, dumpfile)\n      rtx first;\n      int global;\n@@ -497,6 +501,9 @@ reload (first, global, dumpfile)\n   enum reg_class caller_save_spill_class = NO_REGS;\n   int caller_save_group_size = 1;\n \n+  /* Nonzero means we couldn't get enough spill regs.  */\n+  int failure = 0;\n+\n   /* The basic block number currently being processed for INSN.  */\n   int this_block;\n \n@@ -777,12 +784,19 @@ reload (first, global, dumpfile)\n \t they must be the same size and equally restrictive for that class,\n \t otherwise we can't handle the complexity.  */\n       enum machine_mode group_mode[N_REG_CLASSES];\n+      /* Record the insn where each maximum need is first found.  */\n+      rtx max_needs_insn[N_REG_CLASSES];\n+      rtx max_groups_insn[N_REG_CLASSES];\n+      rtx max_nongroups_insn[N_REG_CLASSES];\n       rtx x;\n \n       something_changed = 0;\n       bzero (max_needs, sizeof max_needs);\n       bzero (max_groups, sizeof max_groups);\n       bzero (max_nongroups, sizeof max_nongroups);\n+      bzero (max_needs_insn, sizeof max_needs_insn);\n+      bzero (max_groups_insn, sizeof max_groups_insn);\n+      bzero (max_nongroups_insn, sizeof max_nongroups_insn);\n       bzero (group_size, sizeof group_size);\n       for (i = 0; i < N_REG_CLASSES; i++)\n \tgroup_mode[i] = VOIDmode;\n@@ -1271,12 +1285,21 @@ reload (first, global, dumpfile)\n \t      for (i = 0; i < N_REG_CLASSES; i++)\n \t\t{\n \t\t  if (max_needs[i] < insn_needs[i])\n-\t\t    max_needs[i] = insn_needs[i];\n+\t\t    {\n+\t\t      max_needs[i] = insn_needs[i];\n+\t\t      max_needs_insn[i] = insn;\n+\t\t    }\n \t\t  if (max_groups[i] < insn_groups[i])\n-\t\t    max_groups[i] = insn_groups[i];\n+\t\t    {\n+\t\t      max_groups[i] = insn_groups[i];\n+\t\t      max_groups_insn[i] = insn;\n+\t\t    }\n \t\t  if (insn_total_groups > 0)\n \t\t    if (max_nongroups[i] < insn_needs[i])\n-\t\t      max_nongroups[i] = insn_needs[i];\n+\t\t      {\n+\t\t\tmax_nongroups[i] = insn_needs[i];\n+\t\t\tmax_nongroups_insn[i] = insn;\n+\t\t      }\n \t\t}\n \t    }\n \t  /* Note that there is a continue statement above.  */\n@@ -1567,9 +1590,17 @@ reload (first, global, dumpfile)\n \t\t  /* I should be the index in potential_reload_regs\n \t\t     of the new reload reg we have found.  */\n \n-\t\t  something_changed\n-\t\t    |= new_spill_reg (i, class, max_needs, 0,\n-\t\t\t\t      global, dumpfile);\n+\t\t  if (i >= FIRST_PSEUDO_REGISTER)\n+\t\t    {\n+\t\t      /* There are no groups left to spill.  */\n+\t\t      spill_failure (max_groups_insn[class]);\n+\t\t      failure = 1;\n+\t\t      goto failed;\n+\t\t    }\n+\t\t  else\n+\t\t    something_changed\n+\t\t      |= new_spill_reg (i, class, max_needs, 0,\n+\t\t\t\t\tglobal, dumpfile);\n \t\t}\n \t      else\n \t\t{\n@@ -1600,9 +1631,17 @@ reload (first, global, dumpfile)\n \t\t\t\t  for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n \t\t\t\t    if (potential_reload_regs[idx] == j + k)\n \t\t\t\t      break;\n-\t\t\t\t  something_changed\n-\t\t\t\t    |= new_spill_reg (idx, class, max_needs, 0,\n-\t\t\t\t\t\t      global, dumpfile);\n+\t\t\t\t    if (i >= FIRST_PSEUDO_REGISTER)\n+\t\t\t\t      {\n+\t\t\t\t\t/* There are no groups left.  */\n+\t\t\t\t\tspill_failure (max_groups_insn[class]);\n+\t\t\t\t\tfailure = 1;\n+\t\t\t\t\tgoto failed;\n+\t\t\t\t      }\n+\t\t\t\t    else\n+\t\t\t\t      something_changed\n+\t\t\t\t\t|= new_spill_reg (idx, class, max_needs, 0,\n+\t\t\t\t\t\t\t  global, dumpfile);\n \t\t\t\t}\n \n \t\t\t      /* We have found one that will complete a group,\n@@ -1648,9 +1687,18 @@ reload (first, global, dumpfile)\n \t      /* I should be the index in potential_reload_regs\n \t\t of the new reload reg we have found.  */\n \n-\t      something_changed\n-\t\t|= new_spill_reg (i, class, max_needs, max_nongroups,\n-\t\t\t\t  global, dumpfile);\n+\t      if (i >= FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  /* There are no possible registers left to spill.  */\n+\t\t  spill_failure (max_needs[class] > 0 ? max_needs_insn[class]\n+\t\t\t\t : max_nongroups_insn[class]);\n+\t\t  failure = 1;\n+\t\t  goto failed;\n+\t\t}\n+\t      else\n+\t\tsomething_changed\n+\t\t  |= new_spill_reg (i, class, max_needs, max_nongroups,\n+\t\t\t\t    global, dumpfile);\n \t    }\n \t}\n     }\n@@ -1706,6 +1754,10 @@ reload (first, global, dumpfile)\n \n   reload_in_progress = 0;\n \n+  /* Come here (with failure set nonzero) if we can't get enough spill regs\n+     and we decide not to abort about it.  */\n+ failed:\n+\n   /* Now eliminate all pseudo regs by modifying them into\n      their equivalent memory references.\n      The REG-rtx's for the pseudos are modified in place,\n@@ -1766,6 +1818,8 @@ reload (first, global, dumpfile)\n   /* Indicate that we no longer have known memory locations or constants.  */\n   reg_equiv_constant = 0;\n   reg_equiv_memory_loc = 0;\n+\n+  return failure;\n }\n \f\n /* Nonzero if, after spilling reg REGNO for non-groups,\n@@ -1917,6 +1971,19 @@ modes_equiv_for_class_p (allocate_mode, other_mode, class)\n   return 1;\n }\n \n+/* Handle the failure to find a register to spill.\n+   INSN should be one of the insns which needed this particular spill reg.  */\n+\n+static void\n+spill_failure (insn)\n+     rtx insn;\n+{\n+  if (asm_noperands (PATTERN (insn)) >= 0)\n+    error_for_asm (insn, \"`asm' needs too many reloads\");\n+  else\n+    abort ();\n+}\n+\n /* Add a new register to the tables of available spill-registers\n     (as well as spilling all pseudos allocated to the register).\n    I is the index of this register in potential_reload_regs."}]}