{"sha": "c2669da93de6bb84df96b14167429f2046acf4b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI2NjlkYTkzZGU2YmI4NGRmOTZiMTQxNjc0MjlmMjA0NmFjZjRiOA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-09-24T02:05:00Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-09-24T02:05:00Z"}, "message": "Makefile.am: Add regex.tcc.\n\n2013-09-24  Tim Shen  <timshen91@gmail.com>\n\n\t* include/Makefile.am: Add regex.tcc.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/regex.h: Remove definitions to regex.tcc.\n\t* include/bits/regex.tcc: New.\n\t(match_results::format, regex_replace): Implement;\n\t* include/bits/regex_compiler.h: Move _M_flags to the top of class\n\tmember list, because other members' initialization depend on it.\n\t* include/bits/regex_compiler.tcc\n\t(_Compiler<>::_Compiler): Adjust member initializations.\n\t(_Compiler<>::_M_quantifier): Fix ungreedy interval quantifier.\n\t* include/bits/regex_executor.h: Remove _RegexT from _*Executor classes.\n\tIn the future, all regex classes may refactor to *Impl style.\n\t* include/bits/regex_executor.tcc (_Executor::_M_set_results):\n\tMerge identical code from _*Executor classes.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tstring_dispatch_01.cc (fake_match<>): Adjust the hacking-style testcase\n\tcaller for new __get_executors interface.\n\t* testsuite/28_regex/algorithms/regex_replace/char/basic_replace.cc:\n\tNew.\n\t* testsuite/28_regex/match_results/format.cc: New.\n\t* testsuite/28_regex/traits/char/lookup_collatename.cc: Remove digraph\n\ttestcase.\n\t* testsuite/28_regex/traits/wchar_t/lookup_collatename.cc: Likewise.\n\nFrom-SVN: r202858", "tree": {"sha": "f337d8cd5418382592d93b47f24f42a62224bd74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f337d8cd5418382592d93b47f24f42a62224bd74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2669da93de6bb84df96b14167429f2046acf4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2669da93de6bb84df96b14167429f2046acf4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2669da93de6bb84df96b14167429f2046acf4b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2669da93de6bb84df96b14167429f2046acf4b8/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5704e0224012d70573d27f7934b672ee5ff99549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5704e0224012d70573d27f7934b672ee5ff99549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5704e0224012d70573d27f7934b672ee5ff99549"}], "stats": {"total": 1657, "additions": 1048, "deletions": 609}, "files": [{"sha": "432c36a151b5e17a9693ea64629c2496e9cb0bf7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -1,3 +1,29 @@\n+2013-09-24  Tim Shen  <timshen91@gmail.com>\n+\n+\t* include/Makefile.am: Add regex.tcc.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/regex.h: Remove definitions to regex.tcc.\n+\t* include/bits/regex.tcc: New.\n+\t(match_results::format, regex_replace): Implement;\n+\t* include/bits/regex_compiler.h: Move _M_flags to the top of class\n+\tmember list, because other members' initialization depend on it.\n+\t* include/bits/regex_compiler.tcc\n+\t(_Compiler<>::_Compiler): Adjust member initializations.\n+\t(_Compiler<>::_M_quantifier): Fix ungreedy interval quantifier.\n+\t* include/bits/regex_executor.h: Remove _RegexT from _*Executor classes.\n+\tIn the future, all regex classes may refactor to *Impl style.\n+\t* include/bits/regex_executor.tcc (_Executor::_M_set_results):\n+\tMerge identical code from _*Executor classes.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_dispatch_01.cc (fake_match<>): Adjust the hacking-style testcase\n+\tcaller for new __get_executors interface.\n+\t* testsuite/28_regex/algorithms/regex_replace/char/basic_replace.cc:\n+\tNew.\n+\t* testsuite/28_regex/match_results/format.cc: New.\n+\t* testsuite/28_regex/traits/char/lookup_collatename.cc: Remove digraph\n+\ttestcase.\n+\t* testsuite/28_regex/traits/wchar_t/lookup_collatename.cc: Likewise.\n+\n 2013-09-23  Paul Pluzhnikov  <ppluzhnikov@google.com>\n \n \t* src/c++11/snprintf_lite.cc (__concat_size_t): Use"}, {"sha": "3be6e5750d60bb989cc1160569583731030c0016", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -126,6 +126,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/regex.h \\\n+\t${bits_srcdir}/regex.tcc \\\n \t${bits_srcdir}/regex_constants.h \\\n \t${bits_srcdir}/regex_error.h \\\n \t${bits_srcdir}/regex_scanner.h \\"}, {"sha": "cd0b467315f26d9def746db035cf8f7e62c4304f", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -393,6 +393,7 @@ bits_headers = \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\\n \t${bits_srcdir}/regex.h \\\n+\t${bits_srcdir}/regex.tcc \\\n \t${bits_srcdir}/regex_constants.h \\\n \t${bits_srcdir}/regex_error.h \\\n \t${bits_srcdir}/regex_scanner.h \\"}, {"sha": "cbe903625b9db706dd2b0346ecde9d7755106509", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 134, "deletions": 516, "changes": 650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -214,7 +214,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        * is known and can be converted into a primary sort key\n        * then returns that key, otherwise returns an empty string.\n        *\n-       * @todo Implement this function.\n+       * @todo Implement this function correctly.\n        */\n       template<typename _Fwd_iter>\n \tstring_type\n@@ -343,278 +343,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       locale_type _M_locale;\n     };\n \n-  template<typename _Ch_type>\n-  template<typename _Fwd_iter>\n-    typename regex_traits<_Ch_type>::string_type\n-    regex_traits<_Ch_type>::\n-    lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n-    {\n-      typedef std::ctype<char_type> __ctype_type;\n-      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-\n-      static const char* __collatenames[] =\n-\t{\n-\t  \"NUL\",\n-\t  \"SOH\",\n-\t  \"STX\",\n-\t  \"ETX\",\n-\t  \"EOT\",\n-\t  \"ENQ\",\n-\t  \"ACK\",\n-\t  \"alert\",\n-\t  \"backspace\",\n-\t  \"tab\",\n-\t  \"newline\",\n-\t  \"vertical-tab\",\n-\t  \"form-feed\",\n-\t  \"carriage-return\",\n-\t  \"SO\",\n-\t  \"SI\",\n-\t  \"DLE\",\n-\t  \"DC1\",\n-\t  \"DC2\",\n-\t  \"DC3\",\n-\t  \"DC4\",\n-\t  \"NAK\",\n-\t  \"SYN\",\n-\t  \"ETB\",\n-\t  \"CAN\",\n-\t  \"EM\",\n-\t  \"SUB\",\n-\t  \"ESC\",\n-\t  \"IS4\",\n-\t  \"IS3\",\n-\t  \"IS2\",\n-\t  \"IS1\",\n-\t  \"space\",\n-\t  \"exclamation-mark\",\n-\t  \"quotation-mark\",\n-\t  \"number-sign\",\n-\t  \"dollar-sign\",\n-\t  \"percent-sign\",\n-\t  \"ampersand\",\n-\t  \"apostrophe\",\n-\t  \"left-parenthesis\",\n-\t  \"right-parenthesis\",\n-\t  \"asterisk\",\n-\t  \"plus-sign\",\n-\t  \"comma\",\n-\t  \"hyphen\",\n-\t  \"period\",\n-\t  \"slash\",\n-\t  \"zero\",\n-\t  \"one\",\n-\t  \"two\",\n-\t  \"three\",\n-\t  \"four\",\n-\t  \"five\",\n-\t  \"six\",\n-\t  \"seven\",\n-\t  \"eight\",\n-\t  \"nine\",\n-\t  \"colon\",\n-\t  \"semicolon\",\n-\t  \"less-than-sign\",\n-\t  \"equals-sign\",\n-\t  \"greater-than-sign\",\n-\t  \"question-mark\",\n-\t  \"commercial-at\",\n-\t  \"A\",\n-\t  \"B\",\n-\t  \"C\",\n-\t  \"D\",\n-\t  \"E\",\n-\t  \"F\",\n-\t  \"G\",\n-\t  \"H\",\n-\t  \"I\",\n-\t  \"J\",\n-\t  \"K\",\n-\t  \"L\",\n-\t  \"M\",\n-\t  \"N\",\n-\t  \"O\",\n-\t  \"P\",\n-\t  \"Q\",\n-\t  \"R\",\n-\t  \"S\",\n-\t  \"T\",\n-\t  \"U\",\n-\t  \"V\",\n-\t  \"W\",\n-\t  \"X\",\n-\t  \"Y\",\n-\t  \"Z\",\n-\t  \"left-square-bracket\",\n-\t  \"backslash\",\n-\t  \"right-square-bracket\",\n-\t  \"circumflex\",\n-\t  \"underscore\",\n-\t  \"grave-accent\",\n-\t  \"a\",\n-\t  \"b\",\n-\t  \"c\",\n-\t  \"d\",\n-\t  \"e\",\n-\t  \"f\",\n-\t  \"g\",\n-\t  \"h\",\n-\t  \"i\",\n-\t  \"j\",\n-\t  \"k\",\n-\t  \"l\",\n-\t  \"m\",\n-\t  \"n\",\n-\t  \"o\",\n-\t  \"p\",\n-\t  \"q\",\n-\t  \"r\",\n-\t  \"s\",\n-\t  \"t\",\n-\t  \"u\",\n-\t  \"v\",\n-\t  \"w\",\n-\t  \"x\",\n-\t  \"y\",\n-\t  \"z\",\n-\t  \"left-curly-bracket\",\n-\t  \"vertical-line\",\n-\t  \"right-curly-bracket\",\n-\t  \"tilde\",\n-\t  \"DEL\",\n-\t  \"\"\n-\t};\n-\n-      // same as boost\n-      static const char* __digraphs[] =\n-\t{\n-\t  \"ae\",\n-\t  \"Ae\",\n-\t  \"AE\",\n-\t  \"ch\",\n-\t  \"Ch\",\n-\t  \"CH\",\n-\t  \"ll\",\n-\t  \"Ll\",\n-\t  \"LL\",\n-\t  \"ss\",\n-\t  \"Ss\",\n-\t  \"SS\",\n-\t  \"nj\",\n-\t  \"Nj\",\n-\t  \"NJ\",\n-\t  \"dz\",\n-\t  \"Dz\",\n-\t  \"DZ\",\n-\t  \"lj\",\n-\t  \"Lj\",\n-\t  \"LJ\",\n-\t  \"\"\n-\t};\n-\n-      std::string __s(__last - __first, '?');\n-      __fctyp.narrow(__first, __last, '?', &*__s.begin());\n-\n-      for (unsigned int __i = 0; *__collatenames[__i]; __i++)\n-\tif (__s == __collatenames[__i])\n-\t  return string_type(1, __fctyp.widen((char)__i));\n-\n-      for (unsigned int __i = 0; *__digraphs[__i]; __i++)\n-\t{\n-\t  const char* __now = __digraphs[__i];\n-\t  if (__s == __now)\n-\t    {\n-\t      string_type ret(__s.size(), __fctyp.widen('?'));\n-\t      __fctyp.widen(__now, __now + 2/* ouch */, &*ret.begin());\n-\t      return ret;\n-\t    }\n-\t}\n-      return string_type();\n-    }\n-\n-  template<typename _Ch_type>\n-  template<typename _Fwd_iter>\n-    typename regex_traits<_Ch_type>::char_class_type\n-    regex_traits<_Ch_type>::\n-    lookup_classname(_Fwd_iter __first, _Fwd_iter __last, bool __icase) const\n-    {\n-      typedef std::ctype<char_type> __ctype_type;\n-      typedef std::ctype<char> __cctype_type;\n-      typedef const pair<const char*, char_class_type> _ClassnameEntry;\n-      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-      const __cctype_type& __cctyp(use_facet<__cctype_type>(_M_locale));\n-\n-      static _ClassnameEntry __classnames[] =\n-      {\n-\t{\"d\", ctype_base::digit},\n-\t{\"w\", {ctype_base::alnum, _RegexMask::_S_under}},\n-\t{\"s\", ctype_base::space},\n-\t{\"alnum\", ctype_base::alnum},\n-\t{\"alpha\", ctype_base::alpha},\n-\t{\"blank\", {0, _RegexMask::_S_blank}},\n-\t{\"cntrl\", ctype_base::cntrl},\n-\t{\"digit\", ctype_base::digit},\n-\t{\"graph\", ctype_base::graph},\n-\t{\"lower\", ctype_base::lower},\n-\t{\"print\", ctype_base::print},\n-\t{\"punct\", ctype_base::punct},\n-\t{\"space\", ctype_base::space},\n-\t{\"upper\", ctype_base::upper},\n-\t{\"xdigit\", ctype_base::xdigit},\n-      };\n-\n-      std::string __s(__last - __first, '?');\n-      __fctyp.narrow(__first, __last, '?', &__s[0]);\n-      __cctyp.tolower(&*__s.begin(), &*__s.begin() + __s.size());\n-      for (_ClassnameEntry* __it = __classnames;\n-\t   __it < *(&__classnames + 1);\n-\t   ++__it)\n-\t{\n-\t  if (__s == __it->first)\n-\t    {\n-\t      if (__icase\n-\t\t  && ((__it->second\n-\t\t       & (ctype_base::lower | ctype_base::upper)) != 0))\n-\t\treturn ctype_base::alpha;\n-\t      return __it->second;\n-\t    }\n-\t}\n-      return 0;\n-    }\n-\n-  template<typename _Ch_type>\n-    bool\n-    regex_traits<_Ch_type>::\n-    isctype(_Ch_type __c, char_class_type __f) const\n-    {\n-      typedef std::ctype<char_type> __ctype_type;\n-      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n-\n-      return __fctyp.is(__f._M_base, __c)\n-\t// [[:w:]]\n-\t|| ((__f._M_extended & _RegexMask::_S_under)\n-\t    && __c == __fctyp.widen('_'))\n-\t// [[:blank:]]\n-\t|| ((__f._M_extended & _RegexMask::_S_blank)\n-\t    && (__c == __fctyp.widen(' ')\n-\t\t|| __c == __fctyp.widen('\\t')));\n-    }\n-\n-  template<typename _Ch_type>\n-    int\n-    regex_traits<_Ch_type>::\n-    value(_Ch_type __ch, int __radix) const\n-    {\n-      std::basic_istringstream<char_type> __is(string_type(1, __ch));\n-      int __v;\n-      if (__radix == 8)\n-\t__is >> std::oct;\n-      else if (__radix == 16)\n-\t__is >> std::hex;\n-      __is >> __v;\n-      return __is.fail() ? -1 : __v;\n-    }\n-\n   // [7.8] Class basic_regex\n   /**\n    * Objects of specializations of this class represent regular expressions\n@@ -986,7 +714,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __detail::_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n \t__detail::__get_executor(_BiIter,\n \t\t\t\t _BiIter,\n-\t\t\t\t match_results<_BiIter, _Alloc>&,\n+\t\t\t\t std::vector<sub_match<_BiIter>, _Alloc>&,\n \t\t\t\t const basic_regex<_CharT, _TraitsT>&,\n \t\t\t\t regex_constants::match_flag_type);\n \n@@ -2032,14 +1760,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       /**\n        * @pre   ready() == true\n-       * @todo Implement this function.\n        */\n       template<typename _Out_iter>\n \t_Out_iter\n \tformat(_Out_iter __out, const char_type* __fmt_first,\n \t       const char_type* __fmt_last,\n-\t       match_flag_type __flags = regex_constants::format_default) const\n-\t{ return __out; }\n+\t       match_flag_type __flags = regex_constants::format_default) const;\n \n       /**\n        * @pre   ready() == true\n@@ -2229,32 +1955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tmatch_results<_Bi_iter, _Alloc>&         __m,\n \t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n \t\tregex_constants::match_flag_type         __flags\n-\t\t\t       = regex_constants::match_default)\n-    {\n-      if (__re._M_automaton == nullptr)\n-\treturn false;\n-\n-      auto __size = __re._M_automaton->_M_sub_count();\n-      __size += 2;\n-      __m.resize(__size);\n-      for (decltype(__size) __i = 0; __i < __size; ++__i)\n-\t__m.at(__i).matched = false;\n-\n-      if (__detail::__get_executor(__s, __e, __m, __re, __flags)->_M_match())\n-\t{\n-\t  for (auto __it : __m)\n-\t    if (!__it.matched)\n-\t      __it.first = __it.second = __e;\n-\t  __m.at(__m.size()).matched = false;\n-\t  __m.at(__m.size()).first = __s;\n-\t  __m.at(__m.size()).second = __s;\n-\t  __m.at(__m.size()+1).matched = false;\n-\t  __m.at(__m.size()+1).first = __e;\n-\t  __m.at(__m.size()+1).second = __e;\n-\t  return true;\n-\t}\n-      return false;\n-    }\n+\t\t\t       = regex_constants::match_default);\n \n   /**\n    * @brief Indicates if there is a match between the regular expression @p e\n@@ -2271,7 +1972,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @throws an exception of type regex_error.\n    */\n   template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n-    bool\n+    inline bool\n     regex_match(_Bi_iter __first, _Bi_iter __last,\n \t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n \t\tregex_constants::match_flag_type __flags\n@@ -2388,40 +2089,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _Bi_iter, typename _Alloc,\n \t   typename _Ch_type, typename _Rx_traits>\n-    inline bool\n+    bool\n     regex_search(_Bi_iter __first, _Bi_iter __last,\n \t\t match_results<_Bi_iter, _Alloc>& __m,\n \t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n \t\t regex_constants::match_flag_type __flags\n-\t\t = regex_constants::match_default)\n-    {\n-      if (__re._M_automaton == nullptr)\n-\treturn false;\n-\n-      auto __size = __re._M_automaton->_M_sub_count();\n-      __size += 2;\n-      __m.resize(__size);\n-      for (decltype(__size) __i = 0; __i < __size; ++__i)\n-\t__m.at(__i).matched = false;\n-\n-      if (__detail::__get_executor(__first, __last, __m, __re, __flags)\n-\t  ->_M_search())\n-\t{\n-\t  for (auto __it : __m)\n-\t    if (!__it.matched)\n-\t      __it.first = __it.second = __last;\n-\t  __m.at(__m.size()).first = __first;\n-\t  __m.at(__m.size()).second = __m[0].first;\n-\t  __m.at(__m.size()+1).first = __m[0].second;\n-\t  __m.at(__m.size()+1).second = __last;\n-\t  __m.at(__m.size()).matched =\n-\t    (__m.prefix().first != __m.prefix().second);\n-\t  __m.at(__m.size()+1).matched =\n-\t    (__m.suffix().first != __m.suffix().second);\n-\t  return true;\n-\t}\n-      return false;\n-    }\n+\t\t = regex_constants::match_default);\n \n   /**\n    * Searches for a regular expression within a range.\n@@ -2530,45 +2203,96 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // std [28.11.4] Function template regex_replace\n   /**\n-   * @doctodo\n-   * @param __out\n-   * @param __first\n-   * @param __last\n-   * @param __e\n-   * @param __fmt\n-   * @param __flags\n+   * @brief Search for a regular expression within a range for multiple times,\n+   and replace the matched parts through filling a format string.\n+   * @param __out   [OUT] The output iterator.\n+   * @param __first [IN]  The start of the string to search.\n+   * @param __last  [IN]  One-past-the-end of the string to search.\n+   * @param __e     [IN]  The regular expression to search for.\n+   * @param __fmt   [IN]  The format string.\n+   * @param __flags [IN]  Search and replace policy flags.\n    *\n-   * @returns out\n+   * @returns __out\n    * @throws an exception of type regex_error.\n-   *\n-   * @todo Implement this function.\n    */\n   template<typename _Out_iter, typename _Bi_iter,\n-\t   typename _Rx_traits, typename _Ch_type>\n+\t   typename _Rx_traits, typename _Ch_type,\n+\t   typename _St, typename _Sa>\n     inline _Out_iter\n     regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n \t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  const basic_string<_Ch_type, _St, _Sa>& __fmt,\n \t\t  regex_constants::match_flag_type __flags\n \t\t  = regex_constants::match_default)\n-    { return __out; }\n+    {\n+      return regex_replace(__out, __first, __last, __e, __fmt.c_str(), __flags);\n+    }\n \n   /**\n-   * @doctodo\n-   * @param __s\n-   * @param __e\n-   * @param __fmt\n-   * @param __flags\n+   * @brief Search for a regular expression within a range for multiple times,\n+   and replace the matched parts through filling a format C-string.\n+   * @param __out   [OUT] The output iterator.\n+   * @param __first [IN]  The start of the string to search.\n+   * @param __last  [IN]  One-past-the-end of the string to search.\n+   * @param __e     [IN]  The regular expression to search for.\n+   * @param __fmt   [IN]  The format C-string.\n+   * @param __flags [IN]  Search and replace policy flags.\n    *\n-   * @returns a copy of string @p s with replacements.\n+   * @returns __out\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Out_iter, typename _Bi_iter,\n+\t   typename _Rx_traits, typename _Ch_type>\n+    _Out_iter\n+    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const _Ch_type* __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default);\n+\n+  /**\n+   * @brief Search for a regular expression within a string for multiple times,\n+   and replace the matched parts through filling a format string.\n+   * @param __s     [IN] The string to search and replace.\n+   * @param __e     [IN] The regular expression to search for.\n+   * @param __fmt   [IN] The format string.\n+   * @param __flags [IN] Search and replace policy flags.\n    *\n+   * @returns The string after replacing.\n    * @throws an exception of type regex_error.\n    */\n-  template<typename _Rx_traits, typename _Ch_type>\n+  template<typename _Rx_traits, typename _Ch_type,\n+\t   typename _St, typename _Sa, typename _Fst, typename _Fsa>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type, _Fst, _Fsa>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      basic_string<_Ch_type> __result;\n+      regex_replace(std::back_inserter(__result),\n+\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n+  /**\n+   * @brief Search for a regular expression within a string for multiple times,\n+   and replace the matched parts through filling a format C-string.\n+   * @param __s     [IN] The string to search and replace.\n+   * @param __e     [IN] The regular expression to search for.\n+   * @param __fmt   [IN] The format C-string.\n+   * @param __flags [IN] Search and replace policy flags.\n+   *\n+   * @returns The string after replacing.\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type,\n+\t   typename _St, typename _Sa>\n     inline basic_string<_Ch_type>\n-    regex_replace(const basic_string<_Ch_type>& __s,\n+    regex_replace(const basic_string<_Ch_type, _St, _Sa>& __s,\n \t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n-\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  const _Ch_type* __fmt,\n \t\t  regex_constants::match_flag_type __flags\n \t\t  = regex_constants::match_default)\n     {\n@@ -2578,6 +2302,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __result;\n     }\n \n+  /**\n+   * @brief Search for a regular expression within a C-string for multiple\n+   times, and replace the matched parts through filling a format string.\n+   * @param __s     [IN] The C-string to search and replace.\n+   * @param __e     [IN] The regular expression to search for.\n+   * @param __fmt   [IN] The format string.\n+   * @param __flags [IN] Search and replace policy flags.\n+   *\n+   * @returns The string after replacing.\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type,\n+\t   typename _St, typename _Sa>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const _Ch_type* __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type, _St, _Sa>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      basic_string<_Ch_type> __result;\n+      regex_replace(std::back_inserter(__result), __s,\n+\t\t    __s + char_traits<_Ch_type>::length(__s),\n+\t\t    __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n+  /**\n+   * @brief Search for a regular expression within a C-string for multiple\n+   times, and replace the matched parts through filling a format C-string.\n+   * @param __s     [IN] The C-string to search and replace.\n+   * @param __e     [IN] The regular expression to search for.\n+   * @param __fmt   [IN] The format C-string.\n+   * @param __flags [IN] Search and replace policy flags.\n+   *\n+   * @returns The string after replacing.\n+   * @throws an exception of type regex_error.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const _Ch_type* __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const _Ch_type* __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      basic_string<_Ch_type> __result;\n+      regex_replace(std::back_inserter(__result), __s,\n+\t\t    __s + char_traits<_Ch_type>::length(__s),\n+\t\t    __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n   //@}\n \n   // std [28.12] Class template regex_iterator\n@@ -2685,68 +2462,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       match_results<_Bi_iter>          _M_match;\n     };\n \n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    bool\n-    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    operator==(const regex_iterator& __rhs) const\n-    {\n-      return (_M_match.empty() && __rhs._M_match.empty())\n-\t|| (_M_begin == __rhs._M_begin\n-\t    && _M_end == __rhs._M_end\n-\t    && _M_pregex == __rhs._M_pregex\n-\t    && _M_flags == __rhs._M_flags\n-\t    && _M_match[0] == __rhs._M_match[0]);\n-    }\n-\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n-    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    operator++()\n-    {\n-      // In all cases in which the call to regex_search returns true,\n-      // match.prefix().first shall be equal to the previous value of\n-      // match[0].second, and for each index i in the half-open range\n-      // [0, match.size()) for which match[i].matched is true,\n-      // match[i].position() shall return distance(begin, match[i].first).\n-      // [28.12.1.4.5]\n-      if (_M_match[0].matched)\n-\t{\n-\t  auto __start = _M_match[0].second;\n-\t  if (_M_match[0].first == _M_match[0].second)\n-\t    if (__start == _M_end)\n-\t      {\n-\t\t_M_match = value_type();\n-\t\treturn *this;\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n-\t\t\t\t | regex_constants::match_not_null\n-\t\t\t\t | regex_constants::match_continuous))\n-\t\t  {\n-\t\t    _M_match._M_in_iterator = true;\n-\t\t    _M_match._M_begin = _M_begin;\n-\t\t    return *this;\n-\t\t  }\n-\t\telse\n-\t\t  ++__start;\n-\t      }\n-\t  _M_flags |= regex_constants::match_prev_avail;\n-\t  if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n-\t    {\n-\t      _M_match._M_in_iterator = true;\n-\t      _M_match._M_begin = _M_begin;\n-\t    }\n-\t  else\n-\t    _M_match = value_type();\n-\t}\n-      return *this;\n-    }\n-\n   typedef regex_iterator<const char*>             cregex_iterator;\n   typedef regex_iterator<string::const_iterator>  sregex_iterator;\n #ifdef _GLIBCXX_USE_WCHAR_T\n@@ -2957,104 +2672,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool              _M_has_m1;\n     };\n \n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    operator=(const regex_token_iterator& __rhs)\n-    {\n-      _M_position = __rhs._M_position;\n-      _M_subs = __rhs._M_subs;\n-      _M_n = __rhs._M_n;\n-      _M_result = __rhs._M_result;\n-      _M_suffix = __rhs._M_suffix;\n-      _M_has_m1 = __rhs._M_has_m1;\n-      if (__rhs._M_result == &__rhs._M_suffix)\n-\t_M_result = &_M_suffix;\n-    }\n-\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    bool\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    operator==(const regex_token_iterator& __rhs) const\n-    {\n-      if (_M_end_of_seq() && __rhs._M_end_of_seq())\n-\treturn true;\n-      if (_M_suffix.matched && __rhs._M_suffix.matched\n-\t  && _M_suffix == __rhs._M_suffix)\n-\treturn true;\n-      if (_M_end_of_seq() || _M_suffix.matched\n-\t  || __rhs._M_end_of_seq() || __rhs._M_suffix.matched)\n-\treturn false;\n-      return _M_position == __rhs._M_position\n-\t&& _M_n == __rhs._M_n\n-\t&& _M_subs == __rhs._M_subs;\n-    }\n-\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    operator++()\n-    {\n-      _Position __prev = _M_position;\n-      if (_M_suffix.matched)\n-\t*this = regex_token_iterator();\n-      else if (_M_n + 1 < _M_subs.size())\n-\t{\n-\t  _M_n++;\n-\t  _M_result = &_M_current_match();\n-\t}\n-      else\n-\t{\n-\t  _M_n = 0;\n-\t  ++_M_position;\n-\t  if (_M_position != _Position())\n-\t    _M_result = &_M_current_match();\n-\t  else if (_M_has_m1 && __prev->suffix().length() != 0)\n-\t    {\n-\t      _M_suffix.matched = true;\n-\t      _M_suffix.first = __prev->suffix().first;\n-\t      _M_suffix.second = __prev->suffix().second;\n-\t      _M_result = &_M_suffix;\n-\t    }\n-\t  else\n-\t    *this = regex_token_iterator();\n-\t}\n-      return *this;\n-    }\n-\n-  template<typename _Bi_iter,\n-\t   typename _Ch_type,\n-\t   typename _Rx_traits>\n-    void\n-    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n-    _M_init(_Bi_iter __a, _Bi_iter __b)\n-    {\n-      _M_has_m1 = false;\n-      for (auto __it : _M_subs)\n-\tif (__it == -1)\n-\t  {\n-\t    _M_has_m1 = true;\n-\t    break;\n-\t  }\n-      if (_M_position != _Position())\n-\t_M_result = &_M_current_match();\n-      else if (_M_has_m1)\n-\t{\n-\t  _M_suffix.matched = true;\n-\t  _M_suffix.first = __a;\n-\t  _M_suffix.second = __b;\n-\t  _M_result = &_M_suffix;\n-\t}\n-      else\n-\t_M_result = nullptr;\n-    }\n-\n   /** @brief Token iterator for C-style NULL-terminated strings. */\n   typedef regex_token_iterator<const char*>             cregex_token_iterator;\n \n@@ -3073,3 +2690,4 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n \n+#include <bits/regex.tcc>"}, {"sha": "24316d26616f96f56dd56e560a990c705024f550", "filename": "libstdc++-v3/include/bits/regex.tcc", "status": "added", "additions": 677, "deletions": 0, "changes": 677, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -0,0 +1,677 @@\n+// class template regex -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/**\n+ *  @file bits/regex.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{regex}\n+ */\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Ch_type>\n+  template<typename _Fwd_iter>\n+    typename regex_traits<_Ch_type>::string_type\n+    regex_traits<_Ch_type>::\n+    lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n+    {\n+      typedef std::ctype<char_type> __ctype_type;\n+      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n+\n+      static const char* __collatenames[] =\n+\t{\n+\t  \"NUL\",\n+\t  \"SOH\",\n+\t  \"STX\",\n+\t  \"ETX\",\n+\t  \"EOT\",\n+\t  \"ENQ\",\n+\t  \"ACK\",\n+\t  \"alert\",\n+\t  \"backspace\",\n+\t  \"tab\",\n+\t  \"newline\",\n+\t  \"vertical-tab\",\n+\t  \"form-feed\",\n+\t  \"carriage-return\",\n+\t  \"SO\",\n+\t  \"SI\",\n+\t  \"DLE\",\n+\t  \"DC1\",\n+\t  \"DC2\",\n+\t  \"DC3\",\n+\t  \"DC4\",\n+\t  \"NAK\",\n+\t  \"SYN\",\n+\t  \"ETB\",\n+\t  \"CAN\",\n+\t  \"EM\",\n+\t  \"SUB\",\n+\t  \"ESC\",\n+\t  \"IS4\",\n+\t  \"IS3\",\n+\t  \"IS2\",\n+\t  \"IS1\",\n+\t  \"space\",\n+\t  \"exclamation-mark\",\n+\t  \"quotation-mark\",\n+\t  \"number-sign\",\n+\t  \"dollar-sign\",\n+\t  \"percent-sign\",\n+\t  \"ampersand\",\n+\t  \"apostrophe\",\n+\t  \"left-parenthesis\",\n+\t  \"right-parenthesis\",\n+\t  \"asterisk\",\n+\t  \"plus-sign\",\n+\t  \"comma\",\n+\t  \"hyphen\",\n+\t  \"period\",\n+\t  \"slash\",\n+\t  \"zero\",\n+\t  \"one\",\n+\t  \"two\",\n+\t  \"three\",\n+\t  \"four\",\n+\t  \"five\",\n+\t  \"six\",\n+\t  \"seven\",\n+\t  \"eight\",\n+\t  \"nine\",\n+\t  \"colon\",\n+\t  \"semicolon\",\n+\t  \"less-than-sign\",\n+\t  \"equals-sign\",\n+\t  \"greater-than-sign\",\n+\t  \"question-mark\",\n+\t  \"commercial-at\",\n+\t  \"A\",\n+\t  \"B\",\n+\t  \"C\",\n+\t  \"D\",\n+\t  \"E\",\n+\t  \"F\",\n+\t  \"G\",\n+\t  \"H\",\n+\t  \"I\",\n+\t  \"J\",\n+\t  \"K\",\n+\t  \"L\",\n+\t  \"M\",\n+\t  \"N\",\n+\t  \"O\",\n+\t  \"P\",\n+\t  \"Q\",\n+\t  \"R\",\n+\t  \"S\",\n+\t  \"T\",\n+\t  \"U\",\n+\t  \"V\",\n+\t  \"W\",\n+\t  \"X\",\n+\t  \"Y\",\n+\t  \"Z\",\n+\t  \"left-square-bracket\",\n+\t  \"backslash\",\n+\t  \"right-square-bracket\",\n+\t  \"circumflex\",\n+\t  \"underscore\",\n+\t  \"grave-accent\",\n+\t  \"a\",\n+\t  \"b\",\n+\t  \"c\",\n+\t  \"d\",\n+\t  \"e\",\n+\t  \"f\",\n+\t  \"g\",\n+\t  \"h\",\n+\t  \"i\",\n+\t  \"j\",\n+\t  \"k\",\n+\t  \"l\",\n+\t  \"m\",\n+\t  \"n\",\n+\t  \"o\",\n+\t  \"p\",\n+\t  \"q\",\n+\t  \"r\",\n+\t  \"s\",\n+\t  \"t\",\n+\t  \"u\",\n+\t  \"v\",\n+\t  \"w\",\n+\t  \"x\",\n+\t  \"y\",\n+\t  \"z\",\n+\t  \"left-curly-bracket\",\n+\t  \"vertical-line\",\n+\t  \"right-curly-bracket\",\n+\t  \"tilde\",\n+\t  \"DEL\",\n+\t  \"\"\n+\t};\n+\n+      // same as boost\n+      //static const char* __digraphs[] =\n+      //  {\n+      //    \"ae\",\n+      //    \"Ae\",\n+      //    \"AE\",\n+      //    \"ch\",\n+      //    \"Ch\",\n+      //    \"CH\",\n+      //    \"ll\",\n+      //    \"Ll\",\n+      //    \"LL\",\n+      //    \"ss\",\n+      //    \"Ss\",\n+      //    \"SS\",\n+      //    \"nj\",\n+      //    \"Nj\",\n+      //    \"NJ\",\n+      //    \"dz\",\n+      //    \"Dz\",\n+      //    \"DZ\",\n+      //    \"lj\",\n+      //    \"Lj\",\n+      //    \"LJ\",\n+      //    \"\"\n+      //  };\n+\n+      std::string __s(__last - __first, '?');\n+      __fctyp.narrow(__first, __last, '?', &*__s.begin());\n+\n+      for (unsigned int __i = 0; *__collatenames[__i]; __i++)\n+\tif (__s == __collatenames[__i])\n+\t  return string_type(1, __fctyp.widen(static_cast<char>(__i)));\n+\n+      //for (unsigned int __i = 0; *__digraphs[__i]; __i++)\n+      //  {\n+      //    const char* __now = __digraphs[__i];\n+      //    if (__s == __now)\n+      //      {\n+      //\tstring_type ret(__s.size(), __fctyp.widen('?'));\n+      //\t__fctyp.widen(__now, __now + 2/* ouch */, &*ret.begin());\n+      //\treturn ret;\n+      //      }\n+      //  }\n+      return string_type();\n+    }\n+\n+  template<typename _Ch_type>\n+  template<typename _Fwd_iter>\n+    typename regex_traits<_Ch_type>::char_class_type\n+    regex_traits<_Ch_type>::\n+    lookup_classname(_Fwd_iter __first, _Fwd_iter __last, bool __icase) const\n+    {\n+      typedef std::ctype<char_type> __ctype_type;\n+      typedef std::ctype<char> __cctype_type;\n+      typedef const pair<const char*, char_class_type> _ClassnameEntry;\n+      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n+      const __cctype_type& __cctyp(use_facet<__cctype_type>(_M_locale));\n+\n+      static _ClassnameEntry __classnames[] =\n+      {\n+\t{\"d\", ctype_base::digit},\n+\t{\"w\", {ctype_base::alnum, _RegexMask::_S_under}},\n+\t{\"s\", ctype_base::space},\n+\t{\"alnum\", ctype_base::alnum},\n+\t{\"alpha\", ctype_base::alpha},\n+\t{\"blank\", {0, _RegexMask::_S_blank}},\n+\t{\"cntrl\", ctype_base::cntrl},\n+\t{\"digit\", ctype_base::digit},\n+\t{\"graph\", ctype_base::graph},\n+\t{\"lower\", ctype_base::lower},\n+\t{\"print\", ctype_base::print},\n+\t{\"punct\", ctype_base::punct},\n+\t{\"space\", ctype_base::space},\n+\t{\"upper\", ctype_base::upper},\n+\t{\"xdigit\", ctype_base::xdigit},\n+      };\n+\n+      std::string __s(__last - __first, '?');\n+      __fctyp.narrow(__first, __last, '?', &__s[0]);\n+      __cctyp.tolower(&*__s.begin(), &*__s.begin() + __s.size());\n+      for (_ClassnameEntry* __it = __classnames;\n+\t   __it < *(&__classnames + 1);\n+\t   ++__it)\n+\t{\n+\t  if (__s == __it->first)\n+\t    {\n+\t      if (__icase\n+\t\t  && ((__it->second\n+\t\t       & (ctype_base::lower | ctype_base::upper)) != 0))\n+\t\treturn ctype_base::alpha;\n+\t      return __it->second;\n+\t    }\n+\t}\n+      return 0;\n+    }\n+\n+  template<typename _Ch_type>\n+    bool\n+    regex_traits<_Ch_type>::\n+    isctype(_Ch_type __c, char_class_type __f) const\n+    {\n+      typedef std::ctype<char_type> __ctype_type;\n+      const __ctype_type& __fctyp(use_facet<__ctype_type>(_M_locale));\n+\n+      return __fctyp.is(__f._M_base, __c)\n+\t// [[:w:]]\n+\t|| ((__f._M_extended & _RegexMask::_S_under)\n+\t    && __c == __fctyp.widen('_'))\n+\t// [[:blank:]]\n+\t|| ((__f._M_extended & _RegexMask::_S_blank)\n+\t    && (__c == __fctyp.widen(' ')\n+\t\t|| __c == __fctyp.widen('\\t')));\n+    }\n+\n+  template<typename _Ch_type>\n+    int\n+    regex_traits<_Ch_type>::\n+    value(_Ch_type __ch, int __radix) const\n+    {\n+      std::basic_istringstream<char_type> __is(string_type(1, __ch));\n+      int __v;\n+      if (__radix == 8)\n+\t__is >> std::oct;\n+      else if (__radix == 16)\n+\t__is >> std::hex;\n+      __is >> __v;\n+      return __is.fail() ? -1 : __v;\n+    }\n+\n+  template<typename _Bi_iter, typename _Alloc>\n+  template<typename _Out_iter>\n+    _Out_iter match_results<_Bi_iter, _Alloc>::\n+    format(_Out_iter __out,\n+\t   const match_results<_Bi_iter, _Alloc>::char_type* __fmt_first,\n+\t   const match_results<_Bi_iter, _Alloc>::char_type* __fmt_last,\n+\t   match_flag_type __flags) const\n+    {\n+      _GLIBCXX_DEBUG_ASSERT( ready() );\n+      regex_traits<char_type> __traits;\n+      typedef std::ctype<char_type> __ctype_type;\n+      const __ctype_type&\n+\t__fctyp(use_facet<__ctype_type>(__traits.getloc()));\n+\n+      auto __output = [&](int __idx)\n+\t{\n+\t  auto& __sub = _Base_type::operator[](__idx);\n+\t  if (__sub.matched)\n+\t    std::copy(__sub.first, __sub.second, __out);\n+\t};\n+\n+      if (__flags & regex_constants::format_sed)\n+\t{\n+\t  for (; __fmt_first != __fmt_last;)\n+\t    if (*__fmt_first == '&')\n+\t      {\n+\t\t__output(0);\n+\t\t++__fmt_first;\n+\t      }\n+\t    else if (*__fmt_first == '\\\\')\n+\t      {\n+\t\tif (++__fmt_first != __fmt_last\n+\t\t    && __fctyp.is(__ctype_type::digit, *__fmt_first))\n+\t\t  __output(__traits.value(*__fmt_first++, 10));\n+\t\telse\n+\t\t  *__out++ = '\\\\';\n+\t      }\n+\t    else\n+\t      *__out++ = *__fmt_first++;\n+\t}\n+      else\n+\t{\n+\t  while (1)\n+\t    {\n+\t      auto __next = std::find(__fmt_first, __fmt_last, '$');\n+\t      if (__next == __fmt_last)\n+\t\tbreak;\n+\n+\t      std::copy(__fmt_first, __next, __out);\n+\n+\t      auto __eat = [&](char __ch) -> bool\n+\t\t{\n+\t\t  if (*__next == __ch)\n+\t\t    {\n+\t\t      ++__next;\n+\t\t      return true;\n+\t\t    }\n+\t\t  return false;\n+\t\t};\n+\n+\t      if (++__next == __fmt_last)\n+\t\t*__out++ = '$';\n+\t      else if (__eat('$'))\n+\t\t*__out++ = '$';\n+\t      else if (__eat('&'))\n+\t\t__output(0);\n+\t      else if (__eat('`'))\n+\t\t__output(_Base_type::size()-2);\n+\t      else if (__eat('\\''))\n+\t\t__output(_Base_type::size()-1);\n+\t      else if (__fctyp.is(__ctype_type::digit, *__next))\n+\t\t{\n+\t\t  int __num = __traits.value(*__next, 10);\n+\t\t  if (++__next != __fmt_last\n+\t\t      && __fctyp.is(__ctype_type::digit, *__next))\n+\t\t    {\n+\t\t      __num *= 10;\n+\t\t      __num += __traits.value(*__next++, 10);\n+\t\t    }\n+\t\t  if (0 <= __num && __num < this->size())\n+\t\t    __output(__num);\n+\t\t}\n+\t      else\n+\t\t*__out++ = '$';\n+\t      __fmt_first = __next;\n+\t    }\n+\t  std::copy(__fmt_first, __fmt_last, __out);\n+\t}\n+      return __out;\n+    }\n+\n+  template<typename _Bi_iter, typename _Alloc,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter                                 __s,\n+\t\t_Bi_iter                                 __e,\n+\t\tmatch_results<_Bi_iter, _Alloc>&         __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type         __flags\n+\t\t\t       = regex_constants::match_default)\n+    {\n+      if (__re._M_automaton == nullptr)\n+\treturn false;\n+\n+      typename match_results<_Bi_iter, _Alloc>::_Base_type& __res = __m;\n+      auto __size = __re._M_automaton->_M_sub_count();\n+      __size += 2;\n+      __res.resize(__size);\n+      for (decltype(__size) __i = 0; __i < __size; ++__i)\n+\t__res[__i].matched = false;\n+\n+      if (__detail::__get_executor(__s, __e, __res, __re, __flags)->_M_match())\n+\t{\n+\t  for (auto __it : __res)\n+\t    if (!__it.matched)\n+\t      __it.first = __it.second = __e;\n+\t  auto& __pre = __res[__res.size()-2];\n+\t  auto& __suf = __res[__res.size()-1];\n+\t  __pre.matched = false;\n+\t  __pre.first = __s;\n+\t  __pre.second = __s;\n+\t  __suf.matched = false;\n+\t  __suf.first = __e;\n+\t  __suf.second = __e;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _Bi_iter, typename _Alloc,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t match_results<_Bi_iter, _Alloc>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    {\n+      if (__re._M_automaton == nullptr)\n+\treturn false;\n+\n+      typename match_results<_Bi_iter, _Alloc>::_Base_type& __res = __m;\n+      auto __size = __re._M_automaton->_M_sub_count();\n+      __size += 2;\n+      __res.resize(__size);\n+      for (decltype(__size) __i = 0; __i < __size; ++__i)\n+\t__res[__i].matched = false;\n+\n+      if (__detail::__get_executor(__first, __last, __res, __re, __flags)\n+\t  ->_M_search())\n+\t{\n+\t  for (auto __it : __res)\n+\t    if (!__it.matched)\n+\t      __it.first = __it.second = __last;\n+\t  auto& __pre = __res[__res.size()-2];\n+\t  auto& __suf = __res[__res.size()-1];\n+\t  __pre.first = __first;\n+\t  __pre.second = __res[0].first;\n+\t  __pre.matched = (__pre.first != __pre.second);\n+\t  __suf.first = __res[0].second;\n+\t  __suf.second = __last;\n+\t  __suf.matched = (__suf.first != __suf.second);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  template<typename _Out_iter, typename _Bi_iter,\n+\t   typename _Rx_traits, typename _Ch_type>\n+    _Out_iter\n+    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const _Ch_type* __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> _IterT;\n+      _IterT __i(__first, __last, __e, __flags);\n+      _IterT __end;\n+      if (__i == __end)\n+\t{\n+\t  if (!(__flags & regex_constants::format_no_copy))\n+\t    std::copy(__first, __last, __out);\n+\t}\n+      else\n+\t{\n+\t  sub_match<_Bi_iter> __last;\n+\t  auto __len = char_traits<_Ch_type>::length(__fmt);\n+\t  for (; __i != __end; ++__i)\n+\t    {\n+\t      if (!(__flags & regex_constants::format_no_copy))\n+\t\tstd::copy(__i->prefix().first, __i->prefix().second, __out);\n+\t      __out = __i->format(__out, __fmt, __fmt + __len, __flags);\n+\t      __last = __i->suffix();\n+\t      if (__flags & regex_constants::format_first_only)\n+\t\tbreak;\n+\t    }\n+\t  if (!(__flags & regex_constants::format_no_copy))\n+\t    std::copy(__last.first, __last.second, __out);\n+\t}\n+      return __out;\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    bool\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator==(const regex_iterator& __rhs) const\n+    {\n+      return (_M_match.empty() && __rhs._M_match.empty())\n+\t|| (_M_begin == __rhs._M_begin\n+\t    && _M_end == __rhs._M_end\n+\t    && _M_pregex == __rhs._M_pregex\n+\t    && _M_flags == __rhs._M_flags\n+\t    && _M_match[0] == __rhs._M_match[0]);\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator++()\n+    {\n+      // In all cases in which the call to regex_search returns true,\n+      // match.prefix().first shall be equal to the previous value of\n+      // match[0].second, and for each index i in the half-open range\n+      // [0, match.size()) for which match[i].matched is true,\n+      // match[i].position() shall return distance(begin, match[i].first).\n+      // [28.12.1.4.5]\n+      if (_M_match[0].matched)\n+\t{\n+\t  auto __start = _M_match[0].second;\n+\t  auto __prefix_first = _M_match[0].second;\n+\t  if (_M_match[0].first == _M_match[0].second)\n+\t    if (__start == _M_end)\n+\t      {\n+\t\t_M_match = value_type();\n+\t\treturn *this;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags\n+\t\t\t\t | regex_constants::match_not_null\n+\t\t\t\t | regex_constants::match_continuous))\n+\t\t  {\n+\t\t    _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);\n+\t\t    _M_match.at(_M_match.size()).first = __prefix_first;\n+\t\t    _M_match._M_in_iterator = true;\n+\t\t    _M_match._M_begin = _M_begin;\n+\t\t    return *this;\n+\t\t  }\n+\t\telse\n+\t\t  ++__start;\n+\t      }\n+\t  _M_flags |= regex_constants::match_prev_avail;\n+\t  if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))\n+\t    {\n+\t      _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);\n+\t      _M_match.at(_M_match.size()).first = __prefix_first;\n+\t      _M_match._M_in_iterator = true;\n+\t      _M_match._M_begin = _M_begin;\n+\t    }\n+\t  else\n+\t    _M_match = value_type();\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator=(const regex_token_iterator& __rhs)\n+    {\n+      _M_position = __rhs._M_position;\n+      _M_subs = __rhs._M_subs;\n+      _M_n = __rhs._M_n;\n+      _M_result = __rhs._M_result;\n+      _M_suffix = __rhs._M_suffix;\n+      _M_has_m1 = __rhs._M_has_m1;\n+      if (__rhs._M_result == &__rhs._M_suffix)\n+\t_M_result = &_M_suffix;\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    bool\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator==(const regex_token_iterator& __rhs) const\n+    {\n+      if (_M_end_of_seq() && __rhs._M_end_of_seq())\n+\treturn true;\n+      if (_M_suffix.matched && __rhs._M_suffix.matched\n+\t  && _M_suffix == __rhs._M_suffix)\n+\treturn true;\n+      if (_M_end_of_seq() || _M_suffix.matched\n+\t  || __rhs._M_end_of_seq() || __rhs._M_suffix.matched)\n+\treturn false;\n+      return _M_position == __rhs._M_position\n+\t&& _M_n == __rhs._M_n\n+\t&& _M_subs == __rhs._M_subs;\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>&\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    operator++()\n+    {\n+      _Position __prev = _M_position;\n+      if (_M_suffix.matched)\n+\t*this = regex_token_iterator();\n+      else if (_M_n + 1 < _M_subs.size())\n+\t{\n+\t  _M_n++;\n+\t  _M_result = &_M_current_match();\n+\t}\n+      else\n+\t{\n+\t  _M_n = 0;\n+\t  ++_M_position;\n+\t  if (_M_position != _Position())\n+\t    _M_result = &_M_current_match();\n+\t  else if (_M_has_m1 && __prev->suffix().length() != 0)\n+\t    {\n+\t      _M_suffix.matched = true;\n+\t      _M_suffix.first = __prev->suffix().first;\n+\t      _M_suffix.second = __prev->suffix().second;\n+\t      _M_result = &_M_suffix;\n+\t    }\n+\t  else\n+\t    *this = regex_token_iterator();\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type,\n+\t   typename _Rx_traits>\n+    void\n+    regex_token_iterator<_Bi_iter, _Ch_type, _Rx_traits>::\n+    _M_init(_Bi_iter __a, _Bi_iter __b)\n+    {\n+      _M_has_m1 = false;\n+      for (auto __it : _M_subs)\n+\tif (__it == -1)\n+\t  {\n+\t    _M_has_m1 = true;\n+\t    break;\n+\t  }\n+      if (_M_position != _Position())\n+\t_M_result = &_M_current_match();\n+      else if (_M_has_m1)\n+\t{\n+\t  _M_suffix.matched = true;\n+\t  _M_suffix.first = __a;\n+\t  _M_suffix.second = __b;\n+\t  _M_result = &_M_suffix;\n+\t}\n+      else\n+\t_M_result = nullptr;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+"}, {"sha": "4e393e7be9a744636fa753a851ca330e3ecfa666", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -120,13 +120,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn ret;\n       }\n \n+      _FlagT          _M_flags;\n       const _TraitsT& _M_traits;\n       const _CtypeT&  _M_ctype;\n       _ScannerT       _M_scanner;\n       _RegexT         _M_nfa;\n       _StringT        _M_value;\n       _StackT         _M_stack;\n-      _FlagT          _M_flags;\n     };\n \n   template<typename _CharT, typename _TraitsT>\n@@ -207,7 +207,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t __s.data() + __s.size());\n \tif (__st.empty())\n \t  __throw_regex_error(regex_constants::error_collate);\n-\t// TODO: digraph\n \t_M_char_set.insert(_M_translate(__st[0]));\n       }\n "}, {"sha": "94f3d5ea86cb44eea7d522d53afb595c62bffff2", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -63,9 +63,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _Compiler(_FwdIter __b, _FwdIter __e,\n \t      const _TraitsT& __traits, _FlagT __flags)\n-    : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n-      _M_ctype(std::use_facet<std::ctype<_CharT>>(_M_traits.getloc())),\n-      _M_nfa(__flags), _M_flags(__flags)\n+    : _M_flags((__flags\n+\t\t& (regex_constants::ECMAScript\n+\t\t   | regex_constants::basic\n+\t\t   | regex_constants::extended\n+\t\t   | regex_constants::grep\n+\t\t   | regex_constants::egrep\n+\t\t   | regex_constants::awk))\n+\t       ? __flags\n+\t       : __flags | regex_constants::ECMAScript),\n+    _M_traits(__traits),\n+    _M_scanner(__b, __e, _M_flags, _M_traits.getloc()),\n+    _M_ctype(std::use_facet<std::ctype<_CharT>>(_M_traits.getloc())),\n+    _M_nfa(_M_flags)\n     {\n       _StateSeqT __r(_M_nfa, _M_nfa._M_start());\n       __r._M_append(_M_nfa._M_insert_subexpr_begin());\n@@ -85,7 +95,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _M_disjunction()\n     {\n       this->_M_alternative();\n-      // TODO empty alternative like, um, \"(|asdf)\"\n       while (_M_match_token(_ScannerT::_S_token_or))\n \t{\n \t  _StateSeqT __alt1 = _M_pop();\n@@ -170,7 +179,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler<_FwdIter, _CharT, _TraitsT>::\n     _M_quantifier()\n     {\n-      bool __neg = regex_constants::ECMAScript;\n+      bool __neg = (_M_flags & regex_constants::ECMAScript);\n       auto __init = [this, &__neg]()\n \t{\n \t  if (_M_stack.empty())\n@@ -207,53 +216,66 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (_M_match_token(_ScannerT::_S_token_interval_begin))\n \t{\n-\t  __init();\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n \t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n \t    __throw_regex_error(regex_constants::error_badbrace);\n \t  _StateSeqT __r(_M_pop());\n \t  _StateSeqT __e(_M_nfa, _M_nfa._M_insert_dummy());\n \t  int __min_rep = _M_cur_int_value(10);\n+\t  bool __infi = false;\n+\t  int __n;\n+\n \t  // {3\n-\t  for (int __i = 0; __i < __min_rep; ++__i)\n-\t    __e._M_append(__r._M_clone());\n \t  if (_M_match_token(_ScannerT::_S_token_comma))\n \t    if (_M_match_token(_ScannerT::_S_token_dup_count)) // {3,7}\n-\t      {\n-\t\tint __n = _M_cur_int_value(10) - __min_rep;\n-\t\tif (__n < 0)\n-\t\t  __throw_regex_error(regex_constants::error_badbrace);\n-\t\tauto __end = _M_nfa._M_insert_dummy();\n-\t\t// _M_alt is the \"match more\" branch, and _M_next is the\n-\t\t// \"match less\" one. Switch _M_alt and _M_next of all created\n-\t\t// nodes. This is a hacking but IMO works well.\n-\t\tstd::stack<_StateIdT> __stack;\n-\t\tfor (int __i = 0; __i < __n; ++__i)\n-\t\t  {\n-\t\t    auto __tmp = __r._M_clone();\n-\t\t    auto __alt = _M_nfa._M_insert_alt(__tmp._M_start,\n-\t\t\t\t\t\t      __end, __neg);\n-\t\t    __stack.push(__alt);\n-\t\t    __e._M_append(_StateSeqT(_M_nfa, __alt, __tmp._M_end));\n-\t\t  }\n-\t\t__e._M_append(__end);\n-\t\twhile (!__stack.empty())\n-\t\t  {\n-\t\t    auto& __tmp = _M_nfa[__stack.top()];\n-\t\t    __stack.pop();\n-\t\t    swap(__tmp._M_next, __tmp._M_alt);\n-\t\t  }\n-\t      }\n-\t    else // {3,}\n-\t      {\n-\t\tauto __tmp = __r._M_clone();\n-\t\t_StateSeqT __s(_M_nfa,\n-\t\t\t       _M_nfa._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t    __tmp._M_start, __neg));\n-\t\t__tmp._M_append(__s);\n-\t\t__e._M_append(__s);\n-\t      }\n+\t      __n = _M_cur_int_value(10) - __min_rep;\n+\t    else\n+\t      __infi = true;\n+\t  else\n+\t    __n = 0;\n \t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n \t    __throw_regex_error(regex_constants::error_brace);\n+\n+\t  __neg = __neg && _M_match_token(_ScannerT::_S_token_opt);\n+\n+\t  for (int __i = 0; __i < __min_rep; ++__i)\n+\t    __e._M_append(__r._M_clone());\n+\n+\t  if (__infi)\n+\t    {\n+\t      auto __tmp = __r._M_clone();\n+\t      _StateSeqT __s(_M_nfa,\n+\t\t\t     _M_nfa._M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t  __tmp._M_start, __neg));\n+\t      __tmp._M_append(__s);\n+\t      __e._M_append(__s);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (__n < 0)\n+\t\t__throw_regex_error(regex_constants::error_badbrace);\n+\t      auto __end = _M_nfa._M_insert_dummy();\n+\t      // _M_alt is the \"match more\" branch, and _M_next is the\n+\t      // \"match less\" one. Switch _M_alt and _M_next of all created\n+\t      // nodes. This is a hacking but IMO works well.\n+\t      std::stack<_StateIdT> __stack;\n+\t      for (int __i = 0; __i < __n; ++__i)\n+\t\t{\n+\t\t  auto __tmp = __r._M_clone();\n+\t\t  auto __alt = _M_nfa._M_insert_alt(__tmp._M_start,\n+\t\t\t\t\t\t    __end, __neg);\n+\t\t  __stack.push(__alt);\n+\t\t  __e._M_append(_StateSeqT(_M_nfa, __alt, __tmp._M_end));\n+\t\t}\n+\t      __e._M_append(__end);\n+\t      while (!__stack.empty())\n+\t\t{\n+\t\t  auto& __tmp = _M_nfa[__stack.top()];\n+\t\t  __stack.pop();\n+\t\t  swap(__tmp._M_next, __tmp._M_alt);\n+\t\t}\n+\t    }\n \t  _M_stack.push(__e);\n \t}\n     }"}, {"sha": "a0149d2a54867cc1c29499f913b43fdfd57ec81e", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -62,22 +62,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n     public:\n       typedef basic_regex<_CharT, _TraitsT>           _RegexT;\n-      typedef match_results<_BiIter, _Alloc>          _ResultsT;\n       typedef std::vector<sub_match<_BiIter>, _Alloc> _ResultsVec;\n       typedef regex_constants::match_flag_type        _FlagT;\n       typedef typename _TraitsT::char_class_type      _ClassT;\n \n     public:\n       _Executor(_BiIter         __begin,\n \t\t_BiIter         __end,\n-\t\t_ResultsT&      __results,\n+\t\t_ResultsVec&    __results,\n \t\tconst _RegexT&  __re,\n \t\t_FlagT          __flags)\n       : _M_begin(__begin),\n       _M_end(__end),\n       _M_results(__results),\n       _M_re(__re),\n-      _M_flags(__flags)\n+      _M_flags((__flags & regex_constants::match_prev_avail)\n+\t       ? (__flags\n+\t\t  & ~regex_constants::match_not_bol\n+\t\t  & ~regex_constants::match_not_bow)\n+\t       : __flags)\n       { }\n \n       // Set matched when string exactly match the pattern.\n@@ -145,6 +148,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_lookahead(_State<_CharT, _TraitsT> __state) const;\n \n+      void\n+      _M_set_results(_ResultsVec& __cur_results);\n+\n     public:\n       virtual void\n       _M_init(_BiIter __cur) = 0;\n@@ -159,8 +165,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const _BiIter   _M_begin;\n       const _BiIter   _M_end;\n       const _RegexT&  _M_re;\n-      _ResultsT&      _M_results;\n-      const _FlagT    _M_flags;\n+      _ResultsVec&    _M_results;\n+      _FlagT          _M_flags;\n       bool            _M_match_mode;\n     };\n \n@@ -186,14 +192,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n       typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n       typedef typename _BaseT::_RegexT                     _RegexT;\n-      typedef typename _BaseT::_ResultsT                   _ResultsT;\n       typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n       typedef typename _BaseT::_FlagT                      _FlagT;\n \n     public:\n       _DFSExecutor(_BiIter         __begin,\n \t\t   _BiIter         __end,\n-\t\t   _ResultsT&      __results,\n+\t\t   _ResultsVec&    __results,\n \t\t   const _RegexT&  __re,\n \t\t   _FlagT          __flags)\n       : _BaseT(__begin, __end, __results, __re, __flags),\n@@ -249,7 +254,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Executor<_BiIter, _Alloc, _CharT, _TraitsT> _BaseT;\n       typedef _NFA<_CharT, _TraitsT>                       _NFAT;\n       typedef typename _BaseT::_RegexT                     _RegexT;\n-      typedef typename _BaseT::_ResultsT                   _ResultsT;\n       typedef typename _BaseT::_ResultsVec                 _ResultsVec;\n       typedef typename _BaseT::_FlagT                      _FlagT;\n       // Here's a solution for greedy/ungreedy mode in BFS approach. We need to\n@@ -314,7 +318,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_inc(unsigned int __idx, bool __neg)\n \t{ _M_quant_keys[__idx] += __neg ? 1 : -1; }\n \n-\t_ResultsVec\n+\t_ResultsVec&\n \t_M_get()\n \t{ return *this; }\n \n@@ -326,7 +330,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     public:\n       _BFSExecutor(_BiIter         __begin,\n \t\t   _BiIter         __end,\n-\t\t   _ResultsT&      __results,\n+\t\t   _ResultsVec&    __results,\n \t\t   const _RegexT&  __re,\n \t\t   _FlagT          __flags)\n       : _BaseT(__begin, __end, __results, __re, __flags),\n@@ -377,7 +381,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n     __get_executor(_BiIter __b,\n \t\t   _BiIter __e,\n-\t\t   match_results<_BiIter, _Alloc>& __m,\n+\t\t   std::vector<sub_match<_BiIter>, _Alloc>& __m,\n \t\t   const basic_regex<_CharT, _TraitsT>& __re,\n \t\t   regex_constants::match_flag_type __flags);\n "}, {"sha": "3a4080081b74af69044719bd4aa857bfe211496e", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -148,17 +148,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      && (this->_M_flags & regex_constants::match_not_null))\n \t    __ret = false;\n \t  if (__ret)\n-\t    {\n-\t      _ResultsVec& __res(this->_M_results);\n-\t      if (this->_M_re.flags() & regex_constants::nosubs)\n-\t\t{\n-\t\t  _M_cur_results.resize(3); // truncate\n-\t\t  __res.resize(3);\n-\t\t}\n-\t      for (unsigned int __i = 0; __i < _M_cur_results.size(); ++__i)\n-\t\tif (_M_cur_results[__i].matched)\n-\t\t  __res[__i] = _M_cur_results[__i];\n-\t    }\n+\t    this->_M_set_results(_M_cur_results);\n \t  break;\n \tdefault:\n \t  _GLIBCXX_DEBUG_ASSERT(false);\n@@ -187,18 +177,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (this->_M_match_mode)\n \t__ret = _M_includes_some();\n       if (__ret)\n-\t{\n-\t  _ResultsVec& __res(this->_M_results);\n-\t  if (this->_M_re.flags() & regex_constants::nosubs)\n-\t    {\n-\t      // truncate\n-\t      _M_cur_results->resize(3);\n-\t      __res.resize(3);\n-\t    }\n-\t  for (unsigned int __i = 0; __i < _M_cur_results->size(); ++__i)\n-\t    if ((*_M_cur_results)[__i].matched)\n-\t      __res[__i] = (*_M_cur_results)[__i];\n-\t}\n+\tthis->_M_set_results(_M_cur_results->_M_get());\n       return __ret;\n     }\n \n@@ -401,12 +380,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __sub->_M_search_from_first();\n     }\n \n+  template<typename _BiIter, typename _Alloc,\n+    typename _CharT, typename _TraitsT>\n+    void _Executor<_BiIter, _Alloc, _CharT, _TraitsT>::\n+    _M_set_results(_ResultsVec& __cur_results)\n+    {\n+      if (_M_re.flags() & regex_constants::nosubs)\n+\t{\n+\t  // truncate\n+\t  __cur_results.resize(3);\n+\t  _M_results.resize(3);\n+\t}\n+      for (unsigned int __i = 0; __i < __cur_results.size(); ++__i)\n+\tif (__cur_results[__i].matched)\n+\t  _M_results[__i] = __cur_results[__i];\n+    }\n+\n   template<typename _BiIter, typename _Alloc,\n     typename _CharT, typename _TraitsT>\n     std::unique_ptr<_Executor<_BiIter, _Alloc, _CharT, _TraitsT>>\n     __get_executor(_BiIter __b,\n \t\t   _BiIter __e,\n-\t\t   match_results<_BiIter, _Alloc>& __m,\n+\t\t   std::vector<sub_match<_BiIter>, _Alloc>& __m,\n \t\t   const basic_regex<_CharT, _TraitsT>& __re,\n \t\t   regex_constants::match_flag_type __flags)\n     {"}, {"sha": "4634c7d1d35a82f4182b72941e367b869accec39", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -38,9 +38,10 @@ template<typename _Bi_iter, typename _Alloc,\n              regex_constants::match_flag_type         __flags\n                             = regex_constants::match_default)\n   {\n+    auto& __res = (vector<sub_match<_Bi_iter>, _Alloc>&)(__m);\n     VERIFY( (dynamic_cast\n              <__detail::_DFSExecutor<_Bi_iter, _Alloc, _Ch_type, _Rx_traits>*>\n-             (&*__detail::__get_executor(__s, __e, __m, __re, __flags))\n+             (&*__detail::__get_executor(__s, __e, __res, __re, __flags))\n              != nullptr) );\n   }\n "}, {"sha": "ca3f16f7d23ba8d5d086008fbd3847b394692e27", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_replace/char/basic_replace.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_replace%2Fchar%2Fbasic_replace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_replace%2Fchar%2Fbasic_replace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_replace%2Fchar%2Fbasic_replace.cc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-24  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.4 regex_replace\n+// Tests ECMAScript regex_replace.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  VERIFY(regex_replace(string(\"This is a string\"), regex(\"\\\\b\\\\w*\\\\b\"), \"|$0|\")\n+\t == \"|This||| |is||| |a||| |string|||\");\n+  VERIFY(regex_replace(string(\"This is a string\"), regex(\"\\\\b\\\\w*\\\\b\"), \"|$0|\",\n+\t\t       regex_constants::format_no_copy)\n+\t == \"|This||||is||||a||||string|||\");\n+  VERIFY(regex_replace(string(\"This is a string\"), regex(\"\\\\b\\\\w*\\\\b\"), \"|$0|\",\n+\t\t       regex_constants::format_first_only)\n+\t == \"|This| is a string\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "be0801621437e1803b49e0f2cccc490592007963", "filename": "libstdc++-v3/testsuite/28_regex/match_results/format.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fformat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fformat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Fmatch_results%2Fformat.cc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-09-24  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.10.5 formatting\n+// Tests ECMAScript format()\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  cmatch m;\n+  VERIFY(regex_search(\"*** this is a string !!!\", m,\n+\t\t      regex(\"(\\\\w+) (\\\\w+) (\\\\w+) (\\\\w+)\")));\n+  VERIFY(m.format(\"$&|$`|$3|$4|$2|$1|$'$$$\")\n+\t == \"this is a string|*** |a|string|is|this| !!!$$\");\n+  VERIFY(m.format(\"&|\\\\3|\\\\4|\\\\2|\\\\1|\\\\\",\n+\t\t  regex_constants::format_sed)\n+\t == \"this is a string|a|string|is|this|\\\\\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dba0fc357e567f13611556cbdbb557fb666777d7", "filename": "libstdc++-v3/testsuite/28_regex/traits/char/lookup_collatename.cc", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fchar%2Flookup_collatename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fchar%2Flookup_collatename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fchar%2Flookup_collatename.cc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -35,12 +35,9 @@ test01()\n   typedef char CharT;\n   typedef std::regex_traits<CharT> traits;\n \n-\tchar name[] = \"ll\";\n-\ttraits t;\n-\n-\ttraits::string_type sname = t.lookup_collatename(name, name+sizeof(name)-1);\n-\n-  VERIFY( !sname.empty() );\n+  traits t;\n+  CharT name[] = \"tilde\";\n+  VERIFY(t.lookup_collatename(name, name+sizeof(name)-1) == \"~\");\n }\n \n int main()"}, {"sha": "3d20cfaf9a00efddea078a5ecfb6109bdaf9f477", "filename": "libstdc++-v3/testsuite/28_regex/traits/wchar_t/lookup_collatename.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fwchar_t%2Flookup_collatename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2669da93de6bb84df96b14167429f2046acf4b8/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fwchar_t%2Flookup_collatename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Ftraits%2Fwchar_t%2Flookup_collatename.cc?ref=c2669da93de6bb84df96b14167429f2046acf4b8", "patch": "@@ -33,13 +33,9 @@ test01()\n   typedef wchar_t CharT;\n   typedef std::regex_traits<CharT> traits;\n \n-\twchar_t name[] = L\"ll\";\n-\ttraits t;\n-\n-\ttraits::string_type sname =\n-          t.lookup_collatename(name, name+sizeof(name)/sizeof(*name)-1);\n-\n-  VERIFY( !sname.empty() );\n+  traits t;\n+  CharT name[] = L\"tilde\";\n+  VERIFY(t.lookup_collatename(name, name+sizeof(name)/sizeof(*name)-1) == L\"~\");\n }\n \n int main()"}]}