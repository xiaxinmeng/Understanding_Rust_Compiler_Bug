{"sha": "c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "node_id": "C_kwDOANBUbNoAKGM1MmMzMjI2MjdkZDBmMjA2YjRiZjdmN2M5NGFiNDJiZjVlNjFiNmY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-15T14:31:54Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-15T14:31:54Z"}, "message": "c++: remove function_p parm from tsubst_copy_and_build\n\nThe function_p parameter of tsubst_copy_and_build (added in r69316) is\ninspected only in its IDENTIFIER_NODE case, where it controls whether we\ndiagnose unqualified name lookup failure for the given identifier.  But\nI think ever since r173965, we never substitute an IDENTIFIER_NODE with\nfunction_p=true for which the lookup can possibly fail, and therefore\nthe flag is effectively unneeded.\n\nBefore that commit, we would incorrectly repeat unqualified lookup for\nan ADL-enabled CALL_EXPR at instantiation time, which naturally could\nfail and thus motivated the flag.  Afterwards, we no longer substitute\nan IDENTIFIER_NODE callee when koenig_p is true, so the flag isn't needed\nfor its original purpose.  What about when koenig_p=false?  Apparently\nwe still may have an IDENTIFIER_NODE callee in this case, namely when\nunqualified name lookup found a dependent local function declaration,\nbut repeating that lookup can't fail (ditto for USING_DECL callees).\n\nSo this patch removes this effectively unneeded parameter from\ntsubst_copy_and_build.  It also updates an outdated comment in the\nCALL_EXPR case about when we may see an IDENTIFIER_NODE callee with\nkoenig_p=false.\n\ngcc/cp/ChangeLog:\n\n\t* cp-lang.cc (objcp_tsubst_copy_and_build): Remove\n\tfunction_p parameter.\n\t* cp-objcp-common.h (objcp_tsubst_copy_and_build):\n\tLikewise.\n\t* cp-tree.h (tsubst_copy_and_build): Likewise.\n\t* init.cc (get_nsdmi): Adjust calls to tsubst_copy_and_build.\n\t* pt.cc (expand_integer_pack): Likewise.\n\t(instantiate_non_dependent_expr_internal): Likewise.\n\t(tsubst_function_decl): Likewise.\n\t(tsubst_arg_types): Likewise.\n\t(tsubst_exception_specification): Likewise.\n\t(tsubst): Likewise.\n\t(tsubst_copy_asm_operands): Likewise.\n\t(tsubst_expr): Likewise.\n\t(tsubst_non_call_postfix_expression): Likewise.\n\t(tsubst_lambda_expr): Likewise.\n\t(tsubst_copy_and_build_call_args): Likewise.\n\t(tsubst_copy_and_build): Remove function_p parameter\n\tand adjust function comment.  Adjust recursive calls.\n\t<case CALL_EXPR>: Update outdated comment about when\n\twe can see an IDENTIFIER_NODE callee with koenig_p=false.\n\t(maybe_instantiate_noexcept): Adjust calls to\n\ttsubst_copy_and_build.\n\ngcc/objcp/ChangeLog:\n\n\t* objcp-lang.cc (objcp_tsubst_copy_and_build): Remove\n\tfunction_p parameter.", "tree": {"sha": "d14f832563460b440ada6a3ed0b9da5001e33755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d14f832563460b440ada6a3ed0b9da5001e33755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/comments", "author": null, "committer": null, "parents": [{"sha": "c68c468e0ebb6922816367a06e4ab02bad08eb08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c68c468e0ebb6922816367a06e4ab02bad08eb08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c68c468e0ebb6922816367a06e4ab02bad08eb08"}], "stats": {"total": 61, "additions": 19, "deletions": 42}, "files": [{"sha": "a3f29eda0d6996832b8ad0b0680cf6b608d44d1c", "filename": "gcc/cp/cp-lang.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.cc?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -116,8 +116,7 @@ tree\n objcp_tsubst_copy_and_build (tree /*t*/,\n \t\t\t     tree /*args*/,\n \t\t\t     tsubst_flags_t /*complain*/,\n-\t\t\t     tree /*in_decl*/,\n-\t\t\t     bool /*function_p*/)\n+\t\t\t     tree /*in_decl*/)\n {\n   return NULL_TREE;\n }"}, {"sha": "f4ba0c9e012b033e389dc5a122950188116ed094", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -24,8 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n /* In cp/objcp-common.c, cp/cp-lang.cc and objcp/objcp-lang.cc.  */\n \n extern tree cp_get_debug_type (const_tree);\n-extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,\n-\t\t\t\t\t tree, bool);\n+extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t, tree);\n \n extern int cp_decl_dwarf_attribute (const_tree, int);\n extern int cp_type_dwarf_attribute (const_tree, int);"}, {"sha": "99612e9c0c61984fd71c066ff02728d9e615e5e2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -7384,7 +7384,7 @@ extern tree tsubst_default_argument\t\t(tree, int, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree tsubst (tree, tree, tsubst_flags_t, tree);\n extern tree tsubst_copy_and_build\t\t(tree, tree, tsubst_flags_t,\n-\t\t\t\t\t\t tree, bool = false, bool = false);\n+\t\t\t\t\t\t tree, bool = false);\n extern tree tsubst_expr                         (tree, tree, tsubst_flags_t,\n                                                  tree, bool);\n extern tree tsubst_pack_expansion\t\t(tree, tree, tsubst_flags_t, tree);"}, {"sha": "fee49090de76eb051d15a87ec0eb7d67f9cfaf55", "filename": "gcc/cp/init.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Finit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Finit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.cc?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -622,7 +622,7 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n \t  /* Do deferred instantiation of the NSDMI.  */\n \t  init = (tsubst_copy_and_build\n \t\t  (init, DECL_TI_ARGS (member),\n-\t\t   complain, member, /*function_p=*/false,\n+\t\t   complain, member,\n \t\t   /*integral_constant_expression_p=*/false));\n \t  init = digest_nsdmi_init (member, init, complain);\n "}, {"sha": "74f04ee8bf8be04def54fecc394497db671b8ead", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -3773,7 +3773,7 @@ expand_integer_pack (tree call, tree args, tsubst_flags_t complain,\n {\n   tree ohi = CALL_EXPR_ARG (call, 0);\n   tree hi = tsubst_copy_and_build (ohi, args, complain, in_decl,\n-\t\t\t\t   false/*fn*/, true/*int_cst*/);\n+\t\t\t\t   true/*int_cst*/);\n \n   if (instantiation_dependent_expression_p (hi))\n     {\n@@ -6361,7 +6361,6 @@ instantiate_non_dependent_expr_internal (tree expr, tsubst_flags_t complain)\n \t\t\t\t/*args=*/NULL_TREE,\n \t\t\t\tcomplain,\n \t\t\t\t/*in_decl=*/NULL_TREE,\n-\t\t\t\t/*function_p=*/false,\n \t\t\t\t/*integral_constant_expression_p=*/true);\n }\n \n@@ -14213,7 +14212,6 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n     {\n       tree spec = lookup_explicit_specifier (t);\n       spec = tsubst_copy_and_build (spec, args, complain, in_decl,\n-\t\t\t\t    /*function_p=*/false,\n \t\t\t\t    /*i_c_e_p=*/true);\n       spec = build_explicit_specifier (spec, complain);\n       if (spec == error_mark_node)\n@@ -15279,7 +15277,7 @@ tsubst_arg_types (tree arg_types,\n       || (in_decl && TREE_CODE (in_decl) == FUNCTION_DECL\n \t  && DECL_LOCAL_DECL_P (in_decl)))\n     default_arg = tsubst_copy_and_build (default_arg, args, complain, in_decl,\n-\t\t\t\t\t false/*fn*/, false/*constexpr*/);\n+\t\t\t\t\t false/*constexpr*/);\n \n   tree remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n \t\t\t\t\t       args, end, complain, in_decl);\n@@ -15461,7 +15459,7 @@ tsubst_exception_specification (tree fntype,\n \t      expr = DEFERRED_NOEXCEPT_PATTERN (expr);\n \t    }\n \t  new_specs = tsubst_copy_and_build\n-\t    (expr, args, complain, in_decl, /*function_p=*/false,\n+\t    (expr, args, complain, in_decl,\n \t     /*integral_constant_expression_p=*/true);\n \t}\n       new_specs = build_noexcept_spec (new_specs, complain);\n@@ -16386,7 +16384,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n \ttype = tsubst_copy_and_build (DECLTYPE_TYPE_EXPR (t), args,\n \t\t\t\t      complain|tf_decltype, in_decl,\n-\t\t\t\t      /*function_p*/false,\n \t\t\t\t      /*integral_constant_expression*/false);\n \n \t--cp_unevaluated_operand;\n@@ -18052,7 +18049,6 @@ tsubst_copy_asm_operands (tree t, tree args, tsubst_flags_t complain,\n \n   if (TREE_CODE (t) != TREE_LIST)\n     return tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t  /*function_p=*/false,\n \t\t\t\t  /*integral_constant_expression_p=*/false);\n \n   if (t == void_list_node)\n@@ -19639,7 +19635,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n \n       RETURN (tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t\t    /*function_p=*/false,\n \t\t\t\t    integral_constant_expression_p));\n     }\n \n@@ -19732,7 +19727,6 @@ tsubst_non_call_postfix_expression (tree t, tree args,\n \t\t\t     /*done=*/false, /*address_p=*/false);\n   else\n     t = tsubst_copy_and_build (t, args, complain, in_decl,\n-\t\t\t       /*function_p=*/false,\n \t\t\t       /*integral_constant_expression_p=*/false);\n \n   return t;\n@@ -19805,7 +19799,7 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tinit = tsubst_pack_expansion (init, args, complain, in_decl);\n       else\n \tinit = tsubst_copy_and_build (init, args, complain, in_decl,\n-\t\t\t\t      /*fn*/false, /*constexpr*/false);\n+\t\t\t\t      /*constexpr*/false);\n \n       if (init == error_mark_node)\n \treturn error_mark_node;\n@@ -20073,7 +20067,6 @@ tsubst_copy_and_build_call_args (tree t, tree args, tsubst_flags_t complain,\n       if (!PACK_EXPANSION_P (arg))\n \tvec_safe_push (call_args,\n \t\t       tsubst_copy_and_build (arg, args, complain, in_decl,\n-\t\t\t\t\t      /*function_p=*/false,\n \t\t\t\t\t      integral_constant_expression_p));\n       else\n \t{\n@@ -20100,21 +20093,18 @@ tsubst_copy_and_build_call_args (tree t, tree args, tsubst_flags_t complain,\n }\n \n /* Like tsubst but deals with expressions and performs semantic\n-   analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\" or\n-   \"F<TARGS> (ARGS)\".  */\n+   analysis.  */\n \n tree\n tsubst_copy_and_build (tree t,\n \t\t       tree args,\n \t\t       tsubst_flags_t complain,\n \t\t       tree in_decl,\n-\t\t       bool function_p,\n \t\t       bool integral_constant_expression_p)\n {\n #define RETURN(EXP) do { retval = (EXP); goto out; } while(0)\n #define RECUR(NODE)\t\t\t\t\t\t\\\n   tsubst_copy_and_build (NODE, args, complain, in_decl, \t\\\n-\t\t\t /*function_p=*/false,\t\t\t\\\n \t\t\t integral_constant_expression_p)\n \n   tree retval, op1;\n@@ -20171,7 +20161,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t     input_location);\n \tif (error_msg)\n \t  error (error_msg);\n-\tif (!function_p && identifier_p (decl))\n+\tif (identifier_p (decl))\n \t  {\n \t    if (complain & tf_error)\n \t      unqualified_name_lookup_error (decl);\n@@ -20185,7 +20175,6 @@ tsubst_copy_and_build (tree t,\n \ttree object;\n \ttree templ = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n \t\t\t\t\t    complain, in_decl,\n-\t\t\t\t\t    function_p,\n \t\t\t\t\t    integral_constant_expression_p);\n \ttree targs = TREE_OPERAND (t, 1);\n \n@@ -20568,7 +20557,6 @@ tsubst_copy_and_build (tree t,\n \t      op1 = tsubst (op1, args, complain, in_decl);\n \t    else\n \t      op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t\t   /*function_p=*/false,\n \t\t\t\t\t   /*integral_constant_expression_p=*/\n \t\t\t\t\t   false);\n \t    --cp_unevaluated_operand;\n@@ -20608,7 +20596,6 @@ tsubst_copy_and_build (tree t,\n \t++cp_unevaluated_operand;\n \t++c_inhibit_evaluation_warnings;\n \top1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t     /*function_p=*/false,\n \t\t\t\t     /*integral_constant_expression_p=*/false);\n \t--cp_unevaluated_operand;\n \t--c_inhibit_evaluation_warnings;\n@@ -20621,7 +20608,6 @@ tsubst_copy_and_build (tree t,\n       ++c_inhibit_evaluation_warnings;\n       ++cp_noexcept_operand;\n       op1 = tsubst_copy_and_build (op1, args, complain, in_decl,\n-\t\t\t\t   /*function_p=*/false,\n \t\t\t\t   /*integral_constant_expression_p=*/false);\n       --cp_unevaluated_operand;\n       --c_inhibit_evaluation_warnings;\n@@ -20732,7 +20718,6 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree op0 = tsubst_copy_and_build (TREE_OPERAND (t, 0), args,\n \t\t\t\t\t  complain & ~tf_decltype, in_decl,\n-\t\t\t\t\t  /*function_p=*/false,\n \t\t\t\t\t  integral_constant_expression_p);\n \tRETURN (build_x_compound_expr (EXPR_LOCATION (t),\n \t\t\t\t       op0,\n@@ -20778,12 +20763,10 @@ tsubst_copy_and_build (tree t,\n \t       would incorrectly perform unqualified lookup again.\n \n \t       Note that we can also have an IDENTIFIER_NODE if the earlier\n-\t       unqualified lookup found a member function; in that case\n-\t       koenig_p will be false and we do want to do the lookup\n-\t       again to find the instantiated member function.\n-\n-\t       FIXME but doing that causes c++/15272, so we need to stop\n-\t       using IDENTIFIER_NODE in that situation.  */\n+\t       unqualified lookup found a dependent local extern declaration\n+\t       (as per finish_call_expr); in that case koenig_p will be false\n+\t       and we do want to do the lookup again to find the substituted\n+\t       declaration.  */\n \t    qualified_p = false;\n \n \t    if (TREE_CODE (function) == TEMPLATE_ID_EXPR)\n@@ -20818,7 +20801,6 @@ tsubst_copy_and_build (tree t,\n \t      subcomplain |= tf_conv;\n \t    function = tsubst_copy_and_build (function, args, subcomplain,\n \t\t\t\t\t      in_decl,\n-\t\t\t\t\t      !qualified_p,\n \t\t\t\t\t      integral_constant_expression_p);\n \n \t    if (BASELINK_P (function))\n@@ -20922,7 +20904,7 @@ tsubst_copy_and_build (tree t,\n \t\t   the unqualified lookup again if we aren't in SFINAE\n \t\t   context.  */\n \t\ttree unq = (tsubst_copy_and_build\n-\t\t\t    (function, args, complain, in_decl, true,\n+\t\t\t    (function, args, complain, in_decl,\n \t\t\t     integral_constant_expression_p));\n \t\tif (unq == error_mark_node)\n \t\t  RETURN (error_mark_node);\n@@ -21473,7 +21455,7 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree object_ptr\n \t  = tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t   in_decl, /*function_p=*/false,\n+\t\t\t\t   in_decl,\n \t\t\t\t   /*integral_constant_expression_p=*/false);\n \tRETURN (finish_offsetof (object_ptr,\n \t\t\t\t RECUR (TREE_OPERAND (t, 0)),\n@@ -21575,8 +21557,7 @@ tsubst_copy_and_build (tree t,\n       /* Handle Objective-C++ constructs, if appropriate.  */\n       {\n \ttree subst\n-\t  = objcp_tsubst_copy_and_build (t, args, complain,\n-\t\t\t\t\t in_decl, /*function_p=*/false);\n+\t  = objcp_tsubst_copy_and_build (t, args, complain, in_decl);\n \tif (subst)\n \t  RETURN (subst);\n       }\n@@ -26393,7 +26374,6 @@ maybe_instantiate_noexcept (tree fn, tsubst_flags_t complain)\n \t  noex = tsubst_copy_and_build (DEFERRED_NOEXCEPT_PATTERN (noex),\n \t\t\t\t\tDEFERRED_NOEXCEPT_ARGS (noex),\n \t\t\t\t\ttf_warning_or_error, fn,\n-\t\t\t\t\t/*function_p=*/false,\n \t\t\t\t\t/*i_c_e_p=*/true);\n \n \t  /* Build up the noexcept-specification.  */"}, {"sha": "5f0e22942b813281bff3b88b68e9896fa4376db3", "filename": "gcc/objcp/objcp-lang.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fobjcp%2Fobjcp-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f/gcc%2Fobjcp%2Fobjcp-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-lang.cc?ref=c52c322627dd0f206b4bf7f7c94ab42bf5e61b6f", "patch": "@@ -50,12 +50,11 @@ struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n    there should be very few (if any) routines below.  */\n \n tree\n-objcp_tsubst_copy_and_build (tree t, tree args, tsubst_flags_t complain, \n-\t\t\t     tree in_decl, bool function_p ATTRIBUTE_UNUSED)\n+objcp_tsubst_copy_and_build (tree t, tree args, tsubst_flags_t complain,\n+\t\t\t     tree in_decl)\n {\n #define RECURSE(NODE)\t\t\t\t\t\t\t\\\n   tsubst_copy_and_build (NODE, args, complain, in_decl, \t\t\\\n-\t\t\t /*function_p=*/false,\t\t\t\t\\\n \t\t\t /*integral_constant_expression_p=*/false)\n \n   /* The following two can only occur in Objective-C++.  */"}]}