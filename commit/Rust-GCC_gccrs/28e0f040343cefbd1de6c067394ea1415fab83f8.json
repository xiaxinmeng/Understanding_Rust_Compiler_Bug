{"sha": "28e0f040343cefbd1de6c067394ea1415fab83f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlMGYwNDAzNDNjZWZiZDFkZTZjMDY3Mzk0ZWExNDE1ZmFiODNmOA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-12-09T12:06:37Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-12-09T12:06:37Z"}, "message": "cppfiles.c (NEVER_REREAD, [...]): Move from cpphash.h.\n\n        * cppfiles.c (NEVER_REREAD, DO_NOT_REREAD): Move from cpphash.h.\n        * cpphash.h (NEVER_REREAD, DO_NOT_REREAD, ABSOLUTE_PATH): Delete.\n        * cpplex.c (parse_identifier): Improve diagnostic.\n        (_cpp_lex_token): Return unconditionally at the end of a directive.\n        * cpplib.c (read_flag): Verify legality of each flag.\n        (end_directive): Resotre pfile->skipping before skip_rest_of_line.\n        (do_line): Use the new read_flag.\n        * cppmacro.c (struct cpp_macro, parse_arg, replace_args,\n        check_macro_redefinition, parse_params): Rename var_args to\n        variadic.\n\nFrom-SVN: r38150", "tree": {"sha": "03c1db8498e9dbaa46fcb7c0ed5437d1bbb36e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03c1db8498e9dbaa46fcb7c0ed5437d1bbb36e07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28e0f040343cefbd1de6c067394ea1415fab83f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e0f040343cefbd1de6c067394ea1415fab83f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e0f040343cefbd1de6c067394ea1415fab83f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e0f040343cefbd1de6c067394ea1415fab83f8/comments", "author": null, "committer": null, "parents": [{"sha": "1b32f732bf637e9783bf840d04cf4039944b3339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b32f732bf637e9783bf840d04cf4039944b3339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b32f732bf637e9783bf840d04cf4039944b3339"}], "stats": {"total": 128, "additions": 72, "deletions": 56}, "files": [{"sha": "24aa798830b017906c2715a119015465f6bb3d46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -1,3 +1,16 @@\n+2000-12-09  Neil Booth  <neilb@earthling.net>\n+\n+        * cppfiles.c (NEVER_REREAD, DO_NOT_REREAD): Move from cpphash.h.\n+        * cpphash.h (NEVER_REREAD, DO_NOT_REREAD, ABSOLUTE_PATH): Delete.\n+        * cpplex.c (parse_identifier): Improve diagnostic.\n+        (_cpp_lex_token): Return unconditionally at the end of a directive.\n+        * cpplib.c (read_flag): Verify legality of each flag.\n+        (end_directive): Resotre pfile->skipping before skip_rest_of_line.\n+        (do_line): Use the new read_flag.\n+        * cppmacro.c (struct cpp_macro, parse_arg, replace_args,\n+        check_macro_redefinition, parse_params): Rename var_args to\n+        variadic.\n+\n 2000-12-09  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* .cvsignore: Add info files."}, {"sha": "aeca30d627b35c6c60f72df5888d5939773195e9", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -80,6 +80,16 @@ struct include_file\n   unsigned char defined;\t/* cmacro prevents inclusion in this state */\n };\n \n+/* The cmacro works like this: If it's NULL, the file is to be\n+   included again.  If it's NEVER_REREAD, the file is never to be\n+   included again.  Otherwise it is a macro hashnode, and the file is\n+   to be included again if the macro is defined or not as specified by\n+   DEFINED.  */\n+#define NEVER_REREAD ((const cpp_hashnode *)-1)\n+#define DO_NOT_REREAD(inc) \\\n+((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n+\t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n+\n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));"}, {"sha": "f1f4400118729be1ffc43f67883d163ceb521132", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -68,17 +68,6 @@ struct file_name_list\n      Only used on MS-DOS and related platforms. */\n   struct file_name_map *name_map;\n };\n-#define ABSOLUTE_PATH ((struct file_name_list *)-1)\n-\n-/* The cmacro works like this: If it's NULL, the file is to be\n-   included again.  If it's NEVER_REREAD, the file is never to be\n-   included again.  Otherwise it is a macro hashnode, and the file is\n-   to be included again if the macro is defined or not as specified by\n-   DEFINED.  */\n-#define NEVER_REREAD ((const cpp_hashnode *)-1)\n-#define DO_NOT_REREAD(inc) \\\n-((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n-\t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n \n struct cpp_buffer\n {\n@@ -168,10 +157,8 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n #define CPP_PRINT_DEPS(PFILE) CPP_OPTION (PFILE, print_deps)\n #define CPP_IN_SYSTEM_HEADER(PFILE) \\\n   (CPP_BUFFER (PFILE) && CPP_BUFFER (PFILE)->sysp)\n-#define CPP_PEDANTIC(PF) \\\n-  CPP_OPTION (PF, pedantic)\n-#define CPP_WTRADITIONAL(PF) \\\n-  CPP_OPTION (PF, warn_traditional)\n+#define CPP_PEDANTIC(PF) CPP_OPTION (PF, pedantic)\n+#define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n /* Hash step.  The hash calculation is duplicated in cpp_lookup and\n    parse_name.  */"}, {"sha": "2b5b85233a34fd5dc64b1461747f4e6d004597ce", "filename": "gcc/cpplex.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -521,10 +521,10 @@ parse_identifier (pfile, c)\n \tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\", result->name);\n \n       /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n-\t replacement list of a variable-arguments macro.  */\n+\t replacement list of a variadic macro.  */\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n-\tcpp_pedwarn (pfile, \"__VA_ARGS__ can only appear in the expansion of a C99 variable-argument macro\");\n+\tcpp_pedwarn (pfile, \"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro\");\n     }\n \n   return result;\n@@ -907,7 +907,8 @@ _cpp_lex_token (pfile, result)\n       buffer->read_ahead = c;\n       pfile->state.next_bol = 1;\n       result->type = CPP_EOF;\n-      break;\n+      /* Don't break; pfile->skipping might be true.  */\n+      return;\n \n     case '?':\n     case '\\\\':"}, {"sha": "5c7e4e1ab108b18b8fbb856aa93b0b3031b48bc3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -90,7 +90,7 @@ static int glue_header_name\tPARAMS ((cpp_reader *, cpp_token *));\n static int  parse_include\tPARAMS ((cpp_reader *, cpp_token *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n-static unsigned int read_flag\tPARAMS ((cpp_reader *));\n+static unsigned int read_flag\tPARAMS ((cpp_reader *, unsigned int));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n@@ -247,14 +247,14 @@ end_directive (pfile, skip_line)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n+  /* Restore pfile->skipping before skip_rest_of_line, so that e.g.\n+     __VA_ARGS__ in the rest of the directive doesn't warn.  */\n+  pfile->skipping = buffer->was_skipping;\n+\n   /* We don't skip for an assembler #.  */\n   if (skip_line)\n     skip_rest_of_line (pfile);\n \n-  /* Restore pfile->skipping after skip_rest_of_line.  Otherwise the\n-     lexer might not return!  */\n-  pfile->skipping = buffer->was_skipping;\n-\n   /* Restore state.  */\n   pfile->la_write = pfile->la_saved;\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n@@ -639,22 +639,26 @@ do_include_next (pfile)\n     _cpp_execute_include (pfile, &header, 0, 1);\n }\n \n-/* Subroutine of do_line.  Read possible flags after file name.  If it\n-   is a number between 1 and 4, return it, otherwise return 0.  If\n-   it's not the end of the directive complain.  */\n+/* Subroutine of do_line.  Read possible flags after file name.  LAST\n+   is the last flag seen; 0 if this is the first flag. Return the flag\n+   if it is valid, 0 at the end of the directive. Otherwise complain.  */\n \n static unsigned int\n-read_flag (pfile)\n+read_flag (pfile, last)\n      cpp_reader *pfile;\n+     unsigned int last;\n {\n   cpp_token token;\n \n   _cpp_lex_token (pfile, &token);\n   if (token.type == CPP_NUMBER && token.val.str.len == 1)\n     {\n-      unsigned int flag = token.val.str.text[0] - '1';\n-      if (flag <= 3)\n-\treturn flag + 1;\n+      unsigned int flag = token.val.str.text[0] - '0';\n+\n+      if (flag > last && flag <= 4\n+\t  && (flag != 4 || last == 3)\n+\t  && (flag != 2 || last == 0))\n+\treturn flag;\n     }\n \n   if (token.type != CPP_EOF)\n@@ -733,31 +737,33 @@ do_line (pfile)\n       _cpp_simplify_pathname (fname);\n       buffer->nominal_fname = fname;\n \n-      if (pfile->state.line_extension)\n+      if (! pfile->state.line_extension)\n+\tcheck_eol (pfile);\n+      else\n \t{\n-\t  int flag, sysp = 0;\n+\t  int flag = 0, sysp = 0;\n \n-\t  flag = read_flag (pfile);\n+\t  flag = read_flag (pfile, flag);\n \t  if (flag == 1)\n \t    {\n \t      reason = FC_ENTER;\n-\t      flag = read_flag (pfile);\n+\t      flag = read_flag (pfile, flag);\n \t    }\n \t  else if (flag == 2)\n \t    {\n \t      reason = FC_LEAVE;\n-\t      flag = read_flag (pfile);\n+\t      flag = read_flag (pfile, flag);\n \t    }\n \t  if (flag == 3)\n \t    {\n-\t      flag = read_flag (pfile);\n \t      sysp = 1;\n+\t      flag = read_flag (pfile, flag);\n+\t      if (flag == 4)\n+\t\tsysp = 2, read_flag (pfile, flag);\n \t    }\n \n-\t  cpp_make_system_header (pfile, sysp, flag == 4);\n+\t  cpp_make_system_header (pfile, sysp, sysp == 2);\n \t}\n-\n-      check_eol (pfile);\n     }\n   else if (token.type != CPP_EOF)\n     {"}, {"sha": "e312d7d83e953e68241813b92c5777cb434cfb94", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e0f040343cefbd1de6c067394ea1415fab83f8/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=28e0f040343cefbd1de6c067394ea1415fab83f8", "patch": "@@ -42,7 +42,7 @@ struct cpp_macro\n   unsigned int count;\t\t/* Number of tokens in expansion.  */\n   unsigned short paramc;\t/* Number of parameters.  */\n   unsigned int fun_like : 1;\t/* If a function-like macro.  */\n-  unsigned int var_args : 1;\t/* If a variable-args macro.  */\n+  unsigned int variadic : 1;\t/* If a variadic macro.  */\n   unsigned int disabled : 1;\t/* If macro is disabled.  */\n };\n \n@@ -475,13 +475,13 @@ paste_all_tokens (pfile, lhs)\n }\n \n /* Reads the unexpanded tokens of a macro argument into ARG.  VAR_ARGS\n-   is non-zero if this is a variable argument.  Returns the type of\n-   the token that caused reading to finish.  */\n+   is non-zero if this is a variadic macro.  Returns the type of the\n+   token that caused reading to finish.  */\n static enum cpp_ttype\n-parse_arg (pfile, arg, var_args)\n+parse_arg (pfile, arg, variadic)\n      cpp_reader *pfile;\n      struct macro_arg *arg;\n-     int var_args;\n+     int variadic;\n {\n   enum cpp_ttype result;\n   unsigned int paren = 0;\n@@ -509,8 +509,8 @@ parse_arg (pfile, arg, var_args)\n \tparen++;\n       else if (result == CPP_CLOSE_PAREN && paren-- == 0)\n \tbreak;\n-      /* Commas are not terminators within parantheses or var_args.  */\n-      else if (result == CPP_COMMA && paren == 0 && !var_args)\n+      /* Commas are not terminators within parantheses or variadic.  */\n+      else if (result == CPP_COMMA && paren == 0 && !variadic)\n \tbreak;\n       else if (result == CPP_EOF)\n \tbreak;\t\t/* Error reported by caller.  */\n@@ -541,7 +541,7 @@ parse_args (pfile, node)\n     {\n       argc++;\n \n-      type = parse_arg (pfile, cur, argc == macro->paramc && macro->var_args);\n+      type = parse_arg (pfile, cur, argc == macro->paramc && macro->variadic);\n       if (type == CPP_CLOSE_PAREN || type == CPP_EOF)\n \tbreak;\n \n@@ -566,7 +566,7 @@ parse_args (pfile, node)\n \t This is exactly the same as if there had been an empty rest\n \t argument - debug(\"string\", ).  */\n \n-      if (argc + 1 == macro->paramc && macro->var_args)\n+      if (argc + 1 == macro->paramc && macro->variadic)\n \t{\n \t  if (CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n@@ -794,7 +794,7 @@ replace_args (pfile, macro, args, list)\n \t\t   given no actual arguments (not merely if b is an\n \t\t   empty argument); otherwise pasting is turned off.  */\n \t\tif (dest[-1].type == CPP_COMMA\n-\t\t    && macro->var_args\n+\t\t    && macro->variadic\n \t\t    && src->val.arg_no == macro->paramc)\n \t\t  {\n \t\t    if (count == 0)\n@@ -1182,7 +1182,7 @@ check_macro_redefinition (pfile, node, macro2)\n   if (macro1->count != macro2->count\n       || macro1->paramc != macro2->paramc\n       || macro1->fun_like != macro2->fun_like\n-      || macro1->var_args != macro2->var_args)\n+      || macro1->variadic != macro2->variadic)\n     return 0;\n \n   /* Check each token.  */\n@@ -1287,18 +1287,17 @@ parse_params (pfile, macro)\n \t  continue;\n \n \tcase CPP_ELLIPSIS:\n-\t  macro->var_args = 1;\n+\t  macro->variadic = 1;\n \t  if (!prev_ident)\n \t    {\n \t      save_parameter (pfile, macro, pfile->spec_nodes.n__VA_ARGS__);\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99) && CPP_OPTION (pfile, pedantic))\n \t\tcpp_pedwarn (pfile,\n-\t\t     \"anonymous variable arguments were introduced in C99\");\n+\t\t     \"anonymous variadic macros were introduced in C99\");\n \t    }\n \t  else if (CPP_OPTION (pfile, pedantic))\n-\t    cpp_pedwarn (pfile,\n-\t\t\t \"ISO C does not permit named variable arguments\");\n+\t    cpp_pedwarn (pfile, \"ISO C does not permit named variadic macros\");\n \n \t  /* We're at the end, and just expect a closing parenthesis.  */\n \t  _cpp_lex_token (pfile, &token);\n@@ -1368,7 +1367,7 @@ _cpp_create_definition (pfile, node)\n   macro->params = 0;\n   macro->paramc = 0;\n   macro->fun_like = 0;\n-  macro->var_args = 0;\n+  macro->variadic = 0;\n   macro->count = 0;\n   macro->expansion = (cpp_token *) POOL_FRONT (&pfile->macro_pool);\n \n@@ -1598,7 +1597,7 @@ cpp_macro_definition (pfile, node)\n \n \t  if (i + 1 < macro->paramc)\n \t    *buffer++ = ',', *buffer++ = ' ';\n-\t  else if (macro->var_args)\n+\t  else if (macro->variadic)\n \t    *buffer++ = '.', *buffer++ = '.', *buffer++ = '.';\n \t}\n       *buffer++ = ')';"}]}