{"sha": "da2d1d3a8f3121eb1d3ae502b0367291577919ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyZDFkM2E4ZjMxMjFlYjFkM2FlNTAyYjAzNjcyOTE1Nzc5MTlhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-02-12T00:49:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-02-12T00:49:11Z"}, "message": "i386.c (ix86_emit_restore_regs_using_mov): Break out from ...\n\n\t* i386.c (ix86_emit_restore_regs_using_mov): Break out from ...\n\t(ix86_expand_epilogue): ... here. Use mov instead of add to restore\n\tstack pointer in functions w/o saved registers, output LEAVE more often\n\ton TARGET_USE_LEAVE machines.\n\nFrom-SVN: r31941", "tree": {"sha": "519d4188849c4d4b69b57aec887adde1c91819ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/519d4188849c4d4b69b57aec887adde1c91819ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da2d1d3a8f3121eb1d3ae502b0367291577919ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2d1d3a8f3121eb1d3ae502b0367291577919ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2d1d3a8f3121eb1d3ae502b0367291577919ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2d1d3a8f3121eb1d3ae502b0367291577919ab/comments", "author": null, "committer": null, "parents": [{"sha": "28ec5077d7f533713104cdfa21817917098c8111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ec5077d7f533713104cdfa21817917098c8111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ec5077d7f533713104cdfa21817917098c8111"}], "stats": {"total": 74, "additions": 59, "deletions": 15}, "files": [{"sha": "e7698d57f14b964d02314932c671cd4d743c9d58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2d1d3a8f3121eb1d3ae502b0367291577919ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2d1d3a8f3121eb1d3ae502b0367291577919ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da2d1d3a8f3121eb1d3ae502b0367291577919ab", "patch": "@@ -1,3 +1,10 @@\n+Sat Feb 12 01:44:26 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_emit_restore_regs_using_mov): Break out from ...\n+\t(ix86_expand_epilogue): ... here. Use mov instead of add to restore\n+\tstack pointer in functions w/o saved registers, output LEAVE more often\n+\ton TARGET_USE_LEAVE machines.\n+\n 2000-02-07  Dmitri Makarov  <dim@wrs.com> & Bernd Schmidt <bernds@redhat.com>\n \n \t* config/arm/arm.c (arm_init_cumulative_args); New function:"}, {"sha": "18128b71e44d71e7e78395bfe191f3ccc9bcabf9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2d1d3a8f3121eb1d3ae502b0367291577919ab/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2d1d3a8f3121eb1d3ae502b0367291577919ab/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=da2d1d3a8f3121eb1d3ae502b0367291577919ab", "patch": "@@ -401,6 +401,7 @@ static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT,\n \t\t\t\t\t\t     int *, int *, int *));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n+static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int));\n static void ix86_emit_epilogue_esp_adjustment PARAMS((int));\n static void ix86_sched_reorder_pentium PARAMS((rtx *, rtx *));\n static void ix86_sched_reorder_ppro PARAMS((rtx *, rtx *));\n@@ -1963,6 +1964,31 @@ ix86_emit_epilogue_esp_adjustment (tsize)\n     }\n }\n \n+/* Emit code to restore saved registers using MOV insns.  First register\n+   is restored from POINTER + OFFSET.  */\n+static void\n+ix86_emit_restore_regs_using_mov (pointer, offset)\n+\trtx pointer;\n+\tint offset;\n+{\n+  int regno;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  int limit = (frame_pointer_needed\n+\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\n+  for (regno = 0; regno < limit; regno++)\n+    if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      {\n+\temit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\tadj_offsettable_operand (gen_rtx_MEM (SImode,\n+\t\t\t\t\t\t\t      pointer),\n+\t\t\t\t\t\t offset));\n+\toffset += 4;\n+      }\n+}\n+\n /* Restore function stack, frame, and registers. */\n \n void\n@@ -1991,23 +2017,34 @@ ix86_expand_epilogue ()\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n-     less work than reloading sp and popping the register.  */\n-  if (!sp_valid && nregs <= 1)\n-    {\n-      if (!frame_pointer_needed)\n-\tabort();\n-\n-      for (regno = 0; regno < HARD_FRAME_POINTER_REGNUM; regno++)\n-\tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-\t  {\n-\t    emit_move_insn (gen_rtx_REG (SImode, regno),\n-\t\t\t    adj_offsettable_operand (AT_BP (Pmode), offset));\n-\t    offset += 4;\n-\t  }\n+     less work than reloading sp and popping the register.  \n+\n+     The default code result in stack adjustment using add/lea instruction,\n+     while this code results in LEAVE instruction (or discrete equivalent),\n+     so it is profitable in some other cases as well.  Especially when there\n+     are no registers to restore.  We also use this code when TARGET_USE_LEAVE\n+     and there is exactly one register to pop. This heruistic may need some\n+     tuning in future.  */\n+  if ((!sp_valid && nregs <= 1)\n+      || (frame_pointer_needed && !nregs && tsize)\n+      || (frame_pointer_needed && TARGET_USE_LEAVE && !optimize_size\n+\t  && nregs == 1))\n+    {\n+      /* Restore registers.  We can use ebp or esp to address the memory\n+\t locations.  If both are available, default to ebp, since offsets\n+\t are known to be small.  Only exception is esp pointing directly to the\n+\t end of block of saved registers, where we may simplify addressing\n+\t mode.  */\n+\n+      if (!frame_pointer_needed || (sp_valid && !tsize))\n+\tix86_emit_restore_regs_using_mov (stack_pointer_rtx, tsize);\n+      else\n+\tix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx, offset);\n \n+      if (!frame_pointer_needed)\n+\tix86_emit_epilogue_esp_adjustment (tsize + nregs * UNITS_PER_WORD);\n       /* If not an i386, mov & pop is faster than \"leave\". */\n-      if (TARGET_USE_LEAVE || optimize_size)\n+      else if (TARGET_USE_LEAVE || optimize_size)\n \temit_insn (gen_leave ());\n       else\n \t{"}]}