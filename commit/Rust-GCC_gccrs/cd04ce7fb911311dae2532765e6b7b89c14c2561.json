{"sha": "cd04ce7fb911311dae2532765e6b7b89c14c2561", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwNGNlN2ZiOTExMzExZGFlMjUzMjc2NWU2YjdiODljMTRjMjU2MQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-12-01T15:43:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-12-01T15:43:58Z"}, "message": "fold-const.c (const_binop): Handle POINTER_PLUS_EXPR.\n\n2014-12-01  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (const_binop): Handle POINTER_PLUS_EXPR.\n\tProperly handle FIXED_CST shifts by INTEGER_CST.\n\t(const_binop): Move COMPLEX_EXPR, VEC_PACK_TRUNC_EXPR,\n\tVEC_PACK_FIX_TRUNC_EXPR, VEC_WIDEN_MULT_LO_EXPR,\n\tVEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_EVEN_EXPR and\n\tVEC_WIDEN_MULT_ODD_EXPR handling here from ...\n\t(fold_binary_loc): ... here.  Call const_binop overload\n\twith result type.\n\nFrom-SVN: r218223", "tree": {"sha": "8cb54ef068a9c4c27cb670e3acb40e482d29addc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cb54ef068a9c4c27cb670e3acb40e482d29addc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd04ce7fb911311dae2532765e6b7b89c14c2561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd04ce7fb911311dae2532765e6b7b89c14c2561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd04ce7fb911311dae2532765e6b7b89c14c2561", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd04ce7fb911311dae2532765e6b7b89c14c2561/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d1f4ae5f155c0656ef53d7692bb81b424c28220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d1f4ae5f155c0656ef53d7692bb81b424c28220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d1f4ae5f155c0656ef53d7692bb81b424c28220"}], "stats": {"total": 224, "additions": 120, "deletions": 104}, "files": [{"sha": "f2c4587899ad1f7aeddf030d28b48c95faff5115", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd04ce7fb911311dae2532765e6b7b89c14c2561/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd04ce7fb911311dae2532765e6b7b89c14c2561/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd04ce7fb911311dae2532765e6b7b89c14c2561", "patch": "@@ -1,3 +1,14 @@\n+2014-12-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (const_binop): Handle POINTER_PLUS_EXPR.\n+\tProperly handle FIXED_CST shifts by INTEGER_CST.\n+\t(const_binop): Move COMPLEX_EXPR, VEC_PACK_TRUNC_EXPR,\n+\tVEC_PACK_FIX_TRUNC_EXPR, VEC_WIDEN_MULT_LO_EXPR,\n+\tVEC_WIDEN_MULT_HI_EXPR, VEC_WIDEN_MULT_EVEN_EXPR and\n+\tVEC_WIDEN_MULT_ODD_EXPR handling here from ...\n+\t(fold_binary_loc): ... here.  Call const_binop overload\n+\twith result type.\n+\n 2014-12-01  Marek Polacek  <polacek@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "29975e438c73092b62621183a5bf345e78ba2206", "filename": "gcc/fold-const.c", "status": "modified", "additions": 109, "deletions": 104, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd04ce7fb911311dae2532765e6b7b89c14c2561/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd04ce7fb911311dae2532765e6b7b89c14c2561/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=cd04ce7fb911311dae2532765e6b7b89c14c2561", "patch": "@@ -1134,7 +1134,13 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n   STRIP_NOPS (arg2);\n \n   if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n-    return int_const_binop (code, arg1, arg2);\n+    {\n+      if (code == POINTER_PLUS_EXPR)\n+\treturn int_const_binop (PLUS_EXPR,\n+\t\t\t\targ1, fold_convert (TREE_TYPE (arg1), arg2));\n+\n+      return int_const_binop (code, arg1, arg2);\n+    }\n \n   if (TREE_CODE (arg1) == REAL_CST && TREE_CODE (arg2) == REAL_CST)\n     {\n@@ -1214,7 +1220,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n       return t;\n     }\n \n-  if (TREE_CODE (arg1) == FIXED_CST && TREE_CODE (arg2) == FIXED_CST)\n+  if (TREE_CODE (arg1) == FIXED_CST)\n     {\n       FIXED_VALUE_TYPE f1;\n       FIXED_VALUE_TYPE f2;\n@@ -1230,12 +1236,16 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \tcase MINUS_EXPR:\n \tcase MULT_EXPR:\n \tcase TRUNC_DIV_EXPR:\n+\t  if (TREE_CODE (arg2) != FIXED_CST)\n+\t    return NULL_TREE;\n \t  f2 = TREE_FIXED_CST (arg2);\n \t  break;\n \n \tcase LSHIFT_EXPR:\n \tcase RSHIFT_EXPR:\n \t  {\n+\t    if (TREE_CODE (arg2) != INTEGER_CST)\n+\t      return NULL_TREE;\n \t    wide_int w2 = arg2;\n \t    f2.data.high = w2.elt (1);\n \t    f2.data.low = w2.elt (0);\n@@ -1443,8 +1453,102 @@ const_binop (enum tree_code code, tree type, tree arg1, tree arg2)\n {\n   if (TREE_CODE_CLASS (code) == tcc_comparison)\n     return fold_relational_const (code, type, arg1, arg2);\n-  else\n-    return const_binop (code, arg1, arg2);\n+\n+  /* ???  Until we make the const_binop worker take the type of the\n+     result as argument put those cases that need it here.  */\n+  switch (code)\n+    {\n+    case COMPLEX_EXPR:\n+      if ((TREE_CODE (arg1) == REAL_CST\n+\t   && TREE_CODE (arg2) == REAL_CST)\n+\t  || (TREE_CODE (arg1) == INTEGER_CST\n+\t      && TREE_CODE (arg2) == INTEGER_CST))\n+\treturn build_complex (type, arg1, arg2);\n+      return NULL_TREE;\n+\n+    case VEC_PACK_TRUNC_EXPR:\n+    case VEC_PACK_FIX_TRUNC_EXPR:\n+      {\n+\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+\ttree *elts;\n+\n+\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts / 2\n+\t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2)) == nelts / 2);\n+\tif (TREE_CODE (arg1) != VECTOR_CST\n+\t    || TREE_CODE (arg2) != VECTOR_CST)\n+\t  return NULL_TREE;\n+\n+\telts = XALLOCAVEC (tree, nelts);\n+\tif (!vec_cst_ctor_to_array (arg1, elts)\n+\t    || !vec_cst_ctor_to_array (arg2, elts + nelts / 2))\n+\t  return NULL_TREE;\n+\n+\tfor (i = 0; i < nelts; i++)\n+\t  {\n+\t    elts[i] = fold_convert_const (code == VEC_PACK_TRUNC_EXPR\n+\t\t\t\t\t  ? NOP_EXPR : FIX_TRUNC_EXPR,\n+\t\t\t\t\t  TREE_TYPE (type), elts[i]);\n+\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n+\t      return NULL_TREE;\n+\t  }\n+\n+\treturn build_vector (type, elts);\n+      }\n+\n+    case VEC_WIDEN_MULT_LO_EXPR:\n+    case VEC_WIDEN_MULT_HI_EXPR:\n+    case VEC_WIDEN_MULT_EVEN_EXPR:\n+    case VEC_WIDEN_MULT_ODD_EXPR:\n+      {\n+\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n+\tunsigned int out, ofs, scale;\n+\ttree *elts;\n+\n+\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts * 2\n+\t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2)) == nelts * 2);\n+\tif (TREE_CODE (arg1) != VECTOR_CST || TREE_CODE (arg2) != VECTOR_CST)\n+\t  return NULL_TREE;\n+\n+\telts = XALLOCAVEC (tree, nelts * 4);\n+\tif (!vec_cst_ctor_to_array (arg1, elts)\n+\t    || !vec_cst_ctor_to_array (arg2, elts + nelts * 2))\n+\t  return NULL_TREE;\n+\n+\tif (code == VEC_WIDEN_MULT_LO_EXPR)\n+\t  scale = 0, ofs = BYTES_BIG_ENDIAN ? nelts : 0;\n+\telse if (code == VEC_WIDEN_MULT_HI_EXPR)\n+\t  scale = 0, ofs = BYTES_BIG_ENDIAN ? 0 : nelts;\n+\telse if (code == VEC_WIDEN_MULT_EVEN_EXPR)\n+\t  scale = 1, ofs = 0;\n+\telse /* if (code == VEC_WIDEN_MULT_ODD_EXPR) */\n+\t  scale = 1, ofs = 1;\n+\n+\tfor (out = 0; out < nelts; out++)\n+\t  {\n+\t    unsigned int in1 = (out << scale) + ofs;\n+\t    unsigned int in2 = in1 + nelts * 2;\n+\t    tree t1, t2;\n+\n+\t    t1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in1]);\n+\t    t2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in2]);\n+\n+\t    if (t1 == NULL_TREE || t2 == NULL_TREE)\n+\t      return NULL_TREE;\n+\t    elts[out] = const_binop (MULT_EXPR, t1, t2);\n+\t    if (elts[out] == NULL_TREE || !CONSTANT_CLASS_P (elts[out]))\n+\t      return NULL_TREE;\n+\t  }\n+\n+\treturn build_vector (type, elts);\n+      }\n+\n+    default:;\n+    }\n+\n+  /* Make sure type and arg0 have the same saturating flag.  */\n+  gcc_checking_assert (TYPE_SATURATING (type)\n+\t\t       == TYPE_SATURATING (TREE_TYPE (arg1)));\n+  return const_binop (code, arg1, arg2);\n }\n \n /* Compute CODE ARG1 with resulting type TYPE with ARG1 being constant.\n@@ -9756,18 +9860,7 @@ fold_binary_loc (location_t loc,\n      constant but we can't do arithmetic on them.  */\n   if (CONSTANT_CLASS_P (arg0) && CONSTANT_CLASS_P (arg1))\n     {\n-      if (kind == tcc_binary)\n-\t{\n-\t  /* Make sure type and arg0 have the same saturating flag.  */\n-\t  gcc_checking_assert (TYPE_SATURATING (type)\n-\t\t\t       == TYPE_SATURATING (TREE_TYPE (arg0)));\n-\t  tem = const_binop (code, arg0, arg1);\n-\t}\n-      else if (kind == tcc_comparison)\n-\ttem = fold_relational_const (code, type, arg0, arg1);\n-      else\n-\ttem = NULL_TREE;\n-\n+      tem = const_binop (code, type, arg0, arg1);\n       if (tem != NULL_TREE)\n \t{\n \t  if (TREE_TYPE (tem) != type)\n@@ -9920,11 +10013,6 @@ fold_binary_loc (location_t loc,\n \t\t\t\t\t      fold_convert_loc (loc, sizetype,\n \t\t\t\t\t\t\t\targ0)));\n \n-      /* PTR_CST +p CST -> CST1 */\n-      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n-\treturn fold_build2_loc (loc, PLUS_EXPR, type, arg0,\n-\t\t\t    fold_convert_loc (loc, type, arg1));\n-\n       return NULL_TREE;\n \n     case PLUS_EXPR:\n@@ -13126,93 +13214,10 @@ fold_binary_loc (location_t loc,\n \t\t\t\t : fold_convert_loc (loc, type, arg1);\n       return pedantic_non_lvalue_loc (loc, tem);\n \n-    case COMPLEX_EXPR:\n-      if ((TREE_CODE (arg0) == REAL_CST\n-\t   && TREE_CODE (arg1) == REAL_CST)\n-\t  || (TREE_CODE (arg0) == INTEGER_CST\n-\t      && TREE_CODE (arg1) == INTEGER_CST))\n-\treturn build_complex (type, arg0, arg1);\n-      return NULL_TREE;\n-\n     case ASSERT_EXPR:\n       /* An ASSERT_EXPR should never be passed to fold_binary.  */\n       gcc_unreachable ();\n \n-    case VEC_PACK_TRUNC_EXPR:\n-    case VEC_PACK_FIX_TRUNC_EXPR:\n-      {\n-\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n-\ttree *elts;\n-\n-\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts / 2\n-\t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts / 2);\n-\tif (TREE_CODE (arg0) != VECTOR_CST || TREE_CODE (arg1) != VECTOR_CST)\n-\t  return NULL_TREE;\n-\n-\telts = XALLOCAVEC (tree, nelts);\n-\tif (!vec_cst_ctor_to_array (arg0, elts)\n-\t    || !vec_cst_ctor_to_array (arg1, elts + nelts / 2))\n-\t  return NULL_TREE;\n-\n-\tfor (i = 0; i < nelts; i++)\n-\t  {\n-\t    elts[i] = fold_convert_const (code == VEC_PACK_TRUNC_EXPR\n-\t\t\t\t\t  ? NOP_EXPR : FIX_TRUNC_EXPR,\n-\t\t\t\t\t  TREE_TYPE (type), elts[i]);\n-\t    if (elts[i] == NULL_TREE || !CONSTANT_CLASS_P (elts[i]))\n-\t      return NULL_TREE;\n-\t  }\n-\n-\treturn build_vector (type, elts);\n-      }\n-\n-    case VEC_WIDEN_MULT_LO_EXPR:\n-    case VEC_WIDEN_MULT_HI_EXPR:\n-    case VEC_WIDEN_MULT_EVEN_EXPR:\n-    case VEC_WIDEN_MULT_ODD_EXPR:\n-      {\n-\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n-\tunsigned int out, ofs, scale;\n-\ttree *elts;\n-\n-\tgcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts * 2\n-\t\t    && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts * 2);\n-\tif (TREE_CODE (arg0) != VECTOR_CST || TREE_CODE (arg1) != VECTOR_CST)\n-\t  return NULL_TREE;\n-\n-\telts = XALLOCAVEC (tree, nelts * 4);\n-\tif (!vec_cst_ctor_to_array (arg0, elts)\n-\t    || !vec_cst_ctor_to_array (arg1, elts + nelts * 2))\n-\t  return NULL_TREE;\n-\n-\tif (code == VEC_WIDEN_MULT_LO_EXPR)\n-\t  scale = 0, ofs = BYTES_BIG_ENDIAN ? nelts : 0;\n-\telse if (code == VEC_WIDEN_MULT_HI_EXPR)\n-\t  scale = 0, ofs = BYTES_BIG_ENDIAN ? 0 : nelts;\n-\telse if (code == VEC_WIDEN_MULT_EVEN_EXPR)\n-\t  scale = 1, ofs = 0;\n-\telse /* if (code == VEC_WIDEN_MULT_ODD_EXPR) */\n-\t  scale = 1, ofs = 1;\n-\t\n-\tfor (out = 0; out < nelts; out++)\n-\t  {\n-\t    unsigned int in1 = (out << scale) + ofs;\n-\t    unsigned int in2 = in1 + nelts * 2;\n-\t    tree t1, t2;\n-\n-\t    t1 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in1]);\n-\t    t2 = fold_convert_const (NOP_EXPR, TREE_TYPE (type), elts[in2]);\n-\n-\t    if (t1 == NULL_TREE || t2 == NULL_TREE)\n-\t      return NULL_TREE;\n-\t    elts[out] = const_binop (MULT_EXPR, t1, t2);\n-\t    if (elts[out] == NULL_TREE || !CONSTANT_CLASS_P (elts[out]))\n-\t      return NULL_TREE;\n-\t  }\n-\n-\treturn build_vector (type, elts);\n-      }\n-\n     default:\n       return NULL_TREE;\n     } /* switch (code) */"}]}