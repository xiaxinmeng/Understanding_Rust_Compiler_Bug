{"sha": "bd785b44932274f7067105de417938597289962c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ3ODViNDQ5MzIyNzRmNzA2NzEwNWRlNDE3OTM4NTk3Mjg5OTYyYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:19:38Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:19:38Z"}, "message": "Add function_abi.{h,cc}\n\nThis patch adds new structures and functions for handling\nmultiple ABIs in a translation unit.  The structures are:\n\n- predefined_function_abi: describes a static, predefined ABI\n- function_abi: describes either a predefined ABI or a local\n  variant of one (e.g. taking -fipa-ra into account)\n\nThe patch adds functions for getting the ABI from a given type\nor decl; a later patch will also add a function for getting the\nABI of the target of a call insn.\n\nAlthough ABIs are about much more than call-clobber/saved choices,\nI wanted to keep the name general in case we add more ABI-related\ninformation in future.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* Makefile.in (OBJS): Add function-abi.o.\n\t(GTFILES): Add function-abi.h.\n\t* function-abi.cc: New file.\n\t* function-abi.h: Likewise.\n\t* emit-rtl.h (rtl_data::abi): New field.\n\t* function.c: Include function-abi.h.\n\t(prepare_function_start): Initialize crtl->abi.\n\t* read-rtl-function.c: Include regs.h and function-abi.h.\n\t(read_rtl_function_body): Initialize crtl->abi.\n\t(read_rtl_function_body_from_file_range): Likewise.\n\t* reginfo.c: Include function-abi.h.\n\t(init_reg_sets_1): Initialize default_function_abi.\n\t(globalize_reg): Call add_full_reg_clobber for each predefined ABI\n\twhen making a register global.\n\t* target-globals.h (this_target_function_abi_info): Declare.\n\t(target_globals::function_abi_info): New field.\n\t(restore_target_globals): Copy it.\n\t* target-globals.c: Include function-abi.h.\n\t(default_target_globals): Initialize the function_abi_info field.\n\t(target_globals): Allocate it.\n\t(save_target_globals): Free it.\n\nFrom-SVN: r276307", "tree": {"sha": "503a651572b5e0035d9cb5422d10f45b3e051b5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/503a651572b5e0035d9cb5422d10f45b3e051b5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd785b44932274f7067105de417938597289962c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd785b44932274f7067105de417938597289962c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd785b44932274f7067105de417938597289962c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd785b44932274f7067105de417938597289962c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c88d078eba7f51d2e5fc76a630f7eb369c09c87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c88d078eba7f51d2e5fc76a630f7eb369c09c87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c88d078eba7f51d2e5fc76a630f7eb369c09c87"}], "stats": {"total": 476, "additions": 475, "deletions": 1}, "files": [{"sha": "858f5962cf4d2ded526caa959ed664792aebddf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -1,3 +1,27 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* Makefile.in (OBJS): Add function-abi.o.\n+\t(GTFILES): Add function-abi.h.\n+\t* function-abi.cc: New file.\n+\t* function-abi.h: Likewise.\n+\t* emit-rtl.h (rtl_data::abi): New field.\n+\t* function.c: Include function-abi.h.\n+\t(prepare_function_start): Initialize crtl->abi.\n+\t* read-rtl-function.c: Include regs.h and function-abi.h.\n+\t(read_rtl_function_body): Initialize crtl->abi.\n+\t(read_rtl_function_body_from_file_range): Likewise.\n+\t* reginfo.c: Include function-abi.h.\n+\t(init_reg_sets_1): Initialize default_function_abi.\n+\t(globalize_reg): Call add_full_reg_clobber for each predefined ABI\n+\twhen making a register global.\n+\t* target-globals.h (this_target_function_abi_info): Declare.\n+\t(target_globals::function_abi_info): New field.\n+\t(restore_target_globals): Copy it.\n+\t* target-globals.c: Include function-abi.h.\n+\t(default_target_globals): Initialize the function_abi_info field.\n+\t(target_globals): Allocate it.\n+\t(save_target_globals): Free it.\n+\n 2019-09-30  Nick Clifton  <nickc@redhat.com>\n \n \tPR target/85978"}, {"sha": "d796c149ca09b949d6c3349263685a03cac265ea", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -1306,6 +1306,7 @@ OBJS = \\\n \tfold-const.o \\\n \tfold-const-call.o \\\n \tfunction.o \\\n+\tfunction-abi.o \\\n \tfunction-tests.o \\\n \tfwprop.o \\\n \tgcc-rich-location.o \\\n@@ -2523,6 +2524,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n+  $(srcdir)/function-abi.h \\\n   $(srcdir)/output.h $(srcdir)/cfgloop.h $(srcdir)/cfg.h $(srcdir)/profile-count.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\"}, {"sha": "320aab52976ac494e4824dde7699619ebe6d0f77", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n class temp_slot;\n typedef class temp_slot *temp_slot_p;\n+class predefined_function_abi;\n \n /* Information mainlined about RTL representation of incoming arguments.  */\n struct GTY(()) incoming_args {\n@@ -64,6 +65,14 @@ struct GTY(()) rtl_data {\n   struct function_subsections subsections;\n   struct rtl_eh eh;\n \n+  /* The ABI of the function, i.e. the interface it presents to its callers.\n+     This is the ABI that should be queried to see which registers the\n+     function needs to save before it uses them.\n+\n+     Other functions (including those called by this function) might use\n+     different ABIs.  */\n+  const predefined_function_abi *GTY((skip)) abi;\n+\n   /* For function.c  */\n \n   /* # of bytes of outgoing arguments.  If ACCUMULATE_OUTGOING_ARGS is"}, {"sha": "e7c85816a125f1545523ac21f2e171a7e0e172a0", "filename": "gcc/function-abi.cc", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction-abi.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction-abi.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.cc?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -0,0 +1,145 @@\n+/* Information about fuunction binary interfaces.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"regs.h\"\n+#include \"function-abi.h\"\n+#include \"varasm.h\"\n+#include \"cgraph.h\"\n+\n+target_function_abi_info default_target_function_abi_info;\n+#if SWITCHABLE_TARGET\n+target_function_abi_info *this_target_function_abi_info\n+  = &default_target_function_abi_info;\n+#endif\n+\n+/* Initialize a predefined function ABI with the given values of\n+   ID and FULL_REG_CLOBBERS.  */\n+\n+void\n+predefined_function_abi::initialize (unsigned int id,\n+\t\t\t\t     const_hard_reg_set full_reg_clobbers)\n+{\n+  m_id = id;\n+  m_initialized = true;\n+  m_full_reg_clobbers = full_reg_clobbers;\n+\n+  /* Set up the value of m_full_and_partial_reg_clobbers.\n+\n+     If the ABI specifies that part of a hard register R is call-clobbered,\n+     we should be able to find a single-register mode M for which\n+     targetm.hard_regno_call_part_clobbered (NULL, R, M) is true.\n+     In other words, it shouldn't be the case that R can hold all\n+     single-register modes across a call, but can't hold part of\n+     a multi-register mode.\n+\n+     If that assumption doesn't hold for a future target, we would need\n+     to change the interface of TARGET_HARD_REGNO_CALL_PART_CLOBBERED so\n+     that it tells us which registers in a multi-register value are\n+     actually clobbered.  */\n+  m_full_and_partial_reg_clobbers = full_reg_clobbers;\n+  for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    {\n+      machine_mode mode = (machine_mode) i;\n+      for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\tif (targetm.hard_regno_mode_ok (regno, mode)\n+\t    && hard_regno_nregs (regno, mode) == 1\n+\t    && targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t  SET_HARD_REG_BIT (m_full_and_partial_reg_clobbers, regno);\n+    }\n+\n+  /* For each mode MODE, work out which registers are unable to hold\n+     any part of a MODE value across a call, i.e. those for which no\n+     overlapping call-preserved (reg:MODE REGNO) exists.\n+\n+     We assume that this can be flipped around to say that a call\n+     preserves (reg:MODE REGNO) unless the register overlaps this set.\n+     The usual reason for this being true is that if (reg:MODE REGNO)\n+     contains a part-clobbered register, that register would be\n+     part-clobbered regardless of which part of MODE it holds.\n+     For example, if (reg:M 2) occupies two registers and if the\n+     register 3 portion of it is part-clobbered, (reg:M 3) is usually\n+     either invalid or also part-clobbered.  */\n+  for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    {\n+      machine_mode mode = (machine_mode) i;\n+      m_mode_clobbers[i] = m_full_and_partial_reg_clobbers;\n+      for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\tif (targetm.hard_regno_mode_ok (regno, mode)\n+\t    && !overlaps_hard_reg_set_p (m_full_reg_clobbers, mode, regno)\n+\t    && !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t  remove_from_hard_reg_set (&m_mode_clobbers[i], mode, regno);\n+    }\n+\n+  /* Check that the assumptions above actually hold, i.e. that testing\n+     for single-register modes makes sense, and that overlap tests for\n+     mode_clobbers work as expected.  */\n+  if (flag_checking)\n+    for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+      {\n+\tmachine_mode mode = (machine_mode) i;\n+\tconst_hard_reg_set all_clobbers = m_full_and_partial_reg_clobbers;\n+\tfor (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t  if (targetm.hard_regno_mode_ok (regno, mode)\n+\t      && !overlaps_hard_reg_set_p (m_full_reg_clobbers, mode, regno)\n+\t      && targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n+\t    gcc_assert (overlaps_hard_reg_set_p (all_clobbers, mode, regno)\n+\t\t\t&& overlaps_hard_reg_set_p (m_mode_clobbers[i],\n+\t\t\t\t\t\t    mode, regno));\n+      }\n+}\n+\n+/* If the ABI has been initialized, add REGNO to the set of registers\n+   that can be completely altered by a call.  */\n+\n+void\n+predefined_function_abi::add_full_reg_clobber (unsigned int regno)\n+{\n+  if (!m_initialized)\n+    return;\n+\n+  SET_HARD_REG_BIT (m_full_reg_clobbers, regno);\n+  SET_HARD_REG_BIT (m_full_and_partial_reg_clobbers, regno);\n+  for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    SET_HARD_REG_BIT (m_mode_clobbers[i], regno);\n+}\n+\n+/* Return the predefined ABI used by functions with type TYPE.  */\n+\n+const predefined_function_abi &\n+fntype_abi (const_tree type)\n+{\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (type));\n+  return default_function_abi;\n+}\n+\n+/* Return the ABI of function decl FNDECL.  */\n+\n+function_abi\n+fndecl_abi (const_tree fndecl)\n+{\n+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+  return fntype_abi (TREE_TYPE (fndecl));\n+}"}, {"sha": "05e502e1013d31246b5f4b17c76cfda92f4e53c3", "filename": "gcc/function-abi.h", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-abi.h?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -0,0 +1,269 @@\n+/* Information about fuunction binary interfaces.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_FUNCTION_ABI_H\n+#define GCC_FUNCTION_ABI_H\n+\n+/* Most targets use the same ABI for all functions in a translation\n+   unit, but some targets support interoperability between several ABIs.\n+   Each such ABI has a unique 0-based identifier, with 0 always being\n+   the default choice of ABI.\n+\n+   NUM_ABI_IDS is the maximum number of such ABIs that GCC can handle at once.\n+   A bitfield with this number of bits can represent any combinaion of the\n+   supported ABIs.  */\n+const size_t NUM_ABI_IDS = 8;\n+\n+/* Information about one of the target's predefined ABIs.  */\n+class predefined_function_abi\n+{\n+public:\n+  /* A target-specific identifier for this ABI.  The value must be in\n+     the range [0, NUM_ABI_IDS - 1].  */\n+  unsigned int id () const { return m_id; }\n+\n+  /* True if this ABI has been initialized.  */\n+  bool initialized_p () const { return m_initialized; }\n+\n+  /* Return true if a function call is allowed to alter every bit of\n+     register REGNO, so that the register contains an arbitrary value\n+     on return.  If so, the register cannot hold any part of a value\n+     that is live across a call.  */\n+  bool\n+  clobbers_full_reg_p (unsigned int regno) const\n+  {\n+    return TEST_HARD_REG_BIT (m_full_reg_clobbers, regno);\n+  }\n+\n+  /* Return true if a function call is allowed to alter some or all bits\n+     of register REGNO.\n+\n+     This is true whenever clobbers_full_reg_p (REGNO) is true.  It is\n+     also true if, for example, the ABI says that a call must preserve the\n+     low 32 or 64 bits of REGNO, but can clobber the upper bits of REGNO.\n+     In the latter case, it is possible for REGNO to hold values that\n+     are live across a call, provided that the value occupies only the\n+     call-preserved part of the register.  */\n+  bool\n+  clobbers_at_least_part_of_reg_p (unsigned int regno) const\n+  {\n+    return TEST_HARD_REG_BIT (m_full_and_partial_reg_clobbers, regno);\n+  }\n+\n+  /* Return true if a function call is allowed to clobber at least part\n+     of (reg:MODE REGNO).  If so, it is not possible for the register\n+     as a whole to be live across a call.  */\n+  bool\n+  clobbers_reg_p (machine_mode mode, unsigned int regno) const\n+  {\n+    return overlaps_hard_reg_set_p (m_mode_clobbers[mode], mode, regno);\n+  }\n+\n+  /* Return the set of registers that a function call is allowed to\n+     alter completely, so that the registers contain arbitrary values\n+     on return.  This doesn't include registers that a call can only\n+     partly clobber (as per TARGET_HARD_REGNO_CALL_PART_CLOBBERED).\n+\n+     These registers cannot hold any part of a value that is live across\n+     a call.  */\n+  HARD_REG_SET full_reg_clobbers () const { return m_full_reg_clobbers; }\n+\n+  /* Return the set of registers that a function call is allowed to alter\n+     to some degree.  For example, if an ABI says that a call must preserve\n+     the low 32 or 64 bits of a register R, but can clobber the upper bits\n+     of R, R would be in this set but not in full_reg_clobbers ().\n+\n+     This set is a superset of full_reg_clobbers ().  It is possible for a\n+     register in full_and_partial_reg_clobbers () & ~full_reg_clobbers ()\n+     to contain values that are live across a call, provided that the live\n+     value only occupies the call-preserved part of the register.  */\n+  HARD_REG_SET\n+  full_and_partial_reg_clobbers () const\n+  {\n+    return m_full_and_partial_reg_clobbers;\n+  }\n+\n+  /* Return the set of registers that cannot be used to hold a value of\n+     mode MODE across a function call.  That is:\n+\n+       (reg:REGNO MODE)\n+\n+     might be clobbered by a call whenever:\n+\n+       overlaps_hard_reg_set (mode_clobbers (MODE), MODE, REGNO)\n+\n+     In allocation terms, the registers in the returned set conflict\n+     with any value of mode MODE that is live across a call.  */\n+  HARD_REG_SET\n+  mode_clobbers (machine_mode mode) const\n+  {\n+    return m_mode_clobbers[mode];\n+  }\n+\n+  void initialize (unsigned int, const_hard_reg_set);\n+  void add_full_reg_clobber (unsigned int);\n+\n+private:\n+  unsigned int m_id : NUM_ABI_IDS;\n+  unsigned int m_initialized : 1;\n+  HARD_REG_SET m_full_reg_clobbers;\n+  HARD_REG_SET m_full_and_partial_reg_clobbers;\n+  HARD_REG_SET m_mode_clobbers[NUM_MACHINE_MODES];\n+};\n+\n+/* Describes either a predefined ABI or the ABI of a particular function.\n+   In the latter case, the ABI might make use of extra function-specific\n+   information, such as for -fipa-ra.  */\n+class function_abi\n+{\n+public:\n+  /* Initialize the structure for a general function with the given ABI.  */\n+  function_abi (const predefined_function_abi &base_abi)\n+    : m_base_abi (&base_abi),\n+      m_mask (base_abi.full_and_partial_reg_clobbers ()) {}\n+\n+  /* Initialize the structure for a function that has the given ABI and\n+     that is known not to clobber registers outside MASK.  */\n+  function_abi (const predefined_function_abi &base_abi,\n+\t\tconst_hard_reg_set mask)\n+    : m_base_abi (&base_abi), m_mask (mask) {}\n+\n+  /* The predefined ABI from which this ABI is derived.  */\n+  const predefined_function_abi &base_abi () const { return *m_base_abi; }\n+\n+  /* The target-specific identifier of the predefined ABI.  */\n+  unsigned int id () const { return m_base_abi->id (); }\n+\n+  /* See the corresponding predefined_function_abi functions for\n+     details about the following functions.  */\n+\n+  HARD_REG_SET\n+  full_reg_clobbers () const\n+  {\n+    return m_mask & m_base_abi->full_reg_clobbers ();\n+  }\n+\n+  HARD_REG_SET\n+  full_and_partial_reg_clobbers () const\n+  {\n+    return m_mask & m_base_abi->full_and_partial_reg_clobbers ();\n+  }\n+\n+  HARD_REG_SET\n+  mode_clobbers (machine_mode mode) const\n+  {\n+    return m_mask & m_base_abi->mode_clobbers (mode);\n+  }\n+\n+  bool\n+  clobbers_full_reg_p (unsigned int regno) const\n+  {\n+    return (TEST_HARD_REG_BIT (m_mask, regno)\n+\t    & m_base_abi->clobbers_full_reg_p (regno));\n+  }\n+\n+  bool\n+  clobbers_at_least_part_of_reg_p (unsigned int regno) const\n+  {\n+    return (TEST_HARD_REG_BIT (m_mask, regno)\n+\t    & m_base_abi->clobbers_at_least_part_of_reg_p (regno));\n+  }\n+\n+  bool\n+  clobbers_reg_p (machine_mode mode, unsigned int regno) const\n+  {\n+    return overlaps_hard_reg_set_p (mode_clobbers (mode), mode, regno);\n+  }\n+\n+  bool\n+  operator== (const function_abi &other) const\n+  {\n+    return m_base_abi == other.m_base_abi && m_mask == other.m_mask;\n+  }\n+\n+  bool\n+  operator!= (const function_abi &other) const\n+  {\n+    return !operator== (other);\n+  }\n+\n+protected:\n+  const predefined_function_abi *m_base_abi;\n+  HARD_REG_SET m_mask;\n+};\n+\n+struct target_function_abi_info\n+{\n+  /* An array of all the target ABIs that are available in this\n+     translation unit.  Not all entries are used for all targets,\n+     but the structures are relatively small, and using a fixed-size\n+     array avoids extra indirection.\n+\n+     There are various ways of getting an ABI descriptor:\n+\n+     * fndecl_abi (FNDECL) is the ABI of function FNDECL.\n+\n+     * fntype_abi (FNTYPE) is the ABI of a function with type FNTYPE.\n+\n+     * crtl->abi is the ABI of the function that we are currently\n+       compiling to rtl.\n+\n+     * eh_edge_abi is the \"ABI\" used when taking an EH edge from an\n+       exception-throwing statement to an exception handler.  Catching\n+       exceptions from calls can be treated as an abnormal return from\n+       those calls, and this ABI therefore describes the ABI of functions\n+       on such an abnormal return.  Statements that throw non-call\n+       exceptions can be treated as being implicitly wrapped in a call\n+       that has such an abnormal return.\n+\n+       At present, no target needs to support more than one EH ABI.\n+\n+     * function_abis[N] is the ABI with identifier N.  This can be useful\n+       when referring back to ABIs that have been collected by number in\n+       a bitmask, such as after walking function calls in a particular\n+       region of code.\n+\n+     * default_function_abi refers specifically to the target's default\n+       choice of ABI, regardless of which (if any) functions actually\n+       use it.  This ABI and data derived from it do *not* provide\n+       globally conservatively-correct information, so it is only\n+       useful in very specific circumstances.  */\n+  predefined_function_abi x_function_abis[NUM_ABI_IDS];\n+};\n+\n+extern target_function_abi_info default_target_function_abi_info;\n+#if SWITCHABLE_TARGET\n+extern target_function_abi_info *this_target_function_abi_info;\n+#else\n+#define this_target_function_abi_info (&default_target_function_abi_info)\n+#endif\n+\n+/* See the comment above x_function_abis for when these macros should be used.\n+   At present, eh_edge_abi is always the default ABI, but that could change\n+   in future if a target needs it to.  */\n+#define function_abis \\\n+  (this_target_function_abi_info->x_function_abis)\n+#define default_function_abi \\\n+  (this_target_function_abi_info->x_function_abis[0])\n+#define eh_edge_abi default_function_abi\n+\n+extern const predefined_function_abi &fntype_abi (const_tree);\n+extern function_abi fndecl_abi (const_tree);\n+\n+#endif"}, {"sha": "c3aa6a5e9c595f313cf738cc665119290dd8d231", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"gimple.h\"\n #include \"options.h\"\n+#include \"function-abi.h\"\n \n /* So we can assign to cfun in this file.  */\n #undef cfun\n@@ -4826,6 +4827,12 @@ static void\n prepare_function_start (void)\n {\n   gcc_assert (!get_last_insn ());\n+\n+  if (in_dummy_function)\n+    crtl->abi = &default_function_abi;\n+  else\n+    crtl->abi = &fndecl_abi (cfun->decl).base_abi ();\n+\n   init_temp_slots ();\n   init_emit ();\n   init_varasm_status ();"}, {"sha": "b87ea301e8ef53db410af784af74b6fc8a62917e", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -41,6 +41,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"read-rtl-function.h\"\n #include \"selftest.h\"\n #include \"selftest-rtl.h\"\n+#include \"regs.h\"\n+#include \"function-abi.h\"\n \n /* Forward decls.  */\n class function_reader;\n@@ -1611,6 +1613,7 @@ bool\n read_rtl_function_body (const char *path)\n {\n   initialize_rtl ();\n+  crtl->abi = &default_function_abi;\n   init_emit ();\n   init_varasm_status ();\n \n@@ -1644,6 +1647,7 @@ read_rtl_function_body_from_file_range (location_t start_loc,\n     }\n \n   initialize_rtl ();\n+  crtl->abi = &fndecl_abi (cfun->decl).base_abi ();\n   init_emit ();\n   init_varasm_status ();\n "}, {"sha": "a3fbbe67c52a7a6ec791b4afe7db1949ee613152", "filename": "gcc/reginfo.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"reload.h\"\n #include \"output.h\"\n #include \"tree-pass.h\"\n+#include \"function-abi.h\"\n \n /* Maximum register number used in this function, plus one.  */\n \n@@ -419,6 +420,8 @@ init_reg_sets_1 (void)\n \t       }\n \t  }\n      }\n+\n+  default_function_abi.initialize (0, regs_invalidated_by_call);\n }\n \n /* Compute the table of register modes.\n@@ -728,7 +731,11 @@ globalize_reg (tree decl, int i)\n      appropriate regs_invalidated_by_call bit, even if it's already\n      set in fixed_regs.  */\n   if (i != STACK_POINTER_REGNUM)\n-    SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+    {\n+      SET_HARD_REG_BIT (regs_invalidated_by_call, i);\n+      for (unsigned int i = 0; i < NUM_ABI_IDS; ++i)\n+\tfunction_abis[i].add_full_reg_clobber (i);\n+    }\n \n   /* If already fixed, nothing else to do.  */\n   if (fixed_regs[i])"}, {"sha": "359677e68af72a29049516e2d689d701bc34d4af", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcse.h\"\n #include \"bb-reorder.h\"\n #include \"lower-subreg.h\"\n+#include \"function-abi.h\"\n \n #if SWITCHABLE_TARGET\n class target_globals default_target_globals = {\n@@ -48,6 +49,7 @@ class target_globals default_target_globals = {\n   &default_target_rtl,\n   &default_target_recog,\n   &default_target_hard_regs,\n+  &default_target_function_abi_info,\n   &default_target_reload,\n   &default_target_expmed,\n   &default_target_optabs,\n@@ -70,6 +72,7 @@ save_target_globals (void)\n   g->rtl = ggc_cleared_alloc<target_rtl> ();\n   g->recog = XCNEW (struct target_recog);\n   g->hard_regs = XCNEW (struct target_hard_regs);\n+  g->function_abi_info = XCNEW (struct target_function_abi_info);\n   g->reload = XCNEW (struct target_reload);\n   g->expmed = XCNEW (struct target_expmed);\n   g->optabs = XCNEW (struct target_optabs);\n@@ -127,6 +130,7 @@ target_globals::~target_globals ()\n       XDELETE (regs);\n       XDELETE (recog);\n       XDELETE (hard_regs);\n+      XDELETE (function_abi_info);\n       XDELETE (reload);\n       XDELETE (expmed);\n       XDELETE (optabs);"}, {"sha": "9c42913beff80c750195a8d433140ae7ec844549", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd785b44932274f7067105de417938597289962c/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd785b44932274f7067105de417938597289962c/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=bd785b44932274f7067105de417938597289962c", "patch": "@@ -26,6 +26,7 @@ extern struct target_regs *this_target_regs;\n extern struct target_rtl *this_target_rtl;\n extern struct target_recog *this_target_recog;\n extern struct target_hard_regs *this_target_hard_regs;\n+extern struct target_function_abi_info *this_target_function_abi_info;\n extern struct target_reload *this_target_reload;\n extern struct target_expmed *this_target_expmed;\n extern struct target_optabs *this_target_optabs;\n@@ -48,6 +49,7 @@ class GTY(()) target_globals {\n   struct target_rtl *rtl;\n   struct target_recog *GTY((skip)) recog;\n   struct target_hard_regs *GTY((skip)) hard_regs;\n+  struct target_function_abi_info *GTY((skip)) function_abi_info;\n   struct target_reload *GTY((skip)) reload;\n   struct target_expmed *GTY((skip)) expmed;\n   struct target_optabs *GTY((skip)) optabs;\n@@ -75,6 +77,7 @@ restore_target_globals (class target_globals *g)\n   this_target_rtl = g->rtl;\n   this_target_recog = g->recog;\n   this_target_hard_regs = g->hard_regs;\n+  this_target_function_abi_info = g->function_abi_info;\n   this_target_reload = g->reload;\n   this_target_expmed = g->expmed;\n   this_target_optabs = g->optabs;"}]}