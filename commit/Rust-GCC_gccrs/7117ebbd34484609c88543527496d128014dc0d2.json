{"sha": "7117ebbd34484609c88543527496d128014dc0d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExN2ViYmQzNDQ4NDYwOWM4ODU0MzUyNzQ5NmQxMjgwMTRkYzBkMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-09T23:56:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-09T23:56:54Z"}, "message": "compiler: use temporary variable for stack allocation\n    \n    Currently, allocation expression that can be allocated on stack\n    is implemented with __builtin_alloca, which turns into\n    __morestack_allocate_stack_space, which may call C malloc. This\n    may be slow. Also if this happens during certain runtime\n    functions (e.g. write barrier), bad things might happen (when\n    the escape analysis is enabled for the runtime). Make a temporary\n    variable on stack for the allocation instead.\n    \n    Also remove the write barrier in the assignment in building heap\n    expression when it is stack allocated.\n    \n    Reviewed-on: https://go-review.googlesource.com/86242\n\nFrom-SVN: r256412", "tree": {"sha": "2e759dfa0ae434d9a556946c8dabf9047e2fc444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e759dfa0ae434d9a556946c8dabf9047e2fc444"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7117ebbd34484609c88543527496d128014dc0d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7117ebbd34484609c88543527496d128014dc0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7117ebbd34484609c88543527496d128014dc0d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7117ebbd34484609c88543527496d128014dc0d2/comments", "author": null, "committer": null, "parents": [{"sha": "4a59d4472b9a0a4c25c4483a03c71def7cb3aa8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a59d4472b9a0a4c25c4483a03c71def7cb3aa8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a59d4472b9a0a4c25c4483a03c71def7cb3aa8c"}], "stats": {"total": 19, "additions": 15, "deletions": 4}, "files": [{"sha": "0c6538d4e092c7086f01f084cc481333129d87c7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7117ebbd34484609c88543527496d128014dc0d2/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7117ebbd34484609c88543527496d128014dc0d2/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7117ebbd34484609c88543527496d128014dc0d2", "patch": "@@ -1,4 +1,4 @@\n-bea521d1d8688bea5b14b1ae2a03aec949f48a44\n+7ef1b48f63c0a64b83fc049884fb89677e19b2dd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d4a207174db62a441ac62a43e754e8ae222c12e2", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7117ebbd34484609c88543527496d128014dc0d2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7117ebbd34484609c88543527496d128014dc0d2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=7117ebbd34484609c88543527496d128014dc0d2", "patch": "@@ -12387,6 +12387,7 @@ Allocation_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location loc = this->location();\n+  Btype* btype = this->type_->get_backend(gogo);\n \n   if (this->allocate_on_stack_)\n     {\n@@ -12397,10 +12398,20 @@ Allocation_expression::do_get_backend(Translate_context* context)\n           go_assert(saw_errors());\n           return gogo->backend()->error_expression();\n         }\n-      return gogo->backend()->stack_allocation_expression(size, loc);\n+      Bstatement* decl;\n+      Named_object* fn = context->function();\n+      go_assert(fn != NULL);\n+      Bfunction* fndecl = fn->func_value()->get_or_make_decl(gogo, fn);\n+      Bexpression* zero = gogo->backend()->zero_expression(btype);\n+      Bvariable* temp =\n+        gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n+                                            zero, true, loc, &decl);\n+      Bexpression* ret = gogo->backend()->var_expression(temp, loc);\n+      ret = gogo->backend()->address_expression(ret, loc);\n+      ret = gogo->backend()->compound_expression(decl, ret, loc);\n+      return ret;\n     }\n \n-  Btype* btype = this->type_->get_backend(gogo);\n   Bexpression* space =\n     gogo->allocate_memory(this->type_, loc)->get_backend(context);\n   Btype* pbtype = gogo->backend()->pointer_type(btype);\n@@ -14278,7 +14289,7 @@ Heap_expression::do_get_backend(Translate_context* context)\n   // don't do this in the write barrier pass because in some cases\n   // backend conversion can introduce new Heap_expression values.\n   Bstatement* assn;\n-  if (!etype->has_pointer())\n+  if (!etype->has_pointer() || this->allocate_on_stack_)\n     {\n       space = gogo->backend()->var_expression(space_temp, loc);\n       Bexpression* ref ="}]}