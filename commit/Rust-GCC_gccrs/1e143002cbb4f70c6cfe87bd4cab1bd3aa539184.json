{"sha": "1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxNDMwMDJjYmI0ZjcwYzZjZmU4N2JkNGNhYjFiZDNhYTUzOTE4NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-04-07T09:07:24Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-04-07T09:07:24Z"}, "message": "tinfo.cc (convert_to_base): New function.\n\n\t* tinfo.cc (convert_to_base): New function.\n\t(get_vbase_offset): Remove. Move into convert_to_base.\n\t(__vmi_class_type_info::do_find_public_src): Adjust.\n\t(__vmi_class_type_info::do_dyncast): Adjust.\n\t(__vmi_class_type_info::do_upcast): Adjust.\nplus commit changelog entry 2000-04-06  Nathan Sidwell  <nathan@codesourcery.com>\n\nFrom-SVN: r32993", "tree": {"sha": "df1a187aa3e1f8829bd0947a84637a9a7feb2b6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df1a187aa3e1f8829bd0947a84637a9a7feb2b6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184/comments", "author": null, "committer": null, "parents": [{"sha": "62771d518605d12ca322cf35c20ba5164b5b9c5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62771d518605d12ca322cf35c20ba5164b5b9c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62771d518605d12ca322cf35c20ba5164b5b9c5e"}], "stats": {"total": 66, "additions": 41, "deletions": 25}, "files": [{"sha": "1cf52b64b88b6cba7b775f92fa496ba35ee6f0ac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "patch": "@@ -1,3 +1,11 @@\n+2000-04-07  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tinfo.cc (convert_to_base): New function.\n+\t(get_vbase_offset): Remove. Move into convert_to_base.\n+\t(__vmi_class_type_info::do_find_public_src): Adjust.\n+\t(__vmi_class_type_info::do_dyncast): Adjust.\n+\t(__vmi_class_type_info::do_upcast): Adjust.\n+\n 2000-04-06  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tinfo.cc (operator=): Use __builtin_strcmp.\n@@ -28,6 +36,14 @@\n \t* rtti.c (get_tinfo_decl): Adjust call to mark_inline_for_output.\n \t* semantics.c (expand_body): Defer more functions.\n \n+2000-04-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.cc: New file.\n+\t* Make-lang.in (CXX_LIB2FUNCS): Add it.\n+\t(vec.o): Build it.\n+\t* inc/cxxabi.h (__cxa_vec_new, __cxa_vec_ctor, __cxa_vec_dtor,\n+\t__cxa_vec_delete): Declare.\n+\n 2000-04-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* rtti.c (dfs_class_hint_mark): New static function."}, {"sha": "130a7753cb5b3420b12ba431c6388e12eb456e5a", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e143002cbb4f70c6cfe87bd4cab1bd3aa539184/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=1e143002cbb4f70c6cfe87bd4cab1bd3aa539184", "patch": "@@ -590,12 +590,19 @@ adjust_pointer (const void *base, ptrdiff_t offset)\n     (reinterpret_cast <const char *> (base) + offset);\n }\n \n-inline ptrdiff_t\n-get_vbase_offset (const void *object, ptrdiff_t offset)\n+// ADDR is a pointer to an object.  Convert it to a pointer to a base,\n+// using OFFSET. IS_VIRTUAL is true, if we are getting a virtual base.\n+inline void const *\n+convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)\n {\n-  const char *vtable = *reinterpret_cast <const char *const *> (object);\n-  vtable += offset;\n-  return *reinterpret_cast <const ptrdiff_t *> (vtable);\n+  if (is_virtual)\n+    {\n+      const void *vtable = *static_cast <const void *const *> (addr);\n+      \n+      offset = *adjust_pointer<ptrdiff_t> (vtable, offset);\n+    }\n+\n+  return adjust_pointer<void> (addr, offset);\n }\n \n // some predicate functions for __class_type_info::sub_kind\n@@ -721,20 +728,20 @@ do_find_public_src (ptrdiff_t src2dst,\n       \n       const void *base = obj_ptr;\n       ptrdiff_t offset = base_list[i].offset ();\n+      bool is_virtual = base_list[i].is_virtual_p ();\n       \n-      if (base_list[i].is_virtual_p ())\n+      if (is_virtual)\n         {\n           if (src2dst == -3)\n             continue; // Not a virtual base, so can't be here.\n-\t  offset = get_vbase_offset (base, offset);\n         }\n-      base = adjust_pointer <void> (base, offset);\n+      base = convert_to_base (base, is_virtual, offset);\n       \n       sub_kind base_kind = base_list[i].base->do_find_public_src\n                               (src2dst, base, src_type, src_ptr);\n       if (contained_p (base_kind))\n         {\n-          if (base_list[i].is_virtual_p ())\n+          if (is_virtual)\n             base_kind = sub_kind (base_kind | contained_virtual_mask);\n           return base_kind;\n         }\n@@ -843,13 +850,11 @@ do_dyncast (ptrdiff_t src2dst,\n       void const *base = obj_ptr;\n       sub_kind base_access = access_path;\n       ptrdiff_t offset = base_list[i].offset ();\n+      bool is_virtual = base_list[i].is_virtual_p ();\n       \n-      if (base_list[i].is_virtual_p ())\n-        {\n-          base_access = sub_kind (base_access | contained_virtual_mask);\n-\t  offset = get_vbase_offset (base, offset);\n-\t}\n-      base = adjust_pointer <void> (base, offset);\n+      if (is_virtual)\n+        base_access = sub_kind (base_access | contained_virtual_mask);\n+      base = convert_to_base (base, is_virtual, offset);\n \n       if (!base_list[i].is_public_p ())\n         base_access = sub_kind (base_access & ~contained_public_mask);\n@@ -1032,6 +1037,7 @@ do_upcast (sub_kind access_path,\n       const void *base = obj_ptr;\n       sub_kind sub_access = access_path;\n       ptrdiff_t offset = base_list[i].offset ();\n+      bool is_virtual = base_list[i].is_virtual_p ();\n       \n       if (!base_list[i].is_public_p ())\n         {\n@@ -1040,22 +1046,16 @@ do_upcast (sub_kind access_path,\n             continue;\n           sub_access = sub_kind (sub_access & ~contained_public_mask);\n         }\n-      if (base_list[i].is_virtual_p ())\n-        {\n-      \t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n-          \n-          if (base)\n-\t    offset = get_vbase_offset (base, offset);\n-        }\n+      if (is_virtual)\n+    \t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n       if (base)\n-        base = adjust_pointer <void> (base, offset);\n+        base = convert_to_base (base, is_virtual, offset);\n       \n       if (base_list[i].base->do_upcast (sub_access, dst, base, result2))\n         return true; // must fail\n       if (result2.base_type)\n         {\n-          if (result2.base_type == nonvirtual_base_type\n-              && base_list[i].is_virtual_p ())\n+          if (result2.base_type == nonvirtual_base_type && is_virtual)\n             result2.base_type = base_list[i].base;\n           if (!result.base_type)\n             {"}]}