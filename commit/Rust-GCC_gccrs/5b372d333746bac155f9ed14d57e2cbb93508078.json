{"sha": "5b372d333746bac155f9ed14d57e2cbb93508078", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIzNzJkMzMzNzQ2YmFjMTU1ZjllZDE0ZDU3ZTJjYmI5MzUwODA3OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-19T08:30:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-19T08:30:31Z"}, "message": "mips.c (mips_output_32bit_xfer): New function.\n\ngcc/\n\t* config/mips/mips.c (mips_output_32bit_xfer): New function.\n\t(mips_output_64bit_xfer): Likewise.\n\t(mips16_fp_args): Rename to...\n\t(mips_output_args_xfer): ...this and replace the FROM_FP_P argument\n\twith a DIRECTION argument.  Use mips_output_32bit_xfer and\n\tmips_output_64bit_xfer.\n\t(build_mips16_function_stub): Update accordingly.\n\t(mips16_fpret_double): Delete.\n\t(build_mips16_call_stub): Update after above changes.\n\tUse mips_output_32bit_xfer.  Use mips_output_64bit_xfer instead\n\tof mips16_fpret_double.  Use GP_REG_RETURN.\n\nFrom-SVN: r129475", "tree": {"sha": "478bca549edba1314b6736ee0ecc8bfca095d799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/478bca549edba1314b6736ee0ecc8bfca095d799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b372d333746bac155f9ed14d57e2cbb93508078", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b372d333746bac155f9ed14d57e2cbb93508078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b372d333746bac155f9ed14d57e2cbb93508078", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b372d333746bac155f9ed14d57e2cbb93508078/comments", "author": null, "committer": null, "parents": [{"sha": "23fdf75ca50beb236cc0f50120697e3a9278defe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23fdf75ca50beb236cc0f50120697e3a9278defe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23fdf75ca50beb236cc0f50120697e3a9278defe"}], "stats": {"total": 162, "additions": 71, "deletions": 91}, "files": [{"sha": "de27aeed833289de0ab078330fb44ebe78821859", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b372d333746bac155f9ed14d57e2cbb93508078/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b372d333746bac155f9ed14d57e2cbb93508078/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b372d333746bac155f9ed14d57e2cbb93508078", "patch": "@@ -1,3 +1,17 @@\n+2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips_output_32bit_xfer): New function.\n+\t(mips_output_64bit_xfer): Likewise.\n+\t(mips16_fp_args): Rename to...\n+\t(mips_output_args_xfer): ...this and replace the FROM_FP_P argument\n+\twith a DIRECTION argument.  Use mips_output_32bit_xfer and\n+\tmips_output_64bit_xfer.\n+\t(build_mips16_function_stub): Update accordingly.\n+\t(mips16_fpret_double): Delete.\n+\t(build_mips16_call_stub): Update after above changes.\n+\tUse mips_output_32bit_xfer.  Use mips_output_64bit_xfer instead\n+\tof mips16_fpret_double.  Use GP_REG_RETURN.\n+\n 2007-10-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.c (mips16_fp_args): Remove the FILE argument and"}, {"sha": "21abe73b9cabb90c4f862f3badf0f34c113e64b9", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 57, "deletions": 91, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b372d333746bac155f9ed14d57e2cbb93508078/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b372d333746bac155f9ed14d57e2cbb93508078/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5b372d333746bac155f9ed14d57e2cbb93508078", "patch": "@@ -5067,28 +5067,57 @@ mips16_call_stub_mode_suffix (enum machine_mode mode)\n     gcc_unreachable ();\n }\n \n-/* Write out code to move floating point arguments in or out of\n+/* Write instructions to move a 32-bit value between general register\n+   GPREG and floating-point register FPREG.  DIRECTION is 't' to move\n+   from GPREG to FPREG and 'f' to move in the opposite direction.  */\n+\n+static void\n+mips_output_32bit_xfer (char direction, unsigned int gpreg, unsigned int fpreg)\n+{\n+  fprintf (asm_out_file, \"\\tm%cc1\\t%s,%s\\n\", direction,\n+\t   reg_names[gpreg], reg_names[fpreg]);\n+}\n+\n+/* Likewise for 64-bit values.  */\n+\n+static void\n+mips_output_64bit_xfer (char direction, unsigned int gpreg, unsigned int fpreg)\n+{\n+  if (TARGET_64BIT)\n+    fprintf (asm_out_file, \"\\tdm%cc1\\t%s,%s\\n\", direction,\n+ \t     reg_names[gpreg], reg_names[fpreg]);\n+  else if (TARGET_FLOAT64)\n+    {\n+      fprintf (asm_out_file, \"\\tm%cc1\\t%s,%s\\n\", direction,\n+ \t       reg_names[gpreg + TARGET_BIG_ENDIAN], reg_names[fpreg]);\n+      fprintf (asm_out_file, \"\\tm%chc1\\t%s,%s\\n\", direction,\n+ \t       reg_names[gpreg + TARGET_LITTLE_ENDIAN], reg_names[fpreg]);\n+    }\n+  else\n+    {\n+      /* Move the least-significant word.  */\n+      fprintf (asm_out_file, \"\\tm%cc1\\t%s,%s\\n\", direction,\n+\t       reg_names[gpreg + TARGET_BIG_ENDIAN], reg_names[fpreg]);\n+      /* ...then the most significant word.  */\n+      fprintf (asm_out_file, \"\\tm%cc1\\t%s,%s\\n\", direction,\n+\t       reg_names[gpreg + TARGET_LITTLE_ENDIAN], reg_names[fpreg + 1]);\n+    }\n+}\n+\n+/* Write out code to move floating-point arguments into or out of\n    general registers.  FP_CODE is the code describing which arguments\n-   are present (see the comment at the definition of CUMULATIVE_ARGS in\n-   mips.h).  FROM_FP_P is nonzero if we are copying from the floating\n-   point registers.  */\n+   are present (see the comment above the definition of CUMULATIVE_ARGS\n+   in mips.h).  DIRECTION is as for mips_output_32bit_xfer.  */\n \n static void\n-mips16_fp_args (int fp_code, int from_fp_p)\n+mips_output_args_xfer (int fp_code, char direction)\n {\n-  const char *s;\n-  int gparg, fparg;\n-  unsigned int f;\n+  unsigned int gparg, fparg, f;\n   CUMULATIVE_ARGS cum;\n \n   /* This code only works for the original 32-bit ABI and the O64 ABI.  */\n   gcc_assert (TARGET_OLDABI);\n \n-  if (from_fp_p)\n-    s = \"mfc1\";\n-  else\n-    s = \"mtc1\";\n-\n   init_cumulative_args (&cum, NULL, NULL);\n \n   for (f = (unsigned int) fp_code; f != 0; f >>= 2)\n@@ -5108,28 +5137,9 @@ mips16_fp_args (int fp_code, int from_fp_p)\n       fparg = mips_arg_regno (&info, true);\n \n       if (mode == SFmode)\n-\tfprintf (asm_out_file, \"\\t%s\\t%s,%s\\n\", s,\n-\t\t reg_names[gparg], reg_names[fparg]);\n-      else if (TARGET_64BIT)\n-\tfprintf (asm_out_file, \"\\td%s\\t%s,%s\\n\", s,\n-\t\t reg_names[gparg], reg_names[fparg]);\n-      else if (ISA_HAS_MXHC1)\n-\t/* -mips32r2 -mfp64 */\n-\tfprintf (asm_out_file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\",\n-\t\t s,\n-\t\t reg_names[gparg + (WORDS_BIG_ENDIAN ? 1 : 0)],\n-\t\t reg_names[fparg],\n-\t\t from_fp_p ? \"mfhc1\" : \"mthc1\",\n-\t\t reg_names[gparg + (WORDS_BIG_ENDIAN ? 0 : 1)],\n-\t\t reg_names[fparg]);\n-      else if (TARGET_BIG_ENDIAN)\n-\tfprintf (asm_out_file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n-\t\t reg_names[gparg], reg_names[fparg + 1], s,\n-\t\t reg_names[gparg + 1], reg_names[fparg]);\n+\tmips_output_32bit_xfer (direction, gparg, fparg);\n       else\n-\tfprintf (asm_out_file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n-\t\t reg_names[gparg], reg_names[fparg], s,\n-\t\t reg_names[gparg + 1], reg_names[fparg + 1]);\n+\tmips_output_64bit_xfer (direction, gparg, fparg);\n \n       function_arg_advance (&cum, mode, NULL, true);\n     }\n@@ -5193,7 +5203,7 @@ build_mips16_function_stub (void)\n   /* We don't want the assembler to insert any nops here.  */\n   fprintf (asm_out_file, \"\\t.set\\tnoreorder\\n\");\n \n-  mips16_fp_args (current_function_args_info.fp_code, 1);\n+  mips_output_args_xfer (current_function_args_info.fp_code, 'f');\n \n   fprintf (asm_out_file, \"\\t.set\\tnoat\\n\");\n   fprintf (asm_out_file, \"\\tla\\t%s,\", reg_names[GP_REG_FIRST + 1]);\n@@ -5221,47 +5231,6 @@ build_mips16_function_stub (void)\n   switch_to_section (function_section (current_function_decl));\n }\n \n-/* Emit code to return a double value from a mips16 stub.  GPREG is the\n-   first GP reg to use, FPREG is the first FP reg to use.  */\n-\n-static void\n-mips16_fpret_double (int gpreg, int fpreg)\n-{\n-  if (TARGET_64BIT)\n-    fprintf (asm_out_file, \"\\tdmfc1\\t%s,%s\\n\",\n- \t     reg_names[gpreg], reg_names[fpreg]);\n-  else if (TARGET_FLOAT64)\n-    {\n-      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n- \t       reg_names[gpreg + WORDS_BIG_ENDIAN],\n- \t       reg_names[fpreg]);\n-      fprintf (asm_out_file, \"\\tmfhc1\\t%s,%s\\n\",\n- \t       reg_names[gpreg + !WORDS_BIG_ENDIAN],\n- \t       reg_names[fpreg]);\n-    }\n-  else\n-    {\n-      if (TARGET_BIG_ENDIAN)\n- \t{\n- \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n- \t\t   reg_names[gpreg + 0],\n- \t\t   reg_names[fpreg + 1]);\n- \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n- \t\t   reg_names[gpreg + 1],\n- \t\t   reg_names[fpreg + 0]);\n- \t}\n-      else\n- \t{\n-\t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n-\t\t   reg_names[gpreg + 0],\n- \t\t   reg_names[fpreg + 0]);\n- \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n- \t\t   reg_names[gpreg + 1],\n- \t\t   reg_names[fpreg + 1]);\n- \t}\n-    }\n-}\n-\n /* Build a call stub for a mips16 call.  A stub is needed if we are\n    passing any floating point values which should go into the floating\n    point registers.  If we are, and the call turns out to be to a\n@@ -5452,7 +5421,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       /* We don't want the assembler to insert any nops here.  */\n       fprintf (asm_out_file, \"\\t.set\\tnoreorder\\n\");\n \n-      mips16_fp_args (fp_code, 0);\n+      mips_output_args_xfer (fp_code, 't');\n \n       if (! fpret)\n \t{\n@@ -5478,36 +5447,33 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \t  switch (GET_MODE (retval))\n \t    {\n \t    case SCmode:\n- \t      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n- \t\t       reg_names[GP_REG_FIRST + 3],\n-\t\t       reg_names[FP_REG_FIRST + MAX_FPRS_PER_FMT]);\n+\t      mips_output_32bit_xfer ('f', GP_RETURN + 1,\n+\t\t\t\t      FP_REG_FIRST + MAX_FPRS_PER_FMT);\n \t      /* Fall though.  */\n \t    case SFmode:\n-\t      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n-\t\t       reg_names[GP_REG_FIRST + 2],\n-\t\t       reg_names[FP_REG_FIRST + 0]);\n+\t      mips_output_32bit_xfer ('f', GP_RETURN, FP_REG_FIRST);\n \t      if (GET_MODE (retval) == SCmode && TARGET_64BIT)\n \t\t{\n \t\t  /* On 64-bit targets, complex floats are returned in\n \t\t     a single GPR, such that \"sd\" on a suitably-aligned\n \t\t     target would store the value correctly.  */\n \t\t  fprintf (asm_out_file, \"\\tdsll\\t%s,%s,32\\n\",\n-\t\t\t   reg_names[GP_REG_FIRST + 2 + TARGET_LITTLE_ENDIAN],\n-\t\t\t   reg_names[GP_REG_FIRST + 2 + TARGET_LITTLE_ENDIAN]);\n+\t\t\t   reg_names[GP_RETURN + TARGET_LITTLE_ENDIAN],\n+\t\t\t   reg_names[GP_RETURN + TARGET_LITTLE_ENDIAN]);\n \t\t  fprintf (asm_out_file, \"\\tor\\t%s,%s,%s\\n\",\n-\t\t\t   reg_names[GP_REG_FIRST + 2],\n-\t\t\t   reg_names[GP_REG_FIRST + 2],\n-\t\t\t   reg_names[GP_REG_FIRST + 3]);\n+\t\t\t   reg_names[GP_RETURN],\n+\t\t\t   reg_names[GP_RETURN],\n+\t\t\t   reg_names[GP_RETURN + 1]);\n \t\t}\n \t      break;\n \n \t    case DCmode:\n- \t      mips16_fpret_double (GP_REG_FIRST + 2 + (8 / UNITS_PER_WORD),\n-\t\t\t\t   FP_REG_FIRST + MAX_FPRS_PER_FMT);\n+\t      mips_output_64bit_xfer ('f', GP_RETURN + (8 / UNITS_PER_WORD),\n+\t\t\t\t      FP_REG_FIRST + MAX_FPRS_PER_FMT);\n \t      /* Fall though.  */\n  \t    case DFmode:\n \t    case V2SFmode:\n- \t      mips16_fpret_double (GP_REG_FIRST + 2, FP_REG_FIRST + 0);\n+\t      mips_output_64bit_xfer ('f', GP_RETURN, FP_REG_FIRST);\n \t      break;\n \n \t    default:"}]}