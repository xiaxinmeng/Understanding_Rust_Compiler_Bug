{"sha": "62984918665f0c82b187293ba762bc2edb32ab92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI5ODQ5MTg2NjVmMGM4MmIxODcyOTNiYTc2MmJjMmVkYjMyYWI5Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-06-12T20:47:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-06-12T20:47:21Z"}, "message": "Support -Wabi warning about backward compatibility.\n\ngcc/c-family/\n\t* c.opt (Wabi=, fabi-compat-version): New.\n\t* c-opts.c (c_common_handle_option): Handle -Wabi=.\n\t(c_common_post_options): Handle flag_abi_compat_version default.\n\tDisallow -fabi-compat-version=1.\n\t* c-common.h (abi_version_crosses): New.\ngcc/cp/\n\t* call.c (convert_arg_to_ellipsis): Use abi_version_crosses.\n\t* cvt.c (type_promotes_to): Likewise.\n\t* mangle.c (write_type, write_expression): Likewise.\n\t(write_name, write_template_arg): Likewise.\n\t(mangle_decl): Make alias based on flag_abi_compat_version.\n\tEmit -Wabi warning here.\n\t(finish_mangling_internal): Not here.  Drop warn parm.\n\t(finish_mangling_get_identifier, finish_mangling): Adjust.\n\t(mangle_type_string, mangle_special_for_type): Adjust.\n\t(mangle_ctor_vtbl_for_type, mangle_thunk): Adjust.\n\t(mangle_guard_variable, mangle_tls_init_fn): Adjust.\n\t(mangle_tls_wrapper_fn, mangle_ref_init_variable): Adjust.\n\nFrom-SVN: r211594", "tree": {"sha": "c0d0389e8a30820854148e9a086d0b15f452ac9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d0389e8a30820854148e9a086d0b15f452ac9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62984918665f0c82b187293ba762bc2edb32ab92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62984918665f0c82b187293ba762bc2edb32ab92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62984918665f0c82b187293ba762bc2edb32ab92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62984918665f0c82b187293ba762bc2edb32ab92/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca0e51a0e5983a68e47b5195b99a8805938ecc26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca0e51a0e5983a68e47b5195b99a8805938ecc26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca0e51a0e5983a68e47b5195b99a8805938ecc26"}], "stats": {"total": 460, "additions": 326, "deletions": 134}, "files": [{"sha": "dd91f6b51c1a624f97d37e46df2abbcd3cc53891", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,3 +1,11 @@\n+2014-06-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt (Wabi=, fabi-compat-version): New.\n+\t* c-opts.c (c_common_handle_option): Handle -Wabi=.\n+\t(c_common_post_options): Handle flag_abi_compat_version default.\n+\tDisallow -fabi-compat-version=1.\n+\t* c-common.h (abi_version_crosses): New.\n+\n 2014-06-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* c-family/c-common.c (handle_section_attribute): Update handling for"}, {"sha": "6bf4051622dceb67e51cfd92599771cc0eb4a51f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -619,6 +619,13 @@ extern const char *constant_string_class_name;\n /* C++ language option variables.  */\n \n \n+/* Return TRUE if one of {flag_abi_version,flag_abi_compat_version} is\n+   less than N and the other is at least N, for use by -Wabi.  */\n+#define abi_version_crosses(N)\t\t\t\\\n+  (abi_version_at_least(N)\t\t\t\\\n+   != (flag_abi_compat_version == 0\t\t\\\n+       || flag_abi_compat_version >= (N)))\n+\n /* Nonzero means generate separate instantiation control files and\n    juggle them at link time.  */\n "}, {"sha": "fbbc80ee94ab76dcaddce95a793e356fe955aeee", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -456,6 +456,16 @@ c_common_handle_option (size_t scode, const char *arg, int value,\n       handle_OPT_d (arg);\n       break;\n \n+    case OPT_Wabi_:\n+      warn_abi = true;\n+      if (value == 1)\n+\t{\n+\t  warning (0, \"%<-Wabi=1%> is not supported, using =2\");\n+\t  value = 2;\n+\t}\n+      flag_abi_compat_version = value;\n+      break;\n+\n     case OPT_fcanonical_system_headers:\n       cpp_opts->canonical_system_headers = value;\n       break;\n@@ -910,6 +920,22 @@ c_common_post_options (const char **pfilename)\n   if (flag_declone_ctor_dtor == -1)\n     flag_declone_ctor_dtor = optimize_size;\n \n+  if (flag_abi_compat_version == 1)\n+    {\n+      warning (0, \"%<-fabi-compat-version=1%> is not supported, using =2\");\n+      flag_abi_compat_version = 2;\n+    }\n+  else if (flag_abi_compat_version == -1)\n+    {\n+      /* Generate compatibility aliases for ABI v2 (3.4-4.9) by default. */\n+      flag_abi_compat_version = (flag_abi_version == 0 ? 2 : 0);\n+\n+      /* But don't warn about backward compatibility unless explicitly\n+\t requested with -Wabi=n.  */\n+      if (flag_abi_version == 0)\n+\twarn_abi = false;\n+    }\n+\n   if (cxx_dialect >= cxx11)\n     {\n       /* If we're allowing C++0x constructs, don't warn about C++98"}, {"sha": "d2e047fc877ff560fdaf29f8d416a2fa9a5fd42c", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -256,6 +256,10 @@ Wabi\n C ObjC C++ ObjC++ LTO Var(warn_abi) Warning\n Warn about things that will change when compiling with an ABI-compliant compiler\n \n+Wabi=\n+C ObjC C++ ObjC++ LTO Joined RejectNegative UInteger Warning\n+Warn about things that change between the current -fabi-version and the specified version\n+\n Wabi-tag\n C++ ObjC++ Var(warn_abi_tag) Warning\n Warn if a subobject has an abi_tag attribute that the complete object type does not have\n@@ -845,6 +849,10 @@ d\n C ObjC C++ ObjC++ Joined\n ; Documented in common.opt.  FIXME - what about -dI, -dD, -dN and -dD?\n \n+fabi-compat-version=\n+C++ ObjC++ Joined RejectNegative UInteger Var(flag_abi_compat_version) Init(-1)\n+The version of the C++ ABI used for -Wabi warnings and link compatibility aliases\n+\n faccess-control\n C++ ObjC++ Var(flag_access_control) Init(1)\n Enforce class member access control semantics"}, {"sha": "5fac4a52dab1b4c7621f72d41a4de878afcd7cfd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,5 +1,18 @@\n 2014-06-12  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (convert_arg_to_ellipsis): Use abi_version_crosses.\n+\t* cvt.c (type_promotes_to): Likewise.\n+\t* mangle.c (write_type, write_expression): Likewise.\n+\t(write_name, write_template_arg): Likewise.\n+\t(mangle_decl): Make alias based on flag_abi_compat_version.\n+\tEmit -Wabi warning here.\n+\t(finish_mangling_internal): Not here.  Drop warn parm.\n+\t(finish_mangling_get_identifier, finish_mangling): Adjust.\n+\t(mangle_type_string, mangle_special_for_type): Adjust.\n+\t(mangle_ctor_vtbl_for_type, mangle_thunk): Adjust.\n+\t(mangle_guard_variable, mangle_tls_init_fn): Adjust.\n+\t(mangle_tls_wrapper_fn, mangle_ref_init_variable): Adjust.\n+\n \t* call.c (build_operator_new_call): Remove -fabi-version=1 support.\n \t* class.c (walk_subobject_offsets, include_empty_classes): Likewise.\n \t(layout_nonempty_base_or_field, end_of_class): Likewise."}, {"sha": "44e92fcd437f5fcc19af3cc63455161a9cb9bc54", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -6508,14 +6508,22 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n     arg = null_pointer_node;\n   else if (INTEGRAL_OR_ENUMERATION_TYPE_P (arg_type))\n     {\n-      if (SCOPED_ENUM_P (arg_type) && !abi_version_at_least (6))\n+      if (SCOPED_ENUM_P (arg_type))\n \t{\n-\t  if (complain & tf_warning)\n-\t    warning_at (loc, OPT_Wabi, \"scoped enum %qT will not promote to an \"\n-\t\t\t\"integral type in a future version of GCC\", arg_type);\n-\t  arg = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg, complain);\n+\t  tree prom = cp_convert (ENUM_UNDERLYING_TYPE (arg_type), arg,\n+\t\t\t\t  complain);\n+\t  prom = cp_perform_integral_promotions (prom, complain);\n+\t  if (abi_version_crosses (6)\n+\t      && TYPE_MODE (TREE_TYPE (prom)) != TYPE_MODE (arg_type)\n+\t      && (complain & tf_warning))\n+\t    warning_at (loc, OPT_Wabi, \"scoped enum %qT passed through ... as \"\n+\t\t\t\"%qT before -fabi-version=6, %qT after\", arg_type,\n+\t\t\tTREE_TYPE (prom), ENUM_UNDERLYING_TYPE (arg_type));\n+\t  if (!abi_version_at_least (6))\n+\t    arg = prom;\n \t}\n-      arg = cp_perform_integral_promotions (arg, complain);\n+      else\n+\targ = cp_perform_integral_promotions (arg, complain);\n     }\n \n   arg = require_complete_type_sfinae (arg, complain);"}, {"sha": "1dec9cc7f0e64db70938defe56a34f9e1849e92e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1701,13 +1701,9 @@ type_promotes_to (tree type)\n   if (TREE_CODE (type) == BOOLEAN_TYPE)\n     type = integer_type_node;\n \n-  /* Scoped enums don't promote, but pretend they do for backward ABI bug\n-     compatibility wrt varargs.  */\n-  else if (SCOPED_ENUM_P (type) && abi_version_at_least (6))\n-    ;\n-\n   /* Normally convert enums to int, but convert wide enums to something\n-     wider.  */\n+     wider.  Scoped enums don't promote, but pretend they do for backward\n+     ABI bug compatibility wrt varargs.  */\n   else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t   || type == char16_type_node\n \t   || type == char32_type_node\n@@ -1716,16 +1712,26 @@ type_promotes_to (tree type)\n       int precision = MAX (TYPE_PRECISION (type),\n \t\t\t   TYPE_PRECISION (integer_type_node));\n       tree totype = c_common_type_for_size (precision, 0);\n+      tree prom = type;\n+      if (TREE_CODE (prom) == ENUMERAL_TYPE)\n+\tprom = ENUM_UNDERLYING_TYPE (prom);\n+      if (TYPE_UNSIGNED (prom)\n+\t  && ! int_fits_type_p (TYPE_MAX_VALUE (prom), totype))\n+\tprom = c_common_type_for_size (precision, 1);\n+      else\n+\tprom = totype;\n       if (SCOPED_ENUM_P (type))\n-\twarning (OPT_Wabi, \"scoped enum %qT will not promote to an integral \"\n-\t\t \"type in a future version of GCC\", type);\n-      if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\ttype = ENUM_UNDERLYING_TYPE (type);\n-      if (TYPE_UNSIGNED (type)\n-\t  && ! int_fits_type_p (TYPE_MAX_VALUE (type), totype))\n-\ttype = c_common_type_for_size (precision, 1);\n+\t{\n+\t  if (abi_version_crosses (6)\n+\t      && TYPE_MODE (prom) != TYPE_MODE (type))\n+\t    warning (OPT_Wabi, \"scoped enum %qT passed through ... as \"\n+\t\t     \"%qT before -fabi-version=6, %qT after\",\n+\t\t     type, prom, ENUM_UNDERLYING_TYPE (type));\n+\t  if (!abi_version_at_least (6))\n+\t    type = prom;\n+\t}\n       else\n-\ttype = totype;\n+\ttype = prom;\n     }\n   else if (c_promoting_integer_type_p (type))\n     {"}, {"sha": "ac1c1da9730a3982b8796f3ed7715e983242eb0e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 85, "deletions": 55, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -225,7 +225,6 @@ static int local_class_index (tree);\n /* Control functions.  */\n \n static inline void start_mangling (const tree);\n-static inline const char *finish_mangling (const bool);\n static tree mangle_special_for_type (const tree, const char *);\n \n /* Foreign language functions.  */\n@@ -786,6 +785,11 @@ write_name (tree decl, const int ignore_local_scope)\n \n   gcc_assert (context != NULL_TREE);\n \n+  if (abi_version_crosses (7)\n+      && ignore_local_scope\n+      && TREE_CODE (context) == PARM_DECL)\n+    G.need_abi_warning = 1;\n+\n   /* A decl in :: or ::std scope is treated specially.  The former is\n      mangled using <unscoped-name> or <unscoped-template-name>, the\n      latter with a special substitution.  Also, a name that is\n@@ -1865,6 +1869,8 @@ write_type (tree type)\n \t    write_function_type (t);\n \t  else\n \t    write_type (t);\n+\t  if (abi_version_crosses (8))\n+\t    G.need_abi_warning = 1;\n \t}\n       else\n \twrite_type (t);\n@@ -1970,9 +1976,14 @@ write_type (tree type)\n \t\t   a typedef or template argument can have function type\n \t\t   with function-cv-quals (that use the same representation),\n \t\t   but you can't have a pointer/reference to such a type.  */\n-\t\tif (abi_version_at_least (5)\n-\t\t    && TREE_CODE (target) == FUNCTION_TYPE)\n-\t\t  target = build_qualified_type (target, TYPE_UNQUALIFIED);\n+\t\tif (TREE_CODE (target) == FUNCTION_TYPE)\n+\t\t  {\n+\t\t    if (abi_version_crosses (5)\n+\t\t\t&& TYPE_QUALS (target) != TYPE_UNQUALIFIED)\n+\t\t      G.need_abi_warning = 1;\n+\t\t    if (abi_version_at_least (5))\n+\t\t      target = build_qualified_type (target, TYPE_UNQUALIFIED);\n+\t\t  }\n \t\twrite_type (target);\n \t      }\n \t      break;\n@@ -2012,10 +2023,9 @@ write_type (tree type)\n \t\t  write_char ('_');\n \t\t}\n \t      else\n-\t\t{\n-\t\t  G.need_abi_warning = 1;\n-\t\t  write_string (\"U8__vector\");\n-\t\t}\n+\t\twrite_string (\"U8__vector\");\n+\t      if (abi_version_crosses (4))\n+\t\tG.need_abi_warning = 1;\n \t      write_type (TREE_TYPE (type));\n \t      break;\n \n@@ -2030,8 +2040,7 @@ write_type (tree type)\n \t\t\t  && !DECLTYPE_FOR_LAMBDA_PROXY (type));\n \n \t      /* In ABI <5, we stripped decltype of a plain decl.  */\n-\t      if (!abi_version_at_least (5)\n-\t\t  && DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type))\n+\t      if (DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (type))\n \t\t{\n \t\t  tree expr = DECLTYPE_TYPE_EXPR (type);\n \t\t  tree etype = NULL_TREE;\n@@ -2052,9 +2061,13 @@ write_type (tree type)\n \n \t\t  if (etype && !type_uses_auto (etype))\n \t\t    {\n-\t\t      G.need_abi_warning = 1;\n-\t\t      write_type (etype);\n-\t\t      return;\n+\t\t      if (abi_version_crosses (5))\n+\t\t\tG.need_abi_warning = 1;\n+\t\t      if (!abi_version_at_least (5))\n+\t\t\t{\n+\t\t\t  write_type (etype);\n+\t\t\t  return;\n+\t\t\t}\n \t\t    }\n \t\t}\n \n@@ -2073,6 +2086,8 @@ write_type (tree type)\n \t      write_string (\"Dn\");\n \t      if (abi_version_at_least (7))\n \t\t++is_builtin_type;\n+\t      if (abi_version_crosses (7))\n+\t\tG.need_abi_warning = 1;\n \t      break;\n \n \t    case TYPEOF_TYPE:\n@@ -2621,7 +2636,7 @@ write_expression (tree expr)\n \t      write_char ('L');\n \t      write_unsigned_number (delta - 1);\n \t    }\n-\t  else\n+\t  if (abi_version_crosses (5))\n \t    G.need_abi_warning = true;\n \t}\n       write_char ('p');\n@@ -2853,12 +2868,13 @@ write_expression (tree expr)\n       name = operator_name_info[(int) code].mangled_name;\n \n       /* We used to mangle const_cast and static_cast like a C cast.  */\n-      if (!abi_version_at_least (6)\n-\t  && (code == CONST_CAST_EXPR\n-\t      || code == STATIC_CAST_EXPR))\n+      if (code == CONST_CAST_EXPR\n+\t  || code == STATIC_CAST_EXPR)\n \t{\n-\t  name = operator_name_info[CAST_EXPR].mangled_name;\n-\t  G.need_abi_warning = 1;\n+\t  if (abi_version_crosses (6))\n+\t    G.need_abi_warning = 1;\n+\t  if (!abi_version_at_least (6))\n+\t    name = operator_name_info[CAST_EXPR].mangled_name;\n \t}\n \n       if (name == NULL)\n@@ -2929,7 +2945,7 @@ write_expression (tree expr)\n \tcase PREDECREMENT_EXPR:\n \t  if (abi_version_at_least (6))\n \t    write_char ('_');\n-\t  else\n+\t  if (abi_version_crosses (6))\n \t    G.need_abi_warning = 1;\n \t  /* Fall through.  */\n \n@@ -3064,7 +3080,7 @@ write_template_arg (tree node)\n     {\n       if (abi_version_at_least (6))\n \tnode = BASELINK_FUNCTIONS (node);\n-      else\n+      if (abi_version_crosses (6))\n \t/* We wrongly wrapped a class-scope function in X/E.  */\n \tG.need_abi_warning = 1;\n     }\n@@ -3077,10 +3093,9 @@ write_template_arg (tree node)\n       if (abi_version_at_least (6))\n \twrite_char ('J');\n       else\n-\t{\n-\t  write_char ('I');\n-\t  G.need_abi_warning = 1;\n-\t}\n+\twrite_char ('I');\n+      if (abi_version_crosses (6))\n+\tG.need_abi_warning = 1;\n       for (i = 0; i < length; ++i)\n         write_template_arg (TREE_VEC_ELT (args, i));\n       write_char ('E');\n@@ -3100,12 +3115,11 @@ write_template_arg (tree node)\n       /* Until ABI version 3, the underscore before the mangled name\n \t was incorrectly omitted.  */\n       if (!abi_version_at_least (3))\n-\t{\n-\t  G.need_abi_warning = 1;\n-\t  write_char ('Z');\n-\t}\n+\twrite_char ('Z');\n       else\n \twrite_string (\"_Z\");\n+      if (abi_version_crosses (3))\n+\tG.need_abi_warning = 1;\n       write_encoding (node);\n       write_char ('E');\n     }\n@@ -3286,13 +3300,8 @@ start_mangling (const tree entity)\n    warning.  */\n \n static void\n-finish_mangling_internal (const bool warn)\n+finish_mangling_internal (void)\n {\n-  if (warn_abi && warn && G.need_abi_warning)\n-    warning (OPT_Wabi, \"the mangled name of %qD will change in a future \"\n-\t     \"version of GCC\",\n-\t     G.entity);\n-\n   /* Clear all the substitutions.  */\n   vec_safe_truncate (G.substitutions, 0);\n \n@@ -3304,18 +3313,18 @@ finish_mangling_internal (const bool warn)\n /* Like finish_mangling_internal, but return the mangled string.  */\n \n static inline const char *\n-finish_mangling (const bool warn)\n+finish_mangling (void)\n {\n-  finish_mangling_internal (warn);\n+  finish_mangling_internal ();\n   return (const char *) obstack_finish (mangle_obstack);\n }\n \n /* Like finish_mangling_internal, but return an identifier.  */\n \n static tree\n-finish_mangling_get_identifier (const bool warn)\n+finish_mangling_get_identifier (void)\n {\n-  finish_mangling_internal (warn);\n+  finish_mangling_internal ();\n   /* Don't obstack_finish here, and the next start_mangling will\n      remove the identifier.  */\n   return get_identifier ((const char *) obstack_base (mangle_obstack));\n@@ -3373,7 +3382,7 @@ mangle_decl_string (const tree decl)\n   else\n     write_mangled_name (decl, true);\n \n-  result = finish_mangling_get_identifier (/*warn=*/true);\n+  result = finish_mangling_get_identifier ();\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_decl_string = '%s'\\n\\n\",\n \t     IDENTIFIER_POINTER (result));\n@@ -3425,26 +3434,47 @@ mangle_decl (const tree decl)\n       && !DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)\n       && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n     {\n-#ifdef ASM_OUTPUT_DEF\n       /* If the mangling will change in the future, emit an alias with the\n \t future mangled name for forward-compatibility.  */\n       int save_ver;\n-      tree id2, alias;\n-#endif\n+      tree id2;\n \n       SET_IDENTIFIER_GLOBAL_VALUE (id, decl);\n       if (IDENTIFIER_GLOBAL_VALUE (id) != decl)\n-\tinform (DECL_SOURCE_LOCATION (decl), \"-fabi-version=6 (or =0) \"\n+\tinform (DECL_SOURCE_LOCATION (decl), \"a later -fabi-version= (or =0) \"\n \t\t\"avoids this error with a change in mangling\");\n \n-#ifdef ASM_OUTPUT_DEF\n       save_ver = flag_abi_version;\n-      flag_abi_version = 0;\n+      flag_abi_version = flag_abi_compat_version;\n       id2 = mangle_decl_string (decl);\n       id2 = targetm.mangle_decl_assembler_name (decl, id2);\n       flag_abi_version = save_ver;\n \n-      alias = make_alias_for (decl, id2);\n+      if (id2 == id)\n+\treturn;\n+\n+      if (warn_abi)\n+\t{\n+\t  if (flag_abi_compat_version != 0\n+\t      && abi_version_at_least (flag_abi_compat_version))\n+\t    warning (OPT_Wabi, \"the mangled name of %q+D changed between \"\n+\t\t     \"-fabi-version=%d (%D) and -fabi-version=%d (%D)\",\n+\t\t     G.entity, flag_abi_compat_version, id2,\n+\t\t     flag_abi_version, id);\n+\t  else\n+\t    warning (OPT_Wabi, \"the mangled name of %q+D changes between \"\n+\t\t     \"-fabi-version=%d (%D) and -fabi-version=%d (%D)\",\n+\t\t     G.entity, flag_abi_version, id,\n+\t\t     flag_abi_compat_version, id2);\n+\t}\n+\n+#ifdef ASM_OUTPUT_DEF\n+      if (flag_abi_compat_version != 0\n+\t  && IDENTIFIER_GLOBAL_VALUE (id2))\n+\treturn;\n+\n+      tree alias = make_alias_for (decl, id2);\n+      SET_IDENTIFIER_GLOBAL_VALUE (id2, alias);\n       DECL_IGNORED_P (alias) = 1;\n       TREE_PUBLIC (alias) = TREE_PUBLIC (decl);\n       DECL_VISIBILITY (alias) = DECL_VISIBILITY (decl);\n@@ -3471,7 +3501,7 @@ mangle_type_string (const tree type)\n \n   start_mangling (type);\n   write_type (type);\n-  result = finish_mangling (/*warn=*/false);\n+  result = finish_mangling ();\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_type_string = '%s'\\n\\n\", result);\n   return result;\n@@ -3496,7 +3526,7 @@ mangle_special_for_type (const tree type, const char *code)\n \n   /* Add the type.  */\n   write_type (type);\n-  result = finish_mangling_get_identifier (/*warn=*/false);\n+  result = finish_mangling_get_identifier ();\n \n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_special_for_type = %s\\n\\n\",\n@@ -3567,7 +3597,7 @@ mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n   write_char ('_');\n   write_type (BINFO_TYPE (binfo));\n \n-  result = finish_mangling_get_identifier (/*warn=*/false);\n+  result = finish_mangling_get_identifier ();\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_ctor_vtbl_for_type = %s\\n\\n\",\n \t     IDENTIFIER_POINTER (result));\n@@ -3646,7 +3676,7 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n   /* Scoped name.  */\n   write_encoding (fn_decl);\n \n-  result = finish_mangling_get_identifier (/*warn=*/false);\n+  result = finish_mangling_get_identifier ();\n   if (DEBUG_MANGLE)\n     fprintf (stderr, \"mangle_thunk = %s\\n\\n\", IDENTIFIER_POINTER (result));\n   return result;\n@@ -3739,7 +3769,7 @@ mangle_guard_variable (const tree variable)\n   start_mangling (variable);\n   write_string (\"_ZGV\");\n   write_guarded_var_name (variable);\n-  return finish_mangling_get_identifier (/*warn=*/false);\n+  return finish_mangling_get_identifier ();\n }\n \n /* Return an identifier for the name of a thread_local initialization\n@@ -3751,7 +3781,7 @@ mangle_tls_init_fn (const tree variable)\n   start_mangling (variable);\n   write_string (\"_ZTH\");\n   write_guarded_var_name (variable);\n-  return finish_mangling_get_identifier (/*warn=*/false);\n+  return finish_mangling_get_identifier ();\n }\n \n /* Return an identifier for the name of a thread_local wrapper\n@@ -3765,7 +3795,7 @@ mangle_tls_wrapper_fn (const tree variable)\n   start_mangling (variable);\n   write_string (TLS_WRAPPER_PREFIX);\n   write_guarded_var_name (variable);\n-  return finish_mangling_get_identifier (/*warn=*/false);\n+  return finish_mangling_get_identifier ();\n }\n \n /* Return true iff FN is a thread_local wrapper function.  */\n@@ -3795,7 +3825,7 @@ mangle_ref_init_variable (const tree variable)\n   /* Avoid name clashes with aggregate initialization of multiple\n      references at once.  */\n   write_unsigned_number (temp_count++);\n-  return finish_mangling_get_identifier (/*warn=*/false);\n+  return finish_mangling_get_identifier ();\n }\n \f\n "}, {"sha": "3c02341a3a7fe7f5c199eb4755ddc949c88820c7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 75, "deletions": 10, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -195,7 +195,7 @@ in the following sections.\n -fvtv-counts -fvtv-debug @gol\n -fvisibility-ms-compat @gol\n -fext-numeric-literals @gol\n--Wabi  -Wconversion-null  -Wctor-dtor-privacy @gol\n+-Wabi=@var{n}  -Wconversion-null  -Wctor-dtor-privacy @gol\n -Wdelete-non-virtual-dtor -Wliteral-suffix -Wnarrowing @gol\n -Wnoexcept -Wnon-virtual-dtor  -Wreorder @gol\n -Weffc++  -Wstrict-null-sentinel @gol\n@@ -2023,15 +2023,16 @@ Here is a list of options that are @emph{only} for compiling C++ programs:\n \n @item -fabi-version=@var{n}\n @opindex fabi-version\n-Use version @var{n} of the C++ ABI@.  The default is version 2.\n+Use version @var{n} of the C++ ABI@.  The default is version 0.\n \n Version 0 refers to the version conforming most closely to\n the C++ ABI specification.  Therefore, the ABI obtained using version 0\n will change in different versions of G++ as ABI bugs are fixed.\n \n Version 1 is the version of the C++ ABI that first appeared in G++ 3.2.  \n \n-Version 2 is the version of the C++ ABI that first appeared in G++ 3.4.  \n+Version 2 is the version of the C++ ABI that first appeared in G++\n+3.4, and was the default through G++ 4.9.\n \n Version 3 corrects an error in mangling a constant address as a\n template argument.\n@@ -2049,8 +2050,27 @@ behavior of C++11 scoped enums and the mangling of template argument\n packs, const/static_cast, prefix ++ and --, and a class scope function\n used as a template argument.\n \n+Version 7, which first appeared in G++ 4.8, that treats nullptr_t as a\n+builtin type and corrects the mangling of lambdas in default argument\n+scope.\n+\n+Version 8, which first appeared in G++ 4.9, corrects the substitution\n+behavior of function types with function-cv-qualifiers.\n+\n See also @option{-Wabi}.\n \n+@item -fabi-compat-version=@var{n}\n+@opindex fabi-compat-version\n+Starting with GCC 4.5, on targets that support strong aliases, G++\n+works around mangling changes by creating an alias with the correct\n+mangled name when defining a symbol with an incorrect mangled name.\n+This switch specifies which ABI version to use for the alias.\n+\n+With @option{-fabi-version=0} (the default), this defaults to 2.  If\n+another ABI version is explicitly selected, this defaults to 0.\n+\n+The compatibility version is also set by @option{-Wabi=@var{n}}.\n+\n @item -fno-access-control\n @opindex fno-access-control\n Turn off all access checking.  This switch is mainly useful for working\n@@ -2445,8 +2465,15 @@ have meanings only for C++ programs:\n @item -Wabi @r{(C, Objective-C, C++ and Objective-C++ only)}\n @opindex Wabi\n @opindex Wno-abi\n-Warn when G++ generates code that is probably not compatible with the\n-vendor-neutral C++ ABI@.  Although an effort has been made to warn about\n+When an explicit @option{-fabi-version=@var{n}} option is used, causes\n+G++ to warn when it generates code that is probably not compatible with the\n+vendor-neutral C++ ABI@.  Since G++ now defaults to\n+@option{-fabi-version=0}, @option{-Wabi} has no effect unless either\n+an older ABI version is selected (with @option{-fabi-version=@var{n}})\n+or an older compatibility version is selected (with\n+@option{-Wabi=@var{n}} or @option{-fabi-compat-version=@var{n}}).\n+\n+Although an effort has been made to warn about\n all such cases, there are probably some cases that are not warned about,\n even though G++ is generating incompatible code.  There may also be\n cases where warnings are emitted even though the code that is generated\n@@ -2456,27 +2483,65 @@ You should rewrite your code to avoid these warnings if you are\n concerned about the fact that code generated by G++ may not be binary\n compatible with code generated by other compilers.\n \n-The known incompatibilities in @option{-fabi-version=2} (the default) include:\n+@option{-Wabi} can also be used with an explicit version number to\n+warn about compatibility with a particular @option{-fabi-version}\n+level, e.g. @option{-Wabi=2} to warn about changes relative to\n+@option{-fabi-version=2}.  Specifying a version number also sets\n+@option{-fabi-compat-version=@var{n}}.\n+\n+The known incompatibilities in @option{-fabi-version=2} (which was the\n+default from GCC 3.4 to 4.9) include:\n \n @itemize @bullet\n \n @item\n-A template with a non-type template parameter of reference type is\n+A template with a non-type template parameter of reference type was\n mangled incorrectly:\n @smallexample\n extern int N;\n template <int &> struct S @{@};\n void n (S<N>) @{2@}\n @end smallexample\n \n-This is fixed in @option{-fabi-version=3}.\n+This was fixed in @option{-fabi-version=3}.\n \n @item\n-SIMD vector types declared using @code{__attribute ((vector_size))} are\n+SIMD vector types declared using @code{__attribute ((vector_size))} were\n mangled in a non-standard way that does not allow for overloading of\n functions taking vectors of different sizes.\n \n-The mangling is changed in @option{-fabi-version=4}.\n+The mangling was changed in @option{-fabi-version=4}.\n+\n+@item\n+@code{__attribute ((const))} and @code{noreturn} were mangled as type\n+qualifiers, and @code{decltype} of a plain declaration was folded away.\n+\n+These mangling issues were fixed in @option{-fabi-version=5}.\n+\n+@item\n+Scoped enumerators passed as arguments to a variadic function are\n+promoted like unscoped enumerators, causing @samp{va_arg} to complain.\n+On most targets this does not actually affect the parameter passing\n+ABI, as there is no way to pass an argument smaller than @samp{int}.\n+\n+Also, the ABI changed the mangling of template argument packs,\n+@code{const_cast}, @code{static_cast}, prefix increment/decrement, and\n+a class scope function used as a template argument.\n+\n+These issues were corrected in @option{-fabi-version=6}.\n+\n+@item\n+Lambdas in default argument scope were mangled incorrectly, and the\n+ABI changed the mangling of nullptr_t.\n+\n+These issues were corrected in @option{-fabi-version=7}.\n+\n+@item\n+When mangling a function type with function-cv-qualifiers, the\n+un-qualified function type was incorrectly treated as a substitution\n+candidate.\n+\n+This was fixed in @option{-fabi-version=8}.\n @end itemize\n \n It also warns about psABI-related changes.  The known psABI changes at this"}, {"sha": "a888173304bb4404c0b25f9644423b301b7089e0", "filename": "gcc/testsuite/g++.dg/abi/mangle19-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle19-1.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-fabi-version=2 -Wno-abi\" }\n+// { dg-options \"-fabi-version=2 -Wabi\" }\n \n // Copyright (C) 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 15 Dec 2003 <nathan@codesourcery.com>\n@@ -9,5 +9,5 @@\n \n extern int N;\n template <int &> struct S {};\n-void n (S<N>) {}\n+void n (S<N>) {}\t\t// { dg-warning \"mangle\" }\n // { dg-final { scan-assembler \"\\n_?_Z1n1SILZ1NEE\\[: \\t\\n\\]\" } }"}, {"sha": "538c5cbfae25e0900bbfbd269e4b467cf20f8307", "filename": "gcc/testsuite/g++.dg/abi/mangle3-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3-2.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,12 +1,12 @@\n // Test mangling of type casts\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=5\" }\n // { dg-do compile }\n \n template<int i> class A {};\n template<bool b> class B {};\n \n template<int i> void f(A<i> &, B<bool(i)> &) {}\n-template<int i> void g(A<i> &, B<static_cast<bool>(i)> &) {}\n+template<int i> void g(A<i> &, B<static_cast<bool>(i)> &) {} // { dg-warning \"mangle\" }\n \n int main()\n {"}, {"sha": "42f8deac5370f6150f271bf6a9a7b96e0984e4d1", "filename": "gcc/testsuite/g++.dg/abi/mangle3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle3.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,12 +1,12 @@\n // Test mangling of type casts\n-// { dg-options \"-fabi-version=2\" }\n+// { dg-options \"-fabi-version=2 -Wabi\" }\n // { dg-do compile }\n \n template<int i> class A {};\n template<bool b> class B {};\n \n template<int i> void f(A<i> &, B<bool(i)> &) {}\n-template<int i> void g(A<i> &, B<static_cast<bool>(i)> &) {}\n+template<int i> void g(A<i> &, B<static_cast<bool>(i)> &) {} // { dg-warning \"mangle\" }\n \n int main()\n {"}, {"sha": "bdedb0ab3b3c0738b22c78fc8c8aabb3f9698777", "filename": "gcc/testsuite/g++.dg/abi/mangle45.C", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle45.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,26 +1,26 @@\n // Testcase for mangling of parameters used other than in a trailing return type\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=5\" }\n+// { dg-options \"-fabi-version=5 -Wabi=4\" }\n \n-template<class T> void f(T p, decltype(p)) { }                // L = 1\n-template<class T> void g(T p, decltype(p) (*)()) { }          // L = 1\n+template<class T> void f(T p, decltype(p)) { }\t     // L = 1 { dg-warning \"mangle\" }\n+template<class T> void g(T p, decltype(p) (*)()) { } // L = 1 { dg-warning \"mangle\" }\n // G++ incorrectly rejects these currently.\n // template<class T> void h(T p, auto (*)()->decltype(p));    // L = 1\n // template<class T> void i(T p, auto (*)(T q)->decltype(q)); // L = 0\n // template<class T> void j(T p, auto (*)(decltype(p))->T);   // L = 2\n-template<class T> void k(T p, int (*(*)(T* p))[sizeof(p)]) {} // L = 1\n+template<class T> void k(T p, int (*(*)(T* p))[sizeof(p)]) {} // L = 1 { dg-warning \"mangle\" }\n \n int garg();\n int (*karg (int*))[sizeof(int)];\n int main()\n {\n-  // { dg-final { scan-assembler  \"_Z1fIiEvT_DtfL0p_E\" } }\n+  // { dg-final { scan-assembler  \"\\n_?_Z1fIiEvT_DtfL0p_E\\[: \\t\\n\\]\" } }\n   f (1,0);\n-  // { dg-final { scan-assembler  \"_Z1gIiEvT_PFDtfL0p_EvE\" } }\n+  // { dg-final { scan-assembler  \"\\n_?_Z1gIiEvT_PFDtfL0p_EvE\\[: \\t\\n\\]\" } }\n   g (1,garg);\n   // h (1,0);\n   // i (1,0);\n   // j (1,0);\n-  // { dg-final { scan-assembler  \"_Z1kIiEvT_PFPAszfL0p__iPS0_E\" } }\n+  // { dg-final { scan-assembler  \"\\n_?_Z1kIiEvT_PFPAszfL0p__iPS0_E\\[: \\t\\n\\]\" } }\n   k (1,karg);\n }"}, {"sha": "fae013a2635b8b7babc99edf5d5a0a64cf957ee6", "filename": "gcc/testsuite/g++.dg/abi/mangle49.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle49.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,10 +1,10 @@\n // PR c++/49932\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n \n template < typename T >\n auto\n-f1( T x ) // ICE on here\n+f1( T x )\t\t\t// { dg-warning \"mangle\" }\n   -> typename decltype( x )::type {}\n \n template < typename T >\n@@ -19,5 +19,5 @@ void g()\n   f2( S() );\n }\n \n-// { dg-final { scan-assembler \"_Z2f1I1SENDtfp_E4typeET_\" } }\n-// { dg-final { scan-assembler \"_Z2f2I1SENDTcvT__EE4typeES1_\" } }\n+// { dg-final { scan-assembler \"\\n_?_Z2f1I1SENDtfp_E4typeET_\\[: \\t\\n\\]\" } }\n+// { dg-final { scan-assembler \"\\n_?_Z2f2I1SENDTcvT__EE4typeES1_\\[: \\t\\n\\]\" } }"}, {"sha": "0b9a72fd2178412359d789e33c6872ab6544b0a7", "filename": "gcc/testsuite/g++.dg/abi/mangle52.C", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle52.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,13 +1,13 @@\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n \n template <unsigned int> struct helper {};\n-// { dg-final { scan-assembler \"_Z6check1IiEvP6helperIXszscT_Li1EEE\" } }\n-template <class T> void check1( helper<sizeof(static_cast<T>(1))> * ) { }\n-// { dg-final { scan-assembler \"_Z6check2IiXadL_Z1iEEEvP6helperIXszccPT_T0_EE\" } }\n-template <class T, T* p> void check2( helper<sizeof(const_cast<T*>(p))> * ) { }\n-// { dg-final { scan-assembler \"_Z6check3IiEvP6helperIXszrcPT_Li0EEE\" } }\n+// { dg-final { scan-assembler \"\\n_?_Z6check1IiEvP6helperIXszscT_Li1EEE\\[: \\t\\n\\]\" } }\n+template <class T> void check1( helper<sizeof(static_cast<T>(1))> * ) { } // { dg-warning \"mangle\" }\n+// { dg-final { scan-assembler \"\\n_?_Z6check2IiXadL_Z1iEEEvP6helperIXszccPT_T0_EE\\[: \\t\\n\\]\" } }\n+template <class T, T* p> void check2( helper<sizeof(const_cast<T*>(p))> * ) { } // { dg-warning \"mangle\" }\n+// { dg-final { scan-assembler \"\\n_?_Z6check3IiEvP6helperIXszrcPT_Li0EEE\\[: \\t\\n\\]\" } }\n template <class T> void check3( helper<sizeof(reinterpret_cast<T*>(0))> * ) { }\n-// { dg-final { scan-assembler \"_Z6check4I1AXadL_Z1aEEEvP6helperIXszdcPT_T0_EE\" } }\n+// { dg-final { scan-assembler \"\\n_?_Z6check4I1AXadL_Z1aEEEvP6helperIXszdcPT_T0_EE\\[: \\t\\n\\]\" } }\n template <class T, T* p> void check4( helper<sizeof(dynamic_cast<T*>(p))> * ) { }\n \n struct A{} a;"}, {"sha": "ba1d3bc31822779a21a89b31bfa0ac93c0c23d4d", "filename": "gcc/testsuite/g++.dg/abi/mangle54.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle54.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle54.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle54.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,15 +1,15 @@\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n \n int i;\n // { dg-final { scan-assembler \"_Z2f1IiEDTppfp_ET_\" } }\n template <class T> auto f1 (T t) -> decltype(t++) { return i; }\n // { dg-final { scan-assembler \"_Z2f2IiEDTpp_fp_ET_\" } }\n-template <class T> auto f2 (T t) -> decltype(++t) { return i; }\n+template <class T> auto f2 (T t) -> decltype(++t) { return i; } // { dg-warning \"mangle\" }\n // { dg-final { scan-assembler \"_Z2f3IiEDTmmfp_ET_\" } }\n template <class T> auto f3 (T t) -> decltype(t--) { return i; }\n // { dg-final { scan-assembler \"_Z2f4IiEDTmm_fp_ET_\" } }\n-template <class T> auto f4 (T t) -> decltype(--t) { return i; }\n+template <class T> auto f4 (T t) -> decltype(--t) { return i; } // { dg-warning \"mangle\" }\n \n int main()\n {"}, {"sha": "46cf377ebc7c2d234e0fe7825e1d2723a9d975b4", "filename": "gcc/testsuite/g++.dg/abi/mangle57.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle57.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle57.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle57.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,13 +1,13 @@\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n \n template<typename T> int cmp1(T a, T b);\n int cmp2(char a, char b);\n template<typename T, int (*cmp)(T, T)> struct A { };\n-// { dg-final { scan-assembler \"_Z1fIcEvR1AIT_X4cmp1EE\" } }\n-template <typename T> void f (A<T,cmp1> &);\n-// { dg-final { scan-assembler \"_Z1fIcEvR1AIT_L_Z4cmp2ccEE\" } }\n-template <typename T> void f (A<T,cmp2> &);\n+// { dg-final { scan-assembler \"\\n_?_Z1fIcEvR1AIT_X4cmp1EE\\[: \\t\\n\\]\" } }\n+template <typename T> void f (A<T,cmp1> &) {}\n+// { dg-final { scan-assembler \"\\n_?_Z1fIcEvR1AIT_L_Z4cmp2ccEE\\[: \\t\\n\\]\" } }\n+template <typename T> void f (A<T,cmp2> &) {} // { dg-warning \"mangle\" }\n void g()\n {\n   A<char,cmp1> a;"}, {"sha": "f9aadc2a9008702446c984ff26466da0563cd8c3", "filename": "gcc/testsuite/g++.dg/abi/mangle58.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle58.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle58.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle58.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile { target c++11 } }\n-// { dg-options \"-fabi-version=0\" }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n \n template<typename T, int (*cmp)(T, T)> struct A { };\n struct B {\n@@ -10,9 +10,9 @@ struct B {\n   // { dg-final { scan-assembler \"_ZN1B1gIcEEvR1AIT_XsrS_4cmp1EE\" } }\n   template <typename T> static void g (A<T,B::cmp1> &);\n   // { dg-final { scan-assembler \"_ZN1B1fIcEEvR1AIT_L_ZNS_4cmp2EccEE\" } }\n-  template <typename T> static void f (A<T,cmp2> &);\n+  template <typename T> static void f (A<T,cmp2> &); // { dg-warning \"mangle\" }\n   // { dg-final { scan-assembler \"_ZN1B1gIcEEvR1AIT_L_ZNS_4cmp2EccEE\" } }\n-  template <typename T> static void g (A<T,B::cmp2> &);\n+  template <typename T> static void g (A<T,B::cmp2> &); // { dg-warning \"mangle\" }\n };\n \n void g()"}, {"sha": "db541ca1902b9310e80f801977372629d70ebfa4", "filename": "gcc/testsuite/g++.dg/abi/mangle62.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -2,10 +2,10 @@\n // as a substitution candidate for a function type with function-cv-quals.\n // Test for the conformant behavior.\n \n-// { dg-options -fabi-version=0 }\n+// { dg-options \"-fabi-version=0 -Wabi=7\" }\n \n template <class T, class U> struct A { };\n-// { dg-final { scan-assembler \"_Z1fP1AIKFvvEFvvEE\" } }\n-void f (A<void()const, void()> *){}\n-// { dg-final { scan-assembler \"_Z1gP1AIFvvEKFvvEE\" } }\n-void g (A<void(), void()const> *){}\n+// { dg-final { scan-assembler \"\\n_?_Z1fP1AIKFvvEFvvEE\\[: \\t\\n\\]\" } }\n+void f (A<void()const, void()> *){} // { dg-warning \"mangled name\" }\n+// { dg-final { scan-assembler \"\\n_?_Z1gP1AIFvvEKFvvEE\\[: \\t\\n\\]\" } }\n+void g (A<void(), void()const> *){} // { dg-warning \"mangled name\" }"}, {"sha": "a48efd07ae7336d82bbf32da0339fe3344f9a419", "filename": "gcc/testsuite/g++.dg/abi/mangle62a.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle62a.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -2,10 +2,10 @@\n // as a substitution candidate for a function type with function-cv-quals.\n // Test for that for backward compatibility.\n \n-// { dg-options -fabi-version=7 }\n+// { dg-options \"-fabi-version=7 -Wabi\" }\n \n template <class T, class U> struct A { };\n-// { dg-final { scan-assembler \"_Z1fP1AIKFvvES0_E\" } }\n-void f (A<void()const, void()> *){}\n-// { dg-final { scan-assembler \"_Z1gP1AIFvvEKS0_E\" } }\n-void g (A<void(), void()const> *){}\n+// { dg-final { scan-assembler \"\\n_?_Z1fP1AIKFvvES0_E\\[: \\t\\n\\]\" } }\n+void f (A<void()const, void()> *){} // { dg-warning \"mangle\" }\n+// { dg-final { scan-assembler \"\\n_?_Z1gP1AIFvvEKS0_E\\[: \\t\\n\\]\" } }\n+void g (A<void(), void()const> *){} // { dg-warning \"mangle\" }"}, {"sha": "7589ed44066d6ae67ca5fac0e28fd54a532b6834", "filename": "gcc/testsuite/g++.dg/abi/scoped1.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fscoped1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fscoped1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fscoped1.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-fabi-version=0 -Wabi=2\" }\n+\n+enum class A: short { a1, a2, a3 };\n+void f(int i, ...)\n+{\n+  __builtin_va_list ap;\n+  __builtin_va_start (ap, i);\n+  if (__builtin_va_arg (ap, A) != A::a1) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a2) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a3) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a1) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a2) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a3) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a1) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a2) __builtin_abort(); // { dg-warning \"passed\" }\n+  if (__builtin_va_arg (ap, A) != A::a3) __builtin_abort(); // { dg-warning \"passed\" }\n+}\n+\n+int main()\n+{\n+  f(9, A::a1, A::a2, A::a3, A::a1, A::a2, A::a3, A::a1, A::a2, A::a3);\t// { dg-warning \"passed\" }\n+}"}, {"sha": "8335fadd78e2a86025893101a851b4819e542fb5", "filename": "gcc/testsuite/g++.dg/cpp0x/enum13.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62984918665f0c82b187293ba762bc2edb32ab92/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fenum13.C?ref=62984918665f0c82b187293ba762bc2edb32ab92", "patch": "@@ -10,12 +10,10 @@ enum struct A : short { X };\n void foo(int x, ...) {\n    va_list vl;\n    __builtin_va_start(vl, x);\n-   enum A t = __builtin_va_arg(vl, enum A); // { dg-warning \"promote\" }\n+   enum A t = __builtin_va_arg(vl, enum A); // { dg-warning \"scoped|promote\" }\n    __builtin_va_end(vl);\n }\n \n int main() {\n-   foo(0, A::X);\t\t// { dg-warning \"will not promote\" }\n+   foo(0, A::X);\t\t// { dg-warning \"scoped\" }\n }\n-\n-// { dg-prune-output \"note\" }"}]}