{"sha": "efea75f9a48a3b5571ed974fd48aaf42616f877c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlYTc1ZjlhNDhhM2I1NTcxZWQ5NzRmZDQ4YWFmNDI2MTZmODc3Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-10-30T00:06:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-10-30T00:06:22Z"}, "message": "tree-ssa-dom.c (struct edge_info): New structure holding edge equivalences and edge redirection information.\n\n\n\t* tree-ssa-dom.c (struct edge_info): New structure holding\n\tedge equivalences and edge redirection information.\n\t(get_eq_expr_value, record_dominating_conditions): Kill.\n\t(propagate_to_outgoing_edges): Renamed from cprop_into_phis.\n\tCall record_edge_info.\n\t(allocate_edge_info, free_edge_info): New.\n\t(tree_ssa_dominator_optimize): Use propagate_to_outgoing_edges\n\trather than cprop_into_phis.  Free all edge infos before threading\n\tjumps.\n\t(thread_across_edge): Allocate new edge info structures as needed\n\tand store the redirection target into the edge info structure\n\tinstead of the edge's AUX field.\n\t(dom_opt_initialize_block): Mark unused argument with ATTRIBUTE_UNUSED.\n\t(record_equivalence_from_incoming_edge): Lose unnecessary argument.\n\tRevamp code which finds and records equivalences associated with\n\tedges to use saved data in the edge_info structure.\n\t(record_equivalencs_from_phis): Similarly.\n\t(dom_opt_finalize_block): Revamp code which finds and records\n\tequivalences associated with edges to use saved data in the\n\tedge_info structure.\n\t(build_and_record_new_cond): New function.\n\t(record_conditions): Use build_and_record_new_cond to record\n\tdominating conditions.\n\t(record_edge_info): New function.\n\t(record_range): Tighten test for conditions which create\n\tuseful range records.\n\nFrom-SVN: r89866", "tree": {"sha": "530ac2f67b6fb4445dfaebac63e5456ff97a9510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/530ac2f67b6fb4445dfaebac63e5456ff97a9510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efea75f9a48a3b5571ed974fd48aaf42616f877c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efea75f9a48a3b5571ed974fd48aaf42616f877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efea75f9a48a3b5571ed974fd48aaf42616f877c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efea75f9a48a3b5571ed974fd48aaf42616f877c/comments", "author": null, "committer": null, "parents": [{"sha": "cc92f54fcff028571601312836c427692ae93161", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc92f54fcff028571601312836c427692ae93161", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc92f54fcff028571601312836c427692ae93161"}], "stats": {"total": 874, "additions": 511, "deletions": 363}, "files": [{"sha": "db0e3f5204395c61f9730c3b330b771ce0e44f87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efea75f9a48a3b5571ed974fd48aaf42616f877c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efea75f9a48a3b5571ed974fd48aaf42616f877c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efea75f9a48a3b5571ed974fd48aaf42616f877c", "patch": "@@ -1,3 +1,32 @@\n+2004-10-29 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (struct edge_info): New structure holding\n+\tedge equivalences and edge redirection information.\n+\t(get_eq_expr_value, record_dominating_conditions): Kill.\n+\t(propagate_to_outgoing_edges): Renamed from cprop_into_phis.\n+\tCall record_edge_info.\n+\t(allocate_edge_info, free_edge_info): New.\n+\t(tree_ssa_dominator_optimize): Use propagate_to_outgoing_edges\n+\trather than cprop_into_phis.  Free all edge infos before threading\n+\tjumps.\n+\t(thread_across_edge): Allocate new edge info structures as needed\n+\tand store the redirection target into the edge info structure\n+\tinstead of the edge's AUX field.\n+\t(dom_opt_initialize_block): Mark unused argument with ATTRIBUTE_UNUSED.\n+\t(record_equivalence_from_incoming_edge): Lose unnecessary argument.\n+\tRevamp code which finds and records equivalences associated with\n+\tedges to use saved data in the edge_info structure.\n+\t(record_equivalencs_from_phis): Similarly.\n+\t(dom_opt_finalize_block): Revamp code which finds and records\n+\tequivalences associated with edges to use saved data in the\n+\tedge_info structure.\n+\t(build_and_record_new_cond): New function.\n+\t(record_conditions): Use build_and_record_new_cond to record\n+\tdominating conditions.\n+\t(record_edge_info): New function.\n+\t(record_range): Tighten test for conditions which create\n+\tuseful range records.\n+\n 2004-10-29  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/darwin-fallback.c: Include <mach/thread_status.h>."}, {"sha": "b50767fba53c36bca01c4e05c317950da7311b8e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 482, "deletions": 363, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efea75f9a48a3b5571ed974fd48aaf42616f877c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efea75f9a48a3b5571ed974fd48aaf42616f877c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=efea75f9a48a3b5571ed974fd48aaf42616f877c", "patch": "@@ -45,6 +45,40 @@ Boston, MA 02111-1307, USA.  */\n \n /* This file implements optimizations on the dominator tree.  */\n \n+\n+/* Structure for recording edge equivalences as well as any pending\n+   edge redirections during the dominator optimizer.\n+\n+   Computing and storing the edge equivalences instead of creating\n+   them on-demand can save significant amounts of time, particularly\n+   for pathological cases involving switch statements.  \n+\n+   These structures live for a single iteration of the dominator\n+   optimizer in the edge's AUX field.  At the end of an iteration we\n+   free each of these structures and update the AUX field to point\n+   to any requested redirection target (the code for updating the\n+   CFG and SSA graph for edge redirection expects redirection edge\n+   targets to be in the AUX field for each edge.  */\n+\n+struct edge_info\n+{\n+  /* If this edge creates a simple equivalence, the LHS and RHS of\n+     the equivalence will be stored here.  */\n+  tree lhs;\n+  tree rhs;\n+\n+  /* Traversing an edge may also indicate one or more particular conditions\n+     are true or false.  The number of recorded conditions can vary, but\n+     can be determined by the condition's code.  So we have an array\n+     and its maximum index rather than use a varray.  */\n+  tree *cond_equivalences;\n+  unsigned int max_cond_equivalences;\n+\n+  /* If we can thread this edge this field records the new target.  */\n+  edge redirection_target;\n+};\n+\n+\n /* Hash table with expressions made available during the renaming process.\n    When an assignment of the form X_i = EXPR is found, the statement is\n    stored in this table.  If the same expression EXPR is later found on the\n@@ -231,15 +265,13 @@ static void optimize_stmt (struct dom_walk_data *,\n \t\t\t   basic_block bb,\n \t\t\t   block_stmt_iterator);\n static tree lookup_avail_expr (tree, bool);\n-static struct eq_expr_value get_eq_expr_value (tree, int, basic_block);\n static hashval_t vrp_hash (const void *);\n static int vrp_eq (const void *, const void *);\n static hashval_t avail_expr_hash (const void *);\n static hashval_t real_avail_expr_hash (const void *);\n static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree);\n-static void record_dominating_conditions (tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n static tree update_rhs_and_lookup_avail_expr (tree, tree, bool);\n@@ -250,16 +282,15 @@ static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n static void record_range (tree, basic_block);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n-static void record_equivalences_from_phis (struct dom_walk_data *, basic_block);\n-static void record_equivalences_from_incoming_edge (struct dom_walk_data *,\n-\t\t\t\t\t\t    basic_block);\n+static void record_equivalences_from_phis (basic_block);\n+static void record_equivalences_from_incoming_edge (basic_block);\n static bool eliminate_redundant_computations (struct dom_walk_data *,\n \t\t\t\t\t      tree, stmt_ann_t);\n static void record_equivalences_from_stmt (tree, int, stmt_ann_t);\n static void thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n-static void cprop_into_phis (struct dom_walk_data *, basic_block);\n+static void propagate_to_outgoing_edges (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n static void restore_currdefs_to_original_value (void);\n@@ -283,6 +314,50 @@ local_fold (tree t)\n   return t;\n }\n \n+/* Allocate an EDGE_INFO for edge E and attach it to E.\n+   Return the new EDGE_INFO structure.  */\n+\n+static struct edge_info *\n+allocate_edge_info (edge e)\n+{\n+  struct edge_info *edge_info;\n+\n+  edge_info = xcalloc (1, sizeof (struct edge_info));\n+\n+  e->aux = edge_info;\n+  return edge_info;\n+}\n+\n+/* Free all EDGE_INFO structures associated with edges in the CFG.\n+   If a partciular edge can be threaded, copy the redirection\n+   target from the EDGE_INFO structure into the edge's AUX field\n+   as required by code to update the CFG and SSA graph for\n+   jump threading.  */\n+\n+static void\n+free_all_edge_infos (void)\n+{\n+  basic_block bb;\n+  edge_iterator ei;\n+  edge e;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+        {\n+\t struct edge_info *edge_info = e->aux;\n+\n+\t  if (edge_info)\n+\t    {\n+\t      e->aux = edge_info->redirection_target;\n+\t      if (edge_info->cond_equivalences)\n+\t\tfree (edge_info->cond_equivalences);\n+\t      free (edge_info);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Jump threading, redundancy elimination and const/copy propagation. \n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -323,7 +398,7 @@ tree_ssa_dominator_optimize (void)\n   walk_data.initialize_block_local_data = NULL;\n   walk_data.before_dom_children_before_stmts = dom_opt_initialize_block;\n   walk_data.before_dom_children_walk_stmts = optimize_stmt;\n-  walk_data.before_dom_children_after_stmts = cprop_into_phis;\n+  walk_data.before_dom_children_after_stmts = propagate_to_outgoing_edges;\n   walk_data.after_dom_children_before_stmts = NULL;\n   walk_data.after_dom_children_walk_stmts = NULL;\n   walk_data.after_dom_children_after_stmts = dom_opt_finalize_block;\n@@ -362,6 +437,8 @@ tree_ssa_dominator_optimize (void)\n \t  bitmap_clear (vars_to_rename);\n \t}\n \n+      free_all_edge_infos ();\n+\n       /* Thread jumps, creating duplicate blocks as needed.  */\n       cfg_altered = thread_through_all_blocks ();\n \n@@ -697,9 +774,15 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t     bypass the conditional at our original destination.  */\n \t  if (dest)\n \t    {\n+\t      struct edge_info *edge_info;\n+\n \t      update_bb_profile_for_threading (e->dest, EDGE_FREQUENCY (e),\n \t\t\t\t\t       e->count, taken_edge);\n-\t      e->aux = taken_edge;\n+\t      if (e->aux)\n+\t\tedge_info = e->aux;\n+\t      else\n+\t\tedge_info = allocate_edge_info (e);\n+\t      edge_info->redirection_target = taken_edge;\n \t      bb_ann (e->dest)->incoming_edge_threaded = true;\n \t    }\n \t}\n@@ -712,7 +795,8 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n    reach BB or they may come from PHI nodes at the start of BB.  */\n \n static void\n-dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n+dom_opt_initialize_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t  basic_block bb)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n\\nOptimizing block #%d\\n\\n\", bb->index);\n@@ -725,10 +809,10 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n   VARRAY_PUSH_TREE (nonzero_vars_stack, NULL_TREE);\n   VARRAY_PUSH_TREE (vrp_variables_stack, NULL_TREE);\n \n-  record_equivalences_from_incoming_edge (walk_data, bb);\n+  record_equivalences_from_incoming_edge (bb);\n \n   /* PHI nodes can create equivalences too.  */\n-  record_equivalences_from_phis (walk_data, bb);\n+  record_equivalences_from_phis (bb);\n }\n \n /* Given an expression EXPR (a relational expression or a statement), \n@@ -900,38 +984,56 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t   && (EDGE_SUCC (bb, 1)->flags & EDGE_ABNORMAL) == 0)\n     {\n       edge true_edge, false_edge;\n-      tree cond, inverted = NULL;\n-      enum tree_code cond_code;\n \n       extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n \n-      cond = COND_EXPR_COND (last);\n-      cond_code = TREE_CODE (cond);\n-\n-      if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n-\tinverted = invert_truthvalue (cond);\n-\n       /* If the THEN arm is the end of a dominator tree or has PHI nodes,\n \t then try to thread through its edge.  */\n       if (get_immediate_dominator (CDI_DOMINATORS, true_edge->dest) != bb\n \t  || phi_nodes (true_edge->dest))\n \t{\n+\t  struct edge_info *edge_info;\n+\t  unsigned int i;\n+\n \t  /* Push a marker onto the available expression stack so that we\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n \t  VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n \t  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n \t  VARRAY_PUSH_TREE (const_and_copies_stack, NULL_TREE);\n \n-\t  /* Record any equivalences created by following this edge.  */\n-\t  if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n+\t  edge_info = true_edge->aux;\n+\n+\t  /* If we have info associated with this edge, record it into\n+\t     our equivalency tables.  */\n+\t  if (edge_info)\n \t    {\n-\t      record_cond (cond, boolean_true_node);\n-\t      record_dominating_conditions (cond);\n-\t      record_cond (inverted, boolean_false_node);\n+\t      tree *cond_equivalences = edge_info->cond_equivalences;\n+\t      tree lhs = edge_info->lhs;\n+\t      tree rhs = edge_info->rhs;\n+\n+\t      /* If we have a simple NAME = VALUE equivalency record it.\n+\t\t Until the jump threading selection code improves, only\n+\t\t do this if both the name and value are SSA_NAMEs with\n+\t\t the same underlying variable to avoid missing threading\n+\t\t opportunities.  */\n+\t      if (lhs\n+\t\t  && TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME\n+\t\t  && TREE_CODE (edge_info->rhs) == SSA_NAME\n+\t\t  && SSA_NAME_VAR (lhs) == SSA_NAME_VAR (rhs))\n+\t\trecord_const_or_copy (lhs, rhs);\n+\n+\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t\t into our expression hash tables.  */\n+\t      if (cond_equivalences)\n+\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i += 2)\n+\t\t  {\n+\t\t    tree expr = cond_equivalences[i];\n+\t\t    tree value = cond_equivalences[i + 1];\n+\n+\t\t    record_cond (expr, value);\n+\t\t  }\n \t    }\n-\t  else if (cond_code == SSA_NAME)\n-\t    record_const_or_copy (cond, boolean_true_node);\n \n \t  /* Now thread the edge.  */\n \t  thread_across_edge (walk_data, true_edge);\n@@ -947,15 +1049,39 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       if (get_immediate_dominator (CDI_DOMINATORS, false_edge->dest) != bb\n \t  || phi_nodes (false_edge->dest))\n \t{\n-\t  /* Record any equivalences created by following this edge.  */\n-\t  if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n+\t  struct edge_info *edge_info;\n+\t  unsigned int i;\n+\n+\t  edge_info = false_edge->aux;\n+\n+\t  /* If we have info associated with this edge, record it into\n+\t     our equivalency tables.  */\n+\t  if (edge_info)\n \t    {\n-\t      record_cond (cond, boolean_false_node);\n-\t      record_cond (inverted, boolean_true_node);\n-\t      record_dominating_conditions (inverted);\n+\t      tree *cond_equivalences = edge_info->cond_equivalences;\n+\t      tree lhs = edge_info->lhs;\n+\t      tree rhs = edge_info->rhs;\n+\n+\t      /* If we have a simple NAME = VALUE equivalency record it.\n+\t\t Until the jump threading selection code improves, only\n+\t\t do this if both the name and value are SSA_NAMEs with\n+\t\t the same underlying variable to avoid missing threading\n+\t\t opportunities.  */\n+\t      if (lhs\n+\t\t  && TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME)\n+\t\trecord_const_or_copy (lhs, rhs);\n+\n+\t      /* If we have 0 = COND or 1 = COND equivalences, record them\n+\t\t into our expression hash tables.  */\n+\t      if (cond_equivalences)\n+\t\tfor (i = 0; i < edge_info->max_cond_equivalences; i += 2)\n+\t\t  {\n+\t\t    tree expr = cond_equivalences[i];\n+\t\t    tree value = cond_equivalences[i + 1];\n+\n+\t\t    record_cond (expr, value);\n+\t\t  }\n \t    }\n-\t  else if (cond_code == SSA_NAME)\n-\t    record_const_or_copy (cond, boolean_false_node);\n \n \t  thread_across_edge (walk_data, false_edge);\n \n@@ -1040,8 +1166,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n    even if we do not know its exact value.  */\n \n static void\n-record_equivalences_from_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t       basic_block bb)\n+record_equivalences_from_phis (basic_block bb)\n {\n   tree phi;\n \n@@ -1138,110 +1263,62 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n    has more than one incoming edge, then no equivalence is created.  */\n \n static void\n-record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t\t\tbasic_block bb)\n+record_equivalences_from_incoming_edge (basic_block bb)\n {\n-  int edge_flags;\n+  edge e;\n   basic_block parent;\n-  struct eq_expr_value eq_expr_value;\n-  tree parent_block_last_stmt = NULL;\n+  struct edge_info *edge_info;\n \n   /* If our parent block ended with a control statment, then we may be\n      able to record some equivalences based on which outgoing edge from\n      the parent was followed.  */\n   parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n-  if (parent)\n-    {\n-      parent_block_last_stmt = last_stmt (parent);\n-      if (parent_block_last_stmt && !is_ctrl_stmt (parent_block_last_stmt))\n-\tparent_block_last_stmt = NULL;\n-    }\n \n-  eq_expr_value.src = NULL;\n-  eq_expr_value.dst = NULL;\n+  e = single_incoming_edge_ignoring_loop_edges (bb);\n \n-  /* If we have a single predecessor (ignoring loop backedges), then extract\n-     EDGE_FLAGS from the single incoming edge.  Otherwise just return as\n-     there is nothing to do.  */\n-  if (EDGE_COUNT (bb->preds) >= 1\n-      && parent_block_last_stmt)\n+  /* If we had a single incoming edge from our parent block, then enter\n+     any data associated with the edge into our tables.  */\n+  if (e && e->src == parent)\n     {\n-      edge e = single_incoming_edge_ignoring_loop_edges (bb);\n-      if (e && bb_for_stmt (parent_block_last_stmt) == e->src)\n-\tedge_flags = e->flags;\n-      else\n-\treturn;\n-    }\n-  else\n-    return;\n+      unsigned int i;\n \n-  /* If our parent block ended in a COND_EXPR, add any equivalences\n-     created by the COND_EXPR to the hash table and initialize\n-     EQ_EXPR_VALUE appropriately.\n-\n-     EQ_EXPR_VALUE is an assignment expression created when BB's immediate\n-     dominator ends in a COND_EXPR statement whose predicate is of the form\n-     'VAR == VALUE', where VALUE may be another variable or a constant.\n-     This is used to propagate VALUE on the THEN_CLAUSE of that\n-     conditional. This assignment is inserted in CONST_AND_COPIES so that\n-     the copy and constant propagator can find more propagation\n-     opportunities.  */\n-  if (TREE_CODE (parent_block_last_stmt) == COND_EXPR\n-      && (edge_flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))\n-    eq_expr_value = get_eq_expr_value (parent_block_last_stmt,\n-\t\t\t\t       (edge_flags & EDGE_TRUE_VALUE) != 0,\n-\t\t\t\t       bb);\n-  /* Similarly when the parent block ended in a SWITCH_EXPR.\n-     We can only know the value of the switch's condition if the dominator\n-     parent is also the only predecessor of this block.  */\n-  else if (EDGE_PRED (bb, 0)->src == parent\n-\t   && TREE_CODE (parent_block_last_stmt) == SWITCH_EXPR)\n-    {\n-      tree switch_cond = SWITCH_COND (parent_block_last_stmt);\n+      edge_info = e->aux;\n \n-      /* If the switch's condition is an SSA variable, then we may\n-\t know its value at each of the case labels.  */\n-      if (TREE_CODE (switch_cond) == SSA_NAME)\n+      if (edge_info)\n \t{\n-\t  tree switch_vec = SWITCH_LABELS (parent_block_last_stmt);\n-\t  size_t i, n = TREE_VEC_LENGTH (switch_vec);\n-\t  int case_count = 0;\n-\t  tree match_case = NULL_TREE;\n-\n-\t  /* Search the case labels for those whose destination is\n-\t     the current basic block.  */\n-\t  for (i = 0; i < n; ++i)\n+\t  tree lhs = edge_info->lhs;\n+\t  tree rhs = edge_info->rhs;\n+\t  tree *cond_equivalences = edge_info->cond_equivalences;\n+\n+\t  if (lhs)\n+\t    record_equality (lhs, rhs);\n+\n+\t  if (cond_equivalences)\n \t    {\n-\t      tree elt = TREE_VEC_ELT (switch_vec, i);\n-\t      if (label_to_block (CASE_LABEL (elt)) == bb)\n+\t      bool recorded_range = false;\n+\t      for (i = 0; i < edge_info->max_cond_equivalences; i += 2)\n \t\t{\n-\t\t  if (++case_count > 1 || CASE_HIGH (elt))\n-\t\t    break;\n-\t\t  match_case = elt;\n+\t\t  tree expr = cond_equivalences[i];\n+\t\t  tree value = cond_equivalences[i + 1];\n+\n+\t\t  record_cond (expr, value);\n+\n+\t\t  /* For the first true equivalence, record range\n+\t\t     information.  We only do this for the first\n+\t\t     true equivalence as it should dominate any\n+\t\t     later true equivalences.  */\n+\t\t  if (! recorded_range \n+\t\t      && COMPARISON_CLASS_P (expr)\n+\t\t      && value == boolean_true_node\n+\t\t      && TREE_CONSTANT (TREE_OPERAND (expr, 1)))\n+\t\t    {\n+\t\t      record_range (expr, bb);\n+\t\t      recorded_range = true;\n+\t\t    }\n \t\t}\n \t    }\n-\n-\t  /* If we encountered precisely one CASE_LABEL_EXPR and it\n-\t     was not the default case, or a case range, then we know\n-\t     the exact value of SWITCH_COND which caused us to get to\n-\t     this block.  Record that equivalence in EQ_EXPR_VALUE.  */\n-\t  if (case_count == 1\n-\t      && match_case\n-\t      && CASE_LOW (match_case)\n-\t      && !CASE_HIGH (match_case))\n-\t    {\n-\t      eq_expr_value.dst = switch_cond;\n-\t      eq_expr_value.src = fold_convert (TREE_TYPE (switch_cond),\n-\t\t\t\t\t\tCASE_LOW (match_case));\n-\t    }\n \t}\n     }\n-\n-  /* If EQ_EXPR_VALUE (VAR == VALUE) is given, register the VALUE as a\n-     new value for VAR, so that occurrences of VAR can be replaced with\n-     VALUE while re-writing the THEN arm of a COND_EXPR.  */\n-  if (eq_expr_value.src && eq_expr_value.dst)\n-    record_equality (eq_expr_value.dst, eq_expr_value.src);\n }\n \n /* Dump SSA statistics on FILE.  */\n@@ -1333,150 +1410,129 @@ record_cond (tree cond, tree value)\n     free (element);\n }\n \n-/* COND is a condition which is known to be true.   Record variants of\n-   COND which must also be true.\n+/* Build a new conditional using NEW_CODE, OP0 and OP1 and store\n+   the new conditional into *p, then store a boolean_true_node\n+   into the the *(p + 1).  */\n+   \n+static void\n+build_and_record_new_cond (enum tree_code new_code, tree op0, tree op1, tree *p)\n+{\n+  *p = build2 (new_code, boolean_type_node, op0, op1);\n+  p++;\n+  *p = boolean_true_node;\n+}\n+\n+/* Record that COND is true and INVERTED is false into the edge information\n+   structure.  Also record that any conditions dominated by COND are true\n+   as well.\n \n    For example, if a < b is true, then a <= b must also be true.  */\n \n static void\n-record_dominating_conditions (tree cond)\n+record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n {\n+  tree op0, op1;\n+\n+  if (!COMPARISON_CLASS_P (cond))\n+    return;\n+\n+  op0 = TREE_OPERAND (cond, 0);\n+  op1 = TREE_OPERAND (cond, 1);\n+\n   switch (TREE_CODE (cond))\n     {\n     case LT_EXPR:\n-      record_cond (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (LTGT_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      break;\n-\n     case GT_EXPR:\n-      record_cond (build2 (GE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (LTGT_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 12;\n+      edge_info->cond_equivalences = xmalloc (12 * sizeof (tree));\n+      build_and_record_new_cond ((TREE_CODE (cond) == LT_EXPR\n+\t\t\t\t  ? LE_EXPR : GE_EXPR),\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[8]);\n+      build_and_record_new_cond (LTGT_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[10]);\n       break;\n \n     case GE_EXPR:\n     case LE_EXPR:\n-      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 6;\n+      edge_info->cond_equivalences = xmalloc (6 * sizeof (tree));\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[4]);\n       break;\n \n     case EQ_EXPR:\n-      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (GE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 10;\n+      edge_info->cond_equivalences = xmalloc (10 * sizeof (tree));\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (LE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n+      build_and_record_new_cond (GE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[8]);\n       break;\n \n     case UNORDERED_EXPR:\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNEQ_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNLT_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNGT_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 16;\n+      edge_info->cond_equivalences = xmalloc (16 * sizeof (tree));\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[8]);\n+      build_and_record_new_cond (UNEQ_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[10]);\n+      build_and_record_new_cond (UNLT_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[12]);\n+      build_and_record_new_cond (UNGT_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[14]);\n       break;\n \n     case UNLT_EXPR:\n-      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      break;\n-\n     case UNGT_EXPR:\n-      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 8;\n+      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      build_and_record_new_cond ((TREE_CODE (cond) == UNLT_EXPR\n+\t\t\t\t  ? UNLE_EXPR : UNGE_EXPR),\n+\t\t\t\t op0, op1, &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n       break;\n \n     case UNEQ_EXPR:\n-      record_cond (build2 (UNLE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (UNGE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 8;\n+      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      build_and_record_new_cond (UNLE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (UNGE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n       break;\n \n     case LTGT_EXPR:\n-      record_cond (build2 (NE_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n-      record_cond (build2 (ORDERED_EXPR, boolean_type_node,\n-\t\t\t   TREE_OPERAND (cond, 0),\n-\t\t\t   TREE_OPERAND (cond, 1)),\n-\t\t   boolean_true_node);\n+      edge_info->max_cond_equivalences = 8;\n+      edge_info->cond_equivalences = xmalloc (8 * sizeof (tree));\n+      build_and_record_new_cond (NE_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[4]);\n+      build_and_record_new_cond (ORDERED_EXPR, op0, op1,\n+\t\t\t\t &edge_info->cond_equivalences[6]);\n+      break;\n \n     default:\n+      edge_info->max_cond_equivalences = 4;\n+      edge_info->cond_equivalences = xmalloc (4 * sizeof (tree));\n       break;\n     }\n+\n+  /* Now store the original true and false conditions into the first\n+     two slots.  */\n+  edge_info->cond_equivalences[0] = cond;\n+  edge_info->cond_equivalences[1] = boolean_true_node;\n+  edge_info->cond_equivalences[2] = inverted;\n+  edge_info->cond_equivalences[3] = boolean_false_node;\n }\n \n /* A helper function for record_const_or_copy and record_equality.\n@@ -2311,14 +2367,198 @@ cprop_into_successor_phis (basic_block bb, bitmap nonzero_vars)\n     }\n }\n \n+/* We have finished optimizing BB, record any information implied by\n+   taking a specific outgoing edge from BB.  */\n+\n+static void\n+record_edge_info (basic_block bb)\n+{\n+  block_stmt_iterator bsi = bsi_last (bb);\n+  struct edge_info *edge_info;\n+\n+  if (! bsi_end_p (bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (stmt && TREE_CODE (stmt) == SWITCH_EXPR)\n+\t{\n+\t  tree cond = SWITCH_COND (stmt);\n+\n+\t  if (TREE_CODE (cond) == SSA_NAME)\n+\t    {\n+\t      tree labels = SWITCH_LABELS (stmt);\n+\t      int i, n_labels = TREE_VEC_LENGTH (labels);\n+\t      tree *info = xcalloc (n_basic_blocks, sizeof (tree));\n+\t      edge e;\n+\t      edge_iterator ei;\n+\n+\t      for (i = 0; i < n_labels; i++)\n+\t\t{\n+\t\t  tree label = TREE_VEC_ELT (labels, i);\n+\t\t  basic_block target_bb = label_to_block (CASE_LABEL (label));\n+\n+\t\t  if (CASE_HIGH (label)\n+\t\t      || !CASE_LOW (label)\n+\t\t      || info[target_bb->index])\n+\t\t    info[target_bb->index] = error_mark_node;\n+\t\t  else\n+\t\t    info[target_bb->index] = label;\n+\t\t}\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t{\n+\t\t  basic_block target_bb = e->dest;\n+\t\t  tree node = info[target_bb->index];\n \n-/* Propagate known constants/copies into PHI nodes of BB's successor\n-   blocks.  */\n+\t\t  if (node != NULL && node != error_mark_node)\n+\t\t    {\n+\t\t      tree x = fold_convert (TREE_TYPE (cond), CASE_LOW (node));\n+\t\t      edge_info = allocate_edge_info (e);\n+\t\t      edge_info->lhs = cond;\n+\t\t      edge_info->rhs = x;\n+\t\t    }\n+\t\t}\n+\t      free (info);\n+\t    }\n+\t}\n+\n+      /* A COND_EXPR may create equivalences too.  */\n+      if (stmt && TREE_CODE (stmt) == COND_EXPR)\n+\t{\n+\t  tree cond = COND_EXPR_COND (stmt);\n+\t  edge true_edge;\n+\t  edge false_edge;\n+\n+\t  extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\n+\t  /* If the conditinoal is a single variable 'X', record 'X = 1'\n+\t     for the true edge and 'X = 0' on the false edge.  */\n+\t  if (SSA_VAR_P (cond))\n+\t    {\n+\t      struct edge_info *edge_info;\n+\n+\t      edge_info = allocate_edge_info (true_edge);\n+\t      edge_info->lhs = cond;\n+\t      edge_info->rhs = constant_boolean_node (1, TREE_TYPE (cond));\n+\n+\t      edge_info = allocate_edge_info (false_edge);\n+\t      edge_info->lhs = cond;\n+\t      edge_info->rhs = constant_boolean_node (0, TREE_TYPE (cond));\n+\t    }\n+\t  /* Equality tests may create one or two equivalences.  */\n+\t  else if (COMPARISON_CLASS_P (cond))\n+\t    {\n+\t      tree op0 = TREE_OPERAND (cond, 0);\n+\t      tree op1 = TREE_OPERAND (cond, 1);\n+\n+\t      /* Special case comparing booleans against a constant as we\n+\t\t know the value of OP0 on both arms of the branch.  i.e., we\n+\t\t can record an equivalence for OP0 rather than COND.  */\n+\t      if ((TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n+\t\t  && TREE_CODE (op0) == SSA_NAME\n+\t\t  && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n+\t\t  && is_gimple_min_invariant (op1))\n+\t\t{\n+\t\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t\t    {\n+\t\t      edge_info = allocate_edge_info (true_edge);\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = (integer_zerop (op1)\n+\t\t\t\t\t    ? boolean_false_node\n+\t\t\t\t\t    : boolean_true_node);\n+\n+\t\t      edge_info = allocate_edge_info (false_edge);\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = (integer_zerop (op1)\n+\t\t\t\t\t    ? boolean_true_node\n+\t\t\t\t\t    : boolean_false_node);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      edge_info = allocate_edge_info (true_edge);\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = (integer_zerop (op1)\n+\t\t\t\t\t    ? boolean_true_node\n+\t\t\t\t\t    : boolean_false_node);\n+\n+\t\t      edge_info = allocate_edge_info (false_edge);\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = (integer_zerop (op1)\n+\t\t\t\t\t    ? boolean_false_node\n+\t\t\t\t\t    : boolean_true_node);\n+\t\t    }\n+\t\t}\n+\n+\t      if (is_gimple_min_invariant (op0)\n+\t\t  && (TREE_CODE (op1) == SSA_NAME\n+\t\t       || is_gimple_min_invariant (op1)))\n+\t\t{\n+\t\t  tree inverted = invert_truthvalue (cond);\n+\t\t  struct edge_info *edge_info;\n+\n+\t\t  edge_info = allocate_edge_info (true_edge);\n+\t\t  record_conditions (edge_info, cond, inverted);\n+\n+\t\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t\t    {\n+\t\t      edge_info->lhs = op1;\n+\t\t      edge_info->rhs = op0;\n+\t\t    }\n+\n+\t\t  edge_info = allocate_edge_info (false_edge);\n+\t\t  record_conditions (edge_info, inverted, cond);\n+\n+\t\t  if (TREE_CODE (cond) == NE_EXPR)\n+\t\t    {\n+\t\t      edge_info->lhs = op1;\n+\t\t      edge_info->rhs = op0;\n+\t\t    }\n+\t\t}\n+\n+\t      if (TREE_CODE (op0) == SSA_NAME\n+\t\t  && (is_gimple_min_invariant (op1)\n+\t\t      || TREE_CODE (op1) == SSA_NAME))\n+\t\t{\n+\t\t  tree inverted = invert_truthvalue (cond);\n+\t\t  struct edge_info *edge_info;\n+\n+\t\t  edge_info = allocate_edge_info (true_edge);\n+\t\t  record_conditions (edge_info, cond, inverted);\n+\n+\t\t  if (TREE_CODE (cond) == EQ_EXPR)\n+\t\t    {\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = op1;\n+\t\t    }\n+\n+\t\t  edge_info = allocate_edge_info (false_edge);\n+\t\t  record_conditions (edge_info, inverted, cond);\n+\n+\t\t  if (TREE_CODE (cond) == NE_EXPR)\n+\t\t    {\n+\t\t      edge_info->lhs = op0;\n+\t\t      edge_info->rhs = op1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* ??? TRUTH_NOT_EXPR can create an equivalence too.  */\n+\t}\n+    }\n+}\n+\n+/* Propagate information from BB to its outgoing edges.\n+\n+   This can include equivalency information implied by control statements\n+   at the end of BB and const/copy propagation into PHIs in BB's\n+   successor blocks.  */\n \n static void\n-cprop_into_phis (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t basic_block bb)\n+propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n+\t\t\t     basic_block bb)\n {\n+  \n+  record_edge_info (bb);\n   cprop_into_successor_phis (bb, nonzero_vars);\n }\n \n@@ -3037,10 +3277,13 @@ extract_range_from_cond (tree cond, tree *hi_p, tree *lo_p, int *inverted_p)\n static void\n record_range (tree cond, basic_block bb)\n {\n-  /* We explicitly ignore NE_EXPRs.  They rarely allow for meaningful\n-     range optimizations and significantly complicate the implementation.  */\n-  if (COMPARISON_CLASS_P (cond)\n-      && TREE_CODE (cond) != NE_EXPR\n+  enum tree_code code = TREE_CODE (cond);\n+\n+  /* We explicitly ignore NE_EXPRs and all the unordered comparisons.\n+     They rarely allow for meaningful range optimizations and significantly\n+     complicate the implementation.  */\n+  if ((code == LT_EXPR || code == LE_EXPR || code == GT_EXPR\n+       || code == GE_EXPR || code == EQ_EXPR)\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (cond, 1))) == INTEGER_TYPE)\n     {\n       struct vrp_hash_elt *vrp_hash_elt;\n@@ -3076,130 +3319,6 @@ record_range (tree cond, basic_block bb)\n     }\n }\n \n-/* Given a conditional statement IF_STMT, return the assignment 'X = Y'\n-   known to be true depending on which arm of IF_STMT is taken.\n-\n-   Not all conditional statements will result in a useful assignment.\n-   Return NULL_TREE in that case.\n-\n-   Also enter into the available expression table statements of\n-   the form:\n-\n-     TRUE ARM\t\tFALSE ARM\n-     1 = cond\t\t1 = cond'\n-     0 = cond'\t\t0 = cond\n-\n-   This allows us to lookup the condition in a dominated block and\n-   get back a constant indicating if the condition is true.  */\n-\n-static struct eq_expr_value\n-get_eq_expr_value (tree if_stmt,\n-\t\t   int true_arm,\n-\t\t   basic_block bb)\n-{\n-  tree cond;\n-  struct eq_expr_value retval;\n-\n-  cond = COND_EXPR_COND (if_stmt);\n-  retval.src = NULL;\n-  retval.dst = NULL;\n-\n-  /* If the conditional is a single variable 'X', return 'X = 1' for\n-     the true arm and 'X = 0' on the false arm.  */\n-  if (TREE_CODE (cond) == SSA_NAME)\n-    {\n-      retval.dst = cond;\n-      retval.src = constant_boolean_node (true_arm, TREE_TYPE (cond));\n-      return retval;\n-    }\n-\n-  /* If we have a comparison expression, then record its result into\n-     the available expression table.  */\n-  if (COMPARISON_CLASS_P (cond))\n-    {\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      tree op1 = TREE_OPERAND (cond, 1);\n-\n-      /* Special case comparing booleans against a constant as we know\n-\t the value of OP0 on both arms of the branch.  i.e., we can record\n-\t an equivalence for OP0 rather than COND.  */\n-      if ((TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n-\t  && TREE_CODE (op0) == SSA_NAME\n-\t  && TREE_CODE (TREE_TYPE (op0)) == BOOLEAN_TYPE\n-\t  && is_gimple_min_invariant (op1))\n-\t{\n-\t  if ((TREE_CODE (cond) == EQ_EXPR && true_arm)\n-\t      || (TREE_CODE (cond) == NE_EXPR && ! true_arm))\n-\t    {\n-\t      retval.src = op1;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (integer_zerop (op1))\n-\t\tretval.src = boolean_true_node;\n-\t      else\n-\t\tretval.src = boolean_false_node;\n-\t    }\n-\t  retval.dst = op0;\n-\t  return retval;\n-\t}\n-\n-      if (TREE_CODE (op0) == SSA_NAME\n-\t  && (is_gimple_min_invariant (op1) || TREE_CODE (op1) == SSA_NAME))\n-\t{\n-\t  tree inverted = invert_truthvalue (cond);\n-\n-\t  /* When we find an available expression in the hash table, we replace\n-\t     the expression with the LHS of the statement in the hash table.\n-\n-\t     So, we want to build statements such as \"1 = <condition>\" on the\n-\t     true arm and \"0 = <condition>\" on the false arm.  That way if we\n-\t     find the expression in the table, we will replace it with its\n-\t     known constant value.  Also insert inversions of the result and\n-\t     condition into the hash table.  */\n-\t  if (true_arm)\n-\t    {\n-\t      record_cond (cond, boolean_true_node);\n-\t      record_dominating_conditions (cond);\n-\t      record_cond (inverted, boolean_false_node);\n-\n-\t      if (TREE_CONSTANT (op1))\n-\t\trecord_range (cond, bb);\n-\n-\t\t/* If the conditional is of the form 'X == Y', return 'X = Y'\n-\t\t   for the true arm.  */\n-\t      if (TREE_CODE (cond) == EQ_EXPR)\n-\t\t{\n-\t\t  retval.dst = op0;\n-\t\t  retval.src = op1;\n-\t\t  return retval;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\n-\t      record_cond (inverted, boolean_true_node);\n-\t      record_dominating_conditions (inverted);\n-\t      record_cond (cond, boolean_false_node);\n-\n-\t      if (TREE_CONSTANT (op1))\n-\t\trecord_range (inverted, bb);\n-\n-\t\t/* If the conditional is of the form 'X != Y', return 'X = Y'\n-\t\t   for the false arm.  */\n-\t      if (TREE_CODE (cond) == NE_EXPR)\n-\t\t{\n-\t\t  retval.dst = op0;\n-\t\t  retval.src = op1;\n-\t\t  return retval;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  return retval;\n-}\n-\n /* Hashing and equality functions for VRP_DATA.\n \n    Since this hash table is addressed by SSA_NAMEs, we can hash on"}]}