{"sha": "dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJhYzRhZmZiNWU5N2JiMGRjNWZmNDhmMGI5NmJjODBhMTliZDE0NQ==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-04-01T07:48:59Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-04-01T07:48:59Z"}, "message": "cppexp.c: Redefine priority constants.\n\n        * cppexp.c: Redefine priority constants.\n        (_cpp_parse_expr): Replace left and right priority scheme with\n\tsingle priority logic.  Move LOGICAL to same place as COMPARE.\n\tRemove bogus check for multiple unary +/- operators.\n\nFrom-SVN: r32855", "tree": {"sha": "50f9267487cce187e52c03086e57dead13382197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f9267487cce187e52c03086e57dead13382197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145/comments", "author": null, "committer": null, "parents": [{"sha": "9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee70313bc999f044c8affc12e01ab41b8ccd6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee70313bc999f044c8affc12e01ab41b8ccd6c5"}], "stats": {"total": 148, "additions": 84, "deletions": 64}, "files": [{"sha": "92a7e0e9d58557e06d0f2d9fd1e3f19e05cb8abe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "patch": "@@ -1,3 +1,10 @@\n+2000-04-01  Neil Booth <NeilB@earthling.net>\n+\n+        * cppexp.c: Redefine priority constants.\n+        (_cpp_parse_expr): Replace left and right priority scheme with\n+\tsingle priority logic.  Move LOGICAL to same place as COMPARE.\n+\tRemove bogus check for multiple unary +/- operators.\n+\n 2000-04-01  Neil Booth <NeilB@earthling.net>\n \n         * cppexp.c: (_cpp_parse_expr): Numerical constants are pushed"}, {"sha": "01efa0e68f1924c1b1242c35b21df3772a77e8cf", "filename": "gcc/cppexp.c", "status": "modified", "additions": 77, "deletions": 64, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=dbac4affb5e97bb0dc5ff48f0b96bc80a19bd145", "patch": "@@ -106,7 +106,7 @@ static struct operation lex PARAMS ((cpp_reader *, int));\n struct operation\n {\n   short op;\n-  U_CHAR rprio; /* Priority of op (relative to it right operand).  */\n+  U_CHAR prio; /* Priority of op (relative to it right operand).  */\n   U_CHAR flags;\n   U_CHAR unsignedp;    /* true if value should be treated as unsigned */\n   HOST_WIDEST_INT value;        /* The value logically \"right\" of op.  */\n@@ -636,32 +636,60 @@ right_shift (pfile, a, unsignedp, b)\n     return a >> b;\n }\n \f\n-/* These priorities are all even, so we can handle associatively.  */\n-#define PAREN_INNER_PRIO 2\n-#define COMMA_PRIO 4\n-#define COND_PRIO (COMMA_PRIO+2)\n-#define OROR_PRIO (COND_PRIO+2)\n-#define ANDAND_PRIO (OROR_PRIO+2)\n-#define OR_PRIO (ANDAND_PRIO+2)\n-#define XOR_PRIO (OR_PRIO+2)\n-#define AND_PRIO (XOR_PRIO+2)\n-#define EQUAL_PRIO (AND_PRIO+2)\n-#define LESS_PRIO (EQUAL_PRIO+2)\n-#define SHIFT_PRIO (LESS_PRIO+2)\n-#define PLUS_PRIO (SHIFT_PRIO+2)\n-#define MUL_PRIO (PLUS_PRIO+2)\n-#define UNARY_PRIO (MUL_PRIO+2)\n-#define PAREN_OUTER_PRIO (UNARY_PRIO+2)\n+/* Operator precedence table.\n+\n+After an operator is returned from the lexer, if it has priority less\n+than or equal to the operator on the top of the stack, we reduce the\n+stack one operator and repeat the test.  As equal priorities reduce,\n+this is naturally left-associative.\n+\n+We handle right-associative operators by clearing the lower bit of all\n+left-associative operators, and setting it for right-associative ones.\n+After the reduction phase, when an operator is pushed onto the stack,\n+its RIGHT_ASSOC bit is cleared.  This means that at reduction time, a\n+right-associative operator of otherwise equal precedence to the\n+operator on the top of the stack will have a greater priority by 1,\n+avoiding a reduction pass and making the logic right-associative.\n+\n+The remaining cases are '(' and ')'.  We handle '(' by skipping the\n+reduction phase completely.  ')' is given lower priority than\n+everything else, including '(', effectively forcing a reduction of the\n+parenthesised expression.  If there is no matching '(', the expression\n+will be reduced to the beginning, the ')' pushed, and the reduction\n+pass forced by the next ')', or the end of the expression, will meet\n+it and output an appropriate error message.  */\n+\n+#define RIGHT_ASSOC               1\n+#define PREVENT_REDUCE_PRIO (0 << 1)\n+#define FORCE_REDUCE_PRIO   (1 << 1)\n+#define CLOSE_PAREN_PRIO    (2 << 1)\n+#define OPEN_PAREN_PRIO     (3 << 1)\n+#define COMMA_PRIO          (4 << 1)\n+#define COND_PRIO          ((5 << 1) + RIGHT_ASSOC)\n+#define COLON_PRIO          (6 << 1)\n+#define OROR_PRIO           (7 << 1)\n+#define ANDAND_PRIO         (8 << 1)\n+#define OR_PRIO             (9 << 1)\n+#define XOR_PRIO           (10 << 1)\n+#define AND_PRIO           (11 << 1)\n+#define EQUAL_PRIO         (12 << 1)\n+#define LESS_PRIO          (13 << 1)\n+#define SHIFT_PRIO         (14 << 1)\n+#define PLUS_PRIO          (15 << 1)\n+#define MUL_PRIO           (16 << 1)\n+#define UNARY_PRIO        ((17 << 1) + RIGHT_ASSOC)\n \n #define LEFT_OPERAND_REQUIRED 1\n #define RIGHT_OPERAND_REQUIRED 2\n #define HAVE_VALUE 4\n-#define SIGN_QUALIFIED 8\n \n #define COMPARE(OP) \\\n   top->unsignedp = 0;\\\n   top->value = (unsigned1 || unsigned2) \\\n   ? (unsigned HOST_WIDEST_INT) v1 OP (unsigned HOST_WIDEST_INT) v2 : (v1 OP v2)\n+#define LOGICAL(OP) \\\n+\t      top->value = v1 OP v2;\\\n+\t      top->unsignedp = unsigned1 || unsigned2;\n \n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n@@ -685,16 +713,16 @@ _cpp_parse_expr (pfile)\n   struct operation *stack = init_stack;\n   struct operation *limit = stack + INIT_STACK_SIZE;\n   register struct operation *top = stack;\n-  unsigned int lprio, rprio = 0;\n   int skip_evaluation = 0;\n   long old_written = CPP_WRITTEN (pfile);\n   int result;\n \n   pfile->parsing_if_directive++;\n-  top->rprio = 0;\n+  top->prio = PREVENT_REDUCE_PRIO;\n   top->flags = 0;\n   for (;;)\n     {\n+      unsigned int prio;\n       struct operation op;\n       U_CHAR flags = 0;\n \n@@ -730,59 +758,47 @@ _cpp_parse_expr (pfile)\n \t  continue;\n \n \tcase '+':  case '-':\n-\t  lprio = PLUS_PRIO;\n+\t  prio = PLUS_PRIO;\n \t  if (top->flags & HAVE_VALUE)\n \t      break;\n-\t  if (top->flags & SIGN_QUALIFIED)\n-\t    {\n-\t      cpp_error (pfile, \"more than one sign operator given\");\n-\t      goto syntax_error;\n-\t    }\n-\t  flags = SIGN_QUALIFIED;\n \t  /* else fall through */\n \tcase '!':  case '~':\n \t  flags |= RIGHT_OPERAND_REQUIRED;\n-\t  rprio = UNARY_PRIO;  lprio = rprio + 1;  goto maybe_reduce;\n-\n-\tcase '*':  case '/':  case '%':\n-\t  lprio = MUL_PRIO;  break;\n-\tcase '<':  case '>':  case LEQ:  case GEQ:\n-\t  lprio = LESS_PRIO;  break;\n-\tcase EQUAL:  case NOTEQUAL:\n-\t  lprio = EQUAL_PRIO;  break;\n-\tcase LSH:  case RSH:\n-\t  lprio = SHIFT_PRIO;  break;\n-\tcase '&':  lprio = AND_PRIO;  break;\n-\tcase '^':  lprio = XOR_PRIO;  break;\n-\tcase '|':  lprio = OR_PRIO;  break;\n-\tcase ANDAND:  lprio = ANDAND_PRIO;  break;\n-\tcase OROR:  lprio = OROR_PRIO;  break;\n-\tcase ',':\n-\t  lprio = COMMA_PRIO;  break;\n-\tcase '(':\n-\t  lprio = PAREN_OUTER_PRIO;  rprio = PAREN_INNER_PRIO + 1;\n-\t  goto skip_reduction;\n+\t  prio = UNARY_PRIO;  goto maybe_reduce;\n+\n+\tcase '*':\n+\tcase '/':\n+\tcase '%':    prio = MUL_PRIO;  break;\n+\tcase '<':\n+\tcase '>':\n+\tcase LEQ:\n+\tcase GEQ:    prio = LESS_PRIO;  break;\n+\tcase NOTEQUAL:\n+\tcase EQUAL:  prio = EQUAL_PRIO;  break;\n+\tcase LSH:\n+\tcase RSH:    prio = SHIFT_PRIO;  break;\n+\tcase '&':    prio = AND_PRIO;  break;\n+\tcase '^':    prio = XOR_PRIO;  break;\n+\tcase '|':    prio = OR_PRIO;  break;\n+\tcase ANDAND: prio = ANDAND_PRIO;  break;\n+\tcase OROR:   prio = OROR_PRIO;  break;\n+\tcase ',':    prio = COMMA_PRIO;  break;\n+\tcase '(':    prio = OPEN_PAREN_PRIO;  goto skip_reduction;\n \tcase ')':\n-\t  lprio = PAREN_INNER_PRIO;  rprio = PAREN_OUTER_PRIO;\n+\t  prio = CLOSE_PAREN_PRIO;\n \t  flags = HAVE_VALUE;\t/* At least, we will have after reduction.  */\n \t  goto maybe_reduce;\n-        case ':':\n-\t  lprio = COND_PRIO;  rprio = COND_PRIO + 1;\n-\t  goto maybe_reduce;\n-        case '?':\n-\t  lprio = COND_PRIO;  rprio = COND_PRIO;\n-\t  goto maybe_reduce;\n-\tcase 0:\n-\t  lprio = 0;  goto maybe_reduce;\n+        case ':':    prio = COLON_PRIO;  goto maybe_reduce;\n+        case '?':    prio = COND_PRIO;   goto maybe_reduce;\n+\tcase 0:      prio = FORCE_REDUCE_PRIO;  goto maybe_reduce;\n \t}\n \n       /* Binary operation.  */\n       flags = LEFT_OPERAND_REQUIRED|RIGHT_OPERAND_REQUIRED;\n-      rprio = lprio + 1;\n \n     maybe_reduce:\n-      /* Push an operator, and check if we can reduce now.  */\n-      while (top->rprio > lprio)\n+      /* Check for reductions.  Then push the operator.  */\n+      while (prio <= top->prio)\n \t{\n \t  HOST_WIDEST_INT v1 = top[-1].value, v2 = top[0].value;\n \t  unsigned int unsigned1 = top[-1].unsignedp;\n@@ -932,9 +948,6 @@ _cpp_parse_expr (pfile)\n \t      else\n \t\ttop->value = right_shift (pfile, v1, unsigned1, v2);\n \t      break;\n-#define LOGICAL(OP) \\\n-\t      top->value = v1 OP v2;\\\n-\t      top->unsignedp = unsigned1 || unsigned2;\n \t    case '&':  LOGICAL(&); break;\n \t    case '^':  LOGICAL(^);  break;\n \t    case '|':  LOGICAL(|);  break;\n@@ -953,7 +966,7 @@ _cpp_parse_expr (pfile)\n \t      top->unsignedp = unsigned2;\n \t      break;\n \t    case '?':\n-\t      cpp_error (pfile, \"syntax error in #if\");\n+\t      cpp_error (pfile, \"syntax error '?' without following ':'\");\n \t      goto syntax_error;\n \t    case ':':\n \t      if (top[0].op != '?')\n@@ -1027,7 +1040,7 @@ _cpp_parse_expr (pfile)\n \t}\n       \n       top->flags = flags;\n-      top->rprio = rprio;\n+      top->prio = prio & ~RIGHT_ASSOC;\n       top->op = op.op;\n \n       /* Handle short circuiting.  */"}]}