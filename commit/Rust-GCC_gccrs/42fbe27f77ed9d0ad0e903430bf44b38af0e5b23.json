{"sha": "42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmYmUyN2Y3N2VkOWQwYWQwZTkwMzQzMGJmNDRiMzhhZjBlNWIyMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-09-13T16:41:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-09-13T16:41:03Z"}, "message": "pa.c (emit_move_sequence): Handle secondary FP load/store reloads of the form (subreg (mem (plus (reg)...\n\n\t* pa.c (emit_move_sequence): Handle secondary FP load/store\n\treloads of the form (subreg (mem (plus (reg) (disp)))).\n\t(secondary_reload_class): A secondary register is needed to handle\n\tout-of-range FP loads and stores.\n\t* pa.md (reload_indf, reload_outdf): New expanders.\n\t(reload_insf, reload_outsf): Likewise.\n\nFrom-SVN: r8077", "tree": {"sha": "da4a763c7ddad2782f08e71d5c2e5d19eb0c8d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da4a763c7ddad2782f08e71d5c2e5d19eb0c8d92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23/comments", "author": null, "committer": null, "parents": [{"sha": "4b303b50bc9e1f6200952822a4bc7376c030ab05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b303b50bc9e1f6200952822a4bc7376c030ab05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b303b50bc9e1f6200952822a4bc7376c030ab05"}], "stats": {"total": 104, "additions": 95, "deletions": 9}, "files": [{"sha": "0e74080a19405eb145790f9e922c3a029c2c2280", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "patch": "@@ -769,26 +769,37 @@ emit_move_sequence (operands, mode, scratch_reg)\n   register rtx operand1 = operands[1];\n \n   /* Handle secondary reloads for loads/stores of FP registers from\n-     REG+D addresses where D does not fit in 5 bits.  */\n+     REG+D addresses where D does not fit in 5 bits, including \n+     (subreg (mem (addr)) cases.  */\n   if (fp_reg_operand (operand0, mode)\n-      && GET_CODE (operand1) == MEM\n-      /* Using DFmode forces only short displacements be be\n-\t recognized as valid in reg+d addressing modes.  */\n-      && ! memory_address_p (DFmode, XEXP (operand1, 0))\n+      && ((GET_CODE (operand1) == MEM\n+\t   && ! memory_address_p (DFmode, XEXP (operand1, 0)))\n+\t  || ((GET_CODE (operand1) == SUBREG\n+\t       && GET_CODE (XEXP (operand1, 0)) == MEM\n+\t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0)))))\n       && scratch_reg)\n     {\n+      if (GET_CODE (operand1) == SUBREG)\n+\toperand1 = XEXP (operand1, 0);\n+\n+      scratch_reg = gen_rtx (REG, SImode, REGNO (scratch_reg));\n       emit_move_insn (scratch_reg, XEXP (operand1, 0));\n       emit_insn (gen_rtx (SET, VOIDmode, operand0, gen_rtx (MEM, mode,\n \t\t\t\t\t\t\t    scratch_reg)));\n       return 1;\n     }\n   else if (fp_reg_operand (operand1, mode)\n-\t   && GET_CODE (operand0) == MEM\n-\t   /* Using DFmode forces only short displacements be be\n-\t      recognized as valid in reg+d addressing modes.  */\n-\t   && ! memory_address_p (DFmode, XEXP (operand0, 0))\n+\t   && ((GET_CODE (operand0) == MEM\n+\t\t&& ! memory_address_p (DFmode, XEXP (operand0, 0)))\n+\t       || ((GET_CODE (operand0) == SUBREG)\n+\t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n+\t\t   && !memory_address_p (DFmode, XEXP (XEXP (operand0, 0), 0))))\n \t   && scratch_reg)\n     {\n+      if (GET_CODE (operand0) == SUBREG)\n+\toperand0 = XEXP (operand0, 0);\n+\n+      scratch_reg = gen_rtx (REG, SImode, REGNO (scratch_reg));\n       emit_move_insn (scratch_reg, XEXP (operand0, 0));\n       emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (MEM, mode, scratch_reg),\n \t\t\t  operand1));\n@@ -3261,6 +3272,15 @@ secondary_reload_class (class, mode, in)\n   if (class != R1_REGS && symbolic_operand (in, VOIDmode))\n     return R1_REGS;\n \n+  if (GET_CODE (in) == SUBREG)\n+    in = SUBREG_REG (in);\n+\n+  if (FP_REG_CLASS_P (class)\n+      && GET_CODE (in) == MEM\n+      && !memory_address_p (DFmode, XEXP (in, 0))\n+      && memory_address_p (SImode, XEXP (in, 0)))\n+    return GENERAL_REGS;\n+\n   return NO_REGS;\n }\n "}, {"sha": "254f9082d3c22f9cd5c78361d853f178e0de95e6", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fbe27f77ed9d0ad0e903430bf44b38af0e5b23/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=42fbe27f77ed9d0ad0e903430bf44b38af0e5b23", "patch": "@@ -1480,6 +1480,39 @@\n     DONE;\n }\")\n \n+;; Reloading an SImode or DImode value requires a scratch register if\n+;; going in to or out of float point registers.\n+\n+(define_expand \"reload_indf\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=Z\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))\n+   (clobber (match_operand:DF 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1  \"register_operand\" \"Z\"))\n+   (clobber (match_operand:DF 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, DFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t  \"=f,*r,Q,?o,?Q,f,*&r,*&r\")\n@@ -1720,6 +1753,39 @@\n     DONE;\n }\")\n \n+;; Reloading an SImode or DImode value requires a scratch register if\n+;; going in to or out of float point registers.\n+\n+(define_expand \"reload_insf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=Z\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))\n+   (clobber (match_operand:SF 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_expand \"reload_outsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1  \"register_operand\" \"Z\"))\n+   (clobber (match_operand:SF 2 \"register_operand\" \"=&r\"))]\n+  \"\"\n+  \"\n+{\n+  if (emit_move_sequence (operands, SFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves.  */\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"reg_or_nonsymb_mem_operand\"\n \t\t\t  \"=f,r,f,r,Q,Q\")"}]}