{"sha": "724d568a1fd6821dc4dbfadbb8dc148a290397e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI0ZDU2OGExZmQ2ODIxZGM0ZGJmYWRiYjhkYzE0OGEyOTAzOTdlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1998-11-05T23:16:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-11-05T23:16:12Z"}, "message": "i386.md (extendsidi2): Use # in the output template.\n\n        * i386.md (extendsidi2): Use # in the output template.\n        (extendsidi splitters): New splitters.\n\nFrom-SVN: r23543", "tree": {"sha": "4f735782df99f95716f02d3f2122998800bc4bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f735782df99f95716f02d3f2122998800bc4bc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/724d568a1fd6821dc4dbfadbb8dc148a290397e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724d568a1fd6821dc4dbfadbb8dc148a290397e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/724d568a1fd6821dc4dbfadbb8dc148a290397e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724d568a1fd6821dc4dbfadbb8dc148a290397e5/comments", "author": null, "committer": null, "parents": [{"sha": "3fffed0742ce78ed0f8a19ad7231e2c43115885e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fffed0742ce78ed0f8a19ad7231e2c43115885e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fffed0742ce78ed0f8a19ad7231e2c43115885e"}], "stats": {"total": 89, "additions": 75, "deletions": 14}, "files": [{"sha": "2c66a79d4788d8536900408f20f6df9d3abf98f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724d568a1fd6821dc4dbfadbb8dc148a290397e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724d568a1fd6821dc4dbfadbb8dc148a290397e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=724d568a1fd6821dc4dbfadbb8dc148a290397e5", "patch": "@@ -1,3 +1,8 @@\n+Fri Nov  6 00:10:00 1998  Jan Hubicka (hubicka@freesoft.cz)\n+\n+\t* i386.md (extendsidi2): Use # in the output template.\n+\t(extendsidi splitters): New splitters.\n+\n Thu Nov  5 07:59:05 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* jump.c (init_label_info, delete_barrier_successors,"}, {"sha": "e1f026a005e2cb1c557aba6172f45af97963b96a", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 70, "deletions": 14, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724d568a1fd6821dc4dbfadbb8dc148a290397e5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724d568a1fd6821dc4dbfadbb8dc148a290397e5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=724d568a1fd6821dc4dbfadbb8dc148a290397e5", "patch": "@@ -2045,26 +2045,82 @@\n ;;- sign extension instructions\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=A,?r,?Ar,*o\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"0,0,r,*r\")))\n+   (clobber (match_scratch:SI 2 \"=X,X,X,&r\"))]\n   \"\"\n-  \"*\n+  \"#\")\n+\n+;; Extend to memory case when source register does die.\n+(define_split \n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"(flow2_completed\n+    && dead_or_set_p (insn, operands[1])\n+    && !reg_mentioned_p (operands[1], operands[0]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 1) (ashiftrt:SI (match_dup 1) (const_int 31)))\n+   (set (match_dup 4) (match_dup 1))]\n+  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+\n+;; Extend to memory case when source register does not die.\n+(define_split \n+  [(set (match_operand:DI 0 \"memory_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"\"))]\n+  \"flow2_completed\"\n+  [(const_int 0)]\n+  \"\n {\n-  if (REGNO (operands[0]) == 0)\n+  split_di (&operands[0], 1, &operands[3], &operands[4]);\n+\n+  emit_move_insn (operands[3], operands[1]);\n+\n+  /* Generate a cltd if possible and doing so it profitable.  */\n+  if (true_regnum (operands[1]) == 0\n+      && true_regnum (operands[2]) == 1\n+      && (optimize_size || !TARGET_PENTIUM))\n     {\n-      /* This used to be cwtl, but that extends HI to SI somehow.  */\n-#ifdef INTEL_SYNTAX\n-      return \\\"cdq\\\";\n-#else\n-      return \\\"cltd\\\";\n-#endif\n+      emit_insn (gen_ashrsi3_31 (operands[2], operands[1]));\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[2], operands[1]);\n+      emit_insn (gen_ashrsi3_31 (operands[2], operands[2]));\n+    }\n+  emit_move_insn (operands[4], operands[2]);\n+  DONE;\n+}\")\n+\n+;; Extend to register case.  Optimize case where source and destination\n+;; registers match and cases where we can use cltd.\n+(define_split \n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\")))\n+   (clobber (match_scratch:SI 2 \"\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  split_di (&operands[0], 1, &operands[3], &operands[4]);\n+\n+  if (true_regnum (operands[3]) != true_regnum (operands[1]))\n+    emit_move_insn (operands[3], operands[1]);\n+\n+  /* Generate a cltd if possible and doing so it profitable.  */\n+  if (true_regnum (operands[3]) == 0\n+      && (optimize_size || !TARGET_PENTIUM))\n+    {\n+      emit_insn (gen_ashrsi3_31 (operands[4], operands[3]));\n+      DONE;\n     }\n \n-  operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  output_asm_insn (AS2 (mov%L0,%0,%1), operands);\n+  if (true_regnum (operands[4]) != true_regnum (operands[1]))\n+    emit_move_insn (operands[4], operands[1]);\n \n-  operands[0] = GEN_INT (31);\n-  return AS2 (sar%L1,%0,%1);\n+  emit_insn (gen_ashrsi3_31 (operands[4], operands[4]));\n+  DONE;\n }\")\n \n ;; Note that the i386 programmers' manual says that the opcodes"}]}