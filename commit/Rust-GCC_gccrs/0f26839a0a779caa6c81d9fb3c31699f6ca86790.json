{"sha": "0f26839a0a779caa6c81d9fb3c31699f6ca86790", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyNjgzOWEwYTc3OWNhYTZjODFkOWZiM2MzMTY5OWY2Y2E4Njc5MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:13:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:13:50Z"}, "message": "Add an alternative vector loop iv mechanism\n\nNormally we adjust the vector loop so that it iterates:\n\n   (original number of scalar iterations - number of peels) / VF\n\ntimes, enforcing this using an IV that starts at zero and increments\nby one each iteration.  However, dividing by VF would be expensive\nfor variable VF, so this patch adds an alternative in which the IV\nincrements by VF each iteration instead.  We then need to take care\nto handle possible overflow in the IV.\n\nThe new mechanism isn't used yet; a later patch replaces the\n\"if (1)\" with a check for variable VF.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-loop-manip.c: Include gimple-fold.h.\n\t(slpeel_make_loop_iterate_ntimes): Add step, final_iv and\n\tniters_maybe_zero parameters.  Handle other cases besides a step of 1.\n\t(vect_gen_vector_loop_niters): Add a step_vector_ptr parameter.\n\tAdd a path that uses a step of VF instead of 1, but disable it\n\tfor now.\n\t(vect_do_peeling): Add step_vector, niters_vector_mult_vf_var\n\tand niters_no_overflow parameters.  Update calls to\n\tslpeel_make_loop_iterate_ntimes and vect_gen_vector_loop_niters.\n\tCreate a new SSA name if the latter choses to use a ste other\n\tthan zero, and return it via niters_vector_mult_vf_var.\n\t* tree-vect-loop.c (vect_transform_loop): Update calls to\n\tvect_do_peeling, vect_gen_vector_loop_niters and\n\tslpeel_make_loop_iterate_ntimes.\n\t* tree-vectorizer.h (slpeel_make_loop_iterate_ntimes, vect_do_peeling)\n\t(vect_gen_vector_loop_niters): Update declarations after above changes.\n\nFrom-SVN: r256124", "tree": {"sha": "44d57af69920980d1e40d40529a4068d5564c1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44d57af69920980d1e40d40529a4068d5564c1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f26839a0a779caa6c81d9fb3c31699f6ca86790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f26839a0a779caa6c81d9fb3c31699f6ca86790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f26839a0a779caa6c81d9fb3c31699f6ca86790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f26839a0a779caa6c81d9fb3c31699f6ca86790/comments", "author": null, "committer": null, "parents": [{"sha": "e50ffab340e299ad012490ee015e8e4f49c3da5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e50ffab340e299ad012490ee015e8e4f49c3da5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e50ffab340e299ad012490ee015e8e4f49c3da5d"}], "stats": {"total": 273, "additions": 223, "deletions": 50}, "files": [{"sha": "e0a2f3c0cc7ff154b7aae82e4f63235300bbb966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f26839a0a779caa6c81d9fb3c31699f6ca86790", "patch": "@@ -1,3 +1,22 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-loop-manip.c: Include gimple-fold.h.\n+\t(slpeel_make_loop_iterate_ntimes): Add step, final_iv and\n+\tniters_maybe_zero parameters.  Handle other cases besides a step of 1.\n+\t(vect_gen_vector_loop_niters): Add a step_vector_ptr parameter.\n+\tAdd a path that uses a step of VF instead of 1, but disable it\n+\tfor now.\n+\t(vect_do_peeling): Add step_vector, niters_vector_mult_vf_var\n+\tand niters_no_overflow parameters.  Update calls to\n+\tslpeel_make_loop_iterate_ntimes and vect_gen_vector_loop_niters.\n+\tCreate a new SSA name if the latter choses to use a ste other\n+\tthan zero, and return it via niters_vector_mult_vf_var.\n+\t* tree-vect-loop.c (vect_transform_loop): Update calls to\n+\tvect_do_peeling, vect_gen_vector_loop_niters and\n+\tslpeel_make_loop_iterate_ntimes.\n+\t* tree-vectorizer.h (slpeel_make_loop_iterate_ntimes, vect_do_peeling)\n+\t(vect_gen_vector_loop_niters): Update declarations after above changes.\n+\n 2018-01-02  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.md (floor<mode>2): Add support for IEEE"}, {"sha": "098b42874cdc82c271149778b7bb51e60290e884", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 180, "deletions": 40, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=0f26839a0a779caa6c81d9fb3c31699f6ca86790", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-ssa-loop-ivopts.h\"\n+#include \"gimple-fold.h\"\n \n /*************************************************************************\n   Simple Loop Peeling Utilities\n@@ -247,42 +248,126 @@ adjust_phi_and_debug_stmts (gimple *update_phi, edge e, tree new_def)\n \t\t\tgimple_bb (update_phi));\n }\n \n-/* Make the LOOP iterate NITERS times. This is done by adding a new IV\n-   that starts at zero, increases by one and its limit is NITERS.\n+/* Make LOOP iterate N == (NITERS - STEP) / STEP + 1 times,\n+   where NITERS is known to be outside the range [1, STEP - 1].\n+   This is equivalent to making the loop execute NITERS / STEP\n+   times when NITERS is nonzero and (1 << M) / STEP times otherwise,\n+   where M is the precision of NITERS.\n+\n+   NITERS_MAYBE_ZERO is true if NITERS can be zero, false it is known\n+   to be >= STEP.  In the latter case N is always NITERS / STEP.\n+\n+   If FINAL_IV is nonnull, it is an SSA name that should be set to\n+   N * STEP on exit from the loop.\n \n    Assumption: the exit-condition of LOOP is the last stmt in the loop.  */\n \n void\n-slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n+slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters, tree step,\n+\t\t\t\t tree final_iv, bool niters_maybe_zero)\n {\n   tree indx_before_incr, indx_after_incr;\n   gcond *cond_stmt;\n   gcond *orig_cond;\n+  edge pe = loop_preheader_edge (loop);\n   edge exit_edge = single_exit (loop);\n   gimple_stmt_iterator loop_cond_gsi;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n-  tree init = build_int_cst (TREE_TYPE (niters), 0);\n-  tree step = build_int_cst (TREE_TYPE (niters), 1);\n   source_location loop_loc;\n   enum tree_code code;\n+  tree niters_type = TREE_TYPE (niters);\n \n   orig_cond = get_loop_exit_condition (loop);\n   gcc_assert (orig_cond);\n   loop_cond_gsi = gsi_for_stmt (orig_cond);\n \n+  tree init, limit;\n+  if (!niters_maybe_zero && integer_onep (step))\n+    {\n+      /* In this case we can use a simple 0-based IV:\n+\n+\t A:\n+\t   x = 0;\n+\t   do\n+\t     {\n+\t       ...\n+\t       x += 1;\n+\t     }\n+\t   while (x < NITERS);  */\n+      code = (exit_edge->flags & EDGE_TRUE_VALUE) ? GE_EXPR : LT_EXPR;\n+      init = build_zero_cst (niters_type);\n+      limit = niters;\n+    }\n+  else\n+    {\n+      /* The following works for all values of NITERS except 0:\n+\n+\t B:\n+\t   x = 0;\n+\t   do\n+\t     {\n+\t       ...\n+\t       x += STEP;\n+\t     }\n+\t   while (x <= NITERS - STEP);\n+\n+\t so that the loop continues to iterate if x + STEP - 1 < NITERS\n+\t but stops if x + STEP - 1 >= NITERS.\n+\n+\t However, if NITERS is zero, x never hits a value above NITERS - STEP\n+\t before wrapping around.  There are two obvious ways of dealing with\n+\t this:\n+\n+\t - start at STEP - 1 and compare x before incrementing it\n+\t - start at -1 and compare x after incrementing it\n+\n+\t The latter is simpler and is what we use.  The loop in this case\n+\t looks like:\n+\n+\t C:\n+\t   x = -1;\n+\t   do\n+\t     {\n+\t       ...\n+\t       x += STEP;\n+\t     }\n+\t   while (x < NITERS - STEP);\n+\n+\t In both cases the loop limit is NITERS - STEP.  */\n+      gimple_seq seq = NULL;\n+      limit = force_gimple_operand (niters, &seq, true, NULL_TREE);\n+      limit = gimple_build (&seq, MINUS_EXPR, TREE_TYPE (limit), limit, step);\n+      if (seq)\n+\t{\n+\t  basic_block new_bb = gsi_insert_seq_on_edge_immediate (pe, seq);\n+\t  gcc_assert (!new_bb);\n+\t}\n+      if (niters_maybe_zero)\n+\t{\n+\t  /* Case C.  */\n+\t  code = (exit_edge->flags & EDGE_TRUE_VALUE) ? GE_EXPR : LT_EXPR;\n+\t  init = build_all_ones_cst (niters_type);\n+\t}\n+      else\n+\t{\n+\t  /* Case B.  */\n+\t  code = (exit_edge->flags & EDGE_TRUE_VALUE) ? GT_EXPR : LE_EXPR;\n+\t  init = build_zero_cst (niters_type);\n+\t}\n+    }\n+\n   standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n   create_iv (init, step, NULL_TREE, loop,\n              &incr_gsi, insert_after, &indx_before_incr, &indx_after_incr);\n \n   indx_after_incr = force_gimple_operand_gsi (&loop_cond_gsi, indx_after_incr,\n \t\t\t\t\t      true, NULL_TREE, true,\n \t\t\t\t\t      GSI_SAME_STMT);\n-  niters = force_gimple_operand_gsi (&loop_cond_gsi, niters, true, NULL_TREE,\n+  limit = force_gimple_operand_gsi (&loop_cond_gsi, limit, true, NULL_TREE,\n \t\t\t\t     true, GSI_SAME_STMT);\n \n-  code = (exit_edge->flags & EDGE_TRUE_VALUE) ? GE_EXPR : LT_EXPR;\n-  cond_stmt = gimple_build_cond (code, indx_after_incr, niters, NULL_TREE,\n+  cond_stmt = gimple_build_cond (code, indx_after_incr, limit, NULL_TREE,\n \t\t\t\t NULL_TREE);\n \n   gsi_insert_before (&loop_cond_gsi, cond_stmt, GSI_SAME_STMT);\n@@ -301,8 +386,23 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n     }\n \n   /* Record the number of latch iterations.  */\n-  loop->nb_iterations = fold_build2 (MINUS_EXPR, TREE_TYPE (niters), niters,\n-\t\t\t\t     build_int_cst (TREE_TYPE (niters), 1));\n+  if (limit == niters)\n+    /* Case A: the loop iterates NITERS times.  Subtract one to get the\n+       latch count.  */\n+    loop->nb_iterations = fold_build2 (MINUS_EXPR, niters_type, niters,\n+\t\t\t\t       build_int_cst (niters_type, 1));\n+  else\n+    /* Case B or C: the loop iterates (NITERS - STEP) / STEP + 1 times.\n+       Subtract one from this to get the latch count.  */\n+    loop->nb_iterations = fold_build2 (TRUNC_DIV_EXPR, niters_type,\n+\t\t\t\t       limit, step);\n+\n+  if (final_iv)\n+    {\n+      gassign *assign = gimple_build_assign (final_iv, MINUS_EXPR,\n+\t\t\t\t\t     indx_after_incr, init);\n+      gsi_insert_on_edge_immediate (single_exit (loop), assign);\n+    }\n }\n \n /* Helper routine of slpeel_tree_duplicate_loop_to_edge_cfg.\n@@ -1169,23 +1269,32 @@ vect_gen_scalar_loop_niters (tree niters_prolog, int int_niters_prolog,\n   return niters;\n }\n \n-/* This function generates the following statements:\n+/* NITERS is the number of times that the original scalar loop executes\n+   after peeling.  Work out the maximum number of iterations N that can\n+   be handled by the vectorized form of the loop and then either:\n \n-   niters = number of iterations loop executes (after peeling)\n-   niters_vector = niters / vf\n+   a) set *STEP_VECTOR_PTR to the vectorization factor and generate:\n \n-   and places them on the loop preheader edge.  NITERS_NO_OVERFLOW is\n-   true if NITERS doesn't overflow.  */\n+\tniters_vector = N\n+\n+   b) set *STEP_VECTOR_PTR to one and generate:\n+\n+        niters_vector = N / vf\n+\n+   In both cases, store niters_vector in *NITERS_VECTOR_PTR and add\n+   any new statements on the loop preheader edge.  NITERS_NO_OVERFLOW\n+   is true if NITERS doesn't overflow (i.e. if NITERS is always nonzero).  */\n \n void\n vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n-\t\t\t     tree *niters_vector_ptr, bool niters_no_overflow)\n+\t\t\t     tree *niters_vector_ptr, tree *step_vector_ptr,\n+\t\t\t     bool niters_no_overflow)\n {\n   tree ni_minus_gap, var;\n-  tree niters_vector, type = TREE_TYPE (niters);\n+  tree niters_vector, step_vector, type = TREE_TYPE (niters);\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   edge pe = loop_preheader_edge (LOOP_VINFO_LOOP (loop_vinfo));\n-  tree log_vf = build_int_cst (type, exact_log2 (vf));\n+  tree log_vf = NULL_TREE;\n \n   /* If epilogue loop is required because of data accesses with gaps, we\n      subtract one iteration from the total number of iterations here for\n@@ -1206,21 +1315,32 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n   else\n     ni_minus_gap = niters;\n \n-  /* Create: niters >> log2(vf) */\n-  /* If it's known that niters == number of latch executions + 1 doesn't\n-     overflow, we can generate niters >> log2(vf); otherwise we generate\n-     (niters - vf) >> log2(vf) + 1 by using the fact that we know ratio\n-     will be at least one.  */\n-  if (niters_no_overflow)\n-    niters_vector = fold_build2 (RSHIFT_EXPR, type, ni_minus_gap, log_vf);\n+  if (1)\n+    {\n+      /* Create: niters >> log2(vf) */\n+      /* If it's known that niters == number of latch executions + 1 doesn't\n+\t overflow, we can generate niters >> log2(vf); otherwise we generate\n+\t (niters - vf) >> log2(vf) + 1 by using the fact that we know ratio\n+\t will be at least one.  */\n+      log_vf = build_int_cst (type, exact_log2 (vf));\n+      if (niters_no_overflow)\n+\tniters_vector = fold_build2 (RSHIFT_EXPR, type, ni_minus_gap, log_vf);\n+      else\n+\tniters_vector\n+\t  = fold_build2 (PLUS_EXPR, type,\n+\t\t\t fold_build2 (RSHIFT_EXPR, type,\n+\t\t\t\t      fold_build2 (MINUS_EXPR, type,\n+\t\t\t\t\t\t   ni_minus_gap,\n+\t\t\t\t\t\t   build_int_cst (type, vf)),\n+\t\t\t\t      log_vf),\n+\t\t\t build_int_cst (type, 1));\n+      step_vector = build_one_cst (type);\n+    }\n   else\n-    niters_vector\n-      = fold_build2 (PLUS_EXPR, type,\n-\t\t     fold_build2 (RSHIFT_EXPR, type,\n-\t\t\t\t  fold_build2 (MINUS_EXPR, type, ni_minus_gap,\n-\t\t\t\t\t       build_int_cst (type, vf)),\n-\t\t\t\t  log_vf),\n-\t\t     build_int_cst (type, 1));\n+    {\n+      niters_vector = ni_minus_gap;\n+      step_vector = build_int_cst (type, vf);\n+    }\n \n   if (!is_gimple_val (niters_vector))\n     {\n@@ -1230,14 +1350,15 @@ vect_gen_vector_loop_niters (loop_vec_info loop_vinfo, tree niters,\n       gsi_insert_seq_on_edge_immediate (pe, stmts);\n       /* Peeling algorithm guarantees that vector loop bound is at least ONE,\n \t we set range information to make niters analyzer's life easier.  */\n-      if (stmts != NULL)\n+      if (stmts != NULL && log_vf)\n \tset_range_info (niters_vector, VR_RANGE,\n \t\t\twi::to_wide (build_int_cst (type, 1)),\n \t\t\twi::to_wide (fold_build2 (RSHIFT_EXPR, type,\n \t\t\t\t\t\t  TYPE_MAX_VALUE (type),\n \t\t\t\t\t\t  log_vf)));\n     }\n   *niters_vector_ptr = niters_vector;\n+  *step_vector_ptr = step_vector;\n \n   return;\n }\n@@ -1599,7 +1720,12 @@ slpeel_update_phi_nodes_for_lcssa (struct loop *epilog)\n    - TH, CHECK_PROFITABILITY: Threshold of niters to vectorize loop if\n \t\t\t      CHECK_PROFITABILITY is true.\n    Output:\n-   - NITERS_VECTOR: The number of iterations of loop after vectorization.\n+   - *NITERS_VECTOR and *STEP_VECTOR describe how the main loop should\n+     iterate after vectorization; see slpeel_make_loop_iterate_ntimes\n+     for details.\n+   - *NITERS_VECTOR_MULT_VF_VAR is either null or an SSA name that\n+     should be set to the number of scalar iterations handled by the\n+     vector loop.  The SSA name is only used on exit from the loop.\n \n    This function peels prolog and epilog from the loop, adds guards skipping\n    PROLOG and EPILOG for various conditions.  As a result, the changed CFG\n@@ -1656,8 +1782,9 @@ slpeel_update_phi_nodes_for_lcssa (struct loop *epilog)\n \n struct loop *\n vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n-\t\t tree *niters_vector, int th, bool check_profitability,\n-\t\t bool niters_no_overflow)\n+\t\t tree *niters_vector, tree *step_vector,\n+\t\t tree *niters_vector_mult_vf_var, int th,\n+\t\t bool check_profitability, bool niters_no_overflow)\n {\n   edge e, guard_e;\n   tree type = TREE_TYPE (niters), guard_cond;\n@@ -1753,7 +1880,9 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n       /* Generate and update the number of iterations for prolog loop.  */\n       niters_prolog = vect_gen_prolog_loop_niters (loop_vinfo, anchor,\n \t\t\t\t\t\t   &bound_prolog);\n-      slpeel_make_loop_iterate_ntimes (prolog, niters_prolog);\n+      tree step_prolog = build_one_cst (TREE_TYPE (niters_prolog));\n+      slpeel_make_loop_iterate_ntimes (prolog, niters_prolog, step_prolog,\n+\t\t\t\t       NULL_TREE, false);\n \n       /* Skip the prolog loop.  */\n       if (skip_prolog)\n@@ -1866,9 +1995,20 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t overflows.  */\n       niters_no_overflow |= (prolog_peeling > 0);\n       vect_gen_vector_loop_niters (loop_vinfo, niters,\n-\t\t\t\t   niters_vector, niters_no_overflow);\n-      vect_gen_vector_loop_niters_mult_vf (loop_vinfo, *niters_vector,\n-\t\t\t\t\t   &niters_vector_mult_vf);\n+\t\t\t\t   niters_vector, step_vector,\n+\t\t\t\t   niters_no_overflow);\n+      if (!integer_onep (*step_vector))\n+\t{\n+\t  /* On exit from the loop we will have an easy way of calcalating\n+\t     NITERS_VECTOR / STEP * STEP.  Install a dummy definition\n+\t     until then.  */\n+\t  niters_vector_mult_vf = make_ssa_name (TREE_TYPE (*niters_vector));\n+\t  SSA_NAME_DEF_STMT (niters_vector_mult_vf) = gimple_build_nop ();\n+\t  *niters_vector_mult_vf_var = niters_vector_mult_vf;\n+\t}\n+      else\n+\tvect_gen_vector_loop_niters_mult_vf (loop_vinfo, *niters_vector,\n+\t\t\t\t\t     &niters_vector_mult_vf);\n       /* Update IVs of original loop as if they were advanced by\n \t niters_vector_mult_vf steps.  */\n       gcc_checking_assert (vect_can_advance_ivs_p (loop_vinfo));"}, {"sha": "ddb8841b11e22d94b9b04b1ed73348cc4805f7bd", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0f26839a0a779caa6c81d9fb3c31699f6ca86790", "patch": "@@ -7334,7 +7334,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n   int i;\n-  tree niters_vector = NULL;\n+  tree niters_vector = NULL_TREE;\n+  tree step_vector = NULL_TREE;\n+  tree niters_vector_mult_vf = NULL_TREE;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   bool grouped_store;\n   bool slp_scheduled = false;\n@@ -7413,17 +7415,21 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = niters;\n   tree nitersm1 = unshare_expr (LOOP_VINFO_NITERSM1 (loop_vinfo));\n   bool niters_no_overflow = loop_niters_no_overflow (loop_vinfo);\n-  epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector, th,\n+  epilogue = vect_do_peeling (loop_vinfo, niters, nitersm1, &niters_vector,\n+\t\t\t      &step_vector, &niters_vector_mult_vf, th,\n \t\t\t      check_profitability, niters_no_overflow);\n   if (niters_vector == NULL_TREE)\n     {\n       if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-\tniters_vector\n-\t  = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n-\t\t\t   LOOP_VINFO_INT_NITERS (loop_vinfo) / vf);\n+\t{\n+\t  niters_vector\n+\t    = build_int_cst (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)),\n+\t\t\t     LOOP_VINFO_INT_NITERS (loop_vinfo) / vf);\n+\t  step_vector = build_one_cst (TREE_TYPE (niters));\n+\t}\n       else\n \tvect_gen_vector_loop_niters (loop_vinfo, niters, &niters_vector,\n-\t\t\t\t     niters_no_overflow);\n+\t\t\t\t     &step_vector, niters_no_overflow);\n     }\n \n   /* 1) Make sure the loop header has exactly two entries\n@@ -7674,7 +7680,13 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */\n \n-  slpeel_make_loop_iterate_ntimes (loop, niters_vector);\n+  /* The vectorization factor is always > 1, so if we use an IV increment of 1.\n+     a zero NITERS becomes a nonzero NITERS_VECTOR.  */\n+  if (integer_onep (step_vector))\n+    niters_no_overflow = true;\n+  slpeel_make_loop_iterate_ntimes (loop, niters_vector, step_vector,\n+\t\t\t\t   niters_vector_mult_vf,\n+\t\t\t\t   !niters_no_overflow);\n \n   scale_profile_for_vect_loop (loop, vf);\n "}, {"sha": "22bbc9a9abc9ebc128505bdd6ab0621e74bc82bb", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f26839a0a779caa6c81d9fb3c31699f6ca86790/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0f26839a0a779caa6c81d9fb3c31699f6ca86790", "patch": "@@ -1145,14 +1145,15 @@ extern source_location vect_location;\n \n /* Simple loop peeling and versioning utilities for vectorizer's purposes -\n    in tree-vect-loop-manip.c.  */\n-extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n+extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree, tree,\n+\t\t\t\t\t     tree, bool);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *,\n \t\t\t\t\t\t     struct loop *, edge);\n extern void vect_loop_versioning (loop_vec_info, unsigned int, bool,\n \t\t\t\t  poly_uint64);\n extern struct loop *vect_do_peeling (loop_vec_info, tree, tree,\n-\t\t\t\t     tree *, int, bool, bool);\n+\t\t\t\t     tree *, tree *, tree *, int, bool, bool);\n extern source_location find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n@@ -1269,7 +1270,8 @@ extern bool check_reduction_path (location_t, loop_p, gphi *, tree,\n /* Drive for loop analysis stage.  */\n extern loop_vec_info vect_analyze_loop (struct loop *, loop_vec_info);\n extern tree vect_build_loop_niters (loop_vec_info, bool * = NULL);\n-extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *, bool);\n+extern void vect_gen_vector_loop_niters (loop_vec_info, tree, tree *,\n+\t\t\t\t\t tree *, bool);\n /* Drive for loop transformation stage.  */\n extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);"}]}