{"sha": "8b941eec31d98619765dec95929a2a86058d5843", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5NDFlZWMzMWQ5ODYxOTc2NWRlYzk1OTI5YTJhODYwNThkNTg0Mw==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-29T16:07:59Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-29T16:07:59Z"}, "message": "[multiple changes]\n\n2003-10-29  Mark Wielaard  <mark@klomp.org>\n\n\tFrom Guilhem Lavaux  <guilhem.lavaux@free.fr>\n\t* java/text/DateFormat.java (Field): New public static inner class.\n\t* java/text/Format.java (Field): Likewise.\n\t(formatToCharacterIterator): New method.\n\t* java/text/FormatCharacterIterator.java: New file.\n\n2003-10-29  Mark Wielaard  <mark@klomp.org>\n\n\tFrom Guilhem Lavaux  <guilhem.lavaux@free.fr>\n\t* java/util/Currency.java: New file.\n\n2003-10-29  Michael Koch  <konqueror@gmx.de>\n\n\t* Makefile.am (ordinary_java_source_files): Added\n\tjava/text/FormatCharacterIterator.java and java/util/Currency.java.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r73046", "tree": {"sha": "3daf7421c0a1ddab3baedb562dd3045d24afbb98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3daf7421c0a1ddab3baedb562dd3045d24afbb98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b941eec31d98619765dec95929a2a86058d5843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b941eec31d98619765dec95929a2a86058d5843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b941eec31d98619765dec95929a2a86058d5843", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b941eec31d98619765dec95929a2a86058d5843/comments", "author": null, "committer": null, "parents": [{"sha": "f2225d74aa785e72bf706dc836e5010f70ca0542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2225d74aa785e72bf706dc836e5010f70ca0542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2225d74aa785e72bf706dc836e5010f70ca0542"}], "stats": {"total": 760, "additions": 747, "deletions": 13}, "files": [{"sha": "778ee8404af160135a4518c9b0af377bc60a111d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -1,3 +1,22 @@\n+2003-10-29  Mark Wielaard  <mark@klomp.org>\n+\n+\tFrom Guilhem Lavaux  <guilhem.lavaux@free.fr>\n+\t* java/text/DateFormat.java (Field): New public static inner class.\n+\t* java/text/Format.java (Field): Likewise.\n+\t(formatToCharacterIterator): New method.\n+\t* java/text/FormatCharacterIterator.java: New file.\n+\n+2003-10-29  Mark Wielaard  <mark@klomp.org>\n+\n+\tFrom Guilhem Lavaux  <guilhem.lavaux@free.fr>\n+\t* java/util/Currency.java: New file.\n+\n+2003-10-29  Michael Koch  <konqueror@gmx.de>\n+\n+\t* Makefile.am (ordinary_java_source_files): Added\n+\tjava/text/FormatCharacterIterator.java and java/util/Currency.java.\n+\t* Makefile.in: Regenerated.\n+\n 2003-10-29  Dalibor Topic  <robilad@kaffe.org>\n \n \t* gnu/java/beans/IntrospectionIncubator.java (addMethod): Add public"}, {"sha": "569babb7a0c8c35c6d03a07f8c05b597bf7a7dd0", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -1942,6 +1942,7 @@ java/util/Collection.java \\\n java/util/Collections.java \\\n java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n+java/util/Currency.java \\\n java/util/Date.java \\\n java/util/Dictionary.java \\\n java/util/EmptyStackException.java \\\n@@ -2580,6 +2581,7 @@ java/text/DecimalFormat.java \\\n java/text/DecimalFormatSymbols.java \\\n java/text/FieldPosition.java \\\n java/text/Format.java \\\n+java/text/FormatCharacterIterator.java \\\n java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\"}, {"sha": "da479ca9f73b388f02ea2cf0910888a9f3903061", "filename": "libjava/Makefile.in", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -1664,6 +1664,7 @@ java/util/Collection.java \\\n java/util/Collections.java \\\n java/util/Comparator.java \\\n java/util/ConcurrentModificationException.java \\\n+java/util/Currency.java \\\n java/util/Date.java \\\n java/util/Dictionary.java \\\n java/util/EmptyStackException.java \\\n@@ -2297,6 +2298,7 @@ java/text/DecimalFormat.java \\\n java/text/DecimalFormatSymbols.java \\\n java/text/FieldPosition.java \\\n java/text/Format.java \\\n+java/text/FormatCharacterIterator.java \\\n java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\\n@@ -3831,6 +3833,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/text/DateFormat.P .deps/java/text/DateFormatSymbols.P \\\n .deps/java/text/DecimalFormat.P .deps/java/text/DecimalFormatSymbols.P \\\n .deps/java/text/FieldPosition.P .deps/java/text/Format.P \\\n+.deps/java/text/FormatCharacterIterator.P \\\n .deps/java/text/MessageFormat.P .deps/java/text/NumberFormat.P \\\n .deps/java/text/ParseException.P .deps/java/text/ParsePosition.P \\\n .deps/java/text/RuleBasedCollator.P .deps/java/text/SimpleDateFormat.P \\\n@@ -3842,17 +3845,18 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n .deps/java/util/Collections.P .deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n-.deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n-.deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n-.deps/java/util/EventListener.P .deps/java/util/EventListenerProxy.P \\\n-.deps/java/util/EventObject.P .deps/java/util/GregorianCalendar.P \\\n-.deps/java/util/HashMap.P .deps/java/util/HashSet.P \\\n-.deps/java/util/Hashtable.P .deps/java/util/IdentityHashMap.P \\\n-.deps/java/util/Iterator.P .deps/java/util/LinkedHashMap.P \\\n-.deps/java/util/LinkedHashSet.P .deps/java/util/LinkedList.P \\\n-.deps/java/util/List.P .deps/java/util/ListIterator.P \\\n-.deps/java/util/ListResourceBundle.P .deps/java/util/Locale.P \\\n-.deps/java/util/Map.P .deps/java/util/MissingResourceException.P \\\n+.deps/java/util/Currency.P .deps/java/util/Date.P \\\n+.deps/java/util/Dictionary.P .deps/java/util/EmptyStackException.P \\\n+.deps/java/util/Enumeration.P .deps/java/util/EventListener.P \\\n+.deps/java/util/EventListenerProxy.P .deps/java/util/EventObject.P \\\n+.deps/java/util/GregorianCalendar.P .deps/java/util/HashMap.P \\\n+.deps/java/util/HashSet.P .deps/java/util/Hashtable.P \\\n+.deps/java/util/IdentityHashMap.P .deps/java/util/Iterator.P \\\n+.deps/java/util/LinkedHashMap.P .deps/java/util/LinkedHashSet.P \\\n+.deps/java/util/LinkedList.P .deps/java/util/List.P \\\n+.deps/java/util/ListIterator.P .deps/java/util/ListResourceBundle.P \\\n+.deps/java/util/Locale.P .deps/java/util/Map.P \\\n+.deps/java/util/MissingResourceException.P \\\n .deps/java/util/NoSuchElementException.P .deps/java/util/Observable.P \\\n .deps/java/util/Observer.P .deps/java/util/Properties.P \\\n .deps/java/util/PropertyPermission.P \\"}, {"sha": "bf4c2c8d6e034d07ea309a924de39bbb9141a36f", "filename": "libjava/java/text/DateFormat.java", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormat.java?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -1,5 +1,5 @@\n /* DateFormat.java -- Class for formatting/parsing date/times\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,6 +39,7 @@\n package java.text;\n \n import java.util.*;\n+import java.io.InvalidObjectException;\n \n /**\n  * @author Per Bothner <bothner@cygnus.com>\n@@ -86,6 +87,97 @@ public abstract class DateFormat extends Format implements Cloneable\n   public static final int HOUR0_FIELD = 16;\n   public static final int TIMEZONE_FIELD = 17;\n \n+\n+  public static class Field extends Format.Field\n+  {\n+    static final long serialVersionUID = 7441350119349544720L;\n+    \n+    private int calendarField;\n+\n+    public static final DateFormat.Field ERA\n+\t= new Field(\"era\", Calendar.ERA);\n+    public static final DateFormat.Field YEAR\n+\t= new Field(\"year\", Calendar.YEAR);\n+    public static final DateFormat.Field MONTH\n+\t= new Field(\"month\", Calendar.MONTH);\n+    public static final DateFormat.Field DAY_OF_MONTH\n+\t= new Field(\"day of month\", Calendar.DAY_OF_MONTH);\n+    public static final DateFormat.Field HOUR_OF_DAY1\n+\t= new Field(\"hour of day 1\", Calendar.HOUR_OF_DAY);\n+    public static final DateFormat.Field HOUR_OF_DAY0\n+\t= new Field(\"hour of day 0\", Calendar.HOUR_OF_DAY);\n+    public static final DateFormat.Field MINUTE\n+\t= new Field(\"minute\", Calendar.MINUTE);\n+    public static final DateFormat.Field SECOND\n+\t= new Field(\"second\", Calendar.SECOND);\n+    public static final DateFormat.Field MILLISECOND\n+\t= new Field(\"millisecond\", Calendar.MILLISECOND);\n+    public static final DateFormat.Field DAY_OF_WEEK\n+\t= new Field(\"day of week\", Calendar.DAY_OF_WEEK);\n+    public static final DateFormat.Field DAY_OF_YEAR\n+\t= new Field(\"day of year\", Calendar.DAY_OF_YEAR);\n+    public static final DateFormat.Field DAY_OF_WEEK_IN_MONTH\n+\t= new Field(\"day of week in month\", Calendar.DAY_OF_WEEK_IN_MONTH);\n+    public static final DateFormat.Field WEEK_OF_YEAR\n+\t= new Field(\"week of year\", Calendar.WEEK_OF_YEAR);\n+    public static final DateFormat.Field WEEK_OF_MONTH\n+\t= new Field(\"week of month\", Calendar.WEEK_OF_MONTH);\n+    public static final DateFormat.Field AM_PM\n+\t= new Field(\"am/pm\", Calendar.AM_PM);\n+    public static final DateFormat.Field HOUR1\n+\t= new Field(\"hour1\", Calendar.HOUR);\n+    public static final DateFormat.Field HOUR0\n+\t= new Field(\"hour0\", Calendar.HOUR);\n+    public static final DateFormat.Field TIME_ZONE\n+\t= new Field(\"timezone\", Calendar.ZONE_OFFSET);\n+ \n+    public static final DateFormat.Field[] allFields =\n+    {\n+      ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY1,\n+      HOUR_OF_DAY0, MINUTE, SECOND, MILLISECOND,\n+      DAY_OF_WEEK, DAY_OF_YEAR, DAY_OF_WEEK_IN_MONTH,\n+      WEEK_OF_YEAR, WEEK_OF_MONTH, AM_PM, HOUR1, HOUR0,\n+      TIME_ZONE\n+    };\n+\n+    // For deserialization\n+    private Field()\n+    {\n+      super(\"\");\n+    }\n+\n+    protected Field(String name, int calendarField)\n+    {\n+      super(name);\n+      this.calendarField = calendarField;\n+    }\n+    \n+    public int getCalendarField()\n+    {\n+      return calendarField;\n+    }\n+\n+    public static Field ofCalendarField(int calendarField)\n+    {\n+      if (calendarField >= allFields.length || calendarField < 0)\n+\tthrow new IllegalArgumentException(\"no such calendar field (\"\n+\t\t\t\t\t   + calendarField + \")\");\n+      \n+      return allFields[calendarField];\n+    }\n+    \n+    protected Object readResolve() throws InvalidObjectException\n+    {\n+      String s = getName();\n+\n+      for (int i=0;i<allFields.length;i++)\n+\tif (s.equals(allFields[i].getName()))\n+\t  return allFields[i];\n+      \n+      throw new InvalidObjectException(\"no such DateFormat field called \" + s);\n+    }\n+  }\n+\n   /**\n    * This method initializes a new instance of <code>DateFormat</code>.\n    */\n@@ -152,7 +244,9 @@ public final StringBuffer format (Object obj,\n     if (obj instanceof Number)\n       obj = new Date(((Number) obj).longValue());\n     else if (! (obj instanceof Date))\n-      throw new IllegalArgumentException (\"Cannot format given Object as a Date\");\n+      throw new IllegalArgumentException\n+\t(\"Cannot format given Object as a Date\");\n+\n     return format ((Date) obj, buf, pos);\n   }\n "}, {"sha": "8dae1872fd3c5a7eb1e44dc31ff8fcba6578d841", "filename": "libjava/java/text/DecimalFormat.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FDecimalFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDecimalFormat.java?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -202,6 +202,8 @@ else if (c == syms.getDigit())\n \t      }\n \t    else if (c != syms.getExponential()\n \t\t     && c != syms.getPatternSeparator()\n+\t\t     && c != syms.getPercent()\n+\t\t     && c != syms.getPerMill()\n \t\t     && patChars.indexOf(c) != -1)\n \t      throw new IllegalArgumentException (\"unexpected special \" +\n \t\t\t\t\t\t  \"character - index: \" + index);"}, {"sha": "ba32cae25bc796e24f37ca85a1875ebef59afe4c", "filename": "libjava/java/text/Format.java", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormat.java?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -38,6 +38,10 @@\n \n package java.text;\n \n+import java.util.Set;\n+import java.util.Map;\n+import java.util.HashSet;\n+import java.util.HashMap;\n import java.io.Serializable;\n \n /**\n@@ -61,6 +65,16 @@ public abstract class Format implements Serializable, Cloneable\n {\n   static final long serialVersionUID = 4479235611355683992L;\n \n+  public static class Field extends AttributedCharacterIterator.Attribute\n+  {\n+    static final long serialVersionUID = 276966692217360283L;\n+   \n+    public Field(String name)\n+    {\n+      super(name);\n+    }\n+  }\n+  \n   /**\n    * This method initializes a new instance of <code>Format</code>.\n    * It performs no actions, but acts as a default constructor for\n@@ -142,6 +156,11 @@ public Object parseObject (String str) throws ParseException\n    */\n   public abstract Object parseObject (String str, ParsePosition pos);\n \n+  public AttributedCharacterIterator formatToCharacterIterator(Object obj)\n+  {\n+    return new FormatCharacterIterator(format(obj), null, null);\n+  }\n+\n   /**\n    * Creates a copy of this object.\n    *"}, {"sha": "8693707715c0ae814de023a70bbbe65f587dd510", "filename": "libjava/java/text/FormatCharacterIterator.java", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormatCharacterIterator.java?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -0,0 +1,405 @@\n+/* FormatCharacter.java -- Implementation of AttributedCharacterIterator for \n+   formatters.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+package java.text;\n+\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Vector;\n+\n+class FormatCharacterIterator implements AttributedCharacterIterator\n+{\n+  private String formattedString;\n+  private int charIndex;\n+  private int attributeIndex;\n+  private int[] ranges;\n+  private HashMap[] attributes;\n+  \n+  FormatCharacterIterator()\n+  {\n+    formattedString = \"\";\n+    ranges = new int[0];\n+    attributes = new HashMap[0];\n+  }\n+\n+  FormatCharacterIterator(String s, int[] ranges, HashMap[] attributes)\n+  {\n+    formattedString = s;\n+    this.ranges = ranges;\n+    this.attributes = attributes;\n+  }\n+  \n+  /*\n+   * -----------------------------------\n+   * AttributedCharacterIterator methods\n+   * -----------------------------------\n+   */\n+  public Set getAllAttributeKeys()\n+  {\n+    if (attributes != null && attributes[attributeIndex] != null)\n+      return attributes[attributeIndex].keySet();\n+    else\n+      return new HashSet();\n+  }\n+  \n+  public Map getAttributes()\n+  {\n+    if (attributes != null && attributes[attributeIndex] != null)\n+      return attributes[attributeIndex];\n+    else\n+      return new HashMap();\n+  }\n+  \n+  public Object getAttribute(AttributedCharacterIterator.Attribute attrib)\n+  {\n+    if (attributes != null && attributes[attributeIndex] != null)\n+      return attributes[attributeIndex].get(attrib);\n+    else\n+      return null;\n+  }\n+  \n+  public int getRunLimit(Set reqAttrs)\n+  {\n+    if (attributes == null)\n+      return formattedString.length();\n+\n+    int currentAttrIndex = attributeIndex;\n+    Set newKeys;\n+\n+    do\n+      {\n+\tcurrentAttrIndex++;\n+\tif (currentAttrIndex == attributes.length)\n+\t  return formattedString.length();\n+\tif (attributes[currentAttrIndex] == null)\n+\t  break;\n+\tnewKeys = attributes[currentAttrIndex].keySet();\n+      }\n+    while (newKeys.containsAll(reqAttrs));\n+\n+    return ranges[currentAttrIndex-1];\n+  }\n+  \n+  public int getRunLimit(AttributedCharacterIterator.Attribute attribute) \n+  {\n+    Set s = new HashSet();\n+\n+    s.add(attribute);\n+    return getRunLimit(s);\n+  }\n+\n+  public int getRunLimit()\n+  {\n+    if (attributes == null)\n+      return formattedString.length();\n+    if (attributes[attributeIndex] == null)\n+      {\n+\tfor (int i=attributeIndex+1;i<attributes.length;i++)\n+\t  if (attributes[i] != null)\n+\t    return ranges[i-1];\n+\treturn formattedString.length();\n+      }\n+\n+    return getRunLimit (attributes[attributeIndex].keySet());\n+  }\n+  \n+  public int getRunStart(Set reqAttrs)\n+  {\n+    if (attributes == null)\n+      return formattedString.length();\n+  \n+    int currentAttrIndex = attributeIndex;\n+    Set newKeys = null;\n+\n+    do\n+      {\n+\tif (currentAttrIndex == 0)\n+\t  return 0;\n+\n+\tcurrentAttrIndex--;\n+\tif (attributes[currentAttrIndex] == null)\n+\t  break;\n+\tnewKeys = attributes[currentAttrIndex].keySet();\n+      }\n+    while (newKeys.containsAll(reqAttrs));\n+   \n+    return (currentAttrIndex > 0) ? ranges[currentAttrIndex-1] : 0;\n+  } \n+    \n+  public int getRunStart()\n+  {\n+    if (attributes == null)\n+      return 0;\n+\n+    if (attributes[attributeIndex] == null)\n+      {\n+\tfor (int i=attributeIndex;i>0;i--)\n+\t  if (attributes[i] != null)\n+\t    return ranges[attributeIndex-1];\n+\treturn 0;\n+      }\n+\n+    return getRunStart(attributes[attributeIndex].keySet());\n+  }\n+  \n+  public int getRunStart(AttributedCharacterIterator.Attribute attribute) \n+  {\n+    Set s = new HashSet();\n+    \n+    s.add(attribute);\n+    return getRunStart(s);\n+  }\n+\n+  public Object clone()\n+  {\n+    return new FormatCharacterIterator(formattedString, ranges, attributes);\n+  }\n+  \n+  /*\n+   * ---------------------------------\n+   * CharacterIterator methods\n+   * ---------------------------------\n+   */\n+  public char current()\n+  {\n+    return formattedString.charAt(charIndex);\n+  }\n+  \n+  public char first()\n+  {\n+    charIndex = 0;\n+    attributeIndex = 0;\n+    return formattedString.charAt(0);\n+  }\n+  \n+  public int getBeginIndex()\n+  {\n+    return 0;\n+  }\n+  \n+  public int getEndIndex()\n+  {\n+    return formattedString.length();\n+  }\n+  \n+  public int getIndex()\n+  {\n+    return charIndex;\n+  }\n+  \n+  public char last()\n+  {\n+    charIndex = formattedString.length()-1;\n+    if (attributes != null)\n+      attributeIndex = attributes.length-1;\n+    return formattedString.charAt(charIndex);\n+  }\n+  \n+  public char next()\n+  {\n+    charIndex++;\n+    if (charIndex >= formattedString.length())\n+      {\n+\tcharIndex = getEndIndex();\n+\treturn DONE;\n+      }\n+    if (attributes != null)\n+      {\n+\tif (charIndex >= ranges[attributeIndex])\n+\t  attributeIndex++;\n+      }\n+    return formattedString.charAt(charIndex);\n+  }\n+  \n+  public char previous()\n+  {\n+    charIndex--;\n+    if (charIndex < 0)\n+      {\n+\tcharIndex = 0;\n+\treturn DONE;\n+      }\n+    \n+    if (attributes != null)\n+      {\n+\tif (charIndex < ranges[attributeIndex])\n+\t  attributeIndex--;\n+      }\n+    return formattedString.charAt(charIndex);\n+  }\n+  \n+  public char setIndex(int position)\n+  {\n+    if (position < 0 || position > formattedString.length())\n+      throw new IllegalArgumentException(\"position is out of range\");\n+    \n+    charIndex = position;\n+    if (attributes != null)\n+      {\n+\tfor (attributeIndex=0;attributeIndex<attributes.length;\n+\t     attributeIndex++)\n+\t  if (ranges[attributeIndex] > charIndex)\n+\t    break;\n+\tattributeIndex--;\n+      }\n+    if (charIndex == formattedString.length())\n+      return DONE;\n+    else\n+      return formattedString.charAt(charIndex);\n+  }\n+\n+  protected void mergeAttributes(HashMap[] attributes, int[] ranges)\n+  {\n+    Vector new_ranges = new Vector();\n+    Vector new_attributes = new Vector();\n+    int i = 0, j = 0;\n+\n+    while (i < this.ranges.length && j < ranges.length)\n+      {\n+\tif (this.attributes[i] != null)\n+\t  {\n+\t    new_attributes.add(this.attributes[i]);\n+\t    if (attributes[j] != null)\n+\t      this.attributes[i].putAll(attributes[j]);\n+\t  }\n+\telse\n+\t  {\n+\t    new_attributes.add(attributes[j]);\n+\t  }\n+\tif (this.ranges[i] == ranges[j])\n+\t  {\n+\t    new_ranges.add(new Integer(ranges[j]));\n+\t    i++;\n+\t    j++;\n+\t  }\n+\telse if (this.ranges[i] < ranges[j])\n+\t  {\n+\t    new_ranges.add(new Integer(this.ranges[i]));\n+\t    i++;\n+\t  }\n+\telse\n+\t  {\n+\t    new_ranges.add(new Integer(ranges[j]));\n+\t    j++;\n+\t  }\n+     }\n+    \n+    if (i != this.ranges.length)\n+      {\n+\tfor (;i<this.ranges.length;i++)\n+\t  {\n+\t    new_attributes.add(this.attributes[i]);\n+\t    new_ranges.add(new Integer(this.ranges[i]));\n+\t  }\n+      }\n+    if (j != ranges.length)\n+      {\n+\tfor (;j<ranges.length;j++)\n+\t  {\n+\t    new_attributes.add(attributes[j]);\n+\t    new_ranges.add(new Integer(ranges[j]));\n+\t  }\n+      }\n+\n+    this.attributes = new HashMap[new_attributes.size()];\n+    this.ranges = new int[new_ranges.size()];\n+    System.arraycopy(new_attributes.toArray(), 0, this.attributes,\n+\t\t     0, this.attributes.length);\n+\n+    for (i=0;i<new_ranges.size();i++)\n+      {\n+\tthis.ranges[i] = ((Integer)new_ranges.elementAt(i)).intValue();\n+      }\n+    \n+  }\n+\n+  protected void append(AttributedCharacterIterator iterator)\n+  {\n+    char c = iterator.first();\n+    Vector more_ranges = new Vector();\n+    Vector more_attributes = new Vector();\n+\n+    do\n+      {\n+\tformattedString = formattedString + String.valueOf(c);\n+\t// TODO: Reduce the size of the output array.\n+\tmore_attributes.add (iterator.getAttributes());\n+\tmore_ranges.add(new Integer(formattedString.length()));\n+\t// END TOOD\n+\tc = iterator.next();\n+      } \n+    while (c != DONE);\n+\n+    HashMap[] new_attributes = new HashMap[attributes.length\n+\t\t\t\t\t   + more_attributes.size()];\n+    int[] new_ranges = new int[ranges.length + more_ranges.size()];\n+    \n+    System.arraycopy(attributes, 0, new_attributes, 0, attributes.length);\n+    System.arraycopy(more_attributes.toArray(), 0, new_attributes,\n+\t\t     attributes.length, more_attributes.size());\n+\n+    System.arraycopy(ranges, 0, new_ranges, 0, ranges.length);\n+    Object[] new_ranges_array = more_ranges.toArray();\n+    for (int i=0;i<more_ranges.size();i++)\n+      new_ranges[i+ranges.length] = ((Integer)new_ranges_array[i]).intValue();\n+\n+    attributes = new_attributes;\n+    ranges = new_ranges;\n+  }\n+\n+  protected void append(String text, HashMap local_attributes)\n+  {\n+    int[] new_ranges = new int[ranges.length+1];\n+    HashMap[] new_attributes = new HashMap[attributes.length+1];\n+\n+    formattedString += text;\n+    System.arraycopy(attributes, 0, new_attributes, 0, attributes.length);\n+    System.arraycopy(ranges, 0, new_ranges, 0, ranges.length);\n+    new_ranges[ranges.length] = formattedString.length();\n+    new_attributes[attributes.length] = local_attributes;\n+\n+    ranges = new_ranges;\n+    attributes = new_attributes;\n+  }  \n+\n+  protected void append(String text)\n+  {\n+    append(text, null);\n+  }  \n+}"}, {"sha": "a742831e4c3d11ca0703697351da59f223247fdc", "filename": "libjava/java/util/Currency.java", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Futil%2FCurrency.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b941eec31d98619765dec95929a2a86058d5843/libjava%2Fjava%2Futil%2FCurrency.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCurrency.java?ref=8b941eec31d98619765dec95929a2a86058d5843", "patch": "@@ -0,0 +1,189 @@\n+/* Currency.java -- Representation of a currency\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+package java.util;\n+\n+import java.io.Serializable;\n+import java.util.ResourceBundle;\n+import java.util.Locale;\n+import java.text.NumberFormat;\n+\n+public final class Currency implements Serializable\n+{\n+  static final long serialVersionUID = -158308464356906721L;\n+\n+  private Locale locale;\n+  private ResourceBundle res;\n+\n+  // For deserialization\n+  private Currency ()\n+  {\n+  }\n+\n+  private Currency (Locale loc)\n+  {\n+    this.locale = loc;\n+    this.res = ResourceBundle.getBundle (\"gnu.java.locale.LocaleInformation\", locale);\n+  }\n+\n+  /**\n+   * Returns the ISO4217 currency code of this currency.\n+   *\n+   * @return a <code>String</code> containing currency code.\n+   */\n+  public String getCurrencyCode ()\n+  {\n+    try\n+      {\n+\treturn res.getString (\"intlCurrencySymbol\");\n+      }\n+    catch (Exception _)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * @return number of digits after decimal separator for this currency.\n+   */   \n+  public int getDefaultFractionDigits ()\n+  {\n+    NumberFormat currency = NumberFormat.getCurrencyInstance (locale);\n+    \n+    return currency.getMaximumFractionDigits();\n+  }\n+    \n+  /**\n+   * Builds a new currency instance for this locale.\n+   *\n+   * @param locale a <code>Locale</code> instance.\n+   * \n+   * @return a new <code>Currency</code> instance.\n+   */ \n+  public static Currency getInstance (Locale locale)\n+  {\n+    return new Currency (locale);\n+  }\n+\n+  /**\n+   * Builds the currency corresponding to the specified currency code.\n+   *\n+   * @param currencyCode a string representing a currency code.\n+   *\n+   * @return a new <code>Currency</code> instance.\n+   */\n+  public static Currency getInstance (String currencyCode)\n+  {\n+    Locale[] all_locales = Locale.getAvailableLocales ();\n+    \n+    for (int i=0;i<all_locales.length;i++)\n+      {\n+\tCurrency test_currency = getInstance (all_locales[i]);\n+\t\n+\tif (test_currency.getCurrencyCode() != null &&\n+\t    test_currency.getCurrencyCode().equals(currencyCode))\n+\t  return test_currency;\n+      }\n+    \n+    return null;\n+  }\n+\n+  /**\n+   * This method returns the currency symbol.\n+   *\n+   * @return the currency symbol.\n+   */\n+  public String getSymbol()\n+  {\n+    try\n+      {\n+\treturn res.getString (\"currencySymbol\");\n+      }\n+    catch (Exception _)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * This methods returns the currency symbol expressed in the specified locale.\n+   *\n+   * @param locale the locale to express the symbol in.\n+   * @return the currency symbol.\n+   */\n+  public String getSymbol(Locale locale)\n+  {\n+    // TODO. The behaviour is unclear if locale != this.locale.\n+    // First we need to implement fully LocaleInformation*.java\n+    try\n+      {\n+\tResourceBundle res = ResourceBundle.getBundle (\"gnu.java.locale.LocaleInformation\", locale);\n+\n+\tif (res.equals(this.res))\n+\t  return res.getString (\"currencySymbol\");\n+\telse\n+\t  return res.getString (\"intlCurrencySymbol\");\n+      }\n+    catch (Exception e1)\n+      {\n+\ttry\n+\t  {\n+\t    return res.getString (\"intlCurrencySymbol\");\n+\t  }\n+\tcatch (Exception e2)\n+\t  {\n+\t    return null;\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Returns the international ISO4217 currency code of this currency.\n+   *\n+   * @return a <code>String</code> containing the ISO4217 currency code.\n+   */\n+  public String toString()\n+  {\n+    try\n+      {\n+\treturn res.getString (\"intlCurrencySymbol\");\n+      }\n+    catch (Exception _)\n+      {\n+\treturn \"(unknown currency)\";\n+      }\n+  }\n+}"}]}