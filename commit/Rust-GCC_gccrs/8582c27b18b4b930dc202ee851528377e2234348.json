{"sha": "8582c27b18b4b930dc202ee851528377e2234348", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4MmMyN2IxOGI0YjkzMGRjMjAyZWU4NTE1MjgzNzdlMjIzNDM0OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-12-12T22:50:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-12T22:50:05Z"}, "message": "regrename.c (copyprop_hardreg_forward): New optimization.\n\n        * regrename.c (copyprop_hardreg_forward): New optimization.\n        (kill_value_regno, kill_value, init_value_data, kill_clobbered_value,\n        kill_set_value, kill_autoinc_value, copy_value, find_oldest_value_reg,\n        replace_oldest_value_reg, replace_oldest_value_addr,\n        replace_oldest_value_mem, copyprop_hardreg_forward_1,\n        debug_value_data, validate_value_data): New.\n        * rtl.h (copyprop_hardreg_forward): Declare.\n        * toplev.c (flag_cprop_registers): New.\n        (f_options): Add -fcprop-registers\n        (rest_of_compilation): Invoke it.\n        (parse_options_and_default_flags): Set it at -O1.\n        * doc/invoke.texi: Document it.\n\nFrom-SVN: r47951", "tree": {"sha": "bbc23bebdd972d2b44a70bb56df71f814ddfbac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbc23bebdd972d2b44a70bb56df71f814ddfbac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8582c27b18b4b930dc202ee851528377e2234348", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8582c27b18b4b930dc202ee851528377e2234348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8582c27b18b4b930dc202ee851528377e2234348", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8582c27b18b4b930dc202ee851528377e2234348/comments", "author": null, "committer": null, "parents": [{"sha": "de76a39c6e0550ed9cfc87a5e9d112f7f8dbefd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de76a39c6e0550ed9cfc87a5e9d112f7f8dbefd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de76a39c6e0550ed9cfc87a5e9d112f7f8dbefd7"}], "stats": {"total": 775, "additions": 772, "deletions": 3}, "files": [{"sha": "0a5f9e29abab839b428942b9b9f9703274d33573", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8582c27b18b4b930dc202ee851528377e2234348/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8582c27b18b4b930dc202ee851528377e2234348/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8582c27b18b4b930dc202ee851528377e2234348", "patch": "@@ -1,3 +1,18 @@\n+2001-12-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* regrename.c (copyprop_hardreg_forward): New optimization.\n+\t(kill_value_regno, kill_value, init_value_data, kill_clobbered_value,\n+\tkill_set_value, kill_autoinc_value, copy_value, find_oldest_value_reg,\n+\treplace_oldest_value_reg, replace_oldest_value_addr,\n+\treplace_oldest_value_mem, copyprop_hardreg_forward_1,\n+\tdebug_value_data, validate_value_data): New.\n+\t* rtl.h (copyprop_hardreg_forward): Declare.\n+\t* toplev.c (flag_cprop_registers): New.\n+\t(f_options): Add -fcprop-registers\n+\t(rest_of_compilation): Invoke it.\n+\t(parse_options_and_default_flags): Set it at -O1.\n+\t* doc/invoke.texi: Document it.\n+\n 2001-12-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (dw_val_class): Add dw_val_class_range_list."}, {"sha": "66314f1dab870ca0f6f53d7fad1d2ecbafed7e35", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8582c27b18b4b930dc202ee851528377e2234348", "patch": "@@ -259,7 +259,7 @@ in the following sections.\n @gccoptlist{\n -falign-functions=@var{n}  -falign-jumps=@var{n} @gol\n -falign-labels=@var{n}  -falign-loops=@var{n}  @gol\n--fbranch-probabilities  -fcaller-saves @gol\n+-fbranch-probabilities  -fcaller-saves -fcprop-registers @gol\n -fcse-follow-jumps  -fcse-skip-blocks  -fdata-sections @gol\n -fdelayed-branch  -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations  -ffast-math  -ffloat-store @gol\n@@ -3774,6 +3774,12 @@ will most benefit processors with lots of registers.  It can, however,\n make debugging impossible, since variables will no longer stay in\n a ``home register''.\n \n+@item -fno-cprop-registers\n+@opindex fno-cprop-registers\n+After register allocation and post-register allocation instruction splitting,\n+we perform a copy-propagation pass to try to reduce scheduling dependencies\n+and occasionally eliminate the copy.\n+\n @item --param @var{name}=@var{value}\n @opindex param\n In some places, GCC uses various constants to control the amount of"}, {"sha": "69e267cfaca045230b5e28585bddcac0dc31862a", "filename": "gcc/regrename.c", "status": "modified", "additions": 740, "deletions": 0, "changes": 740, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=8582c27b18b4b930dc202ee851528377e2234348", "patch": "@@ -33,6 +33,7 @@\n #include \"function.h\"\n #include \"recog.h\"\n #include \"flags.h\"\n+#include \"toplev.h\"\n #include \"obstack.h\"\n \n #define obstack_chunk_alloc xmalloc\n@@ -960,3 +961,742 @@ dump_def_use_chain (chains)\n       chains = chains->next_chain;\n     }\n }\n+\f\n+/* The following code does forward propagation of hard register copies.\n+   The object is to eliminate as many dependencies as possible, so that\n+   we have the most scheduling freedom.  As a side effect, we also clean\n+   up some silly register allocation decisions made by reload.  This \n+   code may be obsoleted by a new register allocator.  */\n+\n+/* For each register, we have a list of registers that contain the same\n+   value.  The OLDEST_REGNO field points to the head of the list, and \n+   the NEXT_REGNO field runs through the list.  The MODE field indicates\n+   what mode the data is known to be in; this field is VOIDmode when the\n+   register is not known to contain valid data.  */\n+\n+struct value_data_entry\n+{\n+  enum machine_mode mode;\n+  unsigned int oldest_regno;\n+  unsigned int next_regno;\n+};\n+\n+struct value_data\n+{\n+  struct value_data_entry e[FIRST_PSEUDO_REGISTER];\n+};\n+\n+static void kill_value_regno PARAMS ((unsigned, struct value_data *));\n+static void kill_value PARAMS ((rtx, struct value_data *));\n+static void init_value_data PARAMS ((struct value_data *));\n+static void kill_clobbered_value PARAMS ((rtx, rtx, void *));\n+static void kill_set_value PARAMS ((rtx, rtx, void *));\n+static int kill_autoinc_value PARAMS ((rtx *, void *));\n+static void copy_value PARAMS ((rtx, rtx, struct value_data *));\n+static rtx find_oldest_value_reg PARAMS ((enum reg_class, unsigned int,\n+\t\t\t\t\t    enum machine_mode,\n+\t\t\t\t\t    struct value_data *));\n+static bool replace_oldest_value_reg PARAMS ((rtx *, enum reg_class, rtx,\n+\t\t\t\t\t      struct value_data *));\n+static bool replace_oldest_value_addr PARAMS ((rtx *, enum reg_class,\n+\t\t\t\t\t       enum machine_mode, rtx,\n+\t\t\t\t\t       struct value_data *));\n+static bool replace_oldest_value_mem PARAMS ((rtx, rtx, struct value_data *));\n+static bool copyprop_hardreg_forward_1 PARAMS ((basic_block,\n+\t\t\t\t\t\t struct value_data *));\n+extern void debug_value_data PARAMS ((struct value_data *));\n+#ifdef ENABLE_CHECKING\n+static void validate_value_data PARAMS ((struct value_data *));\n+#endif\n+\n+/* Kill register REGNO.  This involves removing it from any value lists,\n+   and resetting the value mode to VOIDmode.  */\n+\n+static void\n+kill_value_regno (regno, vd)\n+     unsigned int regno;\n+     struct value_data *vd;\n+{\n+  unsigned int i, next;\n+\n+  if (vd->e[regno].oldest_regno != regno)\n+    {\n+      for (i = vd->e[regno].oldest_regno;\n+\t   vd->e[i].next_regno != regno;\n+\t   i = vd->e[i].next_regno)\n+\tcontinue;\n+\n+      next = vd->e[regno].next_regno;\n+      while (1)\n+\t{\n+\t  vd->e[i].next_regno = next;\n+\t  if (next == INVALID_REGNUM)\n+\t    break;\n+\t  i = next;\n+\t  next = vd->e[next].next_regno;\n+\t}\n+    }\n+  else if ((next = vd->e[regno].next_regno) != INVALID_REGNUM)\n+    {\n+      for (i = next; i != INVALID_REGNUM; i = vd->e[i].next_regno)\n+        vd->e[i].oldest_regno = next;\n+    }\n+\n+  vd->e[regno].mode = VOIDmode;\n+  vd->e[regno].oldest_regno = regno;\n+  vd->e[regno].next_regno = INVALID_REGNUM;\n+\n+#ifdef ENABLE_CHECKING\n+  validate_value_data (vd);\n+#endif\n+}\n+\n+/* Kill X.  This is a convenience function for kill_value_regno\n+   so that we don't have to check that X is a register first.  */\n+\n+static void\n+kill_value (x, vd)\n+     rtx x;\n+     struct value_data *vd;\n+{\n+  if (REG_P (x))\n+    kill_value_regno (REGNO (x), vd);\n+}\n+\n+/* Initialize VD such that there are no known relationships between regs.  */\n+\n+static void\n+init_value_data (vd)\n+     struct value_data *vd;\n+{\n+  int i;\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    {\n+      vd->e[i].mode = VOIDmode;\n+      vd->e[i].oldest_regno = i;\n+      vd->e[i].next_regno = INVALID_REGNUM;\n+    }\n+}\n+\n+/* Called through note_stores.  If X is clobbered, kill its value.  */\n+\n+static void\n+kill_clobbered_value (x, set, data)\n+     rtx x;\n+     rtx set;\n+     void *data;\n+{\n+  struct value_data *vd = data;\n+  if (GET_CODE (set) == CLOBBER)\n+    kill_value (x, vd);\n+}\n+\n+/* Called through note_stores.  If X is set, not clobbered, kill its \n+   current value and install it as the root of its own value list.  */\n+\n+static void\n+kill_set_value (x, set, data)\n+     rtx x;\n+     rtx set;\n+     void *data;\n+{\n+  struct value_data *vd = data;\n+  if (GET_CODE (set) != CLOBBER && REG_P (x))\n+    {\n+      unsigned int regno = REGNO (x);\n+      kill_value_regno (regno, vd);\n+      vd->e[regno].mode = GET_MODE (x);\n+    }\n+}\n+\n+/* Called through for_each_rtx.  Kill any register used as the base of an\n+   auto-increment expression, and install that register as the root of its\n+   own value list.  */\n+\n+static int\n+kill_autoinc_value (px, data)\n+     rtx *px;\n+     void *data;\n+{\n+  rtx x = *px;\n+  struct value_data *vd = data;\n+\n+  if (GET_RTX_CLASS (GET_CODE (x)) == 'a')\n+    {\n+      unsigned int regno = REGNO (XEXP (x, 0));\n+      kill_value_regno (regno, vd);\n+      vd->e[regno].mode = Pmode;\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Assert that SRC has been copied to DEST.  Adjust the data structures\n+   to reflect that SRC contains an older copy of the shared value.  */\n+\n+static void\n+copy_value (dest, src, vd)\n+     rtx dest;\n+     rtx src;\n+     struct value_data *vd;\n+{\n+  unsigned int dr = REGNO (dest);\n+  unsigned int sr = REGNO (src);\n+  unsigned int i;\n+\n+  /* ??? At present, it's possible to see noop sets.  It'd be nice if\n+     this were cleaned up beforehand...  */\n+  if (sr == dr)\n+    return;\n+\n+  /* Do not propagate copies to the stack pointer, as that can leave\n+     memory accesses with no scheduling dependancy on the stack update.  */\n+  if (dr == STACK_POINTER_REGNUM)\n+    return;\n+\n+  /* Likewise with the frame pointer, if we're using one.  */\n+  if (frame_pointer_needed && dr == HARD_FRAME_POINTER_REGNUM)\n+    return;\n+\n+  /* If SRC had no assigned mode (i.e. we didn't know it was live)\n+     assign it now and assume the value came from an input argument\n+     or somesuch.  */\n+  if (vd->e[sr].mode == VOIDmode)\n+    vd->e[sr].mode = vd->e[dr].mode;\n+\n+  /* Link DR at the end of the value chain used by SR.  */\n+\n+  vd->e[dr].oldest_regno = vd->e[sr].oldest_regno;\n+\n+  for (i = sr; vd->e[i].next_regno != INVALID_REGNUM; i = vd->e[i].next_regno)\n+    continue;\n+  vd->e[i].next_regno = dr;\n+\n+#ifdef ENABLE_CHECKING\n+  validate_value_data (vd);\n+#endif\n+}\n+\n+/* Find the oldest copy of the value contained in REGNO that is in\n+   register class CLASS and has mode MODE.  If found, return an rtx\n+   of that oldest register, otherwise return NULL.  */\n+\n+static rtx\n+find_oldest_value_reg (class, regno, mode, vd)\n+     enum reg_class class;\n+     unsigned int regno;\n+     enum machine_mode mode;\n+     struct value_data *vd;\n+{\n+  unsigned int i;\n+\n+  for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n+    if (vd->e[i].mode == mode\n+\t&& TEST_HARD_REG_BIT (reg_class_contents[class], i))\n+      return gen_rtx_REG (mode, i);\n+\n+  return NULL_RTX;\n+}\n+\n+/* If possible, replace the register at *LOC with the oldest register\n+   in register class CLASS.  Return true if successfully replaced.  */\n+\n+static bool\n+replace_oldest_value_reg (loc, class, insn, vd)\n+     rtx *loc;\n+     enum reg_class class;\n+     rtx insn;\n+     struct value_data *vd;\n+{\n+  rtx new = find_oldest_value_reg (class, REGNO (*loc), GET_MODE (*loc), vd);\n+  if (new)\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"insn %u: replaced reg %u with %u\\n\",\n+\t\t INSN_UID (insn), REGNO (*loc), REGNO (new));\n+\n+      *loc = new;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Similar to replace_oldest_value_reg, but *LOC contains an address.\n+   Adapted from find_reloads_address_1.  CLASS is INDEX_REG_CLASS or\n+   BASE_REG_CLASS depending on how the register is being considered.  */\n+\n+static bool\n+replace_oldest_value_addr (loc, class, mode, insn, vd)\n+     rtx *loc;\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx insn;\n+     struct value_data *vd;\n+{\n+  rtx x = *loc;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n+  int i, j;\n+  bool changed = false;\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+      {\n+\trtx orig_op0 = XEXP (x, 0);\n+\trtx orig_op1 = XEXP (x, 1);\n+\tRTX_CODE code0 = GET_CODE (orig_op0);\n+\tRTX_CODE code1 = GET_CODE (orig_op1);\n+\trtx op0 = orig_op0;\n+\trtx op1 = orig_op1;\n+\trtx *locI = NULL;\n+\trtx *locB = NULL;\n+\n+\tif (GET_CODE (op0) == SUBREG)\n+\t  {\n+\t    op0 = SUBREG_REG (op0);\n+\t    code0 = GET_CODE (op0);\n+\t  }\n+\n+\tif (GET_CODE (op1) == SUBREG)\n+\t  {\n+\t    op1 = SUBREG_REG (op1);\n+\t    code1 = GET_CODE (op1);\n+\t  }\n+\n+\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n+\t    || code0 == ZERO_EXTEND || code1 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t  }\n+\telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n+\t\t || code1 == ZERO_EXTEND || code0 == MEM)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t  }\n+\telse if (code0 == CONST_INT || code0 == CONST\n+\t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n+\t  locB = &XEXP (x, 1);\n+\telse if (code1 == CONST_INT || code1 == CONST\n+\t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n+\t  locB = &XEXP (x, 0);\n+\telse if (code0 == REG && code1 == REG)\n+\t  {\n+\t    int index_op;\n+\n+\t    if (REG_OK_FOR_INDEX_P (op0)\n+\t\t&& REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t      index_op = 0;\n+\t    else if (REG_OK_FOR_INDEX_P (op1)\n+\t\t     && REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t      index_op = 1;\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op1, mode))\n+\t      index_op = 0;\n+\t    else if (REG_MODE_OK_FOR_BASE_P (op0, mode))\n+\t      index_op = 1;\n+\t    else if (REG_OK_FOR_INDEX_P (op1))\n+\t      index_op = 1;\n+\t    else\n+\t      index_op = 0;\n+\n+\t    locI = &XEXP (x, index_op);\n+\t    locB = &XEXP (x, !index_op);\n+\t  }\n+\telse if (code0 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 0);\n+\t    locB = &XEXP (x, 1);\n+\t  }\n+\telse if (code1 == REG)\n+\t  {\n+\t    locI = &XEXP (x, 1);\n+\t    locB = &XEXP (x, 0);\n+\t  }\n+\n+\tif (locI)\n+\t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n+\t\t\t\t\t        insn, vd);\n+\tif (locB)\n+\t  changed |= replace_oldest_value_addr (locB, BASE_REG_CLASS, mode,\n+\t\t\t\t\t        insn, vd);\n+\treturn changed;\n+      }\n+\n+    case POST_INC:\n+    case POST_DEC:\n+    case POST_MODIFY:\n+    case PRE_INC:\n+    case PRE_DEC:\n+    case PRE_MODIFY:\n+      return false;\n+\n+    case MEM:\n+      return replace_oldest_value_mem (x, insn, vd);\n+\n+    case REG:\n+      return replace_oldest_value_reg (loc, class, insn, vd);\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\tchanged |= replace_oldest_value_addr (&XEXP (x, i), class, mode,\n+\t\t\t\t\t      insn, vd);\n+      else if (fmt[i] == 'E')\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), class,\n+\t\t\t\t\t        mode, insn, vd);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Similar to replace_oldest_value_reg, but X contains a memory.  */\n+\n+static bool\n+replace_oldest_value_mem (x, insn, vd)\n+     rtx x;\n+     rtx insn;\n+     struct value_data *vd;\n+{\n+  return replace_oldest_value_addr (&XEXP (x, 0), BASE_REG_CLASS,\n+\t\t\t\t    GET_MODE (x), insn, vd);\n+}\n+\n+/* Perform the forward copy propagation on basic block BB.  */\n+\n+static bool\n+copyprop_hardreg_forward_1 (bb, vd)\n+     basic_block bb;\n+     struct value_data *vd;\n+{\n+  bool changed = false;\n+  rtx insn;\n+\n+  for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+    {\n+      int n_ops, i, alt, predicated;\n+      rtx set;\n+\n+      if (! INSN_P (insn))\n+\t{\n+\t  if (insn == bb->end)\n+\t    break;\n+\t  else\n+\t    continue;\n+\t}\n+\n+      set = single_set (insn);\n+      extract_insn (insn);\n+      constrain_operands (1);\n+      preprocess_constraints ();\n+      alt = which_alternative;\n+      n_ops = recog_data.n_operands;\n+\n+      /* Simplify the code below by rewriting things to reflect\n+\t matching constraints.  Also promote OP_OUT to OP_INOUT\n+\t in predicated instructions.  */\n+\n+      predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n+      for (i = 0; i < n_ops; ++i)\n+\t{\n+\t  int matches = recog_op_alt[i][alt].matches;\n+\t  if (matches >= 0)\n+\t    recog_op_alt[i][alt].class = recog_op_alt[matches][alt].class;\n+\t  if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n+\t      || (predicated && recog_data.operand_type[i] == OP_OUT))\n+\t    recog_data.operand_type[i] = OP_INOUT;\n+\t}\n+\n+      /* For each earlyclobber operand, zap the value data.  */\n+      for (i = 0; i < n_ops; i++)\n+\tif (recog_op_alt[i][alt].earlyclobber)\n+\t  kill_value (recog_data.operand[i], vd);\n+\n+      /* Within asms, a clobber cannot overlap inputs or outputs.\n+\t I wouldn't think this were true for regular insns, but\n+\t scan_rtx treats them like that...  */\n+      note_stores (PATTERN (insn), kill_clobbered_value, vd);\n+\n+      /* Kill all auto-incremented values.  */\n+      /* ??? REG_INC is useless, since stack pushes aren't done that way.  */\n+      for_each_rtx (&PATTERN (insn), kill_autoinc_value, vd);\n+\n+      /* Special-case plain move instructions, since we may well\n+\t be able to do the move from a different register class.  */\n+      if (set && REG_P (SET_SRC (set)))\n+\t{\n+\t  unsigned int regno = REGNO (SET_SRC (set));\n+\t  enum machine_mode mode = GET_MODE (SET_SRC (set));\n+\t  unsigned int i;\n+\t  rtx new;\n+\n+\t  /* If the destination is also a register, try to find a source\n+\t     register in the same class.  */\n+\t  if (REG_P (SET_DEST (set)))\n+\t    {\n+\t      new = find_oldest_value_reg (REGNO_REG_CLASS (regno),\n+\t\t\t\t\t   regno, mode, vd);\n+\t      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n+\t\t{\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file,\n+\t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n+\t\t\t     INSN_UID (insn), regno, REGNO (new));\n+\t          changed = true;\n+\t\t  goto did_replacement;\n+\t\t}\n+\t    }\n+\n+\t  /* Otherwise, try all valid registers and see if its valid.  */\n+\t  for (i = vd->e[regno].oldest_regno; i != regno;\n+\t       i = vd->e[i].next_regno)\n+\t    if (mode == vd->e[regno].mode)\n+\t      {\n+\t\tnew = gen_rtx_REG (mode, i);\n+\t\tif (validate_change (insn, &SET_SRC (set), new, 0))\n+\t\t  {\n+\t\t    if (rtl_dump_file)\n+\t\t      fprintf (rtl_dump_file,\n+\t\t\t       \"insn %u: replaced reg %u with %u\\n\",\n+\t\t\t       INSN_UID (insn), regno, REGNO (new));\n+\t\t    changed = true;\n+\t\t    goto did_replacement;\n+\t\t  }\n+\t      }\n+\t}\n+\n+      /* For each input operand, replace a hard register with the\n+\t eldest live copy that's in an appropriate register class.  */\n+      for (i = 0; i < n_ops; i++)\n+\t{\n+\t  bool replaced = false;\n+\n+\t  /* Don't scan match_operand here, since we've no reg class\n+\t     information to pass down.  Any operands that we could\n+\t     substitute in will be represented elsewhere.  */\n+\t  if (recog_data.constraints[i][0] == '\\0')\n+\t    continue;\n+\n+\t  if (recog_data.operand_type[i] == OP_IN)\n+\t    {\n+\t      if (recog_op_alt[i][alt].is_address)\n+\t\treplaced\n+\t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n+\t\t\t\t\t       recog_op_alt[i][alt].class,\n+\t\t\t\t\t       VOIDmode, insn, vd);\n+\t      else if (REG_P (recog_data.operand[i]))\n+\t\treplaced\n+\t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],\n+\t\t\t\t\t      recog_op_alt[i][alt].class,\n+\t\t\t\t\t      insn, vd);\n+\t      else if (GET_CODE (recog_data.operand[i]) == MEM)\n+\t\treplaced = replace_oldest_value_mem (recog_data.operand[i],\n+\t\t\t\t\t\t     insn, vd);\n+\t    }\n+\t  else if (GET_CODE (recog_data.operand[i]) == MEM)\n+\t    replaced = replace_oldest_value_mem (recog_data.operand[i],\n+\t\t\t\t\t         insn, vd);\n+\n+\t  /* If we performed any replacement, update match_dups.  */\n+\t  if (replaced)\n+\t    {\n+\t      int j;\n+\t      rtx new;\n+\n+\t      changed = true;\n+\n+\t      new = *recog_data.operand_loc[i];\n+\t      recog_data.operand[i] = new;\n+\t      for (j = 0; j < recog_data.n_dups; j++)\n+\t\tif (recog_data.dup_num[j] == i)\n+\t\t  *recog_data.dup_loc[j] = new;\n+\t    }\n+\t}\n+\n+    did_replacement:\n+      /* Clobber call-clobbered registers.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n+\t    kill_value_regno (i, vd);\n+\n+      /* Notice stores.  */\n+      note_stores (PATTERN (insn), kill_set_value, vd);\n+\n+      /* Notice copies.  */\n+      if (set && REG_P (SET_DEST (set)) && REG_P (SET_SRC (set)))\n+\tcopy_value (SET_DEST (set), SET_SRC (set), vd);\n+\n+      if (insn == bb->end)\n+\tbreak;\n+    }\n+\n+  return changed;\n+}\n+\n+/* Main entry point for the forward copy propagation optimization.  */\n+\n+void\n+copyprop_hardreg_forward ()\n+{\n+  int b, need_refresh;\n+  sbitmap refresh_blocks;\n+  struct value_data *all_vd;\n+\n+  refresh_blocks = sbitmap_alloc (n_basic_blocks);\n+  sbitmap_zero (refresh_blocks);\n+  need_refresh = 0;\n+\n+  all_vd = xmalloc (sizeof (struct value_data) * n_basic_blocks);\n+\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      basic_block bb = BASIC_BLOCK (b);\n+\n+      /* If a block has a single predecessor, that we've already\n+\t processed, begin with the value data that was live at\n+\t the end of the predecessor block.  */\n+      /* ??? Ought to use more intelligent queueing of blocks.  */\n+      if (bb->pred\n+\t  && ! bb->pred->pred_next \n+\t  && bb->pred->src->index != ENTRY_BLOCK\n+\t  && bb->pred->src->index < b)\n+\tall_vd[b] = all_vd[bb->pred->src->index];\n+      else\n+        init_value_data (all_vd + b);\n+\n+      if (copyprop_hardreg_forward_1 (bb, all_vd + b))\n+\t{\n+\t  SET_BIT (refresh_blocks, b);\n+\t  need_refresh = 1;\n+\t}\n+    }\n+\n+  if (need_refresh)\n+    {\n+      if (rtl_dump_file)\n+\tfputs (\"\\n\\n\", rtl_dump_file);\n+\n+      update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\tPROP_DEATH_NOTES\n+\t\t\t| PROP_SCAN_DEAD_CODE\n+\t\t\t| PROP_KILL_DEAD_CODE);\n+    }\n+\n+  sbitmap_free (refresh_blocks);\n+  free (all_vd);\n+}\n+\n+/* Dump the value chain data to stderr.  */\n+\n+void\n+debug_value_data (vd)\n+     struct value_data *vd;\n+{\n+  HARD_REG_SET set;\n+  unsigned int i, j;\n+\n+  CLEAR_HARD_REG_SET (set);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (vd->e[i].oldest_regno == i)\n+      {\n+\tif (vd->e[i].mode == VOIDmode)\n+\t  {\n+\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n+\t      fprintf (stderr, \"[%u] Bad next_regno for empty chain (%u)\\n\",\n+\t\t       i, vd->e[i].next_regno);\n+\t    continue;\n+\t  }\n+\n+\tSET_HARD_REG_BIT (set, i);\n+\tfprintf (stderr, \"[%u %s] \", i, GET_MODE_NAME (vd->e[i].mode));\n+\n+\tfor (j = vd->e[i].next_regno;\n+\t     j != INVALID_REGNUM;\n+\t     j = vd->e[j].next_regno)\n+\t  {\n+\t    if (TEST_HARD_REG_BIT (set, vd->e[j].next_regno))\n+\t      {\n+\t\tfprintf (stderr, \"[%u] Loop in regno chain\\n\", j);\n+\t\treturn;\n+\t      }\n+\n+\t    if (vd->e[j].oldest_regno != i)\n+\t      {\n+\t\tfprintf (stderr, \"[%u] Bad oldest_regno (%u)\\n\",\n+\t\t\t j, vd->e[j].oldest_regno);\n+\t\treturn;\n+\t      }\n+\t    SET_HARD_REG_BIT (set, j);\n+\t    fprintf (stderr, \"[%u %s] \", j, GET_MODE_NAME (vd->e[j].mode));\n+\t  }\n+\tfputc ('\\n', stderr);\n+      }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (! TEST_HARD_REG_BIT (set, i)\n+\t&& (vd->e[i].mode != VOIDmode\n+\t    || vd->e[i].oldest_regno != i\n+\t    || vd->e[i].next_regno != INVALID_REGNUM))\n+      fprintf (stderr, \"[%u] Non-empty reg in chain (%s %u %i)\\n\",\n+\t       i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n+\t       vd->e[i].next_regno);\n+}\n+\n+#ifdef ENABLE_CHECKING\n+static void\n+validate_value_data (vd)\n+     struct value_data *vd;\n+{\n+  HARD_REG_SET set;\n+  unsigned int i, j;\n+\n+  CLEAR_HARD_REG_SET (set);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (vd->e[i].oldest_regno == i)\n+      {\n+\tif (vd->e[i].mode == VOIDmode)\n+\t  {\n+\t    if (vd->e[i].next_regno != INVALID_REGNUM)\n+\t      internal_error (\"validate_value_data: [%u] Bad next_regno for empty chain (%u)\",\n+\t\t\t      i, vd->e[i].next_regno);\n+\t    continue;\n+\t  }\n+\n+\tSET_HARD_REG_BIT (set, i);\n+\n+\tfor (j = vd->e[i].next_regno;\n+\t     j != INVALID_REGNUM;\n+\t     j = vd->e[j].next_regno)\n+\t  {\n+\t    if (TEST_HARD_REG_BIT (set, j))\n+\t      internal_error (\"validate_value_data: Loop in regno chain (%u)\",\n+\t\t\t      j);\n+\t    if (vd->e[j].oldest_regno != i)\n+\t      internal_error (\"validate_value_data: [%u] Bad oldest_regno (%u)\",\n+\t\t\t      j, vd->e[j].oldest_regno);\n+\n+\t    SET_HARD_REG_BIT (set, j);\n+\t  }\n+      }\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+    if (! TEST_HARD_REG_BIT (set, i)\n+\t&& (vd->e[i].mode != VOIDmode\n+\t    || vd->e[i].oldest_regno != i\n+\t    || vd->e[i].next_regno != INVALID_REGNUM))\n+      internal_error (\"validate_value_data: [%u] Non-empty reg in chain (%s %u %i)\",\n+\t\t      i, GET_MODE_NAME (vd->e[i].mode), vd->e[i].oldest_regno,\n+\t\t      vd->e[i].next_regno);\n+}\n+#endif"}, {"sha": "4c8d1ff74074451e63411218cd4073558d7d97e5", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8582c27b18b4b930dc202ee851528377e2234348", "patch": "@@ -2097,6 +2097,7 @@ extern rtx stack_limit_rtx;\n \n /* In regrename.c */\n extern void regrename_optimize\t\tPARAMS ((void));\n+extern void copyprop_hardreg_forward\tPARAMS ((void));\n \n /* In ifcvt.c */\n extern void if_convert\t\t\tPARAMS ((int));"}, {"sha": "d2c7ca020540411d346c8201aa820c15efc292cd", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8582c27b18b4b930dc202ee851528377e2234348/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8582c27b18b4b930dc202ee851528377e2234348", "patch": "@@ -427,6 +427,7 @@ int flag_reorder_blocks = 0;\n /* Nonzero if registers should be renamed.  */\n \n int flag_rename_registers = 0;\n+int flag_cprop_registers = 0;\n \n /* Nonzero for -pedantic switch: warn about anything\n    that standard spec forbids.  */\n@@ -1083,6 +1084,8 @@ lang_independent_options f_options[] =\n    N_(\"Reorder basic blocks to improve code placement\") },\n   {\"rename-registers\", &flag_rename_registers, 1,\n    N_(\"Do the register renaming optimization pass\") },\n+  {\"cprop-registers\", &flag_cprop_registers, 1,\n+   N_(\"Do the register copy-propagation optimization pass\") },\n   {\"common\", &flag_no_common, 0,\n    N_(\"Do not put uninitialized globals in the common section\") },\n   {\"inhibit-size-directive\", &flag_inhibit_size_directive, 1,\n@@ -3280,12 +3283,15 @@ rest_of_compilation (decl)\n     }\n #endif\n \n-  if (optimize > 0 && flag_rename_registers)\n+  if (flag_rename_registers || flag_cprop_registers)\n     {\n       timevar_push (TV_RENAME_REGISTERS);\n       open_dump_file (DFI_rnreg, decl);\n \n-      regrename_optimize ();\n+      if (flag_rename_registers)\n+        regrename_optimize ();\n+      if (flag_cprop_registers)\n+        copyprop_hardreg_forward ();\n \n       close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n       timevar_pop (TV_RENAME_REGISTERS);\n@@ -4620,6 +4626,7 @@ parse_options_and_default_flags (argc, argv)\n       flag_omit_frame_pointer = 1;\n #endif\n       flag_guess_branch_prob = 1;\n+      flag_cprop_registers = 1;\n     }\n \n   if (optimize >= 2)"}]}