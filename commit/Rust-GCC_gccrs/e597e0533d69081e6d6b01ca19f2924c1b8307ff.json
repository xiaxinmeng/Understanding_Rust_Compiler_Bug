{"sha": "e597e0533d69081e6d6b01ca19f2924c1b8307ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5N2UwNTMzZDY5MDgxZTZkNmIwMWNhMTlmMjkyNGMxYjgzMDdmZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-21T20:07:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-21T20:07:06Z"}, "message": "runtime: copy lfstack code from Go 1.7 runtime\n    \n    Note that lfstack_64bit.go was modified for Solaris support in a\n    different, and better, way than the superseded lfstack.goc code.\n    \n    Reviewed-on: https://go-review.googlesource.com/31673\n\nFrom-SVN: r241427", "tree": {"sha": "7c1aa0e24fac610637343c40fe8b6a76b60f3ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c1aa0e24fac610637343c40fe8b6a76b60f3ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e597e0533d69081e6d6b01ca19f2924c1b8307ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e597e0533d69081e6d6b01ca19f2924c1b8307ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e597e0533d69081e6d6b01ca19f2924c1b8307ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e597e0533d69081e6d6b01ca19f2924c1b8307ff/comments", "author": null, "committer": null, "parents": [{"sha": "16b61424dd309f61326f577a6deb8487c6c1f291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b61424dd309f61326f577a6deb8487c6c1f291", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b61424dd309f61326f577a6deb8487c6c1f291"}], "stats": {"total": 207, "additions": 88, "deletions": 119}, "files": [{"sha": "bc954f02cbda9cd194479ffc3877ef00249b1bcc", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -1,4 +1,4 @@\n-14dc8052a09ad0a2226e64ab6b5af69c6923b830\n+df6046971233854e5b7533140d4ead095ab69857\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1e99810f478873789bd5b70d2d3d2da1a0050cd6", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -488,7 +488,6 @@ runtime_files = \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tlfstack.c \\\n \tmalloc.c \\\n \truntime1.c \\\n \tsigqueue.c \\"}, {"sha": "c85ec502236d27d7492c8d671b7f0757f54e0f4d", "filename": "libgo/Makefile.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -252,8 +252,8 @@ am__objects_5 = go-append.lo go-assert.lo go-breakpoint.lo \\\n \tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n \t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n \tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n-\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) \\\n-\tlfstack.lo malloc.lo runtime1.lo sigqueue.lo $(am__objects_4)\n+\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) malloc.lo \\\n+\truntime1.lo sigqueue.lo $(am__objects_4)\n am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -884,7 +884,6 @@ runtime_files = \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tlfstack.c \\\n \tmalloc.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n@@ -1562,7 +1561,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unwind.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-varargs.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/heapdump.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lfstack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_a-go-main.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_llgo_a-go-main.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgolibbegin_a-go-libmain.Po@am__quote@"}, {"sha": "d3443566d9204f245966e2414dd65cd41b2f9fae", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -6,6 +6,10 @@\n \n package runtime\n \n+import (\n+\t\"unsafe\"\n+)\n+\n //var Fadd64 = fadd64\n //var Fsub64 = fsub64\n //var Fmul64 = fmul64\n@@ -32,11 +36,13 @@ type LFNode struct {\n \tPushcnt uintptr\n }\n \n-func lfstackpush_go(head *uint64, node *LFNode)\n-func lfstackpop_go(head *uint64) *LFNode\n+func LFStackPush(head *uint64, node *LFNode) {\n+\tlfstackpush(head, (*lfnode)(unsafe.Pointer(node)))\n+}\n \n-var LFStackPush = lfstackpush_go\n-var LFStackPop = lfstackpop_go\n+func LFStackPop(head *uint64) *LFNode {\n+\treturn (*LFNode)(unsafe.Pointer(lfstackpop(head)))\n+}\n \n type ParFor struct {\n \tbody   func(*ParFor, uint32)"}, {"sha": "2f2958c8869cee48054ea7e8a0924b24f76b3ec6", "filename": "libgo/go/runtime/lfstack.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flfstack.go?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Lock-free stack.\n+// Initialize head to 0, compare with 0 to test for emptiness.\n+// The stack does not keep pointers to nodes,\n+// so they can be garbage collected if there are no other pointers to nodes.\n+// The following code runs only in non-preemptible contexts.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"unsafe\"\n+)\n+\n+// Temporary for C code to call:\n+//go:linkname lfstackpush runtime.lfstackpush\n+//go:linkname lfstackpop runtime.lfstackpop\n+\n+func lfstackpush(head *uint64, node *lfnode) {\n+\tnode.pushcnt++\n+\tnew := lfstackPack(node, node.pushcnt)\n+\tif node1 := lfstackUnpack(new); node1 != node {\n+\t\tprint(\"runtime: lfstackpush invalid packing: node=\", node, \" cnt=\", hex(node.pushcnt), \" packed=\", hex(new), \" -> node=\", node1, \"\\n\")\n+\t\tthrow(\"lfstackpush\")\n+\t}\n+\tfor {\n+\t\told := atomic.Load64(head)\n+\t\tnode.next = old\n+\t\tif atomic.Cas64(head, old, new) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+func lfstackpop(head *uint64) unsafe.Pointer {\n+\tfor {\n+\t\told := atomic.Load64(head)\n+\t\tif old == 0 {\n+\t\t\treturn nil\n+\t\t}\n+\t\tnode := lfstackUnpack(old)\n+\t\tnext := atomic.Load64(&node.next)\n+\t\tif atomic.Cas64(head, old, next) {\n+\t\t\treturn unsafe.Pointer(node)\n+\t\t}\n+\t}\n+}"}, {"sha": "6a9920000841266d5ac0e7abe7cd673ebb3d6a1f", "filename": "libgo/go/runtime/lfstack_32bit.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack_32bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack_32bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flfstack_32bit.go?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build 386 arm nacl armbe m68k mips mipsle mips64p32 mips64p32le mipso32 mipsn32 s390 sparc\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// On 32-bit systems, the stored uint64 has a 32-bit pointer and 32-bit count.\n+\n+func lfstackPack(node *lfnode, cnt uintptr) uint64 {\n+\treturn uint64(uintptr(unsafe.Pointer(node)))<<32 | uint64(cnt)\n+}\n+\n+func lfstackUnpack(val uint64) *lfnode {\n+\treturn (*lfnode)(unsafe.Pointer(uintptr(val >> 32)))\n+}"}, {"sha": "213efb10706881f4f808f521c635098fa4f18ef9", "filename": "libgo/go/runtime/lfstack_64bit.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -2,9 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build ignore\n-\n-// +build amd64 arm64 mips64 mips64le ppc64 ppc64le s390x\n+// +build amd64 arm64 mips64 mips64le ppc64 ppc64le s390x arm64be alpha mipsn64 sparc64\n \n package runtime\n \n@@ -41,8 +39,8 @@ func lfstackPack(node *lfnode, cnt uintptr) uint64 {\n }\n \n func lfstackUnpack(val uint64) *lfnode {\n-\tif GOARCH == \"amd64\" {\n-\t\t// amd64 systems can place the stack above the VA hole, so we need to sign extend\n+\tif GOARCH == \"amd64\" || GOOS == \"solaris\" {\n+\t\t// amd64 or Solaris systems can place the stack above the VA hole, so we need to sign extend\n \t\t// val before unpacking.\n \t\treturn (*lfnode)(unsafe.Pointer(uintptr(int64(val) >> cntBits << 3)))\n \t}"}, {"sha": "5ab1baa436ebbe71bb9d8beeabb5c022f8a2130c", "filename": "libgo/runtime/lfstack.goc", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b61424dd309f61326f577a6deb8487c6c1f291/libgo%2Fruntime%2Flfstack.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b61424dd309f61326f577a6deb8487c6c1f291/libgo%2Fruntime%2Flfstack.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flfstack.goc?ref=16b61424dd309f61326f577a6deb8487c6c1f291", "patch": "@@ -1,95 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Lock-free stack.\n-\n-package runtime\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-\n-#if __SIZEOF_POINTER__ == 8\n-// SPARC64 and Solaris on AMD64 uses all 64 bits of virtual addresses.\n-// Use low-order three bits as ABA counter.\n-// http://docs.oracle.com/cd/E19120-01/open.solaris/816-5138/6mba6ua5p/index.html\n-# if defined(__sparc__) || (defined(__sun__) && defined(__amd64__))\n-static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n-\treturn ((uint64)(node)) | ((cnt)&7);\n-}\n-static inline LFNode* lfUnpack(uint64 val) {\n-\treturn (LFNode*)(val&~7);\n-}\n-# else\n-#  if defined(__aarch64__)\n-// Depending on the kernel options, pointers on arm64 can have up to 48 significant\n-// bits (see https://www.kernel.org/doc/Documentation/arm64/memory.txt).\n-#   define PTR_BITS 48\n-#  else\n-// Amd64 uses 48-bit virtual addresses, 47-th bit is used as kernel/user flag.\n-// So we use 17msb of pointers as ABA counter.\n-#   define PTR_BITS 47\n-#  endif\n-# define CNT_BITS (64 - PTR_BITS + 3)\n-static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n-\treturn ((uint64)(node)<<(64-PTR_BITS)) | (cnt&(((1<<CNT_BITS)-1)));\n-}\n-static inline LFNode* lfUnpack(uint64 val) {\n-\treturn (LFNode*)((val >> CNT_BITS) << 3);\n-}\n-# endif\n-#else\n-static inline uint64 lfPack(LFNode *node, uintptr cnt) {\n-\treturn ((uint64)(uintptr)(node)<<32) | cnt;\n-}\n-static inline LFNode* lfUnpack(uint64 val) {\n-\treturn (LFNode*)(uintptr)(val >> 32);\n-}\n-#endif\n-\n-void\n-runtime_lfstackpush(uint64 *head, LFNode *node)\n-{\n-\tuint64 old, new;\n-\n-\tif(node != lfUnpack(lfPack(node, 0))) {\n-\t\truntime_printf(\"p=%p\\n\", node);\n-\t\truntime_throw(\"runtime_lfstackpush: invalid pointer\");\n-\t}\n-\n-\tnode->pushcnt++;\n-\tnew = lfPack(node, node->pushcnt);\n-\tfor(;;) {\n-\t\told = runtime_atomicload64(head);\n-\t\tnode->next = lfUnpack(old);\n-\t\tif(runtime_cas64(head, old, new))\n-\t\t\tbreak;\n-\t}\n-}\n-\n-LFNode*\n-runtime_lfstackpop(uint64 *head)\n-{\n-\tLFNode *node, *node2;\n-\tuint64 old, new;\n-\n-\tfor(;;) {\n-\t\told = runtime_atomicload64(head);\n-\t\tif(old == 0)\n-\t\t\treturn nil;\n-\t\tnode = lfUnpack(old);\n-\t\tnode2 = runtime_atomicloadp(&node->next);\n-\t\tnew = 0;\n-\t\tif(node2 != nil)\n-\t\t\tnew = lfPack(node2, node2->pushcnt);\n-\t\tif(runtime_cas64(head, old, new))\n-\t\t\treturn node;\n-\t}\n-}\n-\n-func lfstackpush_go(head *uint64, node *LFNode) {\n-\truntime_lfstackpush(head, node);\n-}\n-\n-func lfstackpop_go(head *uint64) (node *LFNode) {\n-\tnode = runtime_lfstackpop(head);\n-}"}, {"sha": "8be0df4c17deed3d1a165f86daf76f15772da94f", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e597e0533d69081e6d6b01ca19f2924c1b8307ff/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=e597e0533d69081e6d6b01ca19f2924c1b8307ff", "patch": "@@ -67,7 +67,7 @@ typedef struct\tFixAlloc\tFixAlloc;\n typedef\tstruct\thchan\t\tHchan;\n typedef\tstruct\ttimer\t\tTimer;\n typedef\tstruct\tgcstats\t\tGCStats;\n-typedef\tstruct\tLFNode\t\tLFNode;\n+typedef\tstruct\tlfnode\t\tLFNode;\n typedef\tstruct\tParFor\t\tParFor;\n typedef\tstruct\tParForThread\tParForThread;\n typedef\tstruct\tcgoMal\t\tCgoMal;\n@@ -178,13 +178,6 @@ enum {\n };\n #endif\n \n-// Lock-free stack node.\n-struct LFNode\n-{\n-\tLFNode\t*next;\n-\tuintptr\tpushcnt;\n-};\n-\n // Parallel for descriptor.\n struct ParFor\n {\n@@ -461,7 +454,8 @@ bool\truntime_notetsleepg(Note*, int64)  // false - timeout\n  */\n void\truntime_lfstackpush(uint64 *head, LFNode *node)\n   __asm__ (GOSYM_PREFIX \"runtime.lfstackpush\");\n-LFNode*\truntime_lfstackpop(uint64 *head);\n+void*\truntime_lfstackpop(uint64 *head)\n+  __asm__ (GOSYM_PREFIX \"runtime.lfstackpop\");\n \n /*\n  * Parallel for over [0, n)."}]}