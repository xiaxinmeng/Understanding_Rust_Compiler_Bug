{"sha": "43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNiMGUxMjRlNDU1ZWJhYmU5ZGY2YmI0ZDk5NTliZWI5ZWI5YjYzMw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-04-10T08:59:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-04-10T08:59:54Z"}, "message": "shared_mutex (shared_timed_mutex): Add comments to explain the logic in the non-pthread_rwlock_t version.\n\n\t* include/std/shared_mutex (shared_timed_mutex): Add comments to\n\texplain the logic in the non-pthread_rwlock_t version.\n\t(_Mutex): Remove redundant type.\n\t(_M_n_readers): Rename to _S_max_readers.\n\t(_M_write_entered, _M_readers): New convenience functions.\n\t(lock, lock_shared, try_lock_shared, unlock_shared): Use convenience\n\tfunctions. Use predicates with condition variables. Simplify bitwise\n\toperations.\n\t(try_lock_for, try_shared_lock_for): Convert duration to time_point\n\tand call try_lock_until or try_shared_lock_until respectively.\n\t(try_lock_until, try_shared_lock_until): Wait on the condition\n\tvariables until the specified time passes.\n\t(unlock): Add Debug Mode assertion.\n\t(unlock_shared): Add Debug Mode assertion.\n\t* testsuite/30_threads/shared_timed_mutex/try_lock/3.cc: New.\n\nFrom-SVN: r221970", "tree": {"sha": "341639a9ee9569500b8fd45f9c968683b7026f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/341639a9ee9569500b8fd45f9c968683b7026f93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dccd8858cf03ab89fc167725dbdf7dffbe5ef923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dccd8858cf03ab89fc167725dbdf7dffbe5ef923", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dccd8858cf03ab89fc167725dbdf7dffbe5ef923"}], "stats": {"total": 273, "additions": 181, "deletions": 92}, "files": [{"sha": "e4ca68dee854ab26d3a5d33452f88f4c54dcb47f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "patch": "@@ -1,3 +1,21 @@\n+2015-04-10  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/shared_mutex (shared_timed_mutex): Add comments to\n+\texplain the logic in the non-pthread_rwlock_t version.\n+\t(_Mutex): Remove redundant type.\n+\t(_M_n_readers): Rename to _S_max_readers.\n+\t(_M_write_entered, _M_readers): New convenience functions.\n+\t(lock, lock_shared, try_lock_shared, unlock_shared): Use convenience\n+\tfunctions. Use predicates with condition variables. Simplify bitwise\n+\toperations.\n+\t(try_lock_for, try_shared_lock_for): Convert duration to time_point\n+\tand call try_lock_until or try_shared_lock_until respectively.\n+\t(try_lock_until, try_shared_lock_until): Wait on the condition\n+\tvariables until the specified time passes.\n+\t(unlock): Add Debug Mode assertion.\n+\t(unlock_shared): Add Debug Mode assertion.\n+\t* testsuite/30_threads/shared_timed_mutex/try_lock/3.cc: New.\n+\n 2015-04-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/abi/post/x86_64-linux-gnu/x32/baseline_symbols.txt: Update."}, {"sha": "7f26465788b19dbecd2f5cf92e4493c32fdeccda", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 88, "deletions": 92, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "patch": "@@ -268,33 +268,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #else // ! _GLIBCXX_USE_PTHREAD_RWLOCK_T\n \n-#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n-    struct _Mutex : mutex, __timed_mutex_impl<_Mutex>\n-    {\n-      template<typename _Rep, typename _Period>\n-\tbool\n-\ttry_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n-\t{ return _M_try_lock_for(__rtime); }\n-\n-      template<typename _Clock, typename _Duration>\n-\tbool\n-\ttry_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-\t{ return _M_try_lock_until(__atime); }\n-    };\n-#else\n-    typedef mutex _Mutex;\n-#endif\n-\n-    // Based on Howard Hinnant's reference implementation from N2406\n+    // Must use the same clock as condition_variable\n+    typedef chrono::system_clock\t__clock_t;\n \n-    _Mutex\t\t_M_mut;\n+    // Based on Howard Hinnant's reference implementation from N2406.\n+\n+    // The high bit of _M_state is the write-entered flag which is set to\n+    // indicate a writer has taken the lock or is queuing to take the lock.\n+    // The remaining bits are the count of reader locks.\n+    //\n+    // To take a reader lock, block on gate1 while the write-entered flag is\n+    // set or the maximum number of reader locks is held, then increment the\n+    // reader lock count.\n+    // To release, decrement the count, then if the write-entered flag is set\n+    // and the count is zero then signal gate2 to wake a queued writer,\n+    // otherwise if the maximum number of reader locks was held signal gate1\n+    // to wake a reader.\n+    //\n+    // To take a writer lock, block on gate1 while the write-entered flag is\n+    // set, then set the write-entered flag to start queueing, then block on\n+    // gate2 while the number of reader locks is non-zero.\n+    // To release, unset the write-entered flag and signal gate1 to wake all\n+    // blocked readers and writers.\n+    //\n+    // This means that when no reader locks are held readers and writers get\n+    // equal priority. When one or more reader locks is held a writer gets\n+    // priority and no more reader locks can be taken while the writer is\n+    // queued.\n+\n+    // Only locked when accessing _M_state or waiting on condition variables.\n+    mutex\t\t_M_mut;\n+    // Used to block while write-entered is set or reader count at maximum.\n     condition_variable\t_M_gate1;\n+    // Used to block queued writers while reader count is non-zero.\n     condition_variable\t_M_gate2;\n+    // The write-entered flag and reader count.\n     unsigned\t\t_M_state;\n \n     static constexpr unsigned _S_write_entered\n       = 1U << (sizeof(unsigned)*__CHAR_BIT__ - 1);\n-    static constexpr unsigned _M_n_readers = ~_S_write_entered;\n+    static constexpr unsigned _S_max_readers = ~_S_write_entered;\n+\n+    // Test whether the write-entered flag is set. _M_mut must be locked.\n+    bool _M_write_entered() const { return _M_state & _S_write_entered; }\n+\n+    // The number of reader locks currently held. _M_mut must be locked.\n+    unsigned _M_readers() const { return _M_state & _S_max_readers; }\n \n   public:\n     shared_timed_mutex() : _M_state(0) {}\n@@ -313,11 +332,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     lock()\n     {\n       unique_lock<mutex> __lk(_M_mut);\n-      while (_M_state & _S_write_entered)\n-\t_M_gate1.wait(__lk);\n+      // Wait until we can set the write-entered flag.\n+      _M_gate1.wait(__lk, [=]{ return !_M_write_entered(); });\n       _M_state |= _S_write_entered;\n-      while (_M_state & _M_n_readers)\n-\t_M_gate2.wait(__lk);\n+      // Then wait until there are no more readers.\n+      _M_gate2.wait(__lk, [=]{ return _M_readers() == 0; });\n     }\n \n     bool\n@@ -332,41 +351,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return false;\n     }\n \n-#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n     template<typename _Rep, typename _Period>\n       bool\n       try_lock_for(const chrono::duration<_Rep, _Period>& __rel_time)\n       {\n-\tunique_lock<_Mutex> __lk(_M_mut, __rel_time);\n-\tif (__lk.owns_lock() && _M_state == 0)\n-\t  {\n-\t    _M_state = _S_write_entered;\n-\t    return true;\n-\t  }\n-\treturn false;\n+\treturn try_lock_until(__clock_t::now() + __rel_time);\n       }\n \n     template<typename _Clock, typename _Duration>\n       bool\n       try_lock_until(const chrono::time_point<_Clock, _Duration>& __abs_time)\n       {\n-\tunique_lock<_Mutex> __lk(_M_mut, __abs_time);\n-\tif (__lk.owns_lock() && _M_state == 0)\n+\tunique_lock<mutex> __lk(_M_mut);\n+\tif (!_M_gate1.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return !_M_write_entered(); }))\n \t  {\n-\t    _M_state = _S_write_entered;\n-\t    return true;\n+\t    return false;\n \t  }\n-\treturn false;\n+\t_M_state |= _S_write_entered;\n+\tif (!_M_gate2.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return _M_readers() == 0; }))\n+\t  {\n+\t    _M_state ^= _S_write_entered;\n+\t    // Wake all threads blocked while the write-entered flag was set.\n+\t    _M_gate1.notify_all();\n+\t    return false;\n+\t  }\n+\treturn true;\n       }\n-#endif\n \n     void\n     unlock()\n     {\n-      {\n-\tlock_guard<_Mutex> __lk(_M_mut);\n-\t_M_state = 0;\n-      }\n+      lock_guard<mutex> __lk(_M_mut);\n+      _GLIBCXX_DEBUG_ASSERT( _M_write_entered() );\n+      _M_state = 0;\n+      // call notify_all() while mutex is held so that another thread can't\n+      // lock and unlock the mutex then destroy *this before we make the call.\n       _M_gate1.notify_all();\n     }\n \n@@ -376,90 +397,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     lock_shared()\n     {\n       unique_lock<mutex> __lk(_M_mut);\n-      while ((_M_state & _S_write_entered)\n-\t  || (_M_state & _M_n_readers) == _M_n_readers)\n-\t{\n-\t  _M_gate1.wait(__lk);\n-\t}\n-      unsigned __num_readers = (_M_state & _M_n_readers) + 1;\n-      _M_state &= ~_M_n_readers;\n-      _M_state |= __num_readers;\n+      _M_gate1.wait(__lk, [=]{ return _M_state < _S_max_readers; });\n+      ++_M_state;\n     }\n \n     bool\n     try_lock_shared()\n     {\n-      unique_lock<_Mutex> __lk(_M_mut, try_to_lock);\n-      unsigned __num_readers = _M_state & _M_n_readers;\n-      if (__lk.owns_lock() && !(_M_state & _S_write_entered)\n-\t  && __num_readers != _M_n_readers)\n+      unique_lock<mutex> __lk(_M_mut, try_to_lock);\n+      if (!__lk.owns_lock())\n+\treturn false;\n+      if (_M_state < _S_max_readers)\n \t{\n-\t  ++__num_readers;\n-\t  _M_state &= ~_M_n_readers;\n-\t  _M_state |= __num_readers;\n+\t  ++_M_state;\n \t  return true;\n \t}\n       return false;\n     }\n \n-#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n     template<typename _Rep, typename _Period>\n       bool\n       try_lock_shared_for(const chrono::duration<_Rep, _Period>& __rel_time)\n       {\n-\tunique_lock<_Mutex> __lk(_M_mut, __rel_time);\n-\tif (__lk.owns_lock())\n-\t  {\n-\t    unsigned __num_readers = _M_state & _M_n_readers;\n-\t    if (!(_M_state & _S_write_entered)\n-\t\t&& __num_readers != _M_n_readers)\n-\t      {\n-\t\t++__num_readers;\n-\t\t_M_state &= ~_M_n_readers;\n-\t\t_M_state |= __num_readers;\n-\t\treturn true;\n-\t      }\n-\t  }\n-\treturn false;\n+\treturn try_lock_shared_until(__clock_t::now() + __rel_time);\n       }\n \n     template <typename _Clock, typename _Duration>\n       bool\n       try_lock_shared_until(const chrono::time_point<_Clock,\n \t\t\t\t\t\t     _Duration>& __abs_time)\n       {\n-\tunique_lock<_Mutex> __lk(_M_mut, __abs_time);\n-\tif (__lk.owns_lock())\n+\tunique_lock<mutex> __lk(_M_mut);\n+\tif (!_M_gate1.wait_until(__lk, __abs_time,\n+\t\t\t\t [=]{ return _M_state < _S_max_readers; }))\n \t  {\n-\t    unsigned __num_readers = _M_state & _M_n_readers;\n-\t    if (!(_M_state & _S_write_entered)\n-\t\t&& __num_readers != _M_n_readers)\n-\t      {\n-\t\t++__num_readers;\n-\t\t_M_state &= ~_M_n_readers;\n-\t\t_M_state |= __num_readers;\n-\t\treturn true;\n-\t      }\n+\t    return false;\n \t  }\n-\treturn false;\n+\t++_M_state;\n+\treturn true;\n       }\n-#endif\n \n     void\n     unlock_shared()\n     {\n-      lock_guard<_Mutex> __lk(_M_mut);\n-      unsigned __num_readers = (_M_state & _M_n_readers) - 1;\n-      _M_state &= ~_M_n_readers;\n-      _M_state |= __num_readers;\n-      if (_M_state & _S_write_entered)\n+      lock_guard<mutex> __lk(_M_mut);\n+      _GLIBCXX_DEBUG_ASSERT( _M_readers() > 0 );\n+      auto __prev = _M_state--;\n+      if (_M_write_entered())\n \t{\n-\t  if (__num_readers == 0)\n+\t  // Wake the queued writer if there are no more readers.\n+\t  if (_M_readers() == 0)\n \t    _M_gate2.notify_one();\n+\t  // No need to notify gate1 because we give priority to the queued\n+\t  // writer, and that writer will eventually notify gate1 after it\n+\t  // clears the write-entered flag.\n \t}\n       else\n \t{\n-\t  if (__num_readers == _M_n_readers - 1)\n+\t  // Wake any thread that was blocked on reader overflow.\n+\t  if (__prev == _S_max_readers)\n \t    _M_gate1.notify_one();\n \t}\n     }"}, {"sha": "e9f728e09555069867faffec9bb97a1da2e201f0", "filename": "libstdc++-v3/testsuite/30_threads/shared_timed_mutex/try_lock/3.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_timed_mutex%2Ftry_lock%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43b0e124e455ebabe9df6bb4d9959beb9eb9b633/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_timed_mutex%2Ftry_lock%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fshared_timed_mutex%2Ftry_lock%2F3.cc?ref=43b0e124e455ebabe9df6bb4d9959beb9eb9b633", "patch": "@@ -0,0 +1,75 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++14 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++14 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++14 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2013-2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <shared_mutex>\n+#include <thread>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::shared_timed_mutex mutex_type;\n+\n+  try\n+    {\n+      mutex_type m;\n+      m.lock();\n+      bool b;\n+\n+      std::thread t([&] {\n+        try\n+          {\n+            using namespace std::chrono;\n+            auto timeout = 100ms;\n+            auto start = system_clock::now();\n+            b = m.try_lock_for(timeout);\n+            auto t = system_clock::now() - start;\n+            VERIFY( !b );\n+            VERIFY( t >= timeout );\n+\n+            start = system_clock::now();\n+            b = m.try_lock_until(start + timeout);\n+            t = system_clock::now() - start;\n+            VERIFY( !b );\n+            VERIFY( t >= timeout );\n+          }\n+        catch (const std::system_error& e)\n+          {\n+            VERIFY( false );\n+          }\n+      });\n+      t.join();\n+      m.unlock();\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}"}]}