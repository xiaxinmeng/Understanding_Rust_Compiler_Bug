{"sha": "f9808f81c98e92f3d590391f7924585208725c94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4MDhmODFjOThlOTJmM2Q1OTAzOTFmNzkyNDU4NTIwODcyNWM5NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-23T04:40:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-23T04:40:26Z"}, "message": "expr.c (do_preexpand_calls): Remove.\n\n\t* expr.c (do_preexpand_calls): Remove.\n\t(same_from_p): Don't use CALL_EXPR_RTL.\n\t(expand_expr): Don't call preexpand_calls, or use CALL_EXPR_RTL.\n\t(preexpand_calls): Remove.\n\t* tree.c (first_rtl_op): Remove CALL_EXPR case.\n\t(unsave_expr_1): Likewise.\n\t* tree.def (CALL_EXPR): Give it only two slots.\n\t* tree.h (CALL_EXPR_RTL): Remove.\n\n\t* optimize.c (copy_body_r): Don't treat CALL_EXPRs specially.\n\nFrom-SVN: r37012", "tree": {"sha": "a834ffb7437cb8a679af25dbc3ccd37302b72aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a834ffb7437cb8a679af25dbc3ccd37302b72aaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9808f81c98e92f3d590391f7924585208725c94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9808f81c98e92f3d590391f7924585208725c94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9808f81c98e92f3d590391f7924585208725c94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9808f81c98e92f3d590391f7924585208725c94/comments", "author": null, "committer": null, "parents": [{"sha": "0870bfd6d80b3711972ae5ce17564123727dee53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0870bfd6d80b3711972ae5ce17564123727dee53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0870bfd6d80b3711972ae5ce17564123727dee53"}], "stats": {"total": 191, "additions": 60, "deletions": 131}, "files": [{"sha": "8245daafde93c51419c8e2d62a36594ffd5a1aa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -1,3 +1,14 @@\n+2000-10-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* expr.c (do_preexpand_calls): Remove.\n+\t(same_from_p): Don't use CALL_EXPR_RTL.\n+\t(expand_expr): Don't call preexpand_calls, or use CALL_EXPR_RTL.\n+\t(preexpand_calls): Remove.\n+\t* tree.c (first_rtl_op): Remove CALL_EXPR case.\n+\t(unsave_expr_1): Likewise.\n+\t* tree.def (CALL_EXPR): Give it only two slots.\n+\t* tree.h (CALL_EXPR_RTL): Remove.\n+\n 2000-10-21  Chandrakala Chavva   <cchavva@redhat.com>\n \n \t* libgcc-std.ver (__addvsi3, __addvdi3,  __subvsi3, __subvdi3,"}, {"sha": "88f8c8dc75decf2b79b84c4afd162bfdfb3b52c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -1,5 +1,7 @@\n 2000-10-22  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* optimize.c (copy_body_r): Don't treat CALL_EXPRs specially.\n+\n \t* typeck.c (c_sizeof): Return an expression of `size_t' type, \n \tnot one with TYPE_IS_SIZETYPE set.\n \t(dubious_conversion_warnings): Remove special-case code."}, {"sha": "b8f13786fc6869da9ae3c54d988052acc80d04b8", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -336,10 +336,6 @@ copy_body_r (tp, walk_subtrees, data)\n \t  TREE_OPERAND (*tp, 1) = TREE_OPERAND (*tp, 3);\n \t  TREE_OPERAND (*tp, 3) = NULL_TREE;\n \t}\n-      /* Similarly, if we're copying a CALL_EXPR, the RTL for the\n-\t result is no longer valid.  */\n-      else if (TREE_CODE (*tp) == CALL_EXPR)\n-\tCALL_EXPR_RTL (*tp) = NULL_RTX;\n     }\n \n   /* Keep iterating.  */"}, {"sha": "b030c7a0c29dfe29e0795e5b484a7ed5b711b0bd", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 114, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -102,11 +102,6 @@ int (*lang_safe_from_p) PARAMS ((rtx, tree));\n    the same indirect address eventually.  */\n int cse_not_expected;\n \n-/* Nonzero to generate code for all the subroutines within an\n-   expression before generating the upper levels of the expression.\n-   Nowadays this is never zero.  */\n-int do_preexpand_calls = 1;\n-\n /* Don't check memory usage, since code is being emitted to check a memory\n    usage.  Used when current_function_check_memory_usage is true, to avoid\n    infinite recursion.  */\n@@ -183,7 +178,6 @@ static rtx var_rtx\t\tPARAMS ((tree));\n static int readonly_fields_p\tPARAMS ((tree));\n static rtx expand_expr_unaligned PARAMS ((tree, unsigned int *));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n-static void preexpand_calls\tPARAMS ((tree));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n static void do_compare_and_jump\tPARAMS ((tree, enum rtx_code, enum rtx_code,\n@@ -5533,16 +5527,11 @@ safe_from_p (x, exp, top_p)\n \t  break;\n \n \tcase CALL_EXPR:\n-\t  exp_rtl = CALL_EXPR_RTL (exp);\n-\t  if (exp_rtl == 0)\n-\t    {\n-\t      /* Assume that the call will clobber all hard registers and\n-\t\t all of memory.  */\n-\t      if ((GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t\t  || GET_CODE (x) == MEM)\n-\t\treturn 0;\n-\t    }\n-\n+\t  /* Assume that the call will clobber all hard registers and\n+\t     all of memory.  */\n+\t  if ((GET_CODE (x) == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t      || GET_CODE (x) == MEM)\n+\t    return 0;\n \t  break;\n \n \tcase RTL_EXPR:\n@@ -7030,8 +7019,6 @@ expand_expr (exp, target, tmode, modifier)\n \trtx rlow;\n \trtx diff, quo, rem, addr, bit, result;\n \n-\tpreexpand_calls (exp);\n-\n \t/* If domain is empty, answer is no.  Likewise if index is constant\n \t   and out of bounds.  */\n \tif (((TREE_CODE (set_high_bound) == INTEGER_CST\n@@ -7154,11 +7141,6 @@ expand_expr (exp, target, tmode, modifier)\n \t    return expand_builtin (exp, target, subtarget, tmode, ignore);\n \t}\n \n-      /* If this call was expanded already by preexpand_calls,\n-\t just return the result we got.  */\n-      if (CALL_EXPR_RTL (exp) != 0)\n-\treturn CALL_EXPR_RTL (exp);\n-\n       return expand_call (exp, target, ignore);\n \n     case NON_LVALUE_EXPR:\n@@ -7354,7 +7336,6 @@ expand_expr (exp, target, tmode, modifier)\n \t  || mode != ptr_mode)\n \tgoto binop;\n \n-      preexpand_calls (exp);\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n \n@@ -7453,7 +7434,6 @@ expand_expr (exp, target, tmode, modifier)\n       goto binop;\n \n     case MULT_EXPR:\n-      preexpand_calls (exp);\n       /* If first operand is constant, swap them.\n \t Thus the following special case checks need only\n \t check the second operand.  */\n@@ -7580,7 +7560,6 @@ expand_expr (exp, target, tmode, modifier)\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      preexpand_calls (exp);\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n@@ -7598,7 +7577,6 @@ expand_expr (exp, target, tmode, modifier)\n     case FLOOR_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      preexpand_calls (exp);\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n@@ -7760,7 +7738,6 @@ expand_expr (exp, target, tmode, modifier)\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n-      preexpand_calls (exp);\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n@@ -7782,7 +7759,6 @@ expand_expr (exp, target, tmode, modifier)\n     case UNGT_EXPR:\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n-      preexpand_calls (exp);\n       temp = do_store_flag (exp, target, tmode != VOIDmode ? tmode : mode, 0);\n       if (temp != 0)\n \treturn temp;\n@@ -8280,7 +8256,6 @@ expand_expr (exp, target, tmode, modifier)\n \t    && TREE_CODE (lhs) != PARM_DECL\n \t    && ! (TREE_CODE (lhs) == INDIRECT_REF\n \t\t  && TYPE_READONLY (TREE_TYPE (TREE_OPERAND (lhs, 0)))))\n-\t  preexpand_calls (exp);\n \n \t/* Check for |= or &= of a bitfield of size one into another bitfield\n \t   of size 1.  In this case, (unless we need the result of the\n@@ -8608,7 +8583,6 @@ expand_expr (exp, target, tmode, modifier)\n   /* Here to do an ordinary binary operator, generating an instruction\n      from the optab already placed in `this_optab'.  */\n  binop:\n-  preexpand_calls (exp);\n   if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n     subtarget = 0;\n   op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n@@ -9180,88 +9154,6 @@ expand_increment (exp, post, ignore)\n   return temp;\n }\n \f\n-/* Expand all function calls contained within EXP, innermost ones first.\n-   But don't look within expressions that have sequence points.\n-   For each CALL_EXPR, record the rtx for its value\n-   in the CALL_EXPR_RTL field.  */\n-\n-static void\n-preexpand_calls (exp)\n-     tree exp;\n-{\n-  register int nops, i;\n-  int class = TREE_CODE_CLASS (TREE_CODE (exp));\n-\n-  if (! do_preexpand_calls)\n-    return;\n-\n-  /* Only expressions and references can contain calls.  */\n-\n-  if (! IS_EXPR_CODE_CLASS (class) && class != 'r')\n-    return;\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case CALL_EXPR:\n-      /* Do nothing if already expanded.  */\n-      if (CALL_EXPR_RTL (exp) != 0\n-\t  /* Do nothing if the call returns a variable-sized object.  */\n-\t  || (TREE_CODE (TREE_TYPE (exp)) != VOID_TYPE\n-\t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) != INTEGER_CST)\n-\t  /* Do nothing to built-in functions.  */\n-\t  || (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t\t  == FUNCTION_DECL)\n-\t      && DECL_BUILT_IN (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))))\n-\treturn;\n-\n-      CALL_EXPR_RTL (exp) = expand_call (exp, NULL_RTX, 0);\n-      return;\n-\n-    case COMPOUND_EXPR:\n-    case COND_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-      /* If we find one of these, then we can be sure\n-\t the adjust will be done for it (since it makes jumps).\n-\t Do it now, so that if this is inside an argument\n-\t of a function, we don't get the stack adjustment\n-\t after some other args have already been pushed.  */\n-      do_pending_stack_adjust ();\n-      return;\n-\n-    case BLOCK:\n-    case RTL_EXPR:\n-    case WITH_CLEANUP_EXPR:\n-    case CLEANUP_POINT_EXPR:\n-    case TRY_CATCH_EXPR:\n-      return;\n-\n-    case SAVE_EXPR:\n-      if (SAVE_EXPR_RTL (exp) != 0)\n-\treturn;\n-\n-    default:\n-      break;\n-    }\n-\n-  nops = TREE_CODE_LENGTH (TREE_CODE (exp));\n-  for (i = 0; i < nops; i++)\n-    if (TREE_OPERAND (exp, i) != 0)\n-      {\n-\tif (TREE_CODE (exp) == TARGET_EXPR && i == 2)\n-\t  /* We don't need to preexpand the cleanup for a TARGET_EXPR.\n-\t     It doesn't happen before the call is made.  */\n-\t  ;\n-\telse\n-\t  {\n-\t    class = TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, i)));\n-\t    if (IS_EXPR_CODE_CLASS (class) || class == 'r')\n-\t      preexpand_calls (TREE_OPERAND (exp, i));\n-\t  }\n-      }\n-}\n-\f\n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n \n@@ -10428,7 +10320,6 @@ do_store_flag (exp, target, mode, only_cheap)\n \treturn 0;\n     }\n \n-  preexpand_calls (exp);\n   if (! get_subtarget (target)\n       || GET_MODE (subtarget) != operand_mode\n       || ! safe_from_p (subtarget, arg1, 1))"}, {"sha": "c8f7babb0648fed1cad67d979e872852b916def9", "filename": "gcc/testsuite/g++.old-deja/g++.other/dtor10.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdtor10.C?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -0,0 +1,40 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+extern \"C\" void abort ();\n+\n+int j;\n+\n+struct S {\n+  static S* s[5];\n+\n+  S () { s[j++] = this; }\n+  S (const S&) { s[j++] = this; }\n+  ~S () { \n+    for (int k = 0; k < j; ++k)\n+      if (s[k] == this)\n+\treturn;\n+    abort ();\n+  }\n+};\n+\n+S* S::s[5];\n+\n+struct T {\n+  int i;\n+  S s;\n+};\n+\n+T t;\n+\n+T f () {\n+  return t;\n+}\n+\n+void g (S) {\n+};\n+\n+int main ()\n+{\n+  g (f ().s);\n+}\n+"}, {"sha": "4bebf20d55cbbecb495aaa784e1df9a8cb3ef0bd", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -1764,8 +1764,6 @@ first_rtl_op (code)\n     case GOTO_SUBROUTINE_EXPR:\n     case RTL_EXPR:\n       return 0;\n-    case CALL_EXPR:\n-      return 2;\n     case WITH_CLEANUP_EXPR:\n       /* Should be defined to be 2.  */\n       return 1;\n@@ -1808,10 +1806,6 @@ unsave_expr_1 (expr)\n \tabort ();\n       break;\n \n-    case CALL_EXPR:\n-      CALL_EXPR_RTL (expr) = 0;\n-      break;\n-\n     default:\n       if (lang_unsave_expr_now != 0)\n \t(*lang_unsave_expr_now) (expr);"}, {"sha": "c61a5ff578bee69ebc4fa3aff07ea65b82665a0d", "filename": "gcc/tree.def", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -454,10 +454,8 @@ DEFTREECODE (BIND_EXPR, \"bind_expr\", 'e', 3)\n \n /* Function call.  Operand 0 is the function.\n    Operand 1 is the argument list, a list of expressions\n-   made out of a chain of TREE_LIST nodes.\n-   There is no operand 2.  That slot is used for the\n-   CALL_EXPR_RTL macro (see preexpand_calls).  */\n-DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 3)\n+   made out of a chain of TREE_LIST nodes.  */\n+DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 2)\n \n /* Call a method.  Operand 0 is the method, whose type is a METHOD_TYPE.\n    Operand 1 is the expression for \"self\"."}, {"sha": "17f09a13acf37094320c41483d88b946bacadb87", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9808f81c98e92f3d590391f7924585208725c94/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f9808f81c98e92f3d590391f7924585208725c94", "patch": "@@ -780,9 +780,6 @@ struct tree_vec\n #define RTL_EXPR_SEQUENCE(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[0])\n #define RTL_EXPR_RTL(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[1])\n \n-/* In a CALL_EXPR node.  */\n-#define CALL_EXPR_RTL(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[2])\n-\n /* In a CONSTRUCTOR node.  */\n #define CONSTRUCTOR_ELTS(NODE) TREE_OPERAND (NODE, 1)\n "}]}