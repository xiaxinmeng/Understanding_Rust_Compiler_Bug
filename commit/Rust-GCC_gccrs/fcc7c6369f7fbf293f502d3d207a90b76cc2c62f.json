{"sha": "fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjN2M2MzY5ZjdmYmYyOTNmNTAyZDNkMjA3YTkwYjc2Y2MyYzYyZg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-06-15T10:20:43Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-07-27T10:01:37Z"}, "message": "Implement basic block path solver.\n\nThis is is the main basic block path solver for use in the ranger-based\nbackwards threader.  Given a path of BBs, the class can solve the final\nconditional or any SSA name used in calculating the final conditional.\n\ngcc/ChangeLog:\n\n\t* Makefile.in (OBJS): Add gimple-range-path.o.\n\t* gimple-range-path.cc: New file.\n\t* gimple-range-path.h: New file.", "tree": {"sha": "78044ef9298f34a8e1c5b771250e8a5539c1c416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78044ef9298f34a8e1c5b771250e8a5539c1c416"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bc9db6a989671bedf19e61bd1b21f79588e99da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc9db6a989671bedf19e61bd1b21f79588e99da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc9db6a989671bedf19e61bd1b21f79588e99da"}], "stats": {"total": 415, "additions": 415, "deletions": 0}, "files": [{"sha": "29bd4edb4b7e0353db64380a44585ec2eb26a651", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "patch": "@@ -1650,6 +1650,7 @@ OBJS = \\\n \ttree-ssa-loop.o \\\n \ttree-ssa-math-opts.o \\\n \ttree-ssa-operands.o \\\n+\tgimple-range-path.o \\\n \ttree-ssa-phiopt.o \\\n \ttree-ssa-phiprop.o \\\n \ttree-ssa-pre.o \\"}, {"sha": "a8226a6810fae9c187834d6717925c5188394b18", "filename": "gcc/gimple-range-path.cc", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "patch": "@@ -0,0 +1,329 @@\n+/* Basic block path solver.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"cfganal.h\"\n+#include \"value-range.h\"\n+#include \"gimple-range.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-range-path.h\"\n+#include \"ssa.h\"\n+\n+// Internal construct to help facilitate debugging of solver.\n+#define DEBUG_SOLVER (0 && dump_file)\n+\n+path_range_query::path_range_query (gimple_ranger &ranger)\n+  : m_ranger (ranger)\n+{\n+  m_cache = new ssa_global_cache;\n+  m_has_cache_entry = BITMAP_ALLOC (NULL);\n+  m_path = NULL;\n+}\n+\n+path_range_query::~path_range_query ()\n+{\n+  BITMAP_FREE (m_has_cache_entry);\n+  delete m_cache;\n+}\n+\n+// Mark cache entry for NAME as unused.\n+\n+void\n+path_range_query::clear_cache (tree name)\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  bitmap_clear_bit (m_has_cache_entry, v);\n+}\n+\n+// If NAME has a cache entry, return it in R, and return TRUE.\n+\n+inline bool\n+path_range_query::get_cache (irange &r, tree name)\n+{\n+  if (!gimple_range_ssa_p (name))\n+    return get_global_range_query ()->range_of_expr (r, name);\n+\n+  unsigned v = SSA_NAME_VERSION (name);\n+  if (bitmap_bit_p (m_has_cache_entry, v))\n+    return m_cache->get_global_range (r, name);\n+\n+  return false;\n+}\n+\n+// Set the cache entry for NAME to R.\n+\n+void\n+path_range_query::set_cache (const irange &r, tree name)\n+{\n+  unsigned v = SSA_NAME_VERSION (name);\n+  bitmap_set_bit (m_has_cache_entry, v);\n+  m_cache->set_global_range (name, r);\n+}\n+\n+void\n+path_range_query::dump (FILE *dump_file)\n+{\n+  if (m_path->is_empty ())\n+    return;\n+\n+  unsigned i;\n+  bitmap_iterator bi;\n+  extern void dump_ranger (FILE *, const vec<basic_block> &);\n+\n+  fprintf (dump_file, \"Path is:\\n\");\n+  dump_ranger (dump_file, *m_path);\n+\n+  fprintf (dump_file, \"Imports:\\n\");\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  m_cache->dump (dump_file);\n+}\n+\n+void\n+path_range_query::debug ()\n+{\n+  dump (stderr);\n+}\n+\n+// Return the range of NAME at the end of the path being analyzed.\n+\n+bool\n+path_range_query::range_of_expr (irange &r, tree name, gimple *stmt)\n+{\n+  if (!irange::supports_type_p (TREE_TYPE (name)))\n+    return false;\n+\n+  if (get_cache (r, name))\n+    return true;\n+\n+\n+  basic_block bb = stmt ? gimple_bb (stmt) : exit_bb ();\n+  if (stmt && range_defined_in_block (r, name, bb))\n+    {\n+      set_cache (r, name);\n+      return true;\n+    }\n+\n+  r.set_varying (TREE_TYPE (name));\n+  return true;\n+}\n+\n+// Return the range of STMT at the end of the path being analyzed.\n+// Anything but the final conditional in a BB will return VARYING.\n+\n+bool\n+path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n+{\n+  tree type = gimple_range_type (stmt);\n+\n+  if (!irange::supports_type_p (type))\n+    return false;\n+\n+  if (gimple_code (stmt) == GIMPLE_COND && fold_range (r, stmt, this))\n+    return true;\n+\n+  r.set_varying (type);\n+  return true;\n+}\n+\n+// Initialize the current path to PATH.  The current block is set to\n+// the entry block to the path.\n+//\n+// Note that the blocks are in reverse order, so the exit block is\n+// path[0].\n+\n+void\n+path_range_query::set_path (const vec<basic_block> &path)\n+{\n+  gcc_checking_assert (path.length () > 1);\n+  m_path = &path;\n+  m_pos = m_path->length () - 1;\n+  bitmap_clear (m_has_cache_entry);\n+}\n+\n+// Return the range of the result of PHI in R.\n+\n+void\n+path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n+{\n+  tree name = gimple_phi_result (phi);\n+  basic_block bb = gimple_bb (phi);\n+\n+  // We experimented with querying ranger's range_on_entry here, but\n+  // the performance penalty was too high, for hardly any improvements.\n+  if (at_entry ())\n+    {\n+      // Try fold just in case we can resolve simple things like PHI <5(99), 6(88)>.\n+      if (!fold_range (r, phi, this))\n+\tr.set_varying (TREE_TYPE (name));\n+\n+      return;\n+    }\n+\n+  basic_block prev = prev_bb ();\n+  edge e_in = find_edge (prev, bb);\n+  unsigned nargs = gimple_phi_num_args (phi);\n+\n+  for (size_t i = 0; i < nargs; ++i)\n+    if (e_in == gimple_phi_arg_edge (phi, i))\n+      {\n+\ttree arg = gimple_phi_arg_def (phi, i);\n+\n+\tif (!get_cache (r, arg))\n+\t  r.set_varying (TREE_TYPE (name));\n+\n+\treturn;\n+      }\n+  gcc_unreachable ();\n+}\n+\n+// If NAME is defined in BB, set R to the range of NAME, and return\n+// TRUE.  Otherwise, return FALSE.\n+\n+bool\n+path_range_query::range_defined_in_block (irange &r, tree name, basic_block bb)\n+{\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+  basic_block def_bb = gimple_bb (def_stmt);\n+\n+  if (def_bb != bb)\n+    return false;\n+\n+  if (gimple_code (def_stmt) == GIMPLE_PHI)\n+    ssa_range_in_phi (r, as_a<gphi *> (def_stmt));\n+  else if (!fold_range (r, def_stmt, this))\n+    r.set_varying (TREE_TYPE (name));\n+\n+  if (DEBUG_SOLVER)\n+    {\n+      fprintf (dump_file, \"range_defined_in_block (BB%d) for \", bb->index);\n+      print_generic_expr (dump_file, name, TDF_SLIM);\n+      fprintf (dump_file, \" is \");\n+      r.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  return true;\n+}\n+\n+// Precompute ranges defined in the current block, or ranges\n+// that are exported on an edge to the next block.\n+\n+void\n+path_range_query::precompute_ranges_in_block (basic_block bb)\n+{\n+  bitmap_iterator bi;\n+  int_range_max r, cached_range;\n+  unsigned i;\n+\n+  // Force recalculation of any names in the cache that are defined in\n+  // this block.  This can happen on interdependent SSA/phis in loops.\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+      basic_block def_bb = gimple_bb (def_stmt);\n+\n+      if (def_bb == bb)\n+\tclear_cache (name);\n+    }\n+\n+  // Solve imports defined in this block.\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+\n+      if (range_defined_in_block (r, name, bb))\n+\tset_cache (r, name);\n+    }\n+\n+  if (at_exit ())\n+    return;\n+\n+  // Solve imports that are exported to the next block.\n+  edge e = find_edge (bb, next_bb ());\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      gori_compute &g = m_ranger.gori ();\n+      bitmap exports = g.exports (bb);\n+\n+      if (bitmap_bit_p (exports, i))\n+\t{\n+\t  if (g.outgoing_edge_range_p (r, e, name, *this))\n+\t    {\n+\t      if (get_cache (cached_range, name))\n+\t\tr.intersect (cached_range);\n+\n+\t      set_cache (r, name);\n+\t      if (DEBUG_SOLVER)\n+\t\t{\n+\t\t  fprintf (dump_file, \"outgoing_edge_range_p for \");\n+\t\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" on edge %d->%d \",\n+\t\t\t   e->src->index, e->dest->index);\n+\t\t  fprintf (dump_file, \"is \");\n+\t\t  r.dump (dump_file);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+// Precompute the ranges for IMPORTS along PATH.\n+//\n+// IMPORTS are the set of SSA names, any of which could potentially\n+// change the value of the final conditional in PATH.\n+\n+void\n+path_range_query::precompute_ranges (const vec<basic_block> &path,\n+\t\t\t\t     const bitmap_head *imports)\n+{\n+  set_path (path);\n+  m_imports = imports;\n+\n+  if (DEBUG_SOLVER)\n+    fprintf (dump_file, \"path_range_query: precompute_ranges\\n\");\n+\n+  while (1)\n+    {\n+      basic_block bb = curr_bb ();\n+\n+      precompute_ranges_in_block (bb);\n+\n+      if (at_exit ())\n+\tbreak;\n+\n+      move_next ();\n+    }\n+\n+  if (DEBUG_SOLVER)\n+    dump (dump_file);\n+}"}, {"sha": "43f0ec8028608b73e37ed0501a6be4e861847f11", "filename": "gcc/gimple-range-path.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcc7c6369f7fbf293f502d3d207a90b76cc2c62f/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=fcc7c6369f7fbf293f502d3d207a90b76cc2c62f", "patch": "@@ -0,0 +1,85 @@\n+/* Header file for jump threading path solver.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_SSA_THREADSOLVER_H\n+#define GCC_TREE_SSA_THREADSOLVER_H\n+\n+// This class is a basic block path solver.  Given a set of BBs\n+// indicating a path through the CFG, range_of_expr and range_of_stmt\n+// will calculate the range of an SSA or STMT as if the BBs in the\n+// path would have been executed in order.\n+//\n+// Only SSA names passed in IMPORTS are precomputed, and can be\n+// queried.\n+//\n+// Note that the blocks are in reverse order, thus the exit block is\n+// path[0].\n+\n+class path_range_query : public range_query\n+{\n+public:\n+  path_range_query (class gimple_ranger &ranger);\n+  virtual ~path_range_query ();\n+  void precompute_ranges (const vec<basic_block> &path,\n+\t\t\t  const bitmap_head *imports);\n+  bool range_of_expr (irange &r, tree name, gimple * = NULL) override;\n+  bool range_of_stmt (irange &r, gimple *, tree name = NULL) override;\n+  void dump (FILE *);\n+  void debug ();\n+\n+private:\n+  // Cache manipulation.\n+  void set_cache (const irange &r, tree name);\n+  bool get_cache (irange &r, tree name);\n+  void clear_cache (tree name);\n+\n+  // Methods to precompute ranges for the given path.\n+  bool range_defined_in_block (irange &, tree name, basic_block bb);\n+  void precompute_ranges_in_block (basic_block bb);\n+  void ssa_range_in_phi (irange &r, gphi *phi);\n+\n+  // Path navigation.\n+  void set_path (const vec<basic_block> &);\n+  basic_block entry_bb () { return (*m_path)[m_path->length () - 1]; }\n+  basic_block exit_bb ()  { return (*m_path)[0]; }\n+  basic_block curr_bb ()  { return (*m_path)[m_pos]; }\n+  basic_block prev_bb ()  { return (*m_path)[m_pos + 1]; }\n+  basic_block next_bb ()  { return (*m_path)[m_pos - 1]; }\n+  bool at_entry ()\t  { return m_pos == m_path->length () - 1; }\n+  bool at_exit ()\t  { return m_pos == 0; }\n+  void move_next ()\t  { --m_pos; }\n+\n+  // Range cache for SSA names.\n+  ssa_global_cache *m_cache;\n+\n+  // Set for each SSA that has an active entry in the cache.\n+  bitmap m_has_cache_entry;\n+\n+  // Path being analyzed.\n+  const vec<basic_block> *m_path;\n+\n+  // Current path position.\n+  unsigned m_pos;\n+\n+  const bitmap_head *m_imports;\n+  gimple_ranger &m_ranger;\n+};\n+\n+#endif // GCC_TREE_SSA_THREADSOLVER_H"}]}