{"sha": "4c42b3d84fb4bd1539147b3aa1834d935818b869", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM0MmIzZDg0ZmI0YmQxNTM5MTQ3YjNhYTE4MzRkOTM1ODE4Yjg2OQ==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2007-12-06T22:02:22Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2007-12-06T22:02:22Z"}, "message": "ffi.h.in (FFI_SIZEOF_JAVA_RAW): Define if not\talready defined.\n\n2007-12-06  David Daney  <ddaney@avtrex.com>\n\n\t* include/ffi.h.in (FFI_SIZEOF_JAVA_RAW): Define if not\talready\n\tdefined.\n\t(ffi_java_raw): New typedef.\n\t(ffi_java_raw_call, ffi_java_ptrarray_to_raw,\n\tffi_java_raw_to_ptrarray): Change parameter types from ffi_raw to\n\tffi_java_raw.\n\t(ffi_java_raw_closure) : Same.\n\t(ffi_prep_java_raw_closure, ffi_prep_java_raw_closure_loc): Change\n\tparameter types.\n\t* src/java_raw_api.c (ffi_java_raw_size):  Replace FFI_SIZEOF_ARG with\n\tFFI_SIZEOF_JAVA_RAW.\n\t(ffi_java_raw_to_ptrarray): Change type of raw to ffi_java_raw.\n\tReplace FFI_SIZEOF_ARG with FFI_SIZEOF_JAVA_RAW. Use\n\tsizeof(ffi_java_raw) for alignment calculations.\n\t(ffi_java_ptrarray_to_raw): Same.\n\t(ffi_java_rvalue_to_raw): Add special handling for FFI_TYPE_POINTER\n        if FFI_SIZEOF_JAVA_RAW == 4.\n\t(ffi_java_raw_to_rvalue): Same.\n\t(ffi_java_raw_call): Change type of raw to ffi_java_raw.\n\t(ffi_java_translate_args): Same.\n\t(ffi_prep_java_raw_closure_loc, ffi_prep_java_raw_closure): Change\n\tparameter types.\n\t* src/mips/ffitarget.h (FFI_SIZEOF_JAVA_RAW): Define for N32 ABI.\n\n2007-12-06  David Daney  <ddaney@avtrex.com>\n\n\t* interpret.cc: Replace ffi_raw with INTERP_FFI_RAW_TYPE throughout.\n\t(ncode_closure, ffi_closure_fun): Define versions for\n\tnon-FFI_NATIVE_RAW_API case.\n\t* include/java-interp.h (INTERP_FFI_RAW_TYPE): Define and use to\n\treplace\tffi_raw throughout.\n\t* jni.cc, interpret-run.cc: Replace ffi_raw with INTERP_FFI_RAW_TYPE\n\tthroughout.\n\nFrom-SVN: r130660", "tree": {"sha": "0d9df68f8f49c169b13d4425dee7410372b96a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d9df68f8f49c169b13d4425dee7410372b96a19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c42b3d84fb4bd1539147b3aa1834d935818b869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c42b3d84fb4bd1539147b3aa1834d935818b869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c42b3d84fb4bd1539147b3aa1834d935818b869", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c42b3d84fb4bd1539147b3aa1834d935818b869/comments", "author": null, "committer": null, "parents": [{"sha": "6af5d898a5aa667e20681fb5284394ad77c2dc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af5d898a5aa667e20681fb5284394ad77c2dc68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6af5d898a5aa667e20681fb5284394ad77c2dc68"}], "stats": {"total": 234, "additions": 170, "deletions": 64}, "files": [{"sha": "3a937c48bed3235eb3b2ad66d032970402aff002", "filename": "libffi/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -1,3 +1,29 @@\n+2007-12-06  David Daney  <ddaney@avtrex.com>\n+\n+\t* include/ffi.h.in (FFI_SIZEOF_JAVA_RAW): Define if not\talready\n+\tdefined.\n+\t(ffi_java_raw): New typedef.\n+\t(ffi_java_raw_call, ffi_java_ptrarray_to_raw,\n+\tffi_java_raw_to_ptrarray): Change parameter types from ffi_raw to\n+\tffi_java_raw.\n+\t(ffi_java_raw_closure) : Same.\n+\t(ffi_prep_java_raw_closure, ffi_prep_java_raw_closure_loc): Change\n+\tparameter types.\n+\t* src/java_raw_api.c (ffi_java_raw_size):  Replace FFI_SIZEOF_ARG with\n+\tFFI_SIZEOF_JAVA_RAW.\n+\t(ffi_java_raw_to_ptrarray): Change type of raw to ffi_java_raw.\n+\tReplace FFI_SIZEOF_ARG with FFI_SIZEOF_JAVA_RAW. Use\n+\tsizeof(ffi_java_raw) for alignment calculations.\n+\t(ffi_java_ptrarray_to_raw): Same.\n+\t(ffi_java_rvalue_to_raw): Add special handling for FFI_TYPE_POINTER\n+        if FFI_SIZEOF_JAVA_RAW == 4.\n+\t(ffi_java_raw_to_rvalue): Same.\n+\t(ffi_java_raw_call): Change type of raw to ffi_java_raw.\n+\t(ffi_java_translate_args): Same.\n+\t(ffi_prep_java_raw_closure_loc, ffi_prep_java_raw_closure): Change\n+\tparameter types.\n+\t* src/mips/ffitarget.h (FFI_SIZEOF_JAVA_RAW): Define for N32 ABI.\n+\n 2007-12-06  David Daney  <ddaney@avtrex.com>\n \n \t* src/mips/n32.S (ffi_closure_N32): Use 64-bit add instruction on "}, {"sha": "7784b2e395d880893df534e1a640d01934f6f394", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -193,6 +193,10 @@ typedef struct {\n # endif\n #endif\n \n+#ifndef FFI_SIZEOF_JAVA_RAW\n+#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG\n+#endif\n+\n typedef union {\n   ffi_sarg  sint;\n   ffi_arg   uint;\n@@ -201,6 +205,21 @@ typedef union {\n   void*     ptr;\n } ffi_raw;\n \n+#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8\n+/* This is a special case for mips64/n32 ABI (and perhaps others) where\n+   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */\n+typedef union {\n+  signed int\tsint;\n+  unsigned int\tuint;\n+  float\t\tflt;\n+  char\t\tdata[FFI_SIZEOF_JAVA_RAW];\n+  void*\t\tptr;\n+} ffi_java_raw;\n+#else\n+typedef ffi_raw ffi_java_raw;\n+#endif\n+\n+\n void ffi_raw_call (ffi_cif *cif,\n \t\t   void (*fn)(),\n \t\t   void *rvalue,\n@@ -217,10 +236,10 @@ size_t ffi_raw_size (ffi_cif *cif);\n void ffi_java_raw_call (ffi_cif *cif,\n \t\t\tvoid (*fn)(),\n \t\t\tvoid *rvalue,\n-\t\t\tffi_raw *avalue);\n+\t\t\tffi_java_raw *avalue);\n \n-void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);\n-void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);\n+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);\n+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);\n size_t ffi_java_raw_size (ffi_cif *cif);\n \n /* ---- Definitions for closures ----------------------------------------- */\n@@ -271,6 +290,27 @@ typedef struct {\n \n } ffi_raw_closure;\n \n+typedef struct {\n+  char tramp[FFI_TRAMPOLINE_SIZE];\n+\n+  ffi_cif   *cif;\n+\n+#if !FFI_NATIVE_RAW_API\n+\n+  /* if this is enabled, then a raw closure has the same layout \n+     as a regular closure.  We use this to install an intermediate \n+     handler to do the transaltion, void** -> ffi_raw*. */\n+\n+  void     (*translate_args)(ffi_cif*,void*,void**,void*);\n+  void      *this_closure;\n+\n+#endif\n+\n+  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);\n+  void      *user_data;\n+\n+} ffi_java_raw_closure;\n+\n ffi_status\n ffi_prep_raw_closure (ffi_raw_closure*,\n \t\t      ffi_cif *cif,\n@@ -285,15 +325,15 @@ ffi_prep_raw_closure_loc (ffi_raw_closure*,\n \t\t\t  void *codeloc);\n \n ffi_status\n-ffi_prep_java_raw_closure (ffi_raw_closure*,\n+ffi_prep_java_raw_closure (ffi_java_raw_closure*,\n \t\t           ffi_cif *cif,\n-\t\t           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n \t\t           void *user_data);\n \n ffi_status\n-ffi_prep_java_raw_closure_loc (ffi_raw_closure*,\n+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,\n \t\t\t       ffi_cif *cif,\n-\t\t\t       void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n \t\t\t       void *user_data,\n \t\t\t       void *codeloc);\n "}, {"sha": "4fef115e0a6ff8c3005b9ae55215211491492015", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -54,13 +54,13 @@ ffi_java_raw_size (ffi_cif *cif)\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_DOUBLE:\n-\t  result += 2 * FFI_SIZEOF_ARG;\n+\t  result += 2 * FFI_SIZEOF_JAVA_RAW;\n \t  break;\n \tcase FFI_TYPE_STRUCT:\n \t  /* No structure parameters in Java.\t*/\n \t  abort();\n \tdefault:\n-\t  result += FFI_SIZEOF_ARG;\n+\t  result += FFI_SIZEOF_JAVA_RAW;\n       }\n     }\n \n@@ -69,7 +69,7 @@ ffi_java_raw_size (ffi_cif *cif)\n \n \n void\n-ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n+ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)\n {\n   unsigned i;\n   ffi_type **tp = cif->arg_types;\n@@ -90,7 +90,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \t  *args = (void*) ((char*)(raw++) + 2);\n \t  break;\n \n-#if FFI_SIZEOF_ARG == 8\n+#if FFI_SIZEOF_JAVA_RAW == 8\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_DOUBLE:\n@@ -105,7 +105,8 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \n \tdefault:\n \t  *args = raw;\n-\t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  raw +=\n+\t    ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n \t}\n     }\n \n@@ -116,7 +117,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n   /* then assume little endian */\n   for (i = 0; i < cif->nargs; i++, tp++, args++)\n     {\n-#if FFI_SIZEOF_ARG == 8\n+#if FFI_SIZEOF_JAVA_RAW == 8\n       switch((*tp)->type) {\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n@@ -127,10 +128,11 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \tdefault:\n \t  *args = (void*) raw++;\n       }\n-#else /* FFI_SIZEOF_ARG != 8 */\n+#else /* FFI_SIZEOF_JAVA_RAW != 8 */\n \t*args = (void*) raw;\n-\traw += ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);\n-#endif /* FFI_SIZEOF_ARG == 8 */\n+\traw +=\n+\t  ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n+#endif /* FFI_SIZEOF_JAVA_RAW == 8 */\n     }\n \n #else\n@@ -141,7 +143,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n }\n \n void\n-ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n+ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw)\n {\n   unsigned i;\n   ffi_type **tp = cif->arg_types;\n@@ -202,7 +204,7 @@ ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n \t  (raw++)->flt = *(FLOAT32*) (*args);\n \t  break;\n \n-#if FFI_SIZEOF_ARG == 8\n+#if FFI_SIZEOF_JAVA_RAW == 8\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_DOUBLE:\n@@ -216,11 +218,12 @@ ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n \t  break;\n \n \tdefault:\n-#if FFI_SIZEOF_ARG == 8\n+#if FFI_SIZEOF_JAVA_RAW == 8\n \t  FFI_ASSERT(0);\t/* Should have covered all cases */\n #else\n \t  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);\n-\t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  raw +=\n+\t    ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n #endif\n \t}\n     }\n@@ -244,6 +247,9 @@ ffi_java_rvalue_to_raw (ffi_cif *cif, void *rvalue)\n     case FFI_TYPE_SINT16:\n     case FFI_TYPE_SINT32:\n     case FFI_TYPE_INT:\n+#if FFI_SIZEOF_JAVA_RAW == 4\n+    case FFI_TYPE_POINTER:\n+#endif\n       *(SINT64 *)rvalue <<= 32;\n       break;\n \n@@ -269,6 +275,9 @@ ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)\n     case FFI_TYPE_SINT16:\n     case FFI_TYPE_SINT32:\n     case FFI_TYPE_INT:\n+#if FFI_SIZEOF_JAVA_RAW == 4\n+    case FFI_TYPE_POINTER:\n+#endif\n       *(SINT64 *)rvalue >>= 32;\n       break;\n \n@@ -285,7 +294,8 @@ ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)\n  * these following couple of functions will handle the translation forth\n  * and back automatically. */\n \n-void ffi_java_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *raw)\n+void ffi_java_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue,\n+\t\t\tffi_java_raw *raw)\n {\n   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n   ffi_java_raw_to_ptrarray (cif, raw, avalue);\n@@ -299,7 +309,7 @@ static void\n ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n \t\t    void **avalue, void *user_data)\n {\n-  ffi_raw *raw = (ffi_raw*)alloca (ffi_java_raw_size (cif));\n+  ffi_java_raw *raw = (ffi_java_raw*)alloca (ffi_java_raw_size (cif));\n   ffi_raw_closure *cl = (ffi_raw_closure*)user_data;\n \n   ffi_java_ptrarray_to_raw (cif, avalue, raw);\n@@ -308,9 +318,9 @@ ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n }\n \n ffi_status\n-ffi_prep_java_raw_closure_loc (ffi_raw_closure* cl,\n+ffi_prep_java_raw_closure_loc (ffi_java_raw_closure* cl,\n \t\t\t       ffi_cif *cif,\n-\t\t\t       void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n \t\t\t       void *user_data,\n \t\t\t       void *codeloc)\n {\n@@ -335,9 +345,9 @@ ffi_prep_java_raw_closure_loc (ffi_raw_closure* cl,\n  * the pointer-array format, to the raw format */\n \n ffi_status\n-ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n+ffi_prep_java_raw_closure (ffi_java_raw_closure* cl,\n \t\t\t   ffi_cif *cif,\n-\t\t\t   void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t   void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n \t\t\t   void *user_data)\n {\n   return ffi_prep_java_raw_closure_loc (cl, cif, fun, user_data, cl);"}, {"sha": "ccfc82b9d48b1b6ae8d4faea0485f25912bef6fc", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -42,10 +42,13 @@\n \n #ifdef FFI_MIPS_O32\n /* O32 stack frames have 32bit integer args */\n-#define FFI_SIZEOF_ARG         4\n+#  define FFI_SIZEOF_ARG    4\n #else\n /* N32 and N64 frames have 64bit integer args */\n-#define FFI_SIZEOF_ARG         8\n+#  define FFI_SIZEOF_ARG    8\n+#  if _MIPS_SIM == _ABIN32\n+#    define FFI_SIZEOF_JAVA_RAW  4\n+#  endif\n #endif\n \n #define FFI_FLAG_BITS 2"}, {"sha": "922a93bc2d7493e21ad437c4a82da2fe9b3c6dd1", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -1,3 +1,13 @@\n+2007-12-06  David Daney  <ddaney@avtrex.com>\n+\n+\t* interpret.cc: Replace ffi_raw with INTERP_FFI_RAW_TYPE throughout.\n+\t(ncode_closure, ffi_closure_fun): Define versions for\n+\tnon-FFI_NATIVE_RAW_API case.\n+\t* include/java-interp.h (INTERP_FFI_RAW_TYPE): Define and use to\n+\treplace\tffi_raw throughout.\n+\t* jni.cc, interpret-run.cc: Replace ffi_raw with INTERP_FFI_RAW_TYPE\n+\tthroughout.\n+\n 2007-12-06  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* testsuite/libjava.jni/jni.exp (gcj_jni_get_cxxflags_invocation): Make"}, {"sha": "c6d9955f4bfbbc2fe3df96925a2314eb2eadcabe", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -222,18 +222,26 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   void *ncode (jclass);\n   void compile (const void * const *);\n \n-  static void run_normal (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_synch_object (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_class (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_synch_class (ffi_cif*, void*, ffi_raw*, void*);\n-  \n-  static void run_normal_debug (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_synch_object_debug (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_class_debug (ffi_cif*, void*, ffi_raw*, void*);\n-  static void run_synch_class_debug (ffi_cif*, void*, ffi_raw*, void*);\n+#if FFI_NATIVE_RAW_API\n+#  define INTERP_FFI_RAW_TYPE ffi_raw\n+#else\n+#  define INTERP_FFI_RAW_TYPE ffi_java_raw\n+#endif\n \n-  static void run (void *, ffi_raw *, _Jv_InterpMethod *);\n-  static void run_debug (void *, ffi_raw *, _Jv_InterpMethod *);\n+  static void run_normal (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  static void run_synch_object (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  static void run_class (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  static void run_synch_class (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  \n+  static void run_normal_debug (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  static void run_synch_object_debug (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*,\n+\t\t\t\t      void*);\n+  static void run_class_debug (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*, void*);\n+  static void run_synch_class_debug (ffi_cif*, void*, INTERP_FFI_RAW_TYPE*,\n+\t\t\t\t     void*);\n+\n+  static void run (void *, INTERP_FFI_RAW_TYPE *, _Jv_InterpMethod *);\n+  static void run_debug (void *, INTERP_FFI_RAW_TYPE *, _Jv_InterpMethod *);\n   \n \n   \n@@ -361,7 +369,7 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   ffi_type **jni_arg_types;\n \n   // This function is used when making a JNI call from the interpreter.\n-  static void call (ffi_cif *, void *, ffi_raw *, void *);\n+  static void call (ffi_cif *, void *, INTERP_FFI_RAW_TYPE *, void *);\n \n   void *ncode (jclass);\n "}, {"sha": "f858c971e0bb7427f593b6170f96813c1642abe5", "filename": "libjava/interpret-run.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -576,7 +576,7 @@ details.  */\n       {\n \t/* here goes the magic again... */\n \tffi_cif *cif = &rmeth->cif;\n-\tffi_raw *raw = (ffi_raw*) sp;\n+\tINTERP_FFI_RAW_TYPE *raw = (INTERP_FFI_RAW_TYPE *) sp;\n \n \t_Jv_value rvalue;\n "}, {"sha": "6153c5420367818f240170e7a94914812c3472a3", "filename": "libjava/interpret.cc", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -346,7 +346,7 @@ get4 (unsigned char* loc)\n void\n _Jv_InterpMethod::run_normal (ffi_cif *,\n \t\t\t      void *ret,\n-\t\t\t      ffi_raw *args,\n+\t\t\t      INTERP_FFI_RAW_TYPE *args,\n \t\t\t      void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -356,7 +356,7 @@ _Jv_InterpMethod::run_normal (ffi_cif *,\n void\n _Jv_InterpMethod::run_normal_debug (ffi_cif *,\n \t\t\t\t    void *ret,\n-\t\t\t\t    ffi_raw *args,\n+\t\t\t\t    INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t    void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -366,7 +366,7 @@ _Jv_InterpMethod::run_normal_debug (ffi_cif *,\n void\n _Jv_InterpMethod::run_synch_object (ffi_cif *,\n \t\t\t\t    void *ret,\n-\t\t\t\t    ffi_raw *args,\n+\t\t\t\t    INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t    void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -380,7 +380,7 @@ _Jv_InterpMethod::run_synch_object (ffi_cif *,\n void\n _Jv_InterpMethod::run_synch_object_debug (ffi_cif *,\n \t\t\t\t\t  void *ret,\n-\t\t\t\t\t  ffi_raw *args,\n+\t\t\t\t\t  INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t\t  void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -394,7 +394,7 @@ _Jv_InterpMethod::run_synch_object_debug (ffi_cif *,\n void\n _Jv_InterpMethod::run_class (ffi_cif *,\n \t\t\t     void *ret,\n-\t\t\t     ffi_raw *args,\n+\t\t\t     INTERP_FFI_RAW_TYPE *args,\n \t\t\t     void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -405,7 +405,7 @@ _Jv_InterpMethod::run_class (ffi_cif *,\n void\n _Jv_InterpMethod::run_class_debug (ffi_cif *,\n \t\t\t\t   void *ret,\n-\t\t\t\t   ffi_raw *args,\n+\t\t\t\t   INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t   void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -416,7 +416,7 @@ _Jv_InterpMethod::run_class_debug (ffi_cif *,\n void\n _Jv_InterpMethod::run_synch_class (ffi_cif *,\n \t\t\t\t   void *ret,\n-\t\t\t\t   ffi_raw *args,\n+\t\t\t\t   INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t   void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -431,7 +431,7 @@ _Jv_InterpMethod::run_synch_class (ffi_cif *,\n void\n _Jv_InterpMethod::run_synch_class_debug (ffi_cif *,\n \t\t\t\t\t void *ret,\n-\t\t\t\t\t ffi_raw *args,\n+\t\t\t\t\t INTERP_FFI_RAW_TYPE *args,\n \t\t\t\t\t void *__this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n@@ -975,7 +975,8 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n /* Run the given method.\n    When args is NULL, don't run anything -- just compile it. */\n void\n-_Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n+_Jv_InterpMethod::run (void *retp, INTERP_FFI_RAW_TYPE *args,\n+\t\t       _Jv_InterpMethod *meth)\n {\n #undef DEBUG\n #undef DEBUG_LOCALS_INSN\n@@ -985,7 +986,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n }\n \n void\n-_Jv_InterpMethod::run_debug (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n+_Jv_InterpMethod::run_debug (void *retp, INTERP_FFI_RAW_TYPE *args,\n+\t\t\t     _Jv_InterpMethod *meth)\n {\n #define DEBUG\n #undef DEBUG_LOCALS_INSN\n@@ -1306,27 +1308,32 @@ _Jv_init_cif (_Jv_Utf8Const* signature,\n   return item_count;\n }\n \n-#if FFI_NATIVE_RAW_API\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure_loc\n-#   define FFI_RAW_SIZE ffi_raw_size\n-#else\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure_loc\n-#   define FFI_RAW_SIZE ffi_java_raw_size\n-#endif\n-\n /* we put this one here, and not in interpret.cc because it\n  * calls the utility routines _Jv_count_arguments \n  * which are static to this module.  The following struct defines the\n  * layout we use for the stubs, it's only used in the ncode method. */\n \n+#if FFI_NATIVE_RAW_API\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure_loc\n+#   define FFI_RAW_SIZE ffi_raw_size\n typedef struct {\n   ffi_raw_closure  closure;\n   _Jv_ClosureList list;\n   ffi_cif   cif;\n   ffi_type *arg_types[0];\n } ncode_closure;\n-\n-typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n+typedef void (*ffi_closure_fun) (ffi_cif*,void*,INTERP_FFI_RAW_TYPE*,void*);\n+#else\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure_loc\n+#   define FFI_RAW_SIZE ffi_java_raw_size\n+typedef struct {\n+  ffi_java_raw_closure  closure;\n+  _Jv_ClosureList list;\n+  ffi_cif   cif;\n+  ffi_type *arg_types[0];\n+} ncode_closure;\n+typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_java_raw*,void*);\n+#endif\n \n void *\n _Jv_InterpMethod::ncode (jclass klass)"}, {"sha": "8bb2e59188130bf3fd0337d9533e7b7e05aa74dd", "filename": "libjava/jni.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c42b3d84fb4bd1539147b3aa1834d935818b869/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=4c42b3d84fb4bd1539147b3aa1834d935818b869", "patch": "@@ -2293,7 +2293,8 @@ _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n // This function is the stub which is used to turn an ordinary (CNI)\n // method call into a JNI call.\n void\n-_Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n+_Jv_JNIMethod::call (ffi_cif *, void *ret, INTERP_FFI_RAW_TYPE *args,\n+\t\t     void *__this)\n {\n   _Jv_JNIMethod* _this = (_Jv_JNIMethod *) __this;\n \n@@ -2325,8 +2326,9 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n       }\n   }\n \n-  JvAssert (_this->args_raw_size % sizeof (ffi_raw) == 0);\n-  ffi_raw real_args[2 + _this->args_raw_size / sizeof (ffi_raw)];\n+  JvAssert (_this->args_raw_size % sizeof (INTERP_FFI_RAW_TYPE) == 0);\n+  INTERP_FFI_RAW_TYPE\n+      real_args[2 + _this->args_raw_size / sizeof (INTERP_FFI_RAW_TYPE)];\n   int offset = 0;\n \n   // First argument is always the environment pointer."}]}