{"sha": "7548281d739c119cf7dfc9c83bc52dfc36083f8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0ODI4MWQ3MzljMTE5Y2Y3ZGZjOWM4M2JjNTJkZmMzNjA4M2Y4Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-03-19T14:34:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-19T14:34:47Z"}, "message": "langhooks-def.h (LANG_HOOKS_HASH_TYPES): New macro and hook.\n\n\t* langhooks-def.h (LANG_HOOKS_HASH_TYPES): New macro and hook.\n\t* langhooks.h (struct lang_hooks_for_types): New field hash_types.\n\t* tree.c (debug_no_type_hash): Deleted.\n\t(type_hash_canon): Abort if passed a variant.\n\tCheck lang_hooks.types.hash_types.\n\t(build_type_no_quals): Copy mode of POINTER_TYPE and REFERENCE_TYPE.\n\t(build_array_type): Remove unnecessary allocation of pointer type.\n\t(build_complex_type): Properly qualify resulting type.\n\n\t* ada/decl.c (debug_no_type_hash): Remove.\n\t(gnat_to_gnu_entity, case E_Array_Type): Don't set and clear it.\n\t* ada/misc.c (LANG_HOOK_HASH_TYPE): Redefine.\n\nFrom-SVN: r79684", "tree": {"sha": "046f6fd5dcc59b0ff82a69550dd6265483af9478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/046f6fd5dcc59b0ff82a69550dd6265483af9478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7548281d739c119cf7dfc9c83bc52dfc36083f8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7548281d739c119cf7dfc9c83bc52dfc36083f8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7548281d739c119cf7dfc9c83bc52dfc36083f8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7548281d739c119cf7dfc9c83bc52dfc36083f8c/comments", "author": null, "committer": null, "parents": [{"sha": "32f4f7197f9c12930a4933fc92215fcc45af670f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f4f7197f9c12930a4933fc92215fcc45af670f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32f4f7197f9c12930a4933fc92215fcc45af670f"}], "stats": {"total": 86, "additions": 48, "deletions": 38}, "files": [{"sha": "22ef8593b6549847acc65e7f925742783cd89f66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -1,3 +1,14 @@\n+2004-03-19  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* langhooks-def.h (LANG_HOOKS_HASH_TYPES): New macro and hook.\n+\t* langhooks.h (struct lang_hooks_for_types): New field hash_types.\n+\t* tree.c (debug_no_type_hash): Deleted.\n+\t(type_hash_canon): Abort if passed a variant.\n+\tCheck lang_hooks.types.hash_types.\n+\t(build_type_no_quals): Copy mode of POINTER_TYPE and REFERENCE_TYPE.\n+\t(build_array_type): Remove unnecessary allocation of pointer type.\n+\t(build_complex_type): Properly qualify resulting type.\n+\n 2004-03-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_init_builtins): Fix typo."}, {"sha": "c9f7e54e54fb2d353b6abcfd04aca09b9a2a9f26", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -1,3 +1,9 @@\n+2004-03-19 Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (debug_no_type_hash): Remove.\n+\t(gnat_to_gnu_entity, case E_Array_Type): Don't set and clear it.\n+\t* misc.c (LANG_HOOK_HASH_TYPE): Redefine.\n+\n 2004-03-19  Laurent GUERBY <laurent@guerby.net>\n \n \t* sem_prag.adb (Suppress_Unsuppress_Echeck): use loop instead of "}, {"sha": "9e7749e63b39b304c08bef54fe5524edee0bdca3", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -52,9 +52,6 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n-/* Setting this to 1 suppresses hashing of types.  */\n-extern int debug_no_type_hash;\n-\n /* Provide default values for the macros controlling stack checking.\n    This is copied from GCC's expr.h.  */\n \n@@ -1942,11 +1939,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t     convert (bitsizetype, gnu_max_size),\n \t\t\t\t     TYPE_SIZE (gnu_type));\n \n-\t  /* We don't want any array types shared for two reasons: first,\n-\t     we want to keep differently-named types distinct; second,\n-\t     setting TYPE_MULTI_ARRAY_TYPE of one type can clobber\n-\t     another.  */\n-\t  debug_no_type_hash = 1;\n \t  for (index = array_dim - 1; index >= 0; index --)\n \t    {\n \t      gnu_type = build_array_type (gnu_type, gnu_index_type[index]);\n@@ -2019,7 +2011,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      finish_record_type (gnu_bound_rec_type, gnu_field_list, 0, 0);\n \t    }\n \n-\t  debug_no_type_hash = 0;\n \t  TYPE_CONVENTION_FORTRAN_P (gnu_type)\n \t    = (Convention (gnat_entity) == Convention_Fortran);\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type)"}, {"sha": "7be3b5d6a98c136a441c8fa20673fca8dfc6ffce", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -101,7 +101,7 @@ static rtx gnat_expand_expr\t\t(tree, rtx, enum machine_mode, int,\n static void internal_error_function\t(const char *, va_list *);\n static void gnat_adjust_rli\t\t(record_layout_info);\n \n-/* Structure giving our language-specific hooks.  */\n+/* Definitions for our language-specific hooks.  */\n \n #undef  LANG_HOOKS_NAME\n #define LANG_HOOKS_NAME\t\t\t\"GNU Ada\"\n@@ -118,7 +118,9 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n #undef LANG_HOOKS_HONOR_READONLY\n-#define LANG_HOOKS_HONOR_READONLY\t1\n+#define LANG_HOOKS_HONOR_READONLY\ttrue\n+#undef LANG_HOOKS_HASH_TYPES\n+#define LANG_HOOKS_HASH_TYPES\t\tfalse\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n #undef LANG_HOOKS_GET_ALIAS_SET"}, {"sha": "b986129371f9d4bbe813645d615009cd685a9905", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -222,6 +222,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_INCOMPLETE_TYPE_ERROR lhd_incomplete_type_error\n #define LANG_HOOKS_TYPE_PROMOTES_TO lhd_type_promotes_to\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE lhd_register_builtin_type\n+#define LANG_HOOKS_HASH_TYPES\t\ttrue\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n   LANG_HOOKS_MAKE_TYPE, \\\n@@ -232,7 +233,8 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE, \\\n   LANG_HOOKS_TYPE_PROMOTES_TO, \\\n   LANG_HOOKS_REGISTER_BUILTIN_TYPE, \\\n-  LANG_HOOKS_INCOMPLETE_TYPE_ERROR \\\n+  LANG_HOOKS_INCOMPLETE_TYPE_ERROR, \\\n+  LANG_HOOKS_HASH_TYPES \\\n }\n \n /* Declaration hooks.  */"}, {"sha": "b78dddca2457bf25b8a133ee3a4a1989683edd85", "filename": "gcc/langhooks.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -151,6 +151,11 @@ struct lang_hooks_for_types\n      was used (or 0 if that isn't known) and TYPE is the type that was\n      invalid.  */\n   void (*incomplete_type_error) (tree value, tree type);\n+\n+  /* Nonzero if types that are identical are to be hashed so that only\n+     one copy is kept.  If a language requires unique types for each\n+     user-specified type, such as Ada, this should be set to TRUE.  */\n+  bool hash_types;\n };\n \n /* Language hooks related to decls and the symbol table.  */"}, {"sha": "304cc0264b60d7dfb8a7dc0b103c7f6240cc0072", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7548281d739c119cf7dfc9c83bc52dfc36083f8c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7548281d739c119cf7dfc9c83bc52dfc36083f8c", "patch": "@@ -3218,24 +3218,24 @@ type_hash_add (hashval_t hashcode, tree type)\n \n /* Given TYPE, and HASHCODE its hash code, return the canonical\n    object for an identical type if one already exists.\n-   Otherwise, return TYPE, and record it as the canonical object\n-   if it is a permanent object.\n+   Otherwise, return TYPE, and record it as the canonical object.\n \n    To use this function, first create a type of the sort you want.\n    Then compute its hash code from the fields of the type that\n    make it different from other similar types.\n-   Then call this function and use the value.\n-   This function frees the type you pass in if it is a duplicate.  */\n-\n-/* Set to 1 to debug without canonicalization.  Never set by program.  */\n-int debug_no_type_hash = 0;\n+   Then call this function and use the value.  */\n \n tree\n type_hash_canon (unsigned int hashcode, tree type)\n {\n   tree t1;\n \n-  if (debug_no_type_hash)\n+  /* The hash table only contains main variants, so ensure that's what we're\n+     being passed.  */\n+  if (TYPE_MAIN_VARIANT (type) != type)\n+    abort ();\n+\n+  if (!lang_hooks.types.hash_types)\n     return type;\n \n   /* See if the type is in the hash table already.  If so, return it.\n@@ -3931,9 +3931,12 @@ build_type_no_quals (tree t)\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n-      return build_pointer_type (build_type_no_quals (TREE_TYPE (t)));\n+      return build_pointer_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n+\t\t\t\t\t  TYPE_MODE (t));\n     case REFERENCE_TYPE:\n-      return build_reference_type (build_type_no_quals (TREE_TYPE (t)));\n+      return\n+\tbuild_reference_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n+\t\t\t\t       TYPE_MODE (t));\n     default:\n       return TYPE_MAIN_VARIANT (t);\n     }\n@@ -4026,19 +4029,12 @@ build_array_type (tree elt_type, tree index_type)\n       elt_type = integer_type_node;\n     }\n \n-  /* Make sure TYPE_POINTER_TO (elt_type) is filled in.  */\n-  build_pointer_type (elt_type);\n-\n-  /* Allocate the array after the pointer type,\n-     in case we free it in type_hash_canon.  */\n   t = make_node (ARRAY_TYPE);\n   TREE_TYPE (t) = elt_type;\n   TYPE_DOMAIN (t) = index_type;\n \n   if (index_type == 0)\n-    {\n-      return t;\n-    }\n+    return t;\n \n   hashcode = iterative_hash_object (TYPE_HASH (elt_type), hashcode);\n   hashcode = iterative_hash_object (TYPE_HASH (index_type), hashcode);\n@@ -4087,7 +4083,7 @@ build_function_type (tree value_type, tree arg_types)\n   TREE_TYPE (t) = value_type;\n   TYPE_ARG_TYPES (t) = arg_types;\n \n-  /* If we already have such a type, use the old one and free this one.  */\n+  /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (value_type), hashcode);\n   hashcode = type_hash_list (arg_types, hashcode);\n   t = type_hash_canon (hashcode, t);\n@@ -4149,12 +4145,10 @@ build_method_type_directly (tree basetype,\n   argtypes = tree_cons (NULL_TREE, ptype, argtypes);\n   TYPE_ARG_TYPES (t) = argtypes;\n \n-  /* If we already have such a type, use the old one and free this one.\n-     Note that it also frees up the above cons cell if found.  */\n+  /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n   hashcode = iterative_hash_object (TYPE_HASH (rettype), hashcode);\n   hashcode = type_hash_list (argtypes, hashcode);\n-\n   t = type_hash_canon (hashcode, t);\n \n   if (!COMPLETE_TYPE_P (t))\n@@ -4195,7 +4189,7 @@ build_offset_type (tree basetype, tree type)\n   TYPE_OFFSET_BASETYPE (t) = TYPE_MAIN_VARIANT (basetype);\n   TREE_TYPE (t) = type;\n \n-  /* If we already have such a type, use the old one and free this one.  */\n+  /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (basetype), hashcode);\n   hashcode = iterative_hash_object (TYPE_HASH (type), hashcode);\n   t = type_hash_canon (hashcode, t);\n@@ -4218,9 +4212,8 @@ build_complex_type (tree component_type)\n   t = make_node (COMPLEX_TYPE);\n \n   TREE_TYPE (t) = TYPE_MAIN_VARIANT (component_type);\n-  set_type_quals (t, TYPE_QUALS (component_type));\n \n-  /* If we already have such a type, use the old one and free this one.  */\n+  /* If we already have such a type, use the old one.  */\n   hashcode = iterative_hash_object (TYPE_HASH (component_type), 0);\n   t = type_hash_canon (hashcode, t);\n \n@@ -4262,7 +4255,7 @@ build_complex_type (tree component_type)\n \tTYPE_NAME (t) = get_identifier (name);\n     }\n \n-  return t;\n+  return build_qualified_type (t, TYPE_QUALS (component_type));\n }\n \f\n /* Return OP, stripped of any conversions to wider types as much as is safe."}]}