{"sha": "24bef15854919b1b36f74ea8208c71b146975a0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiZWYxNTg1NDkxOWIxYjM2Zjc0ZWE4MjA4YzcxYjE0Njk3NWEwYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-12T01:12:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-12T01:12:59Z"}, "message": "cp-tree.def (CLEANUP_STMT): New node.\n\n\t* cp-tree.def (CLEANUP_STMT): New node.\n\t* cp-tree.h (language_function): Add name_declared.\n\t(current_function_name_declared): New macro.\n\t(CLEANUP_DECL): New macro.\n\t(CLEANUP_EXPR): Likewise.\n\t(emit_local_var): Likewise.\n\t(finish_decl_cleanup): New function.\n\t* cvt.c (build_up_reference): Simplify.\n\t(ocp_convert): Remove dead code.\n\t* decl.c (start_decl): Remove call to add_decl_stmt.\n\t(grok_reference_init): Adjust, to handle bindings temporaries to\n\treferences.  Remove dead code.\n\t(initialize_local_var): Don't generate RTL for\n\tdeclarations here, or build cleanups here.  Don't fuss with\n\tobstacks.  Replace expand_start_target_temps calls with explicit\n\tsetting of stms_are_full_exprs_p.\n\t(destroy_local_var): New function.\n\t(emit_local_var): Likewise.\n\t(cp_finish_decl): Use them, as appropriate.\n\t(start_function): Announce template functions.\n\t(store_parm_decls): Don't call declare_function_name here.\n\t(finish_stmt): Don't start emit base-initialization code when just\n\tbuilding the statement-tree.\n\t* init.c (create_temporary_var): Move add_decl_stmt call ...\n\t(get_temp_regvar): Here.\n\t* pt.c (tsubst_expr): Make DECL_INITIAL look like what\n\tcp_finish_decl would expect.  Don't call add_decl_stmt.\n\t* semantics.c (begin_compound_stmt): Call declare_function_name,\n\tif appropriate.\n\t(finish_decl_cleanup): New function.\n\t(expand_stmt): Use emit_local_var to output variables.\n\t(expand_body): Set current_funtion_name_declared.\n\nFrom-SVN: r29348", "tree": {"sha": "21262e14b6ea734d629371b88b3f1eeb361b27dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21262e14b6ea734d629371b88b3f1eeb361b27dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24bef15854919b1b36f74ea8208c71b146975a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bef15854919b1b36f74ea8208c71b146975a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24bef15854919b1b36f74ea8208c71b146975a0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bef15854919b1b36f74ea8208c71b146975a0b/comments", "author": null, "committer": null, "parents": [{"sha": "fcf6eeb628b0df816f962c5185641325de7d5f6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf6eeb628b0df816f962c5185641325de7d5f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf6eeb628b0df816f962c5185641325de7d5f6e"}], "stats": {"total": 261, "additions": 169, "deletions": 92}, "files": [{"sha": "ab9ece6270f6419c4bd6b856946ef9b73fef470e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -1,3 +1,38 @@\n+1999-09-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (CLEANUP_STMT): New node.\n+\t* cp-tree.h (language_function): Add name_declared.\n+\t(current_function_name_declared): New macro.\n+\t(CLEANUP_DECL): New macro.\n+\t(CLEANUP_EXPR): Likewise.\n+\t(emit_local_var): Likewise.\n+\t(finish_decl_cleanup): New function.\n+\t* cvt.c (build_up_reference): Simplify.\n+\t(ocp_convert): Remove dead code.\n+\t* decl.c (start_decl): Remove call to add_decl_stmt.\n+\t(grok_reference_init): Adjust, to handle bindings temporaries to\n+\treferences.  Remove dead code.\n+\t(initialize_local_var): Don't generate RTL for\n+\tdeclarations here, or build cleanups here.  Don't fuss with\n+\tobstacks.  Replace expand_start_target_temps calls with explicit\n+\tsetting of stms_are_full_exprs_p.\n+\t(destroy_local_var): New function.\n+\t(emit_local_var): Likewise.\n+\t(cp_finish_decl): Use them, as appropriate.\n+\t(start_function): Announce template functions.\n+\t(store_parm_decls): Don't call declare_function_name here.\n+\t(finish_stmt): Don't start emit base-initialization code when just\n+\tbuilding the statement-tree.\n+\t* init.c (create_temporary_var): Move add_decl_stmt call ...\n+\t(get_temp_regvar): Here.\n+\t* pt.c (tsubst_expr): Make DECL_INITIAL look like what\n+\tcp_finish_decl would expect.  Don't call add_decl_stmt.\n+\t* semantics.c (begin_compound_stmt): Call declare_function_name,\n+\tif appropriate.\n+\t(finish_decl_cleanup): New function.\n+\t(expand_stmt): Use emit_local_var to output variables.\t\t\n+\t(expand_body): Set current_funtion_name_declared.\n+\t\n 1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (finish_cleanup_try_block): New function."}, {"sha": "53e3e1a3bf0b607099ef975df0d2d03a891cb953", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -235,6 +235,10 @@ DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n    run if an exception is thrown before the end of the enclosing\n    function.  */\n DEFTREECODE (SUBOBJECT, \"subobject\", 'e', 1)\n+/* A CLEANUP_STMT marks the point at which a declaration is fully\n+   constructed.  If, after this point, the CLEANUP_DECL goes out of\n+   scope, the CLEANUP_EXPR must be run.  */\n+DEFTREECODE (CLEANUP_STMT, \"cleanup\", 'e', 2)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)"}, {"sha": "5b438290bae835c47214152a0497f329f106fb91", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -636,6 +636,7 @@ struct language_function\n   int in_function_try_handler;\n   int x_expanding_p;\n   int stmts_are_full_exprs_p; \n+  int name_declared;\n \n   struct named_label_list *x_named_label_uses;\n   struct binding_level *bindings;\n@@ -708,6 +709,12 @@ struct language_function\n #define current_function_parms_stored \\\n   cp_function_chain->parms_stored\n \n+/* Non-zero if we have already declared __FUNCTION__ (and related\n+   variables) in the current function.  */\n+\n+#define current_function_name_declared \\\n+  cp_function_chain->name_declared\n+\n /* Used to help generate temporary names which are unique within\n    a function.  Reset to 0 by start_function.  */\n \n@@ -2437,6 +2444,8 @@ extern int flag_new_for_scope;\n #define DECL_STMT_DECL(NODE)    TREE_OPERAND (NODE, 0)\n #define STMT_EXPR_STMT(NODE)    TREE_OPERAND (NODE, 0)\n #define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (NODE, 0)\n+#define CLEANUP_DECL(NODE)      TREE_OPERAND (NODE, 0)\n+#define CLEANUP_EXPR(NODE)      TREE_OPERAND (NODE, 1)\n #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (NODE, 0)\n \n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n@@ -3237,6 +3246,7 @@ extern int wrapup_globals_for_namespace         PROTO((tree, void *));\n extern tree cp_namespace_decls                  PROTO((tree));\n extern tree create_implicit_typedef             PROTO((tree, tree));\n extern tree maybe_push_decl                     PROTO((tree));\n+extern void emit_local_var                      PROTO((tree));\n \n /* in decl2.c */\n extern void init_decl2\t\t\t\tPROTO((void));\n@@ -3651,6 +3661,7 @@ extern void finish_member_declaration           PROTO((tree));\n extern void check_multiple_declarators          PROTO((void));\n extern tree finish_typeof\t\t\tPROTO((tree));\n extern void add_decl_stmt                       PROTO((tree));\n+extern void finish_decl_cleanup                 PROTO((tree, tree));\n extern void finish_named_return_value           PROTO((tree, tree));\n extern tree expand_stmt                         PROTO((tree));\n extern void expand_body                         PROTO((tree));"}, {"sha": "382a9b2660d044c472ed0296fc22a4b7e4cec79d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -345,8 +345,6 @@ build_up_reference (type, arg, flags)\n \n   if ((flags & DIRECT_BIND) && ! real_lvalue_p (arg))\n     {\n-      tree compound_stmt;\n-\n       /* Create a new temporary variable.  */\n       tree targ = arg;\n       if (toplevel_bindings_p ())\n@@ -355,25 +353,12 @@ build_up_reference (type, arg, flags)\n \t{\n \t  arg = pushdecl (build_decl (VAR_DECL, NULL_TREE, argtype));\n \t  DECL_ARTIFICIAL (arg) = 1;\n-\t  /* Generate code to initialize it.  We wrap it in a\n-\t     statement-expression so that when we are building a\n-\t     statement-tree we will have a representation of this\n-\t     declaration.  */\n-\t  begin_init_stmts (&stmt_expr, &compound_stmt);\n \t}\n \n       /* Process the initializer for the declaration.  */\n       DECL_INITIAL (arg) = targ;\n       cp_finish_decl (arg, targ, NULL_TREE, 0,\n \t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n-\n-      /* And wrap up the statement-expression, if necessary.  */\n-      if (!toplevel_bindings_p ())\n-\t{\n-\t  if (building_stmt_tree ())\n-\t    add_decl_stmt (arg);\n-\t  stmt_expr = finish_init_stmts (stmt_expr, compound_stmt);\n-\t}\n     }\n   else if (!(flags & DIRECT_BIND) && ! lvalue_p (arg))\n     {\n@@ -719,27 +704,13 @@ ocp_convert (type, expr, convtype, flags)\n       return e;\n     }\n \n-#if 0\n-  /* This is incorrect.  A truncation can't be stripped this way.\n-     Extensions will be stripped by the use of get_unwidened.  */\n-  if (TREE_CODE (e) == NOP_EXPR)\n-    return cp_convert (type, TREE_OPERAND (e, 0));\n-#endif\n-\n   /* Just convert to the type of the member.  */\n   if (code == OFFSET_TYPE)\n     {\n       type = TREE_TYPE (type);\n       code = TREE_CODE (type);\n     }\n \n-#if 0\n-  if (code == REFERENCE_TYPE)\n-    return fold (convert_to_reference (type, e, convtype, flags, NULL_TREE));\n-  else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n-    e = convert_from_reference (e);\n-#endif\n-\n   if (TREE_CODE (e) == OFFSET_REF)\n     e = resolve_offset_ref (e);\n "}, {"sha": "547f7c6af50e0868dd15745d580deb1133704112", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 83, "deletions": 56, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -179,6 +179,7 @@ static void mark_cp_function_context PROTO((struct function *));\n static void mark_saved_scope PROTO((void *));\n static void check_function_type PROTO((tree));\n static void destroy_local_static PROTO((tree));\n+static void destroy_local_var PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -6843,15 +6844,9 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     {\n       if (at_function_scope_p ())\n \tpush_permanent_obstack ();\n-\n       tem = push_template_decl (tem);\n-      /* In a a local scope, add a representation of this declaration\n-\t to the statement tree.  */\n       if (at_function_scope_p ())\n-\t{\n-\t  add_decl_stmt (decl);\n-\t  pop_obstacks ();\n-\t}\n+\tpop_obstacks ();\n     }\n \n \n@@ -6987,7 +6982,14 @@ grok_reference_init (decl, type, init)\n       /* Note: default conversion is only called in very special cases.  */\n       init = default_conversion (init);\n     }\n-\n+  \n+  /* Convert INIT to the reference type TYPE.  This may involve the\n+     creation of a temporary, whose lifetime must be the same as that\n+     of the reference.  If so, a DECL_STMT for the temporary will be\n+     added just after the DECL_STMT for DECL.  That's why we don't set\n+     DECL_INITIAL for local references (instead assigning to them\n+     explicitly); we need to allow the temporary to be initialized\n+     first.  */\n   tmp = convert_to_reference\n     (type, init, CONV_IMPLICIT,\n      LOOKUP_SPECULATIVELY|LOOKUP_NORMAL|DIRECT_BIND, decl);\n@@ -6997,19 +6999,25 @@ grok_reference_init (decl, type, init)\n   else if (tmp != NULL_TREE)\n     {\n       init = tmp;\n-      DECL_INITIAL (decl) = save_expr (init);\n+      tmp = save_expr (tmp);\n+      if (building_stmt_tree ())\n+\t{\n+\t  /* Initialize the declaration.  */\n+\t  tmp = build (INIT_EXPR, TREE_TYPE (decl), decl, tmp);\n+\t  /* Setting TREE_SIDE_EFFECTS prevents expand_expr from\n+\t     omitting this expression entirely.  */\n+\t  TREE_SIDE_EFFECTS (tmp) = 1;\n+\t  finish_expr_stmt (tmp);\n+\t}\n+      else\n+\tDECL_INITIAL (decl) = tmp;\n     }\n   else\n     {\n       cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n       return;\n     }\n \n-  /* ?? Can this be optimized in some cases to\n-     hand back the DECL_INITIAL slot??  */\n-  if (TYPE_SIZE (TREE_TYPE (type)))\n-    init = convert_from_reference (decl);\n-\n   if (TREE_STATIC (decl) && ! TREE_CONSTANT (DECL_INITIAL (decl)))\n     {\n       expand_static_init (decl, DECL_INITIAL (decl));\n@@ -7526,29 +7534,16 @@ initialize_local_var (decl, init, flags)\n      int flags;\n {\n   tree type;\n-  tree cleanup;\n \n   type = complete_type (TREE_TYPE (decl));\n \n-  cleanup = build_cleanup_on_safe_obstack (decl);\n-\n   if (DECL_SIZE (decl) == NULL_TREE && !TREE_STATIC (decl))\n     {\n       /* If we used it already as memory, it must stay in memory.  */\n       DECL_INITIAL (decl) = NULL_TREE;\n       TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n     }\n \n-  if (DECL_RTL (decl))\n-    /* Only a RESULT_DECL should have non-NULL RTL when arriving here.\n-       All other local variables are assigned RTL in this function.  */\n-    my_friendly_assert (TREE_CODE (decl) == RESULT_DECL, 19990828);\n-  else\n-    /* Create RTL for this variable.  */\n-    expand_decl (decl);\n-\n-  expand_start_target_temps ();\n-\n   if (DECL_SIZE (decl) && type != error_mark_node)\n     {\n       int already_used;\n@@ -7558,21 +7553,15 @@ initialize_local_var (decl, init, flags)\n \n       if (init || TYPE_NEEDS_CONSTRUCTING (type))\n \t{\n+\t  int saved_stmts_are_full_exprs_p;\n+\n \t  emit_line_note (DECL_SOURCE_FILE (decl),\n \t\t\t  DECL_SOURCE_LINE (decl));\n-\t  /* We call push_momentary here so that when\n-\t     finish_expr_stmt clears the momentary obstack it\n-\t     doesn't destory any momentary expressions we may\n-\t     have lying around.  Although cp_finish_decl is\n-\t     usually called at the end of a declaration\n-\t     statement, it may also be called for a temporary\n-\t     object in the middle of an expression.  */\n-\t  push_momentary ();\n+\t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n+\t  stmts_are_full_exprs_p = 1;\n \t  finish_expr_stmt (build_aggr_init (decl, init, flags));\n-\t  pop_momentary ();\n+\t  stmts_are_full_exprs_p = saved_stmts_are_full_exprs_p;\n \t}\n-      else\n-\texpand_decl_init (decl);\n \n       /* Set this to 0 so we can tell whether an aggregate which was\n \t initialized was ever used.  Don't do this if it has a\n@@ -7582,22 +7571,48 @@ initialize_local_var (decl, init, flags)\n \t marked used. (see TREE_USED, above.)  */\n       if (TYPE_NEEDS_CONSTRUCTING (type)\n \t  && ! already_used\n-\t  && cleanup == NULL_TREE\n+\t  && !TYPE_NEEDS_DESTRUCTOR (type) \n \t  && DECL_NAME (decl))\n \tTREE_USED (decl) = 0;\n       else if (already_used)\n \tTREE_USED (decl) = 1;\n     }\n+}\n \n-  /* Cleanup any temporaries needed for the initial value.  */\n-  expand_end_target_temps ();\n+/* Generate code to destroy DECL (a local variable).  */\n+\n+void \n+destroy_local_var (decl)\n+     tree decl;\n+{\n+  tree cleanup = build_cleanup_on_safe_obstack (decl);\n \n   /* Record the cleanup required for this declaration.  */\n-  if (DECL_SIZE (decl) \n-      && type != error_mark_node\n-      && cleanup\n-      && !expand_decl_cleanup (decl, cleanup))\n-    cp_error (\"parser lost in parsing declaration of `%D'\", decl);\n+  if (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node\n+      && cleanup)\n+    finish_decl_cleanup (decl, cleanup);\n+}\n+\n+/* Let the back-end know about DECL.  */\n+\n+void\n+emit_local_var (decl)\n+     tree decl;\n+{\n+  /* Create RTL for this variable.  */\n+  if (DECL_RTL (decl))\n+    /* Only a RESULT_DECL should have non-NULL RTL when\n+\t\t     arriving here.  All other local variables are\n+\t\t     assigned RTL in this function.  */\n+    my_friendly_assert (TREE_CODE (decl) == RESULT_DECL, \n+\t\t\t19990828);\n+  else\n+    expand_decl (decl);\n+\n+  /* Actually do the initialization.  */\n+  expand_start_target_temps ();\n+  expand_decl_init (decl);\n+  expand_end_target_temps ();\n }\n \n /* Finish processing of a declaration;\n@@ -7680,9 +7695,14 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       return;\n     }\n \n+  /* Add this declaration to the statement-tree.  */\n+  if (building_stmt_tree () \n+      && TREE_CODE (current_scope ()) == FUNCTION_DECL)\n+    add_decl_stmt (decl);\n+\n   if (TYPE_HAS_MUTABLE_P (type))\n     TREE_READONLY (decl) = 0;\n-  \n+\n   if (processing_template_decl)\n     {\n       if (init && DECL_INITIAL (decl))\n@@ -7808,10 +7828,19 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t  /* Initialize the local variable.  But, if we're building a\n \t     statement-tree, we'll do the initialization when we\n \t     expand the tree.  */\n-\t  if (!building_stmt_tree ())\n-\t    initialize_local_var (decl, init, flags);\n-\t  else if (init || DECL_INITIAL (decl) == error_mark_node)\n-\t    DECL_INITIAL (decl) = init;\n+\t  if (processing_template_decl)\n+\t    {\n+\t      if (init || DECL_INITIAL (decl) == error_mark_node)\n+\t\tDECL_INITIAL (decl) = init;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!building_stmt_tree ())\n+\t\temit_local_var (decl);\n+\t      initialize_local_var (decl, init, flags);\n+\t      /* Clean up the variable.  */\n+\t      destroy_local_var (decl);\n+\t    }\n \t}\n     finish_end0:\n \n@@ -12900,7 +12929,7 @@ start_function (declspecs, declarator, attrs, flags)\n   get_pending_sizes ();\n \n   /* Let the user know we're compiling this function.  */\n-  if (!building_stmt_tree ())\n+  if (processing_template_decl || !building_stmt_tree ())\n     announce_function (decl1);\n \n   /* Record the decl so that the function name is defined.\n@@ -13210,9 +13239,6 @@ store_parm_decls ()\n \n   storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n \n-  /* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */\n-  declare_function_name ();\n-\n   /* Initialize the RTL code for the function.  */\n   DECL_SAVED_INSNS (fndecl) = 0;\n   if (! building_stmt_tree ())\n@@ -14222,7 +14248,8 @@ finish_stmt ()\n   if (!current_function_assigns_this\n       && current_function_just_assigned_this)\n     {\n-      if (DECL_CONSTRUCTOR_P (current_function_decl))\n+      if (DECL_CONSTRUCTOR_P (current_function_decl) \n+\t  && !building_stmt_tree ())\n \t{\n \t  /* Constructors must wait until we are out of control\n \t     zones before calling base constructors.  */"}, {"sha": "a5b2417e9fa72815965dcf2b7da021f4db60bc43", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -2668,9 +2668,6 @@ create_temporary_var (type)\n   DECL_SOURCE_LINE (decl) = lineno;\n   DECL_IGNORED_P (decl) = 1;\n \n-  if (building_stmt_tree ())\n-    add_decl_stmt (decl);\n-\n   return decl;\n }\n \n@@ -2688,6 +2685,8 @@ get_temp_regvar (type, init)\n   tree decl;\n \n   decl = create_temporary_var (type);\n+  if (building_stmt_tree ())\n+    add_decl_stmt (decl);\n   DECL_REGISTER (decl) = 1;\n   if (!building_stmt_tree ())\n     DECL_RTL (decl) = assign_temp (type, 2, 0, 1);"}, {"sha": "1cb315d3059196d745096bfce5d07efefc4e2085", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -7284,7 +7284,8 @@ tsubst_expr (t, args, complain, in_decl)\n \t    init = DECL_INITIAL (decl);\n \t    decl = tsubst (decl, args, complain, in_decl);\n \t    init = tsubst_expr (init, args, complain, in_decl);\n-\t    DECL_INITIAL (decl) = init;\n+\t    if (init)\n+\t      DECL_INITIAL (decl) = error_mark_node;\n \t    /* By marking the declaration as instantiated, we avoid\n \t       trying to instantiate it.  Since instantiate_decl can't\n \t       handle local variables, and since we've already done\n@@ -7293,8 +7294,7 @@ tsubst_expr (t, args, complain, in_decl)\n \t    if (TREE_CODE (decl) == VAR_DECL)\n \t      DECL_TEMPLATE_INSTANTIATED (decl) = 1;\n \t    maybe_push_decl (decl);\n-\t    cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n-\t    add_decl_stmt (decl);\n+\t    cp_finish_decl (decl, init, NULL_TREE, 0, 0);\n \t  }\n \tresume_momentary (i);\n \treturn decl;"}, {"sha": "657c3dd6a238f71300972ea5fcdcfad47cba89a3", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bef15854919b1b36f74ea8208c71b146975a0b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=24bef15854919b1b36f74ea8208c71b146975a0b", "patch": "@@ -869,6 +869,14 @@ begin_compound_stmt (has_no_scope)\n        to accidentally keep a block *inside* the scopeless block.  */ \n     keep_next_level (0);\n \n+  /* If this is the outermost block of the function, declare the\n+     variables __FUNCTION__, __PRETTY_FUNCTION__, and so forth.  */\n+  if (!current_function_name_declared && !processing_template_decl)\n+    {\n+      declare_function_name ();\n+      current_function_name_declared = 1;\n+    }\n+\n   return r;\n }\n \n@@ -1027,6 +1035,19 @@ finish_subobject (cleanup)\n     add_partial_entry (cleanup);\n }\n \n+/* When DECL goes out of scope, make sure that CLEANUP is executed.  */\n+\n+void \n+finish_decl_cleanup (decl, cleanup)\n+     tree decl;\n+     tree cleanup;\n+{\n+  if (building_stmt_tree ())\n+    add_tree (build_min_nt (CLEANUP_STMT, decl, cleanup));\n+  else if (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node)\n+    expand_decl_cleanup (decl, cleanup);\n+}\n+\n /* Bind a name and initialization to the return value of\n    the current function.  */\n \n@@ -2153,13 +2174,17 @@ expand_stmt (t)\n \t\t       compatibility.  */\n \t\t    maybe_inject_for_scope_var (decl);\n \t\t    /* Let the back-end know about this variable.  */\n-\t\t    initialize_local_var (decl, DECL_INITIAL (decl), 0);\n+\t\t    emit_local_var (decl);\n \t\t  }\n \t      }\n \t    resume_momentary (i);\n \t  }\n \t  break;\n \n+\tcase CLEANUP_STMT:\n+\t  finish_decl_cleanup (CLEANUP_DECL (t), CLEANUP_EXPR (t));\n+\t  break;\n+\n \tcase FOR_STMT:\n \t  {\n \t    tree tmp;\n@@ -2338,6 +2363,11 @@ expand_body (fn)\n   start_function (NULL_TREE, fn, NULL_TREE, SF_PRE_PARSED | SF_EXPAND);\n   store_parm_decls ();\n \n+  /* We don't need to redeclare __FUNCTION__, __PRETTY_FUNCTION__, or\n+     any of the other magic variables we set up when starting a\n+     function body.  */\n+  current_function_name_declared = 1;\n+\n   /* There are a few things that we do not handle recursively.  For\n      example, a function try-block is handled differently from an\n      ordinary try-block, so we must handle it here.  */"}]}