{"sha": "df79dc1a89017f6b70525fcafc94c1ec476fead0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3OWRjMWE4OTAxN2Y2YjcwNTI1ZmNhZmM5NGMxZWM0NzZmZWFkMA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-09-25T09:05:53Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-09-25T09:05:53Z"}, "message": "2002-09-25  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/DatagramSocket.java\n\t(DatagramSocket): Exception documentation added.\n\t(bind): Exception documentation added, addded SecurityManager check,\n\tadded SocketAddress type check.\n\t(getSoTimeout): Check impl.\n\t(receive): Fix SecurityManager check, check impl, documentation added.\n\t(send): Check channel mode, documentation added.\n\t(connect): New method.\n\t(disconnect): Implemented.\n\t(getLocalSocketAddress): New method.\n\t(getReceiveBufferSize): Check impl.\n\t(setReuseAddress): Check impl.\n\t(getReuseAddress): Check impl.\n\t(setBroadcast): Check impl.\n\t(getBroadcast): Check impl.\n\t(setTrafficClass): Check impl, Documentation cleared.\n\t(getTrafficClass): Check impl.\n\t(getSendBufferSize): Check impl.\n\t(setReceiveBufferSize): Check impl, documentation added.\n\t(setSendBufferSize): Documentation added.\n\t(setDatagramSocketImplFactory): New method.\n\t* java/net/HttpURLConnection.java\n\t(HTTP_INTERNAL_ERROR): The correct code is 500.\n\t(HTTP_NOT_IMPLEMENTED): Added new constant.\n\t(setFollowRedirects): Documentation added.\n\t(getInstanceFollowRedirects): New method.\n\t(setInstanceFollowRedirects): New method.\n\t(setRequestMethod): Documentation added.\n\t(getResponseCode): Documentation added.\n\t(getResponseMessage): Documentation added.\n\t* java/net/JarURLConnection.java\n\t(JarURLConnection): protected since JDK 1.4.\n\t(getJarEntry): java.io.IOException to IOException, documentation added.\n\t(getJarFile): Documentation added.\n\t* java/net/ServerSocket.java\n\t(ServerSocket): Private to public, exception added.\n\t(ServerSocket): java.io.IOException to IOException, documentation added.\n\t(bind): Check socket address type, documentation added.\n\t(bind): java.io.IOException to IOException, documentation added.\n\t(accept): Documentation added.\n\t(implAccept): Check ch is not non-blocking, documentation added.\n\t(setSoTimeout): Documentation fixed.\n\t(setReceiveBufferSize): Documentation added.\n\t* java/net/Socket.java\n\t(Socket): Documentation added.\n\t(bind): Documentation added.\n\t(connect): Check socket address type, documentation added.\n\t(getRemoteSocketAddress): New method.\n\nFrom-SVN: r57494", "tree": {"sha": "eba53548213d388013da79db4a20b091267a80e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eba53548213d388013da79db4a20b091267a80e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df79dc1a89017f6b70525fcafc94c1ec476fead0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df79dc1a89017f6b70525fcafc94c1ec476fead0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df79dc1a89017f6b70525fcafc94c1ec476fead0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df79dc1a89017f6b70525fcafc94c1ec476fead0/comments", "author": null, "committer": null, "parents": [{"sha": "33c31b33b58b9a17c94ba1451f79723dabee1961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c31b33b58b9a17c94ba1451f79723dabee1961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c31b33b58b9a17c94ba1451f79723dabee1961"}], "stats": {"total": 631, "additions": 602, "deletions": 29}, "files": [{"sha": "50e8dd8bec81f90666dad67efc3587e326e934ee", "filename": "libjava/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -1,3 +1,69 @@\n+2002-09-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/DatagramSocket.java\n+\t(DatagramSocket): Exception documentation added.\n+\t(bind): Exception documentation added, addded SecurityManager check,\n+\tadded SocketAddress type check.\n+\t(getSoTimeout): Check impl.\n+\t(receive): Fix SecurityManager check, check impl, documentation added.\n+\t(send): Check channel mode, documentation added.\n+\t(connect): New method.\n+\t(disconnect): Implemented.\n+\t(getLocalSocketAddress): New method.\n+\t(getReceiveBufferSize): Check impl.\n+\t(setReuseAddress): Check impl.\n+\t(getReuseAddress): Check impl.\n+\t(setBroadcast): Check impl.\n+\t(getBroadcast): Check impl.\n+\t(setTrafficClass): Check impl, Documentation cleared.\n+\t(getTrafficClass): Check impl.\n+\t(getSendBufferSize): Check impl.\n+\t(setReceiveBufferSize): Check impl, documentation added.\n+\t(setSendBufferSize): Documentation added.\n+\t(setDatagramSocketImplFactory): New method.\n+\t* java/net/HttpURLConnection.java\n+\t(HTTP_INTERNAL_ERROR): The correct code is 500.\n+\t(HTTP_NOT_IMPLEMENTED): Added new constant.\n+\t(setFollowRedirects): Documentation added.\n+\t(getInstanceFollowRedirects): New method.\n+\t(setInstanceFollowRedirects): New method.\n+\t(setRequestMethod): Documentation added.\n+\t(getResponseCode): Documentation added.\n+\t(getResponseMessage): Documentation added.\n+\t* java/net/JarURLConnection.java\n+\t(JarURLConnection): protected since JDK 1.4.\n+\t(getJarEntry): java.io.IOException to IOException, documentation added.\n+\t(getJarFile): Documentation added.\n+\t* java/net/ServerSocket.java\n+\t(ServerSocket): Private to public, exception added.\n+\t(ServerSocket): java.io.IOException to IOException, documentation added.\n+\t(bind): Check socket address type, documentation added.\n+\t(bind): java.io.IOException to IOException, documentation added.\n+\t(accept): Documentation added.\n+\t(implAccept): Check ch is not non-blocking, documentation added.\n+\t(setSoTimeout): Documentation fixed.\n+\t(setReceiveBufferSize): Documentation added.\n+\t* java/net/Socket.java\n+\t(Socket): Documentation added.\n+\t(bind): Documentation added.\n+\t(connect): Check socket address type, documentation added.\n+\t(getRemoteSocketAddress): New method.\n+\t(getLocalSocketAddress): New method.\n+\t(setSoLinger): Documentation added.\n+\t(getReuseAddress): New method.\n+\t(setReuseAddress): New method.\n+\t(getTrafficClass): New method.\n+\t(setTrafficClass): New method.\n+\t* java/net/URLStreamHandler.java\n+\t(openConnection): java.io.IOException to IOException.\n+\t(parseURL): Documentation added.\n+\t(sameFile): public to protected, documentation added.\n+\t(setURL): Documentation added.\n+\t* java/nio/IllegalBlockingModeException.java: New file.\n+\t* Makefile.am (ordinary_java_source_files):\n+\tadded java/nio/IllegalBlockingModeException.java\n+\t* Makefile.in: Regenerated.\n+\n 2002-09-25  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/DatagramPacket"}, {"sha": "4fd11df771e50c6f6baff5bd08a127f3574a5a42", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -1924,6 +1924,7 @@ java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n java/nio/channels/DatagramChannel.java \\\n+java/nio/channels/IllegalBlockingModeException.java \\\n java/nio/channels/ServerSocketChannel.java \\\n java/nio/channels/SocketChannel.java \\\n java/security/AccessControlContext.java \\"}, {"sha": "c0bde3fb9a49dfba30296e9599a81fa4817eac04", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -1686,6 +1686,7 @@ java/net/URLStreamHandlerFactory.java \\\n java/net/UnknownHostException.java \\\n java/net/UnknownServiceException.java \\\n java/nio/channels/DatagramChannel.java \\\n+java/nio/channels/IllegalBlockingModeException.java \\\n java/nio/channels/ServerSocketChannel.java \\\n java/nio/channels/SocketChannel.java \\\n java/security/AccessControlContext.java \\\n@@ -2902,6 +2903,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/net/natPlainDatagramSocketImpl.P \\\n .deps/java/net/natPlainSocketImpl.P \\\n .deps/java/nio/channels/DatagramChannel.P \\\n+.deps/java/nio/channels/IllegalBlockingModeException.P \\\n .deps/java/nio/channels/ServerSocketChannel.P \\\n .deps/java/nio/channels/SocketChannel.P \\\n .deps/java/rmi/AccessException.P .deps/java/rmi/AlreadyBoundException.P \\"}, {"sha": "eef638db091dbb0edfdf032a228f22683d1ab77e", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 176, "deletions": 9, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -9,8 +9,10 @@\n details.  */\n \n package java.net;\n+\n import java.io.IOException;\n import java.nio.channels.DatagramChannel;\n+import java.nio.channels.IllegalBlockingModeException;\n \n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n@@ -25,10 +27,23 @@\n \n public class DatagramSocket\n {\n+  /**\n+   * This is the user DatagramSocketImplFactory for this class.  If this\n+   * variable is null, a default factory is used.\n+   */\n+  static DatagramSocketImplFactory factory;\n+\t  \n   DatagramSocketImpl impl;\n \n   DatagramChannel ch;\n \n+  /**\n+   * Creates a DatagramSocket\n+   *\n+   * @exception SocketException If an error occurs\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation\n+   */\n   public DatagramSocket() throws SocketException\n   {\n     this(0, null);\n@@ -52,6 +67,8 @@ protected DatagramSocket (DatagramSocketImpl impl)\n    * @param bindaddr The socket address to bind to\n    *\n    * @exception SocketException If an error occurs\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation\n    * \n    * @since 1.4\n    */\n@@ -68,6 +85,8 @@ public DatagramSocket (SocketAddress bindaddr)\n    * @param port The port number to bind to\n    *\n    * @exception SocketException If an error occurs\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation\n    */\n   public DatagramSocket(int port) throws SocketException\n   {\n@@ -81,6 +100,8 @@ public DatagramSocket(int port) throws SocketException\n    * @param laddr The local address to bind to\n    *\n    * @exception SocketException If an error occurs\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation\n    */\n   public DatagramSocket(int port, InetAddress laddr) throws SocketException\n   {\n@@ -121,13 +142,24 @@ public DatagramSocket(int port, InetAddress laddr) throws SocketException\n    * @param address The socket address to bind to\n    *\n    * @exception SocketException If an error occurs\n+   * @exception SecurityException If a security manager exists and\n+   * its checkListen method doesn't allow the operation\n+   * @exception IllegalArgumentException If address type is not supported\n    *\n    * @since 1.4\n    */\n   public void bind (SocketAddress address)\n     throws SocketException\n   {\n+    if (! (address instanceof InetSocketAddress))\n+      throw new IllegalArgumentException ();\n+\n     InetSocketAddress tmp = (InetSocketAddress) address;\n+\n+    SecurityManager s = System.getSecurityManager ();\n+    if (s != null)\n+      s.checkListen(tmp.getPort ());\n+\n     impl.bind (tmp.getPort (), tmp.getAddress ());\n   }\n   \n@@ -139,6 +171,16 @@ public void close()\n     impl.close();\n   }\n \n+  /**\n+   * Checks if the datagram socket is closed\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isClosed()\n+  {\n+    return !impl.getFileDescriptor().valid();\n+  }\n+\n   /**\n    * Gets a datagram channel assoziated with the socket\n    * \n@@ -213,6 +255,9 @@ public int getLocalPort()\n    */\n   public synchronized int getSoTimeout() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n     if (timeout instanceof Integer) \n       return ((Integer)timeout).intValue();\n@@ -226,12 +271,25 @@ public synchronized int getSoTimeout() throws SocketException\n    * @param p The datagram packet to put the incoming data into\n    * \n    * @exception IOException If an error occurs\n+   * @exception SocketTimeoutException If setSoTimeout was previously called\n+   * and the timeout has expired\n+   * @exception PortUnreachableException If the socket is connected to a\n+   * currently unreachable destination. Note, there is no guarantee that the\n+   * exception will be thrown\n+   * @exception IllegalBlockingModeException If this socket has an associated\n+   * channel, and the channel is in non-blocking mode\n    */\n   public synchronized void receive(DatagramPacket p) throws IOException\n   {\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkAccept(p.getAddress().getHostAddress(), p.getPort());\n+      s.checkAccept (p.getAddress().getHostName (), p.getPort ());\n+\t\t \n+    if (impl == null)\n+      throw new IOException (\"Cannot initialize Socket implementation\");\n+\n+    if (ch != null && !ch.isBlocking ())\n+      throw new IllegalBlockingModeException ();\n \n     impl.receive(p);\n   }\n@@ -242,22 +300,33 @@ public synchronized void receive(DatagramPacket p) throws IOException\n    * @param p The datagram packet to send\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkMulticast or checkConnect method doesn't allow the send\n+   * @exception PortUnreachableException If the socket is connected to a\n+   * currently unreachable destination. Note, there is no guarantee that the\n+   * exception will be thrown\n+   * @exception IllegalBlockingModeException If this socket has an associated\n+   * channel, and the channel is in non-blocking mode\n    */\n   public void send(DatagramPacket p) throws IOException\n   {\n     // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       {\n-\tInetAddress addr = p.getAddress();\n-\tif (addr.isMulticastAddress())\n-\t  s.checkMulticast(addr);\n-\telse\n-\t  s.checkConnect(addr.getHostAddress(), p.getPort());\n+        InetAddress addr = p.getAddress();\n+        if (addr.isMulticastAddress())\n+          s.checkMulticast(addr);\n+        else\n+          s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n-\n+\t    \n     // FIXME: if this is a subclass of MulticastSocket,\n     // use getTimeToLive for TTL val.\n+\n+    if (ch != null && !ch.isBlocking ())\n+      throw new IllegalBlockingModeException ();\n+\n     impl.send(p);\n   }\n \n@@ -285,6 +354,10 @@ public synchronized void setSoTimeout(int timeout) throws SocketException\n    * @param port The port to connect to\n    *\n    * @exception SocketException If an error occurs\n+   * @exception IllegalArgumentException If address is null\n+   * or the port number is illegal\n+   * @exception SecurityException If the caller is not allowed to send\n+   * datagrams to and receive datagrams from the address and port\n    *\n    * @since 1.2\n    */\n@@ -294,14 +367,34 @@ public void connect(InetAddress address, int port)\n     //impl.connect(address, port);\n   }\n \n+  /**\n+   * Connects the datagram socket to a specified socket address.\n+   *\n+   * @param address The socket address to connect to\n+   *\n+   * @exception SocketException If an error occurs\n+   * @exception IllegalArgumentException If address type is not supported\n+   *\n+   * @since 1.4\n+   */\n+  public void connect (SocketAddress address) throws SocketException\n+  {\n+    if ( !(address instanceof InetSocketAddress) )\n+      throw new IllegalArgumentException (\n+\t\t      \"SocketAddress is not InetSocketAddress\");\n+\n+    InetSocketAddress tmp = (InetSocketAddress) address;\n+    connect( tmp.getAddress(), tmp.getPort());\n+  }\n+  \n   /**\n    * Disconnects the datagram socket\n    *\n    * @since 1.2\n    */\n   public void disconnect()\n   {\n-    //impl.disconnect();\n+    impl.disconnect();\n   }\n \n   /**\n@@ -345,6 +438,28 @@ public int getPort()\n     return impl.localPort;\n   }\n \n+  /**\n+   * Returns the local SocketAddress this socket is bound to\n+   * or null if it is not bound\n+   * \n+   * @since 1.4\n+   */\n+  public SocketAddress getLocalSocketAddress()\n+  {\n+    InetAddress addr;\n+    \n+    try\n+      {\n+        addr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException e)\n+      {\n+        return null;\n+      }\n+\n+    return new InetSocketAddress (addr, impl.localPort);\n+  }\n+\n   /**\n    * This method returns the value of the system level socket option\n    * SO_RCVBUF, which is used by the operating system to tune buffer\n@@ -358,6 +473,9 @@ public int getPort()\n    */\n   public int getReceiveBufferSize() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     Object obj = impl.getOption(SocketOptions.SO_RCVBUF);\n   \n     if (obj instanceof Integer)\n@@ -377,6 +495,9 @@ public int getReceiveBufferSize() throws SocketException\n    */\n   public void setReuseAddress(boolean on) throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n   }\n \n@@ -389,6 +510,9 @@ public void setReuseAddress(boolean on) throws SocketException\n    */\n   public boolean getReuseAddress() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     Object obj = impl.getOption (SocketOptions.SO_REUSEADDR);\n   \n     if (obj instanceof Boolean)\n@@ -408,6 +532,9 @@ public boolean getReuseAddress() throws SocketException\n    */\n   public void setBroadcast(boolean on) throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     impl.setOption (SocketOptions.SO_BROADCAST, new Boolean (on));\n   }\n \n@@ -420,6 +547,9 @@ public void setBroadcast(boolean on) throws SocketException\n    */\n   public boolean getBroadcast() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     Object obj = impl.getOption (SocketOptions.SO_BROADCAST);\n   \n     if (obj instanceof Boolean)\n@@ -434,7 +564,7 @@ public boolean getBroadcast() throws SocketException\n    * @param tc The traffic class\n    *\n    * @exception SocketException If an error occurs\n-   * @exception IllegalArgumentException If tc < 0 or rc > 255\n+   * @exception IllegalArgumentException If tc value is illegal\n    *\n    * @see DatagramSocket:getTrafficClass\n    * \n@@ -443,6 +573,9 @@ public boolean getBroadcast() throws SocketException\n   public void setTrafficClass(int tc)\n     throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     if (tc < 0 || tc > 255)\n       throw new IllegalArgumentException();\n \n@@ -460,6 +593,9 @@ public void setTrafficClass(int tc)\n    */\n   public int getTrafficClass() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException( \"Cannot initialize Socket implementation\");\n+\n     Object obj = impl.getOption(SocketOptions.IP_TOS);\n \n     if (obj instanceof Integer)\n@@ -481,6 +617,9 @@ public int getTrafficClass() throws SocketException\n    */\n   public int getSendBufferSize() throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     Object obj = impl.getOption(SocketOptions.SO_SNDBUF);\n \n     if (obj instanceof Integer)\n@@ -497,11 +636,15 @@ public int getSendBufferSize() throws SocketException\n    * @param size The new receive buffer size.\n    *\n    * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If size is 0 or negative\n    *  \n    * @since 1.2\n    */\n   public void setReceiveBufferSize(int size) throws SocketException\n   {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n     if (size < 0)\n       throw new IllegalArgumentException(\"Buffer size is less than 0\");\n \n@@ -516,6 +659,7 @@ public void setReceiveBufferSize(int size) throws SocketException\n    * @param size The new send buffer size.\n    *\n    * @exception SocketException If an error occurs.\n+   * @exception IllegalArgumentException If size is 0 or negative\n    *\n    * @since 1.2\n    */\n@@ -526,4 +670,27 @@ public void setSendBufferSize(int size) throws SocketException\n   \n     impl.setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n+\n+  /**\n+   * Sets the datagram socket implementation factory for the application\n+   *\n+   * @param fac The factory to set\n+   *\n+   * @exception IOException If an error occurs\n+   * @exception SocketException If the factory is already defined\n+   * @exception SecurityException If a security manager exists and its\n+   * checkSetFactory method doesn't allow the operation\n+   */\n+  public static void setDatagramSocketImplFactory\n+    (DatagramSocketImplFactory fac) throws IOException\n+  {\n+    if (factory != null)\n+      throw new SocketException (\"DatagramSocketImplFactory already defined\");\n+\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkSetFactory();\n+\n+    factory = fac;\n+  }\n }"}, {"sha": "5072b60829ce974e7f22eb0a359b4c1028cf8dfb", "filename": "libjava/java/net/HttpURLConnection.java", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FHttpURLConnection.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -12,6 +12,7 @@\n package java.net;\n \n import java.io.*;\n+import java.security.Permission;\n \n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n@@ -64,7 +65,8 @@ public abstract class HttpURLConnection extends URLConnection\n \n   /* HTTP Server Error Response Codes */\n   public static final int HTTP_SERVER_ERROR\t= 500;\n-  public static final int HTTP_INTERNAL_ERROR\t= 501;\n+  public static final int HTTP_INTERNAL_ERROR\t= 500;\n+  public static final int HTTP_NOT_IMPLEMENTED\t= 501;\n   public static final int HTTP_BAD_GATEWAY\t= 502;\n   public static final int HTTP_UNAVAILABLE\t= 503;\n   public static final int HTTP_GATEWAY_TIMEOUT\t= 504;\n@@ -88,6 +90,13 @@ protected HttpURLConnection(URL url)\n \n   public abstract boolean usingProxy();\n \n+  /**\n+   * Sets whether HTTP redirects (requests with response code 3xx) should be\n+   * automatically followed by this class. True by default\n+   *\n+   * @exception SecurityException If a security manager exists and its\n+   * checkSetFactory method doesn't allow the operation\n+   */\n   public static void setFollowRedirects(boolean set)\n   {\n     // Throw an exception if an extant security mgr precludes\n@@ -104,6 +113,30 @@ public static boolean getFollowRedirects()\n     return followRedirects;\n   }\n \n+  /**\n+   * Returns the value of this HttpURLConnection's instanceFollowRedirects\n+   * field\n+   */\n+  public boolean getInstanceFollowRedirects ()\n+  {\n+    return instanceFollowRedirects;\n+  }\n+\n+  /**\n+   * Sets the value of this HttpURLConnection's instanceFollowRedirects field\n+   */\n+  public void setInstanceFollowRedirects (boolean follow)\n+  {\n+    instanceFollowRedirects = follow;\n+  }\n+\n+  /**\n+   * Set the method for the URL request, one of:\n+   * GET POST HEAD OPTIONS PUT DELETE TRACE are legal\n+   *\n+   * @exception ProtocolException If the method cannot be reset or if the\n+   * requested method isn't valid for HTTP\n+   */\n   public void setRequestMethod(String method) throws ProtocolException\n   {\n     if (connected)\n@@ -123,13 +156,24 @@ public String getRequestMethod()\n     return method;\n   }\n \n+  /**\n+   * Gets the status code from an HTTP response message\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public int getResponseCode() throws IOException\n   {\n     if (!gotResponseVals)\n       getResponseVals();\n     return responseCode;\n   }\n \n+  /**\n+   * Gets the HTTP response message, if any, returned along with the\n+   * response code from a server\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public String getResponseMessage() throws IOException\n   {\n     if (!gotResponseVals)"}, {"sha": "8f75622975f0ff9f553253149093f09891e56656", "filename": "libjava/java/net/JarURLConnection.java", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -50,7 +50,14 @@ public String getEntryName ()\n     return element;\n   }\n \n-  public JarURLConnection(URL url)\n+  /**\n+   * Creates a new JarURLConnection\n+   *\n+   * @exception MalformedURLException If url is invalid\n+   *\n+   * @specnote This constructor is protected since JDK 1.4\n+   */\n+  protected JarURLConnection(URL url)\n     throws MalformedURLException\n   {\n     super(url);\n@@ -153,7 +160,12 @@ public InputStream getInputStream() throws IOException\n     return null;\n   }\n \n-  public JarEntry getJarEntry () throws java.io.IOException\n+  /**\n+   * Return the JAR entry object for this connection, if any\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public JarEntry getJarEntry () throws IOException\n   {\n     JarFile jarfile = null;\n \n@@ -167,7 +179,7 @@ public JarEntry getJarEntry () throws java.io.IOException\n       {\n \tjarfile = getJarFile ();\n       }\n-    catch (java.io.IOException x)\n+    catch (IOException x)\n       {\n \t/* ignore */\n       }\n@@ -197,7 +209,12 @@ public JarEntry getJarEntry () throws java.io.IOException\n     return null;\n   }\n \n-  public abstract JarFile getJarFile() throws java.io.IOException;\n+  /**\n+   * Return the JAR file for this connection\n+   *\n+   * @exception IOException If an error occurs\n+   */\n+  public abstract JarFile getJarFile() throws IOException;\n \n \n   // Steal and borrow from protocol/file/Connection.java"}, {"sha": "36f93e8b64c875dd2bb78e64fa6f8a95d4dc678c", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -38,6 +38,7 @@\n package java.net;\n \n import java.io.IOException;\n+import java.nio.channels.IllegalBlockingModeException;\n import java.nio.channels.ServerSocketChannel;\n \n /* Written using on-line Java Platform 1.2 API Specification.\n@@ -50,7 +51,7 @@\n  * listens for and accepts connections.  At that point the client and\n  * server sockets are ready to communicate with one another utilizing\n  * whatever application layer protocol they desire.\n- * <p>\n+ *\n  * As with the <code>Socket</code> class, most instance methods of this class \n  * simply redirect their calls to an implementation class.\n  *\n@@ -82,9 +83,13 @@\n   private ServerSocketChannel ch;\n \n   /**\n-   * Private constructor that simply sets the implementation.\n+   * Constructor that simply sets the implementation.\n+   * \n+   * @exception IOException If an error occurs\n+   *\n+   * @specnote This constructor is public since JDK 1.4\n    */\n-  private ServerSocket()\n+  public ServerSocket() throws IOException\n   {\n     if (factory != null)\n       impl = factory.createSocketImpl();\n@@ -100,9 +105,11 @@ private ServerSocket()\n    * @param port The port number to bind to\n    * \n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n    */\n   public ServerSocket (int port)\n-    throws java.io.IOException\n+    throws IOException\n   {\n     this(port, 50);\n   }\n@@ -117,9 +124,11 @@ public ServerSocket (int port)\n    * @param backlog The length of the pending connection queue\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n    */\n   public ServerSocket (int port, int backlog)\n-    throws java.io.IOException\n+    throws IOException\n   {\n     this(port, backlog, null);\n   }\n@@ -136,11 +145,13 @@ public ServerSocket (int port, int backlog)\n    * @param bindAddr The address to bind to, or null to bind to all addresses\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n    *\n    * @since 1.1\n    */\n   public ServerSocket (int port, int backlog, InetAddress bindAddr)\n-    throws java.io.IOException\n+    throws IOException\n   {\n     this();\n     if (impl == null)\n@@ -164,6 +175,9 @@ public ServerSocket (int port, int backlog, InetAddress bindAddr)\n    * @param endpoint The socket address to bind to\n    *\n    * @exception IOException If an error occurs\n+   * @exception IllegalArgumentException If address type is not supported\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n    * \n    * @since 1.4\n    */\n@@ -173,6 +187,9 @@ public void bind (SocketAddress endpoint)\n     if (impl == null)\n       throw new IOException (\"Cannot initialize Socket implementation\");\n \n+    if (! (endpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException (\"Address type not supported\");\n+\n     InetSocketAddress tmp = (InetSocketAddress) endpoint;\n     \n     SecurityManager s = System.getSecurityManager ();\n@@ -187,14 +204,22 @@ public void bind (SocketAddress endpoint)\n    *\n    * @param endpoint The socket address to bind to\n    * @param backlog The length of the pending connection queue\n+   * \n    * @exception IOException If an error occurs\n+   * @exception IllegalArgumentException If address type is not supported\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n+   *\n+   * @since 1.4\n    */\n-  public void bind (SocketAddress endpoint, int backlog)\n-    throws java.io.IOException \n+  public void bind (SocketAddress endpoint, int backlog) throws IOException\n   {\n     if (impl == null)\n       throw new IOException (\"Cannot initialize Socket implementation\");\n \n+    if (! (endpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException (\"Address type not supported\");\n+\n     InetSocketAddress tmp = (InetSocketAddress) endpoint;\n     \n     SecurityManager s = System.getSecurityManager ();\n@@ -253,8 +278,14 @@ public SocketAddress getLocalSocketAddress()\n    * connection is available.\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkListen method doesn't allow the operation\n+   * @exception IllegalBlockingModeException If this socket has an associated\n+   * channel, and the channel is in non-blocking mode\n+   * @exception SocketTimeoutException If a timeout was previously set with\n+   * setSoTimeout and the timeout has been reached\n    */\n-  public Socket accept ()  throws IOException\n+  public Socket accept () throws IOException\n   {\n     Socket s = new Socket();\n     implAccept (s);\n@@ -270,11 +301,17 @@ public Socket accept ()  throws IOException\n    * @param socket The socket that is used for the accepted connection\n    *\n    * @exception IOException If an error occurs\n+   * @exception IllegalBlockingModeException If this socket has an associated\n+   * channel, and the channel is in non-blocking mode\n    *\n    * @since 1.1\n    */\n-  protected final void implAccept (Socket s)  throws IOException\n+  protected final void implAccept (Socket s)\n+    throws IOException\n   {\n+    if (ch != null && !ch.isBlocking())\n+      throw new IllegalBlockingModeException();\n+\t    \n     impl.accept(s.impl);\n   }\n \n@@ -329,7 +366,7 @@ public boolean isBound()\n    *\n    * @param timeout The new SO_TIMEOUT value\n    *\n-   * @exception IOException If an error occurs\n+   * @exception SocketException If an error occurs\n    *\n    * @since 1.1\n    */\n@@ -408,6 +445,7 @@ public boolean getReuseAddress()\n    * @param size The new receive buffer size.\n    * \n    * @exception SocketException If an error occurs or Socket is not connected\n+   * @exception IllegalArgumentException If size is 0 or negative\n    *\n    * @since 1.4\n    */"}, {"sha": "9f01b78012aa3cbada2193be8a22f8e8ec73a4b7", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 144, "deletions": 1, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -129,6 +129,8 @@ protected Socket (SocketImpl impl) throws SocketException\n    * @exception UnknownHostException If the hostname cannot be resolved to a\n    * network address.\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    */\n   public Socket (String host, int port)\n     throws UnknownHostException, IOException\n@@ -144,6 +146,8 @@ public Socket (String host, int port)\n    * @param port The port number to connect to\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    */\n   public Socket (InetAddress address, int port)\n     throws IOException \n@@ -183,6 +187,8 @@ public Socket (String host, int port,\n    * @param localPort The local port to connect to\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    */\n   public Socket (InetAddress address, int port,\n \t\t InetAddress localAddr, int localPort) throws IOException\n@@ -202,6 +208,8 @@ public Socket (InetAddress address, int port,\n    * for a datagram socket\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    *\n    * @deprecated Use the <code>DatagramSocket</code> class to create\n    * datagram oriented sockets.\n@@ -223,6 +231,8 @@ public Socket (String host, int port, boolean stream) throws IOException\n    * <code>false</code> to create a datagram socket.\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    *\n    * @deprecated Use the <code>DatagramSocket</code> class to create\n    * datagram oriented sockets.\n@@ -246,6 +256,8 @@ public Socket (InetAddress host, int port, boolean stream) throws IOException\n    * @param stream true for a stream socket, false for a datagram socket\n    *\n    * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n    */\n   private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n                  boolean stream) throws IOException\n@@ -275,7 +287,10 @@ private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n    *\n    * @param bindpoint The address/port to bind to\n    *\n-   * @exception If an error occurs\n+   * @exception IOException If an error occurs\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect method doesn't allow the operation\n+   * @exception IllegalArgumentException If the address type is not supported\n    * \n    * @since 1.4\n    */\n@@ -294,12 +309,17 @@ public void bind (SocketAddress bindpoint) throws IOException\n    * @param endpoint The address to connect to\n    *\n    * @exception IOException If an error occurs\n+   * @exception IllegalArgumentException If the addess type is not supported\n+   * @exception IllegalBlockingModeException FIXME\n    * \n    * @since 1.4\n    */\n   public void connect (SocketAddress endpoint)\n     throws IOException\n   {\n+    if (! (endpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException (\"Address type not supported\");\n+\n     impl.connect (endpoint, 0);\n   }\n \n@@ -311,12 +331,18 @@ public void connect (SocketAddress endpoint)\n    * @param endpoint The address to connect to\n    *\n    * @exception IOException If an error occurs\n+   * @exception IllegalArgumentException If the address type is not supported\n+   * @exception IllegalBlockingModeException FIXME\n+   * @exception SocketTimeoutException If the timeout is reached\n    * \n    * @since 1.4\n    */\n   public void connect (SocketAddress endpoint, int timeout)\n     throws IOException\n   {\n+    if (! (endpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException (\"Address type not supported\");\n+\n     impl.connect (endpoint, timeout);\n   }\n \n@@ -398,6 +424,40 @@ public int getLocalPort ()\n     return -1;\n   }\n \n+  /**\n+   * If the socket is already bound this returns the local SocketAddress,\n+   * otherwise null\n+   *\n+   * @since 1.4\n+   */\n+  public SocketAddress getLocalSocketAddress()\n+  {\n+    InetAddress addr;\n+\n+    try\n+      {\n+        addr = (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n+      }\n+    catch (SocketException e)\n+      {\n+\treturn null;\n+      }\n+    \n+    return new InetSocketAddress (addr, impl.getLocalPort());\n+  }\n+\n+  /**\n+   * If the socket is already connected this returns the remote SocketAddress,\n+   * otherwise null\n+   *\n+   * @since 1.4\n+   */\n+  public SocketAddress getRemoteSocketAddress()\n+  {\n+    // FIXME: Implement this\n+    return null;\n+  }\n+\n   /**\n    * Returns an InputStream for reading from this socket.\n    *\n@@ -479,6 +539,7 @@ public boolean getTcpNoDelay() throws SocketException\n    * SO_LINGER not set.\n    *\n    * @exception SocketException If an error occurs or Socket not connected\n+   * @exception IllegalArgumentException If linger is negative\n    */\n   public void setSoLinger(boolean on, int linger) throws SocketException\n   {\n@@ -640,6 +701,7 @@ public synchronized int getSoTimeout () throws SocketException\n    * @param size The new send buffer size.\n    *\n    * @exception SocketException If an error occurs or Socket not connected\n+   * @exception IllegalArgumentException FIXME\n    *\n    * @since 1.2\n    */\n@@ -686,6 +748,7 @@ public int getSendBufferSize () throws SocketException\n    * @param size The new receive buffer size.\n    *\n    * @exception SocketException If an error occurs or Socket is not connected\n+   * @exception IllegalArgumentException If size is 0 or negative\n    *\n    * @since 1.2\n    */\n@@ -847,4 +910,84 @@ public SocketChannel getChannel()\n   {\n     return ch;\n   }\n+\n+  /**\n+   * Checks if the SO_REUSEADDR option is enabled\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public boolean getReuseAddress () throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    Object reuseaddr = impl.getOption (SocketOptions.SO_REUSEADDR);\n+\n+    if (!(reuseaddr instanceof Boolean))\n+      throw new SocketException (\"Internal Error\");\n+\n+    return ((Boolean) reuseaddr).booleanValue ();\n+  }\n+\n+  /**\n+   * Enables/Disables the SO_REUSEADDR option\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @since 1.4\n+   */\n+  public void setReuseAddress (boolean on) throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    impl.setOption (SocketOptions.SO_REUSEADDR, new Boolean (on));\n+  }\n+\n+  /**\n+   * Returns the current traffic class\n+   *\n+   * @exception SocketException If an error occurs\n+   *\n+   * @see Socket:setTrafficClass\n+   *\n+   * @since 1.4\n+   */\n+  public int getTrafficClass () throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    Object obj = impl.getOption(SocketOptions.IP_TOS);\n+\n+    if (obj instanceof Integer)\n+      return ((Integer) obj).intValue ();\n+    else\n+      throw new SocketException (\"Unexpected type\");\n+  }\n+\n+  /**\n+   * Sets the traffic class value\n+   *\n+   * @param tc The traffic class\n+   *\n+   * @exception SocketException If an error occurs\n+   * @exception IllegalArgumentException If tc value is illegal\n+   *\n+   * @see Socket:getTrafficClass\n+   *\n+   * @since 1.4\n+   */\n+  public void setTrafficClass (int tc) throws SocketException\n+  {\n+    if (impl == null)\n+      throw new SocketException (\"Cannot initialize Socket implementation\");\n+\n+    if (tc < 0 || tc > 255)\n+      throw new IllegalArgumentException();\n+\n+    impl.setOption (SocketOptions.IP_TOS, new Integer (tc));\n+  }\n }"}, {"sha": "ea21ee928e5da130a8134adc1d835ed9b79eb4a5", "filename": "libjava/java/net/URLStreamHandler.java", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -10,6 +10,8 @@\n \n package java.net;\n \n+import java.io.IOException;\n+\n /**\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @date March 4, 1999.\n@@ -24,8 +26,16 @@\n public abstract class URLStreamHandler\n {\n   protected abstract URLConnection openConnection(URL u)\n-    throws java.io.IOException;\n-\n+    throws IOException;\n+\n+  /**\n+   * Pasrses the given URL\n+   *\n+   * @param u The URL to parse\n+   * @param spec The specification to use\n+   * @param start FIXME\n+   * @param limit FIXME\n+   */\n   protected void parseURL(URL u, String spec, int start, int limit)\n   {\n     String host = u.getHost();\n@@ -119,7 +129,15 @@ private static String canonicalizeFilename(String file)\n     return file; \n   }\n \n-  public boolean sameFile(URL url1, URL url2)\n+  /**\n+   * Compares two URLs, excluding the fragment component\n+   *\n+   * @param url1 The first url\n+   * @param url2 The second url to compare with the first\n+   * \n+   * @specnote Now protected\n+   */\n+  protected boolean sameFile(URL url1, URL url2)\n   {\n     if (url1 == url2)\n       return true;\n@@ -143,12 +161,33 @@ public boolean sameFile(URL url1, URL url2)\n     return true;\n   }\n \n+  /**\n+   * Sets the fields of the URL argument to the indicated values\n+   *\n+   * @param u The URL to modify\n+   * @param protocol The protocol to set\n+   * @param host The host name to et\n+   * @param port The port number to set\n+   * @param file The filename to set\n+   * @param ref The reference\n+   *\n+   * @exception SecurityException If the protocol handler of the URL is\n+   * different from this one\n+   *\n+   * @deprecated 1.2 Please use\n+   * #setURL(URL,String,String,int,String,String,String,String);\n+   */\n   protected void setURL(URL u, String protocol, String host, int port,\n \t\t\tString file, String ref)\n   {\n     u.set(protocol, host, port, file, ref);\n   }\n \n+  /**\n+   * Converts an URL of a specific protocol to a string\n+   *\n+   * @param u The URL to convert\n+   */\n   protected String toExternalForm(URL u)\n   {\n     String resStr, host, file, ref;"}, {"sha": "dca8110059b8224db3eb413f3ca9be25964ef420", "filename": "libjava/java/nio/channels/IllegalBlockingModeException.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df79dc1a89017f6b70525fcafc94c1ec476fead0/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FIllegalBlockingModeException.java?ref=df79dc1a89017f6b70525fcafc94c1ec476fead0", "patch": "@@ -0,0 +1,56 @@\n+/* IllegalBlockingModeException.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.channels;\n+\n+/**\n+ * @author Michael Koch <konqueror@gmx.de>\n+ * @since 1.4\n+ *\n+ * Written using JDK 1.4.1 Online API from Sun\n+ * Status: JDK 1.4 complete\n+ */\n+public class IllegalBlockingModeException extends IllegalStateException\n+{\n+  /**\n+   * Creates the exception\n+   */\n+  public IllegalBlockingModeException()\n+  {\n+    super();\n+  }\n+}"}]}