{"sha": "0e1474e5a6b808f10e251e2e1f3519f9f291d093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUxNDc0ZTVhNmI4MDhmMTBlMjUxZTJlMWYzNTE5ZjlmMjkxZDA5Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-22T09:32:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-22T09:32:07Z"}, "message": "* cgraphunit.c (analyze_functions) Use update_type_inheritance_graph.\n\n\t* ipa-utils.h (update_type_inheritance_graph): Declare.\n\t(possible_polymorphic_call_target_p): Declare.\n\t(possible_polymorphic_call_target_p): New.\n\t* ipa-devirt.c: Update toplevel comments.\n\t(cached_polymorphic_call_targets): Move up.\n\t(odr_type_d): Move ID down.\n\t(polymorphic_type_binfo_p): Update comment.\n\t(odr_hasher::remove): Likewise;\n\t(get_odr_type): Set anonymous_namespace.\n\t(dump_odr_type): Dump it.\n\t(dump_type_inheritance_graph): Do not ICE when there are no ODR types.\n\t(maybe_record_node): Record node in cached_polymorphic_call_targets.\n\t(record_binfo): Add comment.\n\t(free_polymorphic_call_targets_hash): Do not ICE when cache is not built.\n\t(devirt_node_removal_hook): Do not iCE when cache is freed.\n\t(possible_polymorphic_call_target_p): New predicate.\n\t(update_type_inheritance_graph): New function.\n\nFrom-SVN: r201917", "tree": {"sha": "4a67019baa93af0815f23244fb5d3620e2978469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a67019baa93af0815f23244fb5d3620e2978469"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e1474e5a6b808f10e251e2e1f3519f9f291d093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1474e5a6b808f10e251e2e1f3519f9f291d093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e1474e5a6b808f10e251e2e1f3519f9f291d093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e1474e5a6b808f10e251e2e1f3519f9f291d093/comments", "author": null, "committer": null, "parents": [{"sha": "e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e280b6ffe7f9f98573b29360dc36f4f7e41f35b4"}], "stats": {"total": 138, "additions": 120, "deletions": 18}, "files": [{"sha": "c38417cf980daafbf20756c065c55013e09e544f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e1474e5a6b808f10e251e2e1f3519f9f291d093", "patch": "@@ -1,3 +1,24 @@\n+2013-08-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (analyze_functions) Use update_type_inheritance_graph.\n+\t* ipa-utils.h (update_type_inheritance_graph): Declare.\n+\t(possible_polymorphic_call_target_p): Declare.\n+\t(possible_polymorphic_call_target_p): New.\n+\t* ipa-devirt.c: Update toplevel comments.\n+\t(cached_polymorphic_call_targets): Move up.\n+\t(odr_type_d): Move ID down.\n+\t(polymorphic_type_binfo_p): Update comment.\n+\t(odr_hasher::remove): Likewise;\n+\t(get_odr_type): Set anonymous_namespace.\n+\t(dump_odr_type): Dump it.\n+\t(dump_type_inheritance_graph): Do not ICE when there are no ODR types.\n+\t(maybe_record_node): Record node in cached_polymorphic_call_targets.\n+\t(record_binfo): Add comment.\n+\t(free_polymorphic_call_targets_hash): Do not ICE when cache is not built.\n+\t(devirt_node_removal_hook): Do not iCE when cache is freed.\n+\t(possible_polymorphic_call_target_p): New predicate.\n+\t(update_type_inheritance_graph): New function.\n+\n 2013-08-22  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Sergey Lega  <sergey.s.lega@intel.com>"}, {"sha": "0b839b06697e324f304bea424ce5e8f7228d86a6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0e1474e5a6b808f10e251e2e1f3519f9f291d093", "patch": "@@ -976,6 +976,8 @@ analyze_functions (void)\n           cgraph_process_new_functions ();\n \t}\n     }\n+  if (optimize && flag_devirtualize)\n+    update_type_inheritance_graph ();\n \n   /* Collect entry points to the unit.  */\n   if (cgraph_dump_file)"}, {"sha": "4daf6b451d90383ecf4869e8535977c8fa91eb3b", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 83, "deletions": 18, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=0e1474e5a6b808f10e251e2e1f3519f9f291d093", "patch": "@@ -37,10 +37,10 @@ along with GCC; see the file COPYING3.  If not see\n \t  names and types are the same.\n \n      OTR = OBJ_TYPE_REF\n-       This is Gimple representation of type information of a polymorphic call.\n+       This is the Gimple representation of type information of a polymorphic call.\n        It contains two parameters:\n \t otr_type is a type of class whose method is called.\n-\t otr_token is index into virtual table where address is taken.\n+\t otr_token is the index into virtual table where address is taken.\n \n      BINFO\n        This is the type inheritance information attached to each tree\n@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n        vector.  Members of this vectors are not BINFOs associated\n        with a base type.  Rather they are new copies of BINFOs\n        (base BINFOs). Their virtual tables may differ from\n-       virtual table of the base type.  Also BINFO_OFFSET specify\n+       virtual table of the base type.  Also BINFO_OFFSET specifies\n        offset of the base within the type.\n \n        In the case of single inheritance, the virtual table is shared\n@@ -72,7 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n      token\n        This is an index of virtual method in virtual table associated\n        to the type defining it. Token can be looked up from OBJ_TYPE_REF\n-       or from DECL_VINDEX of given virtual table.\n+       or from DECL_VINDEX of a given virtual table.\n \n      polymorphic (indirect) call\n        This is callgraph represention of virtual method call.  Every\n@@ -86,7 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n \n      We reconstruct it based on types of methods we see in the unit.\n      This means that the graph is not complete. Types with no methods are not\n-     inserted to the graph.  Also types without virtual methods are not\n+     inserted into the graph.  Also types without virtual methods are not\n      represented at all, though it may be easy to add this.\n   \n      The inheritance graph is represented as follows:\n@@ -95,7 +95,7 @@ along with GCC; see the file COPYING3.  If not see\n        to one or more tree type nodes that are equivalent by ODR rule.\n        (the multiple type nodes appear only with linktime optimization)\n \n-       Edges are repsented by odr_type->base and odr_type->derived_types.\n+       Edges are represented by odr_type->base and odr_type->derived_types.\n        At the moment we do not track offsets of types for multiple inheritance.\n        Adding this is easy.\n \n@@ -117,26 +117,36 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"gimple.h\"\n \n+/* Pointer set of all call targets appearing in the cache.  */\n+static pointer_set_t *cached_polymorphic_call_targets;\n+\n /* The node of type inheritance graph.  For each type unique in\n    One Defintion Rule (ODR) sense, we produce one node linking all \n    main variants of types equivalent to it, bases and derived types.  */\n \n struct GTY(()) odr_type_d\n {\n-  /* Unique ID indexing the type in odr_types array.  */\n-  int id;\n   /* leader type.  */\n   tree type;\n   /* All bases.  */\n   vec<odr_type> GTY((skip)) bases;\n   /* All derrived types with virtual methods seen in unit.  */\n   vec<odr_type> GTY((skip)) derived_types;\n+\n+  /* Unique ID indexing the type in odr_types array.  */\n+  int id;\n   /* Is it in anonymous namespace? */\n   bool anonymous_namespace;\n };\n \n \n-/* Return true if BINFO corresponds to a type with virtual methods.  */\n+/* Return true if BINFO corresponds to a type with virtual methods. \n+\n+   Every type has several BINFOs.  One is the BINFO associated by the type\n+   while other represents bases of derived types.  The BINFOs representing\n+   bases do not have BINFO_VTABLE pointer set when this is the single\n+   inheritance (because vtables are shared).  Look up the BINFO of type\n+   and check presence of its vtable.  */\n \n static inline bool\n polymorphic_type_binfo_p (tree binfo)\n@@ -184,7 +194,7 @@ odr_hasher::hash (const value_type *odr_type)\n   return hash_type_name (odr_type->type);\n }\n \n-/* Compare types operations T1 and T2 and return true if they are\n+/* Compare types T1 and T2 and return true if they are\n    equivalent.  */\n \n inline bool\n@@ -200,7 +210,7 @@ odr_hasher::equal (const value_type *t1, const compare_type *ct2)\n   return types_same_for_odr (t1->type, t2);\n }\n \n-/* Free a phi operation structure VP.  */\n+/* Free ODR type V.  */\n \n inline void\n odr_hasher::remove (value_type *v)\n@@ -259,6 +269,7 @@ get_odr_type (tree type, bool insert)\n       val->type = type;\n       val->bases = vNULL;\n       val->derived_types = vNULL;\n+      val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n       *slot = val;\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n \t/* For now record only polymorphic types. other are\n@@ -289,7 +300,7 @@ dump_odr_type (FILE *f, odr_type t, int indent=0)\n   unsigned int i;\n   fprintf (f, \"%*s type %i: \", indent * 2, \"\", t->id);\n   print_generic_expr (f, t->type, TDF_SLIM);\n-  fprintf (f, \"\\n\");\n+  fprintf (f, \"%s\\n\", t->anonymous_namespace ? \" (anonymous namespace)\":\"\");\n   if (TYPE_NAME (t->type))\n     {\n       fprintf (f, \"%*s defined at: %s:%i\\n\", indent * 2, \"\",\n@@ -318,6 +329,8 @@ static void\n dump_type_inheritance_graph (FILE *f)\n {\n   unsigned int i;\n+  if (!odr_types_ptr)\n+    return;\n   fprintf (f, \"\\n\\nType inheritance graph:\\n\");\n   for (i = 0; i < odr_types.length(); i++)\n     {\n@@ -383,7 +396,11 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n       && !pointer_set_insert (inserted, target)\n       && (target_node = cgraph_get_node (target)) != NULL\n       && symtab_real_symbol_p ((symtab_node)target_node))\n-    nodes.safe_push (target_node);\n+    {\n+      pointer_set_insert (cached_polymorphic_call_targets,\n+\t\t\t  target_node);\n+      nodes.safe_push (target_node);\n+    }\n }\n \n /* See if BINFO's type match OTR_TYPE.  If so, lookup method\n@@ -430,6 +447,8 @@ record_binfo (vec <cgraph_node *> &nodes,\n     /* Walking bases that have no virtual method is pointless excercise.  */\n     if (polymorphic_type_binfo_p (base_binfo))\n       record_binfo (nodes, base_binfo, otr_type,\n+\t\t    /* In the case of single inheritance, the virtual table\n+\t\t       is shared with the outer type.  */\n \t\t    BINFO_VTABLE (base_binfo) ? base_binfo : type_binfo,\n \t\t    otr_token, inserted,\n \t\t    matched_vtables);\n@@ -517,24 +536,27 @@ polymorphic_call_target_hasher::remove (value_type *v)\n typedef hash_table <polymorphic_call_target_hasher>\n    polymorphic_call_target_hash_type;\n static polymorphic_call_target_hash_type polymorphic_call_target_hash;\n-pointer_set_t *cached_polymorphic_call_targets;\n \n /* Destroy polymorphic call target query cache.  */\n \n static void\n free_polymorphic_call_targets_hash ()\n {\n-  polymorphic_call_target_hash.dispose ();\n-  pointer_set_destroy (cached_polymorphic_call_targets);\n-  cached_polymorphic_call_targets = NULL;\n+  if (cached_polymorphic_call_targets)\n+    {\n+      polymorphic_call_target_hash.dispose ();\n+      pointer_set_destroy (cached_polymorphic_call_targets);\n+      cached_polymorphic_call_targets = NULL;\n+    }\n }\n \n /* When virtual function is removed, we may need to flush the cache.  */\n \n static void\n devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n {\n-  if (pointer_set_contains (cached_polymorphic_call_targets, n))\n+  if (cached_polymorphic_call_targets\n+      && pointer_set_contains (cached_polymorphic_call_targets, n))\n     free_polymorphic_call_targets_hash ();\n }\n \n@@ -663,4 +685,47 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   fprintf (f, \"\\n\");\n }\n \n+\n+/* Return true if N can be possibly target of a polymorphic call of\n+   OTR_TYPE/OTR_TOKEN.  */\n+\n+bool\n+possible_polymorphic_call_target_p (tree otr_type,\n+\t\t\t\t    HOST_WIDE_INT otr_token,\n+\t\t\t\t    struct cgraph_node *n)\n+{\n+  vec <cgraph_node *> targets;\n+  unsigned int i;\n+\n+  if (!odr_hash.is_created ())\n+    return true;\n+  targets = possible_polymorphic_call_targets (otr_type, otr_token);\n+  for (i = 0; i < targets.length (); i++)\n+    if (n == targets[i])\n+      return true;\n+  return false;\n+}\n+\n+\n+/* After callgraph construction new external nodes may appear.\n+   Add them into the graph.  */\n+\n+void\n+update_type_inheritance_graph (void)\n+{\n+  struct cgraph_node *n;\n+\n+  if (!odr_hash.is_created ())\n+    return;\n+  free_polymorphic_call_targets_hash ();\n+  timevar_push (TV_IPA_INHERITANCE);\n+  /* We reconstruct the graph starting of types of all methods seen in the\n+     the unit.  */\n+  FOR_EACH_FUNCTION (n)\n+    if (DECL_VIRTUAL_P (n->symbol.decl)\n+\t&& !n->symbol.definition\n+\t&& symtab_real_symbol_p ((symtab_node)n))\n+      get_odr_type (method_class_type (TREE_TYPE (n->symbol.decl)), true);\n+  timevar_pop (TV_IPA_INHERITANCE);\n+}\n #include \"gt-ipa-devirt.h\""}, {"sha": "3c6c93c10a1d509373361efb07ab8f7b46a8915b", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e1474e5a6b808f10e251e2e1f3519f9f291d093/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=0e1474e5a6b808f10e251e2e1f3519f9f291d093", "patch": "@@ -50,12 +50,15 @@ tree get_base_var (tree);\n struct odr_type_d;\n typedef odr_type_d *odr_type;\n void build_type_inheritance_graph (void);\n+void update_type_inheritance_graph (void);\n vec <cgraph_node *>\n possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   bool *final = NULL,\n \t\t\t\t   void **cache_token = NULL);\n odr_type get_odr_type (tree, bool insert = false);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT);\n+bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n+\t\t\t\t\t struct cgraph_node *n);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. \n@@ -87,6 +90,17 @@ dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n \t\t\t\t\t  e->indirect_info->otr_token);\n }\n+\n+/* Return true if N can be possibly target of a polymorphic call of\n+   E.  */\n+\n+inline bool\n+possible_polymorphic_call_target_p (struct cgraph_edge *e,\n+\t\t\t\t    struct cgraph_node *n)\n+{\n+  return possible_polymorphic_call_target_p (e->indirect_info->otr_type,\n+\t\t\t\t\t     e->indirect_info->otr_token, n);\n+}\n #endif  /* GCC_IPA_UTILS_H  */\n \n "}]}