{"sha": "7308a047aba750d36ef75c0a97163ccf00d60023", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwOGEwNDdhYmE3NTBkMzZlZjc1YzBhOTcxNjNjY2YwMGQ2MDAyMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-09T06:38:59Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-09T06:38:59Z"}, "message": "(expand_expr): Support IN_EXPR.\n\n(init_expr_once): Don't try HARD_REGNO_MODE_OK on VOIDmode or BLKmode.\n(emit_move_insn): When moving word by word,\n  mark the whole thing as a libcall block.\n(group_insns): New function.\n(expand_expr): Implement COMPLEX_EXPR, REALPART_EXPR, IMAGPART_EXPR, CONJ_EXPR.\n\nFrom-SVN: r2082", "tree": {"sha": "df4a053c9e24c26a3e965ef712bd47eeff78fc4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df4a053c9e24c26a3e965ef712bd47eeff78fc4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7308a047aba750d36ef75c0a97163ccf00d60023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7308a047aba750d36ef75c0a97163ccf00d60023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7308a047aba750d36ef75c0a97163ccf00d60023", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7308a047aba750d36ef75c0a97163ccf00d60023/comments", "author": null, "committer": null, "parents": [{"sha": "a11ad2c36c6f66a173fcdc5f07914a49b8ea164f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a11ad2c36c6f66a173fcdc5f07914a49b8ea164f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a11ad2c36c6f66a173fcdc5f07914a49b8ea164f"}], "stats": {"total": 295, "additions": 279, "deletions": 16}, "files": [{"sha": "142dedd25720afe8ccce8304c664fb8b3260cd83", "filename": "gcc/expr.c", "status": "modified", "additions": 279, "deletions": 16, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7308a047aba750d36ef75c0a97163ccf00d60023/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7308a047aba750d36ef75c0a97163ccf00d60023/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7308a047aba750d36ef75c0a97163ccf00d60023", "patch": "@@ -158,25 +158,26 @@ init_expr_once ()\n       /* See if there is some register that can be used in this mode and\n \t directly loaded or stored from memory.  */\n \n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER\n-\t   && (direct_load[(int) mode] == 0 || direct_store[(int) mode] == 0);\n-\t   regno++)\n-\t{\n-\t  if (! HARD_REGNO_MODE_OK (regno, mode))\n-\t    continue;\n+      if (mode != VOIDmode && mode != BLKmode)\n+\tfor (regno = 0; regno < FIRST_PSEUDO_REGISTER\n+\t     && (direct_load[(int) mode] == 0 || direct_store[(int) mode] == 0);\n+\t     regno++)\n+\t  {\n+\t    if (! HARD_REGNO_MODE_OK (regno, mode))\n+\t      continue;\n \n-\t  reg = gen_rtx (REG, mode, regno);\n+\t    reg = gen_rtx (REG, mode, regno);\n \n-\t  SET_SRC (pat) = mem;\n-\t  SET_DEST (pat) = reg;\n-\t  if (recog (pat, insn, &num_clobbers) >= 0)\n-\t    direct_load[(int) mode] = 1;\n+\t    SET_SRC (pat) = mem;\n+\t    SET_DEST (pat) = reg;\n+\t    if (recog (pat, insn, &num_clobbers) >= 0)\n+\t      direct_load[(int) mode] = 1;\n \n-\t  SET_SRC (pat) = reg;\n-\t  SET_DEST (pat) = mem;\n-\t  if (recog (pat, insn, &num_clobbers) >= 0)\n-\t    direct_store[(int) mode] = 1;\n-\t}\n+\t    SET_SRC (pat) = reg;\n+\t    SET_DEST (pat) = mem;\n+\t    if (recog (pat, insn, &num_clobbers) >= 0)\n+\t      direct_store[(int) mode] = 1;\n+\t  }\n \n       movstr_optab[(int) mode] = CODE_FOR_nothing;\n     }\n@@ -1320,6 +1321,31 @@ use_regs (regno, nregs)\n   for (i = 0; i < nregs; i++)\n     emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, word_mode, regno + i)));\n }\n+\n+/* Mark the instructions since PREV as a libcall block.\n+   Add REG_LIBCALL to PREV and add a REG_RETVAL to the most recent insn.  */\n+\n+static rtx\n+group_insns (prev)\n+     rtx prev;\n+{\n+  rtx insn_first;\n+  rtx insn_last;\n+\n+  /* Find the instructions to mark */\n+  if (prev)\n+    insn_first = NEXT_INSN (prev);\n+  else\n+    insn_first = get_insns ();\n+\n+  insn_last = get_last_insn ();\n+\n+  REG_NOTES (insn_last) = gen_rtx (INSN_LIST, REG_RETVAL, insn_first,\n+\t\t\t\t   REG_NOTES (insn_last));\n+\n+  REG_NOTES (insn_first) = gen_rtx (INSN_LIST, REG_LIBCALL, insn_last,\n+\t\t\t\t    REG_NOTES (insn_first));\n+}\n \f\n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n@@ -1359,6 +1385,8 @@ emit_move_insn (x, y)\n      rtx x, y;\n {\n   enum machine_mode mode = GET_MODE (x);\n+  enum machine_mode submode;\n+  enum mode_class class = GET_MODE_CLASS (mode);\n   int i;\n \n   x = protect_from_queue (x, 1);\n@@ -1388,16 +1416,54 @@ emit_move_insn (x, y)\n   if (mode == BLKmode)\n     abort ();\n \n+  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n+    submode = mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t\t     (class == MODE_COMPLEX_INT\n+\t\t\t      ? MODE_INT : MODE_FLOAT),\n+\t\t\t     0);\n+\n   if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     return\n       emit_insn (GEN_FCN (mov_optab->handlers[(int) mode].insn_code) (x, y));\n \n+  /* Expand complex moves by moving real part and imag part, if posible.  */\n+  else if ((class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n+\t   && submode != BLKmode\n+\t   && (mov_optab->handlers[(int) submode].insn_code\n+\t       != CODE_FOR_nothing))\n+    {\n+      /* Don't split destination if it is a stack push.  */\n+      int stack = push_operand (x, GET_MODE (x));\n+      rtx prev = get_last_insn ();\n+\n+      /* Tell flow that the whole of the destination is being set.  */\n+      if (GET_CODE (x) == REG)\n+\temit_insn (gen_rtx (CLOBBER, VOIDmode, x));\n+\n+      /* If this is a stack, push the highpart first, so it\n+\t will be in the argument order.\n+\n+\t In that case, change_address is used only to convert\n+\t the mode, not to change the address.  */\n+      emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n+\t\t ((stack ? change_address (x, submode, (rtx) 0)\n+\t\t   : gen_highpart (submode, x)),\n+\t\t  gen_highpart (submode, y)));\n+      emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n+\t\t ((stack ? change_address (x, submode, (rtx) 0)\n+\t\t   : gen_lowpart (submode, x)),\n+\t\t  gen_lowpart (submode, y)));\n+\n+      group_insns (prev);\n+    }\n+\n   /* This will handle any multi-word mode that lacks a move_insn pattern.\n      However, you will get better code if you define such patterns,\n      even if they must turn into multiple assembler instructions.  */\n   else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     {\n       rtx last_insn = 0;\n+      rtx prev_insn = get_last_insn ();\n \n       for (i = 0;\n \t   i < (GET_MODE_SIZE (mode)  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n@@ -1422,6 +1488,9 @@ emit_move_insn (x, y)\n \n \t  last_insn = emit_move_insn (xpart, ypart);\n \t}\n+      /* Mark these insns as a libcall block.  */\n+      group_insns (prev_insn);\n+\n       return last_insn;\n     }\n   else\n@@ -3763,6 +3832,118 @@ expand_expr (exp, target, tmode, modifier)\n     case BUFFER_REF:\n       abort ();\n \n+    /* IN_EXPR: Inlined pascal set IN expression.\n+\n+       Algorithm:\n+         rlo       = set_low - (set_low%bits_per_word);\n+\t the_word  = set [ (index - rlo)/bits_per_word ];\n+\t bit_index = index % bits_per_word;\n+\t bitmask   = 1 << bit_index;\n+\t return !!(the_word & bitmask);  */\n+    case IN_EXPR:\n+      preexpand_calls (exp);\n+      {\n+\ttree set = TREE_OPERAND (exp, 0);\n+\ttree index = TREE_OPERAND (exp, 1);\n+\ttree set_type = TREE_TYPE (set);\n+\n+\ttree set_low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (set_type));\n+\ttree set_high_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (set_type));\n+\n+\trtx index_val;\n+\trtx lo_r;\n+\trtx hi_r;\n+\trtx rlow;\n+\trtx diff, quo, rem, addr, bit, result;\n+\trtx setval, setaddr;\n+\tenum machine_mode index_mode = TYPE_MODE (TREE_TYPE (index));\n+\n+\tif (target == 0)\n+\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\n+\t/* If domain is empty, answer is no.  */\n+\tif (tree_int_cst_lt (set_high_bound, set_low_bound))\n+\t  return const0_rtx;\n+\n+\tindex_val = expand_expr (index, 0, VOIDmode, 0);\n+\tlo_r = expand_expr (set_low_bound, 0, VOIDmode, 0);\n+\thi_r = expand_expr (set_high_bound, 0, VOIDmode, 0);\n+\tsetval = expand_expr (set, 0, VOIDmode, 0);\n+\tsetaddr = XEXP (setval, 0); \n+\n+\t/* Compare index against bounds, if they are constant.  */\n+\tif (GET_CODE (index_val) == CONST_INT\n+\t    && GET_CODE (lo_r) == CONST_INT)\n+\t  {\n+\t    if (INTVAL (index_val) < INTVAL (lo_r))\n+\t      return const0_rtx;\n+\t  }\n+\n+\tif (GET_CODE (index_val) == CONST_INT\n+\t    && GET_CODE (hi_r) == CONST_INT)\n+\t  {\n+\t    if (INTVAL (hi_r) < INTVAL (index_val))\n+\t      return const0_rtx;\n+\t  }\n+\n+\t/* If we get here, we have to generate the code for both cases\n+\t   (in range and out of range).  */\n+\n+\top0 = gen_label_rtx ();\n+\top1 = gen_label_rtx ();\n+\n+\tif (! (GET_CODE (index_val) == CONST_INT\n+\t       && GET_CODE (lo_r) == CONST_INT))\n+\t  {\n+\t    emit_cmp_insn (index_val, lo_r, LT, 0, GET_MODE (index_val), 0, 0);\n+\t    emit_jump_insn (gen_blt (op1));\n+\t  }\n+\n+\tif (! (GET_CODE (index_val) == CONST_INT\n+\t       && GET_CODE (hi_r) == CONST_INT))\n+\t  {\n+\t    emit_cmp_insn (index_val, hi_r, GT, 0, GET_MODE (index_val), 0, 0);\n+\t    emit_jump_insn (gen_bgt (op1));\n+\t  }\n+\n+\t/* Calculate the element number of bit zero in the first word\n+\t   of the set.  */\n+\tif (GET_CODE (lo_r) == CONST_INT)\n+\t  rlow = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  INTVAL (lo_r) & ~ (1 << BITS_PER_UNIT));\n+\telse\n+\t  rlow = expand_binop (index_mode, and_optab,\n+\t\t\t       lo_r, gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t      ~ (1 << BITS_PER_UNIT)),\n+\t\t\t       0, 0, OPTAB_LIB_WIDEN);\n+\n+\tdiff = expand_binop (index_mode, sub_optab,\n+\t\t\t     index_val, rlow, 0, 0, OPTAB_LIB_WIDEN);\n+\n+\tquo = expand_divmod (0, TRUNC_DIV_EXPR, index_mode, diff,\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, BITS_PER_UNIT),\n+\t\t\t     0, 0);\n+\trem = expand_divmod (1, TRUNC_MOD_EXPR, index_mode, index_val,\n+\t\t\t     gen_rtx (CONST_INT, VOIDmode, BITS_PER_UNIT),\n+\t\t\t     0, 0);\n+\taddr = memory_address (byte_mode,\n+\t\t\t       expand_binop (index_mode, add_optab,\n+\t\t\t\t\t     diff, setaddr));\n+\t/* Extract the bit we want to examine */\n+\tbit = expand_shift (RSHIFT_EXPR, byte_mode,\n+\t\t\t    gen_rtx (MEM, byte_mode, addr), rem, 0, 1);\n+\tresult = expand_binop (SImode, and_optab, bit, const1_rtx, target,\n+\t\t\t       1, OPTAB_LIB_WIDEN);\n+\temit_move_insn (target, result);\n+\n+\t/* Output the code to handle the out-of-range case.  */\n+\temit_jump (op0);\n+\temit_label (op1);\n+\temit_move_insn (target, const0_rtx);\n+\temit_label (op0);\n+\treturn target;\n+      }\n+\n     case WITH_CLEANUP_EXPR:\n       if (RTL_EXPR_RTL (exp) == 0)\n \t{\n@@ -4841,6 +5022,88 @@ expand_expr (exp, target, tmode, modifier)\n     case ENTRY_VALUE_EXPR:\n       abort ();\n \n+    /* COMPLEX type for Extended Pascal & Fortran  */\n+    case COMPLEX_EXPR:\n+      {\n+\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n+\n+\trtx prev;\n+\n+\t/* Get the rtx code of the operands.  */\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\top1 = expand_expr (TREE_OPERAND (exp, 1), 0, VOIDmode, 0);\n+\n+\tif (! target)\n+\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\n+\tprev = get_last_insn ();\n+\n+\t/* Tell flow that the whole of the destination is being set.  */\n+\tif (GET_CODE (target) == REG)\n+\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\n+\t/* Move the real (op0) and imaginary (op1) parts to their location.  */\n+\temit_move_insn (gen_lowpart  (mode, target), op0);\n+\temit_move_insn (gen_highpart (mode, target), op1);\n+\n+\t/* Complex construction should appear as a single unit.  */\n+\tgroup_insns (prev);\n+\n+\treturn target;\n+      }\n+\n+    case REALPART_EXPR:\n+      {\n+\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\tif (! target)\n+\t  target = gen_reg_rtx (mode);\n+\temit_move_insn (target, gen_lowpart (mode, op0));\n+\treturn target;\n+      }\t\t\n+      \n+    case IMAGPART_EXPR:\n+      {\n+\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\tif (! target)\n+\t  target = gen_reg_rtx (mode);\n+\temit_move_insn (target, gen_highpart (mode, op0));\n+\treturn target;\n+      }\t\t\n+\n+    case CONJ_EXPR:\n+      {\n+\tenum machine_mode mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n+\trtx imag_t;\n+\trtx prev;\n+\t\n+\top0  = expand_expr (TREE_OPERAND (exp, 0), 0, VOIDmode, 0);\n+\n+\tif (! target)\n+\t  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\t\t\t\t\t\t\t\t    \n+\tprev = get_last_insn ();\n+\n+\t/* Tell flow that the whole of the destination is being set.  */\n+\tif (GET_CODE (target) == REG)\n+\t  emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\n+\t/* Store the realpart and the negated imagpart to target.  */\n+\temit_move_insn (gen_lowpart (mode, target), gen_lowpart (mode, op0));\n+\n+\timag_t = gen_highpart (mode, target);\n+\ttemp   = expand_unop (mode, neg_optab,\n+\t\t\t      gen_highpart (mode, op0), imag_t, 0);\n+\tif (temp != imag_t)\n+\t  emit_move_insn (imag_t, temp);\n+\n+\t/* Conjugate should appear as a single unit */\n+\tgroup_insns (prev);\n+\n+\treturn target;\n+      }\n+\n     case ERROR_MARK:\n       return const0_rtx;\n "}]}