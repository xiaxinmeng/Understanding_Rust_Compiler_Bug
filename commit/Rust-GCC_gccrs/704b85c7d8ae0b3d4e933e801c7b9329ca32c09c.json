{"sha": "704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0Yjg1YzdkOGFlMGIzZDRlOTMzZTgwMWM3YjkzMjljYTMyYzA5Yw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-05-16T14:55:15Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-05-16T14:55:15Z"}, "message": "Update documentation of AArch64 options for GCC6 to be more accurate,\n\nfix a few minor mistakes and remove some duplication.\n\n        * doc/invoke.texi (AArch64 Options): Various updates.\n\nFrom-SVN: r236290", "tree": {"sha": "c6af9878be1d239bf57fce6c940ed993aeecaf22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6af9878be1d239bf57fce6c940ed993aeecaf22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c/comments", "author": null, "committer": null, "parents": [{"sha": "0bc8d0b3c1263f1bb039922ad41b35ab841529b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc8d0b3c1263f1bb039922ad41b35ab841529b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bc8d0b3c1263f1bb039922ad41b35ab841529b0"}], "stats": {"total": 76, "additions": 36, "deletions": 40}, "files": [{"sha": "a79fc670360ad9f0976abd7182638a7d41e90ca8", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "patch": "@@ -1,3 +1,7 @@\n+2016-05-16  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* doc/invoke.texi (AArch64 Options): Various updates.\n+\n 2016-05-09  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "19dad1eea338691274ab1878f6f283f87a455d74", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704b85c7d8ae0b3d4e933e801c7b9329ca32c09c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=704b85c7d8ae0b3d4e933e801c7b9329ca32c09c", "patch": "@@ -12872,9 +12872,9 @@ These options are defined for AArch64 implementations:\n @item -mabi=@var{name}\n @opindex mabi\n Generate code for the specified data model.  Permissible values\n-are @samp{ilp32} for SysV-like data model where int, long int and pointer\n-are 32-bit, and @samp{lp64} for SysV-like data model where int is 32-bit,\n-but long int and pointer are 64-bit.\n+are @samp{ilp32} for SysV-like data model where int, long int and pointers\n+are 32 bits, and @samp{lp64} for SysV-like data model where int is 32 bits,\n+but long int and pointers are 64 bits.\n \n The default depends on the specific target configuration.  Note that\n the LP64 and ILP32 ABIs are not link-compatible; you must compile your\n@@ -12899,25 +12899,24 @@ Generate little-endian code.  This is the default when GCC is configured for an\n @item -mcmodel=tiny\n @opindex mcmodel=tiny\n Generate code for the tiny code model.  The program and its statically defined\n-symbols must be within 1GB of each other.  Pointers are 64 bits.  Programs can\n-be statically or dynamically linked.  This model is not fully implemented and\n-mostly treated as @samp{small}.\n+symbols must be within 1MB of each other.  Programs can be statically or\n+dynamically linked.\n \n @item -mcmodel=small\n @opindex mcmodel=small\n Generate code for the small code model.  The program and its statically defined\n-symbols must be within 4GB of each other.  Pointers are 64 bits.  Programs can\n-be statically or dynamically linked.  This is the default code model.\n+symbols must be within 4GB of each other.  Programs can be statically or\n+dynamically linked.  This is the default code model.\n \n @item -mcmodel=large\n @opindex mcmodel=large\n Generate code for the large code model.  This makes no assumptions about\n-addresses and sizes of sections.  Pointers are 64 bits.  Programs can be\n-statically linked only.\n+addresses and sizes of sections.  Programs can be statically linked only.\n \n @item -mstrict-align\n @opindex mstrict-align\n-Do not assume that unaligned memory references are handled by the system.\n+Avoid generating memory accesses that may not be aligned on a natural object\n+boundary as described in the architecture specification.\n \n @item -momit-leaf-frame-pointer\n @itemx -mno-omit-leaf-frame-pointer\n@@ -12939,7 +12938,7 @@ of TLS variables.\n @item -mtls-size=@var{size}\n @opindex mtls-size\n Specify bit size of immediate TLS offsets.  Valid values are 12, 24, 32, 48.\n-This option depends on binutils higher than 2.25.\n+This option requires binutils 2.26 or newer.\n \n @item -mfix-cortex-a53-835769\n @itemx -mno-fix-cortex-a53-835769\n@@ -12959,12 +12958,13 @@ corresponding flag to the linker.\n \n @item -mlow-precision-recip-sqrt\n @item -mno-low-precision-recip-sqrt\n-@opindex -mlow-precision-recip-sqrt\n-@opindex -mno-low-precision-recip-sqrt\n-When calculating the reciprocal square root approximation,\n-uses one less step than otherwise, thus reducing latency and precision.\n-This is only relevant if @option{-ffast-math} enables the reciprocal square root\n-approximation, which in turn depends on the target processor.\n+@opindex mlow-precision-recip-sqrt\n+@opindex mno-low-precision-recip-sqrt\n+Enable or disable reciprocal square root approximation.\n+This option only has an effect if @option{-ffast-math} or\n+@option{-funsafe-math-optimizations} is used as well.  Enabling this reduces\n+precision of reciprocal square root results to about 16 bits for\n+single precision and to 32 bits for double precision.\n \n @item -march=@var{name}\n @opindex march\n@@ -13001,17 +13001,15 @@ Specify the name of the target processor for which GCC should tune the\n performance of the code.  Permissible values for this option are:\n @samp{generic}, @samp{cortex-a35}, @samp{cortex-a53}, @samp{cortex-a57},\n @samp{cortex-a72}, @samp{exynos-m1}, @samp{qdf24xx}, @samp{thunderx},\n-@samp{xgene1}.\n+@samp{xgene1}, @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},\n+@samp{native}.\n \n-Additionally, this option can specify that GCC should tune the performance\n-of the code for a big.LITTLE system.  Permissible values for this\n-option are: @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53}.\n+The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53}\n+specify that GCC should tune for a big.LITTLE system.\n \n Additionally on native AArch64 GNU/Linux systems the value\n-@samp{native} is available.  This option causes the compiler to pick\n-the architecture of and tune the performance of the code for the\n-processor of the host system.  This option has no effect if the\n-compiler is unable to recognize the architecture of the host system.\n+@samp{native} tunes performance to the host system.  This option has no effect\n+if the compiler is unable to recognize the processor of the host system.\n \n Where none of @option{-mtune=}, @option{-mcpu=} or @option{-march=}\n are specified, the code is tuned to perform well across a range\n@@ -13031,12 +13029,6 @@ documented in the sub-section on\n Feature Modifiers}.  Where conflicting feature modifiers are\n specified, the right-most feature is used.\n \n-Additionally on native AArch64 GNU/Linux systems the value\n-@samp{native} is available.  This option causes the compiler to tune\n-the performance of the code for the processor of the host system.\n-This option has no effect if the compiler is unable to recognize the\n-architecture of the host system.\n-\n GCC uses @var{name} to determine what kind of instructions it can emit when\n generating assembly code (as if by @option{-march}) and to determine\n the target processor for which to tune for performance (as if\n@@ -13054,11 +13046,11 @@ across releases.\n This option is only intended to be useful when developing GCC.\n \n @item -mpc-relative-literal-loads\n-@opindex mpcrelativeliteralloads\n-Enable PC relative literal loads. If this option is used, literal\n-pools are assumed to have a range of up to 1MiB and an appropriate\n-instruction sequence is used. This option has no impact when used\n-with @option{-mcmodel=tiny}.\n+@opindex mpc-relative-literal-loads\n+Enable PC-relative literal loads.  With this option literal pools are\n+accessed using a single instruction and emitted after each function.  This\n+limits the maximum size of functions to 1MB.  This is enabled by default for\n+@option{-mcmodel=tiny}.\n \n @end table\n \n@@ -13089,9 +13081,9 @@ Enable Large System Extension instructions.  This is on by default for\n \n @end table\n \n-That is, @option{crypto} implies @option{simd} implies @option{fp}.\n-Conversely, @option{nofp} (or equivalently, @option{-mgeneral-regs-only})\n-implies @option{nosimd} implies @option{nocrypto}.\n+Feature @option{crypto} implies @option{simd}, which implies @option{fp}.\n+Conversely, @option{nofp} implies @option{nosimd}, which implies\n+@option{nocrypto}.\n \n @node Adapteva Epiphany Options\n @subsection Adapteva Epiphany Options"}]}