{"sha": "c38573a8d0ada5f22281897f0ee5ecd818156e56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM4NTczYThkMGFkYTVmMjIyODE4OTdmMGVlNWVjZDgxODE1NmU1Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-23T10:20:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-23T10:20:04Z"}, "message": "i386.c (ix86_expand_vector_move): Tidy.\n\n        * config/i386/i386.c (ix86_expand_vector_move): Tidy.\n        (ix86_expand_vector_move_misalign): New.\n        (ix86_misaligned_mem_ok): Remove.\n        (TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n        * config/i386/i386-protos.h: Update.\n        * config/i386/i386.md (SSEMODEI): Rename from SSEINT16.\n        (MMXMODEI): Rename from MMXINT8.\n        (SSEMODE, MMXMODE, movmisalign<mode>): New.\n\nFrom-SVN: r92543", "tree": {"sha": "0c3f072d4750018120765dd8de2ddbe8528098e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c3f072d4750018120765dd8de2ddbe8528098e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c38573a8d0ada5f22281897f0ee5ecd818156e56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c38573a8d0ada5f22281897f0ee5ecd818156e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c38573a8d0ada5f22281897f0ee5ecd818156e56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c38573a8d0ada5f22281897f0ee5ecd818156e56/comments", "author": null, "committer": null, "parents": [{"sha": "f98625f6a5077fa1554d7ea94016f452b79a00e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98625f6a5077fa1554d7ea94016f452b79a00e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98625f6a5077fa1554d7ea94016f452b79a00e2"}], "stats": {"total": 208, "additions": 175, "deletions": 33}, "files": [{"sha": "1fa3c957c0496e4883b8a5a795e610f4bec9dc4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c38573a8d0ada5f22281897f0ee5ecd818156e56", "patch": "@@ -1,3 +1,14 @@\n+2004-12-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vector_move): Tidy.\n+\t(ix86_expand_vector_move_misalign): New.\n+\t(ix86_misaligned_mem_ok): Remove.\n+\t(TARGET_VECTORIZE_MISALIGNED_MEM_OK): Remove.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.md (SSEMODEI): Rename from SSEINT16.\n+\t(MMXMODEI): Rename from MMXINT8.\n+\t(SSEMODE, MMXMODE, movmisalign<mode>): New.\n+\n 2004-12-23  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16405"}, {"sha": "58e4e23471b95fc32c58bfe15eefd14547a44f07", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=c38573a8d0ada5f22281897f0ee5ecd818156e56", "patch": "@@ -125,6 +125,7 @@ extern void i386_output_dwarf_dtprel (FILE*, int, rtx);\n extern void ix86_expand_clear (rtx);\n extern void ix86_expand_move (enum machine_mode, rtx[]);\n extern void ix86_expand_vector_move (enum machine_mode, rtx[]);\n+extern void ix86_expand_vector_move_misalign (enum machine_mode, rtx[]);\n extern void ix86_expand_binary_operator (enum rtx_code,\n \t\t\t\t\t enum machine_mode, rtx[]);\n extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);"}, {"sha": "fa6c3b4cbf18d06783485e547b8481de2e41c02b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 129, "deletions": 23, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c38573a8d0ada5f22281897f0ee5ecd818156e56", "patch": "@@ -867,7 +867,6 @@ static void ix86_expand_strlensi_unroll_1 (rtx, rtx, rtx);\n static int ix86_issue_rate (void);\n static int ix86_adjust_cost (rtx, rtx, rtx, int);\n static int ia32_multipass_dfa_lookahead (void);\n-static bool ix86_misaligned_mem_ok (enum machine_mode);\n static void ix86_init_mmx_sse_builtins (void);\n static rtx x86_this_parameter (tree);\n static void x86_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n@@ -1010,9 +1009,6 @@ static void init_ext_80387_constants (void);\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   ia32_multipass_dfa_lookahead\n \n-#undef TARGET_VECTORIZE_MISALIGNED_MEM_OK\n-#define TARGET_VECTORIZE_MISALIGNED_MEM_OK ix86_misaligned_mem_ok\n-\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL ix86_function_ok_for_sibcall\n \n@@ -7556,28 +7552,149 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n void\n ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n {\n+  rtx op0 = operands[0], op1 = operands[1];\n+\n   /* Force constants other than zero into memory.  We do not know how\n      the instructions used to build constants modify the upper 64 bits\n      of the register, once we have that information we may be able\n      to handle some of them more efficiently.  */\n   if ((reload_in_progress | reload_completed) == 0\n-      && register_operand (operands[0], mode)\n-      && CONSTANT_P (operands[1]) && operands[1] != CONST0_RTX (mode))\n-    operands[1] = validize_mem (force_const_mem (mode, operands[1]));\n+      && register_operand (op0, mode)\n+      && CONSTANT_P (op1) && op1 != CONST0_RTX (mode))\n+    op1 = validize_mem (force_const_mem (mode, op1));\n \n   /* Make operand1 a register if it isn't already.  */\n   if (!no_new_pseudos\n-      && !register_operand (operands[0], mode)\n-      && !register_operand (operands[1], mode))\n+      && !register_operand (op0, mode)\n+      && !register_operand (op1, mode))\n     {\n-      rtx temp = force_reg (GET_MODE (operands[1]), operands[1]);\n-      emit_move_insn (operands[0], temp);\n+      emit_move_insn (op0, force_reg (GET_MODE (op0), op1));\n       return;\n     }\n \n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  emit_insn (gen_rtx_SET (VOIDmode, op0, op1));\n+}\n+\n+/* Implement the movmisalign patterns for SSE.  Non-SSE modes go \n+   straight to ix86_expand_vector_move.  */\n+\n+void\n+ix86_expand_vector_move_misalign (enum machine_mode mode, rtx operands[])\n+{\n+  rtx op0, op1, m;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+\n+  if (MEM_P (op1))\n+    {\n+      /* If we're optimizing for size, movups is the smallest.  */\n+      if (optimize_size)\n+\t{\n+\t  op0 = gen_lowpart (V4SFmode, op0);\n+\t  op1 = gen_lowpart (V4SFmode, op1);\n+\t  emit_insn (gen_sse_movups (op0, op1));\n+\t  return;\n+\t}\n+\n+      /* ??? If we have typed data, then it would appear that using\n+\t movdqu is the only way to get unaligned data loaded with\n+\t integer type.  */\n+      if (TARGET_SSE2 && GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t{\n+\t  op0 = gen_lowpart (V16QImode, op0);\n+\t  op1 = gen_lowpart (V16QImode, op1);\n+\t  emit_insn (gen_sse2_movdqu (op0, op1));\n+\t  return;\n+\t}\n+\n+      if (TARGET_SSE2 && mode == V2DFmode)\n+\t{\n+\t  /* When SSE registers are split into halves, we can avoid\n+\t     writing to the top half twice.  */\n+\t  if (TARGET_SSE_SPLIT_REGS)\n+\t    {\n+\t      emit_insn (gen_rtx_CLOBBER (VOIDmode, op0));\n+\t      m = adjust_address (op1, DFmode, 0);\n+\t      emit_insn (gen_sse2_loadlpd (op0, op0, m));\n+\t      m = adjust_address (op1, DFmode, 8);\n+\t      emit_insn (gen_sse2_loadhpd (op0, op0, m));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* ??? Not sure about the best option for the Intel chips.\n+\t\t The following would seem to satisfy; the register is\n+\t\t entirely cleared, breaking the dependency chain.  We\n+\t\t then store to the upper half, with a dependency depth\n+\t\t of one.  A rumor has it that Intel recommends two movsd\n+\t\t followed by an unpacklpd, but this is unconfirmed.  And\n+\t\t given that the dependency depth of the unpacklpd would\n+\t\t still be one, I'm not sure why this would be better.  */\n+\t      m = adjust_address (op1, DFmode, 0);\n+\t      emit_insn (gen_sse2_loadsd (op0, m));\n+\t      m = adjust_address (op1, DFmode, 8);\n+\t      emit_insn (gen_sse2_loadhpd (op0, op0, m));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_SSE_PARTIAL_REG_DEPENDENCY)\n+\t    emit_move_insn (op0, CONST0_RTX (mode));\n+\t  else\n+\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, op0));\n+\n+\t  op0 = gen_lowpart (V4SFmode, op0);\n+\t  m = adjust_address (op1, V4SFmode, 0);\n+\t  emit_insn (gen_sse_movlps (op0, op0, m));\n+\t  m = adjust_address (op1, V4SFmode, 8);\n+\t  emit_insn (gen_sse_movhps (op0, op0, m));\n+\t}\n+    }\n+  else if (MEM_P (op0))\n+    {\n+      /* If we're optimizing for size, movups is the smallest.  */\n+      if (optimize_size)\n+\t{\n+\t  op0 = gen_lowpart (V4SFmode, op0);\n+\t  op1 = gen_lowpart (V4SFmode, op1);\n+\t  emit_insn (gen_sse_movups (op0, op1));\n+\t  return;\n+\t}\n+\n+      /* ??? Similar to above, only less clear because of quote\n+\t typeless stores unquote.  */\n+      if (TARGET_SSE2 && !TARGET_SSE_TYPELESS_STORES\n+\t  && GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+        {\n+\t  op0 = gen_lowpart (V16QImode, op0);\n+\t  op1 = gen_lowpart (V16QImode, op1);\n+\t  emit_insn (gen_sse2_movdqu (op0, op1));\n+\t  return;\n+\t}\n+\n+      if (TARGET_SSE2 && mode == V2DFmode)\n+\t{\n+\t  m = adjust_address (op0, DFmode, 0);\n+\t  emit_insn (gen_sse2_storelpd (m, op1));\n+\t  m = adjust_address (op0, DFmode, 8);\n+\t  emit_insn (gen_sse2_storehpd (m, op1));\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  op1 = gen_lowpart (V4SFmode, op1);\n+\t  m = adjust_address (op0, V4SFmode, 0);\n+\t  emit_insn (gen_sse_movlps (m, m, op1));\n+\t  m = adjust_address (op0, V4SFmode, 8);\n+\t  emit_insn (gen_sse_movhps (m, m, op1));\n+\t  return;\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n }\n \n+\n /* Attempt to expand a binary operator.  Make the expansion closer to the\n    actual machine, then just general_operand, which will allow 3 separate\n    memory references (one output, two input) in a single insn.  */\n@@ -11727,17 +11844,6 @@ ia32_multipass_dfa_lookahead (void)\n }\n \n \f\n-/* Implement the target hook targetm.vectorize.misaligned_mem_ok.  */\n-\n-static bool\n-ix86_misaligned_mem_ok (enum machine_mode mode)\n-{\n-  if (TARGET_MMX && VALID_MMX_REG_MODE (mode))\n-    return true;\n-  else\n-    return false;\n-}\n-\n /* Compute the alignment given to a constant that is being placed in memory.\n    EXP is the constant and ALIGN is the alignment that the object would\n    ordinarily have."}, {"sha": "17835c7e0df0b528608f95d1e4c631ec964b7c2b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c38573a8d0ada5f22281897f0ee5ecd818156e56/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c38573a8d0ada5f22281897f0ee5ecd818156e56", "patch": "@@ -19789,20 +19789,20 @@\n \n ;; 16 byte integral modes handled by SSE, minus TImode, which gets\n ;; special-cased for TARGET_64BIT.\n-(define_mode_macro SSEINT16 [V16QI V8HI V4SI V2DI])\n+(define_mode_macro SSEMODEI [V16QI V8HI V4SI V2DI])\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:SSEINT16 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:SSEINT16 1 \"nonimmediate_operand\" \"\"))]\n+  [(set (match_operand:SSEMODEI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SSEMODEI 1 \"nonimmediate_operand\" \"\"))]\n   \"TARGET_SSE\"\n {\n   ix86_expand_vector_move (<MODE>mode, operands);\n   DONE;\n })\n \n (define_insn \"*mov<mode>_internal\"\n-  [(set (match_operand:SSEINT16 0 \"nonimmediate_operand\" \"=x,x ,m\")\n-\t(match_operand:SSEINT16 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n+  [(set (match_operand:SSEMODEI 0 \"nonimmediate_operand\" \"=x,x ,m\")\n+\t(match_operand:SSEMODEI 1 \"vector_move_operand\"  \"C ,xm,x\"))]\n   \"TARGET_SSE\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n@@ -19842,21 +19842,21 @@\n \t       (const_string \"TI\")))])\n \n ;; 8 byte integral modes handled by MMX (and by extension, SSE)\n-(define_mode_macro MMXINT8 [V8QI V4HI V2SI])\n+(define_mode_macro MMXMODEI [V8QI V4HI V2SI])\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:MMXINT8 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:MMXINT8 1 \"nonimmediate_operand\" \"\"))]\n+  [(set (match_operand:MMXMODEI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:MMXMODEI 1 \"nonimmediate_operand\" \"\"))]\n   \"TARGET_MMX\"\n {\n   ix86_expand_vector_move (<MODE>mode, operands);\n   DONE;\n })\n \n (define_insn \"*mov<mode>_internal\"\n-  [(set (match_operand:MMXINT8 0 \"nonimmediate_operand\"\n+  [(set (match_operand:MMXMODEI 0 \"nonimmediate_operand\"\n \t\t\t\t\t\"=y,y ,m,!y,!*Y,*x,?*x,?m\")\n-\t(match_operand:MMXINT8 1 \"vector_move_operand\"\n+\t(match_operand:MMXMODEI 1 \"vector_move_operand\"\n \t\t\t\t\t\"C ,ym,y,*Y,y  ,C ,*xm,*x\"))]\n   \"TARGET_MMX\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n@@ -20103,6 +20103,30 @@\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n+;; All 16-byte vector modes handled by SSE\n+(define_mode_macro SSEMODE [V16QI V8HI V4SI V2DI V4SF V2DF])\n+\n+(define_expand \"movmisalign<mode>\"\n+  [(set (match_operand:SSEMODE 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SSEMODE 1 \"nonimmediate_operand\" \"\"))]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_move_misalign (<MODE>mode, operands);\n+  DONE;\n+})\n+\n+;; All 8-byte vector modes handled by MMX\n+(define_mode_macro MMXMODE [V8QI V4HI V2SI V2SF])\n+\n+(define_expand \"movmisalign<mode>\"\n+  [(set (match_operand:MMXMODE 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:MMXMODE 1 \"nonimmediate_operand\" \"\"))]\n+  \"TARGET_MMX\"\n+{\n+  ix86_expand_vector_move (<MODE>mode, operands);\n+  DONE;\n+})\n+\n ;; These two patterns are useful for specifying exactly whether to use\n ;; movaps or movups\n (define_expand \"sse_movaps\""}]}