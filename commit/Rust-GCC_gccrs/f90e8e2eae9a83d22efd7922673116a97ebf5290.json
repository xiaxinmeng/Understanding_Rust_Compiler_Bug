{"sha": "f90e8e2eae9a83d22efd7922673116a97ebf5290", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkwZThlMmVhZTlhODNkMjJlZmQ3OTIyNjczMTE2YTk3ZWJmNTI5MA==", "commit": {"author": {"name": "Artjoms Sinkarovs", "email": "artyom.shinkaroff@gmail.com", "date": "2011-10-03T15:13:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-03T15:13:26Z"}, "message": "Vector shuffling patch from Artem Shinkarov.\n\nFrom-SVN: r179462", "tree": {"sha": "f49377e311033773555fb0a2471ab04986fefafe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f49377e311033773555fb0a2471ab04986fefafe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f90e8e2eae9a83d22efd7922673116a97ebf5290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90e8e2eae9a83d22efd7922673116a97ebf5290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f90e8e2eae9a83d22efd7922673116a97ebf5290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f90e8e2eae9a83d22efd7922673116a97ebf5290/comments", "author": {"login": "ashinkarov", "id": 892232, "node_id": "MDQ6VXNlcjg5MjIzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/892232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ashinkarov", "html_url": "https://github.com/ashinkarov", "followers_url": "https://api.github.com/users/ashinkarov/followers", "following_url": "https://api.github.com/users/ashinkarov/following{/other_user}", "gists_url": "https://api.github.com/users/ashinkarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ashinkarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ashinkarov/subscriptions", "organizations_url": "https://api.github.com/users/ashinkarov/orgs", "repos_url": "https://api.github.com/users/ashinkarov/repos", "events_url": "https://api.github.com/users/ashinkarov/events{/privacy}", "received_events_url": "https://api.github.com/users/ashinkarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4a5b262e7bc64b22a34ada24b5d83b6c13dbe40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a5b262e7bc64b22a34ada24b5d83b6c13dbe40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a5b262e7bc64b22a34ada24b5d83b6c13dbe40"}], "stats": {"total": 1647, "additions": 1521, "deletions": 126}, "files": [{"sha": "028ce8e12b77a2b45743275bcfe210f63f2b5c55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -1,3 +1,51 @@\n+2011-10-03  Artem Shinkarov  <artyom.shinkaroff@gmail.com>\n+\n+\t* optabs.c (expand_vec_shuffle_expr_p): New function. Checks\n+\tif given expression can be expanded by the target.\n+\t(expand_vec_shuffle_expr): New function. Expand VEC_SHUFFLE_EXPR\n+\tusing target vector instructions.\n+\t* optabs.h: New optab vshuffle.\n+\t(expand_vec_shuffle_expr_p): New prototype.\n+\t(expand_vec_shuffle_expr): New prototype.\n+\t(vshuffle_optab): New optab.\n+\t* genopinit.c: Adjust to support vecshuffle.\n+\t* c-tree.h (c_build_vec_shuffle_expr): New prototype.\n+\t* expr.c (expand_expr_real_2): Adjust.\n+\t* c-typeck.c: (c_build_vec_shuffle_expr): Build a VEC_SHUFFLE_EXPR\n+\trecognizing the cases of two and three arguments.\n+\t(convert_arguments) (build_binary_op)\n+\t(scalar_to_vector) (build_array_ref): Spurious whitespace.\n+\t* gimplify.c (gimplify_exp): Adjusted to support VEC_SHUFFLE_EXPR.\n+\t* tree.def: New tree code VEC_SHUFFLE_EXPR.\n+\t* tree-inline.c (estimate_operator_cost): Recognize VEC_SHUFFLE_EXPR.\n+\t* tree-vect-generic.c (vector_element): New function. Returns an\n+\telement of the vector at the given position.\n+\t(lower_vec_shuffle): Checks if VEC_SHUFLLE_EXPR is supported\n+\tby the backend or expand an expression piecewise.\n+\t(expand_vector_operations_1): Adjusted.\n+\t(gate_expand_vector_operations_noop): New gate function.\n+\t* Makefile.in (tree-vect-generic.o): New include.\n+\t* gimple.c (get_gimple_rhs_num_ops): Adjust.\n+\t* tree-cfg.c (verify_gimple_assign_trenary): Verify VEC_SHUFFLE_EXPR.\n+\t* passes.c: Move veclower down.\n+\t* tree-pretty-print.c (dump_generic_node): Recognize\n+\tVEC_SHUFFLE_EXPR as valid expression.\n+\t* c-parser.c (c_parser_get_builtin_args): Helper function for the\n+\tbuiltins with variable number of arguments.\n+\t(c_parser_postfix_expression): Use a new helper function for\n+\tRID_CHOOSE_EXPR, RID_BUILTIN_COMPLEX and RID_BUILTIN_SHUFFLE.\n+\t* tree-ssa-operands: Adjust.\n+\t* c-family/c-common.c: New __builtin_shuffle keyword.\n+\t* c-family/c-common.h: New __builtin_shuffle keyword.\n+\t* gcc/doc/extend.texi: Adjust.\n+\n+\t* gcc/config/i386/sse.md: (sseshuffint) New mode_attr.  Correspondence\n+\tbetween the vector and the type of the mask when shuffling.\n+\t(vecshuffle<mode>): New expansion.\n+\t* gcc/config/i386/i386-protos.h (ix86_expand_vshuffle): New prototype.\n+\t* gcc/config/i386/i386.c (ix86_expand_vshuffle): New function.\n+\t(ix86_vectorize_builtin_vec_perm_ok): Adjust.\n+\n 2011-10-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/50587"}, {"sha": "baec5fec991fde2322e248d0182724489d2be45d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -3193,7 +3193,7 @@ tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(TM_H) $(TREE_FLOW_H) $(GIMPLE_H) tree-iterator.h $(TREE_PASS_H) \\\n     $(FLAGS_H) $(OPTABS_H) $(MACHMODE_H) $(EXPR_H) \\\n     langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \\\n-    coretypes.h insn-codes.h\n+    coretypes.h insn-codes.h $(DIAGNOSTIC_H)\n df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\"}, {"sha": "2c5a48916ff9e08011a764c58dccb033d8ca1191", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -425,6 +425,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, D_CONLY },\n   { \"__builtin_complex\", RID_BUILTIN_COMPLEX, D_CONLY },\n+  { \"__builtin_shuffle\", RID_BUILTIN_SHUFFLE, D_CONLY },\n   { \"__builtin_offsetof\", RID_OFFSETOF, 0 },\n   { \"__builtin_types_compatible_p\", RID_TYPES_COMPATIBLE_P, D_CONLY },\n   { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },"}, {"sha": "8996eefd22be8e6d59b8eed78f7602e0e7cc41cb", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -102,7 +102,7 @@ enum rid\n   /* C extensions */\n   RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n-  RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\n+  RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n   RID_FRACT, RID_ACCUM,\n "}, {"sha": "f94b8724c7221c3713fda3baa5bc7e3f931205a8", "filename": "gcc/c-parser.c", "status": "modified", "additions": 175, "deletions": 82, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -5989,6 +5989,46 @@ c_parser_alignof_expression (c_parser *parser)\n     }\n }\n \n+/* Helper function to read arguments of builtins which are interfaces\n+   for the middle-end nodes like COMPLEX_EXPR, VEC_SHUFFLE_EXPR and\n+   others.  The name of the builtin is passed using BNAME parameter.\n+   Function returns true if there were no errors while parsing and\n+   stores the arguments in EXPR_LIST.  List of original types can be\n+   obtained by passing non NULL value to ORIG_TYPES.  */\n+static bool\n+c_parser_get_builtin_args (c_parser *parser, const char *bname,\n+\t\t\t   VEC(tree,gc) **expr_list,\n+\t\t\t   VEC(tree,gc) **orig_types)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  *expr_list = NULL;\n+\n+  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n+    {\n+      error_at (loc, \"cannot take address of %qs\", bname);\n+      return false;\n+    }\n+\n+  c_parser_consume_token (parser);\n+\n+  if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n+    {\n+      c_parser_consume_token (parser);\n+      return true;\n+    }\n+    \n+  if (orig_types)\n+    *expr_list = c_parser_expr_list (parser, false, false, orig_types);\n+  else\n+    *expr_list = c_parser_expr_list (parser, false, false, NULL);\n+\n+  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n /* Parse a postfix expression (C90 6.3.1-6.3.2, C99 6.5.1-6.5.2).\n \n    postfix-expression:\n@@ -6027,6 +6067,10 @@ c_parser_alignof_expression (c_parser *parser)\n \t\t\t     assignment-expression )\n      __builtin_types_compatible_p ( type-name , type-name )\n      __builtin_complex ( assignment-expression , assignment-expression )\n+     __builtin_shuffle ( assignment-expression , assignment-expression )\n+     __builtin_shuffle ( assignment-expression , \n+\t\t\t assignment-expression ,\n+\t\t\t assignment-expression, )\n \n    offsetof-member-designator:\n      identifier\n@@ -6047,7 +6091,7 @@ c_parser_alignof_expression (c_parser *parser)\n static struct c_expr\n c_parser_postfix_expression (c_parser *parser)\n {\n-  struct c_expr expr, e1, e2, e3;\n+  struct c_expr expr, e1;\n   struct c_type_name *t1, *t2;\n   location_t loc = c_parser_peek_token (parser)->location;;\n   expr.original_code = ERROR_MARK;\n@@ -6333,45 +6377,55 @@ c_parser_postfix_expression (c_parser *parser)\n \t  }\n \t  break;\n \tcase RID_CHOOSE_EXPR:\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  loc = c_parser_peek_token (parser)->location;\n-\t  e1 = c_parser_expr_no_commas (parser, NULL);\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  e2 = c_parser_expr_no_commas (parser, NULL);\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  e3 = c_parser_expr_no_commas (parser, NULL);\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n \t  {\n-\t    tree c;\n+\t    VEC(tree,gc) *expr_list;\n+\t    VEC(tree,gc) *orig_types;\n+\t    tree e1value, e2value, e3value, c;\n \n-\t    c = e1.value;\n-\t    mark_exp_read (e2.value);\n-\t    mark_exp_read (e3.value);\n+\t    c_parser_consume_token (parser);\n+\t    if (!c_parser_get_builtin_args (parser,\n+\t\t\t\t\t    \"__builtin_choose_expr\",\n+\t\t\t\t\t    &expr_list, &orig_types))\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\n+\t    if (VEC_length (tree, expr_list) != 3)\n+\t      {\n+\t\terror_at (loc, \"wrong number of arguments to \"\n+\t\t\t       \"%<__builtin_choose_expr%>\");\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    e1value = VEC_index (tree, expr_list, 0);\n+\t    e2value = VEC_index (tree, expr_list, 1);\n+\t    e3value = VEC_index (tree, expr_list, 2);\n+\n+\t    c = e1value;\n+\t    mark_exp_read (e2value);\n+\t    mark_exp_read (e3value);\n \t    if (TREE_CODE (c) != INTEGER_CST\n \t\t|| !INTEGRAL_TYPE_P (TREE_TYPE (c)))\n \t      error_at (loc,\n \t\t\t\"first argument to %<__builtin_choose_expr%> not\"\n \t\t\t\" a constant\");\n \t    constant_expression_warning (c);\n-\t    expr = integer_zerop (c) ? e3 : e2;\n+\t    \n+\t    if (integer_zerop (c))\n+\t      {\n+\t\texpr.value = e3value;\n+\t\texpr.original_type = VEC_index (tree, orig_types, 2);\n+\t      }\n+\t    else\n+\t      {\n+\t\texpr.value = e2value;\n+\t\texpr.original_type = VEC_index (tree, orig_types, 1);\n+\t      }\n+\n+\t    break;\n \t  }\n-\t  break;\n \tcase RID_TYPES_COMPATIBLE_P:\n \t  c_parser_consume_token (parser);\n \t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -6410,57 +6464,96 @@ c_parser_postfix_expression (c_parser *parser)\n \t  }\n \t  break;\n \tcase RID_BUILTIN_COMPLEX:\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  loc = c_parser_peek_token (parser)->location;\n-\t  e1 = c_parser_expr_no_commas (parser, NULL);\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  e2 = c_parser_expr_no_commas (parser, NULL);\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n-\t  mark_exp_read (e1.value);\n-\t  if (TREE_CODE (e1.value) == EXCESS_PRECISION_EXPR)\n-\t    e1.value = convert (TREE_TYPE (e1.value),\n-\t\t\t\tTREE_OPERAND (e1.value, 0));\n-\t  mark_exp_read (e2.value);\n-\t  if (TREE_CODE (e2.value) == EXCESS_PRECISION_EXPR)\n-\t    e2.value = convert (TREE_TYPE (e2.value),\n-\t\t\t\tTREE_OPERAND (e2.value, 0));\n-\t  if (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (e1.value))\n-\t      || DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e1.value))\n-\t      || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (e2.value))\n-\t      || DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e2.value)))\n-\t    {\n-\t      error_at (loc, \"%<__builtin_complex%> operand \"\n-\t\t\t\"not of real binary floating-point type\");\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (e1.value))\n-\t      != TYPE_MAIN_VARIANT (TREE_TYPE (e2.value)))\n-\t    {\n-\t      error_at (loc,\n-\t\t\t\"%<__builtin_complex%> operands of different types\");\n-\t      expr.value = error_mark_node;\n-\t      break;\n-\t    }\n-\t  if (!flag_isoc99)\n-\t    pedwarn (loc, OPT_pedantic,\n-\t\t     \"ISO C90 does not support complex types\");\n-\t  expr.value = build2 (COMPLEX_EXPR,\n-\t\t\t       build_complex_type (TYPE_MAIN_VARIANT\n-\t\t\t\t\t\t   (TREE_TYPE (e1.value))),\n-\t\t\t       e1.value, e2.value);\n-\t  break;\n+\t  { \n+\t    VEC(tree,gc) *expr_list;\n+\t    tree e1value, e2value;\n+\t    \n+\t    c_parser_consume_token (parser);\n+\t    if (!c_parser_get_builtin_args (parser,\n+\t\t\t\t\t    \"__builtin_complex\",\n+\t\t\t\t\t    &expr_list, NULL))\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\n+\t    if (VEC_length (tree, expr_list) != 2)\n+\t      {\n+\t\terror_at (loc, \"wrong number of arguments to \"\n+\t\t\t       \"%<__builtin_complex%>\");\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    \n+\t    e1value = VEC_index (tree, expr_list, 0);\n+\t    e2value = VEC_index (tree, expr_list, 1);\n+\n+\t    mark_exp_read (e1value);\n+\t    if (TREE_CODE (e1value) == EXCESS_PRECISION_EXPR)\n+\t      e1value = convert (TREE_TYPE (e1value),\n+\t\t\t\t TREE_OPERAND (e1value, 0));\n+\t    mark_exp_read (e2value);\n+\t    if (TREE_CODE (e2value) == EXCESS_PRECISION_EXPR)\n+\t      e2value = convert (TREE_TYPE (e2value),\n+\t\t\t\t TREE_OPERAND (e2value, 0));\n+\t    if (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (e1value))\n+\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e1value))\n+\t\t|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (e2value))\n+\t\t|| DECIMAL_FLOAT_TYPE_P (TREE_TYPE (e2value)))\n+\t      {\n+\t\terror_at (loc, \"%<__builtin_complex%> operand \"\n+\t\t\t  \"not of real binary floating-point type\");\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    if (TYPE_MAIN_VARIANT (TREE_TYPE (e1value))\n+\t\t!= TYPE_MAIN_VARIANT (TREE_TYPE (e2value)))\n+\t      {\n+\t\terror_at (loc,\n+\t\t\t  \"%<__builtin_complex%> operands of different types\");\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    if (!flag_isoc99)\n+\t      pedwarn (loc, OPT_pedantic,\n+\t\t       \"ISO C90 does not support complex types\");\n+\t    expr.value = build2 (COMPLEX_EXPR,\n+\t\t\t\t build_complex_type (TYPE_MAIN_VARIANT\n+\t\t\t\t\t\t     (TREE_TYPE (e1value))),\n+\t\t\t\t e1value, e2value);\n+\t    break;\n+\t  }\n+\tcase RID_BUILTIN_SHUFFLE:\n+\t  {\n+\t    VEC(tree,gc) *expr_list;\n+\t    \n+\t    c_parser_consume_token (parser);\n+\t    if (!c_parser_get_builtin_args (parser,\n+\t\t\t\t\t    \"__builtin_shuffle\",\n+\t\t\t\t\t    &expr_list, NULL))\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\n+\t    if (VEC_length (tree, expr_list) == 2)\n+\t      expr.value = c_build_vec_shuffle_expr\n+\t\t\t\t(loc, VEC_index (tree, expr_list, 0),\n+\t\t\t\t NULL_TREE,\n+\t\t\t\t VEC_index (tree, expr_list, 1));\n+\t    else if (VEC_length (tree, expr_list) == 3)\n+\t      expr.value = c_build_vec_shuffle_expr\n+\t\t\t\t(loc, VEC_index (tree, expr_list, 0),\n+\t\t\t\t VEC_index (tree, expr_list, 1),\n+\t\t\t\t VEC_index (tree, expr_list, 2));\n+\t    else\n+\t      {\n+\t\terror_at (loc, \"wrong number of arguments to \"\n+\t\t\t       \"%<__builtin_shuffle%>\");\n+\t\texpr.value = error_mark_node;\n+\t      }\n+\t    break;\n+\t  }\n \tcase RID_AT_SELECTOR:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_consume_token (parser);"}, {"sha": "1948507f8acbfbae2a96da74a7ceee9303169d4e", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -579,6 +579,7 @@ extern tree c_begin_omp_task (void);\n extern tree c_finish_omp_task (location_t, tree, tree);\n extern tree c_finish_omp_clauses (tree);\n extern tree c_build_va_arg (location_t, tree, tree);\n+extern tree c_build_vec_shuffle_expr (location_t, tree, tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "96ef4a3a660dfced293c9770f9a7d879f75e4953", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 113, "deletions": 20, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -2307,7 +2307,7 @@ build_array_ref (location_t loc, tree array, tree index)\n       if (TREE_CODE (TREE_TYPE (index)) != ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (index)) != POINTER_TYPE)\n \t{\n-          error_at (loc, \n+          error_at (loc,\n             \"subscripted value is neither array nor pointer nor vector\");\n \n \t  return error_mark_node;\n@@ -2339,20 +2339,20 @@ build_array_ref (location_t loc, tree array, tree index)\n   index = default_conversion (index);\n \n   gcc_assert (TREE_CODE (TREE_TYPE (index)) == INTEGER_TYPE);\n-  \n-  /* For vector[index], convert the vector to a \n+\n+  /* For vector[index], convert the vector to a\n      pointer of the underlying type.  */\n   if (TREE_CODE (TREE_TYPE (array)) == VECTOR_TYPE)\n     {\n       tree type = TREE_TYPE (array);\n       tree type1;\n \n       if (TREE_CODE (index) == INTEGER_CST)\n-        if (!host_integerp (index, 1) \n-            || ((unsigned HOST_WIDE_INT) tree_low_cst (index, 1) \n+        if (!host_integerp (index, 1)\n+            || ((unsigned HOST_WIDE_INT) tree_low_cst (index, 1)\n                >= TYPE_VECTOR_SUBPARTS (TREE_TYPE (array))))\n           warning_at (loc, OPT_Warray_bounds, \"index value is out of bound\");\n-     \n+\n       c_common_mark_addressable_vec (array);\n       type = build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));\n       type = build_pointer_type (type);\n@@ -2845,6 +2845,99 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n     }\n   return require_complete_type (result);\n }\n+\n+/* Build a VEC_SHUFFLE_EXPR if V0, V1 and MASK are not error_mark_nodes\n+   and have vector types, V0 has the same type as V1, and the number of\n+   elements of V0, V1, MASK is the same.\n+\n+   In case V1 is a NULL_TREE it is assumed that __builtin_shuffle was\n+   called with two arguments.  In this case implementation passes the\n+   first argument twice in order to share the same tree code.  This fact\n+   could enable the mask-values being twice the vector length.  This is\n+   an implementation accident and this semantics is not guaranteed to\n+   the user.  */\n+tree\n+c_build_vec_shuffle_expr (location_t loc, tree v0, tree v1, tree mask)\n+{\n+  tree vec_shuffle, tmp;\n+  bool wrap = true;\n+  bool maybe_const = false;\n+  bool two_arguments;\n+\n+  if (v1 == NULL_TREE)\n+    {\n+      two_arguments = true;\n+      v1 = v0;\n+    }\n+\n+  if (v0 == error_mark_node || v1 == error_mark_node\n+      || mask == error_mark_node)\n+    return error_mark_node;\n+\n+  if (TREE_CODE (TREE_TYPE (mask)) != VECTOR_TYPE\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (mask))) != INTEGER_TYPE)\n+    {\n+      error_at (loc, \"__builtin_shuffle last argument must \"\n+\t\t     \"be an integer vector\");\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (TREE_TYPE (v0)) != VECTOR_TYPE\n+      || TREE_CODE (TREE_TYPE (v1)) != VECTOR_TYPE)\n+    {\n+      error_at (loc, \"__builtin_shuffle arguments must be vectors\");\n+      return error_mark_node;\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (v0)) != TYPE_MAIN_VARIANT (TREE_TYPE (v1)))\n+    {\n+      error_at (loc, \"__builtin_shuffle argument vectors must be of \"\n+\t\t     \"the same type\");\n+      return error_mark_node;\n+    }\n+\n+  if (TYPE_VECTOR_SUBPARTS (TREE_TYPE (v0))\n+      != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask))\n+      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (v1))\n+\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask)))\n+    {\n+      error_at (loc, \"__builtin_shuffle number of elements of the \"\n+\t\t     \"argument vector(s) and the mask vector should \"\n+\t\t     \"be the same\");\n+      return error_mark_node;\n+    }\n+\n+  if (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (v0))))\n+      != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (mask)))))\n+    {\n+      error_at (loc, \"__builtin_shuffle argument vector(s) inner type \"\n+\t\t     \"must have the same size as inner type of the mask\");\n+      return error_mark_node;\n+    }\n+\n+  /* Avoid C_MAYBE_CONST_EXPRs inside VEC_SHUFFLE_EXPR.  */\n+  tmp = c_fully_fold (v0, false, &maybe_const);\n+  v0 = save_expr (tmp);\n+  wrap &= maybe_const;\n+\n+  if (!two_arguments)\n+    {\n+      v1 = c_fully_fold (v1, false, &maybe_const);\n+      wrap &= maybe_const;\n+    }\n+  else\n+    v1 = v0;\n+\n+  mask = c_fully_fold (mask, false, &maybe_const);\n+  wrap &= maybe_const;\n+\n+  vec_shuffle = build3 (VEC_SHUFFLE_EXPR, TREE_TYPE (v0), v0, v1, mask);\n+\n+  if (!wrap)\n+    vec_shuffle = c_wrap_maybe_const (vec_shuffle, true);\n+\n+  return vec_shuffle;\n+}\n \f\n /* Convert the argument expressions in the vector VALUES\n    to the types in the list TYPELIST.\n@@ -3167,7 +3260,7 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n-      error_at (input_location, \n+      error_at (input_location,\n \t\t\"too few arguments to function %qE\", function);\n       if (fundecl && !DECL_BUILT_IN (fundecl))\n \tinform (DECL_SOURCE_LOCATION (fundecl), \"declared here\");\n@@ -3566,7 +3659,7 @@ build_unary_op (location_t location,\n \n       /* Complain about anything that is not a true lvalue.  In\n \t Objective-C, skip this check for property_refs.  */\n-      if (!objc_is_property_ref (arg) \n+      if (!objc_is_property_ref (arg)\n \t  && !lvalue_or_else (location,\n \t\t\t      arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t     || code == POSTINCREMENT_EXPR)\n@@ -3683,7 +3776,7 @@ build_unary_op (location_t location,\n \t   need to ask Objective-C to build the increment or decrement\n \t   expression for it.  */\n \tif (objc_is_property_ref (arg))\n-\t  return objc_build_incr_expr_for_property_ref (location, code, \n+\t  return objc_build_incr_expr_for_property_ref (location, code,\n \t\t\t\t\t\t\targ, inc);\n \n \t/* Report a read-only lvalue.  */\n@@ -5926,7 +6019,7 @@ void\n pedwarn_init (location_t location, int opt, const char *gmsgid)\n {\n   char *ofwhat;\n-  \n+\n   /* The gmsgid may be a format string with %< and %>. */\n   pedwarn (location, opt, gmsgid);\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n@@ -9344,8 +9437,8 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n   tree type1 = TREE_TYPE (op1);\n   bool integer_only_op = false;\n   enum stv_conv ret = stv_firstarg;\n-  \n-  gcc_assert (TREE_CODE (type0) == VECTOR_TYPE \n+\n+  gcc_assert (TREE_CODE (type0) == VECTOR_TYPE\n \t      || TREE_CODE (type1) == VECTOR_TYPE);\n   switch (code)\n     {\n@@ -9370,7 +9463,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n       case BIT_AND_EXPR:\n \tinteger_only_op = true;\n \t/* ... fall through ...  */\n-      \n+\n       case PLUS_EXPR:\n       case MINUS_EXPR:\n       case MULT_EXPR:\n@@ -9387,7 +9480,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n \t  }\n \n \tif (TREE_CODE (type0) == INTEGER_TYPE\n-\t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE) \n+\t    && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)\n \t  {\n \t    if (unsafe_conversion_p (TREE_TYPE (type1), op0, false))\n \t      {\n@@ -9399,7 +9492,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n \t  }\n \telse if (!integer_only_op\n \t\t    /* Allow integer --> real conversion if safe.  */\n-\t\t && (TREE_CODE (type0) == REAL_TYPE \n+\t\t && (TREE_CODE (type0) == REAL_TYPE\n \t\t     || TREE_CODE (type0) == INTEGER_TYPE)\n \t\t && SCALAR_FLOAT_TYPE_P (TREE_TYPE (type1)))\n \t  {\n@@ -9414,7 +9507,7 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1)\n       default:\n \tbreak;\n     }\n- \n+\n   return stv_nothing;\n }\n \f\n@@ -9529,8 +9622,8 @@ build_binary_op (location_t location, enum tree_code code,\n     int_const = int_const_or_overflow = false;\n \n   /* Do not apply default conversion in mixed vector/scalar expression.  */\n-  if (convert_p \n-      && !((TREE_CODE (TREE_TYPE (op0)) == VECTOR_TYPE) \n+  if (convert_p\n+      && !((TREE_CODE (TREE_TYPE (op0)) == VECTOR_TYPE)\n \t   != (TREE_CODE (TREE_TYPE (op1)) == VECTOR_TYPE)))\n     {\n       op0 = default_conversion (op0);\n@@ -9608,7 +9701,7 @@ build_binary_op (location_t location, enum tree_code code,\n   if ((code0 == VECTOR_TYPE) != (code1 == VECTOR_TYPE))\n     {\n       enum stv_conv convert_flag = scalar_to_vector (location, code, op0, op1);\n-      \n+\n       switch (convert_flag)\n \t{\n \t  case stv_error:\n@@ -9974,7 +10067,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t    {\n \t      if (code == EQ_EXPR)\n \t\twarning_at (location,\n-\t\t\t    OPT_Waddress, \n+\t\t\t    OPT_Waddress,\n \t\t\t    \"the comparison will always evaluate as %<false%> \"\n \t\t\t    \"for the address of %qD will never be NULL\",\n \t\t\t    TREE_OPERAND (op1, 0));"}, {"sha": "99327ed496fd27566a8e2831aee99ca6d0efa2a3", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -123,6 +123,7 @@ extern bool ix86_expand_int_movcc (rtx[]);\n extern bool ix86_expand_fp_movcc (rtx[]);\n extern bool ix86_expand_fp_vcond (rtx[]);\n extern bool ix86_expand_int_vcond (rtx[]);\n+extern bool ix86_expand_vshuffle (rtx[]);\n extern void ix86_expand_sse_unpack (rtx[], bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n extern rtx ix86_expand_call (rtx, rtx, rtx, rtx, rtx, bool);"}, {"sha": "9b079afe8e62c60c5c145de012fb186147261f17", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 149, "deletions": 5, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -19254,6 +19254,147 @@ ix86_expand_int_vcond (rtx operands[])\n   return true;\n }\n \n+bool\n+ix86_expand_vshuffle (rtx operands[])\n+{\n+  rtx target = operands[0];\n+  rtx op0 = operands[1];\n+  rtx op1 = operands[2];\n+  rtx mask = operands[3];\n+  rtx new_mask, vt, t1, t2, w_vector;\n+  enum machine_mode mode = GET_MODE (op0);\n+  enum machine_mode maskmode = GET_MODE (mask);\n+  enum machine_mode maskinner = GET_MODE_INNER (mode);\n+  rtx vec[16];\n+  int w, i, j;\n+  bool one_operand_shuffle = op0 == op1;\n+\n+  gcc_assert ((TARGET_SSSE3 || TARGET_AVX) && GET_MODE_BITSIZE (mode) == 128);\n+\n+  /* Number of elements in the vector.  */\n+  w = GET_MODE_BITSIZE (maskmode) / GET_MODE_BITSIZE (maskinner);\n+\n+  /* generate w_vector = {w, w, ...}  */\n+  for (i = 0; i < w; i++)\n+    vec[i] = GEN_INT (w);\n+  w_vector = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+\n+  /* mask = mask & {w-1, w-1, w-1,...} */\n+  for (i = 0; i < w; i++)\n+    vec[i] = GEN_INT (w - 1);\n+\n+  vt = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (w, vec));\n+  new_mask = expand_simple_binop (maskmode, AND, mask, vt,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  /* If the original vector mode is V16QImode, we can just\n+     use pshufb directly.  */\n+  if (mode == V16QImode && one_operand_shuffle)\n+    {\n+      t1 = gen_reg_rtx (V16QImode);\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n+      emit_insn (gen_rtx_SET (VOIDmode, target, t1));\n+      return true;\n+    }\n+  else if (mode == V16QImode)\n+    {\n+      rtx xops[6];\n+\n+      t1 = gen_reg_rtx (V16QImode);\n+      t2 = gen_reg_rtx (V16QImode);\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t2, op1, new_mask));\n+\n+      /* mask = mask & {w, w, ...}  */\n+      mask = expand_simple_binop (V16QImode, AND, mask, w_vector,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+      xops[0] = target;\n+      xops[1] = operands[1];\n+      xops[2] = operands[2];\n+      xops[3] = gen_rtx_EQ (mode, mask, w_vector);\n+      xops[4] = t1;\n+      xops[5] = t2;\n+\n+      return ix86_expand_int_vcond (xops);\n+    }\n+\n+  /* mask = mask * {w, w, ...}  */\n+  new_mask = expand_simple_binop (maskmode, MULT, new_mask, w_vector,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  /* Convert mask to vector of chars.  */\n+  new_mask = simplify_gen_subreg (V16QImode, new_mask, maskmode, 0);\n+  new_mask = force_reg (V16QImode, new_mask);\n+\n+  /* Build a helper mask wich we will use in pshufb\n+     (v4si) --> {0,0,0,0, 4,4,4,4, 8,8,8,8, 12,12,12,12}\n+     (v8hi) --> {0,0, 2,2, 4,4, 6,6, ...}\n+     ...  */\n+  for (i = 0; i < w; i++)\n+    for (j = 0; j < 16/w; j++)\n+      vec[i*w+j] = GEN_INT (i*16/w);\n+  vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n+  vt = force_reg (V16QImode, vt);\n+\n+  t1 = gen_reg_rtx (V16QImode);\n+  emit_insn (gen_ssse3_pshufbv16qi3 (t1, new_mask, vt));\n+  new_mask = t1;\n+\n+  /* Convert it into the byte positions by doing\n+     new_mask = new_mask + {0,1,..,16/w, 0,1,..,16/w, ...}  */\n+  for (i = 0; i < w; i++)\n+    for (j = 0; j < 16/w; j++)\n+      vec[i*w+j] = GEN_INT (j);\n+\n+  vt = gen_rtx_CONST_VECTOR (V16QImode, gen_rtvec_v (16, vec));\n+  new_mask = expand_simple_binop (V16QImode, PLUS, new_mask, vt,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+\n+  t1 = gen_reg_rtx (V16QImode);\n+\n+  /* Convert OP0 to vector of chars.  */\n+  op0 = simplify_gen_subreg (V16QImode, op0, mode, 0);\n+  op0 = force_reg (V16QImode, op0);\n+  emit_insn (gen_ssse3_pshufbv16qi3 (t1, op0, new_mask));\n+\n+  if (one_operand_shuffle)\n+    {\n+      /* Convert it back from vector of chars to the original mode.  */\n+      t1 = simplify_gen_subreg (mode, t1, V16QImode, 0);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, t1));\n+      return true;\n+    }\n+  else\n+    {\n+      rtx xops[6];\n+\n+      t2 = gen_reg_rtx (V16QImode);\n+\n+      /* Convert OP1 to vector of chars.  */\n+      op1 = simplify_gen_subreg (V16QImode, op1, mode, 0);\n+      op1 = force_reg (V16QImode, op1);\n+      emit_insn (gen_ssse3_pshufbv16qi3 (t1, op1, new_mask));\n+\n+      /* mask = mask & {w, w, ...}  */\n+      mask = expand_simple_binop (V16QImode, AND, mask, w_vector,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+\n+      t1 = simplify_gen_subreg (mode, t1, V16QImode, 0);\n+      t2 = simplify_gen_subreg (mode, t2, V16QImode, 0);\n+\n+      xops[0] = target;\n+      xops[1] = operands[1];\n+      xops[2] = operands[2];\n+      xops[3] = gen_rtx_EQ (mode, mask, w_vector);\n+      xops[4] = t1;\n+      xops[5] = t2;\n+\n+      return ix86_expand_int_vcond (xops);\n+    }\n+\n+  return false;\n+}\n+\n /* Unpack OP[1] into the next wider integer vector type.  UNSIGNED_P is\n    true if we should do zero extension, else sign extension.  HIGH_P is\n    true if we want the N/2 high elements, else the low elements.  */\n@@ -31472,6 +31613,9 @@ struct expand_vec_perm_d\n \n static bool expand_vec_perm_1 (struct expand_vec_perm_d *d);\n static bool expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d);\n+static int extract_vec_perm_cst (struct expand_vec_perm_d *, tree);\n+static bool ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask);\n+\n \n /* Get a vector mode of the same size as the original but with elements\n    twice as wide.  This is only guaranteed to apply to integral vectors.  */\n@@ -33103,7 +33247,7 @@ void ix86_emit_i387_round (rtx op0, rtx op1)\n   res = gen_reg_rtx (outmode);\n \n   half = CONST_DOUBLE_FROM_REAL_VALUE (dconsthalf, inmode);\n-  \n+\n   /* round(a) = sgn(a) * floor(fabs(a) + 0.5) */\n \n   /* scratch = fxam(op1) */\n@@ -35262,10 +35406,10 @@ ix86_vectorize_builtin_vec_perm_ok (tree vec_type, tree mask)\n \n   vec_mask = extract_vec_perm_cst (&d, mask);\n \n-  /* This hook is cannot be called in response to something that the\n-     user does (unlike the builtin expander) so we shouldn't ever see\n-     an error generated from the extract.  */\n-  gcc_assert (vec_mask > 0 && vec_mask <= 3);\n+  /* Check whether the mask can be applied to the vector type.  */\n+  if (vec_mask < 0 || vec_mask > 3)\n+    return false;\n+\n   one_vec = (vec_mask != 3);\n \n   /* Implementable with shufps or pshufd.  */"}, {"sha": "251cddeeb570f2aadf97f83626e796ca01edbe56", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -230,6 +230,12 @@\n    (V4SF \"V4SF\") (V2DF \"V2DF\")\n    (TI \"TI\")])\n \n+;; All 128bit vector modes\n+(define_mode_attr sseshuffint\n+  [(V16QI \"V16QI\") (V8HI \"V8HI\")\n+   (V4SI \"V4SI\")  (V2DI \"V2DI\")\n+   (V4SF \"V4SI\") (V2DF \"V2DI\")])\n+\n ;; Mapping of vector float modes to an integer mode of the same size\n (define_mode_attr sseintvecmode\n   [(V8SF \"V8SI\") (V4DF \"V4DI\")\n@@ -6216,6 +6222,19 @@\n   DONE;\n })\n \n+(define_expand \"vshuffle<mode>\"\n+  [(match_operand:V_128 0 \"register_operand\" \"\")\n+   (match_operand:V_128 1 \"register_operand\" \"\")\n+   (match_operand:V_128 2 \"register_operand\" \"\")\n+   (match_operand:<sseshuffint> 3 \"register_operand\" \"\")]\n+  \"TARGET_SSSE3 || TARGET_AVX\"\n+{\n+  bool ok = ix86_expand_vshuffle (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel bitwise logical operations"}, {"sha": "20ee772d753ce09560f85e39ced9a3867974c414", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -6584,6 +6584,32 @@ c = a >  b;     /* The result would be @{0, 0,-1, 0@}  */\n c = a == b;     /* The result would be @{0,-1, 0,-1@}  */\n @end smallexample\n \n+Vector shuffling is available using functions\n+@code{__builtin_shuffle (vec, mask)} and\n+@code{__builtin_shuffle (vec0, vec1, mask)}. Both functions construct\n+a permutation of elements from one or two vectors and return a vector\n+of the same type as input vector(s). The mask is a vector of\n+integer-typed elements. The size of each element of the mask must be\n+the same as the size of each input vector element. The number of\n+elements in input vector(s) and mask must be the same.\n+\n+The elements of the input vectors are numbered from left to right across\n+one or both of the vectors. Each element in the mask specifies a number\n+of element from the input vector(s). Consider the following example.\n+\n+@smallexample\n+typedef int v4si __attribute__ ((vector_size (16)));\n+\n+v4si a = @{1,2,3,4@};\n+v4si b = @{5,6,7,8@};\n+v4si mask1 = @{0,1,1,3@};\n+v4si mask2 = @{0,4,2,5@};\n+v4si res;\n+\n+res = __builtin_shuffle (a, mask1);       /* res is @{1,2,2,4@}  */\n+res = __builtin_shuffle (a, b, mask2);    /* res is @{1,5,3,6@}  */\n+@end smallexample\n+\n You can declare variables and use them in function calls and returns, as\n well as in assignments and some casts.  You can specify a vector type as\n a return type for a function.  Vector types can also be used as function"}, {"sha": "d1807b0acc1fabc1dd078cba1723a48a169296a1", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -8605,6 +8605,10 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n     case VEC_PACK_FIX_TRUNC_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (treeop0));\n       goto binop;\n+    \n+    case VEC_SHUFFLE_EXPR:\n+      target = expand_vec_shuffle_expr (type, treeop0, treeop1, treeop2, target);\n+      return target;\n \n     case DOT_PROD_EXPR:\n       {\n@@ -10308,6 +10312,17 @@ do_store_flag (sepops ops, rtx target, enum machine_mode mode)\n \n   STRIP_NOPS (arg0);\n   STRIP_NOPS (arg1);\n+  \n+  /* For vector typed comparisons emit code to generate the desired\n+     all-ones or all-zeros mask.  Conveniently use the VEC_COND_EXPR\n+     expander for this.  */\n+  if (TREE_CODE (ops->type) == VECTOR_TYPE)\n+    {\n+      tree ifexp = build2 (ops->code, ops->type, arg0, arg1);\n+      tree if_true = constant_boolean_node (true, ops->type);\n+      tree if_false = constant_boolean_node (false, ops->type);\n+      return expand_vec_cond_expr (ops->type, ifexp, if_true, if_false, target);\n+    }\n \n   /* For vector typed comparisons emit code to generate the desired\n      all-ones or all-zeros mask.  Conveniently use the VEC_COND_EXPR"}, {"sha": "4672075cd31c9c2aa5190ec4e11f0aa839ab88bd", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -253,6 +253,7 @@ static const char * const optabs[] =\n   \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n   \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\",\n   \"set_optab_handler (vec_realign_load_optab, $A, CODE_FOR_$(vec_realign_load_$a$))\",\n+  \"set_direct_optab_handler (vshuffle_optab, $A, CODE_FOR_$(vshuffle$a$))\",\n   \"set_convert_optab_handler (vcond_optab, $A, $B, CODE_FOR_$(vcond$a$b$))\",\n   \"set_convert_optab_handler (vcondu_optab, $A, $B, CODE_FOR_$(vcondu$a$b$))\",\n   \"set_optab_handler (ssum_widen_optab, $A, CODE_FOR_$(widen_ssum$I$a3$))\","}, {"sha": "2dbdebe339e8ea3e96bcfdea2c839d0e48d3ff6b", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -417,6 +417,16 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n       pp_string (buffer, \">\");\n       break;\n+    \n+    case VEC_SHUFFLE_EXPR:\n+      pp_string (buffer, \"VEC_SHUFFLE_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      pp_string (buffer, \">\");\n+      break;\n \n     case REALIGN_LOAD_EXPR:\n       pp_string (buffer, \"REALIGN_LOAD <\");"}, {"sha": "e4dfd467d755a3572ace88d4d53cfc7c0ec47e83", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -2638,6 +2638,7 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == DOT_PROD_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == REALIGN_LOAD_EXPR\t\t\t\t\t    \\\n       || (SYM) == VEC_COND_EXPR\t\t\t\t\t\t    \\\n+      || (SYM) == VEC_SHUFFLE_EXPR                                          \\\n       || (SYM) == FMA_EXPR) ? GIMPLE_TERNARY_RHS\t\t\t    \\\n    : ((SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n       || (SYM) == OBJ_TYPE_REF\t\t\t\t\t\t    \\"}, {"sha": "4c15f3a7c456745347ec45251632b6c25e3ee147", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -7286,6 +7286,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  }\n \n \tcase FMA_EXPR:\n+\tcase VEC_SHUFFLE_EXPR:\n \t  /* Classified as tcc_expression.  */\n \t  goto expr_3;\n "}, {"sha": "3a52fb0c07cef38143b10d3f04da890b0271ebce", "filename": "gcc/optabs.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -6620,6 +6620,94 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n   return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);\n }\n \n+/* Return true if VEC_SHUFFLE_EXPR can be expanded using SIMD extensions\n+   of the CPU.  */\n+bool\n+expand_vec_shuffle_expr_p (enum machine_mode mode, tree v0, tree v1, tree mask)\n+{\n+  int v0_mode_s = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (v0))));\n+  int mask_mode_s = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (mask))));\n+\n+  if (TREE_CODE (mask) == VECTOR_CST\n+      && targetm.vectorize.builtin_vec_perm_ok (TREE_TYPE (v0), mask))\n+    return true;\n+\n+  if (v0_mode_s != mask_mode_s\n+      || TYPE_VECTOR_SUBPARTS (TREE_TYPE (v0))\n+\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask))\n+      || TYPE_VECTOR_SUBPARTS (TREE_TYPE (v1))\n+\t != TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask)))\n+    return false;\n+\n+  return direct_optab_handler (vshuffle_optab, mode) != CODE_FOR_nothing;\n+}\n+\n+/* Generate instructions for VEC_COND_EXPR given its type and three\n+   operands.  */\n+rtx\n+expand_vec_shuffle_expr (tree type, tree v0, tree v1, tree mask, rtx target)\n+{\n+  struct expand_operand ops[4];\n+  enum insn_code icode;\n+  enum machine_mode mode = TYPE_MODE (type);\n+  rtx rtx_v0, rtx_mask;\n+\n+  gcc_assert (expand_vec_shuffle_expr_p (mode, v0, v1, mask));\n+\n+  if (TREE_CODE (mask) == VECTOR_CST)\n+    {\n+      tree m_type, call;\n+      tree fn = targetm.vectorize.builtin_vec_perm (TREE_TYPE (v0), &m_type);\n+\n+      if (!fn)\n+\tgoto vshuffle;\n+\n+      if (m_type != TREE_TYPE (TREE_TYPE (mask)))\n+\t{\n+\t  int units = TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask));\n+\t  tree cvt = build_vector_type (m_type, units);\n+\t  mask = fold_convert (cvt, mask);\n+\t}\n+\n+      call = fold_build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n+      call = build_call_nary (type, call, 3, v0, v1, mask);\n+\n+      return expand_expr_real_1 (call, target, VOIDmode, EXPAND_NORMAL, NULL);\n+    }\n+\n+vshuffle:\n+  icode = direct_optab_handler (vshuffle_optab, mode);\n+\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  rtx_mask = expand_normal (mask);\n+\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[3], rtx_mask, mode);\n+\n+  if (operand_equal_p (v0, v1, 0))\n+    {\n+      rtx_v0 = expand_normal (v0);\n+      if (!insn_operand_matches(icode, 1, rtx_v0))\n+        rtx_v0 = force_reg (mode, rtx_v0);\n+\n+      gcc_checking_assert(insn_operand_matches(icode, 2, rtx_v0));\n+\n+      create_fixed_operand (&ops[1], rtx_v0);\n+      create_fixed_operand (&ops[2], rtx_v0);\n+    }\n+  else\n+    {\n+      create_input_operand (&ops[1], expand_normal (v0), mode);\n+      create_input_operand (&ops[2], expand_normal (v1), mode);\n+    }\n+\n+  expand_insn (icode, 4, ops);\n+  return ops[0].value;\n+}\n+\n+\n /* Return insn code for a conditional operator with a comparison in\n    mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n "}, {"sha": "5d5593bb09546a95e56a6ed9b109f55a59a0e886", "filename": "gcc/optabs.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -617,6 +617,7 @@ enum convert_optab_index\n #define vec_store_lanes_optab (&convert_optab_table[COI_vec_store_lanes])\n #define vcond_optab (&convert_optab_table[(int) COI_vcond])\n #define vcondu_optab (&convert_optab_table[(int) COI_vcondu])\n+#define vshuffle_optab (&direct_optab_table[(int) DOI_vshuffle])\n \n /* Contains the optab used for each rtx code.  */\n extern optab code_to_optab[NUM_RTX_CODE + 1];\n@@ -638,6 +639,9 @@ enum direct_optab_index\n   DOI_reload_in,\n   DOI_reload_out,\n \n+  /* Vector shuffling.  */\n+  DOI_vshuffle,\n+\n   /* Block move operation.  */\n   DOI_movmem,\n \n@@ -884,6 +888,12 @@ extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n /* Generate code for VEC_LSHIFT_EXPR and VEC_RSHIFT_EXPR.  */\n extern rtx expand_vec_shift_expr (sepops, rtx);\n \n+/* Return tree if target supports vector operations for VEC_SHUFFLE_EXPR.  */\n+bool expand_vec_shuffle_expr_p (enum machine_mode, tree, tree, tree);\n+\n+/* Generate code for VEC_SHUFFLE_EXPR.  */\n+extern rtx expand_vec_shuffle_expr (tree, tree, tree, tree, rtx);\n+\n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n "}, {"sha": "887007f6dde37bc70621c305a9a75b75c2938d72", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -1355,7 +1355,6 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_vectorize);\n \t    {\n \t      struct opt_pass **p = &pass_vectorize.pass.sub;\n-\t      NEXT_PASS (pass_lower_vector_ssa);\n \t      NEXT_PASS (pass_dce_loop);\n \t    }\n           NEXT_PASS (pass_predcom);\n@@ -1367,6 +1366,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_lim);\n \t  NEXT_PASS (pass_tree_loop_done);\n \t}\n+      NEXT_PASS (pass_lower_vector_ssa);\n       NEXT_PASS (pass_cse_reciprocals);\n       NEXT_PASS (pass_reassoc);\n       NEXT_PASS (pass_vrp);"}, {"sha": "06df7029d477ad309aef9f113e065ba008513168", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -1,3 +1,10 @@\n+2011-10-03  Artem Shinkarov  <artyom.shinkaroff@gmail.com>\n+\n+\t* gcc.c-torture/execute/vect-shuffle-2.c: New test.\n+\t* gcc.c-torture/execute/vect-shuffle-4.c: New test.\n+\t* gcc.c-torture/execute/vect-shuffle-1.c: New test.\n+\t* gcc.dg/builtin-complex-err-1.c: Adjust.\n+\n 2011-10-02  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/range-for22.C: New."}, {"sha": "6664384e220549c762551d7219fe2ab331fa08b4", "filename": "gcc/testsuite/gcc.c-torture/execute/vect-shuffle-1.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-1.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -0,0 +1,92 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shufcompare(type, count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != vidx(type, v0, vidx(type, mask, __i))) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+    /*vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+   \n+    vector (8, short) smask = {0,0,1,2,3,4,5,6};\n+    \n+    v2 = __builtin_shuffle (v0,  smask);\n+    shufcompare (short, 8, v2, v0, smask);\n+    v2 = __builtin_shuffle (v0, v1);\n+    shufcompare (short, 8, v2, v0, v1);\n+    v2 = __builtin_shuffle (smask, v0);\n+    shufcompare (short, 8, v2, smask, v0);*/\n+\n+    vector (4, int) i0 = {argc, 1,2,3};\n+    vector (4, int) i1 = {argc, 1, argc, 3};\n+    vector (4, int) i2;\n+\n+    vector (4, int) imask = {0,3,2,1};\n+\n+    /*i2 = __builtin_shuffle (i0, imask);\n+    shufcompare (int, 4, i2, i0, imask);*/\n+    i2 = __builtin_shuffle (i0, i1);\n+    shufcompare (int, 4, i2, i0, i1);\n+    \n+    i2 = __builtin_shuffle (imask, i0);\n+    shufcompare (int, 4, i2, imask, i0);\n+    \n+    return 0;\n+}\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shufcompare(type, count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != vidx(type, v0, vidx(type, mask, __i))) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+    /*vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+   \n+    vector (8, short) smask = {0,0,1,2,3,4,5,6};\n+    \n+    v2 = __builtin_shuffle (v0,  smask);\n+    shufcompare (short, 8, v2, v0, smask);\n+    v2 = __builtin_shuffle (v0, v1);\n+    shufcompare (short, 8, v2, v0, v1);\n+    v2 = __builtin_shuffle (smask, v0);\n+    shufcompare (short, 8, v2, smask, v0);*/\n+\n+    vector (4, int) i0 = {argc, 1,2,3};\n+    vector (4, int) i1 = {argc, 1, argc, 3};\n+    vector (4, int) i2;\n+\n+    vector (4, int) imask = {0,3,2,1};\n+\n+    /*i2 = __builtin_shuffle (i0, imask);\n+    shufcompare (int, 4, i2, i0, imask);*/\n+    i2 = __builtin_shuffle (i0, i1);\n+    shufcompare (int, 4, i2, i0, i1);\n+    \n+    i2 = __builtin_shuffle (imask, i0);\n+    shufcompare (int, 4, i2, imask, i0);\n+    \n+    return 0;\n+}\n+"}, {"sha": "af3e08db16a372b944ef7e63bd0d3bbaddcd4af7", "filename": "gcc/testsuite/gcc.c-torture/execute/vect-shuffle-2.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-2.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -0,0 +1,88 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shuf2compare(type, count, vres, v0, v1, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != ((vidx(type, mask, __i) < count) ? \\\n+                          vidx(type, v0, vidx(type, mask, __i)) :  \\\n+                          vidx(type, v1, (vidx(type, mask, __i) - count)))) \\\n+            __builtin_abort (); \\\n+        } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {5, 5,5,5,5,5,argc,7};\n+    vector (8, short) v1 = {argc, 1,8,8,4,9,argc,4};\n+    vector (8, short) v2;\n+\n+    //vector (8, short) mask = {1,2,5,4,3,6,7};\n+\n+    vector (8, short) mask0 = {0,2,3,1,4,5,6,7};\n+    vector (8, short) mask1 = {0,12,3,4,3,0,10,9};\n+\n+    vector (8, short) mask2 = {0,8,1,9,2,10,3,11};\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask0);\n+    shuf2compare (short, 8, v2, v0, v1, mask0);\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask1);\n+    shuf2compare (short, 8, v2, v0, v1, mask1);\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask2);\n+    shuf2compare (short, 8, v2, v0, v1, mask2);\n+\n+    v2 = __builtin_shuffle (mask0, mask0,  v0);\n+    shuf2compare (short, 8, v2, mask0, mask0, v0);\n+\n+    return 0;\n+}\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shuf2compare(type, count, vres, v0, v1, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != ((vidx(type, mask, __i) < count) ? \\\n+                          vidx(type, v0, vidx(type, mask, __i)) :  \\\n+                          vidx(type, v1, (vidx(type, mask, __i) - count)))) \\\n+            __builtin_abort (); \\\n+        } \\\n+} while (0)\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {5, 5,5,5,5,5,argc,7};\n+    vector (8, short) v1 = {argc, 1,8,8,4,9,argc,4};\n+    vector (8, short) v2;\n+\n+    //vector (8, short) mask = {1,2,5,4,3,6,7};\n+\n+    vector (8, short) mask0 = {0,2,3,1,4,5,6,7};\n+    vector (8, short) mask1 = {0,12,3,4,3,0,10,9};\n+\n+    vector (8, short) mask2 = {0,8,1,9,2,10,3,11};\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask0);\n+    shuf2compare (short, 8, v2, v0, v1, mask0);\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask1);\n+    shuf2compare (short, 8, v2, v0, v1, mask1);\n+\n+    v2 = __builtin_shuffle (v0, v1,  mask2);\n+    shuf2compare (short, 8, v2, v0, v1, mask2);\n+\n+    v2 = __builtin_shuffle (mask0, mask0,  v0);\n+    shuf2compare (short, 8, v2, mask0, mask0, v0);\n+\n+    return 0;\n+}\n+"}, {"sha": "bd54713d5661f263297dd7e27500b3784d986e1b", "filename": "gcc/testsuite/gcc.c-torture/execute/vect-shuffle-3.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-3.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -0,0 +1,72 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shufcompare(type, count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != vidx(type, v0, vidx(type, mask, __i))) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+vector (8, short) __attribute__ ((noinline))\n+f (vector (8, short) x, vector (8, short) mask) {\n+    return __builtin_shuffle (x, mask);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+\n+    vector (8, short) mask = {0,0,1,2,3,4,5,6};\n+    \n+    v2 = f (v0,  mask);\n+    shufcompare (short, 8, v2, v0, mask);\n+\n+    v2 = f (v0, v1);\n+    shufcompare (short, 8, v2, v0, v1);\n+\n+    return 0;\n+}\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shufcompare(type, count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != vidx(type, v0, vidx(type, mask, __i))) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+vector (8, short) __attribute__ ((noinline))\n+f (vector (8, short) x, vector (8, short) mask) {\n+    return __builtin_shuffle (x, mask);\n+}\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+\n+    vector (8, short) mask = {0,0,1,2,3,4,5,6};\n+    \n+    v2 = f (v0,  mask);\n+    shufcompare (short, 8, v2, v0, mask);\n+\n+    v2 = f (v0, v1);\n+    shufcompare (short, 8, v2, v0, v1);\n+\n+    return 0;\n+}\n+"}, {"sha": "7cf38d4501923ac5b05b7c6312c3e65c321d4402", "filename": "gcc/testsuite/gcc.c-torture/execute/vect-shuffle-4.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-4.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -0,0 +1,100 @@\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shuf2compare(type, count, vres, v0, v1, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != ((vidx(type, mask, __i) < count) ? \\\n+                          vidx(type, v0, vidx(type, mask, __i)) :  \\\n+                          vidx(type, v1, (vidx(type, mask, __i) - count)))) \\\n+            __builtin_abort (); \\\n+        } \\\n+} while (0)\n+\n+\n+vector (8, short) __attribute__ ((noinline))\n+f (vector (8, short) x, vector (8, short) y, vector (8, short) mask) {\n+    return __builtin_shuffle (x, y, mask);\n+}\n+\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+\n+    //vector (8, short) mask = {1,2,5,4,3,6,7};\n+    \n+    vector (8, short) mask0 = {0,2,3,1,4,5,6,7};\n+    vector (8, short) mask1 = {0,12,3,4,3,0,10,9};\n+    vector (8, short) mask2 = {0,8,1,9,2,10,3,11};\n+\n+    v2 = f (v0, v1,  mask0);\n+    shuf2compare (short, 8, v2, v0, v1, mask0);\n+ \n+    v2 = f (v0, v1,  mask1);\n+    shuf2compare (short, 8, v2, v0, v1, mask1);\n+\n+    v2 = f (v0, v1,  mask2);\n+    shuf2compare (short, 8, v2, v0, v1, mask2);\n+\n+    v2 = f (mask0, mask0,  v0);\n+    shuf2compare (short, 8, v2, mask0, mask0, v0);\n+\n+    return 0; \n+}\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define vidx(type, vec, idx) (*(((type *) &(vec)) + idx))\n+\n+#define shuf2compare(type, count, vres, v0, v1, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vidx(type, vres, __i) != ((vidx(type, mask, __i) < count) ? \\\n+                          vidx(type, v0, vidx(type, mask, __i)) :  \\\n+                          vidx(type, v1, (vidx(type, mask, __i) - count)))) \\\n+            __builtin_abort (); \\\n+        } \\\n+} while (0)\n+\n+\n+vector (8, short) __attribute__ ((noinline))\n+f (vector (8, short) x, vector (8, short) y, vector (8, short) mask) {\n+    return __builtin_shuffle (x, y, mask);\n+}\n+\n+\n+\n+int main (int argc, char *argv[]) {\n+    vector (8, short) v0 = {argc, 1,2,3,4,5,6,7};\n+    vector (8, short) v1 = {argc, 1,argc,3,4,5,argc,7};\n+    vector (8, short) v2;\n+\n+    //vector (8, short) mask = {1,2,5,4,3,6,7};\n+    \n+    vector (8, short) mask0 = {0,2,3,1,4,5,6,7};\n+    vector (8, short) mask1 = {0,12,3,4,3,0,10,9};\n+    vector (8, short) mask2 = {0,8,1,9,2,10,3,11};\n+\n+    v2 = f (v0, v1,  mask0);\n+    shuf2compare (short, 8, v2, v0, v1, mask0);\n+ \n+    v2 = f (v0, v1,  mask1);\n+    shuf2compare (short, 8, v2, v0, v1, mask1);\n+\n+    v2 = f (v0, v1,  mask2);\n+    shuf2compare (short, 8, v2, v0, v1, mask2);\n+\n+    v2 = f (mask0, mask0,  v0);\n+    shuf2compare (short, 8, v2, mask0, mask0, v0);\n+\n+    return 0; \n+}\n+"}, {"sha": "2b1a65c4e997e410055433f1e40c8466cfe6a061", "filename": "gcc/testsuite/gcc.c-torture/execute/vect-shuffle-5.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fvect-shuffle-5.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -0,0 +1,128 @@\n+/* Test that different type variants are compatible within\n+   vector shuffling.  */\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define shufcompare(count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vres[__i] != v0[mask[__i]]) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+#define test_compat_mask(res, vec, mask) \\\n+  res = __builtin_shuffle (vec, mask); \\\n+  shufcompare(4, res, vec, mask); \\\n+  res = __builtin_shuffle (vec, c ## mask); \\\n+  shufcompare(4, res, vec, c ##  mask); \\\n+  res = __builtin_shuffle (vec, r ## mask); \\\n+  shufcompare(4, res, vec, r ##  mask); \\\n+  res = __builtin_shuffle (vec, d ## mask); \\\n+  shufcompare(4, res, vec, d ##  mask); \\\n+  res = __builtin_shuffle (vec, dc ## mask); \\\n+  shufcompare(4, res, vec, dc ##  mask); \\\n+\n+#define test_compat_vec(res, vec, mask) \\\n+  test_compat_mask (res, vec, mask); \\\n+  test_compat_mask (res, c ## vec, mask); \\\n+  test_compat_mask (res, r ## vec, mask); \\\n+  test_compat_mask (res, d ## vec, mask); \\\n+  test_compat_mask (res, dc ## vec, mask); \n+\n+#define test_compat(res, vec, mask) \\\n+  test_compat_vec (res, vec, mask); \\\n+  test_compat_vec (d ## res, vec, mask); \\\n+  test_compat_vec (r ## res, vec, mask);\n+\n+typedef vector (4, int) v4si;\n+typedef const vector (4, int) v4sicst;\n+\n+int main (int argc, char *argv[]) {\n+    vector (4, int) vec = {argc, 1,2,3};\n+    const vector (4, int) cvec = {argc, 1,2,3};\n+    register vector (4, int) rvec = {argc, 1,2,3};\n+    v4si dvec = {argc, 1,2,3};\n+    v4sicst dcvec = {argc, 1,2,3};\n+    \n+    vector (4, int) res; \n+    v4si dres;\n+    register vector (4, int) rres;\n+\n+    vector (4, int) mask = {0,3,2,1};\n+    const vector (4, int) cmask = {0,3,2,1};\n+    register vector (4, int) rmask = {0,3,2,1};\n+    v4si dmask = {0,3,2,1};\n+    v4sicst dcmask = {0,3,2,1};\n+\n+    test_compat (res, vec, mask);\n+\n+    return 0;\n+}\n+\n+/* Test that different type variants are compatible within\n+   vector shuffling.  */\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define shufcompare(count, vres, v0, mask) \\\n+do { \\\n+    int __i; \\\n+    for (__i = 0; __i < count; __i++) { \\\n+        if (vres[__i] != v0[mask[__i]]) \\\n+            __builtin_abort (); \\\n+    } \\\n+} while (0)\n+\n+#define test_compat_mask(res, vec, mask) \\\n+  res = __builtin_shuffle (vec, mask); \\\n+  shufcompare(4, res, vec, mask); \\\n+  res = __builtin_shuffle (vec, c ## mask); \\\n+  shufcompare(4, res, vec, c ##  mask); \\\n+  res = __builtin_shuffle (vec, r ## mask); \\\n+  shufcompare(4, res, vec, r ##  mask); \\\n+  res = __builtin_shuffle (vec, d ## mask); \\\n+  shufcompare(4, res, vec, d ##  mask); \\\n+  res = __builtin_shuffle (vec, dc ## mask); \\\n+  shufcompare(4, res, vec, dc ##  mask); \\\n+\n+#define test_compat_vec(res, vec, mask) \\\n+  test_compat_mask (res, vec, mask); \\\n+  test_compat_mask (res, c ## vec, mask); \\\n+  test_compat_mask (res, r ## vec, mask); \\\n+  test_compat_mask (res, d ## vec, mask); \\\n+  test_compat_mask (res, dc ## vec, mask); \n+\n+#define test_compat(res, vec, mask) \\\n+  test_compat_vec (res, vec, mask); \\\n+  test_compat_vec (d ## res, vec, mask); \\\n+  test_compat_vec (r ## res, vec, mask);\n+\n+typedef vector (4, int) v4si;\n+typedef const vector (4, int) v4sicst;\n+\n+int main (int argc, char *argv[]) {\n+    vector (4, int) vec = {argc, 1,2,3};\n+    const vector (4, int) cvec = {argc, 1,2,3};\n+    register vector (4, int) rvec = {argc, 1,2,3};\n+    v4si dvec = {argc, 1,2,3};\n+    v4sicst dcvec = {argc, 1,2,3};\n+    \n+    vector (4, int) res; \n+    v4si dres;\n+    register vector (4, int) rres;\n+\n+    vector (4, int) mask = {0,3,2,1};\n+    const vector (4, int) cmask = {0,3,2,1};\n+    register vector (4, int) rmask = {0,3,2,1};\n+    v4si dmask = {0,3,2,1};\n+    v4sicst dcmask = {0,3,2,1};\n+\n+    test_compat (res, vec, mask);\n+\n+    return 0;\n+}\n+"}, {"sha": "3ef50da92782312ae27d7cb44ab1ae3717a047cb", "filename": "gcc/testsuite/gcc.dg/builtin-complex-err-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-complex-err-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-complex-err-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-complex-err-1.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -19,8 +19,8 @@ _Complex float fc3 = __builtin_complex (1.0f, 1.0); /* { dg-error \"different typ\n void\n f (void)\n {\n-  __builtin_complex (0.0); /* { dg-error \"expected\" } */\n-  __builtin_complex (0.0, 0.0, 0.0); /* { dg-error \"expected\" } */\n+  __builtin_complex (0.0); /* { dg-error \"wrong number of arguments\" } */\n+  __builtin_complex (0.0, 0.0, 0.0); /* { dg-error \"wrong number of arguments\" } */\n }\n \n-void (*p) (void) = __builtin_complex; /* { dg-error \"expected\" } */\n+void (*p) (void) = __builtin_complex; /* { dg-error \"cannot take address\" } */"}, {"sha": "598ef2ac7a6a9b772d256a969d0f51bdc66de501", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -3727,6 +3727,59 @@ verify_gimple_assign_ternary (gimple stmt)\n \t}\n       break;\n \n+    case VEC_SHUFFLE_EXPR:\n+      if (!useless_type_conversion_p (lhs_type, rhs1_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs2_type))\n+\t{\n+\t  error (\"type mismatch in vector shuffle expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (rhs1_type) != VECTOR_TYPE\n+\t  || TREE_CODE (rhs2_type) != VECTOR_TYPE\n+\t  || TREE_CODE (rhs3_type) != VECTOR_TYPE)\n+\t{\n+\t  error (\"vector types expected in vector shuffle expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      if (TYPE_VECTOR_SUBPARTS (rhs1_type) != TYPE_VECTOR_SUBPARTS (rhs2_type)\n+\t  || TYPE_VECTOR_SUBPARTS (rhs2_type)\n+\t     != TYPE_VECTOR_SUBPARTS (rhs3_type)\n+\t  || TYPE_VECTOR_SUBPARTS (rhs3_type)\n+\t     != TYPE_VECTOR_SUBPARTS (lhs_type))\n+\t{\n+\t  error (\"vectors with different element number found \"\n+\t\t \"in vector shuffle expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (TREE_TYPE (rhs3_type)) != INTEGER_TYPE\n+\t  || GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs3_type)))\n+\t     != GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (rhs1_type))))\n+\t{\n+\t  error (\"invalid mask type in vector shuffle expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      return false;\n+\n     case DOT_PROD_EXPR:\n     case REALIGN_LOAD_EXPR:\n       /* FIXME.  */"}, {"sha": "8c60f4d73a9ae0095c299fbf418548f759b16442", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -3285,6 +3285,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n        ??? We may consider mapping RTL costs to this.  */\n     case COND_EXPR:\n     case VEC_COND_EXPR:\n+    case VEC_SHUFFLE_EXPR:\n \n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:"}, {"sha": "c61e901d8be7550081d61cd9eb1c1974cb3fe6c8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -2069,6 +2069,16 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n       pp_string (buffer, \" > \");\n       break;\n+    \n+    case VEC_SHUFFLE_EXPR:\n+      pp_string (buffer, \" VEC_SHUFFLE_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" , \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" , \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n \n     case DOT_PROD_EXPR:\n       pp_string (buffer, \" DOT_PROD_EXPR < \");"}, {"sha": "d1630371fe57e416a888af395e00bd51c011f064", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -943,6 +943,7 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n+    case VEC_SHUFFLE_EXPR:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 0), uflags);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);"}, {"sha": "1a6d1f1a7aaddfa960903f401dd77daca52e18bf", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 291, "deletions": 13, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"diagnostic.h\"\n \n /* Need to include rtl.h, expr.h, etc. for optabs.  */\n #include \"expr.h\"\n@@ -129,7 +130,6 @@ do_binop (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n   return gimplify_build2 (gsi, code, inner_type, a, b);\n }\n \n-\n /* Construct expression (A[BITPOS] code B[BITPOS]) ? -1 : 0\n \n    INNER_TYPE is the type of A and B elements\n@@ -355,10 +355,10 @@ uniform_vector_p (tree vec)\n         }\n       if (i != TYPE_VECTOR_SUBPARTS (TREE_TYPE (vec)))\n \treturn NULL_TREE;\n-      \n+\n       return first;\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -498,6 +498,263 @@ type_for_widest_vector_mode (enum machine_mode inner_mode, optab op, int satp)\n     }\n }\n \n+\n+/* Build a reference to the element of the vector VECT.  Function\n+   returns either the element itself, either BIT_FIELD_REF, or an\n+   ARRAY_REF expression.\n+\n+   GSI is requred to insert temporary variables while building a\n+   refernece to the element of the vector VECT.\n+\n+   PTMPVEC is a pointer to the temporary variable for caching\n+   purposes.  In case when PTMPVEC is NULL new temporary variable\n+   will be created.  */\n+static tree\n+vector_element (gimple_stmt_iterator *gsi, tree vect, tree idx, tree *ptmpvec)\n+{\n+  tree type;\n+  gimple asgn;\n+  tree tmpvec;\n+  tree arraytype;\n+  bool need_asgn = true;\n+\n+  gcc_assert (TREE_CODE (TREE_TYPE (vect)) == VECTOR_TYPE);\n+\n+  type = TREE_TYPE (vect);\n+  if (TREE_CODE (idx) == INTEGER_CST)\n+    {\n+      unsigned HOST_WIDE_INT index;\n+\n+      if (!host_integerp (idx, 1)\n+           || (index = tree_low_cst (idx, 1)) > TYPE_VECTOR_SUBPARTS (type)-1)\n+        return error_mark_node;\n+\n+      if (TREE_CODE (vect) == VECTOR_CST)\n+        {\n+\t  unsigned i;\n+\t  tree vals = TREE_VECTOR_CST_ELTS (vect);\n+\t  for (i = 0; vals; vals = TREE_CHAIN (vals), ++i)\n+\t    if (i == index)\n+\t       return TREE_VALUE (vals);\n+\t  return error_mark_node;\n+        }\n+      else if (TREE_CODE (vect) == CONSTRUCTOR)\n+        {\n+          unsigned i;\n+          VEC (constructor_elt, gc) *vals = CONSTRUCTOR_ELTS (vect);\n+          constructor_elt *elt;\n+\n+          for (i = 0; VEC_iterate (constructor_elt, vals, i, elt); i++)\n+            if (operand_equal_p (elt->index, idx, 0))\n+              return elt->value;\n+          return fold_convert (TREE_TYPE (type), integer_zero_node);\n+        }\n+      else if (TREE_CODE (vect) == SSA_NAME)\n+        {\n+\t  tree size = TYPE_SIZE (TREE_TYPE (type));\n+          tree pos = fold_build2 (MULT_EXPR, TREE_TYPE (idx), idx, size);\n+          return fold_build3 (BIT_FIELD_REF, TREE_TYPE (type), vect, size, pos);\n+        }\n+      else\n+\treturn error_mark_node;\n+    }\n+\n+  if (!ptmpvec)\n+    tmpvec = create_tmp_var (TREE_TYPE (vect), \"vectmp\");\n+  else if (!*ptmpvec)\n+    tmpvec = *ptmpvec = create_tmp_var (TREE_TYPE (vect), \"vectmp\");\n+  else\n+    {\n+      tmpvec = *ptmpvec;\n+      need_asgn = false;\n+    }\n+\n+  if (need_asgn)\n+    {\n+      TREE_ADDRESSABLE (tmpvec) = 1;\n+      asgn = gimple_build_assign (tmpvec, vect);\n+      gsi_insert_before (gsi, asgn, GSI_SAME_STMT);\n+    }\n+\n+  arraytype = build_array_type_nelts (TREE_TYPE (type),\n+\t\t\t\t      TYPE_VECTOR_SUBPARTS (TREE_TYPE (vect)));\n+\n+  return build4 (ARRAY_REF, TREE_TYPE (type),\n+                 build1 (VIEW_CONVERT_EXPR, arraytype, tmpvec),\n+                 idx, NULL_TREE, NULL_TREE);\n+}\n+\n+/* Check if VEC_SHUFFLE_EXPR within the given setting is supported\n+   by hardware, or lower it piecewise.  Function returns false when\n+   the expression must be replaced with TRAP_RETURN, true otherwise.\n+\n+   When VEC_SHUFFLE_EXPR has the same first and second operands:\n+   VEC_SHUFFLE_EXPR <v0, v0, mask> the lowered version would be\n+   {v0[mask[0]], v0[mask[1]], ...}\n+   MASK and V0 must have the same number of elements.\n+\n+   Otherwise VEC_SHUFFLE_EXPR <v0, v1, mask> is lowered to\n+   {mask[0] < len(v0) ? v0[mask[0]] : v1[mask[0]], ...}\n+   V0 and V1 must have the same type.  MASK, V0, V1 must have the\n+   same number of arguments.  */\n+static bool\n+lower_vec_shuffle (gimple_stmt_iterator *gsi, location_t loc)\n+{\n+\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree mask = gimple_assign_rhs3 (stmt);\n+  tree vec0 = gimple_assign_rhs1 (stmt);\n+  tree vec1 = gimple_assign_rhs2 (stmt);\n+  unsigned els = TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask));\n+  tree type0 = TREE_TYPE (TREE_TYPE (vec0));\n+  VEC(constructor_elt,gc) *v = NULL;\n+  tree vectype, constr;\n+  tree vec0tmp = NULL_TREE, masktmp = NULL_TREE;\n+\n+  if (expand_vec_shuffle_expr_p (TYPE_MODE (TREE_TYPE (vec0)), vec0, vec1, mask))\n+    {\n+      tree t;\n+\n+      t = gimplify_build3 (gsi, VEC_SHUFFLE_EXPR, TREE_TYPE (vec0),\n+\t\t\t   vec0, vec1, mask);\n+      gimple_assign_set_rhs_from_tree (gsi, t);\n+      /* Statement should be updated by callee.  */\n+      return true;\n+    }\n+\n+  if (operand_equal_p (vec0, vec1, 0))\n+    {\n+      unsigned i;\n+      tree vec0tmp = NULL_TREE;\n+\n+      v = VEC_alloc (constructor_elt, gc, els);\n+      for (i = 0; i < els; i++)\n+        {\n+          tree idxval, vecel, t;\n+\n+\t  idxval = vector_element (gsi, mask, size_int (i), &masktmp);\n+          if (idxval == error_mark_node)\n+            {\n+              if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n+\t\tinform (loc, \"if this code is reached the programm will abort\");\n+\t      return false;\n+            }\n+\n+\t  vecel = vector_element (gsi, vec0, idxval, &vec0tmp);\n+          if (vecel == error_mark_node)\n+            {\n+              if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n+\t\tinform (loc, \"if this code is reached the programm will abort\");\n+\t      return false;\n+            }\n+\n+          t = force_gimple_operand_gsi (gsi, vecel, true,\n+\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n+          CONSTRUCTOR_APPEND_ELT (v, size_int (i), t);\n+        }\n+    }\n+  else\n+    {\n+      unsigned i;\n+      tree var = create_tmp_var (type0, \"vecel\");\n+      tree vec1tmp = NULL_TREE;\n+\n+      v = VEC_alloc (constructor_elt, gc, els);\n+      for (i = 0; i < els; i++)\n+        {\n+          tree idxval, idx1val, cond, elval0, elval1, condexpr, t, ssatmp;\n+          tree vec0el, vec1el;\n+          gimple asgn;\n+\n+          idxval = vector_element (gsi, mask, size_int (i), &masktmp);\n+\t  if (idxval == error_mark_node)\n+            {\n+              if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n+\t\tinform (loc, \"if this code is reached the programm will abort\");\n+\t      return false;\n+            }\n+\n+          if (TREE_CODE (idxval) == INTEGER_CST)\n+            {\n+              if (tree_int_cst_lt (idxval, size_int (els)))\n+                {\n+                  vec0el = vector_element (gsi, vec0, idxval, &vec0tmp);\n+                  t = force_gimple_operand_gsi (gsi, vec0el,\n+                                    true, NULL_TREE, true, GSI_SAME_STMT);\n+                }\n+              else if (tree_int_cst_lt (idxval, size_int (2*els)))\n+                {\n+                  idx1val = fold_build2 (MINUS_EXPR, TREE_TYPE (idxval),\n+                        idxval, build_int_cst (TREE_TYPE (idxval), els));\n+\n+                  vec1el = vector_element (gsi, vec1, idx1val, &vec1tmp);\n+                  t = force_gimple_operand_gsi (gsi, vec1el, true,\n+\t\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n+                }\n+              else\n+                {\n+                  if (warning_at (loc, 0, \"Invalid shuffling mask index %i\", i))\n+\t\t    inform (loc, \"if this code is reached the \"\n+\t\t\t\t  \"programm will abort\");\n+\t\t  return false;\n+                }\n+            }\n+          else\n+            {\n+\n+              idx1val = fold_build2 (MINUS_EXPR, TREE_TYPE (idxval),\n+                            idxval, build_int_cst (TREE_TYPE (idxval), els));\n+              idx1val = force_gimple_operand_gsi (gsi, idx1val,\n+                                true, NULL_TREE, true, GSI_SAME_STMT);\n+              cond = fold_build2 (GT_EXPR, boolean_type_node, \\\n+                             idxval, fold_convert (type0, size_int (els - 1)));\n+\n+\t      vec0el = vector_element (gsi, vec0, idxval, &vec0tmp);\n+              if (vec0el == error_mark_node)\n+                {\n+                  if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n+\t\t    inform (loc, \"if this code is reached the \"\n+\t\t\t\t \"programm will abort\");\n+\t\t  return false;\n+                }\n+\n+              elval0 = force_gimple_operand_gsi (gsi, vec0el,\n+                                true, NULL_TREE, true, GSI_SAME_STMT);\n+\n+\t      vec1el = vector_element (gsi, vec1, idx1val, &vec1tmp);\n+              if (vec1el == error_mark_node)\n+                {\n+                  if (warning_at (loc, 0, \"Invalid shuffling arguments\"))\n+\t\t    inform (loc, \"if this code is reached the \"\n+\t\t\t\t \"programm will abort\");\n+\t\t  return false;\n+                }\n+\n+              elval1 = force_gimple_operand_gsi (gsi, vec1el,\n+                                true, NULL_TREE, true, GSI_SAME_STMT);\n+\n+              condexpr = fold_build3 (COND_EXPR, type0, cond, \\\n+                                      elval1, elval0);\n+\n+              t = force_gimple_operand_gsi (gsi, condexpr, true, \\\n+                                        NULL_TREE, true, GSI_SAME_STMT);\n+            }\n+\n+          asgn = gimple_build_assign (var, t);\n+          ssatmp = make_ssa_name (var, asgn);\n+          gimple_assign_set_lhs (asgn, ssatmp);\n+          gsi_insert_before (gsi, asgn, GSI_SAME_STMT);\n+          CONSTRUCTOR_APPEND_ELT (v, size_int (i), ssatmp);\n+        }\n+    }\n+\n+  vectype = build_vector_type (type0, els);\n+  constr = build_constructor (vectype, v);\n+  gimple_assign_set_rhs_from_tree (gsi, constr);\n+  /* Statement should be updated by callee.  */\n+  return true;\n+}\n+\n /* Process one statement.  If we identify a vector operation, expand it.  */\n \n static void\n@@ -518,6 +775,25 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   rhs_class = get_gimple_rhs_class (code);\n   lhs = gimple_assign_lhs (stmt);\n \n+  if (code == VEC_SHUFFLE_EXPR)\n+    {\n+      if (!lower_vec_shuffle (gsi, gimple_location (stmt)))\n+\t{\n+\t  gimple new_stmt;\n+\t  tree vec0;\n+\n+\t  vec0 = gimple_assign_rhs1 (stmt);\n+\t  new_stmt = gimple_build_call (built_in_decls[BUILT_IN_TRAP], 0);\n+\t  gsi_insert_before (gsi, new_stmt,  GSI_SAME_STMT);\n+\t  split_block (gimple_bb (new_stmt), new_stmt);\n+\t  new_stmt = gimple_build_assign (gimple_assign_lhs (stmt), vec0);\n+\t  gsi_replace (gsi, new_stmt, false);\n+\t}\n+\n+      gimple_set_modified (gsi_stmt (*gsi), true);\n+      update_stmt (gsi_stmt (*gsi));\n+    }\n+\n   if (rhs_class != GIMPLE_UNARY_RHS && rhs_class != GIMPLE_BINARY_RHS)\n     return;\n \n@@ -551,9 +827,9 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n     {\n       bool vector_scalar_shift;\n       op = optab_for_tree_code (code, type, optab_scalar);\n-      \n+\n       /* Vector/Scalar shift is supported.  */\n-      vector_scalar_shift = (op && (optab_handler (op, TYPE_MODE (type)) \n+      vector_scalar_shift = (op && (optab_handler (op, TYPE_MODE (type))\n \t\t\t\t    != CODE_FOR_nothing));\n \n       /* If the 2nd argument is vector, we need a vector/vector shift.\n@@ -566,10 +842,10 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n           /* Check whether we have vector <op> {x,x,x,x} where x\n              could be a scalar variable or a constant. Transform\n              vector <op> {x,x,x,x} ==> vector <op> scalar.  */\n-          if (vector_scalar_shift \n+          if (vector_scalar_shift\n               && ((TREE_CODE (rhs2) == VECTOR_CST\n \t\t   && (first = uniform_vector_p (rhs2)) != NULL_TREE)\n-\t\t  || (TREE_CODE (rhs2) == SSA_NAME \n+\t\t  || (TREE_CODE (rhs2) == SSA_NAME\n \t\t      && (def_stmt = SSA_NAME_DEF_STMT (rhs2))\n \t\t      && gimple_assign_single_p (def_stmt)\n \t\t      && (first = uniform_vector_p\n@@ -582,14 +858,14 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n           else\n             op = optab_for_tree_code (code, type, optab_vector);\n         }\n-    \n+\n       /* Try for a vector/scalar shift, and if we don't have one, see if we\n          have a vector/vector shift */\n       else if (!vector_scalar_shift)\n \t{\n \t  op = optab_for_tree_code (code, type, optab_vector);\n \n-\t  if (op && (optab_handler (op, TYPE_MODE (type)) \n+\t  if (op && (optab_handler (op, TYPE_MODE (type))\n \t\t     != CODE_FOR_nothing))\n \t    {\n \t      /* Transform vector <op> scalar => vector <op> {x,x,x,x}.  */\n@@ -684,9 +960,9 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n    if it may need the bit-twiddling tricks implemented in this file.  */\n \n static bool\n-gate_expand_vector_operations (void)\n+gate_expand_vector_operations_ssa (void)\n {\n-  return flag_tree_vectorize != 0;\n+  return optimize == 0;\n }\n \n static unsigned int\n@@ -719,7 +995,7 @@ struct gimple_opt_pass pass_lower_vector =\n  {\n   GIMPLE_PASS,\n   \"veclower\",\t\t\t\t/* name */\n-  0,\t\t\t\t\t/* gate */\n+  gate_expand_vector_operations_ssa,    /* gate */\n   expand_vector_operations,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n@@ -732,6 +1008,7 @@ struct gimple_opt_pass pass_lower_vector =\n   TODO_update_ssa\t                /* todo_flags_finish */\n     | TODO_verify_ssa\n     | TODO_verify_stmts | TODO_verify_flow\n+    | TODO_cleanup_cfg\n  }\n };\n \n@@ -740,7 +1017,7 @@ struct gimple_opt_pass pass_lower_vector_ssa =\n  {\n   GIMPLE_PASS,\n   \"veclower2\",\t\t\t\t/* name */\n-  gate_expand_vector_operations,\t/* gate */\n+  0,\t                                /* gate */\n   expand_vector_operations,\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n@@ -753,6 +1030,7 @@ struct gimple_opt_pass pass_lower_vector_ssa =\n   TODO_update_ssa\t                /* todo_flags_finish */\n     | TODO_verify_ssa\n     | TODO_verify_stmts | TODO_verify_flow\n+    | TODO_cleanup_cfg\n  }\n };\n "}, {"sha": "44c4ee8e71712fd04a38cfc7495034799afd6432", "filename": "gcc/tree.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f90e8e2eae9a83d22efd7922673116a97ebf5290/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=f90e8e2eae9a83d22efd7922673116a97ebf5290", "patch": "@@ -497,6 +497,19 @@ DEFTREECODE (COND_EXPR, \"cond_expr\", tcc_expression, 3)\n */\n DEFTREECODE (VEC_COND_EXPR, \"vec_cond_expr\", tcc_expression, 3)\n \n+/* Vector shuffle expression.  A = VEC_SHUFFLE_EXPR<v0, v1, mask>\n+   means\n+\n+   foreach i in length (mask):\n+     A = mask[i] < length (v0) ? v0[mask[i]] : v1[mask[i] - length (mask)]\n+\n+   V0 and V1 are vectors of the same type.  MASK is an integer-typed\n+   vector.  The number of MASK elements must be the same with the\n+   number of elements in V0 and V1.  The size of the inner type\n+   of the MASK and of the V0 and V1 must be the same.\n+*/\n+DEFTREECODE (VEC_SHUFFLE_EXPR, \"vec_shuffle_expr\", tcc_expression, 3)\n+\n /* Declare local variables, including making RTL and allocating space.\n    BIND_EXPR_VARS is a chain of VAR_DECL nodes for the variables.\n    BIND_EXPR_BODY is the body, the expression to be computed using"}]}