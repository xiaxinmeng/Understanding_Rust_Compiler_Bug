{"sha": "3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M3OWIyZGE2YmE1MmZlOWFlMmVjNDVmOWVkNjc3NGYzMzY2ZGI5Mw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:39Z"}, "message": "\ufffd\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22038", "tree": {"sha": "3e221460a1bf1a44a2e3a008fead9cd61b440bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e221460a1bf1a44a2e3a008fead9cd61b440bc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/comments", "author": null, "committer": null, "parents": [{"sha": "360c5f1547ccd947d760a18f59817b38e0a47fd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360c5f1547ccd947d760a18f59817b38e0a47fd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/360c5f1547ccd947d760a18f59817b38e0a47fd3"}], "stats": {"total": 28969, "additions": 28969, "deletions": 0}, "files": [{"sha": "3dba9773bd435f9ddc5f7c2bcb14d53356579f9c", "filename": "gcc/ch/README", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FREADME?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,42 @@\n+This directory contains the GNU front-end for the Chill language,\n+contributed by Cygnus Solutions.\n+\n+Chill is the \"CCITT High-Level Language\", where CCITT is the old\n+name for what is now ITU, the International Telecommunications Union.\n+It is is language in the Modula2 family, and targets many of the\n+same applications as Ada (especially large embedded systems).\n+Chill was never used much in the United States, but is still\n+being used in Europe, Brazil, Korea, and other places.\n+\n+Chill has been standardized by a series of reports/standards.\n+The GNU implementation mostly follows the 1988 version of\n+the language, with some backwards compatibility options for\n+the 1984 version, and some other extensions.  However, it\n+does not implement all of the features of any standard.\n+The most recent standard is ?, available from ?.\n+\n+The GNU Chill implementation is not being actively developed.\n+Cygnus has one customer we are maintaining Chill for,\n+but we are not planning on putting major work into Chill.\n+This Net release is for educational purposes (as an example\n+of a different Gcc front-end), and for those who find it useful.\n+It is an unsupported hacker release.  Bug reports without\n+patches are likely to get ignored.  Questions may get answered or\n+ignored depending on our mood!  If you want to try your luck,\n+you can send a note to David Brolley <brolley@cygnus.com> or\n+Per Bothner <bothner@cygnus.com>.\n+\n+One known problem is that we only support native builds of GNU Chill.\n+If you need a cross-compiler, you will find various problems,\n+including the directory structure, and the setjmp-based exception\n+handling mechanism.\n+\n+The Chill run-time system is in the runtime sub-directory.\n+Notice rts.c contains a poor main's implementation of Chill\n+\"processes\" (threads).  It is not added to libchill.a.\n+We only use it for testing.  (Our customer uses a different\n+implementation for product work.)\n+\n+The GNU Chill implementation was primarily written by\n+Per Bothner, along with Bill Cox, Wilfried Moser, Michael\n+Tiemann, and David Brolley."}, {"sha": "79bacf04c4f7bffb6a47f74f923d058cacf44162", "filename": "gcc/ch/actions.c", "status": "added", "additions": 1820, "deletions": 0, "changes": 1820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Factions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Factions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,1820 @@\n+/* Implement actions for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+   Authors: Per Bothner, Bill Cox, Michael Tiemann, Michael North\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <limits.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"ch-tree.h\"\n+#include \"lex.h\"\n+#include \"flags.h\"\n+#include \"actions.h\"\n+#include \"obstack.h\"\n+#include \"assert.h\"\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+/* reserved tag definitions */\n+\n+#define TYPE_ID                 \"id\"\n+#define TAG_OBJECT              \"chill_object\"\n+#define TAG_CLASS               \"chill_class\"\n+\n+extern int flag_short_enums;\n+extern int current_nesting_level;\n+\n+extern tree build_chill_compound_expr PROTO((tree));\n+extern tree build_chill_exception_decl PROTO((char *));\n+extern tree convert                   PROTO((tree, tree));\n+extern rtx  emit_line_note_force      PROTO((char *, int));\n+extern void error                     PROTO((char *, ...));\n+extern void error_with_decl           PROTO((tree, char *, ...));\n+extern rtx  gen_nop                   PROTO((void));\n+extern tree get_identifier            PROTO((char *));\n+extern void pedwarn                   PROTO((char *, ...));\n+extern void sorry                     PROTO((char *, ...));\n+extern void warning                   PROTO((char *, ...));\n+\n+extern struct obstack *expression_obstack, permanent_obstack;\n+extern struct obstack *current_obstack, *saveable_obstack;\n+\n+/* This flag is checked throughout the non-CHILL-specific\n+   in the front end. */\n+tree chill_integer_type_node;\n+tree chill_unsigned_type_node;\n+\n+/* Never used.  Referenced from c-typeck.c, which we use. */\n+int current_function_returns_value = 0;\n+int current_function_returns_null = 0;\n+\n+/* data imported from toplev.c  */\n+\n+extern char *dump_base_name;\n+\n+/* set from command line parameter, to exit after \n+   grant file written, generating no code. */\n+int grant_only_flag = 0;\n+\f\n+char *\n+lang_identify ()\n+{\n+  return \"chill\";\n+}\n+\n+\n+void\n+init_chill ()\n+{\n+}\n+\n+void\n+print_lang_statistics ()\n+{\n+}\n+\n+\n+void\n+lang_finish ()\n+{\n+#if 0\n+    extern int errorcount, sorrycount;\n+\n+    /* this should be the last action in compiling a module.\n+       If there are other actions to be performed at lang_finish\n+       please insert before this */\n+\n+    /* FIXME: in case of a syntax error, this leaves the grant file incomplete */\n+    /* for the moment we print a warning in case of errors and \n+       continue granting */\n+    if ((errorcount || sorrycount) && grant_count)\n+      {\n+\twarning (\"%d errors, %d sorries, do granting\", errorcount, sorrycount);\n+\terrorcount = sorrycount = 0;\n+      }\n+#endif\n+}\n+\n+void\n+chill_check_decl (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+  static int alreadyWarned = 0;\n+\n+  if (TREE_CODE (type) == RECORD_TYPE) /* && TREE_STATIC_TEMPLATE (type)) */\n+    {\n+      if (!alreadyWarned)\n+        {\n+          error (\"GNU compiler does not support statically allocated objects\");          \n+          alreadyWarned = 1;\n+        }\n+      error_with_decl (decl, \"`%s' cannot be statically allocated\");\n+    }\n+}\n+\f\n+/* Comparison function for sorting identifiers in RAISES lists.\n+   Note that because IDENTIFIER_NODEs are unique, we can sort\n+   them by address, saving an indirection.  */\n+static int\n+id_cmp (p1, p2)\n+     tree *p1, *p2;\n+{\n+  return (int)TREE_VALUE (*p1) - (int)TREE_VALUE (*p2);\n+}\n+\n+/* Build the FUNCTION_TYPE or METHOD_TYPE which may raise exceptions\n+   listed in RAISES.  */\n+tree\n+build_exception_variant (type, raises)\n+     tree type, raises;\n+{\n+  int i;\n+  tree v = TYPE_MAIN_VARIANT (type);\n+  tree t, t2;\n+  int constp    = TYPE_READONLY (type);\n+  int volatilep = TYPE_VOLATILE (type);\n+\n+  if (!raises)\n+    return build_type_variant (v, constp, volatilep);\n+\n+  if (TREE_CHAIN (raises))\n+    { /* Sort the list */\n+      tree *a = (tree *)alloca ((list_length (raises)+1) * sizeof (tree));\n+      for (i = 0, t = raises; t; t = TREE_CHAIN (t), i++)\n+\ta[i] = t;\n+      /* NULL terminator for list.  */\n+      a[i] = NULL_TREE;\n+      qsort (a, i, sizeof (tree), id_cmp);\n+      while (i--)\n+\tTREE_CHAIN (a[i]) = a[i+1];\n+      raises = a[0];\n+    }\n+\n+  for (v = TYPE_NEXT_VARIANT (v); v; v = TYPE_NEXT_VARIANT (v))\n+    {\n+      if (TYPE_READONLY (v) != constp\n+\t  || TYPE_VOLATILE (v) != volatilep)\n+\tcontinue;\n+\n+      t = raises;\n+      t2 = TYPE_RAISES_EXCEPTIONS (v);\n+      while (t && t2)\n+\t{\n+\t  if (TREE_TYPE (t) == TREE_TYPE (t2))\n+\t    {\n+\t      t = TREE_CHAIN (t);\n+\t      t2 = TREE_CHAIN (t2);\n+\t    }\n+\t  else break;\n+\t}\n+      if (t || t2)\n+\tcontinue;\n+      /* List of exceptions raised matches previously found list.\n+\n+         @@ Nice to free up storage used in consing up the\n+\t @@ list of exceptions raised.  */\n+      return v;\n+    }\n+\n+  /* Need to build a new variant.  */\n+  if (TREE_PERMANENT (type))\n+    {\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      v = copy_node (type);\n+      pop_obstacks ();\n+    }\n+  else\n+    v = copy_node (type);\n+\n+  TYPE_NEXT_VARIANT (v) = TYPE_NEXT_VARIANT (type);\n+  TYPE_NEXT_VARIANT (type) = v;\n+  if (raises && ! TREE_PERMANENT (raises))\n+    {\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      raises = copy_list (raises);\n+      pop_obstacks ();\n+    }\n+  TYPE_RAISES_EXCEPTIONS (v) = raises;\n+  return v;\n+}\n+#if 0\n+\f\n+tree\n+build_rts_call (name, type, args)\n+     char *name;\n+     tree type, args;\n+{\n+  tree decl = lookup_name (get_identifier (name));\n+  tree converted_args = NULL_TREE;\n+  tree result, length = NULL_TREE;\n+\n+  assert (decl != NULL_TREE);\n+  while (args)\n+    {\n+      tree arg = TREE_VALUE (args);\n+      if (TREE_CODE (TREE_TYPE (arg)) == SET_TYPE\n+\t  || TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n+\t{\n+\t  length = size_in_bytes (TREE_TYPE (arg));\n+\t  arg = build_chill_addr_expr (arg, (char *)0);\n+\t}\n+      converted_args = tree_cons (NULL_TREE, arg, converted_args);\n+      args = TREE_CHAIN (args);\n+    }\n+  if (length != NULL_TREE)\n+    converted_args = tree_cons (NULL_TREE, length, converted_args);\n+  converted_args = nreverse (converted_args);\n+  result = build_chill_function_call (decl, converted_args);\n+  if (TREE_CODE (type) == SET_TYPE || TREE_CODE (type) == ARRAY_TYPE)\n+    result = build1 (INDIRECT_REF, type, result);\n+  else\n+    result = convert (type, result);\n+  return result;\n+}\n+#endif\n+\n+/*\n+ * queue name of unhandled exception\n+ * to avoid multiple unhandled warnings\n+ * in one compilation module\n+ */\n+\n+struct already_type\n+{\n+  struct already_type *next;\n+  char *name;\n+};\n+\n+static struct already_type *already_warned = 0;\n+\n+static void\n+warn_unhandled (ex)\n+     char *ex;\n+{\n+  struct already_type *p = already_warned;\n+\n+  while (p)\n+    {\n+      if (!strcmp (p->name, ex))\n+\treturn;\n+      p = p->next;\n+    }\n+  \n+  /* not yet warned */\n+  p = (struct already_type *)xmalloc (sizeof (struct already_type));\n+  p->next = already_warned;\n+  p->name = (char *)xmalloc (strlen (ex) + 1);\n+  strcpy (p->name, ex);\n+  already_warned = p;\n+  pedwarn (\"causing unhandled exception `%s' (this is flaged only once)\", ex);\n+}\n+\n+/*\n+ * build a call to the following function:\n+ *   void   __cause_ex1 (char* ex, const char *file, \n+ *                       const unsigned lineno);\n+ * if the exception is handled or\n+ *   void __unhandled_ex (char *ex, char *file, unsigned lineno)\n+ * if the exception is not handled.\n+ */\n+tree\n+build_cause_exception (exp_name, warn_if_unhandled)\n+     tree exp_name;\n+     int warn_if_unhandled;\n+{\n+  /* We don't use build_rts_call() here, because the string (array of char)\n+     would be followed by its length in the parameter list built by\n+     build_rts_call, and the runtime routine doesn't want a length parameter.*/\n+  tree exp_decl = build_chill_exception_decl (IDENTIFIER_POINTER (exp_name));\n+  tree function, fname, lineno, result;\n+  int handled = is_handled (exp_name);\n+\n+  switch (handled)\n+    {\n+    case 0:\n+      /* no handler */\n+      if (warn_if_unhandled)\n+\twarn_unhandled (IDENTIFIER_POINTER (exp_name));\n+      function = lookup_name (get_identifier (\"__unhandled_ex\"));\n+      fname = force_addr_of (get_chill_filename ());\n+      lineno = get_chill_linenumber ();\n+      break;\n+    case 1:\n+      /* local handler */\n+      function = lookup_name (get_identifier (\"__cause_ex1\"));\n+      fname = force_addr_of (get_chill_filename ());\n+      lineno = get_chill_linenumber ();\n+      break;\n+    case 2:\n+      /* function may propagate this exception */\n+      function = lookup_name (get_identifier (\"__cause_ex1\"));\n+      fname = lookup_name (get_identifier (CALLER_FILE));\n+      if (fname == NULL_TREE)\n+\tfname = error_mark_node;\n+      lineno = lookup_name (get_identifier (CALLER_LINE));\n+      if (lineno == NULL_TREE)\n+\tlineno = error_mark_node;\n+      break;\n+    }\n+  result =\n+    build_chill_function_call (function,\n+      tree_cons (NULL_TREE, build_chill_addr_expr (exp_decl, (char *)0),\n+\ttree_cons (NULL_TREE,  fname,\n+\t  tree_cons (NULL_TREE, lineno, NULL_TREE))));\n+  return result;\n+}\n+\n+void\n+expand_cause_exception (exp_name)\n+     tree exp_name;\n+{\n+  expand_expr_stmt (build_cause_exception (exp_name, 1));\n+}\n+\n+/* If CONDITION is true, raise EXCEPTION (an IDENTIFIER_NODE);\n+   otherwise return EXPR. */\n+\n+tree\n+check_expression (expr, condition, exception)\n+     tree expr, condition, exception;\n+{\n+  if (integer_zerop (condition))\n+    return expr;\n+  else\n+    return build (COMPOUND_EXPR, TREE_TYPE (expr),\n+\t\t  fold (build (TRUTH_ANDIF_EXPR, boolean_type_node,\n+\t\t\t       condition, build_cause_exception (exception, 0))),\n+\t\t  expr);\n+}\n+\n+/* Return an expression for VALUE < LO_LIMIT || VALUE > HI_LIMIT,\n+   somewhat optimized and with some warnings suppressed.\n+   If LO_LIMIT or HI_LIMIT is NULL_TREE, assume that (sub-)test passes.  */\n+\n+tree\n+test_range (value, lo_limit, hi_limit)\n+     tree value, lo_limit, hi_limit;\n+{\n+  if (lo_limit || hi_limit)\n+    {\n+      int old_inhibit_warnings = inhibit_warnings;\n+      tree lo_check, hi_check, check;\n+\n+      /* This is a hack so that `shorten_compare' doesn't warn the\n+\t user about useless range checks that are too much work to\n+\t optimize away here.  */\n+      inhibit_warnings = 1;\n+\n+      lo_check = lo_limit ? \n+\tfold (build_compare_discrete_expr (LT_EXPR, value, lo_limit)) :\n+\t  boolean_false_node;   /* fake passing the check */\n+\n+      hi_check = hi_limit ? \n+\tfold (build_compare_discrete_expr (GT_EXPR, value, hi_limit)) :\n+\t  boolean_false_node;   /* fake passing the check */\n+\n+      if (lo_check == boolean_false_node)\n+\tcheck = hi_check;\n+      else if (hi_check == boolean_false_node)\n+\tcheck = lo_check;\n+      else\n+\tcheck = fold (build (TRUTH_ORIF_EXPR, boolean_type_node,\n+\t\t\t     lo_check, hi_check));\n+\n+      inhibit_warnings = old_inhibit_warnings;\n+      return check;\n+    }\n+  else\n+    return boolean_false_node;\n+}\n+\n+/* Return EXPR, except if range_checking is on, return an expression\n+   that also checks that value >= low_limit && value <= hi_limit.\n+   If LO_LIMIT or HI_LIMIT is NULL_TREE, assume that test passes.  */\n+\n+tree\n+check_range (expr, value, lo_limit, hi_limit)\n+     tree expr, value, lo_limit, hi_limit;\n+{\n+  tree check = test_range (value, lo_limit, hi_limit);\n+  if (!integer_zerop (check))\n+    {\n+      if (current_function_decl == NULL_TREE)\n+\t{\n+\t  if (TREE_CODE (check) == INTEGER_CST)\n+\t    error (\"range failure (not inside function)\");\n+\t  else\n+\t    warning (\"possible range failure (not inside function)\");\n+\t}\n+      else\n+\t{\n+\t  if (TREE_CODE (check) == INTEGER_CST)\n+\t    warning (\"expression will always cause RANGEFAIL\");\n+\t  if (range_checking)\n+\t    expr = check_expression (expr, check,\n+\t\t\t\t     ridpointers[(int) RID_RANGEFAIL]);\n+\t}\n+    }\n+  return expr;\n+}\n+\n+/* Same as EXPR, except raise EMPTY if EXPR is NULL. */\n+\n+tree\n+check_non_null (expr)\n+     tree expr;\n+{\n+  if (empty_checking)\n+    {\n+      expr = save_if_needed (expr);\n+      return check_expression (expr,\n+\t\t\t       build_compare_expr (EQ_EXPR,\n+\t\t\t\t\t\t   expr, null_pointer_node),\n+\t\t\t       ridpointers[(int) RID_EMPTY]);\n+    }\n+  return expr;\n+}\n+\f\n+/*\n+ * There are four conditions to generate a runtime check:\n+ *    1) assigning a longer INT to a shorter (signs irrelevant)\n+ *    2) assigning a signed to an unsigned\n+ *    3) assigning an unsigned to a signed of the same size.\n+ *    4) TYPE is a discrete subrange\n+ */\n+tree\n+chill_convert_for_assignment (type, expr, place)\n+     tree type, expr;\n+     char *place; /* location description for error messages */\n+{\n+  tree ttype = type;\n+  tree etype = TREE_TYPE (expr);\n+  tree result;\n+\n+  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n+  if (expr == NULL_TREE || TREE_CODE (expr) == ERROR_MARK)\n+    return expr;\n+  if (TREE_CODE (expr) == TYPE_DECL)\n+    {\n+      error (\"right hand side of assignment is a mode\");\n+      return error_mark_node;\n+    }\n+\n+  if (! CH_COMPATIBLE (expr, type))\n+    {\n+      error (\"incompatible modes in %s\", place);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    ttype = TREE_TYPE (ttype);\n+  if (etype && TREE_CODE (etype) == REFERENCE_TYPE)\n+    etype = TREE_TYPE (etype);\n+\n+  if (etype\n+      && (CH_STRING_TYPE_P (ttype)\n+\t  || (chill_varying_type_p (ttype)\n+\t      && CH_STRING_TYPE_P (CH_VARYING_ARRAY_TYPE (ttype))))\n+      && (CH_STRING_TYPE_P (etype)\n+\t  || (chill_varying_type_p (etype)\n+\t      && CH_STRING_TYPE_P (CH_VARYING_ARRAY_TYPE (etype)))))\n+    {\n+      tree cond;\n+      if (range_checking)\n+\texpr = save_if_needed (expr);\n+      cond = string_assignment_condition (ttype, expr);\n+      if (TREE_CODE (cond) == INTEGER_CST)\n+\t{\n+\t  if (integer_zerop (cond))\n+\t    {\n+\t      error (\"bad string length in %s\", place);\n+\t      return error_mark_node;\n+\t    }\n+\t  /* Otherwise, the condition is always true, so no runtime test. */\n+\t}\n+      else if (range_checking)\n+\texpr = check_expression (expr,\n+\t\t\t\t invert_truthvalue (cond),\n+\t\t\t\t ridpointers[(int) RID_RANGEFAIL]);\n+    }\n+\n+  if (range_checking \n+      && discrete_type_p (ttype) \n+      && etype != NULL_TREE\n+      && discrete_type_p (etype))\n+    {\n+      int cond1 = tree_int_cst_lt (TYPE_SIZE (ttype),\n+\t\t\t\t   TYPE_SIZE (etype));\n+      int cond2 = TREE_UNSIGNED (ttype) \n+\t          && (! TREE_UNSIGNED (etype));\n+      int cond3 = (! TREE_UNSIGNED (type))\n+\t          && TREE_UNSIGNED (etype) \n+\t\t  && tree_int_cst_equal (TYPE_SIZE (ttype),\n+\t\t\t\t\t TYPE_SIZE (etype));\n+      int cond4 = TREE_TYPE (ttype) \n+\t          && discrete_type_p (TREE_TYPE (ttype));\n+\n+      if (cond1 || cond2 || cond3 || cond4)\n+\t{\n+\t  tree type_min = TYPE_MIN_VALUE (ttype);\n+\t  tree type_max = TYPE_MAX_VALUE (ttype);\n+\n+\t  expr = save_if_needed (expr);\n+\t  if (expr && type_min && type_max)\n+\t    expr = check_range (expr, expr, type_min, type_max);\n+\t}\n+    }\n+  result = convert (type, expr);\n+\n+  /* If the type is a array of PACK bits and the expression is an array constructor,\n+     then build a CONSTRUCTOR for a bitstring.  Bitstrings are zero based, so\n+     decrement the value of each CONSTRUCTOR element by the amount of the lower\n+     bound of the array.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_PACKED (type)\n+      && TREE_CODE (result) == CONSTRUCTOR)\n+    {\n+      tree domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+      tree new_list = NULL_TREE;\n+      long index;\n+      tree element;\n+      for (element = TREE_OPERAND (result, 1);\n+\t   element != NULL_TREE;\n+\t   element = TREE_CHAIN (element))\n+\t{\n+\t  if (!tree_int_cst_equal (TREE_VALUE (element), integer_zero_node))\n+\t    {\n+\t      tree purpose = TREE_PURPOSE (element);\n+\t      switch (TREE_CODE (purpose))\n+\t\t{\n+\t\tcase INTEGER_CST:\n+\t\t  new_list = tree_cons (NULL_TREE,\n+\t\t\t\t\tsize_binop (MINUS_EXPR, purpose, domain_min),\n+\t\t\t\t\tnew_list);\n+\t\t  break;\n+\t\tcase RANGE_EXPR:\n+\t\t  for (index  = TREE_INT_CST_LOW (TREE_OPERAND (purpose, 0));\n+\t\t       index <= TREE_INT_CST_LOW (TREE_OPERAND (purpose, 1));\n+\t\t       index++)\n+\t\t    new_list = tree_cons (NULL_TREE,\n+\t\t\t\t\t  size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t      build_int_2 (index, 0),\n+\t\t\t\t\t\t      domain_min),\n+\t\t\t\t\t  new_list);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  abort ();\n+\t\t}\n+\t    }\n+\t}\n+      TREE_OPERAND (result, 1) = nreverse (new_list);\n+      TREE_TYPE (result) = build_bitstring_type (TYPE_SIZE (type));\n+    }\n+\n+  return result;\n+}\n+\f\n+/* Check that EXPR has valid type for a RETURN or RESULT expression,\n+   converting to the right type.  ACTION is \"RESULT\" or \"RETURN\". */\n+\n+static tree\n+adjust_return_value (expr, action)\n+     tree expr;\n+     char *action;\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (current_function_decl));\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      if (CH_LOCATION_P (expr))\n+\t{\n+\t  if (! CH_READ_COMPATIBLE (TREE_TYPE (type), \n+\t\t\t\t    TREE_TYPE (expr)))\n+\t    {\n+\t      error (\"mode mismatch in %s expression\", action);\n+\t      return error_mark_node;\n+\t    }\n+\t  return convert (type, expr);\n+\t}\n+      else\n+\t{\n+\t  error (\"%s expression must be referable\", action);\n+\t  return error_mark_node;\n+\t}\n+    }\n+  else if (! CH_COMPATIBLE (expr, type))\n+    {\n+      error (\"mode mismatch in %s expression\", action);\n+      return error_mark_node;\n+    }\n+  return convert (type, expr);\n+}\n+\f\n+void\n+chill_expand_result (expr, result_or_return)\n+     tree expr;\n+     int result_or_return;\n+{\n+  tree type;\n+  char *action_name = result_or_return ? \"RESULT\" : \"RETURN\";\n+  \n+  if (pass == 1)\n+    return;\n+\n+  if (expr == NULL_TREE || TREE_CODE (expr) == ERROR_MARK)\n+    return;\n+\n+  CH_FUNCTION_SETS_RESULT (current_function_decl) = 1;\n+\n+  if (chill_at_module_level || global_bindings_p ())\n+    error (\"%s not allowed outside a PROC\", action_name);\n+\n+  result_never_set = 0;\n+\n+  if (chill_result_decl == NULL_TREE)\n+    {\n+      error (\"%s action in PROC with no declared RESULTS\", action_name);\n+      return;\n+    }\n+  type = TREE_TYPE (chill_result_decl);\n+\n+  if (TREE_CODE (type) == ERROR_MARK)\n+    return;\n+\n+  expr = adjust_return_value (expr, action_name);\n+\n+  expand_expr_stmt (build_chill_modify_expr (chill_result_decl, expr));\n+}\n+\f\n+/*\n+ * error if EXPR not NULL and procedure doesn't\n+ * have a return type; \n+ * warning if EXPR NULL,\n+ * procedure *has* a return type, and a previous\n+ * RESULT actions hasn't saved a return value.\n+ */\n+void\n+chill_expand_return (expr, implicit)\n+     tree expr;\n+     int implicit; /* 1 if an implicit return at end of function. */\n+{\n+  tree valtype;\n+\n+  if (expr != NULL_TREE && TREE_CODE (expr) == ERROR_MARK)\n+    return;\n+  if (chill_at_module_level || global_bindings_p ())\n+    {\n+      error (\"RETURN not allowed outside PROC\");\n+      return;\n+    }\n+\n+  if (pass == 1)\n+    return;\n+\n+  result_never_set = 0;\n+\n+  valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n+  if (TREE_CODE (valtype) == VOID_TYPE)\n+    {\n+      if (expr != NULL_TREE)\n+\terror (\"RETURN with a value, in PROC returning void\");\n+      expand_null_return ();\n+    }\n+  else if (TREE_CODE (valtype) != ERROR_MARK)\n+    {\n+      if (expr == NULL_TREE)\n+\t{\n+\t  if (!CH_FUNCTION_SETS_RESULT (current_function_decl)\n+\t      && !implicit)\n+\t    warning (\"RETURN with no value and no RESULT action in procedure\");\n+\t  expr = chill_result_decl;\n+\t}\n+      else\n+\texpr = adjust_return_value (expr, \"RETURN\");\n+      expr = build (MODIFY_EXPR, valtype,\n+\t\t    DECL_RESULT (current_function_decl),\n+\t\t    expr);\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+      expand_return (expr);\n+    }\n+}\n+\n+void\n+lookup_and_expand_goto (name)\n+     tree name;\n+{\n+  if (name == NULL_TREE ||  TREE_CODE (name) == ERROR_MARK)\n+    return;\n+  if (!ignoring)\n+    {\n+      tree decl = lookup_name (name);\n+      if (decl == NULL || TREE_CODE (decl) != LABEL_DECL)\n+\terror (\"no label named `%s'\", IDENTIFIER_POINTER (name));\n+      else if (DECL_CONTEXT (decl) != current_function_decl)\n+\terror (\"cannot GOTO label `%s' outside current function\",\n+\t       IDENTIFIER_POINTER (name));\n+      else\n+\t{\n+\t  TREE_USED (decl) = 1;\n+\t  expand_goto_except_cleanup (DECL_ACTION_NESTING_LEVEL (decl));\n+\t  expand_goto (decl);\n+\t}\n+    }\n+}\n+\n+void\n+lookup_and_handle_exit (name)\n+     tree name;\n+{\n+  if (name == NULL_TREE ||  TREE_CODE (name) == ERROR_MARK)\n+    return;\n+  if (!ignoring)\n+    {\n+      tree label = munge_exit_label (name);\n+      tree decl = lookup_name (label);\n+      if (decl == NULL || TREE_CODE (decl) != LABEL_DECL)\n+\terror (\"no EXITable label named `%s'\", IDENTIFIER_POINTER (name));\n+      else if (DECL_CONTEXT (decl) != current_function_decl)\n+\terror (\"cannot EXIT label `%s' outside current function\",\n+\t       IDENTIFIER_POINTER (name));\n+      else\n+\t{\n+\t  TREE_USED (decl) = 1;\n+\t  expand_goto_except_cleanup (DECL_ACTION_NESTING_LEVEL (decl));\n+\t  expand_goto (decl);\n+\t}\n+    }\n+}\n+\f\n+/* ELSE-range handling: The else-range is a chain of trees which collectively\n+   represent the ranges to be tested for the (ELSE) case label. Each element in\n+   the chain represents a range to be tested. The boundaries of the range are\n+   represented by INTEGER_CST trees in the PURPOSE and VALUE fields. */\n+\n+/* This function updates the else-range by removing the given integer constant. */\n+static tree\n+update_else_range_for_int_const (else_range, label)\n+     tree else_range, label;\n+{\n+  int  lowval, highval;\n+  int  label_value = TREE_INT_CST_LOW (label);\n+  tree this_range, prev_range, new_range;\n+\n+  /* First, find the range element containing the integer, if it exists. */\n+  prev_range = NULL_TREE;\n+  for (this_range = else_range ;\n+       this_range != NULL_TREE;\n+       this_range = TREE_CHAIN (this_range))\n+    {\n+      lowval  = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n+      highval = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n+      if (label_value >= lowval && label_value <= highval)\n+\tbreak;\n+      prev_range = this_range;\n+    }\n+\n+  /* If a range element containing the integer was found, then update the range. */\n+  if (this_range != NULL_TREE)\n+    {\n+      tree next = TREE_CHAIN (this_range);\n+      if (label_value == lowval)\n+\t{\n+\t  /* The integer is the lower bound of the range element. If it is also the\n+\t     upper bound, then remove this range element, otherwise update it. */\n+\t  if (label_value == highval)\n+\t    {\n+\t      if (prev_range == NULL_TREE)\n+\t\telse_range = next;\n+\t      else\n+\t\tTREE_CHAIN (prev_range) = next;\n+\t    }\n+\t  else\n+\t    TREE_PURPOSE (this_range) = build_int_2 (label_value + 1, 0);\n+\t}\n+      else if (label_value == highval)\n+\t{\n+\t  /* The integer is the upper bound of the range element, so ajust it. */\n+\t  TREE_VALUE (this_range) = build_int_2 (label_value - 1, 0);\n+\t}\n+      else\n+\t{\n+\t  /* The integer is in the middle of the range element, so split it. */\n+\t  new_range = tree_cons (\n+            build_int_2 (label_value + 1, 0), TREE_VALUE (this_range), next);\n+\t  TREE_VALUE (this_range) = build_int_2 (label_value - 1, 0);\n+\t  TREE_CHAIN (this_range) = new_range;\n+\t}\n+    }\n+  return else_range;\n+}\n+\n+/* Update the else-range to remove a range of values/ */\n+static tree\n+update_else_range_for_range (else_range, low_target, high_target)\n+     tree else_range, low_target, high_target;\n+{\n+  tree this_range, prev_range, new_range, next_range;\n+  int  low_range_val, high_range_val;\n+  int  low_target_val  = TREE_INT_CST_LOW (low_target);\n+  int  high_target_val = TREE_INT_CST_LOW (high_target);\n+\n+  /* find the first else-range element which overlaps the target range. */\n+  prev_range = NULL_TREE;\n+  for (this_range = else_range ;\n+       this_range != NULL_TREE;\n+       this_range = TREE_CHAIN (this_range))\n+    {\n+      low_range_val  = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n+      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n+      if (low_target_val >= low_range_val && low_target_val <= high_range_val\n+\t  || high_target_val >= low_range_val && high_target_val <= high_range_val)\n+\tbreak;\n+      prev_range = this_range;\n+    }\n+  if (this_range == NULL_TREE)\n+    return else_range;\n+\n+  /* This first else-range element might be truncated at the top or completely\n+     contain the target range. */\n+  if (low_range_val < low_target_val)\n+    {\n+      next_range = TREE_CHAIN (this_range);\n+      if (high_range_val > high_target_val)\n+\t{\n+\t  new_range = tree_cons (\n+            build_int_2 (high_target_val + 1, 0), TREE_VALUE (this_range), next_range);\n+\t  TREE_VALUE (this_range) = build_int_2 (low_target_val - 1, 0);\n+\t  TREE_CHAIN (this_range) = new_range;\n+\t  return else_range;\n+\t}\n+\n+      TREE_VALUE (this_range) = build_int_2 (low_target_val - 1, 0);\n+      if (next_range == NULL_TREE)\n+\treturn else_range;\n+\n+      prev_range = this_range;\n+      this_range = next_range;\n+      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n+    }\n+\n+  /* There may then follow zero or more else-range elements which are completely\n+     contained in the target range. */\n+  while (high_range_val <= high_target_val)\n+    {\n+      this_range = TREE_CHAIN (this_range);\n+      if (prev_range == NULL_TREE)\n+\telse_range = this_range;\n+      else\n+\tTREE_CHAIN (prev_range) = this_range;\n+\n+      if (this_range == NULL_TREE)\n+\treturn else_range;\n+      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n+    }\n+\n+  /* Finally, there may be a else-range element which is truncated at the bottom. */\n+  low_range_val = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n+  if (low_range_val <= high_target_val)\n+    TREE_PURPOSE (this_range) = build_int_2 (high_target_val + 1, 0);\n+\n+  return else_range;\n+}\n+\n+static tree\n+update_else_range_for_range_expr (else_range, label)\n+     tree else_range, label;\n+{\n+  if (TREE_OPERAND (label, 0) == NULL_TREE)\n+    {\n+      if (TREE_OPERAND (label, 1) == NULL_TREE)\n+\telse_range = NULL_TREE; /* (*) -- matches everything */\n+    }\n+  else\n+    else_range = update_else_range_for_range (\n+      else_range, TREE_OPERAND (label, 0), TREE_OPERAND (label, 1));\n+\n+  return else_range;\n+}\n+\n+static tree\n+update_else_range_for_type (else_range, label)\n+     tree else_range, label;\n+{\n+  tree type = TREE_TYPE (label);\n+  else_range = update_else_range_for_range (\n+    else_range, TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type));\n+  return else_range;\n+}\n+\n+static tree\n+compute_else_range (selector, alternatives, selector_no)\n+     tree selector, alternatives;\n+     int selector_no;\n+{\n+  /* Start with an else-range that spans the entire range of the selector type. */\n+  tree type = TREE_TYPE (TREE_VALUE (selector));\n+  tree range = tree_cons (TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type), NULL_TREE);\n+\n+  /* Now remove the values represented by each case lebel specified for that\n+     selector. The remaining range is the else-range. */\n+  for ( ; alternatives != NULL_TREE; alternatives = TREE_CHAIN (alternatives))\n+    {\n+      tree label;\n+      tree label_list = TREE_PURPOSE (alternatives);\n+      int  this_selector;\n+      for (this_selector = 0; this_selector < selector_no ; ++this_selector)\n+\tlabel_list = TREE_CHAIN (label_list);\n+\n+      for (label = TREE_VALUE (label_list);\n+\t   label != NULL_TREE;\n+\t   label = TREE_CHAIN (label))\n+\t{\n+\t  tree label_value = TREE_VALUE (label);\n+\t  if (TREE_CODE (label_value) == INTEGER_CST)\n+\t    range = update_else_range_for_int_const (range, label_value);\n+\t  else if (TREE_CODE (label_value) == RANGE_EXPR)\n+\t    range = update_else_range_for_range_expr (range, label_value);\n+\t  else if (TREE_CODE (label_value) == TYPE_DECL)\n+\t    range = update_else_range_for_type (range, label_value);\n+\n+\t  if (range == NULL_TREE)\n+\t    break;\n+\t}\n+    }\n+\n+  return range;\n+}\n+\n+void\n+compute_else_ranges (selectors, alternatives)\n+     tree selectors, alternatives;\n+{\n+  tree selector;\n+  int selector_no = 0;\n+\n+  for (selector = selectors; selector != NULL_TREE; selector = TREE_CHAIN (selector))\n+    {\n+      if (ELSE_LABEL_SPECIFIED (selector))\n+\tTREE_PURPOSE (selector) =\n+\t  compute_else_range (selector, alternatives, selector_no);\n+      selector_no++;\n+    }\n+}\n+\n+static tree\n+check_case_value (label_value, selector)\n+     tree label_value, selector;\n+{\n+  if (TREE_CODE (label_value) == ERROR_MARK)\n+    return label_value;\n+  if (TREE_CODE (selector) == ERROR_MARK)\n+    return selector;    \n+\n+  /* Z.200 (6.4 Case action) says:  \"The class of any discrete expression\n+     in the case selector list must be compatible with the corresponding\n+     (by position) class of the resulting list of classes of the case label\n+     list occurrences ...\".  We don't actually construct the resulting\n+     list of classes, but this test should be more-or-less equivalent.\n+     I think... */\n+  if (!CH_COMPATIBLE_CLASSES (selector, label_value))\n+    {\n+      error (\"case selector not compatible with label\");\n+      return error_mark_node;\n+    }\n+\n+  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n+  STRIP_TYPE_NOPS (label_value);\n+\n+  if (TREE_CODE (label_value) != INTEGER_CST)\n+    {\n+      error (\"case label does not reduce to an integer constant\");\n+      return error_mark_node;\n+    }\n+\n+  constant_expression_warning (label_value);\n+  return label_value;\n+}\n+\n+void\n+chill_handle_case_default ()\n+{\n+  tree duplicate;\n+  register tree label = build_decl (LABEL_DECL, NULL_TREE, \n+\t\t\t\t    NULL_TREE);\n+  int success = pushcase (NULL_TREE, 0, label, &duplicate);\n+\n+  if (success == 1)\n+    error (\"ELSE label not within a CASE statement\");\n+#if 0\n+  else if (success == 2)\n+    {\n+      error (\"multiple default labels found in a CASE statement\"); \n+      error_with_decl (duplicate, \"this is the first ELSE label\");\n+    }\n+#endif\n+}\n+\f\n+/* Handle cases label such as (I:J):  or (modename): */\n+\n+static void\n+chill_handle_case_label_range (min_value, max_value, selector)\n+     tree min_value, max_value, selector;\n+{\n+  register tree label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+  min_value = check_case_value (min_value, selector);\n+  max_value = check_case_value (max_value, selector);\n+  if (TREE_CODE (min_value) != ERROR_MARK\n+      && TREE_CODE (max_value) != ERROR_MARK)\n+    {\n+      tree duplicate;\n+      int success = pushcase_range (min_value, max_value,\n+\t\t\t\t    convert, label, &duplicate);\n+      if (success == 1)\n+\terror (\"label found outside of CASE statement\");\n+      else if (success == 2)\n+\t{\n+\t  error (\"duplicate CASE value\");\n+\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n+\t}\n+      else if (success == 3)\n+\terror (\"CASE value out of range\");\n+      else if (success == 4)\n+\terror (\"empty range\");\n+      else if (success == 5)\n+\terror (\"label within scope of cleanup or variable array\");\n+    }\n+}\n+\n+void\n+chill_handle_case_label (label_value, selector)\n+     tree label_value, selector;\n+{\n+  if (label_value == NULL_TREE \n+      || TREE_CODE (label_value) == ERROR_MARK)\n+    return;\n+  if (TREE_CODE (label_value) == RANGE_EXPR)\n+    {\n+      if (TREE_OPERAND (label_value, 0) == NULL_TREE)\n+\tchill_handle_case_default ();  /* i.e. (ELSE): or (*): */\n+      else\n+\tchill_handle_case_label_range (TREE_OPERAND (label_value, 0),\n+\t\t\t\t       TREE_OPERAND (label_value, 1),\n+\t\t\t\t       selector);\n+    }\n+  else if (TREE_CODE (label_value) == TYPE_DECL)\n+    {\n+      tree type = TREE_TYPE (label_value);\n+      if (! discrete_type_p (type))\n+\terror (\"mode in label is not discrete\");\n+      else\n+\tchill_handle_case_label_range (TYPE_MIN_VALUE (type),\n+\t\t\t\t       TYPE_MAX_VALUE (type),\n+\t\t\t\t       selector);\n+    }\n+  else\n+    {\n+      register tree label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+      label_value = check_case_value (label_value, selector);\n+\n+      if (TREE_CODE (label_value) != ERROR_MARK)\n+\t{\n+\t  tree duplicate;\n+\t  int success = pushcase (label_value, convert, label, &duplicate);\n+\t  if (success == 1)\n+\t    error (\"label not within a CASE statement\");\n+\t  else if (success == 2)\n+\t    {\n+\t      error (\"duplicate case value\");\n+\t      error_with_decl (duplicate, \n+\t\t\t       \"this is the first entry for that value\");\n+\t    }\n+\t  else if (success == 3)\n+\t    error (\"CASE value out of range\");\n+\t  else if (success == 4)\n+\t    error (\"empty range\");\n+\t  else if (success == 5)\n+\t    error (\"label within scope of cleanup or variable array\");\n+        }\n+    }\n+}\n+\n+int\n+chill_handle_single_dimension_case_label (\n+  selector, label_spec, expand_exit_needed, caseaction_flag\n+)\n+  tree selector, label_spec;\n+  int *expand_exit_needed, *caseaction_flag;\n+{\n+  tree labels, one_label;\n+  int  no_completeness_check = 0;\n+\n+  if (*expand_exit_needed || *caseaction_flag == 1)\n+    {\n+      expand_exit_something ();\n+      *expand_exit_needed = 0;\n+    }\n+\n+  for (labels = label_spec; labels != NULL_TREE; labels = TREE_CHAIN (labels))\n+    for (one_label = TREE_VALUE (labels); one_label != NULL_TREE;\n+         one_label = TREE_CHAIN (one_label))\n+      {\n+        if (TREE_VALUE (one_label) == case_else_node)\n+          no_completeness_check = 1;\n+\n+        chill_handle_case_label (TREE_VALUE (one_label), selector);\n+      }\n+\n+  *caseaction_flag = 1;\n+\n+  return no_completeness_check;\n+}\n+\n+static tree\n+chill_handle_multi_case_label_range (low, high, selector)\n+  tree low, high, selector;\n+{\n+  tree low_expr, high_expr, and_expr;\n+  tree selector_type;\n+  int  low_target_val, high_target_val;\n+  int  low_type_val, high_type_val;\n+\n+  /* we can eliminate some tests is the low and/or high value in the given range\n+     are outside the range of the selector type. */\n+  low_target_val  = TREE_INT_CST_LOW (low);\n+  high_target_val = TREE_INT_CST_LOW (high);\n+  selector_type   = TREE_TYPE (selector);\n+  low_type_val    = TREE_INT_CST_LOW (TYPE_MIN_VALUE (selector_type));\n+  high_type_val   = TREE_INT_CST_LOW (TYPE_MAX_VALUE (selector_type));\n+\n+  if (low_target_val > high_type_val || high_target_val < low_type_val)\n+    return boolean_false_node; /* selector never in range */\n+\n+  if (low_type_val >= low_target_val)\n+    {\n+      if (high_type_val <= high_target_val)\n+\treturn boolean_true_node; /* always in the range */\n+      return build_compare_expr (LE_EXPR, selector, high);\n+    }\n+\n+  if (high_type_val <= high_target_val)\n+    return build_compare_expr (GE_EXPR, selector, low);\n+\n+  /* The target range in completely within the range of the selector, but we\n+     might be able to save a test if the upper bound is the same as the lower\n+     bound. */\n+  if (low_target_val == high_target_val)\n+    return build_compare_expr (EQ_EXPR, selector, low);\n+\n+  /* No optimizations possible. Just generate tests against the upper and lower\n+     bound of the target */\n+  low_expr  = build_compare_expr (GE_EXPR, selector, low);\n+  high_expr = build_compare_expr (LE_EXPR, selector, high);\n+  and_expr  = build_chill_binary_op (TRUTH_ANDIF_EXPR, low_expr, high_expr);\n+\n+  return and_expr;\n+}\n+\n+static tree\n+chill_handle_multi_case_else_label (selector)\n+     tree selector;\n+{\n+  tree else_range, selector_value, selector_type;\n+  tree low, high, larg;\n+\n+  else_range = TREE_PURPOSE (selector);\n+  if (else_range == NULL_TREE)\n+    return boolean_false_node; /* no values in ELSE range */\n+\n+  /* Test each of the ranges in the else-range chain */\n+  selector_value = TREE_VALUE (selector);\n+  selector_type  = TREE_TYPE (selector_value);\n+  low  = convert (selector_type, TREE_PURPOSE (else_range));\n+  high = convert (selector_type, TREE_VALUE (else_range));\n+  larg = chill_handle_multi_case_label_range (low, high, selector_value);\n+\n+  for (else_range = TREE_CHAIN (else_range);\n+       else_range != NULL_TREE;\n+       else_range = TREE_CHAIN (else_range))\n+    {\n+      tree rarg;\n+      low  = convert (selector_type, TREE_PURPOSE (else_range));\n+      high = convert (selector_type, TREE_VALUE (else_range));\n+      rarg = chill_handle_multi_case_label_range (low, high, selector_value);\n+      larg = build_chill_binary_op (TRUTH_ORIF_EXPR, larg, rarg);\n+    }\n+\n+  return larg;\n+}\n+\n+static tree\n+chill_handle_multi_case_label (selector, label)\n+  tree selector, label;\n+{\n+  tree expr;\n+\n+  if (label == NULL_TREE || TREE_CODE (label) == ERROR_MARK)\n+    return;\n+\n+  if (TREE_CODE (label) == INTEGER_CST)\n+    {\n+      int  target_val = TREE_INT_CST_LOW (label);\n+      tree selector_type = TREE_TYPE (TREE_VALUE (selector));\n+      int  low_type_val  = TREE_INT_CST_LOW (TYPE_MIN_VALUE (selector_type));\n+      int  high_type_val = TREE_INT_CST_LOW (TYPE_MAX_VALUE (selector_type));\n+      if (target_val < low_type_val || target_val > high_type_val)\n+\texpr = boolean_false_node;\n+      else\n+\texpr = build_compare_expr (EQ_EXPR, TREE_VALUE (selector), label);\n+    }\n+  else if (TREE_CODE (label) == RANGE_EXPR)\n+    {\n+      if (TREE_OPERAND (label, 0) == NULL_TREE)\n+\t{\n+\t  if (TREE_OPERAND (label, 1) == NULL_TREE)\n+\t    expr = boolean_true_node; /* (*) -- matches everything */\n+\t  else\n+\t    expr = chill_handle_multi_case_else_label (selector);\n+\t}\n+      else\n+\t{\n+\t  tree low = TREE_OPERAND (label, 0);\n+\t  tree high = TREE_OPERAND (label, 1);\n+\t  if (TREE_CODE (low) != INTEGER_CST)\n+\t    {\n+\t      error (\"Lower bound of range must be a discrete literal expression\");\n+\t      expr = error_mark_node;\n+\t    }\n+\t  if (TREE_CODE (high) != INTEGER_CST)\n+\t    {\n+\t      error (\"Upper bound of range must be a discrete literal expression\");\n+\t      expr = error_mark_node;\n+\t    }\n+\t  if (expr != error_mark_node)\n+\t    {\n+\t      expr = chill_handle_multi_case_label_range (\n+                       low, high, TREE_VALUE (selector));\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (label) == TYPE_DECL)\n+    {\n+      tree type = TREE_TYPE (label);\n+      if (! discrete_type_p (type))\n+\t{\n+\t  error (\"mode in label is not discrete\");\n+\t  expr = error_mark_node;\n+\t}\n+      else\n+\texpr = chill_handle_multi_case_label_range (\n+\t\t TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type), TREE_VALUE (selector));\n+    }\n+  else\n+    {\n+      error (\"The CASE label is not valid\");\n+      expr = error_mark_node;\n+    }\n+\n+  return expr;\n+}\n+\n+static tree\n+chill_handle_multi_case_label_list (selector, labels)\n+  tree selector, labels;\n+{\n+  tree one_label, selector_value, larg, rarg;\n+\n+  one_label = TREE_VALUE (labels);\n+  larg = chill_handle_multi_case_label (selector, TREE_VALUE (one_label));\n+\n+  for (one_label = TREE_CHAIN (one_label);\n+       one_label != NULL_TREE;\n+       one_label = TREE_CHAIN (one_label))\n+    {\n+      rarg = chill_handle_multi_case_label (selector, TREE_VALUE (one_label));\n+      larg = build_chill_binary_op (TRUTH_ORIF_EXPR, larg, rarg);\n+    }\n+\n+  return larg;\n+}\n+\n+tree\n+build_multi_case_selector_expression (selector_list, label_spec)\n+  tree selector_list, label_spec;\n+{\n+  tree labels, selector, larg, rarg;\n+\n+  labels   = label_spec;\n+  selector = selector_list;\n+  larg = chill_handle_multi_case_label_list(selector, labels);\n+\n+  for (labels = TREE_CHAIN (labels), selector = TREE_CHAIN (selector);\n+       labels != NULL_TREE && selector != NULL_TREE;\n+       labels = TREE_CHAIN (labels), selector = TREE_CHAIN (selector))\n+    {\n+      rarg = chill_handle_multi_case_label_list(selector, labels);\n+      larg = build_chill_binary_op (TRUTH_ANDIF_EXPR, larg, rarg);\n+    }\n+\n+  if (labels != NULL_TREE || selector != NULL_TREE)\n+    error (\"The number of CASE selectors does not match the number of CASE label lists\");\n+\n+  return larg;\n+}\n+\n+#define BITARRAY_TEST(ARRAY, INDEX) \\\n+  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  & (1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR)))\n+#define BITARRAY_SET(ARRAY, INDEX) \\\n+  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  |= 1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR))\n+\n+extern HOST_WIDE_INT all_cases_count PROTO((tree, int*));\n+extern void mark_seen_cases PROTO((tree, unsigned char*, long, int));\n+\n+/* CASES_SEEN is a set (bitarray) of length COUNT.\n+   For each element that is zero, print an error message,\n+   assume the element have the given TYPE. */\n+\n+static void\n+print_missing_cases (type, cases_seen, count)\n+     tree type;\n+     unsigned char *cases_seen;\n+     long count;\n+{\n+  long i;\n+  for (i = 0;  i < count; i++)\n+    {\n+      if (BITARRAY_TEST(cases_seen, i) == 0)\n+\t{\n+\t  char buf[20];\n+\t  long x = i;\n+\t  long j;\n+\t  tree t = type;\n+\t  char *err_val_name = \"???\";\n+\t  if (TYPE_MIN_VALUE (t)\n+\t      && TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST)\n+\t    x += TREE_INT_CST_LOW (TYPE_MIN_VALUE (t));\n+\t  while (TREE_TYPE (t) != NULL_TREE)\n+\t    t = TREE_TYPE (t);\n+\t  switch (TREE_CODE (t))\n+\t    {\n+\t      tree v;\n+\t    case BOOLEAN_TYPE:\n+\t      err_val_name = x ? \"TRUE\" : \"FALSE\";\n+\t      break;\n+\t    case CHAR_TYPE:\n+\t      if ((x >= ' ' && x < 127) && x != '\\'' && x != '^')\n+\t\tsprintf (buf, \"'%c'\", x);\n+\t      else\n+\t\tsprintf (buf, \"'^(%d)'\", x);\n+\t      err_val_name = buf;\n+\t      j = i;\n+\t      while (j < count && !BITARRAY_TEST(cases_seen, j))\n+\t\tj++;\n+\t      if (j > i + 1)\n+\t\t{\n+\t\t  long y = x+j-i-1;\n+\t\t  err_val_name += strlen (err_val_name);\n+\t\t  if ((y >= ' ' && y < 127) && y != '\\'' && y != '^')\n+\t\t    sprintf (err_val_name, \"%s:'%c'\", buf, y);\n+\t\t  else\n+\t\t    sprintf (err_val_name, \"%s:'^(%d)'\", buf, y);\n+\t\t  i = j - 1;      \n+\t\t}\n+\t      break;\n+\t    case ENUMERAL_TYPE:\n+\t      for (v = TYPE_VALUES (t);  v && x;  v = TREE_CHAIN (v))\n+\t\tx--;\n+\t      if (v)\n+\t\terr_val_name = IDENTIFIER_POINTER (TREE_PURPOSE (v));\n+\t      break;\n+\t    default:\n+\t      j = i;\n+\t      while (j < count && !BITARRAY_TEST(cases_seen, j))\n+\t\tj++;\n+\t      if (j == i + 1)\n+\t\tsprintf (buf, \"%d\", x);\n+\t      else\n+\t\tsprintf (buf, \"%d:%d\", x, x+j-i-1);\n+\t      i = j - 1;      \n+\t      err_val_name = buf;\n+\t      break;\n+\t    }\n+\t  error (\"incomplete CASE - %s not handled\", err_val_name);\n+\t}\n+    }\n+}\n+\n+void\n+check_missing_cases (type)\n+     tree type;\n+{\n+  int is_sparse;\n+  /* For each possible selector value. a one iff it has been matched\n+     by a case value alternative. */\n+  unsigned char *cases_seen;\n+  /* The number of possible selector values. */\n+  HOST_WIDE_INT size = all_cases_count (type, &is_sparse);\n+  long bytes_needed = (size+HOST_BITS_PER_CHAR)/HOST_BITS_PER_CHAR;\n+\n+  if (size == -1)\n+    warning (\"CASE selector with variable range\");\n+  else if (size < 0 || size > 600000\n+\t   /* We deliberately use malloc here - not xmalloc. */\n+\t   || (cases_seen = (char*) malloc (bytes_needed)) == NULL)\n+    warning (\"too many cases to do CASE completeness testing\");\n+  else\n+    {\n+      bzero (cases_seen, bytes_needed);\n+      mark_seen_cases (type, cases_seen, size, is_sparse);\n+      print_missing_cases (type, cases_seen, size);\n+      free (cases_seen);\n+    }\n+}\n+\n+/*\n+ * We build an expression tree here because, in many contexts,\n+ * we don't know the type of result that's desired.  By the\n+ * time we get to expanding the tree, we do know.\n+ */\n+tree\n+build_chill_case_expr (exprlist, casealtlist_expr,\n+\t\t       optelsecase_expr)\n+     tree exprlist, casealtlist_expr, optelsecase_expr;\n+{\n+  return build (CASE_EXPR, NULL_TREE, exprlist,\n+\t\toptelsecase_expr ?\n+\t\t  tree_cons (NULL_TREE,\n+\t\t\t     optelsecase_expr,\n+\t\t\t     casealtlist_expr) :\n+\t\t  casealtlist_expr);\n+}\n+\n+/* This function transforms the selector_list and alternatives into a COND_EXPR. */\n+tree\n+build_chill_multi_dimension_case_expr (selector_list, alternatives, else_expr)\n+  tree selector_list, alternatives, else_expr;\n+{\n+  tree expr;\n+\n+  selector_list = check_case_selector_list (selector_list);\n+\n+  if (alternatives == NULL_TREE)\n+    return NULL_TREE;\n+\n+  alternatives = nreverse (alternatives);\n+  /* alternatives represents the CASE label specifications and resulting values in\n+     the reverse order in which they appeared.\n+     If there is an ELSE expression, then use it. If there is no\n+     ELSE expression, make the last alternative (which is the first in the list)\n+     into the ELSE expression. This is safe because, if the CASE is complete\n+     (as required), then the last condition need not be checked anyway. */\n+  if (else_expr != NULL_TREE)\n+    expr = else_expr;\n+  else\n+    {\n+      expr = TREE_VALUE (alternatives);\n+      alternatives = TREE_CHAIN (alternatives);\n+    }\n+\n+  for ( ; alternatives != NULL_TREE; alternatives = TREE_CHAIN (alternatives))\n+    { \n+      tree value  = TREE_VALUE (alternatives);\n+      tree labels = TREE_PURPOSE (alternatives);\n+      tree cond   = build_multi_case_selector_expression(selector_list, labels);\n+      expr = build_nt (COND_EXPR, cond, value, expr);\n+    }\n+\n+  return expr;\n+}\n+\n+\f\n+/* This is called with the assumption that RHS has been stabilized.  \n+   It has one purpose:  to iterate through the CHILL list of LHS's */\n+void\n+expand_assignment_action (loclist, modifycode, rhs)\n+     tree loclist;\n+     enum chill_tree_code modifycode;\n+     tree rhs;\n+{\n+  if (loclist == NULL_TREE || TREE_CODE (loclist) == ERROR_MARK\n+      || rhs == NULL_TREE  || TREE_CODE (rhs) == ERROR_MARK)\n+    return;\n+\n+  if (TREE_CHAIN (loclist) != NULL_TREE)\n+    { /* Multiple assignment */\n+      tree target;\n+      if (TREE_TYPE (rhs) != NULL_TREE)\n+\trhs = save_expr (rhs);\n+      else if (TREE_CODE (rhs) == CONSTRUCTOR)\n+\terror (\"type of tuple cannot be implicit in multiple assignent\");\n+      else if (TREE_CODE (rhs) == CASE_EXPR || TREE_CODE (rhs) == COND_EXPR)\n+\terror (\"conditional expression cannot be used in multiple assignent\");\n+      else\n+\terror (\"internal error - unknown type in multiple assignment\");\n+\n+      if (modifycode != NOP_EXPR)\n+\t{\n+\t  error (\"no operator allowed in multiple assignment,\");\n+\t  modifycode = NOP_EXPR;\n+\t}\n+\n+      for (target = TREE_CHAIN (loclist); target; target = TREE_CHAIN (target))\n+\t{\n+\t  if (!CH_EQUIVALENT (TREE_TYPE (TREE_VALUE (target)),\n+\t\t\t      TREE_TYPE (TREE_VALUE (loclist))))\n+\t    {\n+\t      error\n+\t\t(\"location modes in multiple assignment are not equivalent\");\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  for ( ; loclist != NULL_TREE; loclist = TREE_CHAIN (loclist))\n+    chill_expand_assignment (TREE_VALUE (loclist), modifycode, rhs);\n+}\n+\n+void\n+chill_expand_assignment (lhs, modifycode, rhs)\n+     tree lhs;\n+     enum chill_tree_code modifycode;\n+     tree rhs;\n+{\n+  tree loc;\n+\n+  while (TREE_CODE (lhs) == COMPOUND_EXPR)\n+    {\n+      expand_expr (TREE_OPERAND (lhs, 0), const0_rtx, VOIDmode, 0);\n+      emit_queue ();\n+      lhs = TREE_OPERAND (lhs, 1);\n+    }\n+\n+  if (TREE_CODE (lhs) == ERROR_MARK)\n+    return;\n+\n+  /* errors for assignment to BUFFER, EVENT locations.\n+     what about SIGNALs? FIXME: Need similar test in\n+     build_chill_function_call. */\n+  if (TREE_CODE (lhs) == IDENTIFIER_NODE)\n+    {\n+      tree decl = lookup_name (lhs);\n+      if (decl)\n+\t{\n+\t  tree type = TREE_TYPE (decl);\n+\t  if (CH_IS_BUFFER_MODE (type) || CH_IS_EVENT_MODE (type))\n+\t    {\n+\t      error (\"You may not assign a value to a BUFFER or EVENT location\");\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (TYPE_READONLY_PROPERTY (TREE_TYPE (lhs)) || TREE_READONLY (lhs))\n+    {\n+      error (\"can't assign value to READonly location\");\n+      return;\n+    }\n+  if (CH_TYPE_NONVALUE_P (TREE_TYPE (lhs)))\n+    {\n+      error (\"cannot assign to location with non-value property\");\n+      return;\n+    }\n+\n+  if (TREE_CODE (TREE_TYPE (lhs)) == REFERENCE_TYPE)\n+    lhs = convert_from_reference (lhs);\n+\n+  /* check for lhs is a location */\n+  loc = lhs;\n+  while (1)\n+    {\n+      if (TREE_CODE (loc) == SLICE_EXPR)\n+\tloc = TREE_OPERAND (loc, 0);\n+      else if (TREE_CODE (loc) == SET_IN_EXPR)\n+\tloc = TREE_OPERAND (loc, 1);\n+      else\n+\tbreak;\n+    }\n+  if (! CH_LOCATION_P (loc))\n+    {\n+      error (\"lefthand side of assignment is not a location\");\n+      return;\n+    }\n+\n+  /* If a binary op has been requested, combine the old LHS value with\n+     the RHS producing the value we should actually store into the LHS. */\n+\n+  if (modifycode != NOP_EXPR)\n+    {\n+      lhs = stabilize_reference (lhs);\n+      /* This is to handle border-line cases such\n+\t as: LHS OR := [I].  This seems to be permitted\n+\t by the letter of Z.200, though it violates\n+\t its spirit, since LHS:=LHS OR [I] is\n+\t *not* legal. */\n+      if (TREE_TYPE (rhs) == NULL_TREE)\n+\trhs = convert (TREE_TYPE (lhs), rhs);\n+      rhs = build_chill_binary_op (modifycode, lhs, rhs);\n+    }\n+\n+  rhs = chill_convert_for_assignment (TREE_TYPE (lhs), rhs, \"assignment\");\n+\n+  /* handle the LENGTH (vary_array) := expr action */\n+  loc = lhs;\n+  if (TREE_CODE (loc) == NOP_EXPR)\n+    loc = TREE_OPERAND (loc, 0);\n+  if (TREE_CODE (loc) == COMPONENT_REF\n+      && chill_varying_type_p (TREE_TYPE (TREE_OPERAND (loc, 0)))\n+      && DECL_NAME (TREE_OPERAND (loc, 1)) == var_length_id)\n+    {\n+      expand_varying_length_assignment (TREE_OPERAND (loc, 0), rhs);\n+    }\n+  else if (TREE_CODE (lhs) == SLICE_EXPR)\n+    {\n+      tree func = lookup_name (get_identifier (\"__pscpy\"));\n+      tree dst = TREE_OPERAND (lhs, 0);\n+      tree dst_offset = TREE_OPERAND (lhs, 1);\n+      tree length = TREE_OPERAND (lhs, 2);\n+      tree src, src_offset;\n+      if (TREE_CODE (rhs) == SLICE_EXPR)\n+\t{\n+\t  src = TREE_OPERAND (rhs, 0);\n+\t  /* Should check that the TREE_OPERAND (src, 0) is\n+\t     the same as length and powerserlen (src).  FIXME */\n+\t  src_offset = TREE_OPERAND (rhs, 1);\n+\t}\n+      else\n+\t{\n+\t  src = rhs;\n+\t  src_offset = integer_zero_node;\n+\t}\n+      expand_expr_stmt (build_chill_function_call (func,\n+\ttree_cons (NULL_TREE, force_addr_of (dst),\n+\t  tree_cons (NULL_TREE, powersetlen (dst),\n+\t    tree_cons (NULL_TREE, convert (long_unsigned_type_node, dst_offset),\n+\t      tree_cons (NULL_TREE, force_addr_of (src),\n+\t\ttree_cons (NULL_TREE, powersetlen (src),\n+\t\t  tree_cons (NULL_TREE, convert (long_unsigned_type_node, src_offset),\n+\t\t    tree_cons (NULL_TREE, convert (long_unsigned_type_node, length),\n+\t\t       NULL_TREE)))))))));\n+    }\n+\n+  else if (TREE_CODE (lhs) == SET_IN_EXPR)\n+    {\n+      tree from_pos = save_expr (TREE_OPERAND (lhs, 0));\n+      tree set = TREE_OPERAND (lhs, 1);\n+      tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n+      tree set_length = size_binop (PLUS_EXPR,\n+\t\t\t\t    size_binop (MINUS_EXPR,\n+\t\t\t\t\t\tTYPE_MAX_VALUE (domain),\n+\t\t\t\t\t\tTYPE_MIN_VALUE (domain)),\n+\t\t\t\t    integer_one_node);\n+      tree filename = force_addr_of (get_chill_filename());\n+      \n+      if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n+\tsorry(\"bitstring slice\");\n+      expand_expr_stmt (\n+\tbuild_chill_function_call (lookup_name (\n+\t  get_identifier (\"__setbitpowerset\")),\n+\t      tree_cons (NULL_TREE, build_chill_addr_expr (set, \"powerset\"),\n+\t\t  tree_cons (NULL_TREE, set_length,\n+\t\t    tree_cons (NULL_TREE, TYPE_MIN_VALUE (domain),\n+\t\t      tree_cons (NULL_TREE, convert (long_integer_type_node, from_pos),\n+\t\t\ttree_cons (NULL_TREE, rhs,\n+\t\t\t  tree_cons (NULL_TREE, filename,\n+\t\t\t    tree_cons (NULL_TREE, get_chill_linenumber(),\n+  \t\t\t      NULL_TREE)))))))));\n+    }\n+\n+  /* Handle arrays of packed bitfields. Currently, this is limited to bitfields\n+     which are 1 bit wide, so use the powerset runtime function. */\n+  else if (TREE_CODE (lhs) == PACKED_ARRAY_REF)\n+    {\n+      tree from_pos = save_expr (TREE_OPERAND (lhs, 1));\n+      tree array = TREE_OPERAND (lhs, 0);\n+      tree domain = TYPE_DOMAIN (TREE_TYPE (array));\n+      tree array_length = size_binop (PLUS_EXPR,\n+\t\t\t\t    size_binop (MINUS_EXPR,\n+\t\t\t\t\t\tTYPE_MAX_VALUE (domain),\n+\t\t\t\t\t\tTYPE_MIN_VALUE (domain)),\n+\t\t\t\t    integer_one_node);\n+      tree filename = force_addr_of (get_chill_filename());\n+      expand_expr_stmt (\n+\tbuild_chill_function_call (lookup_name (\n+\t  get_identifier (\"__setbitpowerset\")),\n+            tree_cons (NULL_TREE, build_chill_addr_expr (array, \"packed bitfield array\"),\n+\t\ttree_cons (NULL_TREE, convert (long_unsigned_type_node, array_length),\n+\t\t  tree_cons (NULL_TREE, convert (long_integer_type_node,\n+\t\t\t\t\t\t TYPE_MIN_VALUE (domain)),\n+\t\t    tree_cons (NULL_TREE, convert (long_integer_type_node, from_pos),\n+\t\t      tree_cons (NULL_TREE, build1 (CONVERT_EXPR, boolean_type_node, rhs),\n+\t\t\ttree_cons (NULL_TREE, filename,\n+\t\t\t  tree_cons (NULL_TREE, get_chill_linenumber(),\n+  \t\t\t    NULL_TREE)))))))));\n+    }\n+\n+  /* The following is probably superceded by the\n+     above code for SET_IN_EXPR. FIXME! */\n+  else if (TREE_CODE (lhs) == BIT_FIELD_REF)\n+    {\n+      tree set = TREE_OPERAND (lhs, 0);\n+      tree numbits = TREE_OPERAND (lhs, 1);\n+      tree from_pos = save_expr (TREE_OPERAND (lhs, 2));\n+      tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n+      tree set_length = size_binop (PLUS_EXPR,\n+\t\t\t\t    size_binop (MINUS_EXPR,\n+\t\t\t\t\t\tTYPE_MAX_VALUE (domain),\n+\t\t\t\t\t\tTYPE_MIN_VALUE (domain)),\n+\t\t\t\t    integer_one_node);\n+      tree filename = force_addr_of (get_chill_filename());\n+      tree to_pos;\n+      switch (TREE_CODE (TREE_TYPE (rhs)))\n+\t{\n+\tcase SET_TYPE:\n+\t  to_pos = size_binop (MINUS_EXPR,\n+\t\t\t       size_binop (PLUS_EXPR, from_pos, numbits),\n+\t\t\t       integer_one_node);\n+\t  break;\n+\tcase BOOLEAN_TYPE:\n+\t  to_pos = from_pos;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      \n+      if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n+\tsorry(\"bitstring slice\");\n+      expand_expr_stmt (\n+\t  build_chill_function_call( lookup_name (\n+\t      get_identifier (\"__setbitpowerset\")),\n+\t\ttree_cons (NULL_TREE, build_chill_addr_expr (set, \"powerset\"),\n+\t\t  tree_cons (NULL_TREE, set_length,\n+\t\t    tree_cons (NULL_TREE, TYPE_MIN_VALUE (domain),\n+\t\t      tree_cons (NULL_TREE, from_pos,\n+\t\t\ttree_cons (NULL_TREE, rhs,\n+\t\t\t  tree_cons (NULL_TREE, filename,\n+\t\t\t    tree_cons (NULL_TREE, get_chill_linenumber(),\n+\t  \t\t      NULL_TREE)))))))));\n+    }\n+\n+  else\n+    expand_expr_stmt (build_chill_modify_expr (lhs, rhs));\n+}\n+\f\n+/* Also assumes that rhs has been stabilized */\n+void\n+expand_varying_length_assignment (lhs, rhs)\n+     tree lhs, rhs;\n+{\n+  tree base_array, min_domain_val;\n+\n+  pedwarn (\"LENGTH on left-hand-side is non-portable\");\n+      \n+  if (! CH_LOCATION_P (lhs))\n+    {\n+      error (\"Can only set LENGTH of array location\");\n+      return;\n+    }\n+\n+  /* cause a RANGE exception if rhs would cause a 'hole' in the array. */\n+  rhs = valid_array_index_p (lhs, rhs, \"new array length too large\", 1);\n+\n+  base_array     = CH_VARYING_ARRAY_TYPE (TREE_TYPE (lhs));\n+  min_domain_val = TYPE_MIN_VALUE (TYPE_DOMAIN (base_array));\n+\n+  lhs = build_component_ref (lhs, var_length_id);\n+  rhs = size_binop (MINUS_EXPR, rhs, min_domain_val);\n+\n+  expand_expr_stmt (build_chill_modify_expr (lhs, rhs));\n+}\n+\f\n+void\n+push_action ()\n+{\n+  push_handler ();\n+  if (ignoring)\n+    return;\n+  emit_line_note (input_filename, lineno);\n+}"}, {"sha": "62b73d5f961b660a3145b06c9d8fb33ef7a7c281", "filename": "gcc/ch/chill.in", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fchill.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fchill.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fchill.in?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,130 @@\n+#!/bin/sh\n+# Compile GNU Chill programs.\n+: || exec /bin/sh -f $0 $argv:q\n+\n+# The compiler name might be different when doing cross-compilation\n+# (this should be configured)\n+gcc_name=gcc\n+whatgcc=gcc\n+speclang=-xnone\n+startfile=chillrt0\n+gnuchill_script_flags=\n+gnuchill_version=unknown\n+extraflags=\n+\n+# replace the command name by the name of the new command\n+progname=`basename $0`\n+case \"$0\" in\n+  */*)\n+    gcc=`echo $0 | sed -e \"s;/[^/]*$;;\"`/$gcc_name\n+    ;;\n+  *)\n+    gcc=$gcc_name\n+    ;;\n+esac\n+\n+# $first is yes for first arg, no afterwards.\n+first=yes\n+# If next arg is the argument of an option, $quote is non-empty.\n+# More precisely, it is the option that wants an argument.\n+quote=\n+# $library is made empty to disable use of libchill.\n+library=\"-lchill\"\n+libpath=chillrt\n+numargs=$#\n+\n+for arg\n+do\n+  if [ $first = yes ]\n+  then\n+    # Need some 1st arg to `set' which does not begin with `-'.\n+    # We get rid of it after the loop ends.\n+    set gcc\n+    first=no\n+  fi\n+  # If you have to ask what this does, you should not edit this file. :-)\n+  # The ``S'' at the start is so that echo -nostdinc does not eat the\n+  # -nostdinc.\n+  arg=`echo \"S$arg\" | sed \"s/^S//; s/'/'\\\\\\\\\\\\\\\\''/g\"`\n+  if [ x$quote != x ]\n+  then\n+    quote=\n+  else\n+    quote=\n+    case $arg in\n+      -nostdlib)\n+\t# Inhibit linking with -lchill.\n+\tlibrary=\n+\tlibpath=\n+\tstartfile=\n+\t;;\n+      -B*)\n+\tgcc=`echo $arg | sed -e \"s/^-B//\"`$gcc_name\n+\t;;\n+      -[bBVDUoeTuIYmLiA] | -Tdata | -Xlinker)\n+\t# these switches take following word as argument,\n+\t# so don't treat it as a file name.\n+\tquote=$arg\n+\t;;\n+      -[cSEM] | -MM)\n+\t# Don't specify libraries if we won't link,\n+\t# since that would cause a warning.\n+\tlibrary=\n+\tlibpath=\n+\tstartfile=\n+\t;;\n+      -x*)\n+\tspeclang=$arg\n+\t;;\n+      -v)\n+\t# catch `chill -v'\n+\tif [ $numargs = 1 ] ; then\n+\t  library=\n+\t  libpath=\n+\t  startfile=\n+\tfi\n+\techo \"GNUCHILL version $gnuchill_version\"\n+\t;;\n+      -fgrant-only | -fchill-grant-only)\n+        #inhibit production of an object file\n+        extraflags=\"-S -o /dev/null\"\n+\tlibrary=\n+\tlibpath=\n+\tstartfile=\n+        ;;\n+      -*)\n+\t# Pass other options through; they don't need -x and aren't inputs.\n+\t;;\n+      *)\n+\t# If file ends in .i, put options around it.\n+\t# But not if a specified -x option is currently active.\n+\tcase \"$speclang $arg\" in -xnone\\ *.[i])\n+\t  set \"$@\" -xchill \"'$arg'\" -xnone\n+\t  continue\n+\tesac\n+\t;;\n+    esac\n+  fi\n+  set \"$@\" \"'$arg'\"\n+done\n+\n+# Get rid of that initial 1st arg\n+if [ $first = no ]; then\n+  shift\n+else\n+  echo \"$0: No input files specified.\"\n+  exit 1\n+fi\n+\n+if [ x$quote != x ]\n+then\n+  echo \"$0: argument to \\`$quote' missing\"\n+  exit 1\n+fi\n+\n+# The '-ansi' flag prevents cpp from changing this:\n+#  NEWMODE x = SET (sun, mon, thu, wed, thu, fri, sat);\n+#to this:\n+#  NEWMODE x = SET (1, mon, thu, wed, thu, fri, sat);\n+#which is a CHILL syntax error.\n+eval $whatgcc -ansi $gnuchill_script_flags $startfile \"$@\" $libpath $library $extraflags"}, {"sha": "48be2d9488d25a5bf99fe1337dacb7fc64f3222e", "filename": "gcc/ch/config-lang.in", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconfig-lang.in?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,34 @@\n+# Top level configure fragment for GNU CHILL.\n+#   Copyright (C) 1994 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+# stagestuff\t- files to add to $(STAGESTUFF)\n+# diff_excludes\t- files to ignore when building diffs between two versions.\n+\n+language=\"CHILL\"\n+\n+compilers=\"cc1chill\"\n+\n+stagestuff=\"chill chill-cross cc1chill\"\n+\n+diff_excludes=\"-x -x ch/chill.info*\""}, {"sha": "1179770cd48d09a06c43ed021bfe4cec4607ed93", "filename": "gcc/ch/configure", "status": "added", "additions": 644, "deletions": 0, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconfigure?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,644 @@\n+#!/bin/sh\n+# Configuration script for GNU CHILL\n+#   Copyright (C) 1994 Free Software Foundation, Inc.\n+\n+#This file is part of GNU CC.\n+\n+#GNU CC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 2, or (at your option)\n+#any later version.\n+\n+#GNU CC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GNU CC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+#\n+# Shell script to create proper links to machine-dependent files in\n+# preparation for compiling gcc.\n+#\n+# Options: --srcdir=DIR\t\tspecifies directory where sources are.\n+# \t   --host=HOST\t\tspecifies host configuration.\n+#\t   --target=TARGET\tspecifies target configuration.\n+#\t   --build=TARGET\tspecifies configuration of machine you are\n+#\t\t\t\tusing to compile GCC.\n+#\t   --prefix=DIR\t\tspecifies directory to install in.\n+#\t   --local-prefix=DIR\tspecifies directory to put local ./include in.\n+#\t   --exec-prefix=DIR\tspecifies directory to install executables in.\n+#\t   --with-gnu-ld\tarrange to work with GNU ld.\n+#\t   --with-gnu-as\tarrange to work with GAS.\n+#\t   --with-stabs\t\tarrange to use stabs instead of host debug format.\n+#\t   --with-elf\t\tarrange to use elf instead of host debug format.\n+#\t   --nfp\t\tassume system has no FPU.\n+#\n+# If configure succeeds, it leaves its status in config.status.\n+# If configure fails after disturbing the status quo, \n+# \tconfig.status is removed.\n+#\n+\n+progname=$0\n+# Configure the runtime and regression-test directories\n+SUBDIRS=\"runtime utils\"\n+SUBDIRS=\"$SUBDIRS testsuite/compile\"\n+SUBDIRS=\"$SUBDIRS testsuite/execute\"\n+SUBDIRS=\"$SUBDIRS testsuite/execute/telebras\"\n+SUBDIRS=\"$SUBDIRS testsuite/noncompile\"\n+SUBDIRS=\"$SUBDIRS testsuite/examples\"\n+SUBDIRS=\"$SUBDIRS testsuite/execute/oe\"\n+SUBDIRS=\"$SUBDIRS testsuite/compile/elektra\"\n+SUBDIRS=\"$SUBDIRS testsuite/compile/votrics\"\n+\n+# Default --srcdir to the directory where the script is found, \n+# if a directory was specified.\n+# The second sed call is to convert `.//configure' to `./configure'.\n+srcdir=`echo $0 | sed 's|//|/|' | sed 's|/[^/]*$||'`\n+if [ x$srcdir = x$0 ]\n+then\n+srcdir=\n+fi\n+\n+host=\n+\n+# Default prefix to /usr/local.\n+prefix=/usr/local\n+\n+# local_prefix specifies where to find the directory /usr/local/include\n+# We don't use $(prefix) for this\n+# because we always want GCC to search /usr/local/include\n+# even if GCC is installed somewhere other than /usr/local.\n+# Think THREE TIMES before specifying any other value for this!\n+# DO NOT make this use $prefix!\n+local_prefix=/usr/local\n+# CYGNUS LOCAL: for our purposes, this must be prefix.  This is apparently\n+# only done for the benefit of glibc, and we don't use glibc.\n+local_prefix='$(prefix)'\n+# Default is to let the Makefile set exec_prefix from $(prefix)\n+exec_prefix='$(prefix)'\n+\n+# CYGNUS LOCAL.  Default to nothing.\n+program_transform_name=\n+program_transform_set=\n+site=\n+\n+remove=rm\n+hard_link=ln\n+symbolic_link='ln -s'\n+copy=cp\n+\n+# Record all the arguments, to write them in config.status.\n+arguments=$*\n+\n+#for Test\n+#remove=\"echo rm\"\n+#hard_link=\"echo ln\"\n+#symbolic_link=\"echo ln -s\"\n+\n+target=\n+host=\n+build=\n+\n+for arg in $*;\n+do\n+  case $next_arg in\n+  --srcdir)\n+    srcdir=$arg\n+    next_arg=\n+    ;;\n+  --host)\n+    host=$arg\n+    next_arg=\n+    ;;\n+  --target)\n+    target=$arg\n+    next_arg=\n+    ;;\n+  --build)\n+    build=$arg\n+    next_arg=\n+    ;;\n+  --prefix)\n+    prefix=$arg\n+    next_arg=\n+    ;;\n+  --local-prefix)\n+    local_prefix=$arg\n+    next_arg=\n+    ;;\n+  --exec-prefix)\n+    exec_prefix=$arg\n+    next_arg=\n+    ;;\n+  --program-transform-name) # CYGNUS LOCAL\n+    # Double any backslashes or dollar signs in the argument.\n+    if [ -n \"${arg}\" ] ; then\n+      program_transform_name=\"${program_transform_name} -e `echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`\"\n+    fi\n+    program_transform_set=yes\n+    next_arg=\n+    ;;    \n+  --program-prefix) # CYGNUS LOCAL\n+    if [ -n \"${arg}\" ]; then\n+      program_transform_name=\"${program_transform_name} -e s,^,`echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`,\"\n+    fi\n+    program_transform_set=yes\n+    next_arg=\n+    ;;\n+  --program-suffix) # CYGNUS LOCAL\n+    if [ -n \"${arg}\" ]; then\n+      program_transform_name=\"${program_transform_name} -e s,\\$\\$,`echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`,\"\n+    fi\n+    program_transform_set=yes\n+    next_arg=\n+    ;;\n+  --site) # CYGNUS LOCAL\n+    site=${arg}\n+    next_arg=\n+    ;;\n+  --x-*)\n+    next_arg=\n+    ;;\n+  *)\n+    case $arg in\n+     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)\n+\tnext_arg=--srcdir\n+\t;;\n+     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)\n+\tsrcdir=`echo $arg | sed 's/-*s[a-z]*=//'`\n+\t;;\n+     -host | --host | --hos | --ho | --h)\n+\tnext_arg=--host\n+\t;;\n+     -host=* | --host=* | --hos=* | --ho=* | --h=*)\n+\thost=`echo $arg | sed 's/-*h[a-z]*=//'`\n+\t;; \n+     -target | --target | --targe | --targ | --tar | --ta | --t)\n+\tnext_arg=--target\n+\t;;\n+     -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n+\ttarget=`echo $arg | sed 's/-*t[a-z]*=//'`\n+\t;; \n+     -build | --build | --buil | --bui | --bu | --b)\n+\tnext_arg=--build\n+\t;;\n+     -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)\n+\tbuild=`echo $arg | sed 's/-*b[a-z]*=//'`\n+\t;; \n+     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n+\tnext_arg=--prefix\n+\t;;\n+     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n+\tprefix=`echo $arg | sed 's/-*p[a-z]*=//'`\n+\t;;\n+     -local-prefix | --local-prefix | --local-prefi | --local-pref | --local-pre \\\n+\t| --local-pr | --local-p | --local- | --local | --loc | --lo | --l)\n+\tnext_arg=--local-prefix\n+\t;;\n+     -local-prefix=* | --local-prefix=* | --local-prefi=* | --local-pref=* \\\n+\t| --local-pre=* | --local-pr=* | --local-p=* | --local-=* | --local=* \\\n+\t| --loc=* | --lo=* | --l=*)\n+\tlocal_prefix=`echo $arg | sed 's/-*l[-a-z]*=//'`\n+\t;;\n+     -exec-prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre \\\n+\t| --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)\n+\tnext_arg=--exec-prefix\n+\t;;\n+     -exec-prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* \\\n+\t| --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* \\\n+\t| --exe=* | --ex=* | --e=*)\n+\texec_prefix=`echo $arg | sed 's/-*e[-a-z]*=//'`\n+\t;;\n+     -program-transform-name | --program-transform-name \\\n+\t| --program-transform-nam | --program-transform-na \\\n+\t| --program-transform-n | --program-transform- | --program-transform \\\n+\t| --program-transfor | --program-transfo | --program-transf \\\n+\t| --program-trans | --program-tran | --program-tra \\\n+\t| --program-tr | --program-t)\n+\tnext_arg=--program-transform-name\n+\t# CYGNUS LOCAL\n+\t;;\n+     -program-transform-name=* | --program-transform-name=* \\\n+\t| --program-transform-nam=* | --program-transform-na=* \\\n+\t| --program-transform-n=* | --program-transform-=* \\\n+\t| --program-transform=* | --program-transfor=* | --program-transfo=* \\\n+\t| --program-transf=* | --program-trans=* | --program-tran=* \\\n+\t| --program-tra=* | --program-tr=* | --program-t=*)\n+\t# CYGNUS LOCAL\n+\targ=`echo ${arg} | sed -e 's/^[-a-z_]*=//'`\n+\t# Double any \\ or $ in the argument.\n+\tif [ -n \"${arg}\" ] ; then\n+\t  program_transform_name=\"${program_transform_name} -e `echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`\"\n+\tfi\n+\tprogram_transform_set=yes\n+\t;;\n+     -program-prefix | --program-prefix | --program-prefi \\\n+\t| --program-pref | --program-pre | --program-pr \\\n+\t| --program-p)\n+\tnext_arg=--program-prefix\n+\t# CYGNUS LOCAL\n+\t;;\n+     -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n+\t| --program-pref=* | --program-pre=* | --program-pr=* \\\n+\t| --program-p=*)\n+\t# CYGNUS LOCAL\n+\targ=`echo ${arg} | sed -e 's/^[-a-z_]*=//'`\n+\tif [ -n \"${arg}\" ]; then\n+\t  program_transform_name=\"${program_transform_name} -e s,^,`echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`,\"\n+\tfi\n+\tprogram_transform_set=yes\n+\t;;\n+     -program-suffix | --program-suffix | --program-suffi \\\n+\t| --program-suff | --program-suf | --program-su \\\n+\t| --program-s)\n+\tnext_arg=--program-suffix\n+\t# CYGNUS LOCAL\n+\t;;\n+     -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n+\t| --program-suff=* | --program-suf=* | --program-su=* \\\n+\t| --program-s=*)\n+\t# CYGNUS LOCAL\n+\targ=`echo ${arg} | sed -e 's/^[-a-z_]*=//'`\n+\tif [ -n \"${arg}\" ]; then\n+\t  program_transform_name=\"${program_transform_name} -e s,\\$\\$,`echo ${arg} | sed -e 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g' -e 's/\\\\\\$/$$/g'`,\"\n+\tfi\n+\tprogram_transform_set=yes\n+\t;;\n+     -site | --site | --sit) # CYGNUS LOCAL\n+\tnext_arg=--site\n+\t;;\n+     -site=* | --site=* | --sit=* | --si=*) # CYGNUS LOCAL\n+\tsite=`echo ${arg} | sed 's/^[-a-z]*=//'`\n+\t;;\n+     -with-gnu-ld | --with-gnu-ld | --with-gnu-l)\n+\tgnu_ld=yes\n+\t;;\n+     -gas | --gas | --ga | --g | -with-gnu-as | --with-gnu-as | -with-gnu-a)\n+        gas=yes\n+\t;;\n+     -nfp | --nfp | --nf | --n)\n+\tnfp=yes\n+\t;;\n+     -with-stabs | -with-stab | -with-sta | -with-st | -with-s \\\n+\t| --with-stabs | --with-stab | --with-sta | --with-st | --with-s \\\n+\t| -stabs | -stab | -sta | -st  \\\n+\t| --stabs | --stab | --sta | --st)\n+\tstabs=yes\n+\t;;\n+     -with-elf | -with-el | -with-se \\\n+\t| --with-elf | --with-el | --with-e \\\n+\t| -elf | -el | -e \\\n+\t|--elf | --el | --e)\n+\telf=yes\n+\t;;\n+     -with-* | --with-*) ;; #ignored\n+     -without-* | --without-*) ;; #ignored\n+     -enable-* | --enable-*) ;; #ignored\n+     -x | --x) ;; # ignored\n+     -x-*=* | --x-*=*) ;; # ignored\n+     -x-* | --x-*)\n+\tnext_arg=--x-ignored # ignored\n+\t;;\n+     --he*) ;; # ignored for now (--help)\n+     --vers*) ;; # ignored for now (--version)\n+     -v | -verb* | --verb*) ;; # ignored for now (--verbose)\n+     --program-*) ;; #ignored (--program-prefix, --program-suffix)\n+     --c*) ;; #ignored (--cache-file)\n+     --q*) ;; #ignored (--quiet)\n+     --si*) ;; #ignored (--silent)\n+     -*)\n+\techo \"Invalid option \\`$arg'\" 1>&2\n+\texit 1\n+\t;;\n+     *)\n+# Allow configure HOST TARGET\n+\tif [ x$host = x ]\n+\tthen\n+\t\thost=$target\n+\tfi\n+\ttarget=$arg\n+\t;;\n+    esac\n+  esac\n+done\n+\n+# Find the source files, if location was not specified.\n+if [ x$srcdir = x ]\n+then\n+\tsrcdirdefaulted=1\n+\tsrcdir=.\n+\tif [ ! -r tree.c ]\n+\tthen\n+\t\tsrcdir=..\n+\tfi\n+fi\n+\n+if [ ! -r ${srcdir}/grant.c ]\n+then\n+\tif [ x$srcdirdefaulted = x ]\n+\tthen\n+\t  echo \"$progname: Can't find CHILL frontend sources in \\`${srcdir}'\" 1>&2\n+\telse\n+\t  echo \"$progname: Can't find CHILL frontend sources in \\`.' or \\`..'\" 1>&2\n+\tfi\n+\texit 1\n+fi\n+\n+# Make sure that scripts are executable\n+[ -w ${srcdir} -a -f ${srcdir}/regression.sh   ] && \\\n+  chmod +x ${srcdir}/regression.sh \n+[ -w ${srcdir} -a -f ${srcdir}/regression.prpt ] && \\\n+  chmod +x ${srcdir}/regression.prpt\n+[ -w ${srcdir} -a -f ${srcdir}/regression.awk3 ] && \\\n+  chmod +x ${srcdir}/regression.awk3\n+\n+if [ -r ${srcdir}/config.status ] && [ x$srcdir != x. ]\n+then\n+\techo \"$progname: \\`configure' has been run in \\`${srcdir}'\" 1>&2\n+\texit 1\n+fi\n+\n+host_xmake_file=\n+host_truncate_target=\n+\n+# Complain if an arg is missing\n+if [ x$build = x ]\n+then\n+\t# If host was specified, always use it for build also to avoid\n+\t# confusion.  If someone wants a cross compiler where build != host,\n+\t# then they must specify build explicitly.  Since this case is\n+\t# extremely rare, it does not matter that it is slightly inconvenient.\n+\tif [ x$host != x ]\n+\tthen\n+\t\tbuild=$host\n+\t\n+\t# This way of testing the result of a command substitution is\n+\t# defined by Posix.2 (section 3.9.1) as well as traditional shells.\n+\telif build=`${srcdir}/../config.guess`\n+\tthen\n+\t\techo \"This appears to be a ${build} system.\" 1>&2\n+\n+\telif [ x$target != x ]\n+\tthen\n+\t\techo 'Config.guess failed to determine the host type.  Defaulting to target.'\n+\t\tbuild=$target\n+\telse\n+\t\techo 'Config.guess failed to determine the host type.  You need to specify one.' 1>&2\n+\t\techo \"\\\n+Usage: `basename $progname` [--host=HOST] [--build=BUILD]\n+       [--prefix=DIR] [--gxx-include-dir=DIR] [--local-pref=DIR] [--exec-pref=DIR]\n+       [--with-gnu-as] [--with-gnu-ld] [--with-stabs] [--with-elf] [--nfp] TARGET\" 1>&2\n+\techo \"Where HOST, TARGET and BUILD are three-part configuration names \" 1>&2\n+\t\tif [ -r config.status ]\n+\t\tthen\n+\t\t\ttail +2 config.status 1>&2\n+\t\tfi\n+\t\texit 1\n+\tfi\n+fi\n+\n+# If $host was not specified, use $build.\n+if [ x$host = x ]\n+then\n+\thost=$build\n+fi\n+\n+# If $target was not specified, use $host.\n+if [ x$target = x ]\n+then\n+\ttarget=$host\n+fi\n+\n+# Validate the specs, and canonicalize them.\n+canon_build=`/bin/sh $srcdir/../config.sub $build` || exit 1\n+canon_host=`/bin/sh $srcdir/../config.sub $host` || exit 1\n+canon_target=`/bin/sh $srcdir/../config.sub $target` || exit 1\n+\n+rm -f config.bak\n+if [ -f config.status ]; then mv -f config.status config.bak; fi\n+\n+#\n+# For the current directory and all of the designated SUBDIRS,\n+# do the rest of the script...\n+#\n+if [ ! -d testsuite ] ; then mkdir testsuite; fi\n+_SUBDIRS=\n+for d in $SUBDIRS; do\n+\t[ -d $srcdir/$d ] && _SUBDIRS=\"$_SUBDIRS $d\"\n+done\n+\n+savesrcdir=$srcdir\n+STARTDIR=`pwd`\n+\n+for subdir in $_SUBDIRS\n+do\n+\ttmake_file=\n+\thost_xmake_file=\n+\toldsrcdir=$savesrcdir\n+\n+\t# ${invsubdir} is inverse of ${subdir), *with* trailing /, if needed.\n+\tinvsubdir=`echo ${subdir}/ | sed -e 's|\\./||g' -e 's|[^/]*/|../|g'`\n+\n+\t# Re-adjust the path\n+\t# Also create a .gdbinit file which runs the one in srcdir\n+\t# and tells GDB to look there for source files.\n+\n+\tcase $oldsrcdir in\n+\t\".\") srcdir=. ;;\n+\t/*) # absolute path\n+               \tsrcdir=${oldsrcdir}/${subdir}  ;;\n+        *) # otherwise relative\n+\t\tsrcdir=${invsubdir}${oldsrcdir}/${subdir} ;;\n+\tesac\n+\n+        if [ -r ${oldsrcdir}/${subdir}/.gdbinit -a ${oldsrcdir} != \".\" ] ; then\n+\t\tcat > ${subdir}/.gdbinit <<EOF\n+dir .\n+dir ${srcdir}\n+source ${srcdir}/.gdbinit\n+EOF\n+\tfi\n+\n+\tcase $oldsrcdir in\n+\t/*)\t;;\n+\t*)\toldsrcdir=${invsubdir}${oldsrcdir} ;;\n+\tesac\n+\tmainsrcdir=${oldsrcdir}/..\n+\ttest -d $subdir || mkdir $subdir\n+\tcd $subdir\n+\t#\n+\t# Create Makefile.tem from Makefile.in.\n+\t# Make it set VPATH if necessary so that the sources are found.\n+\t# Also change its value of srcdir.\n+\trm -f Makefile.tem\n+\techo \"VPATH = ${srcdir}\" \\\n+\t  | cat - ${srcdir}/Makefile.in \\\n+\t  | sed \"s@^srcdir = \\.@srcdir = ${srcdir}@\" > Makefile.tem\n+\n+\t# Conditionalize the makefile for this host machine.\n+\tif [ -f ${mainsrcdir}/config/${host_xmake_file} ]\n+\tthen\n+\t\trm -f Makefile.xx\n+\t\tsed -e \"/####host/  r ${mainsrcdir}/config/${host_xmake_file}\" Makefile.tem > Makefile.xx\n+\t\techo \"Merged ${host_xmake_file}.\"\n+\t\trm -f Makefile.tem\n+\t\tmv Makefile.xx Makefile.tem\n+\telse\n+\t# Say in the makefile that there is no host_xmake_file,\n+\t# by using a name which (when interpreted relative to $srcdir/config)\n+\t# will duplicate another dependency: $srcdir/Makefile.in.\n+\t\thost_xmake_file=../Makefile.in\n+\tfi\n+\t\n+\t# Define variables host_canonical, build_canonical, and target_canonical\n+\t# because some Cygnus local changes in the Makefile depend on them.\n+\techo host_canonical = ${canon_host} > Makefile.xx\n+\techo target_canonical = ${canon_target} >> Makefile.xx\n+\techo build_canonical = ${canon_build} >> Makefile.xx\n+\tcat Makefile.tem >> Makefile.xx\n+\tmv Makefile.xx Makefile.tem\n+\t\n+\t# Conditionalize the makefile for this target machine.\n+\tif [ -f ${mainsrcdir}/config/${tmake_file} ]\n+\tthen\n+\t\trm -f Makefile.xx\n+\t\tsed -e \"/####target/  r ${mainsrcdir}/config/${tmake_file}\" Makefile.tem > Makefile.xx\n+\t\techo \"Merged ${tmake_file}.\"\n+\t\trm -f Makefile.tem\n+\t\tmv Makefile.xx Makefile.tem\n+\telse\n+\t# Say in the makefile that there is no tmake_file,\n+\t# by using a name which (when interpreted relative to $srcdir/config)\n+\t# will duplicate another dependency: $srcdir/Makefile.in.\n+\t\ttmake_file=../Makefile.in\n+\tfi\n+\t\n+\t# CYGNUS LOCAL\n+\t# Conditionalize the makefile for this site.\n+\tif [ -f ${mainsrcdir}/config/ms-${site} ]\n+\tthen\n+\t\trm -f Makefile.xx\n+\t\tsed -e \"/####site/  r ${mainsrcdir}/config/ms-${site}\" Makefile.tem > Makefile.xx\n+\t\techo \"Merged ms-${site}.\"\n+\t\trm -f Makefile.tem\n+\t\tmv Makefile.xx Makefile.tem\n+\tfi\n+\t\n+\t# CYGNUS LOCAL\n+\t# If this is a cross compilation, and we have newlib in the build\n+\t# tree, then define inhibit_libc in LIBGCC2_CFLAGS.  This will cause\n+\t# __eprintf to be left out of libgcc.a, but that's OK because newlib\n+\t# has its own version of assert.h.\n+\tif [ x$host != x$target ]; then\n+\t  sed -e 's/^\\(LIBGCC2_CFLAGS[ \t]*=[ \t]*\\)/\\1-Dinhibit_libc /' Makefile.tem > Makefile.tem2\n+\t  rm -f Makefile.tem\n+\t  mv Makefile.tem2 Makefile.tem\n+\tfi\n+\t\n+\t# Remove all formfeeds, since some Makes get confused by them.\n+\t# Also arrange to give the variables `target', `host_xmake_file',\n+\t# `tmake_file', `prefix', `local_prefix', `exec_prefix', `FIXINCLUDES'\n+\t# and `INSTALL_HEADERS_DIR' values in the Makefile from the values\n+\t# they have in this script.\n+\t# CYGNUS LOCAL: FLOAT_H, CROSS_FLOAT_H, objdir\n+\trm -f Makefile.xx\n+\tsed -e \"s/\f//\" -e \"s/^target=.*$/target=${target}/\" \\\n+\t    -e \"s|^xmake_file=.*$|xmake_file=${host_xmake_file}|\" \\\n+\t    -e \"s|^tmake_file=.*$|tmake_file=${tmake_file}|\" \\\n+\t    -e \"s|^version=.*$|version=${version}|\" \\\n+\t    -e \"s|^prefix[ \t]*=.*|prefix = $prefix|\" \\\n+\t    -e \"s|^local_prefix[ \t]*=.*|local_prefix = $local_prefix|\" \\\n+\t    -e \"s|^exec_prefix[ \t]*=.*|exec_prefix = $exec_prefix|\" \\\n+\t    -e \"s|^objdir[ \t]*=.*|objdir=`pwd`|\" \\\n+\t    Makefile.tem > Makefile.xx\n+\trm -f Makefile.tem\n+\tmv Makefile.xx Makefile.tem\n+\t\n+\t# Install Makefile for real, after making final changes.\n+\t# Define macro CROSS_COMPILE in compilation if this is a cross-compiler.\n+\t# Also use all.cross instead of all.internal, and add cross-make to Makefile.\n+\tif [ x$canon_host = x$canon_target ]\n+\tthen\n+\t\trm -f Makefile\n+\t  \tif [ x$canon_host = x$canon_build ]\n+\t\tthen\n+\t\t\tmv Makefile.tem Makefile\n+\t\telse\n+\t#\t\tWhen building gcc with a cross-compiler, we need to fix a\n+\t#\t\tfew things.\n+\t\t\techo \"build= $build\" > Makefile\n+\t\t\tsed -e \"/####build/  r ${mainsrcdir}/build-make\" Makefile.tem >> Makefile\n+\t\t\trm -f Makefile.tem Makefile.xx\n+\t\tfi\n+\telse\n+\t\trm -f Makefile\n+\t\techo \"CROSS=-DCROSS_COMPILE\" > Makefile\n+\t\tsed -e \"/####cross/  r ${mainsrcdir}/cross-make\" Makefile.tem >> Makefile\n+\t\trm -f Makefile.tem Makefile.xx\n+\tfi\n+\t\n+\techo \"Created \\`$subdir/Makefile'.\"\n+\t\n+\tif [ xx${vint} != xx ]\n+\tthen\n+\t\tvintmsg=\" (vint)\"\n+\tfi\n+\t\n+\t# Describe the chosen configuration in config.status.\n+\t# Make that file a shellscript which will reestablish the same configuration.\n+\n+\trm -f config.bak\n+\tif [ -f config.status ]; then mv -f config.status config.bak; fi\n+\n+\techo \"#!/bin/sh\n+\t# This directory was configured as follows:\n+cd $invsubdir; ${progname}\" $arguments > config.new\n+\techo echo host=$canon_host target=$canon_target build=$canon_build >> config.new\n+\tchmod a+x config.new\n+\n+\t# If we aren't executing the configure script in .\n+\tif [ x$subdir != x. ]\n+\tthen\n+\t\tif [ -f $srcdir/configure ]\n+\t\tthen\n+\t\t\techo \"Running \\`${CONFIG_SHELL-sh} $srcdir/configure $arguments\\'\"\n+\t\t\t${CONFIG_SHELL-sh} $srcdir/configure $arguments\n+\t\t\techo \"${srcdir}/configure\" $arguments >> config.new\n+\t\t\techo echo host=$canon_host target=$canon_target build=$canon_build >> config.new\n+\t\tfi\n+\tfi\n+\n+\tif [ -f config.bak ] && cmp config.bak config.new >/dev/null 2>/dev/null;\n+\tthen\n+\t\tmv -f config.bak config.status\n+\t\trm -f config.new\n+\telse\n+\t\tmv -f config.new config.status\n+\t\trm -f config.bak\n+\tfi\n+\n+\tcd $STARTDIR\n+done   # end of current-dir SUBDIRS loop\n+\t\n+srcdir=$savesrcdir\n+\n+# Describe the chosen configuration in config.status.\n+# Make that file a shellscript which will reestablish the same configuration.\n+echo \"#!/bin/sh\n+# This directory was configured as follows:\n+${progname}\" $arguments > config.new\n+echo echo host=$canon_host target=$canon_target build=$canon_build >> config.new\n+chmod a+x config.new\n+if [ -f config.bak ] && cmp config.bak config.new >/dev/null 2>/dev/null;\n+then\n+\tmv -f config.bak config.status\n+\trm -f config.new\n+else\n+\tmv -f config.new config.status\n+\trm -f config.bak\n+fi\n+\n+exit 0"}, {"sha": "d865336bf6f9ce1591a751ada3629d32ae46b5a4", "filename": "gcc/ch/convert.c", "status": "added", "additions": 1231, "deletions": 0, "changes": 1231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconvert.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,1231 @@\n+/* Language-level data type conversion for GNU CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This file contains the functions for converting CHILL expressions\n+   to different data types.  The only entry point is `convert'.\n+   Every language front end must have a `convert' function\n+   but what kind of conversions it does will depend on the language.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+#include \"flags.h\"\n+#include \"convert.h\"\n+#include \"lex.h\"\n+\n+extern void error                              PROTO((char *, ...));\n+extern tree initializer_constant_valid_p       PROTO((tree, tree));\n+extern tree bit_one_node, bit_zero_node;\n+extern tree string_one_type_node;\n+extern tree bitstring_one_type_node;\n+\f\n+static tree\n+convert_to_reference (reftype, expr)\n+     tree reftype, expr;\n+{\n+  while (TREE_CODE (expr) == NOP_EXPR)  /* RETYPE_EXPR */\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (! CH_LOCATION_P (expr))\n+    error(\"internal error: trying to make loc-identity with non-location\");\n+  else\n+    {\n+      mark_addressable (expr);\n+      return fold (build1 (ADDR_EXPR, reftype, expr));\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+tree\n+convert_from_reference (expr)\n+     tree expr;\n+{\n+  tree e = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n+  TREE_READONLY (e) = TREE_READONLY (expr);\n+  return e;\n+}\n+\n+/* Convert EXPR to a boolean type.  */\n+\n+static tree\n+convert_to_boolean (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  \n+  if (integer_zerop (expr))\n+    return boolean_false_node;\n+  if (integer_onep (expr))\n+    return boolean_true_node;\n+\n+  /* Convert a singleton bitstring to a Boolean.\n+     Needed if flag_old_strings. */\n+  if (CH_BOOLS_ONE_P (intype))\n+    {\n+      if (TREE_CODE (expr) == CONSTRUCTOR)\n+\t{\n+\t  tree valuelist = TREE_OPERAND (expr, 1);\n+\t  if (valuelist == NULL_TREE)\n+\t    return boolean_false_node;\n+\t  if (TREE_CHAIN (valuelist) == NULL_TREE\n+\t      && TREE_PURPOSE (valuelist) == NULL_TREE\n+\t      && integer_zerop (TREE_VALUE (valuelist)))\n+\t    return boolean_true_node;\n+\t}\n+      return build_chill_bitref (expr,\n+\t\t\t\t build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t  integer_zero_node));\n+    }\n+\n+  if (INTEGRAL_TYPE_P (intype))\n+    return build1 (CONVERT_EXPR, type, expr);\n+\n+  error (\"cannot convert to a boolean mode\");\n+  return boolean_false_node;\n+}\n+\n+/* Convert EXPR to a char type.  */\n+\n+static tree\n+convert_to_char (type, expr)\n+     tree type, expr;\n+{\n+  register tree intype = TREE_TYPE (expr);\n+  register enum chill_tree_code form = TREE_CODE (intype);\n+  \n+  if (form == CHAR_TYPE)\n+    return build1 (NOP_EXPR, type, expr);\n+\n+  /* Convert a singleton string to a char.\n+     Needed if flag_old_strings. */\n+  if (CH_CHARS_ONE_P (intype))\n+    {\n+      if (TREE_CODE (expr) == STRING_CST)\n+\t{\n+\t  expr = build_int_2 ((unsigned char)TREE_STRING_POINTER(expr)[0], 0);\n+\t  TREE_TYPE (expr) = char_type_node;\n+\t  return expr;\n+\t}\n+      else\n+\treturn build (ARRAY_REF, char_type_node, expr, integer_zero_node);\n+\n+    }\n+\n+  /* For now, assume it will always fit */\n+  if (form == INTEGER_TYPE)\n+    return build1 (CONVERT_EXPR, type, expr);\n+\n+  error (\"cannot convert to a char mode\");\n+\n+  {\n+    register tree tem = build_int_2 (0, 0);\n+    TREE_TYPE (tem) = type;\n+    return tem;\n+  }\n+}\n+\f\n+tree\n+base_type_size_in_bytes (type)\n+     tree type;\n+{\n+  if (type == NULL_TREE\n+      || TREE_CODE (type) == ERROR_MARK\n+      || TREE_CODE (type) != ARRAY_TYPE)\n+    return error_mark_node;\n+  return size_in_bytes (TREE_TYPE (type));\n+}\n+\n+/*\n+ * build a singleton array type, of TYPE objects.\n+ */\n+tree\n+build_array_type_for_scalar (type)\n+     tree type;\n+{\n+  /* KLUDGE */\n+  if (type == char_type_node)\n+    return build_string_type (type, integer_one_node);\n+\n+  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  return build_chill_array_type\n+    (type,\n+     tree_cons (NULL_TREE,\n+\t\tbuild_chill_range_type (NULL_TREE,\n+\t\t\t\t\tinteger_zero_node, integer_zero_node),\n+\t\tNULL_TREE),\n+     0, NULL_TREE);\n+\n+}\n+\f\n+#if 0\n+static tree\n+unreferenced_type_of (type)\n+     tree type;\n+{\n+  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n+  while (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+  return type;\n+}\n+#endif\n+\n+\n+/* Remove from *LISTP the first TREE_LIST node whose TREE_PURPOSE == KEY.\n+   Return the TREE_LIST node, or NULL_TREE on failure. */\n+\n+static tree\n+remove_tree_element (key, listp)\n+     tree *listp;\n+     tree key;\n+{\n+  tree node = *listp;\n+  for ( ; node; listp = &TREE_CHAIN (node), node = *listp)\n+    {\n+      if (TREE_PURPOSE (node) == key)\n+\t{\n+\t  *listp = TREE_CHAIN (node);\n+\t  TREE_CHAIN (node) = NULL_TREE;\n+\t  return node;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This is quite the same as check_range in actions.c, but with\n+   different error message. */\n+\n+static tree\n+check_ps_range (value, lo_limit, hi_limit)\n+     tree value;\n+     tree lo_limit;\n+     tree hi_limit;\n+{\n+  tree check = test_range (value, lo_limit, hi_limit);\n+\n+  if (!integer_zerop (check))\n+    {\n+      if (TREE_CODE (check) == INTEGER_CST)\n+\t{\n+\t  error (\"powerset tuple element out of range\");\n+\t  return error_mark_node;\n+\t}\n+      else\n+\tvalue = check_expression (value, check,\n+\t\t\t\t  ridpointers[(int) RID_RANGEFAIL]);\n+    }\n+  return value;\n+}\n+\n+static tree\n+digest_powerset_tuple (type, inits)\n+     tree type;\n+     tree inits;\n+{\n+  tree list;\n+  tree result;\n+  tree domain = TYPE_DOMAIN (type);\n+  int i = 0;\n+  int is_erroneous = 0, is_constant = 1, is_simple = 1;\n+  if (domain == NULL_TREE || TREE_CODE (domain) == ERROR_MARK)\n+    return error_mark_node;\n+  for (list = TREE_OPERAND (inits, 1);  list; list = TREE_CHAIN (list), i++)\n+    {\n+      tree val = TREE_VALUE (list);\n+      if (TREE_CODE (val) == ERROR_MARK)\n+\t{\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+      if (!TREE_CONSTANT (val))\n+\tis_constant = 0;\n+      else if (!initializer_constant_valid_p (val, TREE_TYPE (val)))\n+\tis_simple = 0;\n+      if (! CH_COMPATIBLE (val, domain))\n+\t{\n+\t  error (\"incompatible member of powerset tuple (at position #%d)\", i);\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+      /* check range of value */\n+      val = check_ps_range (val, TYPE_MIN_VALUE (domain),\n+\t\t\t    TYPE_MAX_VALUE (domain));\n+      if (TREE_CODE (val) == ERROR_MARK)\n+\t{\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+\n+      /* Updating the list in place is in principle questionable,\n+\t but I can't think how it could hurt. */\n+      TREE_VALUE (list) = convert (domain, val);\n+\n+      val = TREE_PURPOSE (list);\n+      if (val == NULL_TREE)\n+\tcontinue;\n+\n+      if (TREE_CODE (val) == ERROR_MARK)\n+\t{\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+      if (! CH_COMPATIBLE (val, domain))\n+\t{\n+\t  error (\"incompatible member of powerset tuple (at position #%d)\", i);\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+      val = check_ps_range (val, TYPE_MIN_VALUE (domain),\n+\t\t\t    TYPE_MAX_VALUE (domain));\n+      if (TREE_CODE (val) == ERROR_MARK)\n+\t{\n+\t  is_erroneous = 1;\n+\t  continue;\n+\t}\n+      TREE_PURPOSE (list) = convert (domain, val);\n+      if (!TREE_CONSTANT (val))\n+\tis_constant = 0;\n+      else if (!initializer_constant_valid_p (val, TREE_TYPE (val)))\n+\tis_simple = 0;\n+    }\n+  result = build (CONSTRUCTOR, type, NULL_TREE, TREE_OPERAND (inits, 1));\n+  if (is_erroneous)\n+    return error_mark_node;\n+  if (is_constant)\n+    TREE_CONSTANT (result) = 1;\n+  if (is_constant && is_simple)\n+    TREE_STATIC (result) = 1;\n+  return result;\n+}\n+\n+static tree\n+digest_structure_tuple (type, inits)\n+     tree type;\n+     tree inits;\n+{\n+  tree elements = CONSTRUCTOR_ELTS (inits);\n+  tree values = NULL_TREE;\n+  int is_constant = 1;\n+  int is_simple = 1;\n+  int is_erroneous = 0;\n+  tree field;\n+  int labelled_elements = 0;\n+  int unlabelled_elements = 0;\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (TREE_TYPE (field)) != UNION_TYPE)\n+\t{ /* Regular fixed field. */\n+\t  tree value = remove_tree_element (DECL_NAME (field), &elements);\n+\n+\t  if (value)\n+\t    labelled_elements++;\n+\t  else if (elements && TREE_PURPOSE (elements) == NULL_TREE)\n+\t    {\n+\t      value = elements;\n+\t      elements = TREE_CHAIN (elements);\n+\t      unlabelled_elements++;\n+\t    }\n+\n+\t  if (value)\n+\t    {\n+\t      tree val;\n+\t      char msg[120];\n+\t      sprintf (msg, \"initializer for field `%.80s'\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t      val = chill_convert_for_assignment (TREE_TYPE (field),\n+\t\t\t\t\t\t  TREE_VALUE (value), msg);\n+\t      if (TREE_CODE (val) == ERROR_MARK)\n+\t\t  is_erroneous = 1;\n+\t      else\n+\t\t{\n+\t\t  TREE_VALUE (value) = val;\n+\t\t  TREE_CHAIN (value) = values;\n+\t\t  TREE_PURPOSE (value) = field;\n+\t\t  values = value;\t\n+\t\t  if (TREE_CODE (val) == ERROR_MARK)\n+\t\t    is_erroneous = 1;\n+\t\t  else if (!TREE_CONSTANT (val))\n+\t\t    is_constant = 0;\n+\t\t  else if (!initializer_constant_valid_p (val,\n+\t\t\t\t\t\t\t  TREE_TYPE (val)))\n+\t\t    is_simple = 0;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      pedwarn (\"no initializer value for fixed field `%s'\",\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree variant;\n+\t  tree selected_variant = NULL_TREE;\n+\t  tree variant_values = NULL_TREE;\n+\n+\t  /* In a tagged variant structure mode, try to figure out\n+\t     (from the fixed fields), which is the selected variant. */\n+\t  if (TYPE_TAGFIELDS (TREE_TYPE (field)))\n+\t    {\n+\t      for (variant = TYPE_FIELDS (TREE_TYPE (field));\n+\t\t   variant; variant = TREE_CHAIN (variant))\n+\t\t{\n+\t\t  tree tag_labels = TYPE_TAG_VALUES (TREE_TYPE (variant));\n+\t\t  tree tag_fields = TYPE_TAGFIELDS (TREE_TYPE (field));\n+\t\t  if (DECL_NAME (variant) == ELSE_VARIANT_NAME)\n+\t\t    {\n+\t\t      selected_variant = variant;\n+\t\t      break;\n+\t\t    }\n+\t\t  for (; tag_labels && tag_fields;\n+\t\t       tag_labels = TREE_CHAIN (tag_labels),\n+\t\t       tag_fields = TREE_CHAIN (tag_fields))\n+\t\t    {\n+\t\t      tree tag_value = values;\n+\t\t      int found = 0;\n+\t\t      tree tag_decl = TREE_VALUE (tag_fields);\n+\t\t      tree tag_value_set = TREE_VALUE (tag_labels);\n+\t\t      for ( ; tag_value; tag_value = TREE_CHAIN (tag_value))\n+\t\t\t{\n+\t\t\t  if (TREE_PURPOSE (tag_value) == tag_decl)\n+\t\t\t    {\n+\t\t\t      tag_value = TREE_VALUE (tag_value);\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (!tag_value || TREE_CODE (tag_value) != INTEGER_CST)\n+\t\t\t{\n+\t\t\t  pedwarn (\"non-constant value for tag field `%s'\",\n+\t\t\t\t   IDENTIFIER_POINTER (DECL_NAME (tag_decl)));\n+\t\t\t  goto get_values;\n+\t\t\t}\n+\n+\t\t      /* Check if the value of the tag (as given in a\n+\t\t\t previous field) matches the case label list. */\n+\t\t      for (; tag_value_set;\n+\t\t\t   tag_value_set = TREE_CHAIN (tag_value_set))\n+\t\t\t{\n+\t\t\t  if (tree_int_cst_equal (TREE_VALUE (tag_value_set),\n+\t\t\t\t\t\t  tag_value))\n+\t\t\t    {\n+\t\t\t      found = 1;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (!found)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  if (!tag_fields)\n+\t\t    {\n+\t\t      selected_variant = variant;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\tget_values:\n+\t  for (variant = TYPE_FIELDS (TREE_TYPE (field));\n+\t       variant; variant = TREE_CHAIN (variant))\n+\t    {\n+\t      tree vfield0 = TYPE_FIELDS (TREE_TYPE (variant)); \n+\t      tree vfield;\n+\t      for (vfield = vfield0; vfield;  vfield = TREE_CHAIN (vfield))\n+\t\t{\n+\t\t  tree value = remove_tree_element (DECL_NAME (vfield),\n+\t\t\t\t\t\t    &elements);\n+\n+\t\t  if (value)\n+\t\t    labelled_elements++;\n+\t\t  else if (variant == selected_variant\n+\t\t\t   && elements && TREE_PURPOSE (elements) == NULL_TREE)\n+\t\t    {\n+\t\t      value = elements;\n+\t\t      elements = TREE_CHAIN (elements);\n+\t\t      unlabelled_elements++;\n+\t\t    }\n+\n+\t\t  if (value)\n+\t\t    {\n+\t\t      if (selected_variant && selected_variant != variant)\n+\t\t\t{\n+\t\t\t  error (\"field `%s' in wrong variant\",\n+\t\t\t\t IDENTIFIER_POINTER (DECL_NAME (vfield)));\n+\t\t\t  is_erroneous = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (!selected_variant && vfield != vfield0)\n+\t\t\t    pedwarn (\"missing variant fields (at least `%s')\",\n+\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME (vfield0)));\n+\t\t\t  selected_variant = variant;\n+\t\t\t  if (CH_COMPATIBLE (TREE_VALUE (value),\n+\t\t\t\t\t     TREE_TYPE (vfield)))\n+\t\t\t    {\n+\t\t\t      tree val = convert (TREE_TYPE (vfield),\n+\t\t\t\t\t\t  TREE_VALUE (value));\n+\t\t\t      TREE_PURPOSE (value) = vfield;\n+\t\t\t      TREE_VALUE (value) = val;\n+\t\t\t      TREE_CHAIN (value) = variant_values;\n+\t\t\t      variant_values = value;\n+\t\t\t      if (TREE_CODE (val) == ERROR_MARK)\n+\t\t\t\tis_erroneous = 1;\n+\t\t\t      else if (!TREE_CONSTANT (val))\n+\t\t\t\tis_constant = 0;\n+\t\t\t      else if (!initializer_constant_valid_p\n+\t\t\t\t       (val, TREE_TYPE (val)))\n+\t\t\t\tis_simple = 0;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      is_erroneous = 1;\n+\t\t\t      error (\"bad initializer for field `%s'\",\n+\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME (vfield)));\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else if (variant == selected_variant)\n+\t\t    {\n+\t\t      pedwarn (\"no initializer value for variant field `%s'\",\n+\t\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (selected_variant == NULL_TREE)\n+\t    pedwarn (\"no selected variant\");\n+\t  else\n+\t    {\n+\t      variant_values = build (CONSTRUCTOR,\n+\t\t\t\t      TREE_TYPE (selected_variant),\n+\t\t\t\t      NULL_TREE, nreverse (variant_values));\n+\t      variant_values\n+\t\t= build (CONSTRUCTOR, TREE_TYPE (field), NULL_TREE,\n+\t\t\t build_tree_list (selected_variant, variant_values));\n+\t      values = tree_cons (field, variant_values, values);\n+\t    }\n+\t}\n+    }\n+\n+  if (labelled_elements && unlabelled_elements)\n+    pedwarn (\"mixture of labelled and unlabelled tuple elements\");\n+\n+  /* Check for unused initializer elements. */\n+  unlabelled_elements = 0;\n+  for ( ; elements != NULL_TREE; elements = TREE_CHAIN (elements))\n+    {\n+      if (TREE_PURPOSE (elements) == NULL_TREE)\n+\tunlabelled_elements++;\n+      else\n+\t{\n+\t  if (IDENTIFIER_POINTER (TREE_PURPOSE (elements)) == 0)\n+\t    error (\"probably not a structure tuple\");\n+\t  else\n+\t    error (\"excess initializer for field `%s'\",\n+\t\t   IDENTIFIER_POINTER (TREE_PURPOSE (elements)));\n+\t  is_erroneous = 1;\n+\t}\n+    }\n+  if (unlabelled_elements)\n+    {\n+      error (\"excess unnamed initializers\");\n+      is_erroneous = 1;\n+    }\n+\n+  CONSTRUCTOR_ELTS (inits) = nreverse (values);\n+  TREE_TYPE (inits) = type;\n+  if (is_erroneous)\n+    return error_mark_node;\n+  if (is_constant)\n+    TREE_CONSTANT (inits) = 1;\n+  if (is_constant && is_simple)\n+    TREE_STATIC (inits) = 1;\n+  return inits;\n+}\n+\n+/* Return a Chill representation of the INTEGER_CST VAL.\n+   The result may be in a static buffer, */\n+\n+char *\n+display_int_cst (val)\n+     tree val;\n+{\n+  static char buffer[50];\n+  HOST_WIDE_INT x;\n+  tree fields;\n+  if (TREE_CODE (val) != INTEGER_CST)\n+    return \"<not a constant>\";\n+\n+  x = TREE_INT_CST_LOW (val);\n+\n+  switch (TREE_CODE (TREE_TYPE (val)))\n+    {\n+    case BOOLEAN_TYPE:\n+      if (x == 0)\n+\treturn \"FALSE\";\n+      if (x == 1)\n+\treturn \"TRUE\";\n+      goto int_case;\n+    case CHAR_TYPE:\n+      if (x == '^')\n+\tstrcpy (buffer, \"'^^'\");\n+      else if (x == '\\n')\n+\tstrcpy (buffer, \"'^J'\");\n+      else if (x < ' ' || x > '~')\n+\tsprintf (buffer, \"'^(%u)'\", x);\n+      else\n+\tsprintf (buffer, \"'%c'\", x);\n+      return buffer;\n+    case ENUMERAL_TYPE:\n+      for (fields = TYPE_VALUES (TREE_TYPE (val)); fields != NULL_TREE;\n+\t   fields = TREE_CHAIN (fields))\n+\t{\n+\t  if (tree_int_cst_equal (TREE_VALUE (fields), val))\n+\t    return IDENTIFIER_POINTER (TREE_PURPOSE (fields));\n+\t}\n+      goto int_case;\n+    case POINTER_TYPE:\n+      if (x == 0)\n+\treturn \"NULL\";\n+      goto int_case;\n+    int_case:\n+    default:\n+      /* This code is derived from print-tree.c:print_code_brief. */\n+      if (TREE_INT_CST_HIGH (val) == 0)\n+\tsprintf (buffer,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \"%1u\",\n+#else\n+\t\t \"%1lu\",\n+#endif\n+\t\t x);\n+      else if (TREE_INT_CST_HIGH (val) == -1 && TREE_INT_CST_LOW (val) != 0)\n+\tsprintf (buffer,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \"-%1u\",\n+#else\n+\t\t \"-%1lu\",\n+#endif\n+\t\t -x);\n+      else\n+\tsprintf (buffer,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \"H'%lx%016lx\",\n+#else\n+\t\t \"H'%x%016x\",\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \"H'%lx%08lx\",\n+#else\n+\t\t \"H'%x%08x\",\n+#endif\n+#endif\n+\t\t TREE_INT_CST_HIGH (val), TREE_INT_CST_LOW (val));\n+      return buffer;\n+    }\n+}\n+\n+static tree\n+digest_array_tuple (type, init, allow_missing_elements)\n+     tree type;\n+     tree init;\n+     int allow_missing_elements;\n+{\n+  tree element = CONSTRUCTOR_ELTS (init);\n+  int is_constant = 1;\n+  int is_simple = 1;\n+  tree element_type = TREE_TYPE (type);\n+  tree default_value = NULL_TREE;\n+  tree element_list = NULL_TREE;\n+  tree domain_min;\n+  tree domain_max;\n+  tree *ptr = &element_list;\n+  int errors = 0;\n+  int labelled_elements = 0;\n+  int unlabelled_elements = 0;\n+  tree first, last = NULL_TREE;\n+\n+  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n+  domain_max = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n+\n+  if (domain_min == NULL || TREE_CODE (domain_min) != INTEGER_CST)\n+    {\n+      error (\"non-constant start index for tuple\");\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (domain_max) != INTEGER_CST)\n+    is_constant = 0;\n+\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    abort ();  \n+\n+  for ( ; element != NULL_TREE; element = TREE_CHAIN (element))\n+    {\n+      tree purpose = TREE_PURPOSE (element);\n+      tree value   = TREE_VALUE (element);\n+\n+      if (purpose == NULL_TREE)\n+\t{\n+\t  if (last == NULL_TREE)\n+\t    first = domain_min;\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT new_lo, new_hi;\n+\t      add_double (TREE_INT_CST_LOW (last), TREE_INT_CST_HIGH (last),\n+\t\t\t  1, 0,\n+\t\t\t  &new_lo, &new_hi);\n+\t      first = build_int_2 (new_lo, new_hi);\n+\t      TREE_TYPE (first) = TYPE_DOMAIN (type);\n+\t    }\n+\t  last = first;\n+\t  unlabelled_elements++;\n+\t}\n+      else\n+\t{\n+\t  labelled_elements++;\n+\t  if (TREE_CODE (purpose) == INTEGER_CST)\n+\t    first = last = purpose;\n+\t  else if (TREE_CODE (purpose) == TYPE_DECL\n+\t\t   && discrete_type_p (TREE_TYPE (purpose)))\n+\t    {\n+\t      first = TYPE_MIN_VALUE (TREE_TYPE (purpose));\n+\t      last = TYPE_MAX_VALUE (TREE_TYPE (purpose));\n+\t    }\n+\t  else if (TREE_CODE (purpose) != RANGE_EXPR)\n+\t    {\n+\t      error (\"invalid array tuple label\");\n+\t      errors++;\n+\t      continue;\n+\t    }\n+\t  else if (TREE_OPERAND (purpose, 0) == NULL_TREE)\n+\t    first = last = NULL_TREE;  /* Default value. */\n+\t  else\n+\t    {\n+\t      first = TREE_OPERAND (purpose, 0);\n+\t      last = TREE_OPERAND (purpose, 1);\n+\t    }\n+\t  if ((first != NULL && TREE_CODE (first) != INTEGER_CST)\n+\t      || (last != NULL && TREE_CODE (last) != INTEGER_CST))\n+\t    {\n+\t      error (\"non-constant array tuple index range\");\n+\t      errors++;\n+\t    }\n+\t}\n+\n+      if (! CH_COMPATIBLE (value, element_type))\n+\t{\n+\t  char *err_val_name = first ? display_int_cst (first) : \"(default)\";\n+\t  error (\"incompatible array tuple element %s\", err_val_name);\n+\t  value = error_mark_node;\n+\t}\n+      else\n+\tvalue = convert (element_type, value);\n+      if (TREE_CODE (value) == ERROR_MARK)\n+\terrors++;\n+      else if (!TREE_CONSTANT (value))\n+\tis_constant = 0;\n+      else if (!initializer_constant_valid_p (value, TREE_TYPE (value)))\n+\tis_simple = 0;\n+\n+      if (first == NULL_TREE)\n+\t{\n+\t  if (default_value != NULL)\n+\t    {\n+\t      error (\"multiple (*) or (ELSE) array tuple labels\");\n+\t      errors++;\n+\t    }\n+\t  default_value = value;\n+\t  continue;\n+\t}\n+\n+      if (first != last && tree_int_cst_lt (last, first))\n+\t{\n+\t  error (\"empty range in array tuple\");\n+\t  errors++;\n+\t  continue;\n+\t}\n+\n+      ptr = &element_list;\n+\n+#define MAYBE_RANGE_OP(PURPOSE, OPNO) \\\n+  (TREE_CODE (PURPOSE) == RANGE_EXPR ? TREE_OPERAND (PURPOSE, OPNO): PURPOSE)\n+#define CONSTRUCTOR_ELT_LO(ELT) MAYBE_RANGE_OP (TREE_PURPOSE (ELT), 0)\n+#define CONSTRUCTOR_ELT_HI(ELT) MAYBE_RANGE_OP (TREE_PURPOSE (ELT), 1)\n+      while (*ptr && tree_int_cst_lt (last,\n+\t\t\t\t      CONSTRUCTOR_ELT_LO (*ptr)))\n+\tptr = &TREE_CHAIN (*ptr);\n+      if (*ptr && ! tree_int_cst_lt (CONSTRUCTOR_ELT_HI (*ptr), first))\n+\t{\n+\t  char *err_val_name = display_int_cst (first);\n+\t  error (\"array tuple has duplicate index %s\", err_val_name);\n+\t  errors++;\n+\t  continue;\n+\t}\n+      if ((ptr == &element_list && tree_int_cst_lt (domain_max, last))\n+\t|| (*ptr == NULL_TREE && tree_int_cst_lt (first, domain_min)))\n+\t{\n+\t  if (purpose)\n+\t    error (\"array tuple index out of range\");\n+\t  else if (errors == 0)\n+\t    error (\"too many array tuple values\");\n+\t  errors++;\n+\t  continue;\n+\t}\n+      if (! tree_int_cst_lt (first, last))\n+\tpurpose = first;\n+      else if (purpose == NULL_TREE || TREE_CODE (purpose) != RANGE_EXPR)\n+\tpurpose = build_nt (RANGE_EXPR, first, last);\n+      *ptr = tree_cons (purpose, value, *ptr);\n+    }\n+\n+  element_list = nreverse (element_list);\n+\n+  /* For each missing element, set it to the default value,\n+     if there is one.  Otherwise, emit an error.  */\n+\n+  if (errors == 0\n+      && (!allow_missing_elements || default_value != NULL_TREE))\n+    {\n+      /* Iterate over each *gap* between specified elements/ranges. */\n+      tree prev_elt;\n+      if (element_list &&\n+\t  tree_int_cst_equal (CONSTRUCTOR_ELT_LO (element_list), domain_min))\n+\t{\n+\t  ptr = &TREE_CHAIN (element_list);\n+\t  prev_elt = element_list;\n+\t}\n+      else\n+\t{\n+\t  prev_elt = NULL_TREE;\n+\t  ptr = &element_list;\n+\t}\n+      for (;;)\n+\t{\n+\t  tree first, last;\n+\t  /* Calculate the first element of the gap. */\n+\t  if (prev_elt == NULL_TREE)\n+\t    first = domain_min;\n+\t  else\n+\t    {\n+\t      first = CONSTRUCTOR_ELT_HI (prev_elt);\n+\t      if (tree_int_cst_equal (first, domain_max))\n+\t\tbreak; /* We're done.  Avoid overflow below. */\n+\t      first = copy_node (first);\n+\t      add_double (TREE_INT_CST_LOW (first), TREE_INT_CST_HIGH (first),\n+\t\t\t  1, 0,\n+\t\t\t  &TREE_INT_CST_LOW (first),\n+\t\t\t  &TREE_INT_CST_HIGH (first));\n+\t    }\n+\t  /* Calculate the last element of the gap. */\n+\t  if (*ptr)\n+\t    {\n+\t      /* Actually end up with correct type. */\n+\t      last = size_binop (MINUS_EXPR,\n+\t\t\t\t CONSTRUCTOR_ELT_LO (*ptr),\n+\t\t\t\t integer_one_node);\n+\t    }\n+\t  else\n+\t    last = domain_max;\n+\t  if (TREE_CODE (last) == INTEGER_CST && tree_int_cst_lt (last, first))\n+\t    ; /* Empty \"gap\" - no missing elements. */\n+\t  else if (default_value)\n+\t    {\n+\t      tree purpose;\n+\t      if (tree_int_cst_equal (first, last))\n+\t\tpurpose = first;\n+\t      else\n+\t\tpurpose = build_nt (RANGE_EXPR, first, last);\n+\t      *ptr = tree_cons (purpose, default_value, *ptr);\n+\t    }\n+\t  else\n+\t    {\n+\t      char *err_val_name = display_int_cst (first);\n+\t      if (TREE_CODE (last) != INTEGER_CST)\n+\t\terror (\"dynamic array tuple without (*) or (ELSE)\");\n+\t      else if (tree_int_cst_equal (first, last))\n+\t\terror (\"missing array tuple element %s\", err_val_name);\n+\t      else\n+\t\t{\n+\t\t  char *first_name = (char *)\n+\t\t    xmalloc (strlen (err_val_name) + 1);\n+\t\t  strcpy (first_name, err_val_name);\n+\t\t  err_val_name = display_int_cst (last);\n+\t\t  error (\"missing array tuple elements %s : %s\",\n+\t\t\t first_name, err_val_name);\n+\t\t  free (first_name);\n+\t\t}\n+\t      errors++;\n+\t    }\n+\t  if (*ptr == NULL_TREE)\n+\t    break;\n+\t  prev_elt = *ptr;\n+\t  ptr = &TREE_CHAIN (*ptr);\n+\t}\n+    }\n+  if (errors)\n+    return error_mark_node;\n+\n+  element = build (CONSTRUCTOR, type, NULL_TREE, element_list);\n+  TREE_CONSTANT (element) = is_constant;\n+  if (is_constant && is_simple)\n+    TREE_STATIC (element) = 1;\n+  if (labelled_elements && unlabelled_elements)\n+    pedwarn (\"mixture of labelled and unlabelled tuple elements\");\n+  return element;\n+}\n+\f\n+/* This function is needed because no-op CHILL conversions are not fully\n+   understood by the initialization machinery.  This function should only\n+   be called when a conversion truly is a no-op.  */\n+\n+static tree\n+convert1 (type, expr)\n+     tree type, expr;\n+{\n+  int was_constant = TREE_CONSTANT (expr);\n+  STRIP_NOPS (expr);\n+  was_constant |= TREE_CONSTANT (expr);\n+  expr = copy_node (expr);\n+  TREE_TYPE (expr) = type;\n+  if (TREE_CONSTANT (expr) != was_constant) abort ();\n+  TREE_CONSTANT (expr) = was_constant;\n+  return expr;\n+}\n+\n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.\n+\n+   In CHILL, we assume that the type is Compatible with the\n+   Class of expr, and generally complain otherwise.\n+   However, convert is more general (e.g. allows enum<->int\n+   conversion), so there should probably be at least two routines.\n+   Maybe add something like convert_for_assignment.  FIXME. */\n+\n+tree\n+convert (type, expr)\n+     tree type, expr;\n+{\n+  register tree e = expr;\n+  register enum chill_tree_code code;\n+  char *errstr;\n+  int type_varying;\n+\n+  if (e == NULL_TREE || TREE_CODE (e) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n+    return error_mark_node;\n+\n+  code = TREE_CODE (type);\n+\n+  if (type == TREE_TYPE (e))\n+    return e;\n+\n+  if (TREE_TYPE (e) != NULL_TREE\n+      && TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n+    e = convert_from_reference (e);\n+\n+  /* Support for converting *to* a reference type is limited;\n+     it is only here as a convenience for loc-identity declarations,\n+     and loc parameters. */\n+  if (code == REFERENCE_TYPE)\n+    return convert_to_reference (type, e);\n+\n+  /* if expression was untyped because of its context (an if_expr or case_expr\n+     in a tuple, perhaps) just apply the type */\n+  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n+    {\n+      TREE_TYPE (e) = type;\n+      return e;\n+    }\n+\n+  /* Turn a NULL keyword into [0, 0] for an instance */\n+  if (CH_IS_INSTANCE_MODE (type) && expr == null_pointer_node)\n+    {\n+      tree field0 = TYPE_FIELDS (type);\n+      tree field1 = TREE_CHAIN (field0);\n+      e = build (CONSTRUCTOR, type, NULL_TREE,\n+\t\t tree_cons (field0, integer_zero_node,\n+\t\t\t    tree_cons (field1, integer_zero_node,\n+\t\t\t\t       NULL_TREE)));\n+      TREE_CONSTANT (e) = 1;\n+      TREE_STATIC (e) = 1;\n+      return e;\n+    }\n+\n+  /* Turn a pointer into a function pointer for a procmode */\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n+      && expr == null_pointer_node)\n+    return convert1 (type, expr);\n+\n+  /* turn function_decl expression into a pointer to \n+     that function */\n+  if (TREE_CODE (expr) == FUNCTION_DECL\n+      && TREE_CODE (type) == POINTER_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    {\n+      e = build1 (ADDR_EXPR, type, expr);\n+      TREE_CONSTANT (e) = 1;\n+      return e;\n+    }\n+\n+  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == RECORD_TYPE)\n+    e = varying_to_slice (e);\n+  type_varying   = chill_varying_type_p (type);\n+\n+  /* Convert a char to a singleton string.\n+     Needed for compatibility with 1984 version of Z.200. */\n+  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == CHAR_TYPE\n+      && (CH_CHARS_ONE_P (type) || type_varying))\n+    {\n+      if (TREE_CODE (e) == INTEGER_CST)\n+\t{\n+\t  char ch = TREE_INT_CST_LOW (e);\n+\t  e = build_chill_string (1, &ch);\n+\t}\n+      else\n+\te = build (CONSTRUCTOR, string_one_type_node, NULL_TREE,\n+\t\t   tree_cons (NULL_TREE, e, NULL_TREE));\n+    }\n+\n+  /* Convert a Boolean to a singleton bitstring.\n+     Needed for compatibility with 1984 version of Z.200. */\n+  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == BOOLEAN_TYPE\n+      && (CH_BOOLS_ONE_P (type) || type_varying))\n+    {\n+      if (TREE_CODE (e) == INTEGER_CST)\n+\te = integer_zerop (e) ? bit_zero_node : bit_one_node;\n+      else\n+\te = build (COND_EXPR, bitstring_one_type_node,\n+\t\t   e, bit_one_node, bit_zero_node);\n+    }\n+\n+  if (type_varying)\n+    {\n+      tree nentries;\n+      tree field0 = TYPE_FIELDS (type);\n+      tree field1 = TREE_CHAIN (field0);\n+      tree orig_e = e;\n+      tree target_array_type = TREE_TYPE (field1);\n+      tree needed_padding;\n+      tree padding_max_size = 0;\n+      int orig_e_constant = TREE_CONSTANT (orig_e);\n+      if (TREE_TYPE (e) != NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (e)) == ARRAY_TYPE)\n+\t{\n+\t  /* Note that array_type_nelts returns 1 less than the size. */\n+\t  nentries = array_type_nelts (TREE_TYPE (e));\n+\t  needed_padding = size_binop (MINUS_EXPR,\n+\t\t\t\t       array_type_nelts (target_array_type),\n+\t\t\t\t       nentries);\n+\t  if (TREE_CODE (needed_padding) != INTEGER_CST)\n+\t    {\n+\t      padding_max_size = size_in_bytes (TREE_TYPE (e));\n+\t      if (TREE_CODE (padding_max_size) != INTEGER_CST)\n+\t\tpadding_max_size = TYPE_ARRAY_MAX_SIZE (TREE_TYPE (e));\n+\t    }\n+\t  nentries = size_binop (PLUS_EXPR, nentries, integer_one_node);\n+\t}\n+      else if (TREE_CODE (e) == CONSTRUCTOR)\n+\t{\n+\t  HOST_WIDE_INT init_cnt = 0;\n+\t  tree chaser = CONSTRUCTOR_ELTS (e);\n+\t  for ( ; chaser; chaser = TREE_CHAIN (chaser))\n+\t    init_cnt++;               /* count initializer elements */\n+\t  nentries = build_int_2 (init_cnt, 0);\n+\t  needed_padding = integer_zero_node;\n+\t  if (TREE_TYPE (e) == NULL_TREE)\n+\t    e = digest_array_tuple (TREE_TYPE (field1), e, 1);\n+\t  orig_e_constant = TREE_CONSTANT (e);\n+\t}\n+      else\n+\t{\n+\t  error (\"initializer is not an array or string mode\");\n+\t  return error_mark_node;\n+\t}\n+#if 0\n+      FIXME check that nentries will fit in type;\n+#endif\n+      if (!integer_zerop (needed_padding))\n+\t{\n+\t  tree padding, padding_type, padding_range;\n+\t  if (TREE_CODE (needed_padding) == INTEGER_CST\n+\t      && (long)TREE_INT_CST_LOW (needed_padding) < 0)\n+\t    {\n+\t      error (\"destination is too small\");\n+\t      return error_mark_node;\n+\t    }\n+\t  padding_range = build_chill_range_type (NULL_TREE, integer_one_node,\n+\t\t\t\t\t\t  needed_padding);\n+\t  padding_type\n+\t    = build_simple_array_type (TREE_TYPE (target_array_type),\n+\t\t\t\t       padding_range, NULL_TREE);\n+\t  TYPE_ARRAY_MAX_SIZE (padding_type) = padding_max_size;\n+\t  if (CH_CHARS_TYPE_P (target_array_type))\n+\t    MARK_AS_STRING_TYPE (padding_type);\n+\t  padding = build (UNDEFINED_EXPR, padding_type);\n+\t  if (TREE_CONSTANT (e))\n+\t    e = build_chill_binary_op (CONCAT_EXPR, e, padding);\n+\t  else\n+\t    e = build (CONCAT_EXPR, target_array_type, e, padding);\n+\t}\n+      e = convert (TREE_TYPE (field1), e);\n+      /* We build this constructor by hand (rather than going through\n+\t digest_structure_tuple), to avoid some type-checking problem.\n+\t E.g. type may have non-null novelty, but its field1 will\n+\t have non-novelty. */\n+      e = build (CONSTRUCTOR, type, NULL_TREE,\n+\t\t    tree_cons (field0, nentries,\n+\t\t\t       build_tree_list (field1, e)));\n+      /* following was wrong, cause orig_e never will be TREE_CONSTANT. e\n+\t may become constant after digest_array_tuple. */\n+      if (TREE_CONSTANT (nentries) && orig_e_constant) /* TREE_CONSTANT (orig_e)) */\n+\t{\n+\t  TREE_CONSTANT (e) = 1;\n+\t  if (TREE_STATIC (nentries) && TREE_STATIC (orig_e))\n+\t    TREE_STATIC (e) = 1;\n+\t}\n+    }\n+  if (TREE_TYPE (e) == NULL_TREE)\n+    {\n+      if (TREE_CODE (e) == CONSTRUCTOR)\n+\t{\n+\t  if (TREE_CODE (type) == SET_TYPE)\n+\t    return digest_powerset_tuple (type, e);\n+\t  if (TREE_CODE (type) == RECORD_TYPE)\n+\t    return digest_structure_tuple (type, e);\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    return digest_array_tuple (type, e, 0);\n+\t  fatal (\"internal error - bad CONSTRUCTOR passed to convert\");\n+\t}\n+      else if (TREE_CODE (e) == COND_EXPR)\n+\te = build (COND_EXPR, type,\n+\t\t   TREE_OPERAND (e, 0),\n+\t\t   convert (type, TREE_OPERAND (e, 1)),\n+\t\t   convert (type, TREE_OPERAND (e, 2)));\n+      else if (TREE_CODE (e) == CASE_EXPR)\n+\tTREE_TYPE (e) = type;\n+      else\n+\t{\n+\t  error (\"internal error:  unknown type of expression\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e))\n+      || (CH_NOVELTY (type) != NULL_TREE\n+\t  && CH_NOVELTY (type) == CH_NOVELTY (TREE_TYPE (e))))\n+    return convert1 (type, e);\n+\n+  if (TREE_CODE (TREE_TYPE (e)) == VOID_TYPE)\n+    {\n+      error (\"void value not ignored as it ought to be\");\n+      return error_mark_node;\n+    }\n+  if (code == VOID_TYPE)\n+    return build1 (CONVERT_EXPR, type, e);\n+\n+  if (code == SET_TYPE)\n+    return convert1 (type, e);\n+\n+  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n+    {\n+      if (flag_old_strings)\n+\t{\n+\t  if (CH_CHARS_ONE_P (TREE_TYPE (e)))\n+\t    e = convert_to_char (char_type_node, e);\n+\t  else if (CH_BOOLS_ONE_P (TREE_TYPE (e)))\n+\t    e = convert_to_boolean (boolean_type_node, e);\n+\t}\n+      return fold (convert_to_integer (type, e));\n+    }\n+  if (code == POINTER_TYPE)\n+    return fold (convert_to_pointer (type, e));\n+  if (code == REAL_TYPE)\n+    return fold (convert_to_real (type, e));\n+  if (code == BOOLEAN_TYPE)\n+    return fold (convert_to_boolean (type, e));\n+  if (code == CHAR_TYPE)\n+    return fold (convert_to_char (type, e));\n+\n+  if (code == ARRAY_TYPE && TYPE_MODE (type) != TYPE_MODE (TREE_TYPE (e)))\n+    {\n+      /* The mode of the expression is different from that of the type.\n+\t Earlier checks should have tested against different lengths.\n+\t But even if the lengths are the same, it is possible that one\n+\t type is a static type (and hence could be say SImode), while the\n+\t other type is dynamic type (and hence is BLKmode).\n+\t This causes problems when emitting instructions.  */\n+      tree ee = build1 (INDIRECT_REF, type,\n+\t\t\tbuild1 (NOP_EXPR, build_pointer_type (type),\n+\t\t\t\tbuild1 (ADDR_EXPR,\n+\t\t\t\t\tbuild_pointer_type (TREE_TYPE (e)),\n+\t\t\t\t\te)));\n+      TREE_READONLY (ee) = TYPE_READONLY (type);\n+      return ee;\n+    }\n+\n+  /* The default! */\n+  return convert1 (type, e);\n+}\n+\n+/* Return an expression whose value is EXPR, but whose class is CLASS. */\n+\n+tree\n+convert_to_class (class, expr)\n+     struct ch_class class;\n+     tree expr;\n+{\n+  switch (class.kind)\n+    {\n+    case CH_NULL_CLASS:\n+    case CH_ALL_CLASS:\n+      return expr;\n+    case CH_DERIVED_CLASS:\n+      if (TREE_TYPE (expr) != class.mode)\n+\texpr = convert (class.mode, expr);\n+      if (!CH_DERIVED_FLAG (expr))\n+\t{\n+\t  expr = copy_node (expr);\n+\t  CH_DERIVED_FLAG (expr) = 1;\n+\t}\n+      return expr;\n+    case CH_VALUE_CLASS:\n+    case CH_REFERENCE_CLASS:\n+      if (TREE_TYPE (expr) != class.mode)\n+\texpr = convert (class.mode, expr);\n+      if (CH_DERIVED_FLAG (expr))\n+\t{\n+\t  expr = copy_node (expr);\n+\t  CH_DERIVED_FLAG (expr) = 0;\n+\t}\n+      return expr;\n+    }\n+  return expr;\n+}"}, {"sha": "57842b03984c997444c58ecc86917325a7b03c1f", "filename": "gcc/ch/decl.c", "status": "added", "additions": 5176, "deletions": 0, "changes": 5176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fdecl.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93"}, {"sha": "16b1e3c6a1078816f904148db119ed7a1f9bbf29", "filename": "gcc/ch/expr.c", "status": "added", "additions": 4493, "deletions": 0, "changes": 4493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexpr.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93"}, {"sha": "be02c117e5ea5f7cd4f216bc359a3508f167ec16", "filename": "gcc/ch/lang-specs.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang-specs.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,42 @@\n+/* Definitions for specs for GNU CHILL.\n+   Copyright (C) 1995 Free Software Foundation, Inc..\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This is the contribution to the `default_compilers' array in gcc.c for\n+   CHILL.  */\n+\n+  {\".ch\",   \"@chill\" },\n+  {\".chi\",  \"@chill\" },\n+  {\"@chill\",\n+   \"cpp -lang-chill %{nostdinc*} %{C} %{v} %{A*} %{I*} %{P} %I\\\n+\t%{C:%{!E:%eGNU CHILL does not support -C without using -E}}\\\n+        -undef -D__GNUCHILL__=%v1 -D__GNUC_MINOR__=%v2\\\n+        %c %{Os:-D__OPTIMIZE_SIZE__} %{O*:-D__OPTIMIZE__} %{traditional} %{ftraditional:-traditional}\\\n+        %{traditional-cpp:-traditional} %{!undef:%{!ansi:%p} %P} %{trigraphs}\\\n+\t%{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z\\\n+        %i %{!E:%g.i}%{E:%W{o*}} \\n\",\n+   \"%{!E:cc1chill %g.i %1 \\\n+\t\t   %{!Q:-quiet} -dumpbase %b.ch %{d*} %{m*} %{a}\\\n+\t\t   %{g*} %{O*} %{W*} %{w} %{pedantic*} %{itu} \\\n+\t\t   %{v:-version} %{pg:-p} %{p} %{f*} %{I*} \\\n+\t\t   %{aux-info*} %X \\\n+\t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n+\t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n+              %{!S:as %a %Y \\\n+\t\t      %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\\\n+                      %{!pipe:%g.s} %A\\n }}\"},"}, {"sha": "b52bca657ebe3553b0e7cc7de6253213dc5e32ea", "filename": "gcc/ch/lang.c", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,306 @@\n+/* Language-specific hook definitions for CHILL front end.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"ch-tree.h\"\n+#include \"lex.h\"\n+#include <stdio.h>\n+#include \"input.h\"\n+\n+/* Type node for boolean types.  */\n+\n+tree boolean_type_node;\n+\n+/* True if STRING(INDEX) yields a CHARS(1) (or BOOLS(1)) rather than\n+   a CHAR (or BOOL).  Also, makes CHARS(1) similar for CHAR,\n+   and BOOLS(1) similar to BOOL.  This is for compatibility\n+   for the 1984 version of Z.200.*/\n+int flag_old_strings = 0;\n+\n+/* This is set non-zero to force user input tokens to lower case.\n+   This is non-standard.  See Z.200, page 8. */\n+int ignore_case = 1;\n+\n+/* True if reserved and predefined words ('special' words in the Z.200\n+   terminology) are in uppercase.  Obviously, this had better not be \n+   true if we're ignoring input case. */\n+int special_UC = 0;\n+\n+/* The actual name of the input file, regardless of any #line directives */\n+char* chill_real_input_filename;\n+extern FILE* finput;\n+\n+extern int maximum_field_alignment;\n+\n+extern void error             PROTO((char *, ...));\n+extern void error_with_decl   PROTO((tree, char *, ...));\n+extern void fatal             PROTO((char *, ...));\n+extern int  floor_log2_wide   PROTO((unsigned HOST_WIDE_INT));\n+extern void pedwarn_with_decl PROTO((tree, char *, ...));\n+extern void sorry             PROTO((char *, ...));\n+extern int  type_hash_list    PROTO((tree));\n+\f\n+/* return 1 if the expression tree given has all\n+   constant nodes as its leaves; return 0 otherwise. */\n+int\n+deep_const_expr (exp)\n+     tree exp;\n+{\n+  enum chill_tree_code code;\n+  int length;\n+  int i;\n+\n+  if (exp == NULL_TREE)\n+    return 0;\n+\n+  code = TREE_CODE (exp);\n+  length = tree_code_length[(int) code];\n+\n+  /* constant leaf?  return TRUE */\n+  if (TREE_CODE_CLASS (code) == 'c')\n+    return 1;\n+\n+  /* recursively check next level down */\n+  for (i = 0; i < length; i++)\n+    if (! deep_const_expr (TREE_OPERAND (exp, i)))\n+      return 0;\n+  return 1;      \n+}\n+\n+\n+tree\n+const_expr (exp)\n+     tree exp;\n+{\n+  if (TREE_CODE (exp) == INTEGER_CST)\n+    return exp;\n+  if (TREE_CODE (exp) == CONST_DECL)\n+    return const_expr (DECL_INITIAL (exp));\n+  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+      && DECL_INITIAL (exp) != NULL_TREE\n+      && TREE_READONLY (exp))\n+    return DECL_INITIAL (exp);\n+  if (deep_const_expr (exp))\n+    return exp;\n+  if (TREE_CODE (exp) != ERROR_MARK)\n+    error (\"non-constant expression\");\n+  return error_mark_node;\n+}\n+\n+/* Each of the functions defined here\n+   is an alternative to a function in objc-actions.c.  */\n+   \n+/* Used by c-lex.c, but only for objc.  */\n+tree\n+lookup_interface (arg)\n+     tree arg;\n+{\n+  return 0;\n+}\n+\n+int\n+maybe_objc_comptypes (lhs, rhs)\n+     tree lhs, rhs;\n+{\n+  return -1;\n+}\n+\n+tree\n+maybe_building_objc_message_expr ()\n+{\n+  return 0;\n+}\n+\n+int\n+recognize_objc_keyword ()\n+{\n+  return 0;\n+}\n+\n+void\n+lang_init_options ()\n+{\n+}\n+\n+/* used by print-tree.c */\n+\n+void\n+lang_print_xnode (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+}\n+\n+void\n+GNU_xref_begin ()\n+{\n+  fatal (\"GCC does not yet support XREF\");\n+}\n+\n+void\n+GNU_xref_end ()\n+{\n+  fatal (\"GCC does not yet support XREF\");\n+}\n+\f\n+/*\n+ * process chill-specific compiler command-line options\n+ */\n+int\n+lang_decode_option (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *p = argv[0];\n+  static explicit_ignore_case = 0;\n+  if (!strcmp(p, \"-lang-chill\"))\n+    ; /* do nothing */\n+  else if (!strcmp (p, \"-fruntime-checking\"))\n+    {\n+      range_checking = 1;\n+      empty_checking = 1;\n+    }\n+  else if (!strcmp (p, \"-fno-runtime-checking\"))\n+    {\n+      range_checking = 0;\n+      empty_checking = 0;\n+      runtime_checking_flag = 0;\n+    }\n+  else if (!strcmp (p, \"-flocal-loop-counter\"))\n+    flag_local_loop_counter = 1;\n+  else if (!strcmp (p, \"-fno-local-loop-counter\"))\n+    flag_local_loop_counter = 0;\n+  else if (!strcmp (p, \"-fold-strings\"))\n+    flag_old_strings = 1;\n+  else if (!strcmp (p, \"-fno-old-strings\"))\n+    flag_old_strings = 0;\n+  else if (!strcmp (p, \"-fignore-case\"))\n+    {\n+      explicit_ignore_case = 1;\n+      if (special_UC)\n+\t{\n+\t  error (\"Ignoring case upon input and\");\n+\t  error (\"making special words uppercase wouldn't work.\");\n+\t}\n+      else\n+\tignore_case = 1;\n+    }\n+  else if (!strcmp (p, \"-fno-ignore-case\"))\n+    ignore_case = 0;\n+  else if (!strcmp (p, \"-fspecial_UC\"))\n+    {\n+      if (explicit_ignore_case)\n+\t{\n+\t  error (\"Making special words uppercase and\");\n+\t  error (\" ignoring case upon input wouldn't work.\");\n+\t}\n+      else\n+\tspecial_UC = 1, ignore_case = 0;\n+    }\n+  else if (!strcmp (p, \"-fspecial_LC\"))\n+    special_UC = 0;\n+  else if (!strcmp (p, \"-fpack\"))\n+    maximum_field_alignment = BITS_PER_UNIT;\n+  else if (!strcmp (p, \"-fno-pack\"))\n+    maximum_field_alignment = 0;\n+  else if (!strcmp (p, \"-fchill-grant-only\"))\n+    grant_only_flag = 1;\n+  else if (!strcmp (p, \"-fgrant-only\"))\n+    grant_only_flag = 1;\n+  /* user has specified a seize-file path */\n+  else if (p[0] == '-' && p[1] == 'I')\n+    register_seize_path (&p[2]);\n+  if (!strcmp(p, \"-itu\"))        /* Force Z.200 semantics */\n+    {\n+      pedantic = 1;   /* FIXME: new flag name? */\n+      flag_local_loop_counter = 1;      \n+    }\n+  else\n+    return c_decode_option (argc, argv);\n+\n+  return 1;\n+}\n+\n+void\n+chill_print_error_function (file)\n+     char *file;\n+{\n+  static tree last_error_function = NULL_TREE;\n+  static struct module *last_error_module = NULL;\n+\n+  if (last_error_function == current_function_decl\n+      && last_error_module == current_module)\n+    return;\n+\n+  last_error_function = current_function_decl;\n+  last_error_module = current_module;\n+\n+  if (file)\n+    fprintf (stderr, \"%s: \", file);\n+\n+  if (current_function_decl == global_function_decl\n+      || current_function_decl == NULL_TREE)\n+    {\n+      if (current_module == NULL)\n+\tfprintf (stderr, \"At top level:\\n\");\n+      else\n+\tfprintf (stderr, \"In module %s:\\n\",\n+\t\t IDENTIFIER_POINTER (current_module->name));\n+    }\n+  else\n+    {\n+      char *kind = \"function\";\n+      char *name = (*decl_printable_name) (current_function_decl, 2);\n+      fprintf (stderr, \"In %s `%s':\\n\", kind, name);\n+    }\n+}\n+\n+/* Print an error message for invalid use of an incomplete type.\n+   VALUE is the expression that was used (or 0 if that isn't known)\n+   and TYPE is the type that was invalid.  */\n+\n+void\n+incomplete_type_error (value, type)\n+     tree value;\n+     tree type;\n+{\n+  error (\"internal error - use of undefined type\");\n+}\n+\n+void\n+lang_init ()\n+{\n+  extern void (*print_error_function) PROTO((char*));\n+\n+  chill_real_input_filename = input_filename;\n+\n+  /* the beginning of the file is a new line; check for # */\n+  /* With luck, we discover the real source file's name from that\n+     and put it in input_filename.  */\n+\n+  ungetc (check_newline (), finput);\n+\n+  /* set default grant file */\n+  set_default_grant_file ();\n+\n+  print_error_function = chill_print_error_function;\n+}"}, {"sha": "32f72e5d249793b10ec23efccbb8d3ab47c6e740", "filename": "gcc/ch/parse.c", "status": "added", "additions": 4237, "deletions": 0, "changes": 4237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fparse.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93"}, {"sha": "8cf2be5c4860dd05f529668e19cd6ec86ec5e946", "filename": "gcc/ch/runtime/allmem.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fallmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fallmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fallmem.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,73 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include <stdlib.h>\n+#include \"config.h\"\n+#include \"rtltypes.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/* define needed exceptions */\n+EXCEPTION (protectionfail);\n+EXCEPTION (rangefail);\n+EXCEPTION (spacefail);\n+\n+/*\n+ * function _allocate_memory\n+ *\n+ * parameters:\n+ *  ptr\t\t\tpointer to location where pointer should be written\n+ *  size\t\tnumber of bytes to allocate\n+ *  filename            source file which issued the call\n+ *  linenumber          line number within that source file\n+ *\n+ * returns:\n+ *  void\n+ *\n+ * exceptions:\n+ *  spacefail\n+ *  protectionfail\n+ *  rangefail\n+ *\n+ * abstract:\n+ *  allocate memory from heap\n+ *\n+*/\n+\n+void\n+_allocate_memory (ptr, size, filename, linenumber)\n+     void **ptr;\n+     int size;\n+     char *filename;\n+     int   linenumber;\n+{\n+  void\t*tmp;\n+    \n+  if (!ptr)\n+    __cause_ex1 (\"protectionfail\", filename, linenumber);\n+  if (size < 0)\n+    __cause_ex1 (\"rangefail\", filename, linenumber);\n+  tmp = malloc (size);\n+  if (!tmp)\n+    __cause_ex1 (\"spacefail\", filename, linenumber);\n+  *ptr = tmp;\n+}"}, {"sha": "fd7d609a930e28973504698d4cc6559338dae771", "filename": "gcc/ch/runtime/andps.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fandps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fandps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fandps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,76 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __andpowerset\n+ *\n+ * parameters:\n+ *\tout\t\treturn from __andpowerset\n+ *\tleft\t\tleft powerset\n+ *\tright\t\tright powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *\tvoid\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  and's two powersets\n+ *\n+ */\n+\n+void\n+__andpowerset (out, left, right, bitlength)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      *((SET_CHAR *)out) = *((SET_CHAR *)left) &\n+                           *((SET_CHAR *)right);\n+      MASK_UNUSED_CHAR_BITS((SET_CHAR *)out, bitlength);\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      *((SET_SHORT *)out) = *((SET_SHORT *)left) &\n+                            *((SET_SHORT *)right);\n+      MASK_UNUSED_SHORT_BITS((SET_SHORT *)out, bitlength);\n+    }\n+  else\n+    {\n+      unsigned long len = BITS_TO_WORDS (bitlength);\n+      register unsigned long i;\n+    \n+      for (i = 0; i < len; i++)\n+\tout[i] = left[i] & right[i];\n+      MASK_UNUSED_WORD_BITS ((out + len - 1), \n+\t\t\t     bitlength % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "627da113eea03b2611a9fb5f95b5d62df38c9aaf", "filename": "gcc/ch/runtime/auxtypes.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fauxtypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fauxtypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fauxtypes.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,45 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _auxtypes_h_\n+#define _auxtypes_h_\n+\n+\n+typedef enum { False, True } Boolean;\n+\n+#define VARYING_STRING(strlen) \\\n+  struct { unsigned short len; char body[strlen]; }\n+\n+typedef struct {\n+  unsigned short len;\n+  char           body[1];\n+} VarString; \n+\n+/* Macros for moving an (U)INT and (U)LONG without alignment worries */\n+#define MOV2(tgt,src) \\\n+  *((char*)(tgt)  ) = *((char*)(src)  ), \\\n+  *((char*)(tgt)+1) = *((char*)(src)+1)\n+#define MOV4(tgt,src) \\\n+  *((char*)(tgt)  ) = *((char*)(src)  ), \\\n+  *((char*)(tgt)+1) = *((char*)(src)+1), \\\n+  *((char*)(tgt)+2) = *((char*)(src)+2), \\\n+  *((char*)(tgt)+3) = *((char*)(src)+3)\n+\n+#endif"}, {"sha": "b13b0b8debfdfec4c7feaebfd021c679affd41e8", "filename": "gcc/ch/runtime/basicio.c", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fbasicio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fbasicio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fbasicio.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,467 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+   \n+   This file is part of GNU CC.\n+   \n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <errno.h>\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include \"fileio.h\"\n+\n+#ifndef PATH_MAX\n+#define PATH_MAX _POSIX_PATH_MAX\n+#endif\n+\n+static\n+void\n+GetSetAttributes( Association_Mode* the_assoc )\n+{\n+  struct stat statbuf;\n+  int retco;\n+\n+  if( (retco = stat( the_assoc->pathname, &statbuf )) )\n+    return;\n+\n+  if( S_ISREG(statbuf.st_mode) )\n+    {\n+      SET_FLAG( the_assoc, IO_EXISTING );\n+      if( !TEST_FLAG( the_assoc, IO_VARIABLE ) )\n+        SET_FLAG( the_assoc, IO_INDEXABLE );\n+    }\n+  else\n+    if( S_ISCHR(statbuf.st_mode) || S_ISFIFO(statbuf.st_mode) )\n+      {\n+\tSET_FLAG( the_assoc, IO_EXISTING );\n+\tCLR_FLAG( the_assoc, IO_INDEXABLE );\n+      }\n+  SET_FLAG( the_assoc, IO_SEQUENCIBLE );\n+\n+  /* FIXME: File size and computation of number of records for outoffile ? */\n+\n+  if( !access( the_assoc->pathname, R_OK ) )\n+    SET_FLAG( the_assoc, IO_READABLE );\n+  if( !access( the_assoc->pathname, W_OK ) )\n+    SET_FLAG( the_assoc, IO_WRITEABLE );\n+}\n+\n+static\n+void \n+makeName( Association_Mode* the_assoc, char* the_path, int the_path_len,\n+\t char* file, int line)\n+{\n+  int namlen;\n+  if( ! the_assoc->pathname && \n+      ! (the_assoc->pathname = (char*)malloc( PATH_MAX )) )\n+    CHILLEXCEPTION( file, line, SPACEFAIL, PATHNAME_ALLOC );\n+\n+  if( the_path[0] != DIRSEP )\n+    {\n+      if( !getcwd( the_assoc->pathname, PATH_MAX ) )\n+\t{\n+\t  the_assoc->syserrno = errno;\n+\t  CHILLEXCEPTION( file, line, ASSOCIATEFAIL, GETCWD_FAILS );\n+\t}\n+      namlen = strlen( the_assoc->pathname );\n+      the_assoc->pathname[namlen++] = DIRSEP;  \n+    }\n+  else\n+    namlen = 0;\n+\n+  strncpy( the_assoc->pathname + namlen, the_path, the_path_len );\n+  the_assoc->pathname[namlen+the_path_len] = '\\0';\n+}\n+\n+/*\n+ * ASSOCIATE\n+ */\n+/* Caution: returns an Association mode location (!) */\n+Association_Mode*\n+__associate( Association_Mode* the_assoc,\n+\t     char*             the_path,\n+\t     int               the_path_len,\n+\t     char*             the_mode,\n+\t     int               the_mode_len,\n+\t     char*             file,\n+\t     int               line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, ASSOCIATEFAIL, IS_ASSOCIATED );\n+\n+  /* clear all flags */\n+  the_assoc->flags = 0;\n+\n+  if( ! the_path_len )\n+    CHILLEXCEPTION( file, line, ASSOCIATEFAIL, NO_PATH_NAME );\n+\n+  makeName( the_assoc, the_path, the_path_len, file, line );\n+  GetSetAttributes( the_assoc );\n+\n+  CLR_FLAG( the_assoc, IO_VARIABLE );\n+  if ( the_mode )\n+    {\n+      if( !strncmp( the_mode, \"VARIABLE\", 8 ) )\n+\t{\n+\t  SET_FLAG( the_assoc, IO_VARIABLE );\n+\t  CLR_FLAG( the_assoc, IO_INDEXABLE );\n+\t}\n+      else\n+\tif( strlen( the_mode ) )\n+\t  CHILLEXCEPTION( file, line, ASSOCIATEFAIL, INVALID_ASSOCIATION_MODE );\n+    }\n+\n+  SET_FLAG( the_assoc, IO_ISASSOCIATED );\n+  return the_assoc;\n+}\n+\n+/*\n+ *  DISSOCIATE\n+ */\n+void\n+__dissociate( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( !TEST_FLAG( the_assoc, IO_ISASSOCIATED ) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+\n+  if( the_assoc->access )\n+    __disconnect( the_assoc->access, file, line );\n+\n+  the_assoc->access = NULL;\n+  CLR_FLAG( the_assoc, IO_ISASSOCIATED );\n+\n+  /* free allocated memory */\n+  if (the_assoc->pathname)\n+    {\n+      free (the_assoc->pathname);\n+      the_assoc->pathname = 0;\n+    }\n+  if (the_assoc->bufptr)\n+    {\n+      free (the_assoc->bufptr);\n+      the_assoc->bufptr = 0;\n+    }\n+}\n+\n+/*\n+ * CREATE\n+ */\n+void __create( Association_Mode* the_assoc, char* file, int line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( !TEST_FLAG( the_assoc, IO_ISASSOCIATED ) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+\n+  if( TEST_FLAG( the_assoc, IO_EXISTING ) )\n+    CHILLEXCEPTION( file, line, CREATEFAIL, FILE_EXISTING );\n+\n+  if( (the_assoc->handle = open( the_assoc->pathname, O_CREAT+O_TRUNC+O_WRONLY, 0666 ))\n+      == -1 )\n+      CHILLEXCEPTION( file, line, CREATEFAIL, CREATE_FAILS );\n+\n+  the_assoc->usage = ReadWrite;\n+  GetSetAttributes( the_assoc );\n+\n+  close( the_assoc->handle );\n+}\n+\n+/*\n+ * MODIFY\n+ */\n+void\n+__modify( Association_Mode* the_assoc,\n+\t  char*             the_path,\n+\t  int               the_path_len,\n+\t  char*             the_mode,\n+\t  int               the_mode_len,\n+\t  char*             file,\n+\t  int               line )\n+{\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( !TEST_FLAG( the_assoc, IO_ISASSOCIATED ) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+\n+  if( the_path_len )\n+    {\n+      char* oldname;\n+\n+      if( ! (oldname = (char*)malloc( PATH_MAX )) )\n+\tCHILLEXCEPTION( file, line, SPACEFAIL, PATHNAME_ALLOC );\n+      strcpy( oldname, the_assoc->pathname );\n+\n+      makeName( the_assoc, the_path, the_path_len, file, line );\n+\n+      if( rename( oldname, the_assoc->pathname ) )\n+\t{\n+\t  free( oldname );\n+\t  CHILLEXCEPTION( file, line, MODIFYFAIL, RENAME_FAILS );\n+\t}\n+      free( oldname );\n+    }\n+  else\n+    {\n+      /* FIXME: other options? */\n+    }\n+}\n+\n+static\n+/*** char* DirMode[] = { \"rb\", \"r+b\", \"r+b\" }; ***/\n+int DirMode[] = { O_RDONLY, O_RDWR, O_RDWR };\n+\n+static\n+/*** char* SeqMode [] = { \"rb\", \"r+b\", \"r+b\" }; ***/\n+int SeqMode[] = { O_RDONLY, O_RDWR, O_RDWR };\n+\n+/*\n+ * CONNECT\n+ */\n+void\n+__connect( void*             the_transfer,\n+\t   Association_Mode* the_assoc,\n+\t   Usage_Mode        the_usage,\n+\t   Where_Mode        the_where,\n+\t   Boolean           with_index,\n+\t   signed long       the_index,\n+\t   char*             file,\n+\t   int               line )\n+{\n+  Access_Mode*  the_access;\n+  off_t         filepos;\n+  off_t         savepos;\n+  char          dummy;\n+  unsigned long nbytes;\n+  int           oflag;\n+\n+  if( !the_transfer )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+  if( !the_assoc )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ASSOCIATION );\n+\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ))\n+    {\n+      if( ! ((Text_Mode*)the_transfer)->access_sub )\n+\tCHILLEXCEPTION( file, line, EMPTY, NO_ACCESS_SUBLOCATION );\n+      the_access = ((Text_Mode*)the_transfer)->access_sub;\n+      SET_FLAG( the_access, IO_TEXTIO );\n+    }\n+  else\n+    {\n+      the_access = (Access_Mode*)the_transfer;\n+      CLR_FLAG( the_access, IO_TEXTIO );\n+    }\n+\n+  /* FIXME: This should be an (implementation-dependent) static check\n+     if( with_index && the_access->rectype > Fixed )\n+     CHILLEXCEPTION( file, line, CONNECTFAIL, IMPL_RESTRICTION );\n+     */\n+\n+  if( ! TEST_FLAG(the_assoc, IO_ISASSOCIATED) )\n+    CHILLEXCEPTION( file, line, NOTASSOCIATED, IS_NOT_ASSOCIATED );\n+\n+  if( ! TEST_FLAG( the_assoc, IO_EXISTING ) )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_EXISTING );\n+\n+  if( ! TEST_FLAG( the_assoc, IO_READABLE ) &&\n+      ( the_usage = ReadOnly || the_usage == ReadWrite ) )    \n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_READABLE );\n+\n+  if( ! TEST_FLAG( the_assoc, IO_WRITEABLE ) &&\n+      ( the_usage = WriteOnly || the_usage == ReadWrite ) )    \n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_WRITEABLE );\n+\n+  if( ! TEST_FLAG( the_assoc, IO_INDEXABLE ) \n+      && TEST_FLAG( the_access, IO_INDEXED ) )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_INDEXABLE );\n+\n+  if( ! TEST_FLAG( the_assoc, IO_SEQUENCIBLE ) \n+      && ! TEST_FLAG( the_access, IO_INDEXED ) )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_SEQUENCIBLE );\n+\n+  if( the_where == Same && the_assoc->access == NULL )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NO_CURRENT_POS );\n+\n+  /* This dynamic condition is not checked for text connections. */\n+  if( ! TEST_FLAG( the_access, IO_TEXTIO ) )\n+    if( ! TEST_FLAG( the_assoc, IO_VARIABLE ) \n+\t&& the_access->rectype > Fixed \n+\t&& ( the_usage == WriteOnly || the_usage == ReadWrite ) )\n+      CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_VARIABLE );\n+ \n+  if( TEST_FLAG( the_assoc, IO_VARIABLE )\n+      && the_access->rectype == Fixed \n+      && ( the_usage == ReadOnly || the_usage == ReadWrite ) )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_FIXED );\n+ \n+  if( ! TEST_FLAG( the_access, IO_INDEXED ) && the_usage == ReadWrite )\n+    CHILLEXCEPTION( file, line, CONNECTFAIL, NOT_INDEXED );\n+\n+  /* Access location may be connected to a different association. */\n+  if( the_access->association && the_access->association != the_assoc )\n+    __disconnect( the_access, file, line );\n+\n+  /* Is the association location already connected? */\n+  if( the_assoc->access )\n+    {\n+      /* save position just in case we need it for the_where == Same */\n+      if( (savepos = lseek( the_assoc->handle, 0L, SEEK_CUR )) == -1L )\n+\tCHILLEXCEPTION( file, line, CONNECTFAIL, LSEEK_FAILS );\n+\n+      /* text: read correction, flush buffer */\n+      if( the_assoc->bufptr ){\n+\tsavepos -= the_assoc->bufptr->len - the_assoc->bufptr->cur;\n+\tthe_assoc->bufptr->len = the_assoc->bufptr->cur = 0;\n+      }\n+\n+      /* implicit disconnect */\n+      __disconnect( the_assoc->access, file, line );\n+    }\n+\n+  the_assoc->usage = the_usage;\n+  CLR_FLAG( the_access, IO_OUTOFFILE );\n+ \n+  if( TEST_FLAG( the_access, IO_INDEXED ) )\n+    {\n+      if( (the_assoc->handle = open( the_assoc->pathname, DirMode[the_usage] )) == -1 )\n+\tCHILLEXCEPTION( file, line, CONNECTFAIL, OPEN_FAILS );\n+\n+      /* Set base index. */\n+      switch( the_where )\n+\t{\n+\tcase First: \n+\t  filepos = 0;\n+\t  break;\n+\tcase Same: \n+\t  filepos = savepos;\n+\t  break;\n+\tcase Last: \n+\t  if( lseek( the_assoc->handle, 0L, SEEK_END ) == -1L )\n+\t    CHILLEXCEPTION( file, line, CONNECTFAIL, LSEEK_FAILS );\n+\t  filepos = lseek( the_assoc->handle, 0L, SEEK_CUR );\n+\t  break;\n+\t}\n+\n+      /* Set current index */\n+      if( with_index )\n+\t{\n+\t  if( the_index < the_access->lowindex\n+\t      || the_access->highindex < the_index )\n+\t    CHILLEXCEPTION( file, line, RANGEFAIL, BAD_INDEX );\n+\t  filepos += (the_index - the_access->lowindex) * the_access->reclength;\n+\t}\n+      if( lseek( the_assoc->handle, filepos, SEEK_SET ) == -1L )\n+\tCHILLEXCEPTION( file, line, CONNECTFAIL, LSEEK_FAILS );\n+      the_access->base = filepos;\n+    }\n+  else\n+    {\n+      /* for association to text for reading: allocate buffer */\n+      if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ) &&\n+\t  the_usage == ReadOnly &&\n+\t  !the_assoc->bufptr )\n+\t{\n+\t  if( ! (the_assoc->bufptr = (readbuf_t*)malloc( sizeof(readbuf_t) )) )\n+\t    CHILLEXCEPTION( file, line, CONNECTFAIL, BUFFER_ALLOC ); \n+\t  memset (the_assoc->bufptr, 0, sizeof (readbuf_t));\n+\t}\n+      if( (the_assoc->handle = open( the_assoc->pathname, SeqMode[the_usage] )) == -1 )\n+\tCHILLEXCEPTION( file, line, CONNECTFAIL, OPEN_FAILS );\n+\n+      /* Set base index. */\n+      switch( the_where )\n+\t{\n+\tcase First: \n+\t  filepos = 0;\n+\t  break;\n+\tcase Same: \n+\t  filepos = savepos;\n+\t  break;\n+\tcase Last:\n+\t  if( lseek( the_assoc->handle, 0L, SEEK_END ) == -1L )\n+\t    CHILLEXCEPTION( file, line, CONNECTFAIL, LSEEK_FAILS );\n+\t  filepos = lseek( the_assoc->handle, 0L, SEEK_CUR );\n+\t  break;\n+\t}\n+\n+      /* file truncation for sequential, Write Only */\n+      /***************************** FIXME: cannot truncate at Same\n+\tif( the_usage == WriteOnly )\n+\t{\n+\tif( fseek( the_assoc->file_ptr, filepos, SEEK_SET ) == -1L )\n+        CHILLEXCEPTION( file, line, CONNECTFAIL, FSEEK_FAILS );\n+\tfclose( the_assoc->file_ptr );\n+\tif( !(the_assoc->file_ptr = fopen( the_assoc->pathname, \"ab\" )) )\n+        CHILLEXCEPTION( file, line, CONNECTFAIL, OPEN_FAILS );\n+\t}\n+\telse\n+\t***************************/\n+      if( (filepos = lseek( the_assoc->handle, filepos, SEEK_SET )) == -1L )\n+\tCHILLEXCEPTION( file, line, CONNECTFAIL, LSEEK_FAILS );\n+    }\n+\n+  the_access->association = the_assoc;\n+  the_assoc->access = the_access;\n+  /* for text: set carriage control default */\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ) ){\n+    the_assoc->ctl_pre  = '\\0';\n+    the_assoc->ctl_post = '\\n';\n+  }\n+}\n+\n+void\n+__disconnect( void* the_transfer, char* file, int line )\n+{\n+  Access_Mode* the_access;\n+\n+  if( !the_transfer )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ))\n+    {\n+      the_access = ((Text_Mode*)the_transfer)->access_sub;\n+      CLR_FLAG( the_access, IO_TEXTIO );\n+    }\n+  else\n+    the_access = (Access_Mode*)the_transfer;\n+\n+  if( !the_access->association )\n+    CHILLEXCEPTION( file, line, NOTCONNECTED, IS_NOT_CONNECTED );\n+\n+  close( the_access->association->handle );\n+  /* FIXME: check result */\n+\n+  if( the_access->store_loc )\n+    free( the_access->store_loc );\n+  the_access->store_loc           = NULL;\n+  the_access->association->access = NULL;\n+  the_access->association         = NULL;\n+}"}, {"sha": "0a8ce629c5d2b96fced15b547d4234e1f303924b", "filename": "gcc/ch/runtime/bitstring.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fbitstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fbitstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fbitstring.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,29 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _bitstring_h_\n+#define _bitstring_h_\n+\n+int __inpowerset( int i, char* string, int strlen, int dummy );\n+void __setbitpowerset (char *powerset, unsigned long bitlength,\n+\t\t       long minval, long bitno, char newval,\n+\t\t       char *filename, int lineno);\n+\t\t       \n+#endif"}, {"sha": "d4d0794409bf59281bbb4cb1c9c7b5b20dca0b56", "filename": "gcc/ch/runtime/cause.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fcause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fcause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fcause.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,48 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+\n+/*\n+ * function cause_exception\n+ *\n+ * parameters:\n+ *  exname\t\texception name\n+ *  file\t\tfile name\n+ *  lineno\t\tline number\n+ *   user_arg\t\tuser specified argument\n+ *\n+ * returns:\n+ *  void\n+ *\n+ * abstract:\n+ *  dummy for ChillLib but may be overwritten by the user\n+ *\n+ */\n+void\n+cause_exception (exname, file, lineno, user_arg)\n+     char *exname;\n+     char *file;\n+     int lineno;\n+     int user_arg;\n+{\n+}"}, {"sha": "4dacda650296d2ff5c772e12b3ab80040fa6c98e", "filename": "gcc/ch/runtime/concatps.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fconcatps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fconcatps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fconcatps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,93 @@\n+/* Implement powerset-related runtime actions for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+   Author: Bill Cox\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"powerset.h\"\n+\n+extern void cause_exception (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __concatps\n+ *\n+ * parameters:\n+ *     OUT      - pointer to output PS\n+ *     LEFT     - pointer to left PS\n+ *     LEFTLEN  - length of left PS in bits\n+ *     RIGHT    - pointer to right PS\n+ *     RIGHTLEN - length of right PS in bits\n+ *\n+ * returns:\n+ *     void\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     concatenates two powersets into the output powerset.\n+ *\n+ */\n+\n+extern void\n+__pscpy (SET_WORD      *dps,\n+\t unsigned long  dbl,\n+\t unsigned long  doffset,\n+\t SET_WORD      *sps,\n+\t unsigned long  sbl,\n+\t unsigned long  start,\n+\t unsigned long  length);\n+\n+void\n+__concatps (out, left, leftlen, right, rightlen)\n+     SET_WORD      *out;\n+     SET_WORD      *left;\n+     unsigned long  leftlen;\n+     SET_WORD      *right;\n+     unsigned long  rightlen;\n+{\n+  /* allocated sizes for each set involved */\n+  unsigned long outall, leftall, rightall;\n+\n+  if (!out)\n+    {\n+      /* FIXME: cause an exception */\n+    }\n+  else if (leftlen == 0 || !left)\n+    {\n+      if (rightlen == 0 || !right)\n+\treturn;               /* no work to do */\n+      __pscpy (out, rightlen, (unsigned long)0,\n+\t       right, rightlen, (unsigned long)0, rightlen);\n+    }\n+  else if (rightlen == 0 || !right)\n+    {\n+      if (leftlen == 0 || !left)\n+\treturn;               /* no work to do */\n+      __pscpy (out, leftlen, (unsigned long)0,\n+\t       left, leftlen, (unsigned long)0, leftlen);\n+    }\n+  /* copy the left powerset into bits 0..leftlen - 1 */\n+  __pscpy (out, leftlen + rightlen, (unsigned long)0,\n+\t   left, leftlen, (unsigned long)0, leftlen);\n+\n+  /* copy the right powerset into bits leftlen..leftlen+rightlen-1 */\n+  __pscpy (out, leftlen + rightlen, leftlen,\n+\t   right, rightlen, (unsigned long)0, rightlen);\n+}"}, {"sha": "226f429356b8f674a90e952f6ba3496336a22b65", "filename": "gcc/ch/runtime/copyps.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fcopyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fcopyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fcopyps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,111 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __powerset_copy\n+ *    This is more general than __psslice, since it\n+ *    can be told where in the destination powerset (DOFFSET\n+ *    parameter) to start storing the slice.\n+ *\n+ * parameters:\n+ *      dps             dest powerset\n+ *      dbl             destination bit length\n+ *      doffset         offset bit number (zero origin)\n+ *\tsps\t\tsourcepowerset\n+ *\tsbl     \tsource powerset length in bits\n+ *      start           starting bit number\n+ *      end             ending bit number\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  Extract into a powerset a slice of another powerset.\n+ *\n+ */\n+void\n+__pscpy (dps, dbl, doffset, sps, sbl, start, length)\n+     SET_WORD      *dps;\n+     unsigned long  dbl;\n+     unsigned long  doffset;\n+     const SET_WORD*sps;\n+     unsigned long  sbl;\n+     unsigned long  start;\n+     unsigned long  length;\n+{\n+  unsigned long end = start + length - 1;\n+  unsigned long src, dst;\n+\n+  /* assert end >= start;\n+     assert end - start + 1 <= dbl;\n+     assert \"the sets don't overlap in memory\" */\n+\n+  /* assert doffset >= 0 and < dbl */\n+\n+  for (src = start, dst = doffset; src <= end; src++, dst++)\n+    {\n+      char tmp;\n+\n+      if (sbl <= SET_CHAR_SIZE)                /* fetch a bit */\n+\ttmp = GET_BIT_IN_CHAR (*((SET_CHAR *)sps), src);\n+      else if (sbl <= SET_SHORT_SIZE)\n+\ttmp = GET_BIT_IN_SHORT (*((SET_SHORT *)sps), src);\n+      else\n+\ttmp = GET_BIT_IN_WORD (sps[src / SET_WORD_SIZE], src % SET_WORD_SIZE);\n+\n+      if (tmp & 1)\n+\t{\n+\t  if (dbl <= SET_CHAR_SIZE)            /* store a 1-bit */\n+\t    SET_BIT_IN_CHAR (*((SET_CHAR *)dps), dst);\n+\t  else if (dbl <= SET_SHORT_SIZE)\n+\t    SET_BIT_IN_SHORT (*((SET_SHORT *)dps), dst);\n+\t  else\n+\t    SET_BIT_IN_WORD (dps[dst / SET_WORD_SIZE], dst % SET_WORD_SIZE);\n+\t}\n+      else\n+\t{\n+\t  if (dbl <= SET_CHAR_SIZE)            /* store a 0-bit */\n+\t    CLEAR_BIT_IN_CHAR (*((SET_CHAR *)dps), dst);\n+\t  else if (dbl <= SET_SHORT_SIZE)\n+\t    CLEAR_BIT_IN_SHORT (*((SET_SHORT *)dps), dst);\n+\t  else\n+\t    CLEAR_BIT_IN_WORD (dps[dst / SET_WORD_SIZE], dst % SET_WORD_SIZE);\n+\t}\n+    }\n+  if (dbl <= SET_CHAR_SIZE)         /* clear unused bits in output bitstring */\n+    {\n+      MASK_UNUSED_CHAR_BITS ((SET_CHAR *)dps, dbl);\n+    }\n+  else if (dbl <= SET_SHORT_SIZE)\n+    {\n+      MASK_UNUSED_SHORT_BITS ((SET_SHORT *)dps, dbl);\n+    }\n+  else\n+    {\n+      MASK_UNUSED_WORD_BITS ((SET_WORD *)(dps + (dbl/SET_WORD_SIZE)), \n+\t\t\t     dbl % SET_WORD_SIZE);\n+    }\n+}"}, {"sha": "4ac002d810356e46055ec32ca28a0bf2655476a8", "filename": "gcc/ch/runtime/eqps.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Feqps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Feqps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Feqps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,88 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __eqpowerset\n+ *\n+ * parameters:\n+ *\tleft\t\tleft powerset\n+ *\tright\t\tright powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *\n+ * returns:\n+ *    1 if powersets are equal, bit for bit\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  compares two powersets for equality\n+ *\n+ */\n+int\n+__eqpowerset (left, right, bitlength)\n+     SET_WORD *left;\n+     SET_WORD *right;\n+     unsigned long bitlength;\n+{\n+#ifndef USE_CHARS\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      SET_CHAR c = *(SET_CHAR *)left ^ *(SET_CHAR *)right;\n+      MASK_UNUSED_CHAR_BITS (&c, bitlength);\n+      return (c == 0) ? 1 : 0;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      SET_SHORT c = *(SET_SHORT *)left ^ *(SET_SHORT *)right;\n+      MASK_UNUSED_SHORT_BITS (&c, bitlength);\n+      return (c == 0) ? 1 : 0;\n+    }\n+  else if (bitlength <= SET_WORD_SIZE)\n+    {\n+      SET_WORD c = *(SET_WORD *)left ^ *(SET_WORD *)right;\n+      MASK_UNUSED_WORD_BITS (&c, bitlength % SET_WORD_SIZE);\n+      return (c == 0) ? 1 : 0;\n+    }\n+  else\n+#endif\n+    {\n+      SET_WORD c;\n+      register unsigned long i;\n+      unsigned long len = bitlength / SET_WORD_SIZE;\n+\n+      for (i = 0; i < len; i++) /* a word-oriented memcmp */\n+\tif (left[i] != right[i])\n+\t  return 0;\n+      /* do the last (possibly partial) word */\n+      bitlength %= SET_WORD_SIZE;\n+      if (bitlength == 0)\n+\treturn 1;\n+      c = left[i] ^ right[i];\n+      MASK_UNUSED_WORD_BITS (&c, bitlength);\n+      return (c == 0) ? 1 : 0;\n+    }\n+}"}, {"sha": "fb15b8f6eb2fb2d41e24faa8e961fc9e7255822b", "filename": "gcc/ch/runtime/fileio.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Ffileio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Ffileio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Ffileio.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,153 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _fileio_h_\n+#define _fileio_h_\n+\n+#include <stdio.h>\n+\n+#include \"auxtypes.h\"\n+#include \"ioerror.h\"\n+#include \"iomodes.h\"\n+\n+#define DIRSEP '/'\n+\n+#define TEST_FLAG(Xloc,Flag) (((Xloc)->flags) & (Flag))\n+#define SET_FLAG(Xloc,Flag)  (Xloc)->flags |= (Flag)\n+#define CLR_FLAG(Xloc,Flag)  (Xloc)->flags = ((Xloc)->flags & ~(Flag))\n+\n+Boolean\n+__isassociated( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__existing( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__readable( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__writeable( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__indexable( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__sequencible( Association_Mode* the_assoc, char* file, int line );\n+\n+Boolean\n+__variable( Association_Mode* the_assoc, char* file, int line );\n+\n+typedef signed long int Index_t;\n+\n+Association_Mode*\n+__associate( Association_Mode* the_assoc,\n+             char*             the_path,\n+             int               the_path_len,\n+             char*             the_mode,\n+             int               the_mode_len,\n+             char*             file,\n+             int               line );\n+\n+void\n+__dissociate( Association_Mode* the_assoc, char* file, int line );\n+\n+void\n+__create( Association_Mode* the_assoc, char* file, int line );\n+\n+void\n+__delete( Association_Mode* the_assoc, char* file, int line );\n+\n+void\n+__modify( Association_Mode* the_assoc,\n+          char*             the_path,\n+          int               the_path_len,\n+          char*             the_mode,\n+          int               the_mode_len,\n+          char*             file,\n+          int               line );\n+\n+void\n+__connect( void*             the_transfer, \n+           Association_Mode* the_assoc,\n+           Usage_Mode        the_usage,\n+           Where_Mode        the_where,\n+           Boolean           with_index,\n+           signed long       the_index,\n+           char*             file,\n+           int               line );\n+\n+void\n+__disconnect( void* the_transfer, char* file, int line );\n+\n+Association_Mode*\n+__getassociation( void* the_transfer, char* file, int line );\n+\n+Usage_Mode\n+__getusage( void* the_transfer, char* file, int line );\n+\n+Boolean\n+__outoffile( void* the_transfer, char* file, int line );\n+\n+void*\n+__readrecord( Access_Mode*  the_access,\n+              signed long   the_index,\n+              char*         the_buf_addr,\n+              char*         file,\n+              int           line );\n+\n+void\n+__writerecord( Access_Mode*  the_access,\n+               signed long   the_index,\n+               char*         the_val_addr,\n+               unsigned long the_val_len,\n+               char*         file,\n+               int           line );\n+\n+VarString*\n+__gettextrecord( Text_Mode* the_text, char* file, int line );\n+\n+unsigned long\n+__gettextindex( Text_Mode* the_text, char* file, int line );\n+\n+Access_Mode*\n+__gettextaccess( Text_Mode* the_text, char* file, int line );\n+\n+Boolean\n+__eoln( Text_Mode* the_text, char* file, int line );\n+\n+void\n+__settextrecord( Text_Mode* the_text,\n+                 VarString* the_text_rec,\n+                 char*      file,\n+                 int        line );\n+\n+void\n+__settextindex( Text_Mode*  the_text,\n+                signed long the_text_index, \n+                char*       file,\n+                int         line );\n+\n+void\n+__settextaccess( Text_Mode*   the_text,\n+                 Access_Mode* the_access,\n+                 char*        file,\n+                 int          line );\n+\n+#endif"}, {"sha": "1a79076899696e5f0b461fd4d6fe74224cc7b83e", "filename": "gcc/ch/runtime/flsetps.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fflsetps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fflsetps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fflsetps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,107 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+extern void __cause_ex1 (char *exname, char *file, int lineno);\n+\n+/*\n+ * function __flsetpowerset\n+ *\n+ * parameters:\n+ *\tps\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *      minval          set low bound\n+ *      filename        caller's file name\n+ *      lineno          caller's line number\n+ *\n+ * returns:\n+ *\tint\t\tlargest enumeration value\n+ * exceptions:\n+ *      \"empty\"         if set is empty\n+ *\n+ * abstract:\n+ *  Find last bit set in a powerset and return the corresponding value.\n+ *\n+ */\n+long\n+__flsetpowerset (ps, bitlength, minval, filename, lineno)\n+     SET_WORD      *ps;\n+     unsigned long  bitlength;\n+     long           minval;\n+     char          *filename;\n+     int            lineno;\n+{\n+  unsigned long bitno;\n+\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      SET_CHAR cset = *((SET_CHAR *)ps);\n+      if (cset != 0)\n+\t{\n+\t  /* found a bit set .. calculate which */\n+\t  for (bitno = SET_CHAR_SIZE; bitno >= 1; bitno--)\n+\t    if (GET_BIT_IN_CHAR (cset, bitno - 1))\n+\t      break;\n+\t  /* return its index */\n+\t  return bitno + minval - 1;\n+\t}\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      SET_SHORT sset = *((SET_SHORT *)ps);\n+      if (sset != 0)\n+\t{\n+\t  /* found a bit set .. calculate which */\n+\t  for (bitno = SET_SHORT_SIZE; bitno >= 1; bitno--)\n+\t    if (GET_BIT_IN_SHORT (sset, bitno - 1))\n+\t      break;\n+\t  /* return its index */\n+\t  return bitno + minval - 1;\n+\t}\n+    }\n+  else /* set composed of array of one or more WORDs */\n+    {\n+      SET_WORD\t*endp = ps;\n+      SET_WORD\t*p = ps + BITS_TO_WORDS(bitlength) - 1;\n+      unsigned long cnt;\n+      \n+      /* FIXME: bitorder problems? */\n+      for (cnt = ((bitlength - 1) / SET_WORD_SIZE) * SET_WORD_SIZE;\n+\t   p >= endp; p--, cnt -= SET_WORD_SIZE)\n+\t{\n+\t  SET_WORD c = *p;\n+\t  if (c)\n+\t    {\n+\t      /* found a bit set .. calculate which */\n+\t      for (bitno = SET_WORD_SIZE; bitno >= 1; bitno--)\n+\t\tif (GET_BIT_IN_WORD (c, bitno - 1))\n+\t\t  break;\n+\t      return cnt + bitno + minval - 1;\n+\t    }\n+\t}\n+    }\n+  /* no bits found - raise exception */\n+  __cause_ex1 (\"empty\", filename, lineno);\n+}"}, {"sha": "8b554f4c20921bae2e05dcf4a9e10c445bb5f9d3", "filename": "gcc/ch/runtime/format.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fformat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fformat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fformat.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,71 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _format_h_\n+#define _format_h_\n+\n+#include \"iomodes.h\"\n+#include \"fileio.h\"\n+\n+extern Text_Mode __stdin_text;\n+extern Text_Mode __stdout_text;\n+extern Text_Mode __stderr_text;\n+\n+void\n+__readtext_f( Text_Mode*      TextLoc,\n+              signed long     Index,\n+              char*           fmtptr,\n+              int             fmtlen,\n+              __tmp_IO_list*  ioptr,\n+              int             iolen,\n+              char*           file,\n+              int             line );\n+\n+void\n+__readtext_s( void*           string_ptr,\n+              int             string_len,\n+              char*           fmtptr,\n+              int             fmtlen,\n+              __tmp_IO_list*  ioptr,\n+              int             iolen,\n+              char*           file,\n+              int             line );\n+\n+void\n+__writetext_f( Text_Mode*      Text_Loc,\n+               signed long     Index,\n+               char*           fmtptr,\n+               int             fmtlen,\n+               __tmp_IO_list*  ioptr,\n+               int             iolen,\n+               char*           file,\n+               int             line );\n+\n+void\n+__writetext_s( void*           string_ptr,\n+               int             string_len,\n+               char*           fmtptr,\n+               int             fmtlen,\n+               __tmp_IO_list*  ioptr,\n+               int             iolen,\n+               char*           file,\n+               int             line );\n+\n+#endif _format_h_"}, {"sha": "1bc92aacef42d35e2c23f8f289754e87dd8b5082", "filename": "gcc/ch/runtime/getassoc.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgetassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgetassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fgetassoc.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,37 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Association_Mode*\n+__getassociation( void* the_transfer, char* file, int line )\n+{\n+  Access_Mode* the_access;\n+\n+  if( !the_transfer )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ))\n+    the_access = ((Text_Mode*)the_transfer)->access_sub;\n+  else\n+    the_access = (Access_Mode*)the_transfer;\n+\n+  return the_access->association;\n+}"}, {"sha": "28f976d6a27d1fe6794b540b8b6627fd92360fdb", "filename": "gcc/ch/runtime/gettextaccess.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgettextaccess.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgettextaccess.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fgettextaccess.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,31 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Access_Mode*\n+__gettextaccess( Text_Mode* the_text, char* file, int line )\n+{\n+  if( !the_text )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_TEXT );\n+\n+  return the_text->access_sub;\n+}\n+"}, {"sha": "2fcaf77dd80f1f4f82da1ea970097e5c638287fc", "filename": "gcc/ch/runtime/getusage.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgetusage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fgetusage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fgetusage.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,40 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"fileio.h\"\n+\n+Usage_Mode\n+__getusage( void* the_transfer, char* file, int line )\n+{\n+  Access_Mode* the_access;\n+\n+  if( !the_transfer )\n+    CHILLEXCEPTION( file, line, EMPTY, NULL_ACCESS );\n+\n+  if( TEST_FLAG((Text_Mode*)the_transfer, IO_TEXTLOCATION ))\n+    the_access = ((Text_Mode*)the_transfer)->access_sub;\n+  else\n+    the_access = (Access_Mode*)the_transfer;\n+\n+  if( !the_access->association )\n+    CHILLEXCEPTION( file, line, NOTCONNECTED, IS_NOT_CONNECTED );\n+  return the_access->association->usage;\n+}\n+"}, {"sha": "d01d76aff242f69775eea9430fed34c19cc93c0f", "filename": "gcc/ch/runtime/inps.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Finps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Finps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Finps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,65 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __inpowerset\n+ *\n+ * parameters:\n+ *\tbitno\t\tbit number within set\n+ *\tpowerset\tthe powerset\n+ *\tbitlength\tlength of powerset in bits\n+ *      minval          number of lowest bit stored\n+ *\n+ * returns:\n+ *\tint\t\t1 .. found\n+ *\t\t\t0 .. not found\n+ *\n+ * exceptions:\n+ *  rangefail\n+ *\n+ * abstract:\n+ *  checks if a given value is included in a powerset\n+ *\n+ */\n+int\n+__inpowerset (bitno, powerset, bitlength, minval)\n+     unsigned long  bitno;\n+     SET_WORD      *powerset;\n+     unsigned long  bitlength;\n+     long           minval;\n+{\n+  if (bitno < minval || (bitno - minval) >= bitlength)\n+    return 0;\n+    \n+  bitno -= minval;\n+  if (bitlength <= SET_CHAR_SIZE)\n+    return GET_BIT_IN_CHAR (*((SET_CHAR *)powerset), bitno);\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    return GET_BIT_IN_SHORT (*((SET_SHORT *)powerset), bitno);\n+  else\n+    return GET_BIT_IN_WORD (powerset[bitno / SET_WORD_SIZE],\n+\t\t\t    bitno % SET_WORD_SIZE);\n+}"}, {"sha": "8c9fad469d72bfea8b5ff9b396579f11cf0e690b", "filename": "gcc/ch/runtime/ioerror.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fioerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fioerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fioerror.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,45 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <setjmp.h>\n+\n+/* define names of IO-exceptions */\n+\n+char * __IO_exception_names[] =\n+{\n+  \"UNUSED\",\n+  \"notassociated\",\n+  \"associatefail\",\n+  \"createfail\",\n+  \"deletefail\",\n+  \"modifyfail\",\n+  \"connectfail\",\n+  \"notconnected\",\n+  \"empty\",\n+  \"rangefail\",\n+  \"spacefail\",\n+  \"readfail\",\n+  \"writefail\",\n+  \"textfail\",\n+};\n+\n+jmp_buf __io_exception;\n+\n+jmp_buf __rw_exception;"}, {"sha": "e2ddfe57c1ec56497aa42c4b1922d1c8b06b0dd6", "filename": "gcc/ch/runtime/ioerror.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fioerror.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fioerror.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fioerror.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,161 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _ioerror_h_\n+#define _ioerror_h_\n+\n+#include <setjmp.h>\n+\n+/* Note: numbers must be in the same order as\n+   strings in ioerror.c */\n+typedef enum \n+{ NOTASSOCIATED = 1,\n+  ASSOCIATEFAIL,\n+  CREATEFAIL, \n+  DELETEFAIL,\n+  MODIFYFAIL,\n+  CONNECTFAIL,\n+  NOTCONNECTED,\n+  EMPTY,\n+  RANGEFAIL,\n+  SPACEFAIL,\n+  READFAIL,\n+  WRITEFAIL,\n+  TEXTFAIL\n+} io_exceptions_t;\n+\n+#ifndef FIRST_IO_ERROR_NUMBER\n+#define FIRST_IO_ERROR_NUMBER 0\n+#endif\n+\n+typedef enum {\n+  FIRST_AND_UNUSED = FIRST_IO_ERROR_NUMBER,\n+  INTERNAL_ERROR,\n+  INVALID_IO_LIST,\n+  REPFAC_OVERFLOW,\n+  CLAUSE_WIDTH_OVERFLOW,\n+  UNMATCHED_CLOSING_PAREN,\n+  UNMATCHED_OPENING_PAREN,\n+  BAD_FORMAT_SPEC_CHAR,\n+  NO_PAD_CHAR,\n+  IO_CONTROL_NOT_VALID,\n+  DUPLICATE_QUALIFIER,\n+  NO_FRACTION_WIDTH,\n+  NO_EXPONENT_WIDTH,\n+  FRACTION_WIDTH_OVERFLOW,\n+  EXPONENT_WIDTH_OVERFLOW,\n+  NO_FRACTION,\n+  NO_EXPONENT,\n+  NEGATIVE_FIELD_WIDTH,\n+  TEXT_LOC_OVERFLOW,\n+  IOLIST_EXHAUSTED,\n+  CONVCODE_MODE_MISFIT,\n+  SET_CONVERSION_ERROR,\n+  BOOL_CONVERSION_ERROR,\n+  NON_INT_FIELD_WIDTH,\n+  EXCESS_IOLIST_ELEMENTS,\n+  NOT_ENOUGH_CHARS,\n+  NO_CHARS_FOR_INT,\n+  NO_CHARS_FOR_FLOAT,\n+  NO_EXPONENT_VAL,\n+  INT_VAL_OVERFLOW,\n+  REAL_OVERFLOW,\n+  NO_DIGITS_FOR_INT,\n+  NO_DIGITS_FOR_FLOAT,\n+  NO_CHARS_FOR_SET,\n+  NO_CHARS_FOR_CHAR,\n+  NO_CHARS_FOR_BOOLS,\n+  NO_CHARS_FOR_CHARS,\n+  NO_CHARS_FOR_TEXT,\n+  NO_CHARS_FOR_EDIT,\n+  NO_SPACE_TO_SKIP,\n+  FORMAT_TEXT_MISMATCH,\n+  INTEGER_RANGE_ERROR,\n+  SET_RANGE_ERROR,\n+  CHAR_RANGE_ERROR,\n+  INVALID_CHAR,\n+/* end of formatting errors */\n+  NULL_ASSOCIATION,\n+  NULL_ACCESS,\n+  NULL_TEXT,\n+  IS_NOT_ASSOCIATED,\n+  IS_ASSOCIATED,\n+  GETCWD_FAILS,\n+  INVALID_ASSOCIATION_MODE,\n+  FILE_EXISTING,\n+  CREATE_FAILS,\n+  DELETE_FAILS,\n+  RENAME_FAILS,\n+  IMPL_RESTRICTION,\n+  NOT_EXISTING,\n+  NOT_READABLE,\n+  NOT_WRITEABLE,\n+  NOT_INDEXABLE,\n+  NOT_SEQUENCIBLE,\n+  NO_CURRENT_POS,\n+  NOT_VARIABLE,\n+  NOT_FIXED,\n+  NOT_INDEXED, \n+  LENGTH_CHANGE,\n+  LSEEK_FAILS,\n+  BUFFER_ALLOC,\n+  OPEN_FAILS,\n+  NO_ACCESS_SUBLOCATION, \n+  BAD_INDEX,\n+  IS_NOT_CONNECTED,\n+  NO_PATH_NAME,\n+  PATHNAME_ALLOC,\n+  BAD_USAGE,\n+  OUT_OF_FILE,\n+  NULL_STORE_LOC,\n+  STORE_LOC_ALLOC,\n+  OS_IO_ERROR,\n+  RECORD_TOO_LONG,\n+  RECORD_TOO_SHORT,\n+  BAD_TEXTINDEX,\n+  NULL_TEXTREC\n+} io_info_word_t;\n+\n+\n+extern\n+char* io_info_text [];\n+\n+extern\n+char* exc_text [];\n+ \n+extern \n+jmp_buf __io_exception;\n+\n+extern \n+jmp_buf __rw_exception;\n+\n+void __cause_exception (char *ex, char* f, int line, int info);\n+extern char * __IO_exception_names[];\n+\n+#define IOEXCEPTION(EXC,INFO) \\\n+    longjmp( __io_exception, (EXC<<16) + INFO )\n+\n+#define RWEXCEPTION(EXC,INFO) \\\n+    longjmp( __rw_exception, (EXC<<16) + INFO )\n+\n+#define CHILLEXCEPTION(FILE,LINE,EXC,INFO) \\\n+    __cause_exception (__IO_exception_names[EXC], FILE, LINE, INFO);\n+\n+#endif"}, {"sha": "8e254e25b0009cdac2cfd44471ece7d65a341d75", "filename": "gcc/ch/runtime/iomodes.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fiomodes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fiomodes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fiomodes.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,251 @@\n+/* Implement Input/Output runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _iomodes_h_\n+#define _iomodes_h_\n+\n+#include \"auxtypes.h\"\n+\n+typedef enum { ReadOnly, WriteOnly, ReadWrite\n+} Usage_Mode;\n+\n+typedef enum { First, Same, Last\n+} Where_Mode;\n+\n+typedef enum { None, Fixed, VaryingChars\n+} Record_t;\n+\n+/* association flags */\n+#define IO_ISASSOCIATED 0x00000001\n+#define IO_EXISTING     0x00000002\n+#define IO_READABLE     0x00000004\n+#define IO_WRITEABLE    0x00000008\n+#define IO_INDEXABLE    0x00000010\n+#define IO_SEQUENCIBLE  0x00000020\n+#define IO_VARIABLE     0x00000040\n+#define IO_FIRSTLINE    0x00000100\n+#define IO_FORCE_PAGE   0x00000200\n+\n+struct Access_Mode;\n+\n+#define READBUFLEN 512\n+typedef struct\n+{\n+  unsigned long len;\n+  unsigned long cur;\n+  char buf[READBUFLEN];\n+} readbuf_t;\n+\n+typedef struct Association_Mode {\n+  unsigned long       flags;      /* INIT = 0 */\n+  char*               pathname;\n+  struct Access_Mode* access;\n+  int                 handle;\n+  readbuf_t*          bufptr;\n+  long                syserrno;\n+  char                usage;\n+  char                ctl_pre;\n+  char                ctl_post;\n+} Association_Mode;\n+\n+/*\n+   rectype   indexed   max. reclength    act. reclength\n+   ---------------------------------------------------\n+   None        T/F        0\n+   Fixed       T/F     SIZE(recmode)  =  SIZE(recmode)\n+   Varying       F     SIZE(recmode) >=  length\n+*/\n+\n+/* access/text flags */\n+#define IO_TEXTLOCATION 0x80000000\n+#define IO_INDEXED      0x00000001\n+#define IO_TEXTIO       0x00000002\n+#define IO_OUTOFFILE    0x00010000\n+\n+typedef struct Access_Mode {\n+  unsigned long     flags;     /* INIT */   \n+  unsigned long     reclength; /* INIT */\n+  signed long       lowindex;  /* INIT */\n+  signed long       highindex; /* INIT */\n+  Association_Mode* association;\n+  unsigned long     base;\n+  char*             store_loc;\n+  Record_t          rectype;   /* INIT */\n+} Access_Mode;\n+\n+typedef struct Text_Mode {\n+  unsigned long flags;         /* INIT */\n+  VarString*    text_record;   /* INIT */\n+  Access_Mode*  access_sub;    /* INIT */\n+  unsigned long actual_index;\n+} Text_Mode;\n+\n+typedef enum\n+{\n+    __IO_UNUSED,\n+\n+    __IO_ByteVal,\n+    __IO_UByteVal,\n+    __IO_IntVal,\n+    __IO_UIntVal,\n+    __IO_LongVal,\n+    __IO_ULongVal,\n+\n+    __IO_ByteLoc,\n+    __IO_UByteLoc,\n+    __IO_IntLoc,\n+    __IO_UIntLoc,\n+    __IO_LongLoc,\n+    __IO_ULongLoc,\n+\n+    __IO_ByteRangeLoc,\n+    __IO_UByteRangeLoc,\n+    __IO_IntRangeLoc,\n+    __IO_UIntRangeLoc,\n+    __IO_LongRangeLoc,\n+    __IO_ULongRangeLoc,\n+\n+    __IO_BoolVal,\n+    __IO_BoolLoc,\n+    __IO_BoolRangeLoc,\n+\n+    __IO_SetVal,\n+    __IO_SetLoc,\n+    __IO_SetRangeLoc,\n+\n+    __IO_CharVal,\n+    __IO_CharLoc,\n+    __IO_CharRangeLoc,\n+\n+    __IO_CharStrLoc,\n+\n+    __IO_CharVaryingLoc,\n+\n+    __IO_BitStrLoc,\n+\n+    __IO_RealVal,\n+    __IO_RealLoc,\n+    __IO_LongRealVal,\n+    __IO_LongRealLoc\n+} __tmp_IO_enum;\n+\n+typedef struct\n+{\n+    long        value;\n+    char*       name;\n+} __tmp_IO_enum_table_type;\n+\n+typedef struct\n+{\n+    long                      value;\n+    __tmp_IO_enum_table_type* name_table;\n+} __tmp_WIO_set;\n+\n+typedef struct\n+{\n+    char*       ptr;\n+    long        lower;\n+    long        upper;\n+} __tmp_IO_charrange;\n+\n+typedef union\n+{\n+      signed long  slong;\n+    unsigned long  ulong;\n+}  __tmp_IO_long;\n+\n+typedef struct\n+{\n+    void*         ptr;\n+    __tmp_IO_long lower;\n+    __tmp_IO_long upper;\n+} __tmp_IO_intrange;\n+\n+typedef struct\n+{\n+    void*           ptr;\n+    unsigned long   lower;\n+    unsigned long   upper;\n+} __tmp_RIO_boolrange;\n+\n+typedef struct\n+{\n+    void*                     ptr;\n+    long                      length;\n+    __tmp_IO_enum_table_type* name_table;\n+} __tmp_RIO_set;\n+\n+typedef struct\n+{\n+    void*                      ptr;\n+    long                       length;\n+    __tmp_IO_enum_table_type*  name_table;\n+    unsigned long              lower;\n+    unsigned long              upper;\n+} __tmp_RIO_setrange;\n+\n+typedef struct\n+{\n+    char*       string;\n+    long        string_length;\n+} __tmp_IO_charstring;\n+\n+typedef union\n+{\n+    char                     __valbyte;\n+    unsigned char            __valubyte;\n+    short                    __valint;\n+    unsigned short           __valuint;\n+    long                     __vallong;\n+    unsigned long            __valulong;\n+    void*                    __locint;\n+    __tmp_IO_intrange        __locintrange;\n+\n+    unsigned char            __valbool;\n+    unsigned char*           __locbool;\n+    __tmp_RIO_boolrange      __locboolrange;\n+\n+    __tmp_WIO_set            __valset;\n+    __tmp_RIO_set            __locset;\n+    __tmp_RIO_setrange       __locsetrange;\n+\n+    unsigned char            __valchar;\n+    unsigned char*           __locchar;\n+    __tmp_IO_charrange       __loccharrange;\n+\n+    __tmp_IO_charstring      __loccharstring;\n+\n+    float                    __valreal;\n+    float*                   __locreal;\n+    double                   __vallongreal;\n+    double*                  __loclongreal;\n+} __tmp_IO_union;\n+\n+/*\n+ * CAUTION: The longest variant of __tmp_IO_union is 5 words long.\n+ * Together with __descr this caters for double alignment where required.\n+ */\n+typedef struct\n+{\n+    __tmp_IO_union    __t;\n+    __tmp_IO_enum     __descr;\n+} __tmp_IO_list;\n+\n+#endif"}, {"sha": "747be42703ed1d287cf9efb17f1f8c3952dd7389", "filename": "gcc/ch/runtime/ltps.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fltps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fltps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fltps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,86 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __ltpowerset\n+ *\n+ * parameters:\n+ *\tleft\t\tpowerset\n+ *\tright\t\tpowerset\n+ *\tbitlength\tlength of powerset\n+ *\n+ * returns:\n+ *\tint\t\t1 .. left is proper subset of right\n+ *                           (excludes case where left == right)\n+ *\t\t\t0 .. not\n+ *\n+ * abstract:\n+ *  check if one powerset is included in another\n+ *\n+ */\n+int\n+__ltpowerset (left, right, bitlength)\n+     SET_WORD      *left;\n+     SET_WORD      *right;\n+     unsigned long  bitlength;\n+{\n+  if (bitlength <= SET_CHAR_SIZE)\n+    {\n+      if ((*((SET_CHAR *)left) & *((SET_CHAR *)right))\n+\t  != *((SET_CHAR *)left))\n+\treturn 0;\n+      if (*((SET_CHAR *)left) != *((SET_CHAR *)right))\n+\treturn 1;\n+      return 0;\n+    }\n+  else if (bitlength <= SET_SHORT_SIZE)\n+    {\n+      if ((*((SET_SHORT *)left) & *((SET_SHORT *)right))\n+\t  != *((SET_SHORT *)left))\n+\treturn 0;\n+      if (*((SET_SHORT *)left) != *((SET_SHORT *)right))\n+\treturn 1;\n+      return 0;\n+    }\n+  else\n+    {\n+      SET_WORD\t*endp = left + BITS_TO_WORDS(bitlength);\n+      int all_equal = 1;              /* assume all bits are equal */\n+    \n+      while (left < endp)\n+\t{\n+\t  if ((*right & *left) != *left)\n+\t    return 0;\n+\t  if (*left != *right)\n+\t    all_equal = 0;\n+\t  left++;\n+\t  right++;\n+\t}\n+      if (left == endp && all_equal)    /* exclude TRUE return for == case */\n+\treturn 0;\n+      return 1;\n+    }\n+}"}, {"sha": "683a94745416c8d2bdfd4beac0c75c629a71bf6a", "filename": "gcc/ch/runtime/ltstr.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fltstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fltstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fltstr.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,55 @@\n+/* Implement string-related runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Bill Cox\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define MIN(a, b)  ((a) < (b) ? (a) : (b))\n+\n+/*\n+ * function __ltstring\n+ *\n+ * parameters:\n+ *     S1 - pointer to left string\n+ *     LEN1 - length of left string\n+ *     S2 - pointer to right string\n+ *     LEN2 - length of right string\n+ *\n+ * returns:\n+ *     1 if left string is a proper subset of the right string, 0 otherwise\n+ *\n+ * exceptions:\n+ *     none\n+ *\n+ * abstract:\n+ *     compares two character strings for subset relationship\n+ *\n+ */\n+\n+int __ltstring (s1, len1, s2, len2)\n+     char *s1;\n+     int len1;\n+     char *s2;\n+     int len2;\n+{\n+  int i;\n+\n+  i = memcmp (s1, s2, MIN (len1, len2));\n+  if (i)\n+    return (i < 0);\n+  return (len1 < len2);\n+}"}, {"sha": "27019e7c04f6b8e0e228089b16018ac14b1ef63f", "filename": "gcc/ch/runtime/rts.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Frts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Frts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Frts.h?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,52 @@\n+/* GNU CHILL compiler regression test file\n+ Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+ \n+ This file is part of GNU CC.\n+\n+ GNU CC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 2, or (at your option)\n+ any later version.\n+\n+ GNU CC is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with GNU CC; see the file COPYING.  If not, write to\n+ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */\n+\n+#ifndef __rts_h_\n+#define __rts_h_\n+\n+typedef enum\n+{\n+  UNUSED,\n+  Process,\n+  Signal,\n+  Buffer,\n+  Event,\n+  Synonym,\n+  Exception,\n+  LAST_AND_UNUSED,\n+} TaskingEnum;\n+\n+typedef void (*EntryPoint) ();\n+\n+typedef struct\n+{\n+  char       *name;\n+  short      *value;\n+  int         value_defined;\n+  EntryPoint  entry;\n+  unsigned char /*TaskingEnum*/ type;\n+} TaskingStruct;\n+\n+typedef struct\n+{\n+  short ptype;\n+  short pcopy;\n+} INSTANCE;\n+\n+#endif /* __rts_h_ */"}, {"sha": "939a0b8e37cf1dc8d4892b084189c9da30a07bcf", "filename": "gcc/ch/runtime/sliceps.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fsliceps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Fsliceps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fsliceps.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,65 @@\n+/* Implement POWERSET runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser, et al\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include \"powerset.h\"\n+\n+/*\n+ * function __powerset_slice\n+ *\n+ * parameters:\n+ *      dps             dest powerset\n+ *      dbl             destination bit length\n+ *\tsps\t\tsourcepowerset\n+ *\tsbl     \tsource powerset length in bits\n+ *      start           starting bit number\n+ *      end             ending bit number\n+ *\n+ * exceptions:\n+ *  none\n+ *\n+ * abstract:\n+ *  Extract into a powerset a slice of another powerset.\n+ *\n+ */\n+extern void\n+__pscpy (SET_WORD      *dps,\n+\t unsigned long  dbl,\n+\t unsigned long  doffset,\n+\t SET_WORD      *sps,\n+\t unsigned long  sbl,\n+\t unsigned long  start,\n+\t unsigned long  length);\n+\n+void\n+__psslice (dps, dbl, sps, sbl, start, length)\n+     SET_WORD      *dps;\n+     unsigned long  dbl;\n+     SET_WORD      *sps;\n+     unsigned long  sbl;\n+     unsigned long  start;\n+     unsigned long  length;\n+{\n+  /* simply supply a zero destination offset and copy the slice */\n+  __pscpy (dps, dbl, (unsigned long)0, sps, sbl, start, length);\n+}"}, {"sha": "3bd23dcf7d7b9cbed70964a1537cf48880c9ab9a", "filename": "gcc/ch/runtime/unhex.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Funhex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Funhex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Funhex.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,57 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <setjmp.h>\n+\n+/*\n+ * function unhandled_exception\n+ *\n+ * parameter:\n+ *  exname\t\tname of exception\n+ *  file\t\tfilename\n+ *  lineno\t\tline number\n+ *  user_arg\t\tuser specified argument\n+ *\n+ * returns:\n+ *  never\n+ *\n+ * abstract:\n+ *  print an error message about unhandled exception and call abort\n+ *\n+ */\n+\n+void\n+unhandled_exception (exname, file, lineno, user_arg)\n+     char *exname;\n+     char *file;\n+     int lineno;\n+     int user_arg;\n+{\n+  sleep (1); /* give previous output a chance to finish */\n+  fprintf (stderr, \"ChillLib: unhandled exception `%s' in file %s at line %d\\n\",\n+\t   exname, file, lineno);\n+  fflush (stderr);\n+  abort ();\n+} /* unhandled_exception */"}, {"sha": "375f6a524977ad7eba964db9ea280f5cd123a186", "filename": "gcc/ch/runtime/unhex1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Funhex1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fruntime%2Funhex1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Funhex1.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,58 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <setjmp.h>\n+\n+extern void cause_exception (char *ex, char *file, int lineno, int arg);\n+extern void unhandled_exception (char *ex, char *file, int lineno, int arg);\n+\n+/*\n+ * function __unhandled_ex\n+ *\n+ * parameter:\n+ *  exname\t\tname of exception\n+ *  file\t\tfilename\n+ *  lineno\t\tline number\n+ *\n+ * returns:\n+ *  never\n+ *\n+ * abstract:\n+ *  This function gets called by compiler generated code when an unhandled\n+ *  exception occures.\n+ *  First cause_exception gets called (which may be user defined) and\n+ *  then the standard unhandled exception routine gets called.\n+ *\n+ */\n+\n+void\n+__unhandled_ex (exname, file, lineno)\n+     char *exname;\n+     char *file;\n+     int lineno;\n+{\n+    cause_exception (exname, file, lineno, 0);\n+    unhandled_exception (exname, file, lineno, 0);\n+} /* unhandled_exception */"}, {"sha": "a9f3c871fa7ca81b5a0bd7e9f7614ad8828922a3", "filename": "gcc/ch/satisfy.c", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fsatisfy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Fsatisfy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fsatisfy.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,628 @@\n+/* Name-satisfaction for GNU Chill compiler.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"ch-tree.h\"\n+#include \"lex.h\"\n+\n+#define SATISFY(ARG) ((ARG) = satisfy(ARG, chain))\n+\n+extern void error           PROTO((char *, ...));\n+extern void error_with_decl PROTO((tree, char *, ...));\n+extern void expand_decl     PROTO((tree));\n+extern void layout_enum     PROTO((tree));\n+\n+struct decl_chain\n+{\n+  struct decl_chain *prev;\n+  /* DECL can be a decl, or a POINTER_TYPE or a REFERENCE_TYPE. */\n+  tree decl;\n+};\n+\n+/* forward declaration */\n+tree satisfy PROTO((tree, struct decl_chain *));\n+\n+static struct decl_chain dummy_chain;\n+#define LOOKUP_ONLY (chain==&dummy_chain)\n+\n+/* Recursive helper routine to logically reverse the chain. */\n+static void\n+cycle_error_print (chain, decl)\n+     struct decl_chain *chain;\n+     tree decl;\n+{\n+  if (chain->decl != decl)\n+    {\n+      cycle_error_print (chain->prev, decl);\n+      if (TREE_CODE_CLASS (TREE_CODE (chain->decl)) == 'd')\n+\terror_with_decl (chain->decl, \"  `%s', which depends on ...\");\n+    }\n+}\n+\n+tree\n+safe_satisfy_decl (decl, prev_chain)\n+     tree decl;\n+     struct decl_chain *prev_chain;\n+{\n+  struct decl_chain new_link;\n+  struct decl_chain *link;\n+  struct decl_chain *chain = prev_chain;\n+  char *save_filename = input_filename;\n+  int save_lineno = lineno;\n+  tree result = decl;\n+  \n+  if (decl == NULL_TREE)\n+    return decl;\n+\n+  if (!LOOKUP_ONLY)\n+    {\n+      int pointer_type_breaks_cycle = 0;\n+      /* Look for a cycle.\n+\t We could do this test more efficiently by setting a flag.  FIXME */\n+      for (link = prev_chain; link != NULL; link = link->prev)\n+\t{\n+\t  if (TREE_CODE_CLASS (TREE_CODE (link->decl)) != 'd')\n+\t    pointer_type_breaks_cycle = 1;\n+\t  if (link->decl == decl)\n+\t    {\n+\t      if (!pointer_type_breaks_cycle)\n+\t\t{\n+\t\t  error_with_decl (decl, \"Cycle: `%s' depends on ...\");\n+\t\t  cycle_error_print (prev_chain, decl);\n+\t\t  error_with_decl (decl, \"  `%s'\");\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      /* There is a cycle, but it includes a pointer type,\n+\t\t so we're OK.  However, we still have to continue\n+\t\t the satisfy (for example in case this is a TYPE_DECL\n+\t\t that points to a LANG_DECL).  The cycle-check for\n+\t\t POINTER_TYPE/REFERENCE_TYPE should stop the recursion. */\n+\t      break;\n+\t    }\n+\t}\n+\n+      new_link.decl = decl;\n+      new_link.prev = prev_chain;\n+      chain = &new_link;\n+    }\n+\n+  input_filename = DECL_SOURCE_FILE (decl);\n+  lineno = DECL_SOURCE_LINE (decl);\n+\n+  switch ((enum chill_tree_code)TREE_CODE (decl))\n+    {\n+    case ALIAS_DECL:\n+      if (!LOOKUP_ONLY && !DECL_POSTFIX_ALL(decl))\n+\tresult = safe_satisfy_decl (DECL_ABSTRACT_ORIGIN (decl), chain);\n+      break;\n+    case BASED_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      SATISFY (DECL_ABSTRACT_ORIGIN (decl));\n+      break;\n+    case CONST_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      SATISFY (DECL_INITIAL (decl));\n+      if (!LOOKUP_ONLY)\n+\t{\n+\t  if (DECL_SIZE (decl) == 0)\n+\t    {\n+\t      tree init_expr = DECL_INITIAL (decl);\n+\t      tree init_type;\n+\t      tree specified_mode = TREE_TYPE (decl);\n+\n+\t      if (init_expr == NULL_TREE\n+\t\t  || TREE_CODE (init_expr) == ERROR_MARK)\n+\t\tgoto bad_const;\n+\t      init_type = TREE_TYPE (init_expr);\n+\t      if (specified_mode == NULL_TREE)\n+\t\t{\n+\t\t  if (init_type == NULL_TREE)\n+\t\t    {\n+\t\t      check_have_mode (init_expr, \"SYN without mode\");\n+\t\t      goto bad_const;\n+\t\t    }\n+\t\t  TREE_TYPE (decl) = init_type;\n+\t\t  CH_DERIVED_FLAG (decl) = CH_DERIVED_FLAG (init_expr);\n+\t\t}\n+\t      else if (CH_IS_ASSOCIATION_MODE (specified_mode) ||\n+\t\t       CH_IS_ACCESS_MODE (specified_mode) || CH_IS_TEXT_MODE (specified_mode) ||\n+\t\t       CH_IS_BUFFER_MODE (specified_mode) || CH_IS_EVENT_MODE (specified_mode))\n+\t\t{\n+\t\t  error (\"SYN of this mode not allowed\");\n+\t\t  goto bad_const;\n+\t\t}\n+\t      else if (!CH_COMPATIBLE (init_expr, specified_mode))\n+\t\t{\n+\t\t  error (\"mode of SYN incompatible with value\");\n+\t\t  goto bad_const;\n+\t\t} \n+\t      else if (discrete_type_p (specified_mode)\n+\t\t       && TREE_CODE (init_expr) == INTEGER_CST\n+\t\t       && (compare_int_csts (LT_EXPR, init_expr,\n+\t\t\t\t\t     TYPE_MIN_VALUE (specified_mode))\n+\t\t\t   || compare_int_csts (GT_EXPR, init_expr,\n+\t\t\t\t\t\tTYPE_MAX_VALUE(specified_mode))\n+\t\t\t   ))\n+\t\t{\n+\t\t  error (\"SYN value outside range of its mode\");\n+\t\t  /* set an always-valid initial value to prevent \n+\t\t     other errors. */\n+\t\t  DECL_INITIAL (decl) = TYPE_MIN_VALUE (specified_mode);\n+\t\t}\n+\t      else if (CH_STRING_TYPE_P (specified_mode) \n+\t\t       && (init_type && CH_STRING_TYPE_P (init_type))\n+\t\t       && integer_zerop (string_assignment_condition (specified_mode, init_expr)))\n+\t\t{\n+\t\t  error (\"INIT string too large for mode\");\n+\t\t  DECL_INITIAL (decl) = error_mark_node;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct ch_class class;\n+\t\t  class.mode = TREE_TYPE (decl);\n+\t\t  class.kind = CH_VALUE_CLASS;\n+\t\t  DECL_INITIAL (decl)\n+\t\t    = convert_to_class (class, DECL_INITIAL (decl));\n+\t\t}\n+\t      /* DECL_SIZE is set to prevent re-doing this stuff. */\n+\t      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n+\t      if (! TREE_CONSTANT (DECL_INITIAL (decl))\n+\t\t  && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK)\n+\t\t{\n+\t\t  error_with_decl (decl,\n+\t\t\t\t   \"value of %s is not a valid constant\");\n+\t\t  DECL_INITIAL (decl) = error_mark_node;\n+\t\t}\n+\t    }\n+\t  result = DECL_INITIAL (decl);\n+\t}\n+      break;\n+    bad_const:\n+      DECL_INITIAL (decl) = error_mark_node;\n+      TREE_TYPE (decl) = error_mark_node;\n+      return error_mark_node;\n+    case FUNCTION_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      if (CH_DECL_PROCESS (decl))\n+\tsafe_satisfy_decl (DECL_TASKING_CODE_DECL (decl), \n+\t\t\t   prev_chain);\n+      break;\n+    case PARM_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      break;\n+    /* RESULT_DECL doesn't need to be satisfied;  \n+       it's only built internally in pass 2 */\n+    case TYPE_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      if (CH_DECL_SIGNAL (decl))\n+\tsafe_satisfy_decl (DECL_TASKING_CODE_DECL (decl), \n+\t\t\t   prev_chain);\n+      if (!LOOKUP_ONLY)\n+\t{\n+\t  if (TYPE_NAME (TREE_TYPE (decl)) == NULL_TREE)\n+\t    TYPE_NAME (TREE_TYPE (decl)) = decl;\n+\t  layout_decl (decl, 0);\n+\t  if (CH_DECL_SIGNAL (decl) && CH_TYPE_NONVALUE_P (TREE_TYPE (decl)))\n+\t    error (\"mode with non-value property in signal definition\");\n+\t  result = TREE_TYPE (decl);\n+\t}\n+      break;\n+    case VAR_DECL:\n+      SATISFY (TREE_TYPE (decl));\n+      if (!LOOKUP_ONLY)\n+\t{\n+\t  layout_decl (decl, 0);\n+\t  if (TREE_READONLY (TREE_TYPE (decl)))\n+\t    TREE_READONLY (decl) = 1;\n+\t}\n+      break;\n+    default:\n+      ;\n+    }\n+\n+  /* Now set the DECL_RTL, if needed. */\n+  if (!LOOKUP_ONLY && DECL_RTL (decl) == 0\n+      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == CONST_DECL))\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))\n+\tmake_function_rtl (decl);\n+      else if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+\texpand_decl (decl);\n+      else\n+\t{ char * asm_name;\n+\t  if (current_module == 0 || TREE_PUBLIC (decl)\n+\t      || current_function_decl)\n+\t    asm_name = NULL;\n+\t  else\n+\t    {\n+\t      asm_name = (char*)\n+\t\talloca (IDENTIFIER_LENGTH (current_module->prefix_name)\n+\t\t\t+ IDENTIFIER_LENGTH (DECL_NAME (decl)) + 3);\n+\t      sprintf (asm_name, \"%s__%s\",\n+\t\t       IDENTIFIER_POINTER (current_module->prefix_name),\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t    }\n+\t  make_decl_rtl (decl, asm_name, TREE_PUBLIC (decl));\n+\t}\n+    }\n+\n+  input_filename = save_filename;\n+  lineno = save_lineno;\n+\n+  return result;\n+}\n+\n+tree\n+satisfy_decl (decl, lookup_only)\n+     tree decl;\n+     int lookup_only;\n+{\n+  return safe_satisfy_decl (decl, lookup_only ? &dummy_chain : NULL);\n+}\n+\n+static void\n+satisfy_list (exp, chain)\n+     register tree exp;\n+     struct decl_chain *chain;\n+{\n+  for (; exp != NULL_TREE; exp = TREE_CHAIN (exp))\n+    {\n+      SATISFY (TREE_VALUE (exp));\n+      SATISFY (TREE_PURPOSE (exp));\n+    }\n+}\n+\n+static void\n+satisfy_list_values (exp, chain)\n+     register tree exp;\n+     struct decl_chain *chain;\n+{\n+  for (; exp != NULL_TREE; exp = TREE_CHAIN (exp))\n+    {\n+      SATISFY (TREE_VALUE (exp));\n+    }\n+}\n+\n+tree\n+satisfy (exp, chain)\n+     tree exp;\n+     struct decl_chain *chain;\n+{\n+  int arg_length;\n+  int i;\n+  tree decl;\n+\n+  if (exp == NULL_TREE)\n+    return NULL_TREE;\n+\n+#if 0\n+  if (!UNSATISFIED (exp))\n+    return exp;\n+#endif\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n+    {\n+    case 'd':\n+      if (!LOOKUP_ONLY)\n+\treturn safe_satisfy_decl (exp, chain);\n+      break;\n+    case 'r':\n+    case 's':\n+    case '<':\n+    case 'e':\n+      switch ((enum chill_tree_code)TREE_CODE (exp))\n+\t{\n+\tcase REPLICATE_EXPR:\n+\t  goto binary_op;\n+\tcase TRUTH_NOT_EXPR:\n+\t  goto unary_op;\n+\tcase COMPONENT_REF:\n+\t  SATISFY (TREE_OPERAND (exp, 0));\n+\t  if (!LOOKUP_ONLY && TREE_TYPE (exp) == NULL_TREE)\n+\t    return resolve_component_ref (exp);\n+\t  return exp;\n+\tcase CALL_EXPR:\n+\t  SATISFY (TREE_OPERAND (exp, 0));\n+\t  SATISFY (TREE_OPERAND (exp, 1));\n+\t  if (!LOOKUP_ONLY && TREE_TYPE (exp) == NULL_TREE)\n+\t    return build_generalized_call (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t   TREE_OPERAND (exp, 1));\n+\t  return exp;\n+\tcase CONSTRUCTOR:\n+\t  { tree link = TREE_OPERAND (exp, 1);\n+\t    int expand_needed = TREE_TYPE (exp)\n+\t      && TREE_CODE_CLASS (TREE_CODE (TREE_TYPE (exp))) != 't';\n+\t    for (; link != NULL_TREE; link = TREE_CHAIN (link))\n+\t      {\n+\t\tSATISFY (TREE_VALUE (link));\n+\t\tif (!TUPLE_NAMED_FIELD (link))\n+\t\t  SATISFY (TREE_PURPOSE (link));\n+\t      }\n+\t    SATISFY (TREE_TYPE (exp));\n+\t    if (expand_needed && !LOOKUP_ONLY)\n+\t      {\n+\t\ttree type = TREE_TYPE (exp);\n+\t\tTREE_TYPE (exp) = NULL_TREE; /* To force expansion. */\n+\t\treturn chill_expand_tuple (type, exp);\n+\t      }\n+\t    return exp;\n+\t  }\n+\tdefault:\n+\t  ;\n+\t}\n+      arg_length = tree_code_length[TREE_CODE (exp)];\n+      for (i = 0; i < arg_length; i++)\n+\tSATISFY (TREE_OPERAND (exp, i));\n+      return exp;\n+    case '1':\n+    unary_op:\n+      SATISFY (TREE_OPERAND (exp, 0));\n+      if ((enum chill_tree_code)TREE_CODE (exp) == PAREN_EXPR)\n+\treturn TREE_OPERAND (exp, 0);\n+      if (!LOOKUP_ONLY)\n+\treturn finish_chill_unary_op (exp);\n+      break;\n+    case '2':\n+    binary_op:\n+      SATISFY (TREE_OPERAND (exp, 0));\n+      SATISFY (TREE_OPERAND (exp, 1));\n+      if (!LOOKUP_ONLY && TREE_CODE (exp) != RANGE_EXPR)\n+\treturn finish_chill_binary_op (exp);\n+      break;\n+    case 'x':\n+      switch ((enum chill_tree_code)TREE_CODE (exp))\n+\t{\n+\tcase IDENTIFIER_NODE:\n+\t  decl = lookup_name (exp);\n+\t  if (decl == NULL)\n+\t    {\n+\t      if (LOOKUP_ONLY)\n+\t\treturn exp;\n+\t      error (\"undeclared identifier `%s'\", IDENTIFIER_POINTER (exp));\n+\t      return error_mark_node;\n+\t    }\n+\t  if (LOOKUP_ONLY)\n+\t    return decl;\n+\t  return safe_satisfy_decl (decl, chain);\n+\tcase TREE_LIST:\n+\t  satisfy_list (exp, chain);\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+      break;\n+    case 't':\n+      /* If TYPE_SIZE is non-NULL, exp and its subfields has already been\n+\t satified and laid out.  The exception is pointer and reference types,\n+\t which we layout before we lay out their TREE_TYPE. */\n+      if (TYPE_SIZE (exp) && TREE_CODE (exp) != POINTER_TYPE\n+\t  && TREE_CODE (exp) != REFERENCE_TYPE)\n+\treturn exp;\n+      if (TYPE_MAIN_VARIANT (exp) != exp)\n+\tSATISFY (TYPE_MAIN_VARIANT (exp));\n+      switch ((enum chill_tree_code)TREE_CODE (exp))\n+\t{\n+\tcase LANG_TYPE:\n+\t  {\n+\t    tree d = TYPE_DOMAIN (exp);\n+\t    tree t = satisfy (TREE_TYPE (exp), chain);\n+\t    SATISFY (d);\n+\t    /* It is possible that one of the above satisfy calls recursively\n+\t       caused exp to be satisfied, in which case we're done. */\n+\t    if (TREE_CODE (exp) != LANG_TYPE)\n+\t      return exp;\n+\t    TREE_TYPE (exp) = t;\n+\t    TYPE_DOMAIN (exp) = d;\n+\t    if (!LOOKUP_ONLY)\n+\t      exp = smash_dummy_type (exp);\n+\t  }\n+\t  break;\n+\tcase ARRAY_TYPE:\n+\t  SATISFY (TREE_TYPE (exp));\n+\t  SATISFY (TYPE_DOMAIN (exp));\n+\t  SATISFY (TYPE_ATTRIBUTES (exp));\n+\t  if (!LOOKUP_ONLY)\n+\t    CH_TYPE_NONVALUE_P (exp) = CH_TYPE_NONVALUE_P (TREE_TYPE (exp));\n+\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t    exp = layout_chill_array_type (exp);\n+\t  break;\n+\tcase FUNCTION_TYPE:\n+\t  SATISFY (TREE_TYPE (exp));\n+\t  if (TREE_CODE_CLASS (TREE_CODE (TREE_TYPE (exp))) != 't'\n+\t      && !LOOKUP_ONLY && TREE_CODE (TREE_TYPE (exp)) != ERROR_MARK)\n+\t    {\n+\t      error (\"RETURNS spec with invalid mode\");\n+\t      TREE_TYPE (exp) = error_mark_node;\n+\t    }\n+\t  satisfy_list_values (TYPE_ARG_TYPES (exp), chain);\n+\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t    layout_type (exp);\n+\t  break;\n+\tcase ENUMERAL_TYPE:\n+\t  if (TYPE_SIZE (exp) == NULL_TREE && !LOOKUP_ONLY)\n+\t    { tree pair;\n+\t      /* FIXME:  Should this use satisfy_decl? */\n+\t      for (pair = TYPE_VALUES (exp); pair; pair = TREE_CHAIN (pair))\n+\t\tSATISFY (DECL_INITIAL (TREE_VALUE (pair)));\n+\t      layout_enum (exp);\n+\t    }\n+\t  break;\n+\tcase INTEGER_TYPE:\n+\t  SATISFY (TYPE_MIN_VALUE (exp));\n+\t  SATISFY (TYPE_MAX_VALUE (exp));\n+\t  if (TREE_TYPE (exp) != NULL_TREE)\n+\t    { /* A range type */\n+\t      if (TREE_TYPE (exp) != ridpointers[(int) RID_RANGE]\n+\t\t  && TREE_TYPE (exp) != ridpointers[(int) RID_BIN]\n+\t\t  && TREE_TYPE (exp) != string_index_type_dummy)\n+\t\tSATISFY (TREE_TYPE (exp));\n+\t      if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t\texp = layout_chill_range_type (exp, 1);\n+\t    }\n+\t  break;\n+\tcase POINTER_TYPE:\n+\tcase REFERENCE_TYPE:\n+\t  if (LOOKUP_ONLY)\n+\t    SATISFY (TREE_TYPE (exp));\n+\t  else\n+\t    {\n+\t      struct decl_chain *link;\n+\t      int already_seen = 0;\n+\t      for (link = chain; ; link = link->prev)\n+\t\t{\n+\t\t  if (link == NULL)\n+\t\t    {\t\n+\t\t      struct decl_chain new_link;\n+\t\t      new_link.decl = exp;\n+\t\t      new_link.prev = chain;\n+\t\t      TREE_TYPE (exp) = satisfy (TREE_TYPE (exp), &new_link);\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (link->decl == exp)\n+\t\t    {\n+\t\t      already_seen = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      if (!TYPE_SIZE (exp))\n+\t\t{\n+\t\t  layout_type (exp);\n+\t\t  if (TREE_CODE (exp) == REFERENCE_TYPE)\n+\t\t    CH_NOVELTY (exp) = CH_NOVELTY (TREE_TYPE (exp));\n+\t\t  if (! already_seen)\n+\t\t    {\n+\t\t      tree valtype = TREE_TYPE (exp);\n+\t\t      if (TREE_CODE_CLASS (TREE_CODE (valtype)) != 't')\n+\t\t\t{\n+\t\t\t  if (TREE_CODE (valtype) != ERROR_MARK)\n+\t\t\t    error (\"operand to REF is not a mode\");\n+\t\t\t  TREE_TYPE (exp) = error_mark_node;\n+\t\t\t  return error_mark_node;\n+\t\t\t}\n+\t\t      else if (TREE_CODE (exp) == POINTER_TYPE\n+\t\t\t       && TYPE_POINTER_TO (valtype) == NULL)\n+\t\t\tTYPE_POINTER_TO (valtype) = exp;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase RECORD_TYPE:\n+\t  {\n+\t    /* FIXME: detected errors in here will be printed as\n+\t       often as this sequence runs. Find another way or\n+\t       place to print the errors. */\n+\t    /* if we have an ACCESS or TEXT mode we have to set\n+\t       maximum_field_alignment to 0 to fit with runtime\n+\t       system, even when we compile with -fpack. */\n+\t    extern int maximum_field_alignment;\n+\t    int save_maximum_field_alignment = maximum_field_alignment;\n+\n+\t    if (CH_IS_ACCESS_MODE (exp) || CH_IS_TEXT_MODE (exp))\n+\t      maximum_field_alignment = 0;\n+\n+\t    for (decl = TYPE_FIELDS (exp); decl; decl = TREE_CHAIN (decl))\n+\t      {\n+\t\tSATISFY (TREE_TYPE (decl));\n+\t\tif (!LOOKUP_ONLY)\n+\t\t  {\n+\t\t    /* if we have a UNION_TYPE here (variant structure), check for\n+\t\t       non-value mode in it. This is not allowed (Z.200/pg. 33) */\n+\t\t    if (TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE &&\n+\t\t\tCH_TYPE_NONVALUE_P (TREE_TYPE (decl)))\n+\t\t      {\n+\t\t\terror (\"field with non-value mode in variant structure not allowed\");\n+\t\t\tTREE_TYPE (decl) = error_mark_node;\n+\t\t      }\n+\t\t    /* RECORD_TYPE gets the non-value property if one of the\n+\t\t       fields has the non-value property */\n+\t\t    CH_TYPE_NONVALUE_P (exp) |= CH_TYPE_NONVALUE_P (TREE_TYPE (decl));\n+\t\t  }\n+\t\tif (TREE_CODE (decl) == CONST_DECL)\n+\t\t  {\n+\t\t    SATISFY (DECL_INITIAL (decl));\n+\t\t    if (!LOOKUP_ONLY)\n+\t\t      {\n+\t\t\tif (CH_IS_BUFFER_MODE (exp) || CH_IS_EVENT_MODE (exp))\n+\t\t\t  DECL_INITIAL (decl)\n+\t\t\t    = check_queue_size (exp, DECL_INITIAL (decl));\n+\t\t\telse if (CH_IS_TEXT_MODE (exp) &&\n+\t\t\t\t DECL_NAME (decl) == get_identifier (\"__textlength\"))\n+\t\t\t  DECL_INITIAL (decl)\n+\t\t\t    = check_text_length (exp, DECL_INITIAL (decl));\n+\t\t      }\n+\t\t  }\n+\t\telse if (TREE_CODE (decl) == FIELD_DECL)\n+\t\t  {\n+\t\t    SATISFY (DECL_INITIAL (decl));\n+\t\t  }\n+\t      }\n+\t    satisfy_list (TYPE_TAG_VALUES (exp), chain);\n+\t    if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t      exp = layout_chill_struct_type (exp);\n+\t    maximum_field_alignment = save_maximum_field_alignment;\n+\n+\t    /* perform some checks on nonvalue modes, they are record_mode's */\n+\t    if (!LOOKUP_ONLY)\n+\t      {\n+\t\tif (CH_IS_BUFFER_MODE (exp))\n+\t\t  {\n+\t\t    tree elemmode = buffer_element_mode (exp);\n+\t\t    if (elemmode != NULL_TREE && CH_TYPE_NONVALUE_P (elemmode))\n+\t\t      {\n+\t\t\terror (\"buffer element mode must not have non-value property\");\n+\t\t\tinvalidate_buffer_element_mode (exp);\n+\t\t      }\n+\t\t  }\n+\t\telse if (CH_IS_ACCESS_MODE (exp))\n+\t\t  {\n+\t\t    tree recordmode = access_recordmode (exp);\n+\t\t    if (recordmode != NULL_TREE && CH_TYPE_NONVALUE_P (recordmode))\n+\t\t      {\n+\t\t\terror (\"recordmode must not have the non-value property\");\n+\t\t\tinvalidate_access_recordmode (exp);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\tcase SET_TYPE:\n+\t  SATISFY (TYPE_DOMAIN (exp));\n+\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t    exp = layout_powerset_type (exp);\n+\t  break;\n+\tcase UNION_TYPE:\n+\t  for (decl = TYPE_FIELDS (exp); decl; decl = TREE_CHAIN (decl))\n+\t    {\n+\t      SATISFY (TREE_TYPE (decl));\n+\t      if (!LOOKUP_ONLY)\n+\t\tCH_TYPE_NONVALUE_P (exp) |= CH_TYPE_NONVALUE_P (TREE_TYPE (decl));\n+\t    }\n+\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n+\t    exp = layout_chill_variants (exp);\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+  return exp;\n+}"}, {"sha": "95c81c6fd2e89d63785364b9ec05ce5c251953be", "filename": "gcc/ch/tasking.c", "status": "added", "additions": 3423, "deletions": 0, "changes": 3423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftasking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftasking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftasking.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93"}, {"sha": "f96b7159f3663a6cc0ba643db8f11be2d2100c8a", "filename": "gcc/ch/timing.c", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftiming.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftiming.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftiming.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93", "patch": "@@ -0,0 +1,494 @@\n+/* Implement timing-related actions for CHILL.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <limits.h>\n+#include <string.h>\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"ch-tree.h\"\n+#include \"flags.h\"\n+#include \"input.h\"\n+#include \"obstack.h\"\n+#include \"lex.h\"\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+/* set non-zero if input text is forced to lowercase */\n+extern int ignore_case;\n+\n+/* set non-zero if special words are to be entered in uppercase */\n+extern int special_UC;\n+\n+/* timing modes */\n+tree abs_timing_type_node;\n+tree duration_timing_type_node;\n+\n+/* rts time type */\n+static tree rtstime_type_node = NULL_TREE;\n+\n+/* the stack for AFTER primval [ DELAY ] IN \n+   and has following layout\n+\n+   TREE_VALUE (TREE_VALUE (after_stack)) = current time or NULL_TREE (if DELAY specified)\n+   TREE_PURPOSE (TREE_VALUE (after_stack)) = the duration location\n+   TREE_VALUE (TREE_PURPOSE (after_stack)) = label at TIMEOUT\n+   TREE_PURPOSE (TREE_PURPOSE (after_stack)) = label at the end of AFTER action\n+*/\n+tree after_stack = NULL_TREE;\n+\n+/* in pass 1 we need a seperate list for the labels */\n+static tree after_stack_pass_1 = NULL_TREE;\n+static tree after_help;\n+\n+void\n+timing_init ()\n+{\n+  tree ptr_ftype_durt_ptr_int;\n+  tree int_ftype_abst_ptr_int;\n+  tree void_ftype_ptr;\n+  tree long_ftype_int_int_int_int_int_int_int_ptr_int;\n+  tree void_ftype_abstime_ptr;\n+  tree int_ftype_ptr_durt_ptr;\n+  tree void_ftype_durt_ptr;\n+  tree void_ftype_ptr_durt_ptr_int;\n+  tree temp;\n+  tree endlink;\n+  tree ulong_type;\n+  \n+  ulong_type = TREE_TYPE (lookup_name (\n+\t\t          get_identifier ((ignore_case || ! special_UC ) ?\n+\t\t\t\t\t  \"ulong\" : \"ULONG\")));\n+\n+  /* build modes for TIME and DURATION */\n+  duration_timing_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n+  temp = pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_DURATION],\n+\t\t\t       duration_timing_type_node));\n+  SET_CH_NOVELTY_NONNIL (duration_timing_type_node, temp);\n+  abs_timing_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n+  temp = pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_TIME],\n+\t\t\t       abs_timing_type_node));\n+  SET_CH_NOVELTY_NONNIL (abs_timing_type_node, temp);\n+\n+  /* the mode of time the runtimesystem returns */\n+  if (rtstime_type_node == NULL_TREE)\n+  {\n+      tree decl1, decl2, result;\n+\n+      decl1 = build_decl (FIELD_DECL,\n+\t\t\t  get_identifier (\"secs\"),\n+\t\t\t  ulong_type);\n+      DECL_INITIAL (decl1) = NULL_TREE;\n+      decl2 = build_decl (FIELD_DECL,\n+\t\t\t  get_identifier (\"nsecs\"),\n+\t\t\t  ulong_type);\n+      DECL_INITIAL (decl2) = NULL_TREE;\n+      TREE_CHAIN (decl2) = NULL_TREE;\n+      TREE_CHAIN (decl1) = decl2;\n+      \n+      result = build_chill_struct_type (decl1);\n+      pushdecl (temp = build_decl (TYPE_DECL,\n+\tget_identifier (\"__tmp_rtstime\"), result));\n+      DECL_SOURCE_LINE (temp) = 0;\n+      satisfy_decl (temp, 0);\n+      rtstime_type_node = TREE_TYPE (temp);\n+  }\n+  \n+  endlink = void_list_node;\n+  \n+  ptr_ftype_durt_ptr_int\n+    = build_function_type (ptr_type_node,\n+         tree_cons (NULL_TREE, duration_timing_type_node,\n+             tree_cons (NULL_TREE, ptr_type_node,\n+                 tree_cons (NULL_TREE, integer_type_node,\n+                     endlink))));\n+\n+  int_ftype_abst_ptr_int\n+    = build_function_type (integer_type_node,\n+         tree_cons (NULL_TREE, abs_timing_type_node,\n+             tree_cons (NULL_TREE, ptr_type_node,\n+                 tree_cons (NULL_TREE, integer_type_node,\n+                     endlink))));\n+\n+  void_ftype_ptr\n+     = build_function_type (void_type_node,\n+\t   tree_cons (NULL_TREE, ptr_type_node,\n+\t       endlink));\n+\n+  long_ftype_int_int_int_int_int_int_int_ptr_int\n+    = build_function_type (abs_timing_type_node,\n+\t tree_cons (NULL_TREE, integer_type_node,\n+\t    tree_cons (NULL_TREE, integer_type_node,\n+\t       tree_cons (NULL_TREE, integer_type_node,\n+\t          tree_cons (NULL_TREE, integer_type_node,\n+\t             tree_cons (NULL_TREE, integer_type_node,\n+\t                tree_cons (NULL_TREE, integer_type_node,\n+\t                   tree_cons (NULL_TREE, integer_type_node,\n+\t                      tree_cons (NULL_TREE, ptr_type_node,\n+\t                         tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t            endlink))))))))));\n+\n+  void_ftype_abstime_ptr\n+    = build_function_type (void_type_node,\n+          tree_cons (NULL_TREE, abs_timing_type_node,\n+              tree_cons (NULL_TREE, ptr_type_node,\n+                  endlink)));\n+\n+  int_ftype_ptr_durt_ptr\n+    = build_function_type (integer_type_node,\n+          tree_cons (NULL_TREE, ptr_type_node,\n+              tree_cons (NULL_TREE, duration_timing_type_node,\n+                  tree_cons (NULL_TREE, ptr_type_node,\n+                      endlink))));\n+\n+  void_ftype_durt_ptr\n+    = build_function_type (void_type_node,\n+          tree_cons (NULL_TREE, duration_timing_type_node,\n+              tree_cons (NULL_TREE, ptr_type_node,\n+                  endlink)));\n+\n+  void_ftype_ptr_durt_ptr_int\n+    = build_function_type (void_type_node,\n+        tree_cons (NULL_TREE, ptr_type_node,\n+          tree_cons (NULL_TREE, duration_timing_type_node,\n+            tree_cons (NULL_TREE, ptr_type_node,\n+              tree_cons (NULL_TREE, integer_type_node,\n+                endlink)))));\n+\n+  builtin_function (\"_abstime\", long_ftype_int_int_int_int_int_int_int_ptr_int,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__check_cycle\", void_ftype_ptr_durt_ptr_int,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__convert_duration_rtstime\", void_ftype_durt_ptr,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__define_timeout\", ptr_ftype_durt_ptr_int,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"_inttime\", void_ftype_abstime_ptr,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__remaintime\", int_ftype_ptr_durt_ptr,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__rtstime\", void_ftype_ptr,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+  builtin_function (\"__wait_until\", int_ftype_abst_ptr_int,\n+\t\t    NOT_BUILT_IN, NULL_PTR);\n+}\n+\n+#if 0\n+ *\n+ * build AT action\n+ *\n+ * AT primval IN\n+ *  ok-actionlist\n+ * TIMEOUT\n+ *  to-actionlist\n+ * END;\n+ *\n+ * gets translated to\n+ *\n+ * if (__wait_until (primval) == 0)\n+ *   ok-actionlist\n+ * else\n+ *   to-action-list\n+ *\n+#endif\n+\n+void\n+build_at_action (t)\n+     tree t;\n+{\n+  tree abstime, expr, filename, fcall;\n+  \n+  if (t == NULL_TREE || TREE_CODE (t) == ERROR_MARK)\n+    abstime = convert (abs_timing_type_node, build_int_2 (0, 0));\n+  else\n+    abstime = t;\n+  \n+  if (TREE_TYPE (abstime) != abs_timing_type_node)\n+    {\n+      error (\"absolute time value must be of mode TIME.\");\n+      abstime = convert (abs_timing_type_node, build_int_2 (0, 0));\n+    }\n+  filename = force_addr_of (get_chill_filename ());\n+  fcall = build_chill_function_call (\n+\t    lookup_name (get_identifier (\"__wait_until\")),\n+\t      tree_cons (NULL_TREE, abstime,\n+\t\ttree_cons (NULL_TREE, filename,\n+\t\t  tree_cons (NULL_TREE, get_chill_linenumber (), NULL_TREE))));\n+  expr = build (EQ_EXPR, integer_type_node, fcall, integer_zero_node);\n+  expand_start_cond (expr, 0);\n+  emit_line_note (input_filename, lineno);\n+}\n+\n+#if 0\n+ *\n+ * build CYCLE action\n+ *\n+ * CYCLE primval IN\n+ *  actionlist\n+ * END;\n+ *\n+ * gets translated to\n+ *\n+ * {\n+ *    RtsTime  now; \n+ *  label:\n+ *    __rtstime (&now); \n+ *     actionlist\n+ *    __check_cycle (&now, primval, filename, lineno); \n+ *    goto label;\n+ *  }\n+ *\n+#endif\n+\n+tree\n+build_cycle_start (t)\n+    tree t;\n+{\n+  tree purpose = build_tree_list (NULL_TREE, NULL_TREE);\n+  tree toid = build_tree_list (purpose, NULL_TREE);\n+\n+  /* define the label. Note: define_label needs to be called in\n+     pass 1 and pass 2. */\n+  TREE_VALUE (toid) = define_label (input_filename, lineno,\n+\t\t\t\t    get_unique_identifier (\"CYCLE_label\"));\n+  if (! ignoring)\n+    {\n+      tree duration_value, now_location;\n+      \n+      if (t == NULL_TREE || TREE_CODE (t) == ERROR_MARK)\n+\tduration_value = convert (duration_timing_type_node, build_int_2 (0,0));\n+      else\n+\tduration_value = t;\n+      \n+      if (TREE_TYPE (duration_value) != duration_timing_type_node)\n+\t{\n+\t  error (\"duration primitive value must be of mode DURATION.\");\n+\t  duration_value = convert (duration_timing_type_node, build_int_2 (0,0));\n+\t}\n+      TREE_PURPOSE (TREE_PURPOSE (toid)) = duration_value;\n+      /* define the variable */\n+      now_location = decl_temp1 (get_unique_identifier (\"CYCLE_var\"),\n+\t\t\t\t rtstime_type_node, 0,\n+\t\t\t\t NULL_TREE, 0, 0);\n+      TREE_VALUE (TREE_PURPOSE (toid)) = force_addr_of (now_location);\n+      \n+      /* build the call to __rtstime */\n+      expand_expr_stmt (\n+        build_chill_function_call (lookup_name (get_identifier (\"__rtstime\")),\n+          build_tree_list (NULL_TREE, TREE_VALUE (TREE_PURPOSE (toid)))));\n+    }\n+\n+  return toid;\n+}\n+\n+void\n+build_cycle_end (toid)\n+     tree toid;\n+{\n+  tree filename, linenumber;\n+  \n+  /* here we call __check_cycle and then jump to beginning of this\n+     action */\n+  filename = force_addr_of (get_chill_filename ());\n+  linenumber = get_chill_linenumber ();\n+  expand_expr_stmt (\n+    build_chill_function_call (\n+      lookup_name (get_identifier (\"__check_cycle\")),\n+\ttree_cons (NULL_TREE, TREE_VALUE (TREE_PURPOSE (toid)),\n+          tree_cons (NULL_TREE, TREE_PURPOSE (TREE_PURPOSE (toid)),\n+\t    tree_cons (NULL_TREE, filename,\n+\t      tree_cons (NULL_TREE, linenumber, NULL_TREE))))));\n+  expand_goto (TREE_VALUE (toid));\n+}\n+\n+#if 0\n+ *\n+ * build AFTER ACTION\n+ *\n+ * AFTER primval [ DELAY ] IN\n+ *  action-list\n+ * TIMEOUT\n+ *  to-action-list\n+ * END\n+ *\n+ * gets translated to\n+ *\n+ * {\n+ *   struct chill_time __now; \n+ *   duration dur = primval; \n+ *   if (! delay_spceified)\n+ *     __rts_time (&__now); \n+ *     .\n+ *     .\n+ *    goto end-label;\n+ *   to-label:\n+ *     .\n+ *     .\n+ *   end-label:\n+ * }\n+ *\n+#endif\n+\n+void\n+build_after_start (duration, delay_flag)\n+    tree duration;\n+    int  delay_flag;\n+{\n+  tree value, purpose;\n+  \n+  if (! ignoring)\n+    {\n+      value = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+      purpose = after_stack_pass_1;\n+      after_stack_pass_1 = TREE_CHAIN (after_stack_pass_1);\n+      after_stack = tree_cons (purpose, value, after_stack);\n+      \n+      if (TREE_TYPE (duration) != duration_timing_type_node)\n+        {\n+\t  error (\"duration primitive value must be of mode DURATION.\");\n+\t  duration = convert (duration_timing_type_node, build_int_2 (0,0));\n+        }\n+      TREE_PURPOSE (value) = decl_temp1 (get_identifier (\"AFTER_duration\"),\n+\t\t\t\t\t duration_timing_type_node, 0,\n+\t\t\t\t\t duration, 0, 0);\n+      \n+      if (! delay_flag)\n+        {\n+\t  /* in this case we have to get the current time */\n+\t  TREE_VALUE (value) = decl_temp1 (get_unique_identifier (\"AFTER_now\"),\n+\t\t\t\t\t   rtstime_type_node, 0,\n+\t\t\t\t\t   NULL_TREE, 0, 0);\n+\t  /* build the function call to initialize the variable */\n+\t  expand_expr_stmt (\n+            build_chill_function_call (lookup_name (get_identifier (\"__rtstime\")),\n+              build_tree_list (NULL_TREE, force_addr_of (TREE_VALUE (value)))));\n+        }\n+    }\n+  else\n+    {\n+      /* in pass 1 we just save the labels */\n+      after_help = tree_cons (NULL_TREE, NULL_TREE, after_help);\n+      after_stack_pass_1 = chainon (after_stack_pass_1, after_help);\n+    }\n+}\n+\n+void\n+build_after_timeout_start ()\n+{\n+  tree label_name, goto_where;\n+  \n+  if (! ignoring)\n+    {\n+      /* jump to the end of AFTER action */\n+      lookup_and_expand_goto (TREE_PURPOSE (TREE_PURPOSE (after_stack)));\n+      label_name = TREE_VALUE (TREE_PURPOSE (after_stack));\n+      /* mark we are in TIMEOUT part of AFTER action */\n+      TREE_VALUE (TREE_PURPOSE (after_stack)) = NULL_TREE;\n+    }\n+  else\n+    {\n+      label_name = get_unique_identifier (\"AFTER_tolabel\");\n+      TREE_VALUE (after_help) = label_name;\n+    }\n+  define_label (input_filename, lineno, label_name);\n+}\n+\n+void\n+build_after_end ()\n+{\n+  tree label_name;\n+    \n+  /* define the end label */\n+  if (! ignoring)\n+    {\n+      label_name = TREE_PURPOSE (TREE_PURPOSE (after_stack));\n+      after_stack = TREE_CHAIN (after_stack);\n+    }\n+  else\n+    {\n+      label_name = get_unique_identifier (\"AFTER_endlabel\");\n+      TREE_PURPOSE (after_help) = label_name;\n+      after_help = TREE_CHAIN (after_help);\n+    }\n+  define_label (input_filename, lineno, label_name);\n+}\n+\n+tree\n+build_timeout_preface ()\n+{\n+  tree timeout_value = null_pointer_node;\n+  \n+  if (after_stack != NULL_TREE &&\n+      TREE_VALUE (TREE_PURPOSE (after_stack)) != NULL_TREE)\n+    {\n+      tree to_loc;\n+      \n+      to_loc = decl_temp1 (get_unique_identifier (\"TOloc\"),\n+\t\t\t   rtstime_type_node, 0, NULL_TREE, 0, 0);\n+      timeout_value = force_addr_of (to_loc);\n+\n+      if (TREE_VALUE (TREE_VALUE (after_stack)) == NULL_TREE)\n+        {\n+\t  /* DELAY specified -- just call __convert_duration_rtstime for\n+\t     given duration value */\n+\t  expand_expr_stmt (\n+            build_chill_function_call (\n+              lookup_name (get_identifier (\"__convert_duration_rtstime\")),\n+                tree_cons (NULL_TREE, TREE_PURPOSE (TREE_VALUE (after_stack)),\n+                  tree_cons (NULL_TREE, timeout_value, NULL_TREE))));\n+        }\n+      else\n+        {\n+\t  /* delay not specified -- call __remaintime which returns the \n+\t     remaining time of duration in rtstime format and check the \n+\t     result */\n+\t  tree fcall = \n+            build_chill_function_call (\n+              lookup_name (get_identifier (\"__remaintime\")),\n+                tree_cons (NULL_TREE, force_addr_of (TREE_VALUE (TREE_VALUE (after_stack))),\n+\t\t  tree_cons (NULL_TREE, TREE_PURPOSE (TREE_VALUE (after_stack)),\n+                    tree_cons (NULL_TREE, timeout_value, NULL_TREE))));\n+\t  tree expr = build (NE_EXPR, integer_type_node,\n+\t\t\t     fcall, integer_zero_node);\n+\t  expand_start_cond (expr, 0);\n+\t  lookup_and_expand_goto (TREE_VALUE (TREE_PURPOSE (after_stack)));\n+\t  expand_end_cond ();\n+        }\n+    }\n+  return timeout_value;\n+}\n+\n+void\n+build_timesupervised_call (fcall, to_loc)\n+    tree fcall;\n+    tree to_loc;\n+{\n+  if (to_loc == null_pointer_node)\n+    expand_expr_stmt (fcall);\n+  else\n+    {\n+      tree expr = build (NE_EXPR, integer_type_node, fcall, integer_zero_node);\n+      expand_start_cond (expr, 0);\n+      lookup_and_expand_goto (TREE_VALUE (TREE_PURPOSE (after_stack)));\n+      expand_end_cond ();\n+    }\n+}"}, {"sha": "5f9749410e0ed88b0ffbb49e55254ed1730830e4", "filename": "gcc/ch/typeck.c", "status": "added", "additions": 3905, "deletions": 0, "changes": 3905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=3c79b2da6ba52fe9ae2ec45f9ed6774f3366db93"}]}