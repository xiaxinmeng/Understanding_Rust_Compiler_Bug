{"sha": "6b6ccd10606c3c0811577e6edd5a95dbc46d17ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2Y2NkMTA2MDZjM2MwODExNTc3ZTZlZGQ1YTk1ZGJjNDZkMTdiYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T23:21:16Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T23:21:16Z"}, "message": "(float{,uns}sidf2): Call rs6000_float_const to portably build the proper floating point constant for conversions.\n\n(float{,uns}sidf2): Call rs6000_float_const to portably build the proper\nfloating point constant for conversions.\n(movdi): Properly handle movdi of CONST_{INT,DOUBLE} on little endian systems.\n\nFrom-SVN: r10318", "tree": {"sha": "797e20b276272c5c01fc6d682b723fb3421488b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/797e20b276272c5c01fc6d682b723fb3421488b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba/comments", "author": null, "committer": null, "parents": [{"sha": "24d304eb56b89020178b2e20df89a7d13131cc07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d304eb56b89020178b2e20df89a7d13131cc07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d304eb56b89020178b2e20df89a7d13131cc07"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "38bd4ba68188dbccd79db8cc5af9931a5d26c9d1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6ccd10606c3c0811577e6edd5a95dbc46d17ba/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6b6ccd10606c3c0811577e6edd5a95dbc46d17ba", "patch": "@@ -3338,9 +3338,7 @@\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_rtx (CONST_INT, VOIDmode, 0x80000000);\n   operands[4] = rs6000_immed_double_const (0, 0x43300000, DImode);\n-  operands[5] = force_reg (DFmode, rs6000_immed_double_const (0x43300000,\n-\t\t\t\t\t\t\t      0x80000000,\n-\t\t\t\t\t\t\t      DFmode));\n+  operands[5] = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n }\")\n \n (define_expand \"floatunssidf2\"\n@@ -3355,7 +3353,7 @@\n {\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = rs6000_immed_double_const (0, 0x43300000, DImode);\n-  operands[4] = force_reg (DFmode, rs6000_immed_double_const (0x43300000, 0, DFmode));\n+  operands[4] = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n }\")\n \n ;; For the above two cases, we always split.\n@@ -4393,19 +4391,34 @@\n   \"\"\n   \"\n {\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DImode, operands[1]);\n+\n   if (GET_CODE (operands[1]) == CONST_DOUBLE\n       || GET_CODE (operands[1]) == CONST_INT)\n     {\n-      emit_move_insn (operand_subword (operands[0], 0, 0, DImode),\n-\t\t      operand_subword (operands[1], 0, 0, DImode));\n-      emit_move_insn (operand_subword (operands[0], 1, 0, DImode),\n-\t\t      operand_subword (operands[1], 1, 0, DImode));\n+      HOST_WIDE_INT low;\n+      HOST_WIDE_INT high;\n+\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t  low = CONST_DOUBLE_LOW (operands[1]);\n+\t  high = CONST_DOUBLE_HIGH (operands[1]);\n+\t}\n+      else\n+\t{\n+\t  low = INTVAL (operands[1]);\n+\t  high = (low < 0) ? ~0 : 0;\n+\t}\n+\n+      emit_move_insn (gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN),\n+\t\t      GEN_INT (low));\n+\n+      emit_move_insn (gen_rtx (SUBREG, SImode, operands[0], !WORDS_BIG_ENDIAN),\n+\t\t      GEN_INT (high));\n       DONE;\n     }\n \n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (DImode, operands[1]);\n-\n       /* Stores between FPR and any non-FPR registers must go through a\n          temporary stack slot.  */\n "}]}