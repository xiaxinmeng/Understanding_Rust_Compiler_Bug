{"sha": "00aaae03db249e61dde41facbf373c3fcde38154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBhYWFlMDNkYjI0OWU2MWRkZTQxZmFjYmYzNzNjM2ZjZGUzODE1NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-25T17:24:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-09-25T17:28:19Z"}, "message": "c++: Replace tag_scope with TAG_how\n\nI always found tag_scope confusing, as it is not a scope, but a\ndirection of how to lookup or insert an elaborated type tag.  This\nreplaces it with a enum class TAG_how.  I also add a new value,\nHIDDEN_FRIEND, to distinguish the two cases of innermost-non-class\ninsertion that we currently conflate.  Also renamed\n'lookup_type_scope' to 'lookup_elaborated_type', because again, we're\nnot providing a scope to lookup in.\n\n\tgcc/cp/\n\t* name-lookup.h (enum tag_scope): Replace with ...\n\t(enum class TAG_how): ... this.  Add HIDDEN_FRIEND value.\n\t(lookup_type_scope): Replace with ...\n\t(lookup_elaborated_type): ... this.\n\t(pushtag): Use TAG_how, not tag_scope.\n\t* cp-tree.h (xref_tag): Parameter is TAG_how, not tag_scope.\n\t* decl.c (lookup_and_check_tag): Likewise.  Adjust.\n\t(xref_tag_1, xref_tag): Likewise. adjust.\n\t(start_enum): Adjust lookup_and_check_tag call.\n\t* name-lookup.c (lookup_type_scope_1): Rename to ...\n\t(lookup_elaborated_type_1) ... here. Use TAG_how, not tag_scope.\n\t(lookup_type_scope): Rename to ...\n\t(lookup_elaborated_type): ... here.  Use TAG_how, not tag_scope.\n\t(do_pushtag): Use TAG_how, not tag_scope.  Adjust.\n\t(pushtag): Likewise.\n\t* parser.c (cp_parser_elaborated_type_specifier): Adjust.\n\t(cp_parser_class_head): Likewise.\n\tgcc/objcp/\n\t* objcp-decl.c (objcp_start_struct): Use TAG_how not tag_scope.\n\t(objcp_xref_tag): Likewise.", "tree": {"sha": "a3ac3986e692c4fd88467b1a50a8947d0da4243b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3ac3986e692c4fd88467b1a50a8947d0da4243b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00aaae03db249e61dde41facbf373c3fcde38154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aaae03db249e61dde41facbf373c3fcde38154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00aaae03db249e61dde41facbf373c3fcde38154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aaae03db249e61dde41facbf373c3fcde38154/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d8f3f612d662ea3007c184a11ea5eb7d58760e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8f3f612d662ea3007c184a11ea5eb7d58760e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8f3f612d662ea3007c184a11ea5eb7d58760e7"}], "stats": {"total": 180, "additions": 84, "deletions": 96}, "files": [{"sha": "321bb95912046ce3901668b19b1d93991b8f83eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -6507,7 +6507,7 @@ extern void grok_special_member_properties\t(tree);\n extern bool grok_ctor_properties\t\t(const_tree, const_tree);\n extern bool grok_op_properties\t\t\t(tree, bool);\n extern tree xref_tag\t\t\t\t(tag_types, tree,\n-\t\t\t\t\t\t tag_scope = ts_current,\n+\t\t\t\t\t\t TAG_how = TAG_how::CURRENT_ONLY,\n \t\t\t\t\t\t bool tpl_header_p = false);\n extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree, tree, tree, tree, bool, bool *);"}, {"sha": "b481bbd7b7dbd6b936b66b2dd522a4c120c71d52", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -75,7 +75,7 @@ static void record_unknown_type (tree, const char *);\n static int member_function_or_else (tree, tree, enum overload_flags);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n static const char *tag_name (enum tag_types);\n-static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n+static tree lookup_and_check_tag (enum tag_types, tree, TAG_how, bool);\n static void maybe_deduce_size_from_array_init (tree, tree);\n static void layout_var_decl (tree);\n static tree check_initializer (tree, tree, int, vec<tree, va_gc> **);\n@@ -14862,11 +14862,10 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \n static tree\n lookup_and_check_tag (enum tag_types tag_code, tree name,\n-\t\t      tag_scope scope, bool template_header_p)\n+\t\t      TAG_how how, bool template_header_p)\n {\n-  tree t;\n   tree decl;\n-  if (scope == ts_global)\n+  if (how == TAG_how::GLOBAL)\n     {\n       /* First try ordinary name lookup, ignoring hidden class name\n \t injected via friend declaration.  */\n@@ -14879,16 +14878,16 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n \t If we find one, that name will be made visible rather than\n \t creating a new tag.  */\n       if (!decl)\n-\tdecl = lookup_type_scope (name, ts_within_enclosing_non_class);\n+\tdecl = lookup_elaborated_type (name, TAG_how::INNERMOST_NON_CLASS);\n     }\n   else\n-    decl = lookup_type_scope (name, scope);\n+    decl = lookup_elaborated_type (name, how);\n \n   if (decl\n       && (DECL_CLASS_TEMPLATE_P (decl)\n-\t  /* If scope is ts_current we're defining a class, so ignore a\n-\t     template template parameter.  */\n-\t  || (scope != ts_current\n+\t  /* If scope is TAG_how::CURRENT_ONLY we're defining a class,\n+\t     so ignore a template template parameter.  */\n+\t  || (how != TAG_how::CURRENT_ONLY\n \t      && DECL_TEMPLATE_TEMPLATE_PARM_P (decl))))\n     decl = DECL_TEMPLATE_RESULT (decl);\n \n@@ -14898,11 +14897,10 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n \t   class C {\n \t     class C {};\n \t   };  */\n-      if (scope == ts_current && DECL_SELF_REFERENCE_P (decl))\n+      if (how == TAG_how::CURRENT_ONLY && DECL_SELF_REFERENCE_P (decl))\n \t{\n \t  error (\"%qD has the same name as the class in which it is \"\n-\t\t \"declared\",\n-\t\t decl);\n+\t\t \"declared\", decl);\n \t  return error_mark_node;\n \t}\n \n@@ -14922,10 +14920,10 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n \t     class C *c2;\t\t// DECL_SELF_REFERENCE_P is true\n \t   };  */\n \n-      t = check_elaborated_type_specifier (tag_code,\n-\t\t\t\t\t   decl,\n-\t\t\t\t\t   template_header_p\n-\t\t\t\t\t   | DECL_SELF_REFERENCE_P (decl));\n+      tree t = check_elaborated_type_specifier (tag_code,\n+\t\t\t\t\t\tdecl,\n+\t\t\t\t\t\ttemplate_header_p\n+\t\t\t\t\t\t| DECL_SELF_REFERENCE_P (decl));\n       if (template_header_p && t && CLASS_TYPE_P (t)\n \t  && (!CLASSTYPE_TEMPLATE_INFO (t)\n \t      || (!PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))))\n@@ -14969,7 +14967,7 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n \n static tree\n xref_tag_1 (enum tag_types tag_code, tree name,\n-            tag_scope scope, bool template_header_p)\n+            TAG_how how, bool template_header_p)\n {\n   enum tree_code code;\n   tree context = NULL_TREE;\n@@ -14996,22 +14994,22 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n      make type node and push name.  Name lookup is not required.  */\n   tree t = NULL_TREE;\n   if (!IDENTIFIER_ANON_P (name))\n-    t = lookup_and_check_tag  (tag_code, name, scope, template_header_p);\n+    t = lookup_and_check_tag  (tag_code, name, how, template_header_p);\n \n   if (t == error_mark_node)\n     return error_mark_node;\n \n-  if (scope != ts_current && t && current_class_type\n+  if (how != TAG_how::CURRENT_ONLY && t && current_class_type\n       && template_class_depth (current_class_type)\n       && template_header_p)\n     {\n       if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \treturn t;\n \n-      /* Since SCOPE is not TS_CURRENT, we are not looking at a\n-\t definition of this tag.  Since, in addition, we are currently\n-\t processing a (member) template declaration of a template\n-\t class, we must be very careful; consider:\n+      /* Since HOW is not TAG_how::CURRENT_ONLY, we are not looking at\n+\t a definition of this tag.  Since, in addition, we are\n+\t currently processing a (member) template declaration of a\n+\t template class, we must be very careful; consider:\n \n \t   template <class X> struct S1\n \n@@ -15057,7 +15055,7 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \t/* Mark it as a lambda type right now.  Our caller will\n \t   correct the value.  */\n \tCLASSTYPE_LAMBDA_EXPR (t) = error_mark_node;\n-      t = pushtag (name, t, scope);\n+      t = pushtag (name, t, how);\n     }\n   else\n     {\n@@ -15083,7 +15081,7 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \t  return error_mark_node;\n \t}\n \n-      if (scope != ts_within_enclosing_non_class && TYPE_HIDDEN_P (t))\n+      if (how != TAG_how::HIDDEN_FRIEND && TYPE_HIDDEN_P (t))\n \t{\n \t  /* This is no longer an invisible friend.  Make it\n \t     visible.  */\n@@ -15108,12 +15106,10 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n \n tree\n xref_tag (enum tag_types tag_code, tree name,\n-          tag_scope scope, bool template_header_p)\n+\t  TAG_how how, bool template_header_p)\n {\n-  tree ret;\n-  bool subtime;\n-  subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = xref_tag_1 (tag_code, name, scope, template_header_p);\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  tree ret = xref_tag_1 (tag_code, name, how, template_header_p);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -15412,7 +15408,7 @@ start_enum (tree name, tree enumtype, tree underlying_type,\n      forward reference.  */\n   if (!enumtype)\n     enumtype = lookup_and_check_tag (enum_type, name,\n-\t\t\t\t     /*tag_scope=*/ts_current,\n+\t\t\t\t     /*tag_scope=*/TAG_how::CURRENT_ONLY,\n \t\t\t\t     /*template_header_p=*/false);\n \n   /* In case of a template_decl, the only check that should be deferred"}, {"sha": "0115a4bd386f179bbc49b2186dae168c11a953e7", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -6583,22 +6583,20 @@ lookup_name (tree name)\n }\n \n /* Look up NAME for type used in elaborated name specifier in\n-   the scopes given by SCOPE.  SCOPE can be either TS_CURRENT or\n-   TS_WITHIN_ENCLOSING_NON_CLASS.  Although not implied by the\n-   name, more scopes are checked if cleanup or template parameter\n-   scope is encountered.\n+   the scopes given by HOW.\n \n    Unlike lookup_name_1, we make sure that NAME is actually\n    declared in the desired scope, not from inheritance, nor using\n    directive.  For using declaration, there is DR138 still waiting\n    to be resolved.  Hidden name coming from an earlier friend\n-   declaration is also returned.\n+   declaration is also returned, and will be made visible unless HOW\n+   is TAG_how::HIDDEN_FRIEND.\n \n    A TYPE_DECL best matching the NAME is returned.  Catching error\n    and issuing diagnostics are caller's responsibility.  */\n \n static tree\n-lookup_type_scope_1 (tree name, tag_scope scope)\n+lookup_elaborated_type_1 (tree name, TAG_how how)\n {\n   cp_binding_level *b = current_binding_level;\n \n@@ -6613,28 +6611,28 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n \t  if (!(b->kind == sk_cleanup\n \t\t|| b->kind == sk_template_parms\n \t\t|| b->kind == sk_function_parms\n-\t\t|| (b->kind == sk_class\n-\t\t    && scope == ts_within_enclosing_non_class)))\n+\t\t|| (b->kind == sk_class && how != TAG_how::CURRENT_ONLY)))\n \t    return NULL_TREE;\n \n \t/* Check if this is the kind of thing we're looking for.  If\n-\t   SCOPE is TS_CURRENT, also make sure it doesn't come from\n-\t   base class.  For ITER->VALUE, we can simply use\n-\t   INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to\n-\t   use our own check.\n+\t   HOW is TAG_how::CURRENT_ONLY, also make sure it doesn't\n+\t   come from base class.  For ITER->VALUE, we can simply use\n+\t   INHERITED_VALUE_BINDING_P.  For ITER->TYPE, we have to use\n+\t   our own check.\n \n \t   We check ITER->TYPE before ITER->VALUE in order to handle\n \t     typedef struct C {} C;\n \t   correctly.  */\n+\n \tif (tree type = iter->type)\n \t  if (qualify_lookup (type, LOOK_want::TYPE)\n-\t      && (scope != ts_current\n+\t      && (how != TAG_how::CURRENT_ONLY\n \t\t  || LOCAL_BINDING_P (iter)\n \t\t  || DECL_CONTEXT (type) == iter->scope->this_entity))\n \t    return type;\n \n \tif (qualify_lookup (iter->value, LOOK_want::TYPE)\n-\t    && (scope != ts_current\n+\t    && (how != TAG_how::CURRENT_ONLY\n \t\t|| !INHERITED_VALUE_BINDING_P (iter)))\n \t  return iter->value;\n       }\n@@ -6644,8 +6642,7 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n     if (!(b->kind == sk_cleanup\n \t  || b->kind == sk_template_parms\n \t  || b->kind == sk_function_parms\n-\t  || (b->kind == sk_class\n-\t      && scope == ts_within_enclosing_non_class)))\n+\t  || (b->kind == sk_class && how != TAG_how::CURRENT_ONLY)))\n       return NULL_TREE;\n \n   /* Look in the innermost namespace.  */\n@@ -6664,15 +6661,14 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n \n   return NULL_TREE;\n }\n- \n+\n /* Wrapper for lookup_type_scope_1.  */\n \n tree\n-lookup_type_scope (tree name, tag_scope scope)\n+lookup_elaborated_type (tree name, TAG_how how)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_type_scope_1 (name, scope);\n+  tree ret = lookup_elaborated_type_1 (name, how);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n@@ -6782,7 +6778,7 @@ maybe_process_template_type_declaration (tree type, int is_friend,\n    Returns TYPE upon success and ERROR_MARK_NODE otherwise.  */\n \n static tree\n-do_pushtag (tree name, tree type, tag_scope scope)\n+do_pushtag (tree name, tree type, TAG_how how)\n {\n   tree decl;\n \n@@ -6799,10 +6795,9 @@ do_pushtag (tree name, tree type, tag_scope scope)\n \t     declaration, these scopes are not scopes from the point of\n \t     view of the language.  */\n \t  || (b->kind == sk_template_parms\n-\t      && (b->explicit_spec_p || scope == ts_global)))\n+\t      && (b->explicit_spec_p || how == TAG_how::GLOBAL)))\n \tb = b->level_chain;\n-      else if (b->kind == sk_class\n-\t       && scope != ts_current)\n+      else if (b->kind == sk_class && how != TAG_how::CURRENT_ONLY)\n \t{\n \t  b = b->level_chain;\n \t  if (b->kind == sk_template_parms)\n@@ -6836,7 +6831,7 @@ do_pushtag (tree name, tree type, tag_scope scope)\n \t\t\t       : TYPE_P (cs) ? cs == current_class_type\n \t\t\t       : cs == current_namespace);\n \n-\t  if (scope == ts_current\n+\t  if (how == TAG_how::CURRENT_ONLY\n \t      || (cs && TREE_CODE (cs) == FUNCTION_DECL))\n \t    context = cs;\n \t  else if (cs && TYPE_P (cs))\n@@ -6856,18 +6851,19 @@ do_pushtag (tree name, tree type, tag_scope scope)\n \n       tdef = create_implicit_typedef (name, type);\n       DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n-      if (scope == ts_within_enclosing_non_class)\n+      bool is_friend = how == TAG_how::HIDDEN_FRIEND;\n+      if (is_friend)\n \t{\n+\t  // FIXME: can go away\n \t  /* This is a friend.  Make this TYPE_DECL node hidden from\n \t     ordinary name lookup.  Its corresponding TEMPLATE_DECL\n-\t     will be marked in push_template_decl_real.  */\n+\t     will be marked in push_template_decl.  */\n \t  retrofit_lang_decl (tdef);\n \t  DECL_ANTICIPATED (tdef) = 1;\n \t  DECL_FRIEND_P (tdef) = 1;\n \t}\n \n-      decl = maybe_process_template_type_declaration\n-\t(type, scope == ts_within_enclosing_non_class, b);\n+      decl = maybe_process_template_type_declaration (type, is_friend, b);\n       if (decl == error_mark_node)\n \treturn decl;\n \n@@ -6888,7 +6884,8 @@ do_pushtag (tree name, tree type, tag_scope scope)\n \t}\n       else if (b->kind != sk_template_parms)\n \t{\n-\t  decl = do_pushdecl_with_scope (decl, b, /*is_friend=*/false);\n+\t  decl = do_pushdecl_with_scope\n+\t    (decl, b, /*hiding=*/(how == TAG_how::HIDDEN_FRIEND));\n \t  if (decl == error_mark_node)\n \t    return decl;\n \n@@ -6954,11 +6951,10 @@ do_pushtag (tree name, tree type, tag_scope scope)\n /* Wrapper for do_pushtag.  */\n \n tree\n-pushtag (tree name, tree type, tag_scope scope)\n+pushtag (tree name, tree type, TAG_how how)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = do_pushtag (name, type, scope);\n+  tree ret = do_pushtag (name, type, how);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }"}, {"sha": "82f4d5155b702c62caee8ee4e81ee9e942b3324d", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -124,22 +124,6 @@ enum scope_kind {\n   sk_omp\t     /* An OpenMP structured block.  */\n };\n \n-/* The scope where the class/struct/union/enum tag applies.  */\n-enum tag_scope {\n-  ts_current = 0,\t/* Current scope only.  This is for the\n-\t\t\t     class-key identifier;\n-\t\t\t   case mentioned in [basic.lookup.elab]/2,\n-\t\t\t   or the class/enum definition\n-\t\t\t     class-key identifier { ... };  */\n-  ts_global = 1,\t/* All scopes.  This is the 3.4.1\n-\t\t\t   [basic.lookup.unqual] lookup mentioned\n-\t\t\t   in [basic.lookup.elab]/2.  */\n-  ts_within_enclosing_non_class = 2,\t/* Search within enclosing non-class\n-\t\t\t\t\t   only, for friend class lookup\n-\t\t\t\t\t   according to [namespace.memdef]/3\n-\t\t\t\t\t   and [class.friend]/9.  */\n-};\n-\n struct GTY(()) cp_class_binding {\n   cxx_binding *base;\n   /* The bound name.  */\n@@ -326,7 +310,19 @@ inline tree lookup_name (tree name, LOOK_want want)\n   return lookup_name (name, LOOK_where::ALL, want);\n }\n \n-extern tree lookup_type_scope (tree, tag_scope);\n+enum class TAG_how\n+{\n+  CURRENT_ONLY = 0, // Look and insert only in current scope\n+\n+  GLOBAL = 1, // Unqualified lookup, innermost-non-class insertion\n+\n+  INNERMOST_NON_CLASS = 2, // Look and insert only into\n+\t\t\t   // innermost-non-class\n+\n+  HIDDEN_FRIEND = 3, // As INNERMOST_NON_CLASS, but hide it\n+};\n+\n+extern tree lookup_elaborated_type (tree, TAG_how);\n extern tree get_namespace_binding (tree ns, tree id);\n extern void set_global_binding (tree decl);\n inline tree get_global_binding (tree id)\n@@ -371,7 +367,7 @@ extern tree pushdecl (tree, bool is_friend = false);\n extern tree pushdecl_outermost_localscope (tree);\n extern tree pushdecl_top_level (tree, bool is_friend = false);\n extern tree pushdecl_top_level_and_finish (tree, tree);\n-extern tree pushtag (tree, tree, tag_scope = ts_current);\n+extern tree pushtag (tree, tree, TAG_how = TAG_how::CURRENT_ONLY);\n extern int push_namespace (tree, bool make_inline = false);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);"}, {"sha": "8905833fbd6f2ff0d1e6cf93688557c2a7072970", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -19057,21 +19057,20 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t     definition of a new type; a new type can only be declared in a\n \t     declaration context.  */\n \n-\t  tag_scope ts;\n-\t  bool template_p;\n+\t  TAG_how how;\n \n \t  if (is_friend)\n \t    /* Friends have special name lookup rules.  */\n-\t    ts = ts_within_enclosing_non_class;\n+\t    how = TAG_how::HIDDEN_FRIEND;\n \t  else if (is_declaration\n \t\t   && cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t      CPP_SEMICOLON))\n \t    /* This is a `class-key identifier ;' */\n-\t    ts = ts_current;\n+\t    how = TAG_how::CURRENT_ONLY;\n \t  else\n-\t    ts = ts_global;\n+\t    how = TAG_how::GLOBAL;\n \n-\t  template_p =\n+\t  bool template_p =\n \t    (template_parm_lists_apply\n \t     && (cp_parser_next_token_starts_class_definition_p (parser)\n \t\t || cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)));\n@@ -19084,7 +19083,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t\t       token->location,\n \t\t\t\t\t\t       /*declarator=*/NULL))\n \t    return error_mark_node;\n-\t  type = xref_tag (tag_type, identifier, ts, template_p);\n+\n+\t  type = xref_tag (tag_type, identifier, how, template_p);\n \t}\n     }\n \n@@ -24708,10 +24708,10 @@ cp_parser_class_head (cp_parser* parser,\n       /* If the class was unnamed, create a dummy name.  */\n       if (!id)\n \tid = make_anon_name ();\n-      tag_scope tag_scope = (parser->in_type_id_in_expr_p\n-\t\t\t     ? ts_within_enclosing_non_class\n-\t\t\t     : ts_current);\n-      type = xref_tag (class_key, id, tag_scope,\n+      TAG_how how = (parser->in_type_id_in_expr_p\n+\t\t     ? TAG_how::INNERMOST_NON_CLASS\n+\t\t     : TAG_how::CURRENT_ONLY);\n+      type = xref_tag (class_key, id, how,\n \t\t       parser->num_template_parameter_lists);\n     }\n "}, {"sha": "c6c4ee5ed363030ae911fb5aab4f497536f18558", "filename": "gcc/objcp/objcp-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fobjcp%2Fobjcp-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aaae03db249e61dde41facbf373c3fcde38154/gcc%2Fobjcp%2Fobjcp-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.c?ref=00aaae03db249e61dde41facbf373c3fcde38154", "patch": "@@ -41,7 +41,7 @@ objcp_start_struct (location_t loc ATTRIBUTE_UNUSED,\n   if (!name)\n     name = make_anon_name ();\n \n-  s = xref_tag (record_type, name, ts_global);\n+  s = xref_tag (record_type, name, TAG_how::GLOBAL);\n   CLASSTYPE_DECLARED_CLASS (s) = 0;  /* this is a 'struct', not a 'class'.  */\n   xref_basetypes (s, NULL_TREE);     /* no base classes here!  */\n \n@@ -84,7 +84,7 @@ objcp_finish_function (void)\n tree\n objcp_xref_tag (enum tree_code code ATTRIBUTE_UNUSED, tree name)\n {\n-  return xref_tag (record_type, name, ts_global);\n+  return xref_tag (record_type, name, TAG_how::GLOBAL);\n }\n \n int"}]}