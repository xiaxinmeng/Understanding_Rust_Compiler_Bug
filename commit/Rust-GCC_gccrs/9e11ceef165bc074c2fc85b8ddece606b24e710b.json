{"sha": "9e11ceef165bc074c2fc85b8ddece606b24e710b", "node_id": "C_kwDOANBUbNoAKDllMTFjZWVmMTY1YmMwNzRjMmZjODViOGRkZWNlNjA2YjI0ZTcxMGI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-27T08:16:52Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-10T10:53:13Z"}, "message": "unswitching of outer loops\n\nThis allows loop unswitching to unswitch outer loops conditions are\ninvariant in.  We restrict ourselves to unswitch conditions in innermost\nloops and will only unswitch loop nests that do not contain any sibling loops.\nTo simplify the implementation the loop nest unswitched is the deepest all\nunswitching candidates are invariant in.\n\nFor 507.cactuBSSN_r it can be observed we unswitch the outer loops\nof the compute kernels for the fdOrder parameter.  It seems to be within\nthe existing growth limitations to perform the unswitchings, a performance\nbenefit is not seen.\n\n\t* tree-ssa-loop-unswitch.cc (init_loop_unswitch_info): First collect\n\tcandidates and determine the outermost loop to unswitch.\n\t(tree_ssa_unswitch_loops): First perform all guard hoisting,\n\tthen perform unswitching on innermost loop predicates.\n\t(find_unswitching_predicates_for_bb): Keep track of the\n\toutermost loop to unswitch.\n\t(evaluate_bbs): Adjust exit test.\n\t(tree_unswitch_single_loop): Dump whether we unswitched an outer\n\tloop.\n\t(tree_unswitch_loop): Remove assert we unswitch only innermost\n\tloops.\n\n\t* gcc.dg/loop-unswitch-18.c: New testcase.\n\t* gcc.dg/tree-ssa/loopclosedphi.c: Disable unswitching,\n\tadjust expected counts.\n\t* gcc.dg/torture/pr71462.c: Add -w to ignore undefined\n\tbehavior diagnostics after now unswitching outer loops.", "tree": {"sha": "165a86411910d5ec0d49a13f7b0ea6a0a977f73b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/165a86411910d5ec0d49a13f7b0ea6a0a977f73b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e11ceef165bc074c2fc85b8ddece606b24e710b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e11ceef165bc074c2fc85b8ddece606b24e710b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e11ceef165bc074c2fc85b8ddece606b24e710b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e11ceef165bc074c2fc85b8ddece606b24e710b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49de156a6adb50e0624479f22c20141cadef812d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49de156a6adb50e0624479f22c20141cadef812d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49de156a6adb50e0624479f22c20141cadef812d"}], "stats": {"total": 221, "additions": 140, "deletions": 81}, "files": [{"sha": "91dc2014922c65640c4ed0825890a2afe6367249", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-18.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-18.c?ref=9e11ceef165bc074c2fc85b8ddece606b24e710b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-unswitch-optimized\" } */\n+\n+void bar();\n+void foo (int x, int n, int m)\n+{\n+  for (int i = 0; i < n; ++i)\n+    for (int j = 0; j < m; ++j)\n+      if (x)\n+        bar ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"unswitching outer loop\" \"unswitch\" } } */"}, {"sha": "996596321ca63f794916c514fd8e94163d6ce9af", "filename": "gcc/testsuite/gcc.dg/torture/pr71462.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71462.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71462.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr71462.c?ref=9e11ceef165bc074c2fc85b8ddece606b24e710b", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do compile } */\n+/* { dg-additional-options \"-w\" } */\n \n short a;\n long b;"}, {"sha": "0a8a4174f5fe0e5f5075f3cd78cf5e85e1105e6a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loopclosedphi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floopclosedphi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floopclosedphi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floopclosedphi.c?ref=9e11ceef165bc074c2fc85b8ddece606b24e710b", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fno-tree-ch -w -fdump-tree-loopdone-details\" } */\n+/* { dg-options \"-O3 -fno-tree-ch -fno-unswitch-loops -w -fdump-tree-loopdone-details\" } */\n \n void\n t6 (int qz, int wh)\n@@ -18,4 +18,4 @@ t6 (int qz, int wh)\n     qz = jl * wh;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Replacing\" 2 \"loopdone\"} } */\n+/* { dg-final { scan-tree-dump-times \"Replacing\" 3 \"loopdone\"} } */"}, {"sha": "186ae953f04ec69a5b2e36c6e6057c75def7153b", "filename": "gcc/tree-ssa-loop-unswitch.cc", "status": "modified", "additions": 124, "deletions": 79, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftree-ssa-loop-unswitch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e11ceef165bc074c2fc85b8ddece606b24e710b/gcc%2Ftree-ssa-loop-unswitch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.cc?ref=9e11ceef165bc074c2fc85b8ddece606b24e710b", "patch": "@@ -217,6 +217,7 @@ static bool tree_unswitch_single_loop (class loop *, dump_user_location_t,\n \t\t\t\t       basic_block = NULL);\n static void\n find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n+\t\t\t\t    class loop *&outer_loop,\n \t\t\t\t    vec<unswitch_predicate *> &candidates,\n \t\t\t\t    unswitch_predicate *&hottest,\n \t\t\t\t    basic_block &hottest_bb);\n@@ -249,36 +250,31 @@ set_predicates_for_bb (basic_block bb, vec<unswitch_predicate *> predicates)\n }\n \n /* Initialize LOOP information reused during the unswitching pass.\n-   Return total number of instructions in the loop.  */\n+   Return total number of instructions in the loop.  Adjusts LOOP to\n+   the outermost loop all candidates are invariant in.  */\n \n static unsigned\n-init_loop_unswitch_info (class loop *loop, unswitch_predicate *&hottest,\n+init_loop_unswitch_info (class loop *&loop, unswitch_predicate *&hottest,\n \t\t\t basic_block &hottest_bb)\n {\n   unsigned total_insns = 0;\n \n-  /* Calculate instruction count.  */\n   basic_block *bbs = get_loop_body (loop);\n-  for (unsigned i = 0; i < loop->num_nodes; i++)\n-    {\n-      unsigned insns = 0;\n-      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);\n-\t   gsi_next (&gsi))\n-\tinsns += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);\n-\n-      bbs[i]->aux = (void *)(uintptr_t)insns;\n-      total_insns += insns;\n-    }\n \n+  /* Unswitch only nests with no sibling loops.  */\n+  class loop *outer_loop = loop;\n+  while (loop_outer (outer_loop)->num != 0\n+\t && !loop_outer (outer_loop)->inner->next)\n+    outer_loop = loop_outer (outer_loop);\n   hottest = NULL;\n   hottest_bb = NULL;\n-  /* Find all unswitching candidates.  */\n+  /* Find all unswitching candidates in the innermost loop.  */\n   for (unsigned i = 0; i != loop->num_nodes; i++)\n     {\n       /* Find a bb to unswitch on.  */\n       vec<unswitch_predicate *> candidates;\n       candidates.create (1);\n-      find_unswitching_predicates_for_bb (bbs[i], loop, candidates,\n+      find_unswitching_predicates_for_bb (bbs[i], loop, outer_loop, candidates,\n \t\t\t\t\t  hottest, hottest_bb);\n       if (!candidates.is_empty ())\n \tset_predicates_for_bb (bbs[i], candidates);\n@@ -291,8 +287,34 @@ init_loop_unswitch_info (class loop *loop, unswitch_predicate *&hottest,\n \t}\n     }\n \n+  if (outer_loop != loop)\n+    {\n+      free (bbs);\n+      bbs = get_loop_body (outer_loop);\n+    }\n+\n+  /* Calculate instruction count.  */\n+  for (unsigned i = 0; i < outer_loop->num_nodes; i++)\n+    {\n+      unsigned insns = 0;\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\tinsns += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);\n+      /* No predicates to unswitch on in the outer loops.  */\n+      if (!flow_bb_inside_loop_p (loop, bbs[i]))\n+\t{\n+\t  gimple *last = last_stmt (bbs[i]);\n+\t  if (last != NULL)\n+\t    gimple_set_uid (last, 0);\n+\t}\n+\n+      bbs[i]->aux = (void *)(uintptr_t)insns;\n+      total_insns += insns;\n+    }\n+\n   free (bbs);\n \n+  loop = outer_loop;\n   return total_insns;\n }\n \n@@ -307,72 +329,74 @@ tree_ssa_unswitch_loops (function *fun)\n \n   ranger = enable_ranger (fun);\n \n-  /* Go through all loops starting from innermost.  */\n+  /* Go through all loops starting from innermost, hoisting guards.  */\n   for (auto loop : loops_list (fun, LI_FROM_INNERMOST))\n     {\n-      if (!loop->inner)\n-\t{\n-\t  /* Perform initial tests if unswitch is eligible.  */\n-\t  dump_user_location_t loc = find_loop_location (loop);\n+      if (loop->inner)\n+\tchanged_hoist |= tree_unswitch_outer_loop (loop);\n+    }\n \n-\t  /* Do not unswitch in cold regions. */\n-\t  if (optimize_loop_for_size_p (loop))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, loc,\n-\t\t\t\t \"Not unswitching cold loops\\n\");\n-\t      continue;\n-\t    }\n+  /* Go through innermost loops, unswitching on invariant predicates\n+     within those.  */\n+  for (auto loop : loops_list (fun, LI_ONLY_INNERMOST))\n+    {\n+      /* Perform initial tests if unswitch is eligible.  */\n+      dump_user_location_t loc = find_loop_location (loop);\n \n-\t  /* If the loop is not expected to iterate, there is no need\n-\t     for unswitching.  */\n-\t  HOST_WIDE_INT iterations = estimated_loop_iterations_int (loop);\n-\t  if (iterations < 0)\n-\t    iterations = likely_max_loop_iterations_int (loop);\n-\t  if (iterations >= 0 && iterations <= 1)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, loc,\n-\t\t\t\t \"Not unswitching, loop is not expected\"\n-\t\t\t\t \" to iterate\\n\");\n-\t      continue;\n-\t    }\n+      /* Do not unswitch in cold regions. */\n+      if (optimize_loop_for_size_p (loop))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t     \"Not unswitching cold loops\\n\");\n+\t  continue;\n+\t}\n \n-\t  bb_predicates = new vec<vec<unswitch_predicate *>> ();\n-\t  bb_predicates->safe_push (vec<unswitch_predicate *> ());\n-\t  unswitch_predicate::predicates = new vec<unswitch_predicate *> ();\n-\n-\t  /* Unswitch innermost loop.  */\n-\t  unswitch_predicate *hottest;\n-\t  basic_block hottest_bb;\n-\t  unsigned int loop_size = init_loop_unswitch_info (loop, hottest,\n-\t\t\t\t\t\t\t    hottest_bb);\n-\t  unsigned int budget = loop_size + param_max_unswitch_insns;\n-\n-\t  predicate_vector predicate_path;\n-\t  predicate_path.create (8);\n-\t  auto_bitmap handled;\n-\t  changed_unswitch\n-\t    |= tree_unswitch_single_loop (loop, loc, predicate_path,\n-\t\t\t\t\t  loop_size, budget,\n-\t\t\t\t\t  ignored_edge_flag, handled,\n-\t\t\t\t\t  hottest, hottest_bb);\n-\t  predicate_path.release ();\n-\n-\t  for (auto predlist : bb_predicates)\n-\t    predlist.release ();\n-\t  bb_predicates->release ();\n-\t  delete bb_predicates;\n-\t  bb_predicates = NULL;\n-\n-\t  for (auto pred : unswitch_predicate::predicates)\n-\t    delete pred;\n-\t  unswitch_predicate::predicates->release ();\n-\t  delete unswitch_predicate::predicates;\n-\t  unswitch_predicate::predicates = NULL;\n+      /* If the loop is not expected to iterate, there is no need\n+\t for unswitching.  */\n+      HOST_WIDE_INT iterations = estimated_loop_iterations_int (loop);\n+      if (iterations < 0)\n+\titerations = likely_max_loop_iterations_int (loop);\n+      if (iterations >= 0 && iterations <= 1)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t     \"Not unswitching, loop is not expected\"\n+\t\t\t     \" to iterate\\n\");\n+\t  continue;\n \t}\n-      else\n-\tchanged_hoist |= tree_unswitch_outer_loop (loop);\n+\n+      bb_predicates = new vec<vec<unswitch_predicate *>> ();\n+      bb_predicates->safe_push (vec<unswitch_predicate *> ());\n+      unswitch_predicate::predicates = new vec<unswitch_predicate *> ();\n+\n+      /* Unswitch loop.  */\n+      unswitch_predicate *hottest;\n+      basic_block hottest_bb;\n+      unsigned int loop_size = init_loop_unswitch_info (loop, hottest,\n+\t\t\t\t\t\t\thottest_bb);\n+      unsigned int budget = loop_size + param_max_unswitch_insns;\n+\n+      predicate_vector predicate_path;\n+      predicate_path.create (8);\n+      auto_bitmap handled;\n+      changed_unswitch |= tree_unswitch_single_loop (loop, loc, predicate_path,\n+\t\t\t\t\t\t     loop_size, budget,\n+\t\t\t\t\t\t     ignored_edge_flag, handled,\n+\t\t\t\t\t\t     hottest, hottest_bb);\n+      predicate_path.release ();\n+\n+      for (auto predlist : bb_predicates)\n+\tpredlist.release ();\n+      bb_predicates->release ();\n+      delete bb_predicates;\n+      bb_predicates = NULL;\n+\n+      for (auto pred : unswitch_predicate::predicates)\n+\tdelete pred;\n+      unswitch_predicate::predicates->release ();\n+      delete unswitch_predicate::predicates;\n+      unswitch_predicate::predicates = NULL;\n     }\n \n   disable_ranger (fun);\n@@ -463,10 +487,13 @@ is_maybe_undefined (const tree name, gimple *stmt, class loop *loop)\n \n /* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n    basic blocks (for what it means see comments below).\n-   All candidates all filled to the provided vector CANDIDATES.  */\n+   All candidates all filled to the provided vector CANDIDATES.\n+   OUTER_LOOP is updated to the innermost loop all found candidates are\n+   invariant in.  */\n \n static void\n find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n+\t\t\t\t    class loop *&outer_loop,\n \t\t\t\t    vec<unswitch_predicate *> &candidates,\n \t\t\t\t    unswitch_predicate *&hottest,\n \t\t\t\t    basic_block &hottest_bb)\n@@ -506,6 +533,18 @@ find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n \t  if (is_maybe_undefined (use, stmt, loop))\n \t    return;\n \t}\n+      /* Narrow OUTER_LOOP.  */\n+      if (outer_loop != loop)\n+\tFOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\t  {\n+\t    def = SSA_NAME_DEF_STMT (use);\n+\t    def_bb = gimple_bb (def);\n+\t    while (outer_loop != loop\n+\t\t   && ((def_bb && flow_bb_inside_loop_p (outer_loop, def_bb))\n+\t\t       || is_maybe_undefined (use, stmt, outer_loop)))\n+\t      outer_loop = superloop_at_depth (loop,\n+\t\t\t\t\t       loop_depth (outer_loop) + 1);\n+\t  }\n \n       unswitch_predicate *predicate = new unswitch_predicate (stmt);\n       candidates.safe_push (predicate);\n@@ -535,6 +574,12 @@ find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n \t behavior that the original program might never exercise.  */\n       if (is_maybe_undefined (idx, stmt, loop))\n \treturn;\n+      /* Narrow OUTER_LOOP.  */\n+      while (outer_loop != loop\n+\t     && ((def_bb && flow_bb_inside_loop_p (outer_loop, def_bb))\n+\t\t || is_maybe_undefined (idx, stmt, outer_loop)))\n+\touter_loop = superloop_at_depth (loop,\n+\t\t\t\t\t loop_depth (outer_loop) + 1);\n \n       /* Build compound expression for all outgoing edges of the switch.  */\n       auto_vec<tree, 16> preds;\n@@ -872,7 +917,7 @@ evaluate_bbs (class loop *loop, predicate_vector *predicate_path,\n \t{\n \t  basic_block dest = e->dest;\n \n-\t  if (dest->loop_father == loop\n+\t  if (flow_bb_inside_loop_p (loop, dest)\n \t      && !(dest->flags & reachable_flag)\n \t      && !(e->flags & flags)\n \t      && !ignored_edges.contains (e))\n@@ -992,7 +1037,8 @@ tree_unswitch_single_loop (class loop *loop, dump_user_location_t loc,\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t\t   \"unswitching loop %d on %qs with condition: %T\\n\",\n+\t\t\t   \"unswitching %sloop %d on %qs with condition: %T\\n\",\n+\t\t\t   loop->inner ? \"outer \" : \"\",\n \t\t\t   loop->num, predicate->switch_p ? \"switch\" : \"if\",\n \t\t\t   predicate->condition);\n \t  dump_printf_loc (MSG_NOTE, loc,\n@@ -1064,7 +1110,6 @@ tree_unswitch_loop (class loop *loop, edge edge_true, tree cond)\n   /* Some sanity checking.  */\n   gcc_assert (flow_bb_inside_loop_p (loop, edge_true->src));\n   gcc_assert (EDGE_COUNT (edge_true->src->succs) >= 2);\n-  gcc_assert (loop->inner == NULL);\n \n   profile_probability prob_true = edge_true->probability;\n   return loop_version (loop, unshare_expr (cond),"}]}