{"sha": "aa0cd7a228206eeee74db0f0744621ed1504065a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEwY2Q3YTIyODIwNmVlZWU3NGRiMGYwNzQ0NjIxZWQxNTA0MDY1YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T07:18:06Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-02T07:18:06Z"}, "message": "(gen_move_insn): Big `if' applies only for MODE_CC class.\n\nFrom-SVN: r3592", "tree": {"sha": "2ad2a998ff5aa1de7afc62d001e4e8d055f988d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ad2a998ff5aa1de7afc62d001e4e8d055f988d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa0cd7a228206eeee74db0f0744621ed1504065a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0cd7a228206eeee74db0f0744621ed1504065a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa0cd7a228206eeee74db0f0744621ed1504065a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa0cd7a228206eeee74db0f0744621ed1504065a/comments", "author": null, "committer": null, "parents": [{"sha": "dae1d3040823d0ffb8f0d9bb8678abfe5051354d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae1d3040823d0ffb8f0d9bb8678abfe5051354d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae1d3040823d0ffb8f0d9bb8678abfe5051354d"}], "stats": {"total": 6, "additions": 3, "deletions": 3}, "files": [{"sha": "cc192be2e3910e75a71a44f7ed37daf59d176767", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa0cd7a228206eeee74db0f0744621ed1504065a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa0cd7a228206eeee74db0f0744621ed1504065a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=aa0cd7a228206eeee74db0f0744621ed1504065a", "patch": "@@ -2577,15 +2577,15 @@ gen_move_insn (x, y)\n      find a mode to do it in.  If we have a movcc, use it.  Otherwise,\n      find the MODE_INT mode of the same width.  */\n \n-  if (insn_code == CODE_FOR_nothing)\n+  if (GET_MODE_CLASS (mode) == MODE_CC && insn_code == CODE_FOR_nothing)\n     {\n       enum machine_mode tmode = VOIDmode;\n       rtx x1 = x, y1 = y;\n \n-      if (GET_MODE_CLASS (mode) == MODE_CC && mode != CCmode\n+      if (mode != CCmode\n \t  && mov_optab->handlers[(int) CCmode].insn_code != CODE_FOR_nothing)\n \ttmode = CCmode;\n-      else if (GET_MODE_CLASS (mode) == MODE_CC)\n+      else\n \tfor (tmode = QImode; tmode != VOIDmode;\n \t     tmode = GET_MODE_WIDER_MODE (tmode))\n \t  if (GET_MODE_SIZE (tmode) == GET_MODE_SIZE (mode))"}]}