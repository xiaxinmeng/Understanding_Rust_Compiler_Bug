{"sha": "ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0MGI4NmM3NzUxZjY3YjFkM2ZmYzViM2VkYjJkZjg3MjIxNWZkOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-04-25T10:40:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:40:23Z"}, "message": "sem_prag.adb, [...]: Minor reformatting.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb, exp_ch6.adb, binde.adb, sem_disp.adb, s-fileio.adb:\n\tMinor reformatting.\n\nFrom-SVN: r247179", "tree": {"sha": "b948809c3993351133c1017bd78e188b792f9f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b948809c3993351133c1017bd78e188b792f9f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca1f6b2991e1864c8db5c9f082c62804467b2a07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1f6b2991e1864c8db5c9f082c62804467b2a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1f6b2991e1864c8db5c9f082c62804467b2a07"}], "stats": {"total": 148, "additions": 79, "deletions": 69}, "files": [{"sha": "634629536f32d060fb4ed013c0d176aa35e72380", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -1,3 +1,8 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb, exp_ch6.adb, binde.adb, sem_disp.adb, s-fileio.adb:\n+\tMinor reformatting.\n+\n 2017-04-25  Bob Duff  <duff@adacore.com>\n \n \t* sem_prag.adb (No_Return): Give an error if the pragma applies"}, {"sha": "869cc4347d638eff03f71df18178b94c8fe7e735", "filename": "gcc/ada/binde.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fbinde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fbinde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbinde.adb?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -2235,7 +2235,7 @@ package body Binde is\n          begin\n             while S /= No_Successor loop\n                if UNR.Table (Succ.Table (S).After).Elab_Position <=\n-                 UNR.Table (U).Elab_Position\n+                    UNR.Table (U).Elab_Position\n                then\n                   OK := False;\n                   Write_Line (Msg & \" elab order failed\");"}, {"sha": "e0499ec9f9f0af005f05a8c3e90663b44cf034d5", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -159,14 +159,16 @@ package body Exp_Ch6 is\n    --  we have an infinite recursion.\n \n    procedure Expand_Actuals\n-     (N : Node_Id; Subp : Entity_Id; Post_Call : out List_Id);\n-   --  Return in Post_Call a list of actions to take place after the call.\n-   --  The call will later be rewritten as an Expression_With_Actions,\n-   --  with the Post_Call actions inserted, and the call inside.\n+     (N         : Node_Id;\n+      Subp      : Entity_Id;\n+      Post_Call : out List_Id);\n+   --  Return a list of actions to take place after the call in Post_Call. The\n+   --  call will later be rewritten as an Expression_With_Actions, with the\n+   --  Post_Call actions inserted, and the call inside.\n    --\n-   --  For each actual of an in-out or out parameter which is a numeric\n-   --  (view) conversion of the form T (A), where A denotes a variable,\n-   --  we insert the declaration:\n+   --  For each actual of an in-out or out parameter which is a numeric (view)\n+   --  conversion of the form T (A), where A denotes a variable, we insert the\n+   --  declaration:\n    --\n    --    Temp : T[ := T (A)];\n    --\n@@ -197,12 +199,7 @@ package body Exp_Ch6 is\n    --  based on the predicates of the actual type.\n \n    procedure Expand_Call_Helper (N : Node_Id; Post_Call : out List_Id);\n-   --  Does the main work of Expand_Call. Post_Call is as for Expand_Actuals\n-\n-   procedure Insert_Post_Call_Actions\n-     (N : Node_Id; Post_Call : List_Id);\n-   --  Insert the Post_Call list (previously produced by\n-   --  Expand_Actuals/Expand_Call_Helper) into the tree.\n+   --  Does the main work of Expand_Call. Post_Call is as for Expand_Actuals.\n \n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  N is a function call which returns a controlled object. Transform the\n@@ -236,6 +233,10 @@ package body Exp_Ch6 is\n    --  Returns True if the given subtype is unconstrained and has one or more\n    --  access discriminants.\n \n+   procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id);\n+   --  Insert the Post_Call list previously produced by routine Expand_Actuals\n+   --  or Expand_Call_Helper into the tree.\n+\n    procedure Rewrite_Function_Call_For_C (N : Node_Id);\n    --  When generating C code, replace a call to a function that returns an\n    --  array into the generated procedure with an additional out parameter.\n@@ -1155,7 +1156,9 @@ package body Exp_Ch6 is\n    --------------------\n \n    procedure Expand_Actuals\n-     (N : Node_Id; Subp : Entity_Id; Post_Call : out List_Id)\n+     (N         : Node_Id;\n+      Subp      : Entity_Id;\n+      Post_Call : out List_Id)\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Actual    : Node_Id;\n@@ -7220,27 +7223,24 @@ package body Exp_Ch6 is\n    -- Insert_Post_Call_Actions --\n    ------------------------------\n \n-   procedure Insert_Post_Call_Actions\n-     (N : Node_Id; Post_Call : List_Id)\n-   is\n+   procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id) is\n    begin\n       if Is_Empty_List (Post_Call) then\n          return;\n       end if;\n \n-      --  Cases where the call is not a member of a statement list.\n-      --  This includes the case where the call is an actual in another\n-      --  function call or indexing, i.e. an expression context as well.\n+      --  Cases where the call is not a member of a statement list. This\n+      --  includes the case where the call is an actual in another function\n+      --  call or indexing, i.e. an expression context as well.\n \n       if not Is_List_Member (N)\n         or else Nkind_In (Parent (N), N_Function_Call, N_Indexed_Component)\n       then\n          --  In Ada 2012 the call may be a function call in an expression\n-         --  (since OUT and IN OUT parameters are now allowed for such\n-         --  calls). The write-back of (in)-out parameters is handled\n-         --  by the back-end, but the constraint checks generated when\n-         --  subtypes of formal and actual don't match must be inserted\n-         --  in the form of assignments.\n+         --  (since OUT and IN OUT parameters are now allowed for such calls).\n+         --  The write-back of (in)-out parameters is handled by the back-end,\n+         --  but the constraint checks generated when subtypes of formal and\n+         --  actual don't match must be inserted in the form of assignments.\n \n          if Nkind (Original_Node (N)) = N_Function_Call then\n             pragma Assert (Ada_Version >= Ada_2012);\n@@ -7252,18 +7252,18 @@ package body Exp_Ch6 is\n             --  Insert_Actions_After (P, Post_Call), but that doesn't work\n             --  for Ada 2012. If we are in the middle of an expression, e.g.\n             --  the condition of an IF, this call would insert after the IF\n-            --  statement, which is much too late to be doing the write\n-            --  back. For example:\n+            --  statement, which is much too late to be doing the write back.\n+            --  For example:\n \n             --     if Clobber (X) then\n             --        Put_Line (X'Img);\n             --     else\n             --        goto Junk\n             --     end if;\n \n-            --  Now assume Clobber changes X, if we put the write back\n-            --  after the IF, the Put_Line gets the wrong value and the\n-            --  goto causes the write back to be skipped completely.\n+            --  Now assume Clobber changes X, if we put the write back after\n+            --  the IF, the Put_Line gets the wrong value and the goto causes\n+            --  the write back to be skipped completely.\n \n             --  To deal with this, we replace the call by\n \n@@ -7304,19 +7304,19 @@ package body Exp_Ch6 is\n                Set_Analyzed (Name, False);\n             end;\n \n-         --  If not the special Ada 2012 case of a function call, then\n-         --  we must have the triggering statement of a triggering\n-         --  alternative or an entry call alternative, and we can add\n-         --  the post call stuff to the corresponding statement list.\n+         --  If not the special Ada 2012 case of a function call, then we must\n+         --  have the triggering statement of a triggering alternative or an\n+         --  entry call alternative, and we can add the post call stuff to the\n+         --  corresponding statement list.\n \n          else\n             declare\n                P : Node_Id;\n \n             begin\n                P := Parent (N);\n-               pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n-                                           N_Entry_Call_Alternative));\n+               pragma Assert (Nkind_In (P, N_Entry_Call_Alternative,\n+                                           N_Triggering_Alternative));\n \n                if Is_Non_Empty_List (Statements (P)) then\n                   Insert_List_Before_And_Analyze\n@@ -7327,8 +7327,8 @@ package body Exp_Ch6 is\n             end;\n          end if;\n \n-      --  Otherwise, normal case where N is in a statement sequence,\n-      --  just put the post-call stuff after the call statement.\n+      --  Otherwise, normal case where N is in a statement sequence, just put\n+      --  the post-call stuff after the call statement.\n \n       else\n          Insert_Actions_After (N, Post_Call);"}, {"sha": "870350c950398d113e4ec36c15f61e2f77415945", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -296,14 +296,15 @@ package body System.File_IO is\n             Temp : access Temp_File_Record_Ptr := Temp_Files'Access;\n             --  Note the double indirection here\n \n+            Discard  : int;\n             New_Temp : Temp_File_Record_Ptr;\n-            Discard : int;\n+\n          begin\n             while Temp.all.all.File /= File loop\n                Temp := Temp.all.all.Next'Access;\n             end loop;\n \n-            Discard := unlink (Temp.all.all.Name'Address);\n+            Discard  := unlink (Temp.all.all.Name'Address);\n             New_Temp := Temp.all.all.Next;\n             Free (Temp.all);\n             Temp.all := New_Temp;"}, {"sha": "8dd6de88aa24262dd3f6364c14deb233e5c95842", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -967,8 +967,8 @@ package body Sem_Disp is\n                   Error_Msg_Name_2 := Chars (E);\n                   Error_Msg_Sloc := Sloc (E);\n                   Error_Msg_N\n-                    (\"?j?primitive of type % defined after private \" &\n-                     \"extension % #?\", Prim);\n+                    (\"?j?primitive of type % defined after private extension \"\n+                     & \"% #?\", Prim);\n                   Error_Msg_Name_1 := Chars (Prim);\n                   Error_Msg_Name_2 := Chars (E);\n                   Error_Msg_N\n@@ -989,6 +989,8 @@ package body Sem_Disp is\n       Ovr_Subp               : Entity_Id := Empty;\n       Tagged_Type            : Entity_Id;\n \n+   --  Start of processing for Check_Dispatching_Operation\n+\n    begin\n       if not Ekind_In (Subp, E_Function, E_Procedure) then\n          return;\n@@ -1080,8 +1082,8 @@ package body Sem_Disp is\n                then\n                   Error_Msg_N (\"??declaration of& is too late!\", Subp);\n                   Error_Msg_NE -- CODEFIX??\n-                    (\"\\??spec should appear immediately after declaration \"\n-                     & \"of & !\", Subp, Typ);\n+                    (\"\\??spec should appear immediately after declaration of \"\n+                     & \"& !\", Subp, Typ);\n                   exit;\n                end if;\n \n@@ -1109,8 +1111,8 @@ package body Sem_Disp is\n                then\n                   Error_Msg_N (\"??declaration of& is too late!\", Subp);\n                   Error_Msg_NE\n-                    (\"\\??spec should appear immediately after declaration \"\n-                     & \"of & !\", Subp, Typ);\n+                    (\"\\??spec should appear immediately after declaration of \"\n+                     & \"& !\", Subp, Typ);\n                end if;\n             end if;\n          end;"}, {"sha": "b0810d9210e65e5fb069c5943fb4b98db0b948ee", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec40b86c7751f67b1d3ffc5b3edb2df872215fd9/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ec40b86c7751f67b1d3ffc5b3edb2df872215fd9", "patch": "@@ -4219,9 +4219,9 @@ package body Sem_Prag is\n \n          function Inherits_Class_Wide_Pre (E : Entity_Id) return Boolean is\n             Typ  : constant Entity_Id := Find_Dispatching_Type (E);\n-            Prev : Entity_Id          := Overridden_Operation (E);\n             Cont : Node_Id;\n             Prag : Node_Id;\n+            Prev : Entity_Id := Overridden_Operation (E);\n \n          begin\n             --  Check ancestors on the overriding operation to examine the\n@@ -4240,9 +4240,9 @@ package body Sem_Prag is\n                   end loop;\n                end if;\n \n-               --  For a type derived from a generic formal type, the\n-               --  operation inheriting the condition is a renaming, not\n-               --  an overriding of the operation of the formal.\n+               --  For a type derived from a generic formal type, the operation\n+               --  inheriting the condition is a renaming, not an overriding of\n+               --  the operation of the formal.\n \n                if Is_Generic_Type (Find_Dispatching_Type (Prev)) then\n                   Prev := Alias (Prev);\n@@ -7399,20 +7399,21 @@ package body Sem_Prag is\n \n                  or else Ekind (E) = E_Variable\n \n-                 --  A component as well.  The entity does not have its\n-                 --  Ekind set until the enclosing record declaration is\n-                 --  fully analyzed.\n+                 --  A component as well. The entity does not have its Ekind\n+                 --  set until the enclosing record declaration is fully\n+                 --  analyzed.\n \n                  or else Nkind (Parent (E)) = N_Component_Declaration\n \n                  --  An access to subprogram is also allowed\n \n-                 or else (Is_Access_Type (E)\n-                   and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n+                 or else\n+                   (Is_Access_Type (E)\n+                     and then Ekind (Designated_Type (E)) = E_Subprogram_Type)\n \n                  --  Allow internal call to set convention of subprogram type\n \n-                 or else (Ekind (E) = E_Subprogram_Type)\n+                 or else Ekind (E) = E_Subprogram_Type\n                then\n                   null;\n \n@@ -8084,8 +8085,8 @@ package body Sem_Prag is\n                                                              N_Subprogram_Body\n                then\n                   Error_Pragma\n-                    (\"pragma% requires separate spec\" &\n-                      \" and must come before body\");\n+                    (\"pragma% requires separate spec and must come before \"\n+                     & \"body\");\n                end if;\n \n                --  Test result type if given, note that the result type\n@@ -8097,14 +8098,14 @@ package body Sem_Prag is\n                   Match := False;\n \n                elsif Etype (Def_Id) /= Standard_Void_Type\n-                 and then\n-                   Nam_In (Pname, Name_Export_Procedure, Name_Import_Procedure)\n+                 and then Nam_In (Pname, Name_Export_Procedure,\n+                                         Name_Import_Procedure)\n                then\n                   Match := False;\n \n-               --  Test parameter types if given. Note that this parameter\n-               --  has not been analyzed (and must not be, since it is\n-               --  semantic nonsense), so we get it as the parser left it.\n+               --  Test parameter types if given. Note that this parameter has\n+               --  not been analyzed (and must not be, since it is semantic\n+               --  nonsense), so we get it as the parser left it.\n \n                elsif Present (Arg_Parameter_Types) then\n                   Check_Matching_Types : declare\n@@ -8119,8 +8120,8 @@ package body Sem_Prag is\n                            Match := False;\n                         end if;\n \n-                     --  A list of one type, e.g. (List) is parsed as\n-                     --  a parenthesized expression.\n+                     --  A list of one type, e.g. (List) is parsed as a\n+                     --  parenthesized expression.\n \n                      elsif Nkind (Arg_Parameter_Types) /= N_Aggregate\n                        and then Paren_Count (Arg_Parameter_Types) = 1\n@@ -18176,7 +18177,8 @@ package body Sem_Prag is\n                while Present (E)\n                  and then Scope (E) = Current_Scope\n                loop\n-                  if Ekind_In (E, E_Procedure, E_Generic_Procedure) then\n+                  if Ekind_In (E, E_Generic_Procedure, E_Procedure) then\n+\n                      --  Check that the pragma is not applied to a body.\n                      --  First check the specless body case, to give a\n                      --  different error message. These checks do not apply\n@@ -18189,8 +18191,8 @@ package body Sem_Prag is\n                           and then not Relaxed_RM_Semantics\n                         then\n                            Error_Pragma\n-                             (\"pragma% requires separate spec\" &\n-                                \" and must come before body\");\n+                             (\"pragma% requires separate spec and must come \"\n+                              & \"before body\");\n                         end if;\n \n                         --  Now the \"specful\" body case"}]}