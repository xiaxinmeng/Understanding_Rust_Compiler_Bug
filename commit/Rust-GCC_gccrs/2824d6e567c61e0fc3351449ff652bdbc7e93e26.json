{"sha": "2824d6e567c61e0fc3351449ff652bdbc7e93e26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyNGQ2ZTU2N2M2MWUwZmMzMzUxNDQ5ZmY2NTJiZGJjN2U5M2UyNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-08T21:57:59Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-08T21:57:59Z"}, "message": "* config/i386/i386.h (EH_RETURN_DATA_REGNO) Use DX_REG instead of\n\tnumerical constant.\n\t(EH_RETURN_STACKADJ_RTX): Use CX_REG insted of numerical constant.\n\nFrom-SVN: r164033", "tree": {"sha": "1e1009f017e0b106c1d29f72b96617ca80541c70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e1009f017e0b106c1d29f72b96617ca80541c70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2824d6e567c61e0fc3351449ff652bdbc7e93e26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2824d6e567c61e0fc3351449ff652bdbc7e93e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2824d6e567c61e0fc3351449ff652bdbc7e93e26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2824d6e567c61e0fc3351449ff652bdbc7e93e26/comments", "author": null, "committer": null, "parents": [{"sha": "c485684d0acd2d99cd81c327bd4b33f4d0a5872e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c485684d0acd2d99cd81c327bd4b33f4d0a5872e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c485684d0acd2d99cd81c327bd4b33f4d0a5872e"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "f4ebde137d4d879be39e2d6f16fd117ca69ed0a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2824d6e567c61e0fc3351449ff652bdbc7e93e26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2824d6e567c61e0fc3351449ff652bdbc7e93e26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2824d6e567c61e0fc3351449ff652bdbc7e93e26", "patch": "@@ -1,3 +1,9 @@\n+2010-09-08  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.h (EH_RETURN_DATA_REGNO) Use DX_REG instead of\n+\tnumerical constant.\n+\t(EH_RETURN_STACKADJ_RTX): Use CX_REG insted of numerical constant.\n+\n 2010-09-08  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/45531\n@@ -21,7 +27,7 @@\n 2010-09-08  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR other/18555\n-\t* doc/cppopts.texi (-isysroot): Document Darwin behaviour. \n+\t* doc/cppopts.texi (-isysroot): Document Darwin behaviour.\n \n 2010-09-08  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "49402d185b13572c170ba086aa027ee735d99449", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2824d6e567c61e0fc3351449ff652bdbc7e93e26/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2824d6e567c61e0fc3351449ff652bdbc7e93e26/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2824d6e567c61e0fc3351449ff652bdbc7e93e26", "patch": "@@ -740,7 +740,7 @@ enum target_cpu_default\n    Pentium+ prefers DFmode values to be aligned to 64 bit boundary\n    and Pentium Pro XFmode values at 128 bit boundaries.  */\n \n-#define BIGGEST_ALIGNMENT (TARGET_AVX ? 256: 128)\n+#define BIGGEST_ALIGNMENT (TARGET_AVX ? 256 : 128)\n \n /* Maximum stack alignment.  */\n #define MAX_STACK_ALIGNMENT MAX_OFILE_ALIGNMENT\n@@ -1553,8 +1553,9 @@ typedef struct ix86_args {\n   int mmx_nregs;\t\t/* # mmx registers available for passing */\n   int mmx_regno;\t\t/* next available mmx register number */\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n-  int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n-\t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n+  int float_in_sse;\t\t/* Set to 1 or 2 for 32bit targets if\n+\t\t\t\t   SFmode/DFmode arguments should be passed\n+\t\t\t\t   in SSE registers.  Otherwise 0.  */\n   enum calling_abi call_abi;\t/* Set to SYSV_ABI for sysv abi. Otherwise\n  \t\t\t\t   MS_ABI for ms abi.  */\n } CUMULATIVE_ARGS;\n@@ -1741,8 +1742,10 @@ typedef struct ix86_args {\n #define X86_32_REGPARM_MAX 3\n \n #define REGPARM_MAX\t\t\t\t\t\t\t\\\n-  (TARGET_64BIT ? (TARGET_64BIT_MS_ABI ? X86_64_MS_REGPARM_MAX\t\t\\\n-\t\t   : X86_64_REGPARM_MAX)\t\t\t\t\\\n+  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n+   ? (TARGET_64BIT_MS_ABI\t\t\t\t\t\t\\\n+      ? X86_64_MS_REGPARM_MAX\t\t\t\t\t\t\\\n+      : X86_64_REGPARM_MAX)\t\t\t\t\t\t\\\n    : X86_32_REGPARM_MAX)\n \n #define X86_64_SSE_REGPARM_MAX 8\n@@ -1751,12 +1754,13 @@ typedef struct ix86_args {\n #define X86_32_SSE_REGPARM_MAX (TARGET_SSE ? (TARGET_MACHO ? 4 : 3) : 0)\n \n #define SSE_REGPARM_MAX\t\t\t\t\t\t\t\\\n-  (TARGET_64BIT ? (TARGET_64BIT_MS_ABI ? X86_64_MS_SSE_REGPARM_MAX\t\\\n-\t\t   : X86_64_SSE_REGPARM_MAX)\t\t\t\t\\\n+  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n+   ? (TARGET_64BIT_MS_ABI\t\t\t\t\t\t\\\n+      ? X86_64_MS_SSE_REGPARM_MAX\t\t\t\t\t\\\n+      : X86_64_SSE_REGPARM_MAX)\t\t\t\t\t\t\\\n    : X86_32_SSE_REGPARM_MAX)\n \n #define MMX_REGPARM_MAX (TARGET_64BIT ? 0 : (TARGET_MMX ? 3 : 0))\n-\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n@@ -1969,8 +1973,8 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n #define INCOMING_FRAME_SP_OFFSET UNITS_PER_WORD\n \n /* Describe how we implement __builtin_eh_return.  */\n-#define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 2)\n+#define EH_RETURN_DATA_REGNO(N)\t((N) <= DX_REG ? (N) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, CX_REG)\n \n \n /* Select a format to encode pointers in exception handling data.  CODE"}]}