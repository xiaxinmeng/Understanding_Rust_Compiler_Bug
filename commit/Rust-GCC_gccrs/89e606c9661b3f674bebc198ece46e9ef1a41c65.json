{"sha": "89e606c9661b3f674bebc198ece46e9ef1a41c65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllNjA2Yzk2NjFiM2Y2NzRiZWJjMTk4ZWNlNDZlOWVmMWE0MWM2NQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-15T06:12:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-15T06:12:50Z"}, "message": "gcse.c (pre_expr_reaches_here_p): Kill CHECK_PRE_COM argument.\n\n        * gcse.c (pre_expr_reaches_here_p): Kill CHECK_PRE_COM argument.\n        All callers changed.\n        (pre_expr_reaches_here_p_work): Likewise.\n        (pre_edge_insert): No longer call pre_expr_reaches_here_p.\n        * lcm.c (compute_laterin): Fix initialization of LATER.\n        (compute_nearerout): Similarly for NEARER.\n\nFrom-SVN: r30528", "tree": {"sha": "735e2967a477839c393b6afce3b1c00c55796967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/735e2967a477839c393b6afce3b1c00c55796967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e606c9661b3f674bebc198ece46e9ef1a41c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e606c9661b3f674bebc198ece46e9ef1a41c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e606c9661b3f674bebc198ece46e9ef1a41c65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e606c9661b3f674bebc198ece46e9ef1a41c65/comments", "author": null, "committer": null, "parents": [{"sha": "cd9f6678b314661cdfde334387c1f06e9265c592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd9f6678b314661cdfde334387c1f06e9265c592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd9f6678b314661cdfde334387c1f06e9265c592"}], "stats": {"total": 54, "additions": 33, "deletions": 21}, "files": [{"sha": "575d01dd450152413505fbb69cac98cbfb9df8bb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89e606c9661b3f674bebc198ece46e9ef1a41c65", "patch": "@@ -1,3 +1,12 @@\n+Sun Nov 14 23:11:05 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* gcse.c (pre_expr_reaches_here_p): Kill CHECK_PRE_COM argument.\n+\tAll callers changed.\n+\t(pre_expr_reaches_here_p_work): Likewise.\n+\t(pre_edge_insert): No longer call pre_expr_reaches_here_p.\n+\t* lcm.c (compute_laterin): Fix initialization of LATER.\n+\t(compute_nearerout): Similarly for NEARER.\n+\n Sun Nov 14 12:41:57 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cse.c (set_nonvarying_address_components): Delete unused function."}, {"sha": "1715f9c332a3126edca359f4708746ef64083c9a", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=89e606c9661b3f674bebc198ece46e9ef1a41c65", "patch": "@@ -596,8 +596,7 @@ static int one_cprop_pass\t     PROTO ((int, int));\n static void alloc_pre_mem\t     PROTO ((int, int));\n static void free_pre_mem\t      PROTO ((void));\n static void compute_pre_data\t  PROTO ((void));\n-static int pre_expr_reaches_here_p    PROTO ((int, struct expr *,\n-\t\t\t\t\t      int, int));\n+static int pre_expr_reaches_here_p    PROTO ((int, struct expr *, int));\n static void insert_insn_end_bb\tPROTO ((struct expr *, int, int));\n static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n static void pre_insert_copies\t PROTO ((void));\n@@ -640,7 +639,8 @@ static void delete_null_pointer_checks_1 PROTO ((int_list_ptr *, int *,\n static rtx process_insert_insn\tPROTO ((struct expr *));\n static int pre_edge_insert\tPROTO ((struct edge_list *, struct expr **));\n static int expr_reaches_here_p_work\tPROTO ((struct occr *, struct expr *, int, int, char *));\n-static int pre_expr_reaches_here_p_work\tPROTO ((int, struct expr *, int, int, char *));\n+static int pre_expr_reaches_here_p_work\tPROTO ((int, struct expr *,\n+\t\t\t\t\t\tint, char *));\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -4213,9 +4213,6 @@ compute_pre_data ()\n    VISITED is a pointer to a working buffer for tracking which BB's have\n    been visited.  It is NULL for the top-level call.\n \n-   CHECK_PRE_COMP controls whether or not we check for a computation of\n-   EXPR in OCCR_BB.\n-\n    We treat reaching expressions that go through blocks containing the same\n    reaching expression as \"not reaching\".  E.g. if EXPR is generated in blocks\n    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block\n@@ -4224,11 +4221,10 @@ compute_pre_data ()\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p_work (occr_bb, expr, bb, check_pre_comp, visited)\n+pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n      int occr_bb;\n      struct expr *expr;\n      int bb;\n-     int check_pre_comp;\n      char *visited;\n {\n   edge pred;\n@@ -4244,8 +4240,7 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, check_pre_comp, visited)\n \t  /* Nothing to do.  */\n \t}\n       /* Does this predecessor generate this expression?  */\n-      else if ((!check_pre_comp && occr_bb == pred_bb)\n-\t       || TEST_BIT (comp[pred_bb], expr->bitmap_index))\n+      else if (TEST_BIT (comp[pred_bb], expr->bitmap_index))\n \t{\n \t  /* Is this the occurrence we're looking for?\n \t     Note that there's only one generating occurrence per block\n@@ -4261,8 +4256,7 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, check_pre_comp, visited)\n       else\n \t{\n \t  visited[pred_bb] = 1;\n-\t  if (pre_expr_reaches_here_p_work (occr_bb, expr, pred_bb,\n-\t\t\t\t            check_pre_comp, visited))\n+\t  if (pre_expr_reaches_here_p_work (occr_bb, expr, pred_bb, visited))\n \t    return 1;\n \t}\n     }\n@@ -4275,17 +4269,15 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, check_pre_comp, visited)\n    memory allocated for that function is returned. */\n \n static int\n-pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp)\n+pre_expr_reaches_here_p (occr_bb, expr, bb)\n      int occr_bb;\n      struct expr *expr;\n      int bb;\n-     int check_pre_comp;\n {\n   int rval;\n   char * visited = (char *) xcalloc (n_basic_blocks, 1);\n \n-  rval = pre_expr_reaches_here_p_work(occr_bb, expr, bb, check_pre_comp, \n-\t\t\t\t      visited);\n+  rval = pre_expr_reaches_here_p_work(occr_bb, expr, bb, visited);\n \n   free (visited);\n \n@@ -4529,10 +4521,7 @@ pre_edge_insert (edge_list, index_map)\n \n \t\t      /* Insert this expression on this edge if if it would\n \t\t\t reach the deleted occurence in BB.  */\n-\t\t      if (!TEST_BIT (inserted[e], j)\n-\t\t\t  && (bb == ENTRY_BLOCK \n-\t\t\t      || pre_expr_reaches_here_p (bb, expr,\n-\t\t\t\t\t\t   BLOCK_NUM (occr->insn), 0)))\n+\t\t      if (!TEST_BIT (inserted[e], j))\n \t\t\t{\n \t\t\t  rtx insn;\n \t\t\t  edge eg = INDEX_EDGE (edge_list, e);\n@@ -4660,7 +4649,7 @@ pre_insert_copies ()\n \t\t    continue;\n \t\t  /* Or if the expression doesn't reach the deleted one.  */\n \t\t  if (! pre_expr_reaches_here_p (BLOCK_NUM (avail->insn), expr,\n-\t\t\t\t\t\t BLOCK_NUM (occr->insn),1))\n+\t\t\t\t\t\t BLOCK_NUM (occr->insn)))\n \t\t    continue;\n \n \t\t  /* Copy the result of avail to reaching_reg.  */"}, {"sha": "dd900b6132d57583b3d2c6e104ad2ce61c052aa2", "filename": "gcc/lcm.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e606c9661b3f674bebc198ece46e9ef1a41c65/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=89e606c9661b3f674bebc198ece46e9ef1a41c65", "patch": "@@ -269,6 +269,13 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n      of the optimistic edge.  That will requeue the affected blocks.  */\n   sbitmap_vector_ones (later, num_edges);\n \n+  /* Note that even though we want an optimistic setting of LATER, we\n+     do not want to be overly optimistic.  Consider an outgoing edge from\n+     the entry block.  That edge should always have a LATER value the\n+     same as EARLIEST for that edge.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    sbitmap_copy (later[(int)e->aux], earliest[(int)e->aux]);\n+\n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n   for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n@@ -598,6 +605,13 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (nearer, num_edges);\n \n+  /* Note that even though we want an optimistic setting of NEARER, we\n+     do not want to be overly optimistic.  Consider an incoming edge to\n+     the exit block.  That edge should always have a NEARER value the\n+     same as FARTHEST for that edge.  */\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+    sbitmap_copy (nearer[(int)e->aux], farthest[(int)e->aux]);\n+\n   /* Add all the blocks to the worklist.  This prevents an early exit\n      from the loop given our optimistic initialization of NEARER.  */\n   for (bb = 0; bb < n_basic_blocks; bb++)"}]}