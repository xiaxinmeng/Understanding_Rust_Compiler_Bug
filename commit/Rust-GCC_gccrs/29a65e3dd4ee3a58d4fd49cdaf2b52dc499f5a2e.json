{"sha": "29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhNjVlM2RkNGVlM2E1OGQ0ZmQ0OWNkYWYyYjUyZGM0OTlmNWEyZQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-10-13T12:57:14Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-10-13T12:57:14Z"}, "message": "Fix discrepancies between devo and egcs.\n\nFrom-SVN: r23052", "tree": {"sha": "8fcd39c61e5c844f084294791e0eedf17835369b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fcd39c61e5c844f084294791e0eedf17835369b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/comments", "author": null, "committer": null, "parents": [{"sha": "48ad5afd7d544281c294b6f7dba498ec88ab11eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48ad5afd7d544281c294b6f7dba498ec88ab11eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48ad5afd7d544281c294b6f7dba498ec88ab11eb"}], "stats": {"total": 213, "additions": 143, "deletions": 70}, "files": [{"sha": "db482bc1295a63fa9ae61e1a8810630975473883", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "patch": "@@ -1,3 +1,19 @@\n+Tue Oct 13 12:51:04 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/v850/lib1funcs.asm (_udivsi3): Add .type declaration.\n+\tReplace use of r5 with use of r19.\n+\n+\t* config/v850/v850.h (LINK_POINTER_REGNUM): Define.\n+\n+\t* config/v850/v850.c (compute_register_save_size): Allow for the\n+\tfact that helper functions save all registers, not just those used\n+\tby the function.\n+\t\n+\tReplace constant 31 with macro LINK_POINTER_REGNUM.\n+\n+\t* config/v850/v850.md: Use 'indirect_operand' rather than\n+\t'memory_operand' for bit test/set/clear patterns.\n+\n Tue Oct 13 11:49:14 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* mips/iris6.h (ASM_OUTPUT_WEAK_ALIAS): Call ASM_GLOBALIZE_LABEL."}, {"sha": "cb1f039fa048313cdf0b1b07e300c3c19880f8f6", "filename": "gcc/config/v850/lib1funcs.asm", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Flib1funcs.asm?ref=29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "patch": "@@ -95,6 +95,7 @@ ___mulsi3:\n #ifdef L_udivsi3\n \t.text\n \t.global ___udivsi3\n+\t.type\t___udivsi3,@function\n ___udivsi3:\n \tmov 1,r12\n \tmov 0,r10\n@@ -110,8 +111,8 @@ ___udivsi3:\n \tbnl .L12\n \tcmp r0,r12\n \tbe .L8\n-\tmov r7,r5\n-\tand r13,r5\n+\tmov r7,r19\n+\tand r13,r19\n \tbe .L4\n \tbr .L12\n .L9:"}, {"sha": "8afb2f3dcfc990b2bb1b8817ca287f208ef71779", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 86, "deletions": 29, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "patch": "@@ -1398,12 +1398,12 @@ compute_register_save_size (p_reg_saved)\n   int size = 0;\n   int i;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n-  int call_p = regs_ever_live[31];\n+  int call_p = regs_ever_live [LINK_POINTER_REGNUM];\n   long reg_saved = 0;\n \n   /* Count the return pointer if we need to save it.  */\n   if (profile_flag && !call_p)\n-    regs_ever_live[31] = call_p = 1;\n+    regs_ever_live [LINK_POINTER_REGNUM] = call_p = 1;\n  \n   /* Count space for the register saves.  */\n   if (interrupt_handler)\n@@ -1436,15 +1436,63 @@ compute_register_save_size (p_reg_saved)\n \t    break;\n \t  }\n     }\n-\n   else\n-    for (i = 0; i <= 31; i++)\n-      if (regs_ever_live[i] && ((! call_used_regs[i]) || i == 31))\n+    {\n+      /* Find the first register that needs to be saved.  */\n+      for (i = 0; i <= 31; i++)\n+\tif (regs_ever_live[i] && ((! call_used_regs[i])\n+\t\t\t\t  || i == LINK_POINTER_REGNUM))\n+\t  break;\n+\n+      /* If it is possible that an out-of-line helper function might be\n+\t used to generate the prologue for the current function, then we\n+\t need to cover the possibility that such a helper function will\n+\t be used, despite the fact that there might be gaps in the list of\n+\t registers that need to be saved.  To detect this we note that the\n+\t helper functions always push at least register r29 if the link\n+\t register is not used, and at least registers r27 - r31 if the\n+\t link register is used (and provided that the function is not an\n+\t interrupt handler).  */\n+\t \n+      if (TARGET_PROLOG_FUNCTION\n+\t  && (i == 2 || i >= 20)\n+\t  && regs_ever_live[LINK_POINTER_REGNUM] ? (i < 28) : (i < 30))\n \t{\n-\t  size += 4;\n-\t  reg_saved |= 1L << i;\n-\t}\n+\t  if (i == 2)\n+\t    {\n+\t      size += 4;\n+\t      reg_saved |= 1L << i;\n+\n+\t      i = 20;\n+\t    }\n \n+\t  /* Helper functions save all registers between the starting\n+\t     register and the last register, regardless of whether they\n+\t     are actually used by the function or not.  */\n+\t  for (; i <= 29; i++)\n+\t    {\n+\t      size += 4;\n+\t      reg_saved |= 1L << i;\n+\t    }\n+\n+\t  if (regs_ever_live [LINK_POINTER_REGNUM])\n+\t    {\n+\t      size += 4;\n+\t      reg_saved |= 1L << LINK_POINTER_REGNUM;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (; i <= 31; i++)\n+\t    if (regs_ever_live[i] && ((! call_used_regs[i])\n+\t\t\t\t      || i == LINK_POINTER_REGNUM))\n+\t      {\n+\t\tsize += 4;\n+\t\treg_saved |= 1L << i;\n+\t      }\n+\t}\n+    }\n+  \n   if (p_reg_saved)\n     *p_reg_saved = reg_saved;\n \n@@ -1486,16 +1534,20 @@ expand_prologue ()\n   if (interrupt_handler)\n     {\n       emit_insn (gen_save_interrupt ());\n+      \n       actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;\n-      if (((1L << 31) & reg_saved) != 0)\n+      \n+      if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \tactual_fsize -= INTERRUPT_ALL_SAVE_SIZE;\n     }\n \n   /* Save arg registers to the stack if necessary.  */\n   else if (current_function_anonymous_args)\n     {\n       if (TARGET_PROLOG_FUNCTION)\n-\temit_insn (gen_save_r6_r9 ());\n+\t{\n+\t  emit_insn (gen_save_r6_r9 ());\n+\t}\n       else\n \t{\n \t  offset = 0;\n@@ -1521,9 +1573,9 @@ expand_prologue ()\n \n   /* If the return pointer is saved, the helper functions also allocate\n      16 bytes of stack for arguments to be saved in.  */\n-  if (((1L << 31) & reg_saved) != 0)\n+  if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n     {\n-      save_regs[num_save++] = gen_rtx (REG, Pmode, 31);\n+      save_regs[num_save++] = gen_rtx (REG, Pmode, LINK_POINTER_REGNUM);\n       default_stack = 16;\n     }\n \n@@ -1563,14 +1615,14 @@ expand_prologue ()\n \n \t  if (TARGET_V850)\n \t    {\n-\t      XVECEXP (save_all, 0, num_save+1)\n+\t      XVECEXP (save_all, 0, num_save + 1)\n \t\t= gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, Pmode, 10));\n \t    }\n \n \t  offset = - default_stack;\n \t  for (i = 0; i < num_save; i++)\n \t    {\n-\t      XVECEXP (save_all, 0, i+1)\n+\t      XVECEXP (save_all, 0, i + 1)\n \t\t= gen_rtx (SET, VOIDmode,\n \t\t\t   gen_rtx (MEM, Pmode,\n \t\t\t\t    plus_constant (stack_pointer_rtx, offset)),\n@@ -1584,7 +1636,7 @@ expand_prologue ()\n \t      rtx insn = emit_insn (save_all);\n \t      INSN_CODE (insn) = code;\n \t      actual_fsize -= alloc_stack;\n-\n+\t      \n \t      if (TARGET_DEBUG)\n \t\tfprintf (stderr, \"\\\n Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n@@ -1602,9 +1654,10 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n   if (!save_all)\n     {\n       /* Special case interrupt functions that save all registers for a call.  */\n-      if (interrupt_handler && ((1L << 31) & reg_saved) != 0)\n-\temit_insn (gen_save_all_interrupt ());\n-\n+      if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n+\t{\n+\t  emit_insn (gen_save_all_interrupt ());\n+\t}\n       else\n \t{\n \t  /* If the stack is too big, allocate it in chunks so we can do the\n@@ -1624,7 +1677,7 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n \t\t\t\t   GEN_INT (-init_stack_alloc)));\n \t  \n \t  /* Save the return pointer first.  */\n-\t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == 31)\n+\t  if (num_save > 0 && REGNO (save_regs[num_save-1]) == LINK_POINTER_REGNUM)\n \t    {\n \t      emit_move_insn (gen_rtx (MEM, SImode,\n \t\t\t\t       plus_constant (stack_pointer_rtx,\n@@ -1688,7 +1741,7 @@ expand_epilogue ()\n   if (interrupt_handler)\n     {\n       actual_fsize -= INTERRUPT_FIXED_SAVE_SIZE;\n-      if (((1L << 31) & reg_saved) != 0)\n+      if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \tactual_fsize -= INTERRUPT_ALL_SAVE_SIZE;\n     }\n \n@@ -1707,9 +1760,9 @@ expand_epilogue ()\n \n   /* If the return pointer is saved, the helper functions also allocate\n      16 bytes of stack for arguments to be saved in.  */\n-  if (((1L << 31) & reg_saved) != 0)\n+  if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n     {\n-      restore_regs[num_restore++] = gen_rtx (REG, Pmode, 31);\n+      restore_regs[num_restore++] = gen_rtx (REG, Pmode, LINK_POINTER_REGNUM);\n       default_stack = 16;\n     }\n \n@@ -1832,15 +1885,18 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \n       /* Special case interrupt functions that save all registers\n \t for a call.  */\n-      if (interrupt_handler && ((1L << 31) & reg_saved) != 0)\n-\temit_insn (gen_restore_all_interrupt ());\n+      if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n+\t{\n+\t  emit_insn (gen_restore_all_interrupt ());\n+\t}\n       else\n \t{\n \t  /* Restore registers from the beginning of the stack frame */\n \t  offset = init_stack_free - 4;\n \n \t  /* Restore the return pointer first.  */\n-\t  if (num_restore > 0 && REGNO (restore_regs[num_restore-1]) == 31)\n+\t  if (num_restore > 0\n+\t      && REGNO (restore_regs [num_restore - 1]) == LINK_POINTER_REGNUM)\n \t    {\n \t      emit_move_insn (restore_regs[--num_restore],\n \t\t\t      gen_rtx (MEM, SImode,\n@@ -2267,17 +2323,18 @@ construct_restore_jr (op)\n     abort ();\n \n   /* Discover the last register to pop.  */\n-  if (mask & (1 << 31))\n+  if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n       if (stack_bytes != 16)\n \tabort ();\n       \n-      last = 31;\n+      last = LINK_POINTER_REGNUM;\n     }\n   else\n     {\n       if (stack_bytes != 0)\n \tabort ();\n+      \n       if ((mask & (1 << 29)) == 0)\n \tabort ();\n       \n@@ -2453,12 +2510,12 @@ construct_save_jarl (op)\n     abort ();\n \n   /* Discover the last register to push.  */\n-  if (mask & (1 << 31))\n+  if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n       if (stack_bytes != -16)\n \tabort ();\n       \n-      last = 31;\n+      last = LINK_POINTER_REGNUM;\n     }\n   else\n     {"}, {"sha": "6b9a9e2f62e5c4d781d771e0909e0e8e639d7f58", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "patch": "@@ -573,6 +573,9 @@ enum reg_class\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 32\n \n+/* Register containing return address from latest function call.  */\n+#define LINK_POINTER_REGNUM 31\n+     \n /* On some machines the offset between the frame pointer and starting\n    offset of the automatic variables is not known until after register\n    allocation has been done (for example, because the saved registers"}, {"sha": "42a95db4541404b45d57479b2e3b4f048e4ab405", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "patch": "@@ -397,7 +397,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_clr1_2\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n \t(subreg:HI\n \t  (and:SI (subreg:SI (match_dup 0) 0)\n \t\t  (match_operand:HI 1 \"not_power_of_two_operand\" \"\")) 0))]\n@@ -417,7 +417,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_clr1_3\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(and:SI (match_dup 0)\n \t\t(match_operand:SI 1 \"not_power_of_two_operand\" \"\")))]\n   \"\"\n@@ -461,7 +461,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_set1_2\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n \t(subreg:HI (ior:SI (subreg:SI (match_dup 0) 0)\n \t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n   \"\"\n@@ -485,7 +485,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_set1_3\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(ior:SI (match_dup 0)\n \t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n   \"\"\n@@ -534,7 +534,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_not1_2\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n \t(subreg:HI (xor:SI (subreg:SI (match_dup 0) 0)\n \t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n   \"\"\n@@ -558,7 +558,7 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"*v850_not1_3\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+  [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(xor:SI (match_dup 0)\n \t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n   \"\"\n@@ -1183,42 +1183,10 @@\n  [(set_attr \"length\" \"4\")\n   (set_attr \"cc\"     \"clobber\")])\n \n-\n-;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n-(define_insn \"save_interrupt\"\n-  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n-   (set (mem:SI (reg:SI 3)) (reg:SI 30))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 10))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 4))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))]\n-  \"\"\n-  \"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\"\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-\n-;; Save all registers except for the registers saved in save_interrupt when\n-;; an interrupt function makes a call.\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-;; This is needed because the rest of the compiler is not ready to handle\n-;; insns this complicated.\n-\n-(define_insn \"save_all_interrupt\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"jarl __save_all_interrupt,r10\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-\n-\n-\n ;; This pattern will match a return RTX followed by any number of pop RTXs\n ;; and possible a stack adjustment as well.  These RTXs will be turned into\n ;; a suitable call to a worker function.\n \n-\n (define_insn \"\"\n [(match_parallel 0 \"pattern_is_ok_for_epilogue\"\n    [(return)\n@@ -1233,6 +1201,18 @@\n  [(set_attr \"length\" \"4\")\n   (set_attr \"cc\"     \"clobber\")])\n \n+;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n+(define_insn \"save_interrupt\"\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n+   (set (mem:SI (reg:SI 3)) (reg:SI 30))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -4))) (reg:SI 10))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -8))) (reg:SI 4))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))]\n+  \"TARGET_V850\"\n+  \"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\"\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;; Restore r1, r4, r10, and return from the interrupt\n (define_insn \"restore_interrupt\"\n   [(return)\n@@ -1246,6 +1226,22 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n+\n+;; Save all registers except for the registers saved in save_interrupt when\n+;; an interrupt function makes a call.\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+;; This is needed because the rest of the compiler is not ready to handle\n+;; insns this complicated.\n+\n+(define_insn \"save_all_interrupt\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"TARGET_V850\"\n+  \"jarl __save_all_interrupt,r10\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n ;; Restore all registers saved when an interrupt function makes a call.\n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n@@ -1254,7 +1250,7 @@\n \n (define_insn \"restore_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 1)]\n-  \"\"\n+  \"TARGET_V850\"\n   \"jarl __restore_all_interrupt,r10\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])"}]}