{"sha": "6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ4NTk0N2QyM2FiNmE5Yjk5NzViMmUwNTkwZGI5MzA4YzVjMWIwNw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-26T21:00:25Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-03-26T21:01:13Z"}, "message": "coroutines: Implement n4849 recommended symmetric transfer.\n\nAlthough the note in the text [expr.await] / 5.1.1 is not normative,\nit is asserted by users that an implementation that is unable to\nperform unlimited symmetric transfers is not terribly useful.\n\nThis relates to the following circumstance:\n\ntry {\n users-function-body:\n {\n    ....\n    { some suspend context\n      continuation_handle = await_suspend (another handle);\n      continuation_handle.resume ();\n      'return' (actually a suspension operation).\n    }\n  }\n} catch (...) {}\n\nThe call to 'continuation_handle.resume ()' needs to be a tail-\ncall in order that an arbitrary number of coroutines can be handled\nin this manner.  There are two issues with this:\n\n1. That the user's function body is wrapped in a try/catch block and\n   one cannot tail-call from within those.\n\n2. That GCC doesn't usually produce tail-calls when the optimisation\n   level is < O2.\n\nAfter considerable discussion at WG21 meetings, it has been determined\nthat the intent is that the operation behaves as if the resume call is\nexecuted in the context of the caller.\n\nSo, we can remap the fragment above like this:\n\n{\n  void_coroutine_handle continuation;\n\n  try {\n   users-function-body:\n   {\n      ....\n      { some suspend context\n        continuation = await_suspend (another handle);\n        <scope exit without cleanup> symmetric_transfer;\n      }\n    }\n  } catch (...) {}\n\nsymmetric_transfer:\n  continuation.resume(); [tail call] [must tail call]\n}\n\nThus we take the call outside the try-catch block which solves\nissue (1) and mark it as a tail call and as \"must tail call\" for\ncorrectness which solves (2).\n\nAs bonuses, since we no longer need to differentiate handle types\nreturned from await_suspend() methods, nor do we need to keep them\nin the coroutine frame, since they are ephemeral, we save entries in\nthe frame and reduce some code too.\n\ngcc/cp/ChangeLog:\n\n2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (coro_init_identifiers): Initialize an identifier\n\tfor the cororoutine handle 'address' method name.\n\t(struct coro_aw_data): Add fields to cover the continuations.\n\t(co_await_expander): Determine the kind of await_suspend in use.\n\tIf we have the case that returns a continuation handle, then save\n\tthis and make the target for 'scope exit without cleanup' be the\n\tcontinuation resume label.\n\t(expand_co_awaits): Remove.\n\t(struct suspend_point_info): Remove fields that kept the returned\n\tawait_suspend handle type.\n\t(transform_await_expr): Remove code tracking continuation handles.\n\t(build_actor_fn): Add the continuation handle as an actor-function\n\tscope var.  Build the symmetric transfer continuation point. Call\n\tthe tree walk for co_await expansion directly, rather than via a\n\ttrivial shim function.\n\t(register_await_info): Remove fields tracking continuation handles.\n\t(get_await_suspend_return_type): Remove.\n\t(register_awaits): Remove code tracking continuation handles.\n\t(morph_fn_to_coro): Remove code tracking continuation handles.\n\ngcc/testsuite/ChangeLog:\n\n2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C: Amend\n\tto n4849 behaviour.\n\t* g++.dg/coroutines/torture/symmetric-transfer-00-basic.C: New\n\ttest.", "tree": {"sha": "ba421ba3fb1f1de402d5695da8edd6f19f2bb16d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba421ba3fb1f1de402d5695da8edd6f19f2bb16d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a1f0f64160e078e23795901ff98575805d6875b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1f0f64160e078e23795901ff98575805d6875b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1f0f64160e078e23795901ff98575805d6875b"}], "stats": {"total": 403, "additions": 259, "deletions": 144}, "files": [{"sha": "e97c4e9d1ad2663da5f0aed210f5f962d3dbceee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "patch": "@@ -1,3 +1,25 @@\n+2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* coroutines.cc (coro_init_identifiers): Initialize an identifier\n+\tfor the cororoutine handle 'address' method name.\n+\t(struct coro_aw_data): Add fields to cover the continuations.\n+\t(co_await_expander): Determine the kind of await_suspend in use.\n+\tIf we have the case that returns a continuation handle, then save\n+\tthis and make the target for 'scope exit without cleanup' be the\n+\tcontinuation resume label.\n+\t(expand_co_awaits): Remove.\n+\t(struct suspend_point_info): Remove fields that kept the returned\n+\tawait_suspend handle type.\n+\t(transform_await_expr): Remove code tracking continuation handles.\n+\t(build_actor_fn): Add the continuation handle as an actor-function\n+\tscope var.  Build the symmetric transfer continuation point. Call\n+\tthe tree walk for co_await expansion directly, rather than via a \n+\ttrivial shim function.\n+\t(register_await_info): Remove fields tracking continuation handles.\n+\t(get_await_suspend_return_type): Remove.\n+\t(register_awaits): Remove code tracking continuation handles.\n+\t(morph_fn_to_coro): Remove code tracking continuation handles.\n+\n 2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* coroutines.cc (co_await_expander): If we are expanding the"}, {"sha": "38a23a91f8bdaa58df5f171c85fac8080627fcdd", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 88, "deletions": 132, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "patch": "@@ -199,6 +199,7 @@ static GTY(()) tree coro_return_void_identifier;\n static GTY(()) tree coro_return_value_identifier;\n static GTY(()) tree coro_yield_value_identifier;\n static GTY(()) tree coro_resume_identifier;\n+static GTY(()) tree coro_address_identifier;\n static GTY(()) tree coro_from_address_identifier;\n static GTY(()) tree coro_get_return_object_identifier;\n static GTY(()) tree coro_gro_on_allocation_fail_identifier;\n@@ -226,6 +227,7 @@ coro_init_identifiers ()\n   coro_return_value_identifier = get_identifier (\"return_value\");\n   coro_yield_value_identifier = get_identifier (\"yield_value\");\n   coro_resume_identifier = get_identifier (\"resume\");\n+  coro_address_identifier = get_identifier (\"address\");\n   coro_from_address_identifier = get_identifier (\"from_address\");\n   coro_get_return_object_identifier = get_identifier (\"get_return_object\");\n   coro_gro_on_allocation_fail_identifier =\n@@ -1352,6 +1354,8 @@ struct coro_aw_data\n   tree self_h;     /* This is a handle to the current coro (frame var).  */\n   tree cleanup;    /* This is where to go once we complete local destroy.  */\n   tree cororet;    /* This is where to go if we suspend.  */\n+  tree corocont;   /* This is where to go if we continue.  */\n+  tree conthand;   /* This is the handle for a continuation.  */\n   unsigned index;  /* This is our current resume index.  */\n };\n \n@@ -1440,7 +1444,6 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n \n   tree actor = data->actor_fn;\n   location_t loc = EXPR_LOCATION (*stmt);\n-  tree sv_handle = TREE_OPERAND (saved_co_await, 0);\n   tree var = TREE_OPERAND (saved_co_await, 1);  /* frame slot. */\n   tree expr = TREE_OPERAND (saved_co_await, 2); /* initializer.  */\n   tree awaiter_calls = TREE_OPERAND (saved_co_await, 3);\n@@ -1493,15 +1496,29 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   r = coro_build_cvt_void_expr_stmt (r, loc);\n   append_to_statement_list (r, &body_list);\n \n+  /* Find out what we have to do with the awaiter's suspend method.\n+     [expr.await]\n+     (5.1) If the result of await-ready is false, the coroutine is considered\n+\t   suspended. Then:\n+     (5.1.1) If the type of await-suspend is std::coroutine_handle<Z>,\n+\t     await-suspend.resume() is evaluated.\n+     (5.1.2) if the type of await-suspend is bool, await-suspend is evaluated,\n+\t     and the coroutine is resumed if the result is false.\n+     (5.1.3) Otherwise, await-suspend is evaluated.  */\n+\n   tree suspend = TREE_VEC_ELT (awaiter_calls, 1); /* await_suspend().  */\n+  tree susp_type = TREE_TYPE (suspend);\n \n-  if (sv_handle == NULL_TREE)\n+  bool is_cont = false;\n+  /* NOTE: final suspend can't resume; the \"resume\" label in that case\n+     corresponds to implicit destruction.  */\n+  if (VOID_TYPE_P (susp_type))\n     {\n-      /* void return, we just call it and hit the yield.  */\n+      /* We just call await_suspend() and hit the yield.  */\n       suspend = coro_build_cvt_void_expr_stmt (suspend, loc);\n       append_to_statement_list (suspend, &body_list);\n     }\n-  else if (sv_handle == boolean_type_node)\n+  else if (TREE_CODE (susp_type) == BOOLEAN_TYPE)\n     {\n       /* Boolean return, continue if the call returns false.  */\n       suspend = build1_loc (loc, TRUTH_NOT_EXPR, boolean_type_node, suspend);\n@@ -1514,24 +1531,17 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n     }\n   else\n     {\n-      r = build2_loc (loc, INIT_EXPR, TREE_TYPE (sv_handle), sv_handle,\n-\t\t      suspend);\n+      r = build1_loc (loc, CONVERT_EXPR, void_coro_handle_type, suspend);\n+      r = build2_loc (loc, INIT_EXPR, void_coro_handle_type, data->conthand, r);\n+      r = build1 (CONVERT_EXPR, void_type_node, r);\n       append_to_statement_list (r, &body_list);\n-      tree resume\n-\t= lookup_member (TREE_TYPE (sv_handle), coro_resume_identifier, 1, 0,\n-\t\t\t tf_warning_or_error);\n-      resume = build_new_method_call (sv_handle, resume, NULL, NULL_TREE,\n-\t\t\t\t      LOOKUP_NORMAL, NULL, tf_warning_or_error);\n-      resume = coro_build_cvt_void_expr_stmt (resume, loc);\n-      append_to_statement_list (resume, &body_list);\n-    }\n-\n-  tree d_l\n-    = build1 (ADDR_EXPR, build_reference_type (void_type_node), destroy_label);\n-  tree r_l\n-    = build1 (ADDR_EXPR, build_reference_type (void_type_node), resume_label);\n-  tree susp\n-    = build1 (ADDR_EXPR, build_reference_type (void_type_node), data->cororet);\n+      is_cont = true;\n+    }\n+\n+  tree d_l = build_address (destroy_label);\n+  tree r_l = build_address (resume_label);\n+  tree susp = build_address (data->cororet);\n+  tree cont = build_address (data->corocont);\n   tree final_susp = build_int_cst (integer_type_node, is_final ? 1 : 0);\n \n   susp_idx = build_int_cst (integer_type_node, data->index);\n@@ -1551,7 +1561,8 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n \t\t\tcreate_anon_label_with_ctx (loc, actor));\n   add_stmt (r); /* case 0: */\n   /* Implement the suspend, a scope exit without clean ups.  */\n-  r = build_call_expr_internal_loc (loc, IFN_CO_SUSPN, void_type_node, 1, susp);\n+  r = build_call_expr_internal_loc (loc, IFN_CO_SUSPN, void_type_node, 1,\n+\t\t\t\t    is_cont ? cont : susp);\n   r = coro_build_cvt_void_expr_stmt (r, loc);\n   add_stmt (r); /*   goto ret;  */\n   r = build_case_label (build_int_cst (integer_type_node, 1), NULL_TREE,\n@@ -1645,16 +1656,6 @@ co_await_expander (tree *stmt, int * /*do_subtree*/, void *d)\n   return NULL_TREE;\n }\n \n-static tree\n-expand_co_awaits (tree fn, tree *fnbody, tree coro_fp, tree resume_idx,\n-\t\t  tree i_a_r_c, tree cleanup, tree cororet, tree self_h)\n-{\n-  coro_aw_data data\n-    = {fn, coro_fp, resume_idx, i_a_r_c, self_h, cleanup, cororet, 2};\n-  cp_walk_tree (fnbody, co_await_expander, &data, NULL);\n-  return *fnbody;\n-}\n-\n /* Suspend point hash_map.  */\n \n struct suspend_point_info\n@@ -1663,10 +1664,6 @@ struct suspend_point_info\n   tree awaitable_type;\n   /* coro frame field name.  */\n   tree await_field_id;\n-  /* suspend method return type.  */\n-  tree suspend_type;\n-  /* suspend handle field name, NULL_TREE if not needed.  */\n-  tree susp_handle_id;\n };\n \n static hash_map<tree, suspend_point_info> *suspend_points;\n@@ -1703,22 +1700,6 @@ transform_await_expr (tree await_expr, await_xform_data *xform)\n \t  We need to replace the e_proxy in the awr_call.  */\n \n   tree coro_frame_type = TREE_TYPE (xform->actor_frame);\n-  tree ah = NULL_TREE;\n-  if (si->susp_handle_id)\n-    {\n-      tree ah_m\n-\t= lookup_member (coro_frame_type, si->susp_handle_id,\n-\t\t\t /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-      ah = build_class_member_access_expr (xform->actor_frame, ah_m, NULL_TREE,\n-\t\t\t\t\t   true, tf_warning_or_error);\n-    }\n-  else if (TREE_CODE (si->suspend_type) == BOOLEAN_TYPE)\n-    ah = boolean_type_node;\n-\n-  /* Replace Op 0 with the frame slot for the temporary handle, if it's needed.\n-     If there's no frame type to be stored we flag boolean_type for that case\n-     and an empty pointer for void return.  */\n-  TREE_OPERAND (await_expr, 0) = ah;\n \n   /* If we have a frame var for the awaitable, get a reference to it.  */\n   proxy_replace data;\n@@ -1988,6 +1969,14 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree top_block = make_node (BLOCK);\n   BIND_EXPR_BLOCK (actor_bind) = top_block;\n \n+  tree continuation = build_lang_decl (VAR_DECL,\n+\t\t\t\t       get_identifier (\"actor.continue\"),\n+\t\t\t\t       void_coro_handle_type);\n+  DECL_ARTIFICIAL (continuation) = 1;\n+  DECL_IGNORED_P (continuation) = 1;\n+  DECL_CONTEXT (continuation) = actor;\n+  BIND_EXPR_VARS (actor_bind) = continuation;\n+\n   /* Update the block associated with the outer scope of the orig fn.  */\n   tree first = expr_first (fnbody);\n   if (first && TREE_CODE (first) == BIND_EXPR)\n@@ -2012,6 +2001,9 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n     = create_named_label_with_ctx (loc, \"actor.begin\", actor);\n   tree actor_frame = build1_loc (loc, INDIRECT_REF, coro_frame_type, actor_fp);\n \n+  /* Declare the continuation handle.  */\n+  add_decl_expr (continuation);\n+\n   /* Re-write param references in the body, no code should be generated\n      here.  */\n   if (DECL_ARGUMENTS (orig))\n@@ -2062,6 +2054,9 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   tree ret_label\n     = create_named_label_with_ctx (loc, \"actor.suspend.ret\", actor);\n \n+  tree continue_label\n+    = create_named_label_with_ctx (loc, \"actor.continue.ret\", actor);\n+\n   tree lsb_if = begin_if_stmt ();\n   tree chkb0 = build2 (BIT_AND_EXPR, short_unsigned_type_node, rat,\n \t\t       build_int_cst (short_unsigned_type_node, 1));\n@@ -2368,11 +2363,41 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   r = maybe_cleanup_point_expr_void (r);\n   add_stmt (r);\n \n-  /* We need the resume index to work with.  */\n+  /* This is the 'continuation' return point.  For such a case we have a coro\n+     handle (from the await_suspend() call) and we want handle.resume() to\n+     execute as a tailcall allowing arbitrary chaining of coroutines.  */\n+  r = build_stmt (loc, LABEL_EXPR, continue_label);\n+  add_stmt (r);\n+\n+  /* We want to force a tail-call even for O0/1, so this expands the resume\n+     call into its underlying implementation.  */\n+  tree addr = lookup_member (void_coro_handle_type, coro_address_identifier,\n+\t\t\t       1, 0, tf_warning_or_error);\n+  addr = build_new_method_call (continuation, addr, NULL, NULL_TREE,\n+\t\t\t\t  LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+  tree resume = build_call_expr_loc\n+    (loc, builtin_decl_explicit (BUILT_IN_CORO_RESUME), 1, addr);\n+\n+  /* Now we have the actual call, and we can mark it as a tail.  */\n+  CALL_EXPR_TAILCALL (resume) = true;\n+  /* ... and for optimisation levels 0..1, mark it as requiring a tail-call\n+     for correctness.  It seems that doing this for optimisation levels that\n+     normally perform tail-calling, confuses the ME (or it would be logical\n+     to put this on unilaterally).  */\n+  if (optimize < 2)\n+    CALL_EXPR_MUST_TAIL_CALL (resume) = true;\n+  resume = coro_build_cvt_void_expr_stmt (resume, loc);\n+  add_stmt (resume);\n+\n+  r = build_stmt (loc, RETURN_EXPR, NULL);\n+  gcc_checking_assert (maybe_cleanup_point_expr_void (r) == r);\n+  add_stmt (r);\n+\n+  /* We will need to know which resume point number should be encoded.  */\n   tree res_idx_m\n     = lookup_member (coro_frame_type, resume_idx_name,\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n-  tree res_idx\n+  tree resume_pt_number\n     = build_class_member_access_expr (actor_frame, res_idx_m, NULL_TREE, false,\n \t\t\t\t      tf_warning_or_error);\n \n@@ -2388,8 +2413,11 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \n   /* We've now rewritten the tree and added the initial and final\n      co_awaits.  Now pass over the tree and expand the co_awaits.  */\n-  actor_body = expand_co_awaits (actor, &actor_body, actor_fp, res_idx,\n-\t\t\t\t i_a_r_c, del_promise_label, ret_label, ash);\n+\n+  coro_aw_data data = {actor, actor_fp, resume_pt_number, i_a_r_c,\n+\t\t       ash, del_promise_label, ret_label,\n+\t\t       continue_label, continuation, 2};\n+  cp_walk_tree (&actor_body, co_await_expander, &data, NULL);\n \n   actor_body = pop_stmt_list (actor_body);\n   BIND_EXPR_BODY (actor_bind) = actor_body;\n@@ -2525,8 +2553,7 @@ build_init_or_final_await (location_t loc, bool is_final)\n    function.  */\n \n static bool\n-register_await_info (tree await_expr, tree aw_type, tree aw_nam, tree susp_type,\n-\t\t     tree susp_handle_nam)\n+register_await_info (tree await_expr, tree aw_type, tree aw_nam)\n {\n   bool seen;\n   suspend_point_info &s\n@@ -2539,8 +2566,6 @@ register_await_info (tree await_expr, tree aw_type, tree aw_nam, tree susp_type,\n     }\n   s.awaitable_type = aw_type;\n   s.await_field_id = aw_nam;\n-  s.suspend_type = susp_type;\n-  s.susp_handle_id = susp_handle_nam;\n   return true;\n }\n \n@@ -2570,26 +2595,6 @@ struct susp_frame_data\n   bool captures_temporary;\n };\n \n-/* Helper to return the type of an awaiter's await_suspend() method.\n-   We start with the result of the build method call, which will be either\n-   a call expression (void, bool) or a target expressions (handle).  */\n-\n-static tree\n-get_await_suspend_return_type (tree aw_expr)\n-{\n-  tree susp_fn = TREE_VEC_ELT (TREE_OPERAND (aw_expr, 3), 1);\n-  if (TREE_CODE (susp_fn) == CALL_EXPR)\n-    {\n-      susp_fn = CALL_EXPR_FN (susp_fn);\n-      if (TREE_CODE (susp_fn) == ADDR_EXPR)\n-\tsusp_fn = TREE_OPERAND (susp_fn, 0);\n-      return TREE_TYPE (TREE_TYPE (susp_fn));\n-    }\n-  else if (TREE_CODE (susp_fn) == TARGET_EXPR)\n-    return TREE_TYPE (susp_fn);\n-  return TREE_TYPE (susp_fn);\n-}\n-\n /* Walk the sub-tree looking for call expressions that both capture\n    references and have compiler-temporaries as parms.  */\n \n@@ -2751,31 +2756,7 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n       free (nam);\n     }\n \n-  /* Find out what we have to do with the awaiter's suspend method (this\n-     determines if we need somewhere to stash the suspend method's handle).\n-     Cache the result of this in the suspend point info.\n-     [expr.await]\n-     (5.1) If the result of await-ready is false, the coroutine is considered\n-\t   suspended. Then:\n-     (5.1.1) If the type of await-suspend is std::coroutine_handle<Z>,\n-\t     await-suspend.resume() is evaluated.\n-     (5.1.2) if the type of await-suspend is bool, await-suspend is evaluated,\n-\t     and the coroutine is resumed if the result is false.\n-     (5.1.3) Otherwise, await-suspend is evaluated.  */\n-\n-  tree susp_typ = get_await_suspend_return_type (aw_expr);\n-  tree handle_field_nam;\n-  if (VOID_TYPE_P (susp_typ) || TREE_CODE (susp_typ) == BOOLEAN_TYPE)\n-    handle_field_nam = NULL_TREE; /* no handle is needed.  */\n-  else\n-    {\n-      char *nam = xasprintf (\"__aw_h.%u\", data->count);\n-      handle_field_nam\n-\t= coro_make_frame_entry (data->field_list, nam, susp_typ, aw_loc);\n-      free (nam);\n-    }\n-  register_await_info (aw_expr, aw_field_type, aw_field_nam, susp_typ,\n-\t\t       handle_field_nam);\n+  register_await_info (aw_expr, aw_field_type, aw_field_nam);\n \n   data->count++; /* Each await suspend context is unique.  */\n \n@@ -3095,9 +3076,7 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n   handle_type self_handle;\n   (maybe) parameter copies.\n   coro1::suspend_never_prt __is;\n-  (maybe) handle_type i_hand;\n   coro1::suspend_always_prt __fs;\n-  (maybe) handle_type f_hand;\n   (maybe) local variables saved\n   (maybe) trailing space.\n  };  */\n@@ -3299,19 +3278,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree init_susp_name = coro_make_frame_entry (&field_list, \"__aw_s.is\",\n \t\t\t\t\t       initial_suspend_type, fn_start);\n \n-  /* Figure out if we need a saved handle from the awaiter type.  */\n-  tree ret_typ = get_await_suspend_return_type (initial_await);\n-  tree init_hand_name;\n-  if (VOID_TYPE_P (ret_typ) || TREE_CODE (ret_typ) == BOOLEAN_TYPE)\n-    init_hand_name = NULL_TREE; /* no handle is needed.  */\n-  else\n-    {\n-      init_hand_name\n-\t= coro_make_frame_entry (&field_list, \"__ih\", ret_typ, fn_start);\n-    }\n-\n-  register_await_info (initial_await, initial_suspend_type, init_susp_name,\n-\t\t       ret_typ, init_hand_name);\n+  register_await_info (initial_await, initial_suspend_type, init_susp_name);\n \n   /* Now insert the data for any body await points, at this time we also need\n      to promote any temporaries that are captured by reference (to regular\n@@ -3326,18 +3293,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   tree fin_susp_name = coro_make_frame_entry (&field_list, \"__aw_s.fs\",\n \t\t\t\t\t      final_suspend_type, fn_start);\n \n-  ret_typ = get_await_suspend_return_type (final_await);\n-  tree fin_hand_name;\n-  if (VOID_TYPE_P (ret_typ) || TREE_CODE (ret_typ) == BOOLEAN_TYPE)\n-    fin_hand_name = NULL_TREE; /* no handle is needed.  */\n-  else\n-    {\n-      fin_hand_name\n-\t= coro_make_frame_entry (&field_list, \"__fh\", ret_typ, fn_start);\n-    }\n-\n-  register_await_info (final_await, final_suspend_type, fin_susp_name,\n-\t\t       void_type_node, fin_hand_name);\n+  register_await_info (final_await, final_suspend_type, fin_susp_name);\n \n   /* 4. Now make space for local vars, this is conservative again, and we\n      would expect to delete unused entries later.  */"}, {"sha": "140f29633559105ae5716b77495c82c36ceda850", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "patch": "@@ -1,3 +1,10 @@\n+2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C: Amend\n+\tto n4849 behaviour.\n+\t* g++.dg/coroutines/torture/symmetric-transfer-00-basic.C: New\n+\ttest.\n+\n 2020-03-26  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* g++.dg/coroutines/torture/exceptions-test-01-n4849-a.C: New test."}, {"sha": "d14c358c4c5adc545e367085fa11dc5a0ed9a04e", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-ret-09-bool-await-susp.C", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-ret-09-bool-await-susp.C?ref=6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "patch": "@@ -4,6 +4,9 @@\n \n #include \"../coro.h\"\n \n+int coro1_dtor_ran = 0;\n+int promise_dtor_ran = 0;\n+\n struct coro1 {\n   struct promise_type;\n   using handle_type = coro::coroutine_handle<coro1::promise_type>;\n@@ -24,10 +27,13 @@ struct coro1 {\n \tPRINT(\"coro1 op=  \");\n \treturn *this;\n   }\n+\n   ~coro1() {\n         PRINT(\"Destroyed coro1\");\n-        if ( handle )\n-          handle.destroy();\n+        coro1_dtor_ran++;\n+        // The coro handle will point to an invalid frame by this stage,\n+        // the coroutine will already have self-destroyed the frame and\n+        // promise.\n   }\n \n   struct suspend_never_prt {\n@@ -51,7 +57,10 @@ struct coro1 {\n \n   struct promise_type {\n   promise_type() {  PRINT (\"Created Promise\"); }\n-  ~promise_type() { PRINT (\"Destroyed Promise\"); }\n+  ~promise_type() {\n+     PRINT (\"Destroyed Promise\"); \n+     promise_dtor_ran++;\n+   }\n \n   coro1 get_return_object () {\n     PRINT (\"get_return_object: from handle from promise\");\n@@ -73,23 +82,34 @@ struct coro1 {\n };\n \n struct coro1\n-f () noexcept\n+my_coro () noexcept\n {\n   PRINT (\"coro1: about to return\");\n   co_return;\n }\n \n int main ()\n {\n-  PRINT (\"main: create coro1\");\n-  struct coro1 x = f ();\n-  auto p = x.handle.promise ();\n-  auto aw = p.initial_suspend();\n-  auto f = aw.await_suspend(coro::coroutine_handle<coro1::promise_type>::from_address ((void *)&x));\n-  PRINT (\"main: got coro1 - should be done\");\n-  if (!x.handle.done())\n+  { // scope so that we can examine the coro dtor marker.\n+    PRINT (\"main: creating coro\");\n+\n+    // This should just run through to completion/destruction.\n+    // In both the initial and final await expressions, the await_suspend()\n+    // method will return 'false' and prevent the suspension.\n+    struct coro1 x = my_coro ();\n+\n+    PRINT (\"main: the coro frame should be already destroyed\");\n+    // We will take the running of the promise DTOR as evidence that the\n+    // frame was destroyed as expected.\n+    if (promise_dtor_ran != 1)\n+      {\n+\tPRINT (\"main: apparently we didn't destroy the frame\");\n+\tabort ();\n+      }\n+  }\n+  if (coro1_dtor_ran != 1 || promise_dtor_ran != 1)\n     {\n-      PRINT (\"main: apparently was not done...\");\n+      PRINT (\"main: bad DTOR counts\");\n       abort ();\n     }\n   PRINT (\"main: returning\");"}, {"sha": "c445fc55a2c3fc3c3bc70358c74b342bb25366ee", "filename": "gcc/testsuite/g++.dg/coroutines/torture/symmetric-transfer-00-basic.C", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d85947d23ab6a9b9975b2e0590db9308c5c1b07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fsymmetric-transfer-00-basic.C?ref=6d85947d23ab6a9b9975b2e0590db9308c5c1b07", "patch": "@@ -0,0 +1,110 @@\n+//  { dg-do run }\n+\n+#if __has_include(<coroutine>)\n+\n+#include <coroutine>\n+namespace coro = std;\n+\n+#elif __has_include(<experimental/coroutine>)\n+\n+#include <experimental/coroutine>\n+namespace coro = std::experimental;\n+\n+#endif\n+\n+#if __clang__\n+#  include <utility>\n+#endif\n+\n+#include <chrono>\n+#include <thread>\n+ \n+template <typename T> \n+struct Loopy {\n+  struct promise_type;\n+  using handle_type = coro::coroutine_handle<Loopy::promise_type>;\n+  handle_type handle;\n+\n+  struct promise_type {\n+    // Cause the Loopy object to be created from the handle.\n+    auto get_return_object () {\n+     return handle_type::from_promise (*this);\n+    }\n+\n+    coro::suspend_never yield_value(T value) {\n+      //fprintf (stderr, \"%s yields %d\\n\", me, value);\n+      current_value = value;\n+      return coro::suspend_never{};\n+    }\n+\n+    coro::suspend_always initial_suspend() { return {}; }\n+    coro::suspend_always final_suspend() { return {}; }\n+\n+    void unhandled_exception() { /*std::terminate();*/  }\n+    void return_void() {}\n+\n+    void set_peer (handle_type  _p) { peer = _p; }\n+    void set_me (const char *m) { me = m; }\n+\n+    T get_value () {return current_value;}\n+    T current_value;\n+    handle_type peer;\n+    const char *me;\n+  };\n+\n+  Loopy () : handle(0) {}\n+  Loopy (handle_type _handle) : handle(_handle) {}\n+  Loopy (const Loopy &) = delete;\n+  Loopy (Loopy &&s) : handle(s.handle) { s.handle = nullptr; }\n+  ~Loopy() { if ( handle ) handle.destroy(); }\n+\n+  struct loopy_awaiter {\n+    handle_type p;\n+    bool await_ready () { return false; }\n+    /* continue the peer. */\n+    handle_type await_suspend (handle_type h) {\n+      p = h.promise().peer;\n+      return p;\n+    }\n+    T await_resume () { return p.promise().get_value (); }\n+  };\n+};\n+\n+Loopy<int>\n+pingpong (const char *id)\n+{\n+  int v = 0;\n+  Loopy<int>::loopy_awaiter aw{};\n+  for (;;)\n+    {\n+      co_yield (v+1);\n+      //std::this_thread::sleep_for(std::chrono::milliseconds(500));\n+      if (v > 10'000'000)\n+        break;\n+      v = co_await aw;\n+      //fprintf (stderr, \"%s = %d\\n\", id, v);\n+    }\n+ fprintf (stderr, \"%s = %d\\n\", id, v);\n+}\n+\n+int main ()\n+{\n+  // identify for fun.. \n+  const char *ping_id = \"ping\";\n+  const char *pong_id = \"pong\";\n+  auto ping = pingpong (ping_id); // created suspended.\n+  auto pong = pingpong (pong_id);\n+\n+  // point them at each other...\n+  ping.handle.promise().set_peer (pong.handle);\n+  pong.handle.promise().set_peer (ping.handle);\n+\n+  ping.handle.promise().set_me (ping_id);\n+  pong.handle.promise().set_me (pong_id);\n+\n+  // and start them ...\n+  ping.handle.resume ();\n+  pong.handle.resume ();\n+  \n+}\n+"}]}