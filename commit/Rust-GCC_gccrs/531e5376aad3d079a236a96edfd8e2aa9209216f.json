{"sha": "531e5376aad3d079a236a96edfd8e2aa9209216f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMxZTUzNzZhYWQzZDA3OWEyMzZhOTZlZGZkOGUyYWE5MjA5MjE2Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-11-15T23:20:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-11-15T23:20:13Z"}, "message": "loop-unroll.c (analyze_insn_to_expand_var): Accept\n\n\t* loop-unroll.c (analyze_insn_to_expand_var): Accept\n\t* accumulation\n\tvia FMA if unsafe math.\n\t(insert_var_expansion_initialization): Handle FMA.\n\t(combine_var_copies_in_loop_exit): Likewise.\n\nFrom-SVN: r166781", "tree": {"sha": "3e1e4987d7ed15774c67ae03fc62ca57335b7400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e1e4987d7ed15774c67ae03fc62ca57335b7400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531e5376aad3d079a236a96edfd8e2aa9209216f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531e5376aad3d079a236a96edfd8e2aa9209216f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531e5376aad3d079a236a96edfd8e2aa9209216f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531e5376aad3d079a236a96edfd8e2aa9209216f/comments", "author": null, "committer": null, "parents": [{"sha": "f19f1e5ef02840325ed579ffa0fb8d2ff82f9b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19f1e5ef02840325ed579ffa0fb8d2ff82f9b35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19f1e5ef02840325ed579ffa0fb8d2ff82f9b35"}], "stats": {"total": 161, "additions": 98, "deletions": 63}, "files": [{"sha": "f538ae88d80657c714b4bf139d51eb577bdb7f17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531e5376aad3d079a236a96edfd8e2aa9209216f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531e5376aad3d079a236a96edfd8e2aa9209216f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=531e5376aad3d079a236a96edfd8e2aa9209216f", "patch": "@@ -1,3 +1,10 @@\n+2010-11-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* loop-unroll.c (analyze_insn_to_expand_var): Accept accumulation\n+\tvia FMA if unsafe math.\n+\t(insert_var_expansion_initialization): Handle FMA.\n+\t(combine_var_copies_in_loop_exit): Likewise.\n+\n 2010-11-15  Richard Henderson  <rth@redhat.com>\n \n \t* config.gcc [ia64-*] (extra_options): Add fused-madd.opt."}, {"sha": "67d6ea0cf64deab1ba7d9811d23007691d947b68", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531e5376aad3d079a236a96edfd8e2aa9209216f/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531e5376aad3d079a236a96edfd8e2aa9209216f/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=531e5376aad3d079a236a96edfd8e2aa9209216f", "patch": "@@ -1616,10 +1616,10 @@ reset_debug_uses_in_loop (struct loop *loop, rtx reg, int debug_uses)\n static struct var_to_expand *\n analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n {\n-  rtx set, dest, src, op1, op2, something;\n+  rtx set, dest, src;\n   struct var_to_expand *ves;\n-  enum machine_mode mode1, mode2;\n   unsigned accum_pos;\n+  enum rtx_code code;\n   int debug_uses = 0;\n \n   set = single_set (insn);\n@@ -1628,12 +1628,20 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n \n   dest = SET_DEST (set);\n   src = SET_SRC (set);\n+  code = GET_CODE (src);\n \n-  if (GET_CODE (src) != PLUS\n-      && GET_CODE (src) != MINUS\n-      && GET_CODE (src) != MULT)\n+  if (code != PLUS && code != MINUS && code != MULT && code != FMA)\n     return NULL;\n \n+  if (FLOAT_MODE_P (GET_MODE (dest)))\n+    {\n+      if (!flag_associative_math)\n+        return NULL;\n+      /* In the case of FMA, we're also changing the rounding.  */\n+      if (code == FMA && !flag_unsafe_math_optimizations)\n+\treturn NULL;\n+    }\n+\n   /* Hmm, this is a bit paradoxical.  We know that INSN is a valid insn\n      in MD.  But if there is no optab to generate the insn, we can not\n      perform the variable expansion.  This can happen if an MD provides\n@@ -1643,54 +1651,57 @@ analyze_insn_to_expand_var (struct loop *loop, rtx insn)\n      So we check have_insn_for which looks for an optab for the operation\n      in SRC.  If it doesn't exist, we can't perform the expansion even\n      though INSN is valid.  */\n-  if (!have_insn_for (GET_CODE (src), GET_MODE (src)))\n+  if (!have_insn_for (code, GET_MODE (src)))\n     return NULL;\n \n-  op1 = XEXP (src, 0);\n-  op2 = XEXP (src, 1);\n-\n   if (!REG_P (dest)\n       && !(GET_CODE (dest) == SUBREG\n            && REG_P (SUBREG_REG (dest))))\n     return NULL;\n \n-  if (rtx_equal_p (dest, op1))\n+  /* Find the accumulator use within the operation.  */\n+  if (code == FMA)\n+    {\n+      /* We only support accumulation via FMA in the ADD position.  */\n+      if (!rtx_equal_p  (dest, XEXP (src, 2)))\n+\treturn NULL;\n+      accum_pos = 2;\n+    }\n+  else if (rtx_equal_p (dest, XEXP (src, 0)))\n     accum_pos = 0;\n-  else if (rtx_equal_p (dest, op2))\n-    accum_pos = 1;\n+  else if (rtx_equal_p (dest, XEXP (src, 1)))\n+    {\n+      /* The method of expansion that we are using; which includes the\n+\t initialization of the expansions with zero and the summation of\n+         the expansions at the end of the computation will yield wrong\n+\t results for (x = something - x) thus avoid using it in that case.  */\n+      if (code == MINUS)\n+\treturn NULL;\n+      accum_pos = 1;\n+    }\n   else\n     return NULL;\n \n-  /* The method of expansion that we are using; which includes\n-     the initialization of the expansions with zero and the summation of\n-     the expansions at the end of the computation will yield wrong results\n-     for (x = something - x) thus avoid using it in that case.  */\n-  if (accum_pos == 1\n-      && GET_CODE (src) == MINUS)\n-   return NULL;\n-\n-  something = (accum_pos == 0) ? op2 : op1;\n-\n-  if (rtx_referenced_p (dest, something))\n+  /* It must not otherwise be used.  */\n+  if (code == FMA)\n+    {\n+      if (rtx_referenced_p (dest, XEXP (src, 0))\n+\t  || rtx_referenced_p (dest, XEXP (src, 1)))\n+\treturn NULL;\n+    }\n+  else if (rtx_referenced_p (dest, XEXP (src, 1 - accum_pos)))\n     return NULL;\n \n+  /* It must be used in exactly one insn.  */\n   if (!referenced_in_one_insn_in_loop_p (loop, dest, &debug_uses))\n     return NULL;\n \n-  mode1 = GET_MODE (dest);\n-  mode2 = GET_MODE (something);\n-  if ((FLOAT_MODE_P (mode1)\n-       || FLOAT_MODE_P (mode2))\n-      && !flag_associative_math)\n-    return NULL;\n-\n   if (dump_file)\n-  {\n-    fprintf (dump_file,\n-    \"\\n;; Expanding Accumulator \");\n-    print_rtl (dump_file, dest);\n-    fprintf (dump_file, \"\\n\");\n-  }\n+    {\n+      fprintf (dump_file, \"\\n;; Expanding Accumulator \");\n+      print_rtl (dump_file, dest);\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n   if (debug_uses)\n     /* Instead of resetting the debug insns, we could replace each\n@@ -2123,22 +2134,33 @@ insert_var_expansion_initialization (struct var_to_expand *ve,\n     return;\n \n   start_sequence ();\n-  if (ve->op == PLUS || ve->op == MINUS)\n-    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n-      {\n-\tif (honor_signed_zero_p)\n-\t  zero_init = simplify_gen_unary (NEG, mode, CONST0_RTX (mode), mode);\n-\telse\n-\t  zero_init = CONST0_RTX (mode);\n+  switch (ve->op)\n+    {\n+    case FMA:\n+      /* Note that we only accumulate FMA via the ADD operand.  */\n+    case PLUS:\n+    case MINUS:\n+      FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n+        {\n+\t  if (honor_signed_zero_p)\n+\t    zero_init = simplify_gen_unary (NEG, mode, CONST0_RTX (mode), mode);\n+\t  else\n+\t    zero_init = CONST0_RTX (mode);\n+          emit_move_insn (var, zero_init);\n+        }\n+      break;\n \n-        emit_move_insn (var, zero_init);\n-      }\n-  else if (ve->op == MULT)\n-    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n-      {\n-        zero_init =  CONST1_RTX (GET_MODE (var));\n-        emit_move_insn (var, zero_init);\n-      }\n+    case MULT:\n+      FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n+        {\n+          zero_init = CONST1_RTX (GET_MODE (var));\n+          emit_move_insn (var, zero_init);\n+        }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   seq = get_insns ();\n   end_sequence ();\n@@ -2165,18 +2187,24 @@ combine_var_copies_in_loop_exit (struct var_to_expand *ve, basic_block place)\n     return;\n \n   start_sequence ();\n-  if (ve->op == PLUS || ve->op == MINUS)\n-    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n-      {\n-        sum = simplify_gen_binary (PLUS, GET_MODE (ve->reg),\n-                                   var, sum);\n-      }\n-  else if (ve->op == MULT)\n-    FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n-      {\n-        sum = simplify_gen_binary (MULT, GET_MODE (ve->reg),\n-                                   var, sum);\n-      }\n+  switch (ve->op)\n+    {\n+    case FMA:\n+      /* Note that we only accumulate FMA via the ADD operand.  */\n+    case PLUS:\n+    case MINUS:\n+      FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n+\tsum = simplify_gen_binary (PLUS, GET_MODE (ve->reg), var, sum);\n+      break;\n+\n+    case MULT:\n+      FOR_EACH_VEC_ELT (rtx, ve->var_expansions, i, var)\n+\tsum = simplify_gen_binary (MULT, GET_MODE (ve->reg), var, sum);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   expr = force_operand (sum, ve->reg);\n   if (expr != ve->reg)"}]}