{"sha": "4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmMDdmM2Y1ZmI0ZmVmYTI3MDJlY2VkMjI5MWVlNWQ5Y2I1YWQ0OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-01-04T15:23:40Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-01-04T15:23:40Z"}, "message": "re PR c++/66735 ([C++14] lambda init-capture fails for const references)\n\n\tcp/\n\tPR c++/66735\n\t* cp-tree.h (DECLTYPE_FOR_REF_CAPTURE): New.\n\t(lambda_capture_field_type): Update prototype.\n\t* lambda.c (lambda_capture_field_type): Add is_reference parm.\n\tAdd referenceness here.\n\t(add_capture): Adjust lambda_capture_field_type call, refactor\n\terror checking.\n\t* pt.c (tsubst): Adjust lambda_capture_field_type call.\n\n\ttestsuite/\n\tPR c++/66735\n\t* g++.dg/cpp1y/pr66735.C: New.\n\nFrom-SVN: r244056", "tree": {"sha": "9781542b18502d109be586512755bffbd4ea4100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9781542b18502d109be586512755bffbd4ea4100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65793e420e34fa140025b1b2d68d84e25f305f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65793e420e34fa140025b1b2d68d84e25f305f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65793e420e34fa140025b1b2d68d84e25f305f63"}], "stats": {"total": 88, "additions": 75, "deletions": 13}, "files": [{"sha": "71aada7970c5b5dbe6ca5fa750d8cb56b1d0f89e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -1,3 +1,14 @@\n+2017-01-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/66735\n+\t* cp-tree.h (DECLTYPE_FOR_REF_CAPTURE): New.\n+\t(lambda_capture_field_type): Update prototype.\n+\t* lambda.c (lambda_capture_field_type): Add is_reference parm.\n+\tAdd referenceness here.\n+\t(add_capture): Adjust lambda_capture_field_type call, refactor\n+\terror checking.\n+\t* pt.c (tsubst): Adjust lambda_capture_field_type call.\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "39f5d790cdc469515e13d2b807a42b79147d11f6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -181,6 +181,7 @@ operator == (const cp_expr &lhs, tree rhs)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n       DECL_NON_TRIVIALLY_INITIALIZED_P (in VAR_DECL)\n       CALL_EXPR_ORDERED_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n+      DECLTYPE_FOR_REF_CAPTURE (in DECLTYPE_TYPE)\n    4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n \t  CALL_EXPR, or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n@@ -4103,6 +4104,8 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))\n #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \\\n   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))\n+#define DECLTYPE_FOR_REF_CAPTURE(NODE) \\\n+  TREE_LANG_FLAG_3 (DECLTYPE_TYPE_CHECK (NODE))\n \n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  This can also be set for an\n@@ -6528,7 +6531,7 @@ extern tree finish_trait_expr\t\t\t(enum cp_trait_kind, tree, tree);\n extern tree build_lambda_expr                   (void);\n extern tree build_lambda_object\t\t\t(tree);\n extern tree begin_lambda_type                   (tree);\n-extern tree lambda_capture_field_type\t\t(tree, bool);\n+extern tree lambda_capture_field_type\t\t(tree, bool, bool);\n extern tree lambda_return_type\t\t\t(tree);\n extern tree lambda_proxy_type\t\t\t(tree);\n extern tree lambda_function\t\t\t(tree);"}, {"sha": "98fdb740a742f3366d95fe3db5555413586c5359", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -211,29 +211,45 @@ lambda_function (tree lambda)\n }\n \n /* Returns the type to use for the FIELD_DECL corresponding to the\n-   capture of EXPR.\n-   The caller should add REFERENCE_TYPE for capture by reference.  */\n+   capture of EXPR.  EXPLICIT_INIT_P indicates whether this is a\n+   C++14 init capture, and BY_REFERENCE_P indicates whether we're\n+   capturing by reference.  */\n \n tree\n-lambda_capture_field_type (tree expr, bool explicit_init_p)\n+lambda_capture_field_type (tree expr, bool explicit_init_p,\n+\t\t\t   bool by_reference_p)\n {\n   tree type;\n   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));\n+\n   if (!is_this && type_dependent_expression_p (expr))\n     {\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;\n       DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;\n       DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;\n+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;\n       SET_TYPE_STRUCTURAL_EQUALITY (type);\n     }\n   else if (!is_this && explicit_init_p)\n     {\n-      type = make_auto ();\n-      type = do_auto_deduction (type, expr, type);\n+      tree auto_node = make_auto ();\n+      \n+      type = auto_node;\n+      if (by_reference_p)\n+\t/* Add the reference now, so deduction doesn't lose\n+\t   outermost CV qualifiers of EXPR.  */\n+\ttype = build_reference_type (type);\n+      type = do_auto_deduction (type, expr, auto_node);\n     }\n   else\n-    type = non_reference (unlowered_expr_type (expr));\n+    {\n+      type = non_reference (unlowered_expr_type (expr));\n+\n+      if (!is_this && by_reference_p)\n+\ttype = build_reference_type (type);\n+    }\n+\n   return type;\n }\n \n@@ -504,27 +520,31 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n     }\n   else\n     {\n-      type = lambda_capture_field_type (initializer, explicit_init_p);\n+      type = lambda_capture_field_type (initializer, explicit_init_p,\n+\t\t\t\t\tby_reference_p);\n       if (type == error_mark_node)\n \treturn error_mark_node;\n+\n       if (id == this_identifier && !by_reference_p)\n \t{\n \t  gcc_assert (POINTER_TYPE_P (type));\n \t  type = TREE_TYPE (type);\n \t  initializer = cp_build_indirect_ref (initializer, RO_NULL,\n \t\t\t\t\t       tf_warning_or_error);\n \t}\n-      if (id != this_identifier && by_reference_p)\n+\n+      if (dependent_type_p (type))\n+\t;\n+      else if (id != this_identifier && by_reference_p)\n \t{\n-\t  type = build_reference_type (type);\n-\t  if (!dependent_type_p (type) && !lvalue_p (initializer))\n+\t  if (!lvalue_p (initializer))\n \t    error (\"cannot capture %qE by reference\", initializer);\n \t}\n       else\n \t{\n \t  /* Capture by copy requires a complete type.  */\n \t  type = complete_type (type);\n-\t  if (!dependent_type_p (type) && !COMPLETE_TYPE_P (type))\n+\t  if (!COMPLETE_TYPE_P (type))\n \t    {\n \t      error (\"capture by copy of incomplete type %qT\", type);\n \t      cxx_incomplete_type_inform (type);"}, {"sha": "51c3c57b009f74758b12073a58d24a4417c2ab4f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -13988,7 +13988,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n \tif (DECLTYPE_FOR_LAMBDA_CAPTURE (t))\n \t  type = lambda_capture_field_type (type,\n-\t\t\t\t\t    DECLTYPE_FOR_INIT_CAPTURE (t));\n+\t\t\t\t\t    DECLTYPE_FOR_INIT_CAPTURE (t),\n+\t\t\t\t\t    DECLTYPE_FOR_REF_CAPTURE (t));\n \telse if (DECLTYPE_FOR_LAMBDA_PROXY (t))\n \t  type = lambda_proxy_type (type);\n \telse"}, {"sha": "65f636054354c40bb21ce7fd3e7f8f41208781e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -1,3 +1,8 @@\n+2017-01-04  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/66735\n+\t* g++.dg/cpp1y/pr66735.C: New.\n+\n 2017-01-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/71563"}, {"sha": "2d81fb880ef2760cf1fc8ec2fe8bc9f202e6481f", "filename": "gcc/testsuite/g++.dg/cpp1y/pr66735.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr66735.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr66735.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr66735.C?ref=4bf07f3f5fb4fefa2702eced2291ee5d9cb5ad48", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile { target c++14 } }\n+\n+// PR c++/66735, lost constness on reference capture\n+\n+template <typename T> void Foo ()\n+{\n+  T const x = 5;\n+\n+  auto l = [&rx = x]() {};\n+\n+  l ();\n+}\n+\n+void Baz ()\n+{\n+  int const x = 5;\n+  auto l = [&rx = x]() {};\n+\n+\n+  l ();\n+  Foo<int> ();\n+}"}]}