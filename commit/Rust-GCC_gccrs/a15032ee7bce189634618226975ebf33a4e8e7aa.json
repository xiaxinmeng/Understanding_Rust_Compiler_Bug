{"sha": "a15032ee7bce189634618226975ebf33a4e8e7aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1MDMyZWU3YmNlMTg5NjM0NjE4MjI2OTc1ZWJmMzNhNGU4ZTdhYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-15T00:04:19Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-15T00:04:19Z"}, "message": "Optimize pool resource allocation\n\nA recent change caused a performance regression. This restores the\nprevious performance and adds a performance test.\n\n\t* scripts/check_performance: Allow tests to choose a -std flag.\n\t* src/c++17/memory_resource.cc (bitset::get_first_unset()): Use local\n\tvariables of the right types. Call update_next_word() unconditionally.\n\t* testsuite/20_util/unsynchronized_pool_resource/cons.cc: New test.\n\t* testsuite/performance/20_util/memory_resource/pools.cc: New test.\n\t* testsuite/util/testsuite_performance.h (time_counter): Allow\n\ttimer to be restarted.\n\nFrom-SVN: r266164", "tree": {"sha": "b0952465e1c2f6afda1f2146fb03002de2d0b1d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0952465e1c2f6afda1f2146fb03002de2d0b1d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a15032ee7bce189634618226975ebf33a4e8e7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15032ee7bce189634618226975ebf33a4e8e7aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a15032ee7bce189634618226975ebf33a4e8e7aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a15032ee7bce189634618226975ebf33a4e8e7aa/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb2b1f7fbe1907f6ff6feaac4f042decd895765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb2b1f7fbe1907f6ff6feaac4f042decd895765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb2b1f7fbe1907f6ff6feaac4f042decd895765"}], "stats": {"total": 241, "additions": 230, "deletions": 11}, "files": [{"sha": "85e79eae8b2e60e939bb1cb09ce2b2eb9adbe8e8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -1,5 +1,13 @@\n 2018-11-15  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* scripts/check_performance: Allow tests to choose a -std flag.\n+\t* src/c++17/memory_resource.cc (bitset::get_first_unset()): Use local\n+\tvariables of the right types. Call update_next_word() unconditionally.\n+\t* testsuite/20_util/unsynchronized_pool_resource/cons.cc: New test.\n+\t* testsuite/performance/20_util/memory_resource/pools.cc: New test.\n+\t* testsuite/util/testsuite_performance.h (time_counter): Allow\n+\ttimer to be restarted.\n+\n \t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc: Fix\n \ttest for 32-bit targets. Test additional allocation sizes.\n "}, {"sha": "3fa927480c9ea714270ac9ac4c12fe79712b049d", "filename": "libstdc++-v3/scripts/check_performance", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcheck_performance?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -44,6 +44,8 @@ do\n   TESTNAME=$SRC_DIR/testsuite/$NAME\n   FILE_NAME=\"`basename $NAME`\"\n   FILE_NAME=\"`echo $FILE_NAME | sed 's/.cc//g'`\"\n+  ORIG_CXX=\"$CXX\"\n+  CXX=\"$CXX `sed -n 's/.* STD=/-std=/p' $TESTNAME`\"\n \n   # TEST_S == single thread\n   # TEST_B == do both single and multi-thread\n@@ -90,6 +92,7 @@ do\n \tmv tmp.$FILE_NAME $FILE_NAME.xml\n     fi\n   fi\n+  CXX=\"$ORIG_CXX\"\n done\n \n exit 0"}, {"sha": "79c1665146d6eebe6c971e9fd98fbd2ffee442f4", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -335,17 +335,16 @@ namespace pmr\n \n     size_type get_first_unset() noexcept\n     {\n-      if (_M_next_word < nwords())\n+      const size_type wd = _M_next_word;\n+      if (wd < nwords())\n \t{\n-\t  const size_type n = std::__countr_one(_M_words[_M_next_word]);\n+\t  const size_type n = std::__countr_one(_M_words[wd]);\n \t  if (n < bits_per_word)\n \t    {\n \t      const word bit = word(1) << n;\n-\t      _M_words[_M_next_word] |= bit;\n-\t      const size_t res = (_M_next_word * bits_per_word) + n;\n-\t      if (n == (bits_per_word - 1))\n-\t\tupdate_next_word();\n-\t      return res;\n+\t      _M_words[wd] |= bit;\n+\t      update_next_word();\n+\t      return (wd * bits_per_word) + n;\n \t    }\n \t}\n       return size_type(-1);"}, {"sha": "14519ba1d006f3c1aaf5e898bfa01b1a516cc5ca", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/cons.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fcons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fcons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fcons.cc?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory_resource>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+void\n+test01()\n+{\n+  __gnu_test::memory_resource test_mr1, test_mr2;\n+  __gnu_test::default_resource_mgr mgr(&test_mr1);\n+\n+  const std::pmr::pool_options opts{1, 2};\n+  using std::pmr::unsynchronized_pool_resource;\n+\n+  unsynchronized_pool_resource p1 = {opts, &test_mr2};\n+  VERIFY( p1.upstream_resource() == &test_mr2 );\n+  unsynchronized_pool_resource p2;\n+  VERIFY( p2.upstream_resource() == std::pmr::get_default_resource() );\n+  unsynchronized_pool_resource p3{&test_mr2};\n+  VERIFY( p3.upstream_resource() == &test_mr2 );\n+  unsynchronized_pool_resource p4{opts};\n+  VERIFY( p4.upstream_resource() == std::pmr::get_default_resource() );\n+\n+  static_assert(!std::is_copy_constructible_v<unsynchronized_pool_resource>);\n+  static_assert(!std::is_copy_assignable_v<unsynchronized_pool_resource>);\n+  static_assert(std::is_destructible_v<unsynchronized_pool_resource>);\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::memory_resource test_mr1, test_mr2;\n+  __gnu_test::default_resource_mgr mgr(&test_mr1);\n+\n+  const std::pmr::pool_options opts{1, 2};\n+\n+  struct derived : std::pmr::unsynchronized_pool_resource\n+  {\n+    using unsynchronized_pool_resource::unsynchronized_pool_resource;\n+  };\n+\n+  derived p1 = {opts, &test_mr2};\n+  VERIFY( p1.upstream_resource() == &test_mr2 );\n+  derived p2;\n+  VERIFY( p2.upstream_resource() == std::pmr::get_default_resource() );\n+  derived p3{&test_mr2};\n+  VERIFY( p3.upstream_resource() == &test_mr2 );\n+  derived p4{opts};\n+  VERIFY( p4.upstream_resource() == std::pmr::get_default_resource() );\n+\n+  static_assert(!std::is_copy_constructible_v<derived>);\n+  static_assert(!std::is_copy_assignable_v<derived>);\n+  static_assert(std::is_destructible_v<derived>);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "77f37fe63b265f6bd5764dbfd1ab2cacae4c52e6", "filename": "libstdc++-v3/testsuite/performance/20_util/memory_resource/pools.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F20_util%2Fmemory_resource%2Fpools.cc?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -0,0 +1,114 @@\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Override the -std flag in the check_performance script: STD=gnu++17\n+\n+#include <memory_resource>\n+#include <list>\n+#include <string>\n+#include <testsuite_performance.h>\n+\n+struct size16 { char c[16]; };\n+struct size32 { char c[32]; };\n+struct size64 { char c[64]; };\n+struct size128 { char c[128]; };\n+\n+// Insert and remove elements of various sizes in std::list containers.\n+// If report=true the function will measure and report the total performance\n+// including the time taken to destroy the lists and deallocate everything.\n+// If dest=false the function will measure and report the performance of\n+// insert/remove operations only, not the destruction of the lists.\n+void\n+populate_lists(std::pmr::memory_resource* r, std::string name, bool dest,\n+\t       int kmax = 100)\n+{\n+  name += \" std::list push/pop\";\n+  if (dest)\n+    name += \"/destroy\";\n+\n+  std::pmr::list<int> l4(r);\n+  std::pmr::list<size16> l16(r);\n+  std::pmr::list<size32> l32(r);\n+  std::pmr::list<size64> l64(r);\n+  std::pmr::list<size128> l128(r);\n+\n+  using namespace __gnu_test;\n+  time_counter time;\n+  resource_counter resource;\n+  start_counters(time, resource);\n+\n+  const int imax = 1000;\n+  const int jmax = 100;\n+  for (int k = 0; k < kmax; ++k)\n+  {\n+    for (int i = 0; i < imax; ++i)\n+    {\n+      for (int j = 0; j < jmax; ++j)\n+      {\n+        l4.emplace_back();\n+        l16.emplace_back();\n+        l32.emplace_back();\n+        l64.emplace_back();\n+        l128.emplace_back();\n+      }\n+      l4.pop_front();\n+      l16.pop_front();\n+      l32.pop_front();\n+      l64.pop_front();\n+      l128.pop_front();\n+    }\n+\n+    if (!dest)\n+      time.stop();\n+\n+    // Deallocate everything:\n+    l4.clear();\n+    l16.clear();\n+    l32.clear();\n+    l64.clear();\n+    l128.clear();\n+\n+    if (!dest)\n+      time.restart();\n+  }\n+\n+  stop_counters(time, resource);\n+\n+  report_performance(__FILE__, name.c_str(), time, resource);\n+  clear_counters(time, resource);\n+}\n+\n+int main()\n+{\n+  std::pmr::memory_resource* newdel = std::pmr::new_delete_resource();\n+  std::pmr::unsynchronized_pool_resource pool;\n+\n+  for (auto b : { false, true })\n+  {\n+    // Start with an empty set of pools:\n+    pool.release();\n+\n+    populate_lists(newdel, \"new_delete 1\", b);\n+    populate_lists(newdel, \"new_delete 2\", b);\n+    populate_lists(newdel, \"new_delete 3\", b);\n+\n+    populate_lists(&pool, \"unsync pool 1\", b);\n+    // Destroy pools and start fresh:\n+    pool.release();\n+    populate_lists(&pool, \"unsync pool 2\", b);\n+    // Do not destroy pools, reuse allocated memory:\n+    populate_lists(&pool, \"unsync pool 3\", b);\n+  }\n+}"}, {"sha": "38ec35d4c456506b3f1c333a58caec7ab90e66f8", "filename": "libstdc++-v3/testsuite/util/testsuite_performance.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a15032ee7bce189634618226975ebf33a4e8e7aa/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_performance.h?ref=a15032ee7bce189634618226975ebf33a4e8e7aa", "patch": "@@ -79,10 +79,12 @@ namespace __gnu_test\n     clock_t\telapsed_end;\n     tms\t\ttms_begin;\n     tms\t\ttms_end;\n+    std::size_t splits[3];\n \n   public:\n     explicit\n-    time_counter() : elapsed_begin(), elapsed_end(), tms_begin(), tms_end()\n+    time_counter()\n+    : elapsed_begin(), elapsed_end(), tms_begin(), tms_end(), splits()\n     { }\n \n     void\n@@ -92,6 +94,7 @@ namespace __gnu_test\n       elapsed_end = clock_t();\n       tms_begin = tms();\n       tms_end = tms();\n+      splits[0] = splits[1] = splits[2] = 0;\n     }\n \n     void\n@@ -113,17 +116,29 @@ namespace __gnu_test\n \tstd::__throw_runtime_error(\"time_counter::stop\");\n     }\n \n+    void\n+    restart()\n+    {\n+      splits[0] += (elapsed_end - elapsed_begin);\n+      splits[1] += (tms_end.tms_utime - tms_begin.tms_utime);\n+      splits[2] += (tms_end.tms_stime - tms_begin.tms_stime);\n+      elapsed_begin = times(&tms_begin);\n+      const clock_t err = clock_t(-1);\n+      if (elapsed_begin == err)\n+\tstd::__throw_runtime_error(\"time_counter::restart\");\n+    }\n+\n     std::size_t\n     real_time() const\n-    { return elapsed_end - elapsed_begin; }\n+    { return (elapsed_end - elapsed_begin) + splits[0]; }\n \n     std::size_t\n     user_time() const\n-    { return tms_end.tms_utime - tms_begin.tms_utime; }\n+    { return (tms_end.tms_utime - tms_begin.tms_utime) + splits[1]; }\n \n     std::size_t\n     system_time() const\n-    { return tms_end.tms_stime - tms_begin.tms_stime; }\n+    { return (tms_end.tms_stime - tms_begin.tms_stime) + splits[1]; }\n   };\n \n   class resource_counter"}]}