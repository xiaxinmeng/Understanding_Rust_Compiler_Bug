{"sha": "b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVhNDMwZjM0NjA5M2FiYTFjYjFlMjhhYTdmOTI0MDVlNjhiMGNjZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-01-04T00:15:08Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-01-04T00:15:08Z"}, "message": "re PR middle-end/38584 (Inline heuristics run even at -O0)\n\n\tPR middle-end/38584\n\t* cfgexpand.c (estimate_stack_frame_size): Simplify the estimate:\n\tCalculate the size of all stack vars assuming no packing of stack\n\tvars will happen, replacing a quadratic algorithm with a linear one.\n\nFrom-SVN: r143040", "tree": {"sha": "6dff999c194db54678145714a827cd983e40b506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dff999c194db54678145714a827cd983e40b506"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5a430f346093aba1cb1e28aa7f92405e68b0ccd/comments", "author": null, "committer": null, "parents": [{"sha": "5a47fc2f955ddee6b4a061f51a75aad555dcc4ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a47fc2f955ddee6b4a061f51a75aad555dcc4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a47fc2f955ddee6b4a061f51a75aad555dcc4ab"}], "stats": {"total": 40, "additions": 22, "deletions": 18}, "files": [{"sha": "2c5a9399979a5bcae2ad47d5c230e9497bc1df53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a430f346093aba1cb1e28aa7f92405e68b0ccd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a430f346093aba1cb1e28aa7f92405e68b0ccd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "patch": "@@ -1,3 +1,10 @@\n+2009-01-04  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/38584\n+\t* cfgexpand.c (estimate_stack_frame_size): Simplify the estimate:\n+\tCalculate the size of all stack vars assuming no packing of stack\n+\tvars will happen, replacing a quadratic algorithm with a linear one.\n+\n 2009-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/38707"}, {"sha": "e0c328f3959170ae5e30200c52bc8dd82827f7b6", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5a430f346093aba1cb1e28aa7f92405e68b0ccd/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5a430f346093aba1cb1e28aa7f92405e68b0ccd/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b5a430f346093aba1cb1e28aa7f92405e68b0ccd", "patch": "@@ -1392,16 +1392,23 @@ fini_vars_expansion (void)\n   stack_vars_conflict_alloc = 0;\n }\n \n+/* Make a fair guess for the size of the stack frame of the current\n+   function.  This doesn't have to be exact, the result is only used\n+   in the inline heuristics.  So we don't want to run the full stack\n+   var packing algorithm (which is quadratic in the number of stack\n+   vars).  Instead, we calculate the total size of all stack vars.\n+   This turns out to be a pretty fair estimate -- packing of stack\n+   vars doesn't happen very often.  */\n+\n HOST_WIDE_INT\n estimated_stack_frame_size (void)\n {\n   HOST_WIDE_INT size = 0;\n+  size_t i;\n   tree t, outer_block = DECL_INITIAL (current_function_decl);\n \n   init_vars_expansion ();\n \n-  /* At this point all variables on the local_decls with TREE_USED\n-     set are not associated with any block scope.  Lay them out.  */\n   for (t = cfun->local_decls; t; t = TREE_CHAIN (t))\n     {\n       tree var = TREE_VALUE (t);\n@@ -1411,27 +1418,17 @@ estimated_stack_frame_size (void)\n       TREE_USED (var) = 1;\n     }\n   size += account_used_vars_for_block (outer_block, true);\n+\n   if (stack_vars_num > 0)\n     {\n-      /* Due to the way alias sets work, no variables with non-conflicting\n-\t alias sets may be assigned the same address.  Add conflicts to\n-\t reflect this.  */\n-      add_alias_set_conflicts ();\n-\n-      /* If stack protection is enabled, we don't share space between\n-\t vulnerable data and non-vulnerable data.  */\n-      if (flag_stack_protect)\n-\tadd_stack_protection_conflicts ();\n-\n-      /* Now that we have collected all stack variables, and have computed a\n-\t minimal interference graph, attempt to save some stack space.  */\n-      partition_stack_vars ();\n-      if (dump_file)\n-\tdump_stack_var_partition ();\n-\n+      /* Fake sorting the stack vars for account_stack_vars ().  */\n+      stack_vars_sorted = XNEWVEC (size_t, stack_vars_num);\n+      for (i = 0; i < stack_vars_num; ++i)\n+\tstack_vars_sorted[i] = i;\n       size += account_stack_vars ();\n       fini_vars_expansion ();\n     }\n+\n   return size;\n }\n "}]}