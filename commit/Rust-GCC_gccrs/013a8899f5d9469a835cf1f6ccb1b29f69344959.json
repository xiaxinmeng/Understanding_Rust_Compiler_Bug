{"sha": "013a8899f5d9469a835cf1f6ccb1b29f69344959", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzYTg4OTlmNWQ5NDY5YTgzNWNmMWY2Y2NiMWIyOWY2OTM0NDk1OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-21T05:56:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-21T05:56:37Z"}, "message": "[PATCH] Move RTL printing code from sched-vis.c into print-rtl.c\n\n\t* Makefile.in (OBJS): Remove sched-vis.c\n\t* sched-vis.c: Removed.  Code moved into...\n\t* print-rtl.c: Here.  Include cfg.h, pretty-print.h and print-rtl.h.\n\t* rtl.h: Remove prototypes for functions now living in print-rtl.c\n\t* print-rtl.h Add prototypes for new functions in print-rtl.c.\n\t* auto-inc-dec.c: Include print-rtl.h\n\t* cfgrtl.c, combine.c, final.c haifa-sched.c: Likewise.\n\t* ira.c, lra-constraints.c, lra.c, sel-sched-dump.c: Likewise.\n\nFrom-SVN: r229110", "tree": {"sha": "b979668a4c5c504c3719f71d3e2973d957457776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b979668a4c5c504c3719f71d3e2973d957457776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/013a8899f5d9469a835cf1f6ccb1b29f69344959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013a8899f5d9469a835cf1f6ccb1b29f69344959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013a8899f5d9469a835cf1f6ccb1b29f69344959", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013a8899f5d9469a835cf1f6ccb1b29f69344959/comments", "author": null, "committer": null, "parents": [{"sha": "84c25fb51158da95d010b755a186b4c0a2e1a0d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c25fb51158da95d010b755a186b4c0a2e1a0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c25fb51158da95d010b755a186b4c0a2e1a0d2"}], "stats": {"total": 1829, "additions": 907, "deletions": 922}, "files": [{"sha": "c3ed26af9c0cd4f163f12052d2961b27203b00d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -1,5 +1,14 @@\n 2015-10-21  Jeff Law  <law@redhat.com>\n \n+\t* Makefile.in (OBJS): Remove sched-vis.c\n+\t* sched-vis.c: Removed.  Code moved into...\n+\t* print-rtl.c: Here.  Include cfg.h, pretty-print.h and print-rtl.h.\n+\t* rtl.h: Remove prototypes for functions now living in print-rtl.c\n+\t* print-rtl.h Add prototypes for new functions in print-rtl.c.\n+\t* auto-inc-dec.c: Include print-rtl.h\n+\t* cfgrtl.c, combine.c, final.c haifa-sched.c: Likewise.\n+\t* ira.c, lra-constraints.c, lra.c, sel-sched-dump.c: Likewise.\n+\n \t* varasm.c (handle_vtv_comdat_section): Mark 2nd parameter with\n \tATTRIBUTE_UNUSED.\n "}, {"sha": "f7137ee7552b611800fa1a8972f2dd14d9b9d3bb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -1385,7 +1385,6 @@ OBJS = \\\n \tsched-deps.o \\\n \tsched-ebb.o \\\n \tsched-rgn.o \\\n-\tsched-vis.o \\\n \tsdbout.o \\\n \tsel-sched-ir.o \\\n \tsel-sched-dump.o \\"}, {"sha": "e003b134f484440372ee26184a3f5c8d236a6fbc", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"target.h\"\n+#include \"print-rtl.h\"\n \n /* This pass was originally removed from flow.c. However there is\n    almost nothing that remains of that code."}, {"sha": "ef73b49201b8334d3749296c50da4b7cf33bd4c4", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n+#include \"print-rtl.h\"\n \n /* Holds the interesting leading and trailing notes for the function.\n    Only applicable if the CFG is in cfglayout mode.  */"}, {"sha": "f7551271f7176b95d68d88ecfaacd972b07c6de8", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -112,6 +112,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"valtrack.h\"\n #include \"cgraph.h\"\n #include \"rtl-iter.h\"\n+#include \"print-rtl.h\"\n \n #ifndef LOAD_EXTEND_OP\n #define LOAD_EXTEND_OP(M) UNKNOWN"}, {"sha": "b604c441f52b1b48b60a1cb74eade57ea913edd6", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"wide-int-print.h\"\n #include \"rtl-iter.h\"\n+#include \"print-rtl.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data"}, {"sha": "3350e37f337112d5c7a56635df3e1603079f91c8", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -148,6 +148,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n #include \"dumpfile.h\"\n+#include \"print-rtl.h\"\n \n #ifdef INSN_SCHEDULING\n "}, {"sha": "4e94632074155442c7bb01a5b2cd4e5984b27dbd", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -402,6 +402,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"rtl-iter.h\"\n #include \"shrink-wrap.h\"\n+#include \"print-rtl.h\"\n \n struct target_ira default_target_ira;\n struct target_ira_int default_target_ira_int;"}, {"sha": "afe885a69f4ac56d59f5cc0c1679ebaa67d40f9a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -141,6 +141,7 @@\n #include \"lra.h\"\n #include \"insn-attr.h\"\n #include \"lra-int.h\"\n+#include \"print-rtl.h\"\n \n /* Value of LRA_CURR_RELOAD_NUM at the beginning of BB of the current\n    insn.  Remember that LRA_CURR_RELOAD_NUM is the number of emitted"}, {"sha": "55b856fbb0f142a9ab1dde364a17ca6462bf04b8", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -137,6 +137,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"lra.h\"\n #include \"insn-attr.h\"\n #include \"lra-int.h\"\n+#include \"print-rtl.h\"\n \n /* Dump bitmap SET with TITLE and BB INDEX.  */\n void"}, {"sha": "9153be86e461b67352b6c53977d85e3344d287c2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 880, "deletions": 0, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GENERATOR_FILE\n #include \"alias.h\"\n #include \"tree.h\"\n+#include \"cfg.h\"\n #include \"print-tree.h\"\n #include \"flags.h\"\n #include \"predict.h\"\n@@ -46,8 +47,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cselib.h\"\n #include \"dumpfile.h\"\t/* for dump_flags */\n #include \"dwarf2out.h\"\n+#include \"pretty-print.h\"\n #endif\n \n+#include \"print-rtl.h\"\n+\n static FILE *outfile;\n \n static int sawclose = 0;\n@@ -865,3 +869,879 @@ print_simple_rtl (FILE *outf, const_rtx x)\n   print_rtl (outf, x);\n   flag_simple = 0;\n }\n+\n+#ifndef GENERATOR_FILE\n+/* The functions below  try to print RTL in a form resembling assembler\n+   mnemonics.  Because this form is more concise than the \"traditional\" form\n+   of RTL printing in Lisp-style, the form printed by this file is called\n+   \"slim\".  RTL dumps in slim format can be obtained by appending the \"-slim\"\n+   option to -fdump-rtl-<pass>.  Control flow graph output as a DOT file is\n+   always printed in slim form.\n+\n+   The normal interface to the functionality provided in this pretty-printer\n+   is through the dump_*_slim functions to print to a stream, or via the\n+   print_*_slim functions to print into a user's pretty-printer.\n+\n+   It is also possible to obtain a string for a single pattern as a string\n+   pointer, via str_pattern_slim, but this usage is discouraged.  */\n+\n+/* For insns we print patterns, and for some patterns we print insns...  */\n+static void print_insn_with_notes (pretty_printer *, const rtx_insn *);\n+\n+/* This recognizes rtx'en classified as expressions.  These are always\n+   represent some action on values or results of other expression, that\n+   may be stored in objects representing values.  */\n+\n+static void\n+print_exp (pretty_printer *pp, const_rtx x, int verbose)\n+{\n+  const char *st[4];\n+  const char *fun;\n+  rtx op[4];\n+  int i;\n+\n+  fun = (char *) 0;\n+  for (i = 0; i < 4; i++)\n+    {\n+      st[i] = (char *) 0;\n+      op[i] = NULL_RTX;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      op[0] = XEXP (x, 0);\n+      if (CONST_INT_P (XEXP (x, 1))\n+\t  && INTVAL (XEXP (x, 1)) < 0)\n+\t{\n+\t  st[1] = \"-\";\n+\t  op[1] = GEN_INT (-INTVAL (XEXP (x, 1)));\n+\t}\n+      else\n+\t{\n+\t  st[1] = \"+\";\n+\t  op[1] = XEXP (x, 1);\n+\t}\n+      break;\n+    case LO_SUM:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"+low(\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \")\";\n+      break;\n+    case MINUS:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"-\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case COMPARE:\n+      fun = \"cmp\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NEG:\n+      st[0] = \"-\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FMA:\n+      st[0] = \"{\";\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"*\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \"+\";\n+      op[2] = XEXP (x, 2);\n+      st[3] = \"}\";\n+      break;\n+    case MULT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"*\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case DIV:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"/\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UDIV:\n+      fun = \"udiv\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case MOD:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"%\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMOD:\n+      fun = \"umod\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SMIN:\n+      fun = \"smin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SMAX:\n+      fun = \"smax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMIN:\n+      fun = \"umin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case UMAX:\n+      fun = \"umax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NOT:\n+      st[0] = \"!\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case AND:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"&\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case IOR:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"|\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case XOR:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"^\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ASHIFT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LSHIFTRT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \" 0>>\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ASHIFTRT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">>\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ROTATE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<-<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case ROTATERT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">->\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case NE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"!=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case EQ:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"==\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case GT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LE:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<=\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case LT:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<\";\n+      op[1] = XEXP (x, 1);\n+      break;\n+    case SIGN_EXTRACT:\n+      fun = (verbose) ? \"sign_extract\" : \"sxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n+      break;\n+    case ZERO_EXTRACT:\n+      fun = (verbose) ? \"zero_extract\" : \"zxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n+      break;\n+    case SIGN_EXTEND:\n+      fun = (verbose) ? \"sign_extend\" : \"sxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case ZERO_EXTEND:\n+      fun = (verbose) ? \"zero_extend\" : \"zxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT_EXTEND:\n+      fun = (verbose) ? \"float_extend\" : \"fxn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case TRUNCATE:\n+      fun = (verbose) ? \"trunc\" : \"trn\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT_TRUNCATE:\n+      fun = (verbose) ? \"float_trunc\" : \"ftr\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FLOAT:\n+      fun = (verbose) ? \"float\" : \"flt\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case UNSIGNED_FLOAT:\n+      fun = (verbose) ? \"uns_float\" : \"ufl\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case FIX:\n+      fun = \"fix\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case UNSIGNED_FIX:\n+      fun = (verbose) ? \"uns_fix\" : \"ufx\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case PRE_DEC:\n+      st[0] = \"--\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case PRE_INC:\n+      st[0] = \"++\";\n+      op[0] = XEXP (x, 0);\n+      break;\n+    case POST_DEC:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"--\";\n+      break;\n+    case POST_INC:\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"++\";\n+      break;\n+    case PRE_MODIFY:\n+      st[0] = \"pre \";\n+      op[0] = XEXP (XEXP (x, 1), 0);\n+      st[1] = \"+=\";\n+      op[1] = XEXP (XEXP (x, 1), 1);\n+      break;\n+    case POST_MODIFY:\n+      st[0] = \"post \";\n+      op[0] = XEXP (XEXP (x, 1), 0);\n+      st[1] = \"+=\";\n+      op[1] = XEXP (XEXP (x, 1), 1);\n+      break;\n+    case CALL:\n+      st[0] = \"call \";\n+      op[0] = XEXP (x, 0);\n+      if (verbose)\n+\t{\n+\t  st[1] = \" argc:\";\n+\t  op[1] = XEXP (x, 1);\n+\t}\n+      break;\n+    case IF_THEN_ELSE:\n+      st[0] = \"{(\";\n+      op[0] = XEXP (x, 0);\n+      st[1] = \")?\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \":\";\n+      op[2] = XEXP (x, 2);\n+      st[3] = \"}\";\n+      break;\n+    case TRAP_IF:\n+      fun = \"trap_if\";\n+      op[0] = TRAP_CONDITION (x);\n+      break;\n+    case PREFETCH:\n+      fun = \"prefetch\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n+      break;\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      {\n+\tpp_string (pp, \"unspec\");\n+\tif (GET_CODE (x) == UNSPEC_VOLATILE)\n+\t  pp_string (pp, \"/v\");\n+\tpp_left_bracket (pp);\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    if (i != 0)\n+\t      pp_comma (pp);\n+\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n+\t  }\n+\tpp_string (pp, \"] \");\n+\tpp_decimal_int (pp, XINT (x, 1));\n+      }\n+      break;\n+    default:\n+      {\n+\t/* Most unhandled codes can be printed as pseudo-functions.  */\n+        if (GET_RTX_CLASS (GET_CODE (x)) == RTX_UNARY)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t  }\n+        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_COMPARE\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_COMPARE\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_BIN_ARITH\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_ARITH)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t    op[1] = XEXP (x, 1);\n+\t  }\n+        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t    op[1] = XEXP (x, 1);\n+\t    op[2] = XEXP (x, 2);\n+\t  }\n+\telse\n+\t  /* Give up, just print the RTX name.  */\n+\t  st[0] = GET_RTX_NAME (GET_CODE (x));\n+      }\n+      break;\n+    }\n+\n+  /* Print this as a function?  */\n+  if (fun)\n+    {\n+      pp_string (pp, fun);\n+      pp_left_paren (pp);\n+    }\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (st[i])\n+        pp_string (pp, st[i]);\n+\n+      if (op[i])\n+\t{\n+\t  if (fun && i != 0)\n+\t    pp_comma (pp);\n+\t  print_value (pp, op[i], verbose);\n+\t}\n+    }\n+\n+  if (fun)\n+    pp_right_paren (pp);\n+}\t\t/* print_exp */\n+\n+/* Prints rtxes, I customarily classified as values.  They're constants,\n+   registers, labels, symbols and memory accesses.  */\n+\n+void\n+print_value (pretty_printer *pp, const_rtx x, int verbose)\n+{\n+  char tmp[1024];\n+\n+  if (!x)\n+    {\n+      pp_string (pp, \"(nil)\");\n+      return;\n+    }\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+      pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n+\t\t (unsigned HOST_WIDE_INT) INTVAL (x));\n+      break;\n+\n+    case CONST_WIDE_INT:\n+      {\n+\tconst char *sep = \"<\";\n+\tint i;\n+\tfor (i = CONST_WIDE_INT_NUNITS (x) - 1; i >= 0; i--)\n+\t  {\n+\t    pp_string (pp, sep);\n+\t    sep = \",\";\n+\t    sprintf (tmp, HOST_WIDE_INT_PRINT_HEX,\n+\t\t     (unsigned HOST_WIDE_INT) CONST_WIDE_INT_ELT (x, i));\n+\t    pp_string (pp, tmp);\n+\t  }\n+        pp_greater (pp);\n+      }\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\t{\n+\t  real_to_decimal (tmp, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t\t   sizeof (tmp), 0, 1);\n+\t  pp_string (pp, tmp);\n+\t}\n+      else\n+\tpp_printf (pp, \"<%wx,%wx>\",\n+\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x),\n+\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (x));\n+      break;\n+    case CONST_FIXED:\n+      fixed_to_decimal (tmp, CONST_FIXED_VALUE (x), sizeof (tmp));\n+      pp_string (pp, tmp);\n+      break;\n+    case CONST_STRING:\n+      pp_printf (pp, \"\\\"%s\\\"\", XSTR (x, 0));\n+      break;\n+    case SYMBOL_REF:\n+      pp_printf (pp, \"`%s'\", XSTR (x, 0));\n+      break;\n+    case LABEL_REF:\n+      pp_printf (pp, \"L%d\", INSN_UID (LABEL_REF_LABEL (x)));\n+      break;\n+    case CONST:\n+    case HIGH:\n+    case STRICT_LOW_PART:\n+      pp_printf (pp, \"%s(\", GET_RTX_NAME (GET_CODE (x)));\n+      print_value (pp, XEXP (x, 0), verbose);\n+      pp_right_paren (pp);\n+      break;\n+    case REG:\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (ISDIGIT (reg_names[REGNO (x)][0]))\n+\t    pp_modulo (pp);\n+\t  pp_string (pp, reg_names[REGNO (x)]);\n+\t}\n+      else\n+\tpp_printf (pp, \"r%d\", REGNO (x));\n+      if (verbose)\n+\tpp_printf (pp, \":%s\", GET_MODE_NAME (GET_MODE (x)));\n+      break;\n+    case SUBREG:\n+      print_value (pp, SUBREG_REG (x), verbose);\n+      pp_printf (pp, \"#%d\", SUBREG_BYTE (x));\n+      break;\n+    case SCRATCH:\n+    case CC0:\n+    case PC:\n+      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n+      break;\n+    case MEM:\n+      pp_left_bracket (pp);\n+      print_value (pp, XEXP (x, 0), verbose);\n+      pp_right_bracket (pp);\n+      break;\n+    case DEBUG_EXPR:\n+      pp_printf (pp, \"D#%i\", DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x)));\n+      break;\n+    default:\n+      print_exp (pp, x, verbose);\n+      break;\n+    }\n+}\t\t\t\t/* print_value */\n+\n+/* The next step in insn detalization, its pattern recognition.  */\n+\n+void\n+print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n+{\n+  if (! x)\n+    {\n+      pp_string (pp, \"(nil)\");\n+      return;\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SET:\n+      print_value (pp, SET_DEST (x), verbose);\n+      pp_equal (pp);\n+      print_value (pp, SET_SRC (x), verbose);\n+      break;\n+    case RETURN:\n+    case SIMPLE_RETURN:\n+    case EH_RETURN:\n+      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n+      break;\n+    case CALL:\n+      print_exp (pp, x, verbose);\n+      break;\n+    case CLOBBER:\n+    case USE:\n+      pp_printf (pp, \"%s \", GET_RTX_NAME (GET_CODE (x)));\n+      print_value (pp, XEXP (x, 0), verbose);\n+      break;\n+    case VAR_LOCATION:\n+      pp_string (pp, \"loc \");\n+      print_value (pp, PAT_VAR_LOCATION_LOC (x), verbose);\n+      break;\n+    case COND_EXEC:\n+      pp_left_paren (pp);\n+      if (GET_CODE (COND_EXEC_TEST (x)) == NE\n+\t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n+\tprint_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+      else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n+\t       && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n+\t{\n+\t  pp_exclamation (pp);\n+\t  print_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+\t}\n+      else\n+\tprint_value (pp, COND_EXEC_TEST (x), verbose);\n+      pp_string (pp, \") \");\n+      print_pattern (pp, COND_EXEC_CODE (x), verbose);\n+      break;\n+    case PARALLEL:\n+      {\n+\tint i;\n+\n+\tpp_left_brace (pp);\n+\tfor (i = 0; i < XVECLEN (x, 0); i++)\n+\t  {\n+\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n+\t    pp_semicolon (pp);\n+\t  }\n+\tpp_right_brace (pp);\n+      }\n+      break;\n+    case SEQUENCE:\n+      {\n+\tconst rtx_sequence *seq = as_a <const rtx_sequence *> (x);\n+\tpp_string (pp, \"sequence{\");\n+\tif (INSN_P (seq->element (0)))\n+\t  {\n+\t    /* Print the sequence insns indented.  */\n+\t    const char * save_print_rtx_head = print_rtx_head;\n+\t    char indented_print_rtx_head[32];\n+\n+\t    pp_newline (pp);\n+\t    gcc_assert (strlen (print_rtx_head) < sizeof (indented_print_rtx_head) - 4);\n+\t    snprintf (indented_print_rtx_head,\n+\t\t      sizeof (indented_print_rtx_head),\n+\t\t      \"%s     \", print_rtx_head);\n+\t    print_rtx_head = indented_print_rtx_head;\n+\t    for (int i = 0; i < seq->len (); i++)\n+\t      print_insn_with_notes (pp, seq->insn (i));\n+\t    pp_printf (pp, \"%s      \", save_print_rtx_head);\n+\t    print_rtx_head = save_print_rtx_head;\n+\t  }\n+\telse\n+\t  {\n+\t    for (int i = 0; i < seq->len (); i++)\n+\t      {\n+\t\tprint_pattern (pp, seq->element (i), verbose);\n+\t\tpp_semicolon (pp);\n+\t      }\n+\t  }\n+\tpp_right_brace (pp);\n+      }\n+      break;\n+    case ASM_INPUT:\n+      pp_printf (pp, \"asm {%s}\", XSTR (x, 0));\n+      break;\n+    case ADDR_VEC:\n+      for (int i = 0; i < XVECLEN (x, 0); i++)\n+\t{\n+\t  print_value (pp, XVECEXP (x, 0, i), verbose);\n+\t  pp_semicolon (pp);\n+\t}\n+      break;\n+    case ADDR_DIFF_VEC:\n+      for (int i = 0; i < XVECLEN (x, 1); i++)\n+\t{\n+\t  print_value (pp, XVECEXP (x, 1, i), verbose);\n+\t  pp_semicolon (pp);\n+\t}\n+      break;\n+    case TRAP_IF:\n+      pp_string (pp, \"trap_if \");\n+      print_value (pp, TRAP_CONDITION (x), verbose);\n+      break;\n+    case UNSPEC:\n+    case UNSPEC_VOLATILE:\n+      /* Fallthru -- leave UNSPECs to print_exp.  */\n+    default:\n+      print_value (pp, x, verbose);\n+    }\n+}\t\t\t\t/* print_pattern */\n+\n+/* This is the main function in slim rtl visualization mechanism.\n+\n+   X is an insn, to be printed into PP.\n+\n+   This function tries to print it properly in human-readable form,\n+   resembling assembler mnemonics (instead of the older Lisp-style\n+   form).\n+\n+   If VERBOSE is TRUE, insns are printed with more complete (but\n+   longer) pattern names and with extra information, and prefixed\n+   with their INSN_UIDs.  */\n+\n+void\n+print_insn (pretty_printer *pp, const rtx_insn *x, int verbose)\n+{\n+  if (verbose)\n+    {\n+      /* Blech, pretty-print can't print integers with a specified width.  */\n+      char uid_prefix[32];\n+      snprintf (uid_prefix, sizeof uid_prefix, \" %4d: \", INSN_UID (x));\n+      pp_string (pp, uid_prefix);\n+    }\n+\n+  switch (GET_CODE (x))\n+    {\n+    case INSN:\n+      print_pattern (pp, PATTERN (x), verbose);\n+      break;\n+\n+    case DEBUG_INSN:\n+      {\n+\tconst char *name = \"?\";\n+\n+\tif (DECL_P (INSN_VAR_LOCATION_DECL (x)))\n+\t  {\n+\t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (x));\n+\t    char idbuf[32];\n+\t    if (id)\n+\t      name = IDENTIFIER_POINTER (id);\n+\t    else if (TREE_CODE (INSN_VAR_LOCATION_DECL (x))\n+\t\t     == DEBUG_EXPR_DECL)\n+\t      {\n+\t\tsprintf (idbuf, \"D#%i\",\n+\t\t\t DEBUG_TEMP_UID (INSN_VAR_LOCATION_DECL (x)));\n+\t\tname = idbuf;\n+\t      }\n+\t    else\n+\t      {\n+\t\tsprintf (idbuf, \"D.%i\",\n+\t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (x)));\n+\t\tname = idbuf;\n+\t      }\n+\t  }\n+\tpp_printf (pp, \"debug %s => \", name);\n+\tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (x)))\n+\t  pp_string (pp, \"optimized away\");\n+\telse\n+\t  print_pattern (pp, INSN_VAR_LOCATION_LOC (x), verbose);\n+      }\n+      break;\n+\n+    case JUMP_INSN:\n+      print_pattern (pp, PATTERN (x), verbose);\n+      break;\n+    case CALL_INSN:\n+      if (GET_CODE (PATTERN (x)) == PARALLEL)\n+        print_pattern (pp, XVECEXP (PATTERN (x), 0, 0), verbose);\n+      else\n+\tprint_pattern (pp, PATTERN (x), verbose);\n+      break;\n+    case CODE_LABEL:\n+      pp_printf (pp, \"L%d:\", INSN_UID (x));\n+      break;\n+    case JUMP_TABLE_DATA:\n+      pp_string (pp, \"jump_table_data{\\n\");\n+      print_pattern (pp, PATTERN (x), verbose);\n+      pp_right_brace (pp);\n+      break;\n+    case BARRIER:\n+      pp_string (pp, \"barrier\");\n+      break;\n+    case NOTE:\n+      {\n+\tpp_string (pp, GET_NOTE_INSN_NAME (NOTE_KIND (x)));\n+\tswitch (NOTE_KIND (x))\n+\t  {\n+\t  case NOTE_INSN_EH_REGION_BEG:\n+\t  case NOTE_INSN_EH_REGION_END:\n+\t    pp_printf (pp, \" %d\", NOTE_EH_HANDLER (x));\n+\t    break;\n+\n+\t  case NOTE_INSN_BLOCK_BEG:\n+\t  case NOTE_INSN_BLOCK_END:\n+\t    pp_printf (pp, \" %d\", BLOCK_NUMBER (NOTE_BLOCK (x)));\n+\t    break;\n+\n+\t  case NOTE_INSN_BASIC_BLOCK:\n+\t    pp_printf (pp, \" %d\", NOTE_BASIC_BLOCK (x)->index);\n+\t    break;\n+\n+\t  case NOTE_INSN_DELETED_LABEL:\n+\t  case NOTE_INSN_DELETED_DEBUG_LABEL:\n+\t    {\n+\t      const char *label = NOTE_DELETED_LABEL_NAME (x);\n+\t      if (label == NULL)\n+\t\tlabel = \"\";\n+\t      pp_printf (pp, \" (\\\"%s\\\")\", label);\n+\t    }\n+\t    break;\n+\n+\t  case NOTE_INSN_VAR_LOCATION:\n+\t  case NOTE_INSN_CALL_ARG_LOCATION:\n+\t    pp_left_brace (pp);\n+\t    print_pattern (pp, NOTE_VAR_LOCATION (x), verbose);\n+\t    pp_right_brace (pp);\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\t\t\t\t/* print_insn */\n+\n+/* Pretty-print a slim dump of X (an insn) to PP, including any register\n+   note attached to the instruction.  */\n+\n+static void\n+print_insn_with_notes (pretty_printer *pp, const rtx_insn *x)\n+{\n+  pp_string (pp, print_rtx_head);\n+  print_insn (pp, x, 1);\n+  pp_newline (pp);\n+  if (INSN_P (x) && REG_NOTES (x))\n+    for (rtx note = REG_NOTES (x); note; note = XEXP (note, 1))\n+      {\n+\tpp_printf (pp, \"%s      %s \", print_rtx_head,\n+\t\t   GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n+\tif (GET_CODE (note) == INT_LIST)\n+\t  pp_printf (pp, \"%d\", XINT (note, 0));\n+\telse\n+\t  print_pattern (pp, XEXP (note, 0), 1);\n+\tpp_newline (pp);\n+      }\n+}\n+\n+/* Print X, an RTL value node, to file F in slim format.  Include\n+   additional information if VERBOSE is nonzero.\n+\n+   Value nodes are constants, registers, labels, symbols and\n+   memory.  */\n+\n+void\n+dump_value_slim (FILE *f, const_rtx x, int verbose)\n+{\n+  pretty_printer rtl_slim_pp;\n+  rtl_slim_pp.buffer->stream = f;\n+  print_value (&rtl_slim_pp, x, verbose);\n+  pp_flush (&rtl_slim_pp);\n+}\n+\n+/* Emit a slim dump of X (an insn) to the file F, including any register\n+   note attached to the instruction.  */\n+void\n+dump_insn_slim (FILE *f, const rtx_insn *x)\n+{\n+  pretty_printer rtl_slim_pp;\n+  rtl_slim_pp.buffer->stream = f;\n+  print_insn_with_notes (&rtl_slim_pp, x);\n+  pp_flush (&rtl_slim_pp);\n+}\n+\n+/* Same as above, but stop at LAST or when COUNT == 0.\n+   If COUNT < 0 it will stop only at LAST or NULL rtx.  */\n+\n+void\n+dump_rtl_slim (FILE *f, const rtx_insn *first, const rtx_insn *last,\n+\t       int count, int flags ATTRIBUTE_UNUSED)\n+{\n+  const rtx_insn *insn, *tail;\n+  pretty_printer rtl_slim_pp;\n+  rtl_slim_pp.buffer->stream = f;\n+\n+  tail = last ? NEXT_INSN (last) : NULL;\n+  for (insn = first;\n+       (insn != NULL) && (insn != tail) && (count != 0);\n+       insn = NEXT_INSN (insn))\n+    {\n+      print_insn_with_notes (&rtl_slim_pp, insn);\n+      if (count > 0)\n+        count--;\n+    }\n+\n+  pp_flush (&rtl_slim_pp);\n+}\n+\n+/* Dumps basic block BB to pretty-printer PP in slim form and without and\n+   no indentation, for use as a label of a DOT graph record-node.  */\n+\n+void\n+rtl_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n+{\n+  rtx_insn *insn;\n+  bool first = true;\n+\n+  /* TODO: inter-bb stuff.  */\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (! first)\n+\t{\n+\t  pp_bar (pp);\n+\t  pp_write_text_to_stream (pp);\n+\t}\n+      first = false;\n+      print_insn_with_notes (pp, insn);\n+      pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n+    }\n+}\n+\n+/* Pretty-print pattern X of some insn in non-verbose mode.\n+   Return a string pointer to the pretty-printer buffer.\n+\n+   This function is only exported exists only to accommodate some older users\n+   of the slim RTL pretty printers.  Please do not use it for new code.  */\n+\n+const char *\n+str_pattern_slim (const_rtx x)\n+{\n+  pretty_printer rtl_slim_pp;\n+  print_pattern (&rtl_slim_pp, x, 0);\n+  return ggc_strdup (pp_formatted_text (&rtl_slim_pp));\n+}\n+\n+/* Emit a slim dump of X (an insn) to stderr.  */\n+extern void debug_insn_slim (const rtx_insn *);\n+DEBUG_FUNCTION void\n+debug_insn_slim (const rtx_insn *x)\n+{\n+  dump_insn_slim (stderr, x);\n+}\n+\n+/* Same as above, but using dump_rtl_slim.  */\n+extern void debug_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n+\t\t\t    int, int);\n+DEBUG_FUNCTION void\n+debug_rtl_slim (const rtx_insn *first, const rtx_insn *last, int count,\n+\t\tint flags)\n+{\n+  dump_rtl_slim (stderr, first, last, count, flags);\n+}\n+\n+extern void debug_bb_slim (basic_block);\n+DEBUG_FUNCTION void\n+debug_bb_slim (basic_block bb)\n+{\n+  dump_bb (stderr, bb, 0, TDF_SLIM | TDF_BLOCKS);\n+}\n+\n+extern void debug_bb_n_slim (int);\n+DEBUG_FUNCTION void\n+debug_bb_n_slim (int n)\n+{\n+  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, n);\n+  debug_bb_slim (bb);\n+}\n+\n+#endif"}, {"sha": "eb079afaa3c115bf0430f5ece69334aa8c54f241", "filename": "gcc/print-rtl.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fprint-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fprint-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.h?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -24,4 +24,13 @@ along with GCC; see the file COPYING3.  If not see\n extern void print_rtl (FILE *, const_rtx);\n #endif\n \n+extern void dump_value_slim (FILE *, const_rtx, int);\n+extern void dump_insn_slim (FILE *, const rtx_insn *);\n+extern void dump_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n+\t\t\t   int, int);\n+extern void print_value (pretty_printer *, const_rtx, int);\n+extern void print_pattern (pretty_printer *, const_rtx, int);\n+extern void rtl_dump_bb_for_graph (pretty_printer *, basic_block);\n+extern const char *str_pattern_slim (const_rtx);\n+\n #endif  // GCC_PRINT_RTL_H"}, {"sha": "ad0cf6abf564fd4a7a4d02d22829f8b7a878c182", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -3565,19 +3565,6 @@ extern int print_rtl_single (FILE *, const_rtx);\n extern int print_rtl_single_with_indent (FILE *, const_rtx, int);\n extern void print_inline_rtx (FILE *, const_rtx, int);\n \n-/* Functions in sched-vis.c.  FIXME: Ideally these functions would\n-   not be in sched-vis.c but in rtl.c, because they are not only used\n-   by the scheduler anymore but for all \"slim\" RTL dumping.  */\n-extern void dump_value_slim (FILE *, const_rtx, int);\n-extern void dump_insn_slim (FILE *, const rtx_insn *);\n-extern void dump_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n-\t\t\t   int, int);\n-extern void print_value (pretty_printer *, const_rtx, int);\n-extern void print_pattern (pretty_printer *, const_rtx, int);\n-extern void print_insn (pretty_printer *, const rtx_insn *, int);\n-extern void rtl_dump_bb_for_graph (pretty_printer *, basic_block);\n-extern const char *str_pattern_slim (const_rtx);\n-\n /* In stmt.c */\n extern void expand_null_return (void);\n extern void expand_naked_return (void);"}, {"sha": "f115e0a061e98b512a8d31e40734616a609c7467", "filename": "gcc/sched-vis.c", "status": "removed", "additions": 0, "deletions": 908, "changes": 908, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c25fb51158da95d010b755a186b4c0a2e1a0d2/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c25fb51158da95d010b755a186b4c0a2e1a0d2/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=84c25fb51158da95d010b755a186b4c0a2e1a0d2", "patch": "@@ -1,908 +0,0 @@\n-/* Printing of RTL in \"slim\", mnemonic like form.\n-   Copyright (C) 1992-2015 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n-   and currently maintained by, Jim Wilson (wilson@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Historically this form of RTL dumping was introduced along with\n-   the Haifa instruction scheduling pass, hence the name of this file.\n-   But there is nothing in this file left that is scheduler-specific.  */\n-\f\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"rtl.h\"\n-#include \"alias.h\"\n-#include \"tree.h\"\n-#include \"dumpfile.h\"\t/* for the TDF_* flags */\n-#include \"pretty-print.h\"\n-\n-/* The functions in this file try to print RTL in a form resembling assembler\n-   mnemonics.  Because this form is more concise than the \"traditional\" form\n-   of RTL printing in Lisp-style, the form printed by this file is called\n-   \"slim\".  RTL dumps in slim format can be obtained by appending the \"-slim\"\n-   option to -fdump-rtl-<pass>.  Control flow graph output as a DOT file is\n-   always printed in slim form.\n-\n-   The normal interface to the functionality provided in this pretty-printer\n-   is through the dump_*_slim functions to print to a stream, or via the\n-   print_*_slim functions to print into a user's pretty-printer.\n-   \n-   It is also possible to obtain a string for a single pattern as a string\n-   pointer, via str_pattern_slim, but this usage is discouraged.  */\n-\n-/* For insns we print patterns, and for some patterns we print insns...  */\n-static void print_insn_with_notes (pretty_printer *, const rtx_insn *);\n-\n-/* This recognizes rtx'en classified as expressions.  These are always\n-   represent some action on values or results of other expression, that\n-   may be stored in objects representing values.  */\n-\n-static void\n-print_exp (pretty_printer *pp, const_rtx x, int verbose)\n-{\n-  const char *st[4];\n-  const char *fun;\n-  rtx op[4];\n-  int i;\n-\n-  fun = (char *) 0;\n-  for (i = 0; i < 4; i++)\n-    {\n-      st[i] = (char *) 0;\n-      op[i] = NULL_RTX;\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case PLUS:\n-      op[0] = XEXP (x, 0);\n-      if (CONST_INT_P (XEXP (x, 1))\n-\t  && INTVAL (XEXP (x, 1)) < 0)\n-\t{\n-\t  st[1] = \"-\";\n-\t  op[1] = GEN_INT (-INTVAL (XEXP (x, 1)));\n-\t}\n-      else\n-\t{\n-\t  st[1] = \"+\";\n-\t  op[1] = XEXP (x, 1);\n-\t}\n-      break;\n-    case LO_SUM:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"+low(\";\n-      op[1] = XEXP (x, 1);\n-      st[2] = \")\";\n-      break;\n-    case MINUS:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"-\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case COMPARE:\n-      fun = \"cmp\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NEG:\n-      st[0] = \"-\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FMA:\n-      st[0] = \"{\";\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"*\";\n-      op[1] = XEXP (x, 1);\n-      st[2] = \"+\";\n-      op[2] = XEXP (x, 2);\n-      st[3] = \"}\";\n-      break;\n-    case MULT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"*\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case DIV:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"/\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UDIV:\n-      fun = \"udiv\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case MOD:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"%\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMOD:\n-      fun = \"umod\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SMIN:\n-      fun = \"smin\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SMAX:\n-      fun = \"smax\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMIN:\n-      fun = \"umin\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case UMAX:\n-      fun = \"umax\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NOT:\n-      st[0] = \"!\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case AND:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"&\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case IOR:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"|\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case XOR:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"^\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ASHIFT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LSHIFTRT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \" 0>>\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ASHIFTRT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">>\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ROTATE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<-<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case ROTATERT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">->\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case NE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"!=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case EQ:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"==\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LE:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<=\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case SIGN_EXTRACT:\n-      fun = (verbose) ? \"sign_extract\" : \"sxt\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      op[2] = XEXP (x, 2);\n-      break;\n-    case ZERO_EXTRACT:\n-      fun = (verbose) ? \"zero_extract\" : \"zxt\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      op[2] = XEXP (x, 2);\n-      break;\n-    case SIGN_EXTEND:\n-      fun = (verbose) ? \"sign_extend\" : \"sxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case ZERO_EXTEND:\n-      fun = (verbose) ? \"zero_extend\" : \"zxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT_EXTEND:\n-      fun = (verbose) ? \"float_extend\" : \"fxn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case TRUNCATE:\n-      fun = (verbose) ? \"trunc\" : \"trn\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT_TRUNCATE:\n-      fun = (verbose) ? \"float_trunc\" : \"ftr\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FLOAT:\n-      fun = (verbose) ? \"float\" : \"flt\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case UNSIGNED_FLOAT:\n-      fun = (verbose) ? \"uns_float\" : \"ufl\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FIX:\n-      fun = \"fix\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case UNSIGNED_FIX:\n-      fun = (verbose) ? \"uns_fix\" : \"ufx\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case PRE_DEC:\n-      st[0] = \"--\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case PRE_INC:\n-      st[0] = \"++\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case POST_DEC:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"--\";\n-      break;\n-    case POST_INC:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"++\";\n-      break;\n-    case PRE_MODIFY:\n-      st[0] = \"pre \";\n-      op[0] = XEXP (XEXP (x, 1), 0);\n-      st[1] = \"+=\";\n-      op[1] = XEXP (XEXP (x, 1), 1);\n-      break;\n-    case POST_MODIFY:\n-      st[0] = \"post \";\n-      op[0] = XEXP (XEXP (x, 1), 0);\n-      st[1] = \"+=\";\n-      op[1] = XEXP (XEXP (x, 1), 1);\n-      break;\n-    case CALL:\n-      st[0] = \"call \";\n-      op[0] = XEXP (x, 0);\n-      if (verbose)\n-\t{\n-\t  st[1] = \" argc:\";\n-\t  op[1] = XEXP (x, 1);\n-\t}\n-      break;\n-    case IF_THEN_ELSE:\n-      st[0] = \"{(\";\n-      op[0] = XEXP (x, 0);\n-      st[1] = \")?\";\n-      op[1] = XEXP (x, 1);\n-      st[2] = \":\";\n-      op[2] = XEXP (x, 2);\n-      st[3] = \"}\";\n-      break;\n-    case TRAP_IF:\n-      fun = \"trap_if\";\n-      op[0] = TRAP_CONDITION (x);\n-      break;\n-    case PREFETCH:\n-      fun = \"prefetch\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      op[2] = XEXP (x, 2);\n-      break;\n-    case UNSPEC:\n-    case UNSPEC_VOLATILE:\n-      {\n-\tpp_string (pp, \"unspec\");\n-\tif (GET_CODE (x) == UNSPEC_VOLATILE)\n-\t  pp_string (pp, \"/v\");\n-\tpp_left_bracket (pp);\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    if (i != 0)\n-\t      pp_comma (pp);\n-\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n-\t  }\n-\tpp_string (pp, \"] \");\n-\tpp_decimal_int (pp, XINT (x, 1));\n-      }\n-      break;\n-    default:\n-      {\n-\t/* Most unhandled codes can be printed as pseudo-functions.  */\n-        if (GET_RTX_CLASS (GET_CODE (x)) == RTX_UNARY)\n-\t  {\n-\t    fun = GET_RTX_NAME (GET_CODE (x));\n-\t    op[0] = XEXP (x, 0);\n-\t  }\n-        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_COMPARE\n-\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_COMPARE\n-\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_BIN_ARITH\n-\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_ARITH)\n-\t  {\n-\t    fun = GET_RTX_NAME (GET_CODE (x));\n-\t    op[0] = XEXP (x, 0);\n-\t    op[1] = XEXP (x, 1);\n-\t  }\n-        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY)\n-\t  {\n-\t    fun = GET_RTX_NAME (GET_CODE (x));\n-\t    op[0] = XEXP (x, 0);\n-\t    op[1] = XEXP (x, 1);\n-\t    op[2] = XEXP (x, 2);\n-\t  }\n-\telse\n-\t  /* Give up, just print the RTX name.  */\n-\t  st[0] = GET_RTX_NAME (GET_CODE (x));\n-      }\n-      break;\n-    }\n-\n-  /* Print this as a function?  */\n-  if (fun)\n-    {\n-      pp_string (pp, fun);\n-      pp_left_paren (pp);\n-    }\n-\n-  for (i = 0; i < 4; i++)\n-    {\n-      if (st[i])\n-        pp_string (pp, st[i]);\n-\n-      if (op[i])\n-\t{\n-\t  if (fun && i != 0)\n-\t    pp_comma (pp);\n-\t  print_value (pp, op[i], verbose);\n-\t}\n-    }\n-\n-  if (fun)\n-    pp_right_paren (pp);\n-}\t\t/* print_exp */\n-\n-/* Prints rtxes, I customarily classified as values.  They're constants,\n-   registers, labels, symbols and memory accesses.  */\n-\n-void\n-print_value (pretty_printer *pp, const_rtx x, int verbose)\n-{\n-  char tmp[1024];\n-\n-  if (!x)\n-    {\n-      pp_string (pp, \"(nil)\");\n-      return;\n-    }\n-  switch (GET_CODE (x))\n-    {\n-    case CONST_INT:\n-      pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n-\t\t (unsigned HOST_WIDE_INT) INTVAL (x));\n-      break;\n-\n-    case CONST_WIDE_INT:\n-      {\n-\tconst char *sep = \"<\";\n-\tint i;\n-\tfor (i = CONST_WIDE_INT_NUNITS (x) - 1; i >= 0; i--)\n-\t  {\n-\t    pp_string (pp, sep);\n-\t    sep = \",\";\n-\t    sprintf (tmp, HOST_WIDE_INT_PRINT_HEX,\n-\t\t     (unsigned HOST_WIDE_INT) CONST_WIDE_INT_ELT (x, i));\n-\t    pp_string (pp, tmp);\n-\t  }\n-        pp_greater (pp);\n-      }\n-      break;\n-\n-    case CONST_DOUBLE:\n-      if (FLOAT_MODE_P (GET_MODE (x)))\n-\t{\n-\t  real_to_decimal (tmp, CONST_DOUBLE_REAL_VALUE (x),\n-\t\t\t   sizeof (tmp), 0, 1);\n-\t  pp_string (pp, tmp);\n-\t}\n-      else\n-\tpp_printf (pp, \"<%wx,%wx>\",\n-\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x),\n-\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (x));\n-      break;\n-    case CONST_FIXED:\n-      fixed_to_decimal (tmp, CONST_FIXED_VALUE (x), sizeof (tmp));\n-      pp_string (pp, tmp);\n-      break;\n-    case CONST_STRING:\n-      pp_printf (pp, \"\\\"%s\\\"\", XSTR (x, 0));\n-      break;\n-    case SYMBOL_REF:\n-      pp_printf (pp, \"`%s'\", XSTR (x, 0));\n-      break;\n-    case LABEL_REF:\n-      pp_printf (pp, \"L%d\", INSN_UID (LABEL_REF_LABEL (x)));\n-      break;\n-    case CONST:\n-    case HIGH:\n-    case STRICT_LOW_PART:\n-      pp_printf (pp, \"%s(\", GET_RTX_NAME (GET_CODE (x)));\n-      print_value (pp, XEXP (x, 0), verbose);\n-      pp_right_paren (pp);\n-      break;\n-    case REG:\n-      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  if (ISDIGIT (reg_names[REGNO (x)][0]))\n-\t    pp_modulo (pp);\n-\t  pp_string (pp, reg_names[REGNO (x)]);\n-\t}\n-      else\n-\tpp_printf (pp, \"r%d\", REGNO (x));\n-      if (verbose)\n-\tpp_printf (pp, \":%s\", GET_MODE_NAME (GET_MODE (x)));\n-      break;\n-    case SUBREG:\n-      print_value (pp, SUBREG_REG (x), verbose);\n-      pp_printf (pp, \"#%d\", SUBREG_BYTE (x));\n-      break;\n-    case SCRATCH:\n-    case CC0:\n-    case PC:\n-      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n-      break;\n-    case MEM:\n-      pp_left_bracket (pp);\n-      print_value (pp, XEXP (x, 0), verbose);\n-      pp_right_bracket (pp);\n-      break;\n-    case DEBUG_EXPR:\n-      pp_printf (pp, \"D#%i\", DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x)));\n-      break;\n-    default:\n-      print_exp (pp, x, verbose);\n-      break;\n-    }\n-}\t\t\t\t/* print_value */\n-\n-/* The next step in insn detalization, its pattern recognition.  */\n-\n-void\n-print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n-{\n-  if (! x)\n-    {\n-      pp_string (pp, \"(nil)\");\n-      return;\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case SET:\n-      print_value (pp, SET_DEST (x), verbose);\n-      pp_equal (pp);\n-      print_value (pp, SET_SRC (x), verbose);\n-      break;\n-    case RETURN:\n-    case SIMPLE_RETURN:\n-    case EH_RETURN:\n-      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n-      break;\n-    case CALL:\n-      print_exp (pp, x, verbose);\n-      break;\n-    case CLOBBER:\n-    case USE:\n-      pp_printf (pp, \"%s \", GET_RTX_NAME (GET_CODE (x)));\n-      print_value (pp, XEXP (x, 0), verbose);\n-      break;\n-    case VAR_LOCATION:\n-      pp_string (pp, \"loc \");\n-      print_value (pp, PAT_VAR_LOCATION_LOC (x), verbose);\n-      break;\n-    case COND_EXEC:\n-      pp_left_paren (pp);\n-      if (GET_CODE (COND_EXEC_TEST (x)) == NE\n-\t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-\tprint_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n-      else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n-\t       && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-\t{\n-\t  pp_exclamation (pp);\n-\t  print_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n-\t}\n-      else\n-\tprint_value (pp, COND_EXEC_TEST (x), verbose);\n-      pp_string (pp, \") \");\n-      print_pattern (pp, COND_EXEC_CODE (x), verbose);\n-      break;\n-    case PARALLEL:\n-      {\n-\tint i;\n-\n-\tpp_left_brace (pp);\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n-\t    pp_semicolon (pp);\n-\t  }\n-\tpp_right_brace (pp);\n-      }\n-      break;\n-    case SEQUENCE:\n-      {\n-\tconst rtx_sequence *seq = as_a <const rtx_sequence *> (x);\n-\tpp_string (pp, \"sequence{\");\n-\tif (INSN_P (seq->element (0)))\n-\t  {\n-\t    /* Print the sequence insns indented.  */\n-\t    const char * save_print_rtx_head = print_rtx_head;\n-\t    char indented_print_rtx_head[32];\n-\n-\t    pp_newline (pp);\n-\t    gcc_assert (strlen (print_rtx_head) < sizeof (indented_print_rtx_head) - 4);\n-\t    snprintf (indented_print_rtx_head,\n-\t\t      sizeof (indented_print_rtx_head),\n-\t\t      \"%s     \", print_rtx_head);\n-\t    print_rtx_head = indented_print_rtx_head;\n-\t    for (int i = 0; i < seq->len (); i++)\n-\t      print_insn_with_notes (pp, seq->insn (i));\n-\t    pp_printf (pp, \"%s      \", save_print_rtx_head);\n-\t    print_rtx_head = save_print_rtx_head;\n-\t  }\n-\telse\n-\t  {\n-\t    for (int i = 0; i < seq->len (); i++)\n-\t      {\n-\t\tprint_pattern (pp, seq->element (i), verbose);\n-\t\tpp_semicolon (pp);\n-\t      }\n-\t  }\n-\tpp_right_brace (pp);\n-      }\n-      break;\n-    case ASM_INPUT:\n-      pp_printf (pp, \"asm {%s}\", XSTR (x, 0));\n-      break;\n-    case ADDR_VEC:\n-      for (int i = 0; i < XVECLEN (x, 0); i++)\n-\t{\n-\t  print_value (pp, XVECEXP (x, 0, i), verbose);\n-\t  pp_semicolon (pp);\n-\t}\n-      break;\n-    case ADDR_DIFF_VEC:\n-      for (int i = 0; i < XVECLEN (x, 1); i++)\n-\t{\n-\t  print_value (pp, XVECEXP (x, 1, i), verbose);\n-\t  pp_semicolon (pp);\n-\t}\n-      break;\n-    case TRAP_IF:\n-      pp_string (pp, \"trap_if \");\n-      print_value (pp, TRAP_CONDITION (x), verbose);\n-      break;\n-    case UNSPEC:\n-    case UNSPEC_VOLATILE:\n-      /* Fallthru -- leave UNSPECs to print_exp.  */\n-    default:\n-      print_value (pp, x, verbose);\n-    }\n-}\t\t\t\t/* print_pattern */\n-\n-/* This is the main function in slim rtl visualization mechanism.\n-\n-   X is an insn, to be printed into PP.\n-\n-   This function tries to print it properly in human-readable form,\n-   resembling assembler mnemonics (instead of the older Lisp-style\n-   form).\n-\n-   If VERBOSE is TRUE, insns are printed with more complete (but\n-   longer) pattern names and with extra information, and prefixed\n-   with their INSN_UIDs.  */\n-\n-void\n-print_insn (pretty_printer *pp, const rtx_insn *x, int verbose)\n-{\n-  if (verbose)\n-    {\n-      /* Blech, pretty-print can't print integers with a specified width.  */\n-      char uid_prefix[32];\n-      snprintf (uid_prefix, sizeof uid_prefix, \" %4d: \", INSN_UID (x));\n-      pp_string (pp, uid_prefix);\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case INSN:\n-      print_pattern (pp, PATTERN (x), verbose);\n-      break;\n-\n-    case DEBUG_INSN:\n-      {\n-\tconst char *name = \"?\";\n-\n-\tif (DECL_P (INSN_VAR_LOCATION_DECL (x)))\n-\t  {\n-\t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (x));\n-\t    char idbuf[32];\n-\t    if (id)\n-\t      name = IDENTIFIER_POINTER (id);\n-\t    else if (TREE_CODE (INSN_VAR_LOCATION_DECL (x))\n-\t\t     == DEBUG_EXPR_DECL)\n-\t      {\n-\t\tsprintf (idbuf, \"D#%i\",\n-\t\t\t DEBUG_TEMP_UID (INSN_VAR_LOCATION_DECL (x)));\n-\t\tname = idbuf;\n-\t      }\n-\t    else\n-\t      {\n-\t\tsprintf (idbuf, \"D.%i\",\n-\t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (x)));\n-\t\tname = idbuf;\n-\t      }\n-\t  }\n-\tpp_printf (pp, \"debug %s => \", name);\n-\tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (x)))\n-\t  pp_string (pp, \"optimized away\");\n-\telse\n-\t  print_pattern (pp, INSN_VAR_LOCATION_LOC (x), verbose);\n-      }\n-      break;\n-\n-    case JUMP_INSN:\n-      print_pattern (pp, PATTERN (x), verbose);\n-      break;\n-    case CALL_INSN:\n-      if (GET_CODE (PATTERN (x)) == PARALLEL)\n-        print_pattern (pp, XVECEXP (PATTERN (x), 0, 0), verbose);\n-      else\n-\tprint_pattern (pp, PATTERN (x), verbose);\n-      break;\n-    case CODE_LABEL:\n-      pp_printf (pp, \"L%d:\", INSN_UID (x));\n-      break;\n-    case JUMP_TABLE_DATA:\n-      pp_string (pp, \"jump_table_data{\\n\");\n-      print_pattern (pp, PATTERN (x), verbose);\n-      pp_right_brace (pp);\n-      break;\n-    case BARRIER:\n-      pp_string (pp, \"barrier\");\n-      break;\n-    case NOTE:\n-      {\n-\tpp_string (pp, GET_NOTE_INSN_NAME (NOTE_KIND (x)));\n-\tswitch (NOTE_KIND (x))\n-\t  {\n-\t  case NOTE_INSN_EH_REGION_BEG:\n-\t  case NOTE_INSN_EH_REGION_END:\n-\t    pp_printf (pp, \" %d\", NOTE_EH_HANDLER (x));\n-\t    break;\n-\n-\t  case NOTE_INSN_BLOCK_BEG:\n-\t  case NOTE_INSN_BLOCK_END:\n-\t    pp_printf (pp, \" %d\", BLOCK_NUMBER (NOTE_BLOCK (x)));\n-\t    break;\n-\n-\t  case NOTE_INSN_BASIC_BLOCK:\n-\t    pp_printf (pp, \" %d\", NOTE_BASIC_BLOCK (x)->index);\n-\t    break;\n-\n-\t  case NOTE_INSN_DELETED_LABEL:\n-\t  case NOTE_INSN_DELETED_DEBUG_LABEL:\n-\t    {\n-\t      const char *label = NOTE_DELETED_LABEL_NAME (x);\n-\t      if (label == NULL)\n-\t\tlabel = \"\";\n-\t      pp_printf (pp, \" (\\\"%s\\\")\", label);\n-\t    }\n-\t    break;\n-\n-\t  case NOTE_INSN_VAR_LOCATION:\n-\t  case NOTE_INSN_CALL_ARG_LOCATION:\n-\t    pp_left_brace (pp);\n-\t    print_pattern (pp, NOTE_VAR_LOCATION (x), verbose);\n-\t    pp_right_brace (pp);\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\tbreak;\n-      }\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\t\t\t\t/* print_insn */\n-\n-/* Pretty-print a slim dump of X (an insn) to PP, including any register\n-   note attached to the instruction.  */\n-\n-static void\n-print_insn_with_notes (pretty_printer *pp, const rtx_insn *x)\n-{\n-  pp_string (pp, print_rtx_head);\n-  print_insn (pp, x, 1);\n-  pp_newline (pp);\n-  if (INSN_P (x) && REG_NOTES (x))\n-    for (rtx note = REG_NOTES (x); note; note = XEXP (note, 1))\n-      {\n-\tpp_printf (pp, \"%s      %s \", print_rtx_head,\n-\t\t   GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n-\tif (GET_CODE (note) == INT_LIST)\n-\t  pp_printf (pp, \"%d\", XINT (note, 0));\n-\telse\n-\t  print_pattern (pp, XEXP (note, 0), 1);\n-\tpp_newline (pp);\n-      }\n-}\n-\n-/* Print X, an RTL value node, to file F in slim format.  Include\n-   additional information if VERBOSE is nonzero.\n-\n-   Value nodes are constants, registers, labels, symbols and\n-   memory.  */\n-\n-void\n-dump_value_slim (FILE *f, const_rtx x, int verbose)\n-{\n-  pretty_printer rtl_slim_pp;\n-  rtl_slim_pp.buffer->stream = f;\n-  print_value (&rtl_slim_pp, x, verbose);\n-  pp_flush (&rtl_slim_pp);\n-}\n-\n-/* Emit a slim dump of X (an insn) to the file F, including any register\n-   note attached to the instruction.  */\n-void\n-dump_insn_slim (FILE *f, const rtx_insn *x)\n-{\n-  pretty_printer rtl_slim_pp;\n-  rtl_slim_pp.buffer->stream = f;\n-  print_insn_with_notes (&rtl_slim_pp, x);\n-  pp_flush (&rtl_slim_pp);\n-}\n-\n-/* Same as above, but stop at LAST or when COUNT == 0.\n-   If COUNT < 0 it will stop only at LAST or NULL rtx.  */\n-\n-void\n-dump_rtl_slim (FILE *f, const rtx_insn *first, const rtx_insn *last,\n-\t       int count, int flags ATTRIBUTE_UNUSED)\n-{\n-  const rtx_insn *insn, *tail;\n-  pretty_printer rtl_slim_pp;\n-  rtl_slim_pp.buffer->stream = f;\n-\n-  tail = last ? NEXT_INSN (last) : NULL;\n-  for (insn = first;\n-       (insn != NULL) && (insn != tail) && (count != 0);\n-       insn = NEXT_INSN (insn))\n-    {\n-      print_insn_with_notes (&rtl_slim_pp, insn);\n-      if (count > 0)\n-        count--;\n-    }\n-\n-  pp_flush (&rtl_slim_pp);\n-}\n-\n-/* Dumps basic block BB to pretty-printer PP in slim form and without and\n-   no indentation, for use as a label of a DOT graph record-node.  */\n-\n-void\n-rtl_dump_bb_for_graph (pretty_printer *pp, basic_block bb)\n-{\n-  rtx_insn *insn;\n-  bool first = true;\n-\n-  /* TODO: inter-bb stuff.  */\n-  FOR_BB_INSNS (bb, insn)\n-    {\n-      if (! first)\n-\t{\n-\t  pp_bar (pp);\n-\t  pp_write_text_to_stream (pp);\n-\t}\n-      first = false;\n-      print_insn_with_notes (pp, insn);\n-      pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n-    }\n-}\n-\n-/* Pretty-print pattern X of some insn in non-verbose mode.\n-   Return a string pointer to the pretty-printer buffer.\n-\n-   This function is only exported exists only to accommodate some older users\n-   of the slim RTL pretty printers.  Please do not use it for new code.  */\n-\n-const char *\n-str_pattern_slim (const_rtx x)\n-{\n-  pretty_printer rtl_slim_pp;\n-  print_pattern (&rtl_slim_pp, x, 0);\n-  return ggc_strdup (pp_formatted_text (&rtl_slim_pp));\n-}\n-\n-/* Emit a slim dump of X (an insn) to stderr.  */\n-extern void debug_insn_slim (const rtx_insn *);\n-DEBUG_FUNCTION void\n-debug_insn_slim (const rtx_insn *x)\n-{\n-  dump_insn_slim (stderr, x);\n-}\n-\n-/* Same as above, but using dump_rtl_slim.  */\n-extern void debug_rtl_slim (FILE *, const rtx_insn *, const rtx_insn *,\n-\t\t\t    int, int);\n-DEBUG_FUNCTION void\n-debug_rtl_slim (const rtx_insn *first, const rtx_insn *last, int count,\n-\t\tint flags)\n-{\n-  dump_rtl_slim (stderr, first, last, count, flags);\n-}\n-\n-extern void debug_bb_slim (basic_block);\n-DEBUG_FUNCTION void\n-debug_bb_slim (basic_block bb)\n-{\n-  dump_bb (stderr, bb, 0, TDF_SLIM | TDF_BLOCKS);\n-}\n-\n-extern void debug_bb_n_slim (int);\n-DEBUG_FUNCTION void\n-debug_bb_n_slim (int n)\n-{\n-  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, n);\n-  debug_bb_slim (bb);\n-}\n-"}, {"sha": "e0320860cb9573ae1dd892b46ccaf27f7b666bcb", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013a8899f5d9469a835cf1f6ccb1b29f69344959/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=013a8899f5d9469a835cf1f6ccb1b29f69344959", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"sel-sched-ir.h\"\n #include \"sel-sched-dump.h\"\n+#include \"print-rtl.h\"\n \f\n \n /* These variables control high-level pretty printing.  */"}]}