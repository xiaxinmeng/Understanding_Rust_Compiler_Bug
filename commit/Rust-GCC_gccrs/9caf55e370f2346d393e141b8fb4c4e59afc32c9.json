{"sha": "9caf55e370f2346d393e141b8fb4c4e59afc32c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhZjU1ZTM3MGYyMzQ2ZDM5M2UxNDFiOGZiNGM0ZTU5YWZjMzJjOQ==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-09-06T10:29:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T10:29:47Z"}, "message": "frontend.adb (Frontend): Skip -gnatec=gnat.adc switch, because we've already read gnat.adc by default.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* frontend.adb (Frontend): Skip -gnatec=gnat.adc\n\tswitch, because we've already read gnat.adc by default.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch5.adb (Get_Default_Iterator): Replace\n\t\"Assert(False)\" with \"return Iter\", because if an iterable\n\ttype is derived from a noniterable one, then we won't find an\n\toverriding or inherited default iterator.\n\nFrom-SVN: r251774", "tree": {"sha": "e4bb54c36f23438917aa71ce413eb309e035d813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4bb54c36f23438917aa71ce413eb309e035d813"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9caf55e370f2346d393e141b8fb4c4e59afc32c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caf55e370f2346d393e141b8fb4c4e59afc32c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caf55e370f2346d393e141b8fb4c4e59afc32c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caf55e370f2346d393e141b8fb4c4e59afc32c9/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6877306fbd70a365ebb8e427e108a399ae924498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6877306fbd70a365ebb8e427e108a399ae924498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6877306fbd70a365ebb8e427e108a399ae924498"}], "stats": {"total": 430, "additions": 223, "deletions": 207}, "files": [{"sha": "19d518ed9063e01bd560f509def55d47dbb1bd45", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9caf55e370f2346d393e141b8fb4c4e59afc32c9", "patch": "@@ -1,3 +1,15 @@\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* frontend.adb (Frontend): Skip -gnatec=gnat.adc\n+\tswitch, because we've already read gnat.adc by default.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch5.adb (Get_Default_Iterator): Replace\n+\t\"Assert(False)\" with \"return Iter\", because if an iterable\n+\ttype is derived from a noniterable one, then we won't find an\n+\toverriding or inherited default iterator.\n+\n 2017-09-06  Yannick Moy  <moy@adacore.com>\n \n \t* sem_warn.adb (Warn_On_Suspicious_Index): Improve warning when the"}, {"sha": "63cc4592967ad6fc8ada241df09e4d8fee56a723", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=9caf55e370f2346d393e141b8fb4c4e59afc32c9", "patch": "@@ -3934,9 +3934,9 @@ package body Exp_Ch5 is\n \n             function Get_Default_Iterator\n               (T : Entity_Id) return Entity_Id;\n-            --  If the container is a derived type, the aspect holds the parent\n-            --  operation. The required one is a primitive of the derived type\n-            --  and is either inherited or overridden. Also sets Container_Arg.\n+            --  Return the default iterator for a specific type. If the type is\n+            --  derived, we return the inherited or overridden one if\n+            --  appropriate.\n \n             --------------------------\n             -- Get_Default_Iterator --\n@@ -3953,11 +3953,11 @@ package body Exp_Ch5 is\n             begin\n                Container_Arg := New_Copy_Tree (Container);\n \n-               --  A previous version of GNAT allowed indexing aspects to\n-               --  be redefined on derived container types, while the\n-               --  default iterator was inherited from the parent type.\n-               --  This non-standard extension is preserved temporarily for\n-               --  use by the modelling project under debug flag d.X.\n+               --  A previous version of GNAT allowed indexing aspects to be\n+               --  redefined on derived container types, while the default\n+               --  iterator was inherited from the parent type. This\n+               --  nonstandard extension is preserved for use by the\n+               --  modelling project under debug flag -gnatd.X.\n \n                if Debug_Flag_Dot_XX then\n                   if Base_Type (Etype (Container)) /=\n@@ -3995,9 +3995,11 @@ package body Exp_Ch5 is\n                      Next_Elmt (Prim);\n                   end loop;\n \n-                  --  Default iterator must exist\n+                  --  If we didn't find it, then our parent type is not\n+                  --  iterable, so we return the Default_Iterator aspect of\n+                  --  this type.\n \n-                  pragma Assert (False);\n+                  return Iter;\n \n                --  Otherwise not a derived type\n "}, {"sha": "461c04bcc73e8fd8e921ba2a180052919f56a590", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 199, "deletions": 197, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caf55e370f2346d393e141b8fb4c4e59afc32c9/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=9caf55e370f2346d393e141b8fb4c4e59afc32c9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -68,9 +68,6 @@ with Tbuild;   use Tbuild;\n with Types;    use Types;\n \n procedure Frontend is\n-   Config_Pragmas : List_Id;\n-   --  Gather configuration pragmas\n-\n begin\n    --  Carry out package initializations. These are initializations which might\n    --  logically be performed at elaboration time, were it not for the fact\n@@ -136,6 +133,12 @@ begin\n    --  Read and process configuration pragma files if present\n \n    declare\n+      Config_Pragmas : List_Id := Empty_List;\n+      --  Gather configuration pragmas\n+\n+      Gnat_Adc : constant File_Name_Type := Name_Find (\"gnat.adc\");\n+      Dot_Gnat_Adc : constant File_Name_Type := Name_Find (\"./gnat.adc\");\n+\n       Save_Style_Check : constant Boolean := Opt.Style_Check;\n       --  Save style check mode so it can be restored later\n \n@@ -144,8 +147,6 @@ begin\n \n       Prag : Node_Id;\n \n-      Temp_File : Boolean;\n-\n    begin\n       --  We always analyze config files with style checks off, since we\n       --  don't want a miscellaneous gnat.adc that is around to discombobulate\n@@ -162,9 +163,7 @@ begin\n       --  First deal with gnat.adc file\n \n       if Opt.Config_File then\n-         Name_Buffer (1 .. 8) := \"gnat.adc\";\n-         Name_Len := 8;\n-         Source_gnat_adc := Load_Config_File (Name_Enter);\n+         Source_gnat_adc := Load_Config_File (Gnat_Adc);\n \n          --  Case of gnat.adc file present\n \n@@ -175,20 +174,11 @@ begin\n             Initialize_Scanner (No_Unit, Source_gnat_adc);\n             Config_Pragmas := Par (Configuration_Pragmas => True);\n \n-            --  We unconditionally add a compilation dependency for gnat.adc\n-            --  so that if it changes, we force a recompilation. This is a\n-            --  fairly recent (2014-03-28) change.\n+            --  We add a compilation dependency for gnat.adc so that if it\n+            --  changes, we force a recompilation.\n \n             Prepcomp.Add_Dependency (Source_gnat_adc);\n-\n-         --  Case of no gnat.adc file present\n-\n-         else\n-            Config_Pragmas := Empty_List;\n          end if;\n-\n-      else\n-         Config_Pragmas := Empty_List;\n       end if;\n \n       --  Now deal with specified config pragmas files if there are any\n@@ -198,42 +188,50 @@ begin\n          --  Loop through config pragmas files\n \n          for Index in Opt.Config_File_Names'Range loop\n-\n-            --  See if extension is .TMP/.tmp indicating a temporary config\n-            --  file (which we ignore from the dependency point of view).\n-\n-            Name_Len := Config_File_Names (Index)'Length;\n-            Name_Buffer (1 .. Name_Len) := Config_File_Names (Index).all;\n-            Temp_File :=\n-              Name_Len > 4\n-                and then\n-                  (Name_Buffer (Name_Len - 3 .. Name_Len) = \".TMP\"\n+            declare\n+               Len : constant Natural := Config_File_Names (Index)'Length;\n+               Str : constant String (1 .. Len) :=\n+                 Config_File_Names (Index).all;\n+               Config_Name : constant File_Name_Type := Name_Find (Str);\n+               Temp_File : constant Boolean := Len > 4\n+                 and then\n+                  (Str (Len - 3 .. Len) = \".TMP\"\n                      or else\n-                   Name_Buffer (Name_Len - 3 .. Name_Len) = \".tmp\");\n+                   Str (Len - 3 .. Len) = \".tmp\");\n+               --  Extension indicating a temporary config file?\n \n-            --  Load the file, error if we did not find it\n+            begin\n+               --  Skip it if it's the default name, already loaded above.\n+               --  Otherwise, we get confusing warning messages about\n+               --  seeing the same thing twice.\n \n-            Source_Config_File := Load_Config_File (Name_Enter);\n+               if Config_Name /= Gnat_Adc\n+                 and then Config_Name /= Dot_Gnat_Adc\n+               then\n+                  --  Load the file, error if we did not find it\n \n-            if Source_Config_File = No_Source_File then\n-               Osint.Fail\n-                 (\"cannot find configuration pragmas file \"\n-                  & Config_File_Names (Index).all);\n+                  Source_Config_File := Load_Config_File (Config_Name);\n \n-            --  If we did find the file, and it is not a temporary file, then\n-            --  we unconditionally add a compilation dependency for it so\n-            --  that if it changes, we force a recompilation. This is a\n-            --  fairly recent (2014-03-28) change.\n+                  if Source_Config_File = No_Source_File then\n+                     Osint.Fail\n+                       (\"cannot find configuration pragmas file \"\n+                        & Config_File_Names (Index).all);\n \n-            elsif not Temp_File then\n-               Prepcomp.Add_Dependency (Source_Config_File);\n-            end if;\n+                  --  If we did find the file, and it is not a temporary file,\n+                  --  then we add a compilation dependency for it so that if it\n+                  --  changes, we force a recompilation.\n+\n+                  elsif not Temp_File then\n+                     Prepcomp.Add_Dependency (Source_Config_File);\n+                  end if;\n \n-            --  Parse the config pragmas file, and accumulate results\n+                  --  Parse the config pragmas file, and accumulate results\n \n-            Initialize_Scanner (No_Unit, Source_Config_File);\n-            Append_List_To\n-              (Config_Pragmas, Par (Configuration_Pragmas => True));\n+                  Initialize_Scanner (No_Unit, Source_Config_File);\n+                  Append_List_To\n+                    (Config_Pragmas, Par (Configuration_Pragmas => True));\n+               end if;\n+            end;\n          end loop;\n       end if;\n \n@@ -260,208 +258,212 @@ begin\n       --  Capture any modifications to suppress options from config pragmas\n \n       Opt.Suppress_Options := Scope_Suppress;\n-   end;\n-\n-   --  If a target dependency info file has been read through switch -gnateT=,\n-   --  add it to the dependencies.\n-\n-   if Target_Dependent_Info_Read_Name /= null then\n-      declare\n-         Index : Source_File_Index;\n-      begin\n-         Name_Len := 0;\n-         Add_Str_To_Name_Buffer (Target_Dependent_Info_Read_Name.all);\n-         Index := Load_Config_File (Name_Enter);\n-         Prepcomp.Add_Dependency (Index);\n-      end;\n-   end if;\n \n-   --  This is where we can capture the value of the compilation unit specific\n-   --  restrictions that have been set by the config pragma files (or from\n-   --  Targparm), for later restoration when processing e.g. subunits.\n+      --  If a target dependency info file has been read through switch\n+      --  -gnateT=, add it to the dependencies.\n+\n+      if Target_Dependent_Info_Read_Name /= null then\n+         declare\n+            Index : Source_File_Index;\n+         begin\n+            Name_Len := 0;\n+            Add_Str_To_Name_Buffer (Target_Dependent_Info_Read_Name.all);\n+            Index := Load_Config_File (Name_Enter);\n+            Prepcomp.Add_Dependency (Index);\n+         end;\n+      end if;\n \n-   Save_Config_Cunit_Boolean_Restrictions;\n+      --  This is where we can capture the value of the compilation unit\n+      --  specific restrictions that have been set by the config pragma\n+      --  files (or from Targparm), for later restoration when processing\n+      --  e.g. subunits.\n \n-   --  If there was a -gnatem switch, initialize the mappings of unit names to\n-   --  file names and of file names to path names from the mapping file.\n+      Save_Config_Cunit_Boolean_Restrictions;\n \n-   if Mapping_File_Name /= null then\n-      Fmap.Initialize (Mapping_File_Name.all);\n-   end if;\n+      --  If there was a -gnatem switch, initialize the mappings of unit names\n+      --  to file names and of file names to path names from the mapping file.\n \n-   --  Adjust Optimize_Alignment mode from debug switches if necessary\n+      if Mapping_File_Name /= null then\n+         Fmap.Initialize (Mapping_File_Name.all);\n+      end if;\n \n-   if Debug_Flag_Dot_SS then\n-      Optimize_Alignment := 'S';\n-   elsif Debug_Flag_Dot_TT then\n-      Optimize_Alignment := 'T';\n-   end if;\n+      --  Adjust Optimize_Alignment mode from debug switches if necessary\n \n-   --  We have now processed the command line switches, and the configuration\n-   --  pragma files, so this is the point at which we want to capture the\n-   --  values of the configuration switches (see Opt for further details).\n+      if Debug_Flag_Dot_SS then\n+         Optimize_Alignment := 'S';\n+      elsif Debug_Flag_Dot_TT then\n+         Optimize_Alignment := 'T';\n+      end if;\n \n-   Opt.Register_Opt_Config_Switches;\n+      --  We have now processed the command line switches, and the\n+      --  configuration pragma files, so this is the point at which we want to\n+      --  capture the values of the configuration switches (see Opt for further\n+      --  details).\n \n-   --  Check for file which contains No_Body pragma\n+      Opt.Register_Opt_Config_Switches;\n \n-   if Source_File_Is_No_Body (Source_Index (Main_Unit)) then\n-      Change_Main_Unit_To_Spec;\n-   end if;\n+      --  Check for file which contains No_Body pragma\n \n-   --  Initialize the scanner. Note that we do this after the call to\n-   --  Create_Standard, which uses the scanner in its processing of\n-   --  floating-point bounds.\n-\n-   Initialize_Scanner (Main_Unit, Source_Index (Main_Unit));\n+      if Source_File_Is_No_Body (Source_Index (Main_Unit)) then\n+         Change_Main_Unit_To_Spec;\n+      end if;\n \n-   --  Here we call the parser to parse the compilation unit (or units in\n-   --  the check syntax mode, but in that case we won't go on to the\n-   --  semantics in any case).\n+      --  Initialize the scanner. Note that we do this after the call to\n+      --  Create_Standard, which uses the scanner in its processing of\n+      --  floating-point bounds.\n \n-   Discard_List (Par (Configuration_Pragmas => False));\n-   Parsing_Main_Extended_Source := False;\n+      Initialize_Scanner (Main_Unit, Source_Index (Main_Unit));\n \n-   --  The main unit is now loaded, and subunits of it can be loaded,\n-   --  without reporting spurious loading circularities.\n+      --  Here we call the parser to parse the compilation unit (or units in\n+      --  the check syntax mode, but in that case we won't go on to the\n+      --  semantics in any case).\n \n-   Set_Loading (Main_Unit, False);\n+      Discard_List (Par (Configuration_Pragmas => False));\n+      Parsing_Main_Extended_Source := False;\n \n-   --  Now that the main unit is installed, we can complete the analysis\n-   --  of the pragmas in gnat.adc and the configuration file, that require\n-   --  a context for their semantic processing.\n+      --  The main unit is now loaded, and subunits of it can be loaded,\n+      --  without reporting spurious loading circularities.\n \n-   if Config_Pragmas /= Error_List\n-     and then Operating_Mode /= Check_Syntax\n+      Set_Loading (Main_Unit, False);\n \n-     --  Do not attempt to process deferred configuration pragmas if the main\n-     --  unit failed to load, to avoid cascaded inconsistencies that can lead\n-     --  to a compiler crash.\n+      --  Now that the main unit is installed, we can complete the analysis\n+      --  of the pragmas in gnat.adc and the configuration file, that require\n+      --  a context for their semantic processing.\n \n-     and then Fatal_Error (Main_Unit) /= Error_Detected\n-   then\n-      --  Pragmas that require some semantic activity, such as Interrupt_State,\n-      --  cannot be processed until the main unit is installed, because they\n-      --  require a compilation unit on which to attach with_clauses, etc. So\n-      --  analyze them now.\n+      if Config_Pragmas /= Error_List\n+        and then Operating_Mode /= Check_Syntax\n \n-      declare\n-         Prag : Node_Id;\n+        --  Do not attempt to process deferred configuration pragmas if the\n+        --  main unit failed to load, to avoid cascaded inconsistencies that\n+        --  can lead to a compiler crash.\n \n-      begin\n-         Prag := First (Config_Pragmas);\n-         while Present (Prag) loop\n+        and then Fatal_Error (Main_Unit) /= Error_Detected\n+      then\n+         --  Pragmas that require some semantic activity, such as\n+         --  Interrupt_State, cannot be processed until the main unit is\n+         --  installed, because they require a compilation unit on which to\n+         --  attach with_clauses, etc. So analyze them now.\n+\n+         declare\n+            Prag : Node_Id;\n+\n+         begin\n+            Prag := First (Config_Pragmas);\n+            while Present (Prag) loop\n+\n+               --  Guard against the case where a configuration pragma may be\n+               --  split into multiple pragmas and the original rewritten as a\n+               --  null statement.\n+\n+               if Nkind (Prag) = N_Pragma\n+                 and then Delay_Config_Pragma_Analyze (Prag)\n+               then\n+                  Analyze_Pragma (Prag);\n+               end if;\n+\n+               Next (Prag);\n+            end loop;\n+         end;\n+      end if;\n \n-            --  Guard against the case where a configuration pragma may be\n-            --  split into multiple pragmas and the original rewritten as a\n-            --  null statement.\n+      --  If we have restriction No_Exception_Propagation, and we did not have\n+      --  an explicit switch turning off Warn_On_Non_Local_Exception, then turn\n+      --  on this warning by default if we have encountered an exception\n+      --  handler.\n \n-            if Nkind (Prag) = N_Pragma\n-              and then Delay_Config_Pragma_Analyze (Prag)\n-            then\n-               Analyze_Pragma (Prag);\n-            end if;\n+      if Restriction_Check_Required (No_Exception_Propagation)\n+        and then not No_Warn_On_Non_Local_Exception\n+        and then Exception_Handler_Encountered\n+      then\n+         Warn_On_Non_Local_Exception := True;\n+      end if;\n \n-            Next (Prag);\n-         end loop;\n-      end;\n-   end if;\n+      --  Now on to the semantics. Skip if in syntax only mode\n \n-   --  If we have restriction No_Exception_Propagation, and we did not have an\n-   --  explicit switch turning off Warn_On_Non_Local_Exception, then turn on\n-   --  this warning by default if we have encountered an exception handler.\n+      if Operating_Mode /= Check_Syntax then\n \n-   if Restriction_Check_Required (No_Exception_Propagation)\n-     and then not No_Warn_On_Non_Local_Exception\n-     and then Exception_Handler_Encountered\n-   then\n-      Warn_On_Non_Local_Exception := True;\n-   end if;\n+         --  Install the configuration pragmas in the tree\n \n-   --  Now on to the semantics. Skip if in syntax only mode\n+         Set_Config_Pragmas\n+           (Aux_Decls_Node (Cunit (Main_Unit)), Config_Pragmas);\n \n-   if Operating_Mode /= Check_Syntax then\n+         --  Following steps are skipped if we had a fatal error during parsing\n \n-      --  Install the configuration pragmas in the tree\n+         if Fatal_Error (Main_Unit) /= Error_Detected then\n \n-      Set_Config_Pragmas (Aux_Decls_Node (Cunit (Main_Unit)), Config_Pragmas);\n+            --  Reset Operating_Mode to Check_Semantics for subunits. We cannot\n+            --  actually generate code for subunits, so we suppress expansion.\n+            --  This also corrects certain problems that occur if we try to\n+            --  incorporate subunits at a lower level.\n \n-      --  Following steps are skipped if we had a fatal error during parsing\n+            if Operating_Mode = Generate_Code\n+              and then Nkind (Unit (Cunit (Main_Unit))) = N_Subunit\n+            then\n+               Operating_Mode := Check_Semantics;\n+            end if;\n \n-      if Fatal_Error (Main_Unit) /= Error_Detected then\n+            --  Analyze (and possibly expand) main unit\n \n-         --  Reset Operating_Mode to Check_Semantics for subunits. We cannot\n-         --  actually generate code for subunits, so we suppress expansion.\n-         --  This also corrects certain problems that occur if we try to\n-         --  incorporate subunits at a lower level.\n+            Scope_Suppress := Suppress_Options;\n+            Semantics (Cunit (Main_Unit));\n \n-         if Operating_Mode = Generate_Code\n-           and then Nkind (Unit (Cunit (Main_Unit))) = N_Subunit\n-         then\n-            Operating_Mode := Check_Semantics;\n-         end if;\n+            --  Cleanup processing after completing main analysis\n \n-         --  Analyze (and possibly expand) main unit\n+            --  Comment needed for ASIS mode test and GNATprove mode test???\n \n-         Scope_Suppress := Suppress_Options;\n-         Semantics (Cunit (Main_Unit));\n+            pragma Assert\n+              (Operating_Mode = Generate_Code\n+                or else Operating_Mode = Check_Semantics);\n \n-         --  Cleanup processing after completing main analysis\n+            if Operating_Mode = Generate_Code\n+              or else (ASIS_Mode or GNATprove_Mode)\n+            then\n+               Instantiate_Bodies;\n+            end if;\n \n-         --  Comment needed for ASIS mode test and GNATprove mode test???\n+            --  Analyze inlined bodies and check elaboration rules in GNATprove\n+            --  mode as well as during compilation.\n \n-         pragma Assert\n-           (Operating_Mode = Generate_Code\n-             or else Operating_Mode = Check_Semantics);\n+            if Operating_Mode = Generate_Code or else GNATprove_Mode then\n+               if Inline_Processing_Required then\n+                  Analyze_Inlined_Bodies;\n+               end if;\n \n-         if Operating_Mode = Generate_Code\n-           or else (ASIS_Mode or GNATprove_Mode)\n-         then\n-            Instantiate_Bodies;\n-         end if;\n+               --  Remove entities from program that do not have any execution\n+               --  time references.\n \n-         --  Analyze inlined bodies and check elaboration rules in GNATprove\n-         --  mode as well as during compilation.\n+               if Debug_Flag_UU then\n+                  Collect_Garbage_Entities;\n+               end if;\n \n-         if Operating_Mode = Generate_Code or else GNATprove_Mode then\n-            if Inline_Processing_Required then\n-               Analyze_Inlined_Bodies;\n-            end if;\n+               Check_Elab_Calls;\n \n-            --  Remove entities from program that do not have any execution\n-            --  time references.\n+               --  Remove any ignored Ghost code as it must not appear in the\n+               --  executable.\n \n-            if Debug_Flag_UU then\n-               Collect_Garbage_Entities;\n+               Remove_Ignored_Ghost_Code;\n             end if;\n \n-            Check_Elab_Calls;\n+            --  At this stage we can unnest subprogram bodies if required\n \n-            --  Remove any ignored Ghost code as it must not appear in the\n-            --  executable.\n+            Exp_Unst.Unnest_Subprograms (Cunit (Main_Unit));\n \n-            Remove_Ignored_Ghost_Code;\n-         end if;\n+            --  List library units if requested\n \n-         --  At this stage we can unnest subprogram bodies if required\n-\n-         Exp_Unst.Unnest_Subprograms (Cunit (Main_Unit));\n+            if List_Units then\n+               Lib.List;\n+            end if;\n \n-         --  List library units if requested\n+            --  Output waiting warning messages\n \n-         if List_Units then\n-            Lib.List;\n+            Lib.Xref.Process_Deferred_References;\n+            Sem_Warn.Output_Non_Modified_In_Out_Warnings;\n+            Sem_Warn.Output_Unreferenced_Messages;\n+            Sem_Warn.Check_Unused_Withs;\n+            Sem_Warn.Output_Unused_Warnings_Off_Warnings;\n          end if;\n-\n-         --  Output waiting warning messages\n-\n-         Lib.Xref.Process_Deferred_References;\n-         Sem_Warn.Output_Non_Modified_In_Out_Warnings;\n-         Sem_Warn.Output_Unreferenced_Messages;\n-         Sem_Warn.Check_Unused_Withs;\n-         Sem_Warn.Output_Unused_Warnings_Off_Warnings;\n       end if;\n-   end if;\n+   end;\n \n    --  Qualify all entity names in inner packages, package bodies, etc\n "}]}