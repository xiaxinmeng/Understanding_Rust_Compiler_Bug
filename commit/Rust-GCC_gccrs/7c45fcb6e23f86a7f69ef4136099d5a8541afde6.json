{"sha": "7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0NWZjYjZlMjNmODZhN2Y2OWVmNDEzNjA5OWQ1YTg1NDFhZmRlNg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-11T09:40:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-11T09:40:31Z"}, "message": "Merge #424\n\n424: Support Impl items to also be generic r=philberty a=philberty\n\nHandle inherited type arguments for methods\r\n    \r\nMethodCallExpr's support generic arguments so we need to handle adjusting\r\nany inherited type arguments from the receiver and apply them to the func.\r\n    \r\nThis changes the handle_substitutions function for ADT, FnType and Params\r\nto be permissive that we can send single arguments to partially substitute\r\nthe type such as the case when we inherit arguments in methods calls. This\r\nis safe because the other interfaces enforce the type checking and number\r\nof arguments etc.\r\n    \r\nFixes #423  #417\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "43459717de6d35d858dce11932a29700444967d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43459717de6d35d858dce11932a29700444967d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgmlEPCRBK7hj4Ov3rIwAAwUsIAAyKjF0lNA6jrXOY2uKo7ChN\nR1BBbFIVaX81+98THiq5k3pHHAAhQe2GmbgxokidX/0wbU2whN8cuPtfXA//IwRn\nA3nqgj/O23kTzr92NIhzSTRYesAPeSvfYHHuo1wB9IfKgulaP65hfohDn+nhM54N\nbvi5blbxqmB+XaftewGBAkMrQKBMwAZHYHi2/eEtnHYLlDzYKCeyR90sv5p4Vbp4\nkZB4j+B+akH8NjL7iNCjEjexpeZnBzxsd/o6HZeZGk6EViQJw7Gl5XpnGrVYyFA5\nUmzJB4z/F12S61hkckwkOEAMiX/rakwU8Sgdt0enJ6h5BNjYIG2kQs1LWHD7+ss=\n=XhB8\n-----END PGP SIGNATURE-----\n", "payload": "tree 43459717de6d35d858dce11932a29700444967d6\nparent 7e66d683186ffdcca835bad1a90081fe56be8822\nparent 99d1330b79a6b8457b45bba2a7b9940b1f2e9acd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620726031 +0000\ncommitter GitHub <noreply@github.com> 1620726031 +0000\n\nMerge #424\n\n424: Support Impl items to also be generic r=philberty a=philberty\n\nHandle inherited type arguments for methods\r\n    \r\nMethodCallExpr's support generic arguments so we need to handle adjusting\r\nany inherited type arguments from the receiver and apply them to the func.\r\n    \r\nThis changes the handle_substitutions function for ADT, FnType and Params\r\nto be permissive that we can send single arguments to partially substitute\r\nthe type such as the case when we inherit arguments in methods calls. This\r\nis safe because the other interfaces enforce the type checking and number\r\nof arguments etc.\r\n    \r\nFixes #423  #417\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e66d683186ffdcca835bad1a90081fe56be8822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e66d683186ffdcca835bad1a90081fe56be8822", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e66d683186ffdcca835bad1a90081fe56be8822"}, {"sha": "99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d1330b79a6b8457b45bba2a7b9940b1f2e9acd"}], "stats": {"total": 567, "additions": 374, "deletions": 193}, "files": [{"sha": "2581d68e1c8a8c33419ef82516383f966d7cdaed", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -86,7 +86,6 @@ class ASTLowerImplItem : public ASTLoweringBase\n   void visit (AST::Function &function) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n     std::vector<HIR::Attribute> outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n@@ -95,6 +94,11 @@ class ASTLowerImplItem : public ASTLoweringBase\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (function.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (function.get_generic_params ());\n+      }\n     Identifier function_name = function.get_function_name ();\n     Location locus = function.get_locus ();\n \n@@ -165,7 +169,6 @@ class ASTLowerImplItem : public ASTLoweringBase\n   void visit (AST::Method &method) override\n   {\n     // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n     std::vector<HIR::Attribute> outer_attrs;\n     std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n@@ -174,6 +177,11 @@ class ASTLowerImplItem : public ASTLoweringBase\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (method.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (method.get_generic_params ());\n+      }\n     Identifier method_name = method.get_method_name ();\n     Location locus = method.get_locus ();\n "}, {"sha": "fc67d60c0ed2402ffd2aa817d344ccb84f17824a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -745,6 +745,8 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   Location get_locus () const { return locus; }\n \n+  Location get_impl_locus () const final { return get_locus (); }\n+\n   std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n   const std::unique_ptr<BlockExpr> &get_function_body () const\n   {\n@@ -1366,6 +1368,8 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location get_locus () const { return locus; }\n \n+  Location get_impl_locus () const final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n   Analysis::NodeMapping get_impl_mappings () const override\n@@ -2266,6 +2270,8 @@ class ConstantItem : public VisItem,\n \n   Location get_locus () const { return locus; }\n \n+  Location get_impl_locus () const final { return get_locus (); }\n+\n   void accept_vis (HIRVisitor &vis) override;\n \n   Type *get_type () { return type.get (); }"}, {"sha": "f6fa62d81e351de715e6679d299d12ec6fd6ca53", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -1295,6 +1295,8 @@ class InherentImplItem\n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n   virtual Analysis::NodeMapping get_impl_mappings () const = 0;\n+\n+  virtual Location get_impl_locus () const = 0;\n };\n \n // Abstract base class for items used in a trait impl"}, {"sha": "f163ef5bb56339d5f64dbb320a2a2bb3bba8fb86", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-ast-resolve-struct-expr-field.h\"\n #include \"rust-ast-verify-assignee.h\"\n+#include \"rust-ast-resolve-type.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -92,6 +93,13 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::MethodCallExpr &expr) override\n   {\n     ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+\n+    if (expr.get_method_name ().has_generic_args ())\n+      {\n+\tAST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+\tResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n+      }\n+\n     expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n       ResolveExpr::go (p, expr.get_node_id ());\n       return true;"}, {"sha": "dc16573c51fad91187a046b201f0be44c529e2c1", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -200,14 +200,22 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    if (method.has_return_type ())\n-      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n-\n     NodeId scope_node_id = method.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n     resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n     resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+    if (method.has_generics ())\n+      {\n+\tfor (auto &generic : method.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), method.get_node_id ());\n+      }\n+\n+    if (method.has_return_type ())\n+      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n \n     // self turns into (self: Self) as a function param\n     AST::SelfParam &self_param = method.get_self_param ();\n@@ -248,6 +256,7 @@ class ResolveItem : public ResolverBase\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n   }\n \n private:"}, {"sha": "b2391e317f0f4a1adec1d291e14f8020c2f8688d", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e66d683186ffdcca835bad1a90081fe56be8822/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e66d683186ffdcca835bad1a90081fe56be8822/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=7e66d683186ffdcca835bad1a90081fe56be8822", "patch": "@@ -1,67 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_METHOD_RESOLVE_H\n-#define RUST_HIR_METHOD_RESOLVE_H\n-\n-#include \"rust-hir-type-check-base.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-hir-path-probe.h\"\n-#include \"rust-substitution-mapper.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-class MethodResolution : public TypeCheckBase\n-{\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n-public:\n-  static std::vector<PathProbeCandidate>\n-  Probe (std::vector<PathProbeCandidate> &path_candidates)\n-  {\n-    MethodResolution probe;\n-    for (auto &c : path_candidates)\n-      probe.process_candidate (c);\n-\n-    return probe.candidates;\n-  }\n-\n-  void process_candidate (PathProbeCandidate &candidate)\n-  {\n-    is_method_flag = false;\n-    candidate.impl_item->accept_vis (*this);\n-\n-    if (is_method_flag)\n-      candidates.push_back (candidate);\n-  }\n-\n-  void visit (HIR::Method &method) override { is_method_flag = true; }\n-\n-private:\n-  MethodResolution () : TypeCheckBase () {}\n-\n-  bool is_method_flag;\n-  std::vector<PathProbeCandidate> candidates;\n-};\n-\n-} // namespace Resolver\n-} // namespace Rust\n-\n-#endif // RUST_HIR_METHOD_RESOLVE_H"}, {"sha": "3e081ec30d29c310d728b467c5df9399139ed95b", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 81, "deletions": 23, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -24,7 +24,6 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n-#include \"rust-hir-method-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-const-fold.h\"\n@@ -221,46 +220,105 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t       \"failed to resolve the PathExprSegment to any Method\");\n \treturn;\n       }\n-\n-    // filter all methods\n-    auto possible_methods = MethodResolution::Probe (candidates);\n-    if (possible_methods.size () == 0)\n-      {\n-\trust_error_at (expr.get_method_name ().get_locus (),\n-\t\t       \"no method named %s found in scope\",\n-\t\t       expr.get_method_name ().as_string ().c_str ());\n-\treturn;\n-      }\n-    else if (possible_methods.size () > 1)\n+    else if (candidates.size () > 1)\n       {\n \tReportMultipleCandidateError::Report (\n-\t  possible_methods, expr.get_method_name ().get_segment (),\n+\t  candidates, expr.get_method_name ().get_segment (),\n \t  expr.get_method_name ().get_locus ());\n \treturn;\n       }\n \n-    auto resolved_candidate = possible_methods.at (0);\n+    auto resolved_candidate = candidates.at (0);\n     HIR::InherentImplItem *resolved_method = resolved_candidate.impl_item;\n     TyTy::BaseType *lookup_tyty = resolved_candidate.ty;\n \n+    if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\tRichLocation r (expr.get_method_name ().get_locus ());\n+\tr.add_range (resolved_method->get_impl_locus ());\n+\trust_error_at (r, \"associated impl item is not a method\");\n+\treturn;\n+      }\n+\n     TyTy::BaseType *lookup = lookup_tyty;\n-    if (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    if (!fn->is_method ())\n       {\n-\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-\tif (receiver_tyty->get_kind () == TyTy::TypeKind::ADT)\n+\tRichLocation r (expr.get_method_name ().get_locus ());\n+\tr.add_range (resolved_method->get_impl_locus ());\n+\trust_error_at (r, \"associated function is not a method\");\n+\treturn;\n+      }\n+\n+    if (receiver_tyty->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver_tyty);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n \t  {\n-\t    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver_tyty);\n-\t    if (adt->has_substitutions () && fn->needs_substitution ())\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ();\n+\t    rust_assert (s->can_eq (adt));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    TyTy::ADTType *self_adt = static_cast<TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n \t      {\n \t\trust_assert (adt->was_substituted ());\n-\t\tauto used_args_in_prev_segment = GetUsedSubstArgs::From (adt);\n-\t\tlookup\n-\t\t  = SubstMapperInternal::Resolve (fn,\n-\t\t\t\t\t\t  used_args_in_prev_segment);\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n \t      }\n \t  }\n       }\n \n+    // apply any remaining generic arguments\n+    if (expr.get_method_name ().has_generic_args ())\n+      {\n+\tHIR::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+\tlookup\n+\t  = SubstMapper::Resolve (lookup, expr.get_method_name ().get_locus (),\n+\t\t\t\t  &args);\n+\tif (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+    else if (lookup->needs_generic_substitutions ())\n+      {\n+\tlookup = SubstMapper::InferSubst (lookup,\n+\t\t\t\t\t  expr.get_method_name ().get_locus ());\n+      }\n+\n     TyTy::BaseType *function_ret_tyty\n       = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n     if (function_ret_tyty == nullptr"}, {"sha": "f961bbafb7132c3b570c166271fb283cfea9e41c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -112,7 +112,7 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    false, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n@@ -189,7 +189,7 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (),\n+    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (), true,\n \t\t\t\t    std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n     context->insert_type (method.get_mappings (), fnType);"}, {"sha": "ef940c166823d48819a8a593540b5c853918078a", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -229,7 +229,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    std::move (params), ret_type,\n+\t\t\t\t    false, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }"}, {"sha": "e74ab936417afc5fbde5ec85c46b61dbacd7a920", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 83, "deletions": 86, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -247,6 +247,9 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n       return SubstitutionArgumentMappings::error ();\n     }\n \n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+\n   std::vector<SubstitutionArg> mappings;\n   for (auto &arg : args.get_type_args ())\n     {\n@@ -257,8 +260,8 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n \t  return SubstitutionArgumentMappings::error ();\n \t}\n \n-      SubstitutionArg subst_arg (&substitutions.at (mappings.size ()),\n-\t\t\t\t resolved);\n+      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n+      offs++;\n       mappings.push_back (std::move (subst_arg));\n     }\n \n@@ -345,6 +348,31 @@ SubstitutionRef::adjust_mappings_for_this (\n \t\t\t\t       mappings.get_locus ());\n }\n \n+// this function assumes that the mappings being passed are for the same type as\n+// this new substitution reference so ordering matters here\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_mappings_from_receiver_for_self (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  rust_assert (mappings.size () == get_num_substitutions ());\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &param_mapping = substitutions.at (i);\n+      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+\n+      if (param_mapping.needs_substitution ())\n+\t{\n+\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -457,13 +485,6 @@ ADTType::clone ()\n ADTType *\n ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n-  if (subst_mappings.size () != get_num_substitutions ())\n-    {\n-      rust_error_at (subst_mappings.get_locus (),\n-\t\t     \"invalid number of generic arguments to generic ADT type\");\n-      return nullptr;\n-    }\n-\n   ADTType *adt = static_cast<ADTType *> (clone ());\n   adt->set_ty_ref (mappings->get_next_hir_id ());\n   adt->used_arguments = subst_mappings;\n@@ -473,8 +494,8 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n       SubstitutionArg arg = SubstitutionArg::error ();\n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n-      rust_assert (ok);\n-      sub.fill_param_ty (arg.get_tyty ());\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty ());\n     }\n \n   adt->iterate_fields ([&] (StructFieldType *field) mutable -> bool {\n@@ -486,27 +507,22 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n \tSubstitutionArg arg = SubstitutionArg::error ();\n \tbool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-\tif (!ok)\n-\t  {\n-\t    rust_error_at (subst_mappings.get_locus (),\n-\t\t\t   \"Failed to resolve parameter type: %s\",\n-\t\t\t   p->as_string ().c_str ());\n-\t    return false;\n-\t  }\n-\n-\tauto argt = arg.get_tyty ();\n-\tbool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n-\n-\tif (arg_is_param || arg_is_concrete)\n-\t  {\n-\t    auto new_field = argt->clone ();\n-\t    new_field->set_ref (fty->get_ref ());\n-\t    field->set_field_type (new_field);\n-\t  }\n-\telse\n+\tif (ok)\n \t  {\n-\t    field->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t    auto argt = arg.get_tyty ();\n+\t    bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t    bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t    if (arg_is_param || arg_is_concrete)\n+\t      {\n+\t\tauto new_field = argt->clone ();\n+\t\tnew_field->set_ref (fty->get_ref ());\n+\t\tfield->set_field_type (new_field);\n+\t      }\n+\t    else\n+\t      {\n+\t\tfield->get_field_type ()->set_ty_ref (argt->get_ref ());\n+\t      }\n \t  }\n       }\n     else if (fty->has_subsititions_defined ()\n@@ -687,22 +703,14 @@ FnType::clone ()\n     cloned_params.push_back (\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n-  return new FnType (get_ref (), get_ty_ref (), std::move (cloned_params),\n-\t\t     get_return_type ()->clone (), clone_substs (),\n-\t\t     get_combined_refs ());\n+  return new FnType (get_ref (), get_ty_ref (), is_method_flag,\n+\t\t     std::move (cloned_params), get_return_type ()->clone (),\n+\t\t     clone_substs (), get_combined_refs ());\n }\n \n FnType *\n FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n {\n-  if (subst_mappings.size () != get_num_substitutions ())\n-    {\n-      rust_error_at (\n-\tsubst_mappings.get_locus (),\n-\t\"invalid number of generic arguments to generic Function type\");\n-      return nullptr;\n-    }\n-\n   FnType *fn = static_cast<FnType *> (clone ());\n   fn->set_ty_ref (mappings->get_next_hir_id ());\n   fn->used_arguments = subst_mappings;\n@@ -713,8 +721,8 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n       bool ok\n \t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n-      rust_assert (ok);\n-      sub.fill_param_ty (arg.get_tyty ());\n+      if (ok)\n+\tsub.fill_param_ty (arg.get_tyty ());\n     }\n \n   auto fty = fn->get_return_type ();\n@@ -725,27 +733,22 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n       SubstitutionArg arg = SubstitutionArg::error ();\n       bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-      if (!ok)\n+      if (ok)\n \t{\n-\t  rust_error_at (subst_mappings.get_locus (),\n-\t\t\t \"Failed to resolve parameter type: %s\",\n-\t\t\t p->as_string ().c_str ());\n-\t  return nullptr;\n-\t}\n-\n-      auto argt = arg.get_tyty ();\n-      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\t  auto argt = arg.get_tyty ();\n+\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n \n-      if (arg_is_param || arg_is_concrete)\n-\t{\n-\t  auto new_field = argt->clone ();\n-\t  new_field->set_ref (fty->get_ref ());\n-\t  fn->type = new_field;\n-\t}\n-      else\n-\t{\n-\t  fty->set_ty_ref (argt->get_ref ());\n+\t  if (arg_is_param || arg_is_concrete)\n+\t    {\n+\t      auto new_field = argt->clone ();\n+\t      new_field->set_ref (fty->get_ref ());\n+\t      fn->type = new_field;\n+\t    }\n+\t  else\n+\t    {\n+\t      fty->set_ty_ref (argt->get_ref ());\n+\t    }\n \t}\n     }\n   else if (fty->needs_generic_substitutions ()\n@@ -778,27 +781,22 @@ FnType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \n \t  SubstitutionArg arg = SubstitutionArg::error ();\n \t  bool ok = subst_mappings.get_argument_for_symbol (p, &arg);\n-\t  if (!ok)\n+\t  if (ok)\n \t    {\n-\t      rust_error_at (subst_mappings.get_locus (),\n-\t\t\t     \"Failed to resolve parameter type: %s\",\n-\t\t\t     p->as_string ().c_str ());\n-\t      return nullptr;\n-\t    }\n-\n-\t  auto argt = arg.get_tyty ();\n-\t  bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n-\t  bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n-\n-\t  if (arg_is_param || arg_is_concrete)\n-\t    {\n-\t      auto new_field = argt->clone ();\n-\t      new_field->set_ref (fty->get_ref ());\n-\t      param.second = new_field;\n-\t    }\n-\t  else\n-\t    {\n-\t      fty->set_ty_ref (argt->get_ref ());\n+\t      auto argt = arg.get_tyty ();\n+\t      bool arg_is_param = argt->get_kind () == TyTy::TypeKind::PARAM;\n+\t      bool arg_is_concrete = argt->get_kind () != TyTy::TypeKind::INFER;\n+\n+\t      if (arg_is_param || arg_is_concrete)\n+\t\t{\n+\t\t  auto new_field = argt->clone ();\n+\t\t  new_field->set_ref (fty->get_ref ());\n+\t\t  param.second = new_field;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fty->set_ty_ref (argt->get_ref ());\n+\t\t}\n \t    }\n \t}\n       else if (fty->has_subsititions_defined ()\n@@ -1396,9 +1394,8 @@ ParamType::handle_substitions (SubstitutionArgumentMappings mappings)\n \n   SubstitutionArg arg = SubstitutionArg::error ();\n   bool ok = mappings.get_argument_for_symbol (this, &arg);\n-  rust_assert (ok);\n-\n-  p->set_ty_ref (arg.get_tyty ()->get_ref ());\n+  if (ok)\n+    p->set_ty_ref (arg.get_tyty ()->get_ref ());\n \n   return p;\n }"}, {"sha": "74250307cee758cfd9ce9ad162621dd3bc174911", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -638,8 +638,16 @@ class SubstitutionRef\n \n   bool needs_substitution () const\n   {\n-    return has_substitutions ()\n-\t   && (used_arguments.is_error () || !used_arguments.is_concrete ());\n+    if (!has_substitutions ())\n+      return false;\n+\n+    if (used_arguments.is_error ())\n+      return true;\n+\n+    if (used_arguments.size () != get_num_substitutions ())\n+      return true;\n+\n+    return !used_arguments.is_concrete ();\n   }\n \n   bool was_substituted () const { return !needs_substitution (); }\n@@ -690,13 +698,36 @@ class SubstitutionRef\n   SubstitutionArgumentMappings\n   adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n \n+  // struct Foo<A, B>(A, B);\n+  //\n+  // impl<T> Foo<T, f32>;\n+  //     -> fn test<X>(self, a: X) -> X\n+  //\n+  // We might invoke this via:\n+  //\n+  // a = Foo(123, 456f32);\n+  // b = a.test::<bool>(false);\n+  //\n+  // we need to figure out relevant generic arguemts for self to apply to the\n+  // fntype\n+  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n+    SubstitutionArgumentMappings &mappings);\n+\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;\n-    for (auto &sub : get_substs ())\n+    for (auto &p : get_substs ())\n       {\n-\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\targs.push_back (SubstitutionArg (&sub, infer_var.get_tyty ()));\n+\tif (p.needs_substitution ())\n+\t  {\n+\t    TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t    args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t  }\n+\telse\n+\t  {\n+\t    args.push_back (\n+\t      SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t  }\n       }\n \n     SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n@@ -819,23 +850,24 @@ class ADTType : public BaseType, public SubstitutionRef\n class FnType : public BaseType, public SubstitutionRef\n {\n public:\n-  FnType (HirId ref, std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n+  FnType (HirId ref, bool is_method,\n+\t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      params (std::move (params)), type (type)\n+      params (std::move (params)), type (type), is_method_flag (is_method)\n   {}\n \n-  FnType (HirId ref, HirId ty_ref,\n+  FnType (HirId ref, HirId ty_ref, bool is_method,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *> > params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      params (params), type (type)\n+      params (params), type (type), is_method_flag (is_method)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -851,6 +883,22 @@ class FnType : public BaseType, public SubstitutionRef\n \n   size_t num_params () const { return params.size (); }\n \n+  bool is_method () const\n+  {\n+    if (num_params () == 0)\n+      return false;\n+\n+    return is_method_flag;\n+  }\n+\n+  // get the Self type for the method\n+  BaseType *get_self_type () const\n+  {\n+    rust_assert (is_method ());\n+    // FIXME this will need updated when we support coercion for & mut self etc\n+    return get_params ().at (0).second;\n+  }\n+\n   std::vector<std::pair<HIR::Pattern *, BaseType *> > &get_params ()\n   {\n     return params;\n@@ -893,6 +941,7 @@ class FnType : public BaseType, public SubstitutionRef\n private:\n   std::vector<std::pair<HIR::Pattern *, BaseType *> > params;\n   BaseType *type;\n+  bool is_method_flag;\n };\n \n class FnPtr : public BaseType"}, {"sha": "8cee8b00fb20264a085912959e449b396f519da8", "filename": "gcc/testsuite/rust.test/compile/generics28.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics28.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics28.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics28.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,18 @@\n+struct Foo<A, B>(A, B);\n+\n+impl Foo<i32, f32> {\n+    fn test<X>(a: X) -> X {\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo::test::<_>(123);\n+\n+    let b;\n+    b = Foo::test::<bool>(true);\n+\n+    let c;\n+    c = Foo::test(456f32);\n+}"}, {"sha": "e09a1044574fbc6deb565b89af482603194d7cd9", "filename": "gcc/testsuite/rust.test/compile/generics29.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics29.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,16 @@\n+struct Foo<A, B>(A, B);\n+\n+impl Foo<i32, f32> {\n+    fn test<X>(self, a: X) -> X {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "229f6d1254b76b5b55ed6df7d48fa1fcc06e67ca", "filename": "gcc/testsuite/rust.test/compile/generics30.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics30.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,16 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> X {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "68ad4bf9a96f1d6a6bcbac4389ee682d96ab5e42", "filename": "gcc/testsuite/rust.test/compile/generics31.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics31.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,15 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> (T, X) {\n+        (self.0, a)\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<bool>(false);\n+}"}, {"sha": "21b9cae7409656e7bfa88f4eb59fc87ecfa7d683", "filename": "gcc/testsuite/rust.test/compile/generics32.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics32.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,15 @@\n+struct Foo<A, B>(A, B);\n+\n+impl<T> Foo<T, f32> {\n+    fn test<X>(self, a: X) -> (T, X) {\n+        (self.0, a)\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test(false);\n+}"}, {"sha": "51bc821335559c175f4284880bbcecb7bee3197f", "filename": "gcc/testsuite/rust.test/xfail_compile/method1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod1.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,14 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn test() {}\n+}\n+\n+pub fn main() {\n+    let a;\n+    a = Foo(123);\n+\n+    a.test()\n+    // { dg-error \"associated function is not a method\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "be43b1a26526866cb07fc1f7f01b8d058e31d018", "filename": "gcc/testsuite/rust.test/xfail_compile/method2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c45fcb6e23f86a7f69ef4136099d5a8541afde6/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fmethod2.rs?ref=7c45fcb6e23f86a7f69ef4136099d5a8541afde6", "patch": "@@ -0,0 +1,17 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<A, B>(A, B);\n+\n+impl Foo<i32, f32> {\n+    fn test<X>(self, a: X) -> X {\n+        a\n+    }\n+}\n+\n+fn main() {\n+    let a;\n+    a = Foo(123, 456f32);\n+\n+    let b;\n+    b = a.test::<asfasfr>(false);\n+    // { dg-error \"failed to resolve TypePath: asfasfr\" \"\" { target *-*-* } .-1 }\n+}"}]}