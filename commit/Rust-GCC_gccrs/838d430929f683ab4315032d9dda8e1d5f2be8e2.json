{"sha": "838d430929f683ab4315032d9dda8e1d5f2be8e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM4ZDQzMDkyOWY2ODNhYjQzMTUwMzJkOWRkYThlMWQ1ZjJiZThlMg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-06-25T06:10:44Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-06-25T06:10:44Z"}, "message": "concurrence.h (__gnu_cxx::lock): New.\n\n\n2004-06-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/concurrence.h (__gnu_cxx::lock): New.\n\t* include/ext/pool_allocator.h (__pool_base::_Lock::_S_lock): Remove.\n\t(__pool_base::_M_get_mutex): New.\n\t* include/bits/allocator.h: Tweak.\n\t* src/allocator.cc (__pool_base::_M_get_free_list): Correct offset.\n\t* config/linker-map.gnu: Remove __pool_base::_Lock::_S_lock.\n\t* include/bits/stl_threads.h: Remove.\n\t* include/Makefile.am: Also here.\n\t* include/Makefile.in: Regenerate.\n\n\t* src/locale_init.cc: Use __gnu_cxx::lock.\n\n\t* src/allocator.cc: Move all instantiations...\n\t* src/allocator-inst.cc: ...here.\n\nFrom-SVN: r83638", "tree": {"sha": "4d9d8130c8565964ce08af9cb4505dc955a561f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d9d8130c8565964ce08af9cb4505dc955a561f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/838d430929f683ab4315032d9dda8e1d5f2be8e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838d430929f683ab4315032d9dda8e1d5f2be8e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/838d430929f683ab4315032d9dda8e1d5f2be8e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/838d430929f683ab4315032d9dda8e1d5f2be8e2/comments", "author": null, "committer": null, "parents": [{"sha": "ade83c33bdb550eeaa645f9e170c0dc54940cb3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade83c33bdb550eeaa645f9e170c0dc54940cb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade83c33bdb550eeaa645f9e170c0dc54940cb3f"}], "stats": {"total": 311, "additions": 96, "deletions": 215}, "files": [{"sha": "40ad5f1b2c4c0ef9330bfef916f222edecfbf7e6", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -1,3 +1,20 @@\n+2004-06-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/concurrence.h (__gnu_cxx::lock): New.\n+\t* include/ext/pool_allocator.h (__pool_base::_Lock::_S_lock): Remove.\n+\t(__pool_base::_M_get_mutex): New.\n+\t* include/bits/allocator.h: Tweak.\n+\t* src/allocator.cc (__pool_base::_M_get_free_list): Correct offset.\n+\t* config/linker-map.gnu: Remove __pool_base::_Lock::_S_lock.\n+\t* include/bits/stl_threads.h: Remove.\n+\t* include/Makefile.am: Also here.\n+\t* include/Makefile.in: Regenerate.\n+\n+\t* src/locale_init.cc: Use __gnu_cxx::lock.\n+\n+\t* src/allocator.cc: Move all instantiations...\n+\t* src/allocator-inst.cc: ...here.\n+\t\n 2004-06-23  Andrew Pinski  <apinski@apple.com>\n \n \t* linkage.m4: Remove check for libmx.\t"}, {"sha": "e6a861b78f3633e25d78eb268f7219c8263da432", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -143,7 +143,6 @@ GLIBCXX_3.4 {\n     _ZNSt12__basic_fileIcE6xsputn*;\n     _ZNSt12__basic_fileIcE7seekoff*;\n     _ZNSt12__basic_fileIcE8sys_openE*St13_Ios_Openmode;\n-    _ZNSt12__basic_fileIcE8sys_openEiSt13_Ios_Openmode;\n     _ZNSt12__basic_fileIcE8xsputn_2*;\n     _ZNSt12__basic_fileIcE9showmanycEv;\n     _ZNSt12__basic_fileIcEC*;\n@@ -257,10 +256,10 @@ GLIBCXX_3.4.1 {\n  \n GLIBCXX_3.4.2 {\n \n-    _ZN9__gnu_cxx11__pool_base5_Lock7_S_lockE;\n-    _ZN9__gnu_cxx11__pool_base9_M_refillEj;\n-    _ZN9__gnu_cxx11__pool_base16_M_get_free_listEj;\n- \n+    _ZN9__gnu_cxx11__pool_base9_M_refillE[jm];\n+    _ZN9__gnu_cxx11__pool_base16_M_get_free_listE[jm];\n+    _ZN9__gnu_cxx11__pool_base12_M_get_mutexEv;\n+\n } GLIBCXX_3.4.1;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "bed615eaecfc062e7d9115391a7d6fff448fc79f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -145,7 +145,6 @@ bits_headers = \\\n \t${bits_srcdir}/stl_set.h \\\n \t${bits_srcdir}/stl_stack.h \\\n \t${bits_srcdir}/stl_tempbuf.h \\\n-\t${bits_srcdir}/stl_threads.h \\\n \t${bits_srcdir}/stl_tree.h \\\n \t${bits_srcdir}/stl_uninitialized.h \\\n \t${bits_srcdir}/stl_vector.h \\"}, {"sha": "51a1718f7959500b411dd6d4ba048ca89ade2099", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -357,7 +357,6 @@ bits_headers = \\\n \t${bits_srcdir}/stl_set.h \\\n \t${bits_srcdir}/stl_stack.h \\\n \t${bits_srcdir}/stl_tempbuf.h \\\n-\t${bits_srcdir}/stl_threads.h \\\n \t${bits_srcdir}/stl_tree.h \\\n \t${bits_srcdir}/stl_uninitialized.h \\\n \t${bits_srcdir}/stl_vector.h \\"}, {"sha": "a744b5ff8944a31668d210af4cd121b53eb2ed5b", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -94,8 +94,8 @@ namespace std\n \n       allocator() throw() { }\n \n-      allocator(const allocator& a) throw()\n-      : ___glibcxx_base_allocator<_Tp>(a) { }\n+      allocator(const allocator& __a) throw()\n+      : ___glibcxx_base_allocator<_Tp>(__a) { }\n \n       template<typename _Tp1>\n         allocator(const allocator<_Tp1>&) throw() { }"}, {"sha": "81f6216d931a2817e82290554fc3ef88ec76d185", "filename": "libstdc++-v3/include/bits/concurrence.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -62,4 +62,26 @@ __gthread_mutex_lock(&NAME)\n \n #endif\n \n+namespace __gnu_cxx\n+{\n+  class lock\n+  {\n+    // Externally defined and initialized.\n+    __gthread_mutex_t* device;\n+\n+  public:\n+    // Acquire the mutex here with a constructor call.  This ensures\n+    // that it is released in exit or during stack unwinding.\n+    explicit lock(__gthread_mutex_t& name) : device(&name)\n+    { __glibcxx_mutex_lock(*device); }\n+\n+    ~lock() throw()\n+    { __glibcxx_mutex_unlock(*device); }\n+\n+  private:\n+    lock(const lock&);\n+    lock& operator=(const lock&);\n+  };\n+}\n+\n #endif"}, {"sha": "04baf0a08f9192c13c6535bc96fb5f71adab9465", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ade83c33bdb550eeaa645f9e170c0dc54940cb3f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ade83c33bdb550eeaa645f9e170c0dc54940cb3f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=ade83c33bdb550eeaa645f9e170c0dc54940cb3f", "patch": "@@ -1,150 +0,0 @@\n-// Threading support -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1997-1999\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file stl_threads.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _STL_THREADS_H\n-#define _STL_THREADS_H 1\n-\n-#include <cstddef>\n-\n-// The only supported threading model is GCC's own gthr.h abstraction\n-// layer.\n-#include \"bits/gthr.h\"\n-\n-namespace __gnu_internal\n-{\n-#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-  extern __gthread_mutex_t _GLIBCXX_mutex;\n-  extern __gthread_mutex_t *_GLIBCXX_mutex_address;\n-  extern __gthread_once_t _GLIBCXX_once;\n-  extern void _GLIBCXX_mutex_init(void);\n-  extern void _GLIBCXX_mutex_address_init(void);\n-#endif\n-} // namespace __gnu_internal\n-\n-namespace __gnu_cxx\n-{\n-  // Locking class.  Note that this class *does not have a\n-  // constructor*.  It must be initialized either statically, with\n-  // __STL_MUTEX_INITIALIZER, or dynamically, by explicitly calling\n-  // the _M_initialize member function.  (This is similar to the ways\n-  // that a pthreads mutex can be initialized.)  There are explicit\n-  // member functions for acquiring and releasing the lock.\n-\n-  // There is no constructor because static initialization is\n-  // essential for some uses, and only a class aggregate (see section\n-  // 8.5.1 of the C++ standard) can be initialized that way.  That\n-  // means we must have no constructors, no base classes, no virtual\n-  // functions, and no private or protected members.\n-  struct _STL_mutex_lock\n-  {\n-    // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n-#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-    volatile int _M_init_flag;\n-    __gthread_once_t _M_once;\n-#endif\n-    __gthread_mutex_t _M_lock;\n-\n-    void\n-    _M_initialize()\n-    {\n-#ifdef __GTHREAD_MUTEX_INIT\n-      // There should be no code in this path given the usage rules above.\n-#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-      if (_M_init_flag) return;\n-      if (__gthread_once(&__gnu_internal::_GLIBCXX_once,\n-\t\t\t __gnu_internal::_GLIBCXX_mutex_init) != 0\n-\t  && __gthread_active_p())\n-\tabort ();\n-      __gthread_mutex_lock(&__gnu_internal::_GLIBCXX_mutex);\n-      if (!_M_init_flag)\n-\t{\n-\t  // Even though we have a global lock, we use __gthread_once to be\n-\t  // absolutely certain the _M_lock mutex is only initialized once on\n-\t  // multiprocessor systems.\n-\t  __gnu_internal::_GLIBCXX_mutex_address = &_M_lock;\n-\t  if (__gthread_once(&_M_once,\n-\t\t\t     __gnu_internal::_GLIBCXX_mutex_address_init) != 0\n-\t    && __gthread_active_p())\n-\t    abort();\n-\t  _M_init_flag = 1;\n-\t}\n-      __gthread_mutex_unlock(&__gnu_internal::_GLIBCXX_mutex);\n-#endif\n-    }\n-\n-    void\n-    _M_acquire_lock()\n-    {\n-#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-      if (!_M_init_flag) _M_initialize();\n-#endif\n-      __gthread_mutex_lock(&_M_lock);\n-    }\n-\n-    void\n-    _M_release_lock()\n-    {\n-#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-      if (!_M_init_flag) _M_initialize();\n-#endif\n-      __gthread_mutex_unlock(&_M_lock);\n-    }\n-  };\n-\n-#ifdef __GTHREAD_MUTEX_INIT\n-#define __STL_MUTEX_INITIALIZER = { __GTHREAD_MUTEX_INIT }\n-#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-#ifdef __GTHREAD_MUTEX_INIT_DEFAULT\n-#define __STL_MUTEX_INITIALIZER \\\n-  = { 0, __GTHREAD_ONCE_INIT, __GTHREAD_MUTEX_INIT_DEFAULT }\n-#else\n-#define __STL_MUTEX_INITIALIZER = { 0, __GTHREAD_ONCE_INIT }\n-#endif\n-#endif\n-} // namespace __gnu_cxx\n-\n-#endif"}, {"sha": "de6299be8cfe3c037a43707300db8383fdd86396", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -50,8 +50,8 @@\n #include <bits/c++config.h>\n #include <new>\n #include <bits/functexcept.h>\n-#include <bits/stl_threads.h>\n #include <bits/atomicity.h>\n+#include <bits/concurrence.h>\n \n namespace __gnu_cxx\n {\n@@ -80,23 +80,14 @@ namespace __gnu_cxx\n       enum { _S_max_bytes = 128 };\n       enum { _S_free_list_size = _S_max_bytes / _S_align };\n       \n-      // It would be nice to use _STL_auto_lock here.  But we need a\n-      // test whether threads are in use.\n-      struct _Lock\n-      {\n-\tstatic _STL_mutex_lock        _S_lock;\n-\t_Lock() { _S_lock._M_acquire_lock(); }\n-\t~_Lock() { _S_lock._M_release_lock(); }\n-      };\n-\n       union _Obj\n       {\n \tunion _Obj* _M_free_list_link;\n \tchar        _M_client_data[1];    // The client sees this.\n       };\n       \n       static _Obj* volatile         _S_free_list[_S_free_list_size];\n-      \n+\n       // Chunk allocation state.\n       static char*                  _S_start_free;\n       static char*                  _S_end_free;\n@@ -109,6 +100,9 @@ namespace __gnu_cxx\n       _Obj* volatile*\n       _M_get_free_list(size_t __bytes);\n     \n+      __gthread_mutex_t&\n+      _M_get_mutex();\n+\n       // Returns an object of size __n, and optionally adds to size __n\n       // free list.\n       void*\n@@ -216,10 +210,7 @@ namespace __gnu_cxx\n \t\t{\n \t\t  _Obj* volatile* __free_list = _M_get_free_list(__bytes);\n \n-\t\t  // Acquire the lock here with a constructor call.  This\n-\t\t  // ensures that it is released in exit or during stack\n-\t\t  // unwinding.\n-\t\t  _Lock __lock_instance;\n+\t\t  lock sentry(_M_get_mutex());\n \t\t  _Obj* __restrict__ __result = *__free_list;\n \t\t  if (__builtin_expect(__result == 0, 0))\n \t\t    __ret = static_cast<_Tp*>(_M_refill(_M_round_up(__bytes)));\n@@ -252,10 +243,7 @@ namespace __gnu_cxx\n \t      _Obj* volatile* __free_list = _M_get_free_list(__bytes);\n \t      _Obj* __q = reinterpret_cast<_Obj*>(__p);\n \n-\t      // Acquire the lock here with a constructor call.  This\n-\t      // ensures that it is released in exit or during stack\n-\t      // unwinding.\n-\t      _Lock __lock_instance;\n+\t      lock sentry(_M_get_mutex());\n \t      __q ->_M_free_list_link = *__free_list;\n \t      *__free_list = __q;\n \t    }"}, {"sha": "40d7049cdddf65f1a7562eed6918c086af598e66", "filename": "libstdc++-v3/src/allocator-inst.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -31,11 +31,21 @@\n // ISO C++ 14882:\n //\n \n-#include <bits/c++config.h>\n #include <memory>\n+#include <ext/mt_allocator.h>\n+#include <ext/pool_allocator.h>\n \n namespace std\n {\n   template class allocator<char>;\n   template class allocator<wchar_t>;\n } // namespace std\n+\n+namespace __gnu_cxx\n+{\n+  template class __mt_alloc<char>;\n+  template class __mt_alloc<wchar_t>;\n+\n+  template class __pool_alloc<char>;\n+  template class __pool_alloc<wchar_t>;\n+} // namespace __gnu_cxx"}, {"sha": "af5de4d2cb9ede279f5b07bfd35798a90dbbc9bc", "filename": "libstdc++-v3/src/allocator.cc", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator.cc?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -36,20 +36,25 @@\n #include <ext/mt_allocator.h>\n #include <ext/pool_allocator.h>\n \n-namespace __gnu_cxx\n+namespace __gnu_internal\n {\n-  // Instantiations for __mt_alloc.\n-  template class __mt_alloc<char>;\n-  template class __mt_alloc<wchar_t>;\n+  __glibcxx_mutex_define_initialized(palloc_init_mutex);\n+}\n \n-  // Definitions and instantiations for __pool_alloc and base class.\n+namespace __gnu_cxx\n+{\n+  // Definitions for __pool_alloc_base.\n   __pool_base::_Obj* volatile*\n   __pool_base::_M_get_free_list(size_t __bytes)\n   { \n     size_t __i = ((__bytes + (size_t)_S_align - 1) / (size_t)_S_align - 1);\n-    return _S_free_list + __i - 1;\n+    return _S_free_list + __i;\n   }\n \n+  __gthread_mutex_t&\n+  __pool_base::_M_get_mutex()\n+  { return __gnu_internal::palloc_init_mutex; }\n+\n   // Allocate memory in large chunks in order to avoid fragmenting the\n   // heap too much.  Assume that __n is properly aligned.  We hold the\n   // allocation lock.\n@@ -89,21 +94,17 @@ namespace __gnu_cxx\n \t_S_start_free = static_cast<char*>(::operator new(__bytes_to_get));\n \tif (_S_start_free == 0)\n \t  {\n-\t    size_t __i;\n-\t    _Obj* volatile* __free_list;\n-\t    _Obj* __p;\n-\n \t    // Try to make do with what we have.  That can't hurt.  We\n \t    // do not try smaller requests, since that tends to result\n \t    // in disaster on multi-process machines.\n-\t    __i = __n;\n+\t    size_t __i = __n;\n \t    for (; __i <= (size_t) _S_max_bytes; __i += (size_t) _S_align)\n \t      {\n-\t\t__free_list = _M_get_free_list(__i);\n-\t\t__p = *__free_list;\n+\t\t_Obj* volatile* __free_list = _M_get_free_list(__i);\n+\t\t_Obj* __p = *__free_list;\n \t\tif (__p != 0)\n \t\t  {\n-\t\t    *__free_list = __p -> _M_free_list_link;\n+\t\t    *__free_list = __p->_M_free_list_link;\n \t\t    _S_start_free = (char*)__p;\n \t\t    _S_end_free = _S_start_free + __i;\n \t\t    return _M_allocate_chunk(__n, __nobjs);\n@@ -112,9 +113,10 @@ namespace __gnu_cxx\n \t\t  }\n \t      }\n \t    _S_end_free = 0;        // In case of exception.\n-\t    _S_start_free = static_cast<char*>(::operator new(__bytes_to_get));\n+\n \t    // This should either throw an exception or remedy the situation.\n \t    // Thus we assume it succeeded.\n+\t    _S_start_free = static_cast<char*>(::operator new(__bytes_to_get));\n \t  }\n \t_S_heap_size += __bytes_to_get;\n \t_S_end_free = _S_start_free + __bytes_to_get;\n@@ -134,26 +136,25 @@ namespace __gnu_cxx\n     _Obj* __result;\n     _Obj* __current_obj;\n     _Obj* __next_obj;\n-    int __i;\n     \n-    if (1 == __nobjs)\n+    if (__nobjs == 1)\n       return __chunk;\n     __free_list = _M_get_free_list(__n);\n     \n     // Build free list in chunk.\n     __result = (_Obj*)(void*)__chunk;\n     *__free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);\n-    for (__i = 1; ; __i++)\n+    for (int __i = 1; ; __i++)\n       {\n \t__current_obj = __next_obj;\n \t__next_obj = (_Obj*)(void*)((char*)__next_obj + __n);\n \tif (__nobjs - 1 == __i)\n \t  {\n-\t    __current_obj -> _M_free_list_link = 0;\n+\t    __current_obj->_M_free_list_link = 0;\n \t    break;\n \t  }\n \telse\n-\t  __current_obj -> _M_free_list_link = __next_obj;\n+\t  __current_obj->_M_free_list_link = __next_obj;\n       }\n     return __result;\n   }\n@@ -165,9 +166,4 @@ namespace __gnu_cxx\n   char* __pool_base::_S_end_free = 0;\n   \n   size_t __pool_base::_S_heap_size = 0;\n-  \n-  _STL_mutex_lock __pool_base::_Lock::_S_lock __STL_MUTEX_INITIALIZER;\n-  \n-  template class __pool_alloc<char>;\n-  template class __pool_alloc<wchar_t>;\n } // namespace __gnu_cxx"}, {"sha": "35dc3611a4b03f5364300c58cbe8289bc6db3f1e", "filename": "libstdc++-v3/src/locale_init.cc", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/838d430929f683ab4315032d9dda8e1d5f2be8e2/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc?ref=838d430929f683ab4315032d9dda8e1d5f2be8e2", "patch": "@@ -100,25 +100,26 @@ namespace std\n \n   locale::locale() throw() : _M_impl(0)\n   { \n-    _S_initialize(); \n-    __glibcxx_mutex_lock(__gnu_internal::locale_cons_mutex);\n+    _S_initialize();\n+    __gnu_cxx::lock sentry(__gnu_internal::locale_cons_mutex);\n     _S_global->_M_add_reference();\n     _M_impl = _S_global;\n-    __glibcxx_mutex_unlock(__gnu_internal::locale_cons_mutex);\n   }\n \n   locale\n   locale::global(const locale& __other)\n   {\n     _S_initialize();\n-    __glibcxx_mutex_lock(__gnu_internal::locale_global_mutex);\n-    _Impl* __old = _S_global;\n-    __other._M_impl->_M_add_reference();\n-    _S_global = __other._M_impl;\n-    const string __other_name = __other.name();\n-    if (__other_name != \"*\")\n-      setlocale(LC_ALL, __other_name.c_str());\n-   __glibcxx_mutex_unlock(__gnu_internal::locale_global_mutex);\n+    _Impl* __old;\n+    {\n+      __gnu_cxx::lock sentry(__gnu_internal::locale_global_mutex);\n+      __old = _S_global;\n+      __other._M_impl->_M_add_reference();\n+      _S_global = __other._M_impl;\n+      const string __other_name = __other.name();\n+      if (__other_name != \"*\")\n+\tsetlocale(LC_ALL, __other_name.c_str());\n+    }\n \n     // Reference count sanity check: one reference removed for the\n     // subsition of __other locale, one added by return-by-value. Net"}]}