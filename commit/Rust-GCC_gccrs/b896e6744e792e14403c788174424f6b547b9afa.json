{"sha": "b896e6744e792e14403c788174424f6b547b9afa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg5NmU2NzQ0ZTc5MmUxNDQwM2M3ODgxNzQ0MjRmNmI1NDdiOWFmYQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-06-27T04:23:36Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-06-27T04:23:36Z"}, "message": "re PR libfortran/61499 (Internal read of negative integer broken)\n\n2014-06-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/61499\n\t* io/list_read.c (eat_spaces): Use a 'for' loop instead of\n\t'while' loop to skip the loop if there are no bytes left in the\n\tstring. Only seek if actual spaces can be skipped.\n\nFrom-SVN: r212059", "tree": {"sha": "11decf8910c0b2d6e4ad42bfdb73c274d648449c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11decf8910c0b2d6e4ad42bfdb73c274d648449c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b896e6744e792e14403c788174424f6b547b9afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b896e6744e792e14403c788174424f6b547b9afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b896e6744e792e14403c788174424f6b547b9afa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b896e6744e792e14403c788174424f6b547b9afa/comments", "author": null, "committer": null, "parents": [{"sha": "5450a05c5b927454821a6f00e0600e600cbd134d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5450a05c5b927454821a6f00e0600e600cbd134d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5450a05c5b927454821a6f00e0600e600cbd134d"}], "stats": {"total": 54, "additions": 25, "deletions": 29}, "files": [{"sha": "26825ca87146575f00e4209554ab6cd11da24a32", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b896e6744e792e14403c788174424f6b547b9afa/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b896e6744e792e14403c788174424f6b547b9afa/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b896e6744e792e14403c788174424f6b547b9afa", "patch": "@@ -1,3 +1,10 @@\n+2014-06-26  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/61499\n+\t* io/list_read.c (eat_spaces): Use a 'for' loop instead of\n+\t'while' loop to skip the loop if there are no bytes left in the\n+\tstring. Only seek if actual spaces can be skipped.\n+\n 2014-06-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* caf/single.c (assign_char4_from_char1, assign_char1_from_char4,"}, {"sha": "96db0594b9046c59358aa1164e45004a86a4a47e", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b896e6744e792e14403c788174424f6b547b9afa/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b896e6744e792e14403c788174424f6b547b9afa/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=b896e6744e792e14403c788174424f6b547b9afa", "patch": "@@ -387,50 +387,39 @@ eat_spaces (st_parameter_dt *dtp)\n   int c;\n \n   /* If internal character array IO, peak ahead and seek past spaces.\n-     This is an optimazation to eliminate numerous calls to\n-     next character unique to character arrays with large character\n-     lengths (PR38199). */\n-  if (is_array_io (dtp))\n+     This is an optimization unique to character arrays with large\n+     character lengths (PR38199).  This code eliminates numerous calls\n+     to next_character.  */\n+  if (is_array_io (dtp) && (dtp->u.p.last_char == EOF - 1))\n     {\n       gfc_offset offset = stell (dtp->u.p.current_unit->s);\n-      gfc_offset limit = offset + dtp->u.p.current_unit->bytes_left;\n+      gfc_offset i;\n \n       if (dtp->common.unit) /* kind=4 */\n \t{\n-\t  gfc_char4_t cc;\n-\t  limit *= (sizeof (gfc_char4_t));\n-\t  do\n+\t  for (i = 0; i < dtp->u.p.current_unit->bytes_left; i++)\n \t    {\n-\t      cc = dtp->internal_unit[offset];\n-\t      offset += (sizeof (gfc_char4_t));\n-\t      dtp->u.p.current_unit->bytes_left--;\n+\t      if (dtp->internal_unit[offset + i * sizeof (gfc_char4_t)]\n+\t\t  != (gfc_char4_t)' ')\n+\t        break;\n \t    }\n-\t  while (offset < limit && cc == (gfc_char4_t)' ');\n-\t  /* Back up, seek ahead, and fall through to complete the\n-\t     process so that END conditions are handled correctly.  */\n-\t  dtp->u.p.current_unit->bytes_left++;\n-\n-\t  cc = dtp->internal_unit[offset];\n-\t  if (cc != (gfc_char4_t)' ')\n-\t    sseek (dtp->u.p.current_unit->s,\n-\t\t   offset-(sizeof (gfc_char4_t)), SEEK_SET);\n \t}\n       else\n \t{\n-\t  do\n+\t  for (i = 0; i < dtp->u.p.current_unit->bytes_left; i++)\n \t    {\n-\t      c = dtp->internal_unit[offset++];\n-\t      dtp->u.p.current_unit->bytes_left--;\n+\t      if (dtp->internal_unit[offset + i] != ' ')\n+\t        break;\n \t    }\n-\t  while (offset < limit && c == ' ');\n-\t  /* Back up, seek ahead, and fall through to complete the\n-\t     process so that END conditions are handled correctly.  */\n-\t  dtp->u.p.current_unit->bytes_left++;\n+\t}\n \n-\t  if (dtp->internal_unit[offset] != ' ')\n-\t    sseek (dtp->u.p.current_unit->s, offset - 1, SEEK_SET);\n+      if (i != 0)\n+\t{\n+\t  sseek (dtp->u.p.current_unit->s, offset + i, SEEK_SET);\n+\t  dtp->u.p.current_unit->bytes_left -= i;\n \t}\n     }\n+\n   /* Now skip spaces, EOF and EOL are handled in next_char.  */\n   do\n     c = next_char (dtp);"}]}