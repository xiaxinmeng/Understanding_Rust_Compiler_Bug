{"sha": "fdded40102ee40d7acbcb6bc2518e5ec14245688", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRkZWQ0MDEwMmVlNDBkN2FjYmNiNmJjMjUxOGU1ZWMxNDI0NTY4OA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-08-09T22:36:39Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-09T22:36:39Z"}, "message": "expmed.c (sdiv_pow2_cheap, [...]): Change type to bool.\n\n\n\t* expmed.c (sdiv_pow2_cheap, smod_pow2_cheap): Change type to bool.\n\t(init_expmed): Fix potential overrun problem with \"all.reg\".\n\t(expand_sdiv2_pow2): Add an alternate implementation for signed\n\tdivision, if the target provides a suitable conditional move insn.\n\nFrom-SVN: r85728", "tree": {"sha": "f2d96387c14f84dfdf8d12ed5292bcb427a0fa5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2d96387c14f84dfdf8d12ed5292bcb427a0fa5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdded40102ee40d7acbcb6bc2518e5ec14245688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdded40102ee40d7acbcb6bc2518e5ec14245688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdded40102ee40d7acbcb6bc2518e5ec14245688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdded40102ee40d7acbcb6bc2518e5ec14245688/comments", "author": null, "committer": null, "parents": [{"sha": "feb21f0d146b949153c91d6a800f5707b0da516d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb21f0d146b949153c91d6a800f5707b0da516d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb21f0d146b949153c91d6a800f5707b0da516d"}], "stats": {"total": 38, "additions": 35, "deletions": 3}, "files": [{"sha": "34ba3413887129620b22eb784ceafac789fb4a44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdded40102ee40d7acbcb6bc2518e5ec14245688/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdded40102ee40d7acbcb6bc2518e5ec14245688/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdded40102ee40d7acbcb6bc2518e5ec14245688", "patch": "@@ -1,3 +1,10 @@\n+2004-08-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expmed.c (sdiv_pow2_cheap, smod_pow2_cheap): Change type to bool.\n+\t(init_expmed): Fix potential overrun problem with \"all.reg\".\n+\t(expand_sdiv2_pow2): Add an alternate implementation for signed\n+\tdivision, if the target provides a suitable conditional move insn.\n+\n 2004-08-09  Paul Brook  <paul@codesourcery.com>\n \tRichard Henderson  <rth@redhat.com>\n "}, {"sha": "735fe987fc16ebdc448f7020e5822303defc8903", "filename": "gcc/expmed.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdded40102ee40d7acbcb6bc2518e5ec14245688/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdded40102ee40d7acbcb6bc2518e5ec14245688/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fdded40102ee40d7acbcb6bc2518e5ec14245688", "patch": "@@ -59,8 +59,8 @@ static rtx expand_sdiv_pow2 (enum machine_mode, rtx, HOST_WIDE_INT);\n    Usually, this will mean that the MD file will emit non-branch\n    sequences.  */\n \n-static int sdiv_pow2_cheap[NUM_MACHINE_MODES];\n-static int smod_pow2_cheap[NUM_MACHINE_MODES];\n+static bool sdiv_pow2_cheap[NUM_MACHINE_MODES];\n+static bool smod_pow2_cheap[NUM_MACHINE_MODES];\n \n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) STRICT_ALIGNMENT\n@@ -109,7 +109,7 @@ init_expmed (void)\n {\n   struct\n   {\n-    struct rtx_def reg;\n+    struct rtx_def reg;\t\trtunion reg_fld[2];\n     struct rtx_def plus;\trtunion plus_fld1;\n     struct rtx_def neg;\n     struct rtx_def udiv;\trtunion udiv_fld1;\n@@ -3194,6 +3194,31 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n       return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n     }\n \n+#ifdef HAVE_conditional_move\n+  if (BRANCH_COST >= 2)\n+    {\n+      rtx temp2;\n+\n+      start_sequence ();\n+      temp2 = copy_to_mode_reg (mode, op0);\n+      temp = expand_binop (mode, add_optab, temp2, GEN_INT (d-1),\n+\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+      temp = force_reg (mode, temp);\n+\n+      /* Construct \"temp2 = (temp2 < 0) ? temp : temp2\".  */\n+      temp2 = emit_conditional_move (temp2, LT, temp2, const0_rtx,\n+\t\t\t\t     mode, temp, temp2, mode, 0);\n+      if (temp2)\n+\t{\n+\t  rtx seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn (seq);\n+\t  return expand_shift (RSHIFT_EXPR, mode, temp2, shift, NULL_RTX, 0);\n+\t}\n+      end_sequence ();\n+    }\n+#endif\n+\n   if (BRANCH_COST >= 2)\n     {\n       int ushift = GET_MODE_BITSIZE (mode) - logd;"}]}