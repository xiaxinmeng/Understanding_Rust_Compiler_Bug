{"sha": "0b37233152b55fb256d7537d7e76067edc52cb88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzNzIzMzE1MmI1NWZiMjU2ZDc1MzdkN2U3NjA2N2VkYzUyY2I4OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-09T15:18:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-09T15:22:35Z"}, "message": "c++: Module parsing\n\nThis adds the module-declaration parsing and other logic.  We have two\nnew kinds of declaration -- module and import.  Plus the ability to\nexport other declarations.  The module processing can also divide the\nTU into several portions -- GMF, Purview and PMF.\n\nThere are restrictions that some declarations must or mustnot appear\nin a #include, so I needed to add a bit to indicate whether a token\ncame from the main source or not.  This seemed the least unpleasant\nway of implementing such a check.\n\n\tgcc/cp/\n\t* parser.h (struct cp_token): Add main_source_p field.\n\t* parser.c (cp_lexer_new_main): Pass thought module token filter.\n\tCheck macros.\n\t(cp_lexer_get_preprocessor_token): Set main_source_p.\n\t(enum module_parse): New.\n\t(cp_parser_diagnose_invalid_type_name): Deal with unrecognized\n\tmodule-directives.\n\t(cp_parser_skip_to_closing_parenthesize_1): Skip module-directivres.\n\t(cp_parser_skip_to_end_of_statement): Likewise.\n\t(cp_parser_skiup_to_end_of_block_or_statement): Likewise.\n\t(cp_parser_translation_unit): Add module parsing calls.\n\t(cp_parser_module_name, cp_parser_module_declaration): New.\n\t(cp_parser_import_declaration, cp_parser_module_export): New.\n\t(cp_parser_declaration): Add module export detection.\n\t(cp_parser_template_declaration): Adjust 'export' error message.\n\t(cp_parser_function_definition_after_declarator): Add\n\tmodule-specific logic.\n\t* module.cc (import_module, declare_module)\n\t(maybe_check_all_macros): Stubs.", "tree": {"sha": "06c922f186b65e8ac0eed9733da3651498d23bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06c922f186b65e8ac0eed9733da3651498d23bd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b37233152b55fb256d7537d7e76067edc52cb88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b37233152b55fb256d7537d7e76067edc52cb88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b37233152b55fb256d7537d7e76067edc52cb88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b37233152b55fb256d7537d7e76067edc52cb88/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe70679b80f5e6193a0976be41b68d590c7cb2f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe70679b80f5e6193a0976be41b68d590c7cb2f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe70679b80f5e6193a0976be41b68d590c7cb2f3"}], "stats": {"total": 409, "additions": 403, "deletions": 6}, "files": [{"sha": "3587dfcc92557f60baeed964b040766ac0374edb", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=0b37233152b55fb256d7537d7e76067edc52cb88", "patch": "@@ -123,6 +123,16 @@ set_originating_module (tree, bool)\n {\n }\n \n+void\n+import_module (module_state *, location_t, bool, tree, cpp_reader *)\n+{\n+}\n+\n+void\n+declare_module (module_state *, location_t, bool, tree, cpp_reader *)\n+{\n+}\n+\n module_state *\n preprocess_module (module_state *, unsigned, bool, bool, bool, cpp_reader *)\n {\n@@ -143,6 +153,11 @@ init_modules (cpp_reader *)\n \t\t \"Shtopp! What are you doing? This is not ready yet.\");\n }\n \n+void\n+maybe_check_all_macros (cpp_reader *)\n+{\n+}\n+\n void\n fini_modules ()\n {"}, {"sha": "39957d4b6a92626e674389f84c7c69c882230ca3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 386, "deletions": 5, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0b37233152b55fb256d7537d7e76067edc52cb88", "patch": "@@ -646,9 +646,17 @@ cp_lexer_new_main (void)\n   /* Put the first token in the buffer.  */\n   cp_token *tok = lexer->buffer->quick_push (token);\n \n+  uintptr_t filter = 0;\n+  if (modules_p ())\n+    filter = module_token_cdtor (parse_in, filter);\n+\n   /* Get the remaining tokens from the preprocessor.  */\n   while (tok->type != CPP_EOF)\n     {\n+      if (filter)\n+\t/* Process the previous token.  */\n+\tmodule_token_lang (tok->type, tok->keyword, tok->u.value,\n+\t\t\t   tok->location, filter);\n       tok = vec_safe_push (lexer->buffer, cp_token ());\n       cp_lexer_get_preprocessor_token (C_LEX_STRING_NO_JOIN, tok);\n     }\n@@ -658,10 +666,15 @@ cp_lexer_new_main (void)\n                       + lexer->buffer->length ()\n \t\t      - 1;\n \n+  if (filter)\n+    module_token_cdtor (parse_in, filter);\n+\n   /* Subsequent preprocessor diagnostics should use compiler\n      diagnostic functions to get the compiler source location.  */\n   done_lexing = true;\n \n+  maybe_check_all_macros (parse_in);\n+\n   gcc_assert (!lexer->next_token->purged_p);\n   return lexer;\n }\n@@ -842,6 +855,8 @@ cp_lexer_get_preprocessor_token (unsigned flags, cp_token *token)\n   token->purged_p = false;\n   token->error_reported = false;\n   token->tree_check_p = false;\n+  /* Usually never see a zero, but just in case ... */\n+  token->main_source_p = line_table->depth <= 1;\n \n   /* On some systems, some header files are surrounded by an\n      implicit extern \"C\" block.  Set a flag in the token if it\n@@ -2190,6 +2205,28 @@ static tree cp_parser_implicitly_scoped_statement\n static void cp_parser_already_scoped_statement\n   (cp_parser *, bool *, const token_indent_info &);\n \n+/* State of module-declaration parsing.  */\n+enum module_parse\n+{\n+  MP_NOT_MODULE,\t/* Not a module.  */\n+\n+  _MP_UNUSED,\n+\n+  MP_FIRST,\t/* First declaration of TU.  */\n+  MP_GLOBAL,\t/* Global Module Fragment.  */\n+\n+  MP_PURVIEW_IMPORTS,   /* Imports of a module.  */\n+  MP_PURVIEW,\t/* Purview of a named module.  */\n+\n+  MP_PRIVATE_IMPORTS, /* Imports of a Private Module Fragment.  */\n+  MP_PRIVATE,   /* Private Module Fragment.  */\n+};\n+\n+static module_parse cp_parser_module_declaration\n+  (cp_parser *parser, module_parse, bool exporting);\n+static void cp_parser_import_declaration\n+  (cp_parser *parser, module_parse, bool exporting);\n+\n /* Declarations [gram.dcl.dcl] */\n \n static void cp_parser_declaration_seq_opt\n@@ -3419,6 +3456,15 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n       else if (cxx_dialect < cxx11 && id == ridpointers[(int)RID_NOEXCEPT])\n \tinform (location, \"C++11 %<noexcept%> only available with \"\n \t\t\"%<-std=c++11%> or %<-std=gnu++11%>\");\n+      else if (TREE_CODE (id) == IDENTIFIER_NODE\n+\t       && (id_equal (id, \"module\") || id_equal (id, \"import\")))\n+\t{\n+\t  if (!modules_p ())\n+\t    inform (location, \"%qE only available with %<-fmodules-ts%>\", id);\n+\t  else\n+\t    inform (location, \"%qE was not recognized as a module control-line\",\n+\t\t    id);\n+\t}\n       else if (cxx_dialect < cxx11\n \t       && TREE_CODE (id) == IDENTIFIER_NODE\n \t       && id_equal (id, \"thread_local\"))\n@@ -3712,6 +3758,13 @@ cp_parser_skip_to_closing_parenthesis_1 (cp_parser *parser,\n \t    condop_depth--;\n \t  break;\n \n+\tcase CPP_KEYWORD:\n+\t  if (token->keyword != RID__EXPORT\n+\t      && token->keyword != RID__MODULE\n+\t      && token->keyword != RID__IMPORT)\n+\t    break;\n+\t  /* FALLTHROUGH  */\n+\n \tcase CPP_PRAGMA:\n \t  /* We fell into a pragma.  Skip it, and continue. */\n \t  cp_parser_skip_to_pragma_eol (parser, recovering ? token : nullptr);\n@@ -3808,6 +3861,13 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \t  ++nesting_depth;\n \t  break;\n \n+\tcase CPP_KEYWORD:\n+\t  if (token->keyword != RID__EXPORT\n+\t      && token->keyword != RID__MODULE\n+\t      && token->keyword != RID__IMPORT)\n+\t    break;\n+\t  /* FALLTHROUGH  */\n+\n \tcase CPP_PRAGMA:\n \t  /* We fell into a pragma.  Skip it, and continue or return. */\n \t  cp_parser_skip_to_pragma_eol (parser, token);\n@@ -3890,6 +3950,13 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \t  nesting_depth++;\n \t  break;\n \n+\tcase CPP_KEYWORD:\n+\t  if (token->keyword != RID__EXPORT\n+\t      && token->keyword != RID__MODULE\n+\t      && token->keyword != RID__IMPORT)\n+\t    break;\n+\t  /* FALLTHROUGH  */\n+\n \tcase CPP_PRAGMA:\n \t  /* Skip it, and continue or return. */\n \t  cp_parser_skip_to_pragma_eol (parser, token);\n@@ -4771,6 +4838,10 @@ cp_parser_translation_unit (cp_parser* parser)\n   push_deferring_access_checks (flag_access_control\n \t\t\t\t? dk_no_deferred : dk_no_check);\n \n+  module_parse mp_state = MP_NOT_MODULE;\n+  if (modules_p () && !header_module_p ())\n+    mp_state = MP_FIRST;\n+\n   bool implicit_extern_c = false;\n \n   /* Parse until EOF.  */\n@@ -4794,6 +4865,55 @@ cp_parser_translation_unit (cp_parser* parser)\n       if (token->type == CPP_EOF)\n \tbreak;\n \n+      if (modules_p ())\n+\t{\n+\t  /* Top-level module declarations are ok, and change the\n+\t     portion of file we're in.  Top-level import declarations\n+\t     are significant for the import portions.  */\n+\n+\t  cp_token *next = token;\n+\t  bool exporting = token->keyword == RID__EXPORT;\n+\t  if (exporting)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      next = cp_lexer_peek_token (parser->lexer);\n+\t    }\n+\t  if (next->keyword == RID__MODULE)\n+\t    {\n+\t      mp_state\n+\t\t= cp_parser_module_declaration (parser, mp_state, exporting);\n+\t      continue;\n+\t    }\n+\t  else if (next->keyword == RID__IMPORT)\n+\t    {\n+\t      if (mp_state == MP_FIRST)\n+\t\tmp_state = MP_NOT_MODULE;\n+\t      cp_parser_import_declaration (parser, mp_state, exporting);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    gcc_checking_assert (!exporting);\n+\n+\t  if (mp_state == MP_GLOBAL && token->main_source_p)\n+\t    {\n+\t      static bool warned = false;\n+\t      if (!warned)\n+\t\t{\n+\t\t  warned = true;\n+\t\t  error_at (token->location,\n+\t\t\t    \"global module fragment contents must be\"\n+\t\t\t    \" from preprocessor inclusion\");\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* This relies on the ordering of module_parse values.  */\n+      if (mp_state == MP_PURVIEW_IMPORTS || mp_state == MP_PRIVATE_IMPORTS)\n+\t/* We're no longer in the import portion of a named module.  */\n+\tmp_state = module_parse (mp_state + 1);\n+      else if (mp_state == MP_FIRST)\n+\tmp_state = MP_NOT_MODULE;\n+\n       if (token->type == CPP_CLOSE_BRACE)\n \t{\n \t  cp_parser_error (parser, \"expected declaration\");\n@@ -13513,9 +13633,236 @@ cp_parser_already_scoped_statement (cp_parser* parser, bool *if_p,\n     }\n }\n \n+/* Modules */\n+\n+/* Parse a module-name,\n+   identifier\n+   module-name . identifier\n+   header-name\n+\n+   Returns a pointer to module object, NULL.   */\n+\n+static module_state *\n+cp_parser_module_name (cp_parser *parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_HEADER_NAME)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      return get_module (token->u.value);\n+    }\n+\n+  module_state *parent = NULL;\n+  bool partitioned = false;\n+  if (token->type == CPP_COLON && named_module_p ())\n+    {\n+      partitioned = true;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  for (;;)\n+    {\n+      if (cp_lexer_peek_token (parser->lexer)->type != CPP_NAME)\n+\t{\n+\t  cp_parser_error (parser, \"expected module-name\");\n+\t  break;\n+\t}\n+\n+      tree name = cp_lexer_consume_token (parser->lexer)->u.value;\n+      parent = get_module (name, parent, partitioned);\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (!partitioned && token->type == CPP_COLON)\n+\tpartitioned = true;\n+      else if (token->type != CPP_DOT)\n+\tbreak;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+   }\n+\n+  return parent;\n+}\n+\n+/* Named module-declaration\n+     __module ; PRAGMA_EOL\n+     __module private ; PRAGMA_EOL (unimplemented)\n+     [__export] __module module-name attr-spec-seq-opt ; PRAGMA_EOL\n+*/\n+\n+static module_parse\n+cp_parser_module_declaration (cp_parser *parser, module_parse mp_state,\n+\t\t\t      bool exporting)\n+{\n+  /* We're a pseudo pragma.  */\n+  parser->lexer->in_pragma = true;\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\n+  if (mp_state == MP_FIRST && !exporting\n+      && cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    {\n+      /* Start global module fragment.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      module_kind |= MK_GLOBAL;\n+      mp_state = MP_GLOBAL;\n+      cp_parser_require_pragma_eol (parser, token);\n+    }\n+  else if (!exporting\n+\t   && cp_lexer_next_token_is (parser->lexer, CPP_COLON)\n+\t   && cp_lexer_nth_token_is_keyword (parser->lexer, 2, RID_PRIVATE)\n+\t   && cp_lexer_nth_token_is (parser->lexer, 3, CPP_SEMICOLON))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_require_pragma_eol (parser, token);\n+\n+      if ((mp_state != MP_PURVIEW && mp_state != MP_PURVIEW_IMPORTS)\n+\t  || !module_interface_p () || module_partition_p ())\n+\terror_at (token->location,\n+\t\t  \"private module fragment not permitted here\");\n+      else\n+\t{\n+\t  mp_state = MP_PRIVATE_IMPORTS;\n+\t  sorry_at (token->location, \"private module fragment\");\n+\t}\n+    }\n+  else if (mp_state != MP_FIRST && mp_state != MP_GLOBAL)\n+    {\n+      error_at (token->location, \"module-declaration not permitted here\");\n+    skip_eol:\n+      cp_parser_skip_to_pragma_eol (parser, token);\n+    }\n+  else\n+    {\n+      module_state *mod = cp_parser_module_name (parser);\n+      tree attrs = cp_parser_attributes_opt (parser);\n+\n+      mp_state = MP_PURVIEW_IMPORTS;\n+      if (!mod || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+\tgoto skip_eol;\n+\n+      declare_module (mod, token->location, exporting, attrs, parse_in);\n+      cp_parser_require_pragma_eol (parser, token);\n+    }\n+\n+  return mp_state;\n+}\n+\n+/* Import-declaration\n+   [__export] __import module-name attr-spec-seq-opt ; PRAGMA_EOL */\n+\n+static void\n+cp_parser_import_declaration (cp_parser *parser, module_parse mp_state,\n+\t\t\t      bool exporting)\n+{\n+  /* We're a pseudo pragma.  */\n+  parser->lexer->in_pragma = true;\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\n+  if (mp_state != MP_PURVIEW_IMPORTS\n+      && mp_state != MP_PRIVATE_IMPORTS\n+      && module_purview_p ()\n+      && !global_purview_p ())\n+    {\n+      error_at (token->location, \"post-module-declaration\"\n+\t\t\" imports must be contiguous\");\n+    note_lexer:\n+      inform (token->location, \"perhaps insert a line break, or other\"\n+\t      \" disambiguation, to prevent this being considered a\"\n+\t      \" module control-line\");\n+    skip_eol:\n+      cp_parser_skip_to_pragma_eol (parser, token);\n+    }\n+  else if (current_scope () != global_namespace)\n+    {\n+      error_at (token->location, \"import-declaration must be at global scope\");\n+      goto note_lexer;\n+    }\n+  else\n+    {\n+      module_state *mod = cp_parser_module_name (parser);\n+      tree attrs = cp_parser_attributes_opt (parser);\n+\n+      if (!mod || !cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON))\n+\tgoto skip_eol;\n+      cp_parser_require_pragma_eol (parser, token);\n+\n+      if (parser->in_unbraced_linkage_specification_p)\n+\terror_at (token->location, \"import cannot appear directly in\"\n+\t\t  \" a linkage-specification\");\n+\n+      /* Module-purview imports must not be from source inclusion\n+\t [cpp.import]/7  */\n+      if (attrs && module_purview_p () && !global_purview_p ()\n+\t  && private_lookup_attribute (\"__translated\",\n+\t\t\t\t       strlen (\"__translated\"), attrs))\n+\terror_at (token->location, \"post-module-declaration imports\"\n+\t\t  \" must not be include-translated\");\n+      else if ((mp_state == MP_PURVIEW_IMPORTS\n+\t\t|| mp_state == MP_PRIVATE_IMPORTS)\n+\t       && !token->main_source_p)\n+\terror_at (token->location, \"post-module-declaration imports\"\n+\t\t  \" must not be from header inclusion\");\n+\n+      import_module (mod, token->location, exporting, attrs, parse_in);\n+    }\n+}\n+\n+/*  export-declaration.\n+\n+    export declaration\n+    export { declaration-seq-opt }  */\n+\n+static void\n+cp_parser_module_export (cp_parser *parser)\n+{\n+  gcc_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_EXPORT));\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\n+  if (!module_interface_p ())\n+    error_at (token->location,\n+\t      \"%qE may only occur after a module interface declaration\",\n+\t      token->u.value);\n+\n+  bool braced = cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE);\n+\n+  unsigned mk = module_kind;\n+  if (module_exporting_p ())\n+    error_at (token->location,\n+\t      \"%qE may only occur once in an export declaration\",\n+\t      token->u.value);\n+  module_kind |= MK_EXPORTING;\n+\n+  if (braced)\n+    {\n+      cp_ensure_no_omp_declare_simd (parser);\n+      cp_ensure_no_oacc_routine (parser);\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_declaration_seq_opt (parser);\n+      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+    }\n+  else\n+    {\n+      /* Explicitly check if the next tokens might be a\n+         module-directive line, so we can give a clearer error message\n+         about why the directive will be rejected.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID__MODULE)\n+\t  || cp_lexer_next_token_is_keyword (parser->lexer, RID__IMPORT)\n+\t  || cp_lexer_next_token_is_keyword (parser->lexer, RID__EXPORT))\n+\terror_at (token->location, \"%<export%> not part of following\"\n+\t\t  \" module-directive\");\n+      cp_parser_declaration (parser, NULL_TREE);\n+    }\n+\n+  module_kind = mk;\n+}\n+\n /* Declarations [gram.dcl.dcl] */\n \n-/* Parse an optional declaration-sequence.\n+/* Parse an optional declaration-sequence.  TOP_LEVEL is true, if this\n+   is the top-level declaration sequence.  That affects whether we\n+   deal with module-preamble.\n \n    declaration-seq:\n      declaration\n@@ -13550,6 +13897,14 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n    C++17:\n      deduction-guide\n \n+   modules:\n+     (all these are only allowed at the outermost level, check\n+   \tthat semantically, for better diagnostics)\n+     module-declaration\n+     module-export-declaration\n+     module-import-declaration\n+     export-declaration\n+\n    GNU extension:\n \n    declaration:\n@@ -13643,10 +13998,28 @@ cp_parser_declaration (cp_parser* parser, tree prefix_attrs)\n       else\n \tcp_parser_explicit_instantiation (parser);\n     }\n-  /* If the next token is `export', then we have a template\n-     declaration.  */\n+  /* If the next token is `export', it's new-style modules or\n+     old-style template.  */\n   else if (token1->keyword == RID_EXPORT)\n-    cp_parser_template_declaration (parser, /*member_p=*/false);\n+    {\n+      if (!modules_p ())\n+\tcp_parser_template_declaration (parser, /*member_p=*/false);\n+      else\n+\tcp_parser_module_export (parser);\n+    }\n+  else if (token1->keyword == RID__EXPORT\n+\t   || token1->keyword == RID__IMPORT\n+\t   || token1->keyword == RID__MODULE)\n+    {\n+      bool exporting = token1->keyword == RID__EXPORT;\n+      cp_token *next = exporting ? token2 : token1;\n+      if (exporting)\n+\tcp_lexer_consume_token (parser->lexer);\n+      if (next->keyword == RID__MODULE)\n+\tcp_parser_module_declaration (parser, MP_NOT_MODULE, exporting);\n+      else\n+\tcp_parser_import_declaration (parser, MP_NOT_MODULE, exporting);\n+    }\n   /* If the next token is `extern', 'static' or 'inline' and the one\n      after that is `template', we have a GNU extended explicit\n      instantiation directive.  */\n@@ -16141,7 +16514,7 @@ cp_parser_template_declaration (cp_parser* parser, bool member_p)\n       else if (cxx_dialect < cxx20)\n \twarning (0, \"keyword %<export%> is deprecated, and is ignored\");\n       else\n-\twarning (0, \"keyword %<export%> not implemented, and will be ignored\");\n+\twarning (0, \"keyword %<export%> is enabled with %<-fmodules-ts%>\");\n     }\n \n   cp_parser_template_declaration_after_export (parser, member_p);\n@@ -29544,6 +29917,14 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \n   /* Finish the function.  */\n   fn = finish_function (inline_p);\n+\n+  if (modules_p ()\n+      && !inline_p\n+      && TYPE_P (DECL_CONTEXT (fn))\n+      && (DECL_DECLARED_INLINE_P (fn)\n+\t  || processing_template_decl))\n+    set_defining_module (fn);\n+\n   /* Generate code for it, if necessary.  */\n   expand_or_defer_fn (fn);\n   /* Restore the saved values.  */"}, {"sha": "13c37b2132654c0902eb7fabb5d5caaca07a35ba", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b37233152b55fb256d7537d7e76067edc52cb88/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=0b37233152b55fb256d7537d7e76067edc52cb88", "patch": "@@ -58,7 +58,8 @@ struct GTY (()) cp_token {\n      deleted.  */\n   bool purged_p : 1;\n   bool tree_check_p : 1;\n-  /* 4 unused bits.  */\n+  bool main_source_p : 1;\n+  /* 3 unused bits.  */\n \n   /* The location at which this token was found.  */\n   location_t location;"}]}