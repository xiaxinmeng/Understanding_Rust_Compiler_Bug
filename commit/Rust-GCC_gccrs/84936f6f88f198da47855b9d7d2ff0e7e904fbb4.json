{"sha": "84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5MzZmNmY4OGYxOThkYTQ3ODU1YjlkN2QyZmYwZTdlOTA0ZmJiNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-07T03:19:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-07T03:19:55Z"}, "message": "langhooks-def.h (LANG_HOOKS_GIMPLE_BEFORE_INLINING): Remove.\n\n        * langhooks-def.h (LANG_HOOKS_GIMPLE_BEFORE_INLINING): Remove.\n        * langhooks.h (struct lang_hooks): Remove gimple_before_inlining.\n        * tree-inline.c (copy_body_r, setup_one_parameter,\n        initialize_inlined_parameters, expand_call_inline,\n        declare_inline_vars): Don't check it.\n        (expand_calls_inline): Remove old version, rename new version\n        from gimple_expand_calls_inline.\n        * tree-optimize.c (execute_gimple): Remove.\n        (pass_gimple): Don't run anything.\n\nFrom-SVN: r84190", "tree": {"sha": "16bf999751c6268bceecc41792cd135703d74051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16bf999751c6268bceecc41792cd135703d74051"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/comments", "author": null, "committer": null, "parents": [{"sha": "634330f5e36ad192af31ac8386d7706b51de2515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634330f5e36ad192af31ac8386d7706b51de2515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634330f5e36ad192af31ac8386d7706b51de2515"}], "stats": {"total": 186, "additions": 67, "deletions": 119}, "files": [{"sha": "0b9f703e6ebc1f93788d9a0c391c351a1120e08c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "patch": "@@ -1,3 +1,15 @@\n+2004-07-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_GIMPLE_BEFORE_INLINING): Remove.\n+\t* langhooks.h (struct lang_hooks): Remove gimple_before_inlining.\n+\t* tree-inline.c (copy_body_r, setup_one_parameter,\n+\tinitialize_inlined_parameters, expand_call_inline,\n+\tdeclare_inline_vars): Don't check it.\n+\t(expand_calls_inline): Remove old version, rename new version\n+\tfrom gimple_expand_calls_inline.\n+\t* tree-optimize.c (execute_gimple): Remove.\n+\t(pass_gimple): Don't run anything.\n+\n 2004-07-06  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/sourcebuild.texi: Use semicolons instead of commas in"}, {"sha": "1cd44f5565eb2c90c1ec6be76eb7156367efcbb0", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "patch": "@@ -201,7 +201,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n /* Hooks for tree gimplification.  */\n #define LANG_HOOKS_GIMPLIFY_EXPR lhd_gimplify_expr\n #define LANG_HOOKS_FOLD_OBJ_TYPE_REF NULL\n-#define LANG_HOOKS_GIMPLE_BEFORE_INLINING true\n \n /* Tree dump hooks.  */\n extern bool lhd_tree_dump_dump_tree (void *, tree);\n@@ -319,7 +318,6 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n   LANG_HOOKS_GIMPLIFY_EXPR, \\\n   LANG_HOOKS_FOLD_OBJ_TYPE_REF, \\\n-  LANG_HOOKS_GIMPLE_BEFORE_INLINING \\\n }\n \n #endif /* GCC_LANG_HOOKS_DEF_H */"}, {"sha": "fb36a144b84b2b36e79121e31ea1f54076dcd6ed", "filename": "gcc/langhooks.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "patch": "@@ -427,10 +427,6 @@ struct lang_hooks\n      KNOWN_TYPE carries the true type of the OBJ_TYPE_REF_OBJECT.  */\n   tree (*fold_obj_type_ref) (tree, tree);\n \n-  /* True if the front end has gimplified the function before running the\n-     inliner, false if the front end generates GENERIC directly.  */\n-  bool gimple_before_inlining;\n-\n   /* Whenever you add entries here, make sure you adjust langhooks-def.h\n      and langhooks.c accordingly.  */\n };"}, {"sha": "be817239e6c505d2ee0ce327ffc129412a63474a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 53, "deletions": 102, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "patch": "@@ -483,9 +483,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       if (assignment)\n         {\n \t  /* Do not create a statement containing a naked RESULT_DECL.  */\n-\t  if (lang_hooks.gimple_before_inlining)\n-\t    if (TREE_CODE (assignment) == RESULT_DECL)\n-\t      gimplify_stmt (&assignment);\n+\t  if (TREE_CODE (assignment) == RESULT_DECL)\n+\t    gimplify_stmt (&assignment);\n \n \t  *tp = build (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n \t  append_to_statement_list (assignment, &BIND_EXPR_BODY (*tp));\n@@ -709,24 +708,13 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n \t Theoretically, we could check the expression to see if\n \t all of the variables that determine its value are\n \t read-only, but we don't bother.  */\n-      if ((TREE_CONSTANT (value) || TREE_READONLY_DECL_P (value))\n-\t  /* We may produce non-gimple trees by adding NOPs or introduce\n-\t     invalid sharing when operand is not really constant.\n-\t     It is not big deal to prohibit constant propagation here as\n-\t     we will constant propagate in DOM1 pass anyway.  */\n-\t  && (!lang_hooks.gimple_before_inlining\n-\t      || (is_gimple_min_invariant (value)\n-\t\t  && TREE_TYPE (value) == TREE_TYPE (p))))\n+      /* We may produce non-gimple trees by adding NOPs or introduce\n+\t invalid sharing when operand is not really constant.\n+\t It is not big deal to prohibit constant propagation here as\n+\t we will constant propagate in DOM1 pass anyway.  */\n+      if (is_gimple_min_invariant (value)\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (value), TREE_TYPE (p)))\n \t{\n-\t  /* If this is a declaration, wrap it a NOP_EXPR so that\n-\t     we don't try to put the VALUE on the list of BLOCK_VARS.  */\n-\t  if (DECL_P (value))\n-\t    value = build1 (NOP_EXPR, TREE_TYPE (value), value);\n-\n-\t  /* If this is a constant, make sure it has the right type.  */\n-\t  else if (TREE_TYPE (value) != TREE_TYPE (p))\n-\t    value = fold (build1 (NOP_EXPR, TREE_TYPE (p), value));\n-\n \t  insert_decl_map (id, p, value);\n \t  return;\n \t}\n@@ -760,7 +748,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n   *vars = var;\n \n   /* Make gimplifier happy about this variable.  */\n-  DECL_SEEN_IN_BIND_EXPR_P (var) = lang_hooks.gimple_before_inlining;\n+  DECL_SEEN_IN_BIND_EXPR_P (var) = 1;\n \n   /* Even if P was TREE_READONLY, the new VAR should not be.\n      In the original code, we would have constructed a\n@@ -856,7 +844,7 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n \t\t\t    &gimplify_init_stmts_p);\n     }\n \n-  if (gimplify_init_stmts_p && lang_hooks.gimple_before_inlining)\n+  if (gimplify_init_stmts_p)\n     gimplify_body (&init_stmts, current_function_decl);\n \n   declare_inline_vars (bind_expr, vars);\n@@ -1637,51 +1625,42 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   /* The new expression has side-effects if the old one did.  */\n   TREE_SIDE_EFFECTS (expr) = TREE_SIDE_EFFECTS (t);\n \n-  /* If we are working with gimple form, then we need to keep the tree\n-     in gimple form.  If we are not in gimple form, we can just replace\n-     *tp with the new BIND_EXPR.  */ \n-  if (lang_hooks.gimple_before_inlining)\n-    {\n-      tree save_decl;\n-\n-      /* We want to create a new variable to hold the result of the inlined\n-\t body.  This new variable needs to be added to the function which we\n-\t are inlining into, thus the saving and restoring of\n-\t current_function_decl.  */\n-      save_decl = current_function_decl;\n-      current_function_decl = id->node->decl;\n-      inline_result = voidify_wrapper_expr (expr, NULL);\n-      current_function_decl = save_decl;\n-\n-      /* If the inlined function returns a result that we care about,\n-\t then we're going to need to splice in a MODIFY_EXPR.  Otherwise\n-\t the call was a standalone statement and we can just replace it\n-\t with the BIND_EXPR inline representation of the called function.  */\n-      if (TREE_CODE (tsi_stmt (id->tsi)) != CALL_EXPR)\n-\t{\n-\t  tsi_link_before (&id->tsi, expr, TSI_SAME_STMT);\n-\t  *tp = inline_result;\n-\t}\n-      else\n-\t*tp = expr;\n-\n-      /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS on\n-\t the call if it is to a \"const\" function.  Thus the copy of\n-\t TREE_SIDE_EFFECTS from the CALL_EXPR to the BIND_EXPR above with\n-\t result in TREE_SIDE_EFFECTS not being set for the inlined copy of a\n-\t \"const\" function.\n-\n-\t Unfortunately, that is wrong as inlining the function can\n-\t create/expose interesting side effects (such as setting of a return\n-\t value).\n+  /* We want to create a new variable to hold the result of the inlined\n+     body.  This new variable needs to be added to the function which we\n+     are inlining into, thus the saving and restoring of\n+     current_function_decl.  */\n+  {\n+    tree save_decl = current_function_decl;\n+    current_function_decl = id->node->decl;\n+    inline_result = voidify_wrapper_expr (expr, NULL);\n+    current_function_decl = save_decl;\n+  }\n \n-\t The easiest solution is to simply recalculate TREE_SIDE_EFFECTS for\n-\t the toplevel expression.  */\n-      recalculate_side_effects (expr);\n+  /* If the inlined function returns a result that we care about,\n+     then we're going to need to splice in a MODIFY_EXPR.  Otherwise\n+     the call was a standalone statement and we can just replace it\n+     with the BIND_EXPR inline representation of the called function.  */\n+  if (TREE_CODE (tsi_stmt (id->tsi)) != CALL_EXPR)\n+    {\n+      tsi_link_before (&id->tsi, expr, TSI_SAME_STMT);\n+      *tp = inline_result;\n     }\n   else\n     *tp = expr;\n \n+  /* When we gimplify a function call, we may clear TREE_SIDE_EFFECTS on\n+     the call if it is to a \"const\" function.  Thus the copy of\n+     TREE_SIDE_EFFECTS from the CALL_EXPR to the BIND_EXPR above with\n+     result in TREE_SIDE_EFFECTS not being set for the inlined copy of a\n+     \"const\" function.\n+\n+     Unfortunately, that is wrong as inlining the function can create/expose\n+     interesting side effects (such as setting of a return value).\n+\n+     The easiest solution is to simply recalculate TREE_SIDE_EFFECTS for\n+     the toplevel expression.  */\n+  recalculate_side_effects (expr);\n+\n   /* If the value of the new expression is ignored, that's OK.  We\n      don't warn about this for CALL_EXPRs, so we shouldn't warn about\n      the equivalent inlined version either.  */\n@@ -1706,7 +1685,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n }\n \n static void\n-gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n+expand_calls_inline (tree *stmt_p, inline_data *id)\n {\n   tree stmt = *stmt_p;\n   enum tree_code code = TREE_CODE (stmt); \n@@ -1722,7 +1701,7 @@ gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n \tfor (i = tsi_start (stmt); !tsi_end_p (i); )\n \t  {\n \t    id->tsi = i;\n-\t    gimple_expand_calls_inline (tsi_stmt_ptr (i), id);\n+\t    expand_calls_inline (tsi_stmt_ptr (i), id);\n \n \t    new = tsi_stmt (i);\n \t    if (TREE_CODE (new) == STATEMENT_LIST)\n@@ -1737,26 +1716,26 @@ gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n       break;\n \n     case COND_EXPR:\n-      gimple_expand_calls_inline (&COND_EXPR_THEN (stmt), id);\n-      gimple_expand_calls_inline (&COND_EXPR_ELSE (stmt), id);\n+      expand_calls_inline (&COND_EXPR_THEN (stmt), id);\n+      expand_calls_inline (&COND_EXPR_ELSE (stmt), id);\n       break;\n \n     case CATCH_EXPR:\n-      gimple_expand_calls_inline (&CATCH_BODY (stmt), id);\n+      expand_calls_inline (&CATCH_BODY (stmt), id);\n       break;\n \n     case EH_FILTER_EXPR:\n-      gimple_expand_calls_inline (&EH_FILTER_FAILURE (stmt), id);\n+      expand_calls_inline (&EH_FILTER_FAILURE (stmt), id);\n       break;\n \n     case TRY_CATCH_EXPR:\n     case TRY_FINALLY_EXPR:\n-      gimple_expand_calls_inline (&TREE_OPERAND (stmt, 0), id);\n-      gimple_expand_calls_inline (&TREE_OPERAND (stmt, 1), id);\n+      expand_calls_inline (&TREE_OPERAND (stmt, 0), id);\n+      expand_calls_inline (&TREE_OPERAND (stmt, 1), id);\n       break;\n \n     case BIND_EXPR:\n-      gimple_expand_calls_inline (&BIND_EXPR_BODY (stmt), id);\n+      expand_calls_inline (&BIND_EXPR_BODY (stmt), id);\n       break;\n \n     case COMPOUND_EXPR:\n@@ -1788,30 +1767,6 @@ gimple_expand_calls_inline (tree *stmt_p, inline_data *id)\n     }\n }\n \n-/* Walk over the entire tree *TP, replacing CALL_EXPRs with inline\n-   expansions as appropriate.  */\n-\n-static void\n-expand_calls_inline (tree *tp, inline_data *id)\n-{\n-  /* If we are not in gimple form, then we want to walk the tree\n-     recursively as we do not know anything about the structure\n-     of the tree.  */\n-\n-  if (!lang_hooks.gimple_before_inlining)\n-    {\n-      walk_tree (tp, expand_call_inline, id, id->tree_pruner);\n-      return;\n-    }\n-\n-  /* We are in gimple form.  We want to stay in gimple form.  Walk\n-     the statements, inlining calls in each statement.  By walking\n-     the statements, we have enough information to keep the tree\n-     in gimple form as we insert inline bodies.  */\n-\n-  gimple_expand_calls_inline (tp, id);\n-}\n-\n /* Expand calls to inline functions in the body of FN.  */\n \n void\n@@ -2510,13 +2465,9 @@ debug_find_tree (tree top, tree search)\n static void\n declare_inline_vars (tree bind_expr, tree vars)\n {\n-  if (lang_hooks.gimple_before_inlining)\n-    {\n-      tree t;\n-\n-      for (t = vars; t; t = TREE_CHAIN (t))\n-\tDECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n-    }\n+  tree t;\n+  for (t = vars; t; t = TREE_CHAIN (t))\n+    DECL_SEEN_IN_BIND_EXPR_P (t) = 1;\n \n   add_var_to_bind_expr (bind_expr, vars);\n }"}, {"sha": "750c7af7b4f10e5bb6ebafb0107e058232928443", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84936f6f88f198da47855b9d7d2ff0e7e904fbb4/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=84936f6f88f198da47855b9d7d2ff0e7e904fbb4", "patch": "@@ -57,22 +57,13 @@ bool in_gimple_form;\n /* The root of the compilation pass tree, once constructed.  */\n static struct tree_opt_pass *all_passes;\n \n-/* Pass: gimplify the function if it's not been done.  */\n-\n-static void\n-execute_gimple (void)\n-{\n-  /* We have this test here rather than as the gate because we always\n-     want to dump the original gimplified function.  */\n-  if (!lang_hooks.gimple_before_inlining)\n-    gimplify_function_tree (current_function_decl);\n-}\n+/* Pass: dump the gimplified, inlined, functions.  */\n \n static struct tree_opt_pass pass_gimple = \n {\n   \"gimple\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  execute_gimple,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */"}]}