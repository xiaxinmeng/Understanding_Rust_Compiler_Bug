{"sha": "04c0a88aabe8f73f87d6b756aaa0925e58229c99", "node_id": "C_kwDOANBUbNoAKDA0YzBhODhhYWJlOGY3M2Y4N2Q2Yjc1NmFhYTA5MjVlNTgyMjljOTk", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-05-13T10:48:51Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-05-13T10:48:51Z"}, "message": "Avoid visiting newly-created blocks in harden-conditionals\n\nReverse iteration over blocks, in gimple-harden-conditionals.cc, was\nsupposed to avoid visiting blocks introduced by hardening and\nintroducing further reversed conditionals and traps for them, but\nnewly-created blocks may be inserted before the current block, as\nshown by the PR105455 testcase.\n\nUse an auto_sbitmap to gather preexisting blocks that need visiting.\n\n\nfor  gcc/ChangeLog\n\n\t* gimple-harden-conditionals.cc: Include sbitmap.h.\n\t(pass_harden_conditional_branches::execute): Skip new blocks.\n\t(pass_harden_compares::execute): Likewise.", "tree": {"sha": "b04ef9a67a67e6f519d2f252fbe2f12c6a339a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b04ef9a67a67e6f519d2f252fbe2f12c6a339a2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04c0a88aabe8f73f87d6b756aaa0925e58229c99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c0a88aabe8f73f87d6b756aaa0925e58229c99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04c0a88aabe8f73f87d6b756aaa0925e58229c99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04c0a88aabe8f73f87d6b756aaa0925e58229c99/comments", "author": null, "committer": null, "parents": [{"sha": "6aaa1d573912828efed1514fbec5e1ef8a7cc3bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aaa1d573912828efed1514fbec5e1ef8a7cc3bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aaa1d573912828efed1514fbec5e1ef8a7cc3bc"}], "stats": {"total": 417, "additions": 220, "deletions": 197}, "files": [{"sha": "79c0a5784baf837a83051465f2d4ec064ab522da", "filename": "gcc/gimple-harden-conditionals.cc", "status": "modified", "additions": 220, "deletions": 197, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04c0a88aabe8f73f87d6b756aaa0925e58229c99/gcc%2Fgimple-harden-conditionals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04c0a88aabe8f73f87d6b756aaa0925e58229c99/gcc%2Fgimple-harden-conditionals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-harden-conditionals.cc?ref=04c0a88aabe8f73f87d6b756aaa0925e58229c99", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"cfgloop.h\"\n #include \"tree-eh.h\"\n+#include \"sbitmap.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n \n@@ -303,9 +304,21 @@ insert_edge_check_and_trap (location_t loc, edge e,\n unsigned int\n pass_harden_conditional_branches::execute (function *fun)\n {\n+  /* Record the preexisting blocks, to avoid visiting newly-created\n+     blocks.  */\n+  auto_sbitmap to_visit (last_basic_block_for_fn (fun));\n+  bitmap_clear (to_visit);\n+\n   basic_block bb;\n-  FOR_EACH_BB_REVERSE_FN (bb, fun)\n+  FOR_EACH_BB_FN (bb, fun)\n+    bitmap_set_bit (to_visit, bb->index);\n+\n+  sbitmap_iterator it;\n+  unsigned i;\n+  EXECUTE_IF_SET_IN_BITMAP (to_visit, 0, i, it)\n     {\n+      bb = BASIC_BLOCK_FOR_FN (fun, i);\n+\n       gimple_stmt_iterator gsi = gsi_last_bb (bb);\n \n       if (gsi_end_p (gsi))\n@@ -385,205 +398,215 @@ non_eh_succ_edge (basic_block bb, edge *ehp = NULL)\n unsigned int\n pass_harden_compares::execute (function *fun)\n {\n+  /* Record the preexisting blocks, to avoid visiting newly-created\n+     blocks.  */\n+  auto_sbitmap to_visit (last_basic_block_for_fn (fun));\n+  bitmap_clear (to_visit);\n+\n   basic_block bb;\n-  /* Go backwards over BBs and stmts, so that, even if we split the\n-     block multiple times to insert a cond_expr after each compare we\n-     find, we remain in the same block, visiting every preexisting\n-     stmt exactly once, and not visiting newly-added blocks or\n-     stmts.  */\n-  FOR_EACH_BB_REVERSE_FN (bb, fun)\n-    for (gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-\t !gsi_end_p (gsi); gsi_prev (&gsi))\n-      {\n-\tgassign *asgn = dyn_cast <gassign *> (gsi_stmt (gsi));\n-\tif (!asgn)\n-\t  continue;\n-\n-\t/* Turn:\n-\n-\t   z = x op y;\n-\n-\t   into:\n-\n-\t   z = x op y;\n-\t   z' = x' cop y';\n-\t   if (z == z') __builtin_trap ();\n-\n-\t   where cop is a complementary boolean operation to op; and x'\n-\t   and y' hold the same value as x and y, but in a way that does\n-\t   not enable the compiler to optimize the redundant compare\n-\t   away.\n-\t*/\n-\n-\tenum tree_code op = gimple_assign_rhs_code (asgn);\n-\n-\tenum tree_code cop;\n-\n-\tswitch (op)\n-\t  {\n-\t  case EQ_EXPR:\n-\t  case NE_EXPR:\n-\t  case GT_EXPR:\n-\t  case GE_EXPR:\n-\t  case LT_EXPR:\n-\t  case LE_EXPR:\n-\t  case LTGT_EXPR:\n-\t  case UNEQ_EXPR:\n-\t  case UNGT_EXPR:\n-\t  case UNGE_EXPR:\n-\t  case UNLT_EXPR:\n-\t  case UNLE_EXPR:\n-\t  case ORDERED_EXPR:\n-\t  case UNORDERED_EXPR:\n-\t    cop = invert_tree_comparison (op,\n-\t\t\t\t\t  HONOR_NANS\n-\t\t\t\t\t  (gimple_assign_rhs1 (asgn)));\n-\n-\t    if (cop == ERROR_MARK)\n-\t      /* ??? Can we do better?  */\n-\t      continue;\n+  FOR_EACH_BB_FN (bb, fun)\n+    bitmap_set_bit (to_visit, bb->index);\n+\n+  sbitmap_iterator it;\n+  unsigned i;\n+  EXECUTE_IF_SET_IN_BITMAP (to_visit, 0, i, it)\n+    {\n+      bb = BASIC_BLOCK_FOR_FN (fun, i);\n \n-\t    break;\n-\n-\t    /* ??? Maybe handle these too?  */\n-\t  case TRUTH_NOT_EXPR:\n-\t    /* ??? The code below assumes binary ops, it would have to\n-\t       be adjusted for TRUTH_NOT_EXPR, since it's unary.  */\n-\t  case TRUTH_ANDIF_EXPR:\n-\t  case TRUTH_ORIF_EXPR:\n-\t  case TRUTH_AND_EXPR:\n-\t  case TRUTH_OR_EXPR:\n-\t  case TRUTH_XOR_EXPR:\n-\t  default:\n+      for (gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+\t   !gsi_end_p (gsi); gsi_prev (&gsi))\n+\t{\n+\t  gassign *asgn = dyn_cast <gassign *> (gsi_stmt (gsi));\n+\t  if (!asgn)\n+\t    continue;\n+\n+\t  /* Turn:\n+\n+\t     z = x op y;\n+\n+\t     into:\n+\n+\t     z = x op y;\n+\t     z' = x' cop y';\n+\t     if (z == z') __builtin_trap ();\n+\n+\t     where cop is a complementary boolean operation to op; and x'\n+\t     and y' hold the same value as x and y, but in a way that does\n+\t     not enable the compiler to optimize the redundant compare\n+\t     away.\n+\t  */\n+\n+\t  enum tree_code op = gimple_assign_rhs_code (asgn);\n+\n+\t  enum tree_code cop;\n+\n+\t  switch (op)\n+\t    {\n+\t    case EQ_EXPR:\n+\t    case NE_EXPR:\n+\t    case GT_EXPR:\n+\t    case GE_EXPR:\n+\t    case LT_EXPR:\n+\t    case LE_EXPR:\n+\t    case LTGT_EXPR:\n+\t    case UNEQ_EXPR:\n+\t    case UNGT_EXPR:\n+\t    case UNGE_EXPR:\n+\t    case UNLT_EXPR:\n+\t    case UNLE_EXPR:\n+\t    case ORDERED_EXPR:\n+\t    case UNORDERED_EXPR:\n+\t      cop = invert_tree_comparison (op,\n+\t\t\t\t\t    HONOR_NANS\n+\t\t\t\t\t    (gimple_assign_rhs1 (asgn)));\n+\n+\t      if (cop == ERROR_MARK)\n+\t\t/* ??? Can we do better?  */\n+\t\tcontinue;\n+\n+\t      break;\n+\n+\t      /* ??? Maybe handle these too?  */\n+\t    case TRUTH_NOT_EXPR:\n+\t      /* ??? The code below assumes binary ops, it would have to\n+\t\t be adjusted for TRUTH_NOT_EXPR, since it's unary.  */\n+\t    case TRUTH_ANDIF_EXPR:\n+\t    case TRUTH_ORIF_EXPR:\n+\t    case TRUTH_AND_EXPR:\n+\t    case TRUTH_OR_EXPR:\n+\t    case TRUTH_XOR_EXPR:\n+\t    default:\n+\t      continue;\n+\t    }\n+\n+\t  /* These are the operands for the verification.  */\n+\t  tree lhs = gimple_assign_lhs (asgn);\n+\t  tree op1 = gimple_assign_rhs1 (asgn);\n+\t  tree op2 = gimple_assign_rhs2 (asgn);\n+\t  location_t loc = gimple_location (asgn);\n+\n+\t  /* Vector booleans can't be used in conditional branches.  ???\n+\t     Can we do better?  How to reduce compare and\n+\t     reversed-compare result vectors to a single boolean?  */\n+\t  if (VECTOR_TYPE_P (TREE_TYPE (op1)))\n \t    continue;\n-\t  }\n-\n-\t/* These are the operands for the verification.  */\n-\ttree lhs = gimple_assign_lhs (asgn);\n-\ttree op1 = gimple_assign_rhs1 (asgn);\n-\ttree op2 = gimple_assign_rhs2 (asgn);\n-\tlocation_t loc = gimple_location (asgn);\n-\n-\t/* Vector booleans can't be used in conditional branches.  ???\n-\t   Can we do better?  How to reduce compare and\n-\t   reversed-compare result vectors to a single boolean?  */\n-\tif (VECTOR_TYPE_P (TREE_TYPE (op1)))\n-\t  continue;\n-\n-\t/* useless_type_conversion_p enables conversions from 1-bit\n-\t   integer types to boolean to be discarded.  */\n-\tgcc_checking_assert (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE\n-\t\t\t     || (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-\t\t\t\t && TYPE_PRECISION (TREE_TYPE (lhs)) == 1));\n-\n-\ttree rhs = copy_ssa_name (lhs);\n-\n-\tgimple_stmt_iterator gsi_split = gsi;\n-\t/* Don't separate the original assignment from debug stmts\n-\t   that might be associated with it, and arrange to split the\n-\t   block after debug stmts, so as to make sure the split block\n-\t   won't be debug stmts only.  */\n-\tgsi_next_nondebug (&gsi_split);\n-\n-\tbool throwing_compare_p = stmt_ends_bb_p (asgn);\n-\tif (throwing_compare_p)\n-\t  {\n-\t    basic_block nbb = split_edge (non_eh_succ_edge\n-\t\t\t\t\t  (gimple_bb (asgn)));\n-\t    gsi_split = gsi_start_bb (nbb);\n-\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"Splitting non-EH edge from block %i into %i\"\n-\t\t       \" after a throwing compare\\n\",\n-\t\t       gimple_bb (asgn)->index, nbb->index);\n-\t  }\n-\n-\tbool same_p = (op1 == op2);\n-\top1 = detach_value (loc, &gsi_split, op1);\n-\top2 = same_p ? op1 : detach_value (loc, &gsi_split, op2);\n-\n-\tgassign *asgnck = gimple_build_assign (rhs, cop, op1, op2);\n-\tgimple_set_location (asgnck, loc);\n-\tgsi_insert_before (&gsi_split, asgnck, GSI_SAME_STMT);\n-\n-\t/* We wish to insert a cond_expr after the compare, so arrange\n-\t   for it to be at the end of a block if it isn't, and for it\n-\t   to have a single successor in case there's more than\n-\t   one, as in PR104975.  */\n-\tif (!gsi_end_p (gsi_split)\n-\t    || !single_succ_p (gsi_bb (gsi_split)))\n-\t  {\n-\t    if (!gsi_end_p (gsi_split))\n-\t      gsi_prev (&gsi_split);\n-\t    else\n-\t      gsi_split = gsi_last_bb (gsi_bb (gsi_split));\n-\t    basic_block obb = gsi_bb (gsi_split);\n-\t    basic_block nbb = split_block (obb, gsi_stmt (gsi_split))->dest;\n-\t    gsi_next (&gsi_split);\n-\t    gcc_checking_assert (gsi_end_p (gsi_split));\n-\n-\t    single_succ_edge (bb)->goto_locus = loc;\n-\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"Splitting block %i into %i\"\n-\t\t       \" before the conditional trap branch\\n\",\n-\t\t       obb->index, nbb->index);\n-\t  }\n-\n-\t/* If the check assignment must end a basic block, we can't\n-\t   insert the conditional branch in the same block, so split\n-\t   the block again, and prepare to insert the conditional\n-\t   branch in the new block.\n-\n-\t   Also assign an EH region to the compare.  Even though it's\n-\t   unlikely that the hardening compare will throw after the\n-\t   original compare didn't, the compiler won't even know that\n-\t   it's the same compare operands, so add the EH edge anyway.  */\n-\tif (throwing_compare_p)\n-\t  {\n-\t    add_stmt_to_eh_lp (asgnck, lookup_stmt_eh_lp (asgn));\n-\t    make_eh_edges (asgnck);\n-\n-\t    edge ckeh;\n-\t    basic_block nbb = split_edge (non_eh_succ_edge\n-\t\t\t\t\t  (gimple_bb (asgnck), &ckeh));\n-\t    gsi_split = gsi_start_bb (nbb);\n-\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"Splitting non-EH edge from block %i into %i after\"\n-\t\t       \" the newly-inserted reversed throwing compare\\n\",\n-\t\t       gimple_bb (asgnck)->index, nbb->index);\n-\n-\t    if (!gimple_seq_empty_p (phi_nodes (ckeh->dest)))\n-\t      {\n-\t\tedge aseh;\n-\t\tnon_eh_succ_edge (gimple_bb (asgn), &aseh);\n-\n-\t\tgcc_checking_assert (aseh->dest == ckeh->dest);\n-\n-\t\tfor (gphi_iterator psi = gsi_start_phis (ckeh->dest);\n-\t\t     !gsi_end_p (psi); gsi_next (&psi))\n-\t\t  {\n-\t\t    gphi *phi = psi.phi ();\n-\t\t    add_phi_arg (phi, PHI_ARG_DEF_FROM_EDGE (phi, aseh), ckeh,\n-\t\t\t\t gimple_phi_arg_location_from_edge (phi, aseh));\n-\t\t  }\n-\n-\t\tif (dump_file)\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"Copying PHI args in EH block %i from %i to %i\\n\",\n-\t\t\t   aseh->dest->index, aseh->src->index, ckeh->src->index);\n-\t      }\n-\t  }\n-\n-\tgcc_checking_assert (single_succ_p (gsi_bb (gsi_split)));\n-\n-\tinsert_check_and_trap (loc, &gsi_split, EDGE_TRUE_VALUE,\n-\t\t\t       EQ_EXPR, lhs, rhs);\n-      }\n+\n+\t  /* useless_type_conversion_p enables conversions from 1-bit\n+\t     integer types to boolean to be discarded.  */\n+\t  gcc_checking_assert (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE\n+\t\t\t       || (INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t\t\t\t   && TYPE_PRECISION (TREE_TYPE (lhs)) == 1));\n+\n+\t  tree rhs = copy_ssa_name (lhs);\n+\n+\t  gimple_stmt_iterator gsi_split = gsi;\n+\t  /* Don't separate the original assignment from debug stmts\n+\t     that might be associated with it, and arrange to split the\n+\t     block after debug stmts, so as to make sure the split block\n+\t     won't be debug stmts only.  */\n+\t  gsi_next_nondebug (&gsi_split);\n+\n+\t  bool throwing_compare_p = stmt_ends_bb_p (asgn);\n+\t  if (throwing_compare_p)\n+\t    {\n+\t      basic_block nbb = split_edge (non_eh_succ_edge\n+\t\t\t\t\t    (gimple_bb (asgn)));\n+\t      gsi_split = gsi_start_bb (nbb);\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Splitting non-EH edge from block %i into %i\"\n+\t\t\t \" after a throwing compare\\n\",\n+\t\t\t gimple_bb (asgn)->index, nbb->index);\n+\t    }\n+\n+\t  bool same_p = (op1 == op2);\n+\t  op1 = detach_value (loc, &gsi_split, op1);\n+\t  op2 = same_p ? op1 : detach_value (loc, &gsi_split, op2);\n+\n+\t  gassign *asgnck = gimple_build_assign (rhs, cop, op1, op2);\n+\t  gimple_set_location (asgnck, loc);\n+\t  gsi_insert_before (&gsi_split, asgnck, GSI_SAME_STMT);\n+\n+\t  /* We wish to insert a cond_expr after the compare, so arrange\n+\t     for it to be at the end of a block if it isn't, and for it\n+\t     to have a single successor in case there's more than\n+\t     one, as in PR104975.  */\n+\t  if (!gsi_end_p (gsi_split)\n+\t      || !single_succ_p (gsi_bb (gsi_split)))\n+\t    {\n+\t      if (!gsi_end_p (gsi_split))\n+\t\tgsi_prev (&gsi_split);\n+\t      else\n+\t\tgsi_split = gsi_last_bb (gsi_bb (gsi_split));\n+\t      basic_block obb = gsi_bb (gsi_split);\n+\t      basic_block nbb = split_block (obb, gsi_stmt (gsi_split))->dest;\n+\t      gsi_next (&gsi_split);\n+\t      gcc_checking_assert (gsi_end_p (gsi_split));\n+\n+\t      single_succ_edge (bb)->goto_locus = loc;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Splitting block %i into %i\"\n+\t\t\t \" before the conditional trap branch\\n\",\n+\t\t\t obb->index, nbb->index);\n+\t    }\n+\n+\t  /* If the check assignment must end a basic block, we can't\n+\t     insert the conditional branch in the same block, so split\n+\t     the block again, and prepare to insert the conditional\n+\t     branch in the new block.\n+\n+\t     Also assign an EH region to the compare.  Even though it's\n+\t     unlikely that the hardening compare will throw after the\n+\t     original compare didn't, the compiler won't even know that\n+\t     it's the same compare operands, so add the EH edge anyway.  */\n+\t  if (throwing_compare_p)\n+\t    {\n+\t      add_stmt_to_eh_lp (asgnck, lookup_stmt_eh_lp (asgn));\n+\t      make_eh_edges (asgnck);\n+\n+\t      edge ckeh;\n+\t      basic_block nbb = split_edge (non_eh_succ_edge\n+\t\t\t\t\t    (gimple_bb (asgnck), &ckeh));\n+\t      gsi_split = gsi_start_bb (nbb);\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Splitting non-EH edge from block %i into %i after\"\n+\t\t\t \" the newly-inserted reversed throwing compare\\n\",\n+\t\t\t gimple_bb (asgnck)->index, nbb->index);\n+\n+\t      if (!gimple_seq_empty_p (phi_nodes (ckeh->dest)))\n+\t\t{\n+\t\t  edge aseh;\n+\t\t  non_eh_succ_edge (gimple_bb (asgn), &aseh);\n+\n+\t\t  gcc_checking_assert (aseh->dest == ckeh->dest);\n+\n+\t\t  for (gphi_iterator psi = gsi_start_phis (ckeh->dest);\n+\t\t       !gsi_end_p (psi); gsi_next (&psi))\n+\t\t    {\n+\t\t      gphi *phi = psi.phi ();\n+\t\t      add_phi_arg (phi, PHI_ARG_DEF_FROM_EDGE (phi, aseh), ckeh,\n+\t\t\t\t   gimple_phi_arg_location_from_edge (phi, aseh));\n+\t\t    }\n+\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Copying PHI args in EH block %i from %i to %i\\n\",\n+\t\t\t     aseh->dest->index, aseh->src->index,\n+\t\t\t     ckeh->src->index);\n+\t\t}\n+\t    }\n+\n+\t  gcc_checking_assert (single_succ_p (gsi_bb (gsi_split)));\n+\n+\t  insert_check_and_trap (loc, &gsi_split, EDGE_TRUE_VALUE,\n+\t\t\t\t EQ_EXPR, lhs, rhs);\n+\t}\n+    }\n \n   return 0;\n }"}]}