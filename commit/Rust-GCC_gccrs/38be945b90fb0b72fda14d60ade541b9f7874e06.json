{"sha": "38be945b90fb0b72fda14d60ade541b9f7874e06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiZTk0NWI5MGZiMGI3MmZkYTE0ZDYwYWRlNTQxYjlmNzg3NGUwNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-07-07T01:12:23Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-07-07T01:12:23Z"}, "message": "gimple.texi (GIMPLE_DEBUG): Document.\n\n* doc/gimple.texi (GIMPLE_DEBUG): Document.\n* doc/rtl.texi (Debug Information): New node.\n(NOTE_INSN_VAR_LOCATION): Document.\n(debug_insn): Likewise.\n* doc/generic.texi (DEBUG_EXPR_DECL): Document.\n\nFrom-SVN: r161899", "tree": {"sha": "965c64a49a4d2c83b9626aef7967bd420c33f779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/965c64a49a4d2c83b9626aef7967bd420c33f779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38be945b90fb0b72fda14d60ade541b9f7874e06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38be945b90fb0b72fda14d60ade541b9f7874e06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38be945b90fb0b72fda14d60ade541b9f7874e06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38be945b90fb0b72fda14d60ade541b9f7874e06/comments", "author": null, "committer": null, "parents": [{"sha": "6938f93f2ec91e5c8f68469512593efba643caef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6938f93f2ec91e5c8f68469512593efba643caef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6938f93f2ec91e5c8f68469512593efba643caef"}], "stats": {"total": 173, "additions": 172, "deletions": 1}, "files": [{"sha": "b42a64fdb3f183c2de2c7a0b8d246788e2a62812", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38be945b90fb0b72fda14d60ade541b9f7874e06", "patch": "@@ -1,3 +1,11 @@\n+2010-07-06  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* doc/gimple.texi (GIMPLE_DEBUG): Document.\n+\t* doc/rtl.texi (Debug Information): New node.\n+\t(NOTE_INSN_VAR_LOCATION): Document.\n+\t(debug_insn): Likewise.\n+\t* doc/generic.texi (DEBUG_EXPR_DECL): Document.\n+\n 2010-07-07  Jan Hubicka  <jh@suse.cz>\n \n \tWith parts by Richard Guenther"}, {"sha": "3dff70359f23922639643ff03ec803ec22b3549b", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=38be945b90fb0b72fda14d60ade541b9f7874e06", "patch": "@@ -601,6 +601,7 @@ in hand, using @code{same_type_p}.\n @tindex TYPE_DECL\n @tindex VAR_DECL\n @tindex PARM_DECL\n+@tindex DEBUG_EXPR_DECL\n @tindex FIELD_DECL\n @tindex NAMESPACE_DECL\n @tindex RESULT_DECL\n@@ -726,6 +727,11 @@ wider type than the @code{TREE_TYPE} of the parameter; for example, the\n ordinary type might be @code{short} while the @code{DECL_ARG_TYPE} is\n @code{int}.\n \n+@item DEBUG_EXPR_DECL\n+Used to represent an anonymous debug-information temporary created to\n+hold an expression as it is optimized away, so that its value can be\n+referenced in debug bind statements.\n+\n @item FIELD_DECL\n These nodes represent non-static data members.  The @code{DECL_SIZE} and\n @code{DECL_ALIGN} behave as for @code{VAR_DECL} nodes.  "}, {"sha": "5e217a772da0f67bf6dfffe9af998b6d4a6e5ba9", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=38be945b90fb0b72fda14d60ade541b9f7874e06", "patch": "@@ -333,6 +333,7 @@ The following table briefly describes the GIMPLE instruction set.\n @item @code{GIMPLE_CALL}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_CATCH}\t\t@tab x\t\t\t@tab\n @item @code{GIMPLE_COND}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_DEBUG}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_EH_FILTER}\t\t@tab x\t\t\t@tab\n @item @code{GIMPLE_GOTO}\t\t@tab x\t\t\t@tab x\n @item @code{GIMPLE_LABEL}\t\t@tab x\t\t\t@tab x\n@@ -907,6 +908,7 @@ Return a deep copy of statement @code{STMT}.\n * @code{GIMPLE_CALL}::\n * @code{GIMPLE_CATCH}::\n * @code{GIMPLE_COND}::\n+* @code{GIMPLE_DEBUG}::\n * @code{GIMPLE_EH_FILTER}::\n * @code{GIMPLE_LABEL}::\n * @code{GIMPLE_NOP}::\n@@ -1397,6 +1399,83 @@ Set the conditional @code{COND_STMT} to be of the form 'if (1 == 0)'.\n Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'. \n @end deftypefn\n \n+@node @code{GIMPLE_DEBUG}\n+@subsection @code{GIMPLE_DEBUG}\n+@cindex @code{GIMPLE_DEBUG}\n+@cindex @code{GIMPLE_DEBUG_BIND}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_debug_bind (tree var, tree value, gimple stmt)\n+Build a @code{GIMPLE_DEBUG} statement with @code{GIMPLE_DEBUG_BIND} of\n+@code{subcode}.  The effect of this statement is to tell debug\n+information generation machinery that the value of user variable\n+@code{var} is given by @code{value} at that point, and to remain with\n+that value until @code{var} runs out of scope, a\n+dynamically-subsequent debug bind statement overrides the binding, or\n+conflicting values reach a control flow merge point.  Even if\n+components of the @code{value} expression change afterwards, the\n+variable is supposed to retain the same value, though not necessarily\n+the same location.\n+\n+It is expected that @code{var} be most often a tree for automatic user\n+variables (@code{VAR_DECL} or @code{PARM_DECL}) that satisfy the\n+requirements for gimple registers, but it may also be a tree for a\n+scalarized component of a user variable (@code{ARRAY_REF},\n+@code{COMPONENT_REF}), or a debug temporary (@code{DEBUG_EXPR_DECL}).\n+\n+As for @code{value}, it can be an arbitrary tree expression, but it is\n+recommended that it be in a suitable form for a gimple assignment\n+@code{RHS}.  It is not expected that user variables that could appear\n+as @code{var} ever appear in @code{value}, because in the latter we'd\n+have their @code{SSA_NAME}s instead, but even if they were not in SSA\n+form, user variables appearing in @code{value} are to be regarded as\n+part of the executable code space, whereas those in @code{var} are to\n+be regarded as part of the source code space.  There is no way to\n+refer to the value bound to a user variable within a @code{value}\n+expression.\n+\n+If @code{value} is @code{GIMPLE_DEBUG_BIND_NOVALUE}, debug information\n+generation machinery is informed that the variable @code{var} is\n+unbound, i.e., that its value is indeterminate, which sometimes means\n+it is really unavailable, and other times that the compiler could not\n+keep track of it.\n+\n+Block and location information for the newly-created stmt are\n+taken from @code{stmt}, if given.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_debug_bind_get_var (gimple stmt)\n+Return the user variable @var{var} that is bound at @code{stmt}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_debug_bind_get_value (gimple stmt)\n+Return the value expression that is bound to a user variable at\n+@code{stmt}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_debug_bind_get_value_ptr (gimple stmt)\n+Return a pointer to the value expression that is bound to a user\n+variable at @code{stmt}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_debug_bind_set_var (gimple stmt, tree var)\n+Modify the user variable bound at @code{stmt} to @var{var}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_debug_bind_set_value (gimple stmt, tree var)\n+Modify the value bound to the user variable bound at @code{stmt} to\n+@var{value}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_debug_bind_reset_value (gimple stmt)\n+Modify the value bound to the user variable bound at @code{stmt} so\n+that the variable becomes unbound.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_debug_bind_has_value_p (gimple stmt)\n+Return @code{TRUE} if @code{stmt} binds a user variable to a value,\n+and @code{FALSE} if it unbinds the variable.\n+@end deftypefn\n+\n @node @code{GIMPLE_EH_FILTER}\n @subsection @code{GIMPLE_EH_FILTER}\n @cindex @code{GIMPLE_EH_FILTER}"}, {"sha": "4c15e8fab1d8be417b63d825988d2951338760b1", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38be945b90fb0b72fda14d60ade541b9f7874e06/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=38be945b90fb0b72fda14d60ade541b9f7874e06", "patch": "@@ -38,6 +38,7 @@ form uses nested parentheses to indicate the pointers in the internal form.\n * Side Effects::      Expressions for storing in registers, etc.\n * Incdec::            Embedded side-effects for autoincrement addressing.\n * Assembler::         Representing @code{asm} with operands.\n+* Debug Information:: Expressions representing debugging information.\n * Insns::             Expression types for entire insns.\n * Calls::             RTL representation of function call insns.\n * Sharing::           Some expressions are unique; others *must* be copied.\n@@ -3285,6 +3286,38 @@ template and vectors, but each contains the constraint for the respective\n output operand.  They are also distinguished by the output-operand index\n number, which is 0, 1, @dots{} for successive output operands.\n \n+@node Debug Information\n+@section Variable Location Debug Information in RTL\n+@cindex Variable Location Debug Information in RTL\n+\n+Variable tracking relies on @code{MEM_EXPR} and @code{REG_EXPR}\n+annotations to determine what user variables memory and register\n+references refer to.\n+\n+Variable tracking at assignments uses these notes only when they refer\n+to variables that live at fixed locations (e.g., addressable\n+variables, global non-automatic variables).  For variables whose\n+location may vary, it relies on the following types of notes.\n+\n+@table @code\n+@findex var_location\n+@item (var_location:@var{mode} @var{var} @var{exp} @var{stat})\n+Binds variable @code{var}, a tree, to value @var{exp}, an RTL\n+expression.  It appears only in @code{NOTE_INSN_VAR_LOCATION} and\n+@code{DEBUG_INSN}s, with slightly different meanings.  @var{mode}, if\n+present, represents the mode of @var{exp}, which is useful if it is a\n+modeless expression.  @var{stat} is only meaningful in notes,\n+indicating whether the variable is known to be initialized or\n+uninitialized.\n+\n+@findex debug_expr\n+@item (debug_expr:@var{mode} @var{decl})\n+Stands for the value bound to the @code{DEBUG_EXPR_DECL} @var{decl},\n+that points back to it, within value expressions in\n+@code{VAR_LOCATION} nodes.\n+\n+@end table\n+\n @node Insns\n @section Insns\n @cindex insns\n@@ -3360,7 +3393,7 @@ of @code{PREV_INSN (NEXT_INSN (@var{insn}))} if @var{insn} is the last\n insn in the @code{sequence} expression.  You can use these expressions\n to find the containing @code{sequence} expression.\n \n-Every insn has one of the following six expression codes:\n+Every insn has one of the following expression codes:\n \n @table @code\n @findex insn\n@@ -3551,9 +3584,54 @@ invariants.\n Appears at the start of the function body, after the function\n prologue.\n \n+@findex NOTE_INSN_VAR_LOCATION\n+@findex NOTE_VAR_LOCATION\n+@item NOTE_INSN_VAR_LOCATION\n+This note is used to generate variable location debugging information.\n+It indicates that the user variable in its @code{VAR_LOCATION} operand\n+is at the location given in the RTL expression, or holds a value that\n+can be computed by evaluating the RTL expression from that static\n+point in the program up to the next such note for the same user\n+variable.\n+\n @end table\n \n These codes are printed symbolically when they appear in debugging dumps.\n+\n+@findex debug_insn\n+@findex INSN_VAR_LOCATION\n+@item debug_insn\n+The expression code @code{debug_insn} is used for pseudo-instructions\n+that hold debugging information for variable tracking at assignments\n+(see @option{-fvar-tracking-assignments} option).  They are the RTL\n+representation of @code{GIMPLE_DEBUG} statements\n+(@ref{@code{GIMPLE_DEBUG}}), with a @code{VAR_LOCATION} operand that\n+binds a user variable tree to an RTL representation of the\n+@code{value} in the corresponding statement.  A @code{DEBUG_EXPR} in\n+it stands for the value bound to the corresponding\n+@code{DEBUG_EXPR_DECL}.\n+\n+Throughout optimization passes, binding information is kept in\n+pseudo-instruction form, so that, unlike notes, it gets the same\n+treatment and adjustments that regular instructions would.  It is the\n+variable tracking pass that turns these pseudo-instructions into var\n+location notes, analyzing control flow, value equivalences and changes\n+to registers and memory referenced in value expressions, propagating\n+the values of debug temporaries and determining expressions that can\n+be used to compute the value of each user variable at as many points\n+(ranges, actually) in the program as possible.\n+\n+Unlike @code{NOTE_INSN_VAR_LOCATION}, the value expression in an\n+@code{INSN_VAR_LOCATION} denotes a value at that specific point in the\n+program, rather than an expression that can be evaluated at any later\n+point before an overriding @code{VAR_LOCATION} is encountered.  E.g.,\n+if a user variable is bound to a @code{REG} and then a subsequent insn\n+modifies the @code{REG}, the note location would keep mapping the user\n+variable to the register across the insn, whereas the insn location\n+would keep the variable bound to the value, so that the variable\n+tracking pass would emit another location note for the variable at the\n+point in which the register is modified.\n+\n @end table\n \n @cindex @code{TImode}, in @code{insn}"}]}