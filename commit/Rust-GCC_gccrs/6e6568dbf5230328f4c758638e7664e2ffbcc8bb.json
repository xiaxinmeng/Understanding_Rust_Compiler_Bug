{"sha": "6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2NTY4ZGJmNTIzMDMyOGY0Yzc1ODYzOGU3NjY0ZTJmZmJjYzhiYg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-07-21T22:56:40Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-07-21T22:56:40Z"}, "message": "Do not compute twice type, lb, and ub.\n\n2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c (graphite_create_new_loop): Do not\n\trecompute type, lb, and ub.  Get them from...\n\t(graphite_create_new_loop_guard): ...here.  Pass in parameter\n\tpointers to type, lb, and ub.\n\t(translate_clast_for_loop): Update function calls.\n\t(translate_clast_for): Same.\n\nFrom-SVN: r176597", "tree": {"sha": "d4093aec7c9e900830381cdcf5cbeb7019df2a10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4093aec7c9e900830381cdcf5cbeb7019df2a10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e6568dbf5230328f4c758638e7664e2ffbcc8bb/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dff62090a4dba1991b7cb7d8af42e92ead0f84b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dff62090a4dba1991b7cb7d8af42e92ead0f84b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dff62090a4dba1991b7cb7d8af42e92ead0f84b4"}], "stats": {"total": 70, "additions": 39, "deletions": 31}, "files": [{"sha": "5767a4f44371a5bd719d7c24f25a6be4be003f34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6568dbf5230328f4c758638e7664e2ffbcc8bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6568dbf5230328f4c758638e7664e2ffbcc8bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "patch": "@@ -1,3 +1,12 @@\n+2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (graphite_create_new_loop): Do not\n+\trecompute type, lb, and ub.  Get them from...\n+\t(graphite_create_new_loop_guard): ...here.  Pass in parameter\n+\tpointers to type, lb, and ub.\n+\t(translate_clast_for_loop): Update function calls.\n+\t(translate_clast_for): Same.\n+\n 2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (compute_bounds_for_level): Call"}, {"sha": "a8ac9c6bfa6716cdafc9f049f743746059761d91", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e6568dbf5230328f4c758638e7664e2ffbcc8bb/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e6568dbf5230328f4c758638e7664e2ffbcc8bb/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=6e6568dbf5230328f4c758638e7664e2ffbcc8bb", "patch": "@@ -696,23 +696,15 @@ gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for, int level,\n    becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n    CLooG's scattering name to the induction variable created for the\n    loop of STMT.  The new induction variable is inserted in the NEWIVS\n-   vector.  */\n+   vector and is of type TYPE.  */\n \n static struct loop *\n-graphite_create_new_loop (sese region, edge entry_edge,\n+graphite_create_new_loop (edge entry_edge,\n \t\t\t  struct clast_for *stmt,\n \t\t\t  loop_p outer, VEC (tree, heap) **newivs,\n-\t\t\t  htab_t newivs_index, htab_t params_index, int level)\n+\t\t\t  htab_t newivs_index,\n+\t\t\t  tree type, tree lb, tree ub)\n {\n-  tree lb_type = gcc_type_for_clast_expr (stmt->LB, region, *newivs,\n-\t\t\t\t\t  newivs_index, params_index);\n-  tree ub_type = gcc_type_for_clast_expr (stmt->UB, region, *newivs,\n-\t\t\t\t\t  newivs_index, params_index);\n-  tree type = gcc_type_for_iv_of_clast_loop (stmt, level, lb_type, ub_type);\n-  tree lb = clast_to_gcc_expression (type, stmt->LB, region, *newivs,\n-\t\t\t\t     newivs_index, params_index);\n-  tree ub = clast_to_gcc_expression (type, stmt->UB, region, *newivs,\n-\t\t\t\t     newivs_index, params_index);\n   tree stride = gmp_cst_to_tree (type, stmt->stride);\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n   tree iv, iv_after_increment;\n@@ -887,36 +879,39 @@ static edge\n graphite_create_new_loop_guard (sese region, edge entry_edge,\n \t\t\t\tstruct clast_for *stmt,\n \t\t\t\tVEC (tree, heap) *newivs,\n-\t\t\t\thtab_t newivs_index, htab_t params_index)\n+\t\t\t\thtab_t newivs_index, htab_t params_index,\n+\t\t\t\tint level, tree *type, tree *lb, tree *ub)\n {\n   tree cond_expr;\n   edge exit_edge;\n   tree lb_type = gcc_type_for_clast_expr (stmt->LB, region, newivs,\n \t\t\t\t\t  newivs_index, params_index);\n   tree ub_type = gcc_type_for_clast_expr (stmt->UB, region, newivs,\n \t\t\t\t\t  newivs_index, params_index);\n-  tree type = max_precision_type (lb_type, ub_type);\n-  tree lb = clast_to_gcc_expression (type, stmt->LB, region, newivs,\n-\t\t\t\t     newivs_index, params_index);\n-  tree ub = clast_to_gcc_expression (type, stmt->UB, region, newivs,\n-\t\t\t\t     newivs_index, params_index);\n+\n+  *type = gcc_type_for_iv_of_clast_loop (stmt, level, lb_type, ub_type);\n+  *lb = clast_to_gcc_expression (*type, stmt->LB, region, newivs,\n+\t\t\t\t newivs_index, params_index);\n+  *ub = clast_to_gcc_expression (*type, stmt->UB, region, newivs,\n+\t\t\t\t newivs_index, params_index);\n+\n   /* When ub is simply a constant or a parameter, use lb <= ub.  */\n-  if (TREE_CODE (ub) == INTEGER_CST || TREE_CODE (ub) == SSA_NAME)\n-    cond_expr = fold_build2 (LE_EXPR, boolean_type_node, lb, ub);\n+  if (TREE_CODE (*ub) == INTEGER_CST || TREE_CODE (*ub) == SSA_NAME)\n+    cond_expr = fold_build2 (LE_EXPR, boolean_type_node, *lb, *ub);\n   else\n     {\n-      tree one = (POINTER_TYPE_P (type)\n+      tree one = (POINTER_TYPE_P (*type)\n \t\t  ? size_one_node\n-\t\t  : fold_convert (type, integer_one_node));\n+\t\t  : fold_convert (*type, integer_one_node));\n       /* Adding +1 and using LT_EXPR helps with loop latches that have a\n \t loop iteration count of \"PARAMETER - 1\".  For PARAMETER == 0 this becomes\n \t 2^k-1 due to integer overflow, and the condition lb <= ub is true,\n \t even if we do not want this.  However lb < ub + 1 is false, as\n \t expected.  */\n-      tree ub_one = fold_build2 (POINTER_TYPE_P (type) ? POINTER_PLUS_EXPR\n-\t\t\t\t : PLUS_EXPR, type, ub, one);\n+      tree ub_one = fold_build2 (POINTER_TYPE_P (*type) ? POINTER_PLUS_EXPR\n+\t\t\t\t : PLUS_EXPR, *type, *ub, one);\n \n-      cond_expr = fold_build2 (LT_EXPR, boolean_type_node, lb, ub_one);\n+      cond_expr = fold_build2 (LT_EXPR, boolean_type_node, *lb, ub_one);\n     }\n \n   exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n@@ -935,17 +930,19 @@ translate_clast (sese, loop_p, struct clast_stmt *, edge,\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n    - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n      the sese region.  */\n+\n static edge\n translate_clast_for_loop (sese region, loop_p context_loop,\n \t\t\t  struct clast_for *stmt, edge next_e,\n \t\t\t  VEC (tree, heap) **newivs,\n \t\t\t  htab_t newivs_index, htab_t bb_pbb_mapping,\n-\t\t\t  int level, htab_t params_index)\n+\t\t\t  int level, htab_t params_index, tree type,\n+\t\t\t  tree lb, tree ub)\n {\n-  struct loop *loop = graphite_create_new_loop (region, next_e, stmt,\n+  struct loop *loop = graphite_create_new_loop (next_e, stmt,\n  \t\t\t\t\t\tcontext_loop, newivs,\n- \t\t\t\t\t\tnewivs_index, params_index,\n-\t\t\t\t\t\tlevel);\n+\t\t\t\t\t\tnewivs_index,\n+\t\t\t\t\t\ttype, lb, ub);\n   edge last_e = single_exit (loop);\n   edge to_body = single_succ_edge (loop->header);\n   basic_block after = to_body->dest;\n@@ -982,13 +979,15 @@ translate_clast_for (sese region, loop_p context_loop, struct clast_for *stmt,\n \t\t     htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n \t\t     htab_t params_index)\n {\n+  tree type, lb, ub;\n   edge last_e = graphite_create_new_loop_guard (region, next_e, stmt, *newivs,\n-\t\t\t\t\t\tnewivs_index, params_index);\n+\t\t\t\t\t\tnewivs_index, params_index,\n+\t\t\t\t\t\tlevel, &type, &lb, &ub);\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n   translate_clast_for_loop (region, context_loop, stmt, true_e, newivs,\n \t\t\t    newivs_index, bb_pbb_mapping, level,\n-\t\t\t    params_index);\n+\t\t\t    params_index, type, lb, ub);\n   return last_e;\n }\n "}]}