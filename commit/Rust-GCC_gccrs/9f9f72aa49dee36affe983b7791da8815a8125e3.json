{"sha": "9f9f72aa49dee36affe983b7791da8815a8125e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY5ZjcyYWE0OWRlZTM2YWZmZTk4M2I3NzkxZGE4ODE1YTgxMjVlMw==", "commit": {"author": {"name": "Antoniu Pop", "email": "antoniu.pop@gmail.com", "date": "2008-04-24T15:23:51Z"}, "committer": {"name": "Antoniu Pop", "email": "apop@gcc.gnu.org", "date": "2008-04-24T15:23:51Z"}, "message": "tree-parloops.c (take_address_of, [...]): Make them work on a region of code delimited by two edges in the CFG.\n\n2008-04-22  Antoniu Pop  <antoniu.pop@gmail.com>\n            Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-parloops.c (take_address_of, eliminate_local_variables_1,\n\teliminate_local_variables_stmt, eliminate_local_variables,\n\tseparate_decls_in_loop_name, separate_decls_in_loop_stmt,\n\tseparate_decls_in_loop, gen_parallel_loop): Make them work on a region\n\tof code delimited by two edges in the CFG.\n\t(separate_decls_in_loop_name): Renamed separate_decls_in_region_name.\n\t(separate_decls_in_loop_stmt): Renamed separate_decls_in_region_stmt.\n\t(separate_decls_in_loop): Renamed separate_decls_in_region.  Isolate \n\tthe case of parallelisation of reductions.\n\t(expr_invariant_in_region_p): New.\n\n\t* tree-flow.h (gather_blocks_in_sese_region): Declared.\n\t* tree-cfg.c (gather_blocks_in_sese_region): Extern.\n\n\nCo-Authored-By: Sebastian Pop <sebastian.pop@amd.com>\n\nFrom-SVN: r134632", "tree": {"sha": "8a8952352263f9599f127aad8876b779ad320e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a8952352263f9599f127aad8876b779ad320e7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f9f72aa49dee36affe983b7791da8815a8125e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9f72aa49dee36affe983b7791da8815a8125e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f9f72aa49dee36affe983b7791da8815a8125e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f9f72aa49dee36affe983b7791da8815a8125e3/comments", "author": {"login": "antoniu-pop", "id": 2536163, "node_id": "MDQ6VXNlcjI1MzYxNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/2536163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoniu-pop", "html_url": "https://github.com/antoniu-pop", "followers_url": "https://api.github.com/users/antoniu-pop/followers", "following_url": "https://api.github.com/users/antoniu-pop/following{/other_user}", "gists_url": "https://api.github.com/users/antoniu-pop/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoniu-pop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoniu-pop/subscriptions", "organizations_url": "https://api.github.com/users/antoniu-pop/orgs", "repos_url": "https://api.github.com/users/antoniu-pop/repos", "events_url": "https://api.github.com/users/antoniu-pop/events{/privacy}", "received_events_url": "https://api.github.com/users/antoniu-pop/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "601e33320a9c26e3b051aa4595d783f568800787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601e33320a9c26e3b051aa4595d783f568800787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601e33320a9c26e3b051aa4595d783f568800787"}], "stats": {"total": 202, "additions": 138, "deletions": 64}, "files": [{"sha": "31bac1edbcdaac1668775af9cd43c88db0c1c9eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f9f72aa49dee36affe983b7791da8815a8125e3", "patch": "@@ -1,3 +1,20 @@\n+2008-04-22  Antoniu Pop  <antoniu.pop@gmail.com>\n+            Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-parloops.c (take_address_of, eliminate_local_variables_1,\n+\teliminate_local_variables_stmt, eliminate_local_variables,\n+\tseparate_decls_in_loop_name, separate_decls_in_loop_stmt,\n+\tseparate_decls_in_loop, gen_parallel_loop): Make them work on a region\n+\tof code delimited by two edges in the CFG.\n+\t(separate_decls_in_loop_name): Renamed separate_decls_in_region_name.\n+\t(separate_decls_in_loop_stmt): Renamed separate_decls_in_region_stmt.\n+\t(separate_decls_in_loop): Renamed separate_decls_in_region.  Isolate \n+\tthe case of parallelisation of reductions.\n+\t(expr_invariant_in_region_p): New.\n+\n+\t* tree-flow.h (gather_blocks_in_sese_region): Declared.\n+\t* tree-cfg.c (gather_blocks_in_sese_region): Extern.\n+\n 2008-04-24  Ira Rosen  <irar@il.ibm.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "d45b277b512a58c894d461cddbdf163140ef0374", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9f9f72aa49dee36affe983b7791da8815a8125e3", "patch": "@@ -5505,7 +5505,7 @@ DEF_VEC_ALLOC_P(basic_block,heap);\n    adding blocks when the dominator traversal reaches EXIT.  This\n    function silently assumes that ENTRY strictly dominates EXIT.  */\n \n-static void\n+void\n gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n \t\t\t      VEC(basic_block,heap) **bbs_p)\n {"}, {"sha": "74cb073277be4172f5a21c94d391d06c2e7ad1b3", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9f9f72aa49dee36affe983b7791da8815a8125e3", "patch": "@@ -771,6 +771,8 @@ extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *);\n extern bool tree_duplicate_sese_tail (edge, edge, basic_block *, unsigned,\n \t\t\t\t      basic_block *);\n+extern void gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n+\t\t\t\t\t  VEC(basic_block,heap) **bbs_p);\n extern void add_phi_args_after_copy_bb (basic_block);\n extern void add_phi_args_after_copy (basic_block *, unsigned, edge);\n extern bool tree_purge_dead_abnormal_call_edges (basic_block);"}, {"sha": "b377e846d0a0900a1484092e16dbb42566727208", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 118, "deletions": 63, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f9f72aa49dee36affe983b7791da8815a8125e3/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=9f9f72aa49dee36affe983b7791da8815a8125e3", "patch": "@@ -455,18 +455,17 @@ loop_has_blocks_with_irreducible_flag (struct loop *loop)\n }\n \n /* Assigns the address of OBJ in TYPE to an ssa name, and returns this name.\n-   The assignment statement is placed before LOOP.  DECL_ADDRESS maps decls\n+   The assignment statement is placed on edge ENTRY.  DECL_ADDRESS maps decls\n    to their addresses that can be reused.  The address of OBJ is known to\n    be invariant in the whole function.  */\n \n static tree\n-take_address_of (tree obj, tree type, struct loop *loop, htab_t decl_address)\n+take_address_of (tree obj, tree type, edge entry, htab_t decl_address)\n {\n   int uid;\n   void **dslot;\n   struct int_tree_map ielt, *nielt;\n   tree *var_p, name, bvar, stmt, addr;\n-  edge entry = loop_preheader_edge (loop);\n \n   /* Since the address of OBJ is invariant, the trees may be shared.\n      Avoid rewriting unrelated parts of the code.  */\n@@ -570,15 +569,16 @@ initialize_reductions (void **slot, void *data)\n \n struct elv_data\n {\n-  struct loop *loop;\n+  edge entry;\n   htab_t decl_address;\n   bool changed;\n };\n \n-/* Eliminates references to local variables in *TP out of LOOP.  DECL_ADDRESS\n-   contains addresses of the references that had their address taken already.\n-   If the expression is changed, CHANGED is set to true.  Callback for\n-   walk_tree.  */\n+/* Eliminates references to local variables in *TP out of the single\n+   entry single exit region starting at DTA->ENTRY.\n+   DECL_ADDRESS contains addresses of the references that had their\n+   address taken already.  If the expression is changed, CHANGED is\n+   set to true.  Callback for walk_tree.  */\n \n static tree\n eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n@@ -595,7 +595,7 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \n       type = TREE_TYPE (t);\n       addr_type = build_pointer_type (type);\n-      addr = take_address_of (t, addr_type, dta->loop, dta->decl_address);\n+      addr = take_address_of (t, addr_type, dta->entry, dta->decl_address);\n       *tp = build1 (INDIRECT_REF, TREE_TYPE (*tp), addr);\n \n       dta->changed = true;\n@@ -625,7 +625,7 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \treturn NULL_TREE;\n \n       addr_type = TREE_TYPE (t);\n-      addr = take_address_of (obj, addr_type, dta->loop, dta->decl_address);\n+      addr = take_address_of (obj, addr_type, dta->entry, dta->decl_address);\n       *tp = addr;\n \n       dta->changed = true;\n@@ -638,17 +638,18 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Moves the references to local variables in STMT from LOOP.  DECL_ADDRESS\n-   contains addresses for the references for that we have already taken\n-   them.  */\n+/* Moves the references to local variables in STMT out of the single\n+   entry single exit region starting at ENTRY.  DECL_ADDRESS contains\n+   addresses of the references that had their address taken\n+   already.  */\n \n static void\n-eliminate_local_variables_stmt (struct loop *loop, tree stmt,\n+eliminate_local_variables_stmt (edge entry, tree stmt,\n \t\t\t\thtab_t decl_address)\n {\n   struct elv_data dta;\n \n-  dta.loop = loop;\n+  dta.entry = entry;\n   dta.decl_address = decl_address;\n   dta.changed = false;\n \n@@ -658,33 +659,75 @@ eliminate_local_variables_stmt (struct loop *loop, tree stmt,\n     update_stmt (stmt);\n }\n \n-/* Eliminates the references to local variables from LOOP.  \n+/* Eliminates the references to local variables from the single entry\n+   single exit region between the ENTRY and EXIT edges.\n+  \n    This includes:\n    1) Taking address of a local variable -- these are moved out of the \n-   loop (and temporary variable is created to hold the address if \n+   region (and temporary variable is created to hold the address if \n    necessary).\n+\n    2) Dereferencing a local variable -- these are replaced with indirect\n    references.  */\n \n static void\n-eliminate_local_variables (struct loop *loop)\n+eliminate_local_variables (edge entry, edge exit)\n {\n-  basic_block bb, *body = get_loop_body (loop);\n+  basic_block bb;\n+  VEC (basic_block, heap) *body = VEC_alloc (basic_block, heap, 3);\n   unsigned i;\n   block_stmt_iterator bsi;\n   htab_t decl_address = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n \t\t\t\t     free);\n+  basic_block entry_bb = entry->src;\n+  basic_block exit_bb = exit->dest;\n \n-  /* Find and rename the ssa names defined outside of loop.  */\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      bb = body[i];\n+  gather_blocks_in_sese_region (entry_bb, exit_bb, &body);\n \n+  for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+    if (bb != entry_bb && bb != exit_bb)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\teliminate_local_variables_stmt (loop, bsi_stmt (bsi), decl_address);\n-    }\n+\teliminate_local_variables_stmt (entry, bsi_stmt (bsi),\n+\t\t\t\t\tdecl_address);\n \n   htab_delete (decl_address);\n+  VEC_free (basic_block, heap, body);\n+}\n+\n+/* Returns true if expression EXPR is not defined between ENTRY and\n+   EXIT, i.e. if all its operands are defined outside of the region.  */\n+\n+static bool\n+expr_invariant_in_region_p (edge entry, edge exit, tree expr)\n+{\n+  basic_block entry_bb = entry->src;\n+  basic_block exit_bb = exit->dest;\n+  basic_block def_bb;\n+  unsigned i, len;\n+\n+  if (is_gimple_min_invariant (expr))\n+    return true;\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (expr));\n+      if (def_bb\n+\t  && dominated_by_p (CDI_DOMINATORS, def_bb, entry_bb)\n+\t  && !dominated_by_p (CDI_DOMINATORS, def_bb, exit_bb))\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  if (!EXPR_P (expr) && !GIMPLE_STMT_P (expr))\n+    return false;\n+\n+  len = TREE_OPERAND_LENGTH (expr);\n+  for (i = 0; i < len; i++)\n+    if (!expr_invariant_in_region_p (entry, exit, TREE_OPERAND (expr, i)))\n+      return false;\n+\n+  return true;\n }\n \n /* If COPY_NAME_P is true, creates and returns a duplicate of NAME.\n@@ -695,9 +738,9 @@ eliminate_local_variables (struct loop *loop)\n    duplicated, storing the copies in DECL_COPIES.  */\n \n static tree\n-separate_decls_in_loop_name (tree name,\n-\t\t\t     htab_t name_copies, htab_t decl_copies,\n-\t\t\t     bool copy_name_p)\n+separate_decls_in_region_name (tree name,\n+\t\t\t       htab_t name_copies, htab_t decl_copies,\n+\t\t\t       bool copy_name_p)\n {\n   tree copy, var, var_copy;\n   unsigned idx, uid, nuid;\n@@ -762,15 +805,16 @@ separate_decls_in_loop_name (tree name,\n   return copy;\n }\n \n-/* Finds the ssa names used in STMT that are defined outside of LOOP and\n-   replaces such ssa names with their duplicates.  The duplicates are stored to\n-   NAME_COPIES.  Base decls of all ssa names used in STMT\n-   (including those defined in LOOP) are replaced with the new temporary\n-   variables; the replacement decls are stored in DECL_COPIES.  */\n+/* Finds the ssa names used in STMT that are defined outside the\n+   region between ENTRY and EXIT and replaces such ssa names with\n+   their duplicates.  The duplicates are stored to NAME_COPIES.  Base\n+   decls of all ssa names used in STMT (including those defined in\n+   LOOP) are replaced with the new temporary variables; the\n+   replacement decls are stored in DECL_COPIES.  */\n \n static void\n-separate_decls_in_loop_stmt (struct loop *loop, tree stmt,\n-\t\t\t     htab_t name_copies, htab_t decl_copies)\n+separate_decls_in_region_stmt (edge entry, edge exit, tree stmt,\n+\t\t\t       htab_t name_copies, htab_t decl_copies)\n {\n   use_operand_p use;\n   def_operand_p def;\n@@ -784,8 +828,8 @@ separate_decls_in_loop_stmt (struct loop *loop, tree stmt,\n   {\n     name = DEF_FROM_PTR (def);\n     gcc_assert (TREE_CODE (name) == SSA_NAME);\n-    copy = separate_decls_in_loop_name (name, name_copies, decl_copies,\n-\t\t\t\t\tfalse);\n+    copy = separate_decls_in_region_name (name, name_copies, decl_copies,\n+\t\t\t\t\t  false);\n     gcc_assert (copy == name);\n   }\n \n@@ -795,9 +839,9 @@ separate_decls_in_loop_stmt (struct loop *loop, tree stmt,\n     if (TREE_CODE (name) != SSA_NAME)\n       continue;\n \n-    copy_name_p = expr_invariant_in_loop_p (loop, name);\n-    copy = separate_decls_in_loop_name (name, name_copies, decl_copies,\n-\t\t\t\t\tcopy_name_p);\n+    copy_name_p = expr_invariant_in_region_p (entry, exit, name);\n+    copy = separate_decls_in_region_name (name, name_copies, decl_copies,\n+\t\t\t\t\t  copy_name_p);\n     SET_USE (use, copy);\n   }\n }\n@@ -1118,36 +1162,44 @@ create_loads_and_stores_for_name (void **slot, void *data)\n    in LOOP.  */\n \n static void\n-separate_decls_in_loop (struct loop *loop, htab_t reduction_list, \n-\t\t\ttree * arg_struct, tree * new_arg_struct, \n-\t\t\tstruct clsn_data *ld_st_data)\n+separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n+\t\t\t  tree *arg_struct, tree *new_arg_struct, \n+\t\t\t  struct clsn_data *ld_st_data)\n \n {\n-  basic_block bb1 = split_edge (loop_preheader_edge (loop));\n+  basic_block bb1 = split_edge (entry);\n   basic_block bb0 = single_pred (bb1);\n   htab_t name_copies = htab_create (10, name_to_copy_elt_hash,\n \t\t\t\t    name_to_copy_elt_eq, free);\n   htab_t decl_copies = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n \t\t\t\t    free);\n-  basic_block bb, *body = get_loop_body (loop);\n   unsigned i;\n   tree phi, type, type_name, nvar;\n   block_stmt_iterator bsi;\n   struct clsn_data clsn_data;\n+  VEC (basic_block, heap) *body = VEC_alloc (basic_block, heap, 3);\n+  basic_block bb;\n+  basic_block entry_bb = bb1;\n+  basic_block exit_bb = exit->dest;\n \n-  /* Find and rename the ssa names defined outside of loop.  */\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      bb = body[i];\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\tseparate_decls_in_loop_stmt (loop, phi, name_copies, decl_copies);\n+  entry = single_succ_edge(entry_bb);\n+  gather_blocks_in_sese_region (entry_bb, exit_bb, &body);\n \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tseparate_decls_in_loop_stmt (loop, bsi_stmt (bsi), name_copies,\n-\t\t\t\t     decl_copies);\n+  for (i = 0; VEC_iterate (basic_block, body, i, bb); i++)\n+    {\n+      if (bb != entry_bb && bb != exit_bb) \n+\t{\n+\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t    separate_decls_in_region_stmt (entry, exit, phi, name_copies,\n+\t\t\t\t\t   decl_copies);\n+\t  \n+\t  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t    separate_decls_in_region_stmt (entry, exit, bsi_stmt (bsi),\n+\t\t\t\t\t   name_copies, decl_copies);\n+\t}\n     }\n-  free (body);\n+\n+  VEC_free (basic_block, heap, body);\n \n   if (htab_elements (name_copies) == 0)\n     {\n@@ -1165,7 +1217,7 @@ separate_decls_in_loop (struct loop *loop, htab_t reduction_list,\n       TYPE_NAME (type) = type_name;\n \n       htab_traverse (name_copies, add_field_for_name, type);\n-      if (htab_elements (reduction_list) > 0)\n+      if (reduction_list && htab_elements (reduction_list) > 0)\n \t{\n \t  /* Create the fields for reductions.  */\n \t  htab_traverse (reduction_list, add_field_for_reduction,\n@@ -1190,12 +1242,12 @@ separate_decls_in_loop (struct loop *loop, htab_t reduction_list,\n \n       /* Load the calculation from memory (after the join of the threads).  */\n \n-      if (htab_elements (reduction_list) > 0)\n+      if (reduction_list && htab_elements (reduction_list) > 0)\n \t{\n \t  htab_traverse (reduction_list, create_stores_for_reduction,\n                         ld_st_data); \n \t  clsn_data.load = make_ssa_name (nvar, NULL_TREE);\n-\t  clsn_data.load_bb = single_dom_exit (loop)->dest;\n+\t  clsn_data.load_bb = exit->dest;\n \t  clsn_data.store = ld_st_data->store;\n \t  create_final_loads_for_reduction (reduction_list, &clsn_data);\n \t}\n@@ -1605,6 +1657,7 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n   tree many_iterations_cond, type, nit;\n   tree stmts, arg_struct, new_arg_struct;\n   basic_block parallel_head;\n+  edge entry, exit;\n   struct clsn_data clsn_data;\n   unsigned prob;\n \n@@ -1702,18 +1755,20 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n   /* Ensure that the exit condition is the first statement in the loop.  */\n   transform_to_exit_first_loop (loop, reduction_list, nit);\n \n-\n   /* Generate intializations for reductions.  */\n-\n   if (htab_elements (reduction_list) > 0)  \n     htab_traverse (reduction_list, initialize_reductions, loop);\n \n   /* Eliminate the references to local variables from the loop.  */\n-  eliminate_local_variables (loop);\n+  gcc_assert (single_exit (loop));\n+  entry = loop_preheader_edge (loop);\n+  exit = single_dom_exit (loop);\n \n+  eliminate_local_variables (entry, exit);\n   /* In the old loop, move all variables non-local to the loop to a structure\n      and back, and create separate decls for the variables used in loop.  */\n-  separate_decls_in_loop (loop, reduction_list, &arg_struct, &new_arg_struct, &clsn_data);\n+  separate_decls_in_region (entry, exit, reduction_list, &arg_struct, \n+\t\t\t    &new_arg_struct, &clsn_data);\n \n   /* Create the parallel constructs.  */\n   parallel_head = create_parallel_loop (loop, create_loop_fn (), arg_struct,"}]}