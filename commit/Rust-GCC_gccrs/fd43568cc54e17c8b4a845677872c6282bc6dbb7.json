{"sha": "fd43568cc54e17c8b4a845677872c6282bc6dbb7", "node_id": "C_kwDOANBUbNoAKGZkNDM1NjhjYzU0ZTE3YzhiNGE4NDU2Nzc4NzJjNjI4MmJjNmRiYjc", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-15T18:47:02Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2021-12-15T18:51:30Z"}, "message": "d: Merge upstream dmd 93108bb9e, druntime 6364e010, phobos 575b67a9b.\n\nD front-end changes:\n\n    - Import dmd v2.098.1-beta.1.\n    - Default extern(C++) compatibility to C++17.\n\nDruntime changes:\n\n    - Import druntime v2.098.1-beta.1.\n    - Fix definition of stat_t on MIPS64 (PR103604)\n\nPhobos changes:\n\n    - Import phobos v2.098.1-beta.1.\n\ngcc/d/ChangeLog:\n\n\t* d-lang.cc (d_init_options): Set default -fextern-std= to C++17.\n\t* dmd/MERGE: Merge upstream dmd 93108bb9e.\n\t* gdc.texi (Runtime Options): Document the default for -fextern-std=.\n\nlibphobos/ChangeLog:\n\n\tPR d/103604\n\t* configure: Regenerate.\n\t* configure.ac (libtool_VERSION): Update to 3:0:0.\n\t* libdruntime/MERGE: Merge upstream druntime 6364e010.\n\t* src/MERGE: Merge upstream phobos 575b67a9b.\n\t* testsuite/libphobos.traits/all_satisfy.d: New test.\n\t* testsuite/libphobos.traits/traits.exp: New test.", "tree": {"sha": "24f591392a2978706aef4d58e377b8b42b5ba418", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24f591392a2978706aef4d58e377b8b42b5ba418"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd43568cc54e17c8b4a845677872c6282bc6dbb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd43568cc54e17c8b4a845677872c6282bc6dbb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd43568cc54e17c8b4a845677872c6282bc6dbb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd43568cc54e17c8b4a845677872c6282bc6dbb7/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "639ece7abfa3688008cb791aec4c7a1a4f76e59f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/639ece7abfa3688008cb791aec4c7a1a4f76e59f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/639ece7abfa3688008cb791aec4c7a1a4f76e59f"}], "stats": {"total": 2337, "additions": 1662, "deletions": 675}, "files": [{"sha": "d7621953b547a32bfc2945fdad989eeac49635d4", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -297,8 +297,8 @@ d_init_options (unsigned int, cl_decoded_option *decoded_options)\n   global.params.argv0 = xstrdup (decoded_options[0].arg);\n   global.params.errorLimit = flag_max_errors;\n \n-  /* Default extern(C++) mangling to C++14.  */\n-  global.params.cplusplus = CppStdRevisionCpp14;\n+  /* Default extern(C++) mangling to C++17.  */\n+  global.params.cplusplus = CppStdRevisionCpp17;\n \n   /* Warnings and deprecations are disabled by default.  */\n   global.params.useDeprecated = DIAGNOSTICinform;"}, {"sha": "d7eff4ffd2fa5448ab844b52f159ca631294bad5", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,4 +1,4 @@\n-3982604c54e8770585985a33577fbf19b9b5c9ce\n+93108bb9ea6216d67fa97bb4842fb59f26f6bfc7\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "822edd4637a5b2dbecc937354c478d585c82c812", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1 +1 @@\n-v2.098.0\n+v2.098.1-beta.1"}, {"sha": "3cc358e19bf42874626f1335431f17186312cffe", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1054,6 +1054,12 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n         emplaceExp!(UnionExp)(&ue, ex);\n         return ue;\n     }\n+    if (e1.type.toBasetype.equals(type) && type.equals(to))\n+    {\n+        emplaceExp!(UnionExp)(&ue, e1);\n+        ue.exp().type = type;\n+        return ue;\n+    }\n     if (e1.type.implicitConvTo(to) >= MATCH.constant || to.implicitConvTo(e1.type) >= MATCH.constant)\n     {\n         goto L1;\n@@ -1087,7 +1093,19 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n     }\n     else if (tb.ty == Tbool)\n     {\n-        emplaceExp!(IntegerExp)(&ue, loc, e1.toInteger() != 0, type);\n+        bool val = void;\n+        const opt = e1.toBool();\n+        if (opt.hasValue(true))\n+            val = true;\n+        else if (opt.hasValue(false))\n+            val = false;\n+        else\n+        {\n+            cantExp(ue);\n+            return ue;\n+        }\n+\n+        emplaceExp!(IntegerExp)(&ue, loc, val, type);\n     }\n     else if (type.isintegral())\n     {"}, {"sha": "b1532adb6a0f7f435d8d1fb3354f3af79b118bab", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -975,12 +975,17 @@ final class CParser(AST) : Parser!AST\n                          token.value == TOK.leftParenthesis &&\n                          !isCastExpression(pt))\n                 {\n-                    /* this might actually be a function\n-                     * call that looks like `(a)(b)` or even `(a)(b,c)`\n+                    /* (t)(...)... might be a cast expression or a function call,\n+                     * with different grammars: a cast would be cparseCastExp(),\n+                     * a function call would be cparsePostfixExp(CallExp(cparseArguments())).\n+                     * We can't know until t is known. So, parse it as a function call\n+                     * and let semantic() rewrite the AST as a CastExp if it turns out\n+                     * to be a type.\n                      */\n                     auto ie = new AST.IdentifierExp(loc, t.isTypeIdentifier().ident);\n-                    ie.parens = true;    // disambiguate it from being a declaration\n-                    return new AST.CallExp(loc, ie, cparseArguments());\n+                    ie.parens = true;    // let semantic know it might be a CastExp\n+                    AST.Expression e = new AST.CallExp(loc, ie, cparseArguments());\n+                    return cparsePostfixOperators(e);\n                 }\n                 else\n                 {\n@@ -1483,9 +1488,12 @@ final class CParser(AST) : Parser!AST\n \n         /* If a declarator does not follow, it is unnamed\n          */\n-        if (token.value == TOK.semicolon && tspec)\n+        if (token.value == TOK.semicolon)\n         {\n             nextToken();\n+            if (!tspec)\n+                return;         // accept empty declaration as an extension\n+\n             auto tt = tspec.isTypeTag();\n             if (!tt ||\n                 !tt.id && (tt.tok == TOK.struct_ || tt.tok == TOK.union_))\n@@ -1662,7 +1670,8 @@ final class CParser(AST) : Parser!AST\n                 {\n                     // Give non-extern variables an implicit void initializer\n                     // if one has not been explicitly set.\n-                    if (!hasInitializer && !(specifier.scw & SCW.xextern))\n+                    if (!hasInitializer &&\n+                        !(specifier.scw & (SCW.xextern | SCW.xstatic | SCW.x_Thread_local) || level == LVL.global))\n                         initializer = new AST.VoidInitializer(token.loc);\n                     s = new AST.VarDeclaration(token.loc, dt, id, initializer, specifiersToSTC(level, specifier));\n                 }\n@@ -2492,7 +2501,18 @@ final class CParser(AST) : Parser!AST\n                 return t;\n             }\n \n-            t = constApply(t);\n+            if (declarator == DTR.xparameter &&\n+                t.isTypePointer())\n+            {\n+                /* Because there are instances in .h files of \"const pointer to mutable\",\n+                 * skip applying transitive `const`\n+                 * https://issues.dlang.org/show_bug.cgi?id=22534\n+                 */\n+                auto tn = cast(AST.TypeNext)t;\n+                tn.next = constApply(tn.next);\n+            }\n+            else\n+                t = constApply(t);\n         }\n \n         //printf(\"result: %s\\n\", t.toChars());\n@@ -2610,6 +2630,8 @@ final class CParser(AST) : Parser!AST\n \n             Identifier id;\n             auto t = cparseDeclarator(DTR.xparameter, tspec, id, specifier);\n+            if (token.value == TOK.__attribute__)\n+                cparseGnuAttributes(specifier);\n             if (specifier.mod & MOD.xconst)\n                 t = toConst(t);\n             auto param = new AST.Parameter(STC.parameter, t, id, null, null);"}, {"sha": "baacaa6e9beae0f849c73148aefa843e921ac3d2", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1574,7 +1574,7 @@ Expression ctfeIndex(UnionExp* pue, const ref Loc loc, Type type, Expression e1,\n     assert(0);\n }\n \n-Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expression e)\n+Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expression e, bool explicitCast = false)\n {\n     Expression paint()\n     {\n@@ -1587,9 +1587,12 @@ Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expres\n     if (e.op == EXP.classReference)\n     {\n         // Disallow reinterpreting class casts. Do this by ensuring that\n-        // the original class can implicitly convert to the target class\n-        ClassDeclaration originalClass = (cast(ClassReferenceExp)e).originalClass();\n-        if (originalClass.type.implicitConvTo(to.mutableOf()))\n+        // the original class can implicitly convert to the target class.\n+        // Also do not check 'alias this' for explicit cast expressions.\n+        auto tclass = (cast(ClassReferenceExp)e).originalClass().type.isTypeClass();\n+        auto match = explicitCast ? tclass.implicitConvToWithoutAliasThis(to.mutableOf())\n+                                  : tclass.implicitConvTo(to.mutableOf());\n+        if (match)\n             return paint();\n         else\n         {"}, {"sha": "8f20c38f6f16005d4288f0a90f6e04744facd7e4", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -6068,7 +6068,7 @@ public:\n             result = pue.exp();\n             return;\n         }\n-        result = ctfeCast(pue, e.loc, e.type, e.to, e1);\n+        result = ctfeCast(pue, e.loc, e.type, e.to, e1, true);\n     }\n \n     override void visit(AssertExp e)"}, {"sha": "0f75157f87438c975fed113b00ce3d068fbc05e1", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -462,6 +462,21 @@ extern (C++) class Dsymbol : ASTNode\n         return null;\n     }\n \n+    /**************************************\n+     * Does this Dsymbol come from a C file?\n+     * Returns:\n+     *  true if it does\n+     */\n+     final bool isCsymbol()\n+     {\n+        if (Module m = getModule())\n+        {\n+            if (m.isCFile)\n+                return true;\n+        }\n+        return false;\n+    }\n+\n     /**********************************\n      * Determine which Module a Dsymbol is in, as far as access rights go.\n      */\n@@ -1783,7 +1798,7 @@ extern (C++) final class WithScopeSymbol : ScopeDsymbol\n         // Acts as proxy to the with class declaration\n         Dsymbol s = null;\n         Expression eold = null;\n-        for (Expression e = withstate.exp; e != eold; e = resolveAliasThis(_scope, e))\n+        for (Expression e = withstate.exp; e && e != eold; e = resolveAliasThis(_scope, e, true))\n         {\n             if (e.op == EXP.scope_)\n             {\n@@ -2426,7 +2441,9 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n     auto vd2 = s2.isVarDeclaration(); // existing declaration\n     if (vd && vd2)\n     {\n-        // if one is `static` and the other isn't\n+        /* if one is `static` and the other isn't, the result is undefined\n+         * behavior, C11 6.2.2.7\n+         */\n         if ((vd.storage_class ^ vd2.storage_class) & STC.static_)\n             return collision();\n \n@@ -2437,7 +2454,10 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n             return collision();         // can't both have initializers\n \n         if (i1)\n-            return vd;\n+        {\n+            vd2._init = vd._init;\n+            vd._init = null;\n+        }\n \n         /* BUG: the types should match, which needs semantic() to be run on it\n          *    extern int x;\n@@ -2454,15 +2474,38 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n     auto fd2 = s2.isFuncDeclaration(); // existing declaration\n     if (fd && fd2)\n     {\n-        // if one is `static` and the other isn't\n-        if ((fd.storage_class ^ fd2.storage_class) & STC.static_)\n+        /* if one is `static` and the other isn't, the result is undefined\n+         * behavior, C11 6.2.2.7\n+         * However, match what gcc allows:\n+         *    static int sun1(); int sun1() { return 0; }\n+         * and:\n+         *    static int sun2() { return 0; } int sun2();\n+         * Both produce a static function.\n+         *\n+         * Both of these should fail:\n+         *    int sun3(); static int sun3() { return 0; }\n+         * and:\n+         *    int sun4() { return 0; } static int sun4();\n+         */\n+        // if adding `static`\n+        if (   fd.storage_class & STC.static_ &&\n+            !(fd2.storage_class & STC.static_))\n+        {\n             return collision();\n+        }\n \n         if (fd.fbody && fd2.fbody)\n             return collision();         // can't both have bodies\n \n         if (fd.fbody)\n-            return fd;\n+        {\n+            fd2.fbody = fd.fbody;       // transfer body to existing declaration\n+            fd.fbody = null;\n+\n+            auto tf = fd.type.toTypeFunction();\n+            auto tf2 = fd2.type.toTypeFunction();\n+            tf2.parameterList = tf.parameterList;   // transfer parameter list.\n+        }\n \n         /* BUG: just like with VarDeclaration, the types should match, which needs semantic() to be run on it.\n          * FuncDeclaration::semantic2() can detect this, but it relies overnext being set."}, {"sha": "668b079060ac347fab88517d347f57837aab1f72", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -199,6 +199,7 @@ class Dsymbol : public ASTNode\n     void deprecation(const char *format, ...);\n     bool checkDeprecated(const Loc &loc, Scope *sc);\n     Module *getModule();\n+    bool isCsymbol();\n     Module *getAccessModule();\n     Dsymbol *pastMixin();\n     Dsymbol *toParent();"}, {"sha": "3a9abd2d87e3b583b2c4e071c1670ffe56e1e1a3", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -46,6 +46,7 @@ import dmd.func;\n import dmd.globals;\n import dmd.id;\n import dmd.identifier;\n+import dmd.importc;\n import dmd.init;\n import dmd.initsem;\n import dmd.hdrgen;\n@@ -891,6 +892,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         bool isBlit = false;\n         d_uns64 sz;\n+        if (sc.flags & SCOPE.Cfile && !dsym._init)\n+        {\n+            addDefaultCInitializer(dsym);\n+        }\n         if (!dsym._init &&\n             !(dsym.storage_class & (STC.static_ | STC.gshared | STC.extern_)) &&\n             fd &&\n@@ -900,7 +905,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             // Provide a default initializer\n \n-            //printf(\"Providing default initializer for '%s'\\n\", toChars());\n+            //printf(\"Providing default initializer for '%s'\\n\", dsym.toChars());\n             if (sz == SIZE_INVALID && dsym.type.ty != Terror)\n                 dsym.error(\"size of type `%s` is invalid\", dsym.type.toChars());\n "}, {"sha": "b1760dd23cf1105539e256dae92827cccedf9dfa", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -5529,6 +5529,20 @@ extern (C++) final class TemplateValueParameter : TemplateParameter\n \n     override bool declareParameter(Scope* sc)\n     {\n+        /*\n+            Do type semantic earlier.\n+\n+            This means for certain erroneous value parameters\n+            their \"type\" can be known earlier and thus a better\n+            error message given.\n+\n+            For example:\n+            `template test(x* x) {}`\n+            now yields \"undefined identifier\" rather than the opaque\n+            \"variable `x` is used as a type\".\n+         */\n+        if (valType)\n+            valType = valType.typeSemantic(loc, sc);\n         auto v = new VarDeclaration(loc, valType, ident, null);\n         v.storage_class = STC.templateparameter;\n         return sc.insert(v) !is null;"}, {"sha": "749a50a38f33ea77fc92c0c01f43ad940a3c1d8e", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -3985,7 +3985,7 @@ extern (C++) final class FuncExp : Expression\n         }\n         else\n         {\n-            assert(tok == TOK.function_ || tok == TOK.reserved && type.ty == Tpointer);\n+            assert(tok == TOK.function_ || tok == TOK.reserved && type.ty == Tpointer || fd.errors);\n             tx = tfx.pointerTo();\n         }\n         //printf(\"\\ttx = %s, to = %s\\n\", tx.toChars(), to.toChars());"}, {"sha": "48e47cef250883dc5ccd1cca8040e7f71c4ac059", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -316,6 +316,9 @@ Expression resolveOpDollar(Scope* sc, ArrayExp ae, IntervalExp ie, Expression* p\n     ie.lwr = sem(ie.lwr);\n     ie.upr = sem(ie.upr);\n \n+    if (ie.lwr.isErrorExp() || ie.upr.isErrorExp())\n+        errors = true;\n+\n     if (lengthVar != ae.lengthVar && sc.func)\n     {\n         // If $ was used, declare it now\n@@ -536,16 +539,16 @@ private Expression resolveUFCS(Scope* sc, CallExp ce)\n                 ce.e1 = ey;\n                 if (isDotOpDispatch(ey))\n                 {\n-                    uint errors = global.startGagging();\n-                    e = ce.syntaxCopy().expressionSemantic(sc);\n-                    if (!global.endGagging(errors))\n-                        return e;\n-\n                     // even opDispatch and UFCS must have valid arguments,\n                     // so now that we've seen indication of a problem,\n                     // check them for issues.\n                     Expressions* originalArguments = Expression.arraySyntaxCopy(ce.arguments);\n \n+                    uint errors = global.startGagging();\n+                    e = ce.expressionSemantic(sc);\n+                    if (!global.endGagging(errors))\n+                        return e;\n+\n                     if (arrayExpressionSemantic(originalArguments, sc))\n                         return ErrorExp.get();\n \n@@ -2792,6 +2795,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             exp.error(\"undefined identifier `%s`, did you mean %s `%s`?\", exp.ident.toChars(), s2.kind(), s2.toChars());\n         else if (const p = Scope.search_correct_C(exp.ident))\n             exp.error(\"undefined identifier `%s`, did you mean `%s`?\", exp.ident.toChars(), p);\n+        else if (exp.ident == Id.dollar)\n+            exp.error(\"undefined identifier `$`\");\n         else\n             exp.error(\"undefined identifier `%s`\", exp.ident.toChars());\n \n@@ -4244,6 +4249,16 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 return;\n             }\n         }\n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            /* See if need to rewrite the AST because of cast/call ambiguity\n+             */\n+            if (auto e = castCallAmbiguity(exp, sc))\n+            {\n+                result = expressionSemantic(e, sc);\n+                return;\n+            }\n+        }\n \n         if (Expression ex = resolveUFCS(sc, exp))\n         {\n@@ -4425,24 +4440,6 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             else if (exp.e1.op == EXP.type && (sc && sc.flags & SCOPE.Cfile))\n             {\n                 const numArgs = exp.arguments ? exp.arguments.length : 0;\n-                if (e1org.parens && numArgs >= 1)\n-                {\n-                    /* Ambiguous cases arise from CParser where there is not enough\n-                     * information to determine if we have a function call or a cast.\n-                     *   ( type-name ) ( identifier ) ;\n-                     *   ( identifier ) ( identifier ) ;\n-                     * If exp.e1 is a type-name, then this is a cast.\n-                     */\n-                    Expression arg;\n-                    foreach (a; (*exp.arguments)[])\n-                    {\n-                        arg = arg ? new CommaExp(a.loc, arg, a) : a;\n-                    }\n-                    auto t = exp.e1.isTypeExp().type;\n-                    auto e = new CastExp(exp.loc, arg, t);\n-                    result = e.expressionSemantic(sc);\n-                    return;\n-                }\n \n                 /* Ambiguous cases arise from CParser where there is not enough\n                  * information to determine if we have a function call or declaration.\n@@ -6406,6 +6403,18 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             printf(\"DotIdExp::semantic(this = %p, '%s')\\n\", exp, exp.toChars());\n             //printf(\"e1.op = %d, '%s'\\n\", e1.op, Token::toChars(e1.op));\n         }\n+\n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            /* See if need to rewrite the AST because of cast/call ambiguity\n+             */\n+            if (auto e = castCallAmbiguity(exp, sc))\n+            {\n+                result = expressionSemantic(e, sc);\n+                return;\n+            }\n+        }\n+\n         if (exp.arrow) // ImportC only\n             exp.e1 = exp.e1.expressionSemantic(sc).arrayFuncConv(sc);\n \n@@ -8059,6 +8068,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         assert(!exp.type);\n \n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            /* See if need to rewrite the AST because of cast/call ambiguity\n+             */\n+            if (auto e = castCallAmbiguity(exp, sc))\n+            {\n+                result = expressionSemantic(e, sc);\n+                return;\n+            }\n+        }\n+\n         result = exp.carraySemantic(sc);  // C semantics\n         if (result)\n             return;\n@@ -8452,6 +8472,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n+        if (sc.flags & SCOPE.Cfile)\n+        {\n+            /* See if need to rewrite the AST because of cast/call ambiguity\n+             */\n+            if (auto e = castCallAmbiguity(exp, sc))\n+            {\n+                result = expressionSemantic(e, sc);\n+                return;\n+            }\n+        }\n+\n         if (Expression ex = binSemantic(exp, sc))\n         {\n             result = ex;\n@@ -13050,7 +13081,7 @@ private bool fit(StructDeclaration sd, const ref Loc loc, Scope* sc, Expressions\n         e = resolveProperties(sc, e);\n         if (i >= nfields)\n         {\n-            if (i <= sd.fields.dim && e.op == EXP.null_)\n+            if (i < sd.fields.dim && e.op == EXP.null_)\n             {\n                 // CTFE sometimes creates null as hidden pointer; we'll allow this.\n                 continue;"}, {"sha": "5ee961f45967090a892021e424282d25cf91e34f", "filename": "gcc/d/dmd/importc.d", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fimportc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fimportc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimportc.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -15,13 +15,18 @@ module dmd.importc;\n \n import core.stdc.stdio;\n \n+import dmd.astenums;\n import dmd.dcast;\n+import dmd.declaration;\n import dmd.dscope;\n import dmd.dsymbol;\n import dmd.expression;\n import dmd.expressionsem;\n import dmd.identifier;\n+import dmd.init;\n import dmd.mtype;\n+import dmd.tokens;\n+import dmd.typesem;\n \n /**************************************\n  * C11 does not allow array or function parameters.\n@@ -84,7 +89,7 @@ Expression arrayFuncConv(Expression e, Scope* sc)\n     }\n     else if (t.isTypeFunction())\n     {\n-        e = e.addressOf();\n+        e = new AddrExp(e.loc, e);\n     }\n     else\n         return e;\n@@ -169,3 +174,89 @@ Expression carraySemantic(ArrayExp ae, Scope* sc)\n     auto ep = new PtrExp(ae.loc, new AddExp(ae.loc, e1, e2));\n     return ep.expressionSemantic(sc);\n }\n+\n+/******************************************\n+ * Determine default initializer for const global symbol.\n+ */\n+void addDefaultCInitializer(VarDeclaration dsym)\n+{\n+    //printf(\"addDefaultCInitializer() %s\\n\", dsym.toChars());\n+    if (!(dsym.storage_class & (STC.static_ | STC.gshared)))\n+        return;\n+    if (dsym.storage_class & (STC.extern_ | STC.field | STC.in_ | STC.foreach_ | STC.parameter | STC.result))\n+        return;\n+\n+    Type t = dsym.type;\n+    if (t.isTypeSArray() && t.isTypeSArray().isIncomplete())\n+    {\n+        dsym._init = new VoidInitializer(dsym.loc);\n+        return; // incomplete arrays will be diagnosed later\n+    }\n+\n+    if (t.isMutable())\n+        return;\n+\n+    auto e = dsym.type.defaultInit(dsym.loc, true);\n+    dsym._init = new ExpInitializer(dsym.loc, e);\n+}\n+\n+/********************************************\n+ * Resolve cast/call grammar ambiguity.\n+ * Params:\n+ *      e = expression that might be a cast, might be a call\n+ *      sc = context\n+ * Returns:\n+ *      null means leave as is, !=null means rewritten AST\n+ */\n+Expression castCallAmbiguity(Expression e, Scope* sc)\n+{\n+    Expression* pe = &e;\n+\n+    while (1)\n+    {\n+        // Walk down the postfix expressions till we find a CallExp or something else\n+        switch ((*pe).op)\n+        {\n+            case EXP.dotIdentifier:\n+                pe = &(*pe).isDotIdExp().e1;\n+                continue;\n+\n+            case EXP.plusPlus:\n+            case EXP.minusMinus:\n+                pe = &(*pe).isPostExp().e1;\n+                continue;\n+\n+            case EXP.array:\n+                pe = &(*pe).isArrayExp().e1;\n+                continue;\n+\n+            case EXP.call:\n+                auto ce = (*pe).isCallExp();\n+                if (ce.e1.parens)\n+                {\n+                    ce.e1 = expressionSemantic(ce.e1, sc);\n+                    if (ce.e1.op == EXP.type)\n+                    {\n+                        const numArgs = ce.arguments ? ce.arguments.length : 0;\n+                        if (numArgs >= 1)\n+                        {\n+                            ce.e1.parens = false;\n+                            Expression arg;\n+                            foreach (a; (*ce.arguments)[])\n+                            {\n+                                arg = arg ? new CommaExp(a.loc, arg, a) : a;\n+                            }\n+                            auto t = ce.e1.isTypeExp().type;\n+                            *pe = arg;\n+                            return new CastExp(ce.loc, e, t);\n+                        }\n+                    }\n+                }\n+                return null;\n+\n+            default:\n+                return null;\n+        }\n+    }\n+}\n+"}, {"sha": "51ee27d00fed3420304beb8b7687e157fda39d0c", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -434,11 +434,22 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                 return i;\n             }\n             if (sc.flags & SCOPE.Cfile)\n+            {\n                 /* the interpreter turns (char*)\"string\" into &\"string\"[0] which then\n                  * it cannot interpret. Resolve that case by doing optimize() first\n                  */\n                 i.exp = i.exp.optimize(WANTvalue);\n-            i.exp = i.exp.ctfeInterpret();\n+                if (i.exp.isSymOffExp())\n+                {\n+                    /* `static variable cannot be read at compile time`\n+                     * https://issues.dlang.org/show_bug.cgi?id=22513\n+                     * Maybe this would be better addressed in ctfeInterpret()?\n+                     */\n+                    needInterpret = NeedInterpret.INITnointerpret;\n+                }\n+            }\n+            if (needInterpret)\n+                i.exp = i.exp.ctfeInterpret();\n             if (i.exp.op == EXP.voidExpression)\n                 error(i.loc, \"variables cannot be initialized with an expression of type `void`. Use `void` initialization instead.\");\n         }"}, {"sha": "bb76a1a3a692562b9a87f47d8898ca219180fd72", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -2073,6 +2073,7 @@ class Lexer\n         bool overflow = false;\n         bool anyBinaryDigitsNoSingleUS = false;\n         bool anyHexDigitsNoSingleUS = false;\n+        char errorDigit = 0;\n         dchar c = *p;\n         if (c == '0')\n         {\n@@ -2093,8 +2094,7 @@ class Lexer\n \n             case '8':\n             case '9':\n-                if (Ccompile)\n-                    error(\"octal digit expected, not `%c`\", c);\n+                errorDigit = cast(char) c;\n                 base = 8;\n                 break;\n             case 'x':\n@@ -2205,12 +2205,9 @@ class Lexer\n             // got a digit here, set any necessary flags, check for errors\n             anyHexDigitsNoSingleUS = true;\n             anyBinaryDigitsNoSingleUS = true;\n-            if (!err && d >= base)\n+            if (!errorDigit && d >= base)\n             {\n-                error(\"%s digit expected, not `%c`\", base == 2 ? \"binary\".ptr :\n-                                                     base == 8 ? \"octal\".ptr :\n-                                                     \"decimal\".ptr, c);\n-                err = true;\n+                errorDigit = cast(char) c;\n             }\n             // Avoid expensive overflow check if we aren't at risk of overflow\n             if (n <= 0x0FFF_FFFF_FFFF_FFFFUL)\n@@ -2224,6 +2221,13 @@ class Lexer\n             }\n         }\n     Ldone:\n+        if (errorDigit)\n+        {\n+            error(\"%s digit expected, not `%c`\", base == 2 ? \"binary\".ptr :\n+                                                 base == 8 ? \"octal\".ptr :\n+                                                 \"decimal\".ptr, errorDigit);\n+            err = true;\n+        }\n         if (overflow && !err)\n         {\n             error(\"integer overflow\");"}, {"sha": "bafeaa332dc2f8e9e609ad7f4e46687ee02695b4", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -523,8 +523,14 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 {\n                     // Deal with $\n                     result = resolveOpDollar(sc, ae, ie, &e0);\n+\n                     if (result.op == EXP.error)\n+                    {\n+                        if (!e0 && !search_function(ad, Id.dollar)) {\n+                            ae.loc.errorSupplemental(\"Aggregate declaration '%s' does not define 'opDollar'\", ae.e1.toChars());\n+                        }\n                         return;\n+                    }\n                     /* Rewrite a[i..j] as:\n                      *      a.opSlice(i, j)\n                      */\n@@ -597,11 +603,13 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                     /* Rewrite op(e1) as:\n                      *      op(e1.aliasthis)\n                      */\n-                    Expression e1 = resolveAliasThis(sc, e.e1);\n-                    result = e.copy();\n-                    (cast(UnaExp)result).e1 = e1;\n-                    result = result.op_overload(sc);\n-                    return;\n+                    if (auto e1 = resolveAliasThis(sc, e.e1, true))\n+                    {\n+                        result = e.copy();\n+                        (cast(UnaExp)result).e1 = e1;\n+                        result = result.op_overload(sc);\n+                        return;\n+                    }\n                 }\n             }\n         }"}, {"sha": "ca9e0b3b6160a1ff0fa80bd8413bc20173c97736", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -26,6 +26,7 @@ import dmd.expressionsem;\n import dmd.globals;\n import dmd.init;\n import dmd.mtype;\n+import dmd.printast;\n import dmd.root.ctfloat;\n import dmd.sideeffect;\n import dmd.tokens;\n@@ -270,6 +271,7 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Type type)\n  */\n Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n {\n+    //printf(\"Expression_optimize() %s\\n\", e.toChars());\n     Expression ret = e;\n \n     void error()\n@@ -459,6 +461,59 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                 return;\n             }\n         }\n+        if (e.e1.isDotVarExp())\n+        {\n+            /******************************\n+             * Run down the left side of the a.b.c expression to determine the\n+             * leftmost variable being addressed (`a`), and accumulate the offsets of the `.b` and `.c`.\n+             * Params:\n+             *      e = the DotVarExp or VarExp\n+             *      var = set to the VarExp at the end, or null if doesn't end in VarExp\n+             *      offset = accumulation of all the .var offsets encountered\n+             * Returns: true on error\n+             */\n+            static bool getVarAndOffset(Expression e, ref VarDeclaration var, ref uint offset)\n+            {\n+                if (e.type.size() == SIZE_INVALID)  // trigger computation of v.offset\n+                    return true;\n+\n+                if (auto dve = e.isDotVarExp())\n+                {\n+                    auto v = dve.var.isVarDeclaration();\n+                    if (!v || !v.isField() || v.isBitFieldDeclaration())\n+                        return false;\n+\n+                    if (getVarAndOffset(dve.e1, var, offset))\n+                        return true;\n+                    offset += v.offset;\n+                }\n+                else if (auto ve = e.isVarExp())\n+                {\n+                    if (!ve.var.isReference() &&\n+                        !ve.var.isImportedSymbol() &&\n+                        ve.var.isDataseg() &&\n+                        ve.var.isCsymbol())\n+                    {\n+                        var = ve.var.isVarDeclaration();\n+                    }\n+                }\n+                return false;\n+            }\n+\n+            uint offset;\n+            VarDeclaration var;\n+            if (getVarAndOffset(e.e1, var, offset))\n+            {\n+                ret = ErrorExp.get();\n+                return;\n+            }\n+            if (var)\n+            {\n+                ret = new SymOffExp(e.loc, var, offset, false);\n+                ret.type = e.type;\n+                return;\n+            }\n+        }\n         if (auto ae = e.e1.isIndexExp())\n         {\n             // Convert &array[n] to &array+n"}, {"sha": "94056aba8062e4cf1b6ed4fed07d3c12894140ed", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -5758,7 +5758,26 @@ LagainStc:\n                     nextToken();\n                 }\n                 else\n-                    check(TOK.semicolon, \"statement\");\n+                {\n+                    /*\n+                     * https://issues.dlang.org/show_bug.cgi?id=22529\n+                     * Avoid empty declaration error in case of missing semicolon\n+                     * followed by another token and another semicolon. E.g.:\n+                     *\n+                     *  foo()\n+                     *  return;\n+                     *\n+                     * When the missing `;` error is emitted, token is sitting on return.\n+                     * If we simply use `check` to emit the error, the token is advanced\n+                     * to `;` and the empty statement error would follow. To avoid that,\n+                     * we check if the next token is a semicolon and simply output the error,\n+                     * otherwise we fall back on the old path (advancing the token).\n+                     */\n+                    if (token.value != TOK.semicolon && peek(&token).value == TOK.semicolon)\n+                        error(\"found `%s` when expecting `;` following statement\", token.toChars());\n+                    else\n+                        check(TOK.semicolon, \"statement\");\n+                }\n                 s = new AST.ExpStatement(loc, exp);\n                 break;\n             }"}, {"sha": "33b5e7f350a5c4f3b8553ca26913322550636a25", "filename": "gcc/d/dmd/printast.d", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -82,6 +82,24 @@ extern (C++) final class PrintASTVisitor : Visitor\n         printf(\".var: %s\\n\", e.var ? e.var.toChars() : \"\");\n     }\n \n+    override void visit(SymOffExp e)\n+    {\n+        printIndent(indent);\n+        printf(\"SymOff %s\\n\", e.type ? e.type.toChars() : \"\");\n+        printIndent(indent + 2);\n+        printf(\".var: %s\\n\", e.var ? e.var.toChars() : \"\");\n+        printIndent(indent + 2);\n+        printf(\".offset: %llx\\n\", e.offset);\n+    }\n+\n+    override void visit(VarExp e)\n+    {\n+        printIndent(indent);\n+        printf(\"Var %s\\n\", e.type ? e.type.toChars() : \"\");\n+        printIndent(indent + 2);\n+        printf(\".var: %s\\n\", e.var ? e.var.toChars() : \"\");\n+    }\n+\n     override void visit(DsymbolExp e)\n     {\n         visit(cast(Expression)e);\n@@ -120,6 +138,15 @@ extern (C++) final class PrintASTVisitor : Visitor\n         printAST(e.e1, indent + 2);\n     }\n \n+    override void visit(DotVarExp e)\n+    {\n+        printIndent(indent);\n+        printf(\"DotVar %s\\n\", e.type ? e.type.toChars() : \"\");\n+        printIndent(indent + 2);\n+        printf(\".var: %s\\n\", e.var.toChars());\n+        printAST(e.e1, indent + 2);\n+    }\n+\n     override void visit(BinExp e)\n     {\n         visit(cast(Expression)e);"}, {"sha": "da328fdcaf91d691faa1762f431a967924533a1a", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -235,6 +235,18 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         if (funcdecl.errors || isError(funcdecl.parent))\n         {\n             funcdecl.errors = true;\n+\n+            // Mark that the return type could not be inferred\n+            if (funcdecl.inferRetType)\n+            {\n+                assert(funcdecl.type);\n+                auto tf = funcdecl.type.isTypeFunction();\n+\n+                // Only change the return type s.t. other analysis is\n+                // still possible e.g. missmatched parameter types\n+                if (tf && !tf.next)\n+                    tf.next = Type.terror;\n+            }\n             return;\n         }\n         //printf(\"FuncDeclaration::semantic3('%s.%s', %p, sc = %p, loc = %s)\\n\", funcdecl.parent.toChars(), funcdecl.toChars(), funcdecl, sc, funcdecl.loc.toChars());"}, {"sha": "91855ac05b6105bd259e90d6f6fbe14ee8e7a33a", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -2471,64 +2471,69 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n         {\n             Expression initialExp = cs.exp;\n \n-            cs.exp = cs.exp.implicitCastTo(sc, sw.condition.type);\n-            cs.exp = cs.exp.optimize(WANTvalue | WANTexpand);\n-\n-            Expression e = cs.exp;\n-            // Remove all the casts the user and/or implicitCastTo may introduce\n-            // otherwise we'd sometimes fail the check below.\n-            while (e.op == EXP.cast_)\n-                e = (cast(CastExp)e).e1;\n-\n-            /* This is where variables are allowed as case expressions.\n-             */\n-            if (e.op == EXP.variable)\n-            {\n-                VarExp ve = cast(VarExp)e;\n-                VarDeclaration v = ve.var.isVarDeclaration();\n-                Type t = cs.exp.type.toBasetype();\n-                if (v && (t.isintegral() || t.ty == Tclass))\n+            // The switch'ed value has errors and doesn't provide the actual type\n+            // Don't touch the case to not replace it with an `ErrorExp` even if it is valid\n+            if (sw.condition.type && !sw.condition.type.isTypeError())\n+            {\n+                cs.exp = cs.exp.implicitCastTo(sc, sw.condition.type);\n+                cs.exp = cs.exp.optimize(WANTvalue | WANTexpand);\n+\n+                Expression e = cs.exp;\n+                // Remove all the casts the user and/or implicitCastTo may introduce\n+                // otherwise we'd sometimes fail the check below.\n+                while (e.op == EXP.cast_)\n+                    e = (cast(CastExp)e).e1;\n+\n+                /* This is where variables are allowed as case expressions.\n+                */\n+                if (e.op == EXP.variable)\n                 {\n-                    /* Flag that we need to do special code generation\n-                     * for this, i.e. generate a sequence of if-then-else\n-                     */\n-                    sw.hasVars = 1;\n-\n-                    /* TODO check if v can be uninitialized at that point.\n-                     */\n-                    if (!v.isConst() && !v.isImmutable())\n-                    {\n-                        cs.error(\"`case` variables have to be `const` or `immutable`\");\n-                    }\n-\n-                    if (sw.isFinal)\n-                    {\n-                        cs.error(\"`case` variables not allowed in `final switch` statements\");\n-                        errors = true;\n-                    }\n-\n-                    /* Find the outermost scope `scx` that set `sw`.\n-                     * Then search scope `scx` for a declaration of `v`.\n-                     */\n-                    for (Scope* scx = sc; scx; scx = scx.enclosing)\n+                    VarExp ve = cast(VarExp)e;\n+                    VarDeclaration v = ve.var.isVarDeclaration();\n+                    Type t = cs.exp.type.toBasetype();\n+                    if (v && (t.isintegral() || t.ty == Tclass))\n                     {\n-                        if (scx.enclosing && scx.enclosing.sw == sw)\n-                            continue;\n-                        assert(scx.sw == sw);\n+                        /* Flag that we need to do special code generation\n+                        * for this, i.e. generate a sequence of if-then-else\n+                        */\n+                        sw.hasVars = 1;\n+\n+                        /* TODO check if v can be uninitialized at that point.\n+                        */\n+                        if (!v.isConst() && !v.isImmutable())\n+                        {\n+                            cs.error(\"`case` variables have to be `const` or `immutable`\");\n+                        }\n \n-                        if (!scx.search(cs.exp.loc, v.ident, null))\n+                        if (sw.isFinal)\n                         {\n-                            cs.error(\"`case` variable `%s` declared at %s cannot be declared in `switch` body\",\n-                                v.toChars(), v.loc.toChars());\n+                            cs.error(\"`case` variables not allowed in `final switch` statements\");\n                             errors = true;\n                         }\n-                        break;\n+\n+                        /* Find the outermost scope `scx` that set `sw`.\n+                        * Then search scope `scx` for a declaration of `v`.\n+                        */\n+                        for (Scope* scx = sc; scx; scx = scx.enclosing)\n+                        {\n+                            if (scx.enclosing && scx.enclosing.sw == sw)\n+                                continue;\n+                            assert(scx.sw == sw);\n+\n+                            if (!scx.search(cs.exp.loc, v.ident, null))\n+                            {\n+                                cs.error(\"`case` variable `%s` declared at %s cannot be declared in `switch` body\",\n+                                    v.toChars(), v.loc.toChars());\n+                                errors = true;\n+                            }\n+                            break;\n+                        }\n+                        goto L1;\n                     }\n-                    goto L1;\n                 }\n+                else\n+                    cs.exp = cs.exp.ctfeInterpret();\n             }\n-            else\n-                cs.exp = cs.exp.ctfeInterpret();\n \n             if (StringExp se = cs.exp.toStringExp())\n                 cs.exp = se;\n@@ -2539,6 +2544,8 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             }\n \n         L1:\n+            // // Don't check other cases if this has errors\n+            if (!cs.exp.isErrorExp())\n             foreach (cs2; *sw.cases)\n             {\n                 //printf(\"comparing '%s' with '%s'\\n\", exp.toChars(), cs.exp.toChars());\n@@ -2877,9 +2884,6 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             if (rs.exp.op == EXP.call)\n                 rs.exp = valueNoDtor(rs.exp);\n \n-            if (e0)\n-                e0 = e0.optimize(WANTvalue);\n-\n             /* Void-return function can have void / noreturn typed expression\n              * on return statement.\n              */\n@@ -2904,7 +2908,10 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 rs.exp = null;\n             }\n             if (e0)\n+            {\n+                e0 = e0.optimize(WANTvalue);\n                 e0 = checkGC(sc, e0);\n+            }\n         }\n \n         if (rs.exp)"}, {"sha": "8e434a373d2084e29c0d44ef8141e0fcc9516aa2", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -323,7 +323,7 @@ struct TargetC\n                               /// https://docs.microsoft.com/en-us/cpp/cpp/cpp-bit-fields?view=msvc-160\n         Gcc_Clang,            /// gcc and clang\n     }\n-\n+    bool  crtDestructorsSupported = true; /// Not all platforms support crt_destructor\n     ubyte longsize;           /// size of a C `long` or `unsigned long` type\n     ubyte long_doublesize;    /// size of a C `long double`\n     ubyte wchar_tsize;        /// size of a C `wchar_t` type"}, {"sha": "6348d93b67dd26b9c5d7c14aff6b8652437c471d", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -70,6 +70,7 @@ struct TargetC\n         Gcc_Clang,            // gcc and clang\n     };\n \n+    uint8_t crtDestructorsSupported; // Not all platforms support crt_destructor\n     uint8_t longsize;            // size of a C 'long' or 'unsigned long' type\n     uint8_t long_doublesize;     // size of a C 'long double'\n     uint8_t wchar_tsize;         // size of a C 'wchar_t' type"}, {"sha": "2d98d5eeed853d4db028cb7667b9a4c4980ecdf4", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -52,38 +52,22 @@ enum TOK : ushort\n     new_,\n     delete_,\n     star,\n-    symbolOffset,\n     variable,\n-    dotVariable,\n-    dotIdentifier,\n-    dotTemplateInstance,\n-    dotType,\n     slice,\n-    arrayLength,\n     version_,\n     module_,\n     dollar,\n     template_,\n-    dotTemplateDeclaration,\n     declaration,\n     typeof_,\n     pragma_,\n-    dSymbol,\n     typeid_,\n     uadd,\n     remove,\n-    newAnonymousClass,\n     comment,\n-    arrayLiteral,\n-    assocArrayLiteral,\n-    structLiteral,\n-    classReference,\n-    thrownException,\n-    delegatePointer,\n-    delegateFunctionPointer,\n \n     // Operators\n-    lessThan = 54,\n+    lessThan,\n     greaterThan,\n     lessOrEqual,\n     greaterOrEqual,\n@@ -94,7 +78,7 @@ enum TOK : ushort\n     index,\n     is_,\n \n-    leftShift = 64,\n+    leftShift,\n     rightShift,\n     leftShiftAssign,\n     rightShiftAssign,\n@@ -136,7 +120,7 @@ enum TOK : ushort\n     preMinusMinus,\n \n     // Numeric literals\n-    int32Literal = 104,\n+    int32Literal,\n     uns32Literal,\n     int64Literal,\n     uns64Literal,\n@@ -150,22 +134,21 @@ enum TOK : ushort\n     imaginary80Literal,\n \n     // Char constants\n-    charLiteral = 116,\n+    charLiteral,\n     wcharLiteral,\n     dcharLiteral,\n \n     // Leaf operators\n-    identifier = 119,\n+    identifier,\n     string_,\n     hexadecimalString,\n     this_,\n     super_,\n-    halt,\n     tuple,\n     error,\n \n     // Basic types\n-    void_ = 127,\n+    void_,\n     int8,\n     uns8,\n     int16,\n@@ -191,7 +174,7 @@ enum TOK : ushort\n     bool_,\n \n     // Aggregates\n-    struct_ = 151,\n+    struct_,\n     class_,\n     interface_,\n     union_,\n@@ -223,7 +206,7 @@ enum TOK : ushort\n     immutable_,\n \n     // Statements\n-    if_ = 181,\n+    if_,\n     else_,\n     while_,\n     for_,\n@@ -249,7 +232,7 @@ enum TOK : ushort\n     onScopeSuccess,\n \n     // Contracts\n-    invariant_ = 205,\n+    invariant_,\n \n     // Testing\n     unittest_,\n@@ -259,7 +242,7 @@ enum TOK : ushort\n     ref_,\n     macro_,\n \n-    parameters = 210,\n+    parameters,\n     traits,\n     overloadSet,\n     pure_,\n@@ -279,18 +262,9 @@ enum TOK : ushort\n     vector,\n     pound,\n \n-    interval = 229,\n-    voidExpression,\n-    cantExpression,\n-    showCtfeContext,\n-\n-    objcClassReference,\n-    vectorArray,\n-\n     arrow,      // ->\n     colonColon, // ::\n     wchar_tLiteral,\n-    compoundLiteral, // ( type-name ) { initializer-list }\n \n     // C only keywords\n     inline,\n@@ -885,33 +859,17 @@ extern (C++) struct Token\n \n         // For debugging\n         TOK.error: \"error\",\n-        TOK.dotIdentifier: \"dotid\",\n-        TOK.dotTemplateDeclaration: \"dottd\",\n-        TOK.dotTemplateInstance: \"dotti\",\n-        TOK.dotVariable: \"dotvar\",\n-        TOK.dotType: \"dottype\",\n-        TOK.symbolOffset: \"symoff\",\n-        TOK.arrayLength: \"arraylength\",\n-        TOK.arrayLiteral: \"arrayliteral\",\n-        TOK.assocArrayLiteral: \"assocarrayliteral\",\n-        TOK.structLiteral: \"structliteral\",\n         TOK.string_: \"string\",\n-        TOK.dSymbol: \"symbol\",\n         TOK.tuple: \"tuple\",\n         TOK.declaration: \"declaration\",\n         TOK.onScopeExit: \"scope(exit)\",\n         TOK.onScopeSuccess: \"scope(success)\",\n         TOK.onScopeFailure: \"scope(failure)\",\n-        TOK.delegatePointer: \"delegateptr\",\n \n         // Finish up\n         TOK.reserved: \"reserved\",\n         TOK.remove: \"remove\",\n-        TOK.newAnonymousClass: \"newanonclass\",\n         TOK.comment: \"comment\",\n-        TOK.classReference: \"classreference\",\n-        TOK.thrownException: \"thrownexception\",\n-        TOK.delegateFunctionPointer: \"delegatefuncptr\",\n         TOK.int32Literal: \"int32v\",\n         TOK.uns32Literal: \"uns32v\",\n         TOK.int64Literal: \"int64v\",\n@@ -928,19 +886,9 @@ extern (C++) struct Token\n         TOK.wcharLiteral: \"wcharv\",\n         TOK.dcharLiteral: \"dcharv\",\n         TOK.wchar_tLiteral: \"wchar_tv\",\n-        TOK.compoundLiteral: \"compoundliteral\",\n \n-        TOK.halt: \"halt\",\n         TOK.hexadecimalString: \"xstring\",\n \n-        TOK.interval: \"interval\",\n-        TOK.voidExpression: \"voidexp\",\n-        TOK.cantExpression: \"cantexp\",\n-        TOK.showCtfeContext : \"showCtfeContext\",\n-\n-        TOK.objcClassReference: \"class\",\n-        TOK.vectorArray: \"vectorarray\",\n-\n         // C only keywords\n         TOK.inline    : \"inline\",\n         TOK.register  : \"register\","}, {"sha": "2e1d1f444927ecb23dc87b8b11f4017e031fd839", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -61,35 +61,19 @@ enum class TOK : unsigned short\n     new_,\n     delete_,\n     star,\n-    symbolOffset,\n     variable,\n-    dotVariable,\n-    dotIdentifier,\n-    dotTemplateInstance,\n-    dotType,\n     slice,\n-    arrayLength,\n     version_,\n     module_,\n     dollar,\n     template_,\n-    dotTemplateDeclaration,\n     declaration,\n     typeof_,\n     pragma_,\n-    dSymbol,\n     typeid_,\n     uadd,\n     remove,\n-    newAnonymousClass,\n     comment,\n-    arrayLiteral,\n-    assocArrayLiteral,\n-    structLiteral,\n-    classReference,\n-    thrownException,\n-    delegatePointer,\n-    delegateFunctionPointer,\n \n     // Operators\n     lessThan,       // 54\n@@ -169,7 +153,6 @@ enum class TOK : unsigned short\n     hexadecimalString,\n     this_,\n     super_,\n-    halt,\n     tuple,\n     error,\n \n@@ -288,18 +271,9 @@ enum class TOK : unsigned short\n     vector,\n     pound,\n \n-    interval,       // 229\n-    voidExpression,\n-    cantExpression,\n-    showCtfeContext,\n-\n-    objcClassReference,\n-    vectorArray,\n-\n     arrow,      // ->\n     colonColon, // ::\n     wchar_tLiteral,\n-    compoundLiteral, // ( type-name ) { initializer-list }\n \n     // C only keywords\n     inline_,"}, {"sha": "2a864161ff6dfd13a6773224ded54100a591de2f", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1709,13 +1709,22 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             }\n             else if (e.op == EXP.variable) // special case: variable is used as a type\n             {\n+                /*\n+                    N.B. This branch currently triggers for the following code\n+                    template test(x* x)\n+                    {\n+\n+                    }\n+                    i.e. the compiler prints \"variable x is used as a type\"\n+                    which isn't a particularly good error message (x is a variable?).\n+                */\n                 Dsymbol varDecl = mtype.toDsymbol(sc);\n                 const(Loc) varDeclLoc = varDecl.getLoc();\n-                Module varDeclModule = varDecl.getModule();\n+                Module varDeclModule = varDecl.getModule(); //This can be null\n \n                 .error(loc, \"variable `%s` is used as a type\", mtype.toChars());\n-\n-                if (varDeclModule != sc._module) // variable is imported\n+                //Check for null to avoid https://issues.dlang.org/show_bug.cgi?id=22574\n+                if ((varDeclModule !is null) && varDeclModule != sc._module) // variable is imported\n                 {\n                     const(Loc) varDeclModuleImportLoc = varDeclModule.getLoc();\n                     .errorSupplemental(\n@@ -4630,11 +4639,12 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n  * Params:\n  *  mt = the type for which the init expression is returned\n  *  loc = the location where the expression needs to be evaluated\n+ *  isCfile = default initializers are different with C\n  *\n  * Returns:\n  *  The initialization expression for the type.\n  */\n-extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n+extern (C++) Expression defaultInit(Type mt, const ref Loc loc, const bool isCfile = false)\n {\n     Expression visitBasic(TypeBasic mt)\n     {\n@@ -4647,12 +4657,12 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n         switch (mt.ty)\n         {\n         case Tchar:\n-            value = 0xFF;\n+            value = isCfile ? 0 : 0xFF;\n             break;\n \n         case Twchar:\n         case Tdchar:\n-            value = 0xFFFF;\n+            value = isCfile ? 0 : 0xFFFF;\n             break;\n \n         case Timaginary32:\n@@ -4661,14 +4671,15 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n         case Tfloat32:\n         case Tfloat64:\n         case Tfloat80:\n-            return new RealExp(loc, target.RealProperties.nan, mt);\n+            return new RealExp(loc, isCfile ? CTFloat.zero : target.RealProperties.nan, mt);\n \n         case Tcomplex32:\n         case Tcomplex64:\n         case Tcomplex80:\n             {\n                 // Can't use fvalue + I*fvalue (the im part becomes a quiet NaN).\n-                const cvalue = complex_t(target.RealProperties.nan, target.RealProperties.nan);\n+                const cvalue = isCfile ? complex_t(CTFloat.zero, CTFloat.zero)\n+                                       : complex_t(target.RealProperties.nan, target.RealProperties.nan);\n                 return new ComplexExp(loc, cvalue, mt);\n             }\n \n@@ -4686,7 +4697,7 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n     {\n         //printf(\"TypeVector::defaultInit()\\n\");\n         assert(mt.basetype.ty == Tsarray);\n-        Expression e = mt.basetype.defaultInit(loc);\n+        Expression e = mt.basetype.defaultInit(loc, isCfile);\n         auto ve = new VectorExp(loc, e, mt);\n         ve.type = mt;\n         ve.dim = cast(int)(mt.basetype.size(loc) / mt.elementType().size(loc));\n@@ -4700,9 +4711,9 @@ extern (C++) Expression defaultInit(Type mt, const ref Loc loc)\n             printf(\"TypeSArray::defaultInit() '%s'\\n\", mt.toChars());\n         }\n         if (mt.next.ty == Tvoid)\n-            return mt.tuns8.defaultInit(loc);\n+            return mt.tuns8.defaultInit(loc, isCfile);\n         else\n-            return mt.next.defaultInit(loc);\n+            return mt.next.defaultInit(loc, isCfile);\n     }\n \n     Expression visitFunction(TypeFunction mt)"}, {"sha": "bfec15688572f9518b7ba379c3a094bb36a509f1", "filename": "gcc/d/gdc.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fgdc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Fd%2Fgdc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fgdc.texi?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -267,15 +267,16 @@ Sets the C++ name mangling compatibility to the version identified by\n @table @samp\n @item c++98\n @item c++03\n-Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{199711}.\n+Sets @code{__traits(getTargetInfo, \"cppStd\")} to @code{199711}.\n @item c++11\n-Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{201103}.\n+Sets @code{__traits(getTargetInfo, \"cppStd\")} to @code{201103}.\n @item c++14\n-Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{201402}.\n+Sets @code{__traits(getTargetInfo, \"cppStd\")} to @code{201402}.\n @item c++17\n-Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{201703}.\n+Sets @code{__traits(getTargetInfo, \"cppStd\")} to @code{201703}.\n+This is the default.\n @item c++20\n-Sets @code{__traits(getTargetInfo \"cppStd\")} to @code{202002}.\n+Sets @code{__traits(getTargetInfo, \"cppStd\")} to @code{202002}.\n @end table\n \n @item -fno-invariants"}, {"sha": "8c112d1e5485e43adbc13fdd230bc1a38ad6e1c8", "filename": "gcc/testsuite/gdc.test/compilable/cppmangle.d", "status": "modified", "additions": 202, "deletions": 169, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -7,6 +7,12 @@\n \n import core.stdc.stdio;\n \n+version (CppRuntime_Clang)       version = CppMangle_Itanium;\n+version (CppRuntime_DigitalMars) version = CppMangle_MSVC;\n+version (CppRuntime_Gcc)         version = CppMangle_Itanium;\n+version (CppRuntime_Microsoft)   version = CppMangle_MSVC;\n+version (CppRuntime_Sun)         version = CppMangle_Itanium;\n+\n extern (C++) int foob(int i, int j, int k);\n \n class C\n@@ -45,23 +51,26 @@ void test1()\n     c.bar(4, 5, 6);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(foo.mangleof == \"_Z3fooiii\");\n     static assert(foob.mangleof == \"_Z4foobiii\");\n     static assert(C.bar.mangleof == \"_ZN1C3barEiii\");\n }\n-version (Win32)\n-{\n-    static assert(foo.mangleof == \"?foo@@YAHHHH@Z\");\n-    static assert(foob.mangleof == \"?foob@@YAHHHH@Z\");\n-    static assert(C.bar.mangleof == \"?bar@C@@UAEHHHH@Z\");\n-}\n-version (Win64)\n+version (CppMangle_MSVC)\n {\n-    static assert(foo.mangleof == \"?foo@@YAHHHH@Z\");\n-    static assert(foob.mangleof == \"?foob@@YAHHHH@Z\");\n-    static assert(C.bar.mangleof == \"?bar@C@@UEAAHHHH@Z\");\n+    version (Win32)\n+    {\n+        static assert(foo.mangleof == \"?foo@@YAHHHH@Z\");\n+        static assert(foob.mangleof == \"?foob@@YAHHHH@Z\");\n+        static assert(C.bar.mangleof == \"?bar@C@@UAEHHHH@Z\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(foo.mangleof == \"?foo@@YAHHHH@Z\");\n+        static assert(foob.mangleof == \"?foob@@YAHHHH@Z\");\n+        static assert(C.bar.mangleof == \"?bar@C@@UEAAHHHH@Z\");\n+    }\n }\n \n /****************************************/\n@@ -81,7 +90,7 @@ void test2()\n     assert(i == 8);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert (getD.mangleof == \"_Z4getDv\");\n     static assert (D.bar.mangleof == \"_ZN1D3barEiii\");\n@@ -118,7 +127,7 @@ void test3()\n     assert(i == 8);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert (callE.mangleof == \"_Z5callEP1E\");\n     static assert (E.bar.mangleof == \"_ZN1E3barEiii\");\n@@ -134,7 +143,7 @@ void test4()\n     foo4(null);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(foo4.mangleof == \"_Z4foo4Pc\");\n }\n@@ -160,7 +169,7 @@ void test5()\n   assert(f.p == cast(void*)b);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(bar5.getFoo.mangleof == \"_ZN4bar56getFooEi\");\n     static assert (newBar.mangleof == \"_Z6newBarv\");\n@@ -190,7 +199,7 @@ void test6()\n     assert(f.d == 2.5);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert (foo6.mangleof == \"_Z4foo6v\");\n }\n@@ -221,7 +230,7 @@ void test8()\n     foo8(&c);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(foo8.mangleof == \"_Z4foo8PKc\");\n }\n@@ -239,7 +248,7 @@ void test9()\n     foobar9(a, a);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(foobar9.mangleof == \"_Z7foobar9P5elem9S0_\");\n }\n@@ -298,7 +307,7 @@ extern (C++)\n     void test10058l(void* function(void*), void* function(const (void)*), const(void)* function(void*)) { }\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(test10058a.mangleof == \"_Z10test10058aPv\");\n     static assert(test10058b.mangleof == \"_Z10test10058bPFvPvE\");\n@@ -329,7 +338,7 @@ class CallExp\n     static void test11696d(Loc, Expression*, Expression*);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(CallExp.test11696a.mangleof == \"_ZN7CallExp10test11696aE3LocP10ExpressionS2_\");\n     static assert(CallExp.test11696b.mangleof == \"_ZN7CallExp10test11696bE3LocP10ExpressionPS2_\");\n@@ -353,7 +362,7 @@ extern(C++, `N13337a`, `N13337b`, `N13337c`)\n     void foo13337_3(S13337_2 s);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(foo13337.mangleof == \"_ZN7N13337a7N13337b7N13337c8foo13337ENS1_6S13337E\");\n     static assert(foo13337_2.mangleof == \"_ZN7N13337a7N13337b7N13337c10foo13337_2ENS1_6S13337E\");\n@@ -383,7 +392,7 @@ extern(C++)\n     }\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(Struct7030.foo.mangleof == \"_ZNK10Struct70303fooEi\");\n     static assert(Struct7030.bar.mangleof == \"_ZN10Struct70303barEi\");\n@@ -494,7 +503,7 @@ extern (C++)\n     void func_20413(pair!(int, float), pair!(float, int));\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     // https://issues.dlang.org/show_bug.cgi?id=17947\n     static assert(std.pair!(void*, void*).swap.mangleof == \"_ZNSt4pairIPvS0_E4swapERS1_\");\n@@ -531,7 +540,7 @@ alias T36 = int ********** ********** ********** **********;\n \n extern (C++) void test36(T36, T36*) { }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(test36.mangleof == \"_Z6test36PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPiPS12_\");\n }\n@@ -545,7 +554,7 @@ int test37(T)(){ return 0;}\n extern(C++, `SPACE`)\n int test37(T)(){ return 0;}\n \n-version (Posix) // all non-Windows machines\n+version (CppMangle_Itanium) // all non-Windows machines\n {\n     static assert(SPACE.test37!int.mangleof == \"_ZN5SPACE6test37IiEEiv\");\n     static assert(test37!int.mangleof == \"_ZN5SPACE6test37IiEEiv\");\n@@ -556,11 +565,11 @@ version (Posix) // all non-Windows machines\n \n extern (C++) void test15388(typeof(null));\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(test15388.mangleof == \"_Z9test15388Dn\");\n }\n-version (Windows)\n+version (CppMangle_MSVC)\n {\n     static assert(test15388.mangleof == \"?test15388@@YAX$$T@Z\");\n }\n@@ -583,29 +592,32 @@ extern (C++) struct Test14086_S\n     ~this();\n }\n \n-version(Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(Test14086.__ctor.mangleof == \"_ZN9Test14086C1Ev\");\n     static assert(Test14086.__dtor.mangleof == \"_ZN9Test14086D1Ev\");\n     static assert(Test14086_2.__dtor.mangleof == \"_ZN11Test14086_2D1Ev\");\n     static assert(Test14086_S.__ctor.mangleof == \"_ZN11Test14086_SC1Ei\");\n     static assert(Test14086_S.__dtor.mangleof == \"_ZN11Test14086_SD1Ev\");\n }\n-version(Win32)\n-{\n-    static assert(Test14086.__ctor.mangleof == \"??0Test14086@@QAE@XZ\");\n-    static assert(Test14086.__dtor.mangleof == \"??1Test14086@@UAE@XZ\");\n-    static assert(Test14086_2.__dtor.mangleof == \"??1Test14086_2@@QAE@XZ\");\n-    static assert(Test14086_S.__ctor.mangleof == \"??0Test14086_S@@QAE@H@Z\");\n-    static assert(Test14086_S.__dtor.mangleof == \"??1Test14086_S@@QAE@XZ\");\n-}\n-version(Win64)\n+version (CppMangle_MSVC)\n {\n-    static assert(Test14086.__ctor.mangleof == \"??0Test14086@@QEAA@XZ\");\n-    static assert(Test14086.__dtor.mangleof == \"??1Test14086@@UEAA@XZ\");\n-    static assert(Test14086_2.__dtor.mangleof == \"??1Test14086_2@@QEAA@XZ\");\n-    static assert(Test14086_S.__ctor.mangleof == \"??0Test14086_S@@QEAA@H@Z\");\n-    static assert(Test14086_S.__dtor.mangleof == \"??1Test14086_S@@QEAA@XZ\");\n+    version (Win32)\n+    {\n+        static assert(Test14086.__ctor.mangleof == \"??0Test14086@@QAE@XZ\");\n+        static assert(Test14086.__dtor.mangleof == \"??1Test14086@@UAE@XZ\");\n+        static assert(Test14086_2.__dtor.mangleof == \"??1Test14086_2@@QAE@XZ\");\n+        static assert(Test14086_S.__ctor.mangleof == \"??0Test14086_S@@QAE@H@Z\");\n+        static assert(Test14086_S.__dtor.mangleof == \"??1Test14086_S@@QAE@XZ\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(Test14086.__ctor.mangleof == \"??0Test14086@@QEAA@XZ\");\n+        static assert(Test14086.__dtor.mangleof == \"??1Test14086@@UEAA@XZ\");\n+        static assert(Test14086_2.__dtor.mangleof == \"??1Test14086_2@@QEAA@XZ\");\n+        static assert(Test14086_S.__ctor.mangleof == \"??0Test14086_S@@QEAA@H@Z\");\n+        static assert(Test14086_S.__dtor.mangleof == \"??1Test14086_S@@QEAA@XZ\");\n+    }\n }\n \n /**************************************/\n@@ -623,17 +635,20 @@ struct S18888(alias arg = T18888)\n     alias I = T18888!(arg!int);\n }\n \n-version(Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(S18888!().I.fun.mangleof == \"_ZN6T18888IS_IiEE3funEv\");\n }\n-version(Win32)\n-{\n-    static assert(S18888!().I.fun.mangleof == \"?fun@?$T18888@U?$T18888@H@@@@QAEXXZ\");\n-}\n-version(Win64)\n+version (CppMangle_MSVC)\n {\n-    static assert(S18888!().I.fun.mangleof == \"?fun@?$T18888@U?$T18888@H@@@@QEAAXXZ\");\n+    version (Win32)\n+    {\n+        static assert(S18888!().I.fun.mangleof == \"?fun@?$T18888@U?$T18888@H@@@@QAEXXZ\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(S18888!().I.fun.mangleof == \"?fun@?$T18888@U?$T18888@H@@@@QEAAXXZ\");\n+    }\n }\n \n /**************************************/\n@@ -653,26 +668,29 @@ extern (C++) class C18890_2\n     Agg s;\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(C18890.__dtor.mangleof == \"_ZN6C18890D1Ev\");\n     static assert(C18890.__xdtor.mangleof == \"_ZN6C18890D1Ev\");\n     static assert(C18890_2.__dtor.mangleof == \"_ZN8C18890_26__dtorEv\");\n     static assert(C18890_2.__xdtor.mangleof == \"_ZN8C18890_2D1Ev\");\n }\n-version (Win32)\n+version (CppMangle_MSVC)\n {\n-    static assert(C18890.__dtor.mangleof == \"??1C18890@@UAE@XZ\");\n-    static assert(C18890.__xdtor.mangleof == \"??_GC18890@@UAEPAXI@Z\");\n-    static assert(C18890_2.__dtor.mangleof == \"?__dtor@C18890_2@@UAEXXZ\");\n-    static assert(C18890_2.__xdtor.mangleof == \"??_GC18890_2@@UAEPAXI@Z\");\n-}\n-version (Win64)\n-{\n-    static assert(C18890.__dtor.mangleof == \"??1C18890@@UEAA@XZ\");\n-    static assert(C18890.__xdtor.mangleof == \"??_GC18890@@UEAAPEAXI@Z\");\n-    static assert(C18890_2.__dtor.mangleof == \"?__dtor@C18890_2@@UEAAXXZ\");\n-    static assert(C18890_2.__xdtor.mangleof == \"??_GC18890_2@@UEAAPEAXI@Z\");\n+    version (Win32)\n+    {\n+        static assert(C18890.__dtor.mangleof == \"??1C18890@@UAE@XZ\");\n+        static assert(C18890.__xdtor.mangleof == \"??_GC18890@@UAEPAXI@Z\");\n+        static assert(C18890_2.__dtor.mangleof == \"?__dtor@C18890_2@@UAEXXZ\");\n+        static assert(C18890_2.__xdtor.mangleof == \"??_GC18890_2@@UAEPAXI@Z\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(C18890.__dtor.mangleof == \"??1C18890@@UEAA@XZ\");\n+        static assert(C18890.__xdtor.mangleof == \"??_GC18890@@UEAAPEAXI@Z\");\n+        static assert(C18890_2.__dtor.mangleof == \"?__dtor@C18890_2@@UEAAXXZ\");\n+        static assert(C18890_2.__xdtor.mangleof == \"??_GC18890_2@@UEAAPEAXI@Z\");\n+    }\n }\n \n /**************************************/\n@@ -688,20 +706,23 @@ extern (C++) class C18891\n     Agg s;\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(C18891.__dtor.mangleof == \"_ZN6C18891D1Ev\");\n     static assert(C18891.__xdtor.mangleof == \"_ZN6C18891D1Ev\");\n }\n-version (Win32)\n+version (CppMangle_MSVC)\n {\n-    static assert(C18891.__dtor.mangleof == \"??1C18891@@UAE@XZ\");\n-    static assert(C18891.__xdtor.mangleof == \"??_GC18891@@UAEPAXI@Z\");\n-}\n-version (Win64)\n-{\n-    static assert(C18891.__dtor.mangleof == \"??1C18891@@UEAA@XZ\");\n-    static assert(C18891.__xdtor.mangleof == \"??_GC18891@@UEAAPEAXI@Z\");\n+    version (Win32)\n+    {\n+        static assert(C18891.__dtor.mangleof == \"??1C18891@@UAE@XZ\");\n+        static assert(C18891.__xdtor.mangleof == \"??_GC18891@@UAEPAXI@Z\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(C18891.__dtor.mangleof == \"??1C18891@@UEAA@XZ\");\n+        static assert(C18891.__xdtor.mangleof == \"??_GC18891@@UEAAPEAXI@Z\");\n+    }\n }\n \n /**************************************/\n@@ -719,7 +740,7 @@ extern (C++) struct TestOperators\n     int opAssign(int);\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(TestOperators.opUnary!\"*\".mangleof     == \"_ZN13TestOperatorsdeEv\");\n     static assert(TestOperators.opUnary!\"++\".mangleof    == \"_ZN13TestOperatorsppEv\");\n@@ -753,73 +774,76 @@ version (Posix)\n     static assert(TestOperators.opIndex.mangleof         == \"_ZN13TestOperatorsixEi\");\n     static assert(TestOperators.opCall.mangleof          == \"_ZN13TestOperatorsclEif\");\n }\n-version (Win32)\n-{\n-    static assert(TestOperators.opUnary!\"*\".mangleof     == \"??DTestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opUnary!\"++\".mangleof    == \"??ETestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opUnary!\"--\".mangleof    == \"??FTestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opUnary!\"-\".mangleof     == \"??GTestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opUnary!\"+\".mangleof     == \"??HTestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opUnary!\"~\".mangleof     == \"??STestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opBinary!\">>\".mangleof   == \"??5TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"<<\".mangleof   == \"??6TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"*\".mangleof    == \"??DTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"-\".mangleof    == \"??GTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"+\".mangleof    == \"??HTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"&\".mangleof    == \"??ITestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"/\".mangleof    == \"??KTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"%\".mangleof    == \"??LTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"^\".mangleof    == \"??TTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opBinary!\"|\".mangleof    == \"??UTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"*\".mangleof  == \"??XTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"+\".mangleof  == \"??YTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"-\".mangleof  == \"??ZTestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"/\".mangleof  == \"??_0TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"%\".mangleof  == \"??_1TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\">>\".mangleof == \"??_2TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"<<\".mangleof == \"??_3TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"&\".mangleof  == \"??_4TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"|\".mangleof  == \"??_5TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"^\".mangleof  == \"??_6TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opCast!int.mangleof      == \"??BTestOperators@@QAEHXZ\");\n-    static assert(TestOperators.opAssign.mangleof        == \"??4TestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opEquals.mangleof        == \"??8TestOperators@@QAE_NH@Z\");\n-    static assert(TestOperators.opIndex.mangleof         == \"??ATestOperators@@QAEHH@Z\");\n-    static assert(TestOperators.opCall.mangleof          == \"??RTestOperators@@QAEHHM@Z\");\n-}\n-version (Win64)\n-{\n-    static assert(TestOperators.opUnary!\"*\".mangleof     == \"??DTestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opUnary!\"++\".mangleof    == \"??ETestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opUnary!\"--\".mangleof    == \"??FTestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opUnary!\"-\".mangleof     == \"??GTestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opUnary!\"+\".mangleof     == \"??HTestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opUnary!\"~\".mangleof     == \"??STestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opBinary!\">>\".mangleof   == \"??5TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"<<\".mangleof   == \"??6TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"*\".mangleof    == \"??DTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"-\".mangleof    == \"??GTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"+\".mangleof    == \"??HTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"&\".mangleof    == \"??ITestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"/\".mangleof    == \"??KTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"%\".mangleof    == \"??LTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"^\".mangleof    == \"??TTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opBinary!\"|\".mangleof    == \"??UTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"*\".mangleof  == \"??XTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"+\".mangleof  == \"??YTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"-\".mangleof  == \"??ZTestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"/\".mangleof  == \"??_0TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"%\".mangleof  == \"??_1TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\">>\".mangleof == \"??_2TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"<<\".mangleof == \"??_3TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"&\".mangleof  == \"??_4TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"|\".mangleof  == \"??_5TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opOpAssign!\"^\".mangleof  == \"??_6TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opCast!int.mangleof      == \"??BTestOperators@@QEAAHXZ\");\n-    static assert(TestOperators.opAssign.mangleof        == \"??4TestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opEquals.mangleof        == \"??8TestOperators@@QEAA_NH@Z\");\n-    static assert(TestOperators.opIndex.mangleof         == \"??ATestOperators@@QEAAHH@Z\");\n-    static assert(TestOperators.opCall.mangleof          == \"??RTestOperators@@QEAAHHM@Z\");\n+version (CppMangle_MSVC)\n+{\n+    version (Win32)\n+    {\n+        static assert(TestOperators.opUnary!\"*\".mangleof     == \"??DTestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opUnary!\"++\".mangleof    == \"??ETestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opUnary!\"--\".mangleof    == \"??FTestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opUnary!\"-\".mangleof     == \"??GTestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opUnary!\"+\".mangleof     == \"??HTestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opUnary!\"~\".mangleof     == \"??STestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opBinary!\">>\".mangleof   == \"??5TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"<<\".mangleof   == \"??6TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"*\".mangleof    == \"??DTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"-\".mangleof    == \"??GTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"+\".mangleof    == \"??HTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"&\".mangleof    == \"??ITestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"/\".mangleof    == \"??KTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"%\".mangleof    == \"??LTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"^\".mangleof    == \"??TTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opBinary!\"|\".mangleof    == \"??UTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"*\".mangleof  == \"??XTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"+\".mangleof  == \"??YTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"-\".mangleof  == \"??ZTestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"/\".mangleof  == \"??_0TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"%\".mangleof  == \"??_1TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\">>\".mangleof == \"??_2TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"<<\".mangleof == \"??_3TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"&\".mangleof  == \"??_4TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"|\".mangleof  == \"??_5TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"^\".mangleof  == \"??_6TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opCast!int.mangleof      == \"??BTestOperators@@QAEHXZ\");\n+        static assert(TestOperators.opAssign.mangleof        == \"??4TestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opEquals.mangleof        == \"??8TestOperators@@QAE_NH@Z\");\n+        static assert(TestOperators.opIndex.mangleof         == \"??ATestOperators@@QAEHH@Z\");\n+        static assert(TestOperators.opCall.mangleof          == \"??RTestOperators@@QAEHHM@Z\");\n+    }\n+    version (Win64)\n+    {\n+        static assert(TestOperators.opUnary!\"*\".mangleof     == \"??DTestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opUnary!\"++\".mangleof    == \"??ETestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opUnary!\"--\".mangleof    == \"??FTestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opUnary!\"-\".mangleof     == \"??GTestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opUnary!\"+\".mangleof     == \"??HTestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opUnary!\"~\".mangleof     == \"??STestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opBinary!\">>\".mangleof   == \"??5TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"<<\".mangleof   == \"??6TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"*\".mangleof    == \"??DTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"-\".mangleof    == \"??GTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"+\".mangleof    == \"??HTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"&\".mangleof    == \"??ITestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"/\".mangleof    == \"??KTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"%\".mangleof    == \"??LTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"^\".mangleof    == \"??TTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opBinary!\"|\".mangleof    == \"??UTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"*\".mangleof  == \"??XTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"+\".mangleof  == \"??YTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"-\".mangleof  == \"??ZTestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"/\".mangleof  == \"??_0TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"%\".mangleof  == \"??_1TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\">>\".mangleof == \"??_2TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"<<\".mangleof == \"??_3TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"&\".mangleof  == \"??_4TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"|\".mangleof  == \"??_5TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opOpAssign!\"^\".mangleof  == \"??_6TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opCast!int.mangleof      == \"??BTestOperators@@QEAAHXZ\");\n+        static assert(TestOperators.opAssign.mangleof        == \"??4TestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opEquals.mangleof        == \"??8TestOperators@@QEAA_NH@Z\");\n+        static assert(TestOperators.opIndex.mangleof         == \"??ATestOperators@@QEAAHH@Z\");\n+        static assert(TestOperators.opCall.mangleof          == \"??RTestOperators@@QEAAHHM@Z\");\n+    }\n }\n \n import cppmangle2;\n@@ -839,14 +863,14 @@ extern(C++, `Namespace18922`)\n     void func18922_3(Struct18922) {}\n }\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(func18922.mangleof == \"_ZN14Namespace189229func18922ENS_11Struct18922E\");\n     static assert(func18922_1.mangleof == \"_ZN14Namespace1892211func18922_1ENS_11Struct18922E\");\n     static assert(func18922_2.mangleof == \"_ZN14Namespace1892211func18922_2ENS_11Struct18922E\");\n     static assert(func18922_3.mangleof == \"_ZN14Namespace1892211func18922_3ENS_11Struct18922E\");\n }\n-else version(Windows)\n+else version (CppMangle_MSVC)\n {\n     static assert(func18922.mangleof == \"?func18922@Namespace18922@@YAXUStruct18922@1@@Z\");\n     static assert(func18922_1.mangleof == \"?func18922_1@Namespace18922@@YAXUStruct18922@1@@Z\");\n@@ -858,7 +882,7 @@ else version(Windows)\n // https://issues.dlang.org/show_bug.cgi?id=18957\n // extern(C++) doesn't mangle 'std' correctly on posix systems\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     // https://godbolt.org/z/C5T2LQ\n     /+\n@@ -881,7 +905,7 @@ extern(C++) struct test19043(T) {}\n \n extern(C++) void test19043a(test19043!(const(char)) a) {}\n extern(C++) void test19043b(T)(T a) {}\n-version(Windows)\n+version (CppMangle_MSVC)\n {\n     static assert(test19043a.mangleof == \"?test19043a@@YAXU?$test19043@$$CBD@@@Z\");\n     static assert(test19043b!(test19043!(const(char))).mangleof ==\n@@ -890,7 +914,7 @@ version(Windows)\n \n // https://issues.dlang.org/show_bug.cgi?id=16479\n //  Missing substitution while mangling C++ template parameter for functions\n-version (Posix) extern (C++)\n+version (CppMangle_Itanium) extern (C++)\n {\n     // Make sure aliases are still resolved\n     alias Alias16479 = int;\n@@ -1084,15 +1108,18 @@ extern(C++, (AliasSeq!(Tup, \"yay\")))\n {\n     void test19278_4();\n }\n-version(Win64)\n+version (CppMangle_MSVC)\n {\n-    static assert(test19278.mangleof == \"?test19278@helloworld@@YAXXZ\");\n-    static assert(test19278_2.mangleof == \"?test19278_2@lookup@@YAXXZ\");\n-    static assert(test19278_3.mangleof == \"?test19278_3@world@hello@@YAXXZ\");\n-    static assert(test19278_4.mangleof == \"?test19278_4@yay@world@hello@@YAXXZ\");\n-    static assert(test19278_var.mangleof == \"?test19278_var@world@hello@@3_KA\");\n+    version (Win64)\n+    {\n+        static assert(test19278.mangleof == \"?test19278@helloworld@@YAXXZ\");\n+        static assert(test19278_2.mangleof == \"?test19278_2@lookup@@YAXXZ\");\n+        static assert(test19278_3.mangleof == \"?test19278_3@world@hello@@YAXXZ\");\n+        static assert(test19278_4.mangleof == \"?test19278_4@yay@world@hello@@YAXXZ\");\n+        static assert(test19278_var.mangleof == \"?test19278_var@world@hello@@3_KA\");\n+    }\n }\n-else version(Posix)\n+else version (CppMangle_Itanium)\n {\n     static assert(test19278.mangleof == \"_ZN10helloworld9test19278Ev\");\n     static assert(test19278_2.mangleof == \"_ZN6lookup11test19278_2Ev\");\n@@ -1105,31 +1132,34 @@ else version(Posix)\n // https://issues.dlang.org/show_bug.cgi?id=18958\n // Issue 18958 - extern(C++) wchar, dchar mangling not correct\n \n-version(Posix)\n+version (Posix)\n     enum __c_wchar_t : dchar;\n-else version(Windows)\n+else version (Windows)\n     enum __c_wchar_t : wchar;\n alias wchar_t = __c_wchar_t;\n extern (C++) void test_char_mangling(char, wchar, dchar, wchar_t);\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     static assert(test_char_mangling.mangleof == \"_Z18test_char_manglingcDsDiw\");\n }\n-version (Win64)\n+version (CppMangle_MSVC)\n {\n-    static assert(test_char_mangling.mangleof == \"?test_char_mangling@@YAXD_S_U_W@Z\");\n+    version (Win64)\n+    {\n+        static assert(test_char_mangling.mangleof == \"?test_char_mangling@@YAXD_S_U_W@Z\");\n+    }\n }\n \n // https://github.com/dlang/dmd/pull/10021/files#r294055424\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++, PR10021_NS) struct PR10021_Struct(T){}\n     extern(C++) void PR10021_fun(int i)(PR10021_Struct!int);\n     static assert(PR10021_fun!0.mangleof == `_Z11PR10021_funILi0EEvN10PR10021_NS14PR10021_StructIiEE`);\n }\n \n // https://github.com/dlang/dmd/pull/10021#discussion_r294095749\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++, \"a\", \"b\")\n     struct PR10021_Struct2\n@@ -1142,7 +1172,7 @@ version (Posix)\n }\n \n /// https://issues.dlang.org/show_bug.cgi?id=20022\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++, `ns20022`) enum Enum20022_1 { A = 1, }\n     extern(C++) void fun20022_1(Enum20022_1);\n@@ -1167,7 +1197,7 @@ version (Posix)\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=20094\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++, \"ns20094\")\n     {\n@@ -1180,7 +1210,7 @@ version (Posix)\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=20223\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++)\n     {\n@@ -1206,7 +1236,7 @@ version (Posix)\n }\n \n // https://issues.dlang.org/show_bug.cgi?id=20224\n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern(C++) public int test20224_1(T)(set20224!T set);  // ok\n     extern(C++) public int test20224_2(T)(ref set20224!T set);  // segfault\n@@ -1228,7 +1258,7 @@ version (Posix)\n \n /**************************************/\n \n-version (Posix)\n+version (CppMangle_Itanium)\n {\n     extern (C++) struct Loc2 {};\n     extern (C++) class FuncDeclaration\n@@ -1251,7 +1281,7 @@ extern(C++, `bar`)\n // https://issues.dlang.org/show_bug.cgi?id=20700\n // Only testing on WIn64 because the mangling includes 'E',\n // and the bug can be tested on either platform\n-version (Win64) extern(C++)\n+version (CppMangle_MSVC) version (Win64) extern(C++)\n {\n     void test20700_1(Struct20700);\n     extern(C++, class) struct Struct20700 {}\n@@ -1285,12 +1315,15 @@ extern (C++)\n     alias fpcpp = noreturn function();\n     int funccpp(fpcpp);\n \n-    version (Posix)\n+    version (CppMangle_Itanium)\n         static assert(funccpp.mangleof == \"_Z7funccppPFvvE\");\n \n-    version (Win32)\n-        static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n+    version (CppMangle_MSVC)\n+    {\n+        version (Win32)\n+            static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n \n-    version (Win64)\n-        static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n+        version (Win64)\n+            static assert(funccpp.mangleof == \"?funccpp@@YAHP6AXXZ@Z\");\n+    }\n }"}, {"sha": "93e49c72c184a41c165af582823cb356c4a1be0e", "filename": "gcc/testsuite/gdc.test/compilable/cppmangle3.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -3,6 +3,11 @@\n // https://issues.dlang.org/show_bug.cgi?id=19920\n module cppmangle3;\n \n+version (CppRuntime_Clang)       version = CppMangle_Itanium;\n+version (CppRuntime_DigitalMars) version = CppMangle_MSVC;\n+version (CppRuntime_Gcc)         version = CppMangle_Itanium;\n+version (CppRuntime_Microsoft)   version = CppMangle_MSVC;\n+version (CppRuntime_Sun)         version = CppMangle_Itanium;\n \n extern(C++, \"true\")\n {\n@@ -23,8 +28,8 @@ extern(C++, \"std\", \"chrono\")\n     void func();\n }\n \n-version(Windows) static assert(func.mangleof == \"?func@chrono@std@@YAXXZ\");\n-else             static assert(func.mangleof == \"_ZNSt6chrono4funcEv\");\n+version(CppMangle_MSVC) static assert(func.mangleof == \"?func@chrono@std@@YAXXZ\");\n+else                    static assert(func.mangleof == \"_ZNSt6chrono4funcEv\");\n \n struct Foo\n {"}, {"sha": "30291a35e626c2ea1acd329c15663b29b8a74f3c", "filename": "gcc/testsuite/gdc.test/compilable/issue21203.d", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21203.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21203.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21203.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,210 @@\n+version (CppRuntime_Clang) version = CppMangle_Itanium;\n+version (CppRuntime_Gcc)   version = CppMangle_Itanium;\n+version (CppRuntime_Sun)   version = CppMangle_Itanium;\n+\n+template ScopeClass(C , string name = C.stringof)\n+//if (is(C == class) && __traits(getLinkage, C) == \"C++\")\n+{\n+    //enum name = C.stringof;\n+    enum ns = __traits(getCppNamespaces,C);\n+    extern(C++, class)\n+    {\n+        extern(C++,(ns))\n+        {\n+            pragma(mangle, C, name)\n+            struct ScopeClass\n+            {\n+                char[__traits(classInstanceSize, C)] buffer;\n+                //... all the things ...\n+            }\n+        }\n+    }\n+}\n+\n+// Basic tests\n+extern(C++)\n+{\n+    class MyClassA {}\n+    void funa(ScopeClass!MyClassA);           // mangles MyClass\n+    void funb(const ScopeClass!MyClassA);     // mangles const MyClass\n+    void func(ref ScopeClass!MyClassA);       // mangles MyClass&\n+    void fund(ref const ScopeClass!MyClassA); // mangles const MyClass&\n+    void fune(const(ScopeClass!MyClassA)*);\n+}\n+\n+version (CppMangle_Itanium)\n+{\n+    static assert(funa.mangleof == \"_Z4funa8MyClassA\");\n+    static assert(funb.mangleof == \"_Z4funb8MyClassA\");\n+    static assert(func.mangleof == \"_Z4funcR8MyClassA\");\n+    static assert(fund.mangleof == \"_Z4fundRK8MyClassA\");\n+    static assert(fune.mangleof == \"_Z4funePK8MyClassA\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static assert(funa.mangleof == \"?funa@@YAXVMyClassA@@@Z\");\n+    static assert(funb.mangleof == \"?funb@@YAXVMyClassA@@@Z\");\n+    static if (size_t.sizeof == ulong.sizeof)\n+    {\n+        static assert(func.mangleof == \"?func@@YAXAEAVMyClassA@@@Z\");\n+        static assert(fund.mangleof == \"?fund@@YAXAEBVMyClassA@@@Z\");\n+        static assert(fune.mangleof == \"?fune@@YAXPEBVMyClassA@@@Z\");\n+    }\n+    else\n+    {\n+        static assert(func.mangleof == \"?func@@YAXAAVMyClassA@@@Z\");\n+        static assert(fund.mangleof == \"?fund@@YAXABVMyClassA@@@Z\");\n+        static assert(fune.mangleof == \"?fune@@YAXPBVMyClassA@@@Z\");\n+    }\n+}\n+\n+//Basic tests with a namespace\n+extern(C++, \"ns\")\n+{\n+    class MyClassB {}\n+    void funf(ScopeClass!MyClassB);           // mangles MyClass\n+    void fung(const ScopeClass!MyClassB);     // mangles const MyClass\n+    void funh(ref ScopeClass!MyClassB);       // mangles MyClass&\n+    void funi(ref const ScopeClass!MyClassB); // mangles const MyClass&\n+    void funj(const(ScopeClass!MyClassB)*);\n+}\n+\n+version (CppMangle_Itanium)\n+{\n+    static assert(funf.mangleof == \"_ZN2ns4funfENS_8MyClassBE\");\n+    static assert(fung.mangleof == \"_ZN2ns4fungENS_8MyClassBE\");\n+    static assert(funh.mangleof == \"_ZN2ns4funhERNS_8MyClassBE\");\n+    static assert(funi.mangleof == \"_ZN2ns4funiERKNS_8MyClassBE\");\n+    static assert(funj.mangleof == \"_ZN2ns4funjEPKNS_8MyClassBE\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static assert(funf.mangleof == \"?funf@ns@@YAXVMyClassB@1@@Z\");\n+    static assert(fung.mangleof == \"?fung@ns@@YAXVMyClassB@1@@Z\");\n+    static if (size_t.sizeof == ulong.sizeof)\n+    {\n+        static assert(funh.mangleof == \"?funh@ns@@YAXAEAVMyClassB@1@@Z\");\n+        static assert(funi.mangleof == \"?funi@ns@@YAXAEBVMyClassB@1@@Z\");\n+        static assert(funj.mangleof == \"?funj@ns@@YAXPEBVMyClassB@1@@Z\");\n+    }\n+    else\n+    {\n+        static assert(funh.mangleof == \"?funh@ns@@YAXAAVMyClassB@1@@Z\");\n+        static assert(funi.mangleof == \"?funi@ns@@YAXABVMyClassB@1@@Z\");\n+        static assert(funj.mangleof == \"?funj@ns@@YAXPBVMyClassB@1@@Z\");\n+    }\n+}\n+\n+//Templates\n+extern(C++)\n+{\n+    void funTempl(T)();\n+    class MyClassC {}\n+    alias funTemplA = funTempl!(ScopeClass!MyClassC);\n+    alias funTemplB = funTempl!(const ScopeClass!MyClassC);\n+    alias funTemplC = funTempl!(const(ScopeClass!MyClassC)*);\n+    // N.B funTempl!([const] ref ScopeClass!MyClassC) is not permissable in D\n+}\n+version (CppMangle_Itanium)\n+{\n+    static assert(funTemplA.mangleof == \"_Z8funTemplI8MyClassCEvv\");\n+    static assert(funTemplB.mangleof == \"_Z8funTemplIK8MyClassCEvv\");\n+    static assert(funTemplC.mangleof == \"_Z8funTemplIPK8MyClassCEvv\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static assert(funTemplA.mangleof == \"??$funTempl@VMyClassC@@@@YAXXZ\");\n+    static assert(funTemplB.mangleof == \"??$funTempl@$$CBVMyClassC@@@@YAXXZ\");\n+    static if (size_t.sizeof == ulong.sizeof)\n+        static assert(funTemplC.mangleof == \"??$funTempl@PEBVMyClassC@@@@YAXXZ\");\n+    else\n+        static assert(funTemplC.mangleof == \"??$funTempl@PBVMyClassC@@@@YAXXZ\");\n+}\n+\n+template _function(F)\n+{\n+extern(C++, \"std\")\n+{\n+    extern(C++, struct)\n+    pragma(mangle, \"function\")\n+    class _function\n+    {\n+    }\n+}\n+}\n+template FunctionOf(F)\n+{\n+    F f;\n+    alias FunctionOf = typeof(*f);\n+}\n+extern(C++) void funk(ScopeClass!(_function!(FunctionOf!(void function(int))),\"function\") a ){ }\n+\n+version (CppMangle_Itanium)\n+{\n+    static assert(funk.mangleof == \"_Z4funkSt8functionIFviEE\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static assert(funk.mangleof == \"?funk@@YAXV?$function@$$A6AXH@Z@std@@@Z\");\n+}\n+\n+extern(C++, \"ns\")\n+{\n+    pragma(mangle, \"function\")\n+    class _function2\n+    {\n+        public final void test();\n+    }\n+}\n+\n+version (CppMangle_Itanium)\n+{\n+    static assert(_function2.test.mangleof == \"_ZN2ns8function4testEv\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static if (size_t.sizeof == ulong.sizeof)\n+        static assert(_function2.test.mangleof == \"?test@function@ns@@QEAAXXZ\");\n+    else\n+        static assert(_function2.test.mangleof == \"?test@function@ns@@QAEXXZ\");\n+}\n+\n+extern(C++, \"ns\")\n+{\n+    template _function3(T)\n+    {\n+        pragma(mangle, _function3, \"function\")\n+        class _function3\n+        {\n+            public final void test();\n+        }\n+    }\n+}\n+\n+version (CppMangle_Itanium)\n+{\n+    static assert(_function3!(int).test.mangleof == \"_ZN2ns8functionIiE4testEv\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static if (size_t.sizeof == ulong.sizeof)\n+        static assert(_function3!(int).test.mangleof == \"?test@?$function@H@ns@@QEAAXXZ\");\n+    else\n+        static assert(_function3!(int).test.mangleof == \"?test@?$function@H@ns@@QAEXXZ\");\n+}\n+\n+extern(C++)\n+{\n+    struct Foo {}\n+    pragma(mangle, Foo)  struct Foo_Doppelganger {}\n+\n+    void funl(Foo_Doppelganger f);\n+}\n+version (CppMangle_Itanium)\n+{\n+    static assert(funl.mangleof == \"_Z4funl3Foo\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    static assert(funl.mangleof == \"?funl@@YAXUFoo@@@Z\");\n+}"}, {"sha": "22eda6e3e02633c9552eb8a423107a1ec84fe7f3", "filename": "gcc/testsuite/gdc.test/compilable/issue21340.d", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21340.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21340.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21340.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,38 @@\n+version (CppRuntime_Clang) version = CppMangle_Itanium;\n+version (CppRuntime_Gcc)   version = CppMangle_Itanium;\n+version (CppRuntime_Sun)   version = CppMangle_Itanium;\n+\n+template ScopeClass(C)\n+if (is(C == class) && __traits(getLinkage, C) == \"C++\")\n+{\n+    \n+    extern(C++, class)\n+    extern(C++, __traits(getCppNamespaces,C))\n+    extern(C++, (ns))\n+    class ScopeClass { }\n+}\n+extern(C++) class Foo {}\n+extern(C++) void test(ScopeClass!Foo)\n+{\n+}\n+version(CppMangle_Itanium)\n+{\n+    static assert (test.mangleof == \"_Z4testP10ScopeClassIP3FooE\");\n+}\n+else version (CppRuntime_Microsoft)\n+{\n+    version (Win32)\n+    {\n+        static assert (test.mangleof == \"?test@@YAXPAV?$ScopeClass@PAVFoo@@@@@Z\");\n+    }\n+    version (Win64)\n+    {\n+        static assert (test.mangleof == \"?test@@YAXPEAV?$ScopeClass@PEAVFoo@@@@@Z\");\n+    }\n+}\n+alias AliasSeq(T...) = T;\n+alias ns = AliasSeq!();\n+immutable ns2 = AliasSeq!();\n+extern(C++,(ns)) class Bar {}\n+extern(C++,) class Baz {}\n+extern(C++, (ns2)) class Quux {} "}, {"sha": "4dc5523e3ebf3459327b7e339f751d0730a74dc7", "filename": "gcc/testsuite/gdc.test/compilable/test10028.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10028.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10028.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10028.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,7 @@\n+enum E:char[4]{ str = \"abcd\" }\n+enum x = {\n+    int[char[4]] aa;\n+    aa[E.str] = 1;\n+    foreach(key,val; aa) {}\n+    return aa[\"abcd\"];\n+}();"}, {"sha": "d50c874785cd18212ee5824a8db4019aabbdb320", "filename": "gcc/testsuite/gdc.test/compilable/test20236.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20236.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20236.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20236.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,22 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20236\n+\n+/*\n+TEST_OUTPUT:\n+---\n+---\n+*/\n+\n+struct X\n+{\n+    alias y this;\n+    deprecated int y() { return 5; }\n+    int x() { return 5; }\n+}\n+\n+void main()\n+{\n+    static void func(int) {}\n+    with(X.init) {\n+        func(x);\n+    }\n+}"}, {"sha": "78b9ddd64cec31bb0eb1ce7291b317d0cc9e3e91", "filename": "gcc/testsuite/gdc.test/compilable/test20860.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20860.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20860.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20860.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20860\n+\n+struct A\n+{\n+    this(int a) {}\n+  ///\n+  void opDispatch(string methodName, Params...)(Params params) {\n+  }\n+\n+  ~this() {}\n+}\n+\n+void main()\n+{\n+    A(3).test();\n+}"}, {"sha": "47d788128b3b760c7f52367b84189b0ca19b4855", "filename": "gcc/testsuite/gdc.test/compilable/test21073.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21073.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21073\n+\n+class C\n+{\n+    auto internal() const\n+    {\n+        return 5;\n+    }\n+    alias internal this;\n+}\n+\n+void main() pure\n+{\n+    const c = new C;\n+    auto r = cast(C)c;\n+}"}, {"sha": "e8a201cfb1c8c79104d1d61984939c6108c0d40b", "filename": "gcc/testsuite/gdc.test/compilable/test21414.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21414.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21414.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21414.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21414\n+\n+struct State\n+{\n+    string s;\n+\n+    immutable this(string s)\n+    {\n+        this.s = s;\n+    }\n+}\n+\n+immutable rootState = new immutable State(\"b\");"}, {"sha": "15f362bc885eb30700c60082ea7ea4da68753492", "filename": "gcc/testsuite/gdc.test/fail_compilation/b15875.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb15875.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb15875.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb15875.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,6 +1,6 @@\n /* TEST_OUTPUT:\n ---\n-fail_compilation/b15875.d(9): Error: circular reference to variable `a`\n+fail_compilation/b15875.d(9): Error: undefined identifier `a`\n fail_compilation/b15875.d(10): Error: circular reference to `b15875.f`\n ---\n */"}, {"sha": "64f225d099413fec9958e45c21789fb19ad0b6fb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail116.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail116.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail116.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail116.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail116.d(11): Error: circular `typeof` definition\n+fail_compilation/fail116.d(11): Error: undefined identifier `x`\n fail_compilation/fail116.d(16): Error: template instance `square!1.2` does not match template declaration `square(_error_ x)`\n ---\n */"}, {"sha": "0f76e315ac741593c80c03fa18944c34374bdfce", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20616.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20616.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20616.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20616.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,26 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail20616.d(16): Error: undefined identifier `$`\n+fail_compilation/fail20616.d(16):        Aggregate declaration 'X()' does not define 'opDollar'\n+fail_compilation/fail20616.d(18): Error: undefined identifier `$`\n+fail_compilation/fail20616.d(18):        Aggregate declaration 'b' does not define 'opDollar'\n+---\n+*/\n+module fail20616;\n+\n+void g() {\n+    struct X {\n+        auto opSlice(size_t a, size_t b) { return \"\"; }\n+    }\n+    auto x = X()[0 .. $];\n+    auto b = X();\n+    auto c = b[0 .. $ - 1];\n+    auto v = [1, 2, 3];\n+    auto d = v[$.. $];\n+}\n+\n+int main() {\n+    g();\n+    return 0;\n+}"}, {"sha": "3bec3c0f7d3d27a5152a014256ae51f10fe01d39", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22529.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22529.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22529.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22529.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22529\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22529.d(13): Error: found `return` when expecting `;` following statement\n+---\n+*/\n+\n+void main()\n+{\n+    foo()\n+    return;\n+}"}, {"sha": "cb8c286650d08abb8daa4aa3d71b5a51fcdcae2a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22570.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22570.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22570\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22570.d(19): Error: more initializers than fields (1) of `S`\n+fail_compilation/fail22570.d(20): Error: more initializers than fields (1) of `S`\n+---\n+*/\n+\n+struct S\n+{\n+    Object o1;\n+}\n+\n+void main() @safe\n+{\n+    S[] s;\n+    s = [S(null, null)];\n+    s ~= S(null, null);\n+}"}, {"sha": "1c71f38d23aee868dc43e61b0c465fce07a2d38c", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice22516.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22516.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22516.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice22516.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,21 @@\n+/++\n+https://issues.dlang.org/show_bug.cgi?id=22516\n+\n+TEST_OUTPUT:\n+---\n+fail_compilation/ice22516.d(18): Error: undefined identifier `X`\n+---\n++/\n+\n+struct Data\n+{\n+    void function() eval;\n+\n+}\n+\n+struct Builtins\n+{\n+    X x;\n+\n+    Data myData = { (){} };\n+}"}, {"sha": "2a7b8849816b81b3ee12bc33f16b3e2b06b73fc0", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22574.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22574.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22574.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22574.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,12 @@\n+//https://issues.dlang.org/show_bug.cgi?id=22574\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22574.d(100): Error: undefined identifier `x`\n+---\n+*/\n+#line 100\n+template test(x* x)\n+{\n+\n+}"}, {"sha": "a0d1d122e630a9bab361bece158dcc2df1d84ee2", "filename": "gcc/testsuite/gdc.test/fail_compilation/test_switch_error.d", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest_switch_error.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,101 @@\n+/++\n+https://issues.dlang.org/show_bug.cgi?id=22514\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(13): Error: undefined identifier `doesNotExist`\n+fail_compilation/test_switch_error.d(16): Error: undefined identifier `alsoDoesNotExits`\n+fail_compilation/test_switch_error.d(19): Error: duplicate `case 2` in `switch` statement\n+---\n+++/\n+\n+void test1()\n+{\n+    switch (doesNotExist)\n+    {\n+        case 1:\n+            alsoDoesNotExits();\n+            break;\n+        case 2: break;\n+        case 2: break;\n+    }\n+}\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(105): Error: undefined identifier `doesNotExist`\n+---\n+++/\n+#line 100\n+\n+enum foo = 1;\n+\n+void test2()\n+{\n+    switch (doesNotExist)\n+    {\n+        case foo: break;\n+    }\n+}\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(206): Error: undefined identifier `a`\n+fail_compilation/test_switch_error.d(207): Error: undefined identifier `b`\n+---\n+++/\n+#line 200\n+\n+void test3()\n+{\n+\n+    switch (1)\n+    {\n+        case a: break;\n+        case b: break;\n+    }\n+}\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(303): Error: undefined identifier `doesNotExits`\n+---\n+++/\n+#line 300\n+\n+void test4()\n+{\n+    auto foo = doesNotExits();\n+    switch (1)\n+    {\n+        case foo: break;\n+        case foo: break;\n+    }\n+}\n+\n+/++\n+TEST_OUTPUT:\n+---\n+fail_compilation/test_switch_error.d(405): Error: `case` variables have to be `const` or `immutable`\n+fail_compilation/test_switch_error.d(412): Error: `case` variables not allowed in `final switch` statements\n+---\n+++/\n+#line 400\n+\n+void test5(int i)\n+{\n+    switch (i)\n+    {\n+        case i: break;\n+        default: break;\n+    }\n+\n+    const int j = i;\n+    final switch (i)\n+    {\n+        case j: break;\n+\n+    }\n+}"}, {"sha": "d8059d32a91cca1f0f581e66eeaf0ceeacafb039", "filename": "gcc/testsuite/gdc.test/runnable/interpret.d", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Finterpret.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -3660,6 +3660,28 @@ void test20133()\n     auto rtest2 = fun20133_2();\n }\n \n+/************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22530\n+\n+class D22530 { }\n+\n+class C22530\n+{\n+    D22530 y = new D22530;\n+    alias y this;\n+}\n+\n+void test22530()\n+{\n+    // fixed\n+    static assert(cast(D22530)(new C22530) is null);\n+    static assert((1 ? cast(D22530)(new C22530) : new D22530) is null);\n+\n+    // runtime version already works\n+    assert(cast(D22530)(new C22530) is null);\n+    assert((1 ? cast(D22530)(new C22530) : new D22530) is null);\n+}\n+\n /************************************************/\n \n int main()\n@@ -3789,6 +3811,7 @@ int main()\n     test20400();\n     test21878();\n     test20133();\n+    test22530();\n \n     printf(\"Success\\n\");\n     return 0;"}, {"sha": "e42ead9b99c9f47e8ddd3f83cf0fb265239e787b", "filename": "gcc/testsuite/gdc.test/runnable/test16579.d", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16579.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16579.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest16579.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,57 @@\n+// REQUIRED_ARGS: -unittest\n+// PERMUTE_ARGS:\n+// https://issues.dlang.org/show_bug.cgi?id=16579\n+\n+struct Thing\n+{\n+    enum Instance = Thing();\n+    int a = 42;\n+\n+    void iter()\n+    {\n+        assert(this.a == 42);\n+    }\n+}\n+\n+void main()\n+{\n+    return Thing.Instance.iter;   // Added 'return'\n+}\n+\n+// From https://issues.dlang.org/show_bug.cgi?id=16576\n+\n+alias a = test2!();\n+alias b = test3!();\n+\n+\n+template test2()\n+{\n+    struct Thing{\n+        static enum Instance = Thing([0, 1, 2, 3]);\n+        int[] array;\n+        void iter(in string str) const{\n+            foreach(j, tup; this.array) assert(tup == j);\n+            assert(this.array && this.array.length == 4);\n+        }\n+    }\n+    unittest{\n+        auto test(in string str){return Thing.Instance.iter(str);}\n+        test(\"?\");\n+    }\n+}\n+\n+template test3()\n+{\n+    struct Thing{\n+        static enum Instance = Thing([0, 1, 2, 3]);\n+        int[] array;\n+        void iter() const{\n+            foreach(j, tup; this.array) assert(tup == j);\n+            assert(this.array && this.array.length == 4);\n+        }\n+    }\n+    unittest{\n+        auto test(){return Thing.Instance.iter();}\n+        test();\n+    }\n+}"}, {"sha": "610dff11e7ac67d51f8b1d8a6c7a35640e31b235", "filename": "gcc/testsuite/gdc.test/runnable/test18054.d", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18054.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18054.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18054.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,41 @@\n+/+\n+REQUIRED_ARGS: -d\n+RUN_OUTPUT:\n+---\n+float: 1 == 1\n+double: 1 == 1\n+real: 1 == 1\n+ifloat: 1 == 1\n+idouble: 1 == 1\n+ireal: 1 == 1\n+cfloat: 1 == 1\n+cdouble: 1 == 1\n+creal: 1 == 1\n+---\n++/\n+\n+import core.stdc.stdio : printf;\n+\n+void test(T, string lit)()\n+{\n+    T d = mixin(lit);\n+    bool runtime = cast(bool) d;\n+    bool folded  = cast(bool) mixin(lit);\n+\n+    printf((T.stringof ~ \": %d == %d\\n\\0\").ptr, runtime, folded);\n+}\n+\n+void main()\n+{\n+    test!(float,  \"0.5f\");\n+    test!(double, \"0.5\" );\n+    test!(real,   \"0.5L\");\n+\n+    test!(ifloat,  \"0.5i\");\n+    test!(idouble, \"0.5i\");\n+    test!(ireal,   \"0.5i\");\n+\n+    test!(cfloat,  \"0.3 + 0.5i\");\n+    test!(cdouble, \"0.3 + 0.5i\");\n+    test!(creal,   \"0.3 + 0.5i\");\n+}"}, {"sha": "c60d6c66ef31476abcdf2b8c6a9d01484d9f5d4f", "filename": "gcc/testsuite/gdc.test/runnable_cxx/cppa.d", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -442,28 +442,54 @@ void test13161()\n \n version (linux)\n {\n-    extern(C++, __gnu_cxx)\n+    static if (__traits(getTargetInfo, \"cppStd\") < 201703)\n     {\n-        struct new_allocator(T)\n+        // See note on std::allocator below.\n+        extern(C++, __gnu_cxx)\n         {\n-            alias size_type = size_t;\n-            static if (is(T : char))\n-                void deallocate(T*, size_type) { }\n-            else\n-                void deallocate(T*, size_type);\n+            struct new_allocator(T)\n+            {\n+                alias size_type = size_t;\n+                static if (is(T : char))\n+                    void deallocate(T*, size_type) { }\n+                else\n+                    void deallocate(T*, size_type);\n+            }\n         }\n     }\n }\n \n extern (C++, std)\n {\n+    version (linux)\n+    {\n+        static if (__traits(getTargetInfo, \"cppStd\") >= 201703)\n+        {\n+            // std::allocator no longer derives from __gnu_cxx::new_allocator,\n+            // it derives from std::__new_allocator instead. \n+            struct __new_allocator(T)\n+            {\n+                alias size_type = size_t;\n+                static if (is(T : char))\n+                    void deallocate(T*, size_type) { }\n+                else\n+                    void deallocate(T*, size_type);\n+            }\n+        }\n+    }\n+\n     extern (C++, class) struct allocator(T)\n     {\n         version (linux)\n         {\n             alias size_type = size_t;\n             void deallocate(T* p, size_type sz)\n-            {   (cast(__gnu_cxx.new_allocator!T*)&this).deallocate(p, sz); }\n+            {\n+                static if (__traits(getTargetInfo, \"cppStd\") >= 201703)\n+                    (cast(std.__new_allocator!T*)&this).deallocate(p, sz);\n+                else\n+                    (cast(__gnu_cxx.new_allocator!T*)&this).deallocate(p, sz);\n+            }\n         }\n     }\n \n@@ -476,12 +502,21 @@ extern (C++, std)\n     {\n     }\n \n-    // https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html\n-    version (none)\n+    version (CppRuntime_Gcc)\n     {\n-        extern (C++, __cxx11)\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html\n+        static if (__traits(getTargetInfo, \"cppStd\") >= 201103)\n+        {\n+            extern (C++, __cxx11)\n+            {\n+                struct basic_string(T, C = char_traits!T, A = allocator!T)\n+                {\n+                }\n+            }\n+        }\n+        else\n         {\n-            struct basic_string(T, C = char_traits!T, A = allocator!T)\n+            extern (C++, class) struct basic_string(T, C = char_traits!T, A = allocator!T)\n             {\n             }\n         }"}, {"sha": "ea4fb1c8a0eb02d43358536502c598906216cb59", "filename": "gcc/testsuite/gdc.test/runnable_cxx/extra-files/cppb.cpp", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fextra-files%2Fcppb.cpp?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,36 +1,3 @@\n-/*\n-GCC 5.1 introduced new implementations of std::string and std::list:\n-\n-https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html\n-\n-This causes e.g. std::string to be actually defined as\n-std::__cxx11::string.\n-\n-On machines with GCC 5.1, this manifests as a linker error when\n-running the cppa.d / cppb.cpp test:\n-\n-cppa.o: In function `_D4cppa6test14FZv':\n-cppa.d:(.text._D4cppa6test14FZv+0x11): undefined reference to `foo14a(std::string*)'\n-cppa.d:(.text._D4cppa6test14FZv+0x18): undefined reference to `foo14b(std::basic_string<int, std::char_traits<int>, std::allocator<int> >*)'\n-cppa.d:(.text._D4cppa6test14FZv+0x3a): undefined reference to `foo14f(std::char_traits<char>*, std::string*, std::string*)'\n-cppa.o: In function `_D4cppa7testeh3FZv':\n-cppa.d:(.text._D4cppa7testeh3FZv+0x19): undefined reference to `throwle()'\n-collect2: error: ld returned 1 exit status\n---- errorlevel 1\n-\n-When the .cpp file is compiled with g++ 5.3.0, the actual function\n-signatures in the cppb.o object file are:\n-\n-foo14a(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)\n-foo14b(std::__cxx11::basic_string<int, std::char_traits<int>, std::allocator<int> >*)\n-foo14f(std::char_traits<char>*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >*)\n-\n-Fortunately, it is easily possible to disable the new feature\n-by defining _GLIBCXX_USE_CXX11_ABI as 0 before including any standard\n-headers.\n-*/\n-#define _GLIBCXX_USE_CXX11_ABI 0\n-\n #include <stdio.h>\n #include <stdint.h>\n #include <assert.h>"}, {"sha": "17b265655052e43ba58c08d2d0dfac94650209a2", "filename": "libphobos/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fconfigure?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -15566,7 +15566,7 @@ SPEC_PHOBOS_DEPS=\"$LIBS\"\n \n \n # Libdruntime / phobos soname version\n-libtool_VERSION=2:0:0\n+libtool_VERSION=3:0:0\n \n \n # Set default flags (after DRUNTIME_WERROR!)"}, {"sha": "c961e68105a8848d0ced45dd28172aece747767b", "filename": "libphobos/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fconfigure.ac?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -265,7 +265,7 @@ SPEC_PHOBOS_DEPS=\"$LIBS\"\n AC_SUBST(SPEC_PHOBOS_DEPS)\n \n # Libdruntime / phobos soname version\n-libtool_VERSION=2:0:0\n+libtool_VERSION=3:0:0\n AC_SUBST(libtool_VERSION)\n \n # Set default flags (after DRUNTIME_WERROR!)"}, {"sha": "b3da9063ce3c7e546819d048c885030e42410a46", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,4 +1,4 @@\n-bc58b1e9ea68051af9094651a26313371297b79f\n+6364e010bc87f3621028c8ac648133535c126fb3\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "0d733f2b384aefab3acefba390fed2ff7a31c5ab", "filename": "libphobos/libdruntime/core/internal/traits.d", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Ftraits.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -185,22 +185,38 @@ template dtorIsNothrow(T)\n }\n \n // taken from std.meta.allSatisfy\n-enum allSatisfy(alias pred, items...) =\n+template allSatisfy(alias F, T...)\n {\n-    static foreach (item; items)\n-        static if (!pred!item)\n-            if (__ctfe) return false;\n-    return true;\n-}();\n+    static foreach (Ti; T)\n+    {\n+        static if (!is(typeof(allSatisfy) == bool) && // not yet defined\n+                   !F!(Ti))\n+        {\n+            enum allSatisfy = false;\n+        }\n+    }\n+    static if (!is(typeof(allSatisfy) == bool)) // if not yet defined\n+    {\n+        enum allSatisfy = true;\n+    }\n+}\n \n // taken from std.meta.anySatisfy\n-enum anySatisfy(alias pred, items...) =\n+template anySatisfy(alias F, Ts...)\n {\n-    static foreach (item; items)\n-        static if (pred!item)\n-            if (__ctfe) return true;\n-    return false;\n-}();\n+    static foreach (T; Ts)\n+    {\n+        static if (!is(typeof(anySatisfy) == bool) && // not yet defined\n+                   F!T)\n+        {\n+            enum anySatisfy = true;\n+        }\n+    }\n+    static if (!is(typeof(anySatisfy) == bool)) // if not yet defined\n+    {\n+        enum anySatisfy = false;\n+    }\n+}\n \n // simplified from std.traits.maxAlignment\n template maxAlignment(Ts...)"}, {"sha": "8fb61a547d5062ff5ea52112e94dcb4cc19d99d5", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 89, "deletions": 20, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -2111,9 +2111,6 @@ private T trustedMoveImpl(T)(return scope ref T source) @trusted\n // target must be first-parameter, because in void-functions DMD + dip1000 allows it to take the place of a return-scope\n private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n {\n-    import core.stdc.string : memcpy, memset;\n-    import core.internal.traits;\n-\n     // TODO: this assert pulls in half of phobos. we need to work out an alternative assert strategy.\n //    static if (!is(T == class) && hasAliasing!T) if (!__ctfe)\n //    {\n@@ -2124,11 +2121,16 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n \n     static if (is(T == struct))\n     {\n+        import core.internal.traits;\n+\n         //  Unsafe when compiling without -preview=dip1000\n         assert((() @trusted => &source !is &target)(), \"source and target must not be identical\");\n \n         static if (hasElaborateAssign!T || !isAssignable!T)\n+        {\n+            import core.stdc.string : memcpy;\n             () @trusted { memcpy(&target, &source, T.sizeof); }();\n+        }\n         else\n             target = source;\n \n@@ -2146,15 +2148,21 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n                 enum sz = T.sizeof;\n \n             static if (__traits(isZeroInit, T))\n+            {\n+                import core.stdc.string : memset;\n                 () @trusted { memset(&source, 0, sz); }();\n+            }\n             else\n+            {\n+                import core.stdc.string : memcpy;\n                 () @trusted { memcpy(&source, __traits(initSymbol, T).ptr, sz); }();\n+            }\n         }\n     }\n     else static if (__traits(isStaticArray, T))\n     {\n         for (size_t i = 0; i < source.length; ++i)\n-            move(source[i], target[i]);\n+            moveEmplaceImpl(target[i], source[i]);\n     }\n     else\n     {\n@@ -2204,6 +2212,34 @@ pure nothrow @nogc @system unittest\n     assert(val == 0);\n }\n \n+@betterC\n+pure nothrow @nogc @system unittest\n+{\n+    static struct Foo\n+    {\n+    pure nothrow @nogc:\n+        this(int* ptr) { _ptr = ptr; }\n+        ~this() { if (_ptr) ++*_ptr; }\n+        int* _ptr;\n+    }\n+\n+    int val;\n+    {\n+        Foo[1] foo1 = void; // uninitialized\n+        Foo[1] foo2 = [Foo(&val)];// initialized\n+        assert(foo2[0]._ptr is &val);\n+\n+        // Using `move(foo2, foo1)` would have an undefined effect because it would destroy\n+        // the uninitialized foo1.\n+        // moveEmplace directly overwrites foo1 without destroying or initializing it first.\n+        moveEmplace(foo2, foo1);\n+        assert(foo1[0]._ptr is &val);\n+        assert(foo2[0]._ptr is null);\n+        assert(val == 0);\n+    }\n+    assert(val == 1);\n+}\n+\n // issue 18913\n @safe unittest\n {\n@@ -2222,17 +2258,10 @@ pure nothrow @nogc @system unittest\n     f(move(ncarray));\n }\n \n-/**\n- * This is called for a delete statement where the value\n- * being deleted is a pointer to a struct with a destructor\n- * but doesn't have an overloaded delete operator.\n- *\n- * Params:\n- *   p = pointer to the value to be deleted\n- */\n-void _d_delstruct(T)(ref T *p)\n+/// Implementation of `_d_delstruct` and `_d_delstructTrace`\n+template _d_delstructImpl(T)\n {\n-    if (p)\n+    private void _d_delstructImpure(ref T p)\n     {\n         debug(PRINTF) printf(\"_d_delstruct(%p)\\n\", p);\n \n@@ -2242,21 +2271,61 @@ void _d_delstruct(T)(ref T *p)\n         GC.free(p);\n         p = null;\n     }\n+\n+    /**\n+     * This is called for a delete statement where the value being deleted is a\n+     * pointer to a struct with a destructor but doesn't have an overloaded\n+     * `delete` operator.\n+     *\n+     * Params:\n+     *   p = pointer to the value to be deleted\n+     *\n+     * Bugs:\n+     *   This function template was ported from a much older runtime hook that\n+     *   bypassed safety, purity, and throwabilty checks. To prevent breaking\n+     *   existing code, this function template is temporarily declared\n+     *   `@trusted` until the implementation can be brought up to modern D\n+     *   expectations.\n+     */\n+    void _d_delstruct(ref T p) @trusted @nogc pure nothrow\n+    {\n+        if (p)\n+        {\n+            alias Type = void function(ref T P) @nogc pure nothrow;\n+            (cast(Type) &_d_delstructImpure)(p);\n+        }\n+    }\n+\n+    import core.internal.array.utils : _d_HookTraceImpl;\n+\n+    private enum errorMessage = \"Cannot delete struct if compiling without support for runtime type information!\";\n+\n+    /**\n+     * TraceGC wrapper around $(REF _d_delstruct, core,lifetime,_d_delstructImpl).\n+     *\n+     * Bugs:\n+     *   This function template was ported from a much older runtime hook that\n+     *   bypassed safety, purity, and throwabilty checks. To prevent breaking\n+     *   existing code, this function template is temporarily declared\n+     *   `@trusted` until the implementation can be brought up to modern D\n+     *   expectations.\n+     */\n+    alias _d_delstructTrace = _d_HookTraceImpl!(T, _d_delstruct, errorMessage);\n }\n \n-@system unittest\n+@system pure nothrow unittest\n {\n     int dtors = 0;\n     struct S { ~this() { ++dtors; } }\n \n     S *s = new S();\n-    _d_delstruct(s);\n+    _d_delstructImpl!(typeof(s))._d_delstruct(s);\n \n     assert(s == null);\n     assert(dtors == 1);\n }\n \n-@system unittest\n+@system pure unittest\n {\n     int innerDtors = 0;\n     int outerDtors = 0;\n@@ -2277,16 +2346,16 @@ void _d_delstruct(T)(ref T *p)\n         {\n             ++outerDtors;\n \n-            _d_delstruct(i1);\n+            _d_delstructImpl!(typeof(i1))._d_delstruct(i1);\n             assert(i1 == null);\n \n-            _d_delstruct(i2);\n+           _d_delstructImpl!(typeof(i2))._d_delstruct(i2);\n             assert(i2 == null);\n         }\n     }\n \n     Outer *o = new Outer(0);\n-    _d_delstruct(o);\n+    _d_delstructImpl!(typeof(o))._d_delstruct(o);\n \n     assert(o == null);\n     assert(innerDtors == 2);"}, {"sha": "81d2d261a807b34bee56a48088c8c8c36020edfa", "filename": "libphobos/libdruntime/core/runtime.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fruntime.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -798,7 +798,7 @@ else static if (hasExecinfo) private class DefaultTraceInfo : Throwable.TraceInf\n         enum CALL_INSTRUCTION_SIZE = 1;\n \n         static if (__traits(compiles, backtrace((void**).init, int.init)))\n-            numframes = backtrace(this.callstack.ptr, MAXFRAMES);\n+            numframes = cast(int) backtrace(this.callstack.ptr, MAXFRAMES);\n         // Backtrace succeeded, adjust the frame to point to the caller\n         if (numframes >= 2)\n             foreach (ref elem; this.callstack)"}, {"sha": "cd9cd166e573d79269ab0d3d4a3d4694dae6162d", "filename": "libphobos/libdruntime/core/sys/openbsd/execinfo.d", "status": "modified", "additions": 6, "deletions": 133, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fexecinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fexecinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fexecinfo.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -11,137 +11,10 @@ module core.sys.openbsd.execinfo;\n version (OpenBSD):\n extern (C):\n nothrow:\n+@nogc:\n \n-version (GNU)\n-    version = BacktraceExternal;\n-\n-version (BacktraceExternal)\n-{\n-    size_t backtrace(void**, size_t);\n-    char** backtrace_symbols(const(void*)*, size_t);\n-    void backtrace_symbols_fd(const(void*)*, size_t, int);\n-    char** backtrace_symbols_fmt(const(void*)*, size_t, const char*);\n-    int backtrace_symbols_fd_fmt(const(void*)*, size_t, int, const char*);\n-}\n-else\n-{\n-    import core.sys.openbsd.dlfcn;\n-\n-    // Use extern (D) so that these functions don't collide with libexecinfo.\n-\n-    extern (D) int backtrace(void** buffer, int size)\n-    {\n-        import core.thread : thread_stackBottom;\n-\n-        void** p, pend=cast(void**)thread_stackBottom();\n-        version (D_InlineAsm_X86)\n-            asm nothrow @trusted { mov p[EBP], EBP; }\n-        else version (D_InlineAsm_X86_64)\n-            asm nothrow @trusted { mov p[RBP], RBP; }\n-        else\n-            static assert(false, \"Architecture not supported.\");\n-\n-        int i;\n-        for (; i < size && p < pend; ++i)\n-        {\n-            buffer[i] = *(p + 1);\n-            auto pnext = cast(void**)*p;\n-            if (pnext <= p) break;\n-            p = pnext;\n-        }\n-        return i;\n-    }\n-\n-\n-    extern (D) char** backtrace_symbols(const(void*)* buffer, int size)\n-    {\n-        static void* realloc(void* p, size_t len) nothrow\n-        {\n-            static import cstdlib=core.stdc.stdlib;\n-            auto res = cstdlib.realloc(p, len);\n-            if (res is null) cstdlib.free(p);\n-            return res;\n-        }\n-\n-        if (size <= 0) return null;\n-\n-        size_t pos = size * (char*).sizeof;\n-        char** p = cast(char**)realloc(null, pos);\n-        if (p is null) return null;\n-\n-        Dl_info info;\n-        foreach (i, addr; buffer[0 .. size])\n-        {\n-            if (dladdr(addr, &info) == 0)\n-                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-            fixupDLInfo(addr, info);\n-\n-            immutable len = formatStackFrame(null, 0, addr, info);\n-            assert(len > 0);\n-\n-            p = cast(char**)realloc(p, pos + len);\n-            if (p is null) return null;\n-\n-            formatStackFrame(cast(char*)p + pos, len, addr, info) == len || assert(0);\n-\n-            p[i] = cast(char*)pos;\n-            pos += len;\n-        }\n-        foreach (i; 0 .. size)\n-        {\n-            pos = cast(size_t)p[i];\n-            p[i] = cast(char*)p + pos;\n-        }\n-        return p;\n-    }\n-\n-\n-    extern (D) void backtrace_symbols_fd(const(void*)* buffer, int size, int fd)\n-    {\n-        import core.sys.posix.unistd : write;\n-        import core.stdc.stdlib : alloca;\n-\n-        if (size <= 0) return;\n-\n-        Dl_info info;\n-        foreach (i, addr; buffer[0 .. size])\n-        {\n-            if (dladdr(addr, &info) == 0)\n-                (cast(ubyte*)&info)[0 .. info.sizeof] = 0;\n-            fixupDLInfo(addr, info);\n-\n-            enum maxAlloca = 1024;\n-            enum min = (size_t a, size_t b) => a <= b ? a : b;\n-            immutable len = min(formatStackFrame(null, 0, addr, info), maxAlloca);\n-            assert(len > 0);\n-\n-            auto p = cast(char*)alloca(len);\n-            if (p is null) return;\n-\n-            formatStackFrame(p, len, addr, info) >= len || assert(0);\n-            p[len - 1] = '\\n';\n-            write(fd, p, len);\n-        }\n-    }\n-\n-\n-    private void fixupDLInfo(const(void)* addr, ref Dl_info info)\n-    {\n-        if (info.dli_fname is null) info.dli_fname = \"???\";\n-        if (info.dli_fbase is null) info.dli_fbase = null;\n-        if (info.dli_sname is null) info.dli_sname = \"???\";\n-        if (info.dli_saddr is null) info.dli_saddr = cast(void*)addr;\n-    }\n-\n-\n-    private size_t formatStackFrame(char* p, size_t plen, const(void)* addr, const ref Dl_info info)\n-    {\n-        import core.stdc.stdio : snprintf;\n-\n-        immutable off = addr - info.dli_saddr;\n-        immutable len = snprintf(p, plen, \"%p <%s+%zd> at %s\",\n-                                 addr, info.dli_sname, off, info.dli_fname);\n-        assert(len > 0);\n-        return cast(size_t)len + 1; // + '\\0'\n-    }\n-}\n+size_t backtrace(void**, size_t);\n+char** backtrace_symbols(const(void*)*, size_t);\n+void backtrace_symbols_fd(const(void*)*, size_t, int);\n+char** backtrace_symbols_fmt(const(void*)*, size_t, const char*);\n+int backtrace_symbols_fd_fmt(const(void*)*, size_t, int, const char*);"}, {"sha": "7d0b1708e2ddb4a516527bc303ee11e277104b28", "filename": "libphobos/libdruntime/core/sys/posix/sys/stat.d", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -340,26 +340,23 @@ version (CRuntime_Glibc)\n             }\n             c_long[14]  st_pad5;\n         }\n+        static if (!__USE_FILE_OFFSET64)\n+            static assert(stat_t.sizeof == 144);\n+        else\n+            static assert(stat_t.sizeof == 160);\n     }\n     else version (MIPS64)\n     {\n         struct stat_t\n         {\n-            c_ulong     st_dev;\n+            dev_t       st_dev;\n             int[3]      st_pad1;\n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                ino_t       st_ino;\n-            }\n-            else\n-            {\n-                c_ulong     st_ino;\n-            }\n+            ino_t       st_ino;\n             mode_t      st_mode;\n             nlink_t     st_nlink;\n             uid_t       st_uid;\n             gid_t       st_gid;\n-            c_ulong     st_rdev;\n+            dev_t       st_rdev;\n             static if (!__USE_FILE_OFFSET64)\n             {\n                 uint[2]     st_pad2;\n@@ -368,8 +365,8 @@ version (CRuntime_Glibc)\n             }\n             else\n             {\n-                c_long[3]   st_pad2;\n-                c_long      st_size;\n+                uint[3]     st_pad2;\n+                off_t       st_size;\n             }\n             static if (__USE_MISC || __USE_XOPEN2K8)\n             {\n@@ -394,15 +391,26 @@ version (CRuntime_Glibc)\n             }\n             blksize_t   st_blksize;\n             uint        st_pad4;\n+            blkcnt_t    st_blocks;\n+            int[14]     st_pad5;\n+        }\n+        version (MIPS_N32)\n+        {\n             static if (!__USE_FILE_OFFSET64)\n-            {\n-                blkcnt_t    st_blocks;\n-            }\n+                static assert(stat_t.sizeof == 160);\n             else\n-            {\n-                c_long  st_blocks;\n-            }\n-            c_long[14]  st_pad5;\n+                static assert(stat_t.sizeof == 176);\n+        }\n+        else version (MIPS_O64)\n+        {\n+            static if (!__USE_FILE_OFFSET64)\n+                static assert(stat_t.sizeof == 160);\n+            else\n+                static assert(stat_t.sizeof == 176);\n+        }\n+        else\n+        {\n+            static assert(stat_t.sizeof == 216);\n         }\n     }\n     else version (PPC)"}, {"sha": "29b5d58de5b6507083bf9253dfbdff5512798d65", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -4651,7 +4651,7 @@ public import core.internal.array.construction : _d_arrayctor;\n public import core.internal.array.construction : _d_arraysetctor;\n public import core.internal.array.capacity: _d_arraysetlengthTImpl;\n \n-public import core.lifetime : _d_delstruct;\n+public import core.lifetime : _d_delstructImpl;\n \n public import core.internal.dassert: _d_assert_fail;\n "}, {"sha": "0f1d0e9700448d85cba2ed992a76151753d820b7", "filename": "libphobos/libdruntime/rt/monitor_.d", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fmonitor_.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -6,10 +6,6 @@\n  * Authors:   Walter Bright, Sean Kelly, Martin Nowak\n  * Source: $(DRUNTIMESRC rt/_monitor_.d)\n  */\n-\n-/* NOTE: This file has been patched from the original DMD distribution to\n- * work with the GDC compiler.\n- */\n module rt.monitor_;\n \n import core.atomic, core.stdc.stdlib, core.stdc.string;\n@@ -175,37 +171,7 @@ package:\n alias IMonitor = Object.Monitor;\n alias DEvent = void delegate(Object);\n \n-version (GNU)\n-{\n-    import gcc.config;\n-    static if (GNU_Thread_Model == ThreadModel.Single)\n-        version = SingleThreaded;\n-    // Ignore ThreadModel, we don't want posix threads on windows and\n-    // will always use native threading instead.\n-}\n-\n-version (SingleThreaded)\n-{\n-@nogc:\n-    alias Mutex = int;\n-\n-    void initMutex(Mutex* mtx)\n-    {\n-    }\n-\n-    void destroyMutex(Mutex* mtx)\n-    {\n-    }\n-\n-    void lockMutex(Mutex* mtx)\n-    {\n-    }\n-\n-    void unlockMutex(Mutex* mtx)\n-    {\n-    }\n-}\n-else version (Windows)\n+version (Windows)\n {\n     version (CRuntime_DigitalMars)\n     {"}, {"sha": "c9d166b03a7c298bdc507ae30bd2cd328b3fcec2", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -1,4 +1,4 @@\n-12329adb67fb43891d6e4e543e7257bc34db0aa7\n+575b67a9b4f78415f96ca77ad50b2de4c667cc74\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "55a14385e8ab7a5771914c223aa654a43e38e60d", "filename": "libphobos/src/std/algorithm/searching.d", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -638,7 +638,7 @@ Returns:\n */\n size_t count(alias pred = \"a == b\", Range, E)(Range haystack, E needle)\n if (isInputRange!Range && !isInfinite!Range &&\n-    is(typeof(binaryFun!pred(haystack.front, needle)) : bool))\n+    is(typeof(binaryFun!pred(haystack.front, needle))))\n {\n     bool pred2(ElementType!Range a) { return binaryFun!pred(a, needle); }\n     return count!pred2(haystack);\n@@ -693,7 +693,7 @@ if (isInputRange!Range && !isInfinite!Range &&\n size_t count(alias pred = \"a == b\", R1, R2)(R1 haystack, R2 needle)\n if (isForwardRange!R1 && !isInfinite!R1 &&\n     isForwardRange!R2 &&\n-    is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool))\n+    is(typeof(binaryFun!pred(haystack.front, needle.front))))\n {\n     assert(!needle.empty, \"Cannot count occurrences of an empty range\");\n \n@@ -716,7 +716,7 @@ if (isForwardRange!R1 && !isInfinite!R1 &&\n /// Ditto\n size_t count(alias pred, R)(R haystack)\n if (isInputRange!R && !isInfinite!R &&\n-    is(typeof(unaryFun!pred(haystack.front)) : bool))\n+    is(typeof(unaryFun!pred(haystack.front))))\n {\n     size_t result;\n     alias T = ElementType!R; //For narrow strings forces dchar iteration\n@@ -745,6 +745,12 @@ if (isInputRange!R && !isInfinite!R)\n     assert([1, 2, 3].count([2, 3]) == 1);\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=22582\n+@safe unittest\n+{\n+    assert([1, 2, 3].count!\"a & 1\" == 2);\n+}\n+\n /++\n     Counts elements in the given\n     $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)"}, {"sha": "28255f4ef993e98d1e0aa4079d55f722ea6a46fa", "filename": "libphobos/src/std/datetime/timezone.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fdatetime%2Ftimezone.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -2464,7 +2464,8 @@ public:\n                         if (!tzName.extension().empty ||\n                             !tzName.startsWith(subName) ||\n                             baseName(tzName) == \"leapseconds\" ||\n-                            tzName == \"+VERSION\")\n+                            tzName == \"+VERSION\" ||\n+                            tzName == \"SECURITY\")\n                         {\n                             continue;\n                         }"}, {"sha": "971cfa07e2be8df36d45df8140ae2d503a8defec", "filename": "libphobos/src/std/parallelism.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fparallelism.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fparallelism.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fparallelism.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -2738,7 +2738,7 @@ public:\n             immutable size_t nBytesNeeded = nWorkUnits * RTask.sizeof;\n \n             import core.stdc.stdlib : malloc, free;\n-            if (nBytesNeeded < maxStack)\n+            if (nBytesNeeded <= maxStack)\n             {\n                 tasks = (cast(RTask*) buf.ptr)[0 .. nWorkUnits];\n             }\n@@ -3045,11 +3045,11 @@ public:\n     Since the underlying data for this struct is heap-allocated, this struct\n     has reference semantics when passed between functions.\n \n-    The main uses cases for `WorkerLocalStorageStorage` are:\n+    The main uses cases for `WorkerLocalStorage` are:\n \n     1.  Performing parallel reductions with an imperative, as opposed to\n         functional, programming style.  In this case, it's useful to treat\n-        `WorkerLocalStorageStorage` as local to each thread for only the parallel\n+        `WorkerLocalStorage` as local to each thread for only the parallel\n         portion of an algorithm.\n \n     2.  Recycling temporary buffers across iterations of a parallel foreach loop."}, {"sha": "8db0b1e1f597af5441773cf9b8d949b662a2374a", "filename": "libphobos/src/std/regex/package.d", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -70,7 +70,7 @@ $(TR $(TD Objects) $(TD\n \n   ...\n   // multi-pattern regex\n-  auto multi = regex([`\\d+,\\d+`,`(a-z]+):(\\d+)`]);\n+  auto multi = regex([`\\d+,\\d+`, `([a-z]+):(\\d+)`]);\n   auto m = \"abc:43 12,34\".matchAll(multi);\n   assert(m.front.whichPattern == 2);\n   assert(m.front[1] == \"abc\");\n@@ -80,9 +80,17 @@ $(TR $(TD Objects) $(TD\n   assert(m.front[1] == \"12\");\n   ...\n \n-  // The result of the `matchAll/matchFirst` is directly testable with if/assert/while.\n-  // e.g. test if a string consists of letters:\n-  assert(matchFirst(\"Letter\", `^\\p{L}+$`));\n+  // The result of `matchAll/matchFirst` is directly testable with `if/assert/while`,\n+  // e.g. test if a string consists of letters only:\n+  assert(matchFirst(\"LettersOnly\", `^\\p{L}+$`));\n+\n+  // And we can take advantage of the ability to define a variable in the $(LINK2 https://dlang.org/spec/statement.html#IfCondition `IfCondition`):\n+  if (const auto captures = matchFirst(\"At l34st one digit, but maybe more...\", `((\\d)(\\d*))`))\n+  {\n+      assert(captures[2] == \"3\");\n+      assert(captures[3] == \"4\");\n+      assert(captures[1] == \"34\");\n+  }\n   ---\n \n   $(SECTION Syntax and general information)"}, {"sha": "c1d6bc97402dc3b3371ff3b07eff959e2652a376", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -829,6 +829,10 @@ private template fqnType(T,\n     {\n         enum fqnType = \"dstring\";\n     }\n+    else static if (is(T == typeof(null)))\n+    {\n+        enum fqnType = \"typeof(null)\";\n+    }\n     else static if (isBasicType!T && !is(T == enum))\n     {\n         enum fqnType = chain!((Unqual!T).stringof);\n@@ -919,6 +923,7 @@ private template fqnType(T,\n         static assert(fqn!(string) == \"string\");\n         static assert(fqn!(wstring) == \"wstring\");\n         static assert(fqn!(dstring) == \"dstring\");\n+        static assert(fqn!(typeof(null)) == \"typeof(null)\");\n         static assert(fqn!(void) == \"void\");\n         static assert(fqn!(const(void)) == \"const(void)\");\n         static assert(fqn!(shared(void)) == \"shared(void)\");"}, {"sha": "2c008ce927ecb30343857437f19d9434fd1fe8ae", "filename": "libphobos/testsuite/libphobos.traits/all_satisfy.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Ftestsuite%2Flibphobos.traits%2Fall_satisfy.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Ftestsuite%2Flibphobos.traits%2Fall_satisfy.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.traits%2Fall_satisfy.d?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,24 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22210\n+\n+import core.internal.traits : allSatisfy;\n+\n+enum isHashable(T) = __traits(compiles,\n+    () { T.init; }\n+);\n+\n+class A\n+{\n+    static if (isHashable!B) {}\n+}\n+\n+class B\n+{\n+    static if (isHashable!C) {}\n+}\n+\n+class C\n+{\n+    static if (allSatisfy!(isHashable, int, B)) {}\n+}\n+\n+void main() {}"}, {"sha": "cb785382f51bfe090b66a26715c54ce7b26b4a50", "filename": "libphobos/testsuite/libphobos.traits/traits.exp", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Ftestsuite%2Flibphobos.traits%2Ftraits.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd43568cc54e17c8b4a845677872c6282bc6dbb7/libphobos%2Ftestsuite%2Flibphobos.traits%2Ftraits.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.traits%2Ftraits.exp?ref=fd43568cc54e17c8b4a845677872c6282bc6dbb7", "patch": "@@ -0,0 +1,27 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Initialize dg.\n+dg-init\n+\n+# Gather a list of all tests.\n+set tests [lsort [find $srcdir/$subdir *.d]]\n+\n+# Main loop.\n+dg-runtest $tests \"\" $DEFAULT_DFLAGS\n+\n+# All done.\n+dg-finish"}]}