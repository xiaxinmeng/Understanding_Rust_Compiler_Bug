{"sha": "fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmYmZhMjE2NjcyYzc3ZDJmMGM0ZmIyNmViMzZhNjU0YzFhODhiYg==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-10-02T23:12:49Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-10-02T23:12:49Z"}, "message": "tree-mudflap.c (mf_build_check_statement_for): Reorganize to take check-base and -limit arguments.\n\n2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* tree-mudflap.c (mf_build_check_statement_for): Reorganize to\n\ttake check-base and -limit arguments.\n\t(mf_xform_derefs_1): Reorganize slightly to pass proper base/limit\n\tcheck ranges for ARRAY_REF and COMPONENT_REF.\n\t(execute_mudflap_fnction_ops, ..._decls): Limit unnecessary\n\tinstrumentation.\n\n2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* testsuite/libmudflap.c/pass50-frag.c, fail33-frag.c, fail34-frag.c:\n\tNew tests for proper base/limit checking for aggregates.\n\nFrom-SVN: r88432", "tree": {"sha": "34af220a8005039a10395e1129f99324b64ce2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34af220a8005039a10395e1129f99324b64ce2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7848dfcac199f677935254d6631ca03b02b677ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7848dfcac199f677935254d6631ca03b02b677ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7848dfcac199f677935254d6631ca03b02b677ea"}], "stats": {"total": 161, "additions": 144, "deletions": 17}, "files": [{"sha": "dcdaf7037ac3c35cc3f0b58e5598e0adb2279215", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -1,3 +1,12 @@\n+2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* tree-mudflap.c (mf_build_check_statement_for): Reorganize to\n+\ttake check-base and -limit arguments.\n+\t(mf_xform_derefs_1): Reorganize slightly to pass proper base/limit\n+\tcheck ranges for ARRAY_REF and COMPONENT_REF.\n+\t(execute_mudflap_fnction_ops, ..._decls): Limit unnecessary\n+\tinstrumentation.\n+\n 2004-10-02  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-objc-common.c (c_tree_printer): Correct description of %E."}, {"sha": "bc42de7096ad8340b173eecdbff4ded8e0712044", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -407,7 +407,10 @@ mudflap_init (void)\n static void\n execute_mudflap_function_ops (void)\n {\n-  if (mf_marked_p (current_function_decl))\n+  /* Don't instrument functions such as the synthetic constructor\n+     built during mudflap_finish_file.  */\n+  if (mf_marked_p (current_function_decl) ||\n+      DECL_ARTIFICIAL (current_function_decl))\n     return;\n \n   push_gimplify_context ();\n@@ -481,7 +484,7 @@ mf_decl_clear_locals (void)\n }\n \n static void\n-mf_build_check_statement_for (tree addr, tree size,\n+mf_build_check_statement_for (tree base, tree addr, tree limit,\n                               block_stmt_iterator *instr_bsi,\n                               location_t *locus, tree dirflag)\n {\n@@ -494,6 +497,7 @@ mf_build_check_statement_for (tree addr, tree size,\n   tree mf_value;\n   tree mf_base;\n   tree mf_elem;\n+  tree mf_limit;\n \n   /* We first need to split the current basic block, and start altering\n      the CFG.  This allows us to insert the statements we're about to\n@@ -557,6 +561,7 @@ mf_build_check_statement_for (tree addr, tree size,\n   mf_value = create_tmp_var (ptrtype, \"__mf_value\");\n   mf_elem = create_tmp_var (mf_cache_structptr_type, \"__mf_elem\");\n   mf_base = create_tmp_var (mf_uintptr_type, \"__mf_base\");\n+  mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n \n   /* Build: __mf_value = <address expression>.  */\n   t = build (MODIFY_EXPR, void_type_node, mf_value, unshare_expr (addr));\n@@ -565,9 +570,16 @@ mf_build_check_statement_for (tree addr, tree size,\n   head = tsi_start (t);\n   tsi = tsi_last (t);\n \n-  /* Build: __mf_base = (uintptr_t)__mf_value.  */\n+  /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n   t = build (MODIFY_EXPR, void_type_node, mf_base,\n-             build1 (NOP_EXPR, mf_uintptr_type, mf_value));\n+             convert (mf_uintptr_type, unshare_expr (base)));\n+  SET_EXPR_LOCUS (t, locus);\n+  gimplify_to_stmt_list (&t);\n+  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n+\n+  /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n+  t = build (MODIFY_EXPR, void_type_node, mf_limit,\n+             convert (mf_uintptr_type, unshare_expr (limit)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n@@ -590,7 +602,7 @@ mf_build_check_statement_for (tree addr, tree size,\n   /* Quick validity check.\n \n      if (__mf_elem->low > __mf_base\n-         || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n+         || (__mf_elem_high < __mf_limit))\n         {\n           __mf_check ();\n           ... and only if single-threaded:\n@@ -607,22 +619,19 @@ mf_build_check_statement_for (tree addr, tree size,\n              TYPE_FIELDS (mf_cache_struct_type), NULL_TREE);\n   t = build (GT_EXPR, boolean_type_node, t, mf_base);\n \n-  /* Construct '__mf_elem->high < __mf_base + sizeof(T) - 1'.\n+  /* Construct '__mf_elem->high < __mf_limit'.\n \n      First build:\n         1) u <--  '__mf_elem->high'\n-        2) v <--  '__mf_base + sizeof (T) - 1'.\n+        2) v <--  '__mf_limit'.\n \n      Then build 'u <-- (u < v).  */\n \n-\n   u = build (COMPONENT_REF, mf_uintptr_type,\n              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n              TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n \n-  v = convert (mf_uintptr_type,\n-               size_binop (MINUS_EXPR, size, size_one_node));\n-  v = fold (build (PLUS_EXPR, mf_uintptr_type, mf_base, v));\n+  v = mf_limit;\n \n   u = build (LT_EXPR, boolean_type_node, u, v);\n \n@@ -647,7 +656,7 @@ mf_build_check_statement_for (tree addr, tree size,\n      the conditional jump,\n \n      if (__mf_elem->low > __mf_base\n-         || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n+         || (__mf_elem_high < __mf_limit))\n \n      The lowered GIMPLE tree representing this code is in the statement\n      list starting at 'head'.\n@@ -670,8 +679,14 @@ mf_build_check_statement_for (tree addr, tree size,\n                                              : *locus),\n                  NULL_TREE);\n   u = tree_cons (NULL_TREE, dirflag, u);\n-  u = tree_cons (NULL_TREE, size, u);\n-  u = tree_cons (NULL_TREE, mf_value, u);\n+  /* NB: we pass the overall [base..limit] range to mf_check,\n+     not the [mf_value..mf_value+size-1] range.  */\n+  u = tree_cons (NULL_TREE, \n+                 fold (build (PLUS_EXPR, integer_type_node,\n+                              fold (build (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base)),\n+                              integer_one_node)),\n+                 u);\n+  u = tree_cons (NULL_TREE, mf_base, u);\n   t = build_function_call_expr (mf_check_fndecl, u);\n   gimplify_to_stmt_list (&t);\n   head = tsi_start (t);\n@@ -701,7 +716,7 @@ static void\n mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                    location_t *locus, tree dirflag)\n {\n-  tree type, ptr_type, addr, size, t;\n+  tree type, ptr_type, addr, base, size, limit, t;\n \n   /* Don't instrument read operations.  */\n   if (dirflag == integer_zero_node && flag_mudflap_ignore_reads)\n@@ -756,12 +771,20 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n         /* If we got here, we couldn't statically the check.  */\n         ptr_type = build_pointer_type (type);\n         addr = build1 (ADDR_EXPR, ptr_type, t);\n+        base = build1 (ADDR_EXPR, ptr_type, op0);\n+        limit = fold (build (MINUS_EXPR, mf_uintptr_type,\n+                             fold (build2 (PLUS_EXPR, mf_uintptr_type, addr, size)),\n+                             integer_one_node));\n       }\n       break;\n \n     case INDIRECT_REF:\n       addr = TREE_OPERAND (t, 0);\n       ptr_type = TREE_TYPE (addr);\n+      base = addr;\n+      limit = fold (build (MINUS_EXPR, ptr_type_node,\n+                           fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n+                           integer_one_node));\n       break;\n \n     case ARRAY_RANGE_REF:\n@@ -798,6 +821,12 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n             ptr_type = build_pointer_type (type);\n             addr = build1 (ADDR_EXPR, ptr_type, t);\n           }\n+\n+        /* XXXXXX */\n+        base = addr;\n+        limit = fold (build (MINUS_EXPR, ptr_type_node,\n+                             fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n+                             integer_one_node));\n       }\n       break;\n \n@@ -823,14 +852,19 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n         addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n         addr = convert (ptr_type_node, addr);\n         addr = fold (build (PLUS_EXPR, ptr_type_node, addr, ofs));\n+\n+        base = addr;\n+        limit = fold (build (MINUS_EXPR, ptr_type_node,\n+                             fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n+                             integer_one_node));\n       }\n       break;\n \n     default:\n       return;\n     }\n \n-  mf_build_check_statement_for (addr, size, iter, locus, dirflag);\n+  mf_build_check_statement_for (base, addr, limit, iter, locus, dirflag);\n }\n \n static void\n@@ -891,7 +925,10 @@ mf_xform_derefs (void)\n static void\n execute_mudflap_function_decls (void)\n {\n-  if (mf_marked_p (current_function_decl))\n+  /* Don't instrument functions such as the synthetic constructor\n+     built during mudflap_finish_file.  */\n+  if (mf_marked_p (current_function_decl) ||\n+      DECL_ARTIFICIAL (current_function_decl))\n     return;\n \n   push_gimplify_context ();"}, {"sha": "97ab17c72f49c35485232d17d780eae59e78d969", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -1,3 +1,8 @@\n+2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* testsuite/libmudflap.c/pass50-frag.c, fail33-frag.c, fail34-frag.c:\n+\tNew tests for proper base/limit checking for aggregates.\n+\n 2004-09-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* testsuite/libmudflap.c/pass35-frag.c: Update expected message."}, {"sha": "5f33be7a852093347b132f98cfb0fc532cf2e5ca", "filename": "libmudflap/testsuite/libmudflap.c/fail33-frag.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -0,0 +1,25 @@\n+#include <stdlib.h>\n+\n+#define SIZE 16\n+\n+char b[SIZE];\n+char a[SIZE];\n+\n+int main ()\n+{\n+  int i, j=0;\n+  int a_before_b = (& a[0] < & b[0]);\n+  /* Rather than iterating linearly, which would allow loop unrolling\n+     and mapping to pointer manipulation, we traverse the \"joined\"\n+     arrays in some random order.  */\n+  for (i=0; i<SIZE*2; i++)\n+    {\n+      k=rand()%(SIZE*2))\n+      j += (a_before_b ? a[k] : b[k]);\n+    }\n+  return j;\n+}\n+/* { dg-output \"mudflap violation 1.*\" } */\n+/* { dg-output \"Nearby object.*\" } */\n+/* { dg-output \"mudflap object.*\\[ab\\]\" } */\n+/* { dg-do run { xfail *-*-* } } */"}, {"sha": "f6572b019a4f382055857d09a2685b79dfa7ec91", "filename": "libmudflap/testsuite/libmudflap.c/fail34-frag.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -0,0 +1,22 @@\n+#include <stdlib.h>\n+\n+struct s\n+{\n+  int a1[4];\n+};\n+\n+struct s a, b;\n+int idx = 7; /* should pass to the next object */\n+\n+int\n+main ()\n+{\n+  int i, j=0;\n+  int a_before_b = (& a < & b);\n+  j = (a_before_b ? a.a1[idx] : b.a1[idx]);\n+  return j;\n+}\n+/* { dg-output \"mudflap violation 1.*\" } */\n+/* { dg-output \"Nearby object.*\" } */\n+/* { dg-output \"mudflap object.*\\[ab\\]\" } */\n+/* { dg-do run { xfail *-*-* } } */"}, {"sha": "ac9ee090950e42ec432e8bcda48e731d98b6be0c", "filename": "libmudflap/testsuite/libmudflap.c/pass50-frag.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefbfa216672c77d2f0c4fb26eb36a654c1a88bb/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c?ref=fefbfa216672c77d2f0c4fb26eb36a654c1a88bb", "patch": "@@ -0,0 +1,29 @@\n+#include <stdlib.h>\n+\n+struct a\n+{\n+  int a1[5];\n+  union\n+  {\n+    int b1[5];\n+    struct\n+    {\n+      int c1;\n+      int c2;\n+    } b2[4];\n+  } a2[8];\n+};\n+\n+int i1 = 5;\n+int i2 = 2;\n+int i3 = 6;\n+int i4 = 0;\n+\n+int\n+main ()\n+{\n+  volatile struct a *k = calloc (1, sizeof (struct a));\n+  k->a2[i1].b1[i2] = k->a2[i3].b2[i4].c2;\n+  free ((void *) k);\n+  return 0;\n+}"}]}