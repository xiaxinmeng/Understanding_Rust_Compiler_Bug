{"sha": "6e98504002b3ee32c9b3d17da648b01e1424f833", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU5ODUwNDAwMmIzZWUzMmM5YjNkMTdkYTY0OGIwMWUxNDI0ZjgzMw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2003-07-14T05:17:18Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2003-07-14T05:17:18Z"}, "message": "tm.texi (BLOCK_REG_PADDING): Describe.\n\n\t* doc/tm.texi (BLOCK_REG_PADDING): Describe.\n\t* expr.h (struct locate_and_pad_arg_data): Add where_pad.\n\t(emit_group_load, emit_group_store): Adjust declarations.\n\tRemove most occurrences of #ifdef TREE_CODE.\n\t* expr.c (emit_group_load): Add \"type\" param, and use\n\tBLOCK_REG_PADDING to determine need for a shift.  Optimize non-\n\taligned accesses if !SLOW_UNALIGNED_ACCESS.\n\t(emit_group_store): Likewise.\n\t(emit_push_insn, expand_assignment, store_expr, expand_expr): Adjust\n\temit_group_load and emit_group_store calls.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Tidy.  Use\n\tBLOCK_REG_PADDING to determine whether we need endian_correction.\n\t(load_register_parameters): Localize vars.  Handle shifting of\n\tsmall values to the correct end of regs.  Adjust emit_group_load\n\tcall.\n\t(expand_call, emit_library_call_value_1): Adjust emit_group_load\n\tand emit_group_store calls.\n\t* function.c (assign_parms): Set mem alignment for stack slots.\n\tAdjust emit_group_store call.  Store values at the \"wrong\" end\n\tof regs to the stack.  Use BLOCK_REG_PADDING.\n\t(locate_and_pad_parm): Save where_pad.\n\t(expand_function_end): Adjust emit_group_load call.\n\t* stmt.c (expand_value_return): Adjust emit_group_load call.\n\t* Makefile.in (calls.o): Depend on $(OPTABS_H).\n\t* config/rs6000/linux64.h (TARGET_LITTLE_ENDIAN): Redefine as 0.\n\t(AGGREGATE_PADDING_FIXED, AGGREGATES_PAD_UPWARD_ALWAYS): Define.\n\t(MUST_PASS_IN_STACK): Define.\n\t(BLOCK_REG_PADDING): Define.\n\t* config/rs6000/rs6000.h (struct rs6000_args): Remove orig_nargs.\n\t(PAD_VARARGS_DOWN): Define in terms of FUNCTION_ARG_PADDING.\n\t* config/rs6000/rs6000.c (init_cumulative_args): Don't set orig_nargs.\n\t(function_arg_padding): !AGGREGATE_PADDING_FIXED compatibility code.\n\tAct on AGGREGATES_PAD_UPWARD_ALWAYS.\n\nFrom-SVN: r69318", "tree": {"sha": "d7df914db340221693c15fa50acf2fcb2f8905f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7df914db340221693c15fa50acf2fcb2f8905f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e98504002b3ee32c9b3d17da648b01e1424f833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e98504002b3ee32c9b3d17da648b01e1424f833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e98504002b3ee32c9b3d17da648b01e1424f833", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e98504002b3ee32c9b3d17da648b01e1424f833/comments", "author": null, "committer": null, "parents": [{"sha": "a3d8777127800e056bf525c39ab4f7bd72b7818b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d8777127800e056bf525c39ab4f7bd72b7818b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d8777127800e056bf525c39ab4f7bd72b7818b"}], "stats": {"total": 386, "additions": 291, "deletions": 95}, "files": [{"sha": "510d74fbd9bdc7b2df4a8cc683dff6e6f11d5fd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -1,3 +1,39 @@\n+2003-07-14  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* doc/tm.texi (BLOCK_REG_PADDING): Describe.\n+\t* expr.h (struct locate_and_pad_arg_data): Add where_pad.\n+\t(emit_group_load, emit_group_store): Adjust declarations.\n+\tRemove most occurrences of #ifdef TREE_CODE.\n+\t* expr.c (emit_group_load): Add \"type\" param, and use\n+\tBLOCK_REG_PADDING to determine need for a shift.  Optimize non-\n+\taligned accesses if !SLOW_UNALIGNED_ACCESS.\n+\t(emit_group_store): Likewise.\n+\t(emit_push_insn, expand_assignment, store_expr, expand_expr): Adjust\n+\temit_group_load and emit_group_store calls.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Tidy.  Use\n+\tBLOCK_REG_PADDING to determine whether we need endian_correction.\n+\t(load_register_parameters): Localize vars.  Handle shifting of\n+\tsmall values to the correct end of regs.  Adjust emit_group_load\n+\tcall.\n+\t(expand_call, emit_library_call_value_1): Adjust emit_group_load\n+\tand emit_group_store calls.\n+\t* function.c (assign_parms): Set mem alignment for stack slots.\n+\tAdjust emit_group_store call.  Store values at the \"wrong\" end\n+\tof regs to the stack.  Use BLOCK_REG_PADDING.\n+\t(locate_and_pad_parm): Save where_pad.\n+\t(expand_function_end): Adjust emit_group_load call.\n+\t* stmt.c (expand_value_return): Adjust emit_group_load call.\n+\t* Makefile.in (calls.o): Depend on $(OPTABS_H).\n+\t* config/rs6000/linux64.h (TARGET_LITTLE_ENDIAN): Redefine as 0.\n+\t(AGGREGATE_PADDING_FIXED, AGGREGATES_PAD_UPWARD_ALWAYS): Define.\n+\t(MUST_PASS_IN_STACK): Define.\n+\t(BLOCK_REG_PADDING): Define.\n+\t* config/rs6000/rs6000.h (struct rs6000_args): Remove orig_nargs.\n+\t(PAD_VARARGS_DOWN): Define in terms of FUNCTION_ARG_PADDING.\n+\t* config/rs6000/rs6000.c (init_cumulative_args): Don't set orig_nargs.\n+\t(function_arg_padding): !AGGREGATE_PADDING_FIXED compatibility code.\n+\tAct on AGGREGATES_PAD_UPWARD_ALWAYS.\n+\n 2003-07-13  Aaron W. LaFramboise  <awlaframboise@aol.com>\n \n \t* config/i386/gthr-win32.c (__GTHREAD_HIDE_WIN32API): Define to 1."}, {"sha": "414980ccf0d48503f10b16b1d4a836e15cf35ab0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -1547,7 +1547,7 @@ builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(T\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n    except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   $(EXPR_H) langhooks.h $(TARGET_H) \\\n+   $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n    libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h except.h\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) real.h \\"}, {"sha": "ef4926ee77093b4aa338fb499af6cbec4bea4295", "filename": "gcc/calls.c", "status": "modified", "additions": 87, "deletions": 33, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -27,6 +27,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"expr.h\"\n+#include \"optabs.h\"\n #include \"libfuncs.h\"\n #include \"function.h\"\n #include \"regs.h\"\n@@ -934,22 +935,27 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    < (unsigned int) MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n       {\n \tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\tint big_endian_correction = 0;\n-\n-\targs[i].n_aligned_regs\n-\t  = args[i].partial ? args[i].partial\n-\t    : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\tint nregs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\tint endian_correction = 0;\n \n+\targs[i].n_aligned_regs = args[i].partial ? args[i].partial : nregs;\n \targs[i].aligned_regs = (rtx *) xmalloc (sizeof (rtx)\n \t\t\t\t\t\t* args[i].n_aligned_regs);\n \n-\t/* Structures smaller than a word are aligned to the least\n-\t   significant byte (to the right).  On a BYTES_BIG_ENDIAN machine,\n+\t/* Structures smaller than a word are normally aligned to the\n+\t   least significant byte.  On a BYTES_BIG_ENDIAN machine,\n \t   this means we must skip the empty high order bytes when\n \t   calculating the bit offset.  */\n-\tif (BYTES_BIG_ENDIAN\n-\t    && bytes < UNITS_PER_WORD)\n-\t  big_endian_correction = (BITS_PER_WORD  - (bytes * BITS_PER_UNIT));\n+\tif (bytes < UNITS_PER_WORD\n+#ifdef BLOCK_REG_PADDING\n+\t    && (BLOCK_REG_PADDING (args[i].mode,\n+\t\t\t\t   TREE_TYPE (args[i].tree_value), 1)\n+\t\t== downward)\n+#else\n+\t    && BYTES_BIG_ENDIAN\n+#endif\n+\t    )\n+\t  endian_correction = BITS_PER_WORD - bytes * BITS_PER_UNIT;\n \n \tfor (j = 0; j < args[i].n_aligned_regs; j++)\n \t  {\n@@ -958,6 +964,8 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n \n \t    args[i].aligned_regs[j] = reg;\n+\t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n+\t\t\t\t      word_mode, word_mode, BITS_PER_WORD);\n \n \t    /* There is no need to restrict this code to loading items\n \t       in TYPE_ALIGN sized hunks.  The bitfield instructions can\n@@ -973,11 +981,8 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    emit_move_insn (reg, const0_rtx);\n \n \t    bytes -= bitsize / BITS_PER_UNIT;\n-\t    store_bit_field (reg, bitsize, big_endian_correction, word_mode,\n-\t\t\t     extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n-\t\t\t\t\t\tword_mode, word_mode,\n-\t\t\t\t\t\tBITS_PER_WORD),\n-\t\t\t     BITS_PER_WORD);\n+\t    store_bit_field (reg, bitsize, endian_correction, word_mode,\n+\t\t\t     word, BITS_PER_WORD);\n \t  }\n       }\n }\n@@ -1580,34 +1585,48 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n     {\n       rtx reg = ((flags & ECF_SIBCALL)\n \t\t ? args[i].tail_call_reg : args[i].reg);\n-      int partial = args[i].partial;\n-      int nregs;\n-\n       if (reg)\n \t{\n+\t  int partial = args[i].partial;\n+\t  int nregs;\n+\t  int size = 0;\n \t  rtx before_arg = get_last_insn ();\n \t  /* Set to non-negative if must move a word at a time, even if just\n \t     one word (e.g, partial == 1 && mode == DFmode).  Set to -1 if\n \t     we just use a normal move insn.  This value can be zero if the\n \t     argument is a zero size structure with no fields.  */\n-\t  nregs = (partial ? partial\n-\t\t   : (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n-\t\t      ? ((int_size_in_bytes (TREE_TYPE (args[i].tree_value))\n-\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t      : -1));\n+\t  nregs = -1;\n+\t  if (partial)\n+\t    nregs = partial;\n+\t  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)\n+\t    {\n+\t      size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\t      nregs = (size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\t    }\n+\t  else\n+\t    size = GET_MODE_SIZE (args[i].mode);\n \n \t  /* Handle calls that pass values in multiple non-contiguous\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \n \t  if (GET_CODE (reg) == PARALLEL)\n-\t    emit_group_load (reg, args[i].value,\n-\t\t\t     int_size_in_bytes (TREE_TYPE (args[i].tree_value)));\n+\t    {\n+\t      tree type = TREE_TYPE (args[i].tree_value);\n+\t      emit_group_load (reg, args[i].value, type,\n+\t\t\t       int_size_in_bytes (type));\n+\t    }\n \n \t  /* If simple case, just do move.  If normal partial, store_one_arg\n \t     has already loaded the register for us.  In all other cases,\n \t     load the register(s) from memory.  */\n \n-\t  else if (nregs == -1)\n+\t  else if (nregs == -1\n+#ifdef BLOCK_REG_PADDING\n+\t\t   && !(size < UNITS_PER_WORD\n+\t\t\t&& (args[i].locate.where_pad\n+\t\t\t    == (BYTES_BIG_ENDIAN ? upward : downward)))\n+#endif\n+\t\t   )\n \t    emit_move_insn (reg, args[i].value);\n \n \t  /* If we have pre-computed the values to put in the registers in\n@@ -1619,9 +1638,44 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t\t      args[i].aligned_regs[j]);\n \n \t  else if (partial == 0 || args[i].pass_on_stack)\n-\t    move_block_to_reg (REGNO (reg),\n-\t\t\t       validize_mem (args[i].value), nregs,\n-\t\t\t       args[i].mode);\n+\t    {\n+\t      rtx mem = validize_mem (args[i].value);\n+\n+#ifdef BLOCK_REG_PADDING\n+\t      /* Handle case where we have a value that needs shifting\n+\t\t up to the msb.  eg. a QImode value and we're padding\n+\t\t upward on a BYTES_BIG_ENDIAN machine.  */\n+\t      if (nregs == -1)\n+\t\t{\n+\t\t  rtx ri = gen_rtx_REG (word_mode, REGNO (reg));\n+\t\t  rtx x;\n+\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t\t  x = expand_binop (word_mode, ashl_optab, mem,\n+\t\t\t\t    GEN_INT (shift), ri, 1, OPTAB_WIDEN);\n+\t\t  if (x != ri)\n+\t\t    emit_move_insn (ri, x);\n+\t\t}\n+\n+\t      /* Handle a BLKmode that needs shifting.  */\n+\t      else if (nregs == 1 && size < UNITS_PER_WORD\n+\t\t       && args[i].locate.where_pad == downward)\n+\t\t{\n+\t\t  rtx tem = operand_subword_force (mem, 0, args[i].mode);\n+\t\t  rtx ri = gen_rtx_REG (word_mode, REGNO (reg));\n+\t\t  rtx x = gen_reg_rtx (word_mode);\n+\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t\t  optab dir = BYTES_BIG_ENDIAN ? lshr_optab : ashl_optab;\n+\n+\t\t  emit_move_insn (x, tem);\n+\t\t  x = expand_binop (word_mode, dir, x, GEN_INT (shift),\n+\t\t\t\t    ri, 1, OPTAB_WIDEN);\n+\t\t  if (x != ri)\n+\t\t    emit_move_insn (ri, x);\n+\t\t}\n+\t      else\n+#endif\n+\t\tmove_block_to_reg (REGNO (reg), mem, nregs, args[i].mode);\n+\t    }\n \n \t  /* When a parameter is a block, and perhaps in other cases, it is\n \t     possible that it did a load from an argument slot that was\n@@ -3144,7 +3198,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    }\n \n \t  if (! rtx_equal_p (target, valreg))\n-\t    emit_group_store (target, valreg,\n+\t    emit_group_store (target, valreg, TREE_TYPE (exp),\n \t\t\t      int_size_in_bytes (TREE_TYPE (exp)));\n \n \t  /* We can not support sibling calls for this case.  */\n@@ -3989,7 +4043,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The PA64 has examples of this for library calls.  */\n       if (reg != 0 && GET_CODE (reg) == PARALLEL)\n-\temit_group_load (reg, val, GET_MODE_SIZE (GET_MODE (val)));\n+\temit_group_load (reg, val, NULL_TREE, GET_MODE_SIZE (GET_MODE (val)));\n       else if (reg != 0 && partial == 0)\n \temit_move_insn (reg, val);\n \n@@ -4093,7 +4147,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t  if (GET_CODE (valreg) == PARALLEL)\n \t    {\n \t      temp = gen_reg_rtx (outmode);\n-\t      emit_group_store (temp, valreg, outmode);\n+\t      emit_group_store (temp, valreg, NULL_TREE, outmode);\n \t      valreg = temp;\n \t    }\n \n@@ -4136,7 +4190,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t{\n \t  if (value == 0)\n \t    value = gen_reg_rtx (outmode);\n-\t  emit_group_store (value, valreg, outmode);\n+\t  emit_group_store (value, valreg, NULL_TREE, outmode);\n \t}\n       else if (value != 0)\n \temit_move_insn (value, valreg);"}, {"sha": "4ef7382cee8af56c45dca5f48ab236910a4d687a", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -160,6 +160,10 @@\n \n #ifndef RS6000_BI_ARCH\n \n+/* 64-bit PowerPC Linux is always big-endian.  */\n+#undef\tTARGET_LITTLE_ENDIAN\n+#define TARGET_LITTLE_ENDIAN\t0\n+\n /* 64-bit PowerPC Linux always has a TOC.  */\n #undef  TARGET_TOC\n #define\tTARGET_TOC\t\t1\n@@ -232,6 +236,35 @@\n #undef  JUMP_TABLES_IN_TEXT_SECTION\n #define JUMP_TABLES_IN_TEXT_SECTION TARGET_64BIT\n \n+/* The linux ppc64 ABI isn't explicit on whether aggregates smaller\n+   than a doubleword should be padded upward or downward.  You could\n+   reasonably assume that they follow the normal rules for structure\n+   layout treating the parameter area as any other block of memory,\n+   then map the reg param area to registers.  ie. pad updard.\n+   Setting both of the following defines results in this behaviour.\n+   Setting just the first one will result in aggregates that fit in a\n+   doubleword being padded downward, and others being padded upward.\n+   Not a bad idea as this results in struct { int x; } being passed\n+   the same way as an int.  */\n+#define AGGREGATE_PADDING_FIXED TARGET_64BIT\n+#define AGGREGATES_PAD_UPWARD_ALWAYS 0\n+\n+/* We don't want anything in the reg parm area being passed on the\n+   stack.  */\n+#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n+  ((TARGET_64BIT\t\t\t\t\t\t\\\n+    && (TYPE) != 0\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\\\n+\t|| TREE_ADDRESSABLE (TYPE)))\t\t\t\t\\\n+   || (!TARGET_64BIT\t\t\t\t\t\t\\\n+       && default_must_pass_in_stack ((MODE), (TYPE))))\n+\n+/* Specify padding for the last element of a block move between\n+   registers and memory.  FIRST is nonzero if this is the only\n+   element.  */\n+#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n+  (!(FIRST) ? upward : FUNCTION_ARG_PADDING (MODE, TYPE))\n+\n /* __throw will restore its own return address to be the same as the\n    return address of the function that the throw is being made to.\n    This is unfortunate, because we want to check the original"}, {"sha": "fa296d5db94ad87bff69ed6c3db122c49e197fcb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -3702,8 +3702,6 @@ init_cumulative_args (cum, fntype, libname, incoming, libcall)\n   else\n     cum->nargs_prototype = 0;\n \n-  cum->orig_nargs = cum->nargs_prototype;\n-\n   /* Check for a longcall attribute.  */\n   if (fntype\n       && lookup_attribute (\"longcall\", TYPE_ATTRIBUTES (fntype))\n@@ -3742,8 +3740,47 @@ function_arg_padding (mode, type)\n      enum machine_mode mode;\n      tree type;\n {\n-  if (type != 0 && AGGREGATE_TYPE_P (type))\n-    return upward;\n+#ifndef AGGREGATE_PADDING_FIXED\n+#define AGGREGATE_PADDING_FIXED 0\n+#endif\n+#ifndef AGGREGATES_PAD_UPWARD_ALWAYS\n+#define AGGREGATES_PAD_UPWARD_ALWAYS 0\n+#endif\n+\n+  if (!AGGREGATE_PADDING_FIXED)\n+    {\n+      /* GCC used to pass structures of the same size as integer types as\n+\t if they were in fact integers, ignoring FUNCTION_ARG_PADDING.\n+\t ie. Structures of size 1 or 2 (or 4 when TARGET_64BIT) were\n+\t passed padded downward, except that -mstrict-align further\n+\t muddied the water in that multi-component structures of 2 and 4\n+\t bytes in size were passed padded upward.\n+\n+\t The following arranges for best compatibility with previous\n+\t versions of gcc, but removes the -mstrict-align dependency.  */\n+      if (BYTES_BIG_ENDIAN)\n+\t{\n+\t  HOST_WIDE_INT size = 0;\n+\n+\t  if (mode == BLKmode)\n+\t    {\n+\t      if (type && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n+\t\tsize = int_size_in_bytes (type);\n+\t    }\n+\t  else\n+\t    size = GET_MODE_SIZE (mode);\n+\n+\t  if (size == 1 || size == 2 || size == 4)\n+\t    return downward;\n+\t}\n+      return upward;\n+    }\n+\n+  if (AGGREGATES_PAD_UPWARD_ALWAYS)\n+    {\n+      if (type != 0 && AGGREGATE_TYPE_P (type))\n+\treturn upward;\n+    }\n \n   /* This is the default definition.  */\n   return (! BYTES_BIG_ENDIAN"}, {"sha": "5ba18dce5cdfebe6afe5d66a8c4a3fcc7645e0a0", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -1734,7 +1734,6 @@ typedef struct rs6000_args\n   int fregno;\t\t\t/* next available FP register */\n   int vregno;\t\t\t/* next available AltiVec register */\n   int nargs_prototype;\t\t/* # args left in the current prototype */\n-  int orig_nargs;\t\t/* Original value of nargs_prototype */\n   int prototype;\t\t/* Whether a prototype was defined */\n   int stdarg;\t\t\t/* Whether function is a stdarg function.  */\n   int call_cookie;\t\t/* Do special things for this call */\n@@ -1878,13 +1877,8 @@ typedef struct rs6000_args\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   rs6000_va_arg (valist, type)\n \n-/* For AIX, the rule is that structures are passed left-aligned in\n-   their stack slot.  However, GCC does not presently do this:\n-   structures which are the same size as integer types are passed\n-   right-aligned, as if they were in fact integers.  This only\n-   matters for structures of size 1 or 2, or 4 when TARGET_64BIT.\n-   ABI_V4 does not use std_expand_builtin_va_arg.  */\n-#define PAD_VARARGS_DOWN (TYPE_MODE (type) != BLKmode)\n+#define PAD_VARARGS_DOWN \\\n+   (FUNCTION_ARG_PADDING (TYPE_MODE (type), type) == downward)\n \n /* Define this macro to be a nonzero value if the location where a function\n    argument is passed depends on whether or not it is a named argument.  */"}, {"sha": "2c82c4044f06bbb24762d81bf34cbd522d1d29ac", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -3762,6 +3762,17 @@ controlled by @code{PARM_BOUNDARY}.  If this macro is not defined, all such\n arguments are padded down if @code{BYTES_BIG_ENDIAN} is true.\n @end defmac\n \n+@defmac BLOCK_REG_PADDING (@var{mode}, @var{type}, @var{first})\n+Specify padding for the last element of a block move between registers and\n+memory.  @var{first} is nonzero if this is the only element.  Defining this\n+macro allows better control of register function parameters on big-endian\n+machines, without using @code{PARALLEL} rtl.  In particular,\n+@code{MUST_PASS_IN_STACK} need not test padding and mode of types in\n+registers, as there is no longer a \"wrong\" part of a register;  For example,\n+a three byte aggregate may be passed in the high part of a register if so\n+required.\n+@end defmac\n+\n @defmac FUNCTION_ARG_BOUNDARY (@var{mode}, @var{type})\n If defined, a C expression that gives the alignment boundary, in bits,\n of an argument with the specified mode and type.  If it is not defined,"}, {"sha": "80efb3f459d60b2305bd3c6e160cd9e30c40dd69", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -2240,18 +2240,13 @@ gen_group_rtx (rtx orig)\n   return gen_rtx_PARALLEL (GET_MODE (orig), gen_rtvec_v (length, tmps));\n }\n \n-/* Emit code to move a block SRC to a block DST, where DST is non-consecutive\n-   registers represented by a PARALLEL.  SSIZE represents the total size of\n-   block SRC in bytes, or -1 if not known.  */\n-/* ??? If SSIZE % UNITS_PER_WORD != 0, we make the blatant assumption that\n-   the balance will be in what would be the low-order memory addresses, i.e.\n-   left justified for big endian, right justified for little endian.  This\n-   happens to be true for the targets currently using this support.  If this\n-   ever changes, a new target macro along the lines of FUNCTION_ARG_PADDING\n-   would be needed.  */\n+/* Emit code to move a block ORIG_SRC of type TYPE to a block DST,\n+   where DST is non-consecutive registers represented by a PARALLEL.\n+   SSIZE represents the total size of block ORIG_SRC in bytes, or -1\n+   if not known.  */ \n \n void\n-emit_group_load (rtx dst, rtx orig_src, int ssize)\n+emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n {\n   rtx *tmps, src;\n   int start, i;\n@@ -2279,7 +2274,17 @@ emit_group_load (rtx dst, rtx orig_src, int ssize)\n       /* Handle trailing fragments that run over the size of the struct.  */\n       if (ssize >= 0 && bytepos + (HOST_WIDE_INT) bytelen > ssize)\n \t{\n-\t  shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n+\t  /* Arrange to shift the fragment to where it belongs.\n+\t     extract_bit_field loads to the lsb of the reg.  */\n+\t  if (\n+#ifdef BLOCK_REG_PADDING\n+\t      BLOCK_REG_PADDING (GET_MODE (orig_src), type, i == start)\n+\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n+#else\n+\t      BYTES_BIG_ENDIAN\n+#endif\n+\t      )\n+\t    shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n \t  bytelen = ssize - bytepos;\n \t  if (bytelen <= 0)\n \t    abort ();\n@@ -2304,7 +2309,8 @@ emit_group_load (rtx dst, rtx orig_src, int ssize)\n \n       /* Optimize the access just a bit.  */\n       if (GET_CODE (src) == MEM\n-\t  && MEM_ALIGN (src) >= GET_MODE_ALIGNMENT (mode)\n+\t  && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (src))\n+\t      || MEM_ALIGN (src) >= GET_MODE_ALIGNMENT (mode))\n \t  && bytepos * BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n \t  && bytelen == GET_MODE_SIZE (mode))\n \t{\n@@ -2360,7 +2366,7 @@ emit_group_load (rtx dst, rtx orig_src, int ssize)\n \t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n \t\t\t\t     mode, mode, ssize);\n \n-      if (BYTES_BIG_ENDIAN && shift)\n+      if (shift)\n \texpand_binop (mode, ashl_optab, tmps[i], GEN_INT (shift),\n \t\t      tmps[i], 0, OPTAB_WIDEN);\n     }\n@@ -2391,12 +2397,13 @@ emit_group_move (rtx dst, rtx src)\n \t\t    XEXP (XVECEXP (src, 0, i), 0));\n }\n \n-/* Emit code to move a block SRC to a block DST, where SRC is non-consecutive\n-   registers represented by a PARALLEL.  SSIZE represents the total size of\n-   block DST, or -1 if not known.  */\n+/* Emit code to move a block SRC to a block ORIG_DST of type TYPE,\n+   where SRC is non-consecutive registers represented by a PARALLEL.\n+   SSIZE represents the total size of block ORIG_DST, or -1 if not\n+   known.  */\n \n void\n-emit_group_store (rtx orig_dst, rtx src, int ssize)\n+emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n {\n   rtx *tmps, dst;\n   int start, i;\n@@ -2440,8 +2447,8 @@ emit_group_store (rtx orig_dst, rtx src, int ssize)\n \t the temporary.  */\n \n       temp = assign_stack_temp (GET_MODE (dst), ssize, 0);\n-      emit_group_store (temp, src, ssize);\n-      emit_group_load (dst, temp, ssize);\n+      emit_group_store (temp, src, type, ssize);\n+      emit_group_load (dst, temp, type, ssize);\n       return;\n     }\n   else if (GET_CODE (dst) != MEM && GET_CODE (dst) != CONCAT)\n@@ -2462,7 +2469,16 @@ emit_group_store (rtx orig_dst, rtx src, int ssize)\n       /* Handle trailing fragments that run over the size of the struct.  */\n       if (ssize >= 0 && bytepos + (HOST_WIDE_INT) bytelen > ssize)\n \t{\n-\t  if (BYTES_BIG_ENDIAN)\n+\t  /* store_bit_field always takes its value from the lsb.\n+\t     Move the fragment to the lsb if it's not already there.  */\n+\t  if (\n+#ifdef BLOCK_REG_PADDING\n+\t      BLOCK_REG_PADDING (GET_MODE (orig_dst), type, i == start)\n+\t      == (BYTES_BIG_ENDIAN ? upward : downward)\n+#else\n+\t      BYTES_BIG_ENDIAN\n+#endif\n+\t      )\n \t    {\n \t      int shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n \t      expand_binop (mode, ashr_optab, tmps[i], GEN_INT (shift),\n@@ -2495,7 +2511,8 @@ emit_group_store (rtx orig_dst, rtx src, int ssize)\n \n       /* Optimize the access just a bit.  */\n       if (GET_CODE (dest) == MEM\n-\t  && MEM_ALIGN (dest) >= GET_MODE_ALIGNMENT (mode)\n+\t  && (! SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (dest))\n+\t      || MEM_ALIGN (dest) >= GET_MODE_ALIGNMENT (mode))\n \t  && bytepos * BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n \t  && bytelen == GET_MODE_SIZE (mode))\n \temit_move_insn (adjust_address (dest, mode, bytepos), tmps[i]);\n@@ -4076,7 +4093,7 @@ emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n       /* Handle calls that pass values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (reg) == PARALLEL)\n-\temit_group_load (reg, x, -1);  /* ??? size? */\n+\temit_group_load (reg, x, type, -1);\n       else\n \tmove_block_to_reg (REGNO (reg), x, partial, mode);\n     }\n@@ -4276,7 +4293,8 @@ expand_assignment (tree to, tree from, int want_value,\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (to_rtx) == PARALLEL)\n-\temit_group_load (to_rtx, value, int_size_in_bytes (TREE_TYPE (from)));\n+\temit_group_load (to_rtx, value, TREE_TYPE (from),\n+\t\t\t int_size_in_bytes (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n \temit_block_move (to_rtx, value, expr_size (from), BLOCK_OP_NORMAL);\n       else\n@@ -4310,7 +4328,8 @@ expand_assignment (tree to, tree from, int want_value,\n       temp = expand_expr (from, 0, GET_MODE (to_rtx), 0);\n \n       if (GET_CODE (to_rtx) == PARALLEL)\n-\temit_group_load (to_rtx, temp, int_size_in_bytes (TREE_TYPE (from)));\n+\temit_group_load (to_rtx, temp, TREE_TYPE (from),\n+\t\t\t int_size_in_bytes (TREE_TYPE (from)));\n       else\n \temit_move_insn (to_rtx, temp);\n \n@@ -4720,7 +4739,8 @@ store_expr (tree exp, rtx target, int want_value)\n       /* Handle calls that return values in multiple non-contiguous locations.\n \t The Irix 6 ABI has examples of this.  */\n       else if (GET_CODE (target) == PARALLEL)\n-\temit_group_load (target, temp, int_size_in_bytes (TREE_TYPE (exp)));\n+\temit_group_load (target, temp, TREE_TYPE (exp),\n+\t\t\t int_size_in_bytes (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n \temit_block_move (target, temp, expr_size (exp),\n \t\t\t (want_value & 2\n@@ -9268,7 +9288,7 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t\t    /* Handle calls that pass values in multiple\n \t\t       non-contiguous locations.  The Irix 6 ABI has examples\n \t\t       of this.  */\n-\t\t    emit_group_store (memloc, op0,\n+\t\t    emit_group_store (memloc, op0, inner_type,\n \t\t\t\t      int_size_in_bytes (inner_type));\n \t\t  else\n \t\t    emit_move_insn (memloc, op0);"}, {"sha": "ba84fd02ae816806a42b98ed176e4cb6df5460e4", "filename": "gcc/expr.h", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -68,7 +68,6 @@ enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM = 2, EXPAND_SUM,\n \f\n enum direction {none, upward, downward};\n \n-#ifdef TREE_CODE /* Don't lose if tree.h not included.  */\n /* Structure to record the size of a sequence of arguments\n    as the sum of a tree-expression and a constant.  This structure is\n    also used to store offsets from the stack, which might be negative,\n@@ -96,8 +95,9 @@ struct locate_and_pad_arg_data\n   /* The amount that the stack pointer needs to be adjusted to\n      force alignment for the next argument.  */\n   struct args_size alignment_pad;\n+  /* Which way we should pad this arg.  */\n+  enum direction where_pad;\n };\n-#endif\n \n /* Add the value of the tree INC to the `struct args_size' TO.  */\n \n@@ -427,20 +427,18 @@ extern rtx gen_group_rtx (rtx);\n \n /* Load a BLKmode value into non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_load (rtx, rtx, int);\n+extern void emit_group_load (rtx, rtx, tree, int);\n \n /* Move a non-consecutive group of registers represented by a PARALLEL into\n    a non-consecutive group of registers represented by a PARALLEL.  */\n extern void emit_group_move (rtx, rtx);\n \n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_store (rtx, rtx, int);\n+extern void emit_group_store (rtx, rtx, tree, int);\n \n-#ifdef TREE_CODE\n /* Copy BLKmode object from a set of registers.  */\n extern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n-#endif\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n extern void use_reg (rtx *, rtx);\n@@ -490,7 +488,6 @@ extern rtx emit_move_insn_1 (rtx, rtx);\n    and return an rtx to address the beginning of the block.  */\n extern rtx push_block (rtx, int, int);\n \n-#ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n extern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,\n \t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n@@ -503,7 +500,6 @@ extern rtx expand_assignment (tree, tree, int, int);\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n extern rtx store_expr (tree, rtx, int);\n-#endif\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value.\n@@ -535,7 +531,6 @@ extern void clear_pending_stack_adjust (void);\n /* Pop any previously-pushed arguments that have not been popped yet.  */\n extern void do_pending_stack_adjust (void);\n \n-#ifdef TREE_CODE\n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n extern tree string_constant (tree, tree *);\n@@ -549,7 +544,6 @@ extern void jumpif (tree, rtx);\n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n extern void do_jump (tree, rtx, rtx);\n-#endif\n \n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n extern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,\n@@ -566,7 +560,6 @@ extern int try_tablejump (tree, tree, tree, tree, rtx, rtx);\n extern unsigned int case_values_threshold (void);\n \n \f\n-#ifdef TREE_CODE\n /* rtl.h and tree.h were included.  */\n /* Return an rtx for the size in bytes of the value of an expr.  */\n extern rtx expr_size (tree);\n@@ -592,10 +585,13 @@ extern rtx prepare_call_address (rtx, tree, rtx *, int, int);\n \n extern rtx expand_call (tree, rtx, int);\n \n+#ifdef TREE_CODE\n extern rtx expand_shift (enum tree_code, enum machine_mode, rtx, tree, rtx,\n \t\t\t int);\n extern rtx expand_divmod (int, enum tree_code, enum machine_mode, rtx, rtx,\n \t\t\t  rtx, int);\n+#endif\n+\n extern void locate_and_pad_parm (enum machine_mode, tree, int, int, tree,\n \t\t\t\t struct args_size *,\n \t\t\t\t struct locate_and_pad_arg_data *);\n@@ -608,7 +604,6 @@ extern rtx label_rtx (tree);\n    list of its containing function (i.e. it is treated as reachable even\n    if how is not obvious).  */\n extern rtx force_label_rtx (tree);\n-#endif\n \n /* Indicate how an input argument register was promoted.  */\n extern rtx promoted_input_arg (unsigned int, enum machine_mode *, int *);\n@@ -691,7 +686,6 @@ extern rtx widen_memory_access (rtx, enum machine_mode, HOST_WIDE_INT);\n    valid address.  */\n extern rtx validize_mem (rtx);\n \n-#ifdef TREE_CODE\n /* Given REF, either a MEM or a REG, and T, either the type of X or\n    the expression corresponding to REF, set RTX_UNCHANGING_P if\n    appropriate.  */\n@@ -706,7 +700,6 @@ extern void set_mem_attributes (rtx, tree, int);\n    we alter MEM_OFFSET according to T then we should subtract BITPOS\n    expecting that it'll be added back in later.  */\n extern void set_mem_attributes_minus_bitpos (rtx, tree, int, HOST_WIDE_INT);\n-#endif\n \n /* Assemble the static constant template for function entry trampolines.  */\n extern rtx assemble_trampoline_template (void);\n@@ -738,10 +731,8 @@ extern rtx force_reg (enum machine_mode, rtx);\n /* Return given rtx, copied into a new temp reg if it was in memory.  */\n extern rtx force_not_mem (rtx);\n \n-#ifdef TREE_CODE\n /* Return mode and signedness to use when object is promoted.  */\n extern enum machine_mode promote_mode (tree, enum machine_mode, int *, int);\n-#endif\n \n /* Remove some bytes from the stack.  An rtx says how many.  */\n extern void adjust_stack (rtx);\n@@ -812,9 +803,7 @@ extern void do_jump_by_parts_equality_rtx (rtx, rtx, rtx);\n extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n \t\t\t\t\t  rtx, rtx);\n \n-#ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n extern void mark_seen_cases (tree, unsigned char *, HOST_WIDE_INT, int);\n-#endif\n \n extern int vector_mode_valid_p (enum machine_mode);\n "}, {"sha": "c3f4dc604d47bef434e82339d2be32033943c726", "filename": "gcc/function.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -4507,6 +4507,8 @@ assign_parms (tree fndecl)\n \t\t\t\t\t\t  offset_rtx));\n \n \tset_mem_attributes (stack_parm, parm, 1);\n+\tif (entry_parm && MEM_ATTRS (stack_parm)->align < PARM_BOUNDARY)\n+\t  set_mem_align (stack_parm, PARM_BOUNDARY);\n \n \t/* Set also REG_ATTRS if parameter was passed in a register.  */\n \tif (entry_parm)\n@@ -4538,6 +4540,7 @@ assign_parms (tree fndecl)\n \t     locations.  The Irix 6 ABI has examples of this.  */\n \t  if (GET_CODE (entry_parm) == PARALLEL)\n \t    emit_group_store (validize_mem (stack_parm), entry_parm,\n+\t\t\t      TREE_TYPE (parm),\n \t\t\t      int_size_in_bytes (TREE_TYPE (parm)));\n \n \t  else\n@@ -4644,7 +4647,12 @@ assign_parms (tree fndecl)\n \n \t Set DECL_RTL to that place.  */\n \n-      if (nominal_mode == BLKmode || GET_CODE (entry_parm) == PARALLEL)\n+      if (nominal_mode == BLKmode\n+#ifdef BLOCK_REG_PADDING\n+\t  || (locate.where_pad == (BYTES_BIG_ENDIAN ? upward : downward)\n+\t      && GET_MODE_SIZE (promoted_mode) < UNITS_PER_WORD)\n+#endif\n+\t  || GET_CODE (entry_parm) == PARALLEL)\n \t{\n \t  /* If a BLKmode arrives in registers, copy it to a stack slot.\n \t     Handle calls that pass values in multiple non-contiguous\n@@ -4680,7 +4688,7 @@ assign_parms (tree fndecl)\n \t      /* Handle calls that pass values in multiple non-contiguous\n \t\t locations.  The Irix 6 ABI has examples of this.  */\n \t      if (GET_CODE (entry_parm) == PARALLEL)\n-\t\temit_group_store (mem, entry_parm, size);\n+\t\temit_group_store (mem, entry_parm, TREE_TYPE (parm), size);\n \n \t      else if (size == 0)\n \t\t;\n@@ -4692,7 +4700,13 @@ assign_parms (tree fndecl)\n \t\t  enum machine_mode mode\n \t\t    = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0);\n \n-\t\t  if (mode != BLKmode)\n+\t\t  if (mode != BLKmode\n+#ifdef BLOCK_REG_PADDING\n+\t\t      && (size == UNITS_PER_WORD\n+\t\t\t  || (BLOCK_REG_PADDING (mode, TREE_TYPE (parm), 1)\n+\t\t\t      != (BYTES_BIG_ENDIAN ? upward : downward)))\n+#endif\n+\t\t      )\n \t\t    {\n \t\t      rtx reg = gen_rtx_REG (mode, REGNO (entry_parm));\n \t\t      emit_move_insn (change_address (mem, mode, 0), reg);\n@@ -4703,7 +4717,13 @@ assign_parms (tree fndecl)\n \t\t     to memory.  Note that the previous test doesn't\n \t\t     handle all cases (e.g. SIZE == 3).  */\n \t\t  else if (size != UNITS_PER_WORD\n-\t\t\t   && BYTES_BIG_ENDIAN)\n+#ifdef BLOCK_REG_PADDING\n+\t\t\t   && (BLOCK_REG_PADDING (mode, TREE_TYPE (parm), 1)\n+\t\t\t       == downward)\n+#else\n+\t\t\t   && BYTES_BIG_ENDIAN\n+#endif\n+\t\t\t   )\n \t\t    {\n \t\t      rtx tem, x;\n \t\t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n@@ -5367,6 +5387,7 @@ locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n   where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n   boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n+  locate->where_pad = where_pad;\n \n #ifdef ARGS_GROW_DOWNWARD\n   locate->slot_offset.constant = -initial_offset_ptr->constant;\n@@ -7036,6 +7057,7 @@ expand_function_end (void)\n \t\temit_group_move (real_decl_rtl, decl_rtl);\n \t      else\n \t\temit_group_load (real_decl_rtl, decl_rtl,\n+\t\t\t\t TREE_TYPE (decl_result),\n \t\t\t\t int_size_in_bytes (TREE_TYPE (decl_result)));\n \t    }\n \t  else"}, {"sha": "a720691404fc670e89f20869af9635781ddb520f", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e98504002b3ee32c9b3d17da648b01e1424f833/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6e98504002b3ee32c9b3d17da648b01e1424f833", "patch": "@@ -2955,7 +2955,7 @@ expand_value_return (rtx val)\n \tval = convert_modes (mode, old_mode, val, unsignedp);\n #endif\n       if (GET_CODE (return_reg) == PARALLEL)\n-\temit_group_load (return_reg, val, int_size_in_bytes (type));\n+\temit_group_load (return_reg, val, type, int_size_in_bytes (type));\n       else\n \temit_move_insn (return_reg, val);\n     }"}]}