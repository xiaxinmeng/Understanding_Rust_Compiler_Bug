{"sha": "5302cd025063e00bde7d102284f638977dde5f27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMwMmNkMDI1MDYzZTAwYmRlN2QxMDIyODRmNjM4OTc3ZGRlNWYyNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-18T00:15:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-18T00:15:38Z"}, "message": "runtime, reflect: rewrite Go to FFI type conversion in Go\n    \n    As we move toward the Go 1.7 garbage collector, it's essential that all\n    allocation of values that can contain Go pointers be done using the\n    correct type descriptor.  That is simplest if we do all such allocation\n    in Go code.  This rewrites the code that converts from a Go type to a\n    libffi CIF into Go.\n    \n    Reviewed-on: https://go-review.googlesource.com/33353\n\nFrom-SVN: r242578", "tree": {"sha": "67be8f93c3e7e9a2a592f5932622a54083146948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67be8f93c3e7e9a2a592f5932622a54083146948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5302cd025063e00bde7d102284f638977dde5f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5302cd025063e00bde7d102284f638977dde5f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5302cd025063e00bde7d102284f638977dde5f27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5302cd025063e00bde7d102284f638977dde5f27/comments", "author": null, "committer": null, "parents": [{"sha": "f97db488a6ad72106426990653fa397d690d1654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97db488a6ad72106426990653fa397d690d1654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f97db488a6ad72106426990653fa397d690d1654"}], "stats": {"total": 811, "additions": 472, "deletions": 339}, "files": [{"sha": "bb8729d696cf21794938d48f8eb82c4b76ee780d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -1,4 +1,4 @@\n-d9189ebc139ff739af956094626ccc5eb92c3091\n+bc5ad6d10092d6238495357468ee093f7caf39f9\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "1e2384690c881654959e20c4c75bca3e2bc9d6bd", "filename": "libgo/Makefile.am", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -1052,6 +1052,14 @@ runtime_internal_atomic_lo_check_GOCFLAGS = -fgo-compiling-runtime\n runtime_internal_sys_lo_GOCFLAGS = -fgo-compiling-runtime\n runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n \n+# If libffi is supported (the normal case) use the ffi build tag for\n+# the runtime package.\n+if USE_LIBFFI\n+matchargs_runtime = --tag=libffi\n+else\n+matchargs_runtime =\n+endif\n+\n # At least for now, we need -static-libgo for this test, because\n # otherwise we can't get the line numbers.\n # Also use -fno-inline to get better results from the memory profiler."}, {"sha": "08ba210e0b0f3ed6640e87573a709ff73996410b", "filename": "libgo/Makefile.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -1154,6 +1154,11 @@ runtime_internal_atomic_lo_GOCFLAGS = -fgo-compiling-runtime\n runtime_internal_atomic_lo_check_GOCFLAGS = -fgo-compiling-runtime\n runtime_internal_sys_lo_GOCFLAGS = -fgo-compiling-runtime\n runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n+@USE_LIBFFI_FALSE@matchargs_runtime = \n+\n+# If libffi is supported (the normal case) use the ffi build tag for\n+# the runtime package.\n+@USE_LIBFFI_TRUE@matchargs_runtime = --tag=libffi\n \n # At least for now, we need -static-libgo for this test, because\n # otherwise we can't get the line numbers."}, {"sha": "868adcd488140272e873615366d3410363c8a704", "filename": "libgo/configure", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -665,6 +665,8 @@ LIBGO_IS_DARWIN_FALSE\n LIBGO_IS_DARWIN_TRUE\n go_include\n LIBATOMIC\n+USE_LIBFFI_FALSE\n+USE_LIBFFI_TRUE\n LIBFFIINCS\n LIBFFI\n nover_glibgo_toolexeclibdir\n@@ -11098,7 +11100,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11101 \"configure\"\n+#line 11106 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13466,6 +13468,14 @@ $as_echo \"#define USE_LIBFFI 1\" >>confdefs.h\n fi\n \n \n+ if test \"$with_liffi\" != \"no\"; then\n+  USE_LIBFFI_TRUE=\n+  USE_LIBFFI_FALSE='#'\n+else\n+  USE_LIBFFI_TRUE='#'\n+  USE_LIBFFI_FALSE=\n+fi\n+\n \n # See if the user wants to configure without libatomic. This is useful if we are\n # on an architecture for which libgo does not need an atomic support library and\n@@ -15596,6 +15606,10 @@ if test -z \"${MAINTAINER_MODE_TRUE}\" && test -z \"${MAINTAINER_MODE_FALSE}\"; then\n   as_fn_error \"conditional \\\"MAINTAINER_MODE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${USE_LIBFFI_TRUE}\" && test -z \"${USE_LIBFFI_FALSE}\"; then\n+  as_fn_error \"conditional \\\"USE_LIBFFI\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_DARWIN_TRUE}\" && test -z \"${LIBGO_IS_DARWIN_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_DARWIN\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "9e765404739e38127ec62dd17f9f672995286bf1", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -121,6 +121,7 @@ if test \"$with_libffi\" != no; then\n fi\n AC_SUBST(LIBFFI)\n AC_SUBST(LIBFFIINCS)\n+AM_CONDITIONAL(USE_LIBFFI, test \"$with_liffi\" != \"no\")\n \n # See if the user wants to configure without libatomic. This is useful if we are\n # on an architecture for which libgo does not need an atomic support library and"}, {"sha": "3a9fd2897b7359e62f8c85b0e25a24b3b14108bd", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -63,7 +63,7 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \t\tmethod: -1,\n \t}\n \n-\tmakeFuncFFI(ftyp, unsafe.Pointer(impl))\n+\tmakeFuncFFI(makeCIF(ftyp), unsafe.Pointer(impl))\n \n \treturn Value{t, unsafe.Pointer(&impl), flag(Func) | flagIndir}\n }\n@@ -102,7 +102,7 @@ func makeMethodValue(op string, v Value) Value {\n \t\trcvr:   rcvr,\n \t}\n \n-\tmakeFuncFFI(ftyp, unsafe.Pointer(fv))\n+\tmakeFuncFFI(makeCIF(ftyp), unsafe.Pointer(fv))\n \n \treturn Value{ft, unsafe.Pointer(&fv), v.flag&flagRO | flag(Func) | flagIndir}\n }\n@@ -128,7 +128,7 @@ func makeValueMethod(v Value) Value {\n \t\trcvr:   v,\n \t}\n \n-\tmakeFuncFFI(ftyp, unsafe.Pointer(impl))\n+\tmakeFuncFFI(makeCIF(ftyp), unsafe.Pointer(impl))\n \n \treturn Value{t, unsafe.Pointer(&impl), v.flag&flagRO | flag(Func) | flagIndir}\n }"}, {"sha": "2acf7bb887a2ba6fbd15c9ed8084cd690ecd211e", "filename": "libgo/go/reflect/makefunc_ffi.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -10,7 +10,10 @@ import (\n \n // The makeFuncFFI function, written in C, fills in an FFI closure.\n // It arranges for ffiCall to be invoked directly from FFI.\n-func makeFuncFFI(ftyp *funcType, impl unsafe.Pointer)\n+func makeFuncFFI(cif unsafe.Pointer, impl unsafe.Pointer)\n+\n+// The makeCIF function, implemented in the runtime package, allocates a CIF.\n+func makeCIF(ft *funcType) unsafe.Pointer\n \n // FFICallbackGo implements the Go side of the libffi callback.\n // It is exported so that C code can call it."}, {"sha": "d3935eb0b73175b909f96c53662648f6c9f7caf1", "filename": "libgo/go/reflect/makefunc_ffi_c.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -8,7 +8,7 @@\n \n #ifdef USE_LIBFFI\n \n-#include \"go-ffi.h\"\n+#include \"ffi.h\"\n \n #if FFI_GO_CLOSURES\n #define USE_LIBFFI_CLOSURES\n@@ -18,7 +18,7 @@\n \n /* Declare C functions with the names used to call from Go.  */\n \n-void makeFuncFFI(const struct __go_func_type *ftyp, void *impl)\n+void makeFuncFFI(void *cif, void *impl)\n   __asm__ (GOSYM_PREFIX \"reflect.makeFuncFFI\");\n \n #ifdef USE_LIBFFI_CLOSURES\n@@ -70,20 +70,15 @@ ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n /* Allocate an FFI closure and arrange to call ffi_callback.  */\n \n void\n-makeFuncFFI(const struct __go_func_type *ftyp, void *impl)\n+makeFuncFFI(void *cif, void *impl)\n {\n-  ffi_cif *cif;\n-\n-  cif = (ffi_cif *) __go_alloc (sizeof (ffi_cif));\n-  __go_func_to_cif (ftyp, 0, 0, cif);\n-\n-  ffi_prep_go_closure(impl, cif, ffi_callback);\n+  ffi_prep_go_closure(impl, (ffi_cif*)cif, ffi_callback);\n }\n \n #else /* !defined(USE_LIBFFI_CLOSURES) */\n \n void\n-makeFuncFFI(const struct __go_func_type *ftyp __attribute__ ((unused)),\n+makeFuncFFI(void *cif __attribute__ ((unused)),\n \t    void *impl __attribute__ ((unused)))\n {\n   runtime_panicstring (\"libgo built without FFI does not support \""}, {"sha": "164e1770ea2b55afadd4ac48466e3650ac5a74a1", "filename": "libgo/go/runtime/ffi.go", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Fruntime%2Fffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fgo%2Fruntime%2Fffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fffi.go?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Only build this file if libffi is supported.\n+\n+// +build libffi\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+// This file contains the code that converts a Go type to an FFI type.\n+// This has to be written in Go because it allocates memory in the Go heap.\n+\n+// C functions to return pointers to libffi variables.\n+\n+func ffi_type_pointer() *__ffi_type\n+func ffi_type_sint8() *__ffi_type\n+func ffi_type_sint16() *__ffi_type\n+func ffi_type_sint32() *__ffi_type\n+func ffi_type_sint64() *__ffi_type\n+func ffi_type_uint8() *__ffi_type\n+func ffi_type_uint16() *__ffi_type\n+func ffi_type_uint32() *__ffi_type\n+func ffi_type_uint64() *__ffi_type\n+func ffi_type_float() *__ffi_type\n+func ffi_type_double() *__ffi_type\n+func ffi_supports_complex() bool\n+func ffi_type_complex_float() *__ffi_type\n+func ffi_type_complex_double() *__ffi_type\n+func ffi_type_void() *__ffi_type\n+\n+// C functions defined in libffi.\n+\n+//extern ffi_prep_cif\n+func ffi_prep_cif(*_ffi_cif, _ffi_abi, uint32, *__ffi_type, **__ffi_type) _ffi_status\n+\n+// ffiFuncToCIF is called from C code.\n+//go:linkname ffiFuncToCIF runtime.ffiFuncToCIF\n+\n+// ffiFuncToCIF builds an _ffi_cif struct for function described by ft.\n+func ffiFuncToCIF(ft *functype, isInterface bool, isMethod bool, cif *_ffi_cif) {\n+\tnparams := len(ft.in)\n+\tnargs := nparams\n+\tif isInterface {\n+\t\tnargs++\n+\t}\n+\targs := make([]*__ffi_type, nargs)\n+\ti := 0\n+\toff := 0\n+\tif isInterface {\n+\t\targs[0] = ffi_type_pointer()\n+\t\toff = 1\n+\t} else if isMethod {\n+\t\targs[0] = ffi_type_pointer()\n+\t\ti = 1\n+\t}\n+\tfor ; i < nparams; i++ {\n+\t\targs[i+off] = typeToFFI(ft.in[i])\n+\t}\n+\n+\trettype := funcReturnFFI(ft)\n+\n+\tvar pargs **__ffi_type\n+\tif len(args) > 0 {\n+\t\tpargs = &args[0]\n+\t}\n+\tstatus := ffi_prep_cif(cif, _FFI_DEFAULT_ABI, uint32(nargs), rettype, pargs)\n+\tif status != _FFI_OK {\n+\t\tthrow(\"ffi_prep_cif failed\")\n+\t}\n+}\n+\n+// funcReturnFFI returns the FFI definition of the return type of ft.\n+func funcReturnFFI(ft *functype) *__ffi_type {\n+\tc := len(ft.out)\n+\tif c == 0 {\n+\t\treturn ffi_type_void()\n+\t}\n+\n+\t// Compile a function that returns a zero-sized value as\n+\t// though it returns void. This works around a problem in\n+\t// libffi: it can't represent a zero-sized value.\n+\tvar size uintptr\n+\tfor _, v := range ft.out {\n+\t\tsize += v.size\n+\t}\n+\tif size == 0 {\n+\t\treturn ffi_type_void()\n+\t}\n+\n+\tif c == 1 {\n+\t\treturn typeToFFI(ft.out[0])\n+\t}\n+\n+\telements := make([]*__ffi_type, c+1)\n+\tfor i, v := range ft.out {\n+\t\telements[i] = typeToFFI(v)\n+\t}\n+\telements[c] = nil\n+\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// typeToFFI returns the __ffi_type for a Go type.\n+func typeToFFI(typ *_type) *__ffi_type {\n+\tswitch typ.kind & kindMask {\n+\tcase kindBool:\n+\t\tswitch unsafe.Sizeof(false) {\n+\t\tcase 1:\n+\t\t\treturn ffi_type_uint8()\n+\t\tcase 4:\n+\t\t\treturn ffi_type_uint32()\n+\t\tdefault:\n+\t\t\tthrow(\"bad bool size\")\n+\t\t\treturn nil\n+\t\t}\n+\tcase kindInt:\n+\t\treturn intToFFI()\n+\tcase kindInt8:\n+\t\treturn ffi_type_sint8()\n+\tcase kindInt16:\n+\t\treturn ffi_type_sint16()\n+\tcase kindInt32:\n+\t\treturn ffi_type_sint32()\n+\tcase kindInt64:\n+\t\treturn ffi_type_sint64()\n+\tcase kindUint:\n+\t\tswitch unsafe.Sizeof(uint(0)) {\n+\t\tcase 4:\n+\t\t\treturn ffi_type_uint32()\n+\t\tcase 8:\n+\t\t\treturn ffi_type_uint64()\n+\t\tdefault:\n+\t\t\tthrow(\"bad uint size\")\n+\t\t\treturn nil\n+\t\t}\n+\tcase kindUint8:\n+\t\treturn ffi_type_uint8()\n+\tcase kindUint16:\n+\t\treturn ffi_type_uint16()\n+\tcase kindUint32:\n+\t\treturn ffi_type_uint32()\n+\tcase kindUint64:\n+\t\treturn ffi_type_uint64()\n+\tcase kindUintptr:\n+\t\tswitch unsafe.Sizeof(uintptr(0)) {\n+\t\tcase 4:\n+\t\t\treturn ffi_type_uint32()\n+\t\tcase 8:\n+\t\t\treturn ffi_type_uint64()\n+\t\tdefault:\n+\t\t\tthrow(\"bad uinptr size\")\n+\t\t\treturn nil\n+\t\t}\n+\tcase kindFloat32:\n+\t\treturn ffi_type_float()\n+\tcase kindFloat64:\n+\t\treturn ffi_type_double()\n+\tcase kindComplex64:\n+\t\tif ffi_supports_complex() {\n+\t\t\treturn ffi_type_complex_float()\n+\t\t} else {\n+\t\t\treturn complexToFFI(ffi_type_float())\n+\t\t}\n+\tcase kindComplex128:\n+\t\tif ffi_supports_complex() {\n+\t\t\treturn ffi_type_complex_double()\n+\t\t} else {\n+\t\t\treturn complexToFFI(ffi_type_double())\n+\t\t}\n+\tcase kindArray:\n+\t\treturn arrayToFFI((*arraytype)(unsafe.Pointer(typ)))\n+\tcase kindChan, kindFunc, kindMap, kindPtr, kindUnsafePointer:\n+\t\t// These types are always simple pointers, and for FFI\n+\t\t// purposes nothing else matters.\n+\t\treturn ffi_type_pointer()\n+\tcase kindInterface:\n+\t\treturn interfaceToFFI()\n+\tcase kindSlice:\n+\t\treturn sliceToFFI((*slicetype)(unsafe.Pointer(typ)))\n+\tcase kindString:\n+\t\treturn stringToFFI()\n+\tcase kindStruct:\n+\t\treturn structToFFI((*structtype)(unsafe.Pointer(typ)))\n+\tdefault:\n+\t\tthrow(\"unknown type kind\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// interfaceToFFI returns an ffi_type for a Go interface type.\n+// This is used for both empty and non-empty interface types.\n+func interfaceToFFI() *__ffi_type {\n+\telements := make([]*__ffi_type, 3)\n+\telements[0] = ffi_type_pointer()\n+\telements[1] = elements[0]\n+\telements[2] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// stringToFFI returns an ffi_type for a Go string type.\n+func stringToFFI() *__ffi_type {\n+\telements := make([]*__ffi_type, 3)\n+\telements[0] = ffi_type_pointer()\n+\telements[1] = intToFFI()\n+\telements[2] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// structToFFI returns an ffi_type for a Go struct type.\n+func structToFFI(typ *structtype) *__ffi_type {\n+\tc := len(typ.fields)\n+\tif c == 0 {\n+\t\treturn emptyStructToFFI()\n+\t}\n+\n+\tfields := make([]*__ffi_type, c+1)\n+\tfor i, v := range typ.fields {\n+\t\tfields[i] = typeToFFI(v.typ)\n+\t}\n+\tfields[c] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &fields[0],\n+\t}\n+}\n+\n+// sliceToFFI returns an ffi_type for a Go slice type.\n+func sliceToFFI(typ *slicetype) *__ffi_type {\n+\telements := make([]*__ffi_type, 4)\n+\telements[0] = ffi_type_pointer()\n+\telements[1] = intToFFI()\n+\telements[2] = elements[1]\n+\telements[3] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// complexToFFI returns an ffi_type for a Go complex type.\n+// This is only used if libffi does not support complex types internally\n+// for this target.\n+func complexToFFI(ffiFloatType *__ffi_type) *__ffi_type {\n+\telements := make([]*__ffi_type, 3)\n+\telements[0] = ffiFloatType\n+\telements[1] = ffiFloatType\n+\telements[2] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// arrayToFFI returns an ffi_type for a Go array type.\n+func arrayToFFI(typ *arraytype) *__ffi_type {\n+\tif typ.len == 0 {\n+\t\treturn emptyStructToFFI()\n+\t}\n+\telements := make([]*__ffi_type, typ.len+1)\n+\tet := typeToFFI(typ.elem)\n+\tfor i := uintptr(0); i < typ.len; i++ {\n+\t\telements[i] = et\n+\t}\n+\telements[typ.len] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+// intToFFI returns an ffi_type for the Go int type.\n+func intToFFI() *__ffi_type {\n+\tswitch unsafe.Sizeof(0) {\n+\tcase 4:\n+\t\treturn ffi_type_sint32()\n+\tcase 8:\n+\t\treturn ffi_type_sint64()\n+\tdefault:\n+\t\tthrow(\"bad int size\")\n+\t\treturn nil\n+\t}\n+}\n+\n+// emptyStructToFFI returns an ffi_type for an empty struct.\n+// The libffi library won't accept a struct with no fields.\n+func emptyStructToFFI() *__ffi_type {\n+\telements := make([]*__ffi_type, 2)\n+\telements[0] = ffi_type_void()\n+\telements[1] = nil\n+\treturn &__ffi_type{\n+\t\t_type:    _FFI_TYPE_STRUCT,\n+\t\telements: &elements[0],\n+\t}\n+}\n+\n+//go:linkname makeCIF reflect.makeCIF\n+\n+// makeCIF is used by the reflect package to allocate a CIF.\n+func makeCIF(ft *functype) *_ffi_cif {\n+\tcif := new(_ffi_cif)\n+\tffiFuncToCIF(ft, false, false, cif)\n+\treturn cif\n+}"}, {"sha": "af1859450108f687bc94b3c98b96fd90cb912f19", "filename": "libgo/mkrsysinfo.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fmkrsysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fmkrsysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkrsysinfo.sh?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -18,6 +18,7 @@ echo 'package runtime' > ${OUT}\n # will all have a leading underscore.\n grep -v '^// ' gen-sysinfo.go | \\\n   grep -v '^func' | \\\n+  grep -v '^var ' | \\\n   grep -v '^type _timeval ' | \\\n   grep -v '^type _timespec_t ' | \\\n   grep -v '^type _timespec ' | \\"}, {"sha": "b030f5e918ed3d5f4328f53d83ba03da38f91799", "filename": "libgo/runtime/go-ffi.c", "status": "modified", "additions": 100, "deletions": 305, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fruntime%2Fgo-ffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fruntime%2Fgo-ffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.c?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -1,357 +1,152 @@\n-/* go-ffi.c -- convert Go type description to libffi.\n+/* go-ffi.c -- libffi support functions.\n \n    Copyright 2009 The Go Authors. All rights reserved.\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n-#include <stdio.h>\n-#include <stdint.h>\n #include <stdlib.h>\n \n #include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-type.h\"\n \n #ifdef USE_LIBFFI\n \n #include \"ffi.h\"\n \n-/* The functions in this file are only called from reflect_call and\n-   reflect.ffi.  As these functions call libffi functions, which will\n-   be compiled without -fsplit-stack, they will always run with a\n-   large stack.  */\n-\n-static ffi_type *go_array_to_ffi (const struct __go_array_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_slice_to_ffi (const struct __go_slice_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_struct_to_ffi (const struct __go_struct_type *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_string_to_ffi (void) __attribute__ ((no_split_stack));\n-static ffi_type *go_interface_to_ffi (void) __attribute__ ((no_split_stack));\n-static ffi_type *go_type_to_ffi (const struct __go_type_descriptor *)\n-  __attribute__ ((no_split_stack));\n-static ffi_type *go_func_return_ffi (const struct __go_func_type *)\n-  __attribute__ ((no_split_stack));\n-\n-/* Return an ffi_type for a Go array type.  The libffi library does\n-   not have any builtin support for passing arrays as values.  We work\n-   around this by pretending that the array is a struct.  */\n-\n-static ffi_type *\n-go_array_to_ffi (const struct __go_array_type *descriptor)\n+/* The functions in this file are called by the Go runtime code to get\n+   the libffi type values.  */\n+\n+ffi_type *go_ffi_type_pointer(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_pointer(void) __asm__ (\"runtime.ffi_type_pointer\");\n+ffi_type *go_ffi_type_sint8(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_sint8(void) __asm__ (\"runtime.ffi_type_sint8\");\n+ffi_type *go_ffi_type_sint16(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_sint16(void) __asm__ (\"runtime.ffi_type_sint16\");\n+ffi_type *go_ffi_type_sint32(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_sint32(void) __asm__ (\"runtime.ffi_type_sint32\");\n+ffi_type *go_ffi_type_sint64(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_sint64(void) __asm__ (\"runtime.ffi_type_sint64\");\n+ffi_type *go_ffi_type_uint8(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_uint8(void) __asm__ (\"runtime.ffi_type_uint8\");\n+ffi_type *go_ffi_type_uint16(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_uint16(void) __asm__ (\"runtime.ffi_type_uint16\");\n+ffi_type *go_ffi_type_uint32(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_uint32(void) __asm__ (\"runtime.ffi_type_uint32\");\n+ffi_type *go_ffi_type_uint64(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_uint64(void) __asm__ (\"runtime.ffi_type_uint64\");\n+ffi_type *go_ffi_type_float(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_float(void) __asm__ (\"runtime.ffi_type_float\");\n+ffi_type *go_ffi_type_double(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_double(void) __asm__ (\"runtime.ffi_type_double\");\n+ffi_type *go_ffi_type_complex_float(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_complex_float(void) __asm__ (\"runtime.ffi_type_complex_float\");\n+ffi_type *go_ffi_type_complex_double(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_complex_double(void) __asm__ (\"runtime.ffi_type_complex_double\");\n+ffi_type *go_ffi_type_void(void) __attribute__ ((no_split_stack));\n+ffi_type *go_ffi_type_void(void) __asm__ (\"runtime.ffi_type_void\");\n+\n+_Bool go_ffi_supports_complex(void) __attribute__ ((no_split_stack));\n+_Bool go_ffi_supports_complex(void) __asm__ (\"runtime.ffi_supports_complex\");\n+\n+ffi_type *\n+go_ffi_type_pointer(void)\n {\n-  ffi_type *ret;\n-  uintptr_t len;\n-  ffi_type *element;\n-  uintptr_t i;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  len = descriptor->__len;\n-  if (len == 0)\n-    {\n-      /* The libffi library won't accept an empty struct.  */\n-      ret->elements = (ffi_type **) __go_alloc (2 * sizeof (ffi_type *));\n-      ret->elements[0] = &ffi_type_void;\n-      ret->elements[1] = NULL;\n-      return ret;\n-    }\n-  ret->elements = (ffi_type **) __go_alloc ((len + 1) * sizeof (ffi_type *));\n-  element = go_type_to_ffi (descriptor->__element_type);\n-  for (i = 0; i < len; ++i)\n-    ret->elements[i] = element;\n-  ret->elements[len] = NULL;\n-  return ret;\n+\treturn &ffi_type_pointer;\n }\n \n-/* Return an ffi_type for a Go slice type.  This describes the\n-   __go_open_array type defines in array.h.  */\n-\n-static ffi_type *\n-go_slice_to_ffi (\n-    const struct __go_slice_type *descriptor __attribute__ ((unused)))\n+ffi_type *\n+go_ffi_type_sint8(void)\n {\n-  ffi_type *ret;\n-  ffi_type *ffi_intgo;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (4 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-  ret->elements[1] = ffi_intgo;\n-  ret->elements[2] = ffi_intgo;\n-  ret->elements[3] = NULL;\n-  return ret;\n+\treturn &ffi_type_sint8;\n }\n \n-/* Return an ffi_type for a Go struct type.  */\n-\n-static ffi_type *\n-go_struct_to_ffi (const struct __go_struct_type *descriptor)\n+ffi_type *\n+go_ffi_type_sint16(void)\n {\n-  ffi_type *ret;\n-  int field_count;\n-  const struct __go_struct_field *fields;\n-  int i;\n-\n-  field_count = descriptor->__fields.__count;\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  if (field_count == 0)\n-    {\n-      /* The libffi library won't accept an empty struct.  */\n-      ret->elements = (ffi_type **) __go_alloc (2 * sizeof (ffi_type *));\n-      ret->elements[0] = &ffi_type_void;\n-      ret->elements[1] = NULL;\n-      return ret;\n-    }\n-  fields = (const struct __go_struct_field *) descriptor->__fields.__values;\n-  ret->elements = (ffi_type **) __go_alloc ((field_count + 1)\n-\t\t\t\t\t    * sizeof (ffi_type *));\n-  for (i = 0; i < field_count; ++i)\n-    ret->elements[i] = go_type_to_ffi (fields[i].__type);\n-  ret->elements[field_count] = NULL;\n-  return ret;\n+\treturn &ffi_type_sint16;\n }\n \n-/* Return an ffi_type for a Go string type.  This describes the String\n-   struct.  */\n-\n-static ffi_type *\n-go_string_to_ffi (void)\n+ffi_type *\n+go_ffi_type_sint32(void)\n {\n-  ffi_type *ret;\n-  ffi_type *ffi_intgo;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ffi_intgo = sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-  ret->elements[1] = ffi_intgo;\n-  ret->elements[2] = NULL;\n-  return ret;\n+\treturn &ffi_type_sint32;\n }\n \n-/* Return an ffi_type for a Go interface type.  This describes the\n-   __go_interface and __go_empty_interface structs.  */\n-\n-static ffi_type *\n-go_interface_to_ffi (void)\n+ffi_type *\n+go_ffi_type_sint64(void)\n {\n-  ffi_type *ret;\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = &ffi_type_pointer;\n-  ret->elements[1] = &ffi_type_pointer;\n-  ret->elements[2] = NULL;\n-  return ret;\n+\treturn &ffi_type_sint64;\n }\n \n+ffi_type *\n+go_ffi_type_uint8(void)\n+{\n+\treturn &ffi_type_uint8;\n+}\n \n-#ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n-/* If libffi hasn't been updated for this target to support complex,\n-   pretend complex is a structure.  Warning: This does not work for\n-   all ABIs.  Eventually libffi should be updated for all targets\n-   and this should go away.  */\n-\n-static ffi_type *go_complex_to_ffi (ffi_type *)\n-  __attribute__ ((no_split_stack));\n-\n-static ffi_type *\n-go_complex_to_ffi (ffi_type *float_type)\n+ffi_type *\n+go_ffi_type_uint16(void)\n {\n-  ffi_type *ret;\n+\treturn &ffi_type_uint16;\n+}\n \n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc (3 * sizeof (ffi_type *));\n-  ret->elements[0] = float_type;\n-  ret->elements[1] = float_type;\n-  ret->elements[2] = NULL;\n-  return ret;\n+ffi_type *\n+go_ffi_type_uint32(void)\n+{\n+\treturn &ffi_type_uint32;\n }\n-#endif\n \n-/* Return an ffi_type for a type described by a\n-   __go_type_descriptor.  */\n+ffi_type *\n+go_ffi_type_uint64(void)\n+{\n+\treturn &ffi_type_uint64;\n+}\n \n-static ffi_type *\n-go_type_to_ffi (const struct __go_type_descriptor *descriptor)\n+ffi_type *\n+go_ffi_type_float(void)\n {\n-  switch (descriptor->__code & GO_CODE_MASK)\n-    {\n-    case GO_BOOL:\n-      if (sizeof (_Bool) == 1)\n-\treturn &ffi_type_uint8;\n-      else if (sizeof (_Bool) == sizeof (int))\n-\treturn &ffi_type_uint;\n-      abort ();\n-    case GO_FLOAT32:\n-      if (sizeof (float) == 4)\n \treturn &ffi_type_float;\n-      abort ();\n-    case GO_FLOAT64:\n-      if (sizeof (double) == 8)\n+}\n+\n+ffi_type *\n+go_ffi_type_double(void)\n+{\n \treturn &ffi_type_double;\n-      abort ();\n-    case GO_COMPLEX64:\n-      if (sizeof (float) == 4)\n-\t{\n+}\n+\n+_Bool\n+go_ffi_supports_complex(void)\n+{\n #ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n-\t  return &ffi_type_complex_float;\n+\treturn true;\n #else\n-\t  return go_complex_to_ffi (&ffi_type_float);\n+\treturn false;\n #endif\n-\t}\n-      abort ();\n-    case GO_COMPLEX128:\n-      if (sizeof (double) == 8)\n-\t{\n+}\n+\n+ffi_type *\n+go_ffi_type_complex_float(void)\n+{\n #ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n-\t  return &ffi_type_complex_double;\n+\treturn &ffi_type_complex_float;\n #else\n-\t  return go_complex_to_ffi (&ffi_type_double);\n+\tabort();\n #endif\n-\t}\n-      abort ();\n-    case GO_INT16:\n-      return &ffi_type_sint16;\n-    case GO_INT32:\n-      return &ffi_type_sint32;\n-    case GO_INT64:\n-      return &ffi_type_sint64;\n-    case GO_INT8:\n-      return &ffi_type_sint8;\n-    case GO_INT:\n-      return sizeof (intgo) == 4 ? &ffi_type_sint32 : &ffi_type_sint64;\n-    case GO_UINT16:\n-      return &ffi_type_uint16;\n-    case GO_UINT32:\n-      return &ffi_type_uint32;\n-    case GO_UINT64:\n-      return &ffi_type_uint64;\n-    case GO_UINT8:\n-      return &ffi_type_uint8;\n-    case GO_UINT:\n-      return sizeof (uintgo) == 4 ? &ffi_type_uint32 : &ffi_type_uint64;\n-    case GO_UINTPTR:\n-      if (sizeof (void *) == 2)\n-\treturn &ffi_type_uint16;\n-      else if (sizeof (void *) == 4)\n-\treturn &ffi_type_uint32;\n-      else if (sizeof (void *) == 8)\n-\treturn &ffi_type_uint64;\n-      abort ();\n-    case GO_ARRAY:\n-      return go_array_to_ffi ((const struct __go_array_type *) descriptor);\n-    case GO_SLICE:\n-      return go_slice_to_ffi ((const struct __go_slice_type *) descriptor);\n-    case GO_STRUCT:\n-      return go_struct_to_ffi ((const struct __go_struct_type *) descriptor);\n-    case GO_STRING:\n-      return go_string_to_ffi ();\n-    case GO_INTERFACE:\n-      return go_interface_to_ffi ();\n-    case GO_CHAN:\n-    case GO_FUNC:\n-    case GO_MAP:\n-    case GO_PTR:\n-    case GO_UNSAFE_POINTER:\n-      /* These types are always pointers, and for FFI purposes nothing\n-\t else matters.  */\n-      return &ffi_type_pointer;\n-    default:\n-      abort ();\n-    }\n }\n \n-/* Return the return type for a function, given the number of out\n-   parameters and their types.  */\n-\n-static ffi_type *\n-go_func_return_ffi (const struct __go_func_type *func)\n+ffi_type *\n+go_ffi_type_complex_double(void)\n {\n-  int count;\n-  const struct __go_type_descriptor **types;\n-  ffi_type *ret;\n-  int i;\n-\n-  count = func->__out.__count;\n-  if (count == 0)\n-    return &ffi_type_void;\n-\n-  types = (const struct __go_type_descriptor **) func->__out.__values;\n-\n-  // We compile a function that returns a zero-sized value as though\n-  // it returns void.  This works around a problem in libffi: it can't\n-  // represent a zero-sized value.\n-  for (i = 0; i < count; ++i)\n-    {\n-      if (types[i]->__size > 0)\n-\tbreak;\n-    }\n-  if (i == count)\n-    return &ffi_type_void;\n-\n-  if (count == 1)\n-    return go_type_to_ffi (types[0]);\n-\n-  ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n-  ret->type = FFI_TYPE_STRUCT;\n-  ret->elements = (ffi_type **) __go_alloc ((count + 1) * sizeof (ffi_type *));\n-  for (i = 0; i < count; ++i)\n-    ret->elements[i] = go_type_to_ffi (types[i]);\n-  ret->elements[count] = NULL;\n-  return ret;\n+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n+\treturn &ffi_type_complex_double;\n+#else\n+\tabort();\n+#endif\n }\n \n-/* Build an ffi_cif structure for a function described by a\n-   __go_func_type structure.  */\n-\n-void\n-__go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n-\t\t_Bool is_method, ffi_cif *cif)\n+ffi_type *\n+go_ffi_type_void(void)\n {\n-  int num_params;\n-  const struct __go_type_descriptor **in_types;\n-  size_t num_args;\n-  ffi_type **args;\n-  int off;\n-  int i;\n-  ffi_type *rettype;\n-  ffi_status status;\n-\n-  num_params = func->__in.__count;\n-  in_types = ((const struct __go_type_descriptor **)\n-\t      func->__in.__values);\n-\n-  num_args = num_params + (is_interface ? 1 : 0);\n-  args = (ffi_type **) __go_alloc (num_args * sizeof (ffi_type *));\n-  i = 0;\n-  off = 0;\n-  if (is_interface)\n-    {\n-      args[0] = &ffi_type_pointer;\n-      off = 1;\n-    }\n-  else if (is_method)\n-    {\n-      args[0] = &ffi_type_pointer;\n-      i = 1;\n-    }\n-  for (; i < num_params; ++i)\n-    args[i + off] = go_type_to_ffi (in_types[i]);\n-\n-  rettype = go_func_return_ffi (func);\n-\n-  status = ffi_prep_cif (cif, FFI_DEFAULT_ABI, num_args, rettype, args);\n-  __go_assert (status == FFI_OK);\n+\treturn &ffi_type_void;\n }\n \n #endif /* defined(USE_LIBFFI) */"}, {"sha": "afae4b6d6ed8f87791df7c7c0c55ab8c680bec44", "filename": "libgo/runtime/go-ffi.h", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f97db488a6ad72106426990653fa397d690d1654/libgo%2Fruntime%2Fgo-ffi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f97db488a6ad72106426990653fa397d690d1654/libgo%2Fruntime%2Fgo-ffi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.h?ref=f97db488a6ad72106426990653fa397d690d1654", "patch": "@@ -1,16 +0,0 @@\n-/* go-ffi.c -- convert Go type description to libffi.\n-\n-   Copyright 2014 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"config.h\"\n-#include \"go-type.h\"\n-\n-#ifdef USE_LIBFFI\n-\n-#include \"ffi.h\"\n-\n-void __go_func_to_cif (const struct __go_func_type *, _Bool, _Bool, ffi_cif *);\n-\n-#endif"}, {"sha": "dc2f60575ecee148ffac0d5afa9b49199fcee3b8", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -12,7 +12,10 @@\n #include \"go-alloc.h\"\n #include \"go-assert.h\"\n #include \"go-type.h\"\n-#include \"go-ffi.h\"\n+\n+#ifdef USE_LIBFFI\n+#include \"ffi.h\"\n+#endif\n \n #if defined(USE_LIBFFI) && FFI_GO_CLOSURES\n \n@@ -197,6 +200,11 @@ go_set_results (const struct __go_func_type *func, unsigned char *call_result,\n     }\n }\n \n+/* The code that converts the Go type to an FFI type is written in Go,\n+   so that it can allocate Go heap memory.  */\n+extern void ffiFuncToCIF(const struct __go_func_type*, _Bool, _Bool, ffi_cif*)\n+  __asm__ (\"runtime.ffiFuncToCIF\");\n+\n /* Call a function.  The type of the function is FUNC_TYPE, and the\n    closure is FUNC_VAL.  PARAMS is an array of parameter addresses.\n    RESULTS is an array of result addresses.\n@@ -218,7 +226,7 @@ reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n   unsigned char *call_result;\n \n   __go_assert ((func_type->__common.__code & GO_CODE_MASK) == GO_FUNC);\n-  __go_func_to_cif (func_type, is_interface, is_method, &cif);\n+  ffiFuncToCIF (func_type, is_interface, is_method, &cif);\n \n   call_result = (unsigned char *) malloc (go_results_size (func_type));\n "}, {"sha": "235941b621152763658e6029896e853f79c401b6", "filename": "libgo/sysinfo.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fsysinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5302cd025063e00bde7d102284f638977dde5f27/libgo%2Fsysinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsysinfo.c?ref=5302cd025063e00bde7d102284f638977dde5f27", "patch": "@@ -163,6 +163,10 @@\n #include <port.h>\n #endif\n \n+#ifdef USE_LIBFFI\n+#include \"ffi.h\"\n+#endif\n+\n /* Constants that may only be defined as expressions on some systems,\n    expressions too complex for -fdump-go-spec to handle.  These are\n    handled specially below.  */"}]}