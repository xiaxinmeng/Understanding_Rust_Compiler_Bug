{"sha": "3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkZjY0YWE5MTliOWJmNzI1NjcyYmQwYWQ5MWJmZDMwYzZhMzFkZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-10-21T16:55:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-10-21T16:55:38Z"}, "message": "State cleanups from jit branch\n\ngcc/ChangeLog:\n\t* cgraph.c (cgraph_c_finalize): New function.\n\t* cgraph.h (cgraph_c_finalize): New prototype.\n\t(cgraphunit_c_finalize): New prototype.\n\t* cgraphunit.c (first_analyzed): Move from analyze_functions\n\tto file-scope.\n\t(first_analyzed_var): Likewise.\n\t(analyze_functions): Move static variables into file-scope.\n\t(cgraphunit_c_finalize): New function.\n\t* diagnostic.c (diagnostic_finish): Free the memory for\n\tcontext->classify_diagnostic and context->printer, running the\n\tdestructor for the latter.\n\t(bt_stop): Use toplev::main.\n\t* dwarf2out.c (dwarf2out_finalize): New function.\n\t* dwarf2out.h (dwarf2out_c_finalize): New prototype.\n\t* gcse.c (gcse_c_finalize): New function.\n\t* gcse.h (gcse_c_finalize): New prototype.\n\t* ggc-page.c (init_ggc): Make idempotent.\n\t* input.c (input_location): Initialize to UNKNOWN_LOCATION.\n\t* ipa-cp.c (ipa_cp_c_finalize): New function.\n\t* ipa-prop.h (ipa_cp_c_finalize): New prototype.\n\t* ipa-pure-const.c (function_insertion_hook_holder): Move to be\n\ta field of class pass_ipa_pure_const.\n\t(node_duplication_hook_holder): Likewise.\n\t(node_removal_hook_holder): Likewise.\n\t(register_hooks): Convert to method...\n\t(pass_ipa_pure_const::register_hooks): ...here, converting\n\tstatic variable init_p into...\n\t(pass_ipa_pure_const::init_p): ...new field.\n\t(pure_const_generate_summary): Update invocation of\n\tregister_hooks to invoke as a method of current_pass.\n\t(pure_const_read_summary): Likewise.\n\t(propagate): Convert to...\n\t(pass_ipa_pure_const::execute): ...method.\n\t* ipa-reference.c (ipa_init): Move static bool init_p from here\n\tto...\n\t(ipa_init_p): New file-scope variable, so that it can be reset\n\twhen repeatedly invoking the compiler within one process by...\n\t(ipa_reference_c_finalize): New function.\n\t* ipa-reference.h (ipa_reference_c_finalize): New.\n\t* main.c (main): Replace invocation of toplev_main with\n\tconstruction of a toplev instance, and call its \"main\" method.\n\t* params.c (global_init_params): Add an assert that\n\tparams_finished is false.\n\t(params_c_finalize): New.\n\t* params.h (params_c_finalize): New.\n\t* passes.c (execute_ipa_summary_passes): Set \"current_pass\" before\n\tinvoking generate_summary, for the benefit of pass_ipa_pure_const.\n\t(ipa_write_summaries_2): Assign \"pass\" to \"current_pass\" global\n\tbefore calling write_summary hook.\n\t(ipa_write_optimization_summaries_1): Likewise when calling\n\twrite_optimization_summary hook.\n\t(ipa_read_summaries_1): Likewise for read_summary hook.\n\t(ipa_read_optimization_summaries_1): Likewise for\n\tread_optimization_summary hook.\n\t(execute_ipa_stmt_fixups): Likewise.\n\t* stringpool.c (init_stringpool): Clean up if we're called more\n\tthan once.\n\t* timevar.c (timevar_init): Ignore repeated calls.\n\t* toplev.c: Include \"dwarf2out.h\", \"ipa-reference.h\", \"gcse.h\",\n\t\"ipa-prop.h\".\n\t(general_init): Reset \"input_location\" to UNKNOWN_LOCATION.\n\t(initialize_rtl): Move static local \"initialized_once\"\n\tinto file scope, and rename to...\n\t(rtl_initialized): New variable.\n\t(do_compile): Move timevar initialization from here to\n\ttoplev::start_timevars.\n\t(toplev::toplev, toplev::~toplev, toplev::start_timevars,\n\ttoplev::finalize): New functions.\n\t(toplev_main): Rename to...\n\t(toplev::main): ...this.\n\t* toplev.h (class toplev): New class.\n\nFrom-SVN: r216522", "tree": {"sha": "c3163bb97d62851d6b1e3f51f6a8d28cd498be0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3163bb97d62851d6b1e3f51f6a8d28cd498be0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50684f95305bc5e6dcab6533e330d66e7ec975fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50684f95305bc5e6dcab6533e330d66e7ec975fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50684f95305bc5e6dcab6533e330d66e7ec975fc"}], "stats": {"total": 499, "additions": 425, "deletions": 74}, "files": [{"sha": "bce5f7010eb65922419e93c5865d48abb4914357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -1,3 +1,77 @@\n+2014-10-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cgraph.c (cgraph_c_finalize): New function.\n+\t* cgraph.h (cgraph_c_finalize): New prototype.\n+\t(cgraphunit_c_finalize): New prototype.\n+\t* cgraphunit.c (first_analyzed): Move from analyze_functions\n+\tto file-scope.\n+\t(first_analyzed_var): Likewise.\n+\t(analyze_functions): Move static variables into file-scope.\n+\t(cgraphunit_c_finalize): New function.\n+\t* diagnostic.c (diagnostic_finish): Free the memory for\n+\tcontext->classify_diagnostic and context->printer, running the\n+\tdestructor for the latter.\n+\t(bt_stop): Use toplev::main.\n+\t* dwarf2out.c (dwarf2out_finalize): New function.\n+\t* dwarf2out.h (dwarf2out_c_finalize): New prototype.\n+\t* gcse.c (gcse_c_finalize): New function.\n+\t* gcse.h (gcse_c_finalize): New prototype.\n+\t* ggc-page.c (init_ggc): Make idempotent.\n+\t* input.c (input_location): Initialize to UNKNOWN_LOCATION.\n+\t* ipa-cp.c (ipa_cp_c_finalize): New function.\n+\t* ipa-prop.h (ipa_cp_c_finalize): New prototype.\n+\t* ipa-pure-const.c (function_insertion_hook_holder): Move to be\n+\ta field of class pass_ipa_pure_const.\n+\t(node_duplication_hook_holder): Likewise.\n+\t(node_removal_hook_holder): Likewise.\n+\t(register_hooks): Convert to method...\n+\t(pass_ipa_pure_const::register_hooks): ...here, converting\n+\tstatic variable init_p into...\n+\t(pass_ipa_pure_const::init_p): ...new field.\n+\t(pure_const_generate_summary): Update invocation of\n+\tregister_hooks to invoke as a method of current_pass.\n+\t(pure_const_read_summary): Likewise.\n+\t(propagate): Convert to...\n+\t(pass_ipa_pure_const::execute): ...method.\n+\t* ipa-reference.c (ipa_init): Move static bool init_p from here\n+\tto...\n+\t(ipa_init_p): New file-scope variable, so that it can be reset\n+\twhen repeatedly invoking the compiler within one process by...\n+\t(ipa_reference_c_finalize): New function.\n+\t* ipa-reference.h (ipa_reference_c_finalize): New.\n+\t* main.c (main): Replace invocation of toplev_main with\n+\tconstruction of a toplev instance, and call its \"main\" method.\n+\t* params.c (global_init_params): Add an assert that\n+\tparams_finished is false.\n+\t(params_c_finalize): New.\n+\t* params.h (params_c_finalize): New.\n+\t* passes.c (execute_ipa_summary_passes): Set \"current_pass\" before\n+\tinvoking generate_summary, for the benefit of pass_ipa_pure_const.\n+\t(ipa_write_summaries_2): Assign \"pass\" to \"current_pass\" global\n+\tbefore calling write_summary hook.\n+\t(ipa_write_optimization_summaries_1): Likewise when calling\n+\twrite_optimization_summary hook.\n+\t(ipa_read_summaries_1): Likewise for read_summary hook.\n+\t(ipa_read_optimization_summaries_1): Likewise for\n+\tread_optimization_summary hook.\n+\t(execute_ipa_stmt_fixups): Likewise.\n+\t* stringpool.c (init_stringpool): Clean up if we're called more\n+\tthan once.\n+\t* timevar.c (timevar_init): Ignore repeated calls.\n+\t* toplev.c: Include \"dwarf2out.h\", \"ipa-reference.h\", \"gcse.h\",\n+\t\"ipa-prop.h\".\n+\t(general_init): Reset \"input_location\" to UNKNOWN_LOCATION.\n+\t(initialize_rtl): Move static local \"initialized_once\"\n+\tinto file scope, and rename to...\n+\t(rtl_initialized): New variable.\n+\t(do_compile): Move timevar initialization from here to\n+\ttoplev::start_timevars.\n+\t(toplev::toplev, toplev::~toplev, toplev::start_timevars,\n+\ttoplev::finalize): New functions.\n+\t(toplev_main): Rename to...\n+\t(toplev::main): ...this.\n+\t* toplev.h (class toplev): New class.\n+\n 2014-10-21  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* loop-doloop.c: Include loop-unroll.h."}, {"sha": "6536233430dd7537e329b32e47917befcacba4ee", "filename": "gcc/cgraph.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -3097,4 +3097,18 @@ gimple_check_call_matching_types (gimple call_stmt, tree callee,\n   return true;\n }\n \n+/* Reset all state within cgraph.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+cgraph_c_finalize (void)\n+{\n+  symtab = NULL;\n+\n+  x_cgraph_nodes_queue = NULL;\n+\n+  cgraph_fnver_htab = NULL;\n+  version_info_node = NULL;\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "2a55e171f9837f788b23b225115112ec2f22fe3d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -2108,6 +2108,7 @@ asmname_hasher::pch_nx (symtab_node *&n, gt_pointer_operator op, void *cookie)\n }\n \n /* In cgraph.c  */\n+void cgraph_c_finalize (void);\n void release_function_body (tree);\n cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n \n@@ -2121,6 +2122,8 @@ bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n extern bool gimple_check_call_matching_types (gimple, tree, bool);\n \n /* In cgraphunit.c  */\n+void cgraphunit_c_finalize (void);\n+\n /*  Initialize datastructures so DECL is a function in lowered gimple form.\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool);"}, {"sha": "e84c70089c1a254454cc11dcd9b1bb58cc0ceb50", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -884,15 +884,15 @@ walk_polymorphic_call_targets (hash_set<void *> *reachable_call_targets,\n \n /* Discover all functions and variables that are trivially needed, analyze\n    them as well as all functions and variables referred by them  */\n+static cgraph_node *first_analyzed;\n+static varpool_node *first_analyzed_var;\n \n static void\n analyze_functions (void)\n {\n   /* Keep track of already processed nodes when called multiple times for\n      intermodule optimization.  */\n-  static cgraph_node *first_analyzed;\n   cgraph_node *first_handled = first_analyzed;\n-  static varpool_node *first_analyzed_var;\n   varpool_node *first_handled_var = first_analyzed_var;\n   hash_set<void *> reachable_call_targets;\n \n@@ -2292,6 +2292,22 @@ symbol_table::finalize_compilation_unit (void)\n   timevar_pop (TV_CGRAPH);\n }\n \n+/* Reset all state within cgraphunit.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+cgraphunit_c_finalize (void)\n+{\n+  gcc_assert (cgraph_new_nodes.length () == 0);\n+  cgraph_new_nodes.truncate (0);\n+\n+  vtable_entry_type = NULL;\n+  queued_nodes = &symtab_terminator;\n+\n+  first_analyzed = NULL;\n+  first_analyzed_var = NULL;\n+}\n+\n /* Creates a wrapper from cgraph_node to TARGET node. Thunk is used for this\n    kind of wrapper method.  */\n "}, {"sha": "642cbe38b9af67752cb1509b359d0cba2e835481", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -177,6 +177,15 @@ diagnostic_finish (diagnostic_context *context)\n     }\n \n   diagnostic_file_cache_fini ();\n+\n+  XDELETEVEC (context->classify_diagnostic);\n+  context->classify_diagnostic = NULL;\n+\n+  /* diagnostic_initialize allocates context->printer using XNEW\n+     and placement-new.  */\n+  context->printer->~pretty_printer ();\n+  XDELETE (context->printer);\n+  context->printer = NULL;\n }\n \n /* Initialize DIAGNOSTIC, where the message MSG has already been\n@@ -342,7 +351,7 @@ diagnostic_show_locus (diagnostic_context * context,\n static const char * const bt_stop[] =\n {\n   \"main\",\n-  \"toplev_main\",\n+  \"toplev::main\",\n   \"execute_one_pass\",\n   \"compile_file\",\n };"}, {"sha": "a87f9c0997e7ed52fa0b1229a465047bcde7206b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -24619,4 +24619,90 @@ dwarf2out_finish (const char *filename)\n     output_indirect_strings ();\n }\n \n+/* Reset all state within dwarf2out.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+dwarf2out_c_finalize (void)\n+{\n+  last_var_location_insn = NULL;\n+  cached_next_real_insn = NULL;\n+  used_rtx_array = NULL;\n+  incomplete_types = NULL;\n+  decl_scope_table = NULL;\n+  debug_info_section = NULL;\n+  debug_skeleton_info_section = NULL;\n+  debug_abbrev_section = NULL;\n+  debug_skeleton_abbrev_section = NULL;\n+  debug_aranges_section = NULL;\n+  debug_addr_section = NULL;\n+  debug_macinfo_section = NULL;\n+  debug_line_section = NULL;\n+  debug_skeleton_line_section = NULL;\n+  debug_loc_section = NULL;\n+  debug_pubnames_section = NULL;\n+  debug_pubtypes_section = NULL;\n+  debug_str_section = NULL;\n+  debug_str_dwo_section = NULL;\n+  debug_str_offsets_section = NULL;\n+  debug_ranges_section = NULL;\n+  debug_frame_section = NULL;\n+  fde_vec = NULL;\n+  debug_str_hash = NULL;\n+  skeleton_debug_str_hash = NULL;\n+  dw2_string_counter = 0;\n+  have_multiple_function_sections = false;\n+  text_section_used = false;\n+  cold_text_section_used = false;\n+  cold_text_section = NULL;\n+  current_unit_personality = NULL;\n+\n+  deferred_locations_list = NULL;\n+\n+  next_die_offset = 0;\n+  single_comp_unit_die = NULL;\n+  comdat_type_list = NULL;\n+  limbo_die_list = NULL;\n+  deferred_asm_name = NULL;\n+  file_table = NULL;\n+  decl_die_table = NULL;\n+  common_block_die_table = NULL;\n+  decl_loc_table = NULL;\n+  call_arg_locations = NULL;\n+  call_arg_loc_last = NULL;\n+  call_site_count = -1;\n+  tail_call_site_count = -1;\n+  //block_map = NULL;\n+  cached_dw_loc_list_table = NULL;\n+  abbrev_die_table = NULL;\n+  abbrev_die_table_allocated = 0;\n+  abbrev_die_table_in_use = 0;\n+  line_info_label_num = 0;\n+  cur_line_info_table = NULL;\n+  text_section_line_info = NULL;\n+  cold_text_section_line_info = NULL;\n+  separate_line_info = NULL;\n+  info_section_emitted = false;\n+  pubname_table = NULL;\n+  pubtype_table = NULL;\n+  macinfo_table = NULL;\n+  ranges_table = NULL;\n+  ranges_table_allocated = 0;\n+  ranges_table_in_use = 0;\n+  ranges_by_label = 0;\n+  ranges_by_label_allocated = 0;\n+  ranges_by_label_in_use = 0;\n+  have_location_lists = false;\n+  loclabel_num = 0;\n+  poc_label_num = 0;\n+  last_emitted_file = NULL;\n+  label_num = 0;\n+  file_table_last_lookup = NULL;\n+  tmpl_value_parm_die_table = NULL;\n+  generic_type_instances = NULL;\n+  frame_pointer_fb_offset = 0;\n+  frame_pointer_fb_offset_valid = false;\n+  base_types.release ();\n+}\n+\n #include \"gt-dwarf2out.h\""}, {"sha": "c30d81f0d6e2f7c34c6520e688502b5f77ecfc2b", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -277,4 +277,6 @@ struct array_descr_info\n     } dimen[10];\n };\n \n+void dwarf2out_c_finalize (void);\n+\n #endif /* GCC_DWARF2OUT_H */"}, {"sha": "9c62f8b3bb1d5a69c6aeacf839193593d79f5c97", "filename": "gcc/gcse.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -4293,4 +4293,13 @@ make_pass_rtl_hoist (gcc::context *ctxt)\n   return new pass_rtl_hoist (ctxt);\n }\n \n+/* Reset all state within gcse.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+gcse_c_finalize (void)\n+{\n+  test_insn = NULL;\n+}\n+\n #include \"gt-gcse.h\""}, {"sha": "8e6820f79fe7c0d25cfa9fdb44ed7f4352f545d1", "filename": "gcc/gcse.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fgcse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fgcse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -39,4 +39,6 @@ extern struct target_gcse *this_target_gcse;\n #define this_target_gcse (&default_target_gcse)\n #endif\n \n+void gcse_c_finalize (void);\n+\n #endif"}, {"sha": "2236a3a7d2ffc38131ef0a90a6bd6676a8681e91", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -1697,8 +1697,13 @@ compute_inverse (unsigned order)\n void\n init_ggc (void)\n {\n+  static bool init_p = false;\n   unsigned order;\n \n+  if (init_p)\n+    return;\n+  init_p = true;\n+\n   G.pagesize = getpagesize ();\n   G.lg_pagesize = exact_log2 (G.pagesize);\n "}, {"sha": "8d6356a014df19202886e25726bc33c5f79a1a2f", "filename": "gcc/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -105,7 +105,7 @@ struct fcache\n \n /* Current position in real source file.  */\n \n-location_t input_location;\n+location_t input_location = UNKNOWN_LOCATION;\n \n struct line_maps *line_table;\n "}, {"sha": "a6269755036380973f97982a3fc8011e5b1acd1d", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -3827,3 +3827,15 @@ make_pass_ipa_cp (gcc::context *ctxt)\n {\n   return new pass_ipa_cp (ctxt);\n }\n+\n+/* Reset all state within ipa-cp.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+ipa_cp_c_finalize (void)\n+{\n+  max_count = 0;\n+  overall_size = 0;\n+  max_new_size = 0;\n+  values_topo = NULL;\n+}"}, {"sha": "d2f0c675846ef5e2b7d294764ff27394573864b2", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -732,4 +732,7 @@ ipa_parm_adjustment *ipa_get_adjustment_candidate (tree **, bool *,\n tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n \t\t\t   gimple_stmt_iterator *, bool);\n \n+/* In ipa-cp.c  */\n+void ipa_cp_c_finalize (void);\n+\n #endif /* IPA_PROP_H */"}, {"sha": "c221cd0a3babf94a2beaff3e8f4fb5f8c2052f48", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -115,10 +115,45 @@ typedef struct funct_state_d * funct_state;\n \n static vec<funct_state> funct_state_vec;\n \n-/* Holders of ipa cgraph hooks: */\n-static struct cgraph_node_hook_list *function_insertion_hook_holder;\n-static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n-static struct cgraph_node_hook_list *node_removal_hook_holder;\n+static bool gate_pure_const (void);\n+\n+namespace {\n+\n+const pass_data pass_data_ipa_pure_const =\n+{\n+  IPA_PASS, /* type */\n+  \"pure-const\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_IPA_PURE_CONST, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_ipa_pure_const : public ipa_opt_pass_d\n+{\n+public:\n+  pass_ipa_pure_const(gcc::context *ctxt);\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) { return gate_pure_const (); }\n+  unsigned int execute (function *fun);\n+\n+  void register_hooks (void);\n+\n+private:\n+  bool init_p;\n+\n+  /* Holders of ipa cgraph hooks: */\n+  struct cgraph_node_hook_list *function_insertion_hook_holder;\n+  struct cgraph_2node_hook_list *node_duplication_hook_holder;\n+  struct cgraph_node_hook_list *node_removal_hook_holder;\n+\n+}; // class pass_ipa_pure_const\n+\n+} // anon namespace\n \n /* Try to guess if function body will always be visible to compiler\n    when compiling the call and whether compiler will be able\n@@ -881,11 +916,10 @@ remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n }\n \n \f\n-static void\n+void\n+pass_ipa_pure_const::\n register_hooks (void)\n {\n-  static bool init_p = false;\n-\n   if (init_p)\n     return;\n \n@@ -908,7 +942,8 @@ pure_const_generate_summary (void)\n {\n   struct cgraph_node *node;\n \n-  register_hooks ();\n+  pass_ipa_pure_const *pass = static_cast <pass_ipa_pure_const *> (current_pass);\n+  pass->register_hooks ();\n \n   /* Process all of the functions.\n \n@@ -989,7 +1024,9 @@ pure_const_read_summary (void)\n   struct lto_file_decl_data *file_data;\n   unsigned int j = 0;\n \n-  register_hooks ();\n+  pass_ipa_pure_const *pass = static_cast <pass_ipa_pure_const *> (current_pass);\n+  pass->register_hooks ();\n+\n   while ((file_data = file_data_vec[j++]))\n     {\n       const char *data;\n@@ -1470,8 +1507,9 @@ propagate_nothrow (void)\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by generate_summary.  */\n \n-static unsigned int\n-propagate (void)\n+unsigned int\n+pass_ipa_pure_const::\n+execute (function *)\n {\n   struct cgraph_node *node;\n \n@@ -1500,44 +1538,23 @@ gate_pure_const (void)\n \t  && !seen_error ());\n }\n \n-namespace {\n-\n-const pass_data pass_data_ipa_pure_const =\n+pass_ipa_pure_const::pass_ipa_pure_const(gcc::context *ctxt)\n+    : ipa_opt_pass_d(pass_data_ipa_pure_const, ctxt,\n+\t\t     pure_const_generate_summary, /* generate_summary */\n+\t\t     pure_const_write_summary, /* write_summary */\n+\t\t     pure_const_read_summary, /* read_summary */\n+\t\t     NULL, /* write_optimization_summary */\n+\t\t     NULL, /* read_optimization_summary */\n+\t\t     NULL, /* stmt_fixup */\n+\t\t     0, /* function_transform_todo_flags_start */\n+\t\t     NULL, /* function_transform */\n+\t\t     NULL), /* variable_transform */\n+  init_p(false),\n+  function_insertion_hook_holder(NULL),\n+  node_duplication_hook_holder(NULL),\n+  node_removal_hook_holder(NULL)\n {\n-  IPA_PASS, /* type */\n-  \"pure-const\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_IPA_PURE_CONST, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_ipa_pure_const : public ipa_opt_pass_d\n-{\n-public:\n-  pass_ipa_pure_const (gcc::context *ctxt)\n-    : ipa_opt_pass_d (pass_data_ipa_pure_const, ctxt,\n-\t\t      pure_const_generate_summary, /* generate_summary */\n-\t\t      pure_const_write_summary, /* write_summary */\n-\t\t      pure_const_read_summary, /* read_summary */\n-\t\t      NULL, /* write_optimization_summary */\n-\t\t      NULL, /* read_optimization_summary */\n-\t\t      NULL, /* stmt_fixup */\n-\t\t      0, /* function_transform_todo_flags_start */\n-\t\t      NULL, /* function_transform */\n-\t\t      NULL) /* variable_transform */\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *) { return gate_pure_const (); }\n-  virtual unsigned int execute (function *) { return propagate (); }\n-\n-}; // class pass_ipa_pure_const\n-\n-} // anon namespace\n+}\n \n ipa_opt_pass_d *\n make_pass_ipa_pure_const (gcc::context *ctxt)"}, {"sha": "f3af47ae832e2e6950fba28cc9e6cee85f3214ee", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -399,17 +399,17 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n     }\n }\n \n+static bool ipa_init_p = false;\n+\n /* The init routine for analyzing global static variable usage.  See\n    comments at top for description.  */\n static void\n ipa_init (void)\n {\n-  static bool init_p = false;\n-\n-  if (init_p)\n+  if (ipa_init_p)\n     return;\n \n-  init_p = true;\n+  ipa_init_p = true;\n \n   if (dump_file)\n     reference_vars_to_consider = splay_tree_new (splay_tree_compare_ints, 0, 0);\n@@ -1173,3 +1173,12 @@ make_pass_ipa_reference (gcc::context *ctxt)\n {\n   return new pass_ipa_reference (ctxt);\n }\n+\n+/* Reset all state within ipa-reference.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+ipa_reference_c_finalize (void)\n+{\n+  ipa_init_p = false;\n+}"}, {"sha": "3e7dc73198090dfad9a9fb2f792efc90809e7f76", "filename": "gcc/ipa-reference.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fipa-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n /* In ipa-reference.c  */\n bitmap ipa_reference_get_not_read_global (struct cgraph_node *fn);\n bitmap ipa_reference_get_not_written_global (struct cgraph_node *fn);\n+void ipa_reference_c_finalize (void);\n \n #endif  /* GCC_IPA_REFERENCE_H  */\n "}, {"sha": "4bba0415ab332df1ad5ffef8d6e36d78598f9b12", "filename": "gcc/main.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmain.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -26,12 +26,14 @@ along with GCC; see the file COPYING3.  If not see\n \n int main (int argc, char **argv);\n \n-/* We define main() to call toplev_main(), which is defined in toplev.c.\n+/* We define main() to call toplev::main(), which is defined in toplev.c.\n    We do this in a separate file in order to allow the language front-end\n    to define a different main(), if it so desires.  */\n \n int\n main (int argc, char **argv)\n {\n-  return toplev_main (argc, argv);\n+  toplev toplev (true);\n+\n+  return toplev.main (argc, argv);\n }"}, {"sha": "7aa96e2c8f365457db009d60555ee137f521ac1f", "filename": "gcc/params.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fparams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fparams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -69,6 +69,8 @@ add_params (const param_info params[], size_t n)\n void\n global_init_params (void)\n {\n+  gcc_assert (!params_finished);\n+\n   add_params (lang_independent_params, LAST_PARAM);\n   targetm_common.option_default_params ();\n }\n@@ -82,6 +84,18 @@ finish_params (void)\n   params_finished = true;\n }\n \n+/* Reset all state within params.c so that we can rerun the compiler\n+   within the same process.  For use by toplev::finalize.  */\n+\n+void\n+params_c_finalize (void)\n+{\n+  XDELETEVEC (compiler_params);\n+  compiler_params = NULL;\n+  num_compiler_params = 0;\n+  params_finished = false;\n+}\n+\n /* Set the value of the parameter given by NUM to VALUE in PARAMS and\n    PARAMS_SET.  If EXPLICIT_P, this is being set by the user;\n    otherwise it is being set implicitly by the compiler.  */"}, {"sha": "4779e17da33041c10fc8c19dadef5e6477f5de0e", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -113,6 +113,10 @@ extern void global_init_params (void);\n    set.  */\n extern void finish_params (void);\n \n+/* Reset all state in params.c  */\n+\n+extern void params_c_finalize (void);\n+\n /* Return the default value of parameter NUM.  */\n \n extern int default_param_value (compiler_param num);"}, {"sha": "428c79792b72ddc73530add6ea1c000f1e8d993a", "filename": "gcc/passes.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -1948,6 +1948,7 @@ execute_ipa_summary_passes (ipa_opt_pass_d *ipa_pass)\n \t  if (pass->tv_id)\n \t    timevar_push (pass->tv_id);\n \n+\t  current_pass = pass;\n \t  ipa_pass->generate_summary ();\n \n \t  /* Stop timevar.  */\n@@ -2259,6 +2260,7 @@ ipa_write_summaries_2 (opt_pass *pass, struct lto_out_decl_state *state)\n \n           pass_init_dump_file (pass);\n \n+\t  current_pass = pass;\n \t  ipa_pass->write_summary ();\n \n           pass_fini_dump_file (pass);\n@@ -2377,6 +2379,7 @@ ipa_write_optimization_summaries_1 (opt_pass *pass,\n \n           pass_init_dump_file (pass);\n \n+\t  current_pass = pass;\n \t  ipa_pass->write_optimization_summary ();\n \n           pass_fini_dump_file (pass);\n@@ -2457,6 +2460,7 @@ ipa_read_summaries_1 (opt_pass *pass)\n \n \t      pass_init_dump_file (pass);\n \n+\t      current_pass = pass;\n \t      ipa_pass->read_summary ();\n \n \t      pass_fini_dump_file (pass);\n@@ -2507,6 +2511,7 @@ ipa_read_optimization_summaries_1 (opt_pass *pass)\n \n \t      pass_init_dump_file (pass);\n \n+\t      current_pass = pass;\n \t      ipa_pass->read_optimization_summary ();\n \n \t      pass_fini_dump_file (pass);\n@@ -2586,6 +2591,7 @@ execute_ipa_stmt_fixups (opt_pass *pass,\n \t      if (pass->tv_id)\n \t\ttimevar_push (pass->tv_id);\n \n+\t      current_pass = pass;\n \t      ipa_pass->stmt_fixup (node, stmts);\n \n \t      /* Stop timevar.  */"}, {"sha": "330df6c1d3579e9f8fd6370e6cb5d57b52b53d56", "filename": "gcc/stringpool.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -61,6 +61,11 @@ stringpool_ggc_alloc (size_t x)\n void\n init_stringpool (void)\n {\n+  /* Clean up if we're called more than once.\n+     (We can't make this idempotent since identifiers contain state) */\n+  if (ident_hash)\n+    ht_destroy (ident_hash);\n+\n   /* Create with 16K (2^14) entries.  */\n   ident_hash = ht_create (14);\n   ident_hash->alloc_node = alloc_node;"}, {"sha": "0e56a23e23c5bfe0b799ddf7c4bab29082892020", "filename": "gcc/timevar.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -223,6 +223,9 @@ timevar_accumulate (struct timevar_time_def *timer,\n void\n timevar_init (void)\n {\n+  if (timevar_enable)\n+    return;\n+\n   timevar_enable = true;\n \n   /* Zero all elapsed times.  */"}, {"sha": "a87ff9a2ff897669b407448777cba720c582a760", "filename": "gcc/toplev.c", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -83,6 +83,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-color.h\"\n #include \"context.h\"\n #include \"pass_manager.h\"\n+#include \"dwarf2out.h\"\n+#include \"ipa-reference.h\"\n+#include \"ipa-prop.h\"\n+#include \"gcse.h\"\n #include \"optabs.h\"\n \n #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)\n@@ -101,7 +105,7 @@ along with GCC; see the file COPYING3.  If not see\n #include <new>\n \n static void general_init (const char *);\n-static void do_compile (void);\n+static void do_compile ();\n static void process_options (void);\n static void backend_init (void);\n static int lang_dependent_init (const char *);\n@@ -1161,6 +1165,7 @@ general_init (const char *argv0)\n      table.  */\n   init_ggc ();\n   init_stringpool ();\n+  input_location = UNKNOWN_LOCATION;\n   line_table = ggc_alloc<line_maps> ();\n   linemap_init (line_table, BUILTINS_LOCATION);\n   line_table->reallocator = realloc_for_line_map;\n@@ -1708,16 +1713,16 @@ lang_dependent_init_target (void)\n /* Perform initializations that are lang-dependent or target-dependent.\n    but matters only for late optimizations and RTL generation.  */\n \n+static int rtl_initialized;\n+\n void\n initialize_rtl (void)\n {\n-  static int initialized_once;\n-\n   /* Initialization done just once per compilation, but delayed\n      till code generation.  */\n-  if (!initialized_once)\n+  if (!rtl_initialized)\n     ira_init_once ();\n-  initialized_once = true;\n+  rtl_initialized = true;\n \n   /* Target specific RTL backend initialization.  */\n   if (!this_target_rtl->target_specific_initialized)\n@@ -1922,14 +1927,8 @@ standard_type_bitsize (int bitsize)\n \n /* Initialize the compiler, and compile the input file.  */\n static void\n-do_compile (void)\n+do_compile ()\n {\n-  /* Initialize timing first.  The C front ends read the main file in\n-     the post_options hook, and C++ does file timings.  */\n-  if (time_report || !quiet_flag  || flag_detailed_statistics)\n-    timevar_init ();\n-  timevar_start (TV_TOTAL);\n-\n   process_options ();\n \n   /* Don't do any more if an error has already occurred.  */\n@@ -1987,20 +1986,38 @@ do_compile (void)\n \n       timevar_stop (TV_PHASE_FINALIZE);\n     }\n+}\n \n-  /* Stop timing and print the times.  */\n+toplev::toplev (bool use_TV_TOTAL)\n+  : m_use_TV_TOTAL (use_TV_TOTAL)\n+{\n+  if (!m_use_TV_TOTAL)\n+    start_timevars ();\n+}\n+\n+toplev::~toplev ()\n+{\n   timevar_stop (TV_TOTAL);\n   timevar_print (stderr);\n }\n \n+void\n+toplev::start_timevars ()\n+{\n+  if (time_report || !quiet_flag  || flag_detailed_statistics)\n+    timevar_init ();\n+\n+  timevar_start (TV_TOTAL);\n+}\n+\n /* Entry point of cc1, cc1plus, jc1, f771, etc.\n    Exit code is FATAL_EXIT_CODE if can't open files or if there were\n    any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n \n    It is not safe to call this function more than once.  */\n \n int\n-toplev_main (int argc, char **argv)\n+toplev::main (int argc, char **argv)\n {\n   /* Parsing and gimplification sometimes need quite large stack.\n      Increase stack size limits if possible.  */\n@@ -2050,7 +2067,11 @@ toplev_main (int argc, char **argv)\n \n   /* Exit early if we can (e.g. -help).  */\n   if (!exit_after_options)\n-    do_compile ();\n+    {\n+      if (m_use_TV_TOTAL)\n+\tstart_timevars ();\n+      do_compile ();\n+    }\n \n   if (warningcount || errorcount || werrorcount)\n     print_ignored_options ();\n@@ -2068,3 +2089,20 @@ toplev_main (int argc, char **argv)\n \n   return (SUCCESS_EXIT_CODE);\n }\n+\n+/* For those that want to, this function aims to clean up enough state that\n+   you can call toplev::main again. */\n+void\n+toplev::finalize (void)\n+{\n+  rtl_initialized = false;\n+  this_target_rtl->target_specific_initialized = false;\n+\n+  cgraph_c_finalize ();\n+  cgraphunit_c_finalize ();\n+  dwarf2out_c_finalize ();\n+  gcse_c_finalize ();\n+  ipa_cp_c_finalize ();\n+  ipa_reference_c_finalize ();\n+  params_c_finalize ();\n+}"}, {"sha": "b845843307a8cae3866b7fe3bd26401ce4b133c0", "filename": "gcc/toplev.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edf64aa919b9bf725672bd0ad91bfd30c6a31df/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=3edf64aa919b9bf725672bd0ad91bfd30c6a31df", "patch": "@@ -24,7 +24,24 @@ along with GCC; see the file COPYING3.  If not see\n extern struct cl_decoded_option *save_decoded_options;\n extern unsigned int save_decoded_options_count;\n \n-extern int toplev_main (int, char **);\n+/* Invoking the compiler.  */\n+class toplev\n+{\n+public:\n+  toplev (bool use_TV_TOTAL);\n+  ~toplev ();\n+\n+  int main (int argc, char **argv);\n+\n+  void finalize ();\n+\n+private:\n+\n+  void start_timevars ();\n+\n+  bool m_use_TV_TOTAL;\n+};\n+\n extern void rest_of_decl_compilation (tree, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void init_optimization_passes (void);"}]}