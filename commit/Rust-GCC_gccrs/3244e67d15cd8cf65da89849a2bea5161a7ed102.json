{"sha": "3244e67d15cd8cf65da89849a2bea5161a7ed102", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI0NGU2N2QxNWNkOGNmNjVkYTg5ODQ5YTJiZWE1MTYxYTdlZDEwMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-25T19:15:50Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-25T19:15:50Z"}, "message": "convert.c (convert_to_real, [...]): Replace calls to build with calls to buildN.\n\n\n\t* convert.c (convert_to_real, convert_to_integer,\n\tconvert_to_complex): Replace calls to build with calls to buildN.\n\t* coverage.c (tree_coverage_counter_ref): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* dwarf2out.c (loc_descriptor_from_tree): Likewise.\n\t* emit-rtl.c (component_ref_for_mem_expr,\n\tset_mem_attributes_minus_bitpos): Likewise.\n\t* explow.c (update_nonlocal_goto_save_area): Likewise.\n\t* expmed.c (expand_shift, make_tree, const_mult_add_overflow_p,\n\texpand_mult_add): Likewise.\n\t* expr.c (emit_block_move_via_libcall, clear_storage_via_libcall,\n\tstore_constructor, get_inner_reference, expand_expr_real_1,\n\ttry_casesi, try_tablejump): Likewise.\n\t* function.c (expand_function_start): Likewise.\n\t* stmt.c (emit_case_bit_tests, expand_end_case_type,\n\tnode_has_low_bound, node_has_high_bound, emit_case_nodes): Likewise.\n\t* stor-layout.c (place_union_field, layout_type): Likewise.\n\t* tree.c (substitute_in_expr, tree_fold_gcd): Likewise.\n\t* varasm.c (copy_constant): Likewise.\n\nFrom-SVN: r85160", "tree": {"sha": "af2779b1ec5669ccd9b5104179ae4f53c95149ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af2779b1ec5669ccd9b5104179ae4f53c95149ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3244e67d15cd8cf65da89849a2bea5161a7ed102", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3244e67d15cd8cf65da89849a2bea5161a7ed102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3244e67d15cd8cf65da89849a2bea5161a7ed102", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3244e67d15cd8cf65da89849a2bea5161a7ed102/comments", "author": null, "committer": null, "parents": [{"sha": "53ed1a12d363e501b61b9bfd4a44d568918878c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ed1a12d363e501b61b9bfd4a44d568918878c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53ed1a12d363e501b61b9bfd4a44d568918878c0"}], "stats": {"total": 343, "additions": 184, "deletions": 159}, "files": [{"sha": "5bf60dede093752b052bc69e2086378d8408a218", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -1,3 +1,25 @@\n+2004-07-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* convert.c (convert_to_real, convert_to_integer,\n+\tconvert_to_complex): Replace calls to build with calls to buildN.\n+\t* coverage.c (tree_coverage_counter_ref): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* dwarf2out.c (loc_descriptor_from_tree): Likewise.\n+\t* emit-rtl.c (component_ref_for_mem_expr,\n+\tset_mem_attributes_minus_bitpos): Likewise.\n+\t* explow.c (update_nonlocal_goto_save_area): Likewise.\n+\t* expmed.c (expand_shift, make_tree, const_mult_add_overflow_p,\n+\texpand_mult_add): Likewise.\n+\t* expr.c (emit_block_move_via_libcall, clear_storage_via_libcall,\n+\tstore_constructor, get_inner_reference, expand_expr_real_1,\n+\ttry_casesi, try_tablejump): Likewise.\n+\t* function.c (expand_function_start): Likewise.\n+\t* stmt.c (emit_case_bit_tests, expand_end_case_type,\n+\tnode_has_low_bound, node_has_high_bound, emit_case_nodes): Likewise.\n+\t* stor-layout.c (place_union_field, layout_type): Likewise.\n+\t* tree.c (substitute_in_expr, tree_fold_gcd): Likewise.\n+\t* varasm.c (copy_constant): Likewise.\n+\n 2004-07-25  Bernardo Innocenti  <bernie@develer.com>\n \n \t* c-common.c: Rename all identifiers named `new'."}, {"sha": "6ff1a54113126c5320d457ddc36a73c7e04761e0", "filename": "gcc/convert.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -268,9 +268,9 @@ convert_to_real (tree type, tree expr)\n \t\t    newtype = TREE_TYPE (arg1);\n \t\t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (itype))\n \t\t    {\n-\t\t      expr = build (TREE_CODE (expr), newtype,\n-\t\t\t\t    fold (convert_to_real (newtype, arg0)),\n-\t\t\t\t    fold (convert_to_real (newtype, arg1)));\n+\t\t      expr = build2 (TREE_CODE (expr), newtype,\n+\t\t\t\t     fold (convert_to_real (newtype, arg0)),\n+\t\t\t\t     fold (convert_to_real (newtype, arg1)));\n \t\t      if (newtype == type)\n \t\t\treturn expr;\n \t\t    }\n@@ -525,7 +525,7 @@ convert_to_integer (tree type, tree expr)\n \t\t  /* If the original expression had side-effects, we must\n \t\t     preserve it.  */\n \t\t  if (TREE_SIDE_EFFECTS (expr))\n-\t\t    return build (COMPOUND_EXPR, type, expr, t);\n+\t\t    return build2 (COMPOUND_EXPR, type, expr, t);\n \t\t  else\n \t\t    return t;\n \t\t}\n@@ -605,9 +605,9 @@ convert_to_integer (tree type, tree expr)\n \t\t    else\n \t\t      typex = lang_hooks.types.signed_type (typex);\n \t\t    return convert (type,\n-\t\t\t\t    fold (build (ex_form, typex,\n-\t\t\t\t\t\t convert (typex, arg0),\n-\t\t\t\t\t\t convert (typex, arg1))));\n+\t\t\t\t    fold (build2 (ex_form, typex,\n+\t\t\t\t\t\t  convert (typex, arg0),\n+\t\t\t\t\t\t  convert (typex, arg1))));\n \t\t  }\n \t      }\n \t  }\n@@ -658,9 +658,9 @@ convert_to_integer (tree type, tree expr)\n \tcase COND_EXPR:\n \t  /* It is sometimes worthwhile to push the narrowing down through\n \t     the conditional and never loses.  */\n-\t  return fold (build (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t      convert (type, TREE_OPERAND (expr, 1)),\n-\t\t\t      convert (type, TREE_OPERAND (expr, 2))));\n+\t  return fold (build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t       convert (type, TREE_OPERAND (expr, 1)),\n+\t\t\t       convert (type, TREE_OPERAND (expr, 2))));\n \n \tdefault:\n \t  break;\n@@ -704,8 +704,8 @@ convert_to_complex (tree type, tree expr)\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case CHAR_TYPE:\n-      return build (COMPLEX_EXPR, type, convert (subtype, expr),\n-\t\t    convert (subtype, integer_zero_node));\n+      return build2 (COMPLEX_EXPR, type, convert (subtype, expr),\n+\t\t     convert (subtype, integer_zero_node));\n \n     case COMPLEX_TYPE:\n       {\n@@ -714,23 +714,22 @@ convert_to_complex (tree type, tree expr)\n \tif (TYPE_MAIN_VARIANT (elt_type) == TYPE_MAIN_VARIANT (subtype))\n \t  return expr;\n \telse if (TREE_CODE (expr) == COMPLEX_EXPR)\n-\t  return fold (build (COMPLEX_EXPR,\n-\t\t\t      type,\n-\t\t\t      convert (subtype, TREE_OPERAND (expr, 0)),\n-\t\t\t      convert (subtype, TREE_OPERAND (expr, 1))));\n+\t  return fold (build2 (COMPLEX_EXPR, type,\n+\t\t\t       convert (subtype, TREE_OPERAND (expr, 0)),\n+\t\t\t       convert (subtype, TREE_OPERAND (expr, 1))));\n \telse\n \t  {\n \t    expr = save_expr (expr);\n \t    return\n-\t      fold (build (COMPLEX_EXPR,\n-\t\t\t   type, convert (subtype,\n-\t\t\t\t\t  fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t\texpr))),\n-\t\t\t   convert (subtype,\n-\t\t\t\t    fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\t  TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t  expr)))));\n+\t      fold (build2 (COMPLEX_EXPR, type,\n+\t\t\t    convert (subtype,\n+\t\t\t\t     fold (build1 (REALPART_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\t   expr))),\n+\t\t\t    convert (subtype,\n+\t\t\t\t     fold (build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\t   expr)))));\n \t  }\n       }\n "}, {"sha": "eb6f801982b1b3c7526019279b2ff078d5539c48", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -435,11 +435,11 @@ tree_coverage_counter_ref (unsigned counter, unsigned no)\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n \n   /* \"no\" here is an array index, scaled to bytes later.  */\n-  return build (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n-\t\tfold_convert (domain_type, build_int_2 (no, 0)),\n-\t\tTYPE_MIN_VALUE (domain_type),\n-\t\tsize_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (GCOV_TYPE_NODE),\n-\t\t\t    size_int (TYPE_ALIGN (GCOV_TYPE_NODE))));\n+  return build4 (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n+\t\t fold_convert (domain_type, build_int_2 (no, 0)),\n+\t\t TYPE_MIN_VALUE (domain_type),\n+\t\t size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (GCOV_TYPE_NODE),\n+\t\t\t     size_int (TYPE_ALIGN (GCOV_TYPE_NODE))));\n }\n \f\n /* Generate a checksum for a string.  CHKSUM is the current"}, {"sha": "ab81d047947235ee3edc2dcc0151a5c4fa93a45f", "filename": "gcc/dojump.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -219,18 +219,19 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n          a test and can be longer if the test is eliminated.  */\n     case PLUS_EXPR:\n       /* Reduce to minus.  */\n-      exp = build (MINUS_EXPR, TREE_TYPE (exp),\n-                   TREE_OPERAND (exp, 0),\n-                   fold (build1 (NEGATE_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)),\n-                                 TREE_OPERAND (exp, 1))));\n+      exp = build2 (MINUS_EXPR, TREE_TYPE (exp),\n+\t\t    TREE_OPERAND (exp, 0),\n+\t\t    fold (build1 (NEGATE_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_OPERAND (exp, 1)),\n+\t\t\t\t  TREE_OPERAND (exp, 1))));\n       /* Process as MINUS.  */\n #endif\n \n     case MINUS_EXPR:\n       /* Nonzero iff operands of minus differ.  */\n-      do_compare_and_jump (build (NE_EXPR, TREE_TYPE (exp),\n-                                  TREE_OPERAND (exp, 0),\n-                                  TREE_OPERAND (exp, 1)),\n+      do_compare_and_jump (build2 (NE_EXPR, TREE_TYPE (exp),\n+\t\t\t\t   TREE_OPERAND (exp, 0),\n+\t\t\t\t   TREE_OPERAND (exp, 1)),\n                            NE, NE, if_false_label, if_true_label);\n       break;\n \n@@ -251,8 +252,9 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t      && prefer_and_bit_test (TYPE_MODE (argtype),\n \t\t\t\t      TREE_INT_CST_LOW (shift)))\n \t    {\n-\t      do_jump (build (BIT_AND_EXPR, argtype, arg,\n-\t\t\t      fold (build (LSHIFT_EXPR, argtype, one, shift))),\n+\t      do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n+\t\t\t       fold (build2 (LSHIFT_EXPR, argtype,\n+\t\t\t\t\t     one, shift))),\n \t\t       if_false_label, if_true_label);\n \t      break;\n \t    }\n@@ -381,15 +383,15 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n             tree exp1 = save_expr (TREE_OPERAND (exp, 1));\n             do_jump\n               (fold\n-               (build (TRUTH_ANDIF_EXPR, TREE_TYPE (exp),\n-                 fold (build (EQ_EXPR, TREE_TYPE (exp),\n+               (build2 (TRUTH_ANDIF_EXPR, TREE_TYPE (exp),\n+                 fold (build2 (EQ_EXPR, TREE_TYPE (exp),\n                   fold (build1 (REALPART_EXPR,\n                     TREE_TYPE (inner_type),\n                     exp0)),\n                   fold (build1 (REALPART_EXPR,\n                     TREE_TYPE (inner_type),\n                     exp1)))),\n-                 fold (build (EQ_EXPR, TREE_TYPE (exp),\n+                 fold (build2 (EQ_EXPR, TREE_TYPE (exp),\n                   fold (build1 (IMAGPART_EXPR,\n                     TREE_TYPE (inner_type),\n                     exp0)),\n@@ -421,15 +423,15 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n             tree exp1 = save_expr (TREE_OPERAND (exp, 1));\n             do_jump\n               (fold\n-               (build (TRUTH_ORIF_EXPR, TREE_TYPE (exp),\n-                 fold (build (NE_EXPR, TREE_TYPE (exp),\n+               (build2 (TRUTH_ORIF_EXPR, TREE_TYPE (exp),\n+                 fold (build2 (NE_EXPR, TREE_TYPE (exp),\n                   fold (build1 (REALPART_EXPR,\n                     TREE_TYPE (inner_type),\n                     exp0)),\n                   fold (build1 (REALPART_EXPR,\n                     TREE_TYPE (inner_type),\n                     exp1)))),\n-                 fold (build (NE_EXPR, TREE_TYPE (exp),\n+                 fold (build2 (NE_EXPR, TREE_TYPE (exp),\n                     fold (build1 (IMAGPART_EXPR,\n                       TREE_TYPE (inner_type),\n                       exp0)),\n@@ -563,9 +565,9 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \n             /* If the target doesn't support combined unordered\n                compares, decompose into two comparisons.  */\n-            cmp0 = fold (build (tcode1, TREE_TYPE (exp), op0, op1));\n-            cmp1 = fold (build (tcode2, TREE_TYPE (exp), op0, op1));\n-            exp = build (TRUTH_ORIF_EXPR, TREE_TYPE (exp), cmp0, cmp1);\n+            cmp0 = fold (build2 (tcode1, TREE_TYPE (exp), op0, op1));\n+            cmp1 = fold (build2 (tcode2, TREE_TYPE (exp), op0, op1));\n+            exp = build2 (TRUTH_ORIF_EXPR, TREE_TYPE (exp), cmp0, cmp1);\n             do_jump (exp, if_false_label, if_true_label);\n           }\n       }"}, {"sha": "64fa5c96fc76282c479bb1d2d66248cc6316fea8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -9195,9 +9195,9 @@ loc_descriptor_from_tree (tree loc, int addressp)\n         const enum tree_code code =\n           TREE_CODE (loc) == MIN_EXPR ? GT_EXPR : LT_EXPR;\n \n-        loc = build (COND_EXPR, TREE_TYPE (loc),\n-                     build (code, integer_type_node,\n-                            TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),\n+        loc = build3 (COND_EXPR, TREE_TYPE (loc),\n+\t\t      build2 (code, integer_type_node,\n+\t\t\t      TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),\n                      TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));\n       }\n "}, {"sha": "19df2e717a3e82643453ddad0b955c2bcc70d87a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -1460,8 +1460,8 @@ component_ref_for_mem_expr (tree ref)\n   if (inner == TREE_OPERAND (ref, 0))\n     return ref;\n   else\n-    return build (COMPONENT_REF, TREE_TYPE (ref), inner, TREE_OPERAND (ref, 1),\n-\t\t  NULL_TREE);\n+    return build3 (COMPONENT_REF, TREE_TYPE (ref), inner,\n+\t\t   TREE_OPERAND (ref, 1), NULL_TREE);\n }\n \n /* Returns 1 if both MEM_EXPR can be considered equal\n@@ -1634,8 +1634,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t index, then convert to sizetype and multiply by the size of\n \t\t the array element.  */\n \t      if (! integer_zerop (low_bound))\n-\t\tindex = fold (build (MINUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t     index, low_bound));\n+\t\tindex = fold (build2 (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t      index, low_bound));\n \n \t      off_tree = size_binop (PLUS_EXPR,\n \t\t\t\t     size_binop (MULT_EXPR, convert (sizetype,"}, {"sha": "515778f5e6ba8cb609079a6559ebe46afed83bf1", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -1089,8 +1089,8 @@ update_nonlocal_goto_save_area (void)\n      first one is used for the frame pointer save; the rest are sized by\n      STACK_SAVEAREA_MODE.  Create a reference to array index 1, the first\n      of the stack save area slots.  */\n-  t_save = build (ARRAY_REF, ptr_type_node, cfun->nonlocal_goto_save_area,\n-\t\t  integer_one_node, NULL_TREE, NULL_TREE);\n+  t_save = build4 (ARRAY_REF, ptr_type_node, cfun->nonlocal_goto_save_area,\n+\t\t   integer_one_node, NULL_TREE, NULL_TREE);\n   r_save = expand_expr (t_save, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n   emit_stack_save (SAVE_NONLOCAL, &r_save, NULL_RTX);"}, {"sha": "cdbbd1779586aa2207c5f338ea4b1a10ed16257c", "filename": "gcc/expmed.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -2075,11 +2075,11 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t      tree type = TREE_TYPE (amount);\n \t      tree new_amount = make_tree (type, op1);\n \t      tree other_amount\n-\t\t= fold (build (MINUS_EXPR, type,\n-\t\t\t       convert (type,\n-\t\t\t\t\tbuild_int_2 (GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t\t     0)),\n-\t\t\t       amount));\n+\t\t= fold (build2 (MINUS_EXPR, type,\n+\t\t\t\tconvert (type,\n+\t\t\t\t\t build_int_2 (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t      0)),\n+\t\t\t\tamount));\n \n \t      shifted = force_reg (mode, shifted);\n \n@@ -4386,37 +4386,37 @@ make_tree (tree type, rtx x)\n       }\n \n     case PLUS:\n-      return fold (build (PLUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n-\t\t\t  make_tree (type, XEXP (x, 1))));\n+      return fold (build2 (PLUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n+\t\t\t   make_tree (type, XEXP (x, 1))));\n \n     case MINUS:\n-      return fold (build (MINUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n-\t\t\t  make_tree (type, XEXP (x, 1))));\n+      return fold (build2 (MINUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n+\t\t\t   make_tree (type, XEXP (x, 1))));\n \n     case NEG:\n       return fold (build1 (NEGATE_EXPR, type, make_tree (type, XEXP (x, 0))));\n \n     case MULT:\n-      return fold (build (MULT_EXPR, type, make_tree (type, XEXP (x, 0)),\n-\t\t\t  make_tree (type, XEXP (x, 1))));\n+      return fold (build2 (MULT_EXPR, type, make_tree (type, XEXP (x, 0)),\n+\t\t\t   make_tree (type, XEXP (x, 1))));\n \n     case ASHIFT:\n-      return fold (build (LSHIFT_EXPR, type, make_tree (type, XEXP (x, 0)),\n-\t\t\t  make_tree (type, XEXP (x, 1))));\n+      return fold (build2 (LSHIFT_EXPR, type, make_tree (type, XEXP (x, 0)),\n+\t\t\t   make_tree (type, XEXP (x, 1))));\n \n     case LSHIFTRT:\n       t = lang_hooks.types.unsigned_type (type);\n       return fold (convert (type,\n-\t\t\t    build (RSHIFT_EXPR, t,\n-\t\t\t\t   make_tree (t, XEXP (x, 0)),\n-\t\t\t\t   make_tree (type, XEXP (x, 1)))));\n+\t\t\t    build2 (RSHIFT_EXPR, t,\n+\t\t\t\t    make_tree (t, XEXP (x, 0)),\n+\t\t\t\t    make_tree (type, XEXP (x, 1)))));\n \n     case ASHIFTRT:\n       t = lang_hooks.types.signed_type (type);\n       return fold (convert (type,\n-\t\t\t    build (RSHIFT_EXPR, t,\n-\t\t\t\t   make_tree (t, XEXP (x, 0)),\n-\t\t\t\t   make_tree (type, XEXP (x, 1)))));\n+\t\t\t    build2 (RSHIFT_EXPR, t,\n+\t\t\t\t    make_tree (t, XEXP (x, 0)),\n+\t\t\t\t    make_tree (type, XEXP (x, 1)))));\n \n     case DIV:\n       if (TREE_CODE (type) != REAL_TYPE)\n@@ -4425,15 +4425,15 @@ make_tree (tree type, rtx x)\n \tt = type;\n \n       return fold (convert (type,\n-\t\t\t    build (TRUNC_DIV_EXPR, t,\n-\t\t\t\t   make_tree (t, XEXP (x, 0)),\n-\t\t\t\t   make_tree (t, XEXP (x, 1)))));\n+\t\t\t    build2 (TRUNC_DIV_EXPR, t,\n+\t\t\t\t    make_tree (t, XEXP (x, 0)),\n+\t\t\t\t    make_tree (t, XEXP (x, 1)))));\n     case UDIV:\n       t = lang_hooks.types.unsigned_type (type);\n       return fold (convert (type,\n-\t\t\t    build (TRUNC_DIV_EXPR, t,\n-\t\t\t\t   make_tree (t, XEXP (x, 0)),\n-\t\t\t\t   make_tree (t, XEXP (x, 1)))));\n+\t\t\t    build2 (TRUNC_DIV_EXPR, t,\n+\t\t\t\t    make_tree (t, XEXP (x, 0)),\n+\t\t\t\t    make_tree (t, XEXP (x, 1)))));\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n@@ -4483,11 +4483,11 @@ const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int\n   add_type = (GET_MODE (add) == VOIDmode ? mult_type\n \t      : lang_hooks.types.type_for_mode (GET_MODE (add), unsignedp));\n \n-  result = fold (build (PLUS_EXPR, mult_type,\n-\t\t\tfold (build (MULT_EXPR, mult_type,\n-\t\t\t\t     make_tree (mult_type, x),\n-\t\t\t\t     make_tree (mult_type, mult))),\n-\t\t\tmake_tree (add_type, add)));\n+  result = fold (build2 (PLUS_EXPR, mult_type,\n+\t\t\t fold (build2 (MULT_EXPR, mult_type,\n+\t\t\t\t       make_tree (mult_type, x),\n+\t\t\t\t       make_tree (mult_type, mult))),\n+\t\t\t make_tree (add_type, add)));\n \n   return TREE_CONSTANT_OVERFLOW (result);\n }\n@@ -4508,11 +4508,11 @@ expand_mult_add (rtx x, rtx target, rtx mult, rtx add, enum machine_mode mode,\n   tree add_type = (GET_MODE (add) == VOIDmode\n \t\t   ? type: lang_hooks.types.type_for_mode (GET_MODE (add),\n \t\t\t\t\t\t\t   unsignedp));\n-  tree result =  fold (build (PLUS_EXPR, type,\n-\t\t\t      fold (build (MULT_EXPR, type,\n-\t\t\t\t\t   make_tree (type, x),\n-\t\t\t\t\t   make_tree (type, mult))),\n-\t\t\t      make_tree (add_type, add)));\n+  tree result =  fold (build2 (PLUS_EXPR, type,\n+\t\t\t       fold (build2 (MULT_EXPR, type,\n+\t\t\t\t\t     make_tree (type, x),\n+\t\t\t\t\t     make_tree (type, mult))),\n+\t\t\t       make_tree (add_type, add)));\n \n   return expand_expr (result, target, VOIDmode, 0);\n }"}, {"sha": "0cb1fcad09718b8b483d5301ff98b70ed353e916", "filename": "gcc/expr.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -1322,8 +1322,8 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n \n   /* Now we have to build up the CALL_EXPR itself.  */\n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     call_expr, arg_list, NULL_TREE);\n+  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t      call_expr, arg_list, NULL_TREE);\n \n   retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n \n@@ -2390,8 +2390,8 @@ clear_storage_via_libcall (rtx object, rtx size)\n \n   /* Now we have to build up the CALL_EXPR itself.  */\n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n-  call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     call_expr, arg_list, NULL_TREE);\n+  call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t      call_expr, arg_list, NULL_TREE);\n \n   retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n \n@@ -4529,8 +4529,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t      if (BYTES_BIG_ENDIAN)\n \t\tvalue\n-\t\t  = fold (build (LSHIFT_EXPR, type, value,\n-\t\t\t\t build_int_2 (BITS_PER_WORD - bitsize, 0)));\n+\t\t  = fold (build2 (LSHIFT_EXPR, type, value,\n+\t\t\t\t  build_int_2 (BITS_PER_WORD - bitsize, 0)));\n \t      bitsize = BITS_PER_WORD;\n \t      mode = word_mode;\n \t    }\n@@ -4729,8 +4729,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t  /* Assign value to element index.  */\n \t\t  position\n \t\t    = convert (ssizetype,\n-\t\t\t       fold (build (MINUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t\t    index, TYPE_MIN_VALUE (domain))));\n+\t\t\t       fold (build2 (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t\t     index, TYPE_MIN_VALUE (domain))));\n \t\t  position = size_binop (MULT_EXPR, position,\n \t\t\t\t\t convert (ssizetype,\n \t\t\t\t\t\t  TYPE_SIZE_UNIT (elttype)));\n@@ -4746,8 +4746,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    store_expr (value, xtarget, 0);\n \n \t\t  /* Generate a conditional jump to exit the loop.  */\n-\t\t  exit_cond = build (LT_EXPR, integer_type_node,\n-\t\t\t\t     index, hi_index);\n+\t\t  exit_cond = build2 (LT_EXPR, integer_type_node,\n+\t\t\t\t      index, hi_index);\n \t\t  jumpif (exit_cond, loop_end);\n \n \t\t  /* Update the loop counter, and jump to the head of\n@@ -4772,8 +4772,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t      if (minelt)\n \t\tindex = fold_convert (ssizetype,\n-\t\t\t\t      fold (build (MINUS_EXPR, index,\n-\t\t\t\t\t\t   TYPE_MIN_VALUE (domain))));\n+\t\t\t\t      fold (build2 (MINUS_EXPR,\n+\t\t\t\t\t\t    TREE_TYPE (index),\n+\t\t\t\t\t\t    index,\n+\t\t\t\t\t\t    TYPE_MIN_VALUE (domain))));\n \n \t      position = size_binop (MULT_EXPR, index,\n \t\t\t\t     convert (ssizetype,\n@@ -5409,8 +5411,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t     index, then convert to sizetype and multiply by the size of the\n \t     array element.  */\n \t  if (! integer_zerop (low_bound))\n-\t    index = fold (build (MINUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t index, low_bound));\n+\t    index = fold (build2 (MINUS_EXPR, TREE_TYPE (index),\n+\t\t\t\t  index, low_bound));\n \n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       size_binop (MULT_EXPR,\n@@ -7601,10 +7603,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (flag_unsafe_math_optimizations && optimize && !optimize_size\n \t  && TREE_CODE (type) == REAL_TYPE\n \t  && !real_onep (TREE_OPERAND (exp, 0)))\n-        return expand_expr (build (MULT_EXPR, type, TREE_OPERAND (exp, 0),\n-\t\t\t\t   build (RDIV_EXPR, type,\n-\t\t\t\t\t  build_real (type, dconst1),\n-\t\t\t\t\t  TREE_OPERAND (exp, 1))),\n+        return expand_expr (build2 (MULT_EXPR, type, TREE_OPERAND (exp, 0),\n+\t\t\t\t    build2 (RDIV_EXPR, type,\n+\t\t\t\t\t    build_real (type, dconst1),\n+\t\t\t\t\t    TREE_OPERAND (exp, 1))),\n \t\t\t    target, tmode, modifier);\n       this_optab = sdiv_optab;\n       goto binop;\n@@ -7974,9 +7976,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      || (TREE_CODE_CLASS (TREE_CODE (iffalse)) == '1'\n \t\t  && operand_equal_p (iftrue, TREE_OPERAND (iffalse, 0), 0)))\n \t    return expand_expr (build1 (NOP_EXPR, type,\n-\t\t\t\t\tbuild (COND_EXPR, TREE_TYPE (iftrue),\n-\t\t\t\t\t       TREE_OPERAND (exp, 0),\n-\t\t\t\t\t       iftrue, iffalse)),\n+\t\t\t\t\tbuild3 (COND_EXPR, TREE_TYPE (iftrue),\n+\t\t\t\t\t\tTREE_OPERAND (exp, 0),\n+\t\t\t\t\t\tiftrue, iffalse)),\n \t\t\t\ttarget, tmode, modifier);\n \t}\n \n@@ -8152,9 +8154,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      expand_expr (TREE_OPERAND (binary_op, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n \t    else if (binary_op)\n-\t      store_expr (build (TREE_CODE (binary_op), type,\n-\t\t\t\t make_tree (type, temp),\n-\t\t\t\t TREE_OPERAND (binary_op, 1)),\n+\t      store_expr (build2 (TREE_CODE (binary_op), type,\n+\t\t\t\t  make_tree (type, temp),\n+\t\t\t\t  TREE_OPERAND (binary_op, 1)),\n \t\t\t  temp, modifier == EXPAND_STACK_PARM ? 2 : 0);\n \t    else\n \t      store_expr (build1 (TREE_CODE (unary_op), type,\n@@ -9033,8 +9035,8 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n       rtx rangertx = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n       /* We must handle the endpoints in the original mode.  */\n-      index_expr = build (MINUS_EXPR, index_type,\n-\t\t\t  index_expr, minval);\n+      index_expr = build2 (MINUS_EXPR, index_type,\n+\t\t\t   index_expr, minval);\n       minval = integer_zero_node;\n       index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n       emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n@@ -9175,9 +9177,9 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n   if (! HAVE_tablejump)\n     return 0;\n \n-  index_expr = fold (build (MINUS_EXPR, index_type,\n-\t\t\t    convert (index_type, index_expr),\n-\t\t\t    convert (index_type, minval)));\n+  index_expr = fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t     convert (index_type, index_expr),\n+\t\t\t     convert (index_type, minval)));\n   index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n   do_pending_stack_adjust ();\n "}, {"sha": "a55b023887bfdd3ed679eb8e7b57e303473461e8", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -4154,8 +4154,9 @@ expand_function_start (tree subr)\n \t before the frame variable gets declared.  Help out...  */\n       expand_var (TREE_OPERAND (cfun->nonlocal_goto_save_area, 0));\n \n-      t_save = build (ARRAY_REF, ptr_type_node, cfun->nonlocal_goto_save_area,\n-\t\t      integer_zero_node, NULL_TREE, NULL_TREE);\n+      t_save = build4 (ARRAY_REF, ptr_type_node,\n+\t\t       cfun->nonlocal_goto_save_area,\n+\t\t       integer_zero_node, NULL_TREE, NULL_TREE);\n       r_save = expand_expr (t_save, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       r_save = convert_memory_address (Pmode, r_save);\n "}, {"sha": "542d843eef113298e8cd6e8f56f9753f95db1805", "filename": "gcc/stmt.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -2655,10 +2655,10 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n       else\n         test[i].bits++;\n \n-      lo = tree_low_cst (fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t      n->low, minval)), 1);\n-      hi = tree_low_cst (fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t      n->high, minval)), 1);\n+      lo = tree_low_cst (fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t       n->low, minval)), 1);\n+      hi = tree_low_cst (fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t       n->high, minval)), 1);\n       for (j = lo; j <= hi; j++)\n         if (j >= HOST_BITS_PER_WIDE_INT)\n \t  test[i].hi |= (HOST_WIDE_INT) 1 << (j - HOST_BITS_PER_INT);\n@@ -2668,9 +2668,9 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n \n   qsort (test, count, sizeof(*test), case_bit_test_cmp);\n \n-  index_expr = fold (build (MINUS_EXPR, index_type,\n-\t\t\t    convert (index_type, index_expr),\n-\t\t\t    convert (index_type, minval)));\n+  index_expr = fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t     convert (index_type, index_expr),\n+\t\t\t     convert (index_type, minval)));\n   index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n   do_pending_stack_adjust ();\n \n@@ -2808,7 +2808,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \n       /* Compute span of values.  */\n       if (count != 0)\n-\trange = fold (build (MINUS_EXPR, index_type, maxval, minval));\n+\trange = fold (build2 (MINUS_EXPR, index_type, maxval, minval));\n \n       if (count == 0)\n \t{\n@@ -2973,11 +2973,11 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t\t value since that should fit in a HOST_WIDE_INT while the\n \t\t actual values may not.  */\n \t      HOST_WIDE_INT i_low\n-\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t\t     n->low, minval)), 1);\n+\t\t= tree_low_cst (fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t\t      n->low, minval)), 1);\n \t      HOST_WIDE_INT i_high\n-\t\t= tree_low_cst (fold (build (MINUS_EXPR, index_type,\n-\t\t\t\t\t     n->high, minval)), 1);\n+\t\t= tree_low_cst (fold (build2 (MINUS_EXPR, index_type,\n+\t\t\t\t\t      n->high, minval)), 1);\n \t      HOST_WIDE_INT i;\n \n \t      for (i = i_low; i <= i_high; i ++)\n@@ -3280,8 +3280,8 @@ node_has_low_bound (case_node_ptr node, tree index_type)\n   if (node->left)\n     return 0;\n \n-  low_minus_one = fold (build (MINUS_EXPR, TREE_TYPE (node->low),\n-\t\t\t       node->low, integer_one_node));\n+  low_minus_one = fold (build2 (MINUS_EXPR, TREE_TYPE (node->low),\n+\t\t\t\tnode->low, integer_one_node));\n \n   /* If the subtraction above overflowed, we can't verify anything.\n      Otherwise, look for a parent that tests our value - 1.  */\n@@ -3330,8 +3330,8 @@ node_has_high_bound (case_node_ptr node, tree index_type)\n   if (node->right)\n     return 0;\n \n-  high_plus_one = fold (build (PLUS_EXPR, TREE_TYPE (node->high),\n-\t\t\t       node->high, integer_one_node));\n+  high_plus_one = fold (build2 (PLUS_EXPR, TREE_TYPE (node->high),\n+\t\t\t\tnode->high, integer_one_node));\n \n   /* If the addition above overflowed, we can't verify anything.\n      Otherwise, look for a parent that tests our value + 1.  */\n@@ -3754,8 +3754,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      new_index = expand_simple_binop (mode, MINUS, index, low_rtx,\n \t\t\t\t\t       NULL_RTX, unsignedp,\n \t\t\t\t\t       OPTAB_WIDEN);\n-\t      new_bound = expand_expr (fold (build (MINUS_EXPR, type,\n-\t\t\t\t\t\t    high, low)),\n+\t      new_bound = expand_expr (fold (build2 (MINUS_EXPR, type,\n+\t\t\t\t\t\t     high, low)),\n \t\t\t\t       NULL_RTX, mode, 0);\n \n \t      emit_cmp_and_jump_insns (new_index, new_bound, GT, NULL_RTX,"}, {"sha": "772177077f2b10041c163f54ed5bad74cd76cbf7", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -802,9 +802,9 @@ place_union_field (record_layout_info rli, tree field)\n   if (TREE_CODE (rli->t) == UNION_TYPE)\n     rli->offset = size_binop (MAX_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n   else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n-    rli->offset = fold (build (COND_EXPR, sizetype,\n-\t\t\t       DECL_QUALIFIER (field),\n-\t\t\t       DECL_SIZE_UNIT (field), rli->offset));\n+    rli->offset = fold (build3 (COND_EXPR, sizetype,\n+\t\t\t\tDECL_QUALIFIER (field),\n+\t\t\t\tDECL_SIZE_UNIT (field), rli->offset));\n }\n \n #if defined (PCC_BITFIELD_TYPE_MATTERS) || defined (BITFIELD_NBYTES_LIMITED)\n@@ -1692,9 +1692,9 @@ layout_type (tree type)\n \t       that (possible) negative values are handled appropriately.  */\n \t    length = size_binop (PLUS_EXPR, size_one_node,\n \t\t\t\t convert (sizetype,\n-\t\t\t\t\t  fold (build (MINUS_EXPR,\n-\t\t\t\t\t\t       TREE_TYPE (lb),\n-\t\t\t\t\t\t       ub, lb))));\n+\t\t\t\t\t  fold (build2 (MINUS_EXPR,\n+\t\t\t\t\t\t\tTREE_TYPE (lb),\n+\t\t\t\t\t\t\tub, lb))));\n \n \t    /* Special handling for arrays of bits (for Chill).  */\n \t    element_size = TYPE_SIZE (element);"}, {"sha": "bba53fd5727f361d77cad525080a4b2c948bc003", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -1898,17 +1898,16 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t && TREE_OPERAND (exp, 1) == f)\n        return r;\n \n-     /* If this expression hasn't been completed let, leave it\n-\talone.  */\n+     /* If this expression hasn't been completed let, leave it alone.  */\n      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && TREE_TYPE (inner) == 0)\n        return exp;\n \n      op0 = SUBSTITUTE_IN_EXPR (TREE_OPERAND (exp, 0), f, r);\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n-     new = fold (build (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n-\t\t\tNULL_TREE));\n+     new = fold (build3 (COMPONENT_REF, TREE_TYPE (exp),\n+\t\t\t op0, TREE_OPERAND (exp, 1), NULL_TREE));\n    }\n   else\n     switch (TREE_CODE_CLASS (code))\n@@ -5761,16 +5760,16 @@ tree_fold_gcd (tree a, tree b)\n     return a;\n   \n   if (tree_int_cst_sgn (a) == -1)\n-    a = fold (build (MULT_EXPR, type, a,\n-\t\t     convert (type, integer_minus_one_node)));\n+    a = fold (build2 (MULT_EXPR, type, a,\n+\t\t      convert (type, integer_minus_one_node)));\n   \n   if (tree_int_cst_sgn (b) == -1)\n-    b = fold (build (MULT_EXPR, type, b,\n-\t\t     convert (type, integer_minus_one_node)));\n+    b = fold (build2 (MULT_EXPR, type, b,\n+\t\t      convert (type, integer_minus_one_node)));\n  \n   while (1)\n     {\n-      a_mod_b = fold (build (CEIL_MOD_EXPR, type, a, b));\n+      a_mod_b = fold (build2 (CEIL_MOD_EXPR, type, a, b));\n  \n       if (!TREE_INT_CST_LOW (a_mod_b)\n \t  && !TREE_INT_CST_HIGH (a_mod_b))"}, {"sha": "95ac3775136a9f271622d32fdd5b587403f50fa8", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3244e67d15cd8cf65da89849a2bea5161a7ed102/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=3244e67d15cd8cf65da89849a2bea5161a7ed102", "patch": "@@ -2362,9 +2362,9 @@ copy_constant (tree exp)\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      return build (TREE_CODE (exp), TREE_TYPE (exp),\n-\t\t    copy_constant (TREE_OPERAND (exp, 0)),\n-\t\t    copy_constant (TREE_OPERAND (exp, 1)));\n+      return build2 (TREE_CODE (exp), TREE_TYPE (exp),\n+\t\t     copy_constant (TREE_OPERAND (exp, 0)),\n+\t\t     copy_constant (TREE_OPERAND (exp, 1)));\n \n     case NOP_EXPR:\n     case CONVERT_EXPR:"}]}