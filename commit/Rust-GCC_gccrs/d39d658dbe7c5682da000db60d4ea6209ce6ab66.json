{"sha": "d39d658dbe7c5682da000db60d4ea6209ce6ab66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM5ZDY1OGRiZTdjNTY4MmRhMDAwZGI2MGQ0ZWE2MjA5Y2U2YWI2Ng==", "commit": {"author": {"name": "Rask Ingemann Lambertsen", "email": "rask@sygehus.dk", "date": "2007-08-14T14:39:24Z"}, "committer": {"name": "Rask Ingemann Lambertsen", "email": "rask@gcc.gnu.org", "date": "2007-08-14T14:39:24Z"}, "message": "re PR target/30315 (optimize unsigned-add overflow test on x86 to use cpu flags from addl)\n\n\tPR target/30315\n\t* config/i386/i386.h (CANONICALIZE_COMPARISON): New.\n\t* config/i386/i386.md (plusminus)(addsub)(SWI): New.\n\t(*<addsub><mode>3_cc_overflow): New.\n\t(*add<mode>3_cconly_overflow): New.\n\t(*sub<mode>3_cconly_overflow): New.\n\t(*<addsub>si3_zext_cc_overflow): New.\n\t* config/i386/predicates.md (fcmov_comparison_operator): Accept\n\tCCCmode for LTU, GTU, LEU and GEU.\n\t(ix86_comparison_operator): Likewise.\n\t(ix86_carry_flag_operator): Carry flag is set if LTU or GTU in CCCmode.\n\t* gcc/config/i386/i386.c (put_condition_code): Support CCCmode.\n\t(ix86_cc_mode): Use CCCmode when testing for overflow of PLUS\n\tor MINUS expressions.\n\ntestsuite/\n\tPR target/30315\n\t* gcc.target/i386/pr30315.c: New.\n\nFrom-SVN: r127481", "tree": {"sha": "22db592c1799b6343afa09bfa8ece2e1faa8d6d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22db592c1799b6343afa09bfa8ece2e1faa8d6d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d39d658dbe7c5682da000db60d4ea6209ce6ab66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39d658dbe7c5682da000db60d4ea6209ce6ab66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d39d658dbe7c5682da000db60d4ea6209ce6ab66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d39d658dbe7c5682da000db60d4ea6209ce6ab66/comments", "author": null, "committer": null, "parents": [{"sha": "9a251aa11803ceed2c52286f2b649b4d53a05dba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a251aa11803ceed2c52286f2b649b4d53a05dba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a251aa11803ceed2c52286f2b649b4d53a05dba"}], "stats": {"total": 255, "additions": 244, "deletions": 11}, "files": [{"sha": "f22ca2214d37d56d5c21867e7b4ccef5dae70933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -1,3 +1,20 @@\n+2007-08-14  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n+\n+\tPR target/30315\n+\t* config/i386/i386.h (CANONICALIZE_COMPARISON): New.\n+\t* config/i386/i386.md (plusminus)(addsub)(SWI): New.\n+\t(*<addsub><mode>3_cc_overflow): New.\n+\t(*add<mode>3_cconly_overflow): New.\n+\t(*sub<mode>3_cconly_overflow): New.\n+\t(*<addsub>si3_zext_cc_overflow): New.\n+\t* config/i386/predicates.md (fcmov_comparison_operator): Accept\n+\tCCCmode for LTU, GTU, LEU and GEU.\n+\t(ix86_comparison_operator): Likewise.\n+\t(ix86_carry_flag_operator): Carry flag is set if LTU or GTU in CCCmode.\n+\t* gcc/config/i386/i386.c (put_condition_code): Support CCCmode.\n+\t(ix86_cc_mode): Use CCCmode when testing for overflow of PLUS\n+\tor MINUS expressions.\n+\n 2007-08-14  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR c/30428"}, {"sha": "20044fdf92ade3c70e888d58209c557a65c06435", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -8261,8 +8261,12 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n     case GTU:\n       /* ??? Use \"nbe\" instead of \"a\" for fcmov lossage on some assemblers.\n \t Those same assemblers have the same but opposite lossage on cmov.  */\n-      gcc_assert (mode == CCmode);\n-      suffix = fp ? \"nbe\" : \"a\";\n+      if (mode == CCmode)\n+\tsuffix = fp ? \"nbe\" : \"a\";\n+      else if (mode == CCCmode)\n+\tsuffix = \"b\";\n+      else\n+\tgcc_unreachable ();\n       break;\n     case LT:\n       switch (mode)\n@@ -8282,7 +8286,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n \t}\n       break;\n     case LTU:\n-      gcc_assert (mode == CCmode);\n+      gcc_assert (mode == CCmode || mode == CCCmode);\n       suffix = \"b\";\n       break;\n     case GE:\n@@ -8304,16 +8308,21 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n       break;\n     case GEU:\n       /* ??? As above.  */\n-      gcc_assert (mode == CCmode);\n+      gcc_assert (mode == CCmode || mode == CCCmode);\n       suffix = fp ? \"nb\" : \"ae\";\n       break;\n     case LE:\n       gcc_assert (mode == CCmode || mode == CCGCmode || mode == CCNOmode);\n       suffix = \"le\";\n       break;\n     case LEU:\n-      gcc_assert (mode == CCmode);\n-      suffix = \"be\";\n+      /* ??? As above.  */\n+      if (mode == CCmode)\n+\tsuffix = \"be\";\n+      else if (mode == CCCmode)\n+\tsuffix = fp ? \"nb\" : \"ae\";\n+      else\n+\tgcc_unreachable ();\n       break;\n     case UNORDERED:\n       suffix = fp ? \"u\" : \"p\";\n@@ -11040,10 +11049,21 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n       return CCZmode;\n       /* Codes needing carry flag.  */\n     case GEU:\t\t\t/* CF=0 */\n-    case GTU:\t\t\t/* CF=0 & ZF=0 */\n     case LTU:\t\t\t/* CF=1 */\n+      /* Detect overflow checks.  They need just the carry flag.  */\n+      if (GET_CODE (op0) == PLUS\n+\t  && rtx_equal_p (op1, XEXP (op0, 0)))\n+\treturn CCCmode;\n+      else\n+\treturn CCmode;\n+    case GTU:\t\t\t/* CF=0 & ZF=0 */\n     case LEU:\t\t\t/* CF=1 | ZF=1 */\n-      return CCmode;\n+      /* Detect overflow checks.  They need just the carry flag.  */\n+      if (GET_CODE (op0) == MINUS\n+\t  && rtx_equal_p (op1, XEXP (op0, 0)))\n+\treturn CCCmode;\n+      else\n+\treturn CCmode;\n       /* Codes possibly doable only with sign flag when\n          comparing against zero.  */\n     case GE:\t\t\t/* SF=OF   or   SF=0 */"}, {"sha": "4a41a6c76f83bea95ee7f15fece1b1efde60b094", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -2065,6 +2065,16 @@ do {\t\t\t\t\t\t\t\\\n \n #define SELECT_CC_MODE(OP, X, Y) ix86_cc_mode ((OP), (X), (Y))\n \n+/* Canonicalize overflow checks to save on the insn patterns. We change\n+   \"a + b < b\" into \"a + b < a\" and \"a + b >= b\" into \"a + b >= a\".  */\n+#define CANONICALIZE_COMPARISON(code, op0, op1)\t\\\n+{\t\t\t\t\t\t\\\n+  if ((code == LTU || code == GEU)\t\t\\\n+      && GET_CODE (op0) == PLUS\t\t\t\\\n+      && rtx_equal_p (op1, XEXP (op0, 1)))\t\\\n+    op1 = XEXP (op0, 0);\t\t\t\\\n+}\n+\n /* Return nonzero if MODE implies a floating point inequality can be\n    reversed.  */\n "}, {"sha": "f316cec0989d08a67ca25d16b6393d013079b378", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -488,6 +488,33 @@\n   [(set_attr \"length\" \"128\")\n    (set_attr \"type\" \"multi\")])\n \n+(define_code_macro plusminus [plus minus])\n+\n+;; Base name for define_insn and insn mnemonic.\n+(define_code_attr addsub [(plus \"add\") (minus \"sub\")])\n+\n+;; Mark commutative operators as such in constraints.\n+(define_code_attr comm [(plus \"%\") (minus \"\")])\n+\n+;; All single word integer modes.\n+(define_mode_macro SWI [QI HI SI (DI \"TARGET_64BIT\")])\n+\n+;; Instruction suffix for integer modes.\n+(define_mode_attr imodesuffix [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n+\n+;; Register class for integer modes.\n+(define_mode_attr r [(QI \"q\") (HI \"r\") (SI \"r\") (DI \"r\")])\n+\n+;; Immediate operand constraint for integer modes.\n+(define_mode_attr i [(QI \"i\") (HI \"i\") (SI \"i\") (DI \"e\")])\n+\n+;; General operand predicate for integer modes.\n+(define_mode_attr general_operand\n+\t[(QI \"general_operand\")\n+\t (HI \"general_operand\")\n+\t (SI \"general_operand\")\n+\t (DI \"x86_64_general_operand\")])\n+\n ;; All x87 floating point modes\n (define_mode_macro X87MODEF [SF DF XF])\n \n@@ -4855,6 +4882,56 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"*<addsub><mode>3_cc_overflow\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t    (plusminus:SWI\n+\t\t(match_operand:SWI 1 \"nonimmediate_operand\" \"<comm>0,0\")\n+\t\t(match_operand:SWI 2 \"<general_operand>\" \"<r><i>,<r>m\"))\n+\t    (match_dup 1)))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n+\t(plusminus:SWI (match_dup 1) (match_dup 2)))]\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+  \"<addsub>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*add<mode>3_cconly_overflow\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t\t(plus:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<r><i>m\"))\n+\t\t(match_dup 1)))\n+   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n+  \"ix86_binary_operator_ok (PLUS, <MODE>mode, operands)\"\n+  \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*sub<mode>3_cconly_overflow\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t     (minus:SWI (match_operand:SWI 0 \"nonimmediate_operand\" \"<r>m,<r>\")\n+\t\t\t(match_operand:SWI 1 \"<general_operand>\" \"<r><i>,<r>m\"))\n+\t     (match_dup 0)))]\n+  \"\"\n+  \"cmp{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"icmp\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_insn \"*<addsub>si3_zext_cc_overflow\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t    (plusminus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"<comm>0\")\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t    (match_dup 1)))\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (plusminus:SI (match_dup 1) (match_dup 2))))]\n+  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+  \"<addsub>{l}\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn \"addqi3_carry\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,q\")\n \t  (plus:QI (plus:QI (match_operand:QI 3 \"ix86_carry_flag_operator\" \"\")"}, {"sha": "f231c5788e54fd35cebb8580b9b9ece4edd72039", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -879,7 +879,8 @@\n   switch (code)\n     {\n     case LTU: case GTU: case LEU: case GEU:\n-      if (inmode == CCmode || inmode == CCFPmode || inmode == CCFPUmode)\n+      if (inmode == CCmode || inmode == CCFPmode || inmode == CCFPUmode\n+\t  || inmode == CCCmode)\n \treturn 1;\n       return 0;\n     case ORDERED: case UNORDERED:\n@@ -924,7 +925,11 @@\n \t  || inmode == CCGOCmode || inmode == CCNOmode)\n \treturn 1;\n       return 0;\n-    case LTU: case GTU: case LEU: case ORDERED: case UNORDERED: case GEU:\n+    case LTU: case GTU: case LEU: case GEU:\n+      if (inmode == CCmode || inmode == CCCmode)\n+\treturn 1;\n+      return 0;\n+    case ORDERED: case UNORDERED:\n       if (inmode == CCmode)\n \treturn 1;\n       return 0;\n@@ -939,7 +944,7 @@\n \n ;; Return 1 if OP is a valid comparison operator testing carry flag to be set.\n (define_predicate \"ix86_carry_flag_operator\"\n-  (match_code \"ltu,lt,unlt,gt,ungt,le,unle,ge,unge,ltgt,uneq\")\n+  (match_code \"ltu,lt,unlt,gtu,gt,ungt,le,unle,ge,unge,ltgt,uneq\")\n {\n   enum machine_mode inmode = GET_MODE (XEXP (op, 0));\n   enum rtx_code code = GET_CODE (op);\n@@ -957,6 +962,8 @@\n \treturn 0;\n       code = ix86_fp_compare_code_to_integer (code);\n     }\n+  else if (inmode == CCCmode)\n+   return code == LTU || code == GTU;\n   else if (inmode != CCmode)\n     return 0;\n "}, {"sha": "124a8220398cfc989ee9e8d5d7980d2651cc727b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -1,3 +1,8 @@\n+2007-08-14  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n+\n+\tPR target/30315\n+\t* gcc.target/i386/pr30315.c: New.\n+\n 2007-08-14  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/32594"}, {"sha": "998d5071e5c0d9f290aac61f3673c9f5b9b31035", "filename": "gcc/testsuite/gcc.target/i386/pr30315.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr30315.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d39d658dbe7c5682da000db60d4ea6209ce6ab66/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr30315.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr30315.c?ref=d39d658dbe7c5682da000db60d4ea6209ce6ab66", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"cmp\" 4 } } */\n+\n+extern void abort (void);\n+int c;\n+\n+#define PLUSCC1(T, t, C)\t\\\n+T pluscc##t##C (T a, T b)\t\\\n+{\t\\\n+  T sum = a + b;\t\\\n+  if (sum < C)\t\t\\\n+    abort ();\t\t\\\n+  return sum;\t\t\\\n+}\n+#define PLUSCC(T, t) PLUSCC1(T, t, a) PLUSCC1(T, t, b)\n+\n+#define INCCC1(T, t, C)\t\\\n+T inccc##t##C (T a, T b)\t\\\n+{\t\\\n+  T sum = a + b;\t\\\n+  if (sum < C)\t\t\\\n+    c ++;\t\t\\\n+  return sum;\t\t\\\n+}\n+#define INCCC(T, t) INCCC1(T, t, a) INCCC1(T, t, b)\n+\n+#define PLUSCCONLY1(T, t, C)\t\\\n+void pluscconly##t##C (T a, T b)\t\\\n+{\t\\\n+  T sum = a + b;\t\\\n+  if (sum < C)\t\t\\\n+    abort ();\t\t\\\n+}\n+#define PLUSCCONLY(T, t) PLUSCCONLY1(T, t, a) PLUSCCONLY1(T, t, b)\n+\n+#define MINUSCC(T, t)\t\\\n+T minuscc##t (T a, T b)\t\\\n+{\t\\\n+  T difference = a - b;\t\\\n+  if (difference > a)\t\\\n+    abort ();\t\t\\\n+  return difference;\t\\\n+}\n+\n+#define DECCC(T, t)\t\\\n+T deccc##t (T a, T b)\t\\\n+{\t\\\n+  T difference = a - b;\t\\\n+  if (difference > a)\t\\\n+    c --;\t\t\\\n+  return difference;\t\\\n+}\n+\n+#define MINUSCCONLY(T, t)\t\\\n+void minuscconly##t (T a, T b)\t\\\n+{\t\\\n+  T difference = a - b;\t\\\n+  if (difference > a)\t\\\n+    abort ();\t\t\\\n+}\n+\n+#define TEST(T, t)\t\\\n+  PLUSCC(T, t)\t\t\\\n+  PLUSCCONLY(T, t)\t\\\n+  INCCC(T, t)\t\t\\\n+  MINUSCC(T, t)\t\t\\\n+  MINUSCCONLY(T, t)\t\\\n+  DECCC(T, t)\n+\n+TEST (unsigned long,  l)\n+TEST (unsigned int,   i)\n+TEST (unsigned short, s) \n+TEST (unsigned char,  c)\n+\n+#define PLUSCCZEXT(C)\t\\\n+unsigned long pluscczext##C (unsigned int a, unsigned int b)\t\\\n+{\t\\\n+  unsigned int sum = a + b;\t\\\n+  if (sum < C)\t\t\\\n+    abort ();\t\t\\\n+  return sum;\t\t\\\n+}\n+\n+PLUSCCZEXT(a)\n+PLUSCCZEXT(b)\n+\n+#define MINUSCCZEXT\t\\\n+unsigned long minuscczext (unsigned int a, unsigned int b)\t\\\n+{\t\\\n+  unsigned int difference = a - b;\t\\\n+  if (difference > a)\t\t\\\n+    abort ();\t\t\t\\\n+  return difference;\t\t\\\n+}\n+\n+MINUSCCZEXT"}]}