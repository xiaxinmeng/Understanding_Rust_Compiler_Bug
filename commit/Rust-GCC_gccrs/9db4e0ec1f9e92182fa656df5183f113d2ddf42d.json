{"sha": "9db4e0ec1f9e92182fa656df5183f113d2ddf42d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiNGUwZWMxZjllOTIxODJmYTY1NmRmNTE4M2YxMTNkMmRkZjQyZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-04T23:01:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-11-04T23:01:28Z"}, "message": "Initial revision\n\nFrom-SVN: r54", "tree": {"sha": "3f1cbb112cae4d765252f82eb43d312c8a09ddf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f1cbb112cae4d765252f82eb43d312c8a09ddf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db4e0ec1f9e92182fa656df5183f113d2ddf42d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db4e0ec1f9e92182fa656df5183f113d2ddf42d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db4e0ec1f9e92182fa656df5183f113d2ddf42d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db4e0ec1f9e92182fa656df5183f113d2ddf42d/comments", "author": null, "committer": null, "parents": [{"sha": "aabf90e8ce80ca78708982eee04b776682e2aeb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aabf90e8ce80ca78708982eee04b776682e2aeb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aabf90e8ce80ca78708982eee04b776682e2aeb3"}], "stats": {"total": 954, "additions": 954, "deletions": 0}, "files": [{"sha": "99af18a60a7c1c7cf13865c1e7ed462e469277db", "filename": "gcc/genoutput.c", "status": "added", "additions": 954, "deletions": 0, "changes": 954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db4e0ec1f9e92182fa656df5183f113d2ddf42d/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db4e0ec1f9e92182fa656df5183f113d2ddf42d/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=9db4e0ec1f9e92182fa656df5183f113d2ddf42d", "patch": "@@ -0,0 +1,954 @@\n+/* Generate code from to output assembler insns as recognized from rtl.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This program reads the machine description for the compiler target machine\n+   and produces a file containing these things:\n+\n+   1. An array of strings `insn_template' which is indexed by insn code number\n+   and contains the template for output of that insn,\n+\n+   2. An array of functions `insn_outfun' which, indexed by the insn code\n+   number, gives the function that returns a template to use for output of\n+   that insn.  This is used only in the cases where the template is not\n+   constant.  These cases are specified by a * or @ at the beginning of the\n+   template string in the machine description.  They are identified for the\n+   sake of other parts of the compiler by a zero element in `insn_template'.\n+  \n+   3. An array of functions `insn_gen_function' which, indexed\n+   by insn code number, gives the function to generate a body\n+   for that pattern, given operands as arguments.\n+\n+   4. An array of strings `insn_name' which, indexed by insn code number,\n+   gives the name for that pattern.  Nameless patterns are given a name.\n+\n+   5. An array of ints `insn_n_operands' which is indexed by insn code number\n+   and contains the number of distinct operands in the pattern for that insn,\n+\n+   6. An array of ints `insn_n_dups' which is indexed by insn code number\n+   and contains the number of match_dup's that appear in the insn's pattern.\n+   This says how many elements of `recog_dup_loc' are significant\n+   after an insn has been recognized.\n+\n+   7. An array of arrays of operand constraint strings,\n+   `insn_operand_constraint',\n+   indexed first by insn code number and second by operand number,\n+   containing the constraint for that operand.\n+\n+   This array is generated only if register constraints appear in \n+   match_operand rtx's.\n+\n+   8. An array of arrays of chars which indicate which operands of\n+   which insn patterns appear within ADDRESS rtx's.  This array is\n+   called `insn_operand_address_p' and is generated only if there\n+   are *no* register constraints in the match_operand rtx's.\n+\n+   9. An array of arrays of machine modes, `insn_operand_mode',\n+   indexed first by insn code number and second by operand number,\n+   containing the machine mode that that operand is supposed to have.\n+   Also `insn_operand_strict_low', which is nonzero for operands\n+   contained in a STRICT_LOW_PART.\n+\n+   10. An array of arrays of int-valued functions, `insn_operand_predicate',\n+   indexed first by insn code number and second by operand number,\n+   containing the match_operand predicate for this operand.\n+\n+   11. An array of ints, `insn_n_alternatives', that gives the number\n+   of alternatives in the constraints of each pattern.\n+\n+The code number of an insn is simply its position in the machine description;\n+code numbers are assigned sequentially to entries in the description,\n+starting with code number 0.\n+\n+Thus, the following entry in the machine description\n+\n+    (define_insn \"clrdf\"\n+      [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t    (const_int 0))]\n+      \"\"\n+      \"clrd %0\")\n+\n+assuming it is the 25th entry present, would cause\n+insn_template[24] to be \"clrd %0\", and insn_n_operands[24] to be 1.\n+It would not make an case in output_insn_hairy because the template\n+given in the entry is a constant (it does not start with `*').  */\n+\f\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"obstack.h\"\n+\n+/* No instruction can have more operands than this.\n+   Sorry for this arbitrary limit, but what machine will\n+   have an instruction with this many operands?  */\n+\n+#define MAX_MAX_OPERANDS 40\n+\n+static struct obstack obstack;\n+struct obstack *rtl_obstack = &obstack;\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+extern void free ();\n+\n+char *xmalloc ();\n+static void fatal ();\n+void fancy_abort ();\n+static void error ();\n+static void mybcopy ();\n+static void mybzero ();\n+static int n_occurrences ();\n+\n+/* insns in the machine description are assigned sequential code numbers\n+   that are used by insn-recog.c (produced by genrecog) to communicate\n+   to insn-output.c (produced by this program).  */\n+\n+static int next_code_number;\n+\n+/* This counts all definitions in the md file,\n+   for the sake of error messages.  */\n+\n+static int next_index_number;\n+\n+/* Record in this chain all information that we will output,\n+   associated with the code number of the insn.  */\n+\n+struct data\n+{\n+  int code_number;\n+  int index_number;\n+  char *name;\n+  char *template;\t\t/* string such as \"movl %1,%0\" */\n+  int n_operands;\t\t/* Number of operands this insn recognizes */\n+  int n_dups;\t\t\t/* Number times match_dup appears in pattern */\n+  int n_alternatives;\t\t/* Number of alternatives in each constraint */\n+  struct data *next;\n+  char *constraints[MAX_MAX_OPERANDS];\n+  /* Number of alternatives in constraints of operand N.  */\n+  int op_n_alternatives[MAX_MAX_OPERANDS];\n+  char *predicates[MAX_MAX_OPERANDS];\n+  char address_p[MAX_MAX_OPERANDS];\n+  enum machine_mode modes[MAX_MAX_OPERANDS];\n+  char strict_low[MAX_MAX_OPERANDS];\n+  char outfun;\t\t\t/* Nonzero means this has an output function */\n+};\n+\n+/* This variable points to the first link in the chain.  */\n+\n+struct data *insn_data;\n+\n+/* Pointer to the last link in the chain, so new elements\n+   can be added at the end.  */\n+\n+struct data *end_of_insn_data;\n+\n+/* Nonzero if any match_operand has a constraint string;\n+   implies that REGISTER_CONSTRAINTS will be defined\n+   for this machine description.  */\n+\n+int have_constraints;\n+\f\n+static void\n+output_prologue ()\n+{\n+\n+  printf (\"/* Generated automatically by the program `genoutput'\\n\\\n+from the machine description file `md'.  */\\n\\n\");\n+\n+  printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include \\\"rtl.h\\\"\\n\");\n+  printf (\"#include \\\"regs.h\\\"\\n\");\n+  printf (\"#include \\\"hard-reg-set.h\\\"\\n\");\n+  printf (\"#include \\\"real.h\\\"\\n\");\n+  printf (\"#include \\\"insn-config.h\\\"\\n\\n\");\n+  printf (\"#include \\\"conditions.h\\\"\\n\");\n+  printf (\"#include \\\"insn-flags.h\\\"\\n\");\n+  printf (\"#include \\\"insn-attr.h\\\"\\n\\n\");\n+  printf (\"#include \\\"insn-codes.h\\\"\\n\\n\");\n+  printf (\"#include \\\"recog.h\\\"\\n\\n\");\n+\n+  printf (\"#include <stdio.h>\\n\");\n+  printf (\"#include \\\"output.h\\\"\\n\");\n+}\n+\n+static void\n+output_epilogue ()\n+{\n+  register struct data *d;\n+\n+  printf (\"\\nchar * const insn_template[] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    {\n+      if (d->template)\n+\tprintf (\"    \\\"%s\\\",\\n\", d->template);\n+      else\n+\tprintf (\"    0,\\n\");\n+    }\n+  printf (\"  };\\n\");\n+\n+  printf (\"\\nchar *(*const insn_outfun[])() =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    {\n+      if (d->outfun)\n+\tprintf (\"    output_%d,\\n\", d->code_number);\n+      else\n+\tprintf (\"    0,\\n\");\n+    }\n+  printf (\"  };\\n\");\n+\n+  printf (\"\\nrtx (*const insn_gen_function[]) () =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    {\n+      if (d->name)\n+\tprintf (\"    gen_%s,\\n\", d->name);\n+      else\n+\tprintf (\"    0,\\n\");\n+    }\n+  printf (\"  };\\n\");\n+\n+  printf (\"\\nchar *insn_name[] =\\n  {\\n\");\n+  {\n+    int offset = 0;\n+    int next;\n+    char * last_name = 0;\n+    char * next_name;\n+    register struct data *n;\n+\n+    for (n = insn_data, next = 0; n; n = n->next, next++)\n+      if (n->name)\n+\t{\n+\t  next_name = n->name;\n+\t  break;\n+\t}\n+\n+    for (d = insn_data; d; d = d->next)\n+      {\n+\tif (d->name)\n+\t  {\n+\t    printf (\"    \\\"%s\\\",\\n\", d->name);\n+\t    offset = 0;\n+\t    last_name = d->name;\n+\t    next_name = 0;\n+\t    for (n = d->next, next = 1; n; n = n->next, next++)\n+\t      if (n->name)\n+\t\t{\n+\t\t  next_name = n->name;\n+\t\t  break;\n+\t\t}\n+\t  }\n+\telse\n+\t  {\n+\t    offset++;\n+\t    if (next_name && (last_name == 0 || offset > next / 2))\n+\t      printf (\"    \\\"%s-%d\\\",\\n\", next_name, next - offset);\n+\t    else\n+\t      printf (\"    \\\"%s+%d\\\",\\n\", last_name, offset);\n+\t  }\n+      }\n+  }\n+  printf (\"  };\\n\");\n+  printf (\"char **insn_name_ptr = insn_name;\\n\");\n+\n+  printf (\"\\nconst int insn_n_operands[] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    printf (\"    %d,\\n\", d->n_operands);\n+  printf (\"  };\\n\");\n+\n+  printf (\"\\nconst int insn_n_dups[] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    printf (\"    %d,\\n\", d->n_dups);\n+  printf (\"  };\\n\");\n+\n+  if (have_constraints)\n+    {\n+      printf (\"\\nchar *const insn_operand_constraint[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n+      for (d = insn_data; d; d = d->next)\n+\t{\n+\t  register int i;\n+\t  printf (\"    {\");\n+\t  for (i = 0; i < d->n_operands; i++)\n+\t    {\n+\t      if (d->constraints[i] == 0)\n+\t\tprintf (\" \\\"\\\",\");\n+\t      else\n+\t\tprintf (\" \\\"%s\\\",\", d->constraints[i]);\n+\t    }\n+\t  if (d->n_operands == 0)\n+\t    printf (\" 0\");\n+\t  printf (\" },\\n\");\n+\t}\n+      printf (\"  };\\n\");\n+    }\n+  else\n+    {\n+      printf (\"\\nconst char insn_operand_address_p[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n+      for (d = insn_data; d; d = d->next)\n+\t{\n+\t  register int i;\n+\t  printf (\"    {\");\n+\t  for (i = 0; i < d->n_operands; i++)\n+\t    printf (\" %d,\", d->address_p[i]);\n+\t  if (d->n_operands == 0)\n+\t    printf (\" 0\");\n+\t  printf (\" },\\n\");\n+\t}\n+      printf (\"  };\\n\");\n+    }\n+\n+  printf (\"\\nconst enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    {\n+      register int i;\n+      printf (\"    {\");\n+      for (i = 0; i < d->n_operands; i++)\n+\tprintf (\" %smode,\", GET_MODE_NAME (d->modes[i]));\n+      if (d->n_operands == 0)\n+\tprintf (\" VOIDmode\");\n+      printf (\" },\\n\");\n+    }\n+  printf (\"  };\\n\");\n+\n+  printf (\"\\nconst char insn_operand_strict_low[][MAX_RECOG_OPERANDS] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    {\n+      register int i;\n+      printf (\"    {\");\n+      for (i = 0; i < d->n_operands; i++)\n+\tprintf (\" %d,\", d->strict_low[i]);\n+      if (d->n_operands == 0)\n+\tprintf (\" 0\");\n+      printf (\" },\\n\");\n+    }\n+  printf (\"  };\\n\");\n+\n+  {\n+    /* We need to define all predicates used.  Keep a list of those we\n+       have defined so far.  There normally aren't very many predicates used,\n+       so a linked list should be fast enough.  */\n+    struct predicate { char *name; struct predicate *next; } *predicates = 0;\n+    struct predicate *p;\n+    int i;\n+\n+    printf (\"\\n\");\n+    for (d = insn_data; d; d = d->next)\n+      for (i = 0; i < d->n_operands; i++)\n+\tif (d->predicates[i] && d->predicates[i][0])\n+\t  {\n+\t    for (p = predicates; p; p = p->next)\n+\t      if (! strcmp (p->name, d->predicates[i]))\n+\t\tbreak;\n+\n+\t    if (p == 0)\n+\t      {\n+\t\tprintf (\"extern int %s ();\\n\", d->predicates[i]);\n+\t\tp = (struct predicate *) alloca (sizeof (struct predicate));\n+\t\tp->name = d->predicates[i];\n+\t\tp->next = predicates;\n+\t\tpredicates = p;\n+\t      }\n+\t  }\n+    \n+    printf (\"\\nint (*const insn_operand_predicate[][MAX_RECOG_OPERANDS])() =\\n  {\\n\");\n+    for (d = insn_data; d; d = d->next)\n+      {\n+\tprintf (\"    {\");\n+\tfor (i = 0; i < d->n_operands; i++)\n+\t  printf (\" %s,\", ((d->predicates[i] && d->predicates[i][0])\n+\t\t\t   ? d->predicates[i] : \"0\"));\n+\tif (d->n_operands == 0)\n+\t  printf (\" 0\");\n+\tprintf (\" },\\n\");\n+      }\n+    printf (\"  };\\n\");\n+  }\n+\n+  printf (\"\\nconst int insn_n_alternatives[] =\\n  {\\n\");\n+  for (d = insn_data; d; d = d->next)\n+    printf (\"    %d,\\n\", d->n_alternatives);\n+  printf(\"  };\\n\");\n+}\n+\f\n+/* scan_operands (X) stores in max_opno the largest operand\n+   number present in X, if that is larger than the previous\n+   value of max_opno.  It stores all the constraints in `constraints'\n+   and all the machine modes in `modes'.\n+\n+   THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.\n+   THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */\n+\n+static int max_opno;\n+static int num_dups;\n+static char *constraints[MAX_MAX_OPERANDS];\n+static int op_n_alternatives[MAX_MAX_OPERANDS];\n+static char *predicates[MAX_MAX_OPERANDS];\n+static char address_p[MAX_MAX_OPERANDS];\n+static enum machine_mode modes[MAX_MAX_OPERANDS];\n+static char strict_low[MAX_MAX_OPERANDS];\n+\n+static void\n+scan_operands (part, this_address_p, this_strict_low)\n+     rtx part;\n+     int this_address_p;\n+     int this_strict_low;\n+{\n+  register int i, j;\n+  register char *format_ptr;\n+  int opno;\n+\n+  if (part == 0)\n+    return;\n+\n+  switch (GET_CODE (part))\n+    {\n+    case MATCH_OPERAND:\n+      opno = XINT (part, 0);\n+      if (opno > max_opno)\n+\tmax_opno = opno;\n+      if (max_opno >= MAX_MAX_OPERANDS)\n+\terror (\"Too many operands (%d) in one instruction pattern.\\n\",\n+\t       max_opno + 1);\n+      modes[opno] = GET_MODE (part);\n+      strict_low[opno] = this_strict_low;\n+      predicates[opno] = XSTR (part, 1);\n+      constraints[opno] = XSTR (part, 2);\n+      if (XSTR (part, 2) != 0 && *XSTR (part, 2) != 0)\n+\t{\n+\t  op_n_alternatives[opno] = n_occurrences (',', XSTR (part, 2)) + 1;\n+\t  have_constraints = 1;\n+\t}\n+      address_p[opno] = this_address_p;\n+      return;\n+\n+    case MATCH_SCRATCH:\n+      opno = XINT (part, 0);\n+      if (opno > max_opno)\n+\tmax_opno = opno;\n+      if (max_opno >= MAX_MAX_OPERANDS)\n+\terror (\"Too many operands (%d) in one instruction pattern.\\n\",\n+\t       max_opno + 1);\n+      modes[opno] = GET_MODE (part);\n+      strict_low[opno] = 0;\n+      predicates[opno] = \"scratch_operand\";\n+      constraints[opno] = XSTR (part, 1);\n+      if (XSTR (part, 1) != 0 && *XSTR (part, 1) != 0)\n+\t{\n+\t  op_n_alternatives[opno] = n_occurrences (',', XSTR (part, 1)) + 1;\n+\t  have_constraints = 1;\n+\t}\n+      address_p[opno] = 0;\n+      return;\n+\n+    case MATCH_OPERATOR:\n+    case MATCH_PARALLEL:\n+      opno = XINT (part, 0);\n+      if (opno > max_opno)\n+\tmax_opno = opno;\n+      if (max_opno >= MAX_MAX_OPERANDS)\n+\terror (\"Too many operands (%d) in one instruction pattern.\\n\",\n+\t       max_opno + 1);\n+      modes[opno] = GET_MODE (part);\n+      strict_low[opno] = 0;\n+      predicates[opno] = XSTR (part, 1);\n+      constraints[opno] = 0;\n+      address_p[opno] = 0;\n+      for (i = 0; i < XVECLEN (part, 2); i++)\n+\tscan_operands (XVECEXP (part, 2, i), 0, 0);\n+      return;\n+\n+    case MATCH_DUP:\n+    case MATCH_OP_DUP:\n+      ++num_dups;\n+      return;\n+\n+    case ADDRESS:\n+      scan_operands (XEXP (part, 0), 1, 0);\n+      return;\n+\n+    case STRICT_LOW_PART:\n+      scan_operands (XEXP (part, 0), 0, 1);\n+      return;\n+    }\n+\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (part));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (part)); i++)\n+    switch (*format_ptr++)\n+      {\n+      case 'e':\n+\tscan_operands (XEXP (part, i), 0, 0);\n+\tbreak;\n+      case 'E':\n+\tif (XVEC (part, i) != NULL)\n+\t  for (j = 0; j < XVECLEN (part, i); j++)\n+\t    scan_operands (XVECEXP (part, i, j), 0, 0);\n+\tbreak;\n+      }\n+}\n+\f\n+/* Process an assembler template from a define_insn or a define_peephole.\n+   It is either the assembler code template, a list of assembler code\n+   templates, or C code to generate the assembler code template.  */\n+\n+static void\n+process_template (d, template)\n+    struct data *d;\n+    char *template;\n+{\n+  register char *cp;\n+  register int i;\n+\n+  /* We need to consider only the instructions whose assembler code template\n+     starts with a * or @.  These are the ones where C code is run to decide\n+     on a template to use.  So for all others just return now.  */\n+\n+  if (template[0] != '*' && template[0] != '@')\n+    {\n+      d->template = template;\n+      d->outfun = 0;\n+      return;\n+    }\n+\n+  d->template = 0;\n+  d->outfun = 1;\n+\n+  printf (\"\\nstatic char *\\n\");\n+  printf (\"output_%d (operands, insn)\\n\", d->code_number);\n+  printf (\"     rtx *operands;\\n\");\n+  printf (\"     rtx insn;\\n\");\n+  printf (\"{\\n\");\n+\n+  /* If the assembler code template starts with a @ it is a newline-separated\n+     list of assembler code templates, one for each alternative.  So produce\n+     a routine to select the correct one.  */\n+\n+  if (template[0] == '@')\n+    {\n+\n+      printf (\"  static /*const*/ char *const strings_%d[] = {\\n\",\n+\t      d->code_number);\n+\n+      for (i = 0, cp = &template[1]; *cp; )\n+\t{\n+\t  while (*cp == '\\n' || *cp == ' ' || *cp== '\\t')\n+\t    cp++;\n+\n+\t  printf (\"    \\\"\");\n+\t  while (*cp != '\\n' && *cp != '\\0')\n+\t    putchar (*cp++);\n+\n+\t  printf (\"\\\",\\n\");\n+\t  i++;\n+\t}\n+\n+      printf (\"  };\\n\");\n+      printf (\"  return strings_%d[which_alternative];\\n\", d->code_number);\n+\n+      if (i != d->n_alternatives)\n+\tfatal (\"Insn pattern %d has %d alternatives but %d assembler choices\",\n+\t       d->index_number, d->n_alternatives, i);\n+\n+    }\n+  else\n+    {\n+       /* The following is done in a funny way to get around problems in\n+\t  VAX-11 \"C\" on VMS.  It is the equivalent of:\n+\t\tprintf (\"%s\\n\", &template[1])); */\n+      cp = &template[1];\n+      while (*cp) putchar (*cp++);\n+      putchar ('\\n');\n+    }\n+\n+  printf (\"}\\n\");\n+}\n+\f\n+/* Check insn D for consistency in number of constraint alternatives.  */\n+\n+static void\n+validate_insn_alternatives (d)\n+     struct data *d;\n+{\n+  register int n = 0, start;\n+  /* Make sure all the operands have the same number of\n+     alternatives in their constraints.\n+     Let N be that number.  */\n+  for (start = 0; start < d->n_operands; start++)\n+    if (d->op_n_alternatives[start] > 0)\n+      {\n+\tif (n == 0)\n+\t  n = d->op_n_alternatives[start];\n+\telse if (n != d->op_n_alternatives[start])\n+\t  error (\"wrong number of alternatives in operand %d of insn number %d\",\n+\t\t start, d->index_number);\n+      }\n+  /* Record the insn's overall number of alternatives.  */\n+  d->n_alternatives = n;\n+}\n+\f\n+/* Look at a define_insn just read.  Assign its code number.\n+   Record on insn_data the template and the number of arguments.\n+   If the insn has a hairy output action, output a function for now.  */\n+\n+static void\n+gen_insn (insn)\n+     rtx insn;\n+{\n+  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  register int i;\n+\n+  d->code_number = next_code_number++;\n+  d->index_number = next_index_number;\n+  if (XSTR (insn, 0)[0])\n+    d->name = XSTR (insn, 0);\n+  else\n+    d->name = 0;\n+\n+  /* Build up the list in the same order as the insns are seen\n+     in the machine description.  */\n+  d->next = 0;\n+  if (end_of_insn_data)\n+    end_of_insn_data->next = d;\n+  else\n+    insn_data = d;\n+\n+  end_of_insn_data = d;\n+\n+  max_opno = -1;\n+  num_dups = 0;\n+\n+  mybzero (constraints, sizeof constraints);\n+  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n+  mybzero (predicates, sizeof predicates);\n+  mybzero (address_p, sizeof address_p);\n+  mybzero (modes, sizeof modes);\n+  mybzero (strict_low, sizeof strict_low);\n+\n+  for (i = 0; i < XVECLEN (insn, 1); i++)\n+    scan_operands (XVECEXP (insn, 1, i), 0, 0);\n+\n+  d->n_operands = max_opno + 1;\n+  d->n_dups = num_dups;\n+\n+  mybcopy (constraints, d->constraints, sizeof constraints);\n+  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n+  mybcopy (predicates, d->predicates, sizeof predicates);\n+  mybcopy (address_p, d->address_p, sizeof address_p);\n+  mybcopy (modes, d->modes, sizeof modes);\n+  mybcopy (strict_low, d->strict_low, sizeof strict_low);\n+\n+  validate_insn_alternatives (d);\n+  process_template (d, XSTR (insn, 3));\n+}\n+\f\n+/* Look at a define_peephole just read.  Assign its code number.\n+   Record on insn_data the template and the number of arguments.\n+   If the insn has a hairy output action, output it now.  */\n+\n+static void\n+gen_peephole (peep)\n+     rtx peep;\n+{\n+  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  register int i;\n+\n+  d->code_number = next_code_number++;\n+  d->index_number = next_index_number;\n+  d->name = 0;\n+\n+  /* Build up the list in the same order as the insns are seen\n+     in the machine description.  */\n+  d->next = 0;\n+  if (end_of_insn_data)\n+    end_of_insn_data->next = d;\n+  else\n+    insn_data = d;\n+\n+  end_of_insn_data = d;\n+\n+  max_opno = -1;\n+  mybzero (constraints, sizeof constraints);\n+  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n+\n+  /* Get the number of operands by scanning all the\n+     patterns of the peephole optimizer.\n+     But ignore all the rest of the information thus obtained.  */\n+  for (i = 0; i < XVECLEN (peep, 0); i++)\n+    scan_operands (XVECEXP (peep, 0, i), 0, 0);\n+\n+  d->n_operands = max_opno + 1;\n+  d->n_dups = 0;\n+\n+  mybcopy (constraints, d->constraints, sizeof constraints);\n+  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n+  mybzero (d->predicates, sizeof predicates);\n+  mybzero (d->address_p, sizeof address_p);\n+  mybzero (d->modes, sizeof modes);\n+  mybzero (d->strict_low, sizeof strict_low);\n+\n+  validate_insn_alternatives (d);\n+  process_template (d, XSTR (peep, 2));\n+}\n+\f\n+/* Process a define_expand just read.  Assign its code number,\n+   only for the purposes of `insn_gen_function'.  */\n+\n+static void\n+gen_expand (insn)\n+     rtx insn;\n+{\n+  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  register int i;\n+\n+  d->code_number = next_code_number++;\n+  d->index_number = next_index_number;\n+  if (XSTR (insn, 0)[0])\n+    d->name = XSTR (insn, 0);\n+  else\n+    d->name = 0;\n+\n+  /* Build up the list in the same order as the insns are seen\n+     in the machine description.  */\n+  d->next = 0;\n+  if (end_of_insn_data)\n+    end_of_insn_data->next = d;\n+  else\n+    insn_data = d;\n+\n+  end_of_insn_data = d;\n+\n+  max_opno = -1;\n+  num_dups = 0;\n+\n+  /* Scan the operands to get the specified predicates and modes,\n+     since expand_binop needs to know them.  */\n+\n+  mybzero (constraints, sizeof constraints);\n+  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n+  mybzero (predicates, sizeof predicates);\n+  mybzero (address_p, sizeof address_p);\n+  mybzero (modes, sizeof modes);\n+  mybzero (strict_low, sizeof strict_low);\n+\n+  if (XVEC (insn, 1))\n+    for (i = 0; i < XVECLEN (insn, 1); i++)\n+      scan_operands (XVECEXP (insn, 1, i), 0, 0);\n+\n+  d->n_operands = max_opno + 1;\n+  d->n_dups = num_dups;\n+\n+  mybcopy (constraints, d->constraints, sizeof constraints);\n+  mybcopy (op_n_alternatives, d->op_n_alternatives, sizeof op_n_alternatives);\n+  mybcopy (predicates, d->predicates, sizeof predicates);\n+  mybcopy (address_p, d->address_p, sizeof address_p);\n+  mybcopy (modes, d->modes, sizeof modes);\n+  mybcopy (strict_low, d->strict_low, sizeof strict_low);\n+\n+  d->template = 0;\n+  d->outfun = 0;\n+  validate_insn_alternatives (d);\n+}\n+\f\n+/* Process a define_split just read.  Assign its code number,\n+   only for reasons of consistency and to simplify genrecog.  */\n+\n+\n+static void\n+gen_split (split)\n+     rtx split;\n+{\n+  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  register int i;\n+\n+  d->code_number = next_code_number++;\n+  d->index_number = next_index_number;\n+  d->name = 0;\n+\n+  /* Build up the list in the same order as the insns are seen\n+     in the machine description.  */\n+  d->next = 0;\n+  if (end_of_insn_data)\n+    end_of_insn_data->next = d;\n+  else\n+    insn_data = d;\n+\n+  end_of_insn_data = d;\n+\n+  max_opno = -1;\n+  num_dups = 0;\n+\n+  mybzero (constraints, sizeof constraints);\n+  mybzero (op_n_alternatives, sizeof op_n_alternatives);\n+\n+  /* Get the number of operands by scanning all the\n+     patterns of the split patterns.\n+     But ignore all the rest of the information thus obtained.  */\n+  for (i = 0; i < XVECLEN (split, 0); i++)\n+    scan_operands (XVECEXP (split, 0, i), 0, 0);\n+\n+  d->n_operands = max_opno + 1;\n+\n+  mybzero (d->constraints, sizeof constraints);\n+  mybzero (d->op_n_alternatives, sizeof op_n_alternatives);\n+  mybzero (d->predicates, sizeof predicates);\n+  mybzero (d->address_p, sizeof address_p);\n+  mybzero (d->modes, sizeof modes);\n+  mybzero (d->strict_low, sizeof strict_low);\n+\n+  d->n_dups = 0;\n+  d->template = 0;\n+  d->outfun = 0;\n+}\n+\f\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *val = (char *) malloc (size);\n+\n+  if (val == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return val;\n+}\n+\n+char *\n+xrealloc (ptr, size)\n+     char *ptr;\n+     unsigned size;\n+{\n+  char *result = (char *) realloc (ptr, size);\n+  if (!result)\n+    fatal (\"virtual memory exhausted\");\n+  return result;\n+}\n+\n+static void\n+mybzero (b, length)\n+     register char *b;\n+     register unsigned length;\n+{\n+  while (length-- > 0)\n+    *b++ = 0;\n+}\n+\n+static void\n+mybcopy (b1, b2, length)\n+     register char *b1;\n+     register char *b2;\n+     register unsigned length;\n+{\n+  while (length-- > 0)\n+    *b2++ = *b1++;\n+}\n+\n+static void\n+fatal (s, a1, a2, a3, a4)\n+     char *s;\n+{\n+  fprintf (stderr, \"genoutput: \");\n+  fprintf (stderr, s, a1, a2, a3, a4);\n+  fprintf (stderr, \"\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"Internal gcc abort.\");\n+}\n+\n+static void\n+error (s, a1, a2)\n+     char *s;\n+{\n+  fprintf (stderr, \"genoutput: \");\n+  fprintf (stderr, s, a1, a2);\n+  fprintf (stderr, \"\\n\");\n+}\n+\f\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  rtx desc;\n+  FILE *infile;\n+  extern rtx read_rtx ();\n+  register int c;\n+\n+  obstack_init (rtl_obstack);\n+\n+  if (argc <= 1)\n+    fatal (\"No input file name.\");\n+\n+  infile = fopen (argv[1], \"r\");\n+  if (infile == 0)\n+    {\n+      perror (argv[1]);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+\n+  init_rtl ();\n+\n+  output_prologue ();\n+  next_code_number = 0;\n+  next_index_number = 0;\n+  have_constraints = 0;\n+\n+  /* Read the machine description.  */\n+\n+  while (1)\n+    {\n+      c = read_skip_spaces (infile);\n+      if (c == EOF)\n+\tbreak;\n+      ungetc (c, infile);\n+\n+      desc = read_rtx (infile);\n+      if (GET_CODE (desc) == DEFINE_INSN)\n+\tgen_insn (desc);\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+\tgen_peephole (desc);\n+      if (GET_CODE (desc) == DEFINE_EXPAND)\n+\tgen_expand (desc);\n+      if (GET_CODE (desc) == DEFINE_SPLIT)\n+\tgen_split (desc);\n+      next_index_number++;\n+    }\n+\n+  output_epilogue ();\n+\n+  fflush (stdout);\n+  exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+  /* NOTREACHED */\n+  return 0;\n+}\n+\n+static int\n+n_occurrences (c, s)\n+     char c;\n+     char *s;\n+{\n+  int n = 0;\n+  while (*s)\n+    n += (*s++ == c);\n+  return n;\n+}"}]}