{"sha": "104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA0Y2I1MGJkMTNjY2I4ZWQxOTM0ZWYzYThmOTBlYzllNGUxYzFkZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-04-17T13:53:59Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-04-17T13:53:59Z"}, "message": "gimple-iterator.c (gsi_start_edge): New function.\n\n2014-04-17  Martin Jambor  <mjambor@suse.cz>\n\n\t* gimple-iterator.c (gsi_start_edge): New function.\n\t* gimple-iterator.h (gsi_start_edge): Declare.\n\t* tree-sra.c (single_non_eh_succ): New function.\n\t(disqualify_ops_if_throwing_stmt): Renamed to\n\tdisqualify_if_bad_bb_terminating_stmt.  Allow throwing statements\n\thaving one non-EH successor BB.\n\t(sra_modify_expr): If stmt ends bb, use single non-EH successor to\n\tgenerate loads into replacements.\n\t(sra_modify_assign): Likewise and and also use the simple path for\n\tsuch statements.\n\t(sra_modify_function_body): Commit statements on edges.\n\ntestsuite/\n\t* gnat.dg/opt34.adb: New.\n\t* gnat.dg/opt34_pkg.ads: Likewise.\n\nFrom-SVN: r209487", "tree": {"sha": "b255138251190ed1adfba46943629741890a091d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b255138251190ed1adfba46943629741890a091d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b94970bc41f7b2c6ab28d52493f95efcf2fa97de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b94970bc41f7b2c6ab28d52493f95efcf2fa97de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b94970bc41f7b2c6ab28d52493f95efcf2fa97de"}], "stats": {"total": 138, "additions": 126, "deletions": 12}, "files": [{"sha": "a8a95e978a08769bbaa9e9277936b61b14825a1d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -1,3 +1,17 @@\n+2014-04-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gimple-iterator.c (gsi_start_edge): New function.\n+\t* gimple-iterator.h (gsi_start_edge): Declare.\n+\t* tree-sra.c (single_non_eh_succ): New function.\n+\t(disqualify_ops_if_throwing_stmt): Renamed to\n+\tdisqualify_if_bad_bb_terminating_stmt.  Allow throwing statements\n+\thaving one non-EH successor BB.\n+\t(sra_modify_expr): If stmt ends bb, use single non-EH successor to\n+\tgenerate loads into replacements.\n+\t(sra_modify_assign): Likewise and and also use the simple path for\n+\tsuch statements.\n+\t(sra_modify_function_body): Commit statements on edges.\n+\n 2014-04-17  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/60849"}, {"sha": "8a1ec53a765d1f5803b0a4f0c4113d125e9b2948", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -689,6 +689,15 @@ gsi_insert_seq_on_edge (edge e, gimple_seq seq)\n   gimple_seq_add_seq (&PENDING_STMT (e), seq);\n }\n \n+/* Return a new iterator pointing to the first statement in sequence of\n+   statements on edge E.  Such statements need to be subsequently moved into a\n+   basic block by calling gsi_commit_edge_inserts.  */\n+\n+gimple_stmt_iterator\n+gsi_start_edge (edge e)\n+{\n+  return gsi_start (PENDING_STMT (e));\n+}\n \n /* Insert the statement pointed-to by GSI into edge E.  Every attempt\n    is made to place the statement in an existing basic block, but"}, {"sha": "909d58be8927ffad1ae081647d31c7643056885e", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -123,6 +123,8 @@ gsi_start_bb (basic_block bb)\n   return i;\n }\n \n+gimple_stmt_iterator gsi_start_edge (edge e);\n+\n /* Return a new iterator initially pointing to GIMPLE_SEQ's last statement.  */\n \n static inline gimple_stmt_iterator"}, {"sha": "eb1ac11b5f139fca65ba67b1f1c7a10b2711db8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -1,3 +1,8 @@\n+2014-04-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gnat.dg/opt34.adb: New.\n+\t* gnat.dg/opt34_pkg.ads: Likewise.\n+\n 2014-04-17  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* g++.dg/plugin/dumb_plugin.c, g++.dg/plugin/selfasign.c,"}, {"sha": "a5d0ab6319f095e60d6ca4e1ec2adc5ddc9347d1", "filename": "gcc/testsuite/gnat.dg/opt34.adb", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34.adb?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -0,0 +1,29 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O -fdump-tree-esra\" }\n+\n+with Opt34_Pkg; use Opt34_Pkg;\n+\n+procedure Opt34 is\n+\n+   function Local_Fun (Arg : T_Private) return T_Private is\n+      Result : T_Private;\n+   begin\n+\n+      case Get_Integer (Arg) is\n+         when 1 =>\n+            Result := Get_Private (100);\n+         when 2 =>\n+            Result := T_Private_Zero;\n+         when others =>\n+            null;\n+      end case;\n+\n+      return Result;\n+   end Local_Fun;\n+\n+begin\n+   Assert (Get_Integer (Local_Fun (Get_Private (1))) = 100);\n+end;\n+\n+-- { dg-final { scan-tree-dump \"Created a replacement for result\" \"esra\" } }\n+-- { dg-final { cleanup-tree-dump \"esra\" } }"}, {"sha": "83ecb493ef4ff243071cd652495b94c64c56a6b5", "filename": "gcc/testsuite/gnat.dg/opt34_pkg.ads", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt34_pkg.ads?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -0,0 +1,14 @@\n+package Opt34_Pkg is\n+\n+   type T_Private is record\n+      I : Integer := 0;\n+   end record;\n+\n+   T_Private_Zero : constant T_Private := (I => 0);\n+\n+   function Get_Private (I : Integer) return T_Private;\n+   function Get_Integer (X : T_Private) return Integer;\n+\n+   procedure Assert (Cond : Boolean);\n+\n+end Opt34_Pkg;"}, {"sha": "49bbee3deb762e609c29fb521f0e701f18282b0e", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=104cb50bd13ccb8ed1934ef3a8f90ec9e4e1c1de", "patch": "@@ -1142,17 +1142,41 @@ build_access_from_expr (tree expr, gimple stmt, bool write)\n   return false;\n }\n \n-/* Disqualify LHS and RHS for scalarization if STMT must end its basic block in\n-   modes in which it matters, return true iff they have been disqualified.  RHS\n-   may be NULL, in that case ignore it.  If we scalarize an aggregate in\n-   intra-SRA we may need to add statements after each statement.  This is not\n-   possible if a statement unconditionally has to end the basic block.  */\n+/* Return the single non-EH successor edge of BB or NULL if there is none or\n+   more than one.  */\n+\n+static edge\n+single_non_eh_succ (basic_block bb)\n+{\n+  edge e, res = NULL;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_EH))\n+      {\n+\tif (res)\n+\t  return NULL;\n+\tres = e;\n+      }\n+\n+  return res;\n+}\n+\n+/* Disqualify LHS and RHS for scalarization if STMT has to terminate its BB and\n+   there is no alternative spot where to put statements SRA might need to\n+   generate after it.  The spot we are looking for is an edge leading to a\n+   single non-EH successor, if it exists and is indeed single.  RHS may be\n+   NULL, in that case ignore it.  */\n+\n static bool\n-disqualify_ops_if_throwing_stmt (gimple stmt, tree lhs, tree rhs)\n+disqualify_if_bad_bb_terminating_stmt (gimple stmt, tree lhs, tree rhs)\n {\n   if ((sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n-      && (stmt_can_throw_internal (stmt) || stmt_ends_bb_p (stmt)))\n+      && stmt_ends_bb_p (stmt))\n     {\n+      if (single_non_eh_succ (gimple_bb (stmt)))\n+\treturn false;\n+\n       disqualify_base_of_expr (lhs, \"LHS of a throwing stmt.\");\n       if (rhs)\n \tdisqualify_base_of_expr (rhs, \"RHS of a throwing stmt.\");\n@@ -1180,7 +1204,7 @@ build_accesses_from_assign (gimple stmt)\n   lhs = gimple_assign_lhs (stmt);\n   rhs = gimple_assign_rhs1 (stmt);\n \n-  if (disqualify_ops_if_throwing_stmt (stmt, lhs, rhs))\n+  if (disqualify_if_bad_bb_terminating_stmt (stmt, lhs, rhs))\n     return false;\n \n   racc = build_access_from_expr_1 (rhs, stmt, false);\n@@ -1319,7 +1343,7 @@ scan_function (void)\n \t\t}\n \n \t      t = gimple_call_lhs (stmt);\n-\t      if (t && !disqualify_ops_if_throwing_stmt (stmt, t, NULL))\n+\t      if (t && !disqualify_if_bad_bb_terminating_stmt (stmt, t, NULL))\n \t\tret |= build_access_from_expr (t, stmt, true);\n \t      break;\n \n@@ -2763,6 +2787,13 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n   type = TREE_TYPE (*expr);\n \n   loc = gimple_location (gsi_stmt (*gsi));\n+  gimple_stmt_iterator alt_gsi = gsi_none ();\n+  if (write && stmt_ends_bb_p (gsi_stmt (*gsi)))\n+    {\n+      alt_gsi = gsi_start_edge (single_non_eh_succ (gsi_bb (*gsi)));\n+      gsi = &alt_gsi;\n+    }\n+\n   if (access->grp_to_be_replaced)\n     {\n       tree repl = get_access_replacement (access);\n@@ -3226,14 +3257,23 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n   if (modify_this_stmt\n       || gimple_has_volatile_ops (*stmt)\n       || contains_vce_or_bfcref_p (rhs)\n-      || contains_vce_or_bfcref_p (lhs))\n+      || contains_vce_or_bfcref_p (lhs)\n+      || stmt_ends_bb_p (*stmt))\n     {\n       if (access_has_children_p (racc))\n \tgenerate_subtree_copies (racc->first_child, racc->base, 0, 0, 0,\n \t\t\t\t gsi, false, false, loc);\n       if (access_has_children_p (lacc))\n-\tgenerate_subtree_copies (lacc->first_child, lacc->base, 0, 0, 0,\n-\t\t\t\t gsi, true, true, loc);\n+\t{\n+\t  gimple_stmt_iterator alt_gsi = gsi_none ();\n+\t  if (stmt_ends_bb_p (*stmt))\n+\t    {\n+\t      alt_gsi = gsi_start_edge (single_non_eh_succ (gsi_bb (*gsi)));\n+\t      gsi = &alt_gsi;\n+\t    }\n+\t  generate_subtree_copies (lacc->first_child, lacc->base, 0, 0, 0,\n+\t\t\t\t   gsi, true, true, loc);\n+\t}\n       sra_stats.separate_lhs_rhs_handling++;\n \n       /* This gimplification must be done after generate_subtree_copies,\n@@ -3397,6 +3437,7 @@ sra_modify_function_body (void)\n \t}\n     }\n \n+  gsi_commit_edge_inserts ();\n   return cfg_changed;\n }\n "}]}