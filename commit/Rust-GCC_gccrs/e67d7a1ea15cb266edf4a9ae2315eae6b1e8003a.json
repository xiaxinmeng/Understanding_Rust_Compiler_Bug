{"sha": "e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3ZDdhMWVhMTVjYjI2NmVkZjRhOWFlMjMxNWVhZTZiMWU4MDAzYQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-07-31T06:26:44Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-07-31T06:26:44Z"}, "message": "Don't cancel loop tree in parloops\n\n2015-07-31  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/66846\n\t* omp-low.c (expand_omp_taskreg) [ENABLE_CHECKING]: Call\n\tverify_loop_structure for child_cfun if !LOOPS_NEED_FIXUP.\n\t(expand_omp_target) [ENABLE_CHECKING]: Same.\n\t(execute_expand_omp) [ENABLE_CHECKING]: Call verify_loop_structure for\n\tcfun if !LOOPS_NEED_FIXUP.\n\t(expand_omp_for_static_nochunk): Handle simple latch bb.  Handle case\n\tthat omp_for already has its own loop struct.\n\t* tree-parloops.c (create_phi_for_local_result)\n\t(create_call_for_reduction): Handle simple latch bb.\n\t(create_parallel_loop): Add simple latch bb to preserve\n\tLOOPS_HAVE_SIMPLE_LATCHES.  Record new exit.  Handle simple latch bb.\n\t(gen_parallel_loop): Remove call to cancel_loop_tree.\n\t(parallelize_loops): Skip loops that are inner loops of parallelized\n\tloops.\n\t(pass_parallelize_loops::execute) [ENABLE_CHECKING]: Call\n\tverify_loop_structure.\n\nFrom-SVN: r226427", "tree": {"sha": "d4527665684a78ac3e0d04736f8b19c537ed23a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4527665684a78ac3e0d04736f8b19c537ed23a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/comments", "author": null, "committer": null, "parents": [{"sha": "048e62c34ae4af6d84c2a95649caf6ca584ab71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048e62c34ae4af6d84c2a95649caf6ca584ab71d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048e62c34ae4af6d84c2a95649caf6ca584ab71d"}], "stats": {"total": 101, "additions": 86, "deletions": 15}, "files": [{"sha": "831aba8f865afeb340bdffe4c2d7fb71b77cd68f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "patch": "@@ -1,3 +1,23 @@\n+2015-07-31  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/66846\n+\t* omp-low.c (expand_omp_taskreg) [ENABLE_CHECKING]: Call\n+\tverify_loop_structure for child_cfun if !LOOPS_NEED_FIXUP.\n+\t(expand_omp_target) [ENABLE_CHECKING]: Same.\n+\t(execute_expand_omp) [ENABLE_CHECKING]: Call verify_loop_structure for\n+\tcfun if !LOOPS_NEED_FIXUP.\n+\t(expand_omp_for_static_nochunk): Handle simple latch bb.  Handle case\n+\tthat omp_for already has its own loop struct.\n+\t* tree-parloops.c (create_phi_for_local_result)\n+\t(create_call_for_reduction): Handle simple latch bb.\n+\t(create_parallel_loop): Add simple latch bb to preserve\n+\tLOOPS_HAVE_SIMPLE_LATCHES.  Record new exit.  Handle simple latch bb.\n+\t(gen_parallel_loop): Remove call to cancel_loop_tree.\n+\t(parallelize_loops): Skip loops that are inner loops of parallelized\n+\tloops.\n+\t(pass_parallelize_loops::execute) [ENABLE_CHECKING]: Call\n+\tverify_loop_structure.\n+\n 2015-07-30  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/v850/v850.h (LIBCALL_VALUE): Remove macros."}, {"sha": "0f5c0f1521523fa53253dc58bdedaf39c5ed705c", "filename": "gcc/omp-low.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "patch": "@@ -5604,6 +5604,10 @@ expand_omp_taskreg (struct omp_region *region)\n \t}\n       if (gimple_in_ssa_p (cfun))\n \tupdate_ssa (TODO_update_ssa);\n+#ifdef ENABLE_CHECKING\n+      if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+\tverify_loop_structure ();\n+#endif\n       pop_cfun ();\n     }\n \n@@ -6535,7 +6539,8 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   body_bb = single_succ (seq_start_bb);\n   if (!broken_loop)\n     {\n-      gcc_assert (BRANCH_EDGE (cont_bb)->dest == body_bb);\n+      gcc_assert (BRANCH_EDGE (cont_bb)->dest == body_bb\n+\t\t  || single_succ (BRANCH_EDGE (cont_bb)->dest) == body_bb);\n       gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n     }\n   exit_bb = region->exit;\n@@ -6818,6 +6823,11 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (!broken_loop)\n     {\n       ep = find_edge (cont_bb, body_bb);\n+      if (ep == NULL)\n+\t{\n+\t  ep = BRANCH_EDGE (cont_bb);\n+\t  gcc_assert (single_succ (ep->dest) == body_bb);\n+\t}\n       if (gimple_omp_for_combined_p (fd->for_stmt))\n \t{\n \t  remove_edge (ep);\n@@ -6843,9 +6853,19 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   set_immediate_dominator (CDI_DOMINATORS, fin_bb,\n \t\t\t   recompute_dominator (CDI_DOMINATORS, fin_bb));\n \n+  struct loop *loop = body_bb->loop_father;\n+  if (loop != entry_bb->loop_father)\n+    {\n+      gcc_assert (loop->header == body_bb);\n+      gcc_assert (broken_loop\n+\t\t  || loop->latch == region->cont\n+\t\t  || single_pred (loop->latch) == region->cont);\n+      return;\n+    }\n+\n   if (!broken_loop && !gimple_omp_for_combined_p (fd->for_stmt))\n     {\n-      struct loop *loop = alloc_loop ();\n+      loop = alloc_loop ();\n       loop->header = body_bb;\n       if (collapse_bb == NULL)\n \tloop->latch = cont_bb;\n@@ -8984,6 +9004,10 @@ expand_omp_target (struct omp_region *region)\n \t  if (changed)\n \t    cleanup_tree_cfg ();\n \t}\n+#ifdef ENABLE_CHECKING\n+      if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+\tverify_loop_structure ();\n+#endif\n       pop_cfun ();\n     }\n \n@@ -9492,6 +9516,10 @@ execute_expand_omp (void)\n \n   expand_omp (root_omp_region);\n \n+#ifdef ENABLE_CHECKING\n+  if (!loops_state_satisfies_p (LOOPS_NEED_FIXUP))\n+    verify_loop_structure ();\n+#endif\n   cleanup_tree_cfg ();\n \n   free_omp_regions ();"}, {"sha": "d017479ec2e2d83a8827cb00bdb86eb938ff4648", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=e67d7a1ea15cb266edf4a9ae2315eae6b1e8003a", "patch": "@@ -1032,21 +1032,22 @@ create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n   struct reduction_info *const reduc = *slot;\n   edge e;\n   gphi *new_phi;\n-  basic_block store_bb;\n+  basic_block store_bb, continue_bb;\n   tree local_res;\n   source_location locus;\n \n   /* STORE_BB is the block where the phi\n      should be stored.  It is the destination of the loop exit.\n      (Find the fallthru edge from GIMPLE_OMP_CONTINUE).  */\n-  store_bb = FALLTHRU_EDGE (loop->latch)->dest;\n+  continue_bb = single_pred (loop->latch);\n+  store_bb = FALLTHRU_EDGE (continue_bb)->dest;\n \n   /* STORE_BB has two predecessors.  One coming from  the loop\n      (the reduction's result is computed at the loop),\n      and another coming from a block preceding the loop,\n      when no iterations\n      are executed (the initial value should be taken).  */\n-  if (EDGE_PRED (store_bb, 0) == FALLTHRU_EDGE (loop->latch))\n+  if (EDGE_PRED (store_bb, 0) == FALLTHRU_EDGE (continue_bb))\n     e = EDGE_PRED (store_bb, 1);\n   else\n     e = EDGE_PRED (store_bb, 0);\n@@ -1055,7 +1056,7 @@ create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n   locus = gimple_location (reduc->reduc_stmt);\n   new_phi = create_phi_node (local_res, store_bb);\n   add_phi_arg (new_phi, reduc->init, e, locus);\n-  add_phi_arg (new_phi, lhs, FALLTHRU_EDGE (loop->latch), locus);\n+  add_phi_arg (new_phi, lhs, FALLTHRU_EDGE (continue_bb), locus);\n   reduc->new_phi = new_phi;\n \n   return 1;\n@@ -1134,7 +1135,8 @@ create_call_for_reduction (struct loop *loop,\n {\n   reduction_list->traverse <struct loop *, create_phi_for_local_result> (loop);\n   /* Find the fallthru edge from GIMPLE_OMP_CONTINUE.  */\n-  ld_st_data->load_bb = FALLTHRU_EDGE (loop->latch)->dest;\n+  basic_block continue_bb = single_pred (loop->latch);\n+  ld_st_data->load_bb = FALLTHRU_EDGE (continue_bb)->dest;\n   reduction_list\n     ->traverse <struct clsn_data *, create_call_for_reduction_1> (ld_st_data);\n }\n@@ -1981,7 +1983,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n \t\t      tree new_data, unsigned n_threads, location_t loc)\n {\n   gimple_stmt_iterator gsi;\n-  basic_block bb, paral_bb, for_bb, ex_bb;\n+  basic_block bb, paral_bb, for_bb, ex_bb, continue_bb;\n   tree t, param;\n   gomp_parallel *omp_par_stmt;\n   gimple omp_return_stmt1, omp_return_stmt2;\n@@ -2052,8 +2054,12 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   gcc_assert (exit == single_dom_exit (loop));\n \n   guard = make_edge (for_bb, ex_bb, 0);\n-  single_succ_edge (loop->latch)->flags = 0;\n-  end = make_edge (loop->latch, ex_bb, EDGE_FALLTHRU);\n+  /* Split the latch edge, so LOOPS_HAVE_SIMPLE_LATCHES is still valid.  */\n+  loop->latch = split_edge (single_succ_edge (loop->latch));\n+  single_pred_edge (loop->latch)->flags = 0;\n+  end = make_edge (single_pred (loop->latch), ex_bb, EDGE_FALLTHRU);\n+  rescan_loop_exit (end, true, false);\n+\n   for (gphi_iterator gpi = gsi_start_phis (ex_bb);\n        !gsi_end_p (gpi); gsi_next (&gpi))\n     {\n@@ -2102,7 +2108,8 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   SSA_NAME_DEF_STMT (initvar) = for_stmt;\n \n   /* Emit GIMPLE_OMP_CONTINUE.  */\n-  gsi = gsi_last_bb (loop->latch);\n+  continue_bb = single_pred (loop->latch);\n+  gsi = gsi_last_bb (continue_bb);\n   omp_cont_stmt = gimple_build_omp_continue (cvar_next, cvar);\n   gimple_set_location (omp_cont_stmt, loc);\n   gsi_insert_after (&gsi, omp_cont_stmt, GSI_NEW_STMT);\n@@ -2298,10 +2305,6 @@ gen_parallel_loop (struct loop *loop,\n \n   scev_reset ();\n \n-  /* Cancel the loop (it is simpler to do it here rather than to teach the\n-     expander to do it).  */\n-  cancel_loop_tree (loop);\n-\n   /* Free loop bound estimations that could contain references to\n      removed statements.  */\n   FOR_EACH_LOOP (loop, 0)\n@@ -2587,6 +2590,7 @@ parallelize_loops (void)\n   unsigned n_threads = flag_tree_parallelize_loops;\n   bool changed = false;\n   struct loop *loop;\n+  struct loop *skip_loop = NULL;\n   struct tree_niter_desc niter_desc;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n@@ -2604,6 +2608,19 @@ parallelize_loops (void)\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n+      if (loop == skip_loop)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Skipping loop %d as inner loop of parallelized loop\\n\",\n+\t\t     loop->num);\n+\n+\t  skip_loop = loop->inner;\n+\t  continue;\n+\t}\n+      else\n+\tskip_loop = NULL;\n+\n       reduction_list.empty ();\n       if (dump_file && (dump_flags & TDF_DETAILS))\n       {\n@@ -2663,6 +2680,7 @@ parallelize_loops (void)\n \tcontinue;\n \n       changed = true;\n+      skip_loop = loop->inner;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n       {\n \tif (loop->inner)\n@@ -2729,6 +2747,11 @@ pass_parallelize_loops::execute (function *fun)\n   if (parallelize_loops ())\n     {\n       fun->curr_properties &= ~(PROP_gimple_eomp);\n+\n+#ifdef ENABLE_CHECKING\n+      verify_loop_structure ();\n+#endif\n+\n       return TODO_update_ssa;\n     }\n "}]}