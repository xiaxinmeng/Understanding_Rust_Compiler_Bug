{"sha": "b883fc9b54d360b5f73bf226bb489e8612502298", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg4M2ZjOWI1NGQzNjBiNWY3M2JmMjI2YmI0ODllODYxMjUwMjI5OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-25T06:35:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-25T06:35:30Z"}, "message": "Try harder to preserve operand ties in maybe_legitimize_operands\n\nmaybe_legitimize_operands normally goes through each operand in turn\nand legitimises it in isolation.  For example, if two operands to\nan instruction initially have constant value C, and the instruction\nrequires both operands to be registers, the function ends up forcing\nC into a register twice and passing two different registers to the\ninstruction.\n\nI think we should try a bit harder to preserve the rtx_equal_p\nproperty, if it's easy to do.  Some targets can optimise that\ncase better than they would the general case of all operands\nbeing different.  This is particularly true for SVE after the\nupcoming changes to the IFN_COND_* routines.\n\nThis is hard to test on its own, but is covered by the upcoming\nIFN_COND_* patches.\n\n2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* optabs.c (can_reuse_operands_p): New function.\n\t(maybe_legitimize_operands): Try to reuse the results for\n\tearlier operands.\n\nFrom-SVN: r260706", "tree": {"sha": "2419d2426ca05211e88a58c9f30bb73e43a06db4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2419d2426ca05211e88a58c9f30bb73e43a06db4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b883fc9b54d360b5f73bf226bb489e8612502298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b883fc9b54d360b5f73bf226bb489e8612502298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b883fc9b54d360b5f73bf226bb489e8612502298", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b883fc9b54d360b5f73bf226bb489e8612502298/comments", "author": null, "committer": null, "parents": [{"sha": "9143aa524cee23faf8d4f11d0a8a7b5393952406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9143aa524cee23faf8d4f11d0a8a7b5393952406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9143aa524cee23faf8d4f11d0a8a7b5393952406"}], "stats": {"total": 82, "additions": 73, "deletions": 9}, "files": [{"sha": "117844058476ae25e067154adf3ff6a0243f1448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b883fc9b54d360b5f73bf226bb489e8612502298/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b883fc9b54d360b5f73bf226bb489e8612502298/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b883fc9b54d360b5f73bf226bb489e8612502298", "patch": "@@ -1,3 +1,9 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* optabs.c (can_reuse_operands_p): New function.\n+\t(maybe_legitimize_operands): Try to reuse the results for\n+\tearlier operands.\n+\n 2018-05-24  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (cvtusi2<ssescalarmodesuffix>64<round_name>):"}, {"sha": "278046aa06139e8a1aa5cad55cdad2258f6f3c4f", "filename": "gcc/optabs.c", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b883fc9b54d360b5f73bf226bb489e8612502298/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b883fc9b54d360b5f73bf226bb489e8612502298/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b883fc9b54d360b5f73bf226bb489e8612502298", "patch": "@@ -7207,6 +7207,44 @@ create_convert_operand_from_type (struct expand_operand *op,\n \t\t\t       TYPE_UNSIGNED (type));\n }\n \n+/* Return true if the requirements on operands OP1 and OP2 of instruction\n+   ICODE are similar enough for the result of legitimizing OP1 to be\n+   reusable for OP2.  OPNO1 and OPNO2 are the operand numbers associated\n+   with OP1 and OP2 respectively.  */\n+\n+static inline bool\n+can_reuse_operands_p (enum insn_code icode,\n+\t\t      unsigned int opno1, unsigned int opno2,\n+\t\t      const struct expand_operand *op1,\n+\t\t      const struct expand_operand *op2)\n+{\n+  /* Check requirements that are common to all types.  */\n+  if (op1->type != op2->type\n+      || op1->mode != op2->mode\n+      || (insn_data[(int) icode].operand[opno1].mode\n+\t  != insn_data[(int) icode].operand[opno2].mode))\n+    return false;\n+\n+  /* Check the requirements for specific types.  */\n+  switch (op1->type)\n+    {\n+    case EXPAND_OUTPUT:\n+      /* Outputs must remain distinct.  */\n+      return false;\n+\n+    case EXPAND_FIXED:\n+    case EXPAND_INPUT:\n+    case EXPAND_ADDRESS:\n+    case EXPAND_INTEGER:\n+      return true;\n+\n+    case EXPAND_CONVERT_TO:\n+    case EXPAND_CONVERT_FROM:\n+      return op1->unsigned_p == op2->unsigned_p;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Try to make operands [OPS, OPS + NOPS) match operands [OPNO, OPNO + NOPS)\n    of instruction ICODE.  Return true on success, leaving the new operand\n    values in the OPS themselves.  Emit no code on failure.  */\n@@ -7215,16 +7253,36 @@ bool\n maybe_legitimize_operands (enum insn_code icode, unsigned int opno,\n \t\t\t   unsigned int nops, struct expand_operand *ops)\n {\n-  rtx_insn *last;\n-  unsigned int i;\n+  rtx_insn *last = get_last_insn ();\n+  rtx *orig_values = XALLOCAVEC (rtx, nops);\n+  for (unsigned int i = 0; i < nops; i++)\n+    {\n+      orig_values[i] = ops[i].value;\n+\n+      /* First try reusing the result of an earlier legitimization.\n+\t This avoids duplicate rtl and ensures that tied operands\n+\t remain tied.\n+\n+\t This search is linear, but NOPS is bounded at compile time\n+\t to a small number (current a single digit).  */\n+      unsigned int j = 0;\n+      for (; j < i; ++j)\n+\tif (can_reuse_operands_p (icode, opno + j, opno + i, &ops[j], &ops[i])\n+\t    && rtx_equal_p (orig_values[j], orig_values[i])\n+\t    && ops[j].value\n+\t    && insn_operand_matches (icode, opno + i, ops[j].value))\n+\t  {\n+\t    ops[i].value = copy_rtx (ops[j].value);\n+\t    break;\n+\t  }\n \n-  last = get_last_insn ();\n-  for (i = 0; i < nops; i++)\n-    if (!maybe_legitimize_operand (icode, opno + i, &ops[i]))\n-      {\n-\tdelete_insns_since (last);\n-\treturn false;\n-      }\n+      /* Otherwise try legitimizing the operand on its own.  */\n+      if (j == i && !maybe_legitimize_operand (icode, opno + i, &ops[i]))\n+\t{\n+\t  delete_insns_since (last);\n+\t  return false;\n+\t}\n+    }\n   return true;\n }\n "}]}