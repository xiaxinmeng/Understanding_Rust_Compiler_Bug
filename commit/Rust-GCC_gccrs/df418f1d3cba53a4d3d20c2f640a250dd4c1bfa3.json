{"sha": "df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0MThmMWQzY2JhNTNhNGQzZDIwYzJmNjQwYTI1MGRkNGMxYmZhMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-11-22T21:38:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-11-22T21:38:44Z"}, "message": "re PR c++/92458 (Constraints do not work with precompiled headers)\n\n\tPR c++/92458\n\t* tree-hash-traits.h (tree_decl_hash, tree_ssa_name_hash,\n\ttree_hash): Move to ...\n\t* tree.h (tree_decl_hash, tree_ssa_name_hash, tree_hash): ... here.\n\t(struct decl_tree_cache_traits, struct type_tree_cache_traits): New\n\ttypes.\n\t(decl_tree_cache_map, tree_tree_cache_map): New typedefs.\n\n\t* init.c (nsdmi_inst): Change type to\n\tdecl_tree_cache_map * from tree_cache_map *.\n\t* constraint.cc (decl_constraints): Likewise.\n\t* decl.c (get_tuple_decomp_init): Likewise.\n\t* pt.c (defarg_inst, explicit_specifier_map): Likewise.\n\t(tsubst_default_argument, store_explicit_specifier): Use\n\tdecl_tree_cache_map::create_ggc rather than\n\ttree_cache_map::create_ggc.\n\t* cp-objcp-common.c (debug_type_map): Change type to\n\ttype_tree_cache_map * from tree_cache_map *.\n\n\t* g++.dg/pch/pr92458.C: New test.\n\t* g++.dg/pch/pr92458.Hs: New test.\n\nFrom-SVN: r278633", "tree": {"sha": "f66e383f251a8499f4d34c9d8662bca6f50413af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f66e383f251a8499f4d34c9d8662bca6f50413af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "839e636a9abe65f4880fb5d9609f8ee5ff277fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/839e636a9abe65f4880fb5d9609f8ee5ff277fe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/839e636a9abe65f4880fb5d9609f8ee5ff277fe5"}], "stats": {"total": 160, "additions": 112, "deletions": 48}, "files": [{"sha": "6ed7abaa343287b551693be9792ff04b7051415b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -1,5 +1,13 @@\n 2019-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/92458\n+\t* tree-hash-traits.h (tree_decl_hash, tree_ssa_name_hash,\n+\ttree_hash): Move to ...\n+\t* tree.h (tree_decl_hash, tree_ssa_name_hash, tree_hash): ... here.\n+\t(struct decl_tree_cache_traits, struct type_tree_cache_traits): New\n+\ttypes.\n+\t(decl_tree_cache_map, tree_tree_cache_map): New typedefs.\n+\n \tPR tree-optimization/92618\n \t* tree-ssa-reassoc.c (v_info): Change from auto_vec to a struct\n \tcontaining the auto_vec and a tree."}, {"sha": "93cf9e95f7182300134dba1a24fabb8b3dba27a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -1,3 +1,17 @@\n+2019-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/92458\n+\t* init.c (nsdmi_inst): Change type to\n+\tdecl_tree_cache_map * from tree_cache_map *.\n+\t* constraint.cc (decl_constraints): Likewise.\n+\t* decl.c (get_tuple_decomp_init): Likewise.\n+\t* pt.c (defarg_inst, explicit_specifier_map): Likewise.\n+\t(tsubst_default_argument, store_explicit_specifier): Use\n+\tdecl_tree_cache_map::create_ggc rather than\n+\ttree_cache_map::create_ggc.\n+\t* cp-objcp-common.c (debug_type_map): Change type to\n+\ttype_tree_cache_map * from tree_cache_map *.\n+\n 2019-11-21  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/92450 - ICE with invalid nested name specifier."}, {"sha": "171ca4e0ed4573efa33dcb17b36838afa73da7e4", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -1113,7 +1113,7 @@ build_constraints (tree tr, tree dr)\n \n /* A mapping from declarations to constraint information.  */\n \n-static GTY ((cache)) tree_cache_map *decl_constraints;\n+static GTY ((cache)) decl_tree_cache_map *decl_constraints;\n \n /* Returns the template constraints of declaration T. If T is not\n    constrained, return NULL_TREE. Note that T must be non-null. */"}, {"sha": "d168e2a802fcfb00fbffd373e607d6d6ae7a14ee", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -123,7 +123,7 @@ cxx_types_compatible_p (tree x, tree y)\n   return same_type_ignoring_top_level_qualifiers_p (x, y);\n }\n \n-static GTY((cache)) tree_cache_map *debug_type_map;\n+static GTY((cache)) type_tree_cache_map *debug_type_map;\n \n /* Return a type to use in the debug info instead of TYPE, or NULL_TREE to\n    keep TYPE.  */"}, {"sha": "26120720f07494fb014ce0bc9326657a10156610", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -7998,7 +7998,7 @@ get_tuple_decomp_init (tree decl, unsigned i)\n /* It's impossible to recover the decltype of a tuple decomposition variable\n    based on the actual type of the variable, so store it in a hash table.  */\n \n-static GTY((cache)) tree_cache_map *decomp_type_table;\n+static GTY((cache)) decl_tree_cache_map *decomp_type_table;\n \n tree\n lookup_decomp_type (tree v)"}, {"sha": "aa48f80e58dad1f1d3c13bbe9cc1bb8fe862372a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -548,7 +548,7 @@ perform_target_ctor (tree init)\n \n /* Return the non-static data initializer for FIELD_DECL MEMBER.  */\n \n-static GTY((cache)) tree_cache_map *nsdmi_inst;\n+static GTY((cache)) decl_tree_cache_map *nsdmi_inst;\n \n tree\n get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)"}, {"sha": "78b78bab74d5f9f6577b0de0a6ae487f4dc01461", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -13272,7 +13272,7 @@ tsubst_aggr_type (tree t,\n     }\n }\n \n-static GTY((cache)) tree_cache_map *defarg_inst;\n+static GTY((cache)) decl_tree_cache_map *defarg_inst;\n \n /* Substitute into the default argument ARG (a default argument for\n    FN), which has the indicated TYPE.  */\n@@ -13346,7 +13346,7 @@ tsubst_default_argument (tree fn, int parmnum, tree type, tree arg,\n   if (arg != error_mark_node && !cp_unevaluated_operand)\n     {\n       if (!defarg_inst)\n-\tdefarg_inst = tree_cache_map::create_ggc (37);\n+\tdefarg_inst = decl_tree_cache_map::create_ggc (37);\n       defarg_inst->put (parm, arg);\n     }\n \n@@ -13383,15 +13383,15 @@ tsubst_default_arguments (tree fn, tsubst_flags_t complain)\n }\n \n /* Hash table mapping a FUNCTION_DECL to its dependent explicit-specifier.  */\n-static GTY((cache)) tree_cache_map *explicit_specifier_map;\n+static GTY((cache)) decl_tree_cache_map *explicit_specifier_map;\n \n /* Store a pair to EXPLICIT_SPECIFIER_MAP.  */\n \n void\n store_explicit_specifier (tree v, tree t)\n {\n   if (!explicit_specifier_map)\n-    explicit_specifier_map = tree_cache_map::create_ggc (37);\n+    explicit_specifier_map = decl_tree_cache_map::create_ggc (37);\n   DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P (v) = true;\n   explicit_specifier_map->put (v, t);\n }"}, {"sha": "6f8c791d77694a100cf6af6c17387f2a14587622", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -1,3 +1,9 @@\n+2019-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/92458\n+\t* g++.dg/pch/pr92458.C: New test.\n+\t* g++.dg/pch/pr92458.Hs: New test.\n+\n 2019-11-22  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* gcc.target/i386/pr27971.c: Use mdynamic-no-pic for m32 on"}, {"sha": "a750599be1a8d745106c98028a9e5393e326fc62", "filename": "gcc/testsuite/g++.dg/pch/pr92458.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.C?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -0,0 +1,5 @@\n+// PR c++/92458\n+// { dg-options \"-std=c++2a\" }\n+\n+#include \"pr92458.H\"\n+S<int> s;"}, {"sha": "b81ea634e23842aa1046a6585330e06b535ae09b", "filename": "gcc/testsuite/g++.dg/pch/pr92458.Hs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.Hs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.Hs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpch%2Fpr92458.Hs?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/92458\n+// { dg-options \"-std=c++2a\" }\n+\n+template<typename T> concept C = sizeof(T) > 1;\n+template<typename T> struct S { };\n+template<typename T> requires C<T> struct S<T> { };\n+template<typename T> requires (!C<T>) struct S<T> { };"}, {"sha": "8c2a839c4fe056eb3855b79f1b53fd02fede37e7", "filename": "gcc/tree-hash-traits.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftree-hash-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftree-hash-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-hash-traits.h?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -41,44 +41,4 @@ tree_operand_hash::equal (const value_type &t1,\n   return operand_equal_p (t1, t2, 0);\n }\n \n-/* Hasher for tree decls.  Pointer equality is enough here, but the DECL_UID\n-   is a better hash than the pointer value and gives a predictable traversal\n-   order.  */\n-struct tree_decl_hash : ggc_ptr_hash <tree_node>\n-{\n-  static inline hashval_t hash (tree);\n-};\n-\n-inline hashval_t\n-tree_decl_hash::hash (tree t)\n-{\n-  return DECL_UID (t);\n-}\n-\n-/* Hash for SSA_NAMEs in the same function.  Pointer equality is enough\n-   here, but the SSA_NAME_VERSION is a better hash than the pointer\n-   value and gives a predictable traversal order.  */\n-struct tree_ssa_name_hash : ggc_ptr_hash <tree_node>\n-{\n-  static inline hashval_t hash (tree);\n-};\n-\n-inline hashval_t\n-tree_ssa_name_hash::hash (tree t)\n-{\n-  return SSA_NAME_VERSION (t);\n-}\n-\n-/* Hasher for general trees, based on their TREE_HASH.  */\n-struct tree_hash : ggc_ptr_hash <tree_node>\n-{\n-  static hashval_t hash (tree);\n-};\n-\n-inline hashval_t\n-tree_hash::hash (tree t)\n-{\n-  return TREE_HASH (t);\n-}\n-\n #endif"}, {"sha": "60b6eae7b04463b1c05fa2c292a404a5dda42e78", "filename": "gcc/tree.h", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=df418f1d3cba53a4d3d20c2f640a250dd4c1bfa3", "patch": "@@ -5351,13 +5351,77 @@ struct tree_decl_map_cache_hasher : ggc_cache_ptr_hash<tree_decl_map>\n #define tree_vec_map_hash tree_decl_map_hash\n #define tree_vec_map_marked_p tree_map_base_marked_p\n \n+/* Hasher for tree decls.  Pointer equality is enough here, but the DECL_UID\n+   is a better hash than the pointer value and gives a predictable traversal\n+   order.  Additionally it can be used across PCH save/restore.  */\n+struct tree_decl_hash : ggc_ptr_hash <tree_node>\n+{\n+  static inline hashval_t hash (tree);\n+};\n+\n+inline hashval_t\n+tree_decl_hash::hash (tree t)\n+{\n+  return DECL_UID (t);\n+}\n+\n+/* Similarly for types.  Uses TYPE_UID as hash function.  */\n+struct tree_type_hash : ggc_ptr_hash <tree_node>\n+{\n+  static inline hashval_t hash (tree);\n+};\n+\n+inline hashval_t\n+tree_type_hash::hash (tree t)\n+{\n+  return TYPE_UID (t);\n+}\n+\n+/* Hash for SSA_NAMEs in the same function.  Pointer equality is enough\n+   here, but the SSA_NAME_VERSION is a better hash than the pointer\n+   value and gives a predictable traversal order.  */\n+struct tree_ssa_name_hash : ggc_ptr_hash <tree_node>\n+{\n+  static inline hashval_t hash (tree);\n+};\n+\n+inline hashval_t\n+tree_ssa_name_hash::hash (tree t)\n+{\n+  return SSA_NAME_VERSION (t);\n+}\n+\n+/* Hasher for general trees, based on their TREE_HASH.  */\n+struct tree_hash : ggc_ptr_hash <tree_node>\n+{\n+  static hashval_t hash (tree);\n+};\n+\n+inline hashval_t\n+tree_hash::hash (tree t)\n+{\n+  return TREE_HASH (t);\n+}\n+\n /* A hash_map of two trees for use with GTY((cache)).  Garbage collection for\n    such a map will not mark keys, and will mark values if the key is already\n    marked.  */\n struct tree_cache_traits\n   : simple_cache_map_traits<default_hash_traits<tree>, tree> { };\n typedef hash_map<tree,tree,tree_cache_traits> tree_cache_map;\n \n+/* Similarly, but use DECL_UID as hash function rather than pointer hashing.\n+   This is for hash_maps from decls to trees that need to work across PCH.  */\n+struct decl_tree_cache_traits\n+  : simple_cache_map_traits<tree_decl_hash, tree> { };\n+typedef hash_map<tree,tree,decl_tree_cache_traits> decl_tree_cache_map;\n+\n+/* Similarly, but use TYPE_UID as hash function rather than pointer hashing.\n+   This is for hash_maps from types to trees that need to work across PCH.  */\n+struct type_tree_cache_traits\n+  : simple_cache_map_traits<tree_type_hash, tree> { };\n+typedef hash_map<tree,tree,type_tree_cache_traits> type_tree_cache_map;\n+\n /* Initialize the abstract argument list iterator object ITER with the\n    arguments from CALL_EXPR node EXP.  */\n static inline void"}]}