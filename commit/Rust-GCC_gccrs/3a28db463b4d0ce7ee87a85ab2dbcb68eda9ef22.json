{"sha": "3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2EyOGRiNDYzYjRkMGNlN2VlODdhODVhYjJkYmNiNjhlZGE5ZWYyMg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-01-11T15:48:40Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-01-11T15:48:40Z"}, "message": "re PR middle-end/68999 (FAIL: gfortran.fortran-torture/execute/save_1.f90 execution)\n\n\tPR middle-end/68999\n\t* alias.c (base_alias_check): Move check for addresses with\n\talignment ANDs before the call for compare_base_decls.\n\t(memrefs_conflict_p): Return -1 for different decls\n\tthat went through alignment adjustments.\n\nFrom-SVN: r232229", "tree": {"sha": "4f082545fd981f2ad5cda9e4d3a2d1b8db212f39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f082545fd981f2ad5cda9e4d3a2d1b8db212f39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22/comments", "author": null, "committer": null, "parents": [{"sha": "2b8568fe565d23e8cb9f02334d81c21428eb7cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8568fe565d23e8cb9f02334d81c21428eb7cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b8568fe565d23e8cb9f02334d81c21428eb7cd3"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "62aaea2652520a30f4733608e414361065644464", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "patch": "@@ -1,3 +1,11 @@\n+2016-01-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR middle-end/68999\n+\t* alias.c (base_alias_check): Move check for addresses with\n+\talignment ANDs before the call for compare_base_decls.\n+\t(memrefs_conflict_p): Return -1 for different decls\n+\tthat went through alignment adjustments.\n+\n 2016-01-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/68796\n@@ -8,12 +16,11 @@\n \n 2016-01-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\t* config/i386/sse.md (<avx512>_load<mode>_mask): Remove\n-\tsnprintf.\n+\t* config/i386/sse.md (<avx512>_load<mode>_mask): Remove snprintf.\n \t(<avx512>_store<mode>_mask): Likewise.\n \n 2016-01-11  Bernd Schmidt  <bschmidt@redhat.com>\n-            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/68841\n \t* ifcvt.c (struct noce_if_info): Add orig_x field."}, {"sha": "ccfad4d8386d024a40000fc2f3420c62ccf69f34", "filename": "gcc/alias.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3a28db463b4d0ce7ee87a85ab2dbcb68eda9ef22", "patch": "@@ -2093,17 +2093,6 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n   if (rtx_equal_p (x_base, y_base))\n     return 1;\n \n-  if (GET_CODE (x_base) == SYMBOL_REF && GET_CODE (y_base) == SYMBOL_REF)\n-    {\n-      tree x_decl = SYMBOL_REF_DECL (x_base);\n-      tree y_decl = SYMBOL_REF_DECL (y_base);\n-\n-      /* We can assume that no stores are made to labels.  */\n-      if (!x_decl || !y_decl)\n-\treturn 0;\n-      return compare_base_decls (x_decl, y_decl) != 0;\n-    }\n-\n   /* The base addresses are different expressions.  If they are not accessed\n      via AND, there is no conflict.  We can bring knowledge of object\n      alignment into play here.  For example, on alpha, \"char a, b;\" can\n@@ -2122,6 +2111,17 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n \t  || (int) GET_MODE_UNIT_SIZE (x_mode) < -INTVAL (XEXP (y, 1))))\n     return 1;\n \n+  if (GET_CODE (x_base) == SYMBOL_REF && GET_CODE (y_base) == SYMBOL_REF)\n+    {\n+      tree x_decl = SYMBOL_REF_DECL (x_base);\n+      tree y_decl = SYMBOL_REF_DECL (y_base);\n+\n+      /* We can assume that no stores are made to labels.  */\n+      if (!x_decl || !y_decl)\n+\treturn 0;\n+      return compare_base_decls (x_decl, y_decl) != 0;\n+    }\n+\n   /* Differing symbols not accessed via AND never alias.  */\n   if (GET_CODE (x_base) != ADDRESS && GET_CODE (y_base) != ADDRESS)\n     return 0;\n@@ -2344,6 +2344,12 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       /* If both decls are the same, decide by offsets.  */\n       if (cmp == 1)\n         return offset_overlap_p (c, xsize, ysize);\n+      /* Assume a potential overlap for symbolic addresses that went\n+\t through alignment adjustments (i.e., that have negative\n+\t sizes), because we can't know how far they are from each\n+\t other.  */\n+      if (xsize < 0 || ysize < 0)\n+\treturn -1;\n       /* If decls are different or we know by offsets that there is no overlap,\n \t we win.  */\n       if (!cmp || !offset_overlap_p (c, xsize, ysize))"}]}