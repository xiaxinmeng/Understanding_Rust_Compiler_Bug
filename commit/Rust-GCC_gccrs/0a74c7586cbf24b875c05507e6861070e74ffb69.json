{"sha": "0a74c7586cbf24b875c05507e6861070e74ffb69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE3NGM3NTg2Y2JmMjRiODc1YzA1NTA3ZTY4NjEwNzBlNzRmZmI2OQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-05-28T18:42:15Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-05-28T18:42:15Z"}, "message": "When niter may be zero, return a COND_EXPR with the may_be_zero condition.\n\n2010-05-28  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-scalar-evolution.c (set_nb_iterations_in_loop): Inlined in the\n\tonly place it was called from.\n\t(number_of_latch_executions): Do not return chrec_dont_know when the\n\tmay_be_zero is a runtime condition: instead, return a COND_EXPR\n\tincluding the may_be_zero condition.\n\t* cfgloop.h (struct loop): Add a note on COND_EXPRs to the comment\n\tof nb_iterations.\n\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Handle\n\tCOND_EXPRs.\n\n\t* gcc.dg/vect/vect-outer-fir-lb.c: Un-XFAIL-ed.\n\nFrom-SVN: r159992", "tree": {"sha": "fd9dab29f46e485b9afc38a2e968d2b4f9bb77eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd9dab29f46e485b9afc38a2e968d2b4f9bb77eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a74c7586cbf24b875c05507e6861070e74ffb69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a74c7586cbf24b875c05507e6861070e74ffb69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a74c7586cbf24b875c05507e6861070e74ffb69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a74c7586cbf24b875c05507e6861070e74ffb69/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7cb8957bf8709677b85ba17fa3f9231633aaede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7cb8957bf8709677b85ba17fa3f9231633aaede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7cb8957bf8709677b85ba17fa3f9231633aaede"}], "stats": {"total": 119, "additions": 70, "deletions": 49}, "files": [{"sha": "5b083fd4d7bcafa2c135b0f43c4633a7a3697cd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -1,3 +1,15 @@\n+2010-05-28  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-scalar-evolution.c (set_nb_iterations_in_loop): Inlined in the\n+\tonly place it was called from.\n+\t(number_of_latch_executions): Do not return chrec_dont_know when the\n+\tmay_be_zero is a runtime condition: instead, return a COND_EXPR\n+\tincluding the may_be_zero condition.\n+\t* cfgloop.h (struct loop): Add a note on COND_EXPRs to the comment\n+\tof nb_iterations.\n+\t* tree-ssa-loop-ivopts.c (contains_abnormal_ssa_name_p): Handle\n+\tCOND_EXPRs.\n+\n 2010-05-28  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c (replace_phi_with_cond_gimple_assign_stmt): Don't"}, {"sha": "3821ee66c7993d74e4591333baee45e357d84d30", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -134,11 +134,13 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n   /* Auxiliary info specific to a pass.  */\n   PTR GTY ((skip (\"\"))) aux;\n \n-  /* The number of times the latch of the loop is executed.\n-     This is an INTEGER_CST or an expression containing symbolic\n-     names.  Don't access this field directly:\n-     number_of_latch_executions computes and caches the computed\n-     information in this field.  */\n+  /* The number of times the latch of the loop is executed.  This can be an\n+     INTEGER_CST, or a symbolic expression representing the number of\n+     iterations like \"N - 1\", or a COND_EXPR containing the runtime\n+     conditions under which the number of iterations is non zero.\n+\n+     Don't access this field directly: number_of_latch_executions\n+     computes and caches the computed information in this field.  */\n   tree nb_iterations;\n \n   /* An integer guaranteed to bound the number of iterations of the loop"}, {"sha": "c5b13d632220ea23815043c273464c3f5dbb99ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -1,3 +1,7 @@\n+2010-05-28  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* gcc.dg/vect/vect-outer-fir-lb.c: Un-XFAIL-ed.\n+\n 2010-05-28  Mike Stump  <mikestump@comcast.net>\n \n \tPR objc/44125\n@@ -40,7 +44,7 @@\n \t* obj-c++.dg/torture/tls/thr-init-2.mm: Ditto.\n \t* obj-c++.dg/torture/tls/thr-init-3.mm: Ditto.\n \t* obj-c++.dg/torture/trivial.mm: Ditto.\n-\t\n+\n 2010-05-27  Jack Howarth  <howarth@bromo.med.uc.edu>\n \n \t* g++.dg/lto/20100302_0.C: Skip on darwin."}, {"sha": "3c1a362c003e741eeb686c1f84ca8d80797c860c", "filename": "gcc/testsuite/gcc.dg/vect/vect-outer-fir-lb.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-outer-fir-lb.c?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -10,10 +10,7 @@ float coeff[M];\n float out[N];\n float fir_out[N];\n \n-/* Should be vectorized. Fixed misaligment in the inner-loop.  */\n-/* Currently not vectorized because the loop-count for the inner-loop\n-   has a maybe_zero component. Will be fixed when we incorporate the\n-   \"cond_expr in rhs\" patch.  */\n+/* Vectorized.  Fixed misaligment in the inner-loop.  */\n __attribute__ ((noinline))\n void foo (){\n  int i,j,k;\n@@ -30,7 +27,7 @@ void foo (){\n \n     do {\n       diff += in[j+i]*coeff[j];\n-      j+=4;\t\n+      j+=4;\n     } while (j < M);\n \n     out[i] += diff;\n@@ -39,7 +36,7 @@ void foo (){\n \n }\n \n-/* Vectorized. Changing misalignment in the inner-loop.  */\n+/* Vectorized.  Changing misalignment in the inner-loop.  */\n __attribute__ ((noinline))\n void fir (){\n   int i,j,k;\n@@ -68,7 +65,7 @@ int main (void)\n \n   foo ();\n   fir ();\n-  \n+\n   for (i = 0; i < N; i++) {\n     if (out[i] != fir_out[i])\n       abort ();\n@@ -77,6 +74,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED\" 2 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d50eac9833948e44181ca80c6518d6ce3f702622", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -900,23 +900,6 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n   return res;\n }\n \n-/* Helper function.  */\n-\n-static inline tree\n-set_nb_iterations_in_loop (struct loop *loop,\n-\t\t\t   tree res)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"  (set_nb_iterations_in_loop = \");\n-      print_generic_expr (dump_file, res, 0);\n-      fprintf (dump_file, \"))\\n\");\n-    }\n-\n-  loop->nb_iterations = res;\n-  return res;\n-}\n-\n \f\n \n /* This section selects the loops that will be good candidates for the\n@@ -2685,8 +2668,11 @@ resolve_mixers (struct loop *loop, tree chrec)\n /* Entry point for the analysis of the number of iterations pass.\n    This function tries to safely approximate the number of iterations\n    the loop will run.  When this property is not decidable at compile\n-   time, the result is chrec_dont_know.  Otherwise the result is\n-   a scalar or a symbolic parameter.\n+   time, the result is chrec_dont_know.  Otherwise the result is a\n+   scalar or a symbolic parameter.  When the number of iterations may\n+   be equal to zero and the property cannot be determined at compile\n+   time, the result is a COND_EXPR that represents in a symbolic form\n+   the conditions under which the number of iterations is not zero.\n \n    Example of analysis: suppose that the loop has an exit condition:\n \n@@ -2705,37 +2691,53 @@ resolve_mixers (struct loop *loop, tree chrec)\n tree\n number_of_latch_executions (struct loop *loop)\n {\n-  tree res, type;\n   edge exit;\n   struct tree_niter_desc niter_desc;\n+  tree may_be_zero;\n+  tree res;\n \n-  /* Determine whether the number_of_iterations_in_loop has already\n+  /* Determine whether the number of iterations in loop has already\n      been computed.  */\n   res = loop->nb_iterations;\n   if (res)\n     return res;\n-  res = chrec_dont_know;\n+\n+  may_be_zero = NULL_TREE;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"(number_of_iterations_in_loop\\n\");\n+    fprintf (dump_file, \"(number_of_iterations_in_loop = \\n\");\n \n+  res = chrec_dont_know;\n   exit = single_exit (loop);\n-  if (!exit)\n-    goto end;\n \n-  if (!number_of_iterations_exit (loop, exit, &niter_desc, false))\n-    goto end;\n+  if (exit && number_of_iterations_exit (loop, exit, &niter_desc, false))\n+    {\n+      may_be_zero = niter_desc.may_be_zero;\n+      res = niter_desc.niter;\n+    }\n+\n+  if (res == chrec_dont_know\n+      || !may_be_zero\n+      || integer_zerop (may_be_zero))\n+    ;\n+  else if (integer_nonzerop (may_be_zero))\n+    res = build_int_cst (TREE_TYPE (res), 0);\n \n-  type = TREE_TYPE (niter_desc.niter);\n-  if (integer_nonzerop (niter_desc.may_be_zero))\n-    res = build_int_cst (type, 0);\n-  else if (integer_zerop (niter_desc.may_be_zero))\n-    res = niter_desc.niter;\n+  else if (COMPARISON_CLASS_P (may_be_zero))\n+    res = fold_build3 (COND_EXPR, TREE_TYPE (res), may_be_zero,\n+\t\t       build_int_cst (TREE_TYPE (res), 0), res);\n   else\n     res = chrec_dont_know;\n \n-end:\n-  return set_nb_iterations_in_loop (loop, res);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (set_nb_iterations_in_loop = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+\n+  loop->nb_iterations = res;\n+  return res;\n }\n \n /* Returns the number of executions of the exit condition of LOOP,"}, {"sha": "bda640f3e0eafb11b834b423d38cc006a80cfb9d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a74c7586cbf24b875c05507e6861070e74ffb69/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=0a74c7586cbf24b875c05507e6861070e74ffb69", "patch": "@@ -681,6 +681,11 @@ contains_abnormal_ssa_name_p (tree expr)\n \t\t\t    idx_contains_abnormal_ssa_name_p,\n \t\t\t    NULL);\n \n+  if (code == COND_EXPR)\n+    return contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 0))\n+      || contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 1))\n+      || contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 2));\n+\n   switch (codeclass)\n     {\n     case tcc_binary:"}]}