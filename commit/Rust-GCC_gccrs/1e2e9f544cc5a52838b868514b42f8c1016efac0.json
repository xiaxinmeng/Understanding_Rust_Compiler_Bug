{"sha": "1e2e9f544cc5a52838b868514b42f8c1016efac0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUyZTlmNTQ0Y2M1YTUyODM4Yjg2ODUxNGI0MmY4YzEwMTZlZmFjMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-05-22T19:28:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-05-22T19:28:31Z"}, "message": "re PR c++/15507 (hang laying out union)\n\n\tPR c++/15507\n\t* class.c (layout_nonempty_base_or_field): Do not try to avoid\n\tlayout conflicts for unions.\n\n\tPR c++/15542\n\t* typeck.c (build_x_unary_op): Instantiate template class\n\tspecializations before looking for \"operator &\".\n\n\tPR c++/15427\n\t* typeck.c (complete_type): Layout non-dependent array types, even\n\tin templates.\n\n\tPR c++/15287\n\t* typeck.c (build_unary_op): Do not optimize \"&x[y]\" when in a\n\ttemplate.\n\n\tPR c++/15507\n\t* g++.dg/inherit/union1.C: New test.\n\n\tPR c++/15542\n\t* g++.dg/template/addr1.C: New test.\n\n\tPR c++/15427\n\t* g++.dg/template/array5.C: New test.\n\n\tPR c++/15287\n\t* g++.dg/template/array6.C: New test.\n\nFrom-SVN: r82144", "tree": {"sha": "e082af0b49a7dd245825f7a8bc7b9ca8cd7b23eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e082af0b49a7dd245825f7a8bc7b9ca8cd7b23eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e2e9f544cc5a52838b868514b42f8c1016efac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2e9f544cc5a52838b868514b42f8c1016efac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2e9f544cc5a52838b868514b42f8c1016efac0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2e9f544cc5a52838b868514b42f8c1016efac0/comments", "author": null, "committer": null, "parents": [{"sha": "79bba51c2833a33d574533bf16ea63d97d201736", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79bba51c2833a33d574533bf16ea63d97d201736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79bba51c2833a33d574533bf16ea63d97d201736"}], "stats": {"total": 123, "additions": 111, "deletions": 12}, "files": [{"sha": "063ea63f819c3b54295af09d7359a620b14e45f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -1,3 +1,21 @@\n+2004-05-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/15507\n+\t* class.c (layout_nonempty_base_or_field): Do not try to avoid\n+\tlayout conflicts for unions.\n+\n+\tPR c++/15542\n+\t* typeck.c (build_x_unary_op): Instantiate template class\n+\tspecializations before looking for \"operator &\".\n+\n+\tPR c++/15427\n+\t* typeck.c (complete_type): Layout non-dependent array types, even\n+\tin templates.\n+\n+\tPR c++/15287\n+\t* typeck.c (build_unary_op): Do not optimize \"&x[y]\" when in a\n+\ttemplate.\n+\n 2004-05-22  Roger Sayle  <roger@eyesopen.com>\n \n \t* name-lookup.c (check_for_out_of_scope_variable): Avoid ICE by"}, {"sha": "73828a854e866d58caa73efc108da273b0b87ddb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -3502,14 +3502,14 @@ layout_nonempty_base_or_field (record_layout_info rli,\n       /* Place this field.  */\n       place_field (rli, decl);\n       offset = byte_position (decl);\n- \n+\n       /* We have to check to see whether or not there is already\n \t something of the same type at the offset we're about to use.\n-\t For example:\n+\t For example, consider:\n \t \n-\t struct S {};\n-\t struct T : public S { int i; };\n-\t struct U : public S, public T {};\n+\t   struct S {};\n+\t   struct T : public S { int i; };\n+\t   struct U : public S, public T {};\n \t \n \t Here, we put S at offset zero in U.  Then, we can't put T at\n \t offset zero -- its S component would be at the same address\n@@ -3518,6 +3518,10 @@ layout_nonempty_base_or_field (record_layout_info rli,\n \t empty class, have nonzero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n+      /* In a union, overlap is permitted; all members are placed at\n+\t offset zero.  */\n+      if (TREE_CODE (rli->t) == UNION_TYPE)\n+\tbreak;\n       /* G++ 3.2 did not check for overlaps when placing a non-empty\n \t virtual base.  */\n       if (!abi_version_at_least (2) && binfo && TREE_VIA_VIRTUAL (binfo))"}, {"sha": "603f655c832f18e31bb16554f5d238f79dc27373", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -127,7 +127,7 @@ complete_type (tree type)\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n       tree t = complete_type (TREE_TYPE (type));\n-      if (COMPLETE_TYPE_P (t) && ! processing_template_decl)\n+      if (COMPLETE_TYPE_P (t) && !dependent_type_p (type))\n \tlayout_type (type);\n       TYPE_NEEDS_CONSTRUCTING (type)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n@@ -3527,12 +3527,18 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \n   exp = NULL_TREE;\n \n-  /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n-     error message.  */\n+  /* [expr.unary.op] says:\n+\n+       The address of an object of incomplete type can be taken.\n+\n+     (And is just the ordinary address operator, not an overloaded\n+     \"operator &\".)  However, if the type is a template\n+     specialization, we must complete the type at this point so that\n+     an overloaded \"operator &\" will be available if required.  */\n   if (code == ADDR_EXPR\n       && TREE_CODE (xarg) != TEMPLATE_ID_EXPR\n-      && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n-\t   && !COMPLETE_TYPE_P (TREE_TYPE (xarg)))\n+      && ((CLASS_TYPE_P (TREE_TYPE (xarg))\n+\t   && !COMPLETE_TYPE_P (complete_type (TREE_TYPE (xarg))))\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n     /* Don't look for a function.  */;\n   else\n@@ -3927,8 +3933,12 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  return arg;\n \t}\n \n-      /* For &x[y], return x+y.  */\n-      if (TREE_CODE (arg) == ARRAY_REF)\n+      /* For &x[y], return x+y.  But, in a template, ARG may be an\n+\t ARRAY_REF representing a non-dependent expression.  In that\n+\t case, there may be an overloaded \"operator []\" that will be\n+\t chosen at instantiation time; we must not try to optimize\n+\t here.  */\n+      if (TREE_CODE (arg) == ARRAY_REF && !processing_template_decl)\n \t{\n \t  if (!cxx_mark_addressable (TREE_OPERAND (arg, 0)))\n \t    return error_mark_node;"}, {"sha": "2d7c928f9d0f14680a8e0cbc7853dac46c78a738", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -1,3 +1,17 @@\n+2004-05-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/15507\n+\t* g++.dg/inherit/union1.C: New test.\n+\n+\tPR c++/15542\n+\t* g++.dg/template/addr1.C: New test.\n+\n+\tPR c++/15427\n+\t* g++.dg/template/array5.C: New test.\n+\n+\tPR c++/15287\n+\t* g++.dg/template/array6.C: New test.\n+\n 2004-05-22  Wolfgang Bangerth  <bangerth@dealii.org>\n \t    Roger Sayle  <roger@eyesopen.com>\n "}, {"sha": "da46096c8c8d2c977d660a2f5aefb2c73299c6ec", "filename": "gcc/testsuite/g++.dg/inherit/union1.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Funion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Funion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Funion1.C?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/15507\n+\n+struct A {\n+  // empty\n+};\n+\n+struct B : A {\n+  int b;\n+};\n+\n+union U {\n+  A a;\n+  B b;\n+};"}, {"sha": "dd5e3870fc53e238de9f62d855e5fa02df4965bc", "filename": "gcc/testsuite/g++.dg/template/addr1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faddr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faddr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faddr1.C?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/15542\n+\n+template <typename> struct S_T { \n+  const char** operator & (); \n+}; \n+ \n+template <class T> void foo(T **) {} \n+ \n+template <typename> void templateTest() { \n+  S_T<const char> s_t; \n+  foo(&s_t); \n+} "}, {"sha": "a5435806747d67a070addfe34a2201e1c4cb25bd", "filename": "gcc/testsuite/g++.dg/template/array5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray5.C?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/15427\n+\n+template<class T>\n+struct A\n+{\n+  T foo;\n+};\n+\n+template<class T>\n+struct B\n+{\n+  A<int> _squares[2];\n+};\n+"}, {"sha": "0dc5161b2b2c36a35ba4a81ef9a25a60e9117117", "filename": "gcc/testsuite/g++.dg/template/array6.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2e9f544cc5a52838b868514b42f8c1016efac0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Farray6.C?ref=1e2e9f544cc5a52838b868514b42f8c1016efac0", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/15287\n+\n+struct S {}; \n+ \n+struct Array { \n+  S operator[](int); \n+} array; \n+ \n+void (S::*mem_fun_ptr)(); \n+ \n+template <int> void foo() { \n+  (array[0].*mem_fun_ptr)(); \n+} "}]}