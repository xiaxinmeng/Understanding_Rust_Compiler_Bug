{"sha": "68f9b84438d3ad84f1baf6413723a205e6a49b07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmOWI4NDQzOGQzYWQ4NGYxYmFmNjQxMzcyM2EyMDVlNmE0OWIwNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-01-11T18:43:15Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-01-11T18:43:15Z"}, "message": "basic-block.h (control_flow_graph): Change the type of x_basic_block_info to VEC(basic_block,gc) *.\n\n\t* basic-block.h (control_flow_graph): Change the type of\n\tx_basic_block_info to VEC(basic_block,gc) *.\n\t(BASIC_BLOCK_FOR_FUNCTION, BASIC_BLOCK): Adjust the uses of\n\tbasic_block_info.\n\t(SET_BASIC_BLOCK): New.\n\t* cfg.c (compact_blocks, expunge_block): Use SET_BASIC_BLOCK\n\tinstead of BASIC_BLOCK when assigning to BASIC_BLOCK.\n\t* cfgbuild.c (find_basic_blocks): Likewise.\n\t* cfglayout.c (fixup_reorder_chain): Likewise.\n\t* cfgrtl.c (create_basic_block_structure,\n\trtl_create_basic_block): Likewise.\n\t* ifcvt.c (find_if_case_1): Likewise.\n\t* tree-cfg.c (init_empty_tree_cfg, build_tree_cfg, create_bb):\n\tLikewise.\n\nFrom-SVN: r109596", "tree": {"sha": "107754d72857ad15b86879bbb0e898761aed1c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/107754d72857ad15b86879bbb0e898761aed1c26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f9b84438d3ad84f1baf6413723a205e6a49b07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f9b84438d3ad84f1baf6413723a205e6a49b07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f9b84438d3ad84f1baf6413723a205e6a49b07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f9b84438d3ad84f1baf6413723a205e6a49b07/comments", "author": null, "committer": null, "parents": [{"sha": "043c2d9e0840ed72c6eca4eb9eb75e382224ad3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/043c2d9e0840ed72c6eca4eb9eb75e382224ad3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/043c2d9e0840ed72c6eca4eb9eb75e382224ad3d"}], "stats": {"total": 86, "additions": 63, "deletions": 23}, "files": [{"sha": "692e45a83393bd9a2c3fd9e4ed0a3f0bbb103911", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -1,3 +1,20 @@\n+2006-01-11  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* basic-block.h (control_flow_graph): Change the type of\n+\tx_basic_block_info to VEC(basic_block,gc) *.\n+\t(BASIC_BLOCK_FOR_FUNCTION, BASIC_BLOCK): Adjust the uses of\n+\tbasic_block_info.\n+\t(SET_BASIC_BLOCK): New.\n+\t* cfg.c (compact_blocks, expunge_block): Use SET_BASIC_BLOCK\n+\tinstead of BASIC_BLOCK when assigning to BASIC_BLOCK.\n+\t* cfgbuild.c (find_basic_blocks): Likewise.\n+\t* cfglayout.c (fixup_reorder_chain): Likewise.\n+\t* cfgrtl.c (create_basic_block_structure,\n+\trtl_create_basic_block): Likewise.\n+\t* ifcvt.c (find_if_case_1): Likewise.\n+\t* tree-cfg.c (init_empty_tree_cfg, build_tree_cfg, create_bb):\n+\tLikewise.\n+\n 2005-01-11  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n \t* Makefile.in Removed rotted odf.c entry."}, {"sha": "d9fd10c90d16d172fd0c57de2b6fb238f2fdd194", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -367,7 +367,7 @@ struct control_flow_graph GTY(())\n   basic_block x_exit_block_ptr;\n \n   /* Index by basic block number, get basic block struct info.  */\n-  varray_type x_basic_block_info;\n+  VEC(basic_block,gc) *x_basic_block_info;\n \n   /* Number of basic blocks in this flow graph.  */\n   int x_n_basic_blocks;\n@@ -399,7 +399,7 @@ struct control_flow_graph GTY(())\n #define label_to_block_map_for_function(FN)  ((FN)->cfg->x_label_to_block_map)\n \n #define BASIC_BLOCK_FOR_FUNCTION(FN,N) \\\n-  (VARRAY_BB (basic_block_info_for_function(FN), (N)))\n+  (VEC_index (basic_block, basic_block_info_for_function(FN), (N)))\n \n /* Defines for textual backward source compatibility.  */\n #define ENTRY_BLOCK_PTR\t\t(cfun->cfg->x_entry_block_ptr)\n@@ -411,7 +411,8 @@ struct control_flow_graph GTY(())\n #define label_to_block_map\t(cfun->cfg->x_label_to_block_map)\n #define profile_status\t\t(cfun->cfg->x_profile_status)\n \n-#define BASIC_BLOCK(N)\t\t(VARRAY_BB (basic_block_info, (N)))\n+#define BASIC_BLOCK(N)\t\t(VEC_index (basic_block, basic_block_info, (N)))\n+#define SET_BASIC_BLOCK(N,BB)\t(VEC_replace (basic_block, basic_block_info, (N), (BB)))\n \n /* TRUE if we should re-run loop discovery after threading jumps, FALSE\n    otherwise.  */"}, {"sha": "7b2a30fea6dd16e9cbf4641fdb6ca74c268fd74d", "filename": "gcc/cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -163,21 +163,21 @@ compact_blocks (void)\n   int i;\n   basic_block bb;\n \n-  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n-  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n+  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n+  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n \n   i = NUM_FIXED_BLOCKS;\n   FOR_EACH_BB (bb) \n     {\n-      BASIC_BLOCK (i) = bb;\n+      SET_BASIC_BLOCK (i, bb);\n       bb->index = i;\n       i++;\n     }\n \n   gcc_assert (i == n_basic_blocks);\n \n   for (; i < last_basic_block; i++)\n-    BASIC_BLOCK (i) = NULL;\n+    SET_BASIC_BLOCK (i, NULL);\n \n   last_basic_block = n_basic_blocks;\n }\n@@ -188,7 +188,7 @@ void\n expunge_block (basic_block b)\n {\n   unlink_block (b);\n-  BASIC_BLOCK (b->index) = NULL;\n+  SET_BASIC_BLOCK (b->index, NULL);\n   n_basic_blocks--;\n   /* We should be able to ggc_free here, but we are not.\n      The dead SSA_NAMES are left pointing to dead statements that are pointing"}, {"sha": "6a7395abeebb81b3ec7fc69007f14d127888e3fb", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -542,9 +542,12 @@ find_basic_blocks (rtx f)\n      instructions at all until close to the end of compilation when we\n      actually lay them out.  */\n \n-  VARRAY_BB_INIT (basic_block_info, n_basic_blocks, \"basic_block_info\");\n-  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n-  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n+  basic_block_info = VEC_alloc (basic_block, gc, n_basic_blocks);\n+  VEC_safe_grow (basic_block, gc, basic_block_info, n_basic_blocks);\n+  memset (VEC_address (basic_block, basic_block_info), 0,\n+\t  sizeof (basic_block) * n_basic_blocks);\n+  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n+  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n \n   find_basic_blocks_1 (f);\n "}, {"sha": "265afd73f93c4927f5354b7e001a6e657599cf47", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -814,7 +814,7 @@ fixup_reorder_chain (void)\n   for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n     {\n       bb->index = index;\n-      BASIC_BLOCK (index) = bb;\n+      SET_BASIC_BLOCK (index, bb);\n \n       bb->prev_bb = prev_bb;\n       prev_bb->next_bb = bb;"}, {"sha": "765247260f2bbdc120680402dc262862bec62c17", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -305,7 +305,7 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   bb->index = last_basic_block++;\n   bb->flags = BB_NEW | BB_RTL;\n   link_block (bb, after);\n-  BASIC_BLOCK (bb->index) = bb;\n+  SET_BASIC_BLOCK (bb->index, bb);\n   update_bb_for_insn (bb);\n   BB_SET_PARTITION (bb, BB_UNPARTITIONED);\n \n@@ -328,10 +328,14 @@ rtl_create_basic_block (void *headp, void *endp, basic_block after)\n   basic_block bb;\n \n   /* Grow the basic block array if needed.  */\n-  if ((size_t) last_basic_block >= VARRAY_SIZE (basic_block_info))\n+  if ((size_t) last_basic_block >= VEC_length (basic_block, basic_block_info))\n     {\n+      size_t old_size = VEC_length (basic_block, basic_block_info);\n       size_t new_size = last_basic_block + (last_basic_block + 3) / 4;\n-      VARRAY_GROW (basic_block_info, new_size);\n+      basic_block *p;\n+      VEC_safe_grow (basic_block, gc, basic_block_info, new_size);\n+      p = VEC_address (basic_block, basic_block_info);\n+      memset (&p[old_size], 0, sizeof (basic_block) * (new_size - old_size));\n     }\n \n   n_basic_blocks++;"}, {"sha": "2390f2f3c899eb1b8e7f112a3cd2174cff9e7be7", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -3135,7 +3135,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   if (new_bb)\n     {\n       new_bb->index = then_bb_index;\n-      BASIC_BLOCK (then_bb_index) = new_bb;\n+      SET_BASIC_BLOCK (then_bb_index, new_bb);\n       /* Since the fallthru edge was redirected from test_bb to new_bb,\n          we need to ensure that new_bb is in the same partition as\n          test bb (you can not fall through across section boundaries).  */"}, {"sha": "4b34ddac4ef304eeecb37b4f67941d3d0734c30c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f9b84438d3ad84f1baf6413723a205e6a49b07/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=68f9b84438d3ad84f1baf6413723a205e6a49b07", "patch": "@@ -131,16 +131,19 @@ init_empty_tree_cfg (void)\n   profile_status = PROFILE_ABSENT;\n   n_basic_blocks = NUM_FIXED_BLOCKS;\n   last_basic_block = NUM_FIXED_BLOCKS;\n-  VARRAY_BB_INIT (basic_block_info, initial_cfg_capacity, \"basic_block_info\");\n+  basic_block_info = VEC_alloc (basic_block, gc, initial_cfg_capacity);\n+  VEC_safe_grow (basic_block, gc, basic_block_info, initial_cfg_capacity);\n+  memset (VEC_address (basic_block, basic_block_info), 0,\n+\t  sizeof (basic_block) * initial_cfg_capacity);\n \n   /* Build a mapping of labels to their associated blocks.  */\n   label_to_block_map = VEC_alloc (basic_block, gc, initial_cfg_capacity);\n   VEC_safe_grow (basic_block, gc, label_to_block_map, initial_cfg_capacity);\n   memset (VEC_address (basic_block, label_to_block_map),\n \t  0, sizeof (basic_block) * initial_cfg_capacity);\n \n-  BASIC_BLOCK (ENTRY_BLOCK) = ENTRY_BLOCK_PTR;\n-  BASIC_BLOCK (EXIT_BLOCK) = EXIT_BLOCK_PTR;\n+  SET_BASIC_BLOCK (ENTRY_BLOCK, ENTRY_BLOCK_PTR);\n+  SET_BASIC_BLOCK (EXIT_BLOCK, EXIT_BLOCK_PTR);\n   ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n }\n@@ -178,7 +181,15 @@ build_tree_cfg (tree *tp)\n     create_empty_bb (ENTRY_BLOCK_PTR);\n \n   /* Adjust the size of the array.  */\n-  VARRAY_GROW (basic_block_info, n_basic_blocks);\n+  if (VEC_length (basic_block, basic_block_info) < (size_t) n_basic_blocks)\n+    {\n+      size_t old_size = VEC_length (basic_block, basic_block_info);\n+      basic_block *p;\n+      VEC_safe_grow (basic_block, gc, basic_block_info, n_basic_blocks);\n+      p = VEC_address (basic_block, basic_block_info);\n+      memset (&p[old_size], 0,\n+\t      sizeof (basic_block) * (n_basic_blocks - old_size));\n+    }\n \n   /* To speed up statement iterator walks, we first purge dead labels.  */\n   cleanup_dead_labels ();\n@@ -382,14 +393,18 @@ create_bb (void *h, void *e, basic_block after)\n   link_block (bb, after);\n \n   /* Grow the basic block array if needed.  */\n-  if ((size_t) last_basic_block == VARRAY_SIZE (basic_block_info))\n+  if ((size_t) last_basic_block == VEC_length (basic_block, basic_block_info))\n     {\n+      size_t old_size = VEC_length (basic_block, basic_block_info);\n       size_t new_size = last_basic_block + (last_basic_block + 3) / 4;\n-      VARRAY_GROW (basic_block_info, new_size);\n+      basic_block *p;\n+      VEC_safe_grow (basic_block, gc, basic_block_info, new_size);\n+      p = VEC_address (basic_block, basic_block_info);\n+      memset (&p[old_size], 0, sizeof (basic_block) * (new_size - old_size));\n     }\n \n   /* Add the newly created block to the array.  */\n-  BASIC_BLOCK (last_basic_block) = bb;\n+  SET_BASIC_BLOCK (last_basic_block, bb);\n \n   n_basic_blocks++;\n   last_basic_block++;"}]}