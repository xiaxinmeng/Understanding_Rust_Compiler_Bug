{"sha": "697c3575e2a72e4957cccd73a32930f8697847bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3YzM1NzVlMmE3MmU0OTU3Y2NjZDczYTMyOTMwZjg2OTc4NDdiZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-09-28T16:28:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-09-28T16:28:39Z"}, "message": "tree-ssa-ccp.c (fold_ctor_reference): New function.\n\n\t* tree-ssa-ccp.c (fold_ctor_reference): New function.\n\t(fold_const_aggregate_ref): Use it.\n\t* fold-const.c (canonicalize_constructor_val): Check that we don't fold\n\tinto external static.\n\nFrom-SVN: r164688", "tree": {"sha": "e1c07b1338c16183ef661f24ea71635de02d9505", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1c07b1338c16183ef661f24ea71635de02d9505"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/697c3575e2a72e4957cccd73a32930f8697847bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697c3575e2a72e4957cccd73a32930f8697847bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/697c3575e2a72e4957cccd73a32930f8697847bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697c3575e2a72e4957cccd73a32930f8697847bd/comments", "author": null, "committer": null, "parents": [{"sha": "2770264a75b500cb6b21772223718a2eab620968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2770264a75b500cb6b21772223718a2eab620968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2770264a75b500cb6b21772223718a2eab620968"}], "stats": {"total": 469, "additions": 314, "deletions": 155}, "files": [{"sha": "08ffa06415ae5adf8048d0fbca4a0e4e959e0539", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=697c3575e2a72e4957cccd73a32930f8697847bd", "patch": "@@ -1,3 +1,10 @@\n+2010-09-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-ccp.c (fold_ctor_reference): New function.\n+\t(fold_const_aggregate_ref): Use it.\n+\t* fold-const.c (canonicalize_constructor_val): Check that we don't fold\n+\tinto external static.\n+\n 2010-09-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/44452"}, {"sha": "b8c0fd4ec91c4ec796f1f6d5b8d0c376520be636", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=697c3575e2a72e4957cccd73a32930f8697847bd", "patch": "@@ -54,12 +54,11 @@ static_object_in_other_unit_p (tree decl)\n   struct varpool_node *vnode;\n   struct cgraph_node *node;\n \n-  if (!TREE_STATIC (decl)\n-      || TREE_PUBLIC (decl) || DECL_COMDAT (decl))\n+  if (!TREE_STATIC (decl) || DECL_COMDAT (decl))\n     return false;\n   /* External flag is set, so we deal with C++ reference\n      to static object from other file.  */\n-  if (DECL_EXTERNAL (decl))\n+  if (DECL_EXTERNAL (decl) && TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Just be sure it is not big in frontend setting\n \t flags incorrectly.  Those variables should never\n@@ -68,6 +67,8 @@ static_object_in_other_unit_p (tree decl)\n \t\t\t   || !vnode->finalized);\n       return true;\n     }\n+  if (TREE_PUBLIC (decl))\n+    return false;\n   /* We are not at ltrans stage; so don't worry about WHOPR.  */\n   if (!flag_ltrans)\n     return false;"}, {"sha": "3de4bc015d44f562e5a9ef77437b7a67fa248572", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=697c3575e2a72e4957cccd73a32930f8697847bd", "patch": "@@ -1,3 +1,7 @@\n+2010-09-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/foldconst-5.c: New testcase.\n+\n 2010-09-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/44452"}, {"sha": "1dad931ed7b4d307502a51cc18c9dd327a720d31", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldconst-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldconst-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldconst-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldconst-5.c?ref=697c3575e2a72e4957cccd73a32930f8697847bd", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+\n+static const char a[5]=\"t\";\n+static const int b[5]={1,2};\n+static const struct a {int a : 6; int b : 6;} c = {5,9};\n+test()\n+{\n+  return a[2]+b[1]+b[3]+c.b;\n+}\n+/* { dg-final { scan-tree-dump \"return 11;\" \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */\n+"}, {"sha": "13c51bc7913f5a15dc7f6bcb74f10f8b4fd0e02c", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 285, "deletions": 152, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/697c3575e2a72e4957cccd73a32930f8697847bd/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=697c3575e2a72e4957cccd73a32930f8697847bd", "patch": "@@ -168,6 +168,9 @@ static prop_value_t *const_val;\n \n static void canonicalize_float_value (prop_value_t *);\n static bool ccp_fold_stmt (gimple_stmt_iterator *);\n+static tree fold_ctor_reference (tree type, tree ctor,\n+\t\t\t\t unsigned HOST_WIDE_INT offset,\n+\t\t\t\t unsigned HOST_WIDE_INT size);\n \n /* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n \n@@ -1369,17 +1372,232 @@ get_base_constructor (tree base, tree *offset)\n     }\n }\n \n+/* CTOR is STRING_CST.  Fold reference of type TYPE and size SIZE\n+   to the memory at bit OFFSET.  \n+\n+   We do only simple job of folding byte accesses.  */\n+\n+static tree\n+fold_string_cst_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n+\t\t\t\tunsigned HOST_WIDE_INT size)\n+{\n+  if (INTEGRAL_TYPE_P (type)\n+      && (TYPE_MODE (type)\n+\t  == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n+      && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n+\t  == MODE_INT)\n+      && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor)))) == 1\n+      && size == BITS_PER_UNIT\n+      && !(offset % BITS_PER_UNIT))\n+    {\n+      offset /= BITS_PER_UNIT;\n+      if (offset < (unsigned HOST_WIDE_INT) TREE_STRING_LENGTH (ctor))\n+\treturn build_int_cst_type (type, (TREE_STRING_POINTER (ctor)\n+\t\t\t\t   [offset]));\n+      /* Folding\n+\t const char a[20]=\"hello\";\n+\t return a[10];\n+\n+\t might lead to offset greater than string length.  In this case we\n+\t know value is either initialized to 0 or out of bounds.  Return 0\n+\t in both cases.  */\n+      return build_zero_cst (type);\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* CTOR is CONSTRUCTOR of an array type.  Fold reference of type TYPE and size\n+   SIZE to the memory at bit OFFSET.  */\n+\n+static tree\n+fold_array_ctor_reference (tree type, tree ctor,\n+\t\t\t   unsigned HOST_WIDE_INT offset,\n+\t\t\t   unsigned HOST_WIDE_INT size)\n+{\n+  unsigned HOST_WIDE_INT cnt;\n+  tree cfield, cval;\n+  double_int low_bound, elt_size;\n+  double_int index, max_index;\n+  double_int access_index;\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (ctor));\n+  HOST_WIDE_INT inner_offset;\n+\n+  /* Compute low bound and elt size.  */\n+  if (domain_type && TYPE_MIN_VALUE (domain_type))\n+    {\n+      /* Static constructors for variably sized objects makes no sense.  */\n+      gcc_assert (TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST);\n+      low_bound = tree_to_double_int (TYPE_MIN_VALUE (domain_type));\n+    }\n+  else\n+    low_bound = double_int_zero;\n+  /* Static constructors for variably sized objects makes no sense.  */\n+  gcc_assert (TREE_CODE(TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))))\n+\t      == INTEGER_CST);\n+  elt_size =\n+    tree_to_double_int (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ctor))));\n+\n+\n+  /* We can handle only constantly sized accesses that are known to not\n+     be larger than size of array element.  */\n+  if (!TYPE_SIZE_UNIT (type)\n+      || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n+      || double_int_cmp (elt_size,\n+\t\t\t tree_to_double_int (TYPE_SIZE_UNIT (type)), 0) < 0)\n+    return NULL_TREE;\n+\n+  /* Compute the array index we look for.  */\n+  access_index = double_int_udiv (uhwi_to_double_int (offset / BITS_PER_UNIT),\n+\t\t\t\t  elt_size, TRUNC_DIV_EXPR);\n+  access_index = double_int_add (access_index, low_bound);\n+\n+  /* And offset within the access.  */\n+  inner_offset = offset % (double_int_to_uhwi (elt_size) * BITS_PER_UNIT);\n+\n+  /* See if the array field is large enough to span whole access.  We do not\n+     care to fold accesses spanning multiple array indexes.  */\n+  if (inner_offset + size > double_int_to_uhwi (elt_size) * BITS_PER_UNIT)\n+    return NULL_TREE;\n+\n+  index = double_int_sub (low_bound, double_int_one);\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n+    {\n+      /* Array constructor might explicitely set index, or specify range\n+\t or leave index NULL meaning that it is next index after previous\n+\t one.  */\n+      if (cfield)\n+\t{\n+\t  if (TREE_CODE (cfield) == INTEGER_CST)\n+\t    max_index = index = tree_to_double_int (cfield);\n+\t  else\n+\t    {\n+\t      gcc_assert (TREE_CODE (cfield) == RANGE_EXPR);\n+\t      index = tree_to_double_int (TREE_OPERAND (cfield, 0));\n+\t      max_index = tree_to_double_int (TREE_OPERAND (cfield, 1));\n+\t    }\n+\t}\n+      else\n+\tmax_index = index = double_int_add (index, double_int_one);\n+\n+      /* Do we have match?  */\n+      if (double_int_cmp (access_index, index, 1) >= 0\n+\t  && double_int_cmp (access_index, max_index, 1) <= 0)\n+\treturn fold_ctor_reference (type, cval, inner_offset, size);\n+    }\n+  /* When memory is not explicitely mentioned in constructor,\n+     it is 0 (or out of range).  */\n+  return build_zero_cst (type);\n+}\n+\n+/* CTOR is CONSTRUCTOR of an aggregate or vector.\n+   Fold reference of type TYPE and size SIZE to the memory at bit OFFSET.  */\n+\n+static tree\n+fold_nonarray_ctor_reference (tree type, tree ctor,\n+\t\t\t      unsigned HOST_WIDE_INT offset,\n+\t\t\t      unsigned HOST_WIDE_INT size)\n+{\n+  unsigned HOST_WIDE_INT cnt;\n+  tree cfield, cval;\n+\n+  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield,\n+\t\t\t    cval)\n+    {\n+      tree byte_offset = DECL_FIELD_OFFSET (cfield);\n+      tree field_offset = DECL_FIELD_BIT_OFFSET (cfield);\n+      tree field_size = DECL_SIZE (cfield);\n+      double_int bitoffset;\n+      double_int byte_offset_cst = tree_to_double_int (byte_offset);\n+      double_int bits_per_unit_cst = uhwi_to_double_int (BITS_PER_UNIT);\n+      double_int bitoffset_end;\n+\n+      /* Variable sized objects in static constructors makes no sense.  */\n+      gcc_assert (TREE_CODE (field_offset) == INTEGER_CST\n+\t\t  && TREE_CODE (byte_offset) == INTEGER_CST\n+\t\t  && TREE_CODE (field_size) == INTEGER_CST);\n+\n+      /* Compute bit offset of the field.  */\n+      bitoffset = double_int_add (tree_to_double_int (field_offset),\n+\t\t\t\t  double_int_mul (byte_offset_cst,\n+\t\t\t\t\t\t  bits_per_unit_cst));\n+      /* Compute bit offset where the field ends.  */\n+      bitoffset_end = double_int_add (bitoffset,\n+\t\t\t\t      tree_to_double_int (field_size));\n+\n+      /* Is OFFSET in the range (BITOFFSET, BITOFFSET_END)? */\n+      if (double_int_cmp (uhwi_to_double_int (offset), bitoffset, 0) >= 0\n+\t  && double_int_cmp (uhwi_to_double_int (offset),\n+\t\t\t     bitoffset_end, 0) < 0)\n+\t{\n+\t  double_int access_end = double_int_add (uhwi_to_double_int (offset),\n+\t\t\t\t\t\t  uhwi_to_double_int (size));\n+\t  double_int inner_offset = double_int_sub (uhwi_to_double_int (offset),\n+\t\t\t\t\t\t    bitoffset);\n+\t  /* We do have overlap.  Now see if field is large enough to\n+\t     cover the access.  Give up for accesses spanning multiple\n+\t     fields.  */\n+\t  if (double_int_cmp (access_end, bitoffset_end, 0) > 0)\n+\t    return NULL_TREE;\n+\t  return fold_ctor_reference (type, cval,\n+\t\t\t\t      double_int_to_uhwi (inner_offset), size);\n+\t}\n+    }\n+  /* When memory is not explicitely mentioned in constructor, it is 0.  */\n+  return build_zero_cst (type);\n+}\n+\n+/* CTOR is value initializing memory, fold reference of type TYPE and size SIZE\n+   to the memory at bit OFFSET.  */\n+\n+static tree\n+fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n+\t\t     unsigned HOST_WIDE_INT size)\n+{\n+  tree ret;\n+\n+  /* We found the field with exact match.  */\n+  if (useless_type_conversion_p (type, TREE_TYPE (ctor))\n+      && !offset)\n+    return canonicalize_constructor_val (ctor);\n+\n+  /* We are at the end of walk, see if we can view convert the\n+     result.  */\n+  if (!AGGREGATE_TYPE_P (TREE_TYPE (ctor)) && !offset\n+      /* VIEW_CONVERT_EXPR is defined only for matching sizes.  */\n+      && operand_equal_p (TYPE_SIZE (type),\n+\t\t\t  TYPE_SIZE (TREE_TYPE (ctor)), 0))\n+    {\n+      ret = canonicalize_constructor_val (ctor);\n+      ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);\n+      if (ret)\n+\tSTRIP_NOPS (ret);\n+      return ret;\n+    }\n+  if (TREE_CODE (ctor) == STRING_CST)\n+    return fold_string_cst_ctor_reference (type, ctor, offset, size);\n+  if (TREE_CODE (ctor) == CONSTRUCTOR)\n+    {\n+\n+      if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE)\n+\treturn fold_array_ctor_reference (type, ctor, offset, size);\n+      else\n+\treturn fold_nonarray_ctor_reference (type, ctor, offset, size);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Return the tree representing the element referenced by T if T is an\n    ARRAY_REF or COMPONENT_REF into constant aggregates.  Return\n    NULL_TREE otherwise.  */\n \n tree\n fold_const_aggregate_ref (tree t)\n {\n-  tree ctor, idx, field;\n-  unsigned HOST_WIDE_INT cnt;\n-  tree cfield, cval;\n+  tree ctor, idx, base;\n+  HOST_WIDE_INT offset, size, max_size;\n   tree tem;\n+  tree ctr_offset;\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == tcc_declaration)\n     return get_symbol_constant_value (t);\n@@ -1391,99 +1609,81 @@ fold_const_aggregate_ref (tree t)\n   switch (TREE_CODE (t))\n     {\n     case ARRAY_REF:\n-      ctor = get_base_constructor (TREE_OPERAND (t, 0), &idx);\n+    case ARRAY_RANGE_REF:\n+      /* Constant indexes are handled well by get_base_constructor.\n+\t Only special case variable offsets.\n+\t FIXME: This code can't handle nested references with variable indexes\n+\t (they will be handled only by iteration of ccp).  Perhaps we can bring\n+\t get_ref_base_and_extent here and make it use get_constant_value.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == SSA_NAME\n+\t  && (idx = get_constant_value (TREE_OPERAND (t, 1)))\n+\t  && host_integerp (idx, 0))\n+\t{\n+\t  tree low_bound, unit_size;\n \n-      if (idx)\n-\treturn NULL_TREE;\n+\t  /* If the resulting bit-offset is constant, track it.  */\n+\t  if ((low_bound = array_ref_low_bound (t),\n+\t       host_integerp (low_bound, 0))\n+\t      && (unit_size = array_ref_element_size (t),\n+\t\t  host_integerp (unit_size, 1)))\n+\t    {\n+\t      offset = TREE_INT_CST_LOW (idx);\n+\t      offset -= TREE_INT_CST_LOW (low_bound);\n+\t      offset *= TREE_INT_CST_LOW (unit_size);\n+\t      offset *= BITS_PER_UNIT;\n+\n+\t      base = TREE_OPERAND (t, 0);\n+\t      ctor = get_base_constructor (base, &ctr_offset);\n+\t      if (ctr_offset)\n+\t\t{\n+\t\t  if (!host_integerp (ctr_offset, 1))\n+\t\t    return NULL_TREE;\n+\t\t  offset += TREE_INT_CST_LOW (ctr_offset) * BITS_PER_UNIT;\n+\t\t}\n+\t      /* Empty constructor.  Always fold to 0. */\n+\t      if (ctor == error_mark_node)\n+\t\treturn build_zero_cst (TREE_TYPE (t));\n+\t      /* Out of bound array access.  Value is undefined, but don't fold. */\n+\t      if (offset < 0)\n+\t\treturn NULL_TREE;\n+\t      /* We can not determine ctor.  */\n+\t      if (!ctor)\n+\t\treturn NULL_TREE;\n+\t      return fold_ctor_reference (TREE_TYPE (t), ctor, offset,\n+\t\t\t\t\t  TREE_INT_CST_LOW (unit_size)\n+\t\t\t\t\t  * BITS_PER_UNIT);\n+\t    }\n+\t}\n+      /* Fallthru.  */\n+\t\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case TARGET_MEM_REF:\n+    case MEM_REF:\n+      base = get_ref_base_and_extent (t, &offset, &size, &max_size);\n+      ctor = get_base_constructor (base, &ctr_offset);\n \n+      /* Empty constructor.  Always fold to 0. */\n       if (ctor == error_mark_node)\n \treturn build_zero_cst (TREE_TYPE (t));\n-\n-      if (ctor == NULL_TREE\n-\t  || (TREE_CODE (ctor) != CONSTRUCTOR\n-\t      && TREE_CODE (ctor) != STRING_CST))\n+      /* We do not know precise address.  */\n+      if (max_size == -1 || max_size != size)\n+\treturn NULL_TREE;\n+      /* We can not determine ctor.  */\n+      if (!ctor)\n \treturn NULL_TREE;\n \n-      /* Get the index.  If we have an SSA_NAME, try to resolve it\n-\t with the current lattice value for the SSA_NAME.  */\n-      idx = TREE_OPERAND (t, 1);\n-      switch (TREE_CODE (idx))\n-\t{\n-\tcase SSA_NAME:\n-\t  if ((tem = get_constant_value (idx))\n-\t      && TREE_CODE (tem) == INTEGER_CST)\n-\t    idx = tem;\n-\t  else\n-\t    return NULL_TREE;\n-\t  break;\n-\n-\tcase INTEGER_CST:\n-\t  break;\n-\n-\tdefault:\n-\t  return NULL_TREE;\n-\t}\n-\n-      /* Fold read from constant string.  */\n-      if (TREE_CODE (ctor) == STRING_CST)\n+      if (ctr_offset)\n \t{\n-\t  tree low_bound = array_ref_low_bound (t);\n-\t  double_int low_bound_cst;\n-\t  double_int index_cst;\n-\t  double_int length_cst;\n-\t  bool signed_p = TYPE_UNSIGNED (TREE_TYPE (idx));\n-\n-\t  if (TREE_CODE (idx) != INTEGER_CST\n-\t      || !INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t      || TREE_CODE (low_bound) != INTEGER_CST)\n+\t  if (!host_integerp (ctr_offset, 1))\n \t    return NULL_TREE;\n-\t  low_bound_cst = tree_to_double_int (low_bound);\n-\t  index_cst = tree_to_double_int (idx);\n-\t  length_cst = uhwi_to_double_int (TREE_STRING_LENGTH (ctor));\n-\t  index_cst = double_int_sub (index_cst, low_bound_cst);\n-\t  if ((TYPE_MODE (TREE_TYPE (t))\n-\t       == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n-\t      && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n-\t          == MODE_INT)\n-\t      && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor)))) == 1\n-\t      && double_int_cmp (index_cst, length_cst, signed_p) < 0)\n-\t    return build_int_cst_type (TREE_TYPE (t),\n-\t\t\t\t       (TREE_STRING_POINTER (ctor)\n-\t\t\t\t\t[double_int_to_uhwi (index_cst)]));\n-\t  return NULL_TREE;\n+\t  offset += TREE_INT_CST_LOW (ctr_offset) * BITS_PER_UNIT;\n \t}\n-\n-      /* Whoo-hoo!  I'll fold ya baby.  Yeah!  */\n-      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n-\tif (tree_int_cst_equal (cfield, idx))\n-\t  return canonicalize_constructor_val (cval);\n-      break;\n-\n-    case COMPONENT_REF:\n-      /* Get a CONSTRUCTOR.  If BASE is a VAR_DECL, get its\n-\t DECL_INITIAL.  If BASE is a nested reference into another\n-\t ARRAY_REF or COMPONENT_REF, make a recursive call to resolve\n-\t the inner reference.  */\n-      ctor = get_base_constructor (TREE_OPERAND (t, 0), &idx);\n-\n-      if (idx)\n-\treturn NULL_TREE;\n-\n-      if (ctor == error_mark_node)\n-\treturn build_zero_cst (TREE_TYPE (t));\n-\n-      if (ctor == NULL_TREE\n-\t  || TREE_CODE (ctor) != CONSTRUCTOR)\n+      /* Out of bound array access.  Value is undefined, but don't fold. */\n+      if (offset < 0)\n \treturn NULL_TREE;\n \n-      field = TREE_OPERAND (t, 1);\n-\n-      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n-\tif (cfield == field\n-\t    /* FIXME: Handle bit-fields.  */\n-\t    && ! DECL_BIT_FIELD (cfield))\n-\t  return canonicalize_constructor_val (cval);\n-      break;\n+      return fold_ctor_reference (TREE_TYPE (t), ctor, offset, size);\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -1495,73 +1695,6 @@ fold_const_aggregate_ref (tree t)\n \tbreak;\n       }\n \n-    case MEM_REF:\n-      ctor = get_base_constructor (t, &idx);\n-\n-      if (ctor == error_mark_node)\n-\treturn build_zero_cst (TREE_TYPE (t));\n-\n-      if (ctor && !AGGREGATE_TYPE_P (TREE_TYPE (ctor))\n-\t  && !idx)\n-\t{\n-\t  if (ctor\n-\t      && !useless_type_conversion_p\n-\t\t    (TREE_TYPE (t), TREE_TYPE (ctor)))\n-\t    ctor = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (t), ctor);\n-\t  return ctor;\n-\t}\n-\n-      if (!idx)\n-\tidx = integer_zero_node;\n-\n-      if (ctor == NULL_TREE\n-\t  || (TREE_CODE (ctor) != CONSTRUCTOR\n-\t      && TREE_CODE (ctor) != STRING_CST))\n-\treturn NULL_TREE;\n-\n-      /* Fold read from constant string.  */\n-      if (TREE_CODE (ctor) == STRING_CST)\n-\t{\n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t      && (TYPE_MODE (TREE_TYPE (t))\n-\t\t  == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n-\t      && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n-\t          == MODE_INT)\n-\t      && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor)))) == 1\n-\t      && compare_tree_int (idx, TREE_STRING_LENGTH (ctor)) < 0)\n-\t    return build_int_cst_type (TREE_TYPE (t),\n-\t\t\t\t       (TREE_STRING_POINTER (ctor)\n-\t\t\t\t\t[TREE_INT_CST_LOW (idx)]));\n-\t  return NULL_TREE;\n-\t}\n-\n-      /* ???  Implement byte-offset indexing into a non-array CONSTRUCTOR.  */\n-      if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE\n-\t  && (TYPE_MODE (TREE_TYPE (t))\n-\t      == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n-\t  && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (t))) != 0\n-\t  && integer_zerop\n-\t       (int_const_binop\n-\t\t  (TRUNC_MOD_EXPR, idx,\n-\t\t   size_int (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (t)))), 0)))\n-\t{\n-\t  idx = int_const_binop (TRUNC_DIV_EXPR, idx,\n-\t\t\t\t size_int (GET_MODE_SIZE\n-\t\t\t\t\t     (TYPE_MODE (TREE_TYPE (t)))), 0);\n-\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n-\t    if (tree_int_cst_equal (cfield, idx))\n-\t      {\n-\t\tcval = canonicalize_constructor_val (cval);\n-\t\tif (useless_type_conversion_p (TREE_TYPE (t), TREE_TYPE (cval)))\n-\t\t  return cval;\n-\t\telse if (CONSTANT_CLASS_P (cval))\n-\t\t  return fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (t), cval);\n-\t\telse\n-\t\t  return NULL_TREE;\n-\t      }\n-\t}\n-      break;\n-\n     default:\n       break;\n     }"}]}