{"sha": "0b83e6882437a80458a7435cf434fbdccb37fa60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI4M2U2ODgyNDM3YTgwNDU4YTc0MzVjZjQzNGZiZGNjYjM3ZmE2MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-11T17:43:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-11T17:43:44Z"}, "message": "vapool.c: Include tree-ssa-alias.h, gimple.h and lto-streamer.h\n\n\n\t* vapool.c: Include tree-ssa-alias.h, gimple.h and lto-streamer.h\n\t(varpool_get_constructor): New function.\n\t(varpool_ctor_useable_for_folding_p): Break out from ...\n\t(ctor_for_folding): ... here; use varpool_get_constructor.\n\t(varpool_assemble_decl): Likewise.\n\t* lto-streamer.h (struct output_block): Turn cgraph_node\n\tto symbol filed.\n\t(lto_input_variable_constructor): Declare.\n\t* ipa-visibility.c (function_and_variable_visibility): Use\n\tvarpool_get_constructor.\n\t* cgraph.h (varpool_get_constructor): Declare.\n\t(varpool_ctor_useable_for_folding_p): New function.\n\t* lto-streamer-out.c (get_symbol_initial_value): Take encoder\n\tparameter; return error_mark_node for non-trivial constructors.\n\t(lto_write_tree_1, DFS_write_tree): UPdate use of\n\tget_symbol_initial_value.\n\t(output_function): Update initialization of symbol.\n\t(output_constructor): New function.\n\t(copy_function): Rename to ..\n\t(copy_function_or_variable): ... this one; handle vars too.\n\t(lto_output): Output variable sections.\n\t* lto-streamer-in.c (input_constructor): New function.\n\t(lto_read_body): Rename from ...\n\t(lto_read_body_or_constructor): ... this one; handle vars\n\ttoo.\n\t(lto_input_variable_constructor): New function.\n\t* ipa-prop.c (ipa_prop_write_jump_functions,\n\tipa_prop_write_all_agg_replacement): Update.\n\t* lto-cgraph.c (compute_ltrans_boundary): Use it.\n\t(output_cgraph_opt_summary): Set symbol to NULL.\n\n\t* lto-partition.c (add_references_to_partition): Use \n\tvarpool_ctor_useable_for_folding_p.\n\t* lto.c (lto_read_in_decl_state): Update sanity check.\n\nFrom-SVN: r212467", "tree": {"sha": "559538902f5da455d349414895289f88f3911435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/559538902f5da455d349414895289f88f3911435"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b83e6882437a80458a7435cf434fbdccb37fa60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b83e6882437a80458a7435cf434fbdccb37fa60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b83e6882437a80458a7435cf434fbdccb37fa60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b83e6882437a80458a7435cf434fbdccb37fa60/comments", "author": null, "committer": null, "parents": [{"sha": "01a92e704282e69fc3ec7d817637b8074454168d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a92e704282e69fc3ec7d817637b8074454168d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01a92e704282e69fc3ec7d817637b8074454168d"}], "stats": {"total": 373, "additions": 282, "deletions": 91}, "files": [{"sha": "e0995ce5395ae8b4060d1065c527c911a54d1889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -1,3 +1,36 @@\n+2014-07-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* vapool.c: Include tree-ssa-alias.h, gimple.h and lto-streamer.h\n+\t(varpool_get_constructor): New function.\n+\t(varpool_ctor_useable_for_folding_p): Break out from ...\n+\t(ctor_for_folding): ... here; use varpool_get_constructor.\n+\t(varpool_assemble_decl): Likewise.\n+\t* lto-streamer.h (struct output_block): Turn cgraph_node\n+\tto symbol filed.\n+\t(lto_input_variable_constructor): Declare.\n+\t* ipa-visibility.c (function_and_variable_visibility): Use\n+\tvarpool_get_constructor.\n+\t* cgraph.h (varpool_get_constructor): Declare.\n+\t(varpool_ctor_useable_for_folding_p): New function.\n+\t* lto-streamer-out.c (get_symbol_initial_value): Take encoder\n+\tparameter; return error_mark_node for non-trivial constructors.\n+\t(lto_write_tree_1, DFS_write_tree): UPdate use of\n+\tget_symbol_initial_value.\n+\t(output_function): Update initialization of symbol.\n+\t(output_constructor): New function.\n+\t(copy_function): Rename to ..\n+\t(copy_function_or_variable): ... this one; handle vars too.\n+\t(lto_output): Output variable sections.\n+\t* lto-streamer-in.c (input_constructor): New function.\n+\t(lto_read_body): Rename from ...\n+\t(lto_read_body_or_constructor): ... this one; handle vars\n+\ttoo.\n+\t(lto_input_variable_constructor): New function.\n+\t* ipa-prop.c (ipa_prop_write_jump_functions,\n+\tipa_prop_write_all_agg_replacement): Update.\n+\t* lto-cgraph.c (compute_ltrans_boundary): Use it.\n+\t(output_cgraph_opt_summary): Set symbol to NULL.\n+\n 2014-07-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-prop.c (ipa_binfo_from_known_type_jfunc): In LTO do not walk"}, {"sha": "9ef7bdfe1242aeb8713e25a9318ca70fffd9e93c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -1134,6 +1134,7 @@ void varpool_analyze_node (varpool_node *);\n varpool_node * varpool_extra_name_alias (tree, tree);\n varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n+bool varpool_ctor_useable_for_folding_p (varpool_node *);\n tree ctor_for_folding (tree);\n bool varpool_for_node_and_aliases (varpool_node *,\n \t\t                   bool (*) (varpool_node *, void *),\n@@ -1142,6 +1143,7 @@ void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n void symtab_prevail_in_asm_name_hash (symtab_node *node);\n void varpool_remove_initializer (varpool_node *);\n+tree varpool_get_constructor (struct varpool_node *node);\n \n /* In cgraph.c */\n extern void change_decl_assembler_name (tree, tree);"}, {"sha": "40f696bf960999e4c314c4b1a7ecb144790cb4df", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -4848,7 +4848,7 @@ ipa_prop_write_jump_functions (void)\n \n   ob = create_output_block (LTO_section_jump_functions);\n   encoder = ob->decl_state->symtab_node_encoder;\n-  ob->cgraph_node = NULL;\n+  ob->symbol = NULL;\n   for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_function_in_partition (&lsei))\n     {\n@@ -5024,7 +5024,7 @@ ipa_prop_write_all_agg_replacement (void)\n \n   ob = create_output_block (LTO_section_ipcp_transform);\n   encoder = ob->decl_state->symtab_node_encoder;\n-  ob->cgraph_node = NULL;\n+  ob->symbol = NULL;\n   for (lsei = lsei_start_function_in_partition (encoder); !lsei_end_p (lsei);\n        lsei_next_function_in_partition (&lsei))\n     {"}, {"sha": "3fed3455b675bcd58fc1c6dc68543f75be5beab8", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -686,6 +686,8 @@ function_and_variable_visibility (bool whole_program)\n \t  if (found)\n \t    {\n \t      struct pointer_set_t *visited_nodes = pointer_set_create ();\n+\n+\t      varpool_get_constructor (vnode);\n \t      walk_tree (&DECL_INITIAL (vnode->decl),\n \t\t\t update_vtable_references, NULL, visited_nodes);\n \t      pointer_set_destroy (visited_nodes);"}, {"sha": "a1ee77b5a830c8d4c5578e50fa8af038e9ec5b83", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -867,7 +867,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\tvnode)\n-\t      && ctor_for_folding (vnode->decl) != error_mark_node)\n+\t      && varpool_ctor_useable_for_folding_p (vnode))\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n \t      add_references (encoder, vnode);\n@@ -1808,7 +1808,7 @@ output_cgraph_opt_summary (void)\n   struct output_block *ob = create_output_block (LTO_section_cgraph_opt_sum);\n   unsigned count = 0;\n \n-  ob->cgraph_node = NULL;\n+  ob->symbol = NULL;\n   encoder = ob->decl_state->symtab_node_encoder;\n   n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)"}, {"sha": "7c22183b519c97a30649787d34a207de070c3c1c", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -1029,6 +1029,15 @@ input_function (tree fn_decl, struct data_in *data_in,\n   pop_cfun ();\n }\n \n+/* Read the body of function FN_DECL from DATA_IN using input block IB.  */\n+\n+static void\n+input_constructor (tree var, struct data_in *data_in,\n+\t\t   struct lto_input_block *ib)\n+{\n+  DECL_INITIAL (var) = stream_read_tree (ib, data_in);\n+}\n+\n \n /* Read the body from DATA for function NODE and fill it in.\n    FILE_DATA are the global decls and types.  SECTION_TYPE is either\n@@ -1037,8 +1046,8 @@ input_function (tree fn_decl, struct data_in *data_in,\n    that function.  */\n \n static void\n-lto_read_body (struct lto_file_decl_data *file_data, struct cgraph_node *node,\n-\t       const char *data, enum lto_section_type section_type)\n+lto_read_body_or_constructor (struct lto_file_decl_data *file_data, struct symtab_node *node,\n+\t\t\t      const char *data, enum lto_section_type section_type)\n {\n   const struct lto_function_header *header;\n   struct data_in *data_in;\n@@ -1050,19 +1059,32 @@ lto_read_body (struct lto_file_decl_data *file_data, struct cgraph_node *node,\n   tree fn_decl = node->decl;\n \n   header = (const struct lto_function_header *) data;\n-  cfg_offset = sizeof (struct lto_function_header);\n-  main_offset = cfg_offset + header->cfg_size;\n-  string_offset = main_offset + header->main_size;\n-\n-  LTO_INIT_INPUT_BLOCK (ib_cfg,\n-\t\t        data + cfg_offset,\n-\t\t\t0,\n-\t\t\theader->cfg_size);\n+  if (TREE_CODE (node->decl) == FUNCTION_DECL)\n+    {\n+      cfg_offset = sizeof (struct lto_function_header);\n+      main_offset = cfg_offset + header->cfg_size;\n+      string_offset = main_offset + header->main_size;\n+\n+      LTO_INIT_INPUT_BLOCK (ib_cfg,\n+\t\t\t    data + cfg_offset,\n+\t\t\t    0,\n+\t\t\t    header->cfg_size);\n+\n+      LTO_INIT_INPUT_BLOCK (ib_main,\n+\t\t\t    data + main_offset,\n+\t\t\t    0,\n+\t\t\t    header->main_size);\n+    }\n+  else\n+    {\n+      main_offset = sizeof (struct lto_function_header);\n+      string_offset = main_offset + header->main_size;\n \n-  LTO_INIT_INPUT_BLOCK (ib_main,\n-\t\t\tdata + main_offset,\n-\t\t\t0,\n-\t\t\theader->main_size);\n+      LTO_INIT_INPUT_BLOCK (ib_main,\n+\t\t\t    data + main_offset,\n+\t\t\t    0,\n+\t\t\t    header->main_size);\n+    }\n \n   data_in = lto_data_in_create (file_data, data + string_offset,\n \t\t\t      header->string_size, vNULL);\n@@ -1082,7 +1104,10 @@ lto_read_body (struct lto_file_decl_data *file_data, struct cgraph_node *node,\n \n       /* Set up the struct function.  */\n       from = data_in->reader_cache->nodes.length ();\n-      input_function (fn_decl, data_in, &ib_main, &ib_cfg);\n+      if (TREE_CODE (node->decl) == FUNCTION_DECL)\n+        input_function (fn_decl, data_in, &ib_main, &ib_cfg);\n+      else\n+        input_constructor (fn_decl, data_in, &ib_main);\n       /* And fixup types we streamed locally.  */\n \t{\n \t  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n@@ -1124,7 +1149,17 @@ void\n lto_input_function_body (struct lto_file_decl_data *file_data,\n \t\t\t struct cgraph_node *node, const char *data)\n {\n-  lto_read_body (file_data, node, data, LTO_section_function_body);\n+  lto_read_body_or_constructor (file_data, node, data, LTO_section_function_body);\n+}\n+\n+/* Read the body of NODE using DATA.  FILE_DATA holds the global\n+   decls and types.  */\n+\n+void\n+lto_input_variable_constructor (struct lto_file_decl_data *file_data,\n+\t\t\t\tstruct varpool_node *node, const char *data)\n+{\n+  lto_read_body_or_constructor (file_data, node, data, LTO_section_function_body);\n }\n \n "}, {"sha": "4a94fcda1853eba0236819d9e32d5c8690f69522", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -318,7 +318,7 @@ lto_is_streamable (tree expr)\n /* For EXPR lookup and return what we want to stream to OB as DECL_INITIAL.  */\n \n static tree\n-get_symbol_initial_value (struct output_block *ob, tree expr)\n+get_symbol_initial_value (lto_symtab_encoder_t encoder, tree expr)\n {\n   gcc_checking_assert (DECL_P (expr)\n \t\t       && TREE_CODE (expr) != FUNCTION_DECL\n@@ -331,15 +331,13 @@ get_symbol_initial_value (struct output_block *ob, tree expr)\n       && !DECL_IN_CONSTANT_POOL (expr)\n       && initial)\n     {\n-      lto_symtab_encoder_t encoder;\n       varpool_node *vnode;\n-\n-      encoder = ob->decl_state->symtab_node_encoder;\n-      vnode = varpool_get_node (expr);\n-      if (!vnode\n-\t  || !lto_symtab_encoder_encode_initializer_p (encoder,\n-\t\t\t\t\t\t       vnode))\n-\tinitial = error_mark_node;\n+      /* Extra section needs about 30 bytes; do not produce it for simple\n+\t scalar values.  */\n+      if (TREE_CODE (DECL_INITIAL (expr)) == CONSTRUCTOR\n+\t  || !(vnode = varpool_get_node (expr))\n+\t  || !lto_symtab_encoder_encode_initializer_p (encoder, vnode))\n+        initial = error_mark_node;\n     }\n \n   return initial;\n@@ -369,7 +367,8 @@ lto_write_tree_1 (struct output_block *ob, tree expr, bool ref_p)\n       && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n     {\n       /* Handle DECL_INITIAL for symbols.  */\n-      tree initial = get_symbol_initial_value (ob, expr);\n+      tree initial = get_symbol_initial_value\n+\t\t\t (ob->decl_state->symtab_node_encoder, expr);\n       stream_write_tree (ob, initial, ref_p);\n     }\n }\n@@ -1195,7 +1194,8 @@ DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n \t    {\n \t      /* Handle DECL_INITIAL for symbols.  */\n-\t      tree initial = get_symbol_initial_value (ob, expr);\n+\t      tree initial = get_symbol_initial_value (ob->decl_state->symtab_node_encoder,\n+\t\t\t\t\t\t       expr);\n \t      DFS_write_tree (ob, cstate, initial, ref_p, ref_p);\n \t    }\n \t}\n@@ -1808,7 +1808,7 @@ output_function (struct cgraph_node *node)\n   ob = create_output_block (LTO_section_function_body);\n \n   clear_line_info (ob);\n-  ob->cgraph_node = node;\n+  ob->symbol = node;\n \n   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n \n@@ -1899,6 +1899,32 @@ output_function (struct cgraph_node *node)\n   destroy_output_block (ob);\n }\n \n+/* Output the body of function NODE->DECL.  */\n+\n+static void\n+output_constructor (struct varpool_node *node)\n+{\n+  tree var = node->decl;\n+  struct output_block *ob;\n+\n+  ob = create_output_block (LTO_section_function_body);\n+\n+  clear_line_info (ob);\n+  ob->symbol = node;\n+\n+  /* Make string 0 be a NULL string.  */\n+  streamer_write_char_stream (ob->string_stream, 0);\n+\n+  /* Output DECL_INITIAL for the function, which contains the tree of\n+     lexical scopes.  */\n+  stream_write_tree (ob, DECL_INITIAL (var), true);\n+\n+  /* Create a section to hold the pickled output of this function.   */\n+  produce_asm (ob, var);\n+\n+  destroy_output_block (ob);\n+}\n+\n \n /* Emit toplevel asms.  */\n \n@@ -1957,10 +1983,10 @@ lto_output_toplevel_asms (void)\n }\n \n \n-/* Copy the function body of NODE without deserializing. */\n+/* Copy the function body or variable constructor of NODE without deserializing. */\n \n static void\n-copy_function (struct cgraph_node *node)\n+copy_function_or_variable (struct symtab_node *node)\n {\n   tree function = node->decl;\n   struct lto_file_decl_data *file_data = node->lto_file_data;\n@@ -2072,7 +2098,7 @@ lto_output (void)\n \t      if (gimple_has_body_p (node->decl) || !flag_wpa)\n \t\toutput_function (node);\n \t      else\n-\t\tcopy_function (node);\n+\t\tcopy_function_or_variable (node);\n \t      gcc_assert (lto_get_out_decl_state () == decl_state);\n \t      lto_pop_out_decl_state ();\n \t      lto_record_function_out_decl_state (node->decl, decl_state);\n@@ -2085,6 +2111,25 @@ lto_output (void)\n \t  tree ctor = DECL_INITIAL (node->decl);\n \t  if (ctor && !in_lto_p)\n \t    walk_tree (&ctor, wrap_refs, NULL, NULL);\n+\t  if (get_symbol_initial_value (encoder, node->decl) == error_mark_node\n+\t      && lto_symtab_encoder_encode_initializer_p (encoder, node)\n+\t      && !node->alias)\n+\t    {\n+#ifdef ENABLE_CHECKING\n+\t      gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n+\t      bitmap_set_bit (output, DECL_UID (node->decl));\n+#endif\n+\t      decl_state = lto_new_out_decl_state ();\n+\t      lto_push_out_decl_state (decl_state);\n+\t      if (DECL_INITIAL (node->decl) != error_mark_node\n+\t\t  || !flag_wpa)\n+\t\toutput_constructor (node);\n+\t      else\n+\t\tcopy_function_or_variable (node);\n+\t      gcc_assert (lto_get_out_decl_state () == decl_state);\n+\t      lto_pop_out_decl_state ();\n+\t      lto_record_function_out_decl_state (node->decl, decl_state);\n+\t    }\n \t}\n     }\n "}, {"sha": "c6cf72c1ad395d739ef3366aa3e31796fb438fd4", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -685,9 +685,9 @@ struct output_block\n      far and the indexes assigned to them.  */\n   hash_table<string_slot_hasher> *string_hash_table;\n \n-  /* The current cgraph_node that we are currently serializing.  Null\n+  /* The current symbol that we are currently serializing.  Null\n      if we are serializing something else.  */\n-  struct cgraph_node *cgraph_node;\n+  struct symtab_node *symbol;\n \n   /* These are the last file and line that were seen in the stream.\n      If the current node differs from these, it needs to insert\n@@ -830,6 +830,9 @@ extern void lto_reader_init (void);\n extern void lto_input_function_body (struct lto_file_decl_data *,\n \t\t\t\t     struct cgraph_node *,\n \t\t\t\t     const char *);\n+extern void lto_input_variable_constructor (struct lto_file_decl_data *,\n+\t\t\t\t\t    struct varpool_node *,\n+\t\t\t\t\t    const char *);\n extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n \t\t\t\t\t      const char *);\n extern void lto_input_toplevel_asms (struct lto_file_decl_data *, int);"}, {"sha": "ec78b2aa4e9bd27985e48355cc496bfb3109ce5f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -1,3 +1,9 @@\n+2014-07-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-partition.c (add_references_to_partition): Use \n+\tvarpool_ctor_useable_for_folding_p.\n+\t* lto.c (lto_read_in_decl_state): Update sanity check.\n+\n 2014-07-01  Martin Liska  <mliska@suse.cz>\n \n \tIPA REF alias refactoring"}, {"sha": "5f2903535004b354b63a181ab513701ee531228f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -96,7 +96,7 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node *> (ref->referred)\n-\t     && ctor_for_folding (ref->referred->decl) != error_mark_node\n+\t     && varpool_ctor_useable_for_folding_p (varpool (ref->referred))\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)"}, {"sha": "cdf8a7218d67ab1449e687f3435041516de9389b", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -236,7 +236,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n \n   ix = *data++;\n   decl = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       gcc_assert (decl == void_type_node);\n       decl = NULL_TREE;"}, {"sha": "2b379ccac38530a17f8c5f6e6720b438d17bdcaa", "filename": "gcc/varpool.c", "status": "modified", "additions": 117, "deletions": 52, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b83e6882437a80458a7435cf434fbdccb37fa60/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=0b83e6882437a80458a7435cf434fbdccb37fa60", "patch": "@@ -35,6 +35,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"flags.h\"\n #include \"pointer-set.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"gimple.h\"\n+#include \"lto-streamer.h\"\n \n const char * const tls_model_names[]={\"none\", \"tls-emulated\", \"tls-real\",\n \t\t\t\t      \"tls-global-dynamic\", \"tls-local-dynamic\",\n@@ -163,19 +166,17 @@ varpool_node_for_decl (tree decl)\n void\n varpool_remove_node (varpool_node *node)\n {\n-  tree init;\n   varpool_call_node_removal_hooks (node);\n   symtab_unregister_node (node);\n \n-  /* Because we remove references from external functions before final compilation,\n-     we may end up removing useful constructors.\n-     FIXME: We probably want to trace boundaries better.  */\n+  /* When streaming we can have multiple nodes associated with decl.  */\n   if (cgraph_state == CGRAPH_LTO_STREAMING)\n     ;\n-  else if ((init = ctor_for_folding (node->decl)) == error_mark_node)\n+  /* Keep constructor when it may be used for folding. We remove\n+     references to external variables before final compilation.  */\n+  else if (DECL_INITIAL (node->decl) && DECL_INITIAL (node->decl) != error_mark_node\n+\t   && !varpool_ctor_useable_for_folding_p (node))\n     varpool_remove_initializer (node);\n-  else\n-    DECL_INITIAL (node->decl) = init;\n   ggc_free (node);\n }\n \n@@ -215,7 +216,7 @@ dump_varpool_node (FILE *f, varpool_node *node)\n     fprintf (f, \" used-by-single-function\");\n   if (TREE_READONLY (node->decl))\n     fprintf (f, \" read-only\");\n-  if (ctor_for_folding (node->decl) != error_mark_node)\n+  if (varpool_ctor_useable_for_folding_p (node))\n     fprintf (f, \" const-value-known\");\n   if (node->writeonly)\n     fprintf (f, \" write-only\");\n@@ -253,9 +254,101 @@ varpool_node_for_asm (tree asmname)\n     return NULL;\n }\n \n-/* Return if DECL is constant and its initial value is known (so we can do\n-   constant folding using DECL_INITIAL (decl)).\n-   Return ERROR_MARK_NODE when value is unknown.  */\n+/* When doing LTO, read NODE's constructor from disk if it is not already present.  */\n+\n+tree\n+varpool_get_constructor (struct varpool_node *node)\n+{\n+  struct lto_file_decl_data *file_data;\n+  const char *data, *name;\n+  size_t len;\n+  tree decl = node->decl;\n+\n+  if (DECL_INITIAL (node->decl) != error_mark_node\n+      || !in_lto_p)\n+    return DECL_INITIAL (node->decl);\n+\n+  file_data = node->lto_file_data;\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+\n+  /* We may have renamed the declaration, e.g., a static function.  */\n+  name = lto_get_decl_name_mapping (file_data, name);\n+\n+  data = lto_get_section_data (file_data, LTO_section_function_body,\n+\t\t\t       name, &len);\n+  if (!data)\n+    fatal_error (\"%s: section %s is missing\",\n+\t\t file_data->file_name,\n+\t\t name);\n+\n+  lto_input_variable_constructor (file_data, node, data);\n+  lto_stats.num_function_bodies++;\n+  lto_free_section_data (file_data, LTO_section_function_body, name,\n+\t\t\t data, len);\n+  lto_free_function_in_decl_state_for_node (node);\n+  return DECL_INITIAL (node->decl);\n+}\n+\n+/* Return ture if NODE has constructor that can be used for folding.  */\n+\n+bool\n+varpool_ctor_useable_for_folding_p (varpool_node *node)\n+{\n+  varpool_node *real_node = node;\n+\n+  if (real_node->alias && real_node->definition)\n+    real_node = varpool_variable_node (node);\n+\n+  if (TREE_CODE (node->decl) == CONST_DECL\n+      || DECL_IN_CONSTANT_POOL (node->decl))\n+    return true;\n+  if (TREE_THIS_VOLATILE (node->decl))\n+    return false;\n+\n+  /* If we do not have a constructor, we can't use it.  */\n+  if (DECL_INITIAL (real_node->decl) == error_mark_node\n+      && !real_node->lto_file_data)\n+    return false;\n+\n+  /* Vtables are defined by their types and must match no matter of interposition\n+     rules.  */\n+  if (DECL_VIRTUAL_P (node->decl))\n+    {\n+      /* The C++ front end creates VAR_DECLs for vtables of typeinfo\n+\t classes not defined in the current TU so that it can refer\n+\t to them from typeinfo objects.  Avoid returning NULL_TREE.  */\n+      return DECL_INITIAL (real_node->decl) != NULL;\n+    }\n+\n+  /* Alias of readonly variable is also readonly, since the variable is stored\n+     in readonly memory.  We also accept readonly aliases of non-readonly\n+     locations assuming that user knows what he is asking for.  */\n+  if (!TREE_READONLY (node->decl) && !TREE_READONLY (real_node->decl))\n+    return false;\n+\n+  /* Variables declared 'const' without an initializer\n+     have zero as the initializer if they may not be\n+     overridden at link or run time.  */\n+  if (!DECL_INITIAL (real_node->decl)\n+      && (DECL_EXTERNAL (node->decl) || decl_replaceable_p (node->decl)))\n+    return false;\n+\n+  /* Variables declared `const' with an initializer are considered\n+     to not be overwritable with different initializer by default. \n+\n+     ??? Previously we behaved so for scalar variables but not for array\n+     accesses.  */\n+  return true;\n+}\n+\n+/* If DECL is constant variable and its initial value is known (so we can\n+   do constant folding), return its constructor (DECL_INITIAL). This may\n+   be an expression or NULL when DECL is initialized to 0.\n+   Return ERROR_MARK_NODE otherwise.\n+\n+   In LTO this may actually trigger reading the constructor from disk.\n+   For this reason varpool_ctor_useable_for_folding_p should be used when\n+   the actual constructor value is not needed.  */\n \n tree\n ctor_for_folding (tree decl)\n@@ -284,7 +377,7 @@ ctor_for_folding (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n-  node = varpool_get_node (decl);\n+  real_node = node = varpool_get_node (decl);\n   if (node)\n     {\n       real_node = varpool_variable_node (node);\n@@ -302,54 +395,25 @@ ctor_for_folding (tree decl)\n     {\n       gcc_assert (!DECL_INITIAL (decl)\n \t\t  || DECL_INITIAL (decl) == error_mark_node);\n-      if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+      if (node->weakref)\n \t{\n \t  node = varpool_alias_target (node);\n \t  decl = node->decl;\n \t}\n     }\n \n-  /* Vtables are defined by their types and must match no matter of interposition\n-     rules.  */\n-  if (DECL_VIRTUAL_P (real_decl))\n-    {\n-      gcc_checking_assert (TREE_READONLY (real_decl));\n-      if (DECL_INITIAL (real_decl))\n-\treturn DECL_INITIAL (real_decl);\n-      else\n-\t{\n-\t  /* The C++ front end creates VAR_DECLs for vtables of typeinfo\n-\t     classes not defined in the current TU so that it can refer\n-\t     to them from typeinfo objects.  Avoid returning NULL_TREE.  */\n-\t  gcc_checking_assert (!COMPLETE_TYPE_P (DECL_CONTEXT (real_decl)));\n-\t  return error_mark_node;\n-\t}\n-    }\n-\n-  /* If there is no constructor, we have nothing to do.  */\n-  if (DECL_INITIAL (real_decl) == error_mark_node)\n-    return error_mark_node;\n-\n-  /* Non-readonly alias of readonly variable is also de-facto readonly,\n-     because the variable itself is in readonly section.  \n-     We also honnor READONLY flag on alias assuming that user knows\n-     what he is doing.  */\n-  if (!TREE_READONLY (decl) && !TREE_READONLY (real_decl))\n-    return error_mark_node;\n-\n-  /* Variables declared 'const' without an initializer\n-     have zero as the initializer if they may not be\n-     overridden at link or run time.  */\n-  if (!DECL_INITIAL (real_decl)\n-      && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))\n+  if ((!DECL_VIRTUAL_P (real_decl)\n+       || DECL_INITIAL (real_decl) == error_mark_node\n+       || !DECL_INITIAL (real_decl))\n+      && (!node || !varpool_ctor_useable_for_folding_p (node)))\n     return error_mark_node;\n \n-  /* Variables declared `const' with an initializer are considered\n-     to not be overwritable with different initializer by default. \n-\n-     ??? Previously we behaved so for scalar variables but not for array\n-     accesses.  */\n-  return DECL_INITIAL (real_decl);\n+  /* OK, we can return constructor.  See if we need to fetch it from disk\n+     in LTO mode.  */\n+  if (DECL_INITIAL (real_decl) != error_mark_node\n+      || !in_lto_p)\n+    return DECL_INITIAL (real_decl);\n+  return varpool_get_constructor (real_node);\n }\n \n /* Add the variable DECL to the varpool.\n@@ -471,6 +535,7 @@ varpool_assemble_decl (varpool_node *node)\n   if (!node->in_other_partition\n       && !DECL_EXTERNAL (decl))\n     {\n+      varpool_get_constructor (node);\n       assemble_variable (decl, 0, 1, 0);\n       gcc_assert (TREE_ASM_WRITTEN (decl));\n       node->definition = true;"}]}