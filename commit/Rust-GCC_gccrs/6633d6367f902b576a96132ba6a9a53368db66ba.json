{"sha": "6633d6367f902b576a96132ba6a9a53368db66ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYzM2Q2MzY3ZjkwMmI1NzZhOTYxMzJiYTZhOWE1MzM2OGRiNjZiYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-06-18T02:25:37Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-06-18T02:25:37Z"}, "message": "91th Cygnus<->FSF quick merge\n\nFrom-SVN: r14253", "tree": {"sha": "152e0eb4f4c266090db073465be889164cf6feb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/152e0eb4f4c266090db073465be889164cf6feb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6633d6367f902b576a96132ba6a9a53368db66ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6633d6367f902b576a96132ba6a9a53368db66ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6633d6367f902b576a96132ba6a9a53368db66ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6633d6367f902b576a96132ba6a9a53368db66ba/comments", "author": null, "committer": null, "parents": [{"sha": "59ba1a3a6014045a93643db0ab65c10d3692947d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ba1a3a6014045a93643db0ab65c10d3692947d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ba1a3a6014045a93643db0ab65c10d3692947d"}], "stats": {"total": 686, "additions": 495, "deletions": 191}, "files": [{"sha": "115c4d2204b7c597207fced00db2df7e3767b81f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -1,3 +1,125 @@\n+Tue Jun 17 18:35:57 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_builtin_throw): Add support\n+ \t-fno-sjlj-exceptions -fPIC exception handling on the SPARC.\n+\n+Mon Jun 16 01:24:37 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* repo.c (extract_string): Null-terminate.\n+\n+\t* cp-tree.h (TI_SPEC_INFO): New macro.\n+\t(CLASSTYPE_TI_SPEC_INFO): New macro.\n+\t* pt.c (push_template_decl): Correctly determine # of template parms \n+\tfor partial specs.\n+\n+\t* call.c (compare_ics): Really fix 'this' conversions.\n+\n+\t* pt.c (do_decl_instantiation): Don't crash on explicit inst of\n+\tnon-template fn.\n+\n+\t* pt.c (push_template_decl): Complain about mismatch in # of\n+ \ttemplate parms between a class template and a member template.\n+\n+Sun Jun 15 02:38:20 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (synthesize_method): You can't call\n+ \tfunction_cannot_inline_p after finish_function.\n+\t* decl.c (finish_function): Turn on flag_inline_functions and turn\n+ \toff DECL_INLINE before handing a synthesized method to the\n+ \tbackend.\n+\n+Thu Jun 12 17:35:28 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (synthesize_method): Remove July 30 change to never set\n+ \tDECL_INLINE if at_eof.\n+\n+Thu Jun 12 15:25:08 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* xref.c (GNU_xref_member): Ensure that the node has a\n+\tdecl_lang_specific part before checking DECL_FRIEND_P.\n+\n+Thu Jun 12 12:36:05 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Diagnose non-class types used\n+\tas bases.\n+\n+Wed Jun 11 17:33:40 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_conditional_expr): Use convert_for_initialization\n+\tinstead of convert_and_check.\n+\n+Wed Jun 11 12:31:33 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (typespec): Don't pedwarn for typeof.\n+\n+Tue Jun 10 00:22:09 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* repo.c (finish_repo): Only check changes if we would write a\n+\trepo file.\n+\n+\t* call.c (compare_ics): Fix handling of 'this' conversions.\n+\n+\t* pt.c (do_decl_instantiation): Support static data too.  Rename\n+\tfrom do_function_instantiation.\n+\t* cp-tree.h: Adjust.\n+\t* parse.y: Adjust.\n+\n+\t* repo.c (extract_string): New fn.\n+\t(get_base_filename): Use it.\n+\t(init_repo): Compare old args with current args.\n+\n+Mon Jun  9 14:25:30 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* Makefile.in, Make-lang.in: Protect C-ls with a comment\n+ \tcharacter, idea from Paul Eggert <eggert@twinsun.com>.\n+\n+Mon Jun  9 01:52:03 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Be more persistent in looking for\n+ \treturned temps.\n+\n+\t* cvt.c (build_up_reference): Use NOP_EXPR for switching from\n+ \tpointer to reference.\n+\n+\t* class.c (build_vbase_path): Don't do anything if PATH has no steps.\n+\n+Sun Jun  8 03:07:05 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_member_call, build_offset_ref):\n+ \tUse do_scoped_id instead of do_identifier.\n+\n+\t* cvt.c (convert): Remove bogosity.\n+\n+Sat Jun  7 20:50:17 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Do checks of ARGTYPE and\n+\tTARGET_TYPE before trying to use get_binfo.\n+\n+Fri Jun  6 17:36:39 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Call get_binfo to get access control.\n+\n+\t* decl2.c (import_export_decl): If we don't support weaks, leave\n+ \tstatics undefined.\n+\n+Fri Jun  6 15:55:49 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_builtin_throw): Add support for machines that\n+ \tcannot access globals after throw's epilogue when\n+ \t-fno-sjlj-exceptions is used.\n+\n+Thu Jun  5 16:28:43 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y: 'std::' becomes '::'.\n+\t* lex.c (real_yylex): Remove 'namespace' warning.\n+\t* init.c (build_member_call): Ignore 'std::'.\n+\t(build_offset_ref): Likewise.\n+\t* decl2.c (do_using_directive): Ignore 'using namespace std;'.\n+\t(do_toplevel_using_decl): Ignore 'using std::whatever'.\n+\t* decl.c (push_namespace): Just sorry.\n+\t(pop_namespace): Nop.\n+\t(init_decl_processing): Declare std namespace.\n+\n Tue Jun  3 18:08:23 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* search.c (push_class_decls): A name which ambiguously refers to"}, {"sha": "4890a9476e8d39f9f410e74c99d48aa2042719e4", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -35,7 +35,7 @@\n # - making any compiler driver (eg: g++)\n # - the compiler proper (eg: cc1plus)\n # - define the names for selecting the language in LANGUAGES.\n-\f\n+#\f\n # Extra flags to pass to recursive makes.\n CXX_FLAGS_TO_PASS = \\\n \t\"CXX_FOR_BUILD=$(CXX_FOR_BUILD)\" \\\n@@ -62,7 +62,7 @@ CXX_LIB2FUNCS = tinfo.o tinfo2.o new.o new1.o new2.o exception.o\n CXX_LIB2SRCS = $(srcdir)/cp/new.cc $(srcdir)/cp/new1.cc $(srcdir)/cp/new2.cc \\\n \t$(srcdir)/cp/exception.cc $(srcdir)/cp/tinfo.cc \\\n \t$(srcdir)/cp/tinfo2.cc $(srcdir)/cp/tinfo.h\n-\f\n+#\f\n # Define the names for selecting c++ in LANGUAGES.\n # Note that it would be nice to move the dependency on g++\n # into the C++ rule, but that needs a little bit of work\n@@ -124,7 +124,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n \n cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus\n-\f\n+#\f\n # Build hooks:\n \n c++.all.build: g++$(exeext) $(DEMANGLER_PROG)\n@@ -181,7 +181,7 @@ cplib2.ready: $(GCC_PASSES) $(LIBGCC2_DEPS) stmp-int-hdrs\n \t@if [ -f cplib2.ready ]; then true; else \\\n \t  touch cplib2.ready; \\\n \tfi\n-\f\n+#\f\n # Install hooks:\n # cc1plus is installed elsewhere as part of $(COMPILERS).\n \n@@ -233,7 +233,7 @@ c++.uninstall:\n \t-rm -rf $(bindir)/$(GXX_CROSS_NAME)$(exeext)\n \t-rm -rf $(mandir)/$(GXX_INSTALL_NAME)$(manext)\n \t-rm -rf $(mandir)/$(GXX_CROSS_NAME)$(manext)\n-\f\n+#\f\n # Clean hooks:\n # A lot of the ancillary files are deleted by the main makefile.\n # We just have to delete files specific to us.\n@@ -248,7 +248,7 @@ c++.distclean:\n c++.extraclean:\n c++.maintainer-clean:\n \t-rm -f cp/parse.c cp/parse.h\n-\f\n+#\f\n # Stage hooks:\n # The main makefile has already created stage?/cp.\n \n@@ -260,7 +260,7 @@ c++.stage3: stage3-start\n \t-mv cp/*$(objext) stage3/cp\n c++.stage4: stage4-start\n \t-mv cp/*$(objext) stage4/cp\n-\f\n+#\f\n # Maintenance hooks:\n \n # This target creates the files that can be rebuilt, but go in the"}, {"sha": "9a7bb0b3412518cadc2d20438891922fb3c88f6f", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -116,7 +116,7 @@ all: all.indirect\n ####host overrides\n ####cross overrides\n ####build overrides\n-\f\n+#\f\n # Now figure out from those variables how to compile and link.\n \n all.indirect: Makefile ../cc1plus\n@@ -153,7 +153,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n # This tells GNU make version 3 not to export all the variables\n # defined in this file into the environment.\n .NOEXPORT:\n-\f\n+#\f\n # Lists of files for various purposes.\n \n # Language-specific object files for g++\n@@ -175,7 +175,7 @@ Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n \tcd ..; $(SHELL) config.status\n \n native: config.status ../cc1plus\n-\f\n+#\f\n # Compiling object files from source files.\n \n # Note that dependencies on obstack.h are not written\n@@ -248,7 +248,7 @@ error.o : error.c $(CONFIG_H) $(CXX_TREE_H)\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H)\n sig.o : sig.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H)\n-\f\n+#\f\n # These exist for maintenance purposes.\n \n # Update the tags table."}, {"sha": "39bd13eb8445ed8a2137375849001809a1fdf3b3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -5452,15 +5452,23 @@ compare_ics (ics1, ics2)\n      they were REF_BINDs.  */\n   if (ICS_THIS_FLAG (ics1))\n     {\n-      ics1 = build_conv (REF_BIND, TREE_TYPE (ics1), main1);\n-      TREE_OPERAND (ics1, 0) = TREE_OPERAND (main1, 0);\n-      main1 = ics1;\n+      tree t = main1;\n+      if (TREE_CODE (t) == PTR_CONV)\n+\tt = TREE_OPERAND (t, 0);\n+      t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n+      t = build_conv (REF_BIND, TREE_TYPE (ics1), t);\n+      ICS_STD_RANK (t) = ICS_STD_RANK (main1);\n+      main1 = ics1 = t;\n     }\n   if (ICS_THIS_FLAG (ics2))\n     {\n-      ics2 = build_conv (REF_BIND, TREE_TYPE (ics2), main2);\n-      TREE_OPERAND (ics2, 0) = TREE_OPERAND (main2, 0);\n-      main2 = ics2;\n+      tree t = main2;\n+      if (TREE_CODE (t) == PTR_CONV)\n+\tt = TREE_OPERAND (t, 0);\n+      t = build1 (IDENTITY_CONV, TREE_TYPE (TREE_TYPE (t)), NULL_TREE);\n+      t = build_conv (REF_BIND, TREE_TYPE (ics2), t);\n+      ICS_STD_RANK (t) = ICS_STD_RANK (main2);\n+      main2 = ics2 = t;\n     }\n \n   if (ICS_RANK (ics1) > ICS_RANK (ics2))"}, {"sha": "0dee0fd96901c30bfd90c991f68a6de644133720", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -196,21 +196,28 @@ build_vbase_path (code, type, expr, path, alias_this)\n   register int changed = 0;\n   tree last = NULL_TREE, last_virtual = NULL_TREE;\n   int nonnull = 0;\n-  int fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n+  int fixed_type_p;\n   tree null_expr = 0, nonnull_expr;\n   tree basetype;\n   tree offset = integer_zero_node;\n \n+  if (BINFO_INHERITANCE_CHAIN (path) == NULL_TREE)\n+    return build1 (NOP_EXPR, type, expr);\n+\n   if (nonnull == 0 && (alias_this && flag_this_is_variable <= 0))\n     nonnull = 1;\n \n+#if 0\n   /* We need additional logic to convert back to the unconverted type\n      (the static type of the complete object), and then convert back\n      to the type we want.  Until that is done, or until we can\n      recognize when that is, we cannot do the short cut logic. (mrs) */\n+  fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n+#else\n   /* Do this, until we can undo any previous conversions.  See net35.C\n      for a testcase.  */\n   fixed_type_p = complete_type_p (expr);\n+#endif\n \n   if (!fixed_type_p && TREE_SIDE_EFFECTS (expr))\n     expr = save_expr (expr);"}, {"sha": "70fc15081d4b02ea67be30122d06acf6689ad30c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -1078,12 +1078,14 @@ struct lang_decl\n #define CLASSTYPE_TEMPLATE_INFO(NODE) (TYPE_LANG_SPECIFIC(NODE)->template_info)\n #define TI_TEMPLATE(NODE) (TREE_PURPOSE (NODE))\n #define TI_ARGS(NODE) (TREE_VALUE (NODE))\n+#define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n #define TI_USES_TEMPLATE_PARMS(NODE) TREE_LANG_FLAG_0 (NODE)\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n #define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_ARGS(NODE)     TI_ARGS (CLASSTYPE_TEMPLATE_INFO (NODE))\n+#define CLASSTYPE_TI_SPEC_INFO(NODE) TI_SPEC_INFO (CLASSTYPE_TEMPLATE_INFO (NODE))\n \n #define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -1515,6 +1517,7 @@ extern tree opaque_type_node, signature_type_node;\n /* Array type `(void *)[]' */\n extern tree vtbl_type_node;\n extern tree delta_type_node;\n+extern tree std_node;\n \n extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n /* For building calls to `delete'.  */\n@@ -2295,7 +2298,7 @@ struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree));\n extern void mark_class_instantiated\t\tPROTO((tree, int));\n-extern void do_function_instantiation\t\tPROTO((tree, tree, tree));\n+extern void do_decl_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));"}, {"sha": "8dbbf4ad9e5e5c5adc9dcc2c9731a3c0bc416d7e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -407,12 +407,23 @@ build_up_reference (type, arg, flags, checkconst)\n      address, transform all occurrences of the register, into a memory\n      reference we could win better.  */\n   rval = build_unary_op (ADDR_EXPR, arg, 1);\n-  if (flags & LOOKUP_PROTECT)\n-    rval = convert_pointer_to (target_type, rval);\n+  if ((flags & LOOKUP_PROTECT)\n+      && TYPE_MAIN_VARIANT (argtype) != TYPE_MAIN_VARIANT (target_type)\n+      && IS_AGGR_TYPE (argtype)\n+      && IS_AGGR_TYPE (target_type))\n+    {\n+      /* We go through get_binfo for the access control.  */\n+      tree binfo = get_binfo (target_type, argtype, 1);\n+      if (binfo == error_mark_node)\n+\treturn error_mark_node;\n+      if (binfo == NULL_TREE)\n+\treturn error_not_base_type (target_type, argtype);\n+      rval = convert_pointer_to_real (binfo, rval);\n+    }\n   else\n     rval\n       = convert_to_pointer_force (build_pointer_type (target_type), rval);\n-  rval = build1 (CONVERT_EXPR, type, rval);\n+  rval = build1 (NOP_EXPR, type, rval);\n   TREE_CONSTANT (rval) = TREE_CONSTANT (TREE_OPERAND (rval, 0));\n   return rval;\n }\n@@ -1189,49 +1200,9 @@ convert (type, expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_TYPE (expr) == type)\n-    return expr;\n-\n-  if (TREE_CODE (type) != REFERENCE_TYPE)\n-    {\n-      expr = decay_conversion (expr);\n-\n-      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-      if (TREE_CODE (expr) == NOP_EXPR\n-\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\texpr = TREE_OPERAND (expr, 0);\n-    }\n-\n   intype = TREE_TYPE (expr);\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      expr = build_unary_op (ADDR_EXPR, expr, 0);\n-      if (expr != error_mark_node)\n-\texpr = convert (build_pointer_type (TREE_TYPE (type)), expr);\n-      if (expr != error_mark_node)\n-\texpr = build_indirect_ref (expr, 0);\n-      return expr;\n-    }\n-  else if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n-    return build_static_cast (type, expr);\n-\n-  if (TYPE_PTR_P (type) && (TREE_CODE (intype) == INTEGER_TYPE\n-\t\t\t    || TREE_CODE (intype) == ENUMERAL_TYPE))\n-    /* OK */;\n-  else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n-    {\n-    }\n-  else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n-\t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n-    {\n-      if (TREE_READONLY_DECL_P (expr))\n-\texpr = decl_constant_value (expr);\n-      return fold (build1 (NOP_EXPR, type, expr));\n-    }\n-  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n-\t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n+  if (POINTER_TYPE_P (type) && POINTER_TYPE_P (intype))\n     {\n       if (TREE_READONLY_DECL_P (expr))\n \texpr = decl_constant_value (expr);"}, {"sha": "5a5978c727f44f70d1e265fc8647df20375755b1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -263,6 +263,9 @@ tree sigtable_entry_type;\n /* Array type `vtable_entry_type[]' */\n tree vtbl_type_node;\n \n+/* namespace std */\n+tree std_node;\n+\n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n \n@@ -1675,6 +1678,13 @@ void\n push_namespace (name)\n      tree name;\n {\n+#if 1\n+  static int warned;\n+  if (! warned)\n+    sorry (\"namespace\");\n+  \n+  warned = 1;\n+#else\n   extern tree current_namespace;\n   tree old_id = get_namespace_id ();\n   char *buf;\n@@ -1711,13 +1721,15 @@ push_namespace (name)\n   sprintf (buf, \"%s%s\", old_id ? IDENTIFIER_POINTER (old_id) : \"\",\n \t   IDENTIFIER_POINTER (name));\n   TREE_PURPOSE (current_namespace) = get_identifier (buf);\n+#endif\n }\n \n /* Pop from the scope of the current namespace.  */\n \n void\n pop_namespace ()\n {\n+#if 0\n   extern tree current_namespace;\n   tree decls, link;\n   current_namespace = TREE_CHAIN (current_namespace);\n@@ -1761,6 +1773,7 @@ pop_namespace ()\n \n   /* suspend a level.  */\n   suspend_binding_level ();\n+#endif\n }\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n@@ -5289,6 +5302,10 @@ init_decl_processing ()\n       record_builtin_type (RID_MAX, SIGTABLE_PTR_TYPE, sigtable_entry_type);\n     }\n \n+  std_node = build_decl (NAMESPACE_DECL, get_identifier (\"std\"),\n+\t\t\t void_type_node);\n+  pushdecl (std_node);\n+\n #if 0\n   if (flag_rtti)\n     {\n@@ -12030,8 +12047,25 @@ finish_function (lineno, call_poplevel, nested)\n       /* So we can tell if jump_optimize sets it to 1.  */\n       can_reach_end = 0;\n \n-      /* Run the optimizers and output the assembler code for this function.  */\n-      rest_of_compilation (fndecl);\n+      /* Run the optimizers and output the assembler code for this\n+         function.  */\n+\n+      if (DECL_ARTIFICIAL (fndecl))\n+\t{\n+\t  /* Do we really *want* to inline this synthesized method?  */\n+\n+\t  int save_fif = flag_inline_functions;\n+\t  flag_inline_functions = 1;\n+\n+\t  /* Turn off DECL_INLINE for the moment so function_cannot_inline_p\n+\t     will check our size.  */\n+\t  DECL_INLINE (fndecl) = 0;\n+\n+\t  rest_of_compilation (fndecl);\n+\t  flag_inline_functions = save_fif;\n+\t}\n+      else\n+\trest_of_compilation (fndecl);\n \n       if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n \t{"}, {"sha": "229a656f26078ffeabc3dd8de97bd87ae079ff82", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -2616,7 +2616,10 @@ import_export_decl (decl)\n                  supported.  */\n \t      if (flag_weak)\n \t\tmake_decl_one_only (decl);\n-\t      /* else leave vars public so multiple defs will break.  */\n+\t      else\n+\t\t/* we can't do anything useful; leave vars for explicit\n+                   instantiation.  */\n+\t\tDECL_NOT_REALLY_EXTERN (decl) = 0;\n \t    }\n \t}\n       else\n@@ -3602,6 +3605,12 @@ void\n do_toplevel_using_decl (decl)\n      tree decl;\n {\n+#if 1\n+  if (TREE_CODE (decl) == SCOPE_REF\n+      && TREE_OPERAND (decl, 0) == std_node)\n+    return;\n+  sorry (\"using-declaration\");\n+#else\n   if (decl == NULL_TREE || decl == error_mark_node)\n     return;\n \n@@ -3619,6 +3628,7 @@ do_toplevel_using_decl (decl)\n \tpushdecl (TREE_VALUE (decl));\n \tdecl = TREE_CHAIN (decl);\n       }\n+#endif\n }\n \n tree\n@@ -3648,6 +3658,8 @@ void\n do_using_directive (namespace)\n      tree namespace;\n {\n+  if (namespace == std_node)\n+    return;\n   sorry (\"using directive\");\n }\n "}, {"sha": "55ffa346507e0d086cdbf2f6ccd01fe6a8f8adf4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 122, "deletions": 45, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -240,9 +240,11 @@ init_exception_processing ()\n   tree declspecs;\n   tree d;\n \n+  /* void vtype () */\n+  tree vtype = build_function_type (void_type_node, void_list_node);\n+  \n   /* void (*)() */\n-  tree PFV = build_pointer_type (build_function_type\n-\t\t\t\t (void_type_node, void_list_node));\n+  tree PFV = build_pointer_type (vtype);\n \n   /* Arg list for the build_function_type call for set_terminate and\n      set_unexpected.  */\n@@ -251,9 +253,6 @@ init_exception_processing ()\n   /* void (*pfvtype (void (*) ()))() */\n   tree pfvtype = build_function_type (PFV, pfvlist);\n \n-  /* void vtype () */\n-  tree vtype = build_function_type (void_type_node, void_list_node);\n-  \n   set_terminate_fndecl = auto_function (get_identifier (\"set_terminate\"),\n \t\t\t\t\tpfvtype, NOT_BUILT_IN);\n   set_unexpected_fndecl = auto_function (get_identifier (\"set_unexpected\"),\n@@ -290,7 +289,7 @@ init_exception_processing ()\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   empty_fndecl\n     = builtin_function (\"__empty\",\n-\t\t\tbuild_function_type (void_type_node, void_list_node),\n+\t\t\tvtype,\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n   DECL_EXTERNAL (empty_fndecl) = 1;\n   TREE_PUBLIC (empty_fndecl) = 1;\n@@ -611,18 +610,18 @@ do_unwind (inner_throw_label)\n   /* This doesn't work for the flat model sparc, I bet.  */\n   tree fcall;\n   tree params;\n-  rtx return_val_rtx;\n+  rtx next_pc;\n   rtx temp;\n \n   /* Call to  __builtin_return_address. */\n   params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n+  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n   /* In the return, the new pc is pc+8, as the value coming in is\n      really the address of the call insn, not the next insn.  */\n   temp = gen_reg_rtx (Pmode);\n   emit_move_insn (temp, inner_throw_label);\n-  emit_move_insn (return_val_rtx, plus_constant (temp, -8));\n+  emit_move_insn (next_pc, plus_constant (temp, -8));\n   emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 31)));\n   easy_expand_asm (\"ret\");\n   easy_expand_asm (\"restore\");\n@@ -663,16 +662,16 @@ do_unwind (inner_throw_label)\n #if ! defined (TARGET_88000) && ! defined (ARM_FRAME_RTX) && ! defined (SPARC_STACK_ALIGN)\n   tree fcall;\n   tree params;\n-  rtx return_val_rtx;\n+  rtx next_pc;\n \n #if 0\n   /* I would like to do this here, but the move below doesn't seem to work.  */\n   /* Call to  __builtin_return_address.  */\n   params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n+  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n \n-  emit_move_insn (return_val_rtx, inner_throw_label);\n+  emit_move_insn (next_pc, inner_throw_label);\n   /* So, for now, just pass throw label to stack unwinder.  */\n #endif\n   params = tree_cons (NULL_TREE, make_tree (ptr_type_node,\n@@ -705,12 +704,15 @@ expand_builtin_throw ()\n {\n   tree fcall;\n   tree params;\n-  rtx return_val_rtx;\n+  rtx handler;\n+  rtx saved_pcnthrow;\n+  rtx next_pc;\n   rtx gotta_rethrow_it;\n   rtx gotta_call_terminate;\n+  rtx after_unwind;\n   rtx top_of_loop;\n-  rtx unwind_first;\n   tree t;\n+  rtx x;\n \n   if (! doing_eh (0))\n     return;\n@@ -721,8 +723,11 @@ expand_builtin_throw ()\n   params = void_list_node;\n   t = make_call_declarator (get_identifier (\"__throw\"), params, NULL_TREE,\n \t\t\t    NULL_TREE);\n-  start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n-\t\t\t\t  void_list_node),\n+  start_function (decl_tree_cons (NULL_TREE,\n+\t\t\t\t  get_identifier (\"void\"),\n+\t\t\t\t  decl_tree_cons (NULL_TREE,\n+\t\t\t\t\t\t  get_identifier (\"static\"),\n+\t\t\t\t\t\t  NULL_TREE)),\n \t\t  t, NULL_TREE, 0);\n   store_parm_decls ();\n   pushlevel (0);\n@@ -732,8 +737,6 @@ expand_builtin_throw ()\n \n   gotta_rethrow_it = gen_label_rtx ();\n   gotta_call_terminate = gen_label_rtx ();\n-  top_of_loop = gen_label_rtx ();\n-  unwind_first = gen_label_rtx ();\n \n   /* These two can be frontend specific.  If wanted, they can go in\n      expand_throw.  */\n@@ -742,72 +745,146 @@ expand_builtin_throw ()\n \t\t GET_MODE (DECL_RTL (saved_throw_type)), 0, 0);\n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n-  emit_jump (unwind_first);\n-\n-  emit_label (top_of_loop);\n-\n   /* search for an exception handler for the saved_pc */\n-  return_val_rtx = do_function_call (FirstExceptionMatch,\n-\t\t\t\t     tree_cons (NULL_TREE, saved_pc, NULL_TREE),\n-\t\t\t\t     ptr_type_node);\n+  handler = do_function_call (FirstExceptionMatch,\n+\t\t\t      tree_cons (NULL_TREE, saved_pc,\n+\t\t\t\t\t NULL_TREE),\n+\t\t\t      ptr_type_node);\n   assemble_external (TREE_OPERAND (FirstExceptionMatch, 0));\n \n   /* did we find one? */\n-  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n-\t\t GET_MODE (return_val_rtx), 0, 0);\n+  emit_cmp_insn (handler, const0_rtx, EQ, NULL_RTX,\n+\t\t GET_MODE (handler), 0, 0);\n \n   /* if not, jump to gotta_rethrow_it */\n   emit_jump_insn (gen_beq (gotta_rethrow_it));\n \n-  /* we found it, so jump to it */\n-  emit_indirect_jump (return_val_rtx);\n+  {\n+    rtx ret_val, x;\n+    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t  0, hard_frame_pointer_rtx);\n+\n+    /* Set it up so that we continue at the handler.  */\n+    emit_move_insn (ret_val, handler);\n+#ifdef RETURN_ADDR_OFFSET\n+    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n+    if (x != ret_val)\n+      emit_move_insn (ret_val, x);\n+#endif\n \n-  /* code to deal with unwinding and looking for it again */\n-  emit_label (gotta_rethrow_it);\n+    expand_null_return ();\n+  }\n \n+  top_of_loop = gen_label_rtx ();\n+  emit_label (top_of_loop);\n+  \n+#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n+  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n+    {\n+      saved_pcnthrow = gen_reg_rtx (Pmode);\n+      emit_move_insn (saved_pcnthrow, hard_function_value (ptr_type_node,\n+\t\t\t\t\t\t\t   NULL_TREE));\n+    }\n+#endif\n+      \n   /* Call to  __builtin_return_address.  */\n #if defined (ARM_FRAME_RTX)  /* was __arm */\n   /* This should be moved into arm.h:RETURN_ADDR_RTX */\n   /* This replaces a 'call' to __builtin_return_address */\n-  return_val_rtx = gen_reg_rtx (Pmode);\n-  emit_move_insn (return_val_rtx, gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n+  next_pc = gen_reg_rtx (Pmode);\n+  emit_move_insn (next_pc,\n+\t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n #else\n   params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n-  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n+  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);\n #endif\n \n   /* Did __builtin_return_address return a valid address?  */\n-  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,\n-\t\t GET_MODE (return_val_rtx), 0, 0);\n+  emit_cmp_insn (next_pc, const0_rtx, EQ, NULL_RTX,\n+\t\t GET_MODE (next_pc), 0, 0);\n \n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n-  return_val_rtx = eh_outer_context (return_val_rtx);\n+  next_pc = eh_outer_context (next_pc);\n \n   /* Yes it did.  */\n-  emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n+#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n+  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n+    {\n+      rtx x;\n+\n+      x = validize_mem (gen_rtx (MEM, Pmode, saved_pcnthrow));\n+      emit_move_insn (validize_mem (gen_rtx (MEM, Pmode, x)),\n+\t\t      next_pc);\n+#ifdef FUNCTION_OUTGOING_VALUE\t\n+      emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),\n+\t\t      validize_mem (gen_rtx (MEM, Pmode,\n+\t\t\t\t\t     plus_constant (saved_pcnthrow,\n+\t\t\t\t\t\t\t    GET_MODE_SIZE (Pmode)))));\n+      emit_insn (gen_rtx (USE, VOIDmode,\n+\t\t\t  FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));\n+#endif\n+    }\n+  else\n+#endif\n+    emit_move_insn (eh_saved_pc_rtx, next_pc);\n \n-  do_unwind (gen_rtx (LABEL_REF, Pmode, top_of_loop));\n-  emit_jump (top_of_loop);\n+  after_unwind = gen_label_rtx ();\n+  do_unwind (gen_rtx (LABEL_REF, Pmode, after_unwind));\n+\n+  emit_label (after_unwind);\n+\n+#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n+  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n+    {\n+      t = make_tree (build_pointer_type (TREE_TYPE (empty_fndecl)),\n+\t\t     hard_function_value (ptr_type_node,\n+\t\t\t\t\t  NULL_TREE));\n+      t = build_function_call (t, NULL_TREE);\n+      expand_expr (t, const0_rtx, VOIDmode, 0);\n+    }\n+  else\n+#endif\n+    emit_throw ();\n \n   /* no it didn't --> therefore we need to call terminate */\n   emit_label (gotta_call_terminate);\n   do_function_call (Terminate, NULL_TREE, NULL_TREE);\n   assemble_external (TREE_OPERAND (Terminate, 0));\n \n   {\n-    rtx ret_val, return_val_rtx;\n-    emit_label (unwind_first);\n+    rtx ret_val, x;\n+    /* code to deal with unwinding and looking for it again */\n+    emit_label (gotta_rethrow_it);\n     ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n \t\t\t\t\t  0, hard_frame_pointer_rtx);\n \n     /* Set it up so that we continue inside, at the top of the loop.  */\n     emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, top_of_loop));\n #ifdef RETURN_ADDR_OFFSET\n-  return_val_rtx = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n-    if (return_val_rtx != ret_val)\n-      emit_move_insn (ret_val, return_val_rtx);\n+    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n+    if (x != ret_val)\n+      emit_move_insn (ret_val, x);\n+#endif\n+\n+#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n+    if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n+      {\n+\trtx x = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t\t\t\t  \"__eh_pcnthrow\"),\n+\t\t\t\t\t NULL_RTX, 1,\n+\t\t\t\t\t Pmode, 0);\n+\t/* This is to get a version of throw that will throw properly.  */\n+\temit_move_insn (validize_mem (gen_rtx (MEM, Pmode,\n+\t\t\t\t\t       plus_constant (x, GET_MODE_SIZE (Pmode)))),\n+\t\t\tthrow_libfunc);\n+#ifdef FUNCTION_OUTGOING_VALUE\t\n+\temit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),\n+\t\t\tx);\n+\temit_insn (gen_rtx (USE, VOIDmode, FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));\n+#endif\n+      }\n #endif\n \n     /* Fall into epilogue to unwind prologue.  */"}, {"sha": "06203fbf8a80030aa6fbe2e6c0a0437e0305a764", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -1675,6 +1675,10 @@ build_member_call (type, name, parmlist)\n   int dont_use_this = 0;\n   tree basetype_path, decl;\n \n+  if (type == std_node)\n+    return build_x_function_call (do_scoped_id (name, 0), parmlist,\n+\t\t\t\t  current_class_ref);\n+\n   if (TREE_CODE (method_name) == BIT_NOT_EXPR)\n     {\n       method_name = TREE_OPERAND (method_name, 0);\n@@ -1796,6 +1800,9 @@ build_offset_ref (type, name)\n   tree basebinfo = NULL_TREE;\n   int dtor = 0;\n \n+  if (type == std_node)\n+    return do_scoped_id (name, 0);\n+\n   if (processing_template_decl)\n     return build_min_nt (SCOPE_REF, type, name);\n "}, {"sha": "acb00b0b8d94214eea64f4843638bcc4af53ad42", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -3005,14 +3005,6 @@ real_yylex ()\n \t\t  token_buffer[0] = '^';\n \t\t  token_buffer[1] = 0;\n \t\t}\n-\t      else if (ptr->token == NAMESPACE)\n-\t\t{\n-\t\t  static int warned;\n-\t\t  if (! warned)\n-\t\t    warning (\"namespaces are mostly broken in this version of g++\");\n-\n-\t\t  warned = 1;\n-\t\t}\n \n \t      value = (int) ptr->token;\n \t    }"}, {"sha": "a8502d45f43a899fcc4ae9f4f5de274978c2f583", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -2052,21 +2052,6 @@ synthesize_method (fndecl)\n \n   finish_function (lineno, 0, nested);\n \n-  /* Do we really *want* to inline this function?  */\n-  if (DECL_INLINE (fndecl))\n-    {\n-      /* Turn off DECL_INLINE for the moment so function_cannot_inline_p\n-         will check our size.  */\n-      DECL_INLINE (fndecl) = 0;\n-\n-      /* We say !at_eof because at the end of the file some of the rtl\n-\t for fndecl may have been allocated on the temporary obstack.\n-\t (The function_obstack is the temporary one if we're not in a\n-\t function). */\n-      if ((! at_eof) && function_cannot_inline_p (fndecl) == 0)\n-\tDECL_INLINE (fndecl) = 1;\n-    }\n-\n   extract_interface_info ();\n   if (! context)\n     pop_from_top_level ();"}, {"sha": "ab112305c6d2523ec1ce50146e07cbf688475761", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -390,7 +390,11 @@ extdef:\n \t| using_decl ';'\n \t\t{ do_toplevel_using_decl ($1); }\n \t| USING NAMESPACE any_id ';'\n-\t\t{ do_using_directive ($3); }\n+\t\t{\n+\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE)\n+\t\t    $3 = lastiddecl;\n+\t\t  do_using_directive ($3);\n+\t\t}\n \t| extension extdef\n \t\t{ pedantic = $<itype>1; }\n \t;\n@@ -814,20 +818,20 @@ explicit_instantiation:\n \t\t{ do_type_instantiation ($3, NULL_TREE); }\n \t| TEMPLATE typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($2.t);\n-\t\t  do_function_instantiation (specs, $3, NULL_TREE); }\n+\t\t  do_decl_instantiation (specs, $3, NULL_TREE); }\n \t| TEMPLATE notype_declarator\n-\t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n+\t\t{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }\n \t| TEMPLATE constructor_declarator\n-\t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n+\t\t{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }\n \t| SCSPEC TEMPLATE aggr template_type\n \t\t{ do_type_instantiation ($4, $1); }\n \t| SCSPEC TEMPLATE typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($3.t);\n-\t\t  do_function_instantiation (specs, $4, $1); }\n+\t\t  do_decl_instantiation (specs, $4, $1); }\n \t| SCSPEC TEMPLATE notype_declarator\n-\t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n+\t\t{ do_decl_instantiation (NULL_TREE, $3, $1); }\n \t| SCSPEC TEMPLATE constructor_declarator\n-\t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n+\t\t{ do_decl_instantiation (NULL_TREE, $3, $1); }\n \t;\n \n /* The TYPENAME expansions are to deal with use of a template class name as\n@@ -1831,13 +1835,9 @@ typespec:\n \t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| TYPEOF '(' expr ')'\n \t\t{ $$.t = TREE_TYPE ($3);\n-\t\t  $$.new_type_flag = 0;\n-\t\t  if (pedantic && !in_system_header)\n-\t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n+\t\t  $$.new_type_flag = 0; }\n \t| TYPEOF '(' type_id ')'\n \t\t{ $$.t = groktypename ($3.t);\n-\t\t  if (pedantic && !in_system_header)\n-\t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); \n \t\t  $$.new_type_flag = 0; }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n@@ -3051,7 +3051,15 @@ nested_name_specifier_1:\n \t\t  got_scope = $$ = TREE_TYPE ($$);\n \t\t}\n \t| NSNAME SCOPE\n-\t\t{ got_scope = $$ = $1; }\n+\t\t{\n+\t\t  if (TREE_CODE ($$) == IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n+\t\t  if (TREE_CODE ($$) == NAMESPACE_DECL\n+\t\t      && DECL_NAME ($$) == get_identifier (\"std\"))\n+\t\t    got_scope = void_type_node;\n+\t\t  else\n+\t\t    got_scope = $$;\n+\t\t}\n \t| template_type SCOPE\n \t\t{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }\n /* \tThese break 'const i;'"}, {"sha": "7febfc6390d99b63c9cfdfb2a45cae19d6396ae9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -274,9 +274,9 @@ push_template_decl (decl)\n \t    return;\n \t}\n \n-      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = perm_tree_cons\n-\t(mainargs, TREE_VALUE (current_template_parms),\n-\t DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n+      DECL_TEMPLATE_SPECIALIZATIONS (maintmpl) = CLASSTYPE_TI_SPEC_INFO (type)\n+\t= perm_tree_cons (mainargs, TREE_VALUE (current_template_parms),\n+\t\t\t  DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n       TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n       return;\n     }\n@@ -291,6 +291,8 @@ push_template_decl (decl)\n     }\n   else\n     {\n+      tree t;\n+\n       if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n \tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n \t\t  ctx, decl);\n@@ -303,6 +305,18 @@ push_template_decl (decl)\n \t}\n       else\n \ttmpl = DECL_TI_TEMPLATE (decl);\n+\n+      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (ctx))\n+\tt = TREE_VALUE (CLASSTYPE_TI_SPEC_INFO (ctx));\n+      else\n+\tt = DECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (ctx));\n+\n+      if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (args))\n+\t{\n+\t  cp_error (\"got %d template parameters for `%#D'\",\n+\t\t    TREE_VEC_LENGTH (args), decl);\n+\t  cp_error (\"  but `%#T' has %d\", ctx, TREE_VEC_LENGTH (t));\n+\t}\n     }\n \n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n@@ -1183,8 +1197,13 @@ instantiate_class_template (type)\n \t\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n \t    BINFO_INHERITANCE_CHAIN (elt) = binfo;\n \n-\t    if (! uses_template_parms (type)\n-\t\t&& TYPE_SIZE (complete_type (TREE_TYPE (elt))) == NULL_TREE)\n+\t    if (! IS_AGGR_TYPE (TREE_TYPE (elt)))\n+\t      cp_error\n+\t\t(\"base type `%T' of `%T' fails to be a struct or class type\",\n+\t\t TREE_TYPE (elt), type);\n+\t    else if (! uses_template_parms (type)\n+\t\t     && (TYPE_SIZE (complete_type (TREE_TYPE (elt)))\n+\t\t\t == NULL_TREE))\n \t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n \t\t\tTREE_TYPE (elt), type);\n \t  }\n@@ -1752,11 +1771,13 @@ tsubst (t, args, nargs, in_decl)\n \t    return t;\n \n \t  TREE_TYPE (t) = complete_type (type);\n-\t  BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (type);\n-\t  BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (type);\n-\t  if (TYPE_BINFO_BASETYPES (type) != NULL_TREE)\n-\t    BINFO_BASETYPES (t) = copy_node (TYPE_BINFO_BASETYPES (type));\n-\n+\t  if (IS_AGGR_TYPE (type))\n+\t    {\n+\t      BINFO_VTABLE (t) = TYPE_BINFO_VTABLE (type);\n+\t      BINFO_VIRTUALS (t) = TYPE_BINFO_VIRTUALS (type);\n+\t      if (TYPE_BINFO_BASETYPES (type) != NULL_TREE)\n+\t\tBINFO_BASETYPES (t) = copy_node (TYPE_BINFO_BASETYPES (type));\n+\t    }\n \t  return t;\n \t}\n       {\n@@ -3153,7 +3174,7 @@ most_specialized_class (specs, mainargs)\n /* called from the parser.  */\n \n void\n-do_function_instantiation (declspecs, declarator, storage)\n+do_decl_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n {\n   tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, NULL_TREE);\n@@ -3169,7 +3190,18 @@ do_function_instantiation (declspecs, declarator, storage)\n     }\n \n   /* If we've already seen this template instance, use it.  */\n-  if (DECL_FUNCTION_MEMBER_P (decl))\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    {\n+      result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, 0);\n+      if (result && TREE_CODE (result) != VAR_DECL)\n+\tresult = NULL_TREE;\n+    }\n+  else if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      cp_error (\"explicit instantiation of `%#D'\", decl);\n+      return;\n+    }\n+  else if (DECL_FUNCTION_MEMBER_P (decl))\n     {\n       if (DECL_TEMPLATE_INSTANTIATION (decl))\n \tresult = decl;\n@@ -3220,6 +3252,12 @@ do_function_instantiation (declspecs, declarator, storage)\n       return;\n     }\n \n+  if (! DECL_TEMPLATE_INFO (result))\n+    {\n+      cp_pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n+      return;\n+    }\n+\n   if (flag_external_templates)\n     return;\n "}, {"sha": "d9b4486d1f029c998fef9b78ed1443bf30b4c8dc", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -41,6 +41,8 @@ static tree original_repo;\n static char *repo_name;\n static FILE *repo_file;\n \n+static char *old_args, *old_dir, *old_main;\n+\n extern int flag_use_repository;\n extern int errorcount, sorrycount;\n extern struct obstack temporary_obstack;\n@@ -198,35 +200,55 @@ save_string (s, len)\n   return obstack_copy0 (&temporary_obstack, s, len);\n }\n \n+/* Parse a reasonable subset of shell quoting syntax.  */\n+\n+static char *\n+extract_string (pp)\n+     char **pp;\n+{\n+  char *p = *pp;\n+  int backquote = 0;\n+  int inside = 0;\n+\n+  for (;;)\n+    {\n+      char c = *p;\n+      if (c == '\\0')\n+\tbreak;\n+      ++p;\n+      if (backquote)\n+\tobstack_1grow (&temporary_obstack, c);\n+      else if (! inside && c == ' ')\n+\tbreak;\n+      else if (! inside && c == '\\\\')\n+\tbackquote = 1;\n+      else if (c == '\\'')\n+\tinside = !inside;\n+      else\n+\tobstack_1grow (&temporary_obstack, c);\n+    }\n+\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  *pp = p;\n+  return obstack_finish (&temporary_obstack);\n+}\n+\n static char *\n get_base_filename (filename)\n      char *filename;\n {\n   char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n-  char *output = 0;\n+  char *output = NULL;\n   int compiling = 0;\n \n-  if (p)\n-    while (*p)\n-      {\n-\tchar *q = p;\n-\twhile (*q && *q != ' ') q++;\n-\tif (*p == '-' && p[1] == 'o')\n-\t  {\n-\t    p += 2;\n-\t    if (p == q)\n-\t      {\n-\t\tp++; q++;\n-\t\tif (*q)\n-\t\t  while (*q && *q != ' ') q++;\n-\t      }\n+  while (p && *p)\n+    {\n+      char *q = extract_string (&p);\n \n-\t    output = save_string (p, q - p);\n-\t  }\n-\telse if (*p == '-' && p[1] == 'c')\n-\t  compiling = 1;\n-\tif (*q) q++;\n-\tp = q;\n+      if (strcmp (q, \"-o\") == 0)\n+\toutput = extract_string (&p);\n+      else if (strcmp (q, \"-c\") == 0)\n+\tcompiling = 1;\n       }\n \n   if (compiling && output)\n@@ -301,8 +323,16 @@ init_repo (filename)\n       switch (buf[0])\n \t{\n \tcase 'A':\n+\t  old_args = obstack_copy0 (&permanent_obstack, buf + 2,\n+\t\t\t\t    strlen (buf + 2));\n+\t  break;\n \tcase 'D':\n+\t  old_dir = obstack_copy0 (&permanent_obstack, buf + 2,\n+\t\t\t\t   strlen (buf + 2));\n+\t  break;\n \tcase 'M':\n+\t  old_main = obstack_copy0 (&permanent_obstack, buf + 2,\n+\t\t\t\t    strlen (buf + 2));\n \t  break;\n \tcase 'C':\n \tcase 'O':\n@@ -350,6 +380,7 @@ finish_repo ()\n   tree t;\n   char *p;\n   int repo_changed = 0;\n+  char *dir, *args;\n \n   if (! flag_use_repository)\n     return;\n@@ -382,6 +413,16 @@ finish_repo ()\n \t  }\n       }\n \n+  dir = getpwd ();\n+  args = getenv (\"COLLECT_GCC_OPTIONS\");\n+\n+  if (! repo_changed && pending_repo)\n+    if (strcmp (old_main, main_input_filename) != 0\n+\t|| strcmp (old_dir, dir) != 0\n+\t|| (args == NULL) != (old_args == NULL)\n+\t|| strcmp (old_args, args) != 0)\n+      repo_changed = 1;\n+\n   if (! repo_changed || errorcount || sorrycount)\n     goto out;\n \n@@ -391,13 +432,9 @@ finish_repo ()\n     goto out;\n \n   fprintf (repo_file, \"M %s\\n\", main_input_filename);\n-\n-  p = getpwd ();\n-  fprintf (repo_file, \"D %s\\n\", p);\n-\n-  p = getenv (\"COLLECT_GCC_OPTIONS\");\n-  if (p != 0)\n-    fprintf (repo_file, \"A %s\\n\", p);\n+  fprintf (repo_file, \"D %s\\n\", dir);\n+  if (args)\n+    fprintf (repo_file, \"A %s\\n\", args);\n \n   for (t = pending_repo; t; t = TREE_CHAIN (t))\n     {"}, {"sha": "c73e86ffaf104be08f0aea5db33522f1e53485b7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -5082,9 +5082,11 @@ build_conditional_expr (ifexp, op1, op2)\n     result_type = build_ptrmemfunc_type (result_type);\n \n   if (result_type != TREE_TYPE (op1))\n-    op1 = convert_and_check (result_type, op1);\n+    op1 = convert_for_initialization\n+      (NULL_TREE, result_type, op1, LOOKUP_NORMAL, \"converting\", NULL_TREE, 0);\n   if (result_type != TREE_TYPE (op2))\n-    op2 = convert_and_check (result_type, op2);\n+    op2 = convert_for_initialization\n+      (NULL_TREE, result_type, op2, LOOKUP_NORMAL, \"converting\", NULL_TREE, 0);\n \n   if (TREE_CONSTANT (ifexp))\n     return integer_zerop (ifexp) ? op2 : op1;\n@@ -7221,7 +7223,8 @@ c_expand_return (retval)\n \t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n \t    whats_returned = TREE_OPERAND (whats_returned, 0);\n \t}\n-      if (TREE_CODE (whats_returned) == CONVERT_EXPR)\n+      while (TREE_CODE (whats_returned) == CONVERT_EXPR\n+\t     || TREE_CODE (whats_returned) == NOP_EXPR)\n \twhats_returned = TREE_OPERAND (whats_returned, 0);\n       if (TREE_CODE (whats_returned) == ADDR_EXPR)\n \t{"}, {"sha": "260ddd2d003c239c3e872d4a83cdbacc11f8789c", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6633d6367f902b576a96132ba6a9a53368db66ba/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=6633d6367f902b576a96132ba6a9a53368db66ba", "patch": "@@ -645,7 +645,7 @@ GNU_xref_member(cls, fld)\n \t  filename(xf), fld->decl.linenum, d,  bufa,  prot,\n \t  (TREE_CODE (fld) == FUNCTION_DECL ? 0 : 1),\n \t  (DECL_INLINE (fld) ? 1 : 0),\n-\t  (DECL_FRIEND_P(fld) ? 1 : 0),\n+\t  (DECL_LANG_SPECIFIC(fld) && DECL_FRIEND_P(fld) ? 1 : 0),\n \t  (DECL_VINDEX(fld) ? 1 : 0),\n \t  (TREE_STATIC(fld) ? 1 : 0),\n \t  pure, confg);"}]}