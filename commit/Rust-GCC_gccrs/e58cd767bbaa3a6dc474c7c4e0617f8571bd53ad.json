{"sha": "e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU4Y2Q3NjdiYmFhM2E2ZGM0NzRjN2M0ZTA2MTdmODU3MWJkNTNhZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:40:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:40:04Z"}, "message": "(parser_build_binary_op): Warn about overflows and conversions of out-of-range...\n\n(parser_build_binary_op): Warn about overflows and\nconversions of out-of-range constants in parser-built binary expressions.\n(build_conditional_expr): Check conversions in if-then-else expressions.\n(build_c_cast): Ignore any integer overflow caused by a cast.\n(convert_for_assignment): Warn if source had overflow in folding.\n(process_init_constructor): Report overflows in array initializer indexes.\n\nFrom-SVN: r3404", "tree": {"sha": "ce1b15d53243fa59a139ec34c7423755fafca541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce1b15d53243fa59a139ec34c7423755fafca541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad/comments", "author": null, "committer": null, "parents": [{"sha": "5303129fc91a9ba7b683356333f6e886bdf2dcc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5303129fc91a9ba7b683356333f6e886bdf2dcc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5303129fc91a9ba7b683356333f6e886bdf2dcc5"}], "stats": {"total": 40, "additions": 28, "deletions": 12}, "files": [{"sha": "649467af9f5b6617fac9c5cb919e8db947612e46", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e58cd767bbaa3a6dc474c7c4e0617f8571bd53ad", "patch": "@@ -731,7 +731,7 @@ c_sizeof (type)\n \t\t  size_int (TYPE_PRECISION (char_type_node)));\n   /* size_binop does not put the constant in range, so do it now.  */\n   if (TREE_CODE (t) == INTEGER_CST)\n-    force_fit_type (t);\n+    TREE_CONSTANT_OVERFLOW (t) |= force_fit_type (t, 0);\n   return t;\n }\n \n@@ -752,7 +752,7 @@ c_sizeof_nowarn (type)\n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n \t\t  size_int (TYPE_PRECISION (char_type_node)));\n-  force_fit_type (t);\n+  force_fit_type (t, 0);\n   return t;\n }\n \n@@ -780,7 +780,7 @@ c_size_in_bytes (type)\n   /* Convert in case a char is more than one unit.  */\n   t = size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type), \n \t\t     size_int (BITS_PER_UNIT));\n-  force_fit_type (t);\n+  force_fit_type (t, 0);\n   return t;\n }\n \n@@ -2155,6 +2155,10 @@ parser_build_binary_op (code, arg1, arg2)\n       && (TREE_CODE_CLASS (code1) == '<' || TREE_CODE_CLASS (code2) == '<'))\n     warning (\"comparisons like X<=Y<=Z do not have their mathematical meaning\");\n \n+  unsigned_conversion_warning (result, arg1);\n+  unsigned_conversion_warning (result, arg2);\n+  overflow_warning (result);\n+\n   class = TREE_CODE_CLASS (TREE_CODE (result));\n \n   /* Record the code that was specified in the source,\n@@ -3581,10 +3585,13 @@ build_conditional_expr (ifexp, op1, op2)\n \t\t\t  TREE_READONLY (op1) || TREE_READONLY (op2),\n \t\t\t  TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n     \n+  if (TREE_CODE (ifexp) == INTEGER_CST)\n+    return convert_and_check (result_type, integer_zerop (ifexp) ? op2 : op1);\n+\n   if (result_type != TREE_TYPE (op1))\n-    op1 = convert (result_type, op1);\n+    op1 = convert_and_check (result_type, op1);\n   if (result_type != TREE_TYPE (op2))\n-    op2 = convert (result_type, op2);\n+    op2 = convert_and_check (result_type, op2);\n     \n #if 0\n   if (code1 == RECORD_TYPE || code1 == UNION_TYPE)\n@@ -3623,8 +3630,6 @@ build_conditional_expr (ifexp, op1, op2)\n     }\n #endif /* 0 */\n \n-  if (TREE_CODE (ifexp) == INTEGER_CST)\n-    return (integer_zerop (ifexp) ? op2 : op1);\n   return fold (build (COND_EXPR, result_type, ifexp, op1, op2));\n }\n \f\n@@ -3800,6 +3805,10 @@ build_c_cast (type, expr)\n \twarning (\"cast to pointer from integer of different size\");\n \n       value = convert (type, value);\n+\n+      /* Ignore any integer overflow caused by the cast.  */\n+      if (TREE_CODE (value) == INTEGER_CST)\n+\tTREE_CONSTANT_OVERFLOW (value) = 0;\n     }\n \n   if (value == expr && pedantic)\n@@ -4010,7 +4019,10 @@ convert_for_assignment (type, rhs, errtype, funname, parmnum)\n     return error_mark_node;\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n-    return rhs;\n+    {\n+      overflow_warning (rhs);\n+      return rhs;\n+    }\n \n   if (coder == VOID_TYPE)\n     {\n@@ -4021,9 +4033,7 @@ convert_for_assignment (type, rhs, errtype, funname, parmnum)\n   if ((codel == INTEGER_TYPE || codel == REAL_TYPE || codel == ENUMERAL_TYPE)\n        &&\n       (coder == INTEGER_TYPE || coder == REAL_TYPE || coder == ENUMERAL_TYPE))\n-    {\n-      return convert (type, rhs);\n-    }\n+    return convert_and_check (type, rhs);\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n     {\n@@ -5022,6 +5032,9 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t\t  || TREE_CODE (start_index) == NOP_EXPR))\n \t\t    start_index = TREE_OPERAND (start_index, 0);\n \n+\t\t  constant_expression_warning (start_index);\n+\t\t  constant_expression_warning (end_index);\n+\n \t\t  if ((TREE_CODE (start_index) == IDENTIFIER_NODE) \n \t\t      || (TREE_CODE (end_index) == IDENTIFIER_NODE))\n \t\t    error (\"field name used as index in array initializer\");\n@@ -5060,7 +5073,10 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t\t       || (max_index && tree_int_cst_lt (max_index, index)))\n \t\terror (\"array index out of range in initializer\");\n \t      else\n-\t\tcurrent_index = index, win = 1;\n+\t\t{\n+\t\t  constant_expression_warning (index);\n+\t\t  current_index = index, win = 1;\n+\t\t}\n \n \t      if (!win)\n \t\t{"}]}