{"sha": "fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiNWMyMDAzNjljOGJhNTYzNThhMTQ1ZTBjNWM2YzQ2MWFkNWE0NQ==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2021-04-30T08:24:30Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-05T13:09:17Z"}, "message": "[Ada] Add Reference and Constant_Reference functions to formal containers\n\ngcc/ada/\n\n\t* libgnat/a-cfdlli.ads, libgnat/a-cfdlli.adb\n\tlibgnat/a-cfinve.ads, libgnat/a-cfinve.adb,\n\tlibgnat/a-cofove.ads, libgnat/a-cofove.adb,\n\tlibgnat/a-coboho.ads, libgnat/a-coboho.adb (Constant_Reference):\n\tGet a read-only access to an element of the container.\n\t(At_End): Ghost functions used to express pledges in the\n\tpostcondition of Reference.\n\t(Reference): Get a read-write access to an element of the\n\tcontainer.\n\t* libgnat/a-cfhama.ads, libgnat/a-cfhama.adb,\n\tlibgnat/a-cforma.ads, libgnat/a-cforma.adb: The full view of the\n\tMap type is no longer a tagged type, but a wrapper over this\n\ttagged type. This is to avoid issues with dispatching result in\n\tAt_End functions.\n\t(Constant_Reference): Get a read-only access to an element of\n\tthe container.\n\t(At_End): Ghost functions used to express pledges in the\n\tpostcondition of Reference.\n\t(Reference): Get a read-write access to an element of the\n\tcontainer.\n\n\t* libgnat/a-cfhase.ads, libgnat/a-cfhase.adb,\n\tlibgnat/a-cforse.ads, libgnat/a-cforse.adb: The full view of the\n\tMap type is no longer a tagged type, but a wrapper over this\n\ttagged type.\n\t(Constant_Reference): Get a read-only access to an element of\n\tthe container.\n\t* libgnat/a-cofuse.ads, libgnat/a-cofuve.ads (Copy_Element):\n\tExpression function used to cause SPARK to make sure\n\tElement_Type is copiable.\n\t* libgnat/a-cofuma.ads (Copy_Key): Expression function used to\n\tcause SPARK to make sure Key_Type is copiable.\n\t(Copy_Element): Expression function used to cause SPARK to make\n\tsure Element_Type is copiable.", "tree": {"sha": "c94c6f9694c20e5ff17438e01d3c598adfe7877b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c94c6f9694c20e5ff17438e01d3c598adfe7877b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "902d7076663aff56198b81f8efa356c3e1024e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/902d7076663aff56198b81f8efa356c3e1024e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/902d7076663aff56198b81f8efa356c3e1024e80"}], "stats": {"total": 1443, "additions": 1073, "deletions": 370}, "files": [{"sha": "b289def23fa1f95e974c45eab40164869cd49907", "filename": "gcc/ada/libgnat/a-cfdlli.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -188,6 +188,22 @@ is\n       Free (Container, X);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container => Container, Position  => Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Element'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1376,6 +1392,22 @@ is\n       return (Node => Container.Nodes (Position.Node).Prev);\n    end Previous;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference\n+     (Container : not null access List;\n+      Position  : Cursor) return not null access Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container.all, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      return Container.Nodes (Position.Node).Element'Access;\n+   end Reference;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------"}, {"sha": "8713d33bf34865755e0159d054f8aab9b7cc8a8b", "filename": "gcc/ada/libgnat/a-cfdlli.ads", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -387,6 +387,53 @@ is\n                 Model (Container),\n                 P.Get (Positions (Container), Position));\n \n+   function At_End (E : access constant List) return access constant List\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : aliased List;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+         Element (Model (Container), P.Get (Positions (Container), Position));\n+\n+   function Reference\n+     (Container : not null access List;\n+      Position  : Cursor) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container.all, Position),\n+     Post   =>\n+      Length (Container.all) = Length (At_End (Container).all)\n+\n+         --  Cursors are preserved\n+\n+         and Positions (Container.all) = Positions (At_End (Container).all)\n+\n+         --  Container will have Result.all at position Position\n+\n+         and At_End (Reference'Result).all =\n+           Element (Model (At_End (Container).all),\n+                    P.Get (Positions (At_End (Container).all), Position))\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Model (Container.all),\n+                Model (At_End (Container).all),\n+                P.Get (Positions (At_End (Container).all), Position));\n+\n    procedure Move (Target : in out List; Source : in out List) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n@@ -1609,7 +1656,7 @@ private\n    type Node_Type is record\n       Prev    : Count_Type'Base := -1;\n       Next    : Count_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    function \"=\" (L, R : Node_Type) return Boolean is abstract;"}, {"sha": "179b40074f00e36cc4c8425ff70e49173efa1484", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "modified", "additions": 127, "deletions": 54, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -109,20 +109,21 @@ is\n          ENode : Count_Type;\n \n       begin\n-         Node := Left.First.Node;\n+         Node := First (Left).Node;\n          while Node /= 0 loop\n             ENode :=\n               Find\n                 (Container => Right,\n-                 Key       => Left.Nodes (Node).Key).Node;\n+                 Key       => Left.Content.Nodes (Node).Key).Node;\n \n             if ENode = 0 or else\n-              Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n+              Right.Content.Nodes (ENode).Element /=\n+              Left.Content.Nodes (Node).Element\n             then\n                return False;\n             end if;\n \n-            Node := HT_Ops.Next (Left, Node);\n+            Node := HT_Ops.Next (Left.Content, Node);\n          end loop;\n \n          return True;\n@@ -145,7 +146,7 @@ is\n       --------------------\n \n       procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.Nodes (Source_Node);\n+         N : Node_Type renames Source.Content.Nodes (Source_Node);\n       begin\n          Insert (Target, N.Key, N.Element);\n       end Insert_Element;\n@@ -164,7 +165,7 @@ is\n \n       Clear (Target);\n \n-      Insert_Elements (Source);\n+      Insert_Elements (Source.Content);\n    end Assign;\n \n    --------------\n@@ -173,7 +174,7 @@ is\n \n    function Capacity (Container : Map) return Count_Type is\n    begin\n-      return Container.Nodes'Length;\n+      return Container.Content.Nodes'Length;\n    end Capacity;\n \n    -----------\n@@ -182,9 +183,44 @@ is\n \n    procedure Clear (Container : in out Map) is\n    begin\n-      HT_Ops.Clear (Container);\n+      HT_Ops.Clear (Container.Content);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container, Position),\n+         \"bad cursor in function Constant_Reference\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return not null access constant Element_Type\n+   is\n+      Node : constant Count_Type := Find (Container, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.Content.Nodes (Node).Element'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -214,18 +250,18 @@ is\n          raise Capacity_Error;\n       end if;\n \n-      Target.Length := Source.Length;\n-      Target.Free := Source.Free;\n+      Target.Content.Length := Source.Content.Length;\n+      Target.Content.Free := Source.Content.Free;\n \n       H := 1;\n       while H <= Source.Modulus loop\n-         Target.Buckets (H) := Source.Buckets (H);\n+         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n          H := H + 1;\n       end loop;\n \n       N := 1;\n       while N <= Source.Capacity loop\n-         Target.Nodes (N) := Source.Nodes (N);\n+         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n          N := N + 1;\n       end loop;\n \n@@ -255,7 +291,7 @@ is\n       X : Count_Type;\n \n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete key not in map\";\n@@ -273,7 +309,7 @@ is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n \n       Free (Container, Position.Node);\n       Position := No_Element;\n@@ -292,7 +328,7 @@ is\n            \"no element available because key not in map\";\n       end if;\n \n-      return Container.Nodes (Node).Element;\n+      return Container.Content.Nodes (Node).Element;\n    end Element;\n \n    function Element (Container : Map; Position : Cursor) return Element_Type is\n@@ -304,7 +340,7 @@ is\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in function Element\");\n \n-      return Container.Nodes (Position.Node).Element;\n+      return Container.Content.Nodes (Position.Node).Element;\n    end Element;\n \n    ---------------------\n@@ -326,7 +362,7 @@ is\n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : Count_Type;\n    begin\n-      Key_Ops.Delete_Key_Sans_Free (Container, Key, X);\n+      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n       Free (Container, X);\n    end Exclude;\n \n@@ -335,7 +371,7 @@ is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n \n    begin\n       if Node = 0 then\n@@ -350,7 +386,7 @@ is\n    -----------\n \n    function First (Container : Map) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container);\n+      Node : constant Count_Type := HT_Ops.First (Container.Content);\n \n    begin\n       if Node = 0 then\n@@ -407,16 +443,16 @@ is\n       ----------\n \n       function Keys (Container : Map) return K.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : K.Sequence;\n \n       begin\n          --  Can't use First, Next or Element here, since they depend on models\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := K.Add (R, Container.Nodes (Position).Key);\n-            Position := HT_Ops.Next (Container, Position);\n+            R := K.Add (R, Container.Content.Nodes (Position).Key);\n+            Position := HT_Ops.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -458,7 +494,7 @@ is\n       -----------\n \n       function Model (Container : Map) return M.Map is\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : M.Map;\n \n       begin\n@@ -469,10 +505,10 @@ is\n             R :=\n               M.Add\n                 (Container => R,\n-                 New_Key   => Container.Nodes (Position).Key,\n-                 New_Item  => Container.Nodes (Position).Element);\n+                 New_Key   => Container.Content.Nodes (Position).Key,\n+                 New_Item  => Container.Content.Nodes (Position).Element);\n \n-            Position := HT_Ops.Next (Container, Position);\n+            Position := HT_Ops.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -484,7 +520,7 @@ is\n \n       function Positions (Container : Map) return P.Map is\n          I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : P.Map;\n \n       begin\n@@ -494,7 +530,7 @@ is\n          while Position /= 0 loop\n             R := P.Add (R, (Node => Position), I);\n             pragma Assert (P.Length (R) = I);\n-            Position := HT_Ops.Next (Container, Position);\n+            Position := HT_Ops.Next (Container.Content, Position);\n             I := I + 1;\n          end loop;\n \n@@ -511,8 +547,8 @@ is\n    begin\n       if X /= 0 then\n          pragma Assert (X <= HT.Capacity);\n-         HT.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT, X);\n+         HT.Content.Nodes (X).Has_Element := False;\n+         HT_Ops.Free (HT.Content, X);\n       end if;\n    end Free;\n \n@@ -525,8 +561,8 @@ is\n         new HT_Ops.Generic_Allocate (Set_Element);\n \n    begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n+      Allocate (HT.Content, Node);\n+      HT.Content.Nodes (Node).Has_Element := True;\n    end Generic_Allocate;\n \n    -----------------\n@@ -536,7 +572,7 @@ is\n    function Has_Element (Container : Map; Position : Cursor) return Boolean is\n    begin\n       if Position.Node = 0\n-        or else not Container.Nodes (Position.Node).Has_Element\n+        or else not Container.Content.Nodes (Position.Node).Has_Element\n       then\n          return False;\n       else\n@@ -570,7 +606,7 @@ is\n \n       if not Inserted then\n          declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n+            N : Node_Type renames Container.Content.Nodes (Position.Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -625,7 +661,7 @@ is\n    --  Start of processing for Insert\n \n    begin\n-      Local_Insert (Container, Key, Position.Node, Inserted);\n+      Local_Insert (Container.Content, Key, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -668,7 +704,7 @@ is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in function Key\");\n \n-      return Container.Nodes (Position.Node).Key;\n+      return Container.Content.Nodes (Position.Node).Key;\n    end Key;\n \n    ------------\n@@ -677,7 +713,7 @@ is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.Content.Length;\n    end Length;\n \n    ----------\n@@ -688,7 +724,7 @@ is\n      (Target : in out Map;\n       Source : in out Map)\n    is\n-      NN : HT_Types.Nodes_Type renames Source.Nodes;\n+      NN : HT_Types.Nodes_Type renames Source.Content.Nodes;\n       X  : Count_Type;\n       Y  : Count_Type;\n \n@@ -704,17 +740,17 @@ is\n \n       Clear (Target);\n \n-      if Source.Length = 0 then\n+      if Source.Content.Length = 0 then\n          return;\n       end if;\n \n-      X := HT_Ops.First (Source);\n+      X := HT_Ops.First (Source.Content);\n       while X /= 0 loop\n          Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n \n-         Y := HT_Ops.Next (Source, X);\n+         Y := HT_Ops.Next (Source.Content, X);\n \n-         HT_Ops.Delete_Node_Sans_Free (Source, X);\n+         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n          Free (Source, X);\n \n          X := Y;\n@@ -743,7 +779,8 @@ is\n       pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n \n       declare\n-         Node : constant Count_Type := HT_Ops.Next (Container, Position.Node);\n+         Node : constant Count_Type :=\n+           HT_Ops.Next (Container.Content, Position.Node);\n \n       begin\n          if Node = 0 then\n@@ -759,6 +796,40 @@ is\n       Position := Next (Container, Position);\n    end Next;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Position  : Cursor) return not null access Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container.all, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container.all, Position), \"bad cursor in function Reference\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Reference;\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Key       : Key_Type) return not null access Element_Type\n+   is\n+      Node : constant Count_Type := Find (Container.all, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.Content.Nodes (Node).Element'Access;\n+   end Reference;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -768,15 +839,15 @@ is\n       Key       : Key_Type;\n       New_Item  : Element_Type)\n    is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n \n    begin\n       if Node = 0 then\n          raise Constraint_Error with \"attempt to replace key not in map\";\n       end if;\n \n       declare\n-         N : Node_Type renames Container.Nodes (Node);\n+         N : Node_Type renames Container.Content.Nodes (Node);\n       begin\n          N.Key := Key;\n          N.Element := New_Item;\n@@ -801,7 +872,7 @@ is\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n-      Container.Nodes (Position.Node).Element := New_Item;\n+      Container.Content.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -841,31 +912,33 @@ is\n          X : Count_Type;\n \n       begin\n-         if Container.Length = 0 then\n+         if Container.Content.Length = 0 then\n             return False;\n          end if;\n \n          if Container.Capacity = 0 then\n             return False;\n          end if;\n \n-         if Container.Buckets'Length = 0 then\n+         if Container.Content.Buckets'Length = 0 then\n             return False;\n          end if;\n \n          if Position.Node > Container.Capacity then\n             return False;\n          end if;\n \n-         if Container.Nodes (Position.Node).Next = Position.Node then\n+         if Container.Content.Nodes (Position.Node).Next = Position.Node then\n             return False;\n          end if;\n \n          X :=\n-           Container.Buckets\n-             (Key_Ops.Index (Container, Container.Nodes (Position.Node).Key));\n+           Container.Content.Buckets\n+             (Key_Ops.Index\n+                (Container.Content,\n+                 Container.Content.Nodes (Position.Node).Key));\n \n-         for J in 1 .. Container.Length loop\n+         for J in 1 .. Container.Content.Length loop\n             if X = Position.Node then\n                return True;\n             end if;\n@@ -874,14 +947,14 @@ is\n                return False;\n             end if;\n \n-            if X = Container.Nodes (X).Next then\n+            if X = Container.Content.Nodes (X).Next then\n \n                --  Prevent unnecessary looping\n \n                return False;\n             end if;\n \n-            X := Container.Nodes (X).Next;\n+            X := Container.Content.Nodes (X).Next;\n          end loop;\n \n          return False;"}, {"sha": "2b49c13df3f64c2809f0b7d7aa7f851396edb6ab", "filename": "gcc/ada/libgnat/a-cfhama.ads", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -394,6 +394,95 @@ is\n                 Model (Container)'Old,\n                 Key (Container, Position));\n \n+   function At_End\n+     (E : not null access constant Map) return not null access constant Map\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+           Element (Model (Container), Key (Container, Position));\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Position  : Cursor) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container.all, Position),\n+     Post   =>\n+\n+       --  Order of keys and cursors is preserved\n+\n+       Keys (At_End (Container).all) = Keys (Container.all)\n+         and Positions (At_End (Container).all) = Positions (Container.all)\n+\n+         --  The value designated by the result of Reference is now associated\n+         --  with the key at position Position in Container.\n+\n+         and Element (At_End (Container).all, Position) =\n+               At_End (Reference'Result).all\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys\n+               (Model (At_End (Container).all),\n+                Model (Container.all))\n+         and M.Elements_Equal_Except\n+               (Model (At_End (Container).all),\n+                Model (Container.all),\n+                Key (At_End (Container).all, Position));\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Contains (Container, Key),\n+     Post   =>\n+       Constant_Reference'Result.all = Element (Model (Container), Key);\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Key       : Key_Type) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Contains (Container.all, Key),\n+     Post   =>\n+\n+       --  Order of keys and cursors is preserved\n+\n+       Keys (At_End (Container).all) = Keys (Container.all)\n+         and Positions (At_End (Container).all) = Positions (Container.all)\n+\n+         --  The value designated by the result of Reference is now associated\n+         --  with Key in Container.\n+\n+         and Element (Model (At_End (Container).all), Key) =\n+               At_End (Reference'Result).all\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys\n+               (Model (At_End (Container).all),\n+                Model (Container.all))\n+         and M.Elements_Equal_Except\n+               (Model (At_End (Container).all),\n+                Model (Container.all),\n+                Key);\n+\n    procedure Move (Target : in out Map; Source : in out Map) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n@@ -804,16 +893,17 @@ private\n \n    type Node_Type is record\n       Key         : Key_Type;\n-      Element     : Element_Type;\n+      Element     : aliased Element_Type;\n       Next        : Count_Type;\n       Has_Element : Boolean := False;\n    end record;\n \n    package HT_Types is new\n      Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n \n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is\n-     new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is record\n+     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n+   end record;\n \n    Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n "}, {"sha": "cdb8a98fd582c82f4f34e8dbdc339af38b83908f", "filename": "gcc/ada/libgnat/a-cfhase.adb", "status": "modified", "additions": 118, "deletions": 94, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -136,15 +136,16 @@ is\n             ENode :=\n               Find\n                 (Container => Right,\n-                 Item      => Left.Nodes (Node).Element).Node;\n+                 Item      => Left.Content.Nodes (Node).Element).Node;\n \n             if ENode = 0\n-              or else Right.Nodes (ENode).Element /= Left.Nodes (Node).Element\n+              or else Right.Content.Nodes (ENode).Element /=\n+              Left.Content.Nodes (Node).Element\n             then\n                return False;\n             end if;\n \n-            Node := HT_Ops.Next (Left, Node);\n+            Node := HT_Ops.Next (Left.Content, Node);\n          end loop;\n \n          return True;\n@@ -166,7 +167,7 @@ is\n       --------------------\n \n       procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.Nodes (Source_Node);\n+         N : Node_Type renames Source.Content.Nodes (Source_Node);\n          X : Count_Type;\n          B : Boolean;\n \n@@ -186,8 +187,8 @@ is\n          raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n       end if;\n \n-      HT_Ops.Clear (Target);\n-      Insert_Elements (Source);\n+      HT_Ops.Clear (Target.Content);\n+      Insert_Elements (Source.Content);\n    end Assign;\n \n    --------------\n@@ -196,7 +197,7 @@ is\n \n    function Capacity (Container : Set) return Count_Type is\n    begin\n-      return Container.Nodes'Length;\n+      return Container.Content.Nodes'Length;\n    end Capacity;\n \n    -----------\n@@ -205,9 +206,28 @@ is\n \n    procedure Clear (Container : in out Set) is\n    begin\n-      HT_Ops.Clear (Container);\n+      HT_Ops.Clear (Container.Content);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor equals No_Element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container, Position), \"bad cursor in function Element\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -237,18 +257,18 @@ is\n          raise Capacity_Error;\n       end if;\n \n-      Target.Length := Source.Length;\n-      Target.Free := Source.Free;\n+      Target.Content.Length := Source.Content.Length;\n+      Target.Content.Free := Source.Content.Free;\n \n       H := 1;\n       while H <= Source.Modulus loop\n-         Target.Buckets (H) := Source.Buckets (H);\n+         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n          H := H + 1;\n       end loop;\n \n       N := 1;\n       while N <= Source.Capacity loop\n-         Target.Nodes (N) := Source.Nodes (N);\n+         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n          N := N + 1;\n       end loop;\n \n@@ -278,7 +298,7 @@ is\n       X : Count_Type;\n \n    begin\n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n \n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n@@ -295,7 +315,7 @@ is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n \n-      HT_Ops.Delete_Node_Sans_Free (Container, Position.Node);\n+      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n       Free (Container, Position.Node);\n \n       Position := No_Element;\n@@ -311,53 +331,54 @@ is\n       Src_Node   : Count_Type;\n       Tgt_Node   : Count_Type;\n \n-      TN : Nodes_Type renames Target.Nodes;\n-      SN : Nodes_Type renames Source.Nodes;\n+      TN : Nodes_Type renames Target.Content.Nodes;\n+      SN : Nodes_Type renames Source.Content.Nodes;\n \n    begin\n       if Target'Address = Source'Address then\n          Clear (Target);\n          return;\n       end if;\n \n-      Src_Length := Source.Length;\n+      Src_Length := Source.Content.Length;\n \n       if Src_Length = 0 then\n          return;\n       end if;\n \n-      if Src_Length >= Target.Length then\n-         Tgt_Node := HT_Ops.First (Target);\n+      if Src_Length >= Target.Content.Length then\n+         Tgt_Node := HT_Ops.First (Target.Content);\n          while Tgt_Node /= 0 loop\n-            if Element_Keys.Find (Source, TN (Tgt_Node).Element) /= 0 then\n+            if Element_Keys.Find (Source.Content, TN (Tgt_Node).Element) /= 0\n+            then\n                declare\n                   X : constant Count_Type := Tgt_Node;\n                begin\n-                  Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-                  HT_Ops.Delete_Node_Sans_Free (Target, X);\n+                  Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n+                  HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n                   Free (Target, X);\n                end;\n \n             else\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n             end if;\n          end loop;\n \n          return;\n       else\n-         Src_Node := HT_Ops.First (Source);\n+         Src_Node := HT_Ops.First (Source.Content);\n          Src_Last := 0;\n       end if;\n \n       while Src_Node /= Src_Last loop\n-         Tgt_Node := Element_Keys.Find (Target, SN (Src_Node).Element);\n+         Tgt_Node := Element_Keys.Find (Target.Content, SN (Src_Node).Element);\n \n          if Tgt_Node /= 0 then\n-            HT_Ops.Delete_Node_Sans_Free (Target, Tgt_Node);\n+            HT_Ops.Delete_Node_Sans_Free (Target.Content, Tgt_Node);\n             Free (Target, Tgt_Node);\n          end if;\n \n-         Src_Node := HT_Ops.Next (Source, Src_Node);\n+         Src_Node := HT_Ops.Next (Source.Content, Src_Node);\n       end loop;\n    end Difference;\n \n@@ -373,7 +394,7 @@ is\n \n       procedure Process (L_Node : Count_Type) is\n          B : Boolean;\n-         E : Element_Type renames Left.Nodes (L_Node).Element;\n+         E : Element_Type renames Left.Content.Nodes (L_Node).Element;\n          X : Count_Type;\n \n       begin\n@@ -386,7 +407,7 @@ is\n    --  Start of processing for Difference\n \n    begin\n-      Iterate (Left);\n+      Iterate (Left.Content);\n    end Difference;\n \n    function Difference (Left : Set; Right : Set) return Set is\n@@ -403,7 +424,7 @@ is\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       C := Length (Left);\n@@ -430,7 +451,7 @@ is\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in function Element\");\n \n-      return Container.Nodes (Position.Node).Element;\n+      return Container.Content.Nodes (Position.Node).Element;\n    end Element;\n \n    ---------------------\n@@ -479,7 +500,7 @@ is\n    --  Start of processing for Equivalent_Sets\n \n    begin\n-      return Is_Equivalent (Left, Right);\n+      return Is_Equivalent (Left.Content, Right.Content);\n    end Equivalent_Sets;\n \n    ---------------------\n@@ -501,7 +522,7 @@ is\n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : Count_Type;\n    begin\n-      Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n+      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n       Free (Container, X);\n    end Exclude;\n \n@@ -513,7 +534,8 @@ is\n      (Container : Set;\n       Item      : Element_Type) return Cursor\n    is\n-      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container.Content, Item);\n \n    begin\n       if Node = 0 then\n@@ -528,7 +550,7 @@ is\n    -----------\n \n    function First (Container : Set) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container);\n+      Node : constant Count_Type := HT_Ops.First (Container.Content);\n \n    begin\n       if Node = 0 then\n@@ -632,16 +654,16 @@ is\n       --------------\n \n       function Elements (Container : Set) return E.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : E.Sequence;\n \n       begin\n          --  Can't use First, Next or Element here, since they depend on models\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := E.Add (R, Container.Nodes (Position).Element);\n-            Position := HT_Ops.Next (Container, Position);\n+            R := E.Add (R, Container.Content.Nodes (Position).Element);\n+            Position := HT_Ops.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -710,7 +732,7 @@ is\n       -----------\n \n       function Model (Container : Set) return M.Set is\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : M.Set;\n \n       begin\n@@ -721,9 +743,9 @@ is\n             R :=\n               M.Add\n                 (Container => R,\n-                 Item      => Container.Nodes (Position).Element);\n+                 Item      => Container.Content.Nodes (Position).Element);\n \n-            Position := HT_Ops.Next (Container, Position);\n+            Position := HT_Ops.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -735,7 +757,7 @@ is\n \n       function Positions (Container : Set) return P.Map is\n          I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container);\n+         Position : Count_Type := HT_Ops.First (Container.Content);\n          R        : P.Map;\n \n       begin\n@@ -745,7 +767,7 @@ is\n          while Position /= 0 loop\n             R := P.Add (R, (Node => Position), I);\n             pragma Assert (P.Length (R) = I);\n-            Position := HT_Ops.Next (Container, Position);\n+            Position := HT_Ops.Next (Container.Content, Position);\n             I := I + 1;\n          end loop;\n \n@@ -762,8 +784,8 @@ is\n    begin\n       if X /= 0 then\n          pragma Assert (X <= HT.Capacity);\n-         HT.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT, X);\n+         HT.Content.Nodes (X).Has_Element := False;\n+         HT_Ops.Free (HT.Content, X);\n       end if;\n    end Free;\n \n@@ -774,8 +796,8 @@ is\n    procedure Generic_Allocate (HT : in out Set; Node : out Count_Type) is\n       procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n    begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n+      Allocate (HT.Content, Node);\n+      HT.Content.Nodes (Node).Has_Element := True;\n    end Generic_Allocate;\n \n    package body Generic_Keys with SPARK_Mode => Off is\n@@ -821,7 +843,7 @@ is\n          X : Count_Type;\n \n       begin\n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n \n          if X = 0 then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n@@ -845,7 +867,7 @@ is\n             raise Constraint_Error with \"key not in map\";\n          end if;\n \n-         return Container.Nodes (Node).Element;\n+         return Container.Content.Nodes (Node).Element;\n       end Element;\n \n       -------------------------\n@@ -867,7 +889,7 @@ is\n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n          X : Count_Type;\n       begin\n-         Key_Keys.Delete_Key_Sans_Free (Container, Key, X);\n+         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n          Free (Container, X);\n       end Exclude;\n \n@@ -879,7 +901,7 @@ is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n       begin\n          return (if Node = 0 then No_Element else (Node => Node));\n       end Find;\n@@ -927,7 +949,7 @@ is\n            (Vet (Container, Position), \"bad cursor in function Key\");\n \n          declare\n-            N  : Node_Type renames Container.Nodes (Position.Node);\n+            N  : Node_Type renames Container.Content.Nodes (Position.Node);\n          begin\n             return Key (N.Element);\n          end;\n@@ -942,14 +964,14 @@ is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n \n       begin\n          if Node = 0 then\n             raise Constraint_Error with \"attempt to replace key not in set\";\n          end if;\n \n-         Replace_Element (Container, Node, New_Item);\n+         Replace_Element (Container.Content, Node, New_Item);\n       end Replace;\n \n    end Generic_Keys;\n@@ -961,7 +983,7 @@ is\n    function Has_Element (Container : Set; Position : Cursor) return Boolean is\n    begin\n       if Position.Node = 0\n-        or else not Container.Nodes (Position.Node).Has_Element\n+        or else not Container.Content.Nodes (Position.Node).Has_Element\n       then\n          return False;\n       end if;\n@@ -990,7 +1012,7 @@ is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         Container.Nodes (Position.Node).Element := New_Item;\n+         Container.Content.Nodes (Position.Node).Element := New_Item;\n       end if;\n    end Include;\n \n@@ -1062,7 +1084,7 @@ is\n    --  Start of processing for Insert\n \n    begin\n-      Local_Insert (Container, New_Item, Node, Inserted);\n+      Local_Insert (Container.Content, New_Item, Node, Inserted);\n    end Insert;\n \n    ------------------\n@@ -1071,29 +1093,29 @@ is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n       Tgt_Node : Count_Type;\n-      TN       : Nodes_Type renames Target.Nodes;\n+      TN       : Nodes_Type renames Target.Content.Nodes;\n \n    begin\n       if Target'Address = Source'Address then\n          return;\n       end if;\n \n-      if Source.Length = 0 then\n+      if Source.Content.Length = 0 then\n          Clear (Target);\n          return;\n       end if;\n \n-      Tgt_Node := HT_Ops.First (Target);\n+      Tgt_Node := HT_Ops.First (Target.Content);\n       while Tgt_Node /= 0 loop\n          if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n-            Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n+            Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n \n          else\n             declare\n                X : constant Count_Type := Tgt_Node;\n             begin\n-               Tgt_Node := HT_Ops.Next (Target, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target, X);\n+               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n+               HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n                Free (Target, X);\n             end;\n          end if;\n@@ -1111,7 +1133,7 @@ is\n       -------------\n \n       procedure Process (L_Node : Count_Type) is\n-         E : Element_Type renames Left.Nodes (L_Node).Element;\n+         E : Element_Type renames Left.Content.Nodes (L_Node).Element;\n          X : Count_Type;\n          B : Boolean;\n \n@@ -1125,7 +1147,7 @@ is\n    --  Start of processing for Intersection\n \n    begin\n-      Iterate (Left);\n+      Iterate (Left.Content);\n    end Intersection;\n \n    function Intersection (Left : Set; Right : Set) return Set is\n@@ -1134,7 +1156,7 @@ is\n \n    begin\n       if Left'Address = Right'Address then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       C := Count_Type'Min (Length (Left), Length (Right));  -- ???\n@@ -1162,7 +1184,7 @@ is\n \n    function Is_In (HT : Set; Key : Node_Type) return Boolean is\n    begin\n-      return Element_Keys.Find (HT, Key.Element) /= 0;\n+      return Element_Keys.Find (HT.Content, Key.Element) /= 0;\n    end Is_In;\n \n    ---------------\n@@ -1171,7 +1193,7 @@ is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n       Subset_Node  : Count_Type;\n-      Subset_Nodes : Nodes_Type renames Subset.Nodes;\n+      Subset_Nodes : Nodes_Type renames Subset.Content.Nodes;\n \n    begin\n       if Subset'Address = Of_Set'Address then\n@@ -1194,7 +1216,7 @@ is\n             end if;\n          end;\n \n-         Subset_Node := HT_Ops.Next (Subset, Subset_Node);\n+         Subset_Node := HT_Ops.Next (Subset.Content, Subset_Node);\n       end loop;\n \n       return True;\n@@ -1206,7 +1228,7 @@ is\n \n    function Length (Container : Set) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.Content.Length;\n    end Length;\n \n    ----------\n@@ -1216,7 +1238,7 @@ is\n    --  Comments???\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n-      NN   : HT_Types.Nodes_Type renames Source.Nodes;\n+      NN   : HT_Types.Nodes_Type renames Source.Content.Nodes;\n       X, Y : Count_Type;\n \n    begin\n@@ -1231,17 +1253,17 @@ is\n \n       Clear (Target);\n \n-      if Source.Length = 0 then\n+      if Source.Content.Length = 0 then\n          return;\n       end if;\n \n-      X := HT_Ops.First (Source);\n+      X := HT_Ops.First (Source.Content);\n       while X /= 0 loop\n          Insert (Target, NN (X).Element);  -- optimize???\n \n-         Y := HT_Ops.Next (Source, X);\n+         Y := HT_Ops.Next (Source.Content, X);\n \n-         HT_Ops.Delete_Node_Sans_Free (Source, X);\n+         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n          Free (Source, X);\n \n          X := Y;\n@@ -1269,7 +1291,7 @@ is\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n \n-      return (Node => HT_Ops.Next (Container, Position.Node));\n+      return (Node => HT_Ops.Next (Container.Content, Position.Node));\n    end Next;\n \n    procedure Next (Container : Set; Position : in out Cursor) is\n@@ -1283,7 +1305,7 @@ is\n \n    function Overlap (Left, Right : Set) return Boolean is\n       Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.Nodes;\n+      Left_Nodes : Nodes_Type renames Left.Content.Nodes;\n \n    begin\n       if Length (Right) = 0 or Length (Left) = 0 then\n@@ -1305,7 +1327,7 @@ is\n             end if;\n          end;\n \n-         Left_Node := HT_Ops.Next (Left, Left_Node);\n+         Left_Node := HT_Ops.Next (Left.Content, Left_Node);\n       end loop;\n \n       return False;\n@@ -1316,14 +1338,15 @@ is\n    -------------\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-      Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container.Content, New_Item);\n \n    begin\n       if Node = 0 then\n          raise Constraint_Error with \"attempt to replace element not in set\";\n       end if;\n \n-      Container.Nodes (Node).Element := New_Item;\n+      Container.Content.Nodes (Node).Element := New_Item;\n    end Replace;\n \n    ---------------------\n@@ -1343,7 +1366,7 @@ is\n       pragma Assert\n         (Vet (Container, Position), \"bad cursor in Replace_Element\");\n \n-      Replace_Element (Container, Position.Node, New_Item);\n+      Replace_Element (Container.Content, Position.Node, New_Item);\n    end Replace_Element;\n \n    ----------------------\n@@ -1394,7 +1417,7 @@ is\n \n       procedure Process (Source_Node : Count_Type) is\n          B : Boolean;\n-         N : Node_Type renames Source.Nodes (Source_Node);\n+         N : Node_Type renames Source.Content.Nodes (Source_Node);\n          X : Count_Type;\n \n       begin\n@@ -1419,7 +1442,7 @@ is\n          return;\n       end if;\n \n-      Iterate (Source);\n+      Iterate (Source.Content);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left : Set; Right : Set) return Set is\n@@ -1432,11 +1455,11 @@ is\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       if Length (Left) = 0 then\n-         return Right.Copy;\n+         return Copy (Right);\n       end if;\n \n       C := Length (Left) + Length (Right);\n@@ -1478,7 +1501,7 @@ is\n       -------------\n \n       procedure Process (Src_Node : Count_Type) is\n-         N : Node_Type renames Source.Nodes (Src_Node);\n+         N : Node_Type renames Source.Content.Nodes (Src_Node);\n          E : Element_Type renames N.Element;\n \n          X : Count_Type;\n@@ -1495,7 +1518,7 @@ is\n          return;\n       end if;\n \n-      Iterate (Source);\n+      Iterate (Source.Content);\n    end Union;\n \n    function Union (Left : Set; Right : Set) return Set is\n@@ -1504,15 +1527,15 @@ is\n \n    begin\n       if Left'Address = Right'Address then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       if Length (Left) = 0 then\n-         return Right.Copy;\n+         return Copy (Right);\n       end if;\n \n       C := Length (Left) + Length (Right);\n@@ -1535,11 +1558,11 @@ is\n \n       declare\n          S : Set renames Container;\n-         N : Nodes_Type renames S.Nodes;\n+         N : Nodes_Type renames S.Content.Nodes;\n          X : Count_Type;\n \n       begin\n-         if S.Length = 0 then\n+         if S.Content.Length = 0 then\n             return False;\n          end if;\n \n@@ -1551,9 +1574,10 @@ is\n             return False;\n          end if;\n \n-         X := S.Buckets (Element_Keys.Index (S, N (Position.Node).Element));\n+         X := S.Content.Buckets\n+           (Element_Keys.Index (S.Content, N (Position.Node).Element));\n \n-         for J in 1 .. S.Length loop\n+         for J in 1 .. S.Content.Length loop\n             if X = Position.Node then\n                return True;\n             end if;"}, {"sha": "9bcd8cedb4ccbe2ab4cd00868bfee505abee112d", "filename": "gcc/ada/libgnat/a-cfhase.ads", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -515,6 +515,16 @@ is\n                  Position => Position)\n           and Positions (Container) = Positions (Container)'Old;\n \n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n+\n    procedure Move (Target : in out Set; Source : in out Set) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n@@ -1462,16 +1472,17 @@ private\n \n    type Node_Type is\n       record\n-         Element     : Element_Type;\n+         Element     : aliased Element_Type;\n          Next        : Count_Type;\n          Has_Element : Boolean := False;\n       end record;\n \n    package HT_Types is new\n      Ada.Containers.Hash_Tables.Generic_Bounded_Hash_Table_Types (Node_Type);\n \n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is\n-     new HT_Types.Hash_Table_Type (Capacity, Modulus) with null record;\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is record\n+     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n+   end record;\n \n    use HT_Types;\n "}, {"sha": "d0c7e82ac8f9f95d6a67cc2aa5c32ad5c2e5a2c1", "filename": "gcc/ada/libgnat/a-cfinve.adb", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -184,6 +184,28 @@ is\n       Free (Container.Elements_Ptr);\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return not null access constant Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n+\n+      begin\n+         return Constant_Reference (Elemsc (Container) (I));\n+      end;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1180,6 +1202,32 @@ is\n       Insert (Container, Index_Type'First, New_Item, Count);\n    end Prepend;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference\n+     (Container : not null access Vector;\n+      Index     : Index_Type) return not null access Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      declare\n+         II : constant Int'Base := Int (Index) - Int (No_Index);\n+         I  : constant Capacity_Range := Capacity_Range (II);\n+\n+      begin\n+         if Container.Elements_Ptr = null then\n+            return Reference (Container.Elements (I)'Access);\n+         else\n+            return Reference (Container.Elements_Ptr (I)'Access);\n+         end if;\n+      end;\n+   end Reference;\n+\n    ---------------------\n    -- Replace_Element --\n    ---------------------"}, {"sha": "9b9543756905d61c31877f4d02c266e721140dc4", "filename": "gcc/ada/libgnat/a-cfinve.ads", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -311,6 +311,48 @@ is\n                 Right    => Model (Container),\n                 Position => Index);\n \n+   function At_End (E : access constant Vector) return access constant Vector\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+         Constant_Reference'Result.all = Element (Model (Container), Index);\n+\n+   function Reference\n+     (Container : not null access Vector;\n+      Index     : Index_Type) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    =>\n+      Index in First_Index (Container.all) .. Last_Index (Container.all),\n+     Post   =>\n+      Length (Container.all) = Length (At_End (Container).all)\n+\n+         --  Container will have Result.all at index Index\n+\n+         and At_End (Reference'Result).all =\n+           Element (Model (At_End (Container).all), Index)\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Left     => Model (Container.all),\n+                Right    => Model (At_End (Container).all),\n+                Position => Index);\n+\n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n@@ -909,7 +951,7 @@ private\n    use Holders;\n \n    subtype Array_Index is Capacity_Range range 1 .. Capacity_Range'Last;\n-   type Elements_Array is array (Array_Index range <>) of Holder;\n+   type Elements_Array is array (Array_Index range <>) of aliased Holder;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n    type Elements_Array_Ptr is access all Elements_Array;"}, {"sha": "45f9be73f558aff4c6652ac15141b3282f315ad3", "filename": "gcc/ada/libgnat/a-cforma.adb", "status": "modified", "additions": 153, "deletions": 83, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -133,19 +133,20 @@ is\n          return True;\n       end if;\n \n-      Lst := Next (Left, Last (Left).Node);\n+      Lst := Next (Left.Content, Last (Left).Node);\n \n       Node := First (Left).Node;\n       while Node /= Lst loop\n-         ENode := Find (Right, Left.Nodes (Node).Key).Node;\n+         ENode := Find (Right, Left.Content.Nodes (Node).Key).Node;\n \n          if ENode = 0 or else\n-           Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n+           Left.Content.Nodes (Node).Element /=\n+           Right.Content.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n \n-         Node := Next (Left, Node);\n+         Node := Next (Left.Content, Node);\n       end loop;\n \n       return True;\n@@ -166,7 +167,7 @@ is\n       --------------------\n \n       procedure Append_Element (Source_Node : Count_Type) is\n-         SN : Node_Type renames Source.Nodes (Source_Node);\n+         SN : Node_Type renames Source.Content.Nodes (Source_Node);\n \n          procedure Set_Element (Node : in out Node_Type);\n          pragma Inline (Set_Element);\n@@ -193,7 +194,7 @@ is\n          function New_Node return Count_Type is\n             Result : Count_Type;\n          begin\n-            Allocate (Target, Result);\n+            Allocate (Target.Content, Result);\n             return Result;\n          end New_Node;\n \n@@ -213,7 +214,7 @@ is\n \n       begin\n          Unconditional_Insert_Avec_Hint\n-           (Tree  => Target,\n+           (Tree  => Target.Content,\n             Hint  => 0,\n             Key   => SN.Key,\n             Node  => Target_Node);\n@@ -230,16 +231,16 @@ is\n          raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n       end if;\n \n-      Tree_Operations.Clear_Tree (Target);\n-      Append_Elements (Source);\n+      Tree_Operations.Clear_Tree (Target.Content);\n+      Append_Elements (Source.Content);\n    end Assign;\n \n    -------------\n    -- Ceiling --\n    -------------\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Ceiling (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Ceiling (Container.Content, Key);\n \n    begin\n       if Node = 0 then\n@@ -255,7 +256,7 @@ is\n \n    procedure Clear (Container : in out Map) is\n    begin\n-      Tree_Operations.Clear_Tree (Container);\n+      Tree_Operations.Clear_Tree (Container.Content);\n    end Clear;\n \n    -----------\n@@ -267,6 +268,40 @@ is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Content, Position.Node),\n+                     \"bad cursor in function Constant_Reference\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Constant_Reference;\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return not null access constant Element_Type\n+   is\n+      Node : constant Node_Access := Find (Container, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.Content.Nodes (Node).Element'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -291,33 +326,33 @@ is\n \n       return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n          if Length (Source) > 0 then\n-            Target.Length := Source.Length;\n-            Target.Root := Source.Root;\n-            Target.First := Source.First;\n-            Target.Last := Source.Last;\n-            Target.Free := Source.Free;\n+            Target.Content.Length := Source.Content.Length;\n+            Target.Content.Root := Source.Content.Root;\n+            Target.Content.First := Source.Content.First;\n+            Target.Content.Last := Source.Content.Last;\n+            Target.Content.Free := Source.Content.Free;\n \n             while Node <= Source.Capacity loop\n-               Target.Nodes (Node).Element :=\n-                 Source.Nodes (Node).Element;\n-               Target.Nodes (Node).Key :=\n-                 Source.Nodes (Node).Key;\n-               Target.Nodes (Node).Parent :=\n-                 Source.Nodes (Node).Parent;\n-               Target.Nodes (Node).Left :=\n-                 Source.Nodes (Node).Left;\n-               Target.Nodes (Node).Right :=\n-                 Source.Nodes (Node).Right;\n-               Target.Nodes (Node).Color :=\n-                 Source.Nodes (Node).Color;\n-               Target.Nodes (Node).Has_Element :=\n-                 Source.Nodes (Node).Has_Element;\n+               Target.Content.Nodes (Node).Element :=\n+                 Source.Content.Nodes (Node).Element;\n+               Target.Content.Nodes (Node).Key :=\n+                 Source.Content.Nodes (Node).Key;\n+               Target.Content.Nodes (Node).Parent :=\n+                 Source.Content.Nodes (Node).Parent;\n+               Target.Content.Nodes (Node).Left :=\n+                 Source.Content.Nodes (Node).Left;\n+               Target.Content.Nodes (Node).Right :=\n+                 Source.Content.Nodes (Node).Right;\n+               Target.Content.Nodes (Node).Color :=\n+                 Source.Content.Nodes (Node).Color;\n+               Target.Content.Nodes (Node).Has_Element :=\n+                 Source.Content.Nodes (Node).Has_Element;\n                Node := Node + 1;\n             end loop;\n \n             while Node <= Target.Capacity loop\n                N := Node;\n-               Formal_Ordered_Maps.Free (Tree => Target, X => N);\n+               Free (Tree => Target, X => N);\n                Node := Node + 1;\n             end loop;\n          end if;\n@@ -335,25 +370,25 @@ is\n            \"Position cursor of Delete has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"Position cursor of Delete is bad\");\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container,\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Content,\n                                              Position.Node);\n-      Formal_Ordered_Maps.Free (Container, Position.Node);\n+      Free (Container, Position.Node);\n       Position := No_Element;\n    end Delete;\n \n    procedure Delete (Container : in out Map; Key : Key_Type) is\n-      X : constant Node_Access := Key_Ops.Find (Container, Key);\n+      X : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n \n    begin\n       if X = 0 then\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-      Formal_Ordered_Maps.Free (Container, X);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+      Free (Container, X);\n    end Delete;\n \n    ------------------\n@@ -364,8 +399,8 @@ is\n       X : constant Node_Access := First (Container).Node;\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Maps.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Delete_First;\n \n@@ -377,8 +412,8 @@ is\n       X : constant Node_Access := Last (Container).Node;\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Maps.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Delete_Last;\n \n@@ -393,10 +428,10 @@ is\n            \"Position cursor of function Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"Position cursor of function Element is bad\");\n \n-      return Container.Nodes (Position.Node).Element;\n+      return Container.Content.Nodes (Position.Node).Element;\n \n    end Element;\n \n@@ -408,7 +443,7 @@ is\n          raise Constraint_Error with \"key not in map\";\n       end if;\n \n-      return Container.Nodes (Node).Element;\n+      return Container.Content.Nodes (Node).Element;\n    end Element;\n \n    ---------------------\n@@ -431,11 +466,11 @@ is\n    -------------\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n-      X : constant Node_Access := Key_Ops.Find (Container, Key);\n+      X : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Maps.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Exclude;\n \n@@ -444,7 +479,7 @@ is\n    ----------\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n \n    begin\n       if Node = 0 then\n@@ -464,7 +499,7 @@ is\n          return No_Element;\n       end if;\n \n-      return (Node => Container.First);\n+      return (Node => Container.Content.First);\n    end First;\n \n    -------------------\n@@ -477,7 +512,7 @@ is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Nodes (First (Container).Node).Element;\n+      return Container.Content.Nodes (First (Container).Node).Element;\n    end First_Element;\n \n    ---------------\n@@ -490,15 +525,15 @@ is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Nodes (First (Container).Node).Key;\n+      return Container.Content.Nodes (First (Container).Node).Key;\n    end First_Key;\n \n    -----------\n    -- Floor --\n    -----------\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Floor (Container, Key);\n+      Node : constant Count_Type := Key_Ops.Floor (Container.Content, Key);\n \n    begin\n       if Node = 0 then\n@@ -602,16 +637,16 @@ is\n       ----------\n \n       function Keys (Container : Map) return K.Sequence is\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : K.Sequence;\n \n       begin\n          --  Can't use First, Next or Element here, since they depend on models\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := K.Add (R, Container.Nodes (Position).Key);\n-            Position := Tree_Operations.Next (Container, Position);\n+            R := K.Add (R, Container.Content.Nodes (Position).Key);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -628,7 +663,7 @@ is\n       -----------\n \n       function Model (Container : Map) return M.Map is\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : M.Map;\n \n       begin\n@@ -639,10 +674,10 @@ is\n             R :=\n               M.Add\n                 (Container => R,\n-                 New_Key   => Container.Nodes (Position).Key,\n-                 New_Item  => Container.Nodes (Position).Element);\n+                 New_Key   => Container.Content.Nodes (Position).Key,\n+                 New_Item  => Container.Content.Nodes (Position).Element);\n \n-            Position := Tree_Operations.Next (Container, Position);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -701,7 +736,7 @@ is\n \n       function Positions (Container : Map) return P.Map is\n          I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : P.Map;\n \n       begin\n@@ -711,7 +746,7 @@ is\n          while Position /= 0 loop\n             R := P.Add (R, (Node => Position), I);\n             pragma Assert (P.Length (R) = I);\n-            Position := Tree_Operations.Next (Container, Position);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n             I := I + 1;\n          end loop;\n \n@@ -729,8 +764,8 @@ is\n       X  : Count_Type)\n    is\n    begin\n-      Tree.Nodes (X).Has_Element := False;\n-      Tree_Operations.Free (Tree, X);\n+      Tree.Content.Nodes (X).Has_Element := False;\n+      Tree_Operations.Free (Tree.Content, X);\n    end Free;\n \n    ----------------------\n@@ -758,7 +793,7 @@ is\n          return False;\n       end if;\n \n-      return Container.Nodes (Position.Node).Has_Element;\n+      return Container.Content.Nodes (Position.Node).Has_Element;\n    end Has_Element;\n \n    -------------\n@@ -778,7 +813,7 @@ is\n \n       if not Inserted then\n          declare\n-            N : Node_Type renames Container.Nodes (Position.Node);\n+            N : Node_Type renames Container.Content.Nodes (Position.Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -819,15 +854,15 @@ is\n          X : Node_Access;\n \n       begin\n-         Allocate_Node (Container, X);\n+         Allocate_Node (Container.Content, X);\n          return X;\n       end New_Node;\n \n    --  Start of processing for Insert\n \n    begin\n       Insert_Sans_Hint\n-        (Container,\n+        (Container.Content,\n          Key,\n          Position.Node,\n          Inserted);\n@@ -895,10 +930,10 @@ is\n            \"Position cursor of function Key has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"Position cursor of function Key is bad\");\n \n-      return Container.Nodes (Position.Node).Key;\n+      return Container.Content.Nodes (Position.Node).Key;\n    end Key;\n \n    ----------\n@@ -911,7 +946,7 @@ is\n          return No_Element;\n       end if;\n \n-      return (Node => Container.Last);\n+      return (Node => Container.Content.Last);\n    end Last;\n \n    ------------------\n@@ -924,7 +959,7 @@ is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Nodes (Last (Container).Node).Element;\n+      return Container.Content.Nodes (Last (Container).Node).Element;\n    end Last_Element;\n \n    --------------\n@@ -937,7 +972,7 @@ is\n          raise Constraint_Error with \"map is empty\";\n       end if;\n \n-      return Container.Nodes (Last (Container).Node).Key;\n+      return Container.Content.Nodes (Last (Container).Node).Key;\n    end Last_Key;\n \n    --------------\n@@ -955,15 +990,15 @@ is\n \n    function Length (Container : Map) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.Content.Length;\n    end Length;\n \n    ----------\n    -- Move --\n    ----------\n \n    procedure Move (Target : in out Map; Source : in out Map) is\n-      NN : Tree_Types.Nodes_Type renames Source.Nodes;\n+      NN : Tree_Types.Nodes_Type renames Source.Content.Nodes;\n       X  : Node_Access;\n \n    begin\n@@ -989,7 +1024,7 @@ is\n \n          Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n \n-         Tree_Operations.Delete_Node_Sans_Free (Source, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Source.Content, X);\n          Formal_Ordered_Maps.Free (Source, X);\n       end loop;\n    end Move;\n@@ -1013,10 +1048,10 @@ is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Next\");\n \n-      return (Node => Tree_Operations.Next (Container, Position.Node));\n+      return (Node => Tree_Operations.Next (Container.Content, Position.Node));\n    end Next;\n \n    ------------\n@@ -1047,12 +1082,12 @@ is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Previous\");\n \n       declare\n          Node : constant Count_Type :=\n-           Tree_Operations.Previous (Container, Position.Node);\n+           Tree_Operations.Previous (Container.Content, Position.Node);\n \n       begin\n          if Node = 0 then\n@@ -1063,6 +1098,41 @@ is\n       end;\n    end Previous;\n \n+   --------------\n+   -- Reference --\n+   --------------\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Position  : Cursor) return not null access Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container.all, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert\n+        (Vet (Container.Content, Position.Node),\n+         \"bad cursor in function Reference\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Reference;\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Key       : Key_Type) return not null access Element_Type\n+   is\n+      Node : constant Count_Type := Find (Container.all, Key).Node;\n+\n+   begin\n+      if Node = 0 then\n+         raise Constraint_Error with\n+           \"no element available because key not in map\";\n+      end if;\n+\n+      return Container.Content.Nodes (Node).Element'Access;\n+   end Reference;\n+\n    -------------\n    -- Replace --\n    -------------\n@@ -1074,15 +1144,15 @@ is\n    is\n    begin\n       declare\n-         Node : constant Node_Access := Key_Ops.Find (Container, Key);\n+         Node : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n \n       begin\n          if Node = 0 then\n             raise Constraint_Error with \"key not in map\";\n          end if;\n \n          declare\n-            N : Node_Type renames Container.Nodes (Node);\n+            N : Node_Type renames Container.Content.Nodes (Node);\n          begin\n             N.Key := Key;\n             N.Element := New_Item;\n@@ -1105,10 +1175,10 @@ is\n            \"Position cursor of Replace_Element has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"Position cursor of Replace_Element is bad\");\n \n-      Container.Nodes (Position.Node).Element := New_Item;\n+      Container.Content.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n    ---------------"}, {"sha": "a1cad031c76f957c7724ddaf908b29c26da80833", "filename": "gcc/ada/libgnat/a-cforma.ads", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -400,6 +400,95 @@ is\n                 Model (Container)'Old,\n                 Key (Container, Position));\n \n+   function At_End\n+     (E : not null access constant Map) return not null access constant Map\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+           Element (Model (Container), Key (Container, Position));\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Position  : Cursor) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container.all, Position),\n+     Post   =>\n+\n+       --  Order of keys and cursors is preserved\n+\n+       Keys (At_End (Container).all) = Keys (Container.all)\n+         and Positions (At_End (Container).all) = Positions (Container.all)\n+\n+         --  The value designated by the result of Reference is now associated\n+         --  with the key at position Position in Container.\n+\n+         and Element (At_End (Container).all, Position) =\n+               At_End (Reference'Result).all\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys\n+               (Model (At_End (Container).all),\n+                Model (Container.all))\n+         and M.Elements_Equal_Except\n+               (Model (At_End (Container).all),\n+                Model (Container.all),\n+                Key (At_End (Container).all, Position));\n+\n+   function Constant_Reference\n+     (Container : aliased Map;\n+      Key       : Key_Type) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Contains (Container, Key),\n+     Post   =>\n+       Constant_Reference'Result.all = Element (Model (Container), Key);\n+\n+   function Reference\n+     (Container : not null access Map;\n+      Key       : Key_Type) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    => Contains (Container.all, Key),\n+     Post   =>\n+\n+       --  Order of keys and cursors is preserved\n+\n+       Keys (At_End (Container).all) = Keys (Container.all)\n+         and Positions (At_End (Container).all) = Positions (Container.all)\n+\n+         --  The value designated by the result of Reference is now associated\n+         --  with Key in Container.\n+\n+         and Element (Model (At_End (Container).all), Key) =\n+               At_End (Reference'Result).all\n+\n+         --  Elements associated with other keys are preserved\n+\n+         and M.Same_Keys\n+               (Model (At_End (Container).all),\n+                Model (Container.all))\n+         and M.Elements_Equal_Except\n+               (Model (At_End (Container).all),\n+                Model (Container.all),\n+                Key);\n+\n    procedure Move (Target : in out Map; Source : in out Map) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n@@ -1045,14 +1134,15 @@ private\n       Right   : Node_Access := 0;\n       Color   : Red_Black_Trees.Color_Type := Red;\n       Key     : Key_Type;\n-      Element : Element_Type;\n+      Element : aliased Element_Type;\n    end record;\n \n    package Tree_Types is\n      new Ada.Containers.Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n \n-   type Map (Capacity : Count_Type) is\n-     new Tree_Types.Tree_Type (Capacity) with null record;\n+   type Map (Capacity : Count_Type) is record\n+     Content : Tree_Types.Tree_Type (Capacity);\n+   end record;\n \n    Empty_Map : constant Map := (Capacity => 0, others => <>);\n "}, {"sha": "7c45e4f1237163ec1be3526b54d59541d6f52508", "filename": "gcc/ada/libgnat/a-cforse.adb", "status": "modified", "additions": 155, "deletions": 114, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -81,6 +81,10 @@ is\n \n    --  Comments needed???\n \n+   procedure Assign\n+     (Target : in out Tree_Types.Tree_Type;\n+      Source : Tree_Types.Tree_Type);\n+\n    generic\n       with procedure Set_Element (Node : in out Node_Type);\n    procedure Generic_Allocate\n@@ -90,13 +94,13 @@ is\n    procedure Free (Tree : in out Set; X : Count_Type);\n \n    procedure Insert_Sans_Hint\n-     (Container : in out Set;\n+     (Container : in out Tree_Types.Tree_Type;\n       New_Item  : Element_Type;\n       Node      : out Count_Type;\n       Inserted  : out Boolean);\n \n    procedure Insert_With_Hint\n-     (Dst_Set  : in out Set;\n+     (Dst_Set  : in out Tree_Types.Tree_Type;\n       Dst_Hint : Count_Type;\n       Src_Node : Node_Type;\n       Dst_Node : out Count_Type);\n@@ -141,7 +145,7 @@ is\n    package Set_Ops is\n      new Red_Black_Trees.Generic_Bounded_Set_Operations\n        (Tree_Operations  => Tree_Operations,\n-        Set_Type         => Set,\n+        Set_Type         => Tree_Types.Tree_Type,\n         Assign           => Assign,\n         Insert_With_Hint => Insert_With_Hint,\n         Is_Less          => Is_Less_Node_Node);\n@@ -164,18 +168,19 @@ is\n          return True;\n       end if;\n \n-      Lst := Next (Left, Last (Left).Node);\n+      Lst := Next (Left.Content, Last (Left).Node);\n \n       Node := First (Left).Node;\n       while Node /= Lst loop\n-         ENode := Find (Right, Left.Nodes (Node).Element).Node;\n+         ENode := Find (Right, Left.Content.Nodes (Node).Element).Node;\n          if ENode = 0\n-           or else Left.Nodes (Node).Element /= Right.Nodes (ENode).Element\n+           or else Left.Content.Nodes (Node).Element /=\n+           Right.Content.Nodes (ENode).Element\n          then\n             return False;\n          end if;\n \n-         Node := Next (Left, Node);\n+         Node := Next (Left.Content, Node);\n       end loop;\n \n       return True;\n@@ -185,7 +190,10 @@ is\n    -- Assign --\n    ------------\n \n-   procedure Assign (Target : in out Set; Source : Set) is\n+   procedure Assign\n+     (Target : in out Tree_Types.Tree_Type;\n+      Source : Tree_Types.Tree_Type)\n+   is\n       procedure Append_Element (Source_Node : Count_Type);\n \n       procedure Append_Elements is\n@@ -267,12 +275,18 @@ is\n       Append_Elements (Source);\n    end Assign;\n \n+   procedure Assign (Target : in out Set; Source : Set) is\n+   begin\n+      Assign (Target.Content, Source.Content);\n+   end Assign;\n+\n    -------------\n    -- Ceiling --\n    -------------\n \n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n-      Node : constant Count_Type := Element_Keys.Ceiling (Container, Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Ceiling (Container.Content, Item);\n \n    begin\n       if Node = 0 then\n@@ -288,7 +302,7 @@ is\n \n    procedure Clear (Container : in out Set) is\n    begin\n-      Tree_Operations.Clear_Tree (Container);\n+      Tree_Operations.Clear_Tree (Container.Content);\n    end Clear;\n \n    -----------\n@@ -300,6 +314,25 @@ is\n       return Node.Color;\n    end Color;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return not null access constant Element_Type\n+   is\n+   begin\n+      if not Has_Element (Container, Position) then\n+         raise Constraint_Error with \"Position cursor has no element\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Content, Position.Node),\n+                     \"bad cursor in Element\");\n+\n+      return Container.Content.Nodes (Position.Node).Element'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -327,32 +360,32 @@ is\n       end if;\n \n       if Length (Source) > 0 then\n-         Target.Length := Source.Length;\n-         Target.Root   := Source.Root;\n-         Target.First  := Source.First;\n-         Target.Last   := Source.Last;\n-         Target.Free   := Source.Free;\n+         Target.Content.Length := Source.Content.Length;\n+         Target.Content.Root   := Source.Content.Root;\n+         Target.Content.First  := Source.Content.First;\n+         Target.Content.Last   := Source.Content.Last;\n+         Target.Content.Free   := Source.Content.Free;\n \n          Node := 1;\n          while Node <= Source.Capacity loop\n-            Target.Nodes (Node).Element :=\n-              Source.Nodes (Node).Element;\n-            Target.Nodes (Node).Parent :=\n-              Source.Nodes (Node).Parent;\n-            Target.Nodes (Node).Left :=\n-              Source.Nodes (Node).Left;\n-            Target.Nodes (Node).Right :=\n-              Source.Nodes (Node).Right;\n-            Target.Nodes (Node).Color :=\n-              Source.Nodes (Node).Color;\n-            Target.Nodes (Node).Has_Element :=\n-              Source.Nodes (Node).Has_Element;\n+            Target.Content.Nodes (Node).Element :=\n+              Source.Content.Nodes (Node).Element;\n+            Target.Content.Nodes (Node).Parent :=\n+              Source.Content.Nodes (Node).Parent;\n+            Target.Content.Nodes (Node).Left :=\n+              Source.Content.Nodes (Node).Left;\n+            Target.Content.Nodes (Node).Right :=\n+              Source.Content.Nodes (Node).Right;\n+            Target.Content.Nodes (Node).Color :=\n+              Source.Content.Nodes (Node).Color;\n+            Target.Content.Nodes (Node).Has_Element :=\n+              Source.Content.Nodes (Node).Has_Element;\n             Node := Node + 1;\n          end loop;\n \n          while Node <= Target.Capacity loop\n             N := Node;\n-            Formal_Ordered_Sets.Free (Tree => Target, X => N);\n+            Free (Tree => Target, X => N);\n             Node := Node + 1;\n          end loop;\n       end if;\n@@ -370,37 +403,37 @@ is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Delete\");\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container,\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Content,\n                                              Position.Node);\n-      Formal_Ordered_Sets.Free (Container, Position.Node);\n+      Free (Container, Position.Node);\n       Position := No_Element;\n    end Delete;\n \n    procedure Delete (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container, Item);\n+      X : constant Count_Type := Element_Keys.Find (Container.Content, Item);\n \n    begin\n       if X = 0 then\n          raise Constraint_Error with \"attempt to delete element not in set\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-      Formal_Ordered_Sets.Free (Container, X);\n+      Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+      Free (Container, X);\n    end Delete;\n \n    ------------------\n    -- Delete_First --\n    ------------------\n \n    procedure Delete_First (Container : in out Set) is\n-      X    : constant Count_Type := Container.First;\n+      X    : constant Count_Type := Container.Content.First;\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Sets.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Delete_First;\n \n@@ -409,11 +442,11 @@ is\n    -----------------\n \n    procedure Delete_Last (Container : in out Set) is\n-      X    : constant Count_Type := Container.Last;\n+      X    : constant Count_Type := Container.Content.Last;\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Sets.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Delete_Last;\n \n@@ -423,7 +456,7 @@ is\n \n    procedure Difference (Target : in out Set; Source : Set) is\n    begin\n-      Set_Ops.Set_Difference (Target, Source);\n+      Set_Ops.Set_Difference (Target.Content, Source.Content);\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n@@ -437,11 +470,12 @@ is\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       return S : Set (Length (Left)) do\n-            Assign (S, Set_Ops.Set_Difference (Left, Right));\n+         Assign\n+           (S.Content, Set_Ops.Set_Difference (Left.Content, Right.Content));\n       end return;\n    end Difference;\n \n@@ -455,10 +489,10 @@ is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Element\");\n \n-      return Container.Nodes (Position.Node).Element;\n+      return Container.Content.Nodes (Position.Node).Element;\n    end Element;\n \n    -------------------------\n@@ -506,19 +540,19 @@ is\n    --  Start of processing for Equivalent_Sets\n \n    begin\n-      return Is_Equivalent (Left, Right);\n+      return Is_Equivalent (Left.Content, Right.Content);\n    end Equivalent_Sets;\n \n    -------------\n    -- Exclude --\n    -------------\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container, Item);\n+      X : constant Count_Type := Element_Keys.Find (Container.Content, Item);\n    begin\n       if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Sets.Free (Container, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end if;\n    end Exclude;\n \n@@ -527,7 +561,8 @@ is\n    ----------\n \n    function Find (Container : Set; Item : Element_Type) return Cursor is\n-      Node : constant Count_Type := Element_Keys.Find (Container, Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container.Content, Item);\n \n    begin\n       if Node = 0 then\n@@ -547,7 +582,7 @@ is\n          return No_Element;\n       end if;\n \n-      return (Node => Container.First);\n+      return (Node => Container.Content.First);\n    end First;\n \n    -------------------\n@@ -562,7 +597,7 @@ is\n       end if;\n \n       declare\n-         N : Tree_Types.Nodes_Type renames Container.Nodes;\n+         N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n       begin\n          return N (Fst).Element;\n       end;\n@@ -575,7 +610,8 @@ is\n    function Floor (Container : Set; Item : Element_Type) return Cursor is\n    begin\n       declare\n-         Node : constant Count_Type := Element_Keys.Floor (Container, Item);\n+         Node : constant Count_Type :=\n+           Element_Keys.Floor (Container.Content, Item);\n \n       begin\n          if Node = 0 then\n@@ -748,16 +784,16 @@ is\n       --------------\n \n       function Elements (Container : Set) return E.Sequence is\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : E.Sequence;\n \n       begin\n          --  Can't use First, Next or Element here, since they depend on models\n          --  for their postconditions.\n \n          while Position /= 0 loop\n-            R := E.Add (R, Container.Nodes (Position).Element);\n-            Position := Tree_Operations.Next (Container, Position);\n+            R := E.Add (R, Container.Content.Nodes (Position).Element);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -873,7 +909,7 @@ is\n       -----------\n \n       function Model (Container : Set) return M.Set is\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : M.Set;\n \n       begin\n@@ -884,9 +920,9 @@ is\n             R :=\n               M.Add\n                 (Container => R,\n-                 Item      => Container.Nodes (Position).Element);\n+                 Item      => Container.Content.Nodes (Position).Element);\n \n-            Position := Tree_Operations.Next (Container, Position);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n          end loop;\n \n          return R;\n@@ -898,7 +934,7 @@ is\n \n       function Positions (Container : Set) return P.Map is\n          I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n+         Position : Count_Type := Container.Content.First;\n          R        : P.Map;\n \n       begin\n@@ -908,7 +944,7 @@ is\n          while Position /= 0 loop\n             R := P.Add (R, (Node => Position), I);\n             pragma Assert (P.Length (R) = I);\n-            Position := Tree_Operations.Next (Container, Position);\n+            Position := Tree_Operations.Next (Container.Content, Position);\n             I := I + 1;\n          end loop;\n \n@@ -923,8 +959,8 @@ is\n \n    procedure Free (Tree : in out Set; X : Count_Type) is\n    begin\n-      Tree.Nodes (X).Has_Element := False;\n-      Tree_Operations.Free (Tree, X);\n+      Tree.Content.Nodes (X).Has_Element := False;\n+      Tree_Operations.Free (Tree.Content, X);\n    end Free;\n \n    ----------------------\n@@ -978,7 +1014,8 @@ is\n       -------------\n \n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type := Key_Keys.Ceiling (Container, Key);\n+         Node : constant Count_Type :=\n+           Key_Keys.Ceiling (Container.Content, Key);\n \n       begin\n          if Node = 0 then\n@@ -1002,31 +1039,31 @@ is\n       ------------\n \n       procedure Delete (Container : in out Set; Key : Key_Type) is\n-         X : constant Count_Type := Key_Keys.Find (Container, Key);\n+         X : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n \n       begin\n          if X = 0 then\n             raise Constraint_Error with \"attempt to delete key not in set\";\n          end if;\n \n-         Delete_Node_Sans_Free (Container, X);\n-         Formal_Ordered_Sets.Free (Container, X);\n+         Delete_Node_Sans_Free (Container.Content, X);\n+         Free (Container, X);\n       end Delete;\n \n       -------------\n       -- Element --\n       -------------\n \n       function Element (Container : Set; Key : Key_Type) return Element_Type is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n \n       begin\n          if Node = 0 then\n             raise Constraint_Error with \"key not in set\";\n          end if;\n \n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n          begin\n             return N (Node).Element;\n          end;\n@@ -1052,11 +1089,11 @@ is\n       -------------\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n-         X : constant Count_Type := Key_Keys.Find (Container, Key);\n+         X : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n       begin\n          if X /= 0 then\n-            Delete_Node_Sans_Free (Container, X);\n-            Formal_Ordered_Sets.Free (Container, X);\n+            Delete_Node_Sans_Free (Container.Content, X);\n+            Free (Container, X);\n          end if;\n       end Exclude;\n \n@@ -1065,7 +1102,7 @@ is\n       ----------\n \n       function Find (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n       begin\n          return (if Node = 0 then No_Element else (Node => Node));\n       end Find;\n@@ -1075,7 +1112,7 @@ is\n       -----------\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type := Key_Keys.Floor (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Floor (Container.Content, Key);\n       begin\n          return (if Node = 0 then No_Element else (Node => Node));\n       end Floor;\n@@ -1225,11 +1262,11 @@ is\n               \"Position cursor has no element\";\n          end if;\n \n-         pragma Assert (Vet (Container, Position.Node),\n+         pragma Assert (Vet (Container.Content, Position.Node),\n                         \"bad cursor in Key\");\n \n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n          begin\n             return Key (N (Position.Node).Element);\n          end;\n@@ -1244,7 +1281,7 @@ is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n-         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n       begin\n          if not Has_Element (Container, (Node => Node)) then\n             raise Constraint_Error with\n@@ -1265,7 +1302,7 @@ is\n       if Position.Node = 0 then\n          return False;\n       else\n-         return Container.Nodes (Position.Node).Has_Element;\n+         return Container.Content.Nodes (Position.Node).Has_Element;\n       end if;\n    end Has_Element;\n \n@@ -1282,7 +1319,7 @@ is\n \n       if not Inserted then\n          declare\n-            N : Tree_Types.Nodes_Type renames Container.Nodes;\n+            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n          begin\n             N (Position.Node).Element := New_Item;\n          end;\n@@ -1300,7 +1337,7 @@ is\n       Inserted  : out Boolean)\n    is\n    begin\n-      Insert_Sans_Hint (Container, New_Item, Position.Node, Inserted);\n+      Insert_Sans_Hint (Container.Content, New_Item, Position.Node, Inserted);\n    end Insert;\n \n    procedure Insert\n@@ -1324,7 +1361,7 @@ is\n    ----------------------\n \n    procedure Insert_Sans_Hint\n-     (Container : in out Set;\n+     (Container : in out Tree_Types.Tree_Type;\n       New_Item  : Element_Type;\n       Node      : out Count_Type;\n       Inserted  : out Boolean)\n@@ -1377,7 +1414,7 @@ is\n    ----------------------\n \n    procedure Insert_With_Hint\n-     (Dst_Set  : in out Set;\n+     (Dst_Set  : in out Tree_Types.Tree_Type;\n       Dst_Hint : Count_Type;\n       Src_Node : Node_Type;\n       Dst_Node : out Count_Type)\n@@ -1439,17 +1476,18 @@ is\n \n    procedure Intersection (Target : in out Set; Source : Set) is\n    begin\n-      Set_Ops.Set_Intersection (Target, Source);\n+      Set_Ops.Set_Intersection (Target.Content, Source.Content);\n    end Intersection;\n \n    function Intersection (Left, Right : Set) return Set is\n    begin\n       if Left'Address = Right'Address then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       return S : Set (Count_Type'Min (Length (Left), Length (Right))) do\n-            Assign (S, Set_Ops.Set_Intersection (Left, Right));\n+            Assign (S.Content,\n+                    Set_Ops.Set_Intersection (Left.Content, Right.Content));\n       end return;\n    end Intersection;\n \n@@ -1503,7 +1541,7 @@ is\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n    begin\n-      return Set_Ops.Set_Subset (Subset, Of_Set => Of_Set);\n+      return Set_Ops.Set_Subset (Subset.Content, Of_Set => Of_Set.Content);\n    end Is_Subset;\n \n    ----------\n@@ -1514,7 +1552,7 @@ is\n    begin\n       return (if Length (Container) = 0\n               then No_Element\n-              else (Node => Container.Last));\n+              else (Node => Container.Content.Last));\n    end Last;\n \n    ------------------\n@@ -1528,7 +1566,7 @@ is\n       end if;\n \n       declare\n-         N : Tree_Types.Nodes_Type renames Container.Nodes;\n+         N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n       begin\n          return N (Last (Container).Node).Element;\n       end;\n@@ -1549,15 +1587,15 @@ is\n \n    function Length (Container : Set) return Count_Type is\n    begin\n-      return Container.Length;\n+      return Container.Content.Length;\n    end Length;\n \n    ----------\n    -- Move --\n    ----------\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n-      N : Tree_Types.Nodes_Type renames Source.Nodes;\n+      N : Tree_Types.Nodes_Type renames Source.Content.Nodes;\n       X : Count_Type;\n \n    begin\n@@ -1573,13 +1611,13 @@ is\n       Clear (Target);\n \n       loop\n-         X := Source.First;\n+         X := Source.Content.First;\n          exit when X = 0;\n \n          Insert (Target, N (X).Element);  -- optimize???\n \n-         Tree_Operations.Delete_Node_Sans_Free (Source, X);\n-         Formal_Ordered_Sets.Free (Source, X);\n+         Tree_Operations.Delete_Node_Sans_Free (Source.Content, X);\n+         Free (Source, X);\n       end loop;\n    end Move;\n \n@@ -1597,9 +1635,9 @@ is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Next\");\n-      return (Node => Tree_Operations.Next (Container, Position.Node));\n+      return (Node => Tree_Operations.Next (Container.Content, Position.Node));\n    end Next;\n \n    procedure Next (Container : Set; Position : in out Cursor) is\n@@ -1613,7 +1651,7 @@ is\n \n    function Overlap (Left, Right : Set) return Boolean is\n    begin\n-      return Set_Ops.Set_Overlap (Left, Right);\n+      return Set_Ops.Set_Overlap (Left.Content, Right.Content);\n    end Overlap;\n \n    ------------\n@@ -1639,12 +1677,12 @@ is\n          raise Constraint_Error;\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Previous\");\n \n       declare\n          Node : constant Count_Type :=\n-           Tree_Operations.Previous (Container, Position.Node);\n+           Tree_Operations.Previous (Container.Content, Position.Node);\n       begin\n          return (if Node = 0 then No_Element else (Node => Node));\n       end;\n@@ -1660,15 +1698,16 @@ is\n    -------------\n \n    procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-      Node : constant Count_Type := Element_Keys.Find (Container, New_Item);\n+      Node : constant Count_Type :=\n+        Element_Keys.Find (Container.Content, New_Item);\n \n    begin\n       if Node = 0 then\n          raise Constraint_Error with\n            \"attempt to replace element not in set\";\n       end if;\n \n-      Container.Nodes (Node).Element := New_Item;\n+      Container.Content.Nodes (Node).Element := New_Item;\n    end Replace;\n \n    ---------------------\n@@ -1696,7 +1735,7 @@ is\n           (Local_Insert_Post,\n            Local_Insert_Sans_Hint);\n \n-      NN : Tree_Types.Nodes_Type renames Tree.Nodes;\n+      NN : Tree_Types.Nodes_Type renames Tree.Content.Nodes;\n \n       --------------\n       -- New_Node --\n@@ -1730,7 +1769,7 @@ is\n          return;\n       end if;\n \n-      Hint := Element_Keys.Ceiling (Tree, Item);\n+      Hint := Element_Keys.Ceiling (Tree.Content, Item);\n \n       if Hint = 0 then\n          null;\n@@ -1746,10 +1785,10 @@ is\n          raise Program_Error with \"attempt to replace existing element\";\n       end if;\n \n-      Tree_Operations.Delete_Node_Sans_Free (Tree, Node);\n+      Tree_Operations.Delete_Node_Sans_Free (Tree.Content, Node);\n \n       Local_Insert_With_Hint\n-        (Tree     => Tree,\n+        (Tree     => Tree.Content,\n          Position => Hint,\n          Key      => Item,\n          Node     => Result,\n@@ -1770,7 +1809,7 @@ is\n            \"Position cursor has no element\";\n       end if;\n \n-      pragma Assert (Vet (Container, Position.Node),\n+      pragma Assert (Vet (Container.Content, Position.Node),\n                      \"bad cursor in Replace_Element\");\n \n       Replace_Element (Container, Position.Node, New_Item);\n@@ -1830,7 +1869,7 @@ is\n \n    procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n    begin\n-      Set_Ops.Set_Symmetric_Difference (Target, Source);\n+      Set_Ops.Set_Symmetric_Difference (Target.Content, Source.Content);\n    end Symmetric_Difference;\n \n    function Symmetric_Difference (Left, Right : Set) return Set is\n@@ -1840,15 +1879,17 @@ is\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       if Length (Left) = 0 then\n-         return Right.Copy;\n+         return Copy (Right);\n       end if;\n \n       return S : Set (Length (Left) + Length (Right)) do\n-         Assign (S, Set_Ops.Set_Symmetric_Difference (Left, Right));\n+         Assign\n+           (S.Content,\n+            Set_Ops.Set_Symmetric_Difference (Left.Content, Right.Content));\n       end return;\n    end Symmetric_Difference;\n \n@@ -1861,7 +1902,7 @@ is\n       Inserted : Boolean;\n    begin\n       return S : Set (Capacity => 1) do\n-         Insert_Sans_Hint (S, New_Item, Node, Inserted);\n+         Insert_Sans_Hint (S.Content, New_Item, Node, Inserted);\n          pragma Assert (Inserted);\n       end return;\n    end To_Set;\n@@ -1872,21 +1913,21 @@ is\n \n    procedure Union (Target : in out Set; Source : Set) is\n    begin\n-      Set_Ops.Set_Union (Target, Source);\n+      Set_Ops.Set_Union (Target.Content, Source.Content);\n    end Union;\n \n    function Union (Left, Right : Set) return Set is\n    begin\n       if Left'Address = Right'Address then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       if Length (Left) = 0 then\n-         return Right.Copy;\n+         return Copy (Right);\n       end if;\n \n       if Length (Right) = 0 then\n-         return Left.Copy;\n+         return Copy (Left);\n       end if;\n \n       return S : Set (Length (Left) + Length (Right)) do"}, {"sha": "e1d7c917a648ef115b60080741fb30093cdff0cd", "filename": "gcc/ada/libgnat/a-cforse.ads", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -529,6 +529,16 @@ is\n                  Position => Position)\n           and Positions (Container) = Positions (Container)'Old;\n \n+   function Constant_Reference\n+     (Container : aliased Set;\n+      Position  : Cursor) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Has_Element (Container, Position),\n+     Post   =>\n+       Constant_Reference'Result.all =\n+         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n+\n    procedure Move (Target : in out Set; Source : in out Set) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n@@ -1770,18 +1780,19 @@ private\n \n    type Node_Type is record\n       Has_Element : Boolean := False;\n-      Parent  : Count_Type := 0;\n-      Left    : Count_Type := 0;\n-      Right   : Count_Type := 0;\n-      Color   : Red_Black_Trees.Color_Type;\n-      Element : Element_Type;\n+      Parent      : Count_Type := 0;\n+      Left        : Count_Type := 0;\n+      Right       : Count_Type := 0;\n+      Color       : Red_Black_Trees.Color_Type;\n+      Element     : aliased Element_Type;\n    end record;\n \n    package Tree_Types is\n      new Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n \n-   type Set (Capacity : Count_Type) is\n-     new Tree_Types.Tree_Type (Capacity) with null record;\n+   type Set (Capacity : Count_Type) is record\n+     Content : Tree_Types.Tree_Type (Capacity);\n+   end record;\n \n    use Red_Black_Trees;\n "}, {"sha": "21b9f5485a28b90035bb572ffc01985c3403eb5e", "filename": "gcc/ada/libgnat/a-coboho.adb", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-coboho.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-coboho.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coboho.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -65,6 +65,26 @@ package body Ada.Containers.Bounded_Holders is\n       return Get (Left) = Get (Right);\n    end \"=\";\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Holder) return not null access constant Element_Type\n+   is\n+   begin\n+      return Cast (Container'Address);\n+   end Constant_Reference;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get (Container : Holder) return Element_Type is\n+   begin\n+      return Cast (Container'Address).all;\n+   end Get;\n+\n    ---------------\n    -- Put_Image --\n    ---------------\n@@ -79,14 +99,16 @@ package body Ada.Containers.Bounded_Holders is\n       Array_After (S);\n    end Put_Image;\n \n-   ---------\n-   -- Get --\n-   ---------\n+   ---------------\n+   -- Reference --\n+   ---------------\n \n-   function Get (Container : Holder) return Element_Type is\n+   function Reference\n+     (Container : not null access Holder) return not null access Element_Type\n+   is\n    begin\n-      return Cast (Container'Address).all;\n-   end Get;\n+      return Cast (Container.all'Address);\n+   end Reference;\n \n    ---------\n    -- Set --"}, {"sha": "086f19410c79fad2baf73b635df6667042569a6a", "filename": "gcc/ada/libgnat/a-coboho.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-coboho.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-coboho.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coboho.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -81,6 +81,12 @@ package Ada.Containers.Bounded_Holders is\n \n    procedure Set (Container : in out Holder; New_Item  : Element_Type);\n \n+   function Constant_Reference\n+     (Container : aliased Holder) return not null access constant Element_Type;\n+\n+   function Reference\n+     (Container : not null access Holder) return not null access Element_Type;\n+\n private\n \n    --  The implementation uses low-level tricks (Address clauses and unchecked"}, {"sha": "c7f4f06005e0abc0accff29756e9b8530e2185a1", "filename": "gcc/ada/libgnat/a-cofove.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.adb?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -142,6 +142,22 @@ is\n       Container.Last := No_Index;\n    end Clear;\n \n+   ------------------------\n+   -- Constant_Reference --\n+   ------------------------\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return not null access constant Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      return Container.Elements (To_Array_Index (Index))'Access;\n+   end Constant_Reference;\n+\n    --------------\n    -- Contains --\n    --------------\n@@ -1096,6 +1112,22 @@ is\n       end;\n    end Replace_Element;\n \n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference\n+     (Container : not null access Vector;\n+      Index     : Index_Type) return not null access Element_Type\n+   is\n+   begin\n+      if Index > Container.Last then\n+         raise Constraint_Error with \"Index is out of range\";\n+      end if;\n+\n+      return Container.Elements (To_Array_Index (Index))'Access;\n+   end Reference;\n+\n    ----------------------\n    -- Reserve_Capacity --\n    ----------------------"}, {"sha": "a4ed7e5d385a0ec031ce614cebf03b0bedeb7756", "filename": "gcc/ada/libgnat/a-cofove.ads", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -290,6 +290,48 @@ is\n                 Right    => Model (Container),\n                 Position => Index);\n \n+   function At_End (E : access constant Vector) return access constant Vector\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function At_End\n+     (E : access constant Element_Type) return access constant Element_Type\n+   is (E)\n+   with Ghost,\n+     Annotate => (GNATprove, At_End_Borrow);\n+\n+   function Constant_Reference\n+     (Container : aliased Vector;\n+      Index     : Index_Type) return not null access constant Element_Type\n+   with\n+     Global => null,\n+     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n+     Post   =>\n+         Constant_Reference'Result.all = Element (Model (Container), Index);\n+\n+   function Reference\n+     (Container : not null access Vector;\n+      Index     : Index_Type) return not null access Element_Type\n+   with\n+     Global => null,\n+     Pre    =>\n+      Index in First_Index (Container.all) .. Last_Index (Container.all),\n+     Post   =>\n+      Length (Container.all) = Length (At_End (Container).all)\n+\n+         --  Container will have Result.all at index Index\n+\n+         and At_End (Reference'Result).all =\n+           Element (Model (At_End (Container).all), Index)\n+\n+         --  All other elements are preserved\n+\n+         and M.Equal_Except\n+               (Left     => Model (Container.all),\n+                Right    => Model (At_End (Container).all),\n+                Position => Index);\n+\n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n@@ -905,7 +947,7 @@ private\n    pragma Inline (Contains);\n \n    subtype Array_Index is Capacity_Range range 1 .. Capacity_Range'Last;\n-   type Elements_Array is array (Array_Index range <>) of Element_Type;\n+   type Elements_Array is array (Array_Index range <>) of aliased Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n    type Vector (Capacity : Capacity_Range) is record"}, {"sha": "a1dd76406a4a1a3ffa1b34cc1dd2335dff026601", "filename": "gcc/ada/libgnat/a-cofuma.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -302,6 +302,14 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Global => null,\n      Pre    => Has_Witness (Container, Witness);\n \n+   function Copy_Key (Key : Key_Type) return Key_Type is (Key);\n+   function Copy_Element (Item : Element_Type) return Element_Type is (Item);\n+   --  Elements and Keys of maps are copied by numerous primitives in this\n+   --  package. This function causes GNATprove to verify that such a copy is\n+   --  valid (in particular, it does not break the ownership policy of SPARK,\n+   --  i.e. it does not contain pointers that could be used to alias mutable\n+   --  data).\n+\n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------"}, {"sha": "d0acba7a012f5aad8ecea0fd4768a688006c0ad5", "filename": "gcc/ada/libgnat/a-cofuse.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -249,6 +249,13 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n            and Right <= Union'Result\n            and Included_In_Union (Union'Result, Left, Right);\n \n+   function Copy_Element (Item : Element_Type) return Element_Type is (Item);\n+   --  Elements of containers are copied by numerous primitives in this\n+   --  package. This function causes GNATprove to verify that such a copy is\n+   --  valid (in particular, it does not break the ownership policy of SPARK,\n+   --  i.e. it does not contain pointers that could be used to alias mutable\n+   --  data).\n+\n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------"}, {"sha": "ee5273039d391b693206e81392a5b348155ec10b", "filename": "gcc/ada/libgnat/a-cofuve.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb5c200369c8ba56358a145e0c5c6c461ad5a45/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads?ref=fdb5c200369c8ba56358a145e0c5c6c461ad5a45", "patch": "@@ -336,6 +336,13 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n                      Lst    => Last (Remove'Result),\n                      Offset => 1);\n \n+   function Copy_Element (Item : Element_Type) return Element_Type is (Item);\n+   --  Elements of containers are copied by numerous primitives in this\n+   --  package. This function causes GNATprove to verify that such a copy is\n+   --  valid (in particular, it does not break the ownership policy of SPARK,\n+   --  i.e. it does not contain pointers that could be used to alias mutable\n+   --  data).\n+\n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------"}]}