{"sha": "a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjODFiYzFmYjQzMzY2Y2ExYjQzMzJkOGE2MDQyYjY0OGE4NGNkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:52:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:52:17Z"}, "message": "Use function_arg_info for TARGET_ARG_PARTIAL_BYTES\n\nThis patch adds the function_arg_info class and uses it for\nTARGET_ARG_PARTIAL_BYTES.\n\nThe hook is passed the promoted mode instead of the original type mode.\n\nThe arguments aren't mentioned in the documentation, which is why the\ntarget.def change is so small.\n\nThe patch changes \"true\" to \"arg.named\" in:\n\n  gcc_assert (!epiphany_pass_by_reference (cum, mode, type, /* named */ true));\n\nbut epiphany_pass_by_reference doesn't care about the named flag.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (arg_partial_bytes): Take a function_arg_info instead\n\tof a mode, type and named flag.\n\t* doc/tm.texi: Regenerate.\n\t* target.h (function_arg_info): Declare.\n\t* calls.h (function_arg_info): New class.\n\t* targhooks.h (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Delete.\n\t(hook_int_CUMULATIVE_ARGS_arg_info_0): Declare.\n\t* targhooks.c (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Delete.\n\t(hook_int_CUMULATIVE_ARGS_arg_info_0): New function.\n\t* calls.c (initialize_argument_information): Update call to\n\ttargetm.calls.partial_bytes.\n\t(emit_library_call_value_1): Likewise.\n\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n\t* function.c (assign_parm_find_entry_rtl): Likewise.\n\t* config/alpha/alpha.c (alpha_arg_partial_bytes): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/arc/arc.c (arc_arg_partial_bytes): Likewise.\n\t* config/arm/arm.c (arm_arg_partial_bytes): Likewise.\n\t(cmse_func_args_or_return_in_stack): Update accordingly.\n\t* config/bfin/bfin.c (bfin_arg_partial_bytes): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/cris/cris.c (cris_arg_partial_bytes): Likewise.\n\t* config/csky/csky.c (csky_arg_partial_bytes): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_arg_partial_bytes): Likewise.\n\t* config/fr30/fr30.c: Include calls.h.\n\t(fr30_arg_partial_bytes): Take a function_arg_info instead of a mode,\n\ttype and named flag.\n\t* config/frv/frv.c: Include calls.h.\n\t(frv_arg_partial_bytes): Take a function_arg_info instead of a mode,\n\ttype and named flag.\n\t* config/ft32/ft32.c (ft32_arg_partial_bytes): Likewise.\n\t* config/gcn/gcn.c (gcn_arg_partial_bytes): Likewise.\n\t* config/ia64/ia64.c (ia64_arg_partial_bytes): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_arg_partial_bytes): Likewise.\n\t* config/m32r/m32r.c (m32r_arg_partial_bytes): Likewise.\n\t* config/mcore/mcore.c (mcore_arg_partial_bytes): Likewise.\n\t* config/microblaze/microblaze.c (function_arg_partial_bytes):\n\tLikewise.\n\t* config/mips/mips.c (mips_arg_partial_bytes): Likewise.\n\t* config/mn10300/mn10300.c (mn10300_arg_partial_bytes): Likewise.\n\t* config/moxie/moxie.c (moxie_arg_partial_bytes): Likewise.\n\t* config/msp430/msp430.c (msp430_arg_partial_bytes): Likewise.\n\t* config/nds32/nds32.c (nds32_arg_partial_bytes): Likewise.\n\t* config/nios2/nios2.c (nios2_arg_partial_bytes): Likewise.\n\t* config/pa/pa.c (pa_arg_partial_bytes): Likewise.\n\t* config/pru/pru.c (pru_arg_partial_bytes): Likewise.\n\t* config/riscv/riscv.c (riscv_arg_partial_bytes): Likewise.\n\t* config/rs6000/rs6000-internal.h (rs6000_arg_partial_bytes): Likewise.\n\t* config/rs6000/rs6000-call.c (rs6000_arg_partial_bytes): Likewise.\n\t(rs6000_parm_needs_stack): Update call accordingly.\n\t* config/sh/sh.c (sh_arg_partial_bytes): Take a\n\tfunction_arg_info instead of a mode, type and named flag.\n\t* config/sparc/sparc.c (sparc_arg_partial_bytes): Likewise.\n\t* config/v850/v850.c (v850_arg_partial_bytes): Likewise.\n\nFrom-SVN: r274697", "tree": {"sha": "789c552939f2fbd5585369d30b3beb3dde5a2a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/789c552939f2fbd5585369d30b3beb3dde5a2a72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f53599cb5b822cd7f95997861c2e064977ecb6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f53599cb5b822cd7f95997861c2e064977ecb6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f53599cb5b822cd7f95997861c2e064977ecb6a"}], "stats": {"total": 575, "additions": 315, "deletions": 260}, "files": [{"sha": "55c0714e277cc17def50f303d6a5e0a23bc5a133", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1,3 +1,60 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (arg_partial_bytes): Take a function_arg_info instead\n+\tof a mode, type and named flag.\n+\t* doc/tm.texi: Regenerate.\n+\t* target.h (function_arg_info): Declare.\n+\t* calls.h (function_arg_info): New class.\n+\t* targhooks.h (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Delete.\n+\t(hook_int_CUMULATIVE_ARGS_arg_info_0): Declare.\n+\t* targhooks.c (hook_int_CUMULATIVE_ARGS_mode_tree_bool_0): Delete.\n+\t(hook_int_CUMULATIVE_ARGS_arg_info_0): New function.\n+\t* calls.c (initialize_argument_information): Update call to\n+\ttargetm.calls.partial_bytes.\n+\t(emit_library_call_value_1): Likewise.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): Likewise.\n+\t* function.c (assign_parm_find_entry_rtl): Likewise.\n+\t* config/alpha/alpha.c (alpha_arg_partial_bytes): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/arc/arc.c (arc_arg_partial_bytes): Likewise.\n+\t* config/arm/arm.c (arm_arg_partial_bytes): Likewise.\n+\t(cmse_func_args_or_return_in_stack): Update accordingly.\n+\t* config/bfin/bfin.c (bfin_arg_partial_bytes): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/cris/cris.c (cris_arg_partial_bytes): Likewise.\n+\t* config/csky/csky.c (csky_arg_partial_bytes): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_arg_partial_bytes): Likewise.\n+\t* config/fr30/fr30.c: Include calls.h.\n+\t(fr30_arg_partial_bytes): Take a function_arg_info instead of a mode,\n+\ttype and named flag.\n+\t* config/frv/frv.c: Include calls.h.\n+\t(frv_arg_partial_bytes): Take a function_arg_info instead of a mode,\n+\ttype and named flag.\n+\t* config/ft32/ft32.c (ft32_arg_partial_bytes): Likewise.\n+\t* config/gcn/gcn.c (gcn_arg_partial_bytes): Likewise.\n+\t* config/ia64/ia64.c (ia64_arg_partial_bytes): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_arg_partial_bytes): Likewise.\n+\t* config/m32r/m32r.c (m32r_arg_partial_bytes): Likewise.\n+\t* config/mcore/mcore.c (mcore_arg_partial_bytes): Likewise.\n+\t* config/microblaze/microblaze.c (function_arg_partial_bytes):\n+\tLikewise.\n+\t* config/mips/mips.c (mips_arg_partial_bytes): Likewise.\n+\t* config/mn10300/mn10300.c (mn10300_arg_partial_bytes): Likewise.\n+\t* config/moxie/moxie.c (moxie_arg_partial_bytes): Likewise.\n+\t* config/msp430/msp430.c (msp430_arg_partial_bytes): Likewise.\n+\t* config/nds32/nds32.c (nds32_arg_partial_bytes): Likewise.\n+\t* config/nios2/nios2.c (nios2_arg_partial_bytes): Likewise.\n+\t* config/pa/pa.c (pa_arg_partial_bytes): Likewise.\n+\t* config/pru/pru.c (pru_arg_partial_bytes): Likewise.\n+\t* config/riscv/riscv.c (riscv_arg_partial_bytes): Likewise.\n+\t* config/rs6000/rs6000-internal.h (rs6000_arg_partial_bytes): Likewise.\n+\t* config/rs6000/rs6000-call.c (rs6000_arg_partial_bytes): Likewise.\n+\t(rs6000_parm_needs_stack): Update call accordingly.\n+\t* config/sh/sh.c (sh_arg_partial_bytes): Take a\n+\tfunction_arg_info instead of a mode, type and named flag.\n+\t* config/sparc/sparc.c (sparc_arg_partial_bytes): Likewise.\n+\t* config/v850/v850.c (v850_arg_partial_bytes): Likewise.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* calls.h (must_pass_va_arg_in_stack): Declare."}, {"sha": "8f3574e42490865a5c63d9176d4a4085eb954219", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2142,10 +2142,9 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       else\n \targs[i].tail_call_reg = args[i].reg;\n \n+      function_arg_info arg (type, mode, argpos < n_named_args);\n       if (args[i].reg)\n-\targs[i].partial\n-\t  = targetm.calls.arg_partial_bytes (args_so_far, mode, type,\n-\t\t\t\t\t     argpos < n_named_args);\n+\targs[i].partial = targetm.calls.arg_partial_bytes (args_so_far, arg);\n \n       args[i].pass_on_stack = targetm.calls.must_pass_in_stack (mode, type);\n \n@@ -4871,10 +4870,10 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       argvec[count].mode = Pmode;\n       argvec[count].partial = 0;\n \n+      function_arg_info ptr_arg (Pmode, /*named=*/true);\n       argvec[count].reg = targetm.calls.function_arg (args_so_far,\n \t\t\t\t\t\t      Pmode, NULL_TREE, true);\n-      gcc_assert (targetm.calls.arg_partial_bytes (args_so_far, Pmode,\n-\t\t\t\t\t\t   NULL_TREE, 1) == 0);\n+      gcc_assert (targetm.calls.arg_partial_bytes (args_so_far, ptr_arg) == 0);\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n@@ -4952,13 +4951,14 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t}\n \n       mode = promote_function_mode (NULL_TREE, mode, &unsigned_p, NULL_TREE, 0);\n+      function_arg_info arg (mode, /*named=*/true);\n       argvec[count].mode = mode;\n       argvec[count].value = convert_modes (mode, GET_MODE (val), val, unsigned_p);\n       argvec[count].reg = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t\t      NULL_TREE, true);\n \n       argvec[count].partial\n-\t= targetm.calls.arg_partial_bytes (args_so_far, mode, NULL_TREE, 1);\n+\t= targetm.calls.arg_partial_bytes (args_so_far, arg);\n \n       if (argvec[count].reg == 0\n \t  || argvec[count].partial != 0"}, {"sha": "38ab6ef7fa1fcc4d162bc99609523a2dbc39b5b7", "filename": "gcc/calls.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -20,6 +20,77 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CALLS_H\n #define GCC_CALLS_H\n \n+/* Describes a function argument.\n+\n+   Each argument conceptually has a gimple-level type.  Usually this type\n+   is available directly as a tree via the TYPE field, but when calling\n+   libgcc support functions it might instead be inferred from a mode,\n+   in which case the type isn't available directly.\n+\n+   This gimple-level type might go through promotion before being passed to\n+   the target function.  Depending on the context, the MODE field is either\n+   the mode of the gimple-level type (whether explicitly given or not)\n+   or the mode after promotion has been performed.  */\n+class function_arg_info\n+{\n+public:\n+  function_arg_info () : type (NULL_TREE), mode (VOIDmode), named (false) {}\n+\n+  /* Initialize an argument of mode MODE, either before or after promotion.  */\n+  function_arg_info (machine_mode mode, bool named)\n+    : type (NULL_TREE), mode (mode), named (named)\n+  {}\n+\n+  /* Initialize an unpromoted argument of type TYPE.  */\n+  function_arg_info (tree type, bool named)\n+    : type (type), mode (TYPE_MODE (type)), named (named)\n+  {}\n+\n+  /* Initialize an argument with explicit properties.  */\n+  function_arg_info (tree type, machine_mode mode, bool named)\n+    : type (type), mode (mode), named (named)\n+  {}\n+\n+  /* Return true if the gimple-level type is an aggregate.  */\n+  bool aggregate_type_p () const { return type && AGGREGATE_TYPE_P (type); }\n+\n+  /* Return the size of the gimple-level type, or -1 if the size is\n+     variable or otherwise not representable as a poly_int64.\n+\n+     Use this function when MODE is the mode of the type before promotion,\n+     or in any context if the target never promotes function arguments.  */\n+  poly_int64 type_size_in_bytes () const\n+  {\n+    if (type)\n+      return int_size_in_bytes (type);\n+    return GET_MODE_SIZE (mode);\n+  }\n+\n+  /* Return the size of the argument after promotion, or -1 if the size\n+     is variable or otherwise not representable as a poly_int64.\n+\n+     Use this function when MODE is the mode of the type after promotion.  */\n+  poly_int64 promoted_size_in_bytes () const\n+  {\n+    if (mode == BLKmode)\n+      return int_size_in_bytes (type);\n+    return GET_MODE_SIZE (mode);\n+  }\n+\n+  /* The type of the argument, or null if not known (which is true for\n+     libgcc support functions).  */\n+  tree type;\n+\n+  /* The mode of the argument.  Depending on context, this might be\n+     the mode of the argument type or the mode after promotion.  */\n+  machine_mode mode;\n+\n+  /* True if the argument is treated as a named argument, false if it is\n+     treated as an unnamed variadic argument (i.e. one passed through\n+     \"...\").  See also TARGET_STRICT_ARGUMENT_NAMING.  */\n+  unsigned int named : 1;\n+};\n+\n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);\n extern int setjmp_call_p (const_tree);"}, {"sha": "f7e35c2b1add4d9dca3d46288527bf1685634c87", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -5635,20 +5635,17 @@ alpha_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n }\n \n static int\n-alpha_arg_partial_bytes (cumulative_args_t cum_v,\n-\t\t\t machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t tree type ATTRIBUTE_UNUSED,\n-\t\t\t bool named ATTRIBUTE_UNUSED)\n+alpha_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   int words = 0;\n   CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED = get_cumulative_args (cum_v);\n \n #if TARGET_ABI_OPEN_VMS\n   if (cum->num_args < 6\n-      && 6 < cum->num_args + ALPHA_ARG_SIZE (mode, type))\n+      && 6 < cum->num_args + ALPHA_ARG_SIZE (arg.mode, arg.type))\n     words = 6 - cum->num_args;\n #elif TARGET_ABI_OSF\n-  if (*cum < 6 && 6 < *cum + ALPHA_ARG_SIZE (mode, type))\n+  if (*cum < 6 && 6 < *cum + ALPHA_ARG_SIZE (arg.mode, arg.type))\n     words = 6 - *cum;\n #else\n #error Unhandled ABI"}, {"sha": "ace7d52f66b98c39572d0d57e80a0b8bc88cd95b", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -6432,17 +6432,15 @@ arc_output_pic_addr_const (FILE * file, rtx x, int code)\n /* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n static int\n-arc_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t       tree type, bool named ATTRIBUTE_UNUSED)\n+arc_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  int bytes = (mode == BLKmode\n-\t       ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode));\n+  int bytes = arg.promoted_size_in_bytes ();\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   int arg_num = *cum;\n   int ret;\n \n-  arg_num = ROUND_ADVANCE_CUM (arg_num, mode, type);\n+  arg_num = ROUND_ADVANCE_CUM (arg_num, arg.mode, arg.type);\n   ret = GPR_REST_ARG_REGS (arg_num);\n \n   /* ICEd at function.c:2361, and ret is copied to data->partial */"}, {"sha": "92bfe16f48e6243d19adab225a90047fba0afa4b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -187,8 +187,8 @@ static int arm_memory_move_cost (machine_mode, reg_class_t, bool);\n static void emit_constant_insn (rtx cond, rtx pattern);\n static rtx_insn *emit_set_insn (rtx, rtx);\n static rtx emit_multi_reg_push (unsigned long, unsigned long);\n-static int arm_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t  tree, bool);\n+static int arm_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t  const function_arg_info &);\n static rtx arm_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n static void arm_function_arg_advance (cumulative_args_t, machine_mode,\n@@ -6754,23 +6754,22 @@ arm_function_arg_boundary (machine_mode mode, const_tree type)\n }\n \n static int\n-arm_arg_partial_bytes (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t       tree type, bool named)\n+arm_arg_partial_bytes (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n   int nregs = pcum->nregs;\n \n   if (pcum->pcs_variant <= ARM_PCS_AAPCS_LOCAL)\n     {\n-      aapcs_layout_arg (pcum, mode, type, named);\n+      aapcs_layout_arg (pcum, arg.mode, arg.type, arg.named);\n       return pcum->aapcs_partial;\n     }\n \n-  if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (mode))\n+  if (TARGET_IWMMXT_ABI && arm_vector_mode_supported_p (arg.mode))\n     return 0;\n \n   if (NUM_ARG_REGS > nregs\n-      && (NUM_ARG_REGS < nregs + ARM_NUM_REGS2 (mode, type))\n+      && (NUM_ARG_REGS < nregs + ARM_NUM_REGS2 (arg.mode, arg.type))\n       && pcum->can_split)\n     return (NUM_ARG_REGS - nregs) * UNITS_PER_WORD;\n \n@@ -6999,11 +6998,11 @@ cmse_func_args_or_return_in_stack (tree fndecl, tree name, tree fntype)\n       if (VOID_TYPE_P (arg_type))\n \tcontinue;\n \n+      function_arg_info arg (arg_type, /*named=*/true);\n       if (!first_param)\n \tarm_function_arg_advance (args_so_far, arg_mode, arg_type, true);\n       arg_rtx = arm_function_arg (args_so_far, arg_mode, arg_type, true);\n-      if (!arg_rtx\n-\t  || arm_arg_partial_bytes (args_so_far, arg_mode, arg_type, true))\n+      if (!arg_rtx || arm_arg_partial_bytes (args_so_far, arg))\n \t{\n \t  error (\"%qE attribute not available to functions with arguments \"\n \t\t \"passed on the stack\", name);"}, {"sha": "c4281a12486c68bfad950e781bfdf0d03f695898", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1723,12 +1723,9 @@ bfin_function_arg (cumulative_args_t cum_v, machine_mode mode,\n    stack.   */\n \n static int\n-bfin_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n-\t\t\ttree type ATTRIBUTE_UNUSED,\n-\t\t\tbool named ATTRIBUTE_UNUSED)\n+bfin_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  int bytes\n-    = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  int bytes = arg.promoted_size_in_bytes ();\n   int bytes_left = get_cumulative_args (cum)->nregs * UNITS_PER_WORD;\n   \n   if (bytes == -1)"}, {"sha": "aac8552eb6299c3f37c22b2e106a1c4adda74ae1", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -141,8 +141,8 @@ static bool cris_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n static int cris_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool cris_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int cris_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t   tree, bool);\n+static int cris_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t   const function_arg_info &);\n static rtx cris_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static rtx cris_function_incoming_arg (cumulative_args_t,\n@@ -4111,13 +4111,12 @@ cris_function_value_regno_p (const unsigned int regno)\n }\n \n static int\n-cris_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n-\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+cris_arg_partial_bytes (cumulative_args_t ca, const function_arg_info &arg)\n {\n   if (get_cumulative_args (ca)->regs == CRIS_MAX_ARGS_IN_REGS - 1\n-      && !targetm.calls.must_pass_in_stack (mode, type)\n-      && CRIS_FUNCTION_ARG_SIZE (mode, type) > 4\n-      && CRIS_FUNCTION_ARG_SIZE (mode, type) <= 8)\n+      && !targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+      && CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 4\n+      && CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) <= 8)\n     return UNITS_PER_WORD;\n   else\n     return 0;"}, {"sha": "98789bcfcffab6135df37e53ef89444dfdd8d142", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1917,11 +1917,10 @@ csky_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n    that are passed entirely in registers or\n    that are entirely pushed on the stack.  */\n static int\n-csky_arg_partial_bytes (cumulative_args_t pcum_v, machine_mode mode,\n-\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+csky_arg_partial_bytes (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n-  int param_size = csky_num_arg_regs (mode, type);\n+  int param_size = csky_num_arg_regs (arg.mode, arg.type);\n \n   if (*pcum < CSKY_NPARM_REGS\n       && *pcum + param_size > CSKY_NPARM_REGS)"}, {"sha": "67b1bd9bc0a1a3f768b2310557b4470df174f57f", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -744,18 +744,20 @@ epiphany_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n }\n \n static int\n-epiphany_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n-\t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\n+epiphany_arg_partial_bytes (cumulative_args_t cum,\n+\t\t\t    const function_arg_info &arg)\n {\n   int words = 0, rounded_cum;\n \n-  gcc_assert (!epiphany_pass_by_reference (cum, mode, type, /* named */ true));\n+  gcc_assert (!epiphany_pass_by_reference (cum, arg.mode, arg.type,\n+\t\t\t\t\t   arg.named));\n \n-  rounded_cum = ROUND_ADVANCE_CUM (*get_cumulative_args (cum), mode, type);\n+  rounded_cum = ROUND_ADVANCE_CUM (*get_cumulative_args (cum),\n+\t\t\t\t   arg.mode, arg.type);\n   if (rounded_cum < MAX_EPIPHANY_PARM_REGS)\n     {\n       words = MAX_EPIPHANY_PARM_REGS - rounded_cum;\n-      if (words >= ROUND_ADVANCE_ARG (mode, type))\n+      if (words >= ROUND_ADVANCE_ARG (arg.mode, arg.type))\n \twords = 0;\n     }\n   return words * UNITS_PER_WORD;"}, {"sha": "59728015f1426df735378edc0a03a2e1655a2200", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -39,6 +39,7 @@\n #include \"output.h\"\n #include \"expr.h\"\n #include \"builtins.h\"\n+#include \"calls.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -115,8 +116,8 @@ static struct fr30_frame_info \tzero_frame_info;\n static void fr30_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n-static int fr30_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t   tree, bool);\n+static int fr30_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t   const function_arg_info &);\n static rtx fr30_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static void fr30_function_arg_advance (cumulative_args_t, machine_mode,\n@@ -770,23 +771,20 @@ fr30_num_arg_regs (machine_mode mode, const_tree type)\n   return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n-/* Returns the number of bytes in which *part* of a parameter of machine\n-   mode MODE and tree type TYPE (which may be NULL if the type is not known).\n-   If the argument fits entirely in the argument registers, or entirely on\n-   the stack, then 0 is returned.\n-   CUM is the number of argument registers already used by earlier\n-   parameters to the function.  */\n+/* Returns the number of bytes of argument registers required to hold *part*\n+   of argument ARG.  If the argument fits entirely in the argument registers,\n+   or entirely on the stack, then 0 is returned.  CUM is the number of\n+   argument registers already used by earlier parameters to the function.  */\n \n static int\n-fr30_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\ttree type, bool named)\n+fr30_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   /* Unnamed arguments, i.e. those that are prototyped as ...\n      are always passed on the stack.\n      Also check here to see if all the argument registers are full.  */\n-  if (named == 0 || *cum >= FR30_NUM_ARG_REGS)\n+  if (!arg.named || *cum >= FR30_NUM_ARG_REGS)\n     return 0;\n \n   /* Work out how many argument registers would be needed if this\n@@ -795,7 +793,7 @@ fr30_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n      are needed because the parameter must be passed on the stack)\n      then return zero, as this parameter does not require partial\n      register, partial stack stack space.  */\n-  if (*cum + fr30_num_arg_regs (mode, type) <= FR30_NUM_ARG_REGS)\n+  if (*cum + fr30_num_arg_regs (arg.mode, arg.type) <= FR30_NUM_ARG_REGS)\n     return 0;\n   \n   return (FR30_NUM_ARG_REGS - *cum) * UNITS_PER_WORD;"}, {"sha": "4560fc6f9ca2e8882338c27da86dff858dbe7e75", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"ifcvt.h\"\n #include \"rtl-iter.h\"\n+#include \"calls.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -379,8 +380,8 @@ static void frv_output_const_unspec\t\t(FILE *,\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n static bool frv_must_pass_in_stack (machine_mode mode, const_tree type);\n-static int frv_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t  tree, bool);\n+static int frv_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t  const function_arg_info &);\n static rtx frv_function_arg (cumulative_args_t, machine_mode,\n \t\t\t     const_tree, bool);\n static rtx frv_function_incoming_arg (cumulative_args_t, machine_mode,\n@@ -3183,28 +3184,12 @@ frv_function_arg_advance (cumulative_args_t cum_v,\n }\n \n \f\n-/* A C expression for the number of words, at the beginning of an argument,\n-   must be put in registers.  The value must be zero for arguments that are\n-   passed entirely in registers or that are entirely pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in registers\n-   and partially in memory.  On these machines, typically the first N words of\n-   arguments are passed in registers, and the rest on the stack.  If a\n-   multi-word argument (a `double' or a structure) crosses that boundary, its\n-   first few words must be passed in registers and the rest must be pushed.\n-   This macro tells the compiler when this occurs, and how many of the words\n-   should go in registers.\n-\n-   `FUNCTION_ARG' for these arguments should return the first register to be\n-   used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for\n-   the called function.  */\n+/* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n static int\n-frv_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n-\t\t       tree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+frv_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n {\n-\n-  machine_mode xmode = (mode == BLKmode) ? SImode : mode;\n+  machine_mode xmode = (arg.mode == BLKmode) ? SImode : arg.mode;\n   int bytes = GET_MODE_SIZE (xmode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   int arg_num = *get_cumulative_args (cum);"}, {"sha": "58448c3dad251702cd8ed4dd5443280c73f74d03", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -711,25 +711,24 @@ ft32_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n    that fit in argument passing registers.  */\n \n static int\n-ft32_arg_partial_bytes (cumulative_args_t cum_v,\n-                        machine_mode mode, tree type, bool named)\n+ft32_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes_left, size;\n \n   if (*cum >= 8)\n     return 0;\n \n-  if (ft32_pass_by_reference (cum_v, mode, type, named))\n+  if (ft32_pass_by_reference (cum_v, arg.mode, arg.type, arg.named))\n     size = 4;\n-  else if (type)\n+  else if (arg.type)\n     {\n-      if (AGGREGATE_TYPE_P (type))\n+      if (AGGREGATE_TYPE_P (arg.type))\n         return 0;\n-      size = int_size_in_bytes (type);\n+      size = int_size_in_bytes (arg.type);\n     }\n   else\n-    size = GET_MODE_SIZE (mode);\n+    size = GET_MODE_SIZE (arg.mode);\n \n   bytes_left = (4 * 6) - ((*cum - 2) * 4);\n "}, {"sha": "d9eb82f876d3f68ad5bd7bfea89db2cf0062ae5e", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2349,22 +2349,21 @@ gcn_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    in registers or that are entirely pushed on the stack.  */\n \n static int\n-gcn_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode, tree type,\n-\t\t       bool named)\n+gcn_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (!named)\n+  if (!arg.named)\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return 0;\n \n   if (cum->num >= NUM_PARM_REGS)\n     return 0;\n \n   /* If the argument fits entirely in registers, return 0.  */\n-  if (cum->num + num_arg_regs (mode, type) <= NUM_PARM_REGS)\n+  if (cum->num + num_arg_regs (arg.mode, arg.type) <= NUM_PARM_REGS)\n     return 0;\n \n   return (NUM_PARM_REGS - cum->num) * UNITS_PER_WORD;"}, {"sha": "13dd71575e42c7da9b13b595fa285dc50634e45c", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -201,8 +201,8 @@ static bool ia64_can_eliminate (const int, const int);\n static machine_mode hfa_element_mode (const_tree, bool);\n static void ia64_setup_incoming_varargs (cumulative_args_t, machine_mode,\n \t\t\t\t\t tree, int *, int);\n-static int ia64_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t   tree, bool);\n+static int ia64_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t   const function_arg_info &);\n static rtx ia64_function_arg_1 (cumulative_args_t, machine_mode,\n \t\t\t\tconst_tree, bool, bool);\n static rtx ia64_function_arg (cumulative_args_t, machine_mode,\n@@ -4961,13 +4961,12 @@ ia64_function_incoming_arg (cumulative_args_t cum,\n    in memory.  */\n \n static int\n-ia64_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+ia64_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  int words = ia64_function_arg_words (type, mode);\n-  int offset = ia64_function_arg_offset (cum, type, words);\n+  int words = ia64_function_arg_words (arg.type, arg.mode);\n+  int offset = ia64_function_arg_offset (cum, arg.type, words);\n \n   /* If all argument slots are used, then it must go on the stack.  */\n   if (cum->words + offset >= MAX_ARGUMENT_SLOTS)"}, {"sha": "9652fa5e1fe2040970d9d0f0a68bb5d4546f0388", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -161,8 +161,8 @@ static section *iq2000_select_section (tree, int, unsigned HOST_WIDE_INT);\n static rtx  iq2000_legitimize_address (rtx, rtx, machine_mode);\n static bool iq2000_pass_by_reference  (cumulative_args_t, machine_mode,\n \t\t\t\t       const_tree, bool);\n-static int  iq2000_arg_partial_bytes  (cumulative_args_t, machine_mode,\n-\t\t\t\t       tree, bool);\n+static int  iq2000_arg_partial_bytes  (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &arg);\n static rtx iq2000_function_arg\t      (cumulative_args_t,\n \t\t\t\t       machine_mode, const_tree, bool);\n static void iq2000_function_arg_advance (cumulative_args_t,\n@@ -1421,13 +1421,12 @@ iq2000_function_arg_boundary (machine_mode mode, const_tree type)\n }\n \n static int\n-iq2000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  tree type ATTRIBUTE_UNUSED,\n-\t\t\t  bool named ATTRIBUTE_UNUSED)\n+iq2000_arg_partial_bytes (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n+  if (arg.mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n     {\n       if (TARGET_DEBUG_D_MODE)\n \tfprintf (stderr, \"iq2000_arg_partial_bytes=%d\\n\", UNITS_PER_WORD);"}, {"sha": "ba6ba7623013fcfbab1abed3a8577c06584c6ab0", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -93,8 +93,8 @@ static bool m32r_rtx_costs (rtx, machine_mode, int, int, int *, bool speed);\n static int m32r_memory_move_cost (machine_mode, reg_class_t, bool);\n static bool m32r_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t    const_tree, bool);\n-static int m32r_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t   tree, bool);\n+static int m32r_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t   const function_arg_info &);\n static rtx m32r_function_arg (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static void m32r_function_arg_advance (cumulative_args_t, machine_mode,\n@@ -1164,17 +1164,13 @@ gen_split_move_double (rtx operands[])\n \n \f\n static int\n-m32r_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n+m32r_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   int words;\n   unsigned int size =\n-    (((mode == BLKmode && type)\n-      ? (unsigned int) int_size_in_bytes (type)\n-      : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n-    / UNITS_PER_WORD;\n+    (arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n \n   if (*cum >= M32R_MAX_PARM_REGS)\n     words = 0;"}, {"sha": "d93c818f3819795b81eb20538b155b8a90fc23f3", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -129,8 +129,7 @@ static bool       mcore_rtx_costs\t\t(rtx, machine_mode, int, int,\n static void       mcore_external_libcall\t(rtx);\n static bool       mcore_return_in_memory\t(const_tree, const_tree);\n static int        mcore_arg_partial_bytes       (cumulative_args_t,\n-\t\t\t\t\t\t machine_mode,\n-\t\t\t\t\t\t tree, bool);\n+\t\t\t\t\t\t const function_arg_info &);\n static rtx        mcore_function_arg            (cumulative_args_t,\n \t\t\t\t\t\t machine_mode,\n \t\t\t\t\t\t const_tree, bool);\n@@ -2841,22 +2840,19 @@ mcore_function_arg_boundary (machine_mode mode,\n }\n \n /* Returns the number of bytes of argument registers required to hold *part*\n-   of a parameter of machine mode MODE and type TYPE (which may be NULL if\n-   the type is not known).  If the argument fits entirely in the argument\n-   registers, or entirely on the stack, then 0 is returned.  CUM is the\n-   number of argument registers already used by earlier parameters to\n-   the function.  */\n+   of argument ARG.  If the argument fits entirely in the argument registers,\n+   or entirely on the stack, then 0 is returned.  CUM is the number of\n+   argument registers already used by earlier parameters to the function.  */\n \n static int\n-mcore_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n-\t\t\t tree type, bool named)\n+mcore_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n {\n-  int reg = ROUND_REG (*get_cumulative_args (cum), mode);\n+  int reg = ROUND_REG (*get_cumulative_args (cum), arg.mode);\n \n-  if (named == 0)\n+  if (!arg.named)\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n     return 0;\n       \n   /* REG is not the *hardware* register number of the register that holds\n@@ -2871,7 +2867,7 @@ mcore_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n     return 0;\n \n   /* If the argument fits entirely in registers, return 0.  */\n-  if (reg + mcore_num_arg_regs (mode, type) <= NPARM_REGS)\n+  if (reg + mcore_num_arg_regs (arg.mode, arg.type) <= NPARM_REGS)\n     return 0;\n \n   /* The argument overflows the number of available argument registers."}, {"sha": "d80acdea876e36e4e1abdef27ba978d0770adbf1", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1653,30 +1653,25 @@ microblaze_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \n /* Return number of bytes of argument to put in registers. */\n static int\n-function_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\t\n-\t\t\t    tree type, bool named ATTRIBUTE_UNUSED)\t\n+function_arg_partial_bytes (cumulative_args_t cum_v,\n+\t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if ((mode == BLKmode\n-       || GET_MODE_CLASS (mode) != MODE_COMPLEX_INT\n-       || GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n+  if ((arg.mode == BLKmode\n+       || GET_MODE_CLASS (arg.mode) != MODE_COMPLEX_INT\n+       || GET_MODE_CLASS (arg.mode) != MODE_COMPLEX_FLOAT)\n       && cum->arg_words < MAX_ARGS_IN_REGISTERS)\n     {\n-      int words;\n-      if (mode == BLKmode)\n-\twords = ((int_size_in_bytes (type) + UNITS_PER_WORD - 1)\n-\t\t / UNITS_PER_WORD);\n-      else\n-\twords = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n+      int words = ((arg.promoted_size_in_bytes () + UNITS_PER_WORD - 1)\n+\t\t   / UNITS_PER_WORD);\n       if (words + cum->arg_words <= MAX_ARGS_IN_REGISTERS)\n \treturn 0;\t\t/* structure fits in registers */\n \n       return (MAX_ARGS_IN_REGISTERS - cum->arg_words) * UNITS_PER_WORD;\n     }\n \n-  else if (mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n+  else if (arg.mode == DImode && cum->arg_words == MAX_ARGS_IN_REGISTERS - 1)\n     return UNITS_PER_WORD;\n \n   return 0;"}, {"sha": "104550116171ccf211aed4cb0b67b5b17d2748fb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -6140,12 +6140,12 @@ mips_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n /* Implement TARGET_ARG_PARTIAL_BYTES.  */\n \n static int\n-mips_arg_partial_bytes (cumulative_args_t cum,\n-\t\t\tmachine_mode mode, tree type, bool named)\n+mips_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n {\n   struct mips_arg_info info;\n \n-  mips_get_arg_info (&info, get_cumulative_args (cum), mode, type, named);\n+  mips_get_arg_info (&info, get_cumulative_args (cum),\n+\t\t     arg.mode, arg.type, arg.named);\n   return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n }\n "}, {"sha": "6f7437a42fd5dca86b58746864ca3b1abad04a39", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1607,8 +1607,8 @@ mn10300_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n    partially in registers and partially in memory.  */\n \n static int\n-mn10300_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t   tree type, bool named ATTRIBUTE_UNUSED)\n+mn10300_arg_partial_bytes (cumulative_args_t cum_v,\n+\t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size;\n@@ -1617,11 +1617,7 @@ mn10300_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n   int nregs = 2;\n \n   /* Figure out the size of the object to be passed.  */\n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  size = arg.promoted_size_in_bytes ();\n   cum->nbytes = (cum->nbytes + 3) & ~3;\n \n   /* Don't pass this arg via a register if all the argument registers\n@@ -1634,7 +1630,7 @@ mn10300_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \n   /* Don't pass this arg via a register if it would be split between\n      registers and memory.  */\n-  if (type == NULL_TREE\n+  if (arg.type == NULL_TREE\n       && cum->nbytes + size > nregs * UNITS_PER_WORD)\n     return 0;\n "}, {"sha": "bd382f1e68936c1234549a3d7bccd06920273a4e", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -478,26 +478,24 @@ moxie_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n    that fit in argument passing registers.  */\n \n static int\n-moxie_arg_partial_bytes (cumulative_args_t cum_v,\n-\t\t\t machine_mode mode,\n-\t\t\t tree type, bool named)\n+moxie_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int bytes_left, size;\n \n   if (*cum >= 8)\n     return 0;\n \n-  if (moxie_pass_by_reference (cum_v, mode, type, named))\n+  if (moxie_pass_by_reference (cum_v, arg.mode, arg.type, arg.named))\n     size = 4;\n-  else if (type)\n+  else if (arg.type)\n     {\n-      if (AGGREGATE_TYPE_P (type))\n+      if (AGGREGATE_TYPE_P (arg.type))\n \treturn 0;\n-      size = int_size_in_bytes (type);\n+      size = int_size_in_bytes (arg.type);\n     }\n   else\n-    size = GET_MODE_SIZE (mode);\n+    size = GET_MODE_SIZE (arg.mode);\n \n   bytes_left = (4 * 6) - ((*cum - 2) * 4);\n "}, {"sha": "fb6c5fb8bec367d077a0ef6090ac78f5c1889320", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -728,14 +728,11 @@ msp430_function_arg (cumulative_args_t cap,\n #define TARGET_ARG_PARTIAL_BYTES msp430_arg_partial_bytes\n \n int\n-msp430_arg_partial_bytes (cumulative_args_t cap,\n-\t\t\t  machine_mode mode,\n-\t\t\t  tree type,\n-\t\t\t  bool named)\n+msp430_arg_partial_bytes (cumulative_args_t cap, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *ca = get_cumulative_args (cap);\n \n-  msp430_evaluate_arg (cap, mode, type, named);\n+  msp430_evaluate_arg (cap, arg.mode, arg.type, arg.named);\n \n   if (ca->reg_count && ca->mem_count)\n     return ca->reg_count * UNITS_PER_WORD;"}, {"sha": "c92a598dc5e456d7a225cda512dc875ba4e19da0", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1963,8 +1963,7 @@ nds32_must_pass_in_stack (machine_mode mode, const_tree type)\n }\n \n static int\n-nds32_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n-\t\t\t tree type, bool named ATTRIBUTE_UNUSED)\n+nds32_arg_partial_bytes (cumulative_args_t ca, const function_arg_info &arg)\n {\n   /* Returns the number of bytes at the beginning of an argument that\n      must be put in registers.  The value must be zero for arguments that are\n@@ -1985,18 +1984,19 @@ nds32_arg_partial_bytes (cumulative_args_t ca, machine_mode mode,\n \n   /* If we have already runned out of argument registers, return zero\n      so that the argument will be entirely pushed on the stack.  */\n-  if (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n+  if (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, arg.mode, arg.type)\n       >= NDS32_GPR_ARG_FIRST_REGNUM + NDS32_MAX_GPR_REGS_FOR_ARGS)\n     return 0;\n \n   /* Calculate how many registers do we need for this argument.  */\n-  needed_reg_count = NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n+  needed_reg_count = NDS32_NEED_N_REGS_FOR_ARG (arg.mode, arg.type);\n \n   /* Calculate how many argument registers have left for passing argument.\n      Note that we should count it from next available register number.  */\n   remaining_reg_count\n     = NDS32_MAX_GPR_REGS_FOR_ARGS\n-      - (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n+      - (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset,\n+\t\t\t\t\t     arg.mode, arg.type)\n \t - NDS32_GPR_ARG_FIRST_REGNUM);\n \n   /* Note that we have to return the nubmer of bytes, not registers count.  */"}, {"sha": "1e04cf96f2769301e231b4df1562e4917df289da", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -3390,20 +3390,11 @@ nios2_function_arg (cumulative_args_t cum_v, machine_mode mode,\n    in memory.  */\n \n static int\n-nios2_arg_partial_bytes (cumulative_args_t cum_v,\n-                         machine_mode mode, tree type ATTRIBUTE_UNUSED,\n-                         bool named ATTRIBUTE_UNUSED)\n+nios2_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n-  HOST_WIDE_INT param_size;\n-\n-  if (mode == BLKmode)\n-    {\n-      param_size = int_size_in_bytes (type);\n-      gcc_assert (param_size >= 0);\n-    }\n-  else\n-    param_size = GET_MODE_SIZE (mode);\n+  HOST_WIDE_INT param_size = arg.promoted_size_in_bytes ();\n+  gcc_assert (param_size >= 0);\n \n   /* Convert to words (round up).  */\n   param_size = (UNITS_PER_WORD - 1 + param_size) / UNITS_PER_WORD;"}, {"sha": "231286e3aaeccec5206c9878070740fdc70b7e89", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -166,8 +166,7 @@ static void pa_init_libfuncs (void);\n static rtx pa_struct_value_rtx (tree, int);\n static bool pa_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t  const_tree, bool);\n-static int pa_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t\t tree, bool);\n+static int pa_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n static void pa_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n static rtx pa_function_arg (cumulative_args_t, machine_mode,\n@@ -9685,8 +9684,7 @@ pa_function_arg_boundary (machine_mode mode, const_tree type)\n    then this routine should return zero.  */\n \n static int\n-pa_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      tree type, bool named ATTRIBUTE_UNUSED)\n+pa_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   unsigned int max_arg_words = 8;\n@@ -9695,10 +9693,11 @@ pa_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n   if (!TARGET_64BIT)\n     return 0;\n \n-  if (pa_function_arg_size (mode, type) > 1 && (cum->words & 1))\n+  if (pa_function_arg_size (arg.mode, arg.type) > 1 && (cum->words & 1))\n     offset = 1;\n \n-  if (cum->words + offset + pa_function_arg_size (mode, type) <= max_arg_words)\n+  if (cum->words + offset + pa_function_arg_size (arg.mode, arg.type)\n+      <= max_arg_words)\n     /* Arg fits fully into registers.  */\n     return 0;\n   else if (cum->words + offset >= max_arg_words)"}, {"sha": "c8ec89c6908f5fccfcd12098819f2db08f815ee8", "filename": "gcc/config/pru/pru.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fpru%2Fpru.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fpru%2Fpru.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2179,10 +2179,7 @@ pru_function_arg (cumulative_args_t cum_v, machine_mode mode,\n    between registers and memory, so we can return 0.  */\n \n static int\n-pru_arg_partial_bytes (cumulative_args_t cum_v ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       tree type ATTRIBUTE_UNUSED,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n+pru_arg_partial_bytes (cumulative_args_t, const function_arg_info &)\n {\n   return 0;\n }"}, {"sha": "f1991029bb51acbe405288fc0a93b07f8b0a33df", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2778,11 +2778,12 @@ riscv_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \n static int\n riscv_arg_partial_bytes (cumulative_args_t cum,\n-\t\t\t machine_mode mode, tree type, bool named)\n+\t\t\t const function_arg_info &generic_arg)\n {\n   struct riscv_arg_info arg;\n \n-  riscv_get_arg_info (&arg, get_cumulative_args (cum), mode, type, named, false);\n+  riscv_get_arg_info (&arg, get_cumulative_args (cum), generic_arg.mode,\n+\t\t      generic_arg.type, generic_arg.named, false);\n   return arg.stack_p ? arg.num_gprs * UNITS_PER_WORD : 0;\n }\n "}, {"sha": "c3fc5eeb1d01bf2c3d66fab1a9c3406161c1ae9d", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2007,8 +2007,8 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n    returns the number of bytes used by the first element of the PARALLEL.  */\n \n int\n-rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t  tree type, bool named)\n+rs6000_arg_partial_bytes (cumulative_args_t cum_v,\n+\t\t\t  const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   bool passed_in_gprs = true;\n@@ -2017,12 +2017,13 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n   machine_mode elt_mode;\n   int n_elts;\n \n-  rs6000_discover_homogeneous_aggregate (mode, type, &elt_mode, &n_elts);\n+  rs6000_discover_homogeneous_aggregate (arg.mode, arg.type,\n+\t\t\t\t\t &elt_mode, &n_elts);\n \n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n \n-  if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, named))\n+  if (USE_ALTIVEC_FOR_ARG_P (cum, elt_mode, arg.named))\n     {\n       /* If we are passing this arg in the fixed parameter save area (gprs or\n          memory) as well as VRs, we do not use the partial bytes mechanism;\n@@ -2041,22 +2042,21 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n     }\n \n   /* In this complicated case we just disable the partial_nregs code.  */\n-  if (TARGET_MACHO && rs6000_darwin64_struct_check_p (mode, type))\n+  if (TARGET_MACHO && rs6000_darwin64_struct_check_p (arg.mode, arg.type))\n     return 0;\n \n-  align_words = rs6000_parm_start (mode, type, cum->words);\n+  align_words = rs6000_parm_start (arg.mode, arg.type, cum->words);\n \n   if (USE_FP_FOR_ARG_P (cum, elt_mode)\n-      && !(TARGET_AIX && !TARGET_ELF\n-\t   && type != NULL && AGGREGATE_TYPE_P (type)))\n+      && !(TARGET_AIX && !TARGET_ELF && arg.aggregate_type_p ()))\n     {\n       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;\n \n       /* If we are passing this arg in the fixed parameter save area\n          (gprs or memory) as well as FPRs, we do not use the partial\n \t bytes mechanism; instead, rs6000_function_arg will return a\n \t PARALLEL including a memory element as necessary.  */\n-      if (type\n+      if (arg.type\n \t  && (cum->nargs_prototype <= 0\n \t      || ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n \t\t  && TARGET_XL_COMPAT\n@@ -2087,7 +2087,7 @@ rs6000_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n \n   if (passed_in_gprs\n       && align_words < GP_ARG_NUM_REG\n-      && GP_ARG_NUM_REG < align_words + rs6000_arg_size (mode, type))\n+      && GP_ARG_NUM_REG < align_words + rs6000_arg_size (arg.mode, arg.type))\n     ret = (GP_ARG_NUM_REG - align_words) * (TARGET_32BIT ? 4 : 8);\n \n   if (ret != 0 && TARGET_DEBUG_ARG)\n@@ -2222,7 +2222,8 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n     return true;\n \n   /* Also true if we're partially in registers and partially not.  */\n-  if (rs6000_arg_partial_bytes (args_so_far, mode, type, true) != 0)\n+  function_arg_info arg (type, mode, /*named=*/true);\n+  if (rs6000_arg_partial_bytes (args_so_far, arg) != 0)\n     return true;\n \n   /* Update info on where next arg arrives in registers.  */"}, {"sha": "b330a5663cf4070b9dc71c316708bf366e1812d2", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -159,9 +159,8 @@ extern void setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n extern unsigned int rs6000_function_arg_boundary (machine_mode mode,\n \t\t\t\t\t\t  const_tree type);\n extern bool rs6000_must_pass_in_stack (machine_mode mode, const_tree type);\n-extern int rs6000_arg_partial_bytes (cumulative_args_t cum_v,\n-\t\t\t\t     machine_mode mode, tree type,\n-\t\t\t\t     bool named);\n+extern int rs6000_arg_partial_bytes (cumulative_args_t,\n+\t\t\t\t     const function_arg_info &);\n extern void rs6000_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t\t machine_mode mode,\n \t\t\t\t\t const_tree type, bool named);"}, {"sha": "1276d3aec0f8c83a58748d7470297a3639597c3c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -298,8 +298,7 @@ static bool sh_pass_by_reference (cumulative_args_t, machine_mode,\n \t\t\t\t  const_tree, bool);\n static bool sh_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n-static int sh_arg_partial_bytes (cumulative_args_t, machine_mode,\n-\t\t\t         tree, bool);\n+static int sh_arg_partial_bytes (cumulative_args_t, const function_arg_info &);\n static void sh_function_arg_advance (cumulative_args_t, machine_mode,\n \t\t\t\t     const_tree, bool);\n static rtx sh_function_arg (cumulative_args_t, machine_mode,\n@@ -7992,20 +7991,17 @@ sh_pass_in_reg_p (const CUMULATIVE_ARGS& cum, machine_mode mode,\n }\n \n static int\n-sh_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-\t\t      tree type, bool named ATTRIBUTE_UNUSED)\n+sh_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int words = 0;\n \n-  if (sh_pass_in_reg_p (*cum, mode, type)\n+  if (sh_pass_in_reg_p (*cum, arg.mode, arg.type)\n       && !TARGET_FPU_DOUBLE\n-      && (sh_round_reg (*cum, mode)\n-\t  + (mode != BLKmode\n-\t     ? CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD)\n-\t     : CEIL (int_size_in_bytes (type), UNITS_PER_WORD))\n-\t  > NPARM_REGS (mode)))\n-    words = NPARM_REGS (mode) - sh_round_reg (*cum, mode);\n+      && (sh_round_reg (*cum, arg.mode)\n+\t  + CEIL (arg.promoted_size_in_bytes (), UNITS_PER_WORD)\n+\t  > NPARM_REGS (arg.mode)))\n+    words = NPARM_REGS (arg.mode) - sh_round_reg (*cum, arg.mode);\n \n   return words * UNITS_PER_WORD;\n }"}, {"sha": "6fb61749c3f531ead054b2a5d5034c677886bfc7", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -668,7 +668,7 @@ static pad_direction sparc_function_arg_padding (machine_mode, const_tree);\n static unsigned int sparc_function_arg_boundary (machine_mode,\n \t\t\t\t\t\t const_tree);\n static int sparc_arg_partial_bytes (cumulative_args_t,\n-\t\t\t\t    machine_mode, tree, bool);\n+\t\t\t\t    const function_arg_info &);\n static bool sparc_return_in_memory (const_tree, const_tree);\n static rtx sparc_struct_value_rtx (tree, int);\n static rtx sparc_function_value (const_tree, const_tree, bool);\n@@ -7533,14 +7533,13 @@ sparc_function_arg_boundary (machine_mode mode, const_tree type)\n    mode] will be split between that reg and memory.  */\n \n static int\n-sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n-\t\t\t tree type, bool named)\n+sparc_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n {\n   int slotno, regno, padding;\n \n   /* We pass false for incoming here, it doesn't matter.  */\n-  slotno = function_arg_slotno (get_cumulative_args (cum), mode, type, named,\n-\t\t\t\tfalse, &regno, &padding);\n+  slotno = function_arg_slotno (get_cumulative_args (cum), arg.mode, arg.type,\n+\t\t\t\targ.named, false, &regno, &padding);\n \n   if (slotno == -1)\n     return 0;\n@@ -7550,7 +7549,7 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n       /* We are guaranteed by pass_by_reference that the size of the\n \t argument is not greater than 8 bytes, so we only need to return\n \t one word if the argument is partially passed in registers.  */\n-      const int size = GET_MODE_SIZE (mode);\n+      const int size = GET_MODE_SIZE (arg.mode);\n \n       if (size > UNITS_PER_WORD && slotno == SPARC_INT_ARG_MAX - 1)\n \treturn UNITS_PER_WORD;\n@@ -7560,33 +7559,33 @@ sparc_arg_partial_bytes (cumulative_args_t cum, machine_mode mode,\n       /* We are guaranteed by pass_by_reference that the size of the\n \t argument is not greater than 16 bytes, so we only need to return\n \t one word if the argument is partially passed in registers.  */\n-      if (type && AGGREGATE_TYPE_P (type))\n+      if (arg.aggregate_type_p ())\n \t{\n-\t  const int size = int_size_in_bytes (type);\n+\t  const int size = int_size_in_bytes (arg.type);\n \n \t  if (size > UNITS_PER_WORD\n \t      && (slotno == SPARC_INT_ARG_MAX - 1\n \t\t  || slotno == SPARC_FP_ARG_MAX - 1))\n \t    return UNITS_PER_WORD;\n \t}\n-      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_INT\n-\t       || ((GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t\t    || (type && VECTOR_TYPE_P (type)))\n-\t\t   && !(TARGET_FPU && named)))\n+      else if (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_INT\n+\t       || ((GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT\n+\t\t    || (arg.type && VECTOR_TYPE_P (arg.type)))\n+\t\t   && !(TARGET_FPU && arg.named)))\n \t{\n-\t  const int size = (type && VECTOR_FLOAT_TYPE_P (type))\n-\t\t\t   ? int_size_in_bytes (type)\n-\t\t\t   : GET_MODE_SIZE (mode);\n+\t  const int size = (arg.type && VECTOR_FLOAT_TYPE_P (arg.type))\n+\t\t\t   ? int_size_in_bytes (arg.type)\n+\t\t\t   : GET_MODE_SIZE (arg.mode);\n \n \t  if (size > UNITS_PER_WORD && slotno == SPARC_INT_ARG_MAX - 1)\n \t    return UNITS_PER_WORD;\n \t}\n-      else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t       || (type && VECTOR_TYPE_P (type)))\n+      else if (GET_MODE_CLASS (arg.mode) == MODE_COMPLEX_FLOAT\n+\t       || (arg.type && VECTOR_TYPE_P (arg.type)))\n \t{\n-\t  const int size = (type && VECTOR_FLOAT_TYPE_P (type))\n-\t\t\t   ? int_size_in_bytes (type)\n-\t\t\t   : GET_MODE_SIZE (mode);\n+\t  const int size = (arg.type && VECTOR_FLOAT_TYPE_P (arg.type))\n+\t\t\t   ? int_size_in_bytes (arg.type)\n+\t\t\t   : GET_MODE_SIZE (arg.mode);\n \n \t  if (size > UNITS_PER_WORD && slotno == SPARC_FP_ARG_MAX - 1)\n \t    return UNITS_PER_WORD;"}, {"sha": "9e221126bb06c12f25c5a7176a98e1ab1d1bad2f", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -196,27 +196,22 @@ v850_function_arg (cumulative_args_t cum_v, machine_mode mode,\n /* Return the number of bytes which must be put into registers\n    for values which are part in registers and part in memory.  */\n static int\n-v850_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n-                        tree type, bool named)\n+v850_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int size, align;\n \n-  if (!named)\n+  if (!arg.named)\n     return 0;\n \n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  size = arg.promoted_size_in_bytes ();\n   if (size < 1)\n     size = 1;\n   \n   if (!TARGET_GCC_ABI)\n     align = UNITS_PER_WORD;\n-  else if (type)\n-    align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n+  else if (arg.type)\n+    align = TYPE_ALIGN (arg.type) / BITS_PER_UNIT;\n   else\n     align = size;\n \n@@ -228,7 +223,7 @@ v850_arg_partial_bytes (cumulative_args_t cum_v, machine_mode mode,\n   if (cum->nbytes + size <= 4 * UNITS_PER_WORD)\n     return 0;\n \n-  if (type == NULL_TREE\n+  if (arg.type == NULL_TREE\n       && cum->nbytes + size > 4 * UNITS_PER_WORD)\n     return 0;\n "}, {"sha": "a7838ff3dc0bd2e0b4a221a76db39878ee029b19", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -4057,7 +4057,7 @@ Perform a target dependent initialization of pic_offset_table_rtx.\n This hook is called at the start of register allocation.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t @var{cum}, machine_mode @var{mode}, tree @var{type}, bool @var{named})\n+@deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (cumulative_args_t @var{cum}, const function_arg_info @var{&arg})\n This target hook returns the number of bytes at the beginning of an\n argument that must be put in registers.  The value must be zero for\n arguments that are passed entirely in registers or that are entirely"}, {"sha": "b008a64d14210bfda1025a91578849d1f18fa8cf", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -1709,11 +1709,12 @@ block_move_libcall_safe_for_call_parm (void)\n     for ( ; arg != void_list_node ; arg = TREE_CHAIN (arg))\n       {\n \tmachine_mode mode = TYPE_MODE (TREE_VALUE (arg));\n+\tfunction_arg_info arg_info (mode, /*named=*/true);\n \trtx tmp = targetm.calls.function_arg (args_so_far, mode,\n \t\t\t\t\t      NULL_TREE, true);\n \tif (!tmp || !REG_P (tmp))\n \t  return false;\n-\tif (targetm.calls.arg_partial_bytes (args_so_far, mode, NULL, 1))\n+\tif (targetm.calls.arg_partial_bytes (args_so_far, arg_info))\n \t  return false;\n \ttargetm.calls.function_arg_advance (args_so_far, mode,\n \t\t\t\t\t    NULL_TREE, true);"}, {"sha": "eabe6986d5e52aef3cae6147e3a7db8bee67dc76", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -2559,10 +2559,9 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n     {\n       int partial;\n \n-      partial = targetm.calls.arg_partial_bytes (all->args_so_far,\n-\t\t\t\t\t\t data->promoted_mode,\n-\t\t\t\t\t\t data->passed_type,\n-\t\t\t\t\t\t data->named_arg);\n+      function_arg_info arg (data->passed_type, data->promoted_mode,\n+\t\t\t     data->named_arg);\n+      partial = targetm.calls.arg_partial_bytes (all->args_so_far, arg);\n       data->partial = partial;\n \n       /* The caller might already have allocated stack space for the"}, {"sha": "22f623022d34190d71430a1bb4fabe94485c81f2", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -4677,8 +4677,8 @@ compiler when this occurs, and how many bytes should go in registers.\\n\\\n @code{TARGET_FUNCTION_ARG} for these arguments should return the first\\n\\\n register to be used by the caller for this argument; likewise\\n\\\n @code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.\",\n- int, (cumulative_args_t cum, machine_mode mode, tree type, bool named),\n- hook_int_CUMULATIVE_ARGS_mode_tree_bool_0)\n+ int, (cumulative_args_t cum, const function_arg_info &arg),\n+ hook_int_CUMULATIVE_ARGS_arg_info_0)\n \n /* Update the state in CA to advance past an argument in the\n    argument list.  The values MODE, TYPE, and NAMED describe that"}, {"sha": "a65693049b2093c4539248503c0146d6c8a347ac", "filename": "gcc/target.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -149,6 +149,9 @@ class ao_ref;\n /* This is defined in tree-vectorizer.h.  */\n class _stmt_vec_info;\n \n+/* This is defined in calls.h.  */\n+class function_arg_info;\n+\n /* These are defined in tree-vect-stmts.c.  */\n extern tree stmt_vectype (class _stmt_vec_info *);\n extern bool stmt_in_inner_loop_p (class _stmt_vec_info *);"}, {"sha": "855a5b385d3c07d9d5ba009afb27a27b86f764d8", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -768,10 +768,8 @@ hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true (\n }\n \n int\n-hook_int_CUMULATIVE_ARGS_mode_tree_bool_0 (\n-\tcumulative_args_t ca ATTRIBUTE_UNUSED,\n-\tmachine_mode mode ATTRIBUTE_UNUSED,\n-\ttree type ATTRIBUTE_UNUSED, bool named ATTRIBUTE_UNUSED)\n+hook_int_CUMULATIVE_ARGS_arg_info_0 (cumulative_args_t,\n+\t\t\t\t     const function_arg_info &)\n {\n   return 0;\n }"}, {"sha": "9dc249bd1404f2e013dea8ba035ad6daa0ed10f0", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c81bc1fb43366ca1b4332d8a6042b648a84cdc/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=a7c81bc1fb43366ca1b4332d8a6042b648a84cdc", "patch": "@@ -137,8 +137,8 @@ extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n   (cumulative_args_t, machine_mode, const_tree, bool);\n extern bool hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n   (cumulative_args_t, machine_mode, const_tree, bool);\n-extern int hook_int_CUMULATIVE_ARGS_mode_tree_bool_0\n-  (cumulative_args_t, machine_mode, tree, bool);\n+extern int hook_int_CUMULATIVE_ARGS_arg_info_0\n+  (cumulative_args_t, const function_arg_info &);\n extern void hook_void_CUMULATIVE_ARGS_tree\n   (cumulative_args_t, tree);\n extern const char *hook_invalid_arg_for_unprototyped_fn"}]}