{"sha": "ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5OTM4MDVlMDhkNmE4ZTYzOTA5NWZkYzljYzg5NWMyZWQ0ZDJkYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-20T15:00:31Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-20T15:00:31Z"}, "message": "fold-const.c (fold): Replace \"t\" with \"tem\" where it is used as a temporary variable.\n\n\t* fold-const.c (fold): Replace \"t\" with \"tem\" where it is used\n\tas a temporary variable.  Remove \"orig_t\" and all of its uses.\n\nFrom-SVN: r79746", "tree": {"sha": "b9109672074983be9ad0891bef380066308a1c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9109672074983be9ad0891bef380066308a1c9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea993805e08d6a8e639095fdc9cc895c2ed4d2da/comments", "author": null, "committer": null, "parents": [{"sha": "8e7b3a43df2bfe691c28de316ff48457178ec4a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7b3a43df2bfe691c28de316ff48457178ec4a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7b3a43df2bfe691c28de316ff48457178ec4a7"}], "stats": {"total": 105, "additions": 54, "deletions": 51}, "files": [{"sha": "c708efa7edef2a2b8dba1f5faf43351caac96393", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea993805e08d6a8e639095fdc9cc895c2ed4d2da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea993805e08d6a8e639095fdc9cc895c2ed4d2da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "patch": "@@ -1,3 +1,8 @@\n+2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c (fold): Replace \"t\" with \"tem\" where it is used\n+\tas a temporary variable.  Remove \"orig_t\" and all of its uses.\n+\n 2004-03-20  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (fold): Remove variable \"invert\"."}, {"sha": "b7d3f16df37d908083b3a606dc5a997dca34e1c7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea993805e08d6a8e639095fdc9cc895c2ed4d2da/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea993805e08d6a8e639095fdc9cc895c2ed4d2da/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ea993805e08d6a8e639095fdc9cc895c2ed4d2da", "patch": "@@ -5385,7 +5385,7 @@ static\n tree\n fold (tree expr)\n {\n-  tree t = expr, orig_t;\n+  const tree t = expr;\n   tree t1 = NULL_TREE;\n   tree tem;\n   tree type = TREE_TYPE (expr);\n@@ -5405,8 +5405,6 @@ fold (tree expr)\n   if (kind == 'c')\n     return t;\n \n-  orig_t = t;\n-\n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n     {\n       tree subop;\n@@ -5513,15 +5511,15 @@ fold (tree expr)\n \t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n \t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n     {\n-      t = fold (build (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n-\t\t       : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n-\t\t       : TRUTH_XOR_EXPR,\n-\t\t       type, arg0, arg1));\n+      tem = fold (build (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n+\t\t\t : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n+\t\t\t : TRUTH_XOR_EXPR,\n+\t\t\t type, arg0, arg1));\n \n       if (code == EQ_EXPR)\n-\tt = invert_truthvalue (t);\n+\ttem = invert_truthvalue (tem);\n \n-      return t;\n+      return tem;\n     }\n \n   if (TREE_CODE_CLASS (code) == '1')\n@@ -5537,8 +5535,8 @@ fold (tree expr)\n \t    arg01 = fold (build1 (code, type, arg01));\n \t  if (! VOID_TYPE_P (TREE_TYPE (arg02)))\n \t    arg02 = fold (build1 (code, type, arg02));\n-\t  t = fold (build (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t   arg01, arg02));\n+\t  tem = fold (build (COND_EXPR, type, TREE_OPERAND (arg0, 0),\n+\t\t\t     arg01, arg02));\n \n \t  /* If this was a conversion, and all we did was to move into\n \t     inside the COND_EXPR, bring it back out.  But leave it if\n@@ -5551,25 +5549,25 @@ fold (tree expr)\n \n \t  if ((code == NOP_EXPR || code == CONVERT_EXPR\n \t       || code == NON_LVALUE_EXPR)\n-\t      && TREE_CODE (t) == COND_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (t, 1)) == code\n-\t      && TREE_CODE (TREE_OPERAND (t, 2)) == code\n-\t      && ! VOID_TYPE_P (TREE_OPERAND (t, 1))\n-\t      && ! VOID_TYPE_P (TREE_OPERAND (t, 2))\n-\t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0))\n-\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 2), 0)))\n-\t      && ! (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TREE_CODE (tem) == COND_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (tem, 1)) == code\n+\t      && TREE_CODE (TREE_OPERAND (tem, 2)) == code\n+\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 1))\n+\t      && ! VOID_TYPE_P (TREE_OPERAND (tem, 2))\n+\t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))\n+\t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 2), 0)))\n+\t      && ! (INTEGRAL_TYPE_P (TREE_TYPE (tem))\n \t\t    && (INTEGRAL_TYPE_P\n-\t\t\t(TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0))))\n-\t\t    && TYPE_PRECISION (TREE_TYPE (t)) <= BITS_PER_WORD))\n-\t    t = build1 (code, type,\n-\t\t\tbuild (COND_EXPR,\n-\t\t\t       TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t  (TREE_OPERAND (t, 1), 0)),\n-\t\t\t       TREE_OPERAND (t, 0),\n-\t\t\t       TREE_OPERAND (TREE_OPERAND (t, 1), 0),\n-\t\t\t       TREE_OPERAND (TREE_OPERAND (t, 2), 0)));\n-\t  return t;\n+\t\t\t(TREE_TYPE (TREE_OPERAND (TREE_OPERAND (tem, 1), 0))))\n+\t\t    && TYPE_PRECISION (TREE_TYPE (tem)) <= BITS_PER_WORD))\n+\t    tem = build1 (code, type,\n+\t\t\t  build (COND_EXPR,\n+\t\t\t\t TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t    (TREE_OPERAND (tem, 1), 0)),\n+\t\t\t\t TREE_OPERAND (tem, 0),\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (tem, 1), 0),\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n+\t  return tem;\n \t}\n       else if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n \treturn fold (build (COND_EXPR, type, arg0,\n@@ -5734,14 +5732,13 @@ fold (tree expr)\n \t  /* Don't leave an assignment inside a conversion\n \t     unless assigning a bitfield.  */\n \t  tree prev = TREE_OPERAND (t, 0);\n-\t  if (t == orig_t)\n-\t    t = copy_node (t);\n-\t  TREE_OPERAND (t, 0) = TREE_OPERAND (prev, 1);\n+\t  tem = copy_node (t);\n+\t  TREE_OPERAND (tem, 0) = TREE_OPERAND (prev, 1);\n \t  /* First do the assignment, then return converted constant.  */\n-\t  t = build (COMPOUND_EXPR, TREE_TYPE (t), prev, fold (t));\n-\t  TREE_NO_UNUSED_WARNING (t) = 1;\n-\t  TREE_USED (t) = 1;\n-\t  return t;\n+\t  tem = build (COMPOUND_EXPR, TREE_TYPE (tem), prev, fold (tem));\n+\t  TREE_NO_UNUSED_WARNING (tem) = 1;\n+\t  TREE_USED (tem) = 1;\n+\t  return tem;\n \t}\n \n       /* Convert (T)(x & c) into (T)x & (T)c, if c is an integer\n@@ -5802,16 +5799,16 @@ fold (tree expr)\n \t{\n \t  tree m = purpose_member (arg1, CONSTRUCTOR_ELTS (arg0));\n \t  if (m)\n-\t    t = TREE_VALUE (m);\n+\t    return TREE_VALUE (m);\n \t}\n       return t;\n \n     case RANGE_EXPR:\n       if (TREE_CONSTANT (t) != wins)\n \t{\n-\t  if (t == orig_t)\n-\t    t = copy_node (t);\n-\t  TREE_CONSTANT (t) = wins;\n+\t  tem = copy_node (t);\n+\t  TREE_CONSTANT (tem) = wins;\n+\t  return tem;\n \t}\n       return t;\n \n@@ -5863,12 +5860,13 @@ fold (tree expr)\n     case BIT_NOT_EXPR:\n       if (wins)\n \t{\n-\t  t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n-\t\t\t   ~ TREE_INT_CST_HIGH (arg0));\n-\t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t, 0);\n-\t  TREE_OVERFLOW (t) = TREE_OVERFLOW (arg0);\n-\t  TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg0);\n+\t  tem = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n+\t\t\t     ~ TREE_INT_CST_HIGH (arg0));\n+\t  TREE_TYPE (tem) = type;\n+\t  force_fit_type (tem, 0);\n+\t  TREE_OVERFLOW (tem) = TREE_OVERFLOW (arg0);\n+\t  TREE_CONSTANT_OVERFLOW (tem) = TREE_CONSTANT_OVERFLOW (arg0);\n+\t  return tem;\n \t}\n       else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n@@ -7233,8 +7231,8 @@ fold (tree expr)\n \t    if (REAL_VALUE_ISNAN (cst)\n \t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n \t      {\n-\t\tt = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t\treturn omit_one_operand (type, fold_convert (type, t), arg0);\n+\t\ttem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n+\t\treturn omit_one_operand (type, fold_convert (type, tem), arg0);\n \t      }\n \n \t    /* Fold comparisons against infinity.  */\n@@ -7842,11 +7840,11 @@ fold (tree expr)\n \t\t      return omit_one_operand (type, integer_one_node, arg0);\n \t\t    }\n \n-\t\t  t = build (code, type, cval1, cval2);\n+\t\t  tem = build (code, type, cval1, cval2);\n \t\t  if (save_p)\n-\t\t    return save_expr (t);\n+\t\t    return save_expr (tem);\n \t\t  else\n-\t\t    return fold (t);\n+\t\t    return fold (tem);\n \t\t}\n \t    }\n \t}"}]}