{"sha": "c8a2ab6d0cba93c47b539695202773b276360745", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhhMmFiNmQwY2JhOTNjNDdiNTM5Njk1MjAyNzczYjI3NjM2MDc0NQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2004-06-30T15:37:42Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2004-06-30T15:37:42Z"}, "message": "Makefile.in (OBJS-common): Add tree-chrec.o.\n\n\t* Makefile.in (OBJS-common): Add tree-chrec.o.\n\t(tree-chrec.o): New rule.\n\t(GTFILES): Add tree-chrec.h.\n\t* gengtype.c (open_base_files): Add tree-chrec.h.\n\t* tree-chrec.c: New file.\n\t* tree-chrec.h: New file.\n\t* tree.def (SCEV_KNOWN, SCEV_NOT_KNOWN, POLYNOMIAL_CHREC): New nodes.\n\nFrom-SVN: r83909", "tree": {"sha": "bb724693bef34970d9612a1039ee2b0dc4f9f826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb724693bef34970d9612a1039ee2b0dc4f9f826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a2ab6d0cba93c47b539695202773b276360745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a2ab6d0cba93c47b539695202773b276360745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a2ab6d0cba93c47b539695202773b276360745", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a2ab6d0cba93c47b539695202773b276360745/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64b8935d4809f32734fa7abe9353fc159adacbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b8935d4809f32734fa7abe9353fc159adacbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b8935d4809f32734fa7abe9353fc159adacbfd"}], "stats": {"total": 1252, "additions": 1252, "deletions": 0}, "files": [{"sha": "1a1f1f3cc06246226cbdc3c1588e30c4fbdda68d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -1,3 +1,13 @@\n+2004-06-30  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* Makefile.in (OBJS-common): Add tree-chrec.o.\n+\t(tree-chrec.o): New rule.\n+\t(GTFILES): Add tree-chrec.h.\n+\t* gengtype.c (open_base_files): Add tree-chrec.h.\n+\t* tree-chrec.c: New file.\n+\t* tree-chrec.h: New file.\n+\t* tree.def (SCEV_KNOWN, SCEV_NOT_KNOWN, POLYNOMIAL_CHREC): New nodes.\n+\n 2004-06-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* combine.c: Include \"output.h\" to define dump_file."}, {"sha": "183d63332eced9f761c9aabefbba322b2e5214f9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -885,6 +885,7 @@ C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n # Language-independent object files.\n \n OBJS-common = \\\n+ tree-chrec.o                                                              \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n  tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o tree-vn.o             \\\n@@ -1699,6 +1700,8 @@ gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) errors.h tree-inline.h diagnostic.h $(HASHTAB_H) \\\n    $(TM_H) coretypes.h\n+tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   errors.h $(GGC_H) $(TREE_H) tree-chrec.h tree-pass.h\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n@@ -2339,6 +2342,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n   $(srcdir)/tree-alias-type.h $(srcdir)/tree-alias-common.h \\\n   $(srcdir)/tree-alias-type.c $(srcdir)/tree-alias-common.c \\\n+  $(srcdir)/tree-chrec.h \\\n   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n   $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n   $(out_file) \\"}, {"sha": "85e856f89fdeb51e96ce10497a264feb401f6347", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -1110,6 +1110,7 @@ open_base_files (void)\n       \"libfuncs.h\", \"debug.h\", \"ggc.h\", \"cgraph.h\",\n       \"tree-alias-type.h\", \"tree-flow.h\", \"reload.h\",\n       \"cpp-id-data.h\",\n+      \"tree-chrec.h\",\n       NULL\n     };\n     const char *const *ifp;"}, {"sha": "9146ec36b369ea70e4bf2ce2909eac7b20e84af7", "filename": "gcc/tree-chrec.c", "status": "added", "additions": 1019, "deletions": 0, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -0,0 +1,1019 @@\n+/* Chains of recurrences.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This file implements operations on chains of recurrences.  Chains\n+   of recurrences are used for modeling evolution functions of scalar\n+   variables.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"varray.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-pass.h\"\n+\n+\f\n+/* This part will be removed once the merging is finished.  */\n+\n+\n+\n+/* The following trees are unique elements.  Thus the comparison of\n+   another element to these elements should be done on the pointer to\n+   these trees, and not on their value.  */\n+\n+/* The SSA_NAMEs that are not yet analyzed are qualified with NULL_TREE.  */\n+tree chrec_not_analyzed_yet;\n+\n+/* Reserved to the cases where the analyzer has detected an\n+   undecidable property at compile time.  */\n+tree chrec_dont_know;\n+\n+/* When the analyzer has detected that a property will never\n+   happen, then it qualifies it with chrec_known.  */\n+tree chrec_known;\n+\n+/* Empty hook.  Will be replaced by the main function from\n+   tree-scalar-evolution.c.  */\n+\n+tree\n+count_ev_in_wider_type (tree foo ATTRIBUTE_UNUSED, \n+\t\t\ttree bar ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n+/* Empty hook.  Will be replaced by the main function from\n+   tree-scalar-evolution.c.  */\n+\n+bool \n+chrec_contains_symbols_defined_in_loop (tree chrec ATTRIBUTE_UNUSED, \n+\t\t\t\t\tunsigned loop_nb ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+\n+\f\n+\n+/* Extended folder for chrecs.  */\n+\n+/* Determines whether CST is not a constant evolution.  */\n+\n+static inline bool\n+is_not_constant_evolution (tree cst)\n+{\n+  return (TREE_CODE (cst) == POLYNOMIAL_CHREC);\n+}\n+\n+/* Fold CODE for a polynomial function and a constant.  */\n+\n+static inline tree \n+chrec_fold_poly_cst (enum tree_code code, \n+\t\t     tree type, \n+\t\t     tree poly, \n+\t\t     tree cst)\n+{\n+#if defined ENABLE_CHECKING\n+  if (poly == NULL_TREE\n+      || cst == NULL_TREE\n+      || TREE_CODE (poly) != POLYNOMIAL_CHREC\n+      || is_not_constant_evolution (cst))\n+    abort ();\n+#endif\n+  \n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      return build_polynomial_chrec \n+\t(CHREC_VARIABLE (poly), \n+\t chrec_fold_plus (type, CHREC_LEFT (poly), cst),\n+\t CHREC_RIGHT (poly));\n+      \n+    case MINUS_EXPR:\n+      return build_polynomial_chrec \n+\t(CHREC_VARIABLE (poly), \n+\t chrec_fold_minus (type, CHREC_LEFT (poly), cst),\n+\t CHREC_RIGHT (poly));\n+      \n+    case MULT_EXPR:\n+      return build_polynomial_chrec \n+\t(CHREC_VARIABLE (poly), \n+\t chrec_fold_multiply (type, CHREC_LEFT (poly), cst),\n+\t chrec_fold_multiply (type, CHREC_RIGHT (poly), cst));\n+      \n+    default:\n+      return chrec_dont_know;\n+    }\n+}\n+\n+/* Fold the addition of two polynomial functions.  */\n+\n+static inline tree \n+chrec_fold_plus_poly_poly (enum tree_code code, \n+\t\t\t   tree type, \n+\t\t\t   tree poly0, \n+\t\t\t   tree poly1)\n+{\n+  tree left, right;\n+  \n+#if defined ENABLE_CHECKING\n+  if (poly0 == NULL_TREE\n+      || poly1 == NULL_TREE\n+      || TREE_CODE (poly0) != POLYNOMIAL_CHREC\n+      || TREE_CODE (poly1) != POLYNOMIAL_CHREC)\n+    abort ();\n+#endif\n+  \n+  /*\n+    {a, +, b}_1 + {c, +, d}_2  ->  {{a, +, b}_1 + c, +, d}_2,\n+    {a, +, b}_2 + {c, +, d}_1  ->  {{c, +, d}_1 + a, +, b}_2,\n+    {a, +, b}_x + {c, +, d}_x  ->  {a+c, +, b+d}_x.  */\n+  if (CHREC_VARIABLE (poly0) < CHREC_VARIABLE (poly1))\n+    {\n+      if (code == PLUS_EXPR)\n+\treturn build_polynomial_chrec \n+\t  (CHREC_VARIABLE (poly1), \n+\t   chrec_fold_plus (type, poly0, CHREC_LEFT (poly1)),\n+\t   CHREC_RIGHT (poly1));\n+      else\n+\treturn build_polynomial_chrec \n+\t  (CHREC_VARIABLE (poly1), \n+\t   chrec_fold_minus (type, poly0, CHREC_LEFT (poly1)),\n+\t   chrec_fold_multiply (type, CHREC_RIGHT (poly1), \n+\t\t\t\tconvert (type, integer_minus_one_node)));\n+    }\n+  \n+  if (CHREC_VARIABLE (poly0) > CHREC_VARIABLE (poly1))\n+    {\n+      if (code == PLUS_EXPR)\n+\treturn build_polynomial_chrec \n+\t  (CHREC_VARIABLE (poly0), \n+\t   chrec_fold_plus (type, CHREC_LEFT (poly0), poly1),\n+\t   CHREC_RIGHT (poly0));\n+      else\n+\treturn build_polynomial_chrec \n+\t  (CHREC_VARIABLE (poly0), \n+\t   chrec_fold_minus (type, CHREC_LEFT (poly0), poly1),\n+\t   CHREC_RIGHT (poly0));\n+    }\n+  \n+  if (code == PLUS_EXPR)\n+    {\n+      left = chrec_fold_plus \n+\t(type, CHREC_LEFT (poly0), CHREC_LEFT (poly1));\n+      right = chrec_fold_plus \n+\t(type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1));\n+    }\n+  else\n+    {\n+      left = chrec_fold_minus \n+\t(type, CHREC_LEFT (poly0), CHREC_LEFT (poly1));\n+      right = chrec_fold_minus \n+\t(type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1));\n+    }\n+\n+  if (chrec_zerop (right))\n+    return left;\n+  else\n+    return build_polynomial_chrec \n+      (CHREC_VARIABLE (poly0), left, right); \n+}\n+\n+\f\n+\n+/* Fold the multiplication of two polynomial functions.  */\n+\n+static inline tree \n+chrec_fold_multiply_poly_poly (tree type, \n+\t\t\t       tree poly0, \n+\t\t\t       tree poly1)\n+{\n+#if defined ENABLE_CHECKING\n+  if (poly0 == NULL_TREE\n+      || poly1 == NULL_TREE\n+      || TREE_CODE (poly0) != POLYNOMIAL_CHREC\n+      || TREE_CODE (poly1) != POLYNOMIAL_CHREC)\n+    abort ();\n+#endif\n+  \n+  /* {a, +, b}_1 * {c, +, d}_2  ->  {c*{a, +, b}_1, +, d}_2,\n+     {a, +, b}_2 * {c, +, d}_1  ->  {a*{c, +, d}_1, +, b}_2,\n+     {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */\n+  if (CHREC_VARIABLE (poly0) < CHREC_VARIABLE (poly1))\n+    /* poly0 is a constant wrt. poly1.  */\n+    return build_polynomial_chrec \n+      (CHREC_VARIABLE (poly1), \n+       chrec_fold_multiply (type, CHREC_LEFT (poly1), poly0),\n+       CHREC_RIGHT (poly1));\n+  \n+  if (CHREC_VARIABLE (poly1) < CHREC_VARIABLE (poly0))\n+    /* poly1 is a constant wrt. poly0.  */\n+    return build_polynomial_chrec \n+      (CHREC_VARIABLE (poly0), \n+       chrec_fold_multiply (type, CHREC_LEFT (poly0), poly1),\n+       CHREC_RIGHT (poly0));\n+  \n+  /* poly0 and poly1 are two polynomials in the same variable,\n+     {a, +, b}_x * {c, +, d}_x  ->  {a*c, +, a*d + b*c + b*d, +, 2*b*d}_x.  */\n+  return \n+    build_polynomial_chrec \n+    (CHREC_VARIABLE (poly0), \n+     build_polynomial_chrec \n+     (CHREC_VARIABLE (poly0), \n+      \n+      /* \"a*c\".  */\n+      chrec_fold_multiply (type, CHREC_LEFT (poly0), CHREC_LEFT (poly1)),\n+      \n+      /* \"a*d + b*c + b*d\".  */\n+      chrec_fold_plus \n+      (type, chrec_fold_multiply (type, CHREC_LEFT (poly0), CHREC_RIGHT (poly1)),\n+       \n+       chrec_fold_plus \n+       (type, \n+\tchrec_fold_multiply (type, CHREC_RIGHT (poly0), CHREC_LEFT (poly1)),\n+\tchrec_fold_multiply (type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1))))),\n+     \n+     /* \"2*b*d\".  */\n+     chrec_fold_multiply\n+     (type, build_int_2 (2, 0),\n+      chrec_fold_multiply (type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1))));\n+}\n+\n+/* When the operands are automatically_generated_chrec_p, the fold has\n+   to respect the semantics of the operands.  */\n+\n+static inline tree \n+chrec_fold_automatically_generated_operands (tree op0, \n+\t\t\t\t\t     tree op1)\n+{\n+  if (op0 == chrec_dont_know\n+      || op1 == chrec_dont_know)\n+    return chrec_dont_know;\n+  \n+  if (op0 == chrec_known\n+      || op1 == chrec_known)\n+    return chrec_known;\n+  \n+  if (op0 == chrec_not_analyzed_yet\n+      || op1 == chrec_not_analyzed_yet)\n+    return chrec_not_analyzed_yet;\n+  \n+  /* The default case produces a safe result. */\n+  return chrec_dont_know;\n+}\n+\n+/* Fold the addition of two chrecs.  */\n+\n+static tree\n+chrec_fold_plus_1 (enum tree_code code, \n+\t\t   tree type, \n+\t\t   tree op0,\n+\t\t   tree op1)\n+{\n+  if (automatically_generated_chrec_p (op0)\n+      || automatically_generated_chrec_p (op1))\n+    return chrec_fold_automatically_generated_operands (op0, op1);\n+  \n+  switch (TREE_CODE (op0))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      switch (TREE_CODE (op1))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  return chrec_fold_plus_poly_poly (code, type, op0, op1);\n+\n+\tdefault:\n+\t  if (code == PLUS_EXPR)\n+\t    return build_polynomial_chrec \n+\t      (CHREC_VARIABLE (op0), \n+\t       chrec_fold_plus (type, CHREC_LEFT (op0), op1),\n+\t       CHREC_RIGHT (op0));\n+\t  else\n+\t    return build_polynomial_chrec \n+\t      (CHREC_VARIABLE (op0), \n+\t       chrec_fold_minus (type, CHREC_LEFT (op0), op1),\n+\t       CHREC_RIGHT (op0));\n+\t}\n+\n+    default:\n+      switch (TREE_CODE (op1))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  if (code == PLUS_EXPR)\n+\t    return build_polynomial_chrec \n+\t      (CHREC_VARIABLE (op1), \n+\t       chrec_fold_plus (type, op0, CHREC_LEFT (op1)),\n+\t       CHREC_RIGHT (op1));\n+\t  else\n+\t    return build_polynomial_chrec \n+\t      (CHREC_VARIABLE (op1), \n+\t       chrec_fold_minus (type, op0, CHREC_LEFT (op1)),\n+\t       chrec_fold_multiply (type, CHREC_RIGHT (op1), \n+\t\t\t\t    convert (type,\n+\t\t\t\t\t     integer_minus_one_node)));\n+\n+\tdefault:\n+\t  if (tree_contains_chrecs (op0)\n+\t      || tree_contains_chrecs (op1))\n+\t    return build (code, type, op0, op1);\n+\t  else\n+\t    return fold (build (code, type, op0, op1));\n+\t}\n+    }\n+}\n+\n+/* Fold the addition of two chrecs.  */\n+\n+tree\n+chrec_fold_plus (tree type, \n+\t\t tree op0,\n+\t\t tree op1)\n+{\n+  if (integer_zerop (op0))\n+    return op1;\n+  if (integer_zerop (op1))\n+    return op0;\n+  \n+  return chrec_fold_plus_1 (PLUS_EXPR, type, op0, op1);\n+}\n+\n+/* Fold the subtraction of two chrecs.  */\n+\n+tree \n+chrec_fold_minus (tree type, \n+\t\t  tree op0, \n+\t\t  tree op1)\n+{\n+  if (integer_zerop (op1))\n+    return op0;\n+  \n+  return chrec_fold_plus_1 (MINUS_EXPR, type, op0, op1);\n+}\n+\n+/* Fold the multiplication of two chrecs.  */\n+\n+tree\n+chrec_fold_multiply (tree type, \n+\t\t     tree op0,\n+\t\t     tree op1)\n+{\n+  if (automatically_generated_chrec_p (op0)\n+      || automatically_generated_chrec_p (op1))\n+    return chrec_fold_automatically_generated_operands (op0, op1);\n+  \n+  switch (TREE_CODE (op0))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      switch (TREE_CODE (op1))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  return chrec_fold_multiply_poly_poly (type, op0, op1);\n+\t  \n+\tdefault:\n+\t  if (integer_onep (op1))\n+\t    return op0;\n+\t  if (integer_zerop (op1))\n+\t    return convert (type, integer_zero_node);\n+\t  \n+\t  return build_polynomial_chrec \n+\t    (CHREC_VARIABLE (op0), \n+\t     chrec_fold_multiply (type, CHREC_LEFT (op0), op1),\n+\t     chrec_fold_multiply (type, CHREC_RIGHT (op0), op1));\n+\t}\n+      \n+    default:\n+      if (integer_onep (op0))\n+\treturn op1;\n+      \n+      if (integer_zerop (op0))\n+\treturn convert (type, integer_zero_node);\n+      \n+      switch (TREE_CODE (op1))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  return build_polynomial_chrec \n+\t    (CHREC_VARIABLE (op1), \n+\t     chrec_fold_multiply (type, CHREC_LEFT (op1), op0),\n+\t     chrec_fold_multiply (type, CHREC_RIGHT (op1), op0));\n+\t  \n+\tdefault:\n+\t  if (integer_onep (op1))\n+\t    return op0;\n+\t  if (integer_zerop (op1))\n+\t    return convert (type, integer_zero_node);\n+\t  return fold (build (MULT_EXPR, type, op0, op1));\n+\t}\n+    }\n+}\n+\n+\f\n+\n+/* Operations.  */\n+\n+/* The factorial.  */\n+ \n+static tree \n+tree_fold_factorial (tree f)\n+{\n+  if (tree_int_cst_sgn (f) <= 0)\n+    return integer_one_node;\n+  else\n+    return fold \n+      (build (MULT_EXPR, integer_type_node, f, \n+\t      tree_fold_factorial (fold (build (MINUS_EXPR, integer_type_node, \n+\t\t\t\t\t\tf, integer_one_node)))));\n+}\n+\n+/* The binomial coefficient.  */\n+\n+static tree \n+tree_fold_binomial (tree n,\n+\t\t    tree k)\n+{\n+  return fold \n+    (build (EXACT_DIV_EXPR, integer_type_node, tree_fold_factorial (n), \n+\t    fold (build (MULT_EXPR, integer_type_node, \n+\t\t\t tree_fold_factorial (k),\n+\t\t\t tree_fold_factorial \n+\t\t\t (fold (build (MINUS_EXPR, integer_type_node, \n+\t\t\t\t       n, k)))))));\n+}\n+\n+/* Helper function.  Use the Newton's interpolating formula for\n+   evaluating the value of the evolution function.  */\n+\n+static tree \n+chrec_evaluate (unsigned var,\n+\t\ttree chrec,\n+\t\ttree n,\n+\t\ttree k)\n+{\n+  tree type = chrec_type (chrec);\n+  tree binomial_n_k = tree_fold_binomial (n, k);\n+  \n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    {\n+      if (CHREC_VARIABLE (chrec) > var)\n+\treturn chrec_evaluate (var, CHREC_LEFT (chrec), n, k);\n+      \n+      if (CHREC_VARIABLE (chrec) == var)\n+\treturn chrec_fold_plus \n+\t  (type, \n+\t   fold (build (MULT_EXPR, type, binomial_n_k, CHREC_LEFT (chrec))),\n+\t   chrec_evaluate (var, CHREC_RIGHT (chrec), n, \n+\t\t\t   fold (build (PLUS_EXPR, type, k, integer_one_node))));\n+      \n+      return fold (build (MULT_EXPR, type, binomial_n_k, chrec));\n+    }\n+  else\n+    return fold (build (MULT_EXPR, type, binomial_n_k, chrec));\n+}\n+\n+/* Evaluates \"CHREC (X)\" when the varying variable is VAR.  \n+   Example:  Given the following parameters, \n+   \n+   var = 1\n+   chrec = {3, +, 4}_1\n+   x = 10\n+   \n+   The result is given by the Newton's interpolating formula: \n+   3 * \\binom{10}{0} + 4 * \\binom{10}{1}.\n+*/\n+\n+tree \n+chrec_apply (unsigned var,\n+\t     tree chrec, \n+\t     tree x)\n+{\n+  tree type = chrec_type (chrec);\n+  tree res = chrec_dont_know;\n+\n+  if (automatically_generated_chrec_p (chrec)\n+      || automatically_generated_chrec_p (x)\n+\n+      /* When the symbols are defined in an outer loop, it is possible\n+\t to symbolically compute the apply, since the symbols are\n+\t constants with respect to the varying loop.  */\n+      || chrec_contains_symbols_defined_in_loop (chrec, var)\n+      || chrec_contains_symbols (x))\n+    return chrec_dont_know;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(chrec_apply \\n\");\n+\n+  if (evolution_function_is_affine_p (chrec))\n+    {\n+      /* \"{a, +, b} (x)\"  ->  \"a + b*x\".  */\n+      if (TREE_CODE (CHREC_LEFT (chrec)) == INTEGER_CST\n+\t  && integer_zerop (CHREC_LEFT (chrec)))\n+\tres = chrec_fold_multiply (type, CHREC_RIGHT (chrec), x);\n+      \n+      else\n+\tres = chrec_fold_plus (type, CHREC_LEFT (chrec), \n+\t\t\t       chrec_fold_multiply (type, \n+\t\t\t\t\t\t    CHREC_RIGHT (chrec), x));\n+    }\n+  \n+  else if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n+    res = chrec;\n+  \n+  else if (TREE_CODE (x) == INTEGER_CST\n+\t   && tree_int_cst_sgn (x) == 1)\n+    /* testsuite/.../ssa-chrec-38.c.  */\n+    res = chrec_evaluate (var, chrec, x, integer_zero_node);\n+\n+  else\n+    res = chrec_dont_know;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (varying_loop = %d\\n\", var);\n+      fprintf (dump_file, \")\\n  (chrec = \");\n+      print_generic_expr (dump_file, chrec, 0);\n+      fprintf (dump_file, \")\\n  (x = \");\n+      print_generic_expr (dump_file, x, 0);\n+      fprintf (dump_file, \")\\n  (res = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  return res;\n+}\n+\n+/* Replaces the initial condition in CHREC with INIT_COND.  */\n+\n+tree \n+chrec_replace_initial_condition (tree chrec, \n+\t\t\t\t tree init_cond)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return chrec;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      return build_polynomial_chrec \n+\t(CHREC_VARIABLE (chrec),\n+\t chrec_replace_initial_condition (CHREC_LEFT (chrec), init_cond),\n+\t CHREC_RIGHT (chrec));\n+      \n+    default:\n+      return init_cond;\n+    }\n+}\n+\n+/* Returns the initial condition of a given CHREC.  */\n+\n+tree \n+initial_condition (tree chrec)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return chrec;\n+  \n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    return initial_condition (CHREC_LEFT (chrec));\n+  else\n+    return chrec;\n+}\n+\n+/* Returns a univariate function that represents the evolution in\n+   LOOP_NUM.  Mask the evolution of any other loop.  */\n+\n+tree \n+hide_evolution_in_other_loops_than_loop (tree chrec, \n+\t\t\t\t\t unsigned loop_num)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return chrec;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (CHREC_VARIABLE (chrec) == loop_num)\n+\treturn build_polynomial_chrec \n+\t  (loop_num, \n+\t   hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec), \n+\t\t\t\t\t\t    loop_num), \n+\t   CHREC_RIGHT (chrec));\n+      \n+      else if (CHREC_VARIABLE (chrec) < loop_num)\n+\t/* There is no evolution in this loop.  */\n+\treturn initial_condition (chrec);\n+      \n+      else\n+\treturn hide_evolution_in_other_loops_than_loop (CHREC_LEFT (chrec), \n+\t\t\t\t\t\t\tloop_num);\n+      \n+    default:\n+      return chrec;\n+    }\n+}\n+\n+/* Returns the evolution part in LOOP_NUM.  Example: the call\n+   get_evolution_in_loop (1, {{0, +, 1}_1, +, 2}_1) returns \n+   {1, +, 2}_1  */\n+\n+tree \n+evolution_part_in_loop_num (tree chrec, \n+\t\t\t    unsigned loop_num)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return chrec;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (CHREC_VARIABLE (chrec) == loop_num)\n+\t{\n+\t  if (TREE_CODE (CHREC_LEFT (chrec)) != POLYNOMIAL_CHREC\n+\t      || CHREC_VARIABLE (CHREC_LEFT (chrec)) != CHREC_VARIABLE (chrec))\n+\t    return CHREC_RIGHT (chrec);\n+\t  \n+\t  else\n+\t    return build_polynomial_chrec\n+\t      (loop_num, \n+\t       evolution_part_in_loop_num (CHREC_LEFT (chrec), loop_num), \n+\t       CHREC_RIGHT (chrec));\n+\t}\n+      \n+      else if (CHREC_VARIABLE (chrec) < loop_num)\n+\t/* There is no evolution part in this loop.  */\n+\treturn NULL_TREE;\n+      \n+      else\n+\treturn evolution_part_in_loop_num (CHREC_LEFT (chrec), loop_num);\n+      \n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Set or reset the evolution of CHREC to NEW_EVOL in loop LOOP_NUM.\n+   This function is essentially used for setting the evolution to\n+   chrec_dont_know, for example after having determined that it is\n+   impossible to say how many times a loop will execute.  */\n+\n+tree \n+reset_evolution_in_loop (unsigned loop_num,\n+\t\t\t tree chrec, \n+\t\t\t tree new_evol)\n+{\n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n+      && CHREC_VARIABLE (chrec) > loop_num)\n+    return build \n+      (TREE_CODE (chrec), \n+       build_int_2 (CHREC_VARIABLE (chrec), 0), \n+       reset_evolution_in_loop (loop_num, CHREC_LEFT (chrec), new_evol), \n+       reset_evolution_in_loop (loop_num, CHREC_RIGHT (chrec), new_evol));\n+  \n+  while (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n+\t && CHREC_VARIABLE (chrec) == loop_num)\n+    chrec = CHREC_LEFT (chrec);\n+  \n+  return build_polynomial_chrec (loop_num, chrec, new_evol);\n+}\n+\n+/* Merges two evolution functions that were found by following two\n+   alternate paths of a conditional expression.  */\n+\n+tree\n+chrec_merge (tree chrec1, \n+\t     tree chrec2)\n+{\n+  if (chrec1 == chrec_dont_know\n+      || chrec2 == chrec_dont_know)\n+    return chrec_dont_know;\n+\n+  if (chrec1 == chrec_known \n+      || chrec2 == chrec_known)\n+    return chrec_known;\n+\n+  if (chrec1 == chrec_not_analyzed_yet)\n+    return chrec2;\n+  if (chrec2 == chrec_not_analyzed_yet)\n+    return chrec1;\n+\n+  if (operand_equal_p (chrec1, chrec2, 0))\n+    return chrec1;\n+\n+  return chrec_dont_know;\n+}\n+\n+\f\n+\n+/* Observers.  */\n+\n+/* Helper function for is_multivariate_chrec.  */\n+\n+static bool \n+is_multivariate_chrec_rec (tree chrec, unsigned int rec_var)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    {\n+      if (CHREC_VARIABLE (chrec) != rec_var)\n+\treturn true;\n+      else\n+\treturn (is_multivariate_chrec_rec (CHREC_LEFT (chrec), rec_var) \n+\t\t|| is_multivariate_chrec_rec (CHREC_RIGHT (chrec), rec_var));\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Determine whether the given chrec is multivariate or not.  */\n+\n+bool \n+is_multivariate_chrec (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    return (is_multivariate_chrec_rec (CHREC_LEFT (chrec), \n+\t\t\t\t       CHREC_VARIABLE (chrec))\n+\t    || is_multivariate_chrec_rec (CHREC_RIGHT (chrec), \n+\t\t\t\t\t  CHREC_VARIABLE (chrec)));\n+  else\n+    return false;\n+}\n+\n+/* Determines whether the chrec contains symbolic names or not.  */\n+\n+bool \n+chrec_contains_symbols (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  if (TREE_CODE (chrec) == SSA_NAME\n+      || TREE_CODE (chrec) == VAR_DECL\n+      || TREE_CODE (chrec) == PARM_DECL\n+      || TREE_CODE (chrec) == FUNCTION_DECL\n+      || TREE_CODE (chrec) == LABEL_DECL\n+      || TREE_CODE (chrec) == RESULT_DECL\n+      || TREE_CODE (chrec) == FIELD_DECL)\n+    return true;\n+  \n+  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+    {\n+    case 3:\n+      if (chrec_contains_symbols (TREE_OPERAND (chrec, 2)))\n+\treturn true;\n+      \n+    case 2:\n+      if (chrec_contains_symbols (TREE_OPERAND (chrec, 1)))\n+\treturn true;\n+      \n+    case 1:\n+      if (chrec_contains_symbols (TREE_OPERAND (chrec, 0)))\n+\treturn true;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determines whether the chrec contains undetermined coefficients.  */\n+\n+bool \n+chrec_contains_undetermined (tree chrec)\n+{\n+  if (chrec == chrec_dont_know\n+      || chrec == chrec_not_analyzed_yet\n+      || chrec == NULL_TREE)\n+    return true;\n+  \n+  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+    {\n+    case 3:\n+      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 2)))\n+\treturn true;\n+      \n+    case 2:\n+      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 1)))\n+\treturn true;\n+      \n+    case 1:\n+      if (chrec_contains_undetermined (TREE_OPERAND (chrec, 0)))\n+\treturn true;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determines whether the tree EXPR contains chrecs.  */\n+\n+bool\n+tree_contains_chrecs (tree expr)\n+{\n+  if (expr == NULL_TREE)\n+    return false;\n+  \n+  if (tree_is_chrec (expr))\n+    return true;\n+  \n+  switch (TREE_CODE_LENGTH (TREE_CODE (expr)))\n+    {\n+    case 3:\n+      if (tree_contains_chrecs (TREE_OPERAND (expr, 2)))\n+\treturn true;\n+      \n+    case 2:\n+      if (tree_contains_chrecs (TREE_OPERAND (expr, 1)))\n+\treturn true;\n+      \n+    case 1:\n+      if (tree_contains_chrecs (TREE_OPERAND (expr, 0)))\n+\treturn true;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determine whether the given tree is an affine multivariate\n+   evolution.  */\n+\n+bool \n+evolution_function_is_affine_multivariate_p (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (evolution_function_is_constant_p (CHREC_LEFT (chrec)))\n+\t{\n+\t  if (evolution_function_is_constant_p (CHREC_RIGHT (chrec)))\n+\t    return true;\n+\t  else\n+\t    {\n+\t      if (TREE_CODE (CHREC_RIGHT (chrec)) == POLYNOMIAL_CHREC\n+\t\t  && CHREC_VARIABLE (CHREC_RIGHT (chrec)) \n+\t\t     != CHREC_VARIABLE (chrec)\n+\t\t  && evolution_function_is_affine_multivariate_p \n+\t\t  (CHREC_RIGHT (chrec)))\n+\t\treturn true;\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (evolution_function_is_constant_p (CHREC_RIGHT (chrec))\n+\t      && TREE_CODE (CHREC_LEFT (chrec)) == POLYNOMIAL_CHREC\n+\t      && CHREC_VARIABLE (CHREC_LEFT (chrec)) != CHREC_VARIABLE (chrec)\n+\t      && evolution_function_is_affine_multivariate_p \n+\t      (CHREC_LEFT (chrec)))\n+\t    return true;\n+\t  else\n+\t    return false;\n+\t}\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determine whether the given tree is a function in zero or one \n+   variables.  */\n+\n+bool\n+evolution_function_is_univariate_p (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return true;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      switch (TREE_CODE (CHREC_LEFT (chrec)))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  if (CHREC_VARIABLE (chrec) != CHREC_VARIABLE (CHREC_LEFT (chrec)))\n+\t    return false;\n+\t  if (!evolution_function_is_univariate_p (CHREC_LEFT (chrec)))\n+\t    return false;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  break;\n+\t}\n+      \n+      switch (TREE_CODE (CHREC_RIGHT (chrec)))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  if (CHREC_VARIABLE (chrec) != CHREC_VARIABLE (CHREC_RIGHT (chrec)))\n+\t    return false;\n+\t  if (!evolution_function_is_univariate_p (CHREC_RIGHT (chrec)))\n+\t    return false;\n+\t  break;\n+\t  \n+\tdefault:\n+\t  break;\t  \n+\t}\n+      \n+    default:\n+      return true;\n+    }\n+}\n+\n+\f\n+\n+/* Convert the initial condition of chrec to type.  */\n+\n+tree \n+chrec_convert (tree type, \n+\t       tree chrec)\n+{\n+  tree ct;\n+  \n+  if (automatically_generated_chrec_p (chrec))\n+    return chrec;\n+  \n+  ct = chrec_type (chrec);\n+  if (ct == type)\n+    return chrec;\n+\n+  if (TYPE_PRECISION (ct) < TYPE_PRECISION (type))\n+    return count_ev_in_wider_type (type, chrec);\n+\n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      return build_polynomial_chrec (CHREC_VARIABLE (chrec),\n+\t\t\t\t     chrec_convert (type,\n+\t\t\t\t\t\t    CHREC_LEFT (chrec)),\n+\t\t\t\t     chrec_convert (type,\n+\t\t\t\t\t\t    CHREC_RIGHT (chrec)));\n+\n+    default:\n+      {\n+\ttree res = convert (type, chrec);\n+\n+\t/* Don't propagate overflows.  */\n+\tTREE_OVERFLOW (res) = 0;\n+\tif (TREE_CODE_CLASS (TREE_CODE (res)) == 'c')\n+\t  TREE_CONSTANT_OVERFLOW (res) = 0;\n+\treturn res;\n+      }\n+    }\n+}\n+\n+/* Returns the type of the chrec.  */\n+\n+tree \n+chrec_type (tree chrec)\n+{\n+  if (automatically_generated_chrec_p (chrec))\n+    return NULL_TREE;\n+  \n+  return TREE_TYPE (chrec);\n+}\n+\n+extern void initialize_scalar_evolutions_analyzer (void);\n+\n+/* Initializer.  */\n+\n+void\n+initialize_scalar_evolutions_analyzer (void)\n+{\n+  /* The elements below are unique.  */\n+  if (chrec_dont_know == NULL_TREE)\n+    {\n+      chrec_not_analyzed_yet = NULL_TREE;\n+      chrec_dont_know = make_node (SCEV_NOT_KNOWN);\n+      chrec_known = make_node (SCEV_KNOWN);\n+      TREE_TYPE (chrec_dont_know) = NULL_TREE;\n+      TREE_TYPE (chrec_known) = NULL_TREE;\n+    }\n+}"}, {"sha": "8e355f0ac35eefc7ce05ee73595e033acad4c9ff", "filename": "gcc/tree-chrec.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -0,0 +1,206 @@\n+/* Chains of recurrences.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_TREE_CHREC_H\n+#define GCC_TREE_CHREC_H\n+\n+/* Accessors for the chains of recurrences.  */\n+#define CHREC_VAR(NODE)           TREE_OPERAND (NODE, 0)\n+#define CHREC_LEFT(NODE)          TREE_OPERAND (NODE, 1)\n+#define CHREC_RIGHT(NODE)         TREE_OPERAND (NODE, 2)\n+#define CHREC_VARIABLE(NODE)      TREE_INT_CST_LOW (CHREC_VAR (NODE))\n+\n+\f\n+\n+/* The following trees are unique elements.  Thus the comparison of another \n+   element to these elements should be done on the pointer to these trees, \n+   and not on their value.  */\n+\n+extern tree chrec_not_analyzed_yet;\n+extern GTY(()) tree chrec_dont_know;\n+extern GTY(()) tree chrec_known;\n+\n+/* After having added an automatically generated element, please\n+   include it in the following function.  */\n+\n+static inline bool\n+automatically_generated_chrec_p (tree chrec)\n+{\n+  return (chrec == chrec_not_analyzed_yet \n+\t  || chrec == chrec_dont_know\n+\t  || chrec == chrec_known);\n+}\n+\n+/* The tree nodes aka. CHRECs.  */\n+\n+static inline bool\n+tree_is_chrec (tree expr)\n+{\n+  if (TREE_CODE (expr) == POLYNOMIAL_CHREC\n+      || automatically_generated_chrec_p (expr))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+\f\n+\n+/* Chrec folding functions.  */\n+extern tree chrec_fold_plus (tree, tree, tree);\n+extern tree chrec_fold_minus (tree, tree, tree);\n+extern tree chrec_fold_multiply (tree, tree, tree);\n+extern tree chrec_convert (tree, tree);\n+extern tree count_ev_in_wider_type (tree, tree);\n+extern tree chrec_type (tree);\n+\n+/* Operations.  */\n+extern tree chrec_apply (unsigned, tree, tree);\n+extern tree chrec_replace_initial_condition (tree, tree);\n+extern tree update_initial_condition_to_origin (tree);\n+extern tree initial_condition (tree);\n+extern tree evolution_part_in_loop_num (tree, unsigned);\n+extern tree hide_evolution_in_other_loops_than_loop (tree, unsigned);\n+extern tree reset_evolution_in_loop (unsigned, tree, tree);\n+extern tree chrec_merge (tree, tree);\n+\n+/* Observers.  */\n+extern bool is_multivariate_chrec (tree);\n+extern bool chrec_is_positive (tree, bool *);\n+extern bool chrec_contains_symbols (tree);\n+extern bool chrec_contains_symbols_defined_in_loop (tree, unsigned);\n+extern bool chrec_contains_undetermined (tree);\n+extern bool tree_contains_chrecs (tree);\n+extern bool evolution_function_is_affine_multivariate_p (tree);\n+extern bool evolution_function_is_univariate_p (tree);\n+\n+\f\n+\n+/* Build a polynomial chain of recurrence.  */\n+\n+static inline tree \n+build_polynomial_chrec (unsigned loop_num, \n+\t\t\ttree left, \n+\t\t\ttree right)\n+{\n+  if (left == chrec_dont_know\n+      || right == chrec_dont_know)\n+    return chrec_dont_know;\n+\n+  return build (POLYNOMIAL_CHREC, TREE_TYPE (left), \n+\t\tbuild_int_2 (loop_num, 0), left, right);\n+}\n+\n+\f\n+\n+/* Observers.  */\n+\n+/* Determines whether CHREC is equal to zero.  */\n+\n+static inline bool \n+chrec_zerop (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  if (TREE_CODE (chrec) == INTEGER_CST)\n+    return integer_zerop (chrec);\n+  \n+  return false;\n+}\n+\n+/* Determines whether the expression CHREC is a constant.  */\n+\n+static inline bool \n+evolution_function_is_constant_p (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+\n+  switch (TREE_CODE (chrec))\n+    {\n+    case INTEGER_CST:\n+    case REAL_CST:\n+      return true;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determine whether the given tree is an affine evolution function or not.  */\n+\n+static inline bool \n+evolution_function_is_affine_p (tree chrec)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (evolution_function_is_constant_p (CHREC_LEFT (chrec))\n+\t  && evolution_function_is_constant_p (CHREC_RIGHT (chrec)))\n+\treturn true;\n+      else\n+\treturn false;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Determine whether the given tree is an affine or constant evolution\n+   function.  */\n+\n+static inline bool \n+evolution_function_is_affine_or_constant_p (tree chrec)\n+{\n+  return evolution_function_is_affine_p (chrec) \n+    || evolution_function_is_constant_p (chrec);\n+}\n+\n+/* Determines whether EXPR does not contains chrec expressions.  */\n+\n+static inline bool\n+tree_does_not_contain_chrecs (tree expr)\n+{\n+  return !tree_contains_chrecs (expr);\n+}\n+\n+/* Determines whether CHREC is a loop invariant with respect to LOOP_NUM.  \n+   Set the result in RES and return true when the property can be computed.  */\n+\n+static inline bool\n+no_evolution_in_loop_p (tree chrec, unsigned loop_num, bool *res)\n+{\n+  tree scev;\n+  \n+  if (chrec == chrec_not_analyzed_yet\n+      || chrec == chrec_dont_know\n+      || chrec_contains_symbols_defined_in_loop (chrec, loop_num))\n+    return false;\n+\n+  scev = hide_evolution_in_other_loops_than_loop (chrec, loop_num);\n+  *res = !tree_is_chrec (scev);\n+  return true;\n+}\n+\n+#endif  /* GCC_TREE_CHREC_H  */"}, {"sha": "15172077bdc367ebc2da993aef5bb6370afa4fa0", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a2ab6d0cba93c47b539695202773b276360745/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=c8a2ab6d0cba93c47b539695202773b276360745", "patch": "@@ -898,6 +898,18 @@ DEFTREECODE (CATCH_EXPR, \"catch_expr\", 's', 2)\n    expanding.  */\n DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", 's', 2)\n \n+/* Node used for describing a property that is known at compile\n+   time.  */\n+DEFTREECODE (SCEV_KNOWN, \"scev_known\", 'e', 0)\n+\n+/* Node used for describing a property that is not known at compile\n+   time.  */\n+DEFTREECODE (SCEV_NOT_KNOWN, \"scev_not_known\", 'e', 0)\n+\n+/* Polynomial chains of recurrences.\n+   Under the form: cr = {CHREC_LEFT (cr), +, CHREC_RIGHT (cr)}.  */\n+DEFTREECODE (POLYNOMIAL_CHREC, \"polynomial_chrec\", 'e', 3)\n+\n /* Used to chain children of container statements together.\n    Use the interface in tree-iterator.h to access this node.  */\n DEFTREECODE (STATEMENT_LIST, \"statement_list\", 'x', 0)"}]}