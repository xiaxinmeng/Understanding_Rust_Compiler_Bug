{"sha": "52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmYTgwZjg1M2MwYjBmNjIzZWE5ZTRjNzE5OGUzMjRjZTQ0ZmYzMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-04-06T21:04:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-04-06T23:37:24Z"}, "message": "libgo: update to almost the 1.14.2 release\n\nUpdate to edea4a79e8d7dea2456b688f492c8af33d381dc2 which is likely to\nbe approximately the 1.14.2 release.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/227377", "tree": {"sha": "e2695726e95b7bd125d52b7bdd315cb0028854fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2695726e95b7bd125d52b7bdd315cb0028854fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749bd22ddc50b5112e5ed506ffef7249bf8e6fb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749bd22ddc50b5112e5ed506ffef7249bf8e6fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749bd22ddc50b5112e5ed506ffef7249bf8e6fb3"}], "stats": {"total": 1026, "additions": 742, "deletions": 284}, "files": [{"sha": "c5e8b29879eb8dc987324d9a14bdfcabbbc5029e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1,4 +1,4 @@\n-7a62a49e62c090118fa003d9265c5f5e2090c4f9\n+4a31d064fd6996f64b620104e849292af8f25e12\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4398cd7dc28972870d1857490c97aa5f04b81dfa", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1,4 +1,4 @@\n-20a838ab94178c55bc4dc23ddc332fce8545a493\n+edea4a79e8d7dea2456b688f492c8af33d381dc2\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "864916ef4996134e87bb7be0070c1da86fd0dece", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1 +1 @@\n-go1.14\n+go1.14.2"}, {"sha": "310316bdda495196c02ba9fa174d336606fe4806", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -2265,7 +2265,7 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t\t// Translate to zero-length array instead.\n \t\t\tcount = 0\n \t\t}\n-\t\tsub := c.loadType(dt.Type, pos, key)\n+\t\tsub := c.Type(dt.Type, pos)\n \t\tt.Align = sub.Align\n \t\tt.Go = &ast.ArrayType{\n \t\t\tLen: c.intExpr(count),\n@@ -2410,7 +2410,7 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\tc.ptrs[key] = append(c.ptrs[key], t)\n \n \tcase *dwarf.QualType:\n-\t\tt1 := c.loadType(dt.Type, pos, key)\n+\t\tt1 := c.Type(dt.Type, pos)\n \t\tt.Size = t1.Size\n \t\tt.Align = t1.Align\n \t\tt.Go = t1.Go\n@@ -2494,7 +2494,13 @@ func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Typ\n \t\t}\n \t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n \t\tgoIdent[name.Name] = name\n-\t\tsub := c.loadType(dt.Type, pos, key)\n+\t\takey := \"\"\n+\t\tif c.anonymousStructTypedef(dt) {\n+\t\t\t// only load type recursively for typedefs of anonymous\n+\t\t\t// structs, see issues 37479 and 37621.\n+\t\t\takey = key\n+\t\t}\n+\t\tsub := c.loadType(dt.Type, pos, akey)\n \t\tif c.badPointerTypedef(dt) {\n \t\t\t// Treat this typedef as a uintptr.\n \t\t\ts := *sub\n@@ -3015,6 +3021,13 @@ func fieldPrefix(fld []*ast.Field) string {\n \treturn prefix\n }\n \n+// anonymousStructTypedef reports whether dt is a C typedef for an anonymous\n+// struct.\n+func (c *typeConv) anonymousStructTypedef(dt *dwarf.TypedefType) bool {\n+\tst, ok := dt.Type.(*dwarf.StructType)\n+\treturn ok && st.StructName == \"\"\n+}\n+\n // badPointerTypedef reports whether t is a C typedef that should not be considered a pointer in Go.\n // A typedef is bad if C code sometimes stores non-pointers in this type.\n // TODO: Currently our best solution is to find these manually and list them as"}, {"sha": "315db69de8a56b2fb522a39dfd408a61009192f4", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -22,6 +22,7 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n )\n \n@@ -438,7 +439,7 @@ func (g *Generator) exec(words []string) {\n \tcmd.Stderr = os.Stderr\n \t// Run the command in the package directory.\n \tcmd.Dir = g.dir\n-\tcmd.Env = append(cfg.OrigEnv, g.env...)\n+\tcmd.Env = str.StringList(cfg.OrigEnv, g.env)\n \terr := cmd.Run()\n \tif err != nil {\n \t\tg.errorf(\"running %q: %s\", words[0], err)"}, {"sha": "4ad142ccd874886d2acf0cc0272164f408dfa789", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1142,7 +1142,7 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \n \tcmd := exec.Command(args[0], args[1:]...)\n \tcmd.Dir = a.Package.Dir\n-\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv)\n+\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv[:len(cfg.OrigEnv):len(cfg.OrigEnv)])\n \tcmd.Stdout = stdout\n \tcmd.Stderr = stdout\n \n@@ -1224,6 +1224,14 @@ func (c *runCache) builderRunTest(b *work.Builder, a *work.Action) error {\n \t\tif len(out) == 0 {\n \t\t\tfmt.Fprintf(cmd.Stdout, \"%s\\n\", err)\n \t\t}\n+\t\t// NOTE(golang.org/issue/37555): test2json reports that a test passes\n+\t\t// unless \"FAIL\" is printed at the beginning of a line. The test may not\n+\t\t// actually print that if it panics, exits, or terminates abnormally,\n+\t\t// so we print it here. We can't always check whether it was printed\n+\t\t// because some tests need stdout to be a terminal (golang.org/issue/34791),\n+\t\t// not a pipe.\n+\t\t// TODO(golang.org/issue/29062): tests that exit with status 0 without\n+\t\t// printing a final result should fail.\n \t\tfmt.Fprintf(cmd.Stdout, \"FAIL\\t%s\\t%s\\n\", a.Package.ImportPath, t)\n \t}\n "}, {"sha": "764291b0584e8178d811ca69e3cdbfb2cf60236c", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -213,6 +213,9 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t} else if cfg.BuildTrimpath && p.Module != nil {\n \t\tfmt.Fprintf(h, \"module %s@%s\\n\", p.Module.Path, p.Module.Version)\n \t}\n+\tif p.Module != nil {\n+\t\tfmt.Fprintf(h, \"go %s\\n\", p.Module.GoVersion)\n+\t}\n \tfmt.Fprintf(h, \"goos %s goarch %s\\n\", cfg.Goos, cfg.Goarch)\n \tfmt.Fprintf(h, \"import %q\\n\", p.ImportPath)\n \tfmt.Fprintf(h, \"omitdebug %v standard %v local %v prefix %q\\n\", p.Internal.OmitDebug, p.Standard, p.Internal.Local, p.Internal.LocalPrefix)"}, {"sha": "78b48f291c0131f1e574b8d5e218b1a7813fa2d6", "filename": "libgo/go/cmd/go/testdata/script/mod_edit_go.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -9,6 +9,13 @@ go mod edit -go=1.9\n grep 'go 1.9' go.mod\n go build\n \n+# Reverting the version should force a rebuild and error instead of using\n+# the cached 1.9 build. (https://golang.org/issue/37804)\n+go mod edit -go=1.8\n+! go build\n+stderr 'type aliases only supported as of'\n+\n+\n -- go.mod --\n module m\n go 1.8"}, {"sha": "8eed6260a2b4438308ec75f696c1112f424b027e", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -153,6 +153,7 @@ var pkgDeps = map[string][]string{\n \t\"internal/syscall/unix\":             {\"L0\", \"syscall\"},\n \t\"internal/syscall/windows\":          {\"L0\", \"syscall\", \"internal/syscall/windows/sysdll\", \"unicode/utf16\"},\n \t\"internal/syscall/windows/registry\": {\"L0\", \"syscall\", \"internal/syscall/windows/sysdll\", \"unicode/utf16\"},\n+\t\"internal/syscall/execenv\":          {\"L0\", \"syscall\", \"internal/syscall/windows\", \"unicode/utf16\"},\n \t\"time\": {\n \t\t// \"L0\" without the \"io\" package:\n \t\t\"errors\",\n@@ -170,10 +171,10 @@ var pkgDeps = map[string][]string{\n \t\"internal/cfg\":     {\"L0\"},\n \t\"internal/poll\":    {\"L0\", \"internal/oserror\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\", \"internal/syscall/unix\"},\n \t\"internal/testlog\": {\"L0\"},\n-\t\"os\":               {\"L1\", \"os\", \"syscall\", \"time\", \"internal/oserror\", \"internal/poll\", \"internal/syscall/windows\", \"internal/syscall/unix\", \"internal/testlog\"},\n+\t\"os\":               {\"L1\", \"os\", \"syscall\", \"time\", \"internal/oserror\", \"internal/poll\", \"internal/syscall/windows\", \"internal/syscall/unix\", \"internal/syscall/execenv\", \"internal/testlog\"},\n \t\"path/filepath\":    {\"L2\", \"os\", \"syscall\", \"internal/syscall/windows\"},\n \t\"io/ioutil\":        {\"L2\", \"os\", \"path/filepath\", \"time\"},\n-\t\"os/exec\":          {\"L2\", \"os\", \"context\", \"path/filepath\", \"syscall\"},\n+\t\"os/exec\":          {\"L2\", \"os\", \"context\", \"path/filepath\", \"syscall\", \"internal/syscall/execenv\"},\n \t\"os/signal\":        {\"L2\", \"os\", \"syscall\"},\n \n \t// OS enables basic operating system functionality,"}, {"sha": "4bdbb55edbf98b3059d88b93042ca726288976dc", "filename": "libgo/go/internal/syscall/execenv/execenv_default.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_default.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_default.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_default.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package execenv\n+\n+import \"syscall\"\n+\n+// Default will return the default environment\n+// variables based on the process attributes\n+// provided.\n+//\n+// Defaults to syscall.Environ() on all platforms\n+// other than Windows.\n+func Default(sys *syscall.SysProcAttr) ([]string, error) {\n+\treturn syscall.Environ(), nil\n+}"}, {"sha": "b50029c19839bf9dc034487369121d5faf1edebe", "filename": "libgo/go/internal/syscall/execenv/execenv_windows.go", "status": "renamed", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Fexecenv%2Fexecenv_windows.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1,8 +1,10 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n+// Copyright 2020 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package os\n+// +build windows\n+\n+package execenv\n \n import (\n \t\"internal/syscall/windows\"\n@@ -11,9 +13,17 @@ import (\n \t\"unsafe\"\n )\n \n-func environForSysProcAttr(sys *syscall.SysProcAttr) (env []string, err error) {\n+// Default will return the default environment\n+// variables based on the process attributes\n+// provided.\n+//\n+// If the process attributes contain a token, then\n+// the environment variables will be sourced from\n+// the defaults for that user token, otherwise they\n+// will be sourced from syscall.Environ().\n+func Default(sys *syscall.SysProcAttr) (env []string, err error) {\n \tif sys == nil || sys.Token == 0 {\n-\t\treturn Environ(), nil\n+\t\treturn syscall.Environ(), nil\n \t}\n \tvar block *uint16\n \terr = windows.CreateEnvironmentBlock(&block, sys.Token, false)", "previous_filename": "libgo/go/os/env_windows.go"}, {"sha": "c11ccce7e3d87244c03ded11906b6593edd45eb5", "filename": "libgo/go/os/env_default.go", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/749bd22ddc50b5112e5ed506ffef7249bf8e6fb3/libgo%2Fgo%2Fos%2Fenv_default.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/749bd22ddc50b5112e5ed506ffef7249bf8e6fb3/libgo%2Fgo%2Fos%2Fenv_default.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_default.go?ref=749bd22ddc50b5112e5ed506ffef7249bf8e6fb3", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !windows\n-\n-package os\n-\n-import \"syscall\"\n-\n-func environForSysProcAttr(sys *syscall.SysProcAttr) ([]string, error) {\n-\treturn Environ(), nil\n-}"}, {"sha": "0c495755116f5254030d45284ea31515cadb8487", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -24,6 +24,7 @@ import (\n \t\"bytes\"\n \t\"context\"\n \t\"errors\"\n+\t\"internal/syscall/execenv\"\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -222,11 +223,11 @@ func interfaceEqual(a, b interface{}) bool {\n \treturn a == b\n }\n \n-func (c *Cmd) envv() []string {\n+func (c *Cmd) envv() ([]string, error) {\n \tif c.Env != nil {\n-\t\treturn c.Env\n+\t\treturn c.Env, nil\n \t}\n-\treturn os.Environ()\n+\treturn execenv.Default(c.SysProcAttr)\n }\n \n func (c *Cmd) argv() []string {\n@@ -413,11 +414,15 @@ func (c *Cmd) Start() error {\n \t}\n \tc.childFiles = append(c.childFiles, c.ExtraFiles...)\n \n-\tvar err error\n+\tenvv, err := c.envv()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \tc.Process, err = os.StartProcess(c.Path, c.argv(), &os.ProcAttr{\n \t\tDir:   c.Dir,\n \t\tFiles: c.childFiles,\n-\t\tEnv:   addCriticalEnv(dedupEnv(c.envv())),\n+\t\tEnv:   addCriticalEnv(dedupEnv(envv)),\n \t\tSys:   c.SysProcAttr,\n \t})\n \tif err != nil {"}, {"sha": "dc9947c903eb731c34e5107c06279c9aaa45f455", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -7,6 +7,7 @@\n package os\n \n import (\n+\t\"internal/syscall/execenv\"\n \t\"runtime\"\n \t\"syscall\"\n )\n@@ -39,7 +40,7 @@ func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \t\tSys: attr.Sys,\n \t}\n \tif sysattr.Env == nil {\n-\t\tsysattr.Env, err = environForSysProcAttr(sysattr.Sys)\n+\t\tsysattr.Env, err = execenv.Default(sysattr.Sys)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}"}, {"sha": "95f02aa31c4425d4f705cb0f0e303b38d1412b68", "filename": "libgo/go/runtime/alg.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -176,9 +176,19 @@ func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {\n // is slower but more general and is used for hashing interface types\n // (called from interhash or nilinterhash, above) or for hashing in\n // maps generated by reflect.MapOf (reflect_typehash, below).\n+// Note: this function must match the compiler generated\n+// functions exactly. See issue 37716.\n func typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr {\n \tif t.tflag&tflagRegularMemory != 0 {\n-\t\treturn memhash(p, h, t.size)\n+\t\t// Handle ptr sizes specially, see issue 37086.\n+\t\tswitch t.size {\n+\t\tcase 4:\n+\t\t\treturn memhash32(p, h)\n+\t\tcase 8:\n+\t\t\treturn memhash64(p, h)\n+\t\tdefault:\n+\t\t\treturn memhash(p, h, t.size)\n+\t\t}\n \t}\n \tswitch t.kind & kindMask {\n \tcase kindFloat32:"}, {"sha": "d5f116c39278a8b00f99931ef57ddbd6f7b86219", "filename": "libgo/go/runtime/checkptr.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fcheckptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fcheckptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcheckptr.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -10,8 +10,10 @@ import \"unsafe\"\n \n func checkptrAlignment(p unsafe.Pointer, elem *_type, n uintptr) {\n \t// Check that (*[n]elem)(p) is appropriately aligned.\n+\t// Note that we allow unaligned pointers if the types they point to contain\n+\t// no pointers themselves. See issue 37298.\n \t// TODO(mdempsky): What about fieldAlign?\n-\tif uintptr(p)&(uintptr(elem.align)-1) != 0 {\n+\tif elem.ptrdata != 0 && uintptr(p)&(uintptr(elem.align)-1) != 0 {\n \t\tthrow(\"checkptr: unsafe pointer conversion\")\n \t}\n "}, {"sha": "0ca7b20cfd43b6507e0f39e44174554690e4ba6e", "filename": "libgo/go/runtime/checkptr_test.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -28,7 +28,8 @@ func TestCheckPtr(t *testing.T) {\n \t\tcmd  string\n \t\twant string\n \t}{\n-\t\t{\"CheckPtrAlignment\", \"fatal error: checkptr: unsafe pointer conversion\\n\"},\n+\t\t{\"CheckPtrAlignmentPtr\", \"fatal error: checkptr: unsafe pointer conversion\\n\"},\n+\t\t{\"CheckPtrAlignmentNoPtr\", \"\"},\n \t\t{\"CheckPtrArithmetic\", \"fatal error: checkptr: unsafe pointer arithmetic\\n\"},\n \t\t{\"CheckPtrSize\", \"fatal error: checkptr: unsafe pointer conversion\\n\"},\n \t\t{\"CheckPtrSmall\", \"fatal error: checkptr: unsafe pointer arithmetic\\n\"},\n@@ -42,6 +43,12 @@ func TestCheckPtr(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\tt.Log(err)\n \t\t\t}\n+\t\t\tif tc.want == \"\" {\n+\t\t\t\tif len(got) > 0 {\n+\t\t\t\t\tt.Errorf(\"output:\\n%s\\nwant no output\", got)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n \t\t\tif !strings.HasPrefix(string(got), tc.want) {\n \t\t\t\tt.Errorf(\"output:\\n%s\\n\\nwant output starting with: %s\", got, tc.want)\n \t\t\t}"}, {"sha": "11436a1f08be1668d71adaad034c26f20dad85ae", "filename": "libgo/go/runtime/defer_test.go", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fdefer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fdefer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdefer_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -6,6 +6,7 @@ package runtime_test\n \n import (\n \t\"fmt\"\n+\t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"testing\"\n@@ -281,3 +282,122 @@ func TestDeferForFuncWithNoExit(t *testing.T) {\n \tfor {\n \t}\n }\n+\n+// Test case approximating issue #37664, where a recursive function (interpreter)\n+// may do repeated recovers/re-panics until it reaches the frame where the panic\n+// can actually be handled. The recurseFnPanicRec() function is testing that there\n+// are no stale defer structs on the defer chain after the interpreter() sequence,\n+// by writing a bunch of 0xffffffffs into several recursive stack frames, and then\n+// doing a single panic-recover which would invoke any such stale defer structs.\n+func TestDeferWithRepeatedRepanics(t *testing.T) {\n+\tinterpreter(0, 6, 2)\n+\trecurseFnPanicRec(0, 10)\n+\tinterpreter(0, 5, 1)\n+\trecurseFnPanicRec(0, 10)\n+\tinterpreter(0, 6, 3)\n+\trecurseFnPanicRec(0, 10)\n+}\n+\n+func interpreter(level int, maxlevel int, rec int) {\n+\tdefer func() {\n+\t\te := recover()\n+\t\tif e == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif level != e.(int) {\n+\t\t\t//fmt.Fprintln(os.Stderr, \"re-panicing, level\", level)\n+\t\t\tpanic(e)\n+\t\t}\n+\t\t//fmt.Fprintln(os.Stderr, \"Recovered, level\", level)\n+\t}()\n+\tif level+1 < maxlevel {\n+\t\tinterpreter(level+1, maxlevel, rec)\n+\t} else {\n+\t\t//fmt.Fprintln(os.Stderr, \"Initiating panic\")\n+\t\tpanic(rec)\n+\t}\n+}\n+\n+func recurseFnPanicRec(level int, maxlevel int) {\n+\tdefer func() {\n+\t\trecover()\n+\t}()\n+\trecurseFn(level, maxlevel)\n+}\n+\n+func recurseFn(level int, maxlevel int) {\n+\ta := [40]uint32{0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff}\n+\tif level+1 < maxlevel {\n+\t\t// Need this print statement to keep a around.  '_ = a[4]' doesn't do it.\n+\t\tfmt.Fprintln(os.Stderr, \"recurseFn\", level, a[4])\n+\t\trecurseFn(level+1, maxlevel)\n+\t} else {\n+\t\tpanic(\"recurseFn panic\")\n+\t}\n+}\n+\n+// Try to reproduce issue #37688, where a pointer to an open-coded defer struct is\n+// mistakenly held, and that struct keeps a pointer to a stack-allocated defer\n+// struct, and that stack-allocated struct gets overwritten or the stack gets\n+// moved, so a memory error happens on GC.\n+func TestIssue37688(t *testing.T) {\n+\tfor j := 0; j < 10; j++ {\n+\t\tg2()\n+\t\tg3()\n+\t}\n+}\n+\n+type foo struct {\n+}\n+\n+func (f *foo) method1() {\n+\tfmt.Fprintln(os.Stderr, \"method1\")\n+}\n+\n+func (f *foo) method2() {\n+\tfmt.Fprintln(os.Stderr, \"method2\")\n+}\n+\n+func g2() {\n+\tvar a foo\n+\tap := &a\n+\t// The loop forces this defer to be heap-allocated and the remaining two\n+\t// to be stack-allocated.\n+\tfor i := 0; i < 1; i++ {\n+\t\tdefer ap.method1()\n+\t}\n+\tdefer ap.method2()\n+\tdefer ap.method1()\n+\tff1(ap, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n+\t// Try to get the stack to be be moved by growing it too large, so\n+\t// existing stack-allocated defer becomes invalid.\n+\trec1(2000)\n+}\n+\n+func g3() {\n+\t// Mix up the stack layout by adding in an extra function frame\n+\tg2()\n+}\n+\n+func ff1(ap *foo, a, b, c, d, e, f, g, h, i int) {\n+\tdefer ap.method1()\n+\n+\t// Make a defer that has a very large set of args, hence big size for the\n+\t// defer record for the open-coded frame (which means it won't use the\n+\t// defer pool)\n+\tdefer func(ap *foo, a, b, c, d, e, f, g, h, i int) {\n+\t\tif v := recover(); v != nil {\n+\t\t\tfmt.Fprintln(os.Stderr, \"did recover\")\n+\t\t}\n+\t\tfmt.Fprintln(os.Stderr, \"debug\", ap, a, b, c, d, e, f, g, h)\n+\t}(ap, a, b, c, d, e, f, g, h, i)\n+\tpanic(\"ff1 panic\")\n+}\n+\n+func rec1(max int) {\n+\tif max > 0 {\n+\t\trec1(max - 1)\n+\t} else {\n+\t\tfmt.Fprintln(os.Stderr, \"finished recursion\", max)\n+\t}\n+}"}, {"sha": "6595fafe3689de14c81819300e3409635e037195", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -945,4 +945,29 @@ func SemNwait(addr *uint32) uint32 {\n \treturn atomic.Load(&root.nwait)\n }\n \n+// MapHashCheck computes the hash of the key k for the map m, twice.\n+// Method 1 uses the built-in hasher for the map.\n+// Method 2 uses the typehash function (the one used by reflect).\n+// Returns the two hash values, which should always be equal.\n+func MapHashCheck(m interface{}, k interface{}) (uintptr, uintptr) {\n+\t// Unpack m.\n+\tmt := (*maptype)(unsafe.Pointer(efaceOf(&m)._type))\n+\tmh := (*hmap)(efaceOf(&m).data)\n+\n+\t// Unpack k.\n+\tkt := efaceOf(&k)._type\n+\tvar p unsafe.Pointer\n+\tif isDirectIface(kt) {\n+\t\tq := efaceOf(&k).data\n+\t\tp = unsafe.Pointer(&q)\n+\t} else {\n+\t\tp = efaceOf(&k).data\n+\t}\n+\n+\t// Compute the hash functions.\n+\tx := mt.hasher(noescape(p), uintptr(mh.hash0))\n+\ty := typehash(kt, noescape(p), uintptr(mh.hash0))\n+\treturn x, y\n+}\n+\n var Pusestackmaps = &usestackmaps"}, {"sha": "522b7febf9b9a2243232c7bb5006d3c758fa6fe5", "filename": "libgo/go/runtime/hash_test.go", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fhash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fhash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhash_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"fmt\"\n \t\"math\"\n \t\"math/rand\"\n+\t\"reflect\"\n \t. \"runtime\"\n \t\"strings\"\n \t\"testing\"\n@@ -48,6 +49,54 @@ func TestMemHash64Equality(t *testing.T) {\n \t}\n }\n \n+func TestCompilerVsRuntimeHash(t *testing.T) {\n+\t// Test to make sure the compiler's hash function and the runtime's hash function agree.\n+\t// See issue 37716.\n+\tfor _, m := range []interface{}{\n+\t\tmap[bool]int{},\n+\t\tmap[int8]int{},\n+\t\tmap[uint8]int{},\n+\t\tmap[int16]int{},\n+\t\tmap[uint16]int{},\n+\t\tmap[int32]int{},\n+\t\tmap[uint32]int{},\n+\t\tmap[int64]int{},\n+\t\tmap[uint64]int{},\n+\t\tmap[int]int{},\n+\t\tmap[uint]int{},\n+\t\tmap[uintptr]int{},\n+\t\tmap[*byte]int{},\n+\t\tmap[chan int]int{},\n+\t\tmap[unsafe.Pointer]int{},\n+\t\tmap[float32]int{},\n+\t\tmap[float64]int{},\n+\t\tmap[complex64]int{},\n+\t\tmap[complex128]int{},\n+\t\tmap[string]int{},\n+\t\t//map[interface{}]int{},\n+\t\t//map[interface{F()}]int{},\n+\t\tmap[[8]uint64]int{},\n+\t\tmap[[8]string]int{},\n+\t\tmap[struct{ a, b, c, d int32 }]int{}, // Note: tests AMEM128\n+\t\tmap[struct{ a, b, _, d int32 }]int{},\n+\t\tmap[struct {\n+\t\t\ta, b int32\n+\t\t\tc    float32\n+\t\t\td, e [8]byte\n+\t\t}]int{},\n+\t\tmap[struct {\n+\t\t\ta int16\n+\t\t\tb int64\n+\t\t}]int{},\n+\t} {\n+\t\tk := reflect.New(reflect.TypeOf(m).Key()).Elem().Interface() // the zero key\n+\t\tx, y := MapHashCheck(m, k)\n+\t\tif x != y {\n+\t\t\tt.Errorf(\"hashes did not match (%x vs %x) for map %T\", x, y, m)\n+\t\t}\n+\t}\n+}\n+\n // Smhasher is a torture test for hash functions.\n // https://code.google.com/p/smhasher/\n // This code is a port of some of the Smhasher tests to Go."}, {"sha": "24043cfb2e20aa64a4137409d8664650fcd83d26", "filename": "libgo/go/runtime/mgc.go", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fmgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fmgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -771,32 +771,40 @@ func gcSetTriggerRatio(triggerRatio float64) {\n \t\tgoal = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100\n \t}\n \n-\t// If we let triggerRatio go too low, then if the application\n-\t// is allocating very rapidly we might end up in a situation\n-\t// where we're allocating black during a nearly always-on GC.\n-\t// The result of this is a growing heap and ultimately an\n-\t// increase in RSS. By capping us at a point >0, we're essentially\n-\t// saying that we're OK using more CPU during the GC to prevent\n-\t// this growth in RSS.\n-\t//\n-\t// The current constant was chosen empirically: given a sufficiently\n-\t// fast/scalable allocator with 48 Ps that could drive the trigger ratio\n-\t// to <0.05, this constant causes applications to retain the same peak\n-\t// RSS compared to not having this allocator.\n-\tconst minTriggerRatio = 0.6\n-\n \t// Set the trigger ratio, capped to reasonable bounds.\n-\tif triggerRatio < minTriggerRatio {\n-\t\t// This can happen if the mutator is allocating very\n-\t\t// quickly or the GC is scanning very slowly.\n-\t\ttriggerRatio = minTriggerRatio\n-\t} else if gcpercent >= 0 {\n+\tif gcpercent >= 0 {\n+\t\tscalingFactor := float64(gcpercent) / 100\n \t\t// Ensure there's always a little margin so that the\n \t\t// mutator assist ratio isn't infinity.\n-\t\tmaxTriggerRatio := 0.95 * float64(gcpercent) / 100\n+\t\tmaxTriggerRatio := 0.95 * scalingFactor\n \t\tif triggerRatio > maxTriggerRatio {\n \t\t\ttriggerRatio = maxTriggerRatio\n \t\t}\n+\n+\t\t// If we let triggerRatio go too low, then if the application\n+\t\t// is allocating very rapidly we might end up in a situation\n+\t\t// where we're allocating black during a nearly always-on GC.\n+\t\t// The result of this is a growing heap and ultimately an\n+\t\t// increase in RSS. By capping us at a point >0, we're essentially\n+\t\t// saying that we're OK using more CPU during the GC to prevent\n+\t\t// this growth in RSS.\n+\t\t//\n+\t\t// The current constant was chosen empirically: given a sufficiently\n+\t\t// fast/scalable allocator with 48 Ps that could drive the trigger ratio\n+\t\t// to <0.05, this constant causes applications to retain the same peak\n+\t\t// RSS compared to not having this allocator.\n+\t\tminTriggerRatio := 0.6 * scalingFactor\n+\t\tif triggerRatio < minTriggerRatio {\n+\t\t\ttriggerRatio = minTriggerRatio\n+\t\t}\n+\t} else if triggerRatio < 0 {\n+\t\t// gcpercent < 0, so just make sure we're not getting a negative\n+\t\t// triggerRatio. This case isn't expected to happen in practice,\n+\t\t// and doesn't really matter because if gcpercent < 0 then we won't\n+\t\t// ever consume triggerRatio further on in this function, but let's\n+\t\t// just be defensive here; the triggerRatio being negative is almost\n+\t\t// certainly undesirable.\n+\t\ttriggerRatio = 0\n \t}\n \tmemstats.triggerRatio = triggerRatio\n "}, {"sha": "35ed42871f11dfef02ce02d951cbe85ce7740ccb", "filename": "libgo/go/runtime/mkpreempt.go", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmkpreempt.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -244,23 +244,26 @@ func genAMD64() {\n \n \t// TODO: MXCSR register?\n \n+\tp(\"PUSHQ BP\")\n+\tp(\"MOVQ SP, BP\")\n+\tp(\"// Save flags before clobbering them\")\n+\tp(\"PUSHFQ\")\n+\tp(\"// obj doesn't understand ADD/SUB on SP, but does understand ADJSP\")\n+\tp(\"ADJSP $%d\", l.stack)\n+\tp(\"// But vet doesn't know ADJSP, so suppress vet stack checking\")\n+\tp(\"NOP SP\")\n+\n \t// Apparently, the signal handling code path in darwin kernel leaves\n \t// the upper bits of Y registers in a dirty state, which causes\n \t// many SSE operations (128-bit and narrower) become much slower.\n \t// Clear the upper bits to get to a clean state. See issue #37174.\n \t// It is safe here as Go code don't use the upper bits of Y registers.\n \tp(\"#ifdef GOOS_darwin\")\n+\tp(\"CMPB internal\u2215cpu\u00b7X86+const_offsetX86HasAVX(SB), $0\")\n+\tp(\"JE 2(PC)\")\n \tp(\"VZEROUPPER\")\n \tp(\"#endif\")\n \n-\tp(\"PUSHQ BP\")\n-\tp(\"MOVQ SP, BP\")\n-\tp(\"// Save flags before clobbering them\")\n-\tp(\"PUSHFQ\")\n-\tp(\"// obj doesn't understand ADD/SUB on SP, but does understand ADJSP\")\n-\tp(\"ADJSP $%d\", l.stack)\n-\tp(\"// But vet doesn't know ADJSP, so suppress vet stack checking\")\n-\tp(\"NOP SP\")\n \tl.save()\n \tp(\"CALL \u00b7asyncPreempt2(SB)\")\n \tl.restore()\n@@ -379,13 +382,15 @@ func genMIPS(_64bit bool) {\n \tsub := \"SUB\"\n \tr28 := \"R28\"\n \tregsize := 4\n+\tsoftfloat := \"GOMIPS_softfloat\"\n \tif _64bit {\n \t\tmov = \"MOVV\"\n \t\tmovf = \"MOVD\"\n \t\tadd = \"ADDV\"\n \t\tsub = \"SUBV\"\n \t\tr28 = \"RSB\"\n \t\tregsize = 8\n+\t\tsoftfloat = \"GOMIPS64_softfloat\"\n \t}\n \n \t// Add integer registers R1-R22, R24-R25, R28\n@@ -408,28 +413,36 @@ func genMIPS(_64bit bool) {\n \t\tmov+\" LO, R1\\n\"+mov+\" R1, %d(R29)\",\n \t\tmov+\" %d(R29), R1\\n\"+mov+\" R1, LO\",\n \t\tregsize)\n+\n \t// Add floating point control/status register FCR31 (FCR0-FCR30 are irrelevant)\n-\tl.addSpecial(\n+\tvar lfp = layout{sp: \"R29\", stack: l.stack}\n+\tlfp.addSpecial(\n \t\tmov+\" FCR31, R1\\n\"+mov+\" R1, %d(R29)\",\n \t\tmov+\" %d(R29), R1\\n\"+mov+\" R1, FCR31\",\n \t\tregsize)\n \t// Add floating point registers F0-F31.\n \tfor i := 0; i <= 31; i++ {\n \t\treg := fmt.Sprintf(\"F%d\", i)\n-\t\tl.add(movf, reg, regsize)\n+\t\tlfp.add(movf, reg, regsize)\n \t}\n \n \t// allocate frame, save PC of interrupted instruction (in LR)\n-\tp(mov+\" R31, -%d(R29)\", l.stack)\n-\tp(sub+\" $%d, R29\", l.stack)\n+\tp(mov+\" R31, -%d(R29)\", lfp.stack)\n+\tp(sub+\" $%d, R29\", lfp.stack)\n \n \tl.save()\n+\tp(\"#ifndef %s\", softfloat)\n+\tlfp.save()\n+\tp(\"#endif\")\n \tp(\"CALL \u00b7asyncPreempt2(SB)\")\n+\tp(\"#ifndef %s\", softfloat)\n+\tlfp.restore()\n+\tp(\"#endif\")\n \tl.restore()\n \n-\tp(mov+\" %d(R29), R31\", l.stack)     // sigctxt.pushCall has pushed LR (at interrupt) on stack, restore it\n-\tp(mov + \" (R29), R23\")              // load PC to REGTMP\n-\tp(add+\" $%d, R29\", l.stack+regsize) // pop frame (including the space pushed by sigctxt.pushCall)\n+\tp(mov+\" %d(R29), R31\", lfp.stack)     // sigctxt.pushCall has pushed LR (at interrupt) on stack, restore it\n+\tp(mov + \" (R29), R23\")                // load PC to REGTMP\n+\tp(add+\" $%d, R29\", lfp.stack+regsize) // pop frame (including the space pushed by sigctxt.pushCall)\n \tp(\"JMP (R23)\")\n }\n "}, {"sha": "f6747f5c87919deb97da064c980cf3bdb9d9a23f", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -218,10 +218,13 @@ func panicmem() {\n // pfn is a C function pointer.\n // arg is a value to pass to pfn.\n func deferproc(frame *bool, pfn uintptr, arg unsafe.Pointer) {\n+\tgp := getg()\n \td := newdefer()\n \tif d._panic != nil {\n \t\tthrow(\"deferproc: d.panic != nil after newdefer\")\n \t}\n+\td.link = gp._defer\n+\tgp._defer = d\n \td.frame = frame\n \td.panicStack = getg()._panic\n \td.pfn = pfn\n@@ -300,8 +303,6 @@ func newdefer() *_defer {\n \t\t}\n \t}\n \td.heap = true\n-\td.link = gp._defer\n-\tgp._defer = d\n \treturn d\n }\n \n@@ -1175,6 +1176,12 @@ func startpanic_m() bool {\n \t}\n }\n \n+// throwReportQuirk, if non-nil, is called by throw after dumping the stacks.\n+//\n+// TODO(austin): Remove this after Go 1.15 when we remove the\n+// mlockGsignal workaround.\n+var throwReportQuirk func()\n+\n var didothers bool\n var deadlock mutex\n \n@@ -1221,6 +1228,10 @@ func dopanic_m(gp *g, pc, sp uintptr) bool {\n \n \tprintDebugLog()\n \n+\tif throwReportQuirk != nil {\n+\t\tthrowReportQuirk()\n+\t}\n+\n \treturn docrash\n }\n "}, {"sha": "7c75872351383012fc506d8c40596f04290dccdf", "filename": "libgo/go/runtime/pprof/map.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fmap.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -68,7 +68,8 @@ Search:\n \tif len(m.freeStk) < len(stk) {\n \t\tm.freeStk = make([]uintptr, 1024)\n \t}\n-\te.stk = m.freeStk[:len(stk)]\n+\t// Limit cap to prevent append from clobbering freeStk.\n+\te.stk = m.freeStk[:len(stk):len(stk)]\n \tm.freeStk = m.freeStk[len(stk):]\n \n \tfor j := range stk {"}, {"sha": "239466fecc6f75c91594fec29f5103b9200f9c3e", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -1192,16 +1192,37 @@ func TestTryAdd(t *testing.T) {\n \t\t\t{Value: []int64{20, 20 * period}, Location: []*profile.Location{{ID: 1}}},\n \t\t},\n \t}, {\n-\t\tname: \"recursive_inlined_funcs\",\n+\t\tname: \"bug38096\",\n+\t\tinput: []uint64{\n+\t\t\t3, 0, 500, // hz = 500. Must match the period.\n+\t\t\t// count (data[2]) == 0 && len(stk) == 1 is an overflow\n+\t\t\t// entry. The \"stk\" entry is actually the count.\n+\t\t\t4, 0, 0, 4242,\n+\t\t},\n+\t\twantLocs: [][]string{{\"runtime/pprof.lostProfileEvent\"}},\n+\t\twantSamples: []*profile.Sample{\n+\t\t\t{Value: []int64{4242, 4242 * period}, Location: []*profile.Location{{ID: 1}}},\n+\t\t},\n+\t}, {\n+\t\t// If a function is called recursively then it must not be\n+\t\t// inlined in the caller.\n+\t\t//\n+\t\t// N.B. We're generating an impossible profile here, with a\n+\t\t// recursive inlineCallee call. This is simulating a non-Go\n+\t\t// function that looks like an inlined Go function other than\n+\t\t// its recursive property. See pcDeck.tryAdd.\n+\t\tname: \"recursive_func_is_not_inlined\",\n \t\tinput: []uint64{\n \t\t\t3, 0, 500, // hz = 500. Must match the period.\n \t\t\t5, 0, 30, inlinedCalleePtr, inlinedCalleePtr,\n \t\t\t4, 0, 40, inlinedCalleePtr,\n \t\t},\n-\t\twantLocs: [][]string{{\"runtime/pprof.inlinedCallee\"}},\n+\t\t// inlinedCaller shows up here because\n+\t\t// runtime_expandFinalInlineFrame adds it to the stack frame.\n+\t\twantLocs: [][]string{{\"runtime/pprof.inlinedCallee\"}, {\"runtime/pprof.inlinedCaller\"}},\n \t\twantSamples: []*profile.Sample{\n-\t\t\t{Value: []int64{30, 30 * period}, Location: []*profile.Location{{ID: 1}, {ID: 1}}},\n-\t\t\t{Value: []int64{40, 40 * period}, Location: []*profile.Location{{ID: 1}}},\n+\t\t\t{Value: []int64{30, 30 * period}, Location: []*profile.Location{{ID: 1}, {ID: 1}, {ID: 2}}},\n+\t\t\t{Value: []int64{40, 40 * period}, Location: []*profile.Location{{ID: 1}, {ID: 2}}},\n \t\t},\n \t}, {\n \t\tname: \"truncated_stack_trace_later\",\n@@ -1222,12 +1243,36 @@ func TestTryAdd(t *testing.T) {\n \t\t\t4, 0, 70, inlinedCalleePtr,\n \t\t\t5, 0, 80, inlinedCalleePtr, inlinedCallerPtr,\n \t\t},\n-\t\twantLocs: [][]string{ // the inline info is screwed up, but better than a crash.\n-\t\t\t{\"runtime/pprof.inlinedCallee\"},\n+\t\twantLocs: [][]string{{\"runtime/pprof.inlinedCallee\", \"runtime/pprof.inlinedCaller\"}},\n+\t\twantSamples: []*profile.Sample{\n+\t\t\t{Value: []int64{70, 70 * period}, Location: []*profile.Location{{ID: 1}}},\n+\t\t\t{Value: []int64{80, 80 * period}, Location: []*profile.Location{{ID: 1}}},\n+\t\t},\n+\t}, {\n+\t\t// We can recover the inlined caller from a truncated stack.\n+\t\tname: \"truncated_stack_trace_only\",\n+\t\tinput: []uint64{\n+\t\t\t3, 0, 500, // hz = 500. Must match the period.\n+\t\t\t4, 0, 70, inlinedCalleePtr,\n+\t\t},\n+\t\twantLocs: [][]string{{\"runtime/pprof.inlinedCallee\", \"runtime/pprof.inlinedCaller\"}},\n+\t\twantSamples: []*profile.Sample{\n+\t\t\t{Value: []int64{70, 70 * period}, Location: []*profile.Location{{ID: 1}}},\n+\t\t},\n+\t}, {\n+\t\t// The same location is used for duplicated stacks.\n+\t\tname: \"truncated_stack_trace_twice\",\n+\t\tinput: []uint64{\n+\t\t\t3, 0, 500, // hz = 500. Must match the period.\n+\t\t\t4, 0, 70, inlinedCalleePtr,\n+\t\t\t5, 0, 80, inlinedCallerPtr, inlinedCalleePtr,\n+\t\t},\n+\t\twantLocs: [][]string{\n+\t\t\t{\"runtime/pprof.inlinedCallee\", \"runtime/pprof.inlinedCaller\"},\n \t\t\t{\"runtime/pprof.inlinedCaller\"}},\n \t\twantSamples: []*profile.Sample{\n \t\t\t{Value: []int64{70, 70 * period}, Location: []*profile.Location{{ID: 1}}},\n-\t\t\t{Value: []int64{80, 80 * period}, Location: []*profile.Location{{ID: 1}, {ID: 2}}},\n+\t\t\t{Value: []int64{80, 80 * period}, Location: []*profile.Location{{ID: 2}, {ID: 1}}},\n \t\t},\n \t}}\n "}, {"sha": "15fa44b991efe93112450504fa46b55da7e10d38", "filename": "libgo/go/runtime/pprof/proto.go", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -335,7 +335,10 @@ func (b *profileBuilder) addCPUData(data []uint64, tags []unsafe.Pointer) error\n \t\t\t// overflow record\n \t\t\tcount = uint64(stk[0])\n \t\t\tstk = []uint64{\n-\t\t\t\tuint64(funcPC(lostProfileEvent)),\n+\t\t\t\t// gentraceback guarantees that PCs in the\n+\t\t\t\t// stack can be unconditionally decremented and\n+\t\t\t\t// still be valid, so we must do the same.\n+\t\t\t\tuint64(funcPC(lostProfileEvent) + 1),\n \t\t\t}\n \t\t}\n \t\tb.m.lookup(stk, tag).count += int64(count)\n@@ -397,6 +400,10 @@ func (b *profileBuilder) build() {\n // It may emit to b.pb, so there must be no message encoding in progress.\n func (b *profileBuilder) appendLocsForStack(locs []uint64, stk []uintptr) (newLocs []uint64) {\n \tb.deck.reset()\n+\n+\t// The last frame might be truncated. Recover lost inline frames.\n+\tstk = runtime_expandFinalInlineFrame(stk)\n+\n \tfor len(stk) > 0 {\n \t\taddr := stk[0]\n \t\tif l, ok := b.locs[addr]; ok {\n@@ -408,22 +415,12 @@ func (b *profileBuilder) appendLocsForStack(locs []uint64, stk []uintptr) (newLo\n \t\t\t// then, record the cached location.\n \t\t\tlocs = append(locs, l.id)\n \n-\t\t\t// The stk may be truncated due to the stack depth limit\n-\t\t\t// (e.g. See maxStack and maxCPUProfStack in runtime) or\n-\t\t\t// bugs in runtime. Avoid the crash in either case.\n-\t\t\t// TODO(hyangah): The correct fix may require using the exact\n-\t\t\t// pcs as the key for b.locs cache management instead of just\n-\t\t\t// relying on the very first pc. We are late in the go1.14 dev\n-\t\t\t// cycle, so this is a workaround with little code change.\n-\t\t\tif len(l.pcs) > len(stk) {\n-\t\t\t\tstk = nil\n-\t\t\t\t// TODO(hyangah): would be nice if we can enable\n-\t\t\t\t// debug print out on demand and report the problematic\n-\t\t\t\t// cached location entry and stack traces. Do we already\n-\t\t\t\t// have such facility to utilize (e.g. GODEBUG)?\n-\t\t\t} else {\n-\t\t\t\tstk = stk[len(l.pcs):] // skip the matching pcs.\n-\t\t\t}\n+\t\t\t// Skip the matching pcs.\n+\t\t\t//\n+\t\t\t// Even if stk was truncated due to the stack depth\n+\t\t\t// limit, expandFinalInlineFrame above has already\n+\t\t\t// fixed the truncation, ensuring it is long enough.\n+\t\t\tstk = stk[len(l.pcs):]\n \t\t\tcontinue\n \t\t}\n \n@@ -440,9 +437,9 @@ func (b *profileBuilder) appendLocsForStack(locs []uint64, stk []uintptr) (newLo\n \t\t\tstk = stk[1:]\n \t\t\tcontinue\n \t\t}\n-\t\t// add failed because this addr is not inlined with\n-\t\t// the existing PCs in the deck. Flush the deck and retry to\n-\t\t// handle this pc.\n+\t\t// add failed because this addr is not inlined with the\n+\t\t// existing PCs in the deck. Flush the deck and retry handling\n+\t\t// this pc.\n \t\tif id := b.emitLocation(); id > 0 {\n \t\t\tlocs = append(locs, id)\n \t\t}\n@@ -476,8 +473,8 @@ func (b *profileBuilder) appendLocsForStack(locs []uint64, stk []uintptr) (newLo\n // the fake pcs and restore the inlined and entry functions. Inlined functions\n // have the following properties:\n //   Frame's Func is nil (note: also true for non-Go functions), and\n-//   Frame's Entry matches its entry function frame's Entry. (note: could also be true for recursive calls and non-Go functions),\n-//   Frame's Name does not match its entry function frame's name.\n+//   Frame's Entry matches its entry function frame's Entry (note: could also be true for recursive calls and non-Go functions), and\n+//   Frame's Name does not match its entry function frame's name (note: inlined functions cannot be recursive).\n //\n // As reading and processing the pcs in a stack trace one by one (from leaf to the root),\n // we use pcDeck to temporarily hold the observed pcs and their expanded frames\n@@ -499,8 +496,8 @@ func (d *pcDeck) reset() {\n // to the deck. If it fails the caller needs to flush the deck and retry.\n func (d *pcDeck) tryAdd(pc uintptr, frames []runtime.Frame, symbolizeResult symbolizeFlag) (success bool) {\n \tif existing := len(d.pcs); existing > 0 {\n-\t\t// 'frames' are all expanded from one 'pc' and represent all inlined functions\n-\t\t// so we check only the last one.\n+\t\t// 'd.frames' are all expanded from one 'pc' and represent all\n+\t\t// inlined functions so we check only the last one.\n \t\tnewFrame := frames[0]\n \t\tlast := d.frames[existing-1]\n \t\tif last.Func != nil { // the last frame can't be inlined. Flush."}, {"sha": "81cd5591d1d8f7dff9ac3ac6106ce2ec71bd9fa1", "filename": "libgo/go/runtime/pprof/proto_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fproto_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -424,3 +424,16 @@ func TestFakeMapping(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Make sure the profiler can handle an empty stack trace.\n+// See issue 37967.\n+func TestEmptyStack(t *testing.T) {\n+\tb := []uint64{\n+\t\t3, 0, 500, // hz = 500\n+\t\t3, 0, 10, // 10 samples with an empty stack trace\n+\t}\n+\t_, err := translateCPUProfile(b)\n+\tif err != nil {\n+\t\tt.Fatalf(\"translating profile: %v\", err)\n+\t}\n+}"}, {"sha": "dd2545b3390dbc6dcd150c3fad2502296cb30e32", "filename": "libgo/go/runtime/pprof/runtime.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fruntime.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -9,6 +9,9 @@ import (\n \t\"unsafe\"\n )\n \n+// runtime_expandFinalInlineFrame is defined in runtime/symtab.go.\n+func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr\n+\n // runtime_setProfLabel is defined in runtime/proflabel.go.\n func runtime_setProfLabel(labels unsafe.Pointer)\n "}, {"sha": "75b42f713090caa1af250401ca602d5e61958f44", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -593,6 +593,10 @@ type m struct {\n \t// requested, but fails. Accessed atomically.\n \tpreemptGen uint32\n \n+\t// Whether this is a pending preemption signal on this M.\n+\t// Accessed atomically.\n+\tsignalPending uint32\n+\n \tdlogPerM\n \n \tmOS"}, {"sha": "1e057f6bf245e620a5e7c612663607cf598d2627", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -343,6 +343,7 @@ func doSigPreempt(gp *g, ctxt *sigctxt, sigpc uintptr) {\n \n \t// Acknowledge the preemption.\n \tatomic.Xadd(&gp.m.preemptGen, 1)\n+\tatomic.Store(&gp.m.signalPending, 0)\n }\n \n // gccgo-specific definition."}, {"sha": "867345740702eaf7cf31783d21d89cb5e4d0d94b", "filename": "libgo/go/runtime/symtab.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsymtab.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -4,6 +4,10 @@\n \n package runtime\n \n+import (\n+\t_ \"unsafe\" // for go:linkname\n+)\n+\n // Frames may be used to get function/file/line information for a\n // slice of PC values returned by Callers.\n type Frames struct {\n@@ -108,6 +112,33 @@ func (ci *Frames) Next() (frame Frame, more bool) {\n \treturn frame, more\n }\n \n+//go:noescape\n+// pcInlineCallers is written in C.\n+func pcInlineCallers(pc uintptr, locbuf *location, max int32) int32\n+\n+// runtime_expandFinalInlineFrame expands the final pc in stk to include all\n+// \"callers\" if pc is inline.\n+//\n+//go:linkname runtime_expandFinalInlineFrame runtime..z2fpprof.runtime_expandFinalInlineFrame\n+func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr {\n+\tif len(stk) == 0 {\n+\t\treturn stk\n+\t}\n+\tpc := stk[len(stk)-1]\n+\ttracepc := pc - 1\n+\n+\tvar locbuf [_TracebackMaxFrames]location\n+\tn := pcInlineCallers(tracepc, &locbuf[0], int32(len(locbuf)))\n+\n+\t// Returning the same PC several times causes Frame.Next to do\n+\t// the right thing.\n+\tfor i := int32(1); i < n; i++ {\n+\t\tstk = append(stk, pc)\n+\t}\n+\n+\treturn stk\n+}\n+\n // NOTE: Func does not expose the actual unexported fields, because we return *Func\n // values to users, and we want to keep them from being able to overwrite the data\n // with (say) *f = Func{}."}, {"sha": "45e6fb1aa53f6c463ad7a8196439505372a00526", "filename": "libgo/go/runtime/testdata/testprog/checkptr.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -7,18 +7,25 @@ package main\n import \"unsafe\"\n \n func init() {\n-\tregister(\"CheckPtrAlignment\", CheckPtrAlignment)\n+\tregister(\"CheckPtrAlignmentNoPtr\", CheckPtrAlignmentNoPtr)\n+\tregister(\"CheckPtrAlignmentPtr\", CheckPtrAlignmentPtr)\n \tregister(\"CheckPtrArithmetic\", CheckPtrArithmetic)\n \tregister(\"CheckPtrSize\", CheckPtrSize)\n \tregister(\"CheckPtrSmall\", CheckPtrSmall)\n }\n \n-func CheckPtrAlignment() {\n+func CheckPtrAlignmentNoPtr() {\n \tvar x [2]int64\n \tp := unsafe.Pointer(&x[0])\n \tsink2 = (*int64)(unsafe.Pointer(uintptr(p) + 1))\n }\n \n+func CheckPtrAlignmentPtr() {\n+\tvar x [2]int64\n+\tp := unsafe.Pointer(&x[0])\n+\tsink2 = (**int64)(unsafe.Pointer(uintptr(p) + 1))\n+}\n+\n func CheckPtrArithmetic() {\n \tvar x int\n \ti := uintptr(unsafe.Pointer(&x))"}, {"sha": "27d88d43105ecd750db5c70c46c6e5a328b82852", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 101, "deletions": 155, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -73,36 +73,26 @@ type timer struct {\n //   timerNoStatus   -> timerWaiting\n //   anything else   -> panic: invalid value\n // deltimer:\n-//   timerWaiting         -> timerDeleted\n+//   timerWaiting         -> timerModifying -> timerDeleted\n //   timerModifiedEarlier -> timerModifying -> timerDeleted\n-//   timerModifiedLater   -> timerDeleted\n+//   timerModifiedLater   -> timerModifying -> timerDeleted\n //   timerNoStatus        -> do nothing\n //   timerDeleted         -> do nothing\n //   timerRemoving        -> do nothing\n //   timerRemoved         -> do nothing\n //   timerRunning         -> wait until status changes\n //   timerMoving          -> wait until status changes\n-//   timerModifying  -> panic: concurrent deltimer/modtimer calls\n+//   timerModifying       -> wait until status changes\n // modtimer:\n //   timerWaiting    -> timerModifying -> timerModifiedXX\n //   timerModifiedXX -> timerModifying -> timerModifiedYY\n-//   timerNoStatus   -> timerWaiting\n-//   timerRemoved    -> timerWaiting\n+//   timerNoStatus   -> timerModifying -> timerWaiting\n+//   timerRemoved    -> timerModifying -> timerWaiting\n+//   timerDeleted    -> timerModifying -> timerModifiedXX\n //   timerRunning    -> wait until status changes\n //   timerMoving     -> wait until status changes\n //   timerRemoving   -> wait until status changes\n-//   timerDeleted    -> panic: concurrent modtimer/deltimer calls\n-//   timerModifying  -> panic: concurrent modtimer calls\n-// resettimer:\n-//   timerNoStatus   -> timerWaiting\n-//   timerRemoved    -> timerWaiting\n-//   timerDeleted    -> timerModifying -> timerModifiedXX\n-//   timerRemoving   -> wait until status changes\n-//   timerRunning    -> wait until status changes\n-//   timerWaiting    -> panic: resettimer called on active timer\n-//   timerMoving     -> panic: resettimer called on active timer\n-//   timerModifiedXX -> panic: resettimer called on active timer\n-//   timerModifying  -> panic: resettimer called on active timer\n+//   timerModifying  -> wait until status changes\n // cleantimers (looks in P's timer heap):\n //   timerDeleted    -> timerRemoving -> timerRemoved\n //   timerModifiedXX -> timerMoving -> timerWaiting\n@@ -250,32 +240,24 @@ func addtimer(t *timer) {\n \t\tt.when = maxWhen\n \t}\n \tif t.status != timerNoStatus {\n-\t\tbadTimer()\n+\t\tthrow(\"addtimer called with initialized timer\")\n \t}\n \tt.status = timerWaiting\n \n-\taddInitializedTimer(t)\n-}\n-\n-// addInitializedTimer adds an initialized timer to the current P.\n-func addInitializedTimer(t *timer) {\n \twhen := t.when\n \n \tpp := getg().m.p.ptr()\n \tlock(&pp.timersLock)\n-\tok := cleantimers(pp) && doaddtimer(pp, t)\n+\tcleantimers(pp)\n+\tdoaddtimer(pp, t)\n \tunlock(&pp.timersLock)\n-\tif !ok {\n-\t\tbadTimer()\n-\t}\n \n \twakeNetPoller(when)\n }\n \n // doaddtimer adds t to the current P's heap.\n-// It reports whether it saw no problems due to races.\n // The caller must have locked the timers for pp.\n-func doaddtimer(pp *p, t *timer) bool {\n+func doaddtimer(pp *p, t *timer) {\n \t// Timers rely on the network poller, so make sure the poller\n \t// has started.\n \tif netpollInited == 0 {\n@@ -288,12 +270,11 @@ func doaddtimer(pp *p, t *timer) bool {\n \tt.pp.set(pp)\n \ti := len(pp.timers)\n \tpp.timers = append(pp.timers, t)\n-\tok := siftupTimer(pp.timers, i)\n+\tsiftupTimer(pp.timers, i)\n \tif t == pp.timers[0] {\n \t\tatomic.Store64(&pp.timer0When, uint64(t.when))\n \t}\n \tatomic.Xadd(&pp.numTimers, 1)\n-\treturn ok\n }\n \n // deltimer deletes the timer t. It may be on some other P, so we can't\n@@ -304,22 +285,42 @@ func deltimer(t *timer) bool {\n \tfor {\n \t\tswitch s := atomic.Load(&t.status); s {\n \t\tcase timerWaiting, timerModifiedLater:\n-\t\t\ttpp := t.pp.ptr()\n-\t\t\tif atomic.Cas(&t.status, s, timerDeleted) {\n+\t\t\t// Prevent preemption while the timer is in timerModifying.\n+\t\t\t// This could lead to a self-deadlock. See #38070.\n+\t\t\tmp := acquirem()\n+\t\t\tif atomic.Cas(&t.status, s, timerModifying) {\n+\t\t\t\t// Must fetch t.pp before changing status,\n+\t\t\t\t// as cleantimers in another goroutine\n+\t\t\t\t// can clear t.pp of a timerDeleted timer.\n+\t\t\t\ttpp := t.pp.ptr()\n+\t\t\t\tif !atomic.Cas(&t.status, timerModifying, timerDeleted) {\n+\t\t\t\t\tbadTimer()\n+\t\t\t\t}\n+\t\t\t\treleasem(mp)\n \t\t\t\tatomic.Xadd(&tpp.deletedTimers, 1)\n \t\t\t\t// Timer was not yet run.\n \t\t\t\treturn true\n+\t\t\t} else {\n+\t\t\t\treleasem(mp)\n \t\t\t}\n \t\tcase timerModifiedEarlier:\n-\t\t\ttpp := t.pp.ptr()\n+\t\t\t// Prevent preemption while the timer is in timerModifying.\n+\t\t\t// This could lead to a self-deadlock. See #38070.\n+\t\t\tmp := acquirem()\n \t\t\tif atomic.Cas(&t.status, s, timerModifying) {\n+\t\t\t\t// Must fetch t.pp before setting status\n+\t\t\t\t// to timerDeleted.\n+\t\t\t\ttpp := t.pp.ptr()\n \t\t\t\tatomic.Xadd(&tpp.adjustTimers, -1)\n \t\t\t\tif !atomic.Cas(&t.status, timerModifying, timerDeleted) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n+\t\t\t\treleasem(mp)\n \t\t\t\tatomic.Xadd(&tpp.deletedTimers, 1)\n \t\t\t\t// Timer was not yet run.\n \t\t\t\treturn true\n+\t\t\t} else {\n+\t\t\t\treleasem(mp)\n \t\t\t}\n \t\tcase timerDeleted, timerRemoving, timerRemoved:\n \t\t\t// Timer was already run.\n@@ -334,7 +335,8 @@ func deltimer(t *timer) bool {\n \t\t\treturn false\n \t\tcase timerModifying:\n \t\t\t// Simultaneous calls to deltimer and modtimer.\n-\t\t\tbadTimer()\n+\t\t\t// Wait for the other call to complete.\n+\t\t\tosyield()\n \t\tdefault:\n \t\t\tbadTimer()\n \t\t}\n@@ -345,7 +347,7 @@ func deltimer(t *timer) bool {\n // We are locked on the P when this is called.\n // It reports whether it saw no problems due to races.\n // The caller must have locked the timers for pp.\n-func dodeltimer(pp *p, i int) bool {\n+func dodeltimer(pp *p, i int) {\n \tif t := pp.timers[i]; t.pp.ptr() != pp {\n \t\tthrow(\"dodeltimer: wrong P\")\n \t} else {\n@@ -357,29 +359,23 @@ func dodeltimer(pp *p, i int) bool {\n \t}\n \tpp.timers[last] = nil\n \tpp.timers = pp.timers[:last]\n-\tok := true\n \tif i != last {\n \t\t// Moving to i may have moved the last timer to a new parent,\n \t\t// so sift up to preserve the heap guarantee.\n-\t\tif !siftupTimer(pp.timers, i) {\n-\t\t\tok = false\n-\t\t}\n-\t\tif !siftdownTimer(pp.timers, i) {\n-\t\t\tok = false\n-\t\t}\n+\t\tsiftupTimer(pp.timers, i)\n+\t\tsiftdownTimer(pp.timers, i)\n \t}\n \tif i == 0 {\n \t\tupdateTimer0When(pp)\n \t}\n \tatomic.Xadd(&pp.numTimers, -1)\n-\treturn ok\n }\n \n // dodeltimer0 removes timer 0 from the current P's heap.\n // We are locked on the P when this is called.\n // It reports whether it saw no problems due to races.\n // The caller must have locked the timers for pp.\n-func dodeltimer0(pp *p) bool {\n+func dodeltimer0(pp *p) {\n \tif t := pp.timers[0]; t.pp.ptr() != pp {\n \t\tthrow(\"dodeltimer0: wrong P\")\n \t} else {\n@@ -391,13 +387,11 @@ func dodeltimer0(pp *p) bool {\n \t}\n \tpp.timers[last] = nil\n \tpp.timers = pp.timers[:last]\n-\tok := true\n \tif last > 0 {\n-\t\tok = siftdownTimer(pp.timers, 0)\n+\t\tsiftdownTimer(pp.timers, 0)\n \t}\n \tupdateTimer0When(pp)\n \tatomic.Xadd(&pp.numTimers, -1)\n-\treturn ok\n }\n \n // modtimer modifies an existing timer.\n@@ -409,30 +403,47 @@ func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg in\n \n \tstatus := uint32(timerNoStatus)\n \twasRemoved := false\n+\tvar mp *m\n loop:\n \tfor {\n \t\tswitch status = atomic.Load(&t.status); status {\n \t\tcase timerWaiting, timerModifiedEarlier, timerModifiedLater:\n+\t\t\t// Prevent preemption while the timer is in timerModifying.\n+\t\t\t// This could lead to a self-deadlock. See #38070.\n+\t\t\tmp = acquirem()\n \t\t\tif atomic.Cas(&t.status, status, timerModifying) {\n \t\t\t\tbreak loop\n \t\t\t}\n+\t\t\treleasem(mp)\n \t\tcase timerNoStatus, timerRemoved:\n+\t\t\t// Prevent preemption while the timer is in timerModifying.\n+\t\t\t// This could lead to a self-deadlock. See #38070.\n+\t\t\tmp = acquirem()\n+\n \t\t\t// Timer was already run and t is no longer in a heap.\n \t\t\t// Act like addtimer.\n-\t\t\tif atomic.Cas(&t.status, status, timerWaiting) {\n+\t\t\tif atomic.Cas(&t.status, status, timerModifying) {\n \t\t\t\twasRemoved = true\n \t\t\t\tbreak loop\n \t\t\t}\n+\t\t\treleasem(mp)\n+\t\tcase timerDeleted:\n+\t\t\t// Prevent preemption while the timer is in timerModifying.\n+\t\t\t// This could lead to a self-deadlock. See #38070.\n+\t\t\tmp = acquirem()\n+\t\t\tif atomic.Cas(&t.status, status, timerModifying) {\n+\t\t\t\tatomic.Xadd(&t.pp.ptr().deletedTimers, -1)\n+\t\t\t\tbreak loop\n+\t\t\t}\n+\t\t\treleasem(mp)\n \t\tcase timerRunning, timerRemoving, timerMoving:\n \t\t\t// The timer is being run or moved, by a different P.\n \t\t\t// Wait for it to complete.\n \t\t\tosyield()\n-\t\tcase timerDeleted:\n-\t\t\t// Simultaneous calls to modtimer and deltimer.\n-\t\t\tbadTimer()\n \t\tcase timerModifying:\n \t\t\t// Multiple simultaneous calls to modtimer.\n-\t\t\tbadTimer()\n+\t\t\t// Wait for the other call to complete.\n+\t\t\tosyield()\n \t\tdefault:\n \t\t\tbadTimer()\n \t\t}\n@@ -445,7 +456,15 @@ loop:\n \n \tif wasRemoved {\n \t\tt.when = when\n-\t\taddInitializedTimer(t)\n+\t\tpp := getg().m.p.ptr()\n+\t\tlock(&pp.timersLock)\n+\t\tdoaddtimer(pp, t)\n+\t\tunlock(&pp.timersLock)\n+\t\tif !atomic.Cas(&t.status, timerModifying, timerWaiting) {\n+\t\t\tbadTimer()\n+\t\t}\n+\t\treleasem(mp)\n+\t\twakeNetPoller(when)\n \t} else {\n \t\t// The timer is in some other P's heap, so we can't change\n \t\t// the when field. If we did, the other P's heap would\n@@ -462,7 +481,6 @@ loop:\n \t\t// Update the adjustTimers field.  Subtract one if we\n \t\t// are removing a timerModifiedEarlier, add one if we\n \t\t// are adding a timerModifiedEarlier.\n-\t\ttpp := t.pp.ptr()\n \t\tadjust := int32(0)\n \t\tif status == timerModifiedEarlier {\n \t\t\tadjust--\n@@ -471,13 +489,14 @@ loop:\n \t\t\tadjust++\n \t\t}\n \t\tif adjust != 0 {\n-\t\t\tatomic.Xadd(&tpp.adjustTimers, adjust)\n+\t\t\tatomic.Xadd(&t.pp.ptr().adjustTimers, adjust)\n \t\t}\n \n \t\t// Set the new status of the timer.\n \t\tif !atomic.Cas(&t.status, timerModifying, newStatus) {\n \t\t\tbadTimer()\n \t\t}\n+\t\treleasem(mp)\n \n \t\t// If the new status is earlier, wake up the poller.\n \t\tif newStatus == timerModifiedEarlier {\n@@ -486,67 +505,22 @@ loop:\n \t}\n }\n \n-// resettimer resets an existing inactive timer to turn it into an active timer,\n-// with a new time for when the timer should fire.\n+// resettimer resets the time when a timer should fire.\n+// If used for an inactive timer, the timer will become active.\n // This should be called instead of addtimer if the timer value has been,\n // or may have been, used previously.\n func resettimer(t *timer, when int64) {\n-\tif when < 0 {\n-\t\twhen = maxWhen\n-\t}\n-\n-\tfor {\n-\t\tswitch s := atomic.Load(&t.status); s {\n-\t\tcase timerNoStatus, timerRemoved:\n-\t\t\tif atomic.Cas(&t.status, s, timerWaiting) {\n-\t\t\t\tt.when = when\n-\t\t\t\taddInitializedTimer(t)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\tcase timerDeleted:\n-\t\t\ttpp := t.pp.ptr()\n-\t\t\tif atomic.Cas(&t.status, s, timerModifying) {\n-\t\t\t\tt.nextwhen = when\n-\t\t\t\tnewStatus := uint32(timerModifiedLater)\n-\t\t\t\tif when < t.when {\n-\t\t\t\t\tnewStatus = timerModifiedEarlier\n-\t\t\t\t\tatomic.Xadd(&t.pp.ptr().adjustTimers, 1)\n-\t\t\t\t}\n-\t\t\t\tif !atomic.Cas(&t.status, timerModifying, newStatus) {\n-\t\t\t\t\tbadTimer()\n-\t\t\t\t}\n-\t\t\t\tatomic.Xadd(&tpp.deletedTimers, -1)\n-\t\t\t\tif newStatus == timerModifiedEarlier {\n-\t\t\t\t\twakeNetPoller(when)\n-\t\t\t\t}\n-\t\t\t\treturn\n-\t\t\t}\n-\t\tcase timerRemoving:\n-\t\t\t// Wait for the removal to complete.\n-\t\t\tosyield()\n-\t\tcase timerRunning:\n-\t\t\t// Even though the timer should not be active,\n-\t\t\t// we can see timerRunning if the timer function\n-\t\t\t// permits some other goroutine to call resettimer.\n-\t\t\t// Wait until the run is complete.\n-\t\t\tosyield()\n-\t\tcase timerWaiting, timerModifying, timerModifiedEarlier, timerModifiedLater, timerMoving:\n-\t\t\t// Called resettimer on active timer.\n-\t\t\tbadTimer()\n-\t\tdefault:\n-\t\t\tbadTimer()\n-\t\t}\n-\t}\n+\tmodtimer(t, when, t.period, t.f, t.arg, t.seq)\n }\n \n // cleantimers cleans up the head of the timer queue. This speeds up\n // programs that create and delete timers; leaving them in the heap\n // slows down addtimer. Reports whether no timer problems were found.\n // The caller must have locked the timers for pp.\n-func cleantimers(pp *p) bool {\n+func cleantimers(pp *p) {\n \tfor {\n \t\tif len(pp.timers) == 0 {\n-\t\t\treturn true\n+\t\t\treturn\n \t\t}\n \t\tt := pp.timers[0]\n \t\tif t.pp.ptr() != pp {\n@@ -557,11 +531,9 @@ func cleantimers(pp *p) bool {\n \t\t\tif !atomic.Cas(&t.status, s, timerRemoving) {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif !dodeltimer0(pp) {\n-\t\t\t\treturn false\n-\t\t\t}\n+\t\t\tdodeltimer0(pp)\n \t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n-\t\t\t\treturn false\n+\t\t\t\tbadTimer()\n \t\t\t}\n \t\t\tatomic.Xadd(&pp.deletedTimers, -1)\n \t\tcase timerModifiedEarlier, timerModifiedLater:\n@@ -571,21 +543,17 @@ func cleantimers(pp *p) bool {\n \t\t\t// Now we can change the when field.\n \t\t\tt.when = t.nextwhen\n \t\t\t// Move t to the right position.\n-\t\t\tif !dodeltimer0(pp) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\tif !doaddtimer(pp, t) {\n-\t\t\t\treturn false\n-\t\t\t}\n+\t\t\tdodeltimer0(pp)\n+\t\t\tdoaddtimer(pp, t)\n \t\t\tif s == timerModifiedEarlier {\n \t\t\t\tatomic.Xadd(&pp.adjustTimers, -1)\n \t\t\t}\n \t\t\tif !atomic.Cas(&t.status, timerMoving, timerWaiting) {\n-\t\t\t\treturn false\n+\t\t\t\tbadTimer()\n \t\t\t}\n \t\tdefault:\n \t\t\t// Head of timers does not need adjustment.\n-\t\t\treturn true\n+\t\t\treturn\n \t\t}\n \t}\n }\n@@ -601,19 +569,15 @@ func moveTimers(pp *p, timers []*timer) {\n \t\t\tswitch s := atomic.Load(&t.status); s {\n \t\t\tcase timerWaiting:\n \t\t\t\tt.pp = 0\n-\t\t\t\tif !doaddtimer(pp, t) {\n-\t\t\t\t\tbadTimer()\n-\t\t\t\t}\n+\t\t\t\tdoaddtimer(pp, t)\n \t\t\t\tbreak loop\n \t\t\tcase timerModifiedEarlier, timerModifiedLater:\n \t\t\t\tif !atomic.Cas(&t.status, s, timerMoving) {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tt.when = t.nextwhen\n \t\t\t\tt.pp = 0\n-\t\t\t\tif !doaddtimer(pp, t) {\n-\t\t\t\t\tbadTimer()\n-\t\t\t\t}\n+\t\t\t\tdoaddtimer(pp, t)\n \t\t\t\tif !atomic.Cas(&t.status, timerMoving, timerWaiting) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n@@ -667,9 +631,7 @@ loop:\n \t\tswitch s := atomic.Load(&t.status); s {\n \t\tcase timerDeleted:\n \t\t\tif atomic.Cas(&t.status, s, timerRemoving) {\n-\t\t\t\tif !dodeltimer(pp, i) {\n-\t\t\t\t\tbadTimer()\n-\t\t\t\t}\n+\t\t\t\tdodeltimer(pp, i)\n \t\t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n@@ -685,9 +647,7 @@ loop:\n \t\t\t\t// We don't add it back yet because the\n \t\t\t\t// heap manipulation could cause our\n \t\t\t\t// loop to skip some other timer.\n-\t\t\t\tif !dodeltimer(pp, i) {\n-\t\t\t\t\tbadTimer()\n-\t\t\t\t}\n+\t\t\t\tdodeltimer(pp, i)\n \t\t\t\tmoved = append(moved, t)\n \t\t\t\tif s == timerModifiedEarlier {\n \t\t\t\t\tif n := atomic.Xadd(&pp.adjustTimers, -1); int32(n) <= 0 {\n@@ -723,9 +683,7 @@ loop:\n // back to the timer heap.\n func addAdjustedTimers(pp *p, moved []*timer) {\n \tfor _, t := range moved {\n-\t\tif !doaddtimer(pp, t) {\n-\t\t\tbadTimer()\n-\t\t}\n+\t\tdoaddtimer(pp, t)\n \t\tif !atomic.Cas(&t.status, timerMoving, timerWaiting) {\n \t\t\tbadTimer()\n \t\t}\n@@ -779,9 +737,7 @@ func runtimer(pp *p, now int64) int64 {\n \t\t\tif !atomic.Cas(&t.status, s, timerRemoving) {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif !dodeltimer0(pp) {\n-\t\t\t\tbadTimer()\n-\t\t\t}\n+\t\t\tdodeltimer0(pp)\n \t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n \t\t\t\tbadTimer()\n \t\t\t}\n@@ -795,12 +751,8 @@ func runtimer(pp *p, now int64) int64 {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tt.when = t.nextwhen\n-\t\t\tif !dodeltimer0(pp) {\n-\t\t\t\tbadTimer()\n-\t\t\t}\n-\t\t\tif !doaddtimer(pp, t) {\n-\t\t\t\tbadTimer()\n-\t\t\t}\n+\t\t\tdodeltimer0(pp)\n+\t\t\tdoaddtimer(pp, t)\n \t\t\tif s == timerModifiedEarlier {\n \t\t\t\tatomic.Xadd(&pp.adjustTimers, -1)\n \t\t\t}\n@@ -838,18 +790,14 @@ func runOneTimer(pp *p, t *timer, now int64) {\n \t\t// Leave in heap but adjust next time to fire.\n \t\tdelta := t.when - now\n \t\tt.when += t.period * (1 + -delta/t.period)\n-\t\tif !siftdownTimer(pp.timers, 0) {\n-\t\t\tbadTimer()\n-\t\t}\n+\t\tsiftdownTimer(pp.timers, 0)\n \t\tif !atomic.Cas(&t.status, timerRunning, timerWaiting) {\n \t\t\tbadTimer()\n \t\t}\n \t\tupdateTimer0When(pp)\n \t} else {\n \t\t// Remove from heap.\n-\t\tif !dodeltimer0(pp) {\n-\t\t\tbadTimer()\n-\t\t}\n+\t\tdodeltimer0(pp)\n \t\tif !atomic.Cas(&t.status, timerRunning, timerNoStatus) {\n \t\t\tbadTimer()\n \t\t}\n@@ -1053,9 +1001,9 @@ func timeSleepUntil() (int64, *p) {\n // \"panic holding locks\" message. Instead, we panic while not\n // holding a lock.\n \n-func siftupTimer(t []*timer, i int) bool {\n+func siftupTimer(t []*timer, i int) {\n \tif i >= len(t) {\n-\t\treturn false\n+\t\tbadTimer()\n \t}\n \twhen := t[i].when\n \ttmp := t[i]\n@@ -1070,13 +1018,12 @@ func siftupTimer(t []*timer, i int) bool {\n \tif tmp != t[i] {\n \t\tt[i] = tmp\n \t}\n-\treturn true\n }\n \n-func siftdownTimer(t []*timer, i int) bool {\n+func siftdownTimer(t []*timer, i int) {\n \tn := len(t)\n \tif i >= n {\n-\t\treturn false\n+\t\tbadTimer()\n \t}\n \twhen := t[i].when\n \ttmp := t[i]\n@@ -1111,13 +1058,12 @@ func siftdownTimer(t []*timer, i int) bool {\n \tif tmp != t[i] {\n \t\tt[i] = tmp\n \t}\n-\treturn true\n }\n \n // badTimer is called if the timer data structures have been corrupted,\n // presumably due to racy use by the program. We panic here rather than\n // panicing due to invalid slice access while holding locks.\n // See issue #25686.\n func badTimer() {\n-\tpanic(errorString(\"racy use of timers\"))\n+\tthrow(\"timer data corruption\")\n }"}, {"sha": "758af7487c7665eeb0f063be80d7ac8957aea864", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -963,16 +963,15 @@ func tRunner(t *T, fn func(t *T)) {\n \t\t\t\tt.Logf(\"cleanup panicked with %v\", r)\n \t\t\t}\n \t\t\t// Flush the output log up to the root before dying.\n-\t\t\tt.mu.Lock()\n-\t\t\troot := &t.common\n-\t\t\tfor ; root.parent != nil; root = root.parent {\n+\t\t\tfor root := &t.common; root.parent != nil; root = root.parent {\n+\t\t\t\troot.mu.Lock()\n \t\t\t\troot.duration += time.Since(root.start)\n-\t\t\t\tfmt.Fprintf(root.parent.w, \"--- FAIL: %s (%s)\\n\", root.name, fmtDuration(root.duration))\n+\t\t\t\td := root.duration\n+\t\t\t\troot.mu.Unlock()\n+\t\t\t\troot.flushToParent(\"--- FAIL: %s (%s)\\n\", root.name, fmtDuration(d))\n \t\t\t\tif r := root.parent.runCleanup(recoverAndReturnPanic); r != nil {\n \t\t\t\t\tfmt.Fprintf(root.parent.w, \"cleanup panicked with %v\", r)\n \t\t\t\t}\n-\t\t\t\troot.parent.mu.Lock()\n-\t\t\t\tio.Copy(root.parent.w, bytes.NewReader(root.output))\n \t\t\t}\n \t\t\tpanic(err)\n \t\t}"}, {"sha": "2fc23c4feebc0ad4f6c6dd1028c79bb13effa9d0", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"encoding/gob\"\n \t\"encoding/json\"\n \t\"fmt\"\n-\t\"internal/race\"\n \t\"math/big\"\n \t\"math/rand\"\n \t\"os\"\n@@ -1393,36 +1392,45 @@ func TestReadFileLimit(t *testing.T) {\n }\n \n // Issue 25686: hard crash on concurrent timer access.\n+// Issue 37400: panic with \"racy use of timers\"\n // This test deliberately invokes a race condition.\n-// We are testing that we don't crash with \"fatal error: panic holding locks\".\n+// We are testing that we don't crash with \"fatal error: panic holding locks\",\n+// and that we also don't panic.\n func TestConcurrentTimerReset(t *testing.T) {\n-\tif race.Enabled {\n-\t\tt.Skip(\"skipping test under race detector\")\n-\t}\n-\n-\t// We expect this code to panic rather than crash.\n-\t// Don't worry if it doesn't panic.\n-\tcatch := func(i int) {\n-\t\tif e := recover(); e != nil {\n-\t\t\tt.Logf(\"panic in goroutine %d, as expected, with %q\", i, e)\n-\t\t} else {\n-\t\t\tt.Logf(\"no panic in goroutine %d\", i)\n-\t\t}\n+\tconst goroutines = 8\n+\tconst tries = 1000\n+\tvar wg sync.WaitGroup\n+\twg.Add(goroutines)\n+\ttimer := NewTimer(Hour)\n+\tfor i := 0; i < goroutines; i++ {\n+\t\tgo func(i int) {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor j := 0; j < tries; j++ {\n+\t\t\t\ttimer.Reset(Hour + Duration(i*j))\n+\t\t\t}\n+\t\t}(i)\n \t}\n+\twg.Wait()\n+}\n \n+// Issue 37400: panic with \"racy use of timers\".\n+func TestConcurrentTimerResetStop(t *testing.T) {\n \tconst goroutines = 8\n \tconst tries = 1000\n \tvar wg sync.WaitGroup\n-\twg.Add(goroutines)\n+\twg.Add(goroutines * 2)\n \ttimer := NewTimer(Hour)\n \tfor i := 0; i < goroutines; i++ {\n \t\tgo func(i int) {\n \t\t\tdefer wg.Done()\n-\t\t\tdefer catch(i)\n \t\t\tfor j := 0; j < tries; j++ {\n \t\t\t\ttimer.Reset(Hour + Duration(i*j))\n \t\t\t}\n \t\t}(i)\n+\t\tgo func(i int) {\n+\t\t\tdefer wg.Done()\n+\t\t\ttimer.Stop()\n+\t\t}(i)\n \t}\n \twg.Wait()\n }"}, {"sha": "a3bdb9484996d58ec5cd4dff7e235c43a22e7196", "filename": "libgo/libgo-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Flibgo-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Flibgo-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Flibgo-packages.txt?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -123,6 +123,7 @@ internal/poll\n internal/race\n internal/reflectlite\n internal/singleflight\n+internal/syscall/execenv\n internal/syscall/unix\n internal/testenv\n internal/testlog"}, {"sha": "a210eb5bc5b45a9c16c3c97a859c172622af2850", "filename": "libgo/misc/cgo/testgodefs/testdata/issue37479.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37479.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37479.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37479.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+//\n+// +build ignore\n+\n+package main\n+\n+/*\n+typedef struct A A;\n+\n+typedef struct {\n+\tstruct A *next;\n+\tstruct A **prev;\n+} N;\n+\n+struct A\n+{\n+\tN n;\n+};\n+\n+typedef struct B\n+{\n+\tA* a;\n+} B;\n+*/\n+import \"C\"\n+\n+type N C.N\n+\n+type A C.A\n+\n+type B C.B"}, {"sha": "d5ace3f6d6da7d4155418279d89f3d09208933fb", "filename": "libgo/misc/cgo/testgodefs/testdata/issue37621.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37621.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37621.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fissue37621.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+//\n+// +build ignore\n+\n+package main\n+\n+/*\n+struct tt {\n+\tlong long a;\n+\tlong long b;\n+};\n+\n+struct s {\n+\tstruct tt ts[3];\n+};\n+*/\n+import \"C\"\n+\n+type TT C.struct_tt\n+\n+type S C.struct_s"}, {"sha": "ef45b95e6553e34bc51385fb68c5574993885a10", "filename": "libgo/misc/cgo/testgodefs/testdata/main.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestdata%2Fmain.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -11,5 +11,13 @@ var v2 = v1.L\n // Test that P, Q, and R all point to byte.\n var v3 = Issue8478{P: (*byte)(nil), Q: (**byte)(nil), R: (***byte)(nil)}\n \n+// Test that N, A and B are fully defined\n+var v4 = N{}\n+var v5 = A{}\n+var v6 = B{}\n+\n+// Test that S is fully defined\n+var v7 = S{}\n+\n func main() {\n }"}, {"sha": "438d23d65c068f0d44d5af88495cc380483f8b8e", "filename": "libgo/misc/cgo/testgodefs/testgodefs_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestgodefs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestgodefs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftestgodefs_test.go?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -21,6 +21,8 @@ var filePrefixes = []string{\n \t\"anonunion\",\n \t\"issue8478\",\n \t\"fieldtypedef\",\n+\t\"issue37479\",\n+\t\"issue37621\",\n }\n \n func TestGoDefs(t *testing.T) {"}, {"sha": "31783696a08231226d550be32e72d61224d27cfd", "filename": "libgo/runtime/go-callers.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fruntime%2Fgo-callers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fa80f853c0b0f623ea9e4c7198e324ce44ff30/libgo%2Fruntime%2Fgo-callers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-callers.c?ref=52fa80f853c0b0f623ea9e4c7198e324ce44ff30", "patch": "@@ -364,3 +364,39 @@ runtime_callersRaw (uintptr *pcbuf, int32 m)\n   return data.index;\n }\n \n+/* runtime_pcInlineCallers returns the inline stack of calls for a PC.\n+   This is like runtime_callers, but instead of doing a backtrace,\n+   just finds the information for a single PC value.  */\n+\n+int32 runtime_pcInlineCallers (uintptr, Location *, int32)\n+  __asm__ (GOSYM_PREFIX \"runtime.pcInlineCallers\");\n+\n+int32\n+runtime_pcInlineCallers (uintptr pc, Location *locbuf, int32 m)\n+{\n+  struct callers_data data;\n+  struct backtrace_state *state;\n+  int32 i;\n+\n+  data.locbuf = locbuf;\n+  data.skip = 0;\n+  data.index = 0;\n+  data.max = m;\n+  data.keep_thunks = false;\n+  data.saw_sigtramp = 0;\n+  runtime_xadd (&__go_runtime_in_callers, 1);\n+  state = __go_get_backtrace_state ();\n+  backtrace_pcinfo (state, pc, callback, error_callback, &data);\n+  runtime_xadd (&__go_runtime_in_callers, -1);\n+\n+  /* Try to use backtrace_syminfo to fill in missing names.  See\n+     runtime_callers.  */\n+  for (i = 0; i < data.index; ++i)\n+    {\n+      if (locbuf[i].function.len == 0 && locbuf[i].pc != 0)\n+\tbacktrace_syminfo (state, locbuf[i].pc, __go_syminfo_fnname_callback,\n+\t\t\t   error_callback, &locbuf[i].function);\n+    }\n+\n+  return data.index;\n+}"}]}