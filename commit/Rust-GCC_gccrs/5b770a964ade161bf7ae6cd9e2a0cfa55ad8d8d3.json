{"sha": "5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3NzBhOTY0YWRlMTYxYmY3YWU2Y2Q5ZTJhMGNmYTU1YWQ4ZDhkMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-08-23T00:28:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-08-23T00:28:29Z"}, "message": "typeck.c (build_class_member_access_expr): Handle COMPOUND_EXPR and COND_EXPR specially; fix error message output.\n\n\t* typeck.c (build_class_member_access_expr): Handle COMPOUND_EXPR\n\tand COND_EXPR specially; fix error message output.\n\n\t* testsuite/g++.dg/inherit/cond1.C: New test.\n\nFrom-SVN: r56524", "tree": {"sha": "9cc24570bcc521efa7653573ea5eac21dd59fe34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cc24570bcc521efa7653573ea5eac21dd59fe34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/comments", "author": null, "committer": null, "parents": [{"sha": "d65b1d77fdef0c19ef451f82b234beb2491bb866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d65b1d77fdef0c19ef451f82b234beb2491bb866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d65b1d77fdef0c19ef451f82b234beb2491bb866"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "cb95b6d33b79cb2397786196edd7547eca7fccbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "patch": "@@ -1,3 +1,8 @@\n+2002-08-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* typeck.c (build_class_member_access_expr): Handle COMPOUND_EXPR\n+\tand COND_EXPR specially; fix error message output.\n+\n 2002-08-22  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst_expr): RETURN_EXPR is now RETURN_STMT_EXPR."}, {"sha": "624b379cf7165da0e0c96fbfe4782e530432723f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "patch": "@@ -1859,6 +1859,27 @@ build_class_member_access_expr (tree object, tree member,\n   my_friendly_assert (DECL_P (member) || BASELINK_P (member),\n \t\t      20020801);\n \n+  /* Transform `(a, b).x' into `a, b.x' and `(a ? b : c).x' into \n+     `a ? b.x : c.x'.  These transformations should not really be\n+     necessary, but they are.  */\n+  if (TREE_CODE (object) == COMPOUND_EXPR)\n+    {\n+      result = build_class_member_access_expr (TREE_OPERAND (object, 1),\n+\t\t\t\t\t       member, access_path, \n+\t\t\t\t\t       preserve_reference);\n+      return build (COMPOUND_EXPR, TREE_TYPE (result), \n+\t\t    TREE_OPERAND (object, 0), result);\n+    }\n+  else if (TREE_CODE (object) == COND_EXPR)\n+    return (build_conditional_expr\n+\t    (TREE_OPERAND (object, 0),\n+\t     build_class_member_access_expr (TREE_OPERAND (object, 1),\n+\t\t\t\t\t     member, access_path,\n+\t\t\t\t\t     preserve_reference),\n+\t     build_class_member_access_expr (TREE_OPERAND (object, 2),\n+\t\t\t\t\t     member, access_path,\n+\t\t\t\t\t     preserve_reference)));\n+\n   /* [expr.ref]\n \n      The type of the first expression shall be \"class object\" (of a\n@@ -2135,7 +2156,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n \t      error (\"`%D::%D' is not a member of `%T'\", \n-\t\t     scope, member, object_type);\n+\t\t     scope, name, object_type);\n \t      return error_mark_node;\n \t    }\n "}, {"sha": "00a92134d458f17ea7d1387fda01c8396cd5dbed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "patch": "@@ -1,3 +1,7 @@\n+2002-08-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* testsuite/g++.dg/inherit/cond1.C: New test.\n+\n 2002-08-22  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* gcc.dg/noncompile/incomplete-1.c: New test."}, {"sha": "843c72ca308c85886cde8326c37a9e95e36c66f1", "filename": "gcc/testsuite/g++.dg/inherit/cond1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcond1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcond1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcond1.C?ref=5b770a964ade161bf7ae6cd9e2a0cfa55ad8d8d3", "patch": "@@ -0,0 +1,10 @@\n+// Origin: jason@redhat.com\n+// { dg-do compile }\n+\n+struct A { A(); A(const A&); int i; };\n+struct B: public A { };\n+\n+int f (bool b, A& ar, B& br)\n+{\n+  return (b?ar:br).i;\n+}"}]}