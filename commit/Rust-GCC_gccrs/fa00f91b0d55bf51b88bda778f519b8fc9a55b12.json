{"sha": "fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEwMGY5MWIwZDU1YmY1MWI4OGJkYTc3OGY1MTliOGZjOWE1NWIxMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-06-19T14:57:17Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-06-19T14:57:17Z"}, "message": "re PR target/27861 (ICE in expand_expr_real_1, at expr.c:6916)\n\n\n\tPR target/27861\n\t* expmed.c (expand_shift): On SHIFT_COUNT_TRUNCATED targets, we may\n\thave stripped a SUBREG from the shift count, so we may need to\n\tconvert_to_mode back to the type's mode before calling make_tree.\n\tUse new_amount instead of amount to avoid expanding a tree twice.\n\n\t* gcc.dg/pr27861-1.c: New test case.\n\nFrom-SVN: r114773", "tree": {"sha": "c8e8a3185728aab4a7f079fa123272dd2738ec55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e8a3185728aab4a7f079fa123272dd2738ec55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/comments", "author": null, "committer": null, "parents": [{"sha": "096dce1b1bf69529a83de92dc17018c82b7b22ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096dce1b1bf69529a83de92dc17018c82b7b22ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096dce1b1bf69529a83de92dc17018c82b7b22ec"}], "stats": {"total": 90, "additions": 87, "deletions": 3}, "files": [{"sha": "11091f0ff1a911f28367c0ce48ff7cb446baec34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "patch": "@@ -1,3 +1,11 @@\n+2006-06-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR target/27861\n+\t* expmed.c (expand_shift): On SHIFT_COUNT_TRUNCATED targets, we may\n+\thave stripped a SUBREG from the shift count, so we may need to\n+\tconvert_to_mode back to the type's mode before calling make_tree.\n+\tUse new_amount instead of amount to avoid expanding a tree twice.\n+\n 2006-06-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/28045"}, {"sha": "6f4e331154658c4376292f8332a092cb78151792", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "patch": "@@ -2260,13 +2260,17 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t\t code below.  */\n \n \t      rtx subtarget = target == shifted ? 0 : target;\n+\t      tree new_amount, other_amount;\n \t      rtx temp1;\n \t      tree type = TREE_TYPE (amount);\n-\t      tree new_amount = make_tree (type, op1);\n-\t      tree other_amount\n+\t      if (GET_MODE (op1) != TYPE_MODE (type)\n+\t\t  && GET_MODE (op1) != VOIDmode)\n+\t\top1 = convert_to_mode (TYPE_MODE (type), op1, 1);\n+\t      new_amount = make_tree (type, op1);\n+\t      other_amount\n \t\t= fold_build2 (MINUS_EXPR, type,\n \t\t\t       build_int_cst (type, GET_MODE_BITSIZE (mode)),\n-\t\t\t       amount);\n+\t\t\t       new_amount);\n \n \t      shifted = force_reg (mode, shifted);\n "}, {"sha": "888e45a572a8ec0119f5483165446805307bc344", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "patch": "@@ -1,3 +1,8 @@\n+2006-06-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR target/27861\n+\t* gcc.dg/pr27861-1.c: New test case.\n+\n 2006-06-19  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/28045"}, {"sha": "cf269dc0ae551ddebbb9608298a51606d2eed2f1", "filename": "gcc/testsuite/gcc.dg/pr27861-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27861-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa00f91b0d55bf51b88bda778f519b8fc9a55b12/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27861-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27861-1.c?ref=fa00f91b0d55bf51b88bda778f519b8fc9a55b12", "patch": "@@ -0,0 +1,67 @@\n+/* PR target/27861 */\n+/* The following code used to cause an ICE during RTL expansion, as\n+   expand shift was stripping the SUBREG of a rotate shift count, and\n+   later producing a VAR_DECL tree whose DECL_RTL's mode didn't match\n+   the VAR_DECL's type's mode.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+typedef struct sim_state *SIM_DESC;\n+typedef enum\n+{\n+  SIM_OPEN_STANDALONE, SIM_OPEN_DEBUG\n+}\n+SIM_RC;\n+typedef unsigned int unsigned32 __attribute__ ((__mode__ (__SI__)));\n+typedef unsigned int unsigned64 __attribute__ ((__mode__ (__DI__)));\n+typedef unsigned32 unsigned_address;\n+typedef unsigned_address address_word;\n+static __inline__ unsigned64\n+  __attribute__ ((__unused__)) ROTR64 (unsigned64 val, int shift)\n+{\n+  unsigned64 result;\n+  result = (((val) >> (shift)) | ((val) << ((64) - (shift))));\n+  return result;\n+}\n+typedef struct _sim_cpu sim_cpu;\n+enum\n+{\n+    TRACE_MEMORY_IDX, TRACE_MODEL_IDX, TRACE_ALU_IDX, TRACE_CORE_IDX,\n+};\n+typedef struct _trace_data\n+{\n+  char trace_flags[32];\n+}\n+TRACE_DATA;\n+typedef enum\n+{\n+    nr_watchpoint_types,\n+}\n+watchpoint_type;\n+typedef struct _sim_watchpoints\n+{\n+  TRACE_DATA trace_data;\n+}\n+sim_cpu_base;\n+struct _sim_cpu\n+{\n+  sim_cpu_base base;\n+};\n+struct sim_state\n+{\n+  sim_cpu cpu[1];\n+};\n+typedef address_word instruction_address;\n+do_dror (SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned64 x,\n+\t unsigned64 y)\n+{\n+  unsigned64 result;\n+  result = ROTR64 (x, y);\n+    {\n+      if ((((-1) & (1 << (TRACE_ALU_IDX))) != 0\n+\t   && (((&(((&(sd)->cpu[0])))->base.trace_data))->\n+\t       trace_flags)[TRACE_ALU_IDX] != 0))\n+\ttrace_result_word1 (sd, ((&(sd)->cpu[0])), TRACE_ALU_IDX, (result));\n+    }\n+}\n+"}]}