{"sha": "9781b6dabd95da9b390eaffe878fb883d10d9e74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc4MWI2ZGFiZDk1ZGE5YjM5MGVhZmZlODc4ZmI4ODNkMTBkOWU3NA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-01-31T02:18:25Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-01-31T02:18:25Z"}, "message": "ggc-zone.c (ggc_free): New function.\n\n2003-01-30  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* ggc-zone.c (ggc_free): New function.\n\nFrom-SVN: r77019", "tree": {"sha": "61737e5c49c00ed5d979ac9af802fa5f8e8f2a48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61737e5c49c00ed5d979ac9af802fa5f8e8f2a48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9781b6dabd95da9b390eaffe878fb883d10d9e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9781b6dabd95da9b390eaffe878fb883d10d9e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9781b6dabd95da9b390eaffe878fb883d10d9e74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9781b6dabd95da9b390eaffe878fb883d10d9e74/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "283334f01103fd6de2b635af2261b035388762ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283334f01103fd6de2b635af2261b035388762ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283334f01103fd6de2b635af2261b035388762ff"}], "stats": {"total": 37, "additions": 30, "deletions": 7}, "files": [{"sha": "5c7792346dd643ab17c0fe0ee3d8c6aed1b8eef2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9781b6dabd95da9b390eaffe878fb883d10d9e74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9781b6dabd95da9b390eaffe878fb883d10d9e74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9781b6dabd95da9b390eaffe878fb883d10d9e74", "patch": "@@ -1,3 +1,7 @@\n+2003-01-30  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* ggc-zone.c (ggc_free): New function.\n+\n 2004-01-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \talloc-pool.c, c-lex.c, c-pragma.h, c-semantics.c, cfghooks.c,"}, {"sha": "bc7a4cd899b91efcacf0050e8835a4d0971fd874", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9781b6dabd95da9b390eaffe878fb883d10d9e74/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9781b6dabd95da9b390eaffe878fb883d10d9e74/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=9781b6dabd95da9b390eaffe878fb883d10d9e74", "patch": "@@ -126,6 +126,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef HOST_BITS_PER_PTR\n #define HOST_BITS_PER_PTR  HOST_BITS_PER_LONG\n #endif\n+\n #ifdef COOKIE_CHECKING\n #define CHUNK_MAGIC 0x95321123\n #define DEADCHUNK_MAGIC 0x12817317\n@@ -734,6 +735,31 @@ ggc_alloc_zone (size_t size, struct alloc_zone *zone)\n   return ggc_alloc_zone_1 (size, zone, -1);\n }\n \n+/* Poison the chunk.  */\n+#ifdef ENABLE_GC_CHECKING\n+#define poison_chunk(CHUNK, SIZE) \\\n+  memset ((CHUNK)->u.data, 0xa5, (SIZE))\n+#else\n+#define poison_chunk(CHUNK, SIZE)\n+#endif\n+\n+/* Free the object at P.  */\n+\n+void\n+ggc_free (void *p)\n+{\n+  struct alloc_chunk *chunk;\n+  \n+  chunk = (struct alloc_chunk *) ((char *)p - CHUNK_OVERHEAD);\n+  \n+  /* Poison the chunk.  */\n+  poison_chunk (chunk, ggc_get_size (p));\n+\n+  /* XXX: We only deal with explicitly freeing large objects ATM.  */\n+  if (chunk->large)\n+    free (p);\n+}\n+\n /* If P is not marked, mark it and return false.  Otherwise return true.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */\n@@ -931,13 +957,6 @@ ggc_pop_context (void)\n   for (zone = G.zones; zone; zone = zone->next_zone)\n     ggc_pop_context_1 (zone);\n }\n-/* Poison the chunk.  */\n-#ifdef ENABLE_GC_CHECKING\n-#define poison_chunk(CHUNK, SIZE) \\\n-  memset ((CHUNK)->u.data, 0xa5, (SIZE))\n-#else\n-#define poison_chunk(CHUNK, SIZE)\n-#endif\n \n /* Free all empty pages and objects within a page for a given zone  */\n "}]}