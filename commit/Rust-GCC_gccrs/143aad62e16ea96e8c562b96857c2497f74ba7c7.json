{"sha": "143aad62e16ea96e8c562b96857c2497f74ba7c7", "node_id": "C_kwDOANBUbNoAKDE0M2FhZDYyZTE2ZWE5NmU4YzU2MmI5Njg1N2MyNDk3Zjc0YmE3Yzc", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-21T09:48:00Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-22T11:05:58Z"}, "message": "substitute_repetition: Add parsing of repetition pattern", "tree": {"sha": "7ed8c0d23acc92be08d775ed9512b848f7f3149b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ed8c0d23acc92be08d775ed9512b848f7f3149b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/143aad62e16ea96e8c562b96857c2497f74ba7c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143aad62e16ea96e8c562b96857c2497f74ba7c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143aad62e16ea96e8c562b96857c2497f74ba7c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143aad62e16ea96e8c562b96857c2497f74ba7c7/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae1f91a698022a5600a2d54e48fc90895ea834fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1f91a698022a5600a2d54e48fc90895ea834fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1f91a698022a5600a2d54e48fc90895ea834fd"}], "stats": {"total": 71, "additions": 62, "deletions": 9}, "files": [{"sha": "7aa4289ec6b15412297edcf92c01045bd5fd5e12", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143aad62e16ea96e8c562b96857c2497f74ba7c7/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143aad62e16ea96e8c562b96857c2497f74ba7c7/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=143aad62e16ea96e8c562b96857c2497f74ba7c7", "patch": "@@ -3905,20 +3905,58 @@ MacroExpander::substitute_metavar (\n   return expanded;\n }\n \n+std::vector<std::unique_ptr<AST::Token>>\n+MacroExpander::substitute_repetition (\n+  std::vector<std::unique_ptr<AST::Token>> &input,\n+  std::map<std::string, MatchedFragment> &fragments,\n+  std::vector<std::unique_ptr<AST::Token>> &pattern)\n+{\n+  // If the repetition is not anything we know (ie no declared metavars, or\n+  // metavars which aren't present in the fragment), we can just error out. No\n+  // need to paste the tokens as if nothing had happened.\n+  for (auto &token : pattern)\n+    rust_debug (\"[repetition pattern]: %s\", token->as_string ().c_str ());\n+\n+  return std::vector<std::unique_ptr<AST::Token>> ();\n+}\n+\n std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n MacroExpander::substitute_token (\n+  std::vector<std::unique_ptr<AST::Token>> &macro,\n   std::vector<std::unique_ptr<AST::Token>> &input,\n-  std::map<std::string, MatchedFragment> &fragments,\n-  std::unique_ptr<AST::Token> &token)\n+  std::map<std::string, MatchedFragment> &fragments, size_t token_idx)\n {\n+  auto &token = macro.at (token_idx);\n   switch (token->get_id ())\n     {\n     case IDENTIFIER:\n       rust_debug (\"expanding metavar\");\n       return {substitute_metavar (input, fragments, token), 1};\n-    case LEFT_PAREN:\n-      rust_debug (\"expanding repetition\");\n-      break;\n+      case LEFT_PAREN: {\n+\t// We need to parse up until the closing delimiter and expand this\n+\t// fragment->n times.\n+\trust_debug (\"expanding repetition\");\n+\tstd::vector<std::unique_ptr<AST::Token>> repetition_pattern;\n+\tfor (size_t rep_idx = token_idx + 1;\n+\t     rep_idx < macro.size ()\n+\t     && macro.at (rep_idx)->get_id () != RIGHT_PAREN;\n+\t     rep_idx++)\n+\t  repetition_pattern.emplace_back (macro.at (rep_idx)->clone_token ());\n+\n+\t// FIXME: This skips whitespaces... Is that okay??\n+\t// FIXME: Is there any existing parsing function that allows us to parse\n+\t// a macro pattern?\n+\n+\t// FIXME: Add error handling in the case we haven't found a matching\n+\t// closing delimiter\n+\n+\t// FIXME: We need to parse the repetition token now\n+\n+\treturn {\n+\t  substitute_repetition (input, fragments, repetition_pattern),\n+\t  // + 2 for the opening and closing parenthesis which are mandatory\n+\t  repetition_pattern.size () + 2};\n+      }\n       // TODO: We need to check if the $ was alone. In that case, do\n       // not error out: Simply act as if there was an empty identifier\n       // with no associated fragment and paste the dollar sign in the\n@@ -3956,10 +3994,9 @@ MacroExpander::substitute_tokens (\n       auto &tok = macro.at (i);\n       if (tok->get_id () == DOLLAR_SIGN)\n \t{\n-\t  auto &next_tok = macro.at (i + 1);\n \t  // Aaaaah, if only we had C++17 :)\n \t  // auto [expanded, tok_to_skip] = ...\n-\t  auto p = substitute_token (input, fragments, next_tok);\n+\t  auto p = substitute_token (macro, input, fragments, i + 1);\n \t  auto expanded = std::move (p.first);\n \t  auto tok_to_skip = p.second;\n "}, {"sha": "943115dcdcd3d32e5b208beec67585fab101d6bc", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143aad62e16ea96e8c562b96857c2497f74ba7c7/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143aad62e16ea96e8c562b96857c2497f74ba7c7/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=143aad62e16ea96e8c562b96857c2497f74ba7c7", "patch": "@@ -199,9 +199,24 @@ struct MacroExpander\n \t\t      std::map<std::string, MatchedFragment> &fragments,\n \t\t      std::unique_ptr<AST::Token> &metavar);\n \n+  /**\n+   * Substitute a macro repetition by its given fragments\n+   *\n+   * @param input Tokens given to the transcribing context\n+   * @param fragments Fragments given to the macro substitution\n+   * @param repetition Set of tokens to substitute and replace\n+   *\n+   * @return A vector containing the repeated pattern\n+   */\n+  static std::vector<std::unique_ptr<AST::Token>>\n+  substitute_repetition (std::vector<std::unique_ptr<AST::Token>> &input,\n+\t\t\t std::map<std::string, MatchedFragment> &fragments,\n+\t\t\t std::vector<std::unique_ptr<AST::Token>> &pattern);\n+\n   /**\n    * Substitute a given token by its appropriate representation\n    *\n+   * @param macro Tokens used in the macro declaration\n    * @param input Tokens given to the transcribing context\n    * @param fragments Fragments given to the macro substitution\n    * @param token Current token to try and substitute\n@@ -213,9 +228,10 @@ struct MacroExpander\n    * ahead of the input to avoid mis-substitutions\n    */\n   static std::pair<std::vector<std::unique_ptr<AST::Token>>, size_t>\n-  substitute_token (std::vector<std::unique_ptr<AST::Token>> &input,\n+  substitute_token (std::vector<std::unique_ptr<AST::Token>> &macro,\n+\t\t    std::vector<std::unique_ptr<AST::Token>> &input,\n \t\t    std::map<std::string, MatchedFragment> &fragments,\n-\t\t    std::unique_ptr<AST::Token> &token);\n+\t\t    size_t token_idx);\n \n   static std::vector<std::unique_ptr<AST::Token>>\n   substitute_tokens (std::vector<std::unique_ptr<AST::Token>> &input,"}]}