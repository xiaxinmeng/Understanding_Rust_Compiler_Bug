{"sha": "0277fabf2b92ed6e94812a8bd0dba50fd0214836", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI3N2ZhYmYyYjkyZWQ2ZTk0ODEyYThiZDBkYmE1MGZkMDIxNDgzNg==", "commit": {"author": {"name": "Laurynas Biveinis", "email": "laurynas.biveinis@gmail.com", "date": "2010-05-05T10:06:37Z"}, "committer": {"name": "Laurynas Biveinis", "email": "lauras@gcc.gnu.org", "date": "2010-05-05T10:06:37Z"}, "message": "Makefile.in (build/gengtype.o): Add $(HASHTAB_H) to dependencies.\n\n2010-05-05  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n\n\t* Makefile.in (build/gengtype.o): Add $(HASHTAB_H) to\n\tdependencies.\n\n\t* gengtype.h (erro_at_line): Constify pos argument.\n\n\t* gengtype.c: Include hashtab.h.\n\t(enum gc_used): Document GC_MAYBE_POINTED_TO.\n\t(error_at_line): Constify pos argument.\n\t(do_typedef): Initialize p->opt field.\n\t(get_file_gtfilename): Fix comment typo.\n\t(struct walk_type_data): Constify line field.\n\t(get_output_file_for_structure): New function.\n\t(write_local_func_for_structure): Constify orig_s argument.\n\tUse get_output_file_for_structure.\n\t(write_func_for_structure): Use get_output_file_for_structure.\n\t(INDENT): New define.\n\t(dump_pair, dump_type, dump_type_list, dump_typekind)\n\t(dump_gc_used, dump_options, dump_fileloc, dump_type_u_s)\n\t(dump_type_u_a, dump_type_u_param_struct, dump_everything): New\n\tfunctions.\n\t(seen_types): New variable.\n\t(main): New variable do_dump.  Process \"-d\" command line option.\n\tCall dump_everything if dump requested.\n\nFrom-SVN: r159060", "tree": {"sha": "8f252db5124c621e3a820083e4b797d0ce217e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f252db5124c621e3a820083e4b797d0ce217e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0277fabf2b92ed6e94812a8bd0dba50fd0214836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0277fabf2b92ed6e94812a8bd0dba50fd0214836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0277fabf2b92ed6e94812a8bd0dba50fd0214836", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0277fabf2b92ed6e94812a8bd0dba50fd0214836/comments", "author": {"login": "laurynas-biveinis", "id": 58894, "node_id": "MDQ6VXNlcjU4ODk0", "avatar_url": "https://avatars.githubusercontent.com/u/58894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/laurynas-biveinis", "html_url": "https://github.com/laurynas-biveinis", "followers_url": "https://api.github.com/users/laurynas-biveinis/followers", "following_url": "https://api.github.com/users/laurynas-biveinis/following{/other_user}", "gists_url": "https://api.github.com/users/laurynas-biveinis/gists{/gist_id}", "starred_url": "https://api.github.com/users/laurynas-biveinis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/laurynas-biveinis/subscriptions", "organizations_url": "https://api.github.com/users/laurynas-biveinis/orgs", "repos_url": "https://api.github.com/users/laurynas-biveinis/repos", "events_url": "https://api.github.com/users/laurynas-biveinis/events{/privacy}", "received_events_url": "https://api.github.com/users/laurynas-biveinis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0576159e4a7cbc6a20bcd047357f6ecd44c68cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0576159e4a7cbc6a20bcd047357f6ecd44c68cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0576159e4a7cbc6a20bcd047357f6ecd44c68cc"}], "stats": {"total": 336, "additions": 310, "deletions": 26}, "files": [{"sha": "12bc380fa4046f9a9910fcce91ab4e6eef1e9404", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0277fabf2b92ed6e94812a8bd0dba50fd0214836", "patch": "@@ -1,3 +1,29 @@\n+2010-05-05  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n+\n+\t* Makefile.in (build/gengtype.o): Add $(HASHTAB_H) to\n+\tdependencies.\n+\n+\t* gengtype.h (erro_at_line): Constify pos argument.\n+\n+\t* gengtype.c: Include hashtab.h.\n+\t(enum gc_used): Document GC_MAYBE_POINTED_TO.\n+\t(error_at_line): Constify pos argument.\n+\t(do_typedef): Initialize p->opt field.\n+\t(get_file_gtfilename): Fix comment typo.\n+\t(struct walk_type_data): Constify line field.\n+\t(get_output_file_for_structure): New function.\n+\t(write_local_func_for_structure): Constify orig_s argument.\n+\tUse get_output_file_for_structure.\n+\t(write_func_for_structure): Use get_output_file_for_structure.\n+\t(INDENT): New define.\n+\t(dump_pair, dump_type, dump_type_list, dump_typekind)\n+\t(dump_gc_used, dump_options, dump_fileloc, dump_type_u_s)\n+\t(dump_type_u_a, dump_type_u_param_struct, dump_everything): New\n+\tfunctions.\n+\t(seen_types): New variable.\n+\t(main): New variable do_dump.  Process \"-d\" command line option.\n+\tCall dump_everything if dump requested.\n+\n 2010-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* var-tracking.c (var_debug_decl): Save DECL_DEBUG_EXPR value"}, {"sha": "ce6e3a1dc3ed2ac4098a9b31e7454cd025d6ae77", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0277fabf2b92ed6e94812a8bd0dba50fd0214836", "patch": "@@ -3721,7 +3721,7 @@ build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)\n build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n   $(SYSTEM_H)\n build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n-  rtl.def insn-notes.def errors.h double-int.h\n+  rtl.def insn-notes.def errors.h double-int.h $(HASHTAB_H)\n build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) errors.h gensupport.h\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\"}, {"sha": "e98f11cdc8d781e940440b526b2f2dbec5e226ee", "filename": "gcc/gengtype.c", "status": "modified", "additions": 282, "deletions": 24, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=0277fabf2b92ed6e94812a8bd0dba50fd0214836", "patch": "@@ -23,6 +23,7 @@\n #include \"gengtype.h\"\n #include \"errors.h\"\t/* for fatal */\n #include \"double-int.h\"\n+#include \"hashtab.h\"\n \n /* Data types, macros, etc. used only in this file.  */\n \n@@ -73,6 +74,10 @@ enum gc_used_enum\n   {\n     GC_UNUSED = 0,\n     GC_USED,\n+    /* Used for structures whose definitions we haven't seen so far when\n+       we encounter a pointer to it that is annotated with ``maybe_undef''.\n+       If after reading in everything we don't have source file\n+       information for it, we assume that it never has been defined. */\n     GC_MAYBE_POINTED_TO,\n     GC_POINTED_TO\n   };\n@@ -178,7 +183,7 @@ static void close_output_files (void);\n /* Report an error at POS, printing MSG.  */\n \n void\n-error_at_line (struct fileloc *pos, const char *msg, ...)\n+error_at_line (const struct fileloc *pos, const char *msg, ...)\n {\n   va_list ap;\n \n@@ -568,6 +573,7 @@ do_typedef (const char *s, type_p t, struct fileloc *pos)\n   p->name = s;\n   p->type = t;\n   p->line = *pos;\n+  p->opt = NULL;\n   typedefs = p;\n }\n \n@@ -1682,7 +1688,7 @@ get_file_gtfilename (const char *f)\n      : xasprintf (\"gt-%s\", basename));\n \n   /* Then replace all non alphanumerics characters by '-' and change the\n-     extenstion to \".h\".  We expect the input filename extension was at least\n+     extension to \".h\".  We expect the input filename extension was at least\n      one character long.  */\n \n   char *s = result;\n@@ -1897,7 +1903,7 @@ static void write_types (outf_p output_header,\n static void write_types_local_process_field\n      (type_p f, const struct walk_type_data *d);\n static void write_local_func_for_structure\n-     (type_p orig_s, type_p s, type_p * param);\n+     (const_type_p orig_s, type_p s, type_p * param);\n static void write_local (outf_p output_header,\n                          type_p structures,\n \t\t\t type_p param_structs);\n@@ -1925,7 +1931,7 @@ struct walk_type_data\n   const char *prev_val[4];\n   int indent;\n   int counter;\n-  struct fileloc *line;\n+  const struct fileloc *line;\n   lang_bitmap bitmap;\n   type_p *param;\n   int used_length;\n@@ -2534,6 +2540,24 @@ output_type_enum (outf_p of, type_p s)\n     oprintf (of, \", gt_types_enum_last\");\n }\n \n+/* Return an output file that is suitable for definitions which can\n+   reference struct S */\n+\n+static outf_p\n+get_output_file_for_structure (const_type_p s, type_p *param)\n+{\n+  const char * fn = s->u.s.line.file;\n+  int i;\n+\n+  /* This is a hack, and not the good kind either.  */\n+  for (i = NUM_PARAM - 1; i >= 0; i--)\n+    if (param && param[i] && param[i]->kind == TYPE_POINTER\n+\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n+      fn = param[i]->u.p->u.s.line.file;\n+\n+  return get_output_file_with_visibility (fn);\n+}\n+\n /* For S, a structure that's part of ORIG_S, and using parameters\n    PARAM, write out a routine that:\n    - Takes a parameter, a void * but actually of type *S\n@@ -2546,23 +2570,15 @@ static void\n write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n \t\t\t  const struct write_types_data *wtd)\n {\n-  const char *fn = s->u.s.line.file;\n-  int i;\n   const char *chain_next = NULL;\n   const char *chain_prev = NULL;\n   const char *chain_circular = NULL;\n   const char *mark_hook_name = NULL;\n   options_p opt;\n   struct walk_type_data d;\n \n-  /* This is a hack, and not the good kind either.  */\n-  for (i = NUM_PARAM - 1; i >= 0; i--)\n-    if (param && param[i] && param[i]->kind == TYPE_POINTER\n-\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n-      fn = param[i]->u.p->u.s.line.file;\n-\n   memset (&d, 0, sizeof (d));\n-  d.of = get_output_file_with_visibility (fn);\n+  d.of = get_output_file_for_structure (s, param);\n \n   for (opt = s->u.s.opt; opt; opt = opt->next)\n     if (strcmp (opt->name, \"chain_next\") == 0)\n@@ -2885,20 +2901,12 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n */\n \n static void\n-write_local_func_for_structure (type_p orig_s, type_p s, type_p *param)\n+write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n {\n-  const char *fn = s->u.s.line.file;\n-  int i;\n   struct walk_type_data d;\n \n-  /* This is a hack, and not the good kind either.  */\n-  for (i = NUM_PARAM - 1; i >= 0; i--)\n-    if (param && param[i] && param[i]->kind == TYPE_POINTER\n-\t&& UNION_OR_STRUCT_P (param[i]->u.p))\n-      fn = param[i]->u.p->u.s.line.file;\n-\n   memset (&d, 0, sizeof (d));\n-  d.of = get_output_file_with_visibility (fn);\n+  d.of = get_output_file_for_structure (s, param);\n   d.process_field = write_types_local_process_field;\n   d.opt = s->u.s.opt;\n   d.line = &s->u.s.line;\n@@ -3689,18 +3697,265 @@ note_def_vec_alloc (const char *type, const char *astrat, struct fileloc *pos)\n   do_typedef (astratname, new_structure (astratname, 0, pos, field, 0), pos);\n }\n \n+static void dump_pair (int indent, pair_p p);\n+static void dump_type (int indent, type_p p);\n+static void dump_type_list (int indent, type_p p);\n+\n+#define INDENT 2\n+\n+/* Dumps the value of typekind KIND.  */\n+\n+static void\n+dump_typekind (int indent, enum typekind kind)\n+{\n+  printf (\"%*ckind = \", indent, ' ');\n+  switch (kind)\n+    {\n+    case TYPE_SCALAR: printf (\"TYPE_SCALAR\"); break;\n+    case TYPE_STRING: printf (\"TYPE_STRING\"); break;\n+    case TYPE_STRUCT: printf (\"TYPE_STRUCT\"); break;\n+    case TYPE_UNION:  printf (\"TYPE_UNION\"); break;\n+    case TYPE_POINTER: printf (\"TYPE_POINTER\"); break;\n+    case TYPE_ARRAY: printf (\"TYPE_ARRAY\"); break;\n+    case TYPE_LANG_STRUCT: printf (\"TYPE_LANG_STRUCT\"); break;\n+    case TYPE_PARAM_STRUCT: printf (\"TYPE_PARAM_STRUCT\"); break;\n+    default: gcc_unreachable ();\n+    }\n+  printf (\"\\n\");\n+}\n+\n+/* Dumps the value of GC_USED flag.  */\n+\n+static void\n+dump_gc_used (int indent, enum gc_used_enum gc_used)\n+{\n+  printf (\"%*cgc_used = \", indent, ' ');\n+  switch (gc_used)\n+    {\n+    case GC_UNUSED: printf (\"GC_UNUSED\"); break;\n+    case GC_USED: printf (\"GC_USED\"); break;\n+    case GC_MAYBE_POINTED_TO: printf (\"GC_MAYBE_POINTED_TO\"); break;\n+    case GC_POINTED_TO: printf (\"GC_POINTED_TO\"); break;\n+    default: gcc_unreachable ();\n+    }\n+  printf (\"\\n\");\n+}\n+\n+/* Dumps the type options OPT.  */\n+\n+static void\n+dump_options (int indent, options_p opt)\n+{\n+  options_p o;\n+  printf (\"%*coptions = \", indent, ' ');\n+  o = opt;\n+  while (o)\n+    {\n+       printf (\"%s:%s \", o->name, o->info);\n+       o = o->next;\n+    }\n+  printf (\"\\n\");\n+}\n+\n+/* Dumps the source file location in LINE.  */\n+\n+static void\n+dump_fileloc (int indent, struct fileloc line)\n+{\n+  printf (\"%*cfileloc: file = %s, line = %d\\n\", indent, ' ', line.file,\n+\t  line.line);\n+}\n+\n+/* Recursively dumps the struct, union, or a language-specific\n+   struct T.  */\n+\n+static void\n+dump_type_u_s (int indent, type_p t)\n+{\n+  pair_p fields;\n+\n+  gcc_assert (t->kind == TYPE_STRUCT || t->kind == TYPE_UNION\n+\t      || t->kind == TYPE_LANG_STRUCT);\n+  printf (\"%*cu.s.tag = %s\\n\", indent, ' ', t->u.s.tag);\n+  dump_fileloc (indent, t->u.s.line);\n+  printf (\"%*cu.s.fields =\\n\", indent, ' ');\n+  fields = t->u.s.fields;\n+  while (fields)\n+    {\n+       dump_pair (indent + INDENT, fields);\n+       fields = fields->next;\n+    }\n+  printf (\"%*cend of fields of type %p\\n\", indent, ' ', (void *) t);\n+  dump_options (indent, t->u.s.opt);\n+  printf (\"%*cu.s.bitmap = %X\\n\", indent, ' ', t->u.s.bitmap);\n+  if (t->kind == TYPE_LANG_STRUCT)\n+    {\n+      printf (\"%*cu.s.lang_struct:\\n\", indent, ' ');\n+      dump_type_list (indent + INDENT, t->u.s.lang_struct);\n+    }\n+}\n+\n+/* Recursively dumps the array T.  */\n+\n+static void\n+dump_type_u_a (int indent, type_p t)\n+{\n+  gcc_assert (t->kind == TYPE_ARRAY);\n+  printf (\"%*clen = %s, u.a.p:\\n\", indent, ' ', t->u.a.len);\n+  dump_type_list (indent + INDENT, t->u.a.p);\n+}\n+\n+/* Recursively dumps the parameterized struct T.  */\n+\n+static void\n+dump_type_u_param_struct (int indent, type_p t)\n+{\n+  int i;\n+  gcc_assert (t->kind == TYPE_PARAM_STRUCT);\n+  printf (\"%*cu.param_struct.stru:\\n\", indent, ' ');\n+  dump_type_list (indent, t->u.param_struct.stru);\n+  dump_fileloc (indent, t->u.param_struct.line);\n+  for (i = 0; i < NUM_PARAM; i++)\n+    {\n+      if (t->u.param_struct.param[i] == NULL)\n+\tcontinue;\n+      printf (\"%*cu.param_struct.param[%d]:\\n\", indent, ' ', i);\n+      dump_type (indent + INDENT, t->u.param_struct.param[i]);\n+    }\n+}\n+\n+/* Recursively dumps the type list T.  */\n+\n+static void\n+dump_type_list (int indent, type_p t)\n+{\n+  type_p p = t;\n+  while (p)\n+    {\n+      dump_type (indent, p);\n+      p = p->next;\n+    }\n+}\n+\n+static htab_t seen_types;\n+\n+/* Recursively dumps the type T if it was not dumped previously.  */\n+\n+static void\n+dump_type (int indent, type_p t)\n+{\n+  PTR *slot;\n+\n+  printf (\"%*cType at %p: \", indent, ' ', (void *)t);\n+  slot = htab_find_slot (seen_types, t, INSERT);\n+  if (*slot != NULL)\n+    {\n+      printf (\"already seen.\\n\");\n+      return;\n+    }\n+  *slot = t;\n+  printf (\"\\n\");\n+\n+  dump_typekind (indent, t->kind);\n+  printf (\"%*cpointer_to = %p\\n\", indent + INDENT, ' ',\n+\t  (void *)t->pointer_to);\n+  dump_gc_used (indent + INDENT, t->gc_used);\n+  switch (t->kind)\n+    {\n+    case TYPE_SCALAR:\n+      printf (\"%*cscalar_is_char = %s\\n\", indent + INDENT, ' ',\n+\t      t->u.scalar_is_char ? \"true\" : \"false\");\n+      break;\n+    case TYPE_STRING:\n+      break;\n+    case TYPE_STRUCT:\n+    case TYPE_UNION:\n+    case TYPE_LANG_STRUCT:\n+      dump_type_u_s (indent + INDENT, t);\n+      break;\n+    case TYPE_POINTER:\n+      printf (\"%*cp:\\n\", indent + INDENT, ' ');\n+      dump_type (indent + INDENT, t->u.p);\n+      break;\n+    case TYPE_ARRAY:\n+      dump_type_u_a (indent + INDENT, t);\n+      break;\n+    case TYPE_PARAM_STRUCT:\n+      dump_type_u_param_struct (indent + INDENT, t);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  printf (\"%*cEnd of type at %p\\n\", indent, ' ', (void *)t);\n+}\n+\n+/* Dumps the pair P.  */\n+\n+static void\n+dump_pair (int indent, pair_p p)\n+{\n+  printf (\"%*cpair: name = %s\\n\", indent, ' ', p->name);\n+  dump_type (indent, p->type);\n+  dump_fileloc (indent, p->line);\n+  dump_options (indent, p->opt);\n+  printf (\"%*cEnd of pair %s\\n\", indent, ' ', p->name);\n+}\n+\n+/* Dumps the list of pairs PP.  */\n+\n+static void\n+dump_pair_list (const char * name, pair_p pp)\n+{\n+  pair_p p;\n+  printf (\"%s:\\n\", name);\n+  for (p = pp; p != NULL; p = p->next)\n+    dump_pair (0, p);\n+  printf (\"End of %s\\n\\n\", name);\n+}\n+\n+/* Dumps the STRUCTURES.  */\n+\n+static void\n+dump_structures (const char * name, type_p structures)\n+{\n+  printf (\"%s:\\n\", name);\n+  dump_type_list (0, structures);\n+  printf (\"End of %s\\n\\n\", name);\n+}\n+\n+/* Dumps the internal structures of gengtype.  */\n+\n+static void\n+dump_everything (void)\n+{\n+  seen_types = htab_create (100, htab_hash_pointer, htab_eq_pointer, NULL);\n+  dump_pair_list (\"typedefs\", typedefs);\n+  dump_structures (\"structures\", structures);\n+  dump_structures (\"param_structs\", param_structs);\n+  dump_pair_list (\"variables\", variables);\n+  htab_delete (seen_types);\n+}\n+\n \f\n int\n main (int argc, char **argv)\n {\n   size_t i;\n   static struct fileloc pos = { this_file, 0 };\n   char* inputlist = 0;\n+  int do_dump = 0;\n   outf_p output_header;\n   char* plugin_output_filename = NULL;\n   /* fatal uses this */\n   progname = \"gengtype\";\n \n+  if (argc >= 2 && !strcmp (argv[1], \"-d\"))\n+    {\n+      do_dump = 1;\n+      argv = &argv[1];\n+      argc--;\n+    }\n+\n   if (argc >= 6 && !strcmp (argv[1], \"-P\"))\n     {\n       plugin_output_filename = argv[2];\n@@ -3725,7 +3980,7 @@ main (int argc, char **argv)\n       inputlist = argv[2];\n     }\n   else\n-    fatal (\"usage: gengtype [-P pluginout.h] srcdir input-list \"\n+    fatal (\"usage: gengtype [-d] [-P pluginout.h] srcdir input-list \"\n            \"[file1 file2 ... fileN]\");\n \n   srcdir_len = strlen (srcdir);\n@@ -3773,6 +4028,9 @@ main (int argc, char **argv)\n   write_rtx_next ();\n   close_output_files ();\n \n+  if (do_dump)\n+    dump_everything ();\n+\n   if (plugin_files)\n   {\n     for (i = 0; i < nb_plugin_files; i++)"}, {"sha": "75e4e2d5c435d59d2d3bb8f3820422381b2a416a", "filename": "gcc/gengtype.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0277fabf2b92ed6e94812a8bd0dba50fd0214836/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=0277fabf2b92ed6e94812a8bd0dba50fd0214836", "patch": "@@ -39,7 +39,7 @@ extern struct fileloc lexer_line;\n \n /* Print an error message.  */\n extern void error_at_line\n-  (struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n+  (const struct fileloc *pos, const char *msg, ...) ATTRIBUTE_PRINTF_2;\n \n /* Like asprintf, but calls fatal() on out of memory.  */\n extern char *xasprintf(const char *, ...) ATTRIBUTE_PRINTF_1;"}]}