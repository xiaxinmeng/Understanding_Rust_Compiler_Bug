{"sha": "16b013c9d9b4d950f89821476e791bf18c1295df", "node_id": "C_kwDOANBUbNoAKDE2YjAxM2M5ZDliNGQ5NTBmODk4MjE0NzZlNzkxYmYxOGMxMjk1ZGY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-09T11:37:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-11T11:27:58Z"}, "message": "tree-optimization/106514 - revisit m_import compute in backward threading\n\nThis revisits how we compute imports later used for the ranger path\nquery during backwards threading.  The compute_imports function\nof the path solver ends up pulling the SSA def chain of regular\nstmts without limit and since it starts with just the gori imports\nof the path exit it misses some interesting names to translate\nduring path discovery.  In fact with a still empty path this\ncompute_imports function looks like not the correct tool.\n\nThe following instead implements what it does during the path discovery\nand since we add the exit block we seed the initial imports and\ninteresting names from just the exit conditional.  When we then\nprocess interesting names (aka imports we did not yet see the definition\nof) we prune local defs but add their uses in a similar way as\ncompute_imports would have done.\n\ncompute_imports also is lacking in its walking of the def chain\ncompared to range_def_chain::get_def_chain which for example\nhandles &_1->x specially through range_op_handler and\ngimple_range_operand1, so the code copies this.  A fix for\ncompute_imports will be done separately, also fixing the unbound\nwalk there.\n\nThe patch also properly unwinds m_imports during the path discovery\nbacktracking and from a debugging session I have verified the two\nsets evolve as expected now while previously behaving slightly erratic.\n\nFortunately the m_imports set now also is shrunken significantly for\nthe PR69592 testcase (aka PR106514) so that there's overall speedup\nwhen increasing --param max-jump-thread-duplication-stmts as\n15 -> 30 -> 60 -> 120 from 1s -> 2s -> 13s -> 27s to with the patch\n1s -> 2s -> 4s -> 8s.\n\nThis runs into a latent issue in X which doesn't seem to expect\nany PHI nodes with a constant argument on an edge inside the path.\nBut we now have those as interesting, for example for the ICEing\ng++.dg/torture/pr100925.C which just has sth like\n\n  if (i)\n    x = 1;\n  else\n    x = 5;\n  if (x == 1)\n    ...\n\nwhere we now have the path from if (i) to if (x) and the PHI for x\nin the set of imports to consider for resolving x == 1 which IMHO\nlooks exactly like what we want.  The path_range_query::ssa_range_in_phi\npapers over the issue and drops the range to varying instead of\ncrashing.  I didn't want to mess with this any further in this patch\n(but I couldn't resist replacing the loop over PHI args with\nPHI_ARG_DEF_FROM_EDGE, so mind the re-indenting).\n\n\tPR tree-optimization/106514\n\t* tree-ssa-threadbackward.cc (back_threader::find_paths_to_names):\n\tCompute and unwind both m_imports and interesting on the fly during\n\tpath discovery.\n\t(back_threader::find_paths): Compute the original m_imports\n\tfrom just the SSA uses of the exit conditional.  Drop\n\thandling single_succ_to_potentially_threadable_block.\n\t* gimple-range-path.cc (path_range_query::ssa_range_in_phi): Handle\n\tconstant PHI arguments without crashing.  Use PHI_ARG_DEF_FROM_EDGE.\n\n\t* gcc.dg/tree-ssa/ssa-thread-19.c: Un-XFAIL.\n\t* gcc.dg/tree-ssa/ssa-thread-20.c: New testcase.", "tree": {"sha": "82f1b6361096c607e6b8008551fb9678fd41687a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82f1b6361096c607e6b8008551fb9678fd41687a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16b013c9d9b4d950f89821476e791bf18c1295df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b013c9d9b4d950f89821476e791bf18c1295df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b013c9d9b4d950f89821476e791bf18c1295df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b013c9d9b4d950f89821476e791bf18c1295df/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621f5362253f00b910686e8221e6756457f71e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/621f5362253f00b910686e8221e6756457f71e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/621f5362253f00b910686e8221e6756457f71e81"}], "stats": {"total": 184, "additions": 131, "deletions": 53}, "files": [{"sha": "5ae374df3a289a2914cc3bb55403fcd22d06c38d", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=16b013c9d9b4d950f89821476e791bf18c1295df", "patch": "@@ -276,8 +276,6 @@ void\n path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n {\n   tree name = gimple_phi_result (phi);\n-  basic_block bb = gimple_bb (phi);\n-  unsigned nargs = gimple_phi_num_args (phi);\n \n   if (at_entry ())\n     {\n@@ -287,6 +285,7 @@ path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n       // Try to fold the phi exclusively with global or cached values.\n       // This will get things like PHI <5(99), 6(88)>.  We do this by\n       // calling range_of_expr with no context.\n+      unsigned nargs = gimple_phi_num_args (phi);\n       Value_Range arg_range (TREE_TYPE (name));\n       r.set_undefined ();\n       for (size_t i = 0; i < nargs; ++i)\n@@ -303,36 +302,31 @@ path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n       return;\n     }\n \n+  basic_block bb = gimple_bb (phi);\n   basic_block prev = prev_bb ();\n   edge e_in = find_edge (prev, bb);\n-\n-  for (size_t i = 0; i < nargs; ++i)\n-    if (e_in == gimple_phi_arg_edge (phi, i))\n-      {\n-\ttree arg = gimple_phi_arg_def (phi, i);\n-\t// Avoid using the cache for ARGs defined in this block, as\n-\t// that could create an ordering problem.\n-\tif (ssa_defined_in_bb (arg, bb) || !get_cache (r, arg))\n-\t  {\n-\t    if (m_resolve)\n-\t      {\n-\t\tValue_Range tmp (TREE_TYPE (name));\n-\t\t// Using both the range on entry to the path, and the\n-\t\t// range on this edge yields significantly better\n-\t\t// results.\n-\t\tif (defined_outside_path (arg))\n-\t\t  range_on_path_entry (r, arg);\n-\t\telse\n-\t\t  r.set_varying (TREE_TYPE (name));\n-\t\tm_ranger->range_on_edge (tmp, e_in, arg);\n-\t\tr.intersect (tmp);\n-\t\treturn;\n-\t      }\n+  tree arg = PHI_ARG_DEF_FROM_EDGE (phi, e_in);\n+  // Avoid using the cache for ARGs defined in this block, as\n+  // that could create an ordering problem.\n+  if (ssa_defined_in_bb (arg, bb) || !get_cache (r, arg))\n+    {\n+      if (m_resolve)\n+\t{\n+\t  Value_Range tmp (TREE_TYPE (name));\n+\t  // Using both the range on entry to the path, and the\n+\t  // range on this edge yields significantly better\n+\t  // results.\n+\t  if (TREE_CODE (arg) == SSA_NAME\n+\t      && defined_outside_path (arg))\n+\t    range_on_path_entry (r, arg);\n+\t  else\n \t    r.set_varying (TREE_TYPE (name));\n-\t  }\n-\treturn;\n-      }\n-  gcc_unreachable ();\n+\t  m_ranger->range_on_edge (tmp, e_in, arg);\n+\t  r.intersect (tmp);\n+\t  return;\n+\t}\n+      r.set_varying (TREE_TYPE (name));\n+    }\n }\n \n // If NAME is defined in BB, set R to the range of NAME, and return"}, {"sha": "62912f372de22492d57b783ee9b9d6dae80c2b30", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-19.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-19.c?ref=16b013c9d9b4d950f89821476e791bf18c1295df", "patch": "@@ -30,4 +30,4 @@ int foo (struct S *chain, _Bool is_ctor, _Bool is_dtor)\n /* We want to thread both paths from A with NULL chain to C, the one through\n    B and one around it.\n    ???  Ideally we'd thread one \"path\" containing the half-diamond with B.  */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 2\" \"threadfull1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 2\" \"threadfull1\" } } */"}, {"sha": "c6529659021c228d09002479ba025760521b3760", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-20.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-20.c?ref=16b013c9d9b4d950f89821476e791bf18c1295df", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ethread-stats\" } */\n+\n+struct S { int base; };\n+void foo (struct S *p)\n+{\n+  if (p)\n+    {\n+      int *q = &p->base;\n+      if (q)\n+        __builtin_puts (\"x\");\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 1\" \"ethread\" } } */"}, {"sha": "546a776bd9182f078bddc23eade223ece21c2900", "filename": "gcc/tree-ssa-threadbackward.cc", "status": "modified", "additions": 92, "deletions": 23, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftree-ssa-threadbackward.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16b013c9d9b4d950f89821476e791bf18c1295df/gcc%2Ftree-ssa-threadbackward.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.cc?ref=16b013c9d9b4d950f89821476e791bf18c1295df", "patch": "@@ -362,32 +362,85 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting,\n     {\n       // For further greedy searching we want to remove interesting\n       // names defined in BB but add ones on the PHI edges for the\n-      // respective edges.  We do this by starting with all names\n+      // respective edges and adding imports from those stmts.\n+      // We do this by starting with all names\n       // not defined in BB as interesting, collecting a list of\n       // interesting PHIs in BB on the fly.  Then we iterate over\n       // predecessor edges, adding interesting PHI edge defs to\n       // the set of interesting names to consider when processing it.\n       auto_bitmap new_interesting;\n+      auto_vec<int, 16> new_imports;\n       auto_vec<gphi *, 4> interesting_phis;\n       bitmap_iterator bi;\n       unsigned i;\n+      auto_vec<tree, 16> worklist;\n       EXECUTE_IF_SET_IN_BITMAP (interesting, 0, i, bi)\n \t{\n \t  tree name = ssa_name (i);\n \t  gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\t  /* Imports remain interesting.  */\n \t  if (gimple_bb (def_stmt) != bb)\n-\t    bitmap_set_bit (new_interesting, i);\n-\t  else if (gphi *phi = dyn_cast<gphi *> (def_stmt))\n \t    {\n-\t      tree res = gimple_phi_result (phi);\n-\t      if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (res))\n-\t\tinteresting_phis.safe_push (phi);\n+\t      bitmap_set_bit (new_interesting, i);\n+\t      continue;\n+\t    }\n+\t  worklist.quick_push (name);\n+\t  while (!worklist.is_empty ())\n+\t    {\n+\t      tree name = worklist.pop ();\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+\t      /* Newly discovered imports are interesting.  */\n+\t      if (gimple_bb (def_stmt) != bb)\n+\t\t{\n+\t\t  bitmap_set_bit (new_interesting, SSA_NAME_VERSION (name));\n+\t\t  continue;\n+\t\t}\n+\t      /* Local PHIs participate in renaming below.  */\n+\t      if (gphi *phi = dyn_cast<gphi *> (def_stmt))\n+\t\t{\n+\t\t  tree res = gimple_phi_result (phi);\n+\t\t  if (!SSA_NAME_OCCURS_IN_ABNORMAL_PHI (res))\n+\t\t    interesting_phis.safe_push (phi);\n+\t\t}\n+\t      /* For other local defs process their uses, amending\n+\t\t imports on the way.  */\n+\t      else if (gassign *ass = dyn_cast <gassign *> (def_stmt))\n+\t\t{\n+\t\t  tree ssa[3];\n+\t\t  if (range_op_handler (ass))\n+\t\t    {\n+\t\t      ssa[0] = gimple_range_ssa_p (gimple_range_operand1 (ass));\n+\t\t      ssa[1] = gimple_range_ssa_p (gimple_range_operand2 (ass));\n+\t\t      ssa[2] = NULL_TREE;\n+\t\t    }\n+\t\t  else if (gimple_assign_rhs_code (ass) == COND_EXPR)\n+\t\t    {\n+\t\t      ssa[0] = gimple_range_ssa_p (gimple_assign_rhs1 (ass));\n+\t\t      ssa[1] = gimple_range_ssa_p (gimple_assign_rhs2 (ass));\n+\t\t      ssa[2] = gimple_range_ssa_p (gimple_assign_rhs3 (ass));\n+\t\t    }\n+\t\t  else\n+\t\t    continue;\n+\t\t  for (unsigned j = 0; j < 3; ++j)\n+\t\t    {\n+\t\t      tree rhs = ssa[j];\n+\t\t      if (rhs\n+\t\t\t  && TREE_CODE (rhs) == SSA_NAME\n+\t\t\t  && bitmap_set_bit (m_imports,\n+\t\t\t\t\t     SSA_NAME_VERSION (rhs)))\n+\t\t\t{\n+\t\t\t  new_imports.safe_push (SSA_NAME_VERSION (rhs));\n+\t\t\t  worklist.safe_push (rhs);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n       if (!bitmap_empty_p (new_interesting)\n \t  || !interesting_phis.is_empty ())\n \t{\n-\t  auto_vec<tree, 4> unwind (interesting_phis.length ());\n+\t  auto_vec<int, 4> unwind (interesting_phis.length ());\n+\t  auto_vec<int, 4> imports_unwind (interesting_phis.length ());\n \t  edge_iterator iter;\n \t  edge e;\n \t  FOR_EACH_EDGE (e, iter, bb->preds)\n@@ -405,22 +458,31 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting,\n \t\t{\n \t\t  tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n \t\t  if (TREE_CODE (def) == SSA_NAME)\n-\t\t    if (bitmap_set_bit (new_interesting,\n-\t\t\t\t\tSSA_NAME_VERSION (def)))\n-\t\t      {\n-\t\t\tbitmap_set_bit (m_imports, SSA_NAME_VERSION (def));\n-\t\t\tunwind.quick_push (def);\n-\t\t      }\n+\t\t    {\n+\t\t      int ver = SSA_NAME_VERSION (def);\n+\t\t      if (bitmap_set_bit (new_interesting, ver))\n+\t\t\t{\n+\t\t\t  if (bitmap_set_bit (m_imports, ver))\n+\t\t\t    imports_unwind.quick_push (ver);\n+\t\t\t  unwind.quick_push (ver);\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t      find_paths_to_names (e->src, new_interesting, overall_paths);\n-\t      // Restore new_interesting.  We leave m_imports alone since\n-\t      // we do not prune defs in BB from it and separately keeping\n-\t      // track of which bits to unwind isn't worth the trouble.\n-\t      for (tree def : unwind)\n-\t\tbitmap_clear_bit (new_interesting, SSA_NAME_VERSION (def));\n+\t      // Restore new_interesting.\n+\t      for (int def : unwind)\n+\t\tbitmap_clear_bit (new_interesting, def);\n \t      unwind.truncate (0);\n+\t      // Restore and m_imports.\n+\t      for (int def : imports_unwind)\n+\t\tbitmap_clear_bit (m_imports, def);\n+\t      imports_unwind.truncate (0);\n \t    }\n \t}\n+      /* m_imports tracks all interesting names on the path, so when\n+\t backtracking we have to restore it.  */\n+      for (int j : new_imports)\n+\tbitmap_clear_bit (m_imports, j);\n     }\n   else if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"  FAIL: Search space limit %d reached.\\n\",\n@@ -444,17 +506,24 @@ back_threader::find_paths (basic_block bb, tree name)\n \t  && gimple_code (stmt) != GIMPLE_SWITCH))\n     return;\n \n-  if (EDGE_COUNT (bb->succs) > 1\n-      || single_succ_to_potentially_threadable_block (bb))\n+  if (EDGE_COUNT (bb->succs) > 1)\n     {\n       m_last_stmt = stmt;\n       m_visited_bbs.empty ();\n       m_path.truncate (0);\n       m_name = name;\n-      m_path.safe_push (bb);\n-      m_solver->compute_imports (m_imports, m_path);\n-      m_path.pop ();\n \n+      // We compute imports of the path during discovery starting\n+      // just with names used in the conditional.\n+      bitmap_clear (m_imports);\n+      ssa_op_iter iter;\n+      FOR_EACH_SSA_TREE_OPERAND (name, stmt, iter, SSA_OP_USE)\n+\tbitmap_set_bit (m_imports, SSA_NAME_VERSION (name));\n+\n+      // Interesting is the set of imports we still not have see\n+      // the definition of.  So while imports only grow, the\n+      // set of interesting defs dwindles and once empty we can\n+      // stop searching.\n       auto_bitmap interesting;\n       bitmap_copy (interesting, m_imports);\n       find_paths_to_names (bb, interesting, 1);"}]}