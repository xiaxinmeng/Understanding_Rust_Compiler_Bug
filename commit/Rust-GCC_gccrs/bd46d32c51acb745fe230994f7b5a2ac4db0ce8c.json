{"sha": "bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ0NmQzMmM1MWFjYjc0NWZlMjMwOTk0ZjdiNWEyYWM0ZGIwY2U4Yw==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-09-06T19:47:06Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-09-06T19:47:06Z"}, "message": "re PR target/86731 (Miscompiles vec_sl at -O3 with -fwrapv on ppc64el)\n\n[gcc]\n\n2018-09-06  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\tPR target/86731\n\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Update logic\n\taround folding of vec_sl to handle out of range shift values.\n\n[testsuite]\n\n2018-08-15  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n\tPR target/86731\n\t* gcc.target/powerpc/pr86731.c: New test.\n\t* gcc.target/powerpc/pr86731-longlong.c: New test.\n\t* gcc.target/powerpc/pr86731-fwrapv.c: New test.\n\t* gcc.target/powerpc/pr86731-fwrapv-longlong.c: New test.\n\t* gcc.target/powerpc/pr86731-nogimplefold.c: New test.\n\t* gcc.target/powerpc/pr86731-nogimplefold-longlong.c: New test.\n\nFrom-SVN: r264150", "tree": {"sha": "9526a48d88ef483848eb954d2462c8140d3780f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9526a48d88ef483848eb954d2462c8140d3780f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "423c2a269e1c6bb84ead150eb4c3bda5afd0801c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423c2a269e1c6bb84ead150eb4c3bda5afd0801c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423c2a269e1c6bb84ead150eb4c3bda5afd0801c"}], "stats": {"total": 346, "additions": 336, "deletions": 10}, "files": [{"sha": "5ab342eaa10da03ed9105afe2635058be1e14b08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -1,3 +1,9 @@\n+2018-09-06  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\tPR target/86731\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Update logic\n+\taround folding of vec_sl to handle out of range shift values.\n+\n 2018-09-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (fix_trunc<mode>_fisttp_i387_1): Remove."}, {"sha": "a36e6140ecb7f9587b66eec246c02b4ec5a674f1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -15487,16 +15487,44 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VSLH:\n     case ALTIVEC_BUILTIN_VSLW:\n     case P8V_BUILTIN_VSLD:\n-      arg0 = gimple_call_arg (stmt, 0);\n-      if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (arg0)))\n-\t  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (TREE_TYPE (arg0))))\n-\treturn false;\n-      arg1 = gimple_call_arg (stmt, 1);\n-      lhs = gimple_call_lhs (stmt);\n-      g = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, arg1);\n-      gimple_set_location (g, gimple_location (stmt));\n-      gsi_replace (gsi, g, true);\n-      return true;\n+      {\n+\tlocation_t loc;\n+\tgimple_seq stmts = NULL;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\tif (INTEGRAL_TYPE_P (TREE_TYPE (arg0_type))\n+\t    && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0_type)))\n+\t  return false;\n+\targ1 = gimple_call_arg (stmt, 1);\n+\ttree arg1_type = TREE_TYPE (arg1);\n+\ttree unsigned_arg1_type = unsigned_type_for (TREE_TYPE (arg1));\n+\ttree unsigned_element_type = unsigned_type_for (TREE_TYPE (arg1_type));\n+\tloc = gimple_location (stmt);\n+\tlhs = gimple_call_lhs (stmt);\n+\t/* Force arg1 into the range valid matching the arg0 type.  */\n+\t/* Build a vector consisting of the max valid bit-size values.  */\n+\tint n_elts = VECTOR_CST_NELTS (arg1);\n+\tint tree_size_in_bits = TREE_INT_CST_LOW (size_in_bytes (arg1_type))\n+\t\t\t\t* BITS_PER_UNIT;\n+\ttree element_size = build_int_cst (unsigned_element_type,\n+\t\t\t\t\t   tree_size_in_bits / n_elts);\n+\ttree_vector_builder elts (unsigned_type_for (arg1_type), n_elts, 1);\n+\tfor (int i = 0; i < n_elts; i++)\n+\t  elts.safe_push (element_size);\n+\ttree modulo_tree = elts.build ();\n+\t/* Modulo the provided shift value against that vector.  */\n+\ttree unsigned_arg1 = gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t   unsigned_arg1_type, arg1);\n+\ttree new_arg1 = gimple_build (&stmts, loc, TRUNC_MOD_EXPR,\n+\t\t\t\t      unsigned_arg1_type, unsigned_arg1,\n+\t\t\t\t      modulo_tree);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* And finally, do the shift.  */\n+\tg = gimple_build_assign (lhs, LSHIFT_EXPR, arg0, new_arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n     /* Flavors of vector shift right.  */\n     case ALTIVEC_BUILTIN_VSRB:\n     case ALTIVEC_BUILTIN_VSRH:"}, {"sha": "4b774321fd612d6bf58281c3c1978e8439e81d55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -1,3 +1,13 @@\n+2018-09-06  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\tPR target/86731\n+\t* gcc.target/powerpc/pr86731.c: New test.\n+\t* gcc.target/powerpc/pr86731-longlong.c: New test.\n+\t* gcc.target/powerpc/pr86731-fwrapv.c: New test.\n+\t* gcc.target/powerpc/pr86731-fwrapv-longlong.c: New test.\n+\t* gcc.target/powerpc/pr86731-nogimplefold.c: New test.\n+\t* gcc.target/powerpc/pr86731-nogimplefold-longlong.c: New test.\n+\n 2018-09-06  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/80080"}, {"sha": "1269fe635c638dc75b4058a7ed945f2a12555039", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-fwrapv-longlong.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv-longlong.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,34 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift operation properly.  This is a testcase variation that\n+   explicitly specifies -fwrapv, which is a condition for the\n+   gimple folding of the vec_sl() intrinsic.  */\n+\n+/* specify -mpower8-vector, which provides vec_sl(long long,...) support. */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3 -fwrapv -mpower8-vector \" } */\n+\n+#include <altivec.h>\n+\n+vector unsigned long long splatu4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector unsigned long long) vec_sl(mzero, mzero);\n+}\n+\n+vector signed long long splats4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector signed long long) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions for most types.\n+   If folding is enabled, the vec_sl tests using vector long long type will\n+   generate a lvx instead of a vspltisw+vsld pair.  */\n+\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 0 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxv\\M|\\mlxvd2x\\M} 2 } } */\n+"}, {"sha": "f312550f04d67d9f8f7a5ac1a5228e86d65ed950", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-fwrapv.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-fwrapv.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,63 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift operation properly.  This is a testcase variation that\n+   explicitly specifies -fwrapv, which is a condition for the\n+   gimple folding of the vec_sl() intrinsic.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3 -fwrapv \" } */\n+\n+#include <altivec.h>\n+/* original test as reported.  */\n+vector unsigned int splat(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+/* more testcase variations.  */\n+vector unsigned char splatu1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector unsigned char) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned short splatu2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector unsigned short) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned int splatu3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+vector signed char splats1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector signed char) vec_sl(mzero, mzero);\n+}\n+\n+vector signed short splats2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector signed short) vec_sl(mzero, mzero);\n+}\n+\n+vector signed int splats3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector signed int) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions.\n+   If folding is enabled, the vec_sl tests using vector long long type will\n+   generate a lvx instead of a vspltisw+vsld pair.  */\n+\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M|\\mxxspltib\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M|\\mlxvd2x\\M} 0 } } */\n+"}, {"sha": "b86209178e18972271fbc1b2da27eb0a8f9f8deb", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-longlong.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-longlong.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,29 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift properly.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3 -mpower8-vector \" } */\n+\n+#include <altivec.h>\n+\n+vector unsigned long long splatu4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector unsigned long long) vec_sl(mzero, mzero);\n+}\n+vector signed long long splats4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector signed long long) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions for most types.\n+   Noted variations:  if gimple folding is disabled, or if -fwrapv is not\n+   specified, the long long tests will generate a vspltisw+vsld pair,\n+   versus generating a single lvx.  */\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M|\\mxxspltib\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M} 0 } } */\n+"}, {"sha": "2c463120676e615ecd1fd48d095cd4c77d4166d4", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-nogimplefold-longlong.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold-longlong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold-longlong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold-longlong.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,32 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift operation properly.  This is a testcase variation that\n+   explicitly disables gimple folding.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3 -fwrapv -mno-fold-gimple -mpower8-vector \" } */\n+/* { dg-prune-output \"gimple folding of rs6000 builtins has been disabled.\" } */\n+\n+\n+#include <altivec.h>\n+\n+vector unsigned long long splatu4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector unsigned long long) vec_sl(mzero, mzero);\n+}\n+\n+vector signed long long splats4(void)\n+{\n+        vector unsigned long long mzero = {-1,-1};\n+        return (vector signed long long) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions for most types.\n+   Noted variations:  if gimple folding is disabled, or if -fwrapv is not specified, the\n+   long long tests will generate a vspltisw+vsld pair, versus generating a lvx.  */\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M|\\mxxspltib\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M} 0 } } */\n+"}, {"sha": "d424b0c488eb6214c642e95c28c0e041b80caf0d", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731-nogimplefold.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731-nogimplefold.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,63 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift operation properly.  This is a testcase variation that\n+   explicitly disables gimple folding.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3 -fwrapv -mno-fold-gimple\" } */\n+/* { dg-prune-output \"gimple folding of rs6000 builtins has been disabled.\" } */\n+\n+\n+#include <altivec.h>\n+/* original test as reported.  */\n+vector unsigned int splat(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+/* more testcase variations.  */\n+vector unsigned char splatu1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector unsigned char) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned short splatu2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector unsigned short) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned int splatu3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+vector signed char splats1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector signed char) vec_sl(mzero, mzero);\n+}\n+\n+vector signed short splats2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector signed short) vec_sl(mzero, mzero);\n+}\n+\n+vector signed int splats3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector signed int) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions for most types.\n+   Noted variations:  if gimple folding is disabled, or if -fwrapv is not specified, the\n+   long long tests will generate a vspltisw+vsld pair, versus generating a lvx.  */\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M|\\mxxspltib\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M} 0 } } */\n+"}, {"sha": "19fefa584fedb8118202a5858fefaf06a11cc5b9", "filename": "gcc/testsuite/gcc.target/powerpc/pr86731.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd46d32c51acb745fe230994f7b5a2ac4db0ce8c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr86731.c?ref=bd46d32c51acb745fe230994f7b5a2ac4db0ce8c", "patch": "@@ -0,0 +1,61 @@\n+/* PR86731.  Verify that the rs6000 gimple-folding code handles the\n+   left shift properly.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-maltivec -O3\" } */\n+\n+#include <altivec.h>\n+/* The original test as reported.  */\n+vector unsigned int splat(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+/* more testcase variations.  */\n+vector unsigned char splatu1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector unsigned char) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned short splatu2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector unsigned short) vec_sl(mzero, mzero);\n+}\n+\n+vector unsigned int splatu3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector unsigned int) vec_sl(mzero, mzero);\n+}\n+\n+vector signed char splats1(void)\n+{\n+        vector unsigned char mzero = vec_splat_u8(-1);\n+        return (vector signed char) vec_sl(mzero, mzero);\n+}\n+\n+vector signed short splats2(void)\n+{\n+        vector unsigned short mzero = vec_splat_u16(-1);\n+        return (vector signed short) vec_sl(mzero, mzero);\n+}\n+\n+vector signed int splats3(void)\n+{\n+        vector unsigned int mzero = vec_splat_u32(-1);\n+        return (vector signed int) vec_sl(mzero, mzero);\n+}\n+\n+/* Codegen will consist of splat and shift instructions for most types.\n+   Noted variations:  if gimple folding is disabled, or if -fwrapv is not\n+   specified, the long long tests will generate a vspltisw+vsld pair,\n+   versus generating a single lvx.  */\n+/* { dg-final { scan-assembler-times {\\mvspltis[bhw]\\M|\\mxxspltib\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mvsl[bhwd]\\M} 7 } } */\n+/* { dg-final { scan-assembler-times {\\mlvx\\M} 0 } } */\n+"}]}