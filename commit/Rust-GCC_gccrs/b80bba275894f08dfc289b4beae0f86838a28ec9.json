{"sha": "b80bba275894f08dfc289b4beae0f86838a28ec9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwYmJhMjc1ODk0ZjA4ZGZjMjg5YjRiZWFlMGY4NjgzOGEyOGVjOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-10T14:05:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-10T14:05:04Z"}, "message": "(emit_reload_insns): Use new vars for secondary reloads and icodes.\n\nFrom-SVN: r6523", "tree": {"sha": "5cf82f142b658613ed616e2a5b7375a6bdb6149d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cf82f142b658613ed616e2a5b7375a6bdb6149d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b80bba275894f08dfc289b4beae0f86838a28ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80bba275894f08dfc289b4beae0f86838a28ec9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80bba275894f08dfc289b4beae0f86838a28ec9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80bba275894f08dfc289b4beae0f86838a28ec9/comments", "author": null, "committer": null, "parents": [{"sha": "9ec7078b6994c46f1464977dea6f0903aa7dd215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ec7078b6994c46f1464977dea6f0903aa7dd215", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ec7078b6994c46f1464977dea6f0903aa7dd215"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "3c15a7f3a30fa89d2f1e02cbb57e6c7f19e37f5d", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80bba275894f08dfc289b4beae0f86838a28ec9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80bba275894f08dfc289b4beae0f86838a28ec9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b80bba275894f08dfc289b4beae0f86838a28ec9", "patch": "@@ -5494,12 +5494,12 @@ emit_reload_insns (insn)\n \t     do this if the secondary register will be used as a scratch\n \t     register.  */\n \n-\t  if (reload_secondary_reload[j] >= 0\n-\t      && reload_secondary_icode[j] == CODE_FOR_nothing\n+\t  if (reload_secondary_in_reload[j] >= 0\n+\t      && reload_secondary_in_icode[j] == CODE_FOR_nothing\n \t      && optimize)\n \t    oldequiv\n \t      = find_equiv_reg (old, insn,\n-\t\t\t\treload_reg_class[reload_secondary_reload[j]],\n+\t\t\t\treload_reg_class[reload_secondary_in_reload[j]],\n \t\t\t\t-1, NULL_PTR, 0, mode);\n #endif\n \n@@ -5630,7 +5630,7 @@ emit_reload_insns (insn)\n \t      /* We are not going to bother supporting the case where a\n \t\t incremented register can't be copied directly from\n \t\t OLDEQUIV since this seems highly unlikely.  */\n-\t      if (reload_secondary_reload[j] >= 0)\n+\t      if (reload_secondary_in_reload[j] >= 0)\n \t\tabort ();\n \t      /* Prevent normal processing of this reload.  */\n \t      special = 1;\n@@ -5702,15 +5702,15 @@ emit_reload_insns (insn)\n \t\t because we don't make such reloads when both the input and\n \t\t output need secondary reload registers.  */\n \n-\t      if (reload_secondary_reload[j] >= 0)\n+\t      if (reload_secondary_in_reload[j] >= 0)\n \t\t{\n-\t\t  int secondary_reload = reload_secondary_reload[j];\n+\t\t  int secondary_reload = reload_secondary_in_reload[j];\n \t\t  rtx real_oldequiv = oldequiv;\n \t\t  rtx real_old = old;\n \n \t\t  /* If OLDEQUIV is a pseudo with a MEM, get the real MEM\n \t\t     and similarly for OLD.\n-\t\t     See comments in find_secondary_reload in reload.c.  */\n+\t\t     See comments in get_secondary_reload in reload.c.  */\n \t\t  if (GET_CODE (oldequiv) == REG\n \t\t      && REGNO (oldequiv) >= FIRST_PSEUDO_REGISTER\n \t\t      && reg_equiv_mem[REGNO (oldequiv)] != 0)\n@@ -5722,7 +5722,7 @@ emit_reload_insns (insn)\n \t\t    real_old = reg_equiv_mem[REGNO (old)];\n \n \t\t  second_reload_reg = reload_reg_rtx[secondary_reload];\n-\t\t  icode = reload_secondary_icode[j];\n+\t\t  icode = reload_secondary_in_icode[j];\n \n \t\t  if ((old != oldequiv && ! rtx_equal_p (old, oldequiv))\n \t\t      || (reload_in[j] != 0 && reload_out[j] != 0))\n@@ -5792,12 +5792,12 @@ emit_reload_insns (insn)\n \t\t\t  /* See if we need a scratch register to load the\n \t\t\t     intermediate register (a tertiary reload).  */\n \t\t\t  enum insn_code tertiary_icode\n-\t\t\t    = reload_secondary_icode[secondary_reload];\n+\t\t\t    = reload_secondary_in_icode[secondary_reload];\n \n \t\t\t  if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t    {\n \t\t\t      rtx third_reload_reg\n-\t\t\t        = reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n+\t\t\t        = reload_reg_rtx[reload_secondary_in_reload[secondary_reload]];\n \n \t\t\t      emit_insn ((GEN_FCN (tertiary_icode)\n \t\t\t\t\t  (second_reload_reg, real_oldequiv,\n@@ -6056,7 +6056,7 @@ emit_reload_insns (insn)\n \t     one, since it will be stored into OUT.  We might need a secondary\n \t     register only for an input reload, so check again here.  */\n \n-\t  if (reload_secondary_reload[j] >= 0)\n+\t  if (reload_secondary_out_reload[j] >= 0)\n \t    {\n \t      rtx real_old = old;\n \n@@ -6069,23 +6069,23 @@ emit_reload_insns (insn)\n \t\t  != NO_REGS))\n \t\t{\n \t\t  second_reloadreg = reloadreg;\n-\t\t  reloadreg = reload_reg_rtx[reload_secondary_reload[j]];\n+\t\t  reloadreg = reload_reg_rtx[reload_secondary_out_reload[j]];\n \n \t\t  /* See if RELOADREG is to be used as a scratch register\n \t\t     or as an intermediate register.  */\n-\t\t  if (reload_secondary_icode[j] != CODE_FOR_nothing)\n+\t\t  if (reload_secondary_out_icode[j] != CODE_FOR_nothing)\n \t\t    {\n-\t\t      emit_insn ((GEN_FCN (reload_secondary_icode[j])\n+\t\t      emit_insn ((GEN_FCN (reload_secondary_out_icode[j])\n \t\t\t\t  (real_old, second_reloadreg, reloadreg)));\n \t\t      special = 1;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* See if we need both a scratch and intermediate reload\n \t\t\t register.  */\n-\t\t      int secondary_reload = reload_secondary_reload[j];\n+\t\t      int secondary_reload = reload_secondary_out_reload[j];\n \t\t      enum insn_code tertiary_icode\n-\t\t\t= reload_secondary_icode[secondary_reload];\n+\t\t\t= reload_secondary_out_icode[secondary_reload];\n \t\t      rtx pat;\n \n \t\t      if (GET_MODE (reloadreg) != mode)\n@@ -6094,7 +6094,7 @@ emit_reload_insns (insn)\n \t\t      if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t{\n \t\t\t  rtx third_reloadreg\n-\t\t\t    = reload_reg_rtx[reload_secondary_reload[secondary_reload]];\n+\t\t\t    = reload_reg_rtx[reload_secondary_out_reload[secondary_reload]];\n \t\t\t  pat = (GEN_FCN (tertiary_icode)\n \t\t\t\t (reloadreg, second_reloadreg, third_reloadreg));\n \t\t\t}"}]}