{"sha": "200e10dc9b0a088d6350f87bbdc99c42047c4090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwZTEwZGM5YjBhMDg4ZDYzNTBmODdiYmRjOTljNDIwNDdjNDA5MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-25T22:41:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-25T22:41:17Z"}, "message": "dwarf2cfi: Generate remember/restore_state.\n\nFrom-SVN: r176772", "tree": {"sha": "191021ee99ae0a5ef03edd4c0b310025a22ee4cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/191021ee99ae0a5ef03edd4c0b310025a22ee4cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200e10dc9b0a088d6350f87bbdc99c42047c4090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200e10dc9b0a088d6350f87bbdc99c42047c4090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200e10dc9b0a088d6350f87bbdc99c42047c4090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200e10dc9b0a088d6350f87bbdc99c42047c4090/comments", "author": null, "committer": null, "parents": [{"sha": "a5d0ce8935bdfa87037b3cbe72e74ab6a96e8109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5d0ce8935bdfa87037b3cbe72e74ab6a96e8109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5d0ce8935bdfa87037b3cbe72e74ab6a96e8109"}], "stats": {"total": 125, "additions": 93, "deletions": 32}, "files": [{"sha": "d3972708f6b660b9526d4ddbb786f48eb5ee2b3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200e10dc9b0a088d6350f87bbdc99c42047c4090/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200e10dc9b0a088d6350f87bbdc99c42047c4090/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=200e10dc9b0a088d6350f87bbdc99c42047c4090", "patch": "@@ -1,3 +1,11 @@\n+2011-07-25  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (dw_trace_info): Add ID member.\n+\t(get_trace_index): Remove.  Change users to use ID member.\n+\t(before_next_cfi_note): New.\n+\t(connect_traces): Remove unreachable traces before the main loop.\n+\tLook across one trace and generate remember/restore_state if needed.\n+\n 2011-07-25  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (dump_cfi_row, debug_cfi_row): New."}, {"sha": "99b37abbff76fb929b8c936ff194c265ee1737f1", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 85, "deletions": 32, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200e10dc9b0a088d6350f87bbdc99c42047c4090/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200e10dc9b0a088d6350f87bbdc99c42047c4090/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=200e10dc9b0a088d6350f87bbdc99c42047c4090", "patch": "@@ -109,9 +109,6 @@ typedef struct\n   /* The row state at the beginning and end of the trace.  */\n   dw_cfi_row *beg_row, *end_row;\n \n-  /* True if this trace immediately follows NOTE_INSN_SWITCH_TEXT_SECTIONS.  */\n-  bool switch_sections;\n-\n   /* The following variables contain data used in interpreting frame related\n      expressions.  These are not part of the \"real\" row state as defined by\n      Dwarf, but it seems like they need to be propagated into a trace in case\n@@ -139,6 +136,11 @@ typedef struct\n      a maximum of 5 entries.  */\n   VEC(reg_saved_in_data, heap) *regs_saved_in_regs;\n \n+  /* An identifier for this trace.  Used only for debugging dumps.  */\n+  unsigned id;\n+\n+  /* True if this trace immediately follows NOTE_INSN_SWITCH_TEXT_SECTIONS.  */\n+  bool switch_sections;\n } dw_trace_info;\n \n DEF_VEC_O (dw_trace_info);\n@@ -288,12 +290,6 @@ dw_trace_info_eq (const void *ptr_a, const void *ptr_b)\n   return a->head == b->head;\n }\n \n-static unsigned\n-get_trace_index (dw_trace_info *trace)\n-{\n-  return trace - VEC_address (dw_trace_info, trace_info);\n-}\n-\n static dw_trace_info *\n get_trace_info (rtx insn)\n {\n@@ -2410,7 +2406,7 @@ maybe_record_trace_start (rtx start, rtx origin, bool abnormal)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"   saw edge from trace %u to %u (via %s %d)\\n\",\n-\t       get_trace_index (cur_trace), get_trace_index (ti),\n+\t       cur_trace->id, ti->id,\n \t       (origin ? rtx_name[(int) GET_CODE (origin)] : \"fallthru\"),\n \t       (origin ? INSN_UID (origin) : 0));\n     }\n@@ -2433,8 +2429,7 @@ maybe_record_trace_start (rtx start, rtx origin, bool abnormal)\n       VEC_safe_push (dw_trace_info_ref, heap, trace_work_list, ti);\n \n       if (dump_file)\n-\tfprintf (dump_file, \"\\tpush trace %u to worklist\\n\",\n-\t\t get_trace_index (ti));\n+\tfprintf (dump_file, \"\\tpush trace %u to worklist\\n\", ti->id);\n     }\n   else\n     {\n@@ -2534,7 +2529,7 @@ scan_trace (dw_trace_info *trace)\n \n   if (dump_file)\n     fprintf (dump_file, \"Processing trace %u : start at %s %d\\n\",\n-\t     get_trace_index (trace), rtx_name[(int) GET_CODE (insn)],\n+\t     trace->id, rtx_name[(int) GET_CODE (insn)],\n \t     INSN_UID (insn));\n \n   trace->end_row = copy_cfi_row (trace->beg_row);\n@@ -2630,33 +2625,61 @@ create_cfi_notes (void)\n   VEC_free (dw_trace_info_ref, heap, trace_work_list);\n }\n \n+/* Return the insn before the first NOTE_INSN_CFI after START.  */\n+\n+static rtx\n+before_next_cfi_note (rtx start)\n+{\n+  rtx prev = start;\n+  while (start)\n+    {\n+      if (NOTE_P (start) && NOTE_KIND (start) == NOTE_INSN_CFI)\n+\treturn prev;\n+      prev = start;\n+      start = NEXT_INSN (start);\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Insert CFI notes between traces to properly change state between them.  */\n-/* ??? TODO: Make use of remember/restore_state.  */\n \n static void\n connect_traces (void)\n {\n   unsigned i, n = VEC_length (dw_trace_info, trace_info);\n   dw_trace_info *prev_ti, *ti;\n \n-  prev_ti = VEC_index (dw_trace_info, trace_info, 0);\n+  /* ??? Ideally, we should have both queued and processed every trace.\n+     However the current representation of constant pools on various targets\n+     is indistinguishable from unreachable code.  Assume for the moment that\n+     we can simply skip over such traces.  */\n+  /* ??? Consider creating a DATA_INSN rtx code to indicate that\n+     these are not \"real\" instructions, and should not be considered.\n+     This could be generically useful for tablejump data as well.  */\n+  /* Remove all unprocessed traces from the list.  */\n+  for (i = n - 1; i > 0; --i)\n+    {\n+      ti = VEC_index (dw_trace_info, trace_info, i);\n+      if (ti->beg_row == NULL)\n+\t{\n+\t  VEC_ordered_remove (dw_trace_info, trace_info, i);\n+\t  n -= 1;\n+\t}\n+      else\n+\tgcc_assert (ti->end_row != NULL);\n+    }\n \n-  for (i = 1; i < n; ++i)\n+  /* Work from the end back to the beginning.  This lets us easily insert\n+     remember/restore_state notes in the correct order wrt other notes.  */\n+  prev_ti = VEC_index (dw_trace_info, trace_info, n - 1);\n+  for (i = n - 1; i > 0; --i)\n     {\n       dw_cfi_row *old_row;\n \n-      ti = VEC_index (dw_trace_info, trace_info, i);\n+      ti = prev_ti;\n+      prev_ti = VEC_index (dw_trace_info, trace_info, i - 1);\n \n-      /* ??? Ideally, we should have both queued and processed.  However\n-\t the current representation of constant pools on various targets\n-\t is indistinguishable from unreachable code.  Assume for the \n-\t moment that we can simply skip over such traces.  */\n-      /* ??? Consider creating a DATA_INSN rtx code to indicate that\n-\t these are not \"real\" instructions, and should not be considered.\n-\t This could be generically useful for tablejump data as well.  */\n-      if (ti->beg_row == NULL)\n-\tcontinue;\n-      gcc_assert (ti->end_row != NULL);\n+      add_cfi_insn = ti->head;\n \n       /* In dwarf2out_switch_text_section, we'll begin a new FDE\n \t for the portion of the function in the alternate text\n@@ -2665,16 +2688,47 @@ connect_traces (void)\n       if (ti->switch_sections)\n \told_row = cie_cfi_row;\n       else\n-\told_row = prev_ti->end_row;\n+\t{\n+\t  old_row = prev_ti->end_row;\n+\t  /* If there's no change from the previous end state, fine.  */\n+\t  if (cfi_row_equal_p (old_row, ti->beg_row))\n+\t    ;\n+\t  /* Otherwise check for the common case of sharing state with\n+\t     the beginning of an epilogue, but not the end.  Insert\n+\t     remember/restore opcodes in that case.  */\n+\t  else if (cfi_row_equal_p (prev_ti->beg_row, ti->beg_row))\n+\t    {\n+\t      dw_cfi_ref cfi;\n+\n+\t      /* Note that if we blindly insert the remember at the\n+\t\t start of the trace, we can wind up increasing the\n+\t\t size of the unwind info due to extra advance opcodes.\n+\t\t Instead, put the remember immediately before the next\n+\t\t state change.  We know there must be one, because the \n+\t\t state at the beginning and head of the trace differ.  */\n+\t      add_cfi_insn = before_next_cfi_note (prev_ti->head);\n+\t      cfi = new_cfi ();\n+\t      cfi->dw_cfi_opc = DW_CFA_remember_state;\n+\t      add_cfi (cfi);\n+\n+\t      add_cfi_insn = ti->head;\n+\t      cfi = new_cfi ();\n+\t      cfi->dw_cfi_opc = DW_CFA_restore_state;\n+\t      add_cfi (cfi);\n+\n+\t      old_row = prev_ti->beg_row;\n+\t    }\n+\t  /* Otherwise, we'll simply change state from the previous end.  */\n+\t}\n \n-      add_cfi_insn = ti->head;\n       change_cfi_row (old_row, ti->beg_row);\n \n       if (dump_file && add_cfi_insn != ti->head)\n \t{\n \t  rtx note;\n \n-\t  fprintf (dump_file, \"Fixup between trace %u and %u:\\n\", i - 1, i);\n+\t  fprintf (dump_file, \"Fixup between trace %u and %u:\\n\",\n+\t\t   prev_ti->id, ti->id);\n \n \t  note = ti->head;\n \t  do\n@@ -2685,8 +2739,6 @@ connect_traces (void)\n \t    }\n \t  while (note != add_cfi_insn);\n \t}\n-\n-      prev_ti = ti;\n     }\n }\n \n@@ -2739,6 +2791,7 @@ create_pseudo_cfg (void)\n \t  memset (ti, 0, sizeof (*ti));\n \t  ti->head = insn;\n \t  ti->switch_sections = switch_sections;\n+\t  ti->id = VEC_length (dw_trace_info, trace_info) - 1;\n \n \t  saw_barrier = false;\n \t  switch_sections = false;"}]}