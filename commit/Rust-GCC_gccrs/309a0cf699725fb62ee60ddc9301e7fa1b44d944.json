{"sha": "309a0cf699725fb62ee60ddc9301e7fa1b44d944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA5YTBjZjY5OTcyNWZiNjJlZTYwZGRjOTMwMWU3ZmExYjQ0ZDk0NA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-04-27T14:51:26Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-04-27T14:51:26Z"}, "message": "tree-ssa-loop-ivopts.c (struct iv): Use pointer to struct iv_use instead of redundant use_id and boolean have_use_for.\n\n\t* tree-ssa-loop-ivopts.c (struct iv): Use pointer to struct iv_use\n\tinstead of redundant use_id and boolean have_use_for.\n\t(struct iv_use): Change sub_id into group_id.  Remove field next.\n\tMove fields: related_cands, n_map_members, cost_map and selected\n\tto ...\n\t(struct iv_group): ... here.  New structure.\n\t(struct iv_common_cand): Use structure declaration directly.\n\t(struct ivopts_data, iv_ca, iv_ca_delta): Rename fields.\n\t(MAX_CONSIDERED_USES): Rename macro to ...\n\t(MAX_CONSIDERED_GROUPS): ... here.\n\t(n_iv_uses, iv_use, n_iv_cands, iv_cand): Delete.\n\t(dump_iv, dump_use, dump_cand): Refactor format of dump information.\n\t(dump_uses): Rename to ...\n\t(dump_groups): ... here.  Update all uses.\n\t(tree_ssa_iv_optimize_init, alloc_iv): Update all uses.\n\t(find_induction_variables): Refactor format of dump information.\n\t(record_sub_use): Delete.\n\t(record_use): Update all uses.\n\t(record_group): New function.\n\t(record_group_use, find_interesting_uses_op): Call above functions.\n\tUpdate all uses.\n\t(find_interesting_uses_cond): Ditto.\n\t(group_compare_offset): New function.\n\t(split_all_small_groups): Rename to ...\n\t(split_small_address_groups_p): ... here.  Update all uses.\n\t(split_address_groups):  Update all uses.\n\t(find_interesting_uses): Refactor format of dump information.\n\t(add_candidate_1): Update all uses.  Remove redundant check on iv,\n\tbase and step.\n\t(add_candidate, record_common_cand): Remove redundant assert.\n\t(add_iv_candidate_for_biv): Update use.\n\t(add_iv_candidate_derived_from_uses): Update all uses.\n\t(add_iv_candidate_for_groups, record_important_candidates): Ditto.\n\t(alloc_use_cost_map): Ditto.\n\t(set_use_iv_cost, get_use_iv_cost): Rename to ...\n\t(set_group_iv_cost, get_group_iv_cost): ... here.  Update all uses.\n\t(determine_use_iv_cost_generic): Ditto.\n\t(determine_group_iv_cost_generic): Ditto.\n\t(determine_use_iv_cost_address): Ditto.\n\t(determine_group_iv_cost_address): Ditto.\n\t(determine_use_iv_cost_condition): Ditto.\n\t(determine_group_iv_cost_cond): Ditto.\n\t(determine_use_iv_cost): Ditto.\n\t(determine_group_iv_cost): Ditto.\n\t(set_autoinc_for_original_candidates): Update all uses.\n\t(find_iv_candidates): Update all uses.  Refactor dump information.\n\t(determine_use_iv_costs): Ditto.\n\t(determine_iv_costs): Ditto.\n\t(iv_ca_cand_for_use): Rename to ...\n\t(iv_ca_cand_for_group): ... here.  Update all uses.\n\t(iv_ca_add_use, iv_ca_add_group): Ditto.\n\t(iv_ca_set_cp, iv_ca_cost, iv_ca_delta_add): Update all uses.\n\t(iv_ca_delta_join, iv_ca_delta_reverse, iv_ca_delta_free): Ditto.\n\t(iv_ca_new, iv_ca_dump, iv_ca_extend, iv_ca_narrow): Ditto.\n\t(iv_ca_prune, cheaper_cost_with_cand, iv_ca_replace): Ditto.\n\t(try_add_cand_for, try_improve_iv_set, find_optimal_iv_set): Ditto.\n\t(create_new_iv, adjust_iv_update_pos): Ditto.\n\t(rewrite_use_address): Delete.\n\t(rewrite_use_address_1): Rename to ...\n\t(rewrite_use_address): ... here.\n\t(rewrite_use_compare): Update all uses.\n\t(rewrite_use): Delete.\n\t(rewrite_uses): Rename to ...\n\t(rewrite_groups): ... here.  Update all uses.\n\t(remove_unused_ivs, free_loop_data): Update all uses.\n\t(tree_ssa_iv_optimize_finalize, tree_ssa_iv_optimize_loop): Ditto.\n\n\tgcc/testsuite/ChangeLog\n\t* gcc.dg/tree-ssa/pr64705.c: Revise check string.\n\t* gcc.dg/tree-ssa/scev-9.c: Ditto.\n\t* gcc.dg/tree-ssa/scev-10.c: Ditto.\n\t* gcc.dg/tree-ssa/scev-11.c: Ditto.\n\t* gcc.dg/tree-ssa/scev-12.c: Ditto.\n\nFrom-SVN: r235513", "tree": {"sha": "9c0016aa2a330485bbb1445a38afb6205e1a60bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0016aa2a330485bbb1445a38afb6205e1a60bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/309a0cf699725fb62ee60ddc9301e7fa1b44d944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309a0cf699725fb62ee60ddc9301e7fa1b44d944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/309a0cf699725fb62ee60ddc9301e7fa1b44d944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/309a0cf699725fb62ee60ddc9301e7fa1b44d944/comments", "author": null, "committer": null, "parents": [{"sha": "317d98872b3c9173d4a9f82693bbdcc84cdeb03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317d98872b3c9173d4a9f82693bbdcc84cdeb03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/317d98872b3c9173d4a9f82693bbdcc84cdeb03c"}], "stats": {"total": 1617, "additions": 776, "deletions": 841}, "files": [{"sha": "b8aa31e5780faf327451dd195ad0d24507a9a724", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -1,3 +1,72 @@\n+2016-04-27  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (struct iv): Use pointer to struct iv_use\n+\tinstead of redundant use_id and boolean have_use_for.\n+\t(struct iv_use): Change sub_id into group_id.  Remove field next.\n+\tMove fields: related_cands, n_map_members, cost_map and selected\n+\tto ...\n+\t(struct iv_group): ... here.  New structure.\n+\t(struct iv_common_cand): Use structure declaration directly.\n+\t(struct ivopts_data, iv_ca, iv_ca_delta): Rename fields.\n+\t(MAX_CONSIDERED_USES): Rename macro to ...\n+\t(MAX_CONSIDERED_GROUPS): ... here.\n+\t(n_iv_uses, iv_use, n_iv_cands, iv_cand): Delete.\n+\t(dump_iv, dump_use, dump_cand): Refactor format of dump information.\n+\t(dump_uses): Rename to ...\n+\t(dump_groups): ... here.  Update all uses.\n+\t(tree_ssa_iv_optimize_init, alloc_iv): Update all uses.\n+\t(find_induction_variables): Refactor format of dump information.\n+\t(record_sub_use): Delete.\n+\t(record_use): Update all uses.\n+\t(record_group): New function.\n+\t(record_group_use, find_interesting_uses_op): Call above functions.\n+\tUpdate all uses.\n+\t(find_interesting_uses_cond): Ditto.\n+\t(group_compare_offset): New function.\n+\t(split_all_small_groups): Rename to ...\n+\t(split_small_address_groups_p): ... here.  Update all uses.\n+\t(split_address_groups):  Update all uses.\n+\t(find_interesting_uses): Refactor format of dump information.\n+\t(add_candidate_1): Update all uses.  Remove redundant check on iv,\n+\tbase and step.\n+\t(add_candidate, record_common_cand): Remove redundant assert.\n+\t(add_iv_candidate_for_biv): Update use.\n+\t(add_iv_candidate_derived_from_uses): Update all uses.\n+\t(add_iv_candidate_for_groups, record_important_candidates): Ditto.\n+\t(alloc_use_cost_map): Ditto.\n+\t(set_use_iv_cost, get_use_iv_cost): Rename to ...\n+\t(set_group_iv_cost, get_group_iv_cost): ... here.  Update all uses.\n+\t(determine_use_iv_cost_generic): Ditto.\n+\t(determine_group_iv_cost_generic): Ditto.\n+\t(determine_use_iv_cost_address): Ditto.\n+\t(determine_group_iv_cost_address): Ditto.\n+\t(determine_use_iv_cost_condition): Ditto.\n+\t(determine_group_iv_cost_cond): Ditto.\n+\t(determine_use_iv_cost): Ditto.\n+\t(determine_group_iv_cost): Ditto.\n+\t(set_autoinc_for_original_candidates): Update all uses.\n+\t(find_iv_candidates): Update all uses.  Refactor dump information.\n+\t(determine_use_iv_costs): Ditto.\n+\t(determine_iv_costs): Ditto.\n+\t(iv_ca_cand_for_use): Rename to ...\n+\t(iv_ca_cand_for_group): ... here.  Update all uses.\n+\t(iv_ca_add_use, iv_ca_add_group): Ditto.\n+\t(iv_ca_set_cp, iv_ca_cost, iv_ca_delta_add): Update all uses.\n+\t(iv_ca_delta_join, iv_ca_delta_reverse, iv_ca_delta_free): Ditto.\n+\t(iv_ca_new, iv_ca_dump, iv_ca_extend, iv_ca_narrow): Ditto.\n+\t(iv_ca_prune, cheaper_cost_with_cand, iv_ca_replace): Ditto.\n+\t(try_add_cand_for, try_improve_iv_set, find_optimal_iv_set): Ditto.\n+\t(create_new_iv, adjust_iv_update_pos): Ditto.\n+\t(rewrite_use_address): Delete.\n+\t(rewrite_use_address_1): Rename to ...\n+\t(rewrite_use_address): ... here.\n+\t(rewrite_use_compare): Update all uses.\n+\t(rewrite_use): Delete.\n+\t(rewrite_uses): Rename to ...\n+\t(rewrite_groups): ... here.  Update all uses.\n+\t(remove_unused_ivs, free_loop_data): Update all uses.\n+\t(tree_ssa_iv_optimize_finalize, tree_ssa_iv_optimize_loop): Ditto.\n+\n 2016-04-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* rtlanal.c (nonzero_bits1): Convert preprocessor check"}, {"sha": "86e215c9d2b2efa9bfac21d9bac572572f922236", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -1,3 +1,11 @@\n+2016-04-27  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/pr64705.c: Revise check string.\n+\t* gcc.dg/tree-ssa/scev-9.c: Ditto.\n+\t* gcc.dg/tree-ssa/scev-10.c: Ditto.\n+\t* gcc.dg/tree-ssa/scev-11.c: Ditto.\n+\t* gcc.dg/tree-ssa/scev-12.c: Ditto.\n+\n 2016-04-27  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/70760"}, {"sha": "fd24e38a53e9f3a4659dece5af4d71fbc0ce2c18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr64705.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64705.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64705.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64705.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -23,4 +23,4 @@ int foo(char *flags, long len, long i, long steps)\n \n /* Don't expand iv {base+step, step}_loop into {base+x+y, step}_loop\n    even if \"step == x + y\".  */\n-/* { dg-final { scan-tree-dump \"base step_\\[0-9\\]* \\\\+ iter|base iter_\\[0-9\\]* \\\\+ step\" \"ivopts\"} } */\n+/* { dg-final { scan-tree-dump \"Base:\\\\tstep_\\[0-9\\]* \\\\+ iter|Base:\\\\titer_\\[0-9\\]* \\\\+ step\" \"ivopts\"} } */"}, {"sha": "e402bf92b751cca207b07725a32ed483fe8181ea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-10.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-10.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -18,6 +18,5 @@ foo (signed char s, signed char l)\n }\n \n /* Address of array reference is scev.  */\n-/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 1 \"ivopts\" } } */\n-\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n "}, {"sha": "088771ebe401e473bfde295b8183fe37e3d2f956", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-11.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-11.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -23,6 +23,4 @@ foo (int n)\n }\n \n /* Address of array reference to b is scev.  */\n-/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 2 \"ivopts\" } } */\n-\n-\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 2 \"ivopts\" } } */"}, {"sha": "c112639d4cbe1b568f1ba146dac78734715de903", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-12.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-12.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -24,7 +24,4 @@ foo (int x, int n)\n }\n \n /* Address of array reference to b is not scev.  */\n-/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 1 \"ivopts\" } } */\n-\n-\n-\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */"}, {"sha": "b11b2f1b482083b3c962cbb71ed8cbc5bce2f930", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-9.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -18,5 +18,5 @@ foo (unsigned char s, unsigned char l)\n }\n \n /* Address of array reference is scev.  */\n-/* { dg-final { scan-tree-dump-times \"use \\[0-9\\]\\n  address\" 1 \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-times \"  Type:\\\\tADDRESS\\n  Use \\[0-9\\].\\[0-9\\]:\" 1 \"ivopts\" } } */\n "}, {"sha": "18c1773be14ea204c4d0a6d5ba1412ba16a3848f", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 694, "deletions": 830, "changes": 1524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/309a0cf699725fb62ee60ddc9301e7fa1b44d944/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=309a0cf699725fb62ee60ddc9301e7fa1b44d944", "patch": "@@ -30,20 +30,25 @@ along with GCC; see the file COPYING3.  If not see\n       -- addresses of arrays\n       -- comparisons of induction variables\n \n+      Note the interesting uses are categorized and handled in group.\n+      Generally, address type uses are grouped together if their iv bases\n+      are different in constant offset.\n+\n    2) Candidates for the induction variables are found.  This includes\n \n       -- old induction variables\n       -- the variables defined by expressions derived from the \"interesting\n-\t uses\" above\n+\t groups/uses\" above\n \n    3) The optimal (w.r. to a cost function) set of variables is chosen.  The\n       cost function assigns a cost to sets of induction variables and consists\n       of three parts:\n \n-      -- The use costs.  Each of the interesting uses chooses the best induction\n-\t variable in the set and adds its cost to the sum.  The cost reflects\n-\t the time spent on modifying the induction variables value to be usable\n-\t for the given purpose (adding base and offset for arrays, etc.).\n+      -- The group/use costs.  Each of the interesting groups/uses chooses\n+\t the best induction variable in the set and adds its cost to the sum.\n+\t The cost reflects the time spent on modifying the induction variables\n+\t value to be usable for the given purpose (adding base and offset for\n+\t arrays, etc.).\n       -- The variable costs.  Each of the variables has a cost assigned that\n \t reflects the costs associated with incrementing the value of the\n \t variable.  The original variables are somewhat preferred.\n@@ -130,16 +135,17 @@ avg_loop_niter (struct loop *loop)\n   return niter;\n }\n \n+struct iv_use;\n+\n /* Representation of the induction variable.  */\n struct iv\n {\n   tree base;\t\t/* Initial value of the iv.  */\n   tree base_object;\t/* A memory object to that the induction variable points.  */\n   tree step;\t\t/* Step of the iv (constant only).  */\n   tree ssa_name;\t/* The ssa name with the value.  */\n-  unsigned use_id;\t/* The identifier in the use if it is the case.  */\n+  struct iv_use *nonlin_use;\t/* The identifier in the use if it is the case.  */\n   bool biv_p;\t\t/* Is it a biv?  */\n-  bool have_use_for;\t/* Do we already have a use for it?  */\n   bool no_overflow;\t/* True if the iv doesn't overflow.  */\n   bool have_address_use;/* For biv, indicate if it's used in any address\n \t\t\t   type use.  */\n@@ -196,27 +202,36 @@ struct cost_pair\n struct iv_use\n {\n   unsigned id;\t\t/* The id of the use.  */\n-  unsigned sub_id;\t/* The id of the sub use.  */\n+  unsigned group_id;\t/* The group id the use belongs to.  */\n   enum use_type type;\t/* Type of the use.  */\n   struct iv *iv;\t/* The induction variable it is based on.  */\n   gimple *stmt;\t\t/* Statement in that it occurs.  */\n   tree *op_p;\t\t/* The place where it occurs.  */\n-  bitmap related_cands;\t/* The set of \"related\" iv candidates, plus the common\n-\t\t\t   important ones.  */\n-\n-  unsigned n_map_members; /* Number of candidates in the cost_map list.  */\n-  struct cost_pair *cost_map;\n-\t\t\t/* The costs wrto the iv candidates.  */\n \n-  struct iv_cand *selected;\n-\t\t\t/* The selected candidate.  */\n-\n-  struct iv_use *next;\t/* The next sub use.  */\n   tree addr_base;\t/* Base address with const offset stripped.  */\n   unsigned HOST_WIDE_INT addr_offset;\n \t\t\t/* Const offset stripped from base address.  */\n };\n \n+/* Group of uses.  */\n+struct iv_group\n+{\n+  /* The id of the group.  */\n+  unsigned id;\n+  /* Uses of the group are of the same type.  */\n+  enum use_type type;\n+  /* The set of \"related\" IV candidates, plus the important ones.  */\n+  bitmap related_cands;\n+  /* Number of IV candidates in the cost_map.  */\n+  unsigned n_map_members;\n+  /* The costs wrto the iv candidates.  */\n+  struct cost_pair *cost_map;\n+  /* The selected candidate for the group.  */\n+  struct iv_cand *selected;\n+  /* Uses in the group.  */\n+  vec<struct iv_use *> vuses;\n+};\n+\n /* The position where the iv is computed.  */\n enum iv_position\n {\n@@ -258,7 +273,7 @@ struct iv_common_cand\n   tree base;\n   tree step;\n   /* IV uses from which this common candidate is derived.  */\n-  auto_vec<iv_use *> uses;\n+  auto_vec<struct iv_use *> uses;\n   hashval_t hash;\n };\n \n@@ -354,10 +369,10 @@ struct ivopts_data\n   bitmap relevant;\n \n   /* The uses of induction variables.  */\n-  vec<iv_use *> iv_uses;\n+  vec<iv_group *> vgroups;\n \n   /* The candidates.  */\n-  vec<iv_cand *> iv_candidates;\n+  vec<iv_cand *> vcands;\n \n   /* A bitmap of important candidates.  */\n   bitmap important_candidates;\n@@ -402,10 +417,10 @@ struct iv_ca\n   unsigned upto;\n \n   /* Number of uses that cannot be expressed by the candidates in the set.  */\n-  unsigned bad_uses;\n+  unsigned bad_groups;\n \n   /* Candidate assigned to a use, together with the related costs.  */\n-  struct cost_pair **cand_for_use;\n+  struct cost_pair **cand_for_group;\n \n   /* Number of times each candidate is used.  */\n   unsigned *n_cand_uses;\n@@ -443,8 +458,8 @@ struct iv_ca\n \n struct iv_ca_delta\n {\n-  /* Changed use.  */\n-  struct iv_use *use;\n+  /* Changed group.  */\n+  struct iv_group *group;\n \n   /* An old assignment (for rollback purposes).  */\n   struct cost_pair *old_cp;\n@@ -453,7 +468,7 @@ struct iv_ca_delta\n   struct cost_pair *new_cp;\n \n   /* Next change in the list.  */\n-  struct iv_ca_delta *next_change;\n+  struct iv_ca_delta *next;\n };\n \n /* Bound on number of candidates below that all candidates are considered.  */\n@@ -464,7 +479,7 @@ struct iv_ca_delta\n /* If there are more iv occurrences, we just give up (it is quite unlikely that\n    optimizing such a loop would help, and it would take ages).  */\n \n-#define MAX_CONSIDERED_USES \\\n+#define MAX_CONSIDERED_GROUPS \\\n   ((unsigned) PARAM_VALUE (PARAM_IV_MAX_CONSIDERED_USES))\n \n /* If there are at most this number of ivs in the set, try removing unnecessary\n@@ -480,38 +495,6 @@ static vec<tree> decl_rtl_to_reset;\n \n static comp_cost force_expr_to_var_cost (tree, bool);\n \n-/* Number of uses recorded in DATA.  */\n-\n-static inline unsigned\n-n_iv_uses (struct ivopts_data *data)\n-{\n-  return data->iv_uses.length ();\n-}\n-\n-/* Ith use recorded in DATA.  */\n-\n-static inline struct iv_use *\n-iv_use (struct ivopts_data *data, unsigned i)\n-{\n-  return data->iv_uses[i];\n-}\n-\n-/* Number of candidates recorded in DATA.  */\n-\n-static inline unsigned\n-n_iv_cands (struct ivopts_data *data)\n-{\n-  return data->iv_candidates.length ();\n-}\n-\n-/* Ith candidate recorded in DATA.  */\n-\n-static inline struct iv_cand *\n-iv_cand (struct ivopts_data *data, unsigned i)\n-{\n-  return data->iv_candidates[i];\n-}\n-\n /* The single loop exit if it dominates the latch, NULL otherwise.  */\n \n edge\n@@ -528,118 +511,91 @@ single_dom_exit (struct loop *loop)\n   return exit;\n }\n \n-/* Dumps information about the induction variable IV to FILE.  */\n+/* Dumps information about the induction variable IV to FILE.  Don't dump\n+   variable's name if DUMP_NAME is FALSE.  The information is dumped with\n+   preceding spaces indicated by INDENT_LEVEL.  */\n \n void\n-dump_iv (FILE *file, struct iv *iv, bool dump_name)\n+dump_iv (FILE *file, struct iv *iv, bool dump_name, unsigned indent_level)\n {\n+  const char *p;\n+  const char spaces[9] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '\\0'};\n+\n+  if (indent_level > 4)\n+    indent_level = 4;\n+  p = spaces + 8 - (indent_level << 1);\n+\n+  fprintf (file, \"%sIV struct:\\n\", p);\n   if (iv->ssa_name && dump_name)\n     {\n-      fprintf (file, \"ssa name \");\n+      fprintf (file, \"%s  SSA_NAME:\\t\", p);\n       print_generic_expr (file, iv->ssa_name, TDF_SLIM);\n       fprintf (file, \"\\n\");\n     }\n \n-  fprintf (file, \"  type \");\n+  fprintf (file, \"%s  Type:\\t\", p);\n   print_generic_expr (file, TREE_TYPE (iv->base), TDF_SLIM);\n   fprintf (file, \"\\n\");\n \n-  if (iv->step)\n-    {\n-      fprintf (file, \"  base \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n+  fprintf (file, \"%s  Base:\\t\", p);\n+  print_generic_expr (file, iv->base, TDF_SLIM);\n+  fprintf (file, \"\\n\");\n \n-      fprintf (file, \"  step \");\n-      print_generic_expr (file, iv->step, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n-  else\n-    {\n-      fprintf (file, \"  invariant \");\n-      print_generic_expr (file, iv->base, TDF_SLIM);\n-      fprintf (file, \"\\n\");\n-    }\n+  fprintf (file, \"%s  Step:\\t\", p);\n+  print_generic_expr (file, iv->step, TDF_SLIM);\n+  fprintf (file, \"\\n\");\n \n   if (iv->base_object)\n     {\n-      fprintf (file, \"  base object \");\n+      fprintf (file, \"%s  Object:\\t\", p);\n       print_generic_expr (file, iv->base_object, TDF_SLIM);\n       fprintf (file, \"\\n\");\n     }\n \n-  if (iv->biv_p)\n-    fprintf (file, \"  is a biv\\n\");\n+  fprintf (file, \"%s  Biv:\\t%c\\n\", p, iv->biv_p ? 'Y' : 'N');\n \n-  if (iv->no_overflow)\n-    fprintf (file, \"  iv doesn't overflow wrto loop niter\\n\");\n+  fprintf (file, \"%s  Overflowness wrto loop niter:\\t%s\\n\",\n+\t   p, iv->no_overflow ? \"No-overflow\" : \"Overflow\");\n }\n \n /* Dumps information about the USE to FILE.  */\n \n void\n dump_use (FILE *file, struct iv_use *use)\n {\n-  fprintf (file, \"use %d\", use->id);\n-  if (use->sub_id)\n-    fprintf (file, \".%d\", use->sub_id);\n-\n-  fprintf (file, \"\\n\");\n-\n-  switch (use->type)\n-    {\n-    case USE_NONLINEAR_EXPR:\n-      fprintf (file, \"  generic\\n\");\n-      break;\n-\n-    case USE_ADDRESS:\n-      fprintf (file, \"  address\\n\");\n-      break;\n-\n-    case USE_COMPARE:\n-      fprintf (file, \"  compare\\n\");\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  fprintf (file, \"  in statement \");\n+  fprintf (file, \"  Use %d.%d:\\n\", use->group_id, use->id);\n+  fprintf (file, \"    At stmt:\\t\");\n   print_gimple_stmt (file, use->stmt, 0, 0);\n-  fprintf (file, \"\\n\");\n-\n-  fprintf (file, \"  at position \");\n+  fprintf (file, \"    At pos:\\t\");\n   if (use->op_p)\n     print_generic_expr (file, *use->op_p, TDF_SLIM);\n   fprintf (file, \"\\n\");\n-\n-  dump_iv (file, use->iv, false);\n-\n-  if (use->related_cands)\n-    {\n-      fprintf (file, \"  related candidates \");\n-      dump_bitmap (file, use->related_cands);\n-    }\n+  dump_iv (file, use->iv, false, 2);\n }\n \n /* Dumps information about the uses to FILE.  */\n \n void\n-dump_uses (FILE *file, struct ivopts_data *data)\n+dump_groups (FILE *file, struct ivopts_data *data)\n {\n-  unsigned i;\n-  struct iv_use *use;\n+  unsigned i, j;\n+  struct iv_group *group;\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      do\n+      group = data->vgroups[i];\n+      fprintf (file, \"Group %d:\\n\", group->id);\n+      if (group->type == USE_NONLINEAR_EXPR)\n+\tfprintf (file, \"  Type:\\tGENERIC\\n\");\n+      else if (group->type == USE_ADDRESS)\n+\tfprintf (file, \"  Type:\\tADDRESS\\n\");\n+      else\n \t{\n-\t  dump_use (file, use);\n-\t  use = use->next;\n+\t  gcc_assert (group->type == USE_COMPARE);\n+\t  fprintf (file, \"  Type:\\tCOMPARE\\n\");\n \t}\n-      while (use);\n-      fprintf (file, \"\\n\");\n+      for (j = 0; j < group->vuses.length (); j++)\n+\tdump_use (file, group->vuses[j]);\n     }\n }\n \n@@ -650,58 +606,50 @@ dump_cand (FILE *file, struct iv_cand *cand)\n {\n   struct iv *iv = cand->iv;\n \n-  fprintf (file, \"candidate %d%s\\n\",\n-\t   cand->id, cand->important ? \" (important)\" : \"\");\n-\n+  fprintf (file, \"Candidate %d:\\n\", cand->id);\n   if (cand->depends_on)\n     {\n-      fprintf (file, \"  depends on \");\n+      fprintf (file, \"  Depend on: \");\n       dump_bitmap (file, cand->depends_on);\n     }\n \n-  if (!iv)\n-    {\n-      fprintf (file, \"  final value replacement\\n\");\n-      return;\n-    }\n-\n   if (cand->var_before)\n     {\n-      fprintf (file, \"  var_before \");\n+      fprintf (file, \"  Var befor: \");\n       print_generic_expr (file, cand->var_before, TDF_SLIM);\n       fprintf (file, \"\\n\");\n     }\n   if (cand->var_after)\n     {\n-      fprintf (file, \"  var_after \");\n+      fprintf (file, \"  Var after: \");\n       print_generic_expr (file, cand->var_after, TDF_SLIM);\n       fprintf (file, \"\\n\");\n     }\n \n   switch (cand->pos)\n     {\n     case IP_NORMAL:\n-      fprintf (file, \"  incremented before exit test\\n\");\n+      fprintf (file, \"  Incr POS: before exit test\\n\");\n       break;\n \n     case IP_BEFORE_USE:\n-      fprintf (file, \"  incremented before use %d\\n\", cand->ainc_use->id);\n+      fprintf (file, \"  Incr POS: before use %d\\n\", cand->ainc_use->id);\n       break;\n \n     case IP_AFTER_USE:\n-      fprintf (file, \"  incremented after use %d\\n\", cand->ainc_use->id);\n+      fprintf (file, \"  Incr POS: after use %d\\n\", cand->ainc_use->id);\n       break;\n \n     case IP_END:\n-      fprintf (file, \"  incremented at end\\n\");\n+      fprintf (file, \"  Incr POS: at end\\n\");\n       break;\n \n     case IP_ORIGINAL:\n-      fprintf (file, \"  original biv\\n\");\n+      fprintf (file, \"  Incr POS: orig biv\\n\");\n       break;\n     }\n \n-  dump_iv (file, iv, false);\n+  dump_iv (file, iv, false, 1);\n }\n \n /* Returns the info for ssa version VER.  */\n@@ -937,8 +885,8 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->important_candidates = BITMAP_ALLOC (NULL);\n   data->max_inv_id = 0;\n   data->niters = NULL;\n-  data->iv_uses.create (20);\n-  data->iv_candidates.create (20);\n+  data->vgroups.create (20);\n+  data->vcands.create (20);\n   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);\n   data->inv_expr_id = 0;\n   data->name_expansion_cache = NULL;\n@@ -1055,8 +1003,7 @@ alloc_iv (struct ivopts_data *data, tree base, tree step,\n   iv->base_object = determine_base_object (base);\n   iv->step = step;\n   iv->biv_p = false;\n-  iv->have_use_for = false;\n-  iv->use_id = 0;\n+  iv->nonlin_use = NULL;\n   iv->ssa_name = NULL_TREE;\n   iv->no_overflow = no_overflow;\n   iv->have_address_use = false;\n@@ -1346,92 +1293,43 @@ find_induction_variables (struct ivopts_data *data)\n \t      fprintf (dump_file, \"; zero if \");\n \t      print_generic_expr (dump_file, niter->may_be_zero, TDF_SLIM);\n \t    }\n-\t  fprintf (dump_file, \"\\n\\n\");\n-    \t};\n-\n-      fprintf (dump_file, \"Induction variables:\\n\\n\");\n+\t  fprintf (dump_file, \"\\n\");\n+\t};\n \n+      fprintf (dump_file, \"\\n<Induction Vars>:\\n\");\n       EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n \t{\n-\t  if (ver_info (data, i)->iv)\n-\t    dump_iv (dump_file, ver_info (data, i)->iv, true);\n+\t  struct version_info *info = ver_info (data, i);\n+\t  if (info->iv && info->iv->step && !integer_zerop (info->iv->step))\n+\t    dump_iv (dump_file, ver_info (data, i)->iv, true, 0);\n \t}\n     }\n \n   return true;\n }\n \n-/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.\n+/* Records a use of TYPE at *USE_P in STMT whose value is IV in GROUP.\n    For address type use, ADDR_BASE is the stripped IV base, ADDR_OFFSET\n-   is the const offset stripped from IV base.  For uses of other types,\n-   ADDR_BASE and ADDR_OFFSET are zero by default.  */\n+   is the const offset stripped from IV base; for other types use, both\n+   are zero by default.  */\n \n static struct iv_use *\n-record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n-\t    gimple *stmt, enum use_type use_type, tree addr_base = NULL,\n-\t    unsigned HOST_WIDE_INT addr_offset = 0)\n+record_use (struct iv_group *group, tree *use_p, struct iv *iv,\n+\t    gimple *stmt, enum use_type type, tree addr_base,\n+\t    unsigned HOST_WIDE_INT addr_offset)\n {\n   struct iv_use *use = XCNEW (struct iv_use);\n \n-  use->id = n_iv_uses (data);\n-  use->sub_id = 0;\n-  use->type = use_type;\n+  use->id = group->vuses.length ();\n+  use->group_id = group->id;\n+  use->type = type;\n   use->iv = iv;\n   use->stmt = stmt;\n   use->op_p = use_p;\n-  use->related_cands = BITMAP_ALLOC (NULL);\n-  use->next = NULL;\n   use->addr_base = addr_base;\n   use->addr_offset = addr_offset;\n \n-  data->iv_uses.safe_push (use);\n-\n-  return use;\n-}\n-\n-/* Records a sub use of type USE_TYPE at *USE_P in STMT whose value is IV.\n-   The sub use is recorded under the one whose use id is ID_GROUP.  */\n-\n-static struct iv_use *\n-record_sub_use (struct ivopts_data *data, tree *use_p,\n-\t\t    struct iv *iv, gimple *stmt, enum use_type use_type,\n-\t\t    tree addr_base, unsigned HOST_WIDE_INT addr_offset,\n-\t\t    unsigned int id_group)\n-{\n-  struct iv_use *use = XCNEW (struct iv_use);\n-  struct iv_use *group = iv_use (data, id_group);\n-\n-  use->id = group->id;\n-  use->sub_id = 0;\n-  use->type = use_type;\n-  use->iv = iv;\n-  use->stmt = stmt;\n-  use->op_p = use_p;\n-  use->related_cands = NULL;\n-  use->addr_base = addr_base;\n-  use->addr_offset = addr_offset;\n-\n-  /* Sub use list is maintained in offset ascending order.  */\n-  if (addr_offset <= group->addr_offset)\n-    {\n-      use->related_cands = group->related_cands;\n-      group->related_cands = NULL;\n-      use->next = group;\n-      data->iv_uses[id_group] = use;\n-    }\n-  else\n-    {\n-      struct iv_use *pre;\n-      do\n-\t{\n-\t  pre = group;\n-\t  group = group->next;\n-\t}\n-      while (group && addr_offset > group->addr_offset);\n-      use->next = pre->next;\n-      pre->next = use;\n-    }\n-\n+  group->vuses.safe_push (use);\n   return use;\n }\n \n@@ -1462,6 +1360,67 @@ record_invariant (struct ivopts_data *data, tree op, bool nonlinear_use)\n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (op));\n }\n \n+static tree\n+strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);\n+\n+/* Record a group of TYPE.  */\n+\n+static struct iv_group *\n+record_group (struct ivopts_data *data, enum use_type type)\n+{\n+  struct iv_group *group = XCNEW (struct iv_group);\n+\n+  group->id = data->vgroups.length ();\n+  group->type = type;\n+  group->related_cands = BITMAP_ALLOC (NULL);\n+  group->vuses.create (1);\n+\n+  data->vgroups.safe_push (group);\n+  return group;\n+}\n+\n+/* Record a use of TYPE at *USE_P in STMT whose value is IV in a group.\n+   New group will be created if there is no existing group for the use.  */\n+\n+static struct iv_use *\n+record_group_use (struct ivopts_data *data, tree *use_p,\n+\t\t  struct iv *iv, gimple *stmt, enum use_type type)\n+{\n+  tree addr_base = NULL;\n+  struct iv_group *group = NULL;\n+  unsigned HOST_WIDE_INT addr_offset = 0;\n+\n+  /* Record non address type use in a new group.  */\n+  if (type == USE_ADDRESS && iv->base_object)\n+    {\n+      unsigned int i;\n+\n+      addr_base = strip_offset (iv->base, &addr_offset);\n+      for (i = 0; i < data->vgroups.length (); i++)\n+\t{\n+\t  struct iv_use *use;\n+\n+\t  group = data->vgroups[i];\n+\t  use = group->vuses[0];\n+\t  if (use->type != USE_ADDRESS || !use->iv->base_object)\n+\t    continue;\n+\n+\t  /* Check if it has the same stripped base and step.  */\n+\t  if (operand_equal_p (iv->base_object, use->iv->base_object, 0)\n+\t      && operand_equal_p (iv->step, use->iv->step, 0)\n+\t      && operand_equal_p (addr_base, use->addr_base, 0))\n+\t    break;\n+\t}\n+      if (i == data->vgroups.length ())\n+\tgroup = NULL;\n+    }\n+\n+  if (!group)\n+    group = record_group (data, type);\n+\n+  return record_use (group, use_p, iv, stmt, type, addr_base, addr_offset);\n+}\n+\n /* Checks whether the use OP is interesting and if so, records it.  */\n \n static struct iv_use *\n@@ -1478,28 +1437,23 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n   if (!iv)\n     return NULL;\n \n-  if (iv->have_use_for)\n+  if (iv->nonlin_use)\n     {\n-      use = iv_use (data, iv->use_id);\n-\n-      gcc_assert (use->type == USE_NONLINEAR_EXPR);\n-      return use;\n+      gcc_assert (iv->nonlin_use->type == USE_NONLINEAR_EXPR);\n+      return iv->nonlin_use;\n     }\n \n   if (integer_zerop (iv->step))\n     {\n       record_invariant (data, op, true);\n       return NULL;\n     }\n-  iv->have_use_for = true;\n \n   stmt = SSA_NAME_DEF_STMT (op);\n-  gcc_assert (gimple_code (stmt) == GIMPLE_PHI\n-\t      || is_gimple_assign (stmt));\n-\n-  use = record_use (data, NULL, iv, stmt, USE_NONLINEAR_EXPR);\n-  iv->use_id = use->id;\n+  gcc_assert (gimple_code (stmt) == GIMPLE_PHI || is_gimple_assign (stmt));\n \n+  use = record_group_use (data, NULL, iv, stmt, USE_NONLINEAR_EXPR);\n+  iv->nonlin_use = use;\n   return use;\n }\n \n@@ -1585,7 +1539,7 @@ find_interesting_uses_cond (struct ivopts_data *data, gimple *stmt)\n       return;\n     }\n \n-  record_use (data, NULL, var_iv, stmt, USE_COMPARE);\n+  record_group_use (data, NULL, var_iv, stmt, USE_COMPARE);\n }\n \n /* Returns the outermost loop EXPR is obviously invariant in\n@@ -2074,50 +2028,6 @@ may_be_nonaddressable_p (tree expr)\n   return false;\n }\n \n-static tree\n-strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);\n-\n-/* Record a use of type USE_TYPE at *USE_P in STMT whose value is IV.\n-   If there is an existing use which has same stripped iv base and step,\n-   this function records this one as a sub use to that; otherwise records\n-   it as a normal one.  */\n-\n-static struct iv_use *\n-record_group_use (struct ivopts_data *data, tree *use_p,\n-\t\t  struct iv *iv, gimple *stmt, enum use_type use_type)\n-{\n-  unsigned int i;\n-  struct iv_use *use;\n-  tree addr_base;\n-  unsigned HOST_WIDE_INT addr_offset;\n-\n-  /* Only support sub use for address type uses, that is, with base\n-     object.  */\n-  if (!iv->base_object)\n-    return record_use (data, use_p, iv, stmt, use_type);\n-\n-  addr_base = strip_offset (iv->base, &addr_offset);\n-  for (i = 0; i < n_iv_uses (data); i++)\n-    {\n-      use = iv_use (data, i);\n-      if (use->type != USE_ADDRESS || !use->iv->base_object)\n-\tcontinue;\n-\n-      /* Check if it has the same stripped base and step.  */\n-      if (operand_equal_p (iv->base_object, use->iv->base_object, 0)\n-\t  && operand_equal_p (iv->step, use->iv->step, 0)\n-\t  && operand_equal_p (addr_base, use->addr_base, 0))\n-\tbreak;\n-    }\n-\n-  if (i == n_iv_uses (data))\n-    return record_use (data, use_p, iv, stmt,\n-\t\t       use_type, addr_base, addr_offset);\n-  else\n-    return record_sub_use (data, use_p, iv, stmt,\n-\t\t\t   use_type, addr_base, addr_offset, i);\n-}\n-\n /* Finds addresses in *OP_P inside STMT.  */\n \n static void\n@@ -2359,62 +2269,6 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n     }\n }\n \n-/* Finds uses of the induction variables that are interesting.  */\n-\n-static void\n-find_interesting_uses (struct ivopts_data *data)\n-{\n-  basic_block bb;\n-  gimple_stmt_iterator bsi;\n-  basic_block *body = get_loop_body (data->current_loop);\n-  unsigned i;\n-  struct version_info *info;\n-  edge e;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Uses:\\n\\n\");\n-\n-  for (i = 0; i < data->current_loop->num_nodes; i++)\n-    {\n-      edge_iterator ei;\n-      bb = body[i];\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t    && !flow_bb_inside_loop_p (data->current_loop, e->dest))\n-\t  find_interesting_uses_outside (data, e);\n-\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tfind_interesting_uses_stmt (data, gsi_stmt (bsi));\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tif (!is_gimple_debug (gsi_stmt (bsi)))\n-\t  find_interesting_uses_stmt (data, gsi_stmt (bsi));\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      bitmap_iterator bi;\n-\n-      fprintf (dump_file, \"\\n\");\n-\n-      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n-\t{\n-\t  info = ver_info (data, i);\n-\t  if (info->inv_id)\n-\t    {\n-\t      fprintf (dump_file, \"  \");\n-\t      print_generic_expr (dump_file, info->name, TDF_SLIM);\n-\t      fprintf (dump_file, \" is invariant (%d)%s\\n\",\n-\t\t       info->inv_id, info->has_nonlin_use ? \"\" : \", eliminable\");\n-\t    }\n-\t}\n-\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  free (body);\n-}\n-\n /* Compute maximum offset of [base + offset] addressing mode\n    for memory reference represented by USE.  */\n \n@@ -2478,107 +2332,178 @@ compute_max_addr_offset (struct iv_use *use)\n   return off;\n }\n \n-/* Check if all small groups should be split.  Return true if and\n-   only if:\n+/* Comparison function to sort group in ascending order of addr_offset.  */\n \n-     1) At least one groups contain two uses with different offsets.\n-     2) No group contains more than two uses with different offsets.\n+static int\n+group_compare_offset (const void *a, const void *b)\n+{\n+  const struct iv_use *const *u1 = (const struct iv_use *const *) a;\n+  const struct iv_use *const *u2 = (const struct iv_use *const *) b;\n+\n+  if ((*u1)->addr_offset != (*u2)->addr_offset)\n+    return (*u1)->addr_offset < (*u2)->addr_offset ? -1 : 1;\n+  else\n+    return 0;\n+}\n \n-   Return false otherwise.  We want to split such groups because:\n+/* Check if small groups should be split.  Return true if no group\n+   contains more than two uses with distinct addr_offsets.  Return\n+   false otherwise.  We want to split such groups because:\n \n      1) Small groups don't have much benefit and may interfer with\n \tgeneral candidate selection.\n      2) Size for problem with only small groups is usually small and\n \tgeneral algorithm can handle it well.\n \n-   TODO -- Above claim may not hold when auto increment is supported.  */\n+   TODO -- Above claim may not hold when we want to merge memory\n+   accesses with conseuctive addresses.  */\n \n static bool\n-split_all_small_groups (struct ivopts_data *data)\n+split_small_address_groups_p (struct ivopts_data *data)\n {\n-  bool split_p = false;\n-  unsigned int i, n, distinct;\n-  struct iv_use *pre, *use;\n+  unsigned int i, j, distinct = 1;\n+  struct iv_use *pre;\n+  struct iv_group *group;\n \n-  n = n_iv_uses (data);\n-  for (i = 0; i < n; i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      if (!use->next)\n+      group = data->vgroups[i];\n+      if (group->vuses.length () == 1)\n+\tcontinue;\n+\n+      gcc_assert (group->type == USE_ADDRESS);\n+      if (group->vuses.length () == 2)\n+\t{\n+\t  if (group->vuses[0]->addr_offset > group->vuses[1]->addr_offset)\n+\t    std::swap (group->vuses[0], group->vuses[1]);\n+\t}\n+      else\n+\tgroup->vuses.qsort (group_compare_offset);\n+\n+      if (distinct > 2)\n \tcontinue;\n \n       distinct = 1;\n-      gcc_assert (use->type == USE_ADDRESS);\n-      for (pre = use, use = use->next; use; pre = use, use = use->next)\n+      for (pre = group->vuses[0], j = 1; j < group->vuses.length (); j++)\n \t{\n-\t  if (pre->addr_offset != use->addr_offset)\n-\t    distinct++;\n+\t  if (group->vuses[j]->addr_offset != pre->addr_offset)\n+\t    {\n+\t      pre = group->vuses[j];\n+\t      distinct++;\n+\t    }\n \n \t  if (distinct > 2)\n-\t    return false;\n+\t    break;\n \t}\n-      if (distinct == 2)\n-\tsplit_p = true;\n     }\n \n-  return split_p;\n+  return (distinct <= 2);\n }\n \n /* For each group of address type uses, this function further groups\n    these uses according to the maximum offset supported by target's\n    [base + offset] addressing mode.  */\n \n static void\n-group_address_uses (struct ivopts_data *data)\n+split_address_groups (struct ivopts_data *data)\n {\n+  unsigned int i, j;\n   HOST_WIDE_INT max_offset = -1;\n-  unsigned int i, n, sub_id;\n-  struct iv_use *pre, *use;\n-  unsigned HOST_WIDE_INT addr_offset_first;\n \n   /* Reset max offset to split all small groups.  */\n-  if (split_all_small_groups (data))\n+  if (split_small_address_groups_p (data))\n     max_offset = 0;\n \n-  n = n_iv_uses (data);\n-  for (i = 0; i < n; i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      if (!use->next)\n+      struct iv_group *group = data->vgroups[i];\n+      struct iv_use *use = group->vuses[0];\n+\n+      use->id = 0;\n+      use->group_id = group->id;\n+      if (group->vuses.length () == 1)\n \tcontinue;\n \n-      gcc_assert (use->type == USE_ADDRESS);\n       if (max_offset != 0)\n \tmax_offset = compute_max_addr_offset (use);\n \n-      while (use)\n+      for (j = 1; j < group->vuses.length (); j++)\n \t{\n-\t  sub_id = 0;\n-\t  addr_offset_first = use->addr_offset;\n+\t  struct iv_use *next = group->vuses[j];\n+\n \t  /* Only uses with offset that can fit in offset part against\n \t     the first use can be grouped together.  */\n-\t  for (pre = use, use = use->next;\n-\t       use && (use->addr_offset - addr_offset_first\n-\t\t       <= (unsigned HOST_WIDE_INT) max_offset);\n-\t       pre = use, use = use->next)\n-\t    {\n-\t      use->id = pre->id;\n-\t      use->sub_id = ++sub_id;\n-\t    }\n+\t  if (next->addr_offset - use->addr_offset\n+\t      > (unsigned HOST_WIDE_INT) max_offset)\n+\t    break;\n+\n+\t  next->id = j;\n+\t  next->group_id = group->id;\n+\t}\n+      /* Split group.  */\n+      if (j < group->vuses.length ())\n+\t{\n+\t  struct iv_group *new_group = record_group (data, group->type);\n+\t  new_group->vuses.safe_splice (group->vuses);\n+\t  new_group->vuses.block_remove (0, j);\n+\t  group->vuses.truncate (j);\n+\t}\n+    }\n+}\n+\n+/* Finds uses of the induction variables that are interesting.  */\n+\n+static void\n+find_interesting_uses (struct ivopts_data *data)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator bsi;\n+  basic_block *body = get_loop_body (data->current_loop);\n+  unsigned i;\n+  edge e;\n+\n+  for (i = 0; i < data->current_loop->num_nodes; i++)\n+    {\n+      edge_iterator ei;\n+      bb = body[i];\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t    && !flow_bb_inside_loop_p (data->current_loop, e->dest))\n+\t  find_interesting_uses_outside (data, e);\n+\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tfind_interesting_uses_stmt (data, gsi_stmt (bsi));\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tif (!is_gimple_debug (gsi_stmt (bsi)))\n+\t  find_interesting_uses_stmt (data, gsi_stmt (bsi));\n+    }\n+\n+  split_address_groups (data);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      bitmap_iterator bi;\n \n-\t  /* Break the list and create new group.  */\n-\t  if (use)\n+      fprintf (dump_file, \"\\n<Invariant Vars>:\\n\");\n+      EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n+\t{\n+\t  struct version_info *info = ver_info (data, i);\n+\t  if (info->inv_id)\n \t    {\n-\t      pre->next = NULL;\n-\t      use->id = n_iv_uses (data);\n-\t      use->related_cands = BITMAP_ALLOC (NULL);\n-\t      data->iv_uses.safe_push (use);\n+\t      fprintf (dump_file, \"Inv %d:\\t\", info->inv_id);\n+\t      print_generic_expr (dump_file, info->name, TDF_SLIM);\n+\t      fprintf (dump_file, \"%s\\n\",\n+\t\t       info->has_nonlin_use ? \"\" : \"\\t(eliminable)\");\n \t    }\n \t}\n+\n+      fprintf (dump_file, \"\\n<IV Groups>:\\n\");\n+      dump_groups (dump_file, data);\n+      fprintf (dump_file, \"\\n\");\n     }\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_uses (dump_file, data);\n+  free (body);\n }\n \n /* Strips constant offsets from EXPR and stores them to OFFSET.  If INSIDE_ADDR\n@@ -2820,6 +2745,8 @@ add_candidate_1 (struct ivopts_data *data,\n   struct iv_cand *cand = NULL;\n   tree type, orig_type;\n \n+  gcc_assert (base && step);\n+\n   /* -fkeep-gc-roots-live means that we have to keep a real pointer\n      live, but the ivopts code may replace a real pointer with one\n      pointing before or after the memory block that is then adjusted\n@@ -2844,9 +2771,9 @@ add_candidate_1 (struct ivopts_data *data,\n \t}\n     }\n \n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      cand = iv_cand (data, i);\n+      cand = data->vcands[i];\n \n       if (cand->pos != pos)\n \tcontinue;\n@@ -2856,46 +2783,29 @@ add_candidate_1 (struct ivopts_data *data,\n \t      && cand->ainc_use != use))\n \tcontinue;\n \n-      if (!cand->iv)\n-\t{\n-\t  if (!base && !step)\n-\t    break;\n-\n-\t  continue;\n-\t}\n-\n-      if (!base && !step)\n-\tcontinue;\n-\n       if (operand_equal_p (base, cand->iv->base, 0)\n \t  && operand_equal_p (step, cand->iv->step, 0)\n           && (TYPE_PRECISION (TREE_TYPE (base))\n               == TYPE_PRECISION (TREE_TYPE (cand->iv->base))))\n \tbreak;\n     }\n \n-  if (i == n_iv_cands (data))\n+  if (i == data->vcands.length ())\n     {\n       cand = XCNEW (struct iv_cand);\n       cand->id = i;\n-\n-      if (!base && !step)\n-\tcand->iv = NULL;\n-      else\n-\tcand->iv = alloc_iv (data, base, step);\n-\n+      cand->iv = alloc_iv (data, base, step);\n       cand->pos = pos;\n-      if (pos != IP_ORIGINAL && cand->iv)\n+      if (pos != IP_ORIGINAL)\n \t{\n \t  cand->var_before = create_tmp_var_raw (TREE_TYPE (base), \"ivtmp\");\n \t  cand->var_after = cand->var_before;\n \t}\n       cand->important = important;\n       cand->incremented_at = incremented_at;\n-      data->iv_candidates.safe_push (cand);\n+      data->vcands.safe_push (cand);\n \n-      if (step\n-\t  && TREE_CODE (step) != INTEGER_CST)\n+      if (TREE_CODE (step) != INTEGER_CST)\n \t{\n \t  fd_ivopts_data = data;\n \t  walk_tree (&step, find_depends, &cand->depends_on, NULL);\n@@ -2911,20 +2821,11 @@ add_candidate_1 (struct ivopts_data *data,\n \tdump_cand (dump_file, cand);\n     }\n \n-  if (important && !cand->important)\n-    {\n-      cand->important = true;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Candidate %d is important\\n\", cand->id);\n-    }\n+  cand->important |= important;\n \n+  /* Relate candidate to the group for which it is added.  */\n   if (use)\n-    {\n-      bitmap_set_bit (use->related_cands, i);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Candidate %d is related to use %d\\n\",\n-\t\t cand->id, use->id);\n-    }\n+    bitmap_set_bit (data->vgroups[use->group_id]->related_cands, i);\n \n   return cand;\n }\n@@ -3018,8 +2919,6 @@ add_candidate (struct ivopts_data *data,\n \t       tree base, tree step, bool important, struct iv_use *use,\n \t       struct iv *orig_iv = NULL)\n {\n-  gcc_assert (use == NULL || use->sub_id == 0);\n-\n   if (ip_normal_pos (data->current_loop))\n     add_candidate_1 (data, base, step, important,\n \t\t     IP_NORMAL, use, NULL, orig_iv);\n@@ -3071,7 +2970,7 @@ add_iv_candidate_for_biv (struct ivopts_data *data, struct iv *iv)\n       /* Add iv cand of same precision as index part in TARGET_MEM_REF.  */\n       add_candidate (data, base, step, true, NULL, iv);\n       /* Add iv cand of the original type only if it has nonlinear use.  */\n-      if (iv->have_use_for)\n+      if (iv->nonlin_use)\n \tadd_candidate (data, iv->base, iv->step, true, NULL);\n     }\n   else\n@@ -3135,8 +3034,6 @@ record_common_cand (struct ivopts_data *data, tree base,\n   struct iv_common_cand ent;\n   struct iv_common_cand **slot;\n \n-  gcc_assert (use != NULL);\n-\n   ent.base = base;\n   ent.step = step;\n   ent.hash = iterative_hash_expr (base, 0);\n@@ -3152,6 +3049,8 @@ record_common_cand (struct ivopts_data *data, tree base,\n       (*slot)->hash = ent.hash;\n       data->iv_common_cands.safe_push ((*slot));\n     }\n+\n+  gcc_assert (use != NULL);\n   (*slot)->uses.safe_push (use);\n   return;\n }\n@@ -3203,11 +3102,11 @@ add_iv_candidate_derived_from_uses (struct ivopts_data *data)\n       /* Bind deriving uses and the new candidates.  */\n       for (j = 0; j < ptr->uses.length (); j++)\n \t{\n-\t  struct iv_use *use = ptr->uses[j];\n+\t  struct iv_group *group = data->vgroups[ptr->uses[j]->group_id];\n \t  if (cand_1)\n-\t    bitmap_set_bit (use->related_cands, cand_1->id);\n+\t    bitmap_set_bit (group->related_cands, cand_1->id);\n \t  if (cand_2)\n-\t    bitmap_set_bit (use->related_cands, cand_2->id);\n+\t    bitmap_set_bit (group->related_cands, cand_2->id);\n \t}\n     }\n \n@@ -3294,29 +3193,17 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n /* Adds candidates based on the uses.  */\n \n static void\n-add_iv_candidate_for_uses (struct ivopts_data *data)\n+add_iv_candidate_for_groups (struct ivopts_data *data)\n {\n   unsigned i;\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  /* Only add candidate for the first use in group.  */\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      struct iv_use *use = iv_use (data, i);\n+      struct iv_group *group = data->vgroups[i];\n \n-      if (!use)\n-\tcontinue;\n-\n-      switch (use->type)\n-\t{\n-\tcase USE_NONLINEAR_EXPR:\n-\tcase USE_COMPARE:\n-\tcase USE_ADDRESS:\n-\t  /* Just add the ivs based on the value of the iv used here.  */\n-\t  add_iv_candidate_for_use (data, use);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      gcc_assert (group->vuses[0] != NULL);\n+      add_iv_candidate_for_use (data, group->vuses[0]);\n     }\n   add_iv_candidate_derived_from_uses (data);\n }\n@@ -3327,24 +3214,24 @@ static void\n record_important_candidates (struct ivopts_data *data)\n {\n   unsigned i;\n-  struct iv_use *use;\n+  struct iv_group *group;\n \n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      struct iv_cand *cand = iv_cand (data, i);\n+      struct iv_cand *cand = data->vcands[i];\n \n       if (cand->important)\n \tbitmap_set_bit (data->important_candidates, i);\n     }\n \n-  data->consider_all_candidates = (n_iv_cands (data)\n+  data->consider_all_candidates = (data->vcands.length ()\n \t\t\t\t   <= CONSIDER_ALL_CANDIDATES_BOUND);\n \n-  /* Add important candidates to uses' related_cands bitmaps.  */\n-  for (i = 0; i < n_iv_uses (data); i++)\n+  /* Add important candidates to groups' related_cands bitmaps.  */\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      bitmap_ior_into (use->related_cands, data->important_candidates);\n+      group = data->vgroups[i];\n+      bitmap_ior_into (group->related_cands, data->important_candidates);\n     }\n }\n \n@@ -3357,22 +3244,22 @@ alloc_use_cost_map (struct ivopts_data *data)\n {\n   unsigned i, size, s;\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      struct iv_use *use = iv_use (data, i);\n+      struct iv_group *group = data->vgroups[i];\n \n       if (data->consider_all_candidates)\n-\tsize = n_iv_cands (data);\n+\tsize = data->vcands.length ();\n       else\n \t{\n-\t  s = bitmap_count_bits (use->related_cands);\n+\t  s = bitmap_count_bits (group->related_cands);\n \n \t  /* Round up to the power of two, so that moduling by it is fast.  */\n \t  size = s ? (1 << ceil_log2 (s)) : 1;\n \t}\n \n-      use->n_map_members = size;\n-      use->cost_map = XCNEWVEC (struct cost_pair, size);\n+      group->n_map_members = size;\n+      group->cost_map = XCNEWVEC (struct cost_pair, size);\n     }\n }\n \n@@ -3434,15 +3321,15 @@ compare_costs (comp_cost cost1, comp_cost cost2)\n   return cost1.cost - cost2.cost;\n }\n \n-/* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n+/* Sets cost of (GROUP, CAND) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n    is VALUE, and in case of iv elimination the comparison operator is COMP.  */\n \n static void\n-set_use_iv_cost (struct ivopts_data *data,\n-\t\t struct iv_use *use, struct iv_cand *cand,\n-\t\t comp_cost cost, bitmap depends_on, tree value,\n-\t\t enum tree_code comp, int inv_expr_id)\n+set_group_iv_cost (struct ivopts_data *data,\n+\t\t   struct iv_group *group, struct iv_cand *cand,\n+\t\t   comp_cost cost, bitmap depends_on, tree value,\n+\t\t   enum tree_code comp, int inv_expr_id)\n {\n   unsigned i, s;\n \n@@ -3454,40 +3341,40 @@ set_use_iv_cost (struct ivopts_data *data,\n \n   if (data->consider_all_candidates)\n     {\n-      use->cost_map[cand->id].cand = cand;\n-      use->cost_map[cand->id].cost = cost;\n-      use->cost_map[cand->id].depends_on = depends_on;\n-      use->cost_map[cand->id].value = value;\n-      use->cost_map[cand->id].comp = comp;\n-      use->cost_map[cand->id].inv_expr_id = inv_expr_id;\n+      group->cost_map[cand->id].cand = cand;\n+      group->cost_map[cand->id].cost = cost;\n+      group->cost_map[cand->id].depends_on = depends_on;\n+      group->cost_map[cand->id].value = value;\n+      group->cost_map[cand->id].comp = comp;\n+      group->cost_map[cand->id].inv_expr_id = inv_expr_id;\n       return;\n     }\n \n   /* n_map_members is a power of two, so this computes modulo.  */\n-  s = cand->id & (use->n_map_members - 1);\n-  for (i = s; i < use->n_map_members; i++)\n-    if (!use->cost_map[i].cand)\n+  s = cand->id & (group->n_map_members - 1);\n+  for (i = s; i < group->n_map_members; i++)\n+    if (!group->cost_map[i].cand)\n       goto found;\n   for (i = 0; i < s; i++)\n-    if (!use->cost_map[i].cand)\n+    if (!group->cost_map[i].cand)\n       goto found;\n \n   gcc_unreachable ();\n \n found:\n-  use->cost_map[i].cand = cand;\n-  use->cost_map[i].cost = cost;\n-  use->cost_map[i].depends_on = depends_on;\n-  use->cost_map[i].value = value;\n-  use->cost_map[i].comp = comp;\n-  use->cost_map[i].inv_expr_id = inv_expr_id;\n+  group->cost_map[i].cand = cand;\n+  group->cost_map[i].cost = cost;\n+  group->cost_map[i].depends_on = depends_on;\n+  group->cost_map[i].value = value;\n+  group->cost_map[i].comp = comp;\n+  group->cost_map[i].inv_expr_id = inv_expr_id;\n }\n \n-/* Gets cost of (USE, CANDIDATE) pair.  */\n+/* Gets cost of (GROUP, CAND) pair.  */\n \n static struct cost_pair *\n-get_use_iv_cost (struct ivopts_data *data, struct iv_use *use,\n-\t\t struct iv_cand *cand)\n+get_group_iv_cost (struct ivopts_data *data, struct iv_group *group,\n+\t\t   struct iv_cand *cand)\n {\n   unsigned i, s;\n   struct cost_pair *ret;\n@@ -3497,24 +3384,24 @@ get_use_iv_cost (struct ivopts_data *data, struct iv_use *use,\n \n   if (data->consider_all_candidates)\n     {\n-      ret = use->cost_map + cand->id;\n+      ret = group->cost_map + cand->id;\n       if (!ret->cand)\n \treturn NULL;\n \n       return ret;\n     }\n \n   /* n_map_members is a power of two, so this computes modulo.  */\n-  s = cand->id & (use->n_map_members - 1);\n-  for (i = s; i < use->n_map_members; i++)\n-    if (use->cost_map[i].cand == cand)\n-      return use->cost_map + i;\n-    else if (use->cost_map[i].cand == NULL)\n+  s = cand->id & (group->n_map_members - 1);\n+  for (i = s; i < group->n_map_members; i++)\n+    if (group->cost_map[i].cand == cand)\n+      return group->cost_map + i;\n+    else if (group->cost_map[i].cand == NULL)\n       return NULL;\n   for (i = 0; i < s; i++)\n-    if (use->cost_map[i].cand == cand)\n-      return use->cost_map + i;\n-    else if (use->cost_map[i].cand == NULL)\n+    if (group->cost_map[i].cand == cand)\n+      return group->cost_map + i;\n+    else if (group->cost_map[i].cand == NULL)\n       return NULL;\n \n   return NULL;\n@@ -4177,7 +4064,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"Address costs:\\n\");\n+\t  fprintf (dump_file, \"<Address Costs>:\\n\");\n \n \t  for (i = 0; i < 16; i++)\n \t    {\n@@ -4956,15 +4843,8 @@ get_computation_cost_at (struct ivopts_data *data,\n \n   /* Record setup cost in scrach field.  */\n   cost.scratch = cost.cost;\n-  /* Set of invariants depended on by sub use has already been computed\n-     for the first use in the group.  */\n-  if (use->sub_id)\n-    {\n-      cost.cost = 0;\n-      if (depends_on && *depends_on)\n-\tbitmap_clear (*depends_on);\n-    }\n-  else if (inv_expr_id)\n+\n+  if (inv_expr_id)\n     {\n       *inv_expr_id =\n           get_loop_invariant_expr_id (data, ubase, cbase, ratio, address_p);\n@@ -5054,109 +4934,98 @@ get_computation_cost (struct ivopts_data *data,\n \t\t\t\t  can_autoinc, inv_expr_id);\n }\n \n-/* Determines cost of basing replacement of USE on CAND in a generic\n+/* Determines cost of computing the use in GROUP with CAND in a generic\n    expression.  */\n \n static bool\n-determine_use_iv_cost_generic (struct ivopts_data *data,\n-\t\t\t       struct iv_use *use, struct iv_cand *cand)\n+determine_group_iv_cost_generic (struct ivopts_data *data,\n+\t\t\t\t struct iv_group *group, struct iv_cand *cand)\n {\n-  bitmap depends_on;\n   comp_cost cost;\n   int inv_expr_id = -1;\n+  bitmap depends_on = NULL;\n+  struct iv_use *use = group->vuses[0];\n \n   /* The simple case first -- if we need to express value of the preserved\n      original biv, the cost is 0.  This also prevents us from counting the\n      cost of increment twice -- once at this use and once in the cost of\n      the candidate.  */\n-  if (cand->pos == IP_ORIGINAL\n-      && cand->incremented_at == use->stmt)\n-    {\n-      set_use_iv_cost (data, use, cand, no_cost, NULL, NULL_TREE,\n-                       ERROR_MARK, -1);\n-      return true;\n-    }\n-\n-  cost = get_computation_cost (data, use, cand, false, &depends_on,\n-                               NULL, &inv_expr_id);\n-\n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,\n-                   inv_expr_id);\n+  if (cand->pos == IP_ORIGINAL && cand->incremented_at == use->stmt)\n+    cost = no_cost;\n+  else\n+    cost = get_computation_cost (data, use, cand, false,\n+\t\t\t\t &depends_on, NULL, &inv_expr_id);\n \n+  set_group_iv_cost (data, group, cand, cost, depends_on,\n+\t\t     NULL_TREE, ERROR_MARK, inv_expr_id);\n   return !infinite_cost_p (cost);\n }\n \n-/* Determines cost of basing replacement of USE on CAND in an address.  */\n+/* Determines cost of computing uses in GROUP with CAND in addresses.  */\n \n static bool\n-determine_use_iv_cost_address (struct ivopts_data *data,\n-\t\t\t       struct iv_use *use, struct iv_cand *cand)\n+determine_group_iv_cost_address (struct ivopts_data *data,\n+\t\t\t\t struct iv_group *group, struct iv_cand *cand)\n {\n+  unsigned i;\n   bitmap depends_on;\n-  bool can_autoinc, first;\n+  bool can_autoinc, first = true;\n   int inv_expr_id = -1;\n-  struct iv_use *sub_use;\n-  comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,\n-\t\t\t\t\t &can_autoinc, &inv_expr_id);\n-  comp_cost sub_cost = cost;\n+  struct iv_use *use = group->vuses[0];\n+  comp_cost sum_cost = no_cost, cost;\n \n-  if (cand->ainc_use == use)\n+  cost = get_computation_cost (data, use, cand, true,\n+\t\t\t       &depends_on, &can_autoinc, &inv_expr_id);\n+\n+  sum_cost = cost;\n+  if (!infinite_cost_p (sum_cost) && cand->ainc_use == use)\n     {\n       if (can_autoinc)\n-\tcost.cost -= cand->cost_step;\n+\tsum_cost.cost -= cand->cost_step;\n       /* If we generated the candidate solely for exploiting autoincrement\n \t opportunities, and it turns out it can't be used, set the cost to\n \t infinity to make sure we ignore it.  */\n       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n-\tcost = infinite_cost;\n-    }\n-\n-  if (!infinite_cost_p (cost) && use->next)\n-    {\n-      first = true;\n-      sub_use = use->next;\n-      /* We don't want to add setup cost for sub-uses.  */\n-      sub_cost.cost -= sub_cost.scratch;\n-      /* Add cost for sub uses in group.  */\n-      do\n+\tsum_cost = infinite_cost;\n+    }\n+\n+  /* Uses in a group can share setup code, so only add setup cost once.  */\n+  cost.cost -= cost.scratch;\n+  /* Compute and add costs for rest uses of this group.  */\n+  for (i = 1; i < group->vuses.length () && !infinite_cost_p (sum_cost); i++)\n+    {\n+      struct iv_use *next = group->vuses[i];\n+\n+      /* Compute cost for the first use with different offset to the main\n+\t use and add it afterwards.  Costs for these uses could be quite\n+\t different.  Given below uses in a group:\n+\t   use 0  : {base + A + offset_0, step}\n+\t   use 0.1: {base + A + offset_0, step}\n+\t   use 0.2: {base + A + offset_1, step}\n+\t   use 0.3: {base + A + offset_2, step}\n+\t when we need to compute costs with candidate:\n+\t   cand 1 : {base + B + offset_0, step}\n+\n+\t The first use with different offset is use 0.2, its cost is larger\n+\t than cost of use 0/0.1 because we need to compute:\n+\t   A - B + offset_1 - offset_0\n+\t   rather than:\n+\t   A - B.  */\n+      if (first && next->addr_offset != use->addr_offset)\n \t{\n-\t  /* Compute cost for the first sub use with different offset to\n-\t     the main use and add it afterwards.  Costs for these uses\n-\t     could be quite different.  Given below uses in a group:\n-\t       use 0  : {base + A + offset_0, step}\n-\t       use 0.1: {base + A + offset_0, step}\n-\t       use 0.2: {base + A + offset_1, step}\n-\t       use 0.3: {base + A + offset_2, step}\n-\t     when we need to compute costs with candidate:\n-\t       cand 1 : {base + B + offset_0, step}\n-\n-\t     The first sub use with different offset is use 0.2, its cost\n-\t     is larger than cost of use 0/0.1 because we need to compute:\n-\t       A - B + offset_1 - offset_0\n-\t     rather than:\n-\t       A - B.  */\n-\t  if (first && use->addr_offset != sub_use->addr_offset)\n-\t    {\n-\t      first = false;\n-\t      sub_cost = get_computation_cost (data, sub_use, cand, true,\n-\t\t\t\t\t       NULL, &can_autoinc, NULL);\n-\t      if (infinite_cost_p (sub_cost))\n-\t\t{\n-\t\t  cost = infinite_cost;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\n-\t  cost = add_costs (cost, sub_cost);\n-\t  sub_use = sub_use->next;\n+\t  first = false;\n+\t  cost = get_computation_cost (data, next, cand, true,\n+\t\t\t\t       NULL, &can_autoinc, NULL);\n+\t  /* Remove setup cost.  */\n+\t  if (!infinite_cost_p (cost))\n+\t    cost.cost -= cost.scratch;\n \t}\n-      while (sub_use);\n+      sum_cost = add_costs (sum_cost, cost);\n     }\n+  set_group_iv_cost (data, group, cand, sum_cost, depends_on,\n+\t\t     NULL_TREE, ERROR_MARK, inv_expr_id);\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,\n-                   inv_expr_id);\n-\n-  return !infinite_cost_p (cost);\n+  return !infinite_cost_p (sum_cost);\n }\n \n /* Computes value of candidate CAND at position AT in iteration NITER, and\n@@ -5562,11 +5431,11 @@ parm_decl_cost (struct ivopts_data *data, tree bound)\n   return 0;\n }\n \n-/* Determines cost of basing replacement of USE on CAND in a condition.  */\n+/* Determines cost of computing the use in GROUP with CAND in a condition.  */\n \n static bool\n-determine_use_iv_cost_condition (struct ivopts_data *data,\n-\t\t\t\t struct iv_use *use, struct iv_cand *cand)\n+determine_group_iv_cost_cond (struct ivopts_data *data,\n+\t\t\t      struct iv_group *group, struct iv_cand *cand)\n {\n   tree bound = NULL_TREE;\n   struct iv *cmp_iv;\n@@ -5576,14 +5445,9 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   int elim_inv_expr_id = -1, express_inv_expr_id = -1, inv_expr_id;\n   tree *control_var, *bound_cst;\n   enum tree_code comp = ERROR_MARK;\n+  struct iv_use *use = group->vuses[0];\n \n-  /* Only consider real candidates.  */\n-  if (!cand->iv)\n-    {\n-      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE,\n-\t\t       ERROR_MARK, -1);\n-      return false;\n-    }\n+  gcc_assert (cand->iv);\n \n   /* Try iv elimination.  */\n   if (may_eliminate_iv (data, use, cand, &bound, &comp))\n@@ -5661,7 +5525,8 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       inv_expr_id = express_inv_expr_id;\n     }\n \n-  set_use_iv_cost (data, use, cand, cost, depends_on, bound, comp, inv_expr_id);\n+  set_group_iv_cost (data, group, cand, cost,\n+\t\t     depends_on, bound, comp, inv_expr_id);\n \n   if (depends_on_elim)\n     BITMAP_FREE (depends_on_elim);\n@@ -5671,23 +5536,23 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   return !infinite_cost_p (cost);\n }\n \n-/* Determines cost of basing replacement of USE on CAND.  Returns false\n-   if USE cannot be based on CAND.  */\n+/* Determines cost of computing uses in GROUP with CAND.  Returns false\n+   if USE cannot be represented with CAND.  */\n \n static bool\n-determine_use_iv_cost (struct ivopts_data *data,\n-\t\t       struct iv_use *use, struct iv_cand *cand)\n+determine_group_iv_cost (struct ivopts_data *data,\n+\t\t\t struct iv_group *group, struct iv_cand *cand)\n {\n-  switch (use->type)\n+  switch (group->type)\n     {\n     case USE_NONLINEAR_EXPR:\n-      return determine_use_iv_cost_generic (data, use, cand);\n+      return determine_group_iv_cost_generic (data, group, cand);\n \n     case USE_ADDRESS:\n-      return determine_use_iv_cost_address (data, use, cand);\n+      return determine_group_iv_cost_address (data, group, cand);\n \n     case USE_COMPARE:\n-      return determine_use_iv_cost_condition (data, use, cand);\n+      return determine_group_iv_cost_cond (data, group, cand);\n \n     default:\n       gcc_unreachable ();\n@@ -5724,17 +5589,18 @@ set_autoinc_for_original_candidates (struct ivopts_data *data)\n {\n   unsigned i, j;\n \n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      struct iv_cand *cand = iv_cand (data, i);\n+      struct iv_cand *cand = data->vcands[i];\n       struct iv_use *closest_before = NULL;\n       struct iv_use *closest_after = NULL;\n       if (cand->pos != IP_ORIGINAL)\n \tcontinue;\n \n-      for (j = 0; j < n_iv_uses (data); j++)\n+      for (j = 0; j < data->vgroups.length (); j++)\n \t{\n-\t  struct iv_use *use = iv_use (data, j);\n+\t  struct iv_group *group = data->vgroups[j];\n+\t  struct iv_use *use = group->vuses[0];\n \t  unsigned uid = gimple_uid (use->stmt);\n \n \t  if (gimple_bb (use->stmt) != gimple_bb (cand->incremented_at))\n@@ -5772,52 +5638,76 @@ find_iv_candidates (struct ivopts_data *data)\n   add_iv_candidate_for_bivs (data);\n \n   /* Add induction variables derived from uses.  */\n-  add_iv_candidate_for_uses (data);\n+  add_iv_candidate_for_groups (data);\n \n   set_autoinc_for_original_candidates (data);\n \n   /* Record the important candidates.  */\n   record_important_candidates (data);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      unsigned i;\n+\n+      fprintf (dump_file, \"\\n<Important Candidates>:\\t\");\n+      for (i = 0; i < data->vcands.length (); i++)\n+\tif (data->vcands[i]->important)\n+\t  fprintf (dump_file, \" %d,\", data->vcands[i]->id);\n+      fprintf (dump_file, \"\\n\");\n+\n+      fprintf (dump_file, \"\\n<Group, Cand> Related:\\n\");\n+      for (i = 0; i < data->vgroups.length (); i++)\n+\t{\n+\t  struct iv_group *group = data->vgroups[i];\n+\n+\t  if (group->related_cands)\n+\t    {\n+\t      fprintf (dump_file, \"  Group %d:\\t\", group->id);\n+\t      dump_bitmap (dump_file, group->related_cands);\n+\t    }\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+    }\n }\n \n-/* Determines costs of basing the use of the iv on an iv candidate.  */\n+/* Determines costs of computing use of iv with an iv candidate.  */\n \n static void\n-determine_use_iv_costs (struct ivopts_data *data)\n+determine_group_iv_costs (struct ivopts_data *data)\n {\n   unsigned i, j;\n-  struct iv_use *use;\n   struct iv_cand *cand;\n+  struct iv_group *group;\n   bitmap to_clear = BITMAP_ALLOC (NULL);\n \n   alloc_use_cost_map (data);\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n+      group = data->vgroups[i];\n \n       if (data->consider_all_candidates)\n \t{\n-\t  for (j = 0; j < n_iv_cands (data); j++)\n+\t  for (j = 0; j < data->vcands.length (); j++)\n \t    {\n-\t      cand = iv_cand (data, j);\n-\t      determine_use_iv_cost (data, use, cand);\n+\t      cand = data->vcands[j];\n+\t      determine_group_iv_cost (data, group, cand);\n \t    }\n \t}\n       else\n \t{\n \t  bitmap_iterator bi;\n \n-\t  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, j, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (group->related_cands, 0, j, bi)\n \t    {\n-\t      cand = iv_cand (data, j);\n-\t      if (!determine_use_iv_cost (data, use, cand))\n+\t      cand = data->vcands[j];\n+\t      if (!determine_group_iv_cost (data, group, cand))\n \t\tbitmap_set_bit (to_clear, j);\n \t    }\n \n \t  /* Remove the candidates for that the cost is infinite from\n \t     the list of related candidates.  */\n-\t  bitmap_and_compl_into (use->related_cands, to_clear);\n+\t  bitmap_and_compl_into (group->related_cands, to_clear);\n \t  bitmap_clear (to_clear);\n \t}\n     }\n@@ -5826,29 +5716,30 @@ determine_use_iv_costs (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Use-candidate costs:\\n\");\n+      fprintf (dump_file, \"<Group-candidate Costs>:\\n\");\n \n-      for (i = 0; i < n_iv_uses (data); i++)\n+      for (i = 0; i < data->vgroups.length (); i++)\n \t{\n-\t  use = iv_use (data, i);\n+\t  group = data->vgroups[i];\n \n-\t  fprintf (dump_file, \"Use %d:\\n\", i);\n+\t  fprintf (dump_file, \"Group %d:\\n\", i);\n \t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tdepends on\\n\");\n-\t  for (j = 0; j < use->n_map_members; j++)\n+\t  for (j = 0; j < group->n_map_members; j++)\n \t    {\n-\t      if (!use->cost_map[j].cand\n-\t\t  || infinite_cost_p (use->cost_map[j].cost))\n+\t      if (!group->cost_map[j].cand\n+\t\t  || infinite_cost_p (group->cost_map[j].cost))\n \t\tcontinue;\n \n \t      fprintf (dump_file, \"  %d\\t%d\\t%d\\t\",\n-\t\t       use->cost_map[j].cand->id,\n-\t\t       use->cost_map[j].cost.cost,\n-\t\t       use->cost_map[j].cost.complexity);\n-\t      if (use->cost_map[j].depends_on)\n+\t\t       group->cost_map[j].cand->id,\n+\t\t       group->cost_map[j].cost.cost,\n+\t\t       group->cost_map[j].cost.complexity);\n+\t      if (group->cost_map[j].depends_on)\n \t\tbitmap_print (dump_file,\n-\t\t\t      use->cost_map[j].depends_on, \"\",\"\");\n-              if (use->cost_map[j].inv_expr_id != -1)\n-                fprintf (dump_file, \" inv_expr:%d\", use->cost_map[j].inv_expr_id);\n+\t\t\t      group->cost_map[j].depends_on, \"\",\"\");\n+\t      if (group->cost_map[j].inv_expr_id != -1)\n+\t\tfprintf (dump_file, \" inv_expr:%d\",\n+\t\t\t group->cost_map[j].inv_expr_id);\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n@@ -5915,13 +5806,13 @@ determine_iv_costs (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Candidate costs:\\n\");\n+      fprintf (dump_file, \"<Candidate Costs>:\\n\");\n       fprintf (dump_file, \"  cand\\tcost\\n\");\n     }\n \n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      struct iv_cand *cand = iv_cand (data, i);\n+      struct iv_cand *cand = data->vcands[i];\n \n       determine_iv_cost (data, cand);\n \n@@ -5958,7 +5849,7 @@ determine_set_costs (struct ivopts_data *data)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Global costs:\\n\");\n+      fprintf (dump_file, \"<Global Costs>:\\n\");\n       fprintf (dump_file, \"  target_avail_regs %d\\n\", target_avail_regs);\n       fprintf (dump_file, \"  target_clobbered_regs %d\\n\", target_clobbered_regs);\n       fprintf (dump_file, \"  target_reg_cost %d\\n\", target_reg_cost[data->speed]);\n@@ -6034,9 +5925,9 @@ cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n /* Returns candidate by that USE is expressed in IVS.  */\n \n static struct cost_pair *\n-iv_ca_cand_for_use (struct iv_ca *ivs, struct iv_use *use)\n+iv_ca_cand_for_group (struct iv_ca *ivs, struct iv_group *group)\n {\n-  return ivs->cand_for_use[use->id];\n+  return ivs->cand_for_group[group->id];\n }\n \n /* Computes the cost field of IVS structure.  */\n@@ -6077,18 +5968,18 @@ iv_ca_set_remove_invariants (struct iv_ca *ivs, bitmap invs)\n \n static void\n iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n-\t\t struct iv_use *use)\n+\t\t struct iv_group *group)\n {\n-  unsigned uid = use->id, cid;\n+  unsigned gid = group->id, cid;\n   struct cost_pair *cp;\n \n-  cp = ivs->cand_for_use[uid];\n+  cp = ivs->cand_for_group[gid];\n   if (!cp)\n     return;\n   cid = cp->cand->id;\n \n-  ivs->bad_uses++;\n-  ivs->cand_for_use[uid] = NULL;\n+  ivs->bad_groups++;\n+  ivs->cand_for_group[gid] = NULL;\n   ivs->n_cand_uses[cid]--;\n \n   if (ivs->n_cand_uses[cid] == 0)\n@@ -6135,26 +6026,26 @@ iv_ca_set_add_invariants (struct iv_ca *ivs, bitmap invs)\n     }\n }\n \n-/* Set cost pair for USE in set IVS to CP.  */\n+/* Set cost pair for GROUP in set IVS to CP.  */\n \n static void\n iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n-\t      struct iv_use *use, struct cost_pair *cp)\n+\t      struct iv_group *group, struct cost_pair *cp)\n {\n-  unsigned uid = use->id, cid;\n+  unsigned gid = group->id, cid;\n \n-  if (ivs->cand_for_use[uid] == cp)\n+  if (ivs->cand_for_group[gid] == cp)\n     return;\n \n-  if (ivs->cand_for_use[uid])\n-    iv_ca_set_no_cp (data, ivs, use);\n+  if (ivs->cand_for_group[gid])\n+    iv_ca_set_no_cp (data, ivs, group);\n \n   if (cp)\n     {\n       cid = cp->cand->id;\n \n-      ivs->bad_uses--;\n-      ivs->cand_for_use[uid] = cp;\n+      ivs->bad_groups--;\n+      ivs->cand_for_group[gid] = cp;\n       ivs->n_cand_uses[cid]++;\n       if (ivs->n_cand_uses[cid] == 1)\n \t{\n@@ -6186,38 +6077,38 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n    set IVS don't give any result.  */\n \n static void\n-iv_ca_add_use (struct ivopts_data *data, struct iv_ca *ivs,\n-\t       struct iv_use *use)\n+iv_ca_add_group (struct ivopts_data *data, struct iv_ca *ivs,\n+\t       struct iv_group *group)\n {\n   struct cost_pair *best_cp = NULL, *cp;\n   bitmap_iterator bi;\n   unsigned i;\n   struct iv_cand *cand;\n \n-  gcc_assert (ivs->upto >= use->id);\n+  gcc_assert (ivs->upto >= group->id);\n   ivs->upto++;\n-  ivs->bad_uses++;\n+  ivs->bad_groups++;\n \n   EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n     {\n-      cand = iv_cand (data, i);\n-      cp = get_use_iv_cost (data, use, cand);\n+      cand = data->vcands[i];\n+      cp = get_group_iv_cost (data, group, cand);\n       if (cheaper_cost_pair (cp, best_cp))\n \tbest_cp = cp;\n     }\n-   \n+\n   if (best_cp == NULL)\n     {\n       EXECUTE_IF_SET_IN_BITMAP (data->important_candidates, 0, i, bi)\n \t{\n-\t  cand = iv_cand (data, i);\n-\t  cp = get_use_iv_cost (data, use, cand);\n+\t  cand = data->vcands[i];\n+\t  cp = get_group_iv_cost (data, group, cand);\n \t  if (cheaper_cost_pair (cp, best_cp))\n \t    best_cp = cp;\n \t}\n     }\n \n-  iv_ca_set_cp (data, ivs, use, best_cp);\n+  iv_ca_set_cp (data, ivs, group, best_cp);\n }\n \n /* Get cost for assignment IVS.  */\n@@ -6227,7 +6118,7 @@ iv_ca_cost (struct iv_ca *ivs)\n {\n   /* This was a conditional expression but it triggered a bug in\n      Sun C 5.5.  */\n-  if (ivs->bad_uses)\n+  if (ivs->bad_groups)\n     return infinite_cost;\n   else\n     return ivs->cost;\n@@ -6253,19 +6144,19 @@ iv_ca_has_deps (struct iv_ca *ivs, struct cost_pair *cp)\n   return true;\n }\n \n-/* Creates change of expressing USE by NEW_CP instead of OLD_CP and chains\n-   it before NEXT_CHANGE.  */\n+/* Creates change of expressing GROUP by NEW_CP instead of OLD_CP and chains\n+   it before NEXT.  */\n \n static struct iv_ca_delta *\n-iv_ca_delta_add (struct iv_use *use, struct cost_pair *old_cp,\n-\t\t struct cost_pair *new_cp, struct iv_ca_delta *next_change)\n+iv_ca_delta_add (struct iv_group *group, struct cost_pair *old_cp,\n+\t\t struct cost_pair *new_cp, struct iv_ca_delta *next)\n {\n   struct iv_ca_delta *change = XNEW (struct iv_ca_delta);\n \n-  change->use = use;\n+  change->group = group;\n   change->old_cp = old_cp;\n   change->new_cp = new_cp;\n-  change->next_change = next_change;\n+  change->next = next;\n \n   return change;\n }\n@@ -6284,9 +6175,9 @@ iv_ca_delta_join (struct iv_ca_delta *l1, struct iv_ca_delta *l2)\n   if (!l1)\n     return l2;\n \n-  for (last = l1; last->next_change; last = last->next_change)\n+  for (last = l1; last->next; last = last->next)\n     continue;\n-  last->next_change = l2;\n+  last->next = l2;\n \n   return l1;\n }\n@@ -6300,8 +6191,8 @@ iv_ca_delta_reverse (struct iv_ca_delta *delta)\n \n   for (act = delta; act; act = next)\n     {\n-      next = act->next_change;\n-      act->next_change = prev;\n+      next = act->next;\n+      act->next = prev;\n       prev = act;\n \n       std::swap (act->old_cp, act->new_cp);\n@@ -6323,12 +6214,12 @@ iv_ca_delta_commit (struct ivopts_data *data, struct iv_ca *ivs,\n   if (!forward)\n     delta = iv_ca_delta_reverse (delta);\n \n-  for (act = delta; act; act = act->next_change)\n+  for (act = delta; act; act = act->next)\n     {\n       from = act->old_cp;\n       to = act->new_cp;\n-      gcc_assert (iv_ca_cand_for_use (ivs, act->use) == from);\n-      iv_ca_set_cp (data, ivs, act->use, to);\n+      gcc_assert (iv_ca_cand_for_group (ivs, act->group) == from);\n+      iv_ca_set_cp (data, ivs, act->group, to);\n     }\n \n   if (!forward)\n@@ -6360,7 +6251,7 @@ iv_ca_delta_free (struct iv_ca_delta **delta)\n \n   for (act = *delta; act; act = next)\n     {\n-      next = act->next_change;\n+      next = act->next;\n       free (act);\n     }\n \n@@ -6375,9 +6266,10 @@ iv_ca_new (struct ivopts_data *data)\n   struct iv_ca *nw = XNEW (struct iv_ca);\n \n   nw->upto = 0;\n-  nw->bad_uses = 0;\n-  nw->cand_for_use = XCNEWVEC (struct cost_pair *, n_iv_uses (data));\n-  nw->n_cand_uses = XCNEWVEC (unsigned, n_iv_cands (data));\n+  nw->bad_groups = 0;\n+  nw->cand_for_group = XCNEWVEC (struct cost_pair *,\n+\t\t\t\t data->vgroups.length ());\n+  nw->n_cand_uses = XCNEWVEC (unsigned, data->vcands.length ());\n   nw->cands = BITMAP_ALLOC (NULL);\n   nw->n_cands = 0;\n   nw->n_regs = 0;\n@@ -6396,7 +6288,7 @@ iv_ca_new (struct ivopts_data *data)\n static void\n iv_ca_free (struct iv_ca **ivs)\n {\n-  free ((*ivs)->cand_for_use);\n+  free ((*ivs)->cand_for_group);\n   free ((*ivs)->n_cand_uses);\n   BITMAP_FREE ((*ivs)->cands);\n   free ((*ivs)->n_invariant_uses);\n@@ -6415,19 +6307,19 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n   comp_cost cost = iv_ca_cost (ivs);\n \n   fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost, cost.complexity);\n-  fprintf (file, \"  cand_cost: %d\\n  cand_use_cost: %d (complexity %d)\\n\",\n+  fprintf (file, \"  cand_cost: %d\\n  cand_group_cost: %d (complexity %d)\\n\",\n            ivs->cand_cost, ivs->cand_use_cost.cost, ivs->cand_use_cost.complexity);\n   bitmap_print (file, ivs->cands, \"  candidates: \",\"\\n\");\n \n    for (i = 0; i < ivs->upto; i++)\n     {\n-      struct iv_use *use = iv_use (data, i);\n-      struct cost_pair *cp = iv_ca_cand_for_use (ivs, use);\n+      struct iv_group *group = data->vgroups[i];\n+      struct cost_pair *cp = iv_ca_cand_for_group (ivs, group);\n       if (cp)\n-        fprintf (file, \"   use:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n-                 use->id, cp->cand->id, cp->cost.cost, cp->cost.complexity);\n+        fprintf (file, \"   group:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n+                 group->id, cp->cand->id, cp->cost.cost, cp->cost.complexity);\n       else\n-        fprintf (file, \"   use:%d --> ??\\n\", use->id);\n+        fprintf (file, \"   group:%d --> ??\\n\", group->id);\n     }\n \n   for (i = 1; i <= data->max_inv_id; i++)\n@@ -6451,20 +6343,20 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n {\n   unsigned i;\n   comp_cost cost;\n-  struct iv_use *use;\n+  struct iv_group *group;\n   struct cost_pair *old_cp, *new_cp;\n \n   *delta = NULL;\n   for (i = 0; i < ivs->upto; i++)\n     {\n-      use = iv_use (data, i);\n-      old_cp = iv_ca_cand_for_use (ivs, use);\n+      group = data->vgroups[i];\n+      old_cp = iv_ca_cand_for_group (ivs, group);\n \n       if (old_cp\n \t  && old_cp->cand == cand)\n \tcontinue;\n \n-      new_cp = get_use_iv_cost (data, use, cand);\n+      new_cp = get_group_iv_cost (data, group, cand);\n       if (!new_cp)\n \tcontinue;\n \n@@ -6474,7 +6366,7 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n       if (!min_ncand && !cheaper_cost_pair (new_cp, old_cp))\n         continue;\n \n-      *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n+      *delta = iv_ca_delta_add (group, old_cp, new_cp, *delta);\n     }\n \n   iv_ca_delta_commit (data, ivs, *delta, true);\n@@ -6496,24 +6388,24 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      struct iv_ca_delta **delta)\n {\n   unsigned i, ci;\n-  struct iv_use *use;\n+  struct iv_group *group;\n   struct cost_pair *old_cp, *new_cp, *cp;\n   bitmap_iterator bi;\n   struct iv_cand *cnd;\n   comp_cost cost, best_cost, acost;\n \n   *delta = NULL;\n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n+      group = data->vgroups[i];\n \n-      old_cp = iv_ca_cand_for_use (ivs, use);\n+      old_cp = iv_ca_cand_for_group (ivs, group);\n       if (old_cp->cand != cand)\n \tcontinue;\n \n       best_cost = iv_ca_cost (ivs);\n       /* Start narrowing with START.  */\n-      new_cp = get_use_iv_cost (data, use, start);\n+      new_cp = get_group_iv_cost (data, group, start);\n \n       if (data->consider_all_candidates)\n \t{\n@@ -6522,13 +6414,13 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      if (ci == cand->id || (start && ci == start->id))\n \t\tcontinue;\n \n-\t      cnd = iv_cand (data, ci);\n+\t      cnd = data->vcands[ci];\n \n-\t      cp = get_use_iv_cost (data, use, cnd);\n+\t      cp = get_group_iv_cost (data, group, cnd);\n \t      if (!cp)\n \t\tcontinue;\n \n-\t      iv_ca_set_cp (data, ivs, use, cp);\n+\t      iv_ca_set_cp (data, ivs, group, cp);\n \t      acost = iv_ca_cost (ivs);\n \n \t      if (compare_costs (acost, best_cost) < 0)\n@@ -6540,18 +6432,18 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t}\n       else\n \t{\n-\t  EXECUTE_IF_AND_IN_BITMAP (use->related_cands, ivs->cands, 0, ci, bi)\n+\t  EXECUTE_IF_AND_IN_BITMAP (group->related_cands, ivs->cands, 0, ci, bi)\n \t    {\n \t      if (ci == cand->id || (start && ci == start->id))\n \t\tcontinue;\n \n-\t      cnd = iv_cand (data, ci);\n+\t      cnd = data->vcands[ci];\n \n-\t      cp = get_use_iv_cost (data, use, cnd);\n+\t      cp = get_group_iv_cost (data, group, cnd);\n \t      if (!cp)\n \t\tcontinue;\n \n-\t      iv_ca_set_cp (data, ivs, use, cp);\n+\t      iv_ca_set_cp (data, ivs, group, cp);\n \t      acost = iv_ca_cost (ivs);\n \n \t      if (compare_costs (acost, best_cost) < 0)\n@@ -6562,15 +6454,15 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t    }\n \t}\n       /* Restore to old cp for use.  */\n-      iv_ca_set_cp (data, ivs, use, old_cp);\n+      iv_ca_set_cp (data, ivs, group, old_cp);\n \n       if (!new_cp)\n \t{\n \t  iv_ca_delta_free (delta);\n \t  return infinite_cost;\n \t}\n \n-      *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n+      *delta = iv_ca_delta_add (group, old_cp, new_cp, *delta);\n     }\n \n   iv_ca_delta_commit (data, ivs, *delta, true);\n@@ -6599,7 +6491,7 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n \n   EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n     {\n-      cand = iv_cand (data, i);\n+      cand = data->vcands[i];\n \n       if (cand == except_cand)\n \tcontinue;\n@@ -6631,11 +6523,11 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n }\n \n /* Check if CAND_IDX is a candidate other than OLD_CAND and has\n-   cheaper local cost for USE than BEST_CP.  Return pointer to\n+   cheaper local cost for GROUP than BEST_CP.  Return pointer to\n    the corresponding cost_pair, otherwise just return BEST_CP.  */\n \n static struct cost_pair*\n-cheaper_cost_with_cand (struct ivopts_data *data, struct iv_use *use,\n+cheaper_cost_with_cand (struct ivopts_data *data, struct iv_group *group,\n \t\t\tunsigned int cand_idx, struct iv_cand *old_cand,\n \t\t\tstruct cost_pair *best_cp)\n {\n@@ -6646,8 +6538,8 @@ cheaper_cost_with_cand (struct ivopts_data *data, struct iv_use *use,\n   if (cand_idx == old_cand->id)\n     return best_cp;\n \n-  cand = iv_cand (data, cand_idx);\n-  cp = get_use_iv_cost (data, use, cand);\n+  cand = data->vcands[cand_idx];\n+  cp = get_group_iv_cost (data, group, cand);\n   if (cp != NULL && cheaper_cost_pair (cp, best_cp))\n     return cp;\n \n@@ -6667,7 +6559,6 @@ iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n {\n   bitmap_iterator bi, bj;\n   unsigned int i, j, k;\n-  struct iv_use *use;\n   struct iv_cand *cand;\n   comp_cost orig_cost, acost;\n   struct iv_ca_delta *act_delta, *tmp_delta;\n@@ -6682,33 +6573,33 @@ iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n \t  || ivs->n_cand_uses[i] > ALWAYS_PRUNE_CAND_SET_BOUND)\n \tcontinue;\n \n-      cand = iv_cand (data, i);\n-  \n+      cand = data->vcands[i];\n+\n       act_delta = NULL;\n       /*  Represent uses under current candidate using other ones with\n \t  lower local cost.  */\n       for (j = 0; j < ivs->upto; j++)\n \t{\n-\t  use = iv_use (data, j);\n-\t  old_cp = iv_ca_cand_for_use (ivs, use);\n+\t  struct iv_group *group = data->vgroups[j];\n+\t  old_cp = iv_ca_cand_for_group (ivs, group);\n \n \t  if (old_cp->cand != cand)\n \t    continue;\n \n \t  best_cp = old_cp;\n \t  if (data->consider_all_candidates)\n-\t    for (k = 0; k < n_iv_cands (data); k++)\n-\t      best_cp = cheaper_cost_with_cand (data, use, k,\n+\t    for (k = 0; k < data->vcands.length (); k++)\n+\t      best_cp = cheaper_cost_with_cand (data, group, k,\n \t\t\t\t\t\told_cp->cand, best_cp);\n \t  else\n-\t    EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, k, bj)\n-\t      best_cp = cheaper_cost_with_cand (data, use, k,\n+\t    EXECUTE_IF_SET_IN_BITMAP (group->related_cands, 0, k, bj)\n+\t      best_cp = cheaper_cost_with_cand (data, group, k,\n \t\t\t\t\t\told_cp->cand, best_cp);\n \n \t  if (best_cp == old_cp)\n \t    continue;\n \n-\t  act_delta = iv_ca_delta_add (use, old_cp, best_cp, act_delta);\n+\t  act_delta = iv_ca_delta_add (group, old_cp, best_cp, act_delta);\n \t}\n       /* No need for further prune.  */\n       if (!act_delta)\n@@ -6732,14 +6623,14 @@ iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n   return orig_cost;\n }\n \n-/* Tries to extend the sets IVS in the best possible way in order\n-   to express the USE.  If ORIGINALP is true, prefer candidates from\n+/* Tries to extend the sets IVS in the best possible way in order to\n+   express the GROUP.  If ORIGINALP is true, prefer candidates from\n    the original set of IVs, otherwise favor important candidates not\n    based on any memory object.  */\n \n static bool\n try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n-\t\t  struct iv_use *use, bool originalp)\n+\t\t  struct iv_group *group, bool originalp)\n {\n   comp_cost best_cost, act_cost;\n   unsigned i;\n@@ -6748,13 +6639,13 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n   struct iv_ca_delta *best_delta = NULL, *act_delta;\n   struct cost_pair *cp;\n \n-  iv_ca_add_use (data, ivs, use);\n+  iv_ca_add_group (data, ivs, group);\n   best_cost = iv_ca_cost (ivs);\n-  cp = iv_ca_cand_for_use (ivs, use);\n+  cp = iv_ca_cand_for_group (ivs, group);\n   if (cp)\n     {\n-      best_delta = iv_ca_delta_add (use, NULL, cp, NULL);\n-      iv_ca_set_no_cp (data, ivs, use);\n+      best_delta = iv_ca_delta_add (group, NULL, cp, NULL);\n+      iv_ca_set_no_cp (data, ivs, group);\n     }\n \n   /* If ORIGINALP is true, try to find the original IV for the use.  Otherwise\n@@ -6766,9 +6657,9 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n      too many ivs.  The approach from few ivs to more seems more likely to be\n      successful -- starting from few ivs, replacing an expensive use by a\n      specific iv should always be a win.  */\n-  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (group->related_cands, 0, i, bi)\n     {\n-      cand = iv_cand (data, i);\n+      cand = data->vcands[i];\n \n       if (originalp && cand->pos !=IP_ORIGINAL)\n \tcontinue;\n@@ -6779,15 +6670,15 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n       if (iv_ca_cand_used_p (ivs, cand))\n         continue;\n \n-      cp = get_use_iv_cost (data, use, cand);\n+      cp = get_group_iv_cost (data, group, cand);\n       if (!cp)\n \tcontinue;\n \n-      iv_ca_set_cp (data, ivs, use, cp);\n+      iv_ca_set_cp (data, ivs, group, cp);\n       act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL,\n                                true);\n-      iv_ca_set_no_cp (data, ivs, use);\n-      act_delta = iv_ca_delta_add (use, NULL, cp, act_delta);\n+      iv_ca_set_no_cp (data, ivs, group);\n+      act_delta = iv_ca_delta_add (group, NULL, cp, act_delta);\n \n       if (compare_costs (act_cost, best_cost) < 0)\n \t{\n@@ -6802,9 +6693,9 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \n   if (infinite_cost_p (best_cost))\n     {\n-      for (i = 0; i < use->n_map_members; i++)\n+      for (i = 0; i < group->n_map_members; i++)\n \t{\n-\t  cp = use->cost_map + i;\n+\t  cp = group->cost_map + i;\n \t  cand = cp->cand;\n \t  if (!cand)\n \t    continue;\n@@ -6822,10 +6713,11 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t    continue;\n \n \t  act_delta = NULL;\n-\t  iv_ca_set_cp (data, ivs, use, cp);\n+\t  iv_ca_set_cp (data, ivs, group, cp);\n \t  act_cost = iv_ca_extend (data, ivs, cand, &act_delta, NULL, true);\n-\t  iv_ca_set_no_cp (data, ivs, use);\n-\t  act_delta = iv_ca_delta_add (use, iv_ca_cand_for_use (ivs, use),\n+\t  iv_ca_set_no_cp (data, ivs, group);\n+\t  act_delta = iv_ca_delta_add (group,\n+\t\t\t\t       iv_ca_cand_for_group (ivs, group),\n \t\t\t\t       cp, act_delta);\n \n \t  if (compare_costs (act_cost, best_cost) < 0)\n@@ -6852,11 +6744,11 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n static struct iv_ca *\n get_initial_solution (struct ivopts_data *data, bool originalp)\n {\n-  struct iv_ca *ivs = iv_ca_new (data);\n   unsigned i;\n+  struct iv_ca *ivs = iv_ca_new (data);\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n-    if (!try_add_cand_for (data, ivs, iv_use (data, i), originalp))\n+  for (i = 0; i < data->vgroups.length (); i++)\n+    if (!try_add_cand_for (data, ivs, data->vgroups[i], originalp))\n       {\n \tiv_ca_free (&ivs);\n \treturn NULL;\n@@ -6879,9 +6771,9 @@ try_improve_iv_set (struct ivopts_data *data,\n   struct iv_cand *cand;\n \n   /* Try extending the set of induction variables by one.  */\n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      cand = iv_cand (data, i);\n+      cand = data->vcands[i];\n \n       if (iv_ca_cand_used_p (ivs, cand))\n \tcontinue;\n@@ -6980,9 +6872,8 @@ static struct iv_ca *\n find_optimal_iv_set (struct ivopts_data *data)\n {\n   unsigned i;\n-  struct iv_ca *set, *origset;\n-  struct iv_use *use;\n   comp_cost cost, origcost;\n+  struct iv_ca *set, *origset;\n \n   /* Determine the cost based on a strategy that starts with original IVs,\n      and try again using a strategy that prefers candidates not based\n@@ -7014,10 +6905,10 @@ find_optimal_iv_set (struct ivopts_data *data)\n   else if (origset)\n     iv_ca_free (&origset);\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      use->selected = iv_ca_cand_for_use (set, use)->cand;\n+      struct iv_group *group = data->vgroups[i];\n+      group->selected = iv_ca_cand_for_group (set, group)->cand;\n     }\n \n   return set;\n@@ -7030,6 +6921,8 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n {\n   gimple_stmt_iterator incr_pos;\n   tree base;\n+  struct iv_use *use;\n+  struct iv_group *group;\n   bool after = false;\n \n   if (!cand->iv)\n@@ -7059,7 +6952,9 @@ create_new_iv (struct ivopts_data *data, struct iv_cand *cand)\n       name_info (data, cand->var_after)->preserve_biv = true;\n \n       /* Rewrite the increment so that it uses var_before directly.  */\n-      find_interesting_uses_op (data, cand->var_after)->selected = cand;\n+      use = find_interesting_uses_op (data, cand->var_after);\n+      group = data->vgroups[use->group_id];\n+      group->selected = cand;\n       return;\n     }\n \n@@ -7083,7 +6978,7 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n \n   EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n     {\n-      cand = iv_cand (data, i);\n+      cand = data->vcands[i];\n       create_new_iv (data, cand);\n     }\n \n@@ -7097,7 +6992,7 @@ create_new_ivs (struct ivopts_data *data, struct iv_ca *set)\n       fprintf (dump_file, \", %lu IVs:\\n\", bitmap_count_bits (set->cands));\n       EXECUTE_IF_SET_IN_BITMAP (set->cands, 0, i, bi)\n         {\n-          cand = iv_cand (data, i);\n+          cand = data->vcands[i];\n           dump_cand (dump_file, cand);\n         }\n       fprintf (dump_file, \"\\n\");\n@@ -7296,8 +7191,8 @@ adjust_iv_update_pos (struct iv_cand *cand, struct iv_use *use)\n /* Rewrites USE (address that is an iv) using candidate CAND.  */\n \n static void\n-rewrite_use_address_1 (struct ivopts_data *data,\n-\t\t       struct iv_use *use, struct iv_cand *cand)\n+rewrite_use_address (struct ivopts_data *data,\n+\t\t     struct iv_use *use, struct iv_cand *cand)\n {\n   aff_tree aff;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n@@ -7332,28 +7227,6 @@ rewrite_use_address_1 (struct ivopts_data *data,\n   *use->op_p = ref;\n }\n \n-/* Rewrites USE (address that is an iv) using candidate CAND.  If it's the\n-   first use of a group, rewrites sub uses in the group too.  */\n-\n-static void\n-rewrite_use_address (struct ivopts_data *data,\n-\t\t      struct iv_use *use, struct iv_cand *cand)\n-{\n-  struct iv_use *next;\n-\n-  gcc_assert (use->sub_id == 0);\n-  rewrite_use_address_1 (data, use, cand);\n-  update_stmt (use->stmt);\n-\n-  for (next = use->next; next != NULL; next = next->next)\n-    {\n-      rewrite_use_address_1 (data, next, cand);\n-      update_stmt (next->stmt);\n-    }\n-\n-  return;\n-}\n-\n /* Rewrites USE (the condition such that one of the arguments is an iv) using\n    candidate CAND.  */\n \n@@ -7364,7 +7237,8 @@ rewrite_use_compare (struct ivopts_data *data,\n   tree comp, *var_p, op, bound;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n   enum tree_code compare;\n-  struct cost_pair *cp = get_use_iv_cost (data, use, cand);\n+  struct iv_group *group = data->vgroups[use->group_id];\n+  struct cost_pair *cp = get_group_iv_cost (data, group, cand);\n   bool ok;\n \n   bound = cp->value;\n@@ -7406,48 +7280,46 @@ rewrite_use_compare (struct ivopts_data *data,\n \t\t\t\t     true, GSI_SAME_STMT);\n }\n \n-/* Rewrites USE using candidate CAND.  */\n+/* Rewrite the groups using the selected induction variables.  */\n \n static void\n-rewrite_use (struct ivopts_data *data, struct iv_use *use, struct iv_cand *cand)\n+rewrite_groups (struct ivopts_data *data)\n {\n-  switch (use->type)\n-    {\n-      case USE_NONLINEAR_EXPR:\n-\trewrite_use_nonlinear_expr (data, use, cand);\n-\tbreak;\n-\n-      case USE_ADDRESS:\n-\trewrite_use_address (data, use, cand);\n-\tbreak;\n-\n-      case USE_COMPARE:\n-\trewrite_use_compare (data, use, cand);\n-\tbreak;\n-\n-      default:\n-\tgcc_unreachable ();\n-    }\n-\n-  update_stmt (use->stmt);\n-}\n-\n-/* Rewrite the uses using the selected induction variables.  */\n-\n-static void\n-rewrite_uses (struct ivopts_data *data)\n-{\n-  unsigned i;\n-  struct iv_cand *cand;\n-  struct iv_use *use;\n+  unsigned i, j;\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      use = iv_use (data, i);\n-      cand = use->selected;\n+      struct iv_group *group = data->vgroups[i];\n+      struct iv_cand *cand = group->selected;\n+\n       gcc_assert (cand);\n \n-      rewrite_use (data, use, cand);\n+      if (group->type == USE_NONLINEAR_EXPR)\n+\t{\n+\t  for (j = 0; j < group->vuses.length (); j++)\n+\t    {\n+\t      rewrite_use_nonlinear_expr (data, group->vuses[j], cand);\n+\t      update_stmt (group->vuses[j]->stmt);\n+\t    }\n+\t}\n+      else if (group->type == USE_ADDRESS)\n+\t{\n+\t  for (j = 0; j < group->vuses.length (); j++)\n+\t    {\n+\t      rewrite_use_address (data, group->vuses[j], cand);\n+\t      update_stmt (group->vuses[j]->stmt);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (group->type == USE_COMPARE);\n+\n+\t  for (j = 0; j < group->vuses.length (); j++)\n+\t    {\n+\t      rewrite_use_compare (data, group->vuses[j], cand);\n+\t      update_stmt (group->vuses[j]->stmt);\n+\t    }\n+\t}\n     }\n }\n \n@@ -7471,11 +7343,11 @@ remove_unused_ivs (struct ivopts_data *data)\n       if (info->iv\n \t  && !integer_zerop (info->iv->step)\n \t  && !info->inv_id\n-\t  && !info->iv->have_use_for\n+\t  && !info->iv->nonlin_use\n \t  && !info->preserve_biv)\n \t{\n \t  bitmap_set_bit (toremove, SSA_NAME_VERSION (info->iv->ssa_name));\n-\t  \n+\n \t  tree def = info->iv->ssa_name;\n \n \t  if (MAY_HAVE_DEBUG_STMTS && SSA_NAME_DEF_STMT (def))\n@@ -7513,9 +7385,9 @@ remove_unused_ivs (struct ivopts_data *data)\n \n \t      memset (&dummy_use, 0, sizeof (dummy_use));\n \t      dummy_use.iv = info->iv;\n-\t      for (i = 0; i < n_iv_uses (data) && i < 64; i++)\n+\t      for (i = 0; i < data->vgroups.length () && i < 64; i++)\n \t\t{\n-\t\t  cand = iv_use (data, i)->selected;\n+\t\t  cand = data->vgroups[i]->selected;\n \t\t  if (cand == best_cand)\n \t\t    continue;\n \t\t  cand_pref = operand_equal_p (cand->iv->step,\n@@ -7625,39 +7497,32 @@ free_loop_data (struct ivopts_data *data)\n   bitmap_clear (data->relevant);\n   bitmap_clear (data->important_candidates);\n \n-  for (i = 0; i < n_iv_uses (data); i++)\n+  for (i = 0; i < data->vgroups.length (); i++)\n     {\n-      struct iv_use *use = iv_use (data, i);\n-      struct iv_use *pre = use, *sub = use->next;\n+      struct iv_group *group = data->vgroups[i];\n \n-      while (sub)\n-\t{\n-\t  gcc_assert (sub->related_cands == NULL);\n-\t  gcc_assert (sub->n_map_members == 0 && sub->cost_map == NULL);\n+      for (j = 0; j < group->vuses.length (); j++)\n+\tfree (group->vuses[j]);\n \n-\t  pre = sub;\n-\t  sub = sub->next;\n-\t  free (pre);\n-\t}\n+      BITMAP_FREE (group->related_cands);\n+      for (j = 0; j < group->n_map_members; j++)\n+\tif (group->cost_map[j].depends_on)\n+\t  BITMAP_FREE (group->cost_map[j].depends_on);\n \n-      BITMAP_FREE (use->related_cands);\n-      for (j = 0; j < use->n_map_members; j++)\n-\tif (use->cost_map[j].depends_on)\n-\t  BITMAP_FREE (use->cost_map[j].depends_on);\n-      free (use->cost_map);\n-      free (use);\n+      free (group->cost_map);\n+      free (group);\n     }\n-  data->iv_uses.truncate (0);\n+  data->vgroups.truncate (0);\n \n-  for (i = 0; i < n_iv_cands (data); i++)\n+  for (i = 0; i < data->vcands.length (); i++)\n     {\n-      struct iv_cand *cand = iv_cand (data, i);\n+      struct iv_cand *cand = data->vcands[i];\n \n       if (cand->depends_on)\n \tBITMAP_FREE (cand->depends_on);\n       free (cand);\n     }\n-  data->iv_candidates.truncate (0);\n+  data->vcands.truncate (0);\n \n   if (data->version_info_size < num_ssa_names)\n     {\n@@ -7692,8 +7557,8 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   BITMAP_FREE (data->important_candidates);\n \n   decl_rtl_to_reset.release ();\n-  data->iv_uses.release ();\n-  data->iv_candidates.release ();\n+  data->vgroups.release ();\n+  data->vcands.release ();\n   delete data->inv_expr_tab;\n   data->inv_expr_tab = NULL;\n   free_affine_expand_cache (&data->name_expansion_cache);\n@@ -7770,16 +7635,15 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n \n   /* Finds interesting uses (item 1).  */\n   find_interesting_uses (data);\n-  group_address_uses (data);\n-  if (n_iv_uses (data) > MAX_CONSIDERED_USES)\n+  if (data->vgroups.length () > MAX_CONSIDERED_GROUPS)\n     goto finish;\n \n   /* Finds candidates for the induction variables (item 2).  */\n   find_iv_candidates (data);\n \n   /* Calculates the costs (item 3, part 1).  */\n   determine_iv_costs (data);\n-  determine_use_iv_costs (data);\n+  determine_group_iv_costs (data);\n   determine_set_costs (data);\n \n   /* Find the optimal set of induction variables (item 3, part 2).  */\n@@ -7793,7 +7657,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   iv_ca_free (&iv_ca);\n \n   /* Rewrite the uses (item 4, part 2).  */\n-  rewrite_uses (data);\n+  rewrite_groups (data);\n \n   /* Remove the ivs that are unused after rewriting.  */\n   remove_unused_ivs (data);"}]}