{"sha": "2353515dafac6c7999110c09568b3cd0ba779710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1MzUxNWRhZmFjNmM3OTk5MTEwYzA5NTY4YjNjZDBiYTc3OTcxMA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-05-06T00:16:55Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-05-06T00:16:55Z"}, "message": "re PR target/55303 ([SH] Add support for clips / clipu instructions)\n\n\tPR target/55303\n\t* config/sh/sh.c (sh_rtx_costs): Handle SMIN and SMAX cases.\n\t* config/sh/sh.md (*clips, uminsi3, *clipu, clipu_one): New insns and\n\trelated expanders.\n\t* config/sh/iterators.md (SMIN_SMAX): New code iterator.\n\t* config/sh/predicates.md (arith_reg_or_0_or_1_operand,\n\tclips_min_const_int, clips_max_const_int, clipu_max_const_int):\n\tNew predicates.\n\n\tPR target/55303\n\t* gcc.target/sh/pr55303-1.c: New.\n\t* gcc.target/sh/pr55303-2.c: New.\n\t* gcc.target/sh/pr55303-3.c: New.\n\nFrom-SVN: r198617", "tree": {"sha": "e9abc6e1a00878a0e359e237b7b39316b2a8f7dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9abc6e1a00878a0e359e237b7b39316b2a8f7dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2353515dafac6c7999110c09568b3cd0ba779710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2353515dafac6c7999110c09568b3cd0ba779710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2353515dafac6c7999110c09568b3cd0ba779710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2353515dafac6c7999110c09568b3cd0ba779710/comments", "author": null, "committer": null, "parents": [{"sha": "459efabf0586f8fe5abcebef1837e2386a4326b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459efabf0586f8fe5abcebef1837e2386a4326b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459efabf0586f8fe5abcebef1837e2386a4326b0"}], "stats": {"total": 336, "additions": 336, "deletions": 0}, "files": [{"sha": "5c2aea36ed9c8586cebcf043642745f88a5b799d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -1,3 +1,14 @@\n+2013-05-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/55303\n+\t* config/sh/sh.c (sh_rtx_costs): Handle SMIN and SMAX cases.\n+\t* config/sh/sh.md (*clips, uminsi3, *clipu, clipu_one): New insns and\n+\trelated expanders.\n+\t* config/sh/iterators.md (SMIN_SMAX): New code iterator.\n+\t* config/sh/predicates.md (arith_reg_or_0_or_1_operand,\n+\tclips_min_const_int, clips_max_const_int, clipu_max_const_int):\n+\tNew predicates.\n+\n 2013-05-05  Steven Bosscher  <steven@gcc.gnu.org>\n \t    John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n "}, {"sha": "1af06b047f05a1c63d63be608abd64f256f5029d", "filename": "gcc/config/sh/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fiterators.md?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -41,3 +41,6 @@\n ;; Lowpart subreg byte position code attributes for big and little endian.\n (define_mode_attr lowpart_be [(QI \"3\") (HI \"2\")])\n (define_mode_attr lowpart_le [(QI \"0\") (HI \"0\")])\n+\n+;; Signed minimum/maximum code iterator.\n+(define_code_iterator SMIN_SMAX [smin smax])"}, {"sha": "25949c62d235258233b02fe1f489a2a66bd0a181", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -195,6 +195,34 @@\n   return 0;\n })\n \n+;; Returns true if OP is either a register or constant 0 or constant 1.\n+(define_predicate \"arith_reg_or_0_or_1_operand\"\n+  (match_code \"subreg,reg,const_int,const_vector\")\n+{\n+  return arith_reg_or_0_operand (op, mode) || satisfies_constraint_M (op);\n+})\n+\n+;; Returns true if OP is a suitable constant for the minimum value of a\n+;; clips.b or clips.w insn.\n+(define_predicate \"clips_min_const_int\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"INTVAL (op) == -128\")\n+\t    (match_test \"INTVAL (op) == -32768\"))))\n+\n+;; Returns true if OP is a suitable constant for the maximum value of a\n+;; clips.b or clips.w insn.\n+(define_predicate \"clips_max_const_int\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"INTVAL (op) == 127\")\n+\t    (match_test \"INTVAL (op) == 32767\"))))\n+\n+;; Returns true if OP is a suitable constant for the maximum value of a\n+;; clipu.b or clipu.w insn.\n+(define_predicate \"clipu_max_const_int\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"INTVAL (op) == 255\")\n+\t    (match_test \"INTVAL (op) == 65535\"))))\n+\n ;; Returns 1 if OP is a floating point operator with two operands.\n (define_predicate \"binary_float_operator\"\n   (and (match_code \"plus,minus,mult,div\")"}, {"sha": "5976206f8b40253d26e0c3cfef2c6786f066e564", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -3504,6 +3504,22 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n       else\n \treturn false;\n \n+    case SMIN:\n+    case SMAX:\n+      /* This is most likely a clips.b or clips.w insn that is being made up\n+\t by combine.  */\n+      if (TARGET_SH2A\n+\t  && (GET_CODE (XEXP (x, 0)) == SMAX || GET_CODE (XEXP (x, 0)) == SMIN)\n+\t  && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n+\t  && REG_P (XEXP (XEXP (x, 0), 0))\n+\t  && CONST_INT_P (XEXP (x, 1)))\n+\t{\n+\t  *total = COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n+\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:"}, {"sha": "b4fbd588d19d10a21d5cf1e648a4b677e94f02d1", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -11710,6 +11710,140 @@ label:\n   [(set_attr \"length\" \"0\")\n    (set_attr \"in_delay_slot\" \"no\")])\n \n+;; -------------------------------------------------------------------------\n+;; Minimum / maximum operations.\n+;; -------------------------------------------------------------------------\n+\n+;; The SH2A clips.b and clips.w insns do a signed min-max function.  If smin\n+;; and smax standard name patterns are defined, they will be used during\n+;; initial expansion and combine will then be able to form the actual min-max\n+;; pattern.\n+;; The clips.b and clips.w set the SR.CS bit if the value in the register is\n+;; clipped, but there is currently no way of making use of this information.\n+;; The only way to read or reset the SR.CS bit is by accessing the SR.\n+(define_expand \"<code>si3\"\n+  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t\t   (SMIN_SMAX:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t\t (match_operand 2 \"const_int_operand\")))\n+\t      (clobber (reg:SI T_REG))])]\n+  \"TARGET_SH2A\"\n+{\n+  /* Force the comparison value into a register, because greater-than\n+     comparisons can work only on registers.  Combine will be able to pick up\n+     the constant value from the REG_EQUAL note when trying to form a min-max\n+     pattern.  */\n+  operands[2] = force_reg (SImode, operands[2]);\n+})\n+\n+;; Convert\n+;;\tsmax (smin (...))\n+;; to\n+;;\tsmin (smax (...))\n+(define_insn_and_split \"*clips\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(smax:SI (smin:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t\t  (match_operand 2 \"clips_max_const_int\"))\n+\t\t (match_operand 3 \"clips_min_const_int\")))]\n+  \"TARGET_SH2A\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(smin:SI (smax:SI (match_dup 1) (match_dup 3)) (match_dup 2)))])\n+\n+(define_insn \"*clips\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(smin:SI (smax:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t\t  (match_operand 2 \"clips_min_const_int\"))\n+\t\t (match_operand 3 \"clips_max_const_int\")))]\n+  \"TARGET_SH2A\"\n+{\n+  if (INTVAL (operands[3]) == 127)\n+    return \"clips.b\t%0\";\n+  else if (INTVAL (operands[3]) == 32767)\n+    return \"clips.w\t%0\";\n+  else\n+    gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"arith\")])\n+\n+;; If the expanded smin or smax patterns were not combined, split them into\n+;; a compare and branch sequence, because there are no real smin or smax\n+;; insns.\n+(define_insn_and_split \"*<code>si3\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(SMIN_SMAX:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t      (match_operand:SI 2 \"arith_reg_or_0_or_1_operand\")))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH2A && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx skip_label = gen_label_rtx ();\n+  emit_move_insn (operands[0], operands[1]);\n+\n+  rtx cmp_val = operands[2];\n+  if (satisfies_constraint_M (cmp_val))\n+    cmp_val = const0_rtx;\n+\n+  emit_insn (gen_cmpgtsi_t (operands[0], cmp_val));\n+  emit_jump_insn (<CODE> == SMIN\n+\t\t\t    ? gen_branch_false (skip_label)\n+\t\t\t    : gen_branch_true (skip_label));\n+\n+  emit_label_after (skip_label, emit_move_insn (operands[0], operands[2]));\n+  DONE;\n+})\n+\n+;; The SH2A clipu.b and clipu.w insns can be used to implement a min function\n+;; with a register and a constant.\n+;; The clipu.b and clipu.w set the SR.CS bit if the value in the register is\n+;; clipped, but there is currently no way of making use of this information.\n+;; The only way to read or reset the SR.CS bit is by accessing the SR.\n+(define_expand \"uminsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(umin:SI (match_operand:SI 1 \"arith_reg_operand\")\n+\t\t (match_operand 2 \"const_int_operand\")))]\n+  \"TARGET_SH2A\"\n+{\n+  if (INTVAL (operands[2]) == 1)\n+    {\n+      emit_insn (gen_clipu_one (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (! clipu_max_const_int (operands[2], VOIDmode))\n+    FAIL;\n+})\n+\n+(define_insn \"*clipu\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(umin:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t (match_operand 2 \"clipu_max_const_int\")))]\n+  \"TARGET_SH2A\"\n+{\n+  if (INTVAL (operands[2]) == 255)\n+    return \"clipu.b\t%0\";\n+  else if (INTVAL (operands[2]) == 65535)\n+    return \"clipu.w\t%0\";\n+  else\n+    gcc_unreachable ();\n+}\n+  [(set_attr \"type\" \"arith\")])\n+\n+(define_insn_and_split \"clipu_one\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(umin:SI (match_operand:SI 1 \"arith_reg_operand\") (const_int 1)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_SH2A\"\n+  \"#\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(const_int 0)]\n+{\n+  emit_insn (gen_cmpeqsi_t (operands[1], const0_rtx));\n+  emit_insn (gen_movnegt (operands[0], get_t_reg_rtx ()));\n+  DONE;\n+})\n+\n ;; -------------------------------------------------------------------------\n ;; Misc\n ;; -------------------------------------------------------------------------"}, {"sha": "745ed0dcec2b3a5df4e0ded3f883eb6a7981a72b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -1,3 +1,10 @@\n+2013-05-06  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/55303\n+\t* gcc.target/sh/pr55303-1.c: New.\n+\t* gcc.target/sh/pr55303-2.c: New.\n+\t* gcc.target/sh/pr55303-3.c: New.\n+\n 2013-05-05  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/allocate_with_source_3.f90: New."}, {"sha": "06151e8675ca2c4a1f5ba2427f4907cac50d1332", "filename": "gcc/testsuite/gcc.target/sh/pr55303-1.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-1.c?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -0,0 +1,87 @@\n+/* Verify that the SH2A clips and clipu instructions are generated as\n+   expected.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"clips.b\" 2 } } */\n+/* { dg-final { scan-assembler-times \"clips.w\" 2 } } */\n+/* { dg-final { scan-assembler-times \"clipu.b\" 2 } } */\n+/* { dg-final { scan-assembler-times \"clipu.w\" 2 } } */\n+\n+static inline int\n+min (int a, int b)\n+{\n+  return a < b ? a : b;\n+}\n+\n+static inline int\n+max (int a, int b)\n+{\n+  return a < b ? b : a;\n+}\n+\n+int\n+test_00 (int a)\n+{\n+  /* 1x clips.b  */\n+  return max (-128, min (127, a));\n+}\n+\n+int\n+test_01 (int a)\n+{\n+  /* 1x clips.b  */\n+  return min (127, max (-128, a));\n+}\n+\n+int\n+test_02 (int a)\n+{\n+  /* 1x clips.w  */\n+  return max (-32768, min (32767, a));\n+}\n+\n+int\n+test_03 (int a)\n+{\n+  /* 1x clips.w  */\n+  return min (32767, max (-32768, a));\n+}\n+\n+unsigned int\n+test_04 (unsigned int a)\n+{\n+  /* 1x clipu.b  */\n+  return a > 255 ? 255 : a;\n+}\n+\n+unsigned int\n+test_05 (unsigned int a)\n+{\n+  /* 1x clipu.b  */\n+  return a >= 255 ? 255 : a;\n+}\n+\n+unsigned int\n+test_06 (unsigned int a)\n+{\n+  /* 1x clipu.w  */\n+  return a > 65535 ? 65535 : a;\n+}\n+\n+unsigned int\n+test_07 (unsigned int a)\n+{\n+  /* 1x clipu.w  */\n+  return a >= 65535 ? 65535 : a;\n+}\n+\n+void\n+test_08 (unsigned short a, unsigned short b, unsigned int* r)\n+{\n+  /* Must not see a clip insn here -- it is not needed.  */\n+  unsigned short x = a + b;\n+  if (x > 65535)\n+    x = 65535;\n+  *r = x;\n+}"}, {"sha": "a70a30aa212ec1902658267455151b166bbde394", "filename": "gcc/testsuite/gcc.target/sh/pr55303-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-2.c?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that for SH2A smax/smin -> cbranch conversion is done properly\n+   if the clips insn is not used and the expected comparison insns are\n+   generated.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"cmp/pl\" 4 } } */\n+\n+int\n+test_00 (int a)\n+{\n+  /* 1x cmp/pl  */\n+  return a >= 0 ? a : 0;\n+}\n+\n+int\n+test_01 (int a)\n+{\n+  /* 1x cmp/pl  */\n+  return a <= 0 ? a : 0;\n+}\n+\n+int\n+test_02 (int a)\n+{\n+  /* 1x cmp/pl  */\n+  return a < 1 ? 1 : a;\n+}\n+\n+int\n+test_03 (int a)\n+{\n+  /* 1x cmp/pl  */\n+  return a < 1 ? a : 1;\n+}"}, {"sha": "b353539be7736837961d4f74283d140f42abf2f9", "filename": "gcc/testsuite/gcc.target/sh/pr55303-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2353515dafac6c7999110c09568b3cd0ba779710/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr55303-3.c?ref=2353515dafac6c7999110c09568b3cd0ba779710", "patch": "@@ -0,0 +1,15 @@\n+/* Verify that the special case (umin (reg const_int 1)) results in the\n+   expected instruction sequence on SH2A.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n+/* { dg-final { scan-assembler-times \"tst\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movrt\" 1 } } */\n+\n+unsigned int\n+test_00 (unsigned int a)\n+{\n+  /* 1x tst\n+     1x movrt  */\n+  return a > 1 ? 1 : a;\n+}"}]}