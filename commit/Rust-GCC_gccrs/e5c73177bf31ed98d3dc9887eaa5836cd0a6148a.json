{"sha": "e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjNzMxNzdiZjMxZWQ5OGQzZGM5ODg3ZWFhNTgzNmNkMGE2MTQ4YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-09-09T13:01:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-09-09T13:01:51Z"}, "message": "Makefile.in: Switch VxWorks to s-interr-hwint.adb.\n\n\t* gcc-interface/Makefile.in: Switch VxWorks to s-interr-hwint.adb.\n\n\t* s-interr-vxworks.adb: Renamed to s-interr-hwint.adb\n\n\t* s-interr-hwint.adb: New file.\n\n\t* s-osinte-vxworks.ads, s-osinte-vxworks.adb: Add new functions\n\tneeded by s-interr-hwint.adb.\n\n\t* s-osinte-vxworks-kernel.adb: New file.\n\nFrom-SVN: r140147", "tree": {"sha": "ffdec878d321a87e3ccd4239c6eb7f4bb7abe81d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffdec878d321a87e3ccd4239c6eb7f4bb7abe81d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/comments", "author": null, "committer": null, "parents": [{"sha": "22fb24d53aed6842ccf44df69f772728b655b444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22fb24d53aed6842ccf44df69f772728b655b444", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22fb24d53aed6842ccf44df69f772728b655b444"}], "stats": {"total": 477, "additions": 425, "deletions": 52}, "files": [{"sha": "8453c2eb964a076dbe3dff8f8dc7a6c9ac37bbc9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -1,3 +1,17 @@\n+2008-09-09  Arnaud Charlet  <charlet@adacore.com>\n+\t    Joel Sherrill  <joel.sherrill@oarcorp.com>\n+\n+       * gcc-interface/Makefile.in: Switch VxWorks to s-interr-hwint.adb.\n+\n+       * s-interr-vxworks.adb: Renamed to s-interr-hwint.adb\n+\n+       * s-interr-hwint.adb: New file.\n+\n+\t* s-osinte-vxworks.ads, s-osinte-vxworks.adb: Add new functions\n+\tneeded by s-interr-hwint.adb.\n+\n+\t* s-osinte-vxworks-kernel.adb: New file.\n+\n 2008-09-05  Joel Sherrill <joel.sherrill@oarcorp.com>\n \n \t* s-stchop-rtems.adb: Add file missed in early commit.  Already\n@@ -28,8 +42,8 @@\n \n \t* checks.adb (Determine_Range): Deal with values that might be invalid\n \n-\t* opt.adb, opt.ads (Assume_No_Invalid_Values[_Config]): New configuration\n-\tswitches.\n+\t* opt.adb, opt.ads (Assume_No_Invalid_Values[_Config]): New\n+\tconfiguration switches.\n \n \t* par-prag.adb: Dummy entry for pragma Assume_No_Invalid_Values\n "}, {"sha": "5a35c07c4d8b42311b1b029de5831527f1918e87", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -391,10 +391,10 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   a-intnam.ads<a-intnam-vxworks.ads \\\n   a-numaux.ads<a-numaux-vxworks.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks-kernel.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n@@ -472,7 +472,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n     EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n   else\n     LIBGNAT_TARGET_PAIRS += \\\n-    s-interr.adb<s-interr-vxworks.adb \\\n+    s-interr.adb<s-interr-hwint.adb \\\n     s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n     system.ads<system-vxworks-ppc.ads\n \n@@ -505,10 +505,10 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n   g-io.adb<g-io-vxworks-ppc-cert.adb \\\n   g-io.ads<g-io-vxworks-ppc-cert.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks-kernel.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-ae653.ads \\\n@@ -551,10 +551,10 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   a-intnam.ads<a-intnam-vxworks.ads \\\n   a-numaux.ads<a-numaux-vxworks.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks-kernel.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n@@ -626,7 +626,7 @@ ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n     EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n   else\n     LIBGNAT_TARGET_PAIRS += \\\n-    s-interr.adb<s-interr-vxworks.adb \\\n+    s-interr.adb<s-interr-hwint.adb \\\n     s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n     system.ads<system-vxworks-x86.ads\n \n@@ -654,10 +654,10 @@ ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n   a-intnam.ads<a-intnam-vxworks.ads \\\n   a-numaux.ads<a-numaux-vxworks.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks-kernel.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\\n@@ -689,10 +689,10 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   a-intnam.ads<a-intnam-vxworks.ads \\\n   a-numaux.ads<a-numaux-vxworks.ads \\\n   s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n+  s-interr.adb<s-interr-hwint.adb \\\n   s-intman.ads<s-intman-vxworks.ads \\\n   s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks-kernel.adb \\\n   s-osinte.ads<s-osinte-vxworks.ads \\\n   s-osprim.adb<s-osprim-vxworks.adb \\\n   s-parame.ads<s-parame-vxworks.ads \\"}, {"sha": "729c62cb8fcab40fe525684900c270197b27e5f5", "filename": "gcc/ada/s-interr-hwint.adb", "status": "renamed", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-interr-hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-interr-hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-hwint.adb?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -40,7 +40,7 @@\n --  it must call Block_Interrupt/Unblock_Interrupt, which will have the effect\n --  of unmasking/masking the signal in the Interrupt_Manager task. These\n --  comments do not apply to vectored hardware interrupts, which may be masked\n---  or unmasked using routined interfaced to the relevant VxWorks system\n+--  or unmasked using routined interfaced to the relevant embedded RTOS system\n --  calls.\n \n --  Once we associate a Signal_Server_Task with an signal, the task never goes\n@@ -61,14 +61,14 @@\n --  status between Interrupt_Manager and Server_Task. Protection among service\n --  requests are ensured via user calls to the Interrupt_Manager entries.\n \n---  This is the VxWorks version of this package, supporting vectored hardware\n---  interrupts.\n+--  This is reasonably generic version of this package, supporting vectored\n+--  hardware interrupts using non-RTOS specific adapter routines which\n+--  should easily implemented on any RTOS capable of supporting GNAT.\n \n with Ada.Unchecked_Conversion;\n with Ada.Task_Identification;\n \n-with Interfaces.VxWorks;\n-\n+with Interfaces.C; use Interfaces.C;\n with System.OS_Interface; use System.OS_Interface;\n with System.Interrupt_Management;\n with System.Task_Primitives.Operations;\n@@ -125,7 +125,7 @@ package body System.Interrupts is\n    end Interrupt_Manager;\n \n    task type Interrupt_Server_Task\n-     (Interrupt : Interrupt_ID; Int_Sema : SEM_ID) is\n+     (Interrupt : Interrupt_ID; Int_Sema : Binary_Semaphore_Id) is\n       --  Server task for vectored hardware interrupt handling\n       pragma Interrupt_Priority (System.Interrupt_Priority'First + 2);\n    end Interrupt_Server_Task;\n@@ -182,7 +182,7 @@ package body System.Interrupts is\n \n    Semaphore_ID_Map : array\n      (Interrupt_ID range 0 .. System.OS_Interface.Max_HW_Interrupt)\n-      of SEM_ID := (others => 0);\n+      of Binary_Semaphore_Id := (others => 0);\n    --  Array of binary semaphores associated with vectored interrupts\n    --  Note that the last bound should be Max_HW_Interrupt, but this will raise\n    --  Storage_Error if Num_HW_Interrupts is null, so use an extra 4 bytes\n@@ -213,11 +213,12 @@ package body System.Interrupts is\n    --  Always consider a null handler as registered.\n \n    procedure Notify_Interrupt (Param : System.Address);\n+   pragma Convention (C, Notify_Interrupt);\n    --  Umbrella handler for vectored interrupts (not signals)\n \n    procedure Install_Umbrella_Handler\n      (Interrupt : HW_Interrupt;\n-      Handler   : Interfaces.VxWorks.VOIDFUNCPTR);\n+      Handler   : System.OS_Interface.Interrupt_Handler);\n    --  Install the runtime umbrella handler for a vectored hardware\n    --  interrupt\n \n@@ -490,16 +491,12 @@ package body System.Interrupts is\n \n    procedure Install_Umbrella_Handler\n      (Interrupt : HW_Interrupt;\n-      Handler   : Interfaces.VxWorks.VOIDFUNCPTR)\n+      Handler   : System.OS_Interface.Interrupt_Handler)\n    is\n-      use Interfaces.VxWorks;\n-\n       Vec : constant Interrupt_Vector :=\n-              INUM_TO_IVEC (Interfaces.VxWorks.int (Interrupt));\n+              Interrupt_Number_To_Vector (int (Interrupt));\n \n-      Stat : Interfaces.VxWorks.STATUS;\n-      pragma Unreferenced (Stat);\n-      --  ??? shouldn't we test Stat at least in a pragma Assert?\n+      Status : int;\n \n    begin\n       --  Only install umbrella handler when no Ada handler has already been\n@@ -508,7 +505,10 @@ package body System.Interrupts is\n       --  wrapper generated by intConnect for each interrupt number.\n \n       if not Handler_Installed (Interrupt) then\n-         Stat := intConnect (Vec, Handler, System.Address (Interrupt));\n+         Status :=\n+            Interrupt_Connect (Vec, Handler, System.Address (Interrupt));\n+         pragma Assert (Status = 0);\n+\n          Handler_Installed (Interrupt) := True;\n       end if;\n    end Install_Umbrella_Handler;\n@@ -618,20 +618,20 @@ package body System.Interrupts is\n    --  on which it pends once it's been started.  This routine determines\n    --  The appropriate semaphore and issues a semGive call, waking\n    --  the server task.  When a handler is unbound,\n-   --  System.Interrupts.Unbind_Handler issues a semFlush, and the\n-   --  server task deletes its semaphore and terminates.\n+   --  System.Interrupts.Unbind_Handler issues a Binary_Semaphore_Flush,\n+   --  and the server task deletes its semaphore and terminates.\n \n    procedure Notify_Interrupt (Param : System.Address) is\n       Interrupt : constant Interrupt_ID := Interrupt_ID (Param);\n \n-      Id : constant SEM_ID := Semaphore_ID_Map (Interrupt);\n+      Id : constant Binary_Semaphore_Id := Semaphore_ID_Map (Interrupt);\n \n-      Discard_Result : STATUS;\n-      pragma Unreferenced (Discard_Result);\n+      Status : int;\n \n    begin\n       if Id /= 0 then\n-         Discard_Result := semGive (Id);\n+         Status := Binary_Semaphore_Release (Id);\n+         pragma Assert (Status = 0);\n       end if;\n    end Notify_Interrupt;\n \n@@ -764,15 +764,13 @@ package body System.Interrupts is\n       --------------------\n \n       procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n-         S : STATUS;\n-         use type STATUS;\n-\n+         Status : int;\n       begin\n \n          --  Flush server task off semaphore, allowing it to terminate\n \n-         S := semFlush (Semaphore_ID_Map (Interrupt));\n-         pragma Assert (S = 0);\n+         Status := Binary_Semaphore_Flush (Semaphore_ID_Map (Interrupt));\n+         pragma Assert (Status = 0);\n       end Unbind_Handler;\n \n       --------------------------------\n@@ -890,8 +888,7 @@ package body System.Interrupts is\n                   (To_Ada (Server_ID (Interrupt))))\n          then\n             Interrupt_Access_Hold :=\n-              new Interrupt_Server_Task\n-                (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+              new Interrupt_Server_Task (Interrupt, Binary_Semaphore_Create);\n             Server_ID (Interrupt) :=\n               To_System (Interrupt_Access_Hold.all'Identity);\n          end if;\n@@ -988,7 +985,7 @@ package body System.Interrupts is\n                         (To_Ada (Server_ID (Interrupt)))\n                   then\n                      Interrupt_Access_Hold := new Interrupt_Server_Task\n-                       (Interrupt, semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+                       (Interrupt, Binary_Semaphore_Create);\n                      Server_ID (Interrupt) :=\n                        To_System (Interrupt_Access_Hold.all'Identity);\n                   end if;\n@@ -1046,9 +1043,7 @@ package body System.Interrupts is\n       Tmp_Handler     : Parameterless_Handler;\n       Tmp_ID          : Task_Id;\n       Tmp_Entry_Index : Task_Entry_Index;\n-      S               : STATUS;\n-\n-      use type STATUS;\n+      Status          : int;\n \n    begin\n       System.Tasking.Utilities.Make_Independent;\n@@ -1058,8 +1053,8 @@ package body System.Interrupts is\n          --  Pend on semaphore that will be triggered by the\n          --  umbrella handler when the associated interrupt comes in\n \n-         S := semTake (Int_Sema, WAIT_FOREVER);\n-         pragma Assert (S = 0);\n+         Status := Binary_Semaphore_Obtain (Int_Sema);\n+         pragma Assert (Status = 0);\n \n          if User_Handler (Interrupt).H /= null then\n \n@@ -1091,9 +1086,9 @@ package body System.Interrupts is\n \n             --  Delete the associated semaphore\n \n-            S := semDelete (Int_Sema);\n+            Status := Binary_Semaphore_Delete (Int_Sema);\n \n-            pragma Assert (S = 0);\n+            pragma Assert (Status = 0);\n \n             --  Set status for the Interrupt_Manager\n ", "previous_filename": "gcc/ada/s-interr-vxworks.adb"}, {"sha": "ed62f8029537e84e98814888da6acfbebbbb5df1", "filename": "gcc/ada/s-osinte-vxworks-kernel.adb", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks-kernel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks-kernel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks-kernel.adb?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -0,0 +1,251 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                   B o d y                                --\n+--                                                                          --\n+--         Copyright (C) 1997-2008, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VxWorks version\n+\n+--  This package encapsulates all direct interfaces to OS services that are\n+--  needed by children of System.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It causes infinite loops and other problems.\n+\n+package body System.OS_Interface is\n+\n+   use type Interfaces.C.int;\n+\n+   Low_Priority : constant := 255;\n+   --  VxWorks native (default) lowest scheduling priority\n+\n+   ----------\n+   -- kill --\n+   ----------\n+\n+   function kill (pid : t_id; sig : Signal) return int is\n+   begin\n+      return System.VxWorks.Ext.kill (pid, int (sig));\n+   end kill;\n+\n+   -------------\n+   -- sigwait --\n+   -------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int\n+   is\n+      Result : int;\n+\n+      function sigwaitinfo\n+        (set : access sigset_t; sigvalue : System.Address) return int;\n+      pragma Import (C, sigwaitinfo, \"sigwaitinfo\");\n+\n+   begin\n+      Result := sigwaitinfo (set, System.Null_Address);\n+\n+      if Result /= -1 then\n+         sig.all := Signal (Result);\n+         return 0;\n+      else\n+         sig.all := 0;\n+         return errno;\n+      end if;\n+   end sigwait;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F is negative due to a round-up, adjust for positive F value\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec'(ts_sec  => S,\n+                       ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   -------------------------\n+   -- To_VxWorks_Priority --\n+   -------------------------\n+\n+   function To_VxWorks_Priority (Priority : int) return int is\n+   begin\n+      return Low_Priority - Priority;\n+   end To_VxWorks_Priority;\n+\n+   --------------------\n+   -- To_Clock_Ticks --\n+   --------------------\n+\n+   --  ??? - For now, we'll always get the system clock rate since it is\n+   --  allowed to be changed during run-time in VxWorks. A better method would\n+   --  be to provide an operation to set it that so we can always know its\n+   --  value.\n+\n+   --  Another thing we should probably allow for is a resultant tick count\n+   --  greater than int'Last. This should probably be a procedure with two\n+   --  output parameters, one in the range 0 .. int'Last, and another\n+   --  representing the overflow count.\n+\n+   function To_Clock_Ticks (D : Duration) return int is\n+      Ticks          : Long_Long_Integer;\n+      Rate_Duration  : Duration;\n+      Ticks_Duration : Duration;\n+\n+   begin\n+      if D < 0.0 then\n+         return -1;\n+      end if;\n+\n+      --  Ensure that the duration can be converted to ticks\n+      --  at the current clock tick rate without overflowing.\n+\n+      Rate_Duration := Duration (sysClkRateGet);\n+\n+      if D > (Duration'Last / Rate_Duration) then\n+         Ticks := Long_Long_Integer (int'Last);\n+      else\n+         Ticks_Duration := D * Rate_Duration;\n+         Ticks := Long_Long_Integer (Ticks_Duration);\n+\n+         if Ticks_Duration > Duration (Ticks) then\n+            Ticks := Ticks + 1;\n+         end if;\n+\n+         if Ticks > Long_Long_Integer (int'Last) then\n+            Ticks := Long_Long_Integer (int'Last);\n+         end if;\n+      end if;\n+\n+      return int (Ticks);\n+   end To_Clock_Ticks;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Create --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Create return Binary_Semaphore_Id is\n+   begin\n+      return Binary_Semaphore_Id (semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+   end Binary_Semaphore_Create;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Delete --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Delete (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semDelete (SEM_ID (ID));\n+   end Binary_Semaphore_Delete;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Obtain --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Obtain (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semTake (SEM_ID (ID), WAIT_FOREVER);\n+   end Binary_Semaphore_Obtain;\n+\n+   ------------------------------\n+   -- Binary_Semaphore_Release --\n+   ------------------------------\n+\n+   function Binary_Semaphore_Release (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semGive (SEM_ID (ID));\n+   end Binary_Semaphore_Release;\n+\n+   ----------------------------\n+   -- Binary_Semaphore_Flush --\n+   ----------------------------\n+\n+   function Binary_Semaphore_Flush (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semFlush (SEM_ID (ID));\n+   end Binary_Semaphore_Flush;\n+\n+   -----------------------\n+   -- Interrupt_Connect --\n+   -----------------------\n+\n+   function Interrupt_Connect\n+     (Vector    : Interrupt_Vector;\n+      Handler   : Interrupt_Handler;\n+      Parameter : System.Address := System.Null_Address) return int\n+   is\n+      function intConnect\n+        (vector    : Interrupt_Vector;\n+         handler   : Interrupt_Handler;\n+         parameter : System.Address) return int;\n+      pragma Import (C, intConnect, \"intConnect\");\n+\n+   begin\n+      return intConnect (Vector, Handler, Parameter);\n+   end Interrupt_Connect;\n+\n+   --------------------------------\n+   -- Interrupt_Number_To_Vector --\n+   --------------------------------\n+\n+   function Interrupt_Number_To_Vector\n+     (intNum : int) return Interrupt_Vector\n+   is\n+      function INUM_TO_IVEC (intNum : int) return Interrupt_Vector;\n+      pragma Import (C, INUM_TO_IVEC, \"__gnat_inum_to_ivec\");\n+\n+   begin\n+      return INUM_TO_IVEC (intNum);\n+   end Interrupt_Number_To_Vector;\n+\n+end System.OS_Interface;"}, {"sha": "b0fd06b10ef72963ecc324616999203436a0aa96", "filename": "gcc/ada/s-osinte-vxworks.adb", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.adb?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                   B o d y                                --\n --                                                                          --\n---         Copyright (C) 1997-2007, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1997-2008, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -170,4 +170,73 @@ package body System.OS_Interface is\n       return int (Ticks);\n    end To_Clock_Ticks;\n \n+   -----------------------------\n+   -- Binary_Semaphore_Create --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Create return Binary_Semaphore_Id is\n+   begin\n+      return Binary_Semaphore_Id (semBCreate (SEM_Q_FIFO, SEM_EMPTY));\n+   end Binary_Semaphore_Create;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Delete --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Delete (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semDelete (SEM_ID (ID));\n+   end Binary_Semaphore_Delete;\n+\n+   -----------------------------\n+   -- Binary_Semaphore_Obtain --\n+   -----------------------------\n+\n+   function Binary_Semaphore_Obtain (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semTake (SEM_ID (ID), WAIT_FOREVER);\n+   end Binary_Semaphore_Obtain;\n+\n+   ------------------------------\n+   -- Binary_Semaphore_Release --\n+   ------------------------------\n+\n+   function Binary_Semaphore_Release (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semGive (SEM_ID (ID));\n+   end Binary_Semaphore_Release;\n+\n+   ----------------------------\n+   -- Binary_Semaphore_Flush --\n+   ----------------------------\n+\n+   function Binary_Semaphore_Flush (ID : Binary_Semaphore_Id) return int is\n+   begin\n+      return semFlush (SEM_ID (ID));\n+   end Binary_Semaphore_Flush;\n+\n+   -----------------------\n+   -- Interrupt_Connect --\n+   -----------------------\n+\n+   function Interrupt_Connect\n+     (Vector    : Interrupt_Vector;\n+      Handler   : Interrupt_Handler;\n+      Parameter : System.Address := System.Null_Address) return int\n+   is\n+      pragma Unreferenced (Vector, Handler, Parameter);\n+   begin\n+      return 0;\n+   end Interrupt_Connect;\n+\n+   --------------------------------\n+   -- Interrupt_Number_To_Vector --\n+   --------------------------------\n+\n+   function Interrupt_Number_To_Vector\n+     (intNum : int) return Interrupt_Vector is\n+   begin\n+      return Interrupt_Vector (intNum);\n+   end Interrupt_Number_To_Vector;\n+\n end System.OS_Interface;"}, {"sha": "532bded849d566c4f410e0839c677a1debb1bbb5", "filename": "gcc/ada/s-osinte-vxworks.ads", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c73177bf31ed98d3dc9887eaa5836cd0a6148a/gcc%2Fada%2Fs-osinte-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vxworks.ads?ref=e5c73177bf31ed98d3dc9887eaa5836cd0a6148a", "patch": "@@ -432,6 +432,50 @@ package System.OS_Interface is\n    pragma Import (C, semFlush, \"semFlush\");\n    --  Release all threads blocked on the semaphore\n \n+   ------------------------------------------------------------\n+   --   Binary Semaphore Wrapper to Support Interrupt Tasks  --\n+   ------------------------------------------------------------\n+\n+   type Binary_Semaphore_Id is new Long_Integer;\n+\n+   function Binary_Semaphore_Create return Binary_Semaphore_Id;\n+   pragma Inline (Binary_Semaphore_Create);\n+\n+   function Binary_Semaphore_Delete (ID : Binary_Semaphore_Id) return int;\n+   pragma Inline (Binary_Semaphore_Delete);\n+\n+   function Binary_Semaphore_Obtain (ID : Binary_Semaphore_Id) return int;\n+   pragma Inline (Binary_Semaphore_Obtain);\n+\n+   function Binary_Semaphore_Release (ID : Binary_Semaphore_Id) return int;\n+   pragma Inline (Binary_Semaphore_Release);\n+\n+   function Binary_Semaphore_Flush (ID : Binary_Semaphore_Id) return int;\n+   pragma Inline (Binary_Semaphore_Flush);\n+\n+   ------------------------------------------------------------\n+   -- Hardware Interrupt Wrappers to Support Interrupt Tasks --\n+   ------------------------------------------------------------\n+\n+   type Interrupt_Handler is access procedure (parameter : System.Address);\n+   pragma Convention (C, Interrupt_Handler);\n+\n+   type Interrupt_Vector is new System.Address;\n+\n+   function Interrupt_Connect\n+     (Vector    : Interrupt_Vector;\n+      Handler   : Interrupt_Handler;\n+      Parameter : System.Address := System.Null_Address) return int;\n+   pragma Inline (Interrupt_Connect);\n+   --  Use this to set up an user handler. The routine installs a\n+   --  a user handler which is invoked after RTEMS has saved enough\n+   --  context for a high-level language routine to be safely invoked.\n+\n+   function Interrupt_Number_To_Vector (intNum : int) return Interrupt_Vector;\n+   pragma Inline (Interrupt_Number_To_Vector);\n+   --  Convert a logical interrupt number to the hardware interrupt vector\n+   --  number used to connect the interrupt.\n+\n private\n    type sigset_t is new unsigned_long_long;\n "}]}