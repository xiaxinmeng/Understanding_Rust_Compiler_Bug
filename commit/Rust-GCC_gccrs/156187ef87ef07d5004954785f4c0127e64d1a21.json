{"sha": "156187ef87ef07d5004954785f4c0127e64d1a21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU2MTg3ZWY4N2VmMDdkNTAwNDk1NDc4NWY0YzAxMjdlNjRkMWEyMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-08T08:14:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-08T08:14:36Z"}, "message": "[Ada] In-place initialization for Initialize_Scalars\n\nUpdate the documentation of pragma Initialize_Scalars in the GNAT\nReference Manual.\n\n2019-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* doc/gnat_rm/implementation_defined_pragmas.rst:\n\tUpdate the documentation of pragma Initialize_Scalars.\n\t* gnat_rm.texi: Regenerate.\n\nFrom-SVN: r273220", "tree": {"sha": "ddcc40a15936631d001edc2909c533038e678d45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcc40a15936631d001edc2909c533038e678d45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/156187ef87ef07d5004954785f4c0127e64d1a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156187ef87ef07d5004954785f4c0127e64d1a21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/156187ef87ef07d5004954785f4c0127e64d1a21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/156187ef87ef07d5004954785f4c0127e64d1a21/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa2538c77b94a62c657aee31a613ea29e6a46d4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa2538c77b94a62c657aee31a613ea29e6a46d4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa2538c77b94a62c657aee31a613ea29e6a46d4d"}], "stats": {"total": 271, "additions": 175, "deletions": 96}, "files": [{"sha": "badbe8f1a1b9cc7f6efa24869c4d6fab863d53ce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=156187ef87ef07d5004954785f4c0127e64d1a21", "patch": "@@ -1,3 +1,9 @@\n+2019-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst:\n+\tUpdate the documentation of pragma Initialize_Scalars.\n+\t* gnat_rm.texi: Regenerate.\n+\n 2019-07-08  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Tagged_Membership): Fix regression silently"}, {"sha": "dff7798ed7d571f026c96b29c1161671305250f7", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 75, "deletions": 46, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=156187ef87ef07d5004954785f4c0127e64d1a21", "patch": "@@ -2432,7 +2432,7 @@ with Import and Export pragmas.  There are two cases to consider:\n   ``As_Is`` provides the normal default behavior in which the casing is\n   taken from the string provided.\n \n-This pragma may appear anywhere that a pragma is valid.  In particular, it\n+This pragma may appear anywhere that a pragma is valid. In particular, it\n can be used as a configuration pragma in the :file:`gnat.adc` file, in which\n case it applies to all subsequent compilations, or it can be used as a program\n unit pragma, in which case it only applies to the current unit, or it can\n@@ -2999,58 +2999,87 @@ Syntax:\n \n .. code-block:: ada\n \n-  pragma Initialize_Scalars;\n+  pragma Initialize_Scalars\n+    [ ( TYPE_VALUE_PAIR {, TYPE_VALUE_PAIR} ) ];\n \n+  TYPE_VALUE_PAIR ::=\n+    SCALAR_TYPE => static_EXPRESSION\n \n-This pragma is similar to ``Normalize_Scalars`` conceptually but has\n-two important differences.  First, there is no requirement for the pragma\n-to be used uniformly in all units of a partition, in particular, it is fine\n-to use this just for some or all of the application units of a partition,\n-without needing to recompile the run-time library.\n+  SCALAR_TYPE :=\n+    Short_Float\n+  | Float\n+  | Long_Float\n+  | Long_Long_Flat\n+  | Signed_8\n+  | Signed_16\n+  | Signed_32\n+  | Signed_64\n+  | Unsigned_8\n+  | Unsigned_16\n+  | Unsigned_32\n+  | Unsigned_64\n \n-In the case where some units are compiled with the pragma, and some without,\n-then a declaration of a variable where the type is defined in package\n-Standard or is locally declared will always be subject to initialization,\n-as will any declaration of a scalar variable.  For composite variables,\n-whether the variable is initialized may also depend on whether the package\n-in which the type of the variable is declared is compiled with the pragma.\n \n-The other important difference is that you can control the value used\n-for initializing scalar objects.  At bind time, you can select several\n-options for initialization. You can\n-initialize with invalid values (similar to Normalize_Scalars, though for\n-Initialize_Scalars it is not always possible to determine the invalid\n-values in complex cases like signed component fields with non-standard\n-sizes). You can also initialize with high or\n-low values, or with a specified bit pattern.  See the GNAT\n-User's Guide for binder options for specifying these cases.\n+This pragma is similar to ``Normalize_Scalars`` conceptually but has two\n+important differences.\n \n-This means that you can compile a program, and then without having to\n-recompile the program, you can run it with different values being used\n-for initializing otherwise uninitialized values, to test if your program\n-behavior depends on the choice.  Of course the behavior should not change,\n-and if it does, then most likely you have an incorrect reference to an\n-uninitialized value.\n+First, there is no requirement for the pragma to be used uniformly in all units\n+of a partition. In particular, it is fine to use this just for some or all of\n+the application units of a partition, without needing to recompile the run-time\n+library. In the case where some units are compiled with the pragma, and some\n+without, then a declaration of a variable where the type is defined in package\n+Standard or is locally declared will always be subject to initialization, as\n+will any declaration of a scalar variable. For composite variables, whether the\n+variable is initialized may also depend on whether the package in which the\n+type of the variable is declared is compiled with the pragma.\n \n-It is even possible to change the value at execution time eliminating even\n-the need to rebind with a different switch using an environment variable.\n-See the GNAT User's Guide for details.\n+The other important difference is that the programmer can control the value\n+used for initializing scalar objects. This effect can be achieved in several\n+different ways:\n+\n+* At compile time, the programmer can specify the invalid value for a\n+  particular family of scalar types using the optional arguments of the pragma.\n+\n+  The compile-time approach is intended to optimize the generated code for the\n+  pragma, by possibly using fast operations such as ``memset``.\n+\n+* At bind time, the programmer has several options:\n+\n+  * Initialization with invalid values (similar to Normalize_Scalars, though\n+    for Initialize_Scalars it is not always possible to determine the invalid\n+    values in complex cases like signed component fields with nonstandard\n+    sizes).\n+\n+  * Initialization with high values.\n+\n+  * Initialization with low values.\n+\n+  * Initialization with a specific bit pattern.\n+\n+  See the GNAT User's Guide for binder options for specifying these cases.\n+\n+  The bind-time approach is intended to provide fast turnaround for testing\n+  with different values, without having to recompile the program.\n+\n+* At execution time, the programmer can speify the invalid values using an\n+  environment variable. See the GNAT User's Guide for details.\n+\n+  The execution-time approach is intended to provide fast turnaround for\n+  testing with different values, without having to recompile and rebind the\n+  program.\n+\n+Note that pragma ``Initialize_Scalars`` is particularly useful in conjunction\n+with the enhanced validity checking that is now provided in GNAT, which checks\n+for invalid values under more conditions. Using this feature (see description\n+of the *-gnatV* flag in the GNAT User's Guide) in conjunction with pragma\n+``Initialize_Scalars`` provides a powerful new tool to assist in the detection\n+of problems caused by uninitialized variables.\n \n-Note that pragma ``Initialize_Scalars`` is particularly useful in\n-conjunction with the enhanced validity checking that is now provided\n-in GNAT, which checks for invalid values under more conditions.\n-Using this feature (see description of the *-gnatV* flag in the\n-GNAT User's Guide) in conjunction with\n-pragma ``Initialize_Scalars``\n-provides a powerful new tool to assist in the detection of problems\n-caused by uninitialized variables.\n-\n-Note: the use of ``Initialize_Scalars`` has a fairly extensive\n-effect on the generated code. This may cause your code to be\n-substantially larger. It may also cause an increase in the amount\n-of stack required, so it is probably a good idea to turn on stack\n-checking (see description of stack checking in the GNAT\n-User's Guide) when using this pragma.\n+Note: the use of ``Initialize_Scalars`` has a fairly extensive effect on the\n+generated code. This may cause your code to be substantially larger. It may\n+also cause an increase in the amount of stack required, so it is probably a\n+good idea to turn on stack checking (see description of stack checking in the\n+GNAT User's Guide) when using this pragma.\n \n .. _Pragma-Initializes:\n "}, {"sha": "b540e7bdd5dec77530f2913bb286101bd30ec1ee", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 94, "deletions": 50, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/156187ef87ef07d5004954785f4c0127e64d1a21/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=156187ef87ef07d5004954785f4c0127e64d1a21", "patch": "@@ -3870,7 +3870,7 @@ then the name will be forced to all lowercase letters.  A specification of\n taken from the string provided.\n @end itemize\n \n-This pragma may appear anywhere that a pragma is valid.  In particular, it\n+This pragma may appear anywhere that a pragma is valid. In particular, it\n can be used as a configuration pragma in the @code{gnat.adc} file, in which\n case it applies to all subsequent compilations, or it can be used as a program\n unit pragma, in which case it only applies to the current unit, or it can\n@@ -4441,58 +4441,102 @@ in the SPARK 2014 Reference Manual, section 7.1.6.\n Syntax:\n \n @example\n-pragma Initialize_Scalars;\n+pragma Initialize_Scalars\n+  [ ( TYPE_VALUE_PAIR @{, TYPE_VALUE_PAIR@} ) ];\n+\n+TYPE_VALUE_PAIR ::=\n+  SCALAR_TYPE => static_EXPRESSION\n+\n+SCALAR_TYPE :=\n+  Short_Float\n+| Float\n+| Long_Float\n+| Long_Long_Flat\n+| Signed_8\n+| Signed_16\n+| Signed_32\n+| Signed_64\n+| Unsigned_8\n+| Unsigned_16\n+| Unsigned_32\n+| Unsigned_64\n @end example\n \n-This pragma is similar to @code{Normalize_Scalars} conceptually but has\n-two important differences.  First, there is no requirement for the pragma\n-to be used uniformly in all units of a partition, in particular, it is fine\n-to use this just for some or all of the application units of a partition,\n-without needing to recompile the run-time library.\n-\n-In the case where some units are compiled with the pragma, and some without,\n-then a declaration of a variable where the type is defined in package\n-Standard or is locally declared will always be subject to initialization,\n-as will any declaration of a scalar variable.  For composite variables,\n-whether the variable is initialized may also depend on whether the package\n-in which the type of the variable is declared is compiled with the pragma.\n-\n-The other important difference is that you can control the value used\n-for initializing scalar objects.  At bind time, you can select several\n-options for initialization. You can\n-initialize with invalid values (similar to Normalize_Scalars, though for\n-Initialize_Scalars it is not always possible to determine the invalid\n-values in complex cases like signed component fields with non-standard\n-sizes). You can also initialize with high or\n-low values, or with a specified bit pattern.  See the GNAT\n-User's Guide for binder options for specifying these cases.\n-\n-This means that you can compile a program, and then without having to\n-recompile the program, you can run it with different values being used\n-for initializing otherwise uninitialized values, to test if your program\n-behavior depends on the choice.  Of course the behavior should not change,\n-and if it does, then most likely you have an incorrect reference to an\n-uninitialized value.\n-\n-It is even possible to change the value at execution time eliminating even\n-the need to rebind with a different switch using an environment variable.\n-See the GNAT User's Guide for details.\n+This pragma is similar to @code{Normalize_Scalars} conceptually but has two\n+important differences.\n+\n+First, there is no requirement for the pragma to be used uniformly in all units\n+of a partition. In particular, it is fine to use this just for some or all of\n+the application units of a partition, without needing to recompile the run-time\n+library. In the case where some units are compiled with the pragma, and some\n+without, then a declaration of a variable where the type is defined in package\n+Standard or is locally declared will always be subject to initialization, as\n+will any declaration of a scalar variable. For composite variables, whether the\n+variable is initialized may also depend on whether the package in which the\n+type of the variable is declared is compiled with the pragma.\n+\n+The other important difference is that the programmer can control the value\n+used for initializing scalar objects. This effect can be achieved in several\n+different ways:\n+\n+\n+@itemize *\n+\n+@item \n+At compile time, the programmer can specify the invalid value for a\n+particular family of scalar types using the optional arguments of the pragma.\n+\n+The compile-time approach is intended to optimize the generated code for the\n+pragma, by possibly using fast operations such as @code{memset}.\n+\n+@item \n+At bind time, the programmer has several options:\n+\n+\n+@itemize *\n+\n+@item \n+Initialization with invalid values (similar to Normalize_Scalars, though\n+for Initialize_Scalars it is not always possible to determine the invalid\n+values in complex cases like signed component fields with nonstandard\n+sizes).\n+\n+@item \n+Initialization with high values.\n+\n+@item \n+Initialization with low values.\n+\n+@item \n+Initialization with a specific bit pattern.\n+@end itemize\n+\n+See the GNAT User's Guide for binder options for specifying these cases.\n+\n+The bind-time approach is intended to provide fast turnaround for testing\n+with different values, without having to recompile the program.\n+\n+@item \n+At execution time, the programmer can speify the invalid values using an\n+environment variable. See the GNAT User's Guide for details.\n+\n+The execution-time approach is intended to provide fast turnaround for\n+testing with different values, without having to recompile and rebind the\n+program.\n+@end itemize\n+\n+Note that pragma @code{Initialize_Scalars} is particularly useful in conjunction\n+with the enhanced validity checking that is now provided in GNAT, which checks\n+for invalid values under more conditions. Using this feature (see description\n+of the @emph{-gnatV} flag in the GNAT User's Guide) in conjunction with pragma\n+@code{Initialize_Scalars} provides a powerful new tool to assist in the detection\n+of problems caused by uninitialized variables.\n \n-Note that pragma @code{Initialize_Scalars} is particularly useful in\n-conjunction with the enhanced validity checking that is now provided\n-in GNAT, which checks for invalid values under more conditions.\n-Using this feature (see description of the @emph{-gnatV} flag in the\n-GNAT User's Guide) in conjunction with\n-pragma @code{Initialize_Scalars}\n-provides a powerful new tool to assist in the detection of problems\n-caused by uninitialized variables.\n-\n-Note: the use of @code{Initialize_Scalars} has a fairly extensive\n-effect on the generated code. This may cause your code to be\n-substantially larger. It may also cause an increase in the amount\n-of stack required, so it is probably a good idea to turn on stack\n-checking (see description of stack checking in the GNAT\n-User's Guide) when using this pragma.\n+Note: the use of @code{Initialize_Scalars} has a fairly extensive effect on the\n+generated code. This may cause your code to be substantially larger. It may\n+also cause an increase in the amount of stack required, so it is probably a\n+good idea to turn on stack checking (see description of stack checking in the\n+GNAT User's Guide) when using this pragma.\n \n @node Pragma Initializes,Pragma Inline_Always,Pragma Initialize_Scalars,Implementation Defined Pragmas\n @anchor{gnat_rm/implementation_defined_pragmas pragma-initializes}@anchor{83}@anchor{gnat_rm/implementation_defined_pragmas id17}@anchor{84}"}]}