{"sha": "ad69b5b6698dc2339b4c227da0319371690dc8ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ2OWI1YjY2OThkYzIzMzliNGMyMjdkYTAzMTkzNzE2OTBkYzhlZg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-06-27T05:18:56Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-06-27T05:18:56Z"}, "message": "re GNATS gcj/238 (Can't call methods from Object on an inner class)\n\n2000-06-09  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* parse.y (find_applicable_accessible_methods_list): Use a hashtable\n\tto track searched classes, and do not search the same class more than\n\tonce. Call find_applicable_accessible_methods_list on immediate\n\tsuperclass, instead of search_applicable_method_list on all ancestors.\n\tFix for PR gcj/238.\n\n(Fix to the Java PR #238:\n http://sourceware.cygnus.com/ml/java-prs/2000-q2/msg00206.html)\n\nFrom-SVN: r34727", "tree": {"sha": "2e97d39042bd137504ee9e15a83de3e9dd50faa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e97d39042bd137504ee9e15a83de3e9dd50faa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad69b5b6698dc2339b4c227da0319371690dc8ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad69b5b6698dc2339b4c227da0319371690dc8ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad69b5b6698dc2339b4c227da0319371690dc8ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad69b5b6698dc2339b4c227da0319371690dc8ef/comments", "author": null, "committer": null, "parents": [{"sha": "7b245d2461191bc67cb3dc22a5006e5478a5552b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b245d2461191bc67cb3dc22a5006e5478a5552b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b245d2461191bc67cb3dc22a5006e5478a5552b"}], "stats": {"total": 204, "additions": 113, "deletions": 91}, "files": [{"sha": "f01dcb8b558d11faa33a748e2c986ced0f6718da", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ad69b5b6698dc2339b4c227da0319371690dc8ef", "patch": "@@ -94,6 +94,14 @@\n \n \t* lang.c (lang_get_alias_set): Mark parameter with ATTRIBUTE_UNUSED.\n \n+2000-06-09  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* parse.y (find_applicable_accessible_methods_list): Use a hashtable\n+\tto track searched classes, and do not search the same class more than\n+\tonce. Call find_applicable_accessible_methods_list on immediate\n+\tsuperclass, instead of search_applicable_method_list on all ancestors.\n+\tFix for PR gcj/238.\n+\n 2000-06-09  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* parse.y (register_fields): Permit static fields in inner classes"}, {"sha": "6f859dd17eb01108db168f0cd4da8722b1b02d78", "filename": "gcc/java/parse.c", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=ad69b5b6698dc2339b4c227da0319371690dc8ef", "patch": "@@ -9496,7 +9496,7 @@ check_inner_class_access (decl, enclosing_type, cl)\n       || enclosing_context_p (TREE_TYPE (enclosing_type), TREE_TYPE (decl)))\n     return;\n \n-  parse_error_context (cl, \"Can't access nested %s %s. Only plublic classes and interfaces in other packages can be accessed\",\n+  parse_error_context (cl, \"Can't access nested %s %s. Only public classes and interfaces in other packages can be accessed\",\n \t\t       (CLASS_INTERFACE (decl) ? \"interface\" : \"class\"),\n \t\t       lang_printable_name (decl, 0));\n }\n@@ -12799,9 +12799,29 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n      int lc;\n      tree class, name, arglist;\n {\n-  static int object_done = 0;\n+  static struct hash_table t, *searched_classes = NULL;\n+  static int search_not_done = 0;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n \n+  /* Check the hash table to determine if this class has been searched \n+     already. */\n+  if (searched_classes)\n+    {\n+      if (hash_lookup (searched_classes, \n+                      (const hash_table_key) class, FALSE, NULL))\n+       return NULL;\n+    }\n+  else\n+    {\n+      hash_table_init (&t, hash_newfunc, java_hash_hash_tree_node,\n+                      java_hash_compare_tree_node);\n+      searched_classes = &t;\n+    }\n+    \n+  search_not_done++;\n+  hash_lookup (searched_classes, \n+              (const hash_table_key) class, TRUE, NULL);\n+\n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n     {\n       load_class (class, 1);\n@@ -12812,30 +12832,8 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n   if (TREE_CODE (TYPE_NAME (class)) == TYPE_DECL \n       && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n-      static struct hash_table t, *searched_interfaces = NULL;\n-      static int search_not_done = 0;\n       int i, n;\n       tree basetype_vec = TYPE_BINFO_BASETYPES (class);\n-\n-      /* Search in the hash table, otherwise create a new one if\n-         necessary and insert the new entry. */\n-\n-      if (searched_interfaces)\n-\t{\n-\t  if (hash_lookup (searched_interfaces, \n-\t\t\t   (const hash_table_key) class, FALSE, NULL))\n-\t    return NULL;\n-\t}\n-      else\n-\t{\n-\t  hash_table_init (&t, hash_newfunc, java_hash_hash_tree_node,\n-\t\t\t   java_hash_compare_tree_node);\n-\t  searched_interfaces = &t;\n-\t}\n-\n-      hash_lookup (searched_interfaces, \n-\t\t   (const hash_table_key) class, TRUE, NULL);\n-\n       search_applicable_methods_list (lc, TYPE_METHODS (class), \n \t\t\t\t      name, arglist, &list, &all_list);\n       n = TREE_VEC_LENGTH (basetype_vec);\n@@ -12844,23 +12842,9 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n \t  tree rlist;\n \n-\t  search_not_done++;\n \t  rlist = find_applicable_accessible_methods_list (lc,  t, name, \n \t\t\t\t\t\t\t   arglist);\n \t  list = chainon (rlist, list);\n-\t  search_not_done--;\n-\t}\n-\n-      /* We're done. Reset the searched interfaces list and finally search\n-         java.lang.Object */\n-      if (!search_not_done)\n-\t{  \n-\t  if (!object_done)\n-\t    search_applicable_methods_list (lc, \n-\t\t\t\t\t    TYPE_METHODS (object_type_node),\n-\t\t\t\t\t    name, arglist, &list, &all_list);\n-\t  hash_table_free (searched_interfaces);\n-\t  searched_interfaces = NULL;  \n \t}\n     }\n   /* Search classes */\n@@ -12876,7 +12860,6 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       {\n \ttree basetype_vec = TYPE_BINFO_BASETYPES (sc);\n \tint n = TREE_VEC_LENGTH (basetype_vec), i;\n-\tobject_done = 1;\n \tfor (i = 1; i < n; i++)\n \t  {\n \t    tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n@@ -12888,7 +12871,6 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t\tlist = chainon (rlist, list);\n \t      }\n \t  }\n-\tobject_done = 0;\n       }\n \n       /* Search enclosing context of inner classes before looking\n@@ -12909,18 +12891,43 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       else\n \tclass = sc;\n \n-      for (class = (lc ? NULL_TREE : CLASSTYPE_SUPER (class)); \n-        class; class = CLASSTYPE_SUPER (class))\n-       search_applicable_methods_list (lc, TYPE_METHODS (class), \n-                                       name, arglist, &list, &all_list);\n+      /* Search superclass */\n+      if (!lc && CLASSTYPE_SUPER (class) != NULL_TREE)\n+\t{\n+          tree rlist;\n+          class = CLASSTYPE_SUPER (class);\n+          rlist = find_applicable_accessible_methods_list (lc, class, \n+                                                           name, arglist);\n+          list = chainon (rlist, list);\n+        }\n+    }\n+\n+  search_not_done--;\n+\n+  /* We're done. Reset the searched classes list and finally search\n+     java.lang.Object if it wasn't searched already. */\n+  if (!search_not_done)\n+    {\n+      if (!lc\n+\t  && TYPE_METHODS (object_type_node)\n+\t  && !hash_lookup (searched_classes, \n+                           (const hash_table_key) object_type_node, \n+                           FALSE, NULL))\n+\t{\n+          search_applicable_methods_list (lc, \n+                                          TYPE_METHODS (object_type_node),\n+                                          name, arglist, &list, &all_list);\n+        }\n+      hash_table_free (searched_classes);\n+      searched_classes = NULL;\n     }\n \n   /* Either return the list obtained or all selected (but\n      inaccessible) methods for better error report. */\n   return (!list ? all_list : list);\n }\n \n-/* Effectively search for the approriate method in method */\n+/* Effectively search for the appropriate method in method */\n \n static void \n search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n@@ -12949,7 +12956,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n \t    *all_list = tree_cons (NULL_TREE, method, *list);\n \t}\n     }\n-}    \n+}\n \n /* 15.11.2.2 Choose the Most Specific Method */\n "}, {"sha": "e26859c2ae5b5e6f5b40b1f89d76a5f0786d1866", "filename": "gcc/java/parse.y", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad69b5b6698dc2339b4c227da0319371690dc8ef/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=ad69b5b6698dc2339b4c227da0319371690dc8ef", "patch": "@@ -10101,9 +10101,29 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n      int lc;\n      tree class, name, arglist;\n {\n-  static int object_done = 0;\n+  static struct hash_table t, *searched_classes = NULL;\n+  static int search_not_done = 0;\n   tree list = NULL_TREE, all_list = NULL_TREE;\n \n+  /* Check the hash table to determine if this class has been searched \n+     already. */\n+  if (searched_classes)\n+    {\n+      if (hash_lookup (searched_classes, \n+                      (const hash_table_key) class, FALSE, NULL))\n+       return NULL;\n+    }\n+  else\n+    {\n+      hash_table_init (&t, hash_newfunc, java_hash_hash_tree_node,\n+                      java_hash_compare_tree_node);\n+      searched_classes = &t;\n+    }\n+    \n+  search_not_done++;\n+  hash_lookup (searched_classes, \n+              (const hash_table_key) class, TRUE, NULL);\n+\n   if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n     {\n       load_class (class, 1);\n@@ -10114,30 +10134,8 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n   if (TREE_CODE (TYPE_NAME (class)) == TYPE_DECL \n       && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n-      static struct hash_table t, *searched_interfaces = NULL;\n-      static int search_not_done = 0;\n       int i, n;\n       tree basetype_vec = TYPE_BINFO_BASETYPES (class);\n-\n-      /* Search in the hash table, otherwise create a new one if\n-         necessary and insert the new entry. */\n-\n-      if (searched_interfaces)\n-\t{\n-\t  if (hash_lookup (searched_interfaces, \n-\t\t\t   (const hash_table_key) class, FALSE, NULL))\n-\t    return NULL;\n-\t}\n-      else\n-\t{\n-\t  hash_table_init (&t, hash_newfunc, java_hash_hash_tree_node,\n-\t\t\t   java_hash_compare_tree_node);\n-\t  searched_interfaces = &t;\n-\t}\n-\n-      hash_lookup (searched_interfaces, \n-\t\t   (const hash_table_key) class, TRUE, NULL);\n-\n       search_applicable_methods_list (lc, TYPE_METHODS (class), \n \t\t\t\t      name, arglist, &list, &all_list);\n       n = TREE_VEC_LENGTH (basetype_vec);\n@@ -10146,23 +10144,9 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t  tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n \t  tree rlist;\n \n-\t  search_not_done++;\n \t  rlist = find_applicable_accessible_methods_list (lc,  t, name, \n \t\t\t\t\t\t\t   arglist);\n \t  list = chainon (rlist, list);\n-\t  search_not_done--;\n-\t}\n-\n-      /* We're done. Reset the searched interfaces list and finally search\n-         java.lang.Object */\n-      if (!search_not_done)\n-\t{  \n-\t  if (!object_done)\n-\t    search_applicable_methods_list (lc, \n-\t\t\t\t\t    TYPE_METHODS (object_type_node),\n-\t\t\t\t\t    name, arglist, &list, &all_list);\n-\t  hash_table_free (searched_interfaces);\n-\t  searched_interfaces = NULL;  \n \t}\n     }\n   /* Search classes */\n@@ -10178,7 +10162,6 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       {\n \ttree basetype_vec = TYPE_BINFO_BASETYPES (sc);\n \tint n = TREE_VEC_LENGTH (basetype_vec), i;\n-\tobject_done = 1;\n \tfor (i = 1; i < n; i++)\n \t  {\n \t    tree t = BINFO_TYPE (TREE_VEC_ELT (basetype_vec, i));\n@@ -10190,7 +10173,6 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t\tlist = chainon (rlist, list);\n \t      }\n \t  }\n-\tobject_done = 0;\n       }\n \n       /* Search enclosing context of inner classes before looking\n@@ -10211,18 +10193,43 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n       else\n \tclass = sc;\n \n-      for (class = (lc ? NULL_TREE : CLASSTYPE_SUPER (class)); \n-        class; class = CLASSTYPE_SUPER (class))\n-       search_applicable_methods_list (lc, TYPE_METHODS (class), \n-                                       name, arglist, &list, &all_list);\n+      /* Search superclass */\n+      if (!lc && CLASSTYPE_SUPER (class) != NULL_TREE)\n+\t{\n+          tree rlist;\n+          class = CLASSTYPE_SUPER (class);\n+          rlist = find_applicable_accessible_methods_list (lc, class, \n+                                                           name, arglist);\n+          list = chainon (rlist, list);\n+        }\n+    }\n+\n+  search_not_done--;\n+\n+  /* We're done. Reset the searched classes list and finally search\n+     java.lang.Object if it wasn't searched already. */\n+  if (!search_not_done)\n+    {\n+      if (!lc\n+\t  && TYPE_METHODS (object_type_node)\n+\t  && !hash_lookup (searched_classes, \n+                           (const hash_table_key) object_type_node, \n+                           FALSE, NULL))\n+\t{\n+          search_applicable_methods_list (lc, \n+                                          TYPE_METHODS (object_type_node),\n+                                          name, arglist, &list, &all_list);\n+        }\n+      hash_table_free (searched_classes);\n+      searched_classes = NULL;\n     }\n \n   /* Either return the list obtained or all selected (but\n      inaccessible) methods for better error report. */\n   return (!list ? all_list : list);\n }\n \n-/* Effectively search for the approriate method in method */\n+/* Effectively search for the appropriate method in method */\n \n static void \n search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n@@ -10251,7 +10258,7 @@ search_applicable_methods_list (lc, method, name, arglist, list, all_list)\n \t    *all_list = tree_cons (NULL_TREE, method, *list);\n \t}\n     }\n-}    \n+}\n \n /* 15.11.2.2 Choose the Most Specific Method */\n "}]}