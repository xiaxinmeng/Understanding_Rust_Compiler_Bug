{"sha": "ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE3MWEyYTYyYzYzZjc3ZjRhMjFjNDYwNzM4ZGM4Nzk1YjBmNmVhYw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-07-09T19:09:33Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-07-09T19:09:33Z"}, "message": "eoshift2.c (eoshift2): Use memcpy for innermost copy where possible.\n\n2017-06-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* intrinsics/eoshift2.c (eoshift2):  Use memcpy\n\tfor innermost copy where possible.\n\t* m4/eoshift1.m4 (eoshift1): Likewise.\n\t* m4/eoshift3.m4 (eoshift3): Likewise.\n\t* generated/eoshift1_16.c: Regenerated.\n\t* generated/eoshift1_4.c: Regenerated.\n\t* generated/eoshift1_8.c: Regenerated.\n\t* generated/eoshift3_16.c: Regenerated.\n\t* generated/eoshift3_4.c: Regenerated.\n\t* generated/eoshift3_8.c: Regenerated.\n\n2017-06-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/eoshift_4.f90:  New test.\n\t* gfortran.dg/eoshift_5.f90:  New test.\n\t* gfortran.dg/eoshift_6.f90:  New test.\n\nFrom-SVN: r250085", "tree": {"sha": "2caab511caafff148913ed01787320db240010f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2caab511caafff148913ed01787320db240010f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/comments", "author": null, "committer": null, "parents": [{"sha": "35c95658180e67503f9de96567ab4d6e71b10a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c95658180e67503f9de96567ab4d6e71b10a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c95658180e67503f9de96567ab4d6e71b10a6e"}], "stats": {"total": 780, "additions": 726, "deletions": 54}, "files": [{"sha": "19c9b0ae432b7ead410558f9b19303dbe498fe94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -1,3 +1,9 @@\n+2017-06-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/eoshift_4.f90:  New test.\n+\t* gfortran.dg/eoshift_5.f90:  New test.\n+\t* gfortran.dg/eoshift_6.f90:  New test.\n+\n 2017-07-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/81313"}, {"sha": "6d1a28a84790baf8fc5876deabca8e8c7d0cabee", "filename": "gcc/testsuite/gfortran.dg/eoshift_4.f90", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_4.f90?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -0,0 +1,187 @@\n+! { dg-do  run }\n+! Check that eoshift works for three-dimensional arrays.\n+module x\n+  implicit none\n+contains\n+  subroutine eoshift_2 (array, shift, boundary, dim, res)\n+    real, dimension(:,:,:), intent(in) :: array\n+    real, dimension(:,:,:), intent(out) :: res\n+    integer, value :: shift\n+    real, optional, dimension(:,:), intent(in) :: boundary\n+    integer, optional, intent(in) :: dim\n+    integer :: s1, s2, s3\n+    integer :: n1, n2, n3\n+\n+    real :: b\n+    integer :: d\n+\n+    if (present(dim)) then\n+       d = dim\n+    else\n+       d = 1\n+    end if\n+\n+    n1 = size(array,1)\n+    n2 = size(array,2)\n+    n3 = size(array,3)\n+\n+    select case(dim)\n+    case(1)\n+       if (shift > 0) then\n+          shift = min(shift, n1)\n+          do s3=1,n3\n+             do s2=1,n2\n+                b = boundary(s2,s3)\n+                do s1= 1, n1 - shift\n+                   res(s1,s2,s3) = array(s1+shift,s2,s3)\n+                end do\n+                do s1 = n1 - shift + 1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+\n+       else\n+          shift = max(shift, -n1)\n+          do s3=1,n3\n+             do s2=1,n2\n+                b = boundary(s2,s3)\n+                do s1=1,-shift\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s1= 1-shift,n1\n+                   res(s1,s2,s3) = array(s1+shift,s2,s3)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case(2)\n+       if (shift > 0) then\n+          shift = min(shift, n2)\n+          do s3=1,n3\n+             do s2=1, n2 - shift\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2+shift,s3)\n+                end do\n+             end do\n+             do s2=n2 - shift + 1, n2\n+                do s1=1,n1\n+                   b = boundary(s1,s3)\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+       else\n+          shift = max(shift, -n2)\n+          do s3=1,n3\n+             do s2=1,-shift\n+                do s1=1,n1\n+                   b = boundary(s1,s3)\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+             do s2=1-shift,n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2+shift,s3)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case(3)\n+       if (shift > 0) then\n+          shift = min(shift, n3)\n+          do s3=1,n3 - shift\n+             do s2=1, n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2,s3+shift)\n+                end do\n+             end do\n+          end do\n+          do s3=n3 - shift + 1, n3\n+             do s2=1, n2\n+                do s1=1,n1\n+                   b = boundary(s1,s2)\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+       else\n+          shift = max(shift, -n3)\n+          do s3=1,-shift\n+             do s2=1,n2\n+                do s1=1,n1\n+                   b = boundary(s1,s2)\n+                   res(s1,s2,s3) = b\n+                end do\n+             end do\n+          end do\n+          do s3=1-shift,n3\n+             do s2=1,n2\n+                do s1=1,n1\n+                   res(s1,s2,s3) = array(s1,s2,s3+shift)\n+                end do\n+             end do\n+          end do\n+       end if\n+\n+    case default\n+       stop \"Illegal dim\"\n+    end select\n+  end subroutine eoshift_2\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, parameter :: n1=20,n2=30,n3=40\n+  real, dimension(n1,n2,n3) :: a,b,c\n+  real, dimension(2*n1,n2,n3) :: a2,c2\n+  integer :: dim, shift, shift_lim\n+  real, dimension(n2,n3), target :: b1\n+  real, dimension(n1,n3), target :: b2\n+  real, dimension(n1,n2), target :: b3\n+  real, dimension(:,:), pointer :: bp\n+\n+  call random_number(a)\n+  call random_number (b1)\n+  call random_number (b2)\n+  call random_number (b3)\n+  do dim=1,3\n+     if (dim == 1) then\n+        shift_lim = n1 + 1\n+        bp => b1\n+     else if (dim == 2) then\n+        shift_lim = n2 + 1\n+        bp => b2\n+     else\n+        shift_lim = n3 + 1\n+        bp => b3\n+     end if\n+     do shift=-shift_lim, shift_lim\n+        b = eoshift(a,shift,dim=dim, boundary=bp)\n+        call eoshift_2 (a, shift=shift, dim=dim, boundary=bp, res=c)\n+        if (any (b /= c)) then\n+           print *,\"dim = \", dim, \"shift = \", shift\n+           print *,b\n+           print *,c\n+           call abort\n+        end if\n+        a2 = 42.\n+        a2(1:2*n1:2,:,:) = a\n+        b = eoshift(a2(1:2*n1:2,:,:), shift, dim=dim, boundary=bp)\n+        if (any (b /= c)) then\n+           call abort\n+        end if\n+        c2 = 43.\n+        c2(1:2*n1:2,:,:) = eoshift(a,shift,dim=dim, boundary=bp)\n+        if (any(c2(1:2*n1:2,:,:) /= c)) then\n+           call abort\n+        end if\n+        if (any(c2(2:2*n1:2,:,:) /= 43)) then\n+           call abort\n+        end if\n+     end do\n+  end do\n+end program main"}, {"sha": "a8c2494ad760dd8ac7bcab2339f2cd2e9979ae17", "filename": "gcc/testsuite/gfortran.dg/eoshift_5.f90", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_5.f90?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -0,0 +1,182 @@\n+! { dg-do  run }\n+! Check that eoshift works for three-dimensional arrays.\n+module x\n+  implicit none\n+contains\n+  subroutine eoshift_1 (array, shift, boundary, dim, res)\n+    real, dimension(:,:,:), intent(in) :: array\n+    real, dimension(:,:,:), intent(out) :: res\n+    integer, dimension(:,:), intent(in) :: shift\n+    real, optional, intent(in) :: boundary\n+    integer, optional, intent(in) :: dim\n+    integer :: s1, s2, s3\n+    integer :: n1, n2, n3\n+    integer :: sh\n+    real :: b\n+    integer :: d\n+\n+    if (present(boundary)) then\n+       b = boundary\n+    else\n+       b = 0.0\n+    end if\n+\n+    if (present(dim)) then\n+       d = dim\n+    else\n+       d = 1\n+    end if\n+\n+    n1 = size(array,1)\n+    n2 = size(array,2)\n+    n3 = size(array,3)\n+\n+    select case(dim)\n+    case(1)\n+       do s3=1,n3\n+          do s2=1,n2\n+             sh = shift(s2,s3)\n+             if (sh > 0) then\n+                sh = min(sh, n1)\n+                do s1= 1, n1 - sh\n+                   res(s1,s2,s3) = array(s1+sh,s2,s3)\n+                end do\n+                do s1 = n1 - sh + 1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n1)\n+                do s1=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s1= 1-sh,n1\n+                   res(s1,s2,s3) = array(s1+sh,s2,s3)\n+                end do\n+             end if\n+          end do\n+       end do\n+    case(2)\n+       do s3=1,n3\n+          do s1=1,n1\n+             sh = shift(s1,s3)\n+             if (sh > 0) then\n+                sh = min (sh, n2)\n+                do s2=1, n2 - sh\n+                   res(s1,s2,s3) = array(s1,s2+sh,s3)\n+                end do\n+                do s2=n2 - sh + 1, n2\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n2)\n+                do s2=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s2=1-sh,n2\n+                   res(s1,s2,s3) = array(s1,s2+sh,s3)\n+                end do\n+             end if\n+          end do\n+       end do\n+\n+    case(3)\n+       do s2=1, n2\n+          do s1=1,n1\n+             sh = shift(s1, s2)\n+             if (sh > 0) then\n+                sh = min(sh, n3)\n+                do s3=1,n3 - sh\n+                   res(s1,s2,s3) = array(s1,s2,s3+sh)\n+                end do\n+                do s3=n3 - sh + 1, n3\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n3)\n+                do s3=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s3=1-sh,n3\n+                   res(s1,s2,s3) = array(s1,s2,s3+sh)\n+                end do\n+             end if\n+          end do\n+       end do\n+       \n+    case default\n+       stop \"Illegal dim\"\n+    end select\n+  end subroutine eoshift_1\n+  subroutine fill_shift(x, n)\n+    integer, intent(out), dimension(:,:) :: x\n+    integer, intent(in) :: n\n+    integer :: n1, n2, s1, s2\n+    integer :: v\n+    v = -n - 1\n+    n1 = size(x,1)\n+    n2 = size(x,2)\n+    do s2=1,n2\n+       do s1=1,n1\n+          x(s1,s2) = v\n+          v = v + 1\n+          if (v > n + 1) v = -n - 1\n+       end do\n+    end do\n+  end subroutine fill_shift\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, parameter :: n1=20,n2=30,n3=40\n+  real, dimension(n1,n2,n3) :: a,b,c\n+  real, dimension(2*n1,n2,n3) :: a2, c2\n+  integer :: dim\n+  integer, dimension(n2,n3), target :: sh1\n+  integer, dimension(n1,n3), target :: sh2\n+  integer, dimension(n1,n2), target :: sh3\n+  real, dimension(n2,n3), target :: b1\n+  real, dimension(n1,n3), target :: b2\n+  real, dimension(n1,n2), target :: b3\n+\n+  integer, dimension(:,:), pointer :: sp\n+  real, dimension(:,:), pointer :: bp\n+\n+  call random_number(a)\n+  call fill_shift(sh1, n1)\n+  call fill_shift(sh2, n2)\n+  call fill_shift(sh3, n3)\n+\n+  do dim=1,3\n+     if (dim == 1) then\n+        sp => sh1\n+     else if (dim == 2) then\n+        sp => sh2\n+     else\n+        sp => sh3\n+     end if\n+     b = eoshift(a,shift=sp,dim=dim,boundary=-0.5)\n+     call eoshift_1 (a, shift=sp, dim=dim, boundary=-0.5,res=c)\n+     if (any (b /= c)) then\n+        print *,\"dim = \", dim\n+        print *,\"sp = \", sp\n+        print '(99F8.4)',b\n+        print '(99F8.4)',c\n+        call abort\n+     end if\n+     a2 = 42.\n+     a2(1:2*n1:2,:,:) = a\n+     b = eoshift(a2(1:2*n1:2,:,:), shift=sp, dim=dim, boundary=-0.5)\n+     if (any(b /= c)) then\n+        call abort\n+     end if\n+     c2 = 43.\n+     c2(1:2*n1:2,:,:) = eoshift(a, shift=sp, dim=dim, boundary=-0.5)\n+     if (any(c2(1:2*n1:2,:,:) /= c)) then\n+        call abort\n+     end if\n+     if (any(c2(2:2*n1:2,:,:) /= 43.)) then\n+        call abort\n+     end if\n+  end do\n+end program main"}, {"sha": "f3f833cc9417358b6750f920ae2e2db551b86b2c", "filename": "gcc/testsuite/gfortran.dg/eoshift_6.f90", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feoshift_6.f90?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -0,0 +1,181 @@\n+! { dg-do  run }\n+! Check that eoshift works for three-dimensional arrays.\n+module x\n+  implicit none\n+contains\n+  subroutine eoshift_3 (array, shift, boundary, dim, res)\n+    real, dimension(:,:,:), intent(in) :: array\n+    real, dimension(:,:,:), intent(out) :: res\n+    integer, dimension(:,:), intent(in) :: shift\n+    real, optional, dimension(:,:), intent(in) :: boundary\n+    integer, optional, intent(in) :: dim\n+    integer :: s1, s2, s3\n+    integer :: n1, n2, n3\n+    integer :: sh\n+    real :: b\n+    integer :: d\n+\n+    if (present(dim)) then\n+       d = dim\n+    else\n+       d = 1\n+    end if\n+\n+    n1 = size(array,1)\n+    n2 = size(array,2)\n+    n3 = size(array,3)\n+\n+    select case(dim)\n+    case(1)\n+       do s3=1,n3\n+          do s2=1,n2\n+             sh = shift(s2,s3)\n+             b = boundary(s2,s3)\n+             if (sh > 0) then\n+                sh = min(sh, n1)\n+                do s1= 1, n1 - sh\n+                   res(s1,s2,s3) = array(s1+sh,s2,s3)\n+                end do\n+                do s1 = n1 - sh + 1,n1\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n1)\n+                do s1=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s1= 1-sh,n1\n+                   res(s1,s2,s3) = array(s1+sh,s2,s3)\n+                end do\n+             end if\n+          end do\n+       end do\n+    case(2)\n+       do s3=1,n3\n+          do s1=1,n1\n+             sh = shift(s1,s3)\n+             b = boundary(s1,s3)\n+             if (sh > 0) then\n+                sh = min (sh, n2)\n+                do s2=1, n2 - sh\n+                   res(s1,s2,s3) = array(s1,s2+sh,s3)\n+                end do\n+                do s2=n2 - sh + 1, n2\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n2)\n+                do s2=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s2=1-sh,n2\n+                   res(s1,s2,s3) = array(s1,s2+sh,s3)\n+                end do\n+             end if\n+          end do\n+       end do\n+\n+    case(3)\n+       do s2=1, n2\n+          do s1=1,n1\n+             sh = shift(s1, s2)\n+             b = boundary(s1, s2)\n+             if (sh > 0) then\n+                sh = min(sh, n3)\n+                do s3=1,n3 - sh\n+                   res(s1,s2,s3) = array(s1,s2,s3+sh)\n+                end do\n+                do s3=n3 - sh + 1, n3\n+                   res(s1,s2,s3) = b\n+                end do\n+             else\n+                sh = max(sh, -n3)\n+                do s3=1,-sh\n+                   res(s1,s2,s3) = b\n+                end do\n+                do s3=1-sh,n3\n+                   res(s1,s2,s3) = array(s1,s2,s3+sh)\n+                end do\n+             end if\n+          end do\n+       end do\n+       \n+    case default\n+       stop \"Illegal dim\"\n+    end select\n+  end subroutine eoshift_3\n+  subroutine fill_shift(x, n)\n+    integer, intent(out), dimension(:,:) :: x\n+    integer, intent(in) :: n\n+    integer :: n1, n2, s1, s2\n+    integer :: v\n+    v = -n - 1\n+    n1 = size(x,1)\n+    n2 = size(x,2)\n+    do s2=1,n2\n+       do s1=1,n1\n+          x(s1,s2) = v\n+          v = v + 1\n+          if (v > n + 1) v = -n - 1\n+       end do\n+    end do\n+  end subroutine fill_shift\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer, parameter :: n1=10,n2=30,n3=40\n+  real, dimension(n1,n2,n3) :: a,b,c\n+  real, dimension(2*n1,n2,n3) :: a2, c2\n+  integer :: dim\n+  integer, dimension(n2,n3), target :: sh1\n+  integer, dimension(n1,n3), target :: sh2\n+  integer, dimension(n1,n2), target :: sh3\n+  real, dimension(n2,n3), target :: b1\n+  real, dimension(n1,n3), target :: b2\n+  real, dimension(n1,n2), target :: b3\n+\n+  integer, dimension(:,:), pointer :: sp\n+  real, dimension(:,:), pointer :: bp\n+\n+  call random_number(a)\n+  call random_number(b1)\n+  call random_number(b2)\n+  call random_number(b3)\n+  call fill_shift(sh1, n1)\n+  call fill_shift(sh2, n2)\n+  call fill_shift(sh3, n3)\n+\n+  do dim=1,3\n+     if (dim == 1) then\n+        sp => sh1\n+        bp => b1\n+     else if (dim == 2) then\n+        sp => sh2\n+        bp => b2\n+     else\n+        sp => sh3\n+        bp => b3\n+     end if\n+     b = eoshift(a,shift=sp,dim=dim,boundary=bp)\n+     call eoshift_3 (a, shift=sp, dim=dim, boundary=bp,res=c)\n+     if (any (b /= c)) then\n+        call abort\n+     end if\n+     a2 = 42.\n+     a2(1:2*n1:2,:,:) = a\n+     b = eoshift(a2(1:2*n1:2,:,:), shift=sp, dim=dim, boundary=bp)\n+     if (any(b /= c)) then\n+        call abort\n+     end if\n+     c2 = 43.\n+     c2(1:2*n1:2,:,:) = eoshift(a, shift=sp, dim=dim, boundary=bp)\n+     if (any(c2(1:2*n1:2,:,:) /= c)) then\n+        call abort\n+     end if\n+     if (any(c2(2:2*n1:2,:,:) /= 43.)) then\n+        call abort\n+     end if\n+  end do\n+end program main"}, {"sha": "f34b4df785a3b09c672c238554022a4b1099138d", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -1,3 +1,16 @@\n+2017-06-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* intrinsics/eoshift2.c (eoshift2):  Use memcpy\n+\tfor innermost copy where possible.\n+\t* m4/eoshift1.m4 (eoshift1): Likewise.\n+\t* m4/eoshift3.m4 (eoshift3): Likewise.\n+\t* generated/eoshift1_16.c: Regenerated.\n+\t* generated/eoshift1_4.c: Regenerated.\n+\t* generated/eoshift1_8.c: Regenerated.\n+\t* generated/eoshift3_16.c: Regenerated.\n+\t* generated/eoshift3_4.c: Regenerated.\n+\t* generated/eoshift3_8.c: Regenerated.\n+\n 2017-07-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* intrinsics/eoshift0.c:  For contiguous arrays, use"}, {"sha": "fe2e8ef66ac8c1ac4cf1cd80114b17a9c4bc9fd0", "filename": "libgfortran/generated/eoshift1_16.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_16.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -183,12 +183,23 @@ eoshift1 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "a90fc2176dead680c4b7a614736bafd602763ea2", "filename": "libgfortran/generated/eoshift1_4.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_4.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -183,12 +183,23 @@ eoshift1 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "8be1e050e3dde5401e3f1ec8a91628df401d270d", "filename": "libgfortran/generated/eoshift1_8.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift1_8.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -183,12 +183,23 @@ eoshift1 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "621fd6f0dc886b124c6deda221a12a30d2b0c844", "filename": "libgfortran/generated/eoshift3_16.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_16.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -198,12 +198,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "ac4fd67f3c7f3b35124cefe7427a0181f8fa278b", "filename": "libgfortran/generated/eoshift3_4.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_4.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -198,12 +198,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "7e9d8b48475b439f96068cc7c752c2ee33c3379d", "filename": "libgfortran/generated/eoshift3_8.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fgenerated%2Feoshift3_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Feoshift3_8.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -198,12 +198,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "5d949dda8bbe1b332ffb5cb5bfb79024c990ba23", "filename": "libgfortran/intrinsics/eoshift2.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fintrinsics%2Feoshift2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fintrinsics%2Feoshift2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Feoshift2.c?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -181,12 +181,23 @@ eoshift2 (gfc_array_char *ret, const gfc_array_char *array,\n           src = sptr;\n           dest = &rptr[-shift * roffset];\n         }\n-      for (n = 0; n < len; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * len;\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (shift >= 0)\n         {\n           n = shift;"}, {"sha": "69504601b3536afad877027ad37e5721794db7d2", "filename": "libgfortran/m4/eoshift1.m4", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fm4%2Feoshift1.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fm4%2Feoshift1.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Feoshift1.m4?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -184,12 +184,23 @@ eoshift1 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}, {"sha": "9e7f78755b18f21b300adbd955a9201165ea6b56", "filename": "libgfortran/m4/eoshift3.m4", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fm4%2Feoshift3.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba71a2a62c63f77f4a21c460738dc8795b0f6eac/libgfortran%2Fm4%2Feoshift3.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Feoshift3.m4?ref=ba71a2a62c63f77f4a21c460738dc8795b0f6eac", "patch": "@@ -199,12 +199,24 @@ eoshift3 (gfc_array_char * const restrict ret,\n           src = sptr;\n           dest = &rptr[delta * roffset];\n         }\n-      for (n = 0; n < len - delta; n++)\n-        {\n-          memcpy (dest, src, size);\n-          dest += roffset;\n-          src += soffset;\n-        }\n+\n+      /* If the elements are contiguous, perform a single block move.  */\n+      if (soffset == size && roffset == size)\n+\t{\n+\t  size_t chunk = size * (len - delta);\n+\t  memcpy (dest, src, chunk);\n+\t  dest += chunk;\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < len - delta; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n       if (sh < 0)\n         dest = rptr;\n       n = delta;"}]}