{"sha": "bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "node_id": "C_kwDOANBUbNoAKGJiOGU5M2ViMWFjYWUzMGE1ZmJlN2UxMzE0OTQ5M2NlNGNjZDMwMWE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-24T17:44:48Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-24T17:44:48Z"}, "message": "analyzer: consolidate call_string instances\n\nana::call_string is a wrapper around an auto_vec of callsites, leading\nto non-trivial copying when copying around call_string instances, e.g.\nin ana::program_point.\n\nThis patch consolidates call_string instances within the\nregion_model_manager: it now owns the root/empty call_string, and\neach call_string instance tracks its children, lazily creating them on\ndemand, so that the call_string instances form a tree-like hierarchy in\nmemory.  Doing this requires passing the region_model_manager to the\nvarious program_point factory methods, so that they can get at the root\ncall_string.\n\nInstances of call_string become immutable (apart from their internal\ncache for looking up their children); operations that previously\nmodified them now return the call_string for the result of the\noperation.\n\nI wasn't able to observe any performance impact of this, but it\nsimplifies call_string and program_point management, and thus I hope\nwill make it easier to improve call summarization.  In particular,\nregion_model_manager::log_stats will now print a hierarchical dump of\nall the call_string instances used in the analysis (in -fdump-analyzer\nand -fdump-analyzer-stderr).\n\ngcc/analyzer/ChangeLog:\n\t* call-string.cc: Add includes of \"analyzer/analyzer.h\"\n\tand \"analyzer/analyzer-logging.h\".\n\t(call_string::call_string): Delete copy ctor.\n\t(call_string::operator=): Delete.\n\t(call_string::operator==): Delete.\n\t(call_string::hash): Delete.\n\t(call_string::push_call): Make const, returning the resulting\n\tcall_string.\n\t(call_string::pop): Delete.\n\t(call_string::cmp_ptr_ptr): New.\n\t(call_string::validate): Assert that m_parent is non-NULL, or\n\tm_elements is empty.\n\t(call_string::call_string): Move default ctor here from\n\tcall-string.h and reimplement.  Add ctor taking a parent\n\tand an element.\n\t(call_string::~call_string): New.\n\t(call_string::recursive_log): New.\n\t* call-string.h (call_string::call_string): Move default ctor's\n\tdefn to call-string.cc.  Delete copy ctor.  Add ctor taking a\n\tparent and an element.\n\t(call_string::operator=): Delete.\n\t(call_string::operator==): Delete.\n\t(call_string::hash): Delete.\n\t(call_string::push_call): Make const, returning the resulting\n\tcall_string.\n\t(call_string::pop): Delete decl.\n\t(call_string::get_parent): New.\n\t(call_string::cmp_ptr_ptr): New decl.\n\t(call_string::get_top_of_stack): New.\n\t(struct call_string::hashmap_traits_t): New.\n\t(class call_string): Add friend class region_model_manager.  Add\n\tDISABLE_COPY_AND_ASSIGN.\n\t(call_string::~call_string): New decl.\n\t(call_string::recursive_log): New decl.\n\t(call_string::m_parent): New field.\n\t(call_string::m_children): New field.\n\t* constraint-manager.cc (selftest::test_many_constants): Pass\n\tmodel manager to program_point::origin.\n\t* engine.cc (exploded_graph::exploded_graph): Likewise.\n\t(exploded_graph::add_function_entry): Likewise for\n\tprogram_point::from_function_entry.\n\t(add_tainted_args_callback): Likewise.\n\t(exploded_graph::maybe_process_run_of_before_supernode_enodes):\n\tUpdate for change to program_point.get_call_string.\n\t(exploded_graph::process_node): Likewise.\n\t(class function_call_string_cluster): Convert m_cs from a\n\tcall_string to a const call_string &.\n\t(struct function_call_string): Likewise.\n\t(pod_hash_traits<function_call_string>::hash): Use pointer_hash\n\tfor m_cs.\n\t(pod_hash_traits<function_call_string>::equal): Update for change\n\tto m_cs.\n\t(root_cluster::add_node): Update for change to\n\tfunction_call_string.\n\t(viz_callgraph_node::dump_dot): Update for change to call_string.\n\t* exploded-graph.h (per_call_string_data::m_key): Convert to a\n\treference.\n\t(struct eg_call_string_hash_map_traits): Delete.\n\t(exploded_graph::call_string_data_map_t): Remove traits class.\n\t* program-point.cc: Move include of \"analyzer/call-string.h\" to\n\tafter \"analyzer/analyzer-logging.h\".\n\t(program_point::print): Update for conversion of m_call_string to\n\ta pointer.\n\t(program_point::to_json): Likewise.\n\t(program_point::push_to_call_stack): Update for immutability of\n\tcall strings.\n\t(program_point::pop_from_call_stack): Likewise.\n\t(program_point::hash): Use pointer hashing for m_call_string.\n\t(program_point::get_function_at_depth): Update for change to\n\tm_call_string.\n\t(program_point::validate): Update for changes to call_string.\n\t(program_point::on_edge): Likewise.\n\t(program_point::origin): Move here from call-string.h.  Add\n\tregion_model_manager param and use it to get empty call string.\n\t(program_point::from_function_entry): Likewise.\n\t(selftest::test_function_point_ordering): Likewise.\n\t(selftest::test_function_point_ordering): Likewise.\n\t* program-point.h (program_point::program_point): Update for\n\tchange to m_call_string.\n\t(program_point::get_call_string): Likewise.\n\t(program_point::get_stack_depth): Likewise.\n\t(program_point::origin): Add region_model_manager param, and move\n\tdefn to call-string.cc.\n\t(program_point::from_function_entry): Likewise.\n\t(program_point::empty): Drop call_string.\n\t(program_point::deleted): Likewise.\n\t(program_point::program_point): New private ctor.\n\t(program_point::m_call_string): Convert from call_string to const\n\tcall_string *.\n\t* program-state.cc (selftest::test_program_state_merging): Update\n\tfor call_string changes.\n\t(selftest::test_program_state_merging_2): Likewise.\n\t* region-model-manager.cc\n\t(region_model_manager::region_model_manager): Construct\n\tm_empty_call_string.\n\t(region_model_manager::log_stats): Log the call strings.\n\t* region-model.cc (assert_region_models_merge): Pass the\n\tregion_model_manager when creating program_point instances.\n\t(selftest::test_state_merging): Likewise.\n\t(selftest::test_constraint_merging): Likewise.\n\t(selftest::test_widening_constraints): Likewise.\n\t(selftest::test_iteration_1): Likewise.\n\t* region-model.h (region_model_manager::get_empty_call_string):\n\tNew.\n\t(region_model_manager::m_empty_call_string): New.\n\t* sm-signal.cc (register_signal_handler::impl_transition): Update\n\tfor changes to call_string.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "85dff9a3f4aed9dc9fd2c6c4a2bf477760cfaa5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85dff9a3f4aed9dc9fd2c6c4a2bf477760cfaa5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3752e21d8c180b197e33006b048eff812adfb4e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3752e21d8c180b197e33006b048eff812adfb4e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3752e21d8c180b197e33006b048eff812adfb4e1"}], "stats": {"total": 496, "additions": 282, "deletions": 214}, "files": [{"sha": "a09f569d9d1f9b748eb892efd5072bd8f06c631a", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 95, "deletions": 65, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -25,7 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"options.h\"\n #include \"json.h\"\n-#include \"analyzer/call-string.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n@@ -35,6 +34,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"gimple-iterator.h\"\n #include \"digraph.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/call-string.h\"\n #include \"analyzer/supergraph.h\"\n \n #if ENABLE_ANALYZER\n@@ -74,45 +76,6 @@ call_string::element_t::get_callee_function () const\n   return m_callee->get_function ();\n }\n \n-/* call_string's copy ctor.  */\n-\n-call_string::call_string (const call_string &other)\n-: m_elements (other.m_elements.length ())\n-{\n-  for (const call_string::element_t &e : other.m_elements)\n-    m_elements.quick_push (e);\n-}\n-\n-/* call_string's assignment operator.  */\n-\n-call_string&\n-call_string::operator= (const call_string &other)\n-{\n-  // would be much simpler if we could rely on vec<> assignment op\n-  m_elements.truncate (0);\n-  m_elements.reserve (other.m_elements.length (), true);\n-  call_string::element_t *e;\n-  int i;\n-  FOR_EACH_VEC_ELT (other.m_elements, i, e)\n-    m_elements.quick_push (*e);\n-  return *this;\n-}\n-\n-/* call_string's equality operator.  */\n-\n-bool\n-call_string::operator== (const call_string &other) const\n-{\n-  if (m_elements.length () != other.m_elements.length ())\n-    return false;\n-  call_string::element_t *e;\n-  int i;\n-  FOR_EACH_VEC_ELT (m_elements, i, e)\n-    if (*e != other.m_elements[i])\n-      return false;\n-  return true;\n-}\n-\n /* Print this to PP.  */\n \n void\n@@ -160,43 +123,34 @@ call_string::to_json () const\n   return arr;\n }\n \n-/* Generate a hash value for this call_string.  */\n+/* Get or create the call_string resulting from pushing the return\n+   superedge for CALL_SEDGE onto the end of this call_string.  */\n \n-hashval_t\n-call_string::hash () const\n-{\n-  inchash::hash hstate;\n-  for (const call_string::element_t &e : m_elements)\n-    hstate.add_ptr (e.m_caller);\n-  return hstate.end ();\n-}\n-\n-/* Push the return superedge for CALL_SEDGE onto the end of this\n-   call_string.  */\n-\n-void\n+const call_string *\n call_string::push_call (const supergraph &sg,\n-\t\t\tconst call_superedge *call_sedge)\n+\t\t\tconst call_superedge *call_sedge) const\n {\n   gcc_assert (call_sedge);\n   const return_superedge *return_sedge = call_sedge->get_edge_for_return (sg);\n   gcc_assert (return_sedge);\n-  call_string::element_t e (return_sedge->m_dest, return_sedge->m_src);\n-  m_elements.safe_push (e);\n+  return push_call (return_sedge->m_dest, return_sedge->m_src);\n }\n \n-void\n+/* Get or create the call_string resulting from pushing the call\n+   (caller, callee) onto the end of this call_string.  */\n+\n+const call_string *\n call_string::push_call (const supernode *caller,\n-\t\t\tconst supernode *callee)\n+\t\t\tconst supernode *callee) const\n {\n   call_string::element_t e (caller, callee);\n-  m_elements.safe_push (e);\n-}\n \n-call_string::element_t\n-call_string::pop ()\n-{\n-  return m_elements.pop();\n+  if (const call_string **slot = m_children.get (e))\n+    return *slot;\n+\n+  call_string *result = new call_string (*this, e);\n+  m_children.put (e, result);\n+  return result;\n }\n \n /* Count the number of times the top-most call site appears in the\n@@ -260,6 +214,16 @@ call_string::cmp (const call_string &a,\n     }\n }\n \n+/* Comparator for use by vec<const call_string *>::qsort.  */\n+\n+int\n+call_string::cmp_ptr_ptr (const void *pa, const void *pb)\n+{\n+  const call_string *cs_a = *static_cast <const call_string * const *> (pa);\n+  const call_string *cs_b = *static_cast <const call_string * const *> (pb);\n+  return cmp (*cs_a, *cs_b);\n+}\n+\n /* Return the pointer to callee of the topmost call in the stack,\n    or NULL if stack is empty.  */\n const supernode *\n@@ -290,6 +254,8 @@ call_string::validate () const\n   return;\n #endif\n \n+  gcc_assert (m_parent || m_elements.length () == 0);\n+\n   /* Each entry's \"caller\" should be the \"callee\" of the previous entry.  */\n   call_string::element_t *e;\n   int i;\n@@ -299,4 +265,68 @@ call_string::validate () const\n \t\t  m_elements[i - 1].get_callee_function ());\n }\n \n+/* ctor for the root/empty call_string.  */\n+\n+call_string::call_string ()\n+: m_parent (NULL), m_elements ()\n+{\n+}\n+\n+/* ctor for a child call_string.  */\n+\n+call_string::call_string (const call_string &parent, const element_t &to_push)\n+: m_parent (&parent),\n+  m_elements (parent.m_elements.length () + 1)\n+{\n+  m_elements.splice (parent.m_elements);\n+  m_elements.quick_push (to_push);\n+}\n+\n+/* dtor for call_string: recursively delete children.  */\n+\n+call_string::~call_string ()\n+{\n+  for (auto child_iter : m_children)\n+    delete child_iter.second;\n+}\n+\n+/* Log this call_string and all its descendents recursively to LOGGER,\n+   using indentation and elision to highlight the hierarchy.  */\n+\n+void\n+call_string::recursive_log (logger *logger) const\n+{\n+  logger->start_log_line ();\n+  pretty_printer *pp = logger->get_printer ();\n+  for (unsigned i = 0; i < length (); i++)\n+    pp_string (pp, \"  \");\n+  if (length () > 0)\n+    {\n+      pp_string (pp, \"[\");\n+      /* Elide all but the final element, since they are shared with\n+\t the parent call_string.  */\n+      for (unsigned i = 0; i < length (); i++)\n+\tpp_string (pp, \"..., \");\n+      /* Log the final element in detail.  */\n+      const element_t *e = &m_elements[m_elements.length () - 1];\n+      pp_printf (pp, \"(SN: %i -> SN: %i in %s)]\",\n+\t\t e->m_callee->m_index, e->m_caller->m_index,\n+\t\t function_name (e->m_caller->m_fun));\n+    }\n+  else\n+    pp_string (pp, \"[]\");\n+  logger->end_log_line ();\n+\n+  /* Recurse into children.  */\n+  {\n+    auto_vec<const call_string *> children (m_children.elements ());\n+    for (auto iter : m_children)\n+      children.safe_push (iter.second);\n+    children.qsort (call_string::cmp_ptr_ptr);\n+\n+    for (auto iter : children)\n+      iter->recursive_log (logger);\n+  }\n+}\n+\n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "c3cea9032770c1149f5e0b64bdf5e88c48f8a4c5", "filename": "gcc/analyzer/call-string.h", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fcall-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fcall-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.h?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -36,8 +36,13 @@ class return_superedge;\n    i.e. that we return to the same callsite that called us.\n \n    The class stores returning calls ( which may be represented by a\n-   returning superedge ). We do so because this is what we need to compare \n-   against.  */\n+   returning superedge ). We do so because this is what we need to compare\n+   against.\n+\n+   Instances of call_string are consolidated by the region_model_manager,\n+   which effectively owns them: it owns the root/empty call_string, and each\n+   call_string instance tracks its children, lazily creating them on demand,\n+   so that the call_string instances form a tree-like hierarchy in memory.  */\n \n class call_string\n {\n@@ -60,38 +65,31 @@ class call_string\n     /* Accessors */\n     function *get_caller_function () const;\n     function *get_callee_function () const;\n-    \n+\n     const supernode *m_caller;\n     const supernode *m_callee;\n   };\n \n-  call_string () : m_elements () {}\n-  call_string (const call_string &other);\n-  call_string& operator= (const call_string &other);\n-\n-  bool operator== (const call_string &other) const;\n-\n   void print (pretty_printer *pp) const;\n \n   json::value *to_json () const;\n \n-  hashval_t hash () const;\n-\n   bool empty_p () const { return m_elements.is_empty (); }\n \n-  void push_call (const supergraph &sg,\n-\t\t  const call_superedge *sedge);\n-\n-  void push_call (const supernode *src, \n-    const supernode *dest);\n+  const call_string *push_call (const supergraph &sg,\n+\t\t\t\tconst call_superedge *sedge) const;\n \n-  element_t pop ();\n+  const call_string *push_call (const supernode *src,\n+\t\t\t\tconst supernode *dest) const;\n+  const call_string *get_parent () const { return m_parent; }\n \n   int calc_recursion_depth () const;\n \n   static int cmp (const call_string &a,\n \t\t  const call_string &b);\n \n+  static int cmp_ptr_ptr (const void *, const void *);\n+\n   /* Accessors */\n \n   const supernode *get_callee_node () const;\n@@ -101,11 +99,69 @@ class call_string\n   {\n     return m_elements[idx];\n   }\n+  const element_t &get_top_of_stack () const\n+  {\n+    gcc_assert (m_elements.length () > 0);\n+    return m_elements[m_elements.length () - 1];\n+  }\n \n   void validate () const;\n \n private:\n+  struct hashmap_traits_t\n+  {\n+    typedef element_t key_type;\n+    typedef const call_string *value_type;\n+\n+    static const bool maybe_mx = false;\n+    static inline hashval_t hash (const key_type &k)\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (k.m_caller);\n+      hstate.add_ptr (k.m_callee);\n+      return hstate.end ();\n+    }\n+    static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+    {\n+      return k1 == k2;\n+    }\n+    template <typename T> static inline void remove (T &entry)\n+    {\n+      entry.m_key = element_t (NULL, NULL);\n+    }\n+    static const bool empty_zero_p = true;\n+    template <typename T> static inline bool is_empty (const T &entry)\n+    {\n+      return entry.m_key.m_caller == NULL;\n+    }\n+    template <typename T> static inline bool is_deleted (const T &entry)\n+    {\n+      return entry.m_key.m_caller == reinterpret_cast<const supernode *> (1);\n+    }\n+    template <typename T> static inline void mark_empty (T &entry)\n+    {\n+      entry.m_key = element_t (NULL, NULL);\n+      entry.m_value = NULL;\n+    }\n+    template <typename T> static inline void mark_deleted (T &entry)\n+    {\n+      entry.m_key.m_caller = reinterpret_cast<const supernode *> (1);\n+    }\n+  };\n+\n+  friend class region_model_manager;\n+\n+  DISABLE_COPY_AND_ASSIGN (call_string);\n+\n+  call_string ();\n+  call_string (const call_string &parent, const element_t &to_push);\n+  ~call_string ();\n+\n+  void recursive_log (logger *logger) const;\n+\n+  const call_string *m_parent;\n   auto_vec<element_t> m_elements;\n+  mutable hash_map<element_t, const call_string *, hashmap_traits_t> m_children;\n };\n \n } // namespace ana"}, {"sha": "4133a134778169d0d8e7328858d2097c328be804", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -3923,10 +3923,10 @@ test_equality ()\n static void\n test_many_constants ()\n {\n-  program_point point (program_point::origin ());\n+  region_model_manager mgr;\n+  program_point point (program_point::origin (mgr));\n   tree a = build_global_decl (\"a\", integer_type_node);\n \n-  region_model_manager mgr;\n   region_model model (&mgr);\n   auto_vec<tree> constants;\n   for (int i = 0; i < 20; i++)"}, {"sha": "0674c8ba3b6f2d53cb67060e2b87ca639344b57d", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -2374,8 +2374,9 @@ exploded_graph::exploded_graph (const supergraph &sg, logger *logger,\n   m_functionless_stats (m_sg.num_nodes ()),\n   m_PK_AFTER_SUPERNODE_per_snode (m_sg.num_nodes ())\n {\n-  m_origin = get_or_create_node (program_point::origin (),\n-\t\t\t\t program_state (ext_state), NULL);\n+  m_origin = get_or_create_node\n+    (program_point::origin (*ext_state.get_model_manager ()),\n+     program_state (ext_state), NULL);\n   for (int i = 0; i < m_sg.num_nodes (); i++)\n     m_PK_AFTER_SUPERNODE_per_snode.quick_push (i);\n }\n@@ -2526,7 +2527,9 @@ exploded_graph::add_function_entry (function *fun)\n       return NULL;\n     }\n \n-  program_point point = program_point::from_function_entry (m_sg, fun);\n+  program_point point\n+    = program_point::from_function_entry (*m_ext_state.get_model_manager (),\n+\t\t\t\t\t  m_sg, fun);\n   program_state state (m_ext_state);\n   state.push_frame (m_ext_state, fun);\n \n@@ -2979,7 +2982,8 @@ add_tainted_args_callback (exploded_graph *eg, tree field, tree fndecl,\n   gcc_assert (fun);\n \n   program_point point\n-    = program_point::from_function_entry (eg->get_supergraph (), fun);\n+    = program_point::from_function_entry (*ext_state.get_model_manager (),\n+\t\t\t\t\t  eg->get_supergraph (), fun);\n   program_state state (ext_state);\n   state.push_frame (ext_state, fun);\n \n@@ -3341,7 +3345,7 @@ maybe_process_run_of_before_supernode_enodes (exploded_node *enode)\n \n       if (point_2.get_kind () == PK_BEFORE_SUPERNODE\n \t  && point_2.get_supernode () == snode\n-\t  && point_2.get_call_string () == point.get_call_string ())\n+\t  && &point_2.get_call_string () == &point.get_call_string ())\n \t{\n \t  enodes.safe_push (enode_2);\n \t  m_worklist.take_next ();\n@@ -4048,7 +4052,7 @@ exploded_graph::process_node (exploded_node *node)\n \tif ((is_an_exit_block && !found_a_superedge)\n \t    && (!point.get_call_string ().empty_p ()))\n \t  {\n-\t    const call_string cs = point.get_call_string ();\n+\t    const call_string &cs = point.get_call_string ();\n \t    program_point next_point\n \t      = program_point::before_supernode (cs.get_caller_node (),\n \t\t\t\t\t\t NULL,\n@@ -4736,7 +4740,7 @@ class supernode_cluster : public exploded_cluster\n class function_call_string_cluster : public exploded_cluster\n {\n public:\n-  function_call_string_cluster (function *fun, call_string cs)\n+  function_call_string_cluster (function *fun, const call_string &cs)\n   : m_fun (fun), m_cs (cs) {}\n \n   ~function_call_string_cluster ()\n@@ -4811,7 +4815,7 @@ class function_call_string_cluster : public exploded_cluster\n \n private:\n   function *m_fun;\n-  call_string m_cs;\n+  const call_string &m_cs;\n   typedef ordered_hash_map<const supernode *, supernode_cluster *> map_t;\n   map_t m_map;\n };\n@@ -4820,14 +4824,15 @@ class function_call_string_cluster : public exploded_cluster\n \n struct function_call_string\n {\n-  function_call_string (function *fun, call_string cs)\n+  function_call_string (function *fun, const call_string *cs)\n   : m_fun (fun), m_cs (cs)\n   {\n     gcc_assert (fun);\n+    gcc_assert (cs);\n   }\n \n   function *m_fun;\n-  call_string m_cs;\n+  const call_string *m_cs;\n };\n \n } // namespace ana\n@@ -4842,15 +4847,16 @@ template <>\n inline hashval_t\n pod_hash_traits<function_call_string>::hash (value_type v)\n {\n-  return pointer_hash <function>::hash (v.m_fun) ^ v.m_cs.hash ();\n+  return (pointer_hash <function>::hash (v.m_fun)\n+\t  ^ pointer_hash <const call_string>::hash (v.m_cs));\n }\n \n template <>\n inline bool\n pod_hash_traits<function_call_string>::equal (const value_type &existing,\n \t\t\t\t\t      const value_type &candidate)\n {\n-  return existing.m_fun == candidate.m_fun && existing.m_cs == candidate.m_cs;\n+  return existing.m_fun == candidate.m_fun && &existing.m_cs == &candidate.m_cs;\n }\n template <>\n inline void\n@@ -4925,7 +4931,7 @@ class root_cluster : public exploded_cluster\n       }\n \n     const call_string &cs = en->get_point ().get_call_string ();\n-    function_call_string key (fun, cs);\n+    function_call_string key (fun, &cs);\n     function_call_string_cluster **slot = m_map.get (key);\n     if (slot)\n       (*slot)->add_node (en);\n@@ -4939,11 +4945,6 @@ class root_cluster : public exploded_cluster\n   }\n \n private:\n-  /* This can't be an ordered_hash_map, as we can't store vec<call_string>,\n-     since it's not a POD; vec<>::quick_push has:\n-       *slot = obj;\n-     and the slot isn't initialized, so the assignment op dies when cleaning up\n-     un-inited *slot (within the truncate call).  */\n   typedef hash_map<function_call_string, function_call_string_cluster *> map_t;\n   map_t m_map;\n \n@@ -5319,7 +5320,7 @@ class viz_callgraph_node : public dnode<viz_callgraph_traits>\n \t    FOR_EACH_VEC_ELT (args.m_eg->m_nodes, i, enode)\n \t      {\n \t\tif (enode->get_point ().get_function () == m_fun\n-\t\t    && enode->get_point ().get_call_string () == *cs)\n+\t\t    && &enode->get_point ().get_call_string () == cs)\n \t\t  num_enodes++;\n \t      }\n \t    if (num_enodes > 0)"}, {"sha": "0613f558b8bd66ff39c3b0168bf7239e20f93b6e", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -599,65 +599,10 @@ struct per_call_string_data\n   : m_key (key), m_stats (num_supernodes)\n   {}\n \n-  const call_string m_key;\n+  const call_string &m_key;\n   stats m_stats;\n };\n \n-/* Traits class for storing per-call_string data within\n-   an exploded_graph.  */\n-\n-struct eg_call_string_hash_map_traits\n-{\n-  typedef const call_string *key_type;\n-  typedef per_call_string_data *value_type;\n-  typedef per_call_string_data *compare_type;\n-\n-  static inline hashval_t hash (const key_type &k)\n-  {\n-    gcc_assert (k != NULL);\n-    gcc_assert (k != reinterpret_cast<key_type> (1));\n-    return k->hash ();\n-  }\n-  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n-  {\n-    gcc_assert (k1 != NULL);\n-    gcc_assert (k2 != NULL);\n-    gcc_assert (k1 != reinterpret_cast<key_type> (1));\n-    gcc_assert (k2 != reinterpret_cast<key_type> (1));\n-    if (k1 && k2)\n-      return *k1 == *k2;\n-    else\n-      /* Otherwise they must both be non-NULL.  */\n-      return k1 == k2;\n-  }\n-  template <typename T>\n-  static inline void remove (T &)\n-  {\n-    /* empty; the nodes are handled elsewhere.  */\n-  }\n-  template <typename T>\n-  static inline void mark_deleted (T &entry)\n-  {\n-    entry.m_key = reinterpret_cast<key_type> (1);\n-  }\n-  template <typename T>\n-  static inline void mark_empty (T &entry)\n-  {\n-    entry.m_key = NULL;\n-  }\n-  template <typename T>\n-  static inline bool is_deleted (const T &entry)\n-  {\n-    return entry.m_key == reinterpret_cast<key_type> (1);\n-  }\n-  template <typename T>\n-  static inline bool is_empty (const T &entry)\n-  {\n-    return entry.m_key == NULL;\n-  }\n-  static const bool empty_zero_p = false;\n-};\n-\n /* Data about a particular function within an exploded_graph.  */\n \n struct per_function_data\n@@ -791,8 +736,8 @@ class worklist\n class exploded_graph : public digraph<eg_traits>\n {\n public:\n-  typedef hash_map <const call_string *, per_call_string_data *,\n-\t\t    eg_call_string_hash_map_traits> call_string_data_map_t;\n+  typedef hash_map <const call_string *,\n+\t\t    per_call_string_data *> call_string_data_map_t;\n \n   exploded_graph (const supergraph &sg, logger *logger,\n \t\t  const extrinsic_state &ext_state,"}, {"sha": "6c296d5ddc8e5b1a7cfd21322e8413caa25c3cb3", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -25,7 +25,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"gcc-rich-location.h\"\n #include \"json.h\"\n-#include \"analyzer/call-string.h\"\n #include \"ordered-hash-map.h\"\n #include \"options.h\"\n #include \"cgraph.h\"\n@@ -37,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"digraph.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/call-string.h\"\n #include \"analyzer/supergraph.h\"\n #include \"analyzer/program-point.h\"\n #include \"sbitmap.h\"\n@@ -290,7 +290,7 @@ void\n program_point::print (pretty_printer *pp, const format &f) const\n {\n   pp_string (pp, \"callstring: \");\n-  m_call_string.print (pp);\n+  m_call_string->print (pp);\n   f.spacer (pp);\n \n   m_function_point.print (pp, f);\n@@ -340,7 +340,7 @@ program_point::to_json () const\n       break;\n     }\n \n-  point_obj->set (\"call_string\", m_call_string.to_json ());\n+  point_obj->set (\"call_string\", m_call_string->to_json ());\n \n   return point_obj;\n }\n@@ -353,14 +353,15 @@ void\n program_point::push_to_call_stack (const supernode *caller,\n \t\t\t\t   const supernode *callee)\n {\n-  m_call_string.push_call (callee, caller);\n+  m_call_string = m_call_string->push_call (callee, caller);\n }\n \n /* Pop the topmost call from the current callstack.  */\n void\n program_point::pop_from_call_stack ()\n {\n-  m_call_string.pop ();\n+  m_call_string = m_call_string->get_parent ();\n+  gcc_assert (m_call_string);\n }\n \n /* Generate a hash value for this program_point.  */\n@@ -370,7 +371,7 @@ program_point::hash () const\n {\n   inchash::hash hstate;\n   hstate.merge_hash (m_function_point.hash ());\n-  hstate.merge_hash (m_call_string.hash ());\n+  hstate.add_ptr (m_call_string);\n   return hstate.end ();\n }\n \n@@ -379,11 +380,11 @@ program_point::hash () const\n function *\n program_point::get_function_at_depth (unsigned depth) const\n {\n-  gcc_assert (depth <= m_call_string.length ());\n-  if (depth == m_call_string.length ())\n+  gcc_assert (depth <= m_call_string->length ());\n+  if (depth == m_call_string->length ())\n     return m_function_point.get_function ();\n   else\n-    return m_call_string[depth].get_caller_function ();\n+    return get_call_string ()[depth].get_caller_function ();\n }\n \n /* Assert that this object is sane.  */\n@@ -396,12 +397,13 @@ program_point::validate () const\n   return;\n #endif\n \n-  m_call_string.validate ();\n+  m_call_string->validate ();\n   /* The \"callee\" of the final entry in the callstring should be the\n      function of the m_function_point.  */\n-  if (m_call_string.length () > 0)\n-    gcc_assert (m_call_string[m_call_string.length () - 1].get_callee_function ()\n-\t\t== get_function ());\n+  if (m_call_string->length () > 0)\n+    gcc_assert\n+      ((*m_call_string)[m_call_string->length () - 1].get_callee_function ()\n+       == get_function ());\n }\n \n /* Check to see if SUCC is a valid edge to take (ensuring that we have\n@@ -444,14 +446,15 @@ program_point::on_edge (exploded_graph &eg,\n \t  }\n \n \t/* Add the callsite to the call string.  */\n-\tm_call_string.push_call (eg.get_supergraph (), call_sedge);\n+\tm_call_string = m_call_string->push_call (eg.get_supergraph (),\n+\t\t\t\t\t\t  call_sedge);\n \n \t/* Impose a maximum recursion depth and don't analyze paths\n \t   that exceed it further.\n \t   This is something of a blunt workaround, but it only\n \t   applies to recursion (and mutual recursion), not to\n \t   general call stacks.  */\n-\tif (m_call_string.calc_recursion_depth ()\n+\tif (m_call_string->calc_recursion_depth ()\n \t    > param_analyzer_max_recursion_depth)\n \t  {\n \t    if (logger)\n@@ -465,13 +468,15 @@ program_point::on_edge (exploded_graph &eg,\n     case SUPEREDGE_RETURN:\n       {\n \t/* Require that we return to the call site in the call string.  */\n-\tif (m_call_string.empty_p ())\n+\tif (m_call_string->empty_p ())\n \t  {\n \t    if (logger)\n \t      logger->log (\"rejecting return edge: empty call string\");\n \t    return false;\n \t  }\n-\tconst call_string::element_t top_of_stack = m_call_string.pop ();\n+\tconst call_string::element_t &top_of_stack\n+\t  = m_call_string->get_top_of_stack ();\n+\tm_call_string = m_call_string->get_parent ();\n \tcall_string::element_t current_call_string_element (succ->m_dest,\n \t\t\t\t\t\t\t    succ->m_src);\n \tif (top_of_stack != current_call_string_element)\n@@ -669,6 +674,25 @@ function_point::get_next () const\n     }\n }\n \n+/* class program_point.  */\n+\n+program_point\n+program_point::origin (const region_model_manager &mgr)\n+{\n+  return program_point (function_point (NULL, NULL,\n+\t\t\t\t\t0, PK_ORIGIN),\n+\t\t\tmgr.get_empty_call_string ());\n+}\n+\n+program_point\n+program_point::from_function_entry (const region_model_manager &mgr,\n+\t\t\t\t    const supergraph &sg,\n+\t\t\t\t    function *fun)\n+{\n+  return program_point (function_point::from_function_entry (sg, fun),\n+\t\t\tmgr.get_empty_call_string ());\n+}\n+\n /* For those program points for which there is a uniquely-defined\n    successor, return it.  */\n \n@@ -721,7 +745,6 @@ static void\n test_function_point_ordering ()\n {\n   const supernode *snode = NULL;\n-  const call_string call_string;\n \n   /* Populate an array with various points within the same\n      snode, in order.  */\n@@ -756,9 +779,11 @@ test_function_point_ordering ()\n static void\n test_program_point_equality ()\n {\n+  region_model_manager mgr;\n+\n   const supernode *snode = NULL;\n \n-  const call_string cs;\n+  const call_string &cs = mgr.get_empty_call_string ();\n \n   program_point a = program_point::before_supernode (snode, NULL,\n \t\t\t\t\t\t     cs);"}, {"sha": "63f72246f696db033c1f23a82bce69e2da22972b", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -174,7 +174,7 @@ class program_point\n   program_point (const function_point &fn_point,\n \t\t const call_string &call_string)\n   : m_function_point (fn_point),\n-    m_call_string (call_string)\n+    m_call_string (&call_string)\n   {\n   }\n \n@@ -197,7 +197,7 @@ class program_point\n   /* Accessors.  */\n \n   const function_point &get_function_point () const { return m_function_point; }\n-  const call_string &get_call_string () const { return m_call_string; }\n+  const call_string &get_call_string () const { return *m_call_string; }\n \n   const supernode *get_supernode () const\n   {\n@@ -242,23 +242,14 @@ class program_point\n   {\n     if (get_kind () == PK_ORIGIN)\n       return 0;\n-    return m_call_string.length () + 1;\n+    return get_call_string ().length () + 1;\n   }\n \n   /* Factory functions for making various kinds of program_point.  */\n-  static program_point origin ()\n-  {\n-    return program_point (function_point (NULL, NULL,\n-\t\t\t\t\t  0, PK_ORIGIN),\n-\t\t\t  call_string ());\n-  }\n-\n-  static program_point from_function_entry (const supergraph &sg,\n-\t\t\t\t\t    function *fun)\n-  {\n-    return program_point (function_point::from_function_entry (sg, fun),\n-\t\t\t  call_string ());\n-  }\n+  static program_point origin (const region_model_manager &mgr);\n+  static program_point from_function_entry (const region_model_manager &mgr,\n+\t\t\t\t\t    const supergraph &sg,\n+\t\t\t\t\t    function *fun);\n \n   static program_point before_supernode (const supernode *supernode,\n \t\t\t\t\t const superedge *from_edge,\n@@ -288,11 +279,11 @@ class program_point\n \n   static program_point empty ()\n   {\n-    return program_point (function_point::empty (), call_string ());\n+    return program_point (function_point::empty ());\n   }\n   static program_point deleted ()\n   {\n-    return program_point (function_point::deleted (), call_string ());\n+    return program_point (function_point::deleted ());\n   }\n \n   bool on_edge (exploded_graph &eg, const superedge *succ);\n@@ -306,8 +297,14 @@ class program_point\n   program_point get_next () const;\n \n  private:\n+  program_point (const function_point &fn_point)\n+  : m_function_point (fn_point),\n+    m_call_string (NULL)\n+  {\n+  }\n+\n   function_point m_function_point;\n-  call_string m_call_string;\n+  const call_string *m_call_string;\n };\n \n } // namespace ana"}, {"sha": "295c6aeb185cb6f4edd0203e9f1e5bb0a7835a97", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -1668,12 +1668,12 @@ test_program_state_merging ()\n      malloc sm-state, pointing to a region on the heap.  */\n   tree p = build_global_decl (\"p\", ptr_type_node);\n \n-  program_point point (program_point::origin ());\n+  engine eng;\n+  region_model_manager *mgr = eng.get_model_manager ();\n+  program_point point (program_point::origin (*mgr));\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (make_malloc_state_machine (NULL));\n-  engine eng;\n   extrinsic_state ext_state (checkers, &eng);\n-  region_model_manager *mgr = eng.get_model_manager ();\n \n   program_state s0 (ext_state);\n   uncertainty_t uncertainty;\n@@ -1736,10 +1736,11 @@ test_program_state_merging ()\n static void\n test_program_state_merging_2 ()\n {\n-  program_point point (program_point::origin ());\n+  engine eng;\n+  region_model_manager *mgr = eng.get_model_manager ();\n+  program_point point (program_point::origin (*mgr));\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (make_signal_state_machine (NULL));\n-  engine eng;\n   extrinsic_state ext_state (checkers, &eng);\n \n   const state_machine::state test_state_0 (\"test state 0\", 0);"}, {"sha": "17713b07c30bd14f086237235fbc21cc900c3d98", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -68,6 +68,7 @@ namespace ana {\n \n region_model_manager::region_model_manager (logger *logger)\n : m_logger (logger),\n+  m_empty_call_string (),\n   m_next_region_id (0),\n   m_root_region (alloc_region_id ()),\n   m_stack_region (alloc_region_id (), &m_root_region),\n@@ -1748,6 +1749,8 @@ void\n region_model_manager::log_stats (logger *logger, bool show_objs) const\n {\n   LOG_SCOPE (logger);\n+  logger->log (\"call string consolidation\");\n+  m_empty_call_string.recursive_log (logger);\n   logger->log (\"svalue consolidation\");\n   log_uniq_map (logger, show_objs, \"constant_svalue\", m_constants_map);\n   log_uniq_map (logger, show_objs, \"unknown_svalue\", m_unknowns_map);"}, {"sha": "5bd5dc720e928685c3fa13901fa8f19b6f43b8f7", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -5460,9 +5460,9 @@ assert_region_models_merge (tree expr, tree val_a, tree val_b,\n \t\t\t     region_model *out_merged_model,\n \t\t\t     const svalue **out_merged_svalue)\n {\n-  program_point point (program_point::origin ());\n-  test_region_model_context ctxt;\n   region_model_manager *mgr = out_merged_model->get_manager ();\n+  program_point point (program_point::origin (*mgr));\n+  test_region_model_context ctxt;\n   region_model model0 (mgr);\n   region_model model1 (mgr);\n   if (val_a)\n@@ -5511,8 +5511,8 @@ test_state_merging ()\n \t\t       ptr_type_node);\n   DECL_CONTEXT (q) = test_fndecl;\n \n-  program_point point (program_point::origin ());\n   region_model_manager mgr;\n+  program_point point (program_point::origin (mgr));\n \n   {\n     region_model model0 (&mgr);\n@@ -5852,7 +5852,7 @@ test_constraint_merging ()\n \n   /* They should be mergeable; the merged constraints should\n      be: (0 <= x < n).  */\n-  program_point point (program_point::origin ());\n+  program_point point (program_point::origin (mgr));\n   region_model merged (&mgr);\n   ASSERT_TRUE (model0.can_merge_with_p (model1, point, &merged));\n \n@@ -5873,12 +5873,12 @@ test_constraint_merging ()\n static void\n test_widening_constraints ()\n {\n-  program_point point (program_point::origin ());\n+  region_model_manager mgr;\n+  program_point point (program_point::origin (mgr));\n   tree int_0 = build_int_cst (integer_type_node, 0);\n   tree int_m1 = build_int_cst (integer_type_node, -1);\n   tree int_1 = build_int_cst (integer_type_node, 1);\n   tree int_256 = build_int_cst (integer_type_node, 256);\n-  region_model_manager mgr;\n   test_region_model_context ctxt;\n   const svalue *int_0_sval = mgr.get_or_create_constant_svalue (int_0);\n   const svalue *int_1_sval = mgr.get_or_create_constant_svalue (int_1);\n@@ -5988,15 +5988,15 @@ test_widening_constraints ()\n static void\n test_iteration_1 ()\n {\n-  program_point point (program_point::origin ());\n+  region_model_manager mgr;\n+  program_point point (program_point::origin (mgr));\n \n   tree int_0 = build_int_cst (integer_type_node, 0);\n   tree int_1 = build_int_cst (integer_type_node, 1);\n   tree int_256 = build_int_cst (integer_type_node, 256);\n   tree int_257 = build_int_cst (integer_type_node, 257);\n   tree i = build_global_decl (\"i\", integer_type_node);\n \n-  region_model_manager mgr;\n   test_region_model_context ctxt;\n \n   /* model0: i: 0.  */"}, {"sha": "129aad2945fede1c35f3c486ac747cec39ce9ad8", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -244,6 +244,12 @@ class region_model_manager\n   region_model_manager (logger *logger = NULL);\n   ~region_model_manager ();\n \n+  /* call_string consolidation.  */\n+  const call_string &get_empty_call_string () const\n+  {\n+    return m_empty_call_string;\n+  }\n+\n   /* svalue consolidation.  */\n   const svalue *get_or_create_constant_svalue (tree cst_expr);\n   const svalue *get_or_create_int_cst (tree type, poly_int64);\n@@ -381,6 +387,8 @@ class region_model_manager\n \n   logger *m_logger;\n \n+  const call_string m_empty_call_string;\n+\n   unsigned m_next_region_id;\n   root_region m_root_region;\n   stack_region m_stack_region;"}, {"sha": "b601f450513621dd223e2e1f13e79dcf3df58506", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb8e93eb1acae30a5fbe7e13149493ce4ccd301a/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=bb8e93eb1acae30a5fbe7e13149493ce4ccd301a", "patch": "@@ -266,11 +266,13 @@ class register_signal_handler : public custom_transition\n     function *handler_fun = DECL_STRUCT_FUNCTION (m_fndecl);\n     if (!handler_fun)\n       return;\n+    const extrinsic_state &ext_state = eg->get_ext_state ();\n     program_point entering_handler\n-      = program_point::from_function_entry (eg->get_supergraph (),\n+      = program_point::from_function_entry (*ext_state.get_model_manager (),\n+\t\t\t\t\t    eg->get_supergraph (),\n \t\t\t\t\t    handler_fun);\n \n-    program_state state_entering_handler (eg->get_ext_state ());\n+    program_state state_entering_handler (ext_state);\n     update_model_for_signal_handler (state_entering_handler.m_region_model,\n \t\t\t\t     handler_fun);\n     state_entering_handler.m_checker_states[sm_idx]->set_global_state"}]}