{"sha": "81d6cdd335ffc60c216a020d5c99306f659377a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFkNmNkZDMzNWZmYzYwYzIxNmEwMjBkNWM5OTMwNmY2NTkzNzdhMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-06T21:29:33Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-06T22:08:36Z"}, "message": "Move more code to new gimple-ssa-warn-access pass.\n\ngcc/ChangeLog:\n\n\t* builtins.c (expand_builtin_memchr): Move to gimple-ssa-warn-access.cc.\n\t(expand_builtin_strcat): Same.\n\t(expand_builtin_stpncpy): Same.\n\t(expand_builtin_strncat): Same.\n\t(check_read_access): Same.\n\t(check_memop_access): Same.\n\t(expand_builtin_strlen): Move checks to gimple-ssa-warn-access.cc.\n\t(expand_builtin_strnlen): Same.\n\t(expand_builtin_memcpy): Same.\n\t(expand_builtin_memmove): Same.\n\t(expand_builtin_mempcpy): Same.\n\t(expand_builtin_strcpy): Same.\n\t(expand_builtin_strcpy_args): Same.\n\t(expand_builtin_stpcpy_1): Same.\n\t(expand_builtin_strncpy): Same.\n\t(expand_builtin_memset): Same.\n\t(expand_builtin_bzero): Same.\n\t(expand_builtin_strcmp): Same.\n\t(expand_builtin_strncmp): Same.\n\t(expand_builtin): Remove handlers.\n\t(fold_builtin_strlen): Add a comment.\n\t* builtins.h (check_access): Move to gimple-ssa-warn-access.cc.\n\t* calls.c (maybe_warn_nonstring_arg): Same.\n\t* diagnostic-spec.c (nowarn_spec_t::nowarn_spec_t): Add warning option.\n\t* gimple-fold.c (gimple_fold_builtin_strcpy): Pass argument to callee.\n\t(gimple_fold_builtin_stpcpy): Same.\n\t* gimple-ssa-warn-access.cc (has_location): New function.\n\t(get_location): Same.\n\t(get_callee_fndecl): Same.\n\t(call_nargs): Same.\n\t(call_arg): Same.\n\t(warn_string_no_nul): Define.\n\t(unterminated_array): Same.\n\t(check_nul_terminated_array): Same.\n\t(maybe_warn_nonstring_arg): Same.\n\t(maybe_warn_for_bound): Same.\n\t(warn_for_access): Same.\n\t(check_access): Same.\n\t(check_memop_access): Same.\n\t(check_read_access): Same.\n\t(warn_dealloc_offset): Use helper functions.\n\t(maybe_emit_free_warning): Same.\n\t(class pass_waccess): Add members.\n\t(check_strcat): New function.\n\t(check_strncat): New function.\n\t(check_stxcpy): New function.\n\t(check_stxncpy): New function.\n\t(check_strncmp): New function.\n\t(pass_waccess::check_builtin): New function.\n\t(pass_waccess::check): Call it.\n\t* gimple-ssa-warn-access.h (warn_string_no_nul): Move here from\n\tbuiltins.h.\n\t(maybe_warn_for_bound): Same.\n\t(check_access): Same.\n\t(check_memop_access): Same.\n\t(check_read_access): Same.\n\t* pointer-query.h (struct access_data): Define a ctor overload.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wsizeof-pointer-memaccess1.c: Also disable\n\t-Wstringop-overread.\n\t* c-c++-common/attr-nonstring-3.c: Adjust pattern of expected message.\n\t* gcc.dg/Warray-bounds-39.c: Add an xfail due to a known bug.\n\t* gcc.dg/Wstring-compare-3.c: Also disable -Wstringop-overread.\n\t* gcc.dg/attr-nonstring-2.c: Adjust pattern of expected message.\n\t* gcc.dg/attr-nonstring-4.c: Same.\n\t* gcc.dg/Wstringop-overread-6.c: New test.\n\t* gcc.dg/sso-14.c: Fix typos to avoid buffer overflow.", "tree": {"sha": "dfc6982f6965e62985d4cc77343c1e26dccebb41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfc6982f6965e62985d4cc77343c1e26dccebb41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81d6cdd335ffc60c216a020d5c99306f659377a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d6cdd335ffc60c216a020d5c99306f659377a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81d6cdd335ffc60c216a020d5c99306f659377a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d6cdd335ffc60c216a020d5c99306f659377a2/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "629b5699fb555b30c25ebc0b503e87b470bed076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/629b5699fb555b30c25ebc0b503e87b470bed076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/629b5699fb555b30c25ebc0b503e87b470bed076"}], "stats": {"total": 2491, "additions": 1656, "deletions": 835}, "files": [{"sha": "d2be807f1d6cb673477b1a9337def558d6f5a766", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 392, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -131,7 +131,6 @@ static rtx expand_builtin_va_copy (tree);\n static rtx inline_expand_builtin_bytecmp (tree, rtx);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n-static rtx expand_builtin_memchr (tree, rtx);\n static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n \t\t\t\t\t    rtx target, tree exp,\n@@ -140,12 +139,9 @@ static rtx expand_builtin_memory_copy_args (tree dest, tree src, tree len,\n static rtx expand_builtin_memmove (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx);\n static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, tree, memop_ret);\n-static rtx expand_builtin_strcat (tree);\n static rtx expand_builtin_strcpy (tree, rtx);\n static rtx expand_builtin_strcpy_args (tree, tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, machine_mode);\n-static rtx expand_builtin_stpncpy (tree, rtx);\n-static rtx expand_builtin_strncat (tree, rtx);\n static rtx expand_builtin_strncpy (tree, rtx);\n static rtx expand_builtin_memset (tree, rtx, machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, machine_mode, tree);\n@@ -186,7 +182,6 @@ static rtx expand_builtin_memory_chk (tree, rtx, machine_mode,\n static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static tree fold_builtin_object_size (tree, tree);\n-static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n \n unsigned HOST_WIDE_INT target_newline;\n unsigned HOST_WIDE_INT target_percent;\n@@ -2957,8 +2952,6 @@ expand_builtin_strlen (tree exp, rtx target,\n     return NULL_RTX;\n \n   tree src = CALL_EXPR_ARG (exp, 0);\n-  if (!check_read_access (exp, src))\n-    return NULL_RTX;\n \n   /* If the length can be computed at compile-time, return it.  */\n   if (tree len = c_strlen (src, 0))\n@@ -3062,8 +3055,6 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n   if (!bound)\n     return NULL_RTX;\n \n-  check_read_access (exp, src, bound);\n-\n   location_t loc = UNKNOWN_LOCATION;\n   if (EXPR_HAS_LOCATION (exp))\n     loc = EXPR_LOCATION (exp);\n@@ -3201,65 +3192,6 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n-/* A convenience wrapper for check_access above to check access\n-   by a read-only function like puts.  */\n-\n-static bool\n-check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n-\t\t   int ost /* = 1 */)\n-{\n-  if (!warn_stringop_overread)\n-    return true;\n-\n-  if (bound && !useless_type_conversion_p (size_type_node, TREE_TYPE (bound)))\n-    bound = fold_convert (size_type_node, bound);\n-  access_data data (exp, access_read_only, NULL_TREE, false, bound, true);\n-  compute_objsize (src, ost, &data.src);\n-  return check_access (exp, /*dstwrite=*/ NULL_TREE, /*maxread=*/ bound,\n-\t\t       /*srcstr=*/ src, /*dstsize=*/ NULL_TREE, data.mode,\n-\t\t       &data);\n-}\n-\n-/* Helper to determine and check the sizes of the source and the destination\n-   of calls to __builtin_{bzero,memcpy,mempcpy,memset} calls.  EXP is the\n-   call expression, DEST is the destination argument, SRC is the source\n-   argument or null, and LEN is the number of bytes.  Use Object Size type-0\n-   regardless of the OPT_Wstringop_overflow_ setting.  Return true on success\n-   (no overflow or invalid sizes), false otherwise.  */\n-\n-static bool\n-check_memop_access (tree exp, tree dest, tree src, tree size)\n-{\n-  /* For functions like memset and memcpy that operate on raw memory\n-     try to determine the size of the largest source and destination\n-     object using type-0 Object Size regardless of the object size\n-     type specified by the option.  */\n-  access_data data (exp, access_read_write);\n-  tree srcsize = src ? compute_objsize (src, 0, &data.src) : NULL_TREE;\n-  tree dstsize = compute_objsize (dest, 0, &data.dst);\n-\n-  return check_access (exp, size, /*maxread=*/NULL_TREE,\n-\t\t       srcsize, dstsize, data.mode, &data);\n-}\n-\n-/* Validate memchr arguments without performing any expansion.\n-   Return NULL_RTX.  */\n-\n-static rtx\n-expand_builtin_memchr (tree exp, rtx)\n-{\n-  if (!validate_arglist (exp,\n- \t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  tree arg1 = CALL_EXPR_ARG (exp, 0);\n-  tree len = CALL_EXPR_ARG (exp, 2);\n-\n-  check_read_access (exp, arg1, len, 0);\n-\n-  return NULL_RTX;\n-}\n-\n /* Expand a call EXP to the memcpy builtin.\n    Return NULL_RTX if we failed, the caller should emit a normal call,\n    otherwise try to get the result in TARGET, if convenient (and in\n@@ -3276,8 +3208,6 @@ expand_builtin_memcpy (tree exp, rtx target)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_access (exp, dest, src, len);\n-\n   return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n \t\t\t\t\t  /*retmode=*/ RETURN_BEGIN, false);\n }\n@@ -3296,8 +3226,6 @@ expand_builtin_memmove (tree exp, rtx target)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_access (exp, dest, src, len);\n-\n   return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n \t\t\t\t\t  /*retmode=*/ RETURN_BEGIN, true);\n }\n@@ -3334,8 +3262,6 @@ expand_builtin_mempcpy (tree exp, rtx target)\n   /* Avoid expanding mempcpy into memcpy when the call is determined\n      to overflow the buffer.  This also prevents the same overflow\n      from being diagnosed again when expanding memcpy.  */\n-  if (!check_memop_access (exp, dest, src, len))\n-    return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n \t\t\t\t      target, exp, /*retmode=*/ RETURN_END);\n@@ -3511,36 +3437,6 @@ expand_movstr (tree dest, tree src, rtx target, memop_ret retmode)\n   return target;\n }\n \n-/* Do some very basic size validation of a call to the strcpy builtin\n-   given by EXP.  Return NULL_RTX to have the built-in expand to a call\n-   to the library function.  */\n-\n-static rtx\n-expand_builtin_strcat (tree exp)\n-{\n-  if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n-      || !warn_stringop_overflow)\n-    return NULL_RTX;\n-\n-  tree dest = CALL_EXPR_ARG (exp, 0);\n-  tree src = CALL_EXPR_ARG (exp, 1);\n-\n-  /* There is no way here to determine the length of the string in\n-     the destination to which the SRC string is being appended so\n-     just diagnose cases when the souce string is longer than\n-     the destination object.  */\n-  access_data data (exp, access_read_write, NULL_TREE, true,\n-\t\t    NULL_TREE, true);\n-  const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-  compute_objsize (src, ost, &data.src);\n-  tree destsize = compute_objsize (dest, ost, &data.dst);\n-\n-  check_access (exp, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\tsrc, destsize, data.mode, &data);\n-\n-  return NULL_RTX;\n-}\n-\n /* Expand expression EXP, which is a call to the strcpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient (and in mode MODE if that's\n@@ -3555,29 +3451,7 @@ expand_builtin_strcpy (tree exp, rtx target)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree src = CALL_EXPR_ARG (exp, 1);\n \n-  if (warn_stringop_overflow)\n-    {\n-      access_data data (exp, access_read_write, NULL_TREE, true,\n-\t\t\tNULL_TREE, true);\n-      const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-      compute_objsize (src, ost, &data.src);\n-      tree dstsize = compute_objsize (dest, ost, &data.dst);\n-      check_access (exp, /*dstwrite=*/ NULL_TREE,\n-\t\t    /*maxread=*/ NULL_TREE, /*srcstr=*/ src,\n-\t\t    dstsize, data.mode, &data);\n-    }\n-\n-  if (rtx ret = expand_builtin_strcpy_args (exp, dest, src, target))\n-    {\n-      /* Check to see if the argument was declared attribute nonstring\n-\t and if so, issue a warning since at this point it's not known\n-\t to be nul-terminated.  */\n-      tree fndecl = get_callee_fndecl (exp);\n-      maybe_warn_nonstring_arg (fndecl, exp);\n-      return ret;\n-    }\n-\n-  return NULL_RTX;\n+  return expand_builtin_strcpy_args (exp, dest, src, target);\n }\n \n /* Helper function to do the actual work for expand_builtin_strcpy.  The\n@@ -3587,19 +3461,8 @@ expand_builtin_strcpy (tree exp, rtx target)\n    expand_builtin_strcpy.  */\n \n static rtx\n-expand_builtin_strcpy_args (tree exp, tree dest, tree src, rtx target)\n+expand_builtin_strcpy_args (tree, tree dest, tree src, rtx target)\n {\n-  /* Detect strcpy calls with unterminated arrays..  */\n-  tree size;\n-  bool exact;\n-  if (tree nonstr = unterminated_array (src, &size, &exact))\n-    {\n-      /* NONSTR refers to the non-nul terminated constant array.  */\n-      warn_string_no_nul (EXPR_LOCATION (exp), exp, NULL, src, nonstr,\n-\t\t\t  size, exact);\n-      return NULL_RTX;\n-    }\n-\n   return expand_movstr (dest, src, target, /*retmode=*/ RETURN_BEGIN);\n }\n \n@@ -3620,15 +3483,6 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n   dst = CALL_EXPR_ARG (exp, 0);\n   src = CALL_EXPR_ARG (exp, 1);\n \n-  if (warn_stringop_overflow)\n-    {\n-      access_data data (exp, access_read_write);\n-      tree destsize = compute_objsize (dst, warn_stringop_overflow - 1,\n-\t\t\t\t       &data.dst);\n-      check_access (exp, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\t    src, destsize, data.mode, &data);\n-    }\n-\n   /* If return value is ignored, transform stpcpy into strcpy.  */\n   if (target == const0_rtx && builtin_decl_implicit (BUILT_IN_STRCPY))\n     {\n@@ -3651,9 +3505,6 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \treturn expand_movstr (dst, src, target,\n \t\t\t      /*retmode=*/ RETURN_END_MINUS_ONE);\n \n-      if (lendata.decl)\n-\twarn_string_no_nul (EXPR_LOCATION (exp), exp, NULL, src, lendata.decl);\n-\n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n \t\t\t\t\t target, exp,\n@@ -3715,30 +3566,6 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n   return NULL_RTX;\n }\n \n-/* Check a call EXP to the stpncpy built-in for validity.\n-   Return NULL_RTX on both success and failure.  */\n-\n-static rtx\n-expand_builtin_stpncpy (tree exp, rtx)\n-{\n-  if (!validate_arglist (exp,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE)\n-      || !warn_stringop_overflow)\n-    return NULL_RTX;\n-\n-  /* The source and destination of the call.  */\n-  tree dest = CALL_EXPR_ARG (exp, 0);\n-  tree src = CALL_EXPR_ARG (exp, 1);\n-\n-  /* The exact number of bytes to write (not the maximum).  */\n-  tree len = CALL_EXPR_ARG (exp, 2);\n-  access_data data (exp, access_read_write);\n-  /* The size of the destination object.  */\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n-  check_access (exp, len, /*maxread=*/len, src, destsize, data.mode, &data);\n-  return NULL_RTX;\n-}\n-\n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n    bytes from constant string DATA + OFFSET and return it as target\n    constant.  */\n@@ -3817,78 +3644,6 @@ check_strncat_sizes (tree exp, tree objsize)\n \t\t       objsize, data.mode, &data);\n }\n \n-/* Similar to expand_builtin_strcat, do some very basic size validation\n-   of a call to the strcpy builtin given by EXP.  Return NULL_RTX to have\n-   the built-in expand to a call to the library function.  */\n-\n-static rtx\n-expand_builtin_strncat (tree exp, rtx)\n-{\n-  if (!validate_arglist (exp,\n-\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE)\n-      || !warn_stringop_overflow)\n-    return NULL_RTX;\n-\n-  tree dest = CALL_EXPR_ARG (exp, 0);\n-  tree src = CALL_EXPR_ARG (exp, 1);\n-  /* The upper bound on the number of bytes to write.  */\n-  tree maxread = CALL_EXPR_ARG (exp, 2);\n-\n-  /* Detect unterminated source (only).  */\n-  if (!check_nul_terminated_array (exp, src, maxread))\n-    return NULL_RTX;\n-\n-  /* The length of the source sequence.  */\n-  tree slen = c_strlen (src, 1);\n-\n-  /* Try to determine the range of lengths that the source expression\n-     refers to.  Since the lengths are only used for warning and not\n-     for code generation disable strict mode below.  */\n-  tree maxlen = slen;\n-  if (!maxlen)\n-    {\n-      c_strlen_data lendata = { };\n-      get_range_strlen (src, &lendata, /* eltsize = */ 1);\n-      maxlen = lendata.maxbound;\n-    }\n-\n-  access_data data (exp, access_read_write);\n-  /* Try to verify that the destination is big enough for the shortest\n-     string.  First try to determine the size of the destination object\n-     into which the source is being copied.  */\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n-\n-  /* Add one for the terminating nul.  */\n-  tree srclen = (maxlen\n-\t\t ? fold_build2 (PLUS_EXPR, size_type_node, maxlen,\n-\t\t\t\tsize_one_node)\n-\t\t : NULL_TREE);\n-\n-  /* The strncat function copies at most MAXREAD bytes and always appends\n-     the terminating nul so the specified upper bound should never be equal\n-     to (or greater than) the size of the destination.  */\n-  if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (destsize)\n-      && tree_int_cst_equal (destsize, maxread))\n-    {\n-      location_t loc = EXPR_LOCATION (exp);\n-      warning_at (loc, OPT_Wstringop_overflow_,\n-\t\t  \"%qD specified bound %E equals destination size\",\n-\t\t  get_callee_fndecl (exp), maxread);\n-\n-      return NULL_RTX;\n-    }\n-\n-  if (!srclen\n-      || (maxread && tree_fits_uhwi_p (maxread)\n-\t  && tree_fits_uhwi_p (srclen)\n-\t  && tree_int_cst_lt (maxread, srclen)))\n-    srclen = maxread;\n-\n-  check_access (exp, /*dstwrite=*/NULL_TREE, maxread, srclen,\n-\t\tdestsize, data.mode, &data);\n-  return NULL_RTX;\n-}\n-\n /* Expand expression EXP, which is a call to the strncpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n@@ -3908,18 +3663,6 @@ expand_builtin_strncpy (tree exp, rtx target)\n   /* The length of the source sequence.  */\n   tree slen = c_strlen (src, 1);\n \n-  if (warn_stringop_overflow)\n-    {\n-      access_data data (exp, access_read_write, len, true, len, true);\n-      const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-      compute_objsize (src, ost, &data.src);\n-      tree dstsize = compute_objsize (dest, ost, &data.dst);\n-      /* The number of bytes to write is LEN but check_access will also\n-\t check SLEN if LEN's value isn't known.  */\n-      check_access (exp, /*dstwrite=*/len,\n-\t\t    /*maxread=*/len, src, dstsize, data.mode, &data);\n-    }\n-\n   /* We must be passed a constant len and src parameter.  */\n   if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))\n     return NULL_RTX;\n@@ -4141,8 +3884,6 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n   tree val = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_access (exp, dest, NULL_TREE, len);\n-\n   return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n }\n \n@@ -4470,8 +4211,6 @@ expand_builtin_bzero (tree exp)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree size = CALL_EXPR_ARG (exp, 1);\n \n-  check_memop_access (exp, dest, NULL_TREE, size);\n-\n   /* New argument list transforming bzero(ptr x, int y) to\n      memset(ptr x, int 0, size_t y).   This is done this way\n      so that if it isn't expanded inline, we fallback to\n@@ -4622,10 +4361,6 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n \n-  if (!check_read_access (exp, arg1)\n-      || !check_read_access (exp, arg2))\n-    return NULL_RTX;\n-\n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n   result = inline_expand_builtin_bytecmp (exp, target);\n@@ -4707,11 +4442,6 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   tree fndecl = get_callee_fndecl (exp);\n   if (result)\n     {\n-      /* Check to see if the argument was declared attribute nonstring\n-\t and if so, issue a warning since at this point it's not known\n-\t to be nul-terminated.  */\n-      maybe_warn_nonstring_arg (fndecl, exp);\n-\n       /* Return the value in the proper mode for this function.  */\n       machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n       if (GET_MODE (result) == mode)\n@@ -4725,6 +4455,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n   /* Expand the library call ourselves using a stabilized argument\n      list to avoid re-evaluating the function's arguments twice.  */\n   tree fn = build_call_nofold_loc (EXPR_LOCATION (exp), fndecl, 2, arg1, arg2);\n+  copy_warning (fn, exp);\n   gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n   CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n   return expand_call (fn, target, target == const0_rtx);\n@@ -4746,66 +4477,10 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree arg3 = CALL_EXPR_ARG (exp, 2);\n \n-  if (!check_nul_terminated_array (exp, arg1, arg3)\n-      || !check_nul_terminated_array (exp, arg2, arg3))\n-    return NULL_RTX;\n-\n   location_t loc = EXPR_LOCATION (exp);\n   tree len1 = c_strlen (arg1, 1);\n   tree len2 = c_strlen (arg2, 1);\n \n-  if (!len1 || !len2)\n-    {\n-      /* Check to see if the argument was declared attribute nonstring\n-\t and if so, issue a warning since at this point it's not known\n-\t to be nul-terminated.  */\n-      if (!maybe_warn_nonstring_arg (get_callee_fndecl (exp), exp)\n-\t  && !len1 && !len2)\n-\t{\n-\t  /* A strncmp read is constrained not just by the bound but\n-\t     also by the length of the shorter string.  Specifying\n-\t     a bound that's larger than the size of either array makes\n-\t     no sense and is likely a bug.  When the length of neither\n-\t     of the two strings is known but the sizes of both of\n-\t     the arrays they are stored in is, issue a warning if\n-\t     the bound is larger than than the size of the larger\n-\t     of the two arrays.  */\n-\n-\t  access_ref ref1 (arg3, true);\n-\t  access_ref ref2 (arg3, true);\n-\n-\t  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n-\t  get_size_range (arg3, bndrng, ref1.bndrng);\n-\n-\t  tree size1 = compute_objsize (arg1, 1, &ref1);\n-\t  tree size2 = compute_objsize (arg2, 1, &ref2);\n-\t  tree func = get_callee_fndecl (exp);\n-\n-\t  if (size1 && size2 && bndrng[0] && !integer_zerop (bndrng[0]))\n-\t    {\n-\t      offset_int rem1 = ref1.size_remaining ();\n-\t      offset_int rem2 = ref2.size_remaining ();\n-\t      if (rem1 == 0 || rem2 == 0)\n-\t\tmaybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n-\t\t\t\t      bndrng, integer_zero_node);\n-\t      else\n-\t\t{\n-\t\t  offset_int maxrem = wi::max (rem1, rem2, UNSIGNED);\n-\t\t  if (maxrem < wi::to_offset (bndrng[0]))\n-\t\t    maybe_warn_for_bound (OPT_Wstringop_overread, loc, exp,\n-\t\t\t\t\t  func, bndrng,\n-\t\t\t\t\t  wide_int_to_tree (sizetype, maxrem));\n-\t\t}\n-\t    }\n-\t  else if (bndrng[0]\n-\t\t   && !integer_zerop (bndrng[0])\n-\t\t   && ((size1 && integer_zerop (size1))\n-\t\t       || (size2 && integer_zerop (size2))))\n-\t    maybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n-\t\t\t\t  bndrng, integer_zero_node);\n-\t}\n-    }\n-\n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n   result = inline_expand_builtin_bytecmp (exp, target);\n@@ -7544,63 +7219,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_STRCAT:\n-      target = expand_builtin_strcat (exp);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_GETTEXT:\n-    case BUILT_IN_PUTS:\n-    case BUILT_IN_PUTS_UNLOCKED:\n-    case BUILT_IN_STRDUP:\n-      if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n-\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n-      break;\n-\n-    case BUILT_IN_INDEX:\n-    case BUILT_IN_RINDEX:\n-    case BUILT_IN_STRCHR:\n-    case BUILT_IN_STRRCHR:\n-      if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n-      break;\n-\n-    case BUILT_IN_FPUTS:\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0));\n-      break;\n-\n-    case BUILT_IN_STRNDUP:\n-      if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-\tcheck_read_access (exp, CALL_EXPR_ARG (exp, 0), CALL_EXPR_ARG (exp, 1));\n-      break;\n-\n-    case BUILT_IN_STRCASECMP:\n-    case BUILT_IN_STRPBRK:\n-    case BUILT_IN_STRSPN:\n-    case BUILT_IN_STRCSPN:\n-    case BUILT_IN_STRSTR:\n-      if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-\t{\n-\t  check_read_access (exp, CALL_EXPR_ARG (exp, 0));\n-\t  check_read_access (exp, CALL_EXPR_ARG (exp, 1));\n-\t}\n-      break;\n-\n     case BUILT_IN_STRCPY:\n       target = expand_builtin_strcpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n \n-    case BUILT_IN_STRNCAT:\n-      target = expand_builtin_strncat (exp, target);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_STRNCPY:\n       target = expand_builtin_strncpy (exp, target);\n       if (target)\n@@ -7613,18 +7237,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_STPNCPY:\n-      target = expand_builtin_stpncpy (exp, target);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_MEMCHR:\n-      target = expand_builtin_memchr (exp, target);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_MEMCPY:\n       target = expand_builtin_memcpy (exp, target);\n       if (target)\n@@ -8626,8 +8238,11 @@ fold_builtin_strlen (location_t loc, tree expr, tree type, tree arg)\n       if (len)\n \treturn fold_convert_loc (loc, type, len);\n \n+      /* TODO: Move this to gimple-ssa-warn-access once the pass runs\n+\t also early enough to detect invalid reads in multimensional\n+\t arrays and struct members.  */\n       if (!lendata.decl)\n-\tc_strlen (arg, 1, &lendata);\n+\t c_strlen (arg, 1, &lendata);\n \n       if (lendata.decl)\n \t{"}, {"sha": "16b47ac1a7b37bedbeda7cfaec3e5d6e984437a7", "filename": "gcc/builtins.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -151,8 +151,4 @@ extern internal_fn replacement_internal_fn (gcall *);\n \n extern bool builtin_with_linkage_p (tree);\n \n-class access_data;\n-extern bool check_access (tree, tree, tree, tree, tree,\n-\t\t\t  access_mode, const access_data * = NULL);\n-\n #endif /* GCC_BUILTINS_H */"}, {"sha": "fcb0d6dec69e20bcb0b7acad26d377244d3fd171", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 309, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -61,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attr-fnspec.h\"\n #include \"value-query.h\"\n #include \"pointer-query.h\"\n-\n+#include \"gimple-ssa-warn-access.h\"\n #include \"tree-pretty-print.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n@@ -1614,314 +1614,6 @@ get_attr_nonstring_decl (tree expr, tree *ref)\n   return NULL_TREE;\n }\n \n-/* Warn about passing a non-string array/pointer to a built-in function\n-   that expects a nul-terminated string argument.  Returns true if\n-   a warning has been issued.*/\n-\n-bool\n-maybe_warn_nonstring_arg (tree fndecl, tree exp)\n-{\n-  if (!fndecl || !fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n-    return false;\n-\n-  if (!warn_stringop_overread || warning_suppressed_p (exp, OPT_Wstringop_overread))\n-    return false;\n-\n-  /* Avoid clearly invalid calls (more checking done below).  */\n-  unsigned nargs = call_expr_nargs (exp);\n-  if (!nargs)\n-    return false;\n-\n-  /* The bound argument to a bounded string function like strncpy.  */\n-  tree bound = NULL_TREE;\n-\n-  /* The longest known or possible string argument to one of the comparison\n-     functions.  If the length is less than the bound it is used instead.\n-     Since the length is only used for warning and not for code generation\n-     disable strict mode in the calls to get_range_strlen below.  */\n-  tree maxlen = NULL_TREE;\n-\n-  /* It's safe to call \"bounded\" string functions with a non-string\n-     argument since the functions provide an explicit bound for this\n-     purpose.  The exception is strncat where the bound may refer to\n-     either the destination or the source.  */\n-  int fncode = DECL_FUNCTION_CODE (fndecl);\n-  switch (fncode)\n-    {\n-    case BUILT_IN_STRCMP:\n-    case BUILT_IN_STRNCMP:\n-    case BUILT_IN_STRNCASECMP:\n-      {\n-\t/* For these, if one argument refers to one or more of a set\n-\t   of string constants or arrays of known size, determine\n-\t   the range of their known or possible lengths and use it\n-\t   conservatively as the bound for the unbounded function,\n-\t   and to adjust the range of the bound of the bounded ones.  */\n-\tfor (unsigned argno = 0;\n-\t     argno < MIN (nargs, 2)\n-\t       && !(maxlen && TREE_CODE (maxlen) == INTEGER_CST); argno++)\n-\t  {\n-\t    tree arg = CALL_EXPR_ARG (exp, argno);\n-\t    if (!get_attr_nonstring_decl (arg))\n-\t      {\n-\t\tc_strlen_data lendata = { };\n-\t\t/* Set MAXBOUND to an arbitrary non-null non-integer\n-\t\t   node as a request to have it set to the length of\n-\t\t   the longest string in a PHI.  */\n-\t\tlendata.maxbound = arg;\n-\t\tget_range_strlen (arg, &lendata, /* eltsize = */ 1);\n-\t\tmaxlen = lendata.maxbound;\n-\t      }\n-\t  }\n-      }\n-      /* Fall through.  */\n-\n-    case BUILT_IN_STRNCAT:\n-    case BUILT_IN_STPNCPY:\n-    case BUILT_IN_STRNCPY:\n-      if (nargs > 2)\n-\tbound = CALL_EXPR_ARG (exp, 2);\n-      break;\n-\n-    case BUILT_IN_STRNDUP:\n-      if (nargs > 1)\n-\tbound = CALL_EXPR_ARG (exp, 1);\n-      break;\n-\n-    case BUILT_IN_STRNLEN:\n-      {\n-\ttree arg = CALL_EXPR_ARG (exp, 0);\n-\tif (!get_attr_nonstring_decl (arg))\n-\t  {\n-\t    c_strlen_data lendata = { };\n-\t    /* Set MAXBOUND to an arbitrary non-null non-integer\n-\t       node as a request to have it set to the length of\n-\t       the longest string in a PHI.  */\n-\t    lendata.maxbound = arg;\n-\t    get_range_strlen (arg, &lendata, /* eltsize = */ 1);\n-\t    maxlen = lendata.maxbound;\n-\t  }\n-\tif (nargs > 1)\n-\t  bound = CALL_EXPR_ARG (exp, 1);\n-\tbreak;\n-      }\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Determine the range of the bound argument (if specified).  */\n-  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n-  if (bound)\n-    {\n-      STRIP_NOPS (bound);\n-      get_size_range (bound, bndrng);\n-    }\n-\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  if (bndrng[0])\n-    {\n-      /* Diagnose excessive bound prior to the adjustment below and\n-\t regardless of attribute nonstring.  */\n-      tree maxobjsize = max_object_size ();\n-      if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n-\t{\n-\t  bool warned = false;\n-\t  if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%qD specified bound %E \"\n-\t\t\t\t \"exceeds maximum object size %E\",\n-\t\t\t\t fndecl, bndrng[0], maxobjsize);\n-\t  else\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%qD specified bound [%E, %E] \"\n-\t\t\t\t \"exceeds maximum object size %E\",\n-\t\t\t\t fndecl, bndrng[0], bndrng[1],\n-\t\t\t\t maxobjsize);\n-\t  if (warned)\n-\t    suppress_warning (exp, OPT_Wstringop_overread);\n-\n-\t  return warned;\n-\t}\n-    }\n-\n-  if (maxlen && !integer_all_onesp (maxlen))\n-    {\n-      /* Add one for the nul.  */\n-      maxlen = const_binop (PLUS_EXPR, TREE_TYPE (maxlen), maxlen,\n-\t\t\t    size_one_node);\n-\n-      if (!bndrng[0])\n-\t{\n-\t  /* Conservatively use the upper bound of the lengths for\n-\t     both the lower and the upper bound of the operation.  */\n-\t  bndrng[0] = maxlen;\n-\t  bndrng[1] = maxlen;\n-\t  bound = void_type_node;\n-\t}\n-      else if (maxlen)\n-\t{\n-\t  /* Replace the bound on the operation with the upper bound\n-\t     of the length of the string if the latter is smaller.  */\n-\t  if (tree_int_cst_lt (maxlen, bndrng[0]))\n-\t    bndrng[0] = maxlen;\n-\t  else if (tree_int_cst_lt (maxlen, bndrng[1]))\n-\t    bndrng[1] = maxlen;\n-\t}\n-    }\n-\n-  bool any_arg_warned = false;\n-  /* Iterate over the built-in function's formal arguments and check\n-     each const char* against the actual argument.  If the actual\n-     argument is declared attribute non-string issue a warning unless\n-     the argument's maximum length is bounded.  */\n-  function_args_iterator it;\n-  function_args_iter_init (&it, TREE_TYPE (fndecl));\n-\n-  for (unsigned argno = 0; ; ++argno, function_args_iter_next (&it))\n-    {\n-      /* Avoid iterating past the declared argument in a call\n-\t to function declared without a prototype.  */\n-      if (argno >= nargs)\n-\tbreak;\n-\n-      tree argtype = function_args_iter_cond (&it);\n-      if (!argtype)\n-\tbreak;\n-\n-      if (TREE_CODE (argtype) != POINTER_TYPE)\n-\tcontinue;\n-\n-      argtype = TREE_TYPE (argtype);\n-\n-      if (TREE_CODE (argtype) != INTEGER_TYPE\n-\t  || !TYPE_READONLY (argtype))\n-\tcontinue;\n-\n-      argtype = TYPE_MAIN_VARIANT (argtype);\n-      if (argtype != char_type_node)\n-\tcontinue;\n-\n-      tree callarg = CALL_EXPR_ARG (exp, argno);\n-      if (TREE_CODE (callarg) == ADDR_EXPR)\n-\tcallarg = TREE_OPERAND (callarg, 0);\n-\n-      /* See if the destination is declared with attribute \"nonstring\".  */\n-      tree decl = get_attr_nonstring_decl (callarg);\n-      if (!decl)\n-\tcontinue;\n-\n-      /* The maximum number of array elements accessed.  */\n-      offset_int wibnd = 0;\n-\n-      if (argno && fncode == BUILT_IN_STRNCAT)\n-\t{\n-\t  /* See if the bound in strncat is derived from the length\n-\t     of the strlen of the destination (as it's expected to be).\n-\t     If so, reset BOUND and FNCODE to trigger a warning.  */\n-\t  tree dstarg = CALL_EXPR_ARG (exp, 0);\n-\t  if (is_strlen_related_p (dstarg, bound))\n-\t    {\n-\t      /* The bound applies to the destination, not to the source,\n-\t\t so reset these to trigger a warning without mentioning\n-\t\t the bound.  */\n-\t      bound = NULL;\n-\t      fncode = 0;\n-\t    }\n-\t  else if (bndrng[1])\n-\t    /* Use the upper bound of the range for strncat.  */\n-\t    wibnd = wi::to_offset (bndrng[1]);\n-\t}\n-      else if (bndrng[0])\n-\t/* Use the lower bound of the range for functions other than\n-\t   strncat.  */\n-\twibnd = wi::to_offset (bndrng[0]);\n-\n-      /* Determine the size of the argument array if it is one.  */\n-      offset_int asize = wibnd;\n-      bool known_size = false;\n-      tree type = TREE_TYPE (decl);\n-\n-      /* Determine the array size.  For arrays of unknown bound and\n-\t pointers reset BOUND to trigger the appropriate warning.  */\n-      if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  if (tree arrbnd = TYPE_DOMAIN (type))\n-\t    {\n-\t      if ((arrbnd = TYPE_MAX_VALUE (arrbnd)))\n-\t\t{\n-\t\t  asize = wi::to_offset (arrbnd) + 1;\n-\t\t  known_size = true;\n-\t\t}\n-\t    }\n-\t  else if (bound == void_type_node)\n-\t    bound = NULL_TREE;\n-\t}\n-      else if (bound == void_type_node)\n-\tbound = NULL_TREE;\n-\n-      /* In a call to strncat with a bound in a range whose lower but\n-\t not upper bound is less than the array size, reset ASIZE to\n-\t be the same as the bound and the other variable to trigger\n-\t the apprpriate warning below.  */\n-      if (fncode == BUILT_IN_STRNCAT\n-\t  && bndrng[0] != bndrng[1]\n-\t  && wi::ltu_p (wi::to_offset (bndrng[0]), asize)\n-\t  && (!known_size\n-\t      || wi::ltu_p (asize, wibnd)))\n-\t{\n-\t  asize = wibnd;\n-\t  bound = NULL_TREE;\n-\t  fncode = 0;\n-\t}\n-\n-      bool warned = false;\n-\n-      auto_diagnostic_group d;\n-      if (wi::ltu_p (asize, wibnd))\n-\t{\n-\t  if (bndrng[0] == bndrng[1])\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%qD argument %i declared attribute \"\n-\t\t\t\t \"%<nonstring%> is smaller than the specified \"\n-\t\t\t\t \"bound %wu\",\n-\t\t\t\t fndecl, argno + 1, wibnd.to_uhwi ());\n-\t  else if (wi::ltu_p (asize, wi::to_offset (bndrng[0])))\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%qD argument %i declared attribute \"\n-\t\t\t\t \"%<nonstring%> is smaller than \"\n-\t\t\t\t \"the specified bound [%E, %E]\",\n-\t\t\t\t fndecl, argno + 1, bndrng[0], bndrng[1]);\n-\t  else\n-\t    warned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t\t \"%qD argument %i declared attribute \"\n-\t\t\t\t \"%<nonstring%> may be smaller than \"\n-\t\t\t\t \"the specified bound [%E, %E]\",\n-\t\t\t\t fndecl, argno + 1, bndrng[0], bndrng[1]);\n-\t}\n-      else if (fncode == BUILT_IN_STRNCAT)\n-\t; /* Avoid warning for calls to strncat() when the bound\n-\t     is equal to the size of the non-string argument.  */\n-      else if (!bound)\n-\twarned = warning_at (loc, OPT_Wstringop_overread,\n-\t\t\t     \"%qD argument %i declared attribute %<nonstring%>\",\n-\t\t\t     fndecl, argno + 1);\n-\n-      if (warned)\n-\t{\n-\t  inform (DECL_SOURCE_LOCATION (decl),\n-\t\t  \"argument %qD declared here\", decl);\n-\t  any_arg_warned = true;\n-\t}\n-    }\n-\n-  if (any_arg_warned)\n-    suppress_warning (exp, OPT_Wstringop_overread);\n-\n-  return any_arg_warned;\n-}\n-\n /* Issue an error if CALL_EXPR was flagged as requiring\n    tall-call optimization.  */\n "}, {"sha": "5e961e1b9f9b3caab1f8ef093e3d0cd1ee2f9d38", "filename": "gcc/diagnostic-spec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fdiagnostic-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fdiagnostic-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-spec.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -84,6 +84,7 @@ nowarn_spec_t::nowarn_spec_t (opt_code opt)\n     case OPT_Wformat_overflow_:\n     case OPT_Wformat_truncation_:\n     case OPT_Wrestrict:\n+    case OPT_Wsizeof_pointer_memaccess:\n     case OPT_Wstrict_aliasing_:\n     case OPT_Wstringop_overflow_:\n     case OPT_Wstringop_overread:"}, {"sha": "3f2c176cff6db0ac0c90add00002d3d3312d5eb8", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -2073,7 +2073,7 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n       if (!warning_suppressed_p (stmt, OPT_Wstringop_overread))\n-\twarn_string_no_nul (loc, NULL_TREE, \"strcpy\", src, nonstr);\n+\twarn_string_no_nul (loc, stmt, \"strcpy\", src, nonstr);\n       suppress_warning (stmt, OPT_Wstringop_overread);\n       return false;\n     }\n@@ -3291,7 +3291,7 @@ gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n       if (!warning_suppressed_p (stmt, OPT_Wstringop_overread))\n-\twarn_string_no_nul (loc, NULL_TREE, \"stpcpy\", src, data.decl, size,\n+\twarn_string_no_nul (loc, stmt, \"stpcpy\", src, data.decl, size,\n \t\t\t    exact);\n       suppress_warning (stmt, OPT_Wstringop_overread);\n       return false;"}, {"sha": "a4559ddb5b3e8a329a9887e5e18fedb88db0921f", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 1001, "deletions": 84, "changes": 1085, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -40,6 +40,7 @@\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n #include \"tree-object-size.h\"\n+#include \"tree-ssa-strlen.h\"\n #include \"calls.h\"\n #include \"cfgloop.h\"\n #include \"intl.h\"\n@@ -49,17 +50,94 @@\n #include \"demangle.h\"\n #include \"pointer-query.h\"\n \n+/* Return true if STMT has an associated location.  */\n+\n+static inline location_t\n+has_location (const gimple *stmt)\n+{\n+  return gimple_has_location (stmt);\n+}\n+\n+/* Return true if tree node X has an associated location.  */\n+\n+static inline location_t\n+has_location (const_tree x)\n+{\n+  if (DECL_P (x))\n+    return DECL_SOURCE_LOCATION (x) != UNKNOWN_LOCATION;\n+\n+  if (EXPR_P (x))\n+    return EXPR_HAS_LOCATION (x);\n+\n+  return false;\n+}\n+\n+/* Return the associated location of STMT.  */\n+\n+static inline location_t\n+get_location (const gimple *stmt)\n+{\n+  return gimple_location (stmt);\n+}\n+\n+/* Return the associated location of tree node X.  */\n+\n+static inline location_t\n+get_location (tree x)\n+{\n+  if (DECL_P (x))\n+    return DECL_SOURCE_LOCATION (x);\n+\n+  if (EXPR_P (x))\n+    return EXPR_LOCATION (x);\n+\n+  return UNKNOWN_LOCATION;\n+}\n+\n+/* Overload of the nascent tree function for GIMPLE STMT.  */\n+\n+static inline tree\n+get_callee_fndecl (const gimple *stmt)\n+{\n+  return gimple_call_fndecl (stmt);\n+}\n+\n+static inline unsigned\n+call_nargs (const gimple *stmt)\n+{\n+  return gimple_call_num_args (stmt);\n+}\n+\n+static inline unsigned\n+call_nargs (const_tree expr)\n+{\n+  return call_expr_nargs (expr);\n+}\n+\n+\n+static inline tree\n+call_arg (const gimple *stmt, unsigned argno)\n+{\n+  return gimple_call_arg (stmt, argno);\n+}\n+\n+static inline tree\n+call_arg (tree expr, unsigned argno)\n+{\n+  return CALL_EXPR_ARG (expr, argno);\n+}\n+\n /* For a call EXPR at LOC to a function FNAME that expects a string\n    in the argument ARG, issue a diagnostic due to it being a called\n    with an argument that is a character array with no terminating\n    NUL.  SIZE is the EXACT size of the array, and BNDRNG the number\n    of characters in which the NUL is expected.  Either EXPR or FNAME\n    may be null but noth both.  SIZE may be null when BNDRNG is null.  */\n \n-void\n-warn_string_no_nul (location_t loc, tree expr, const char *fname,\n-\t\t    tree arg, tree decl, tree size /* = NULL_TREE */,\n-\t\t    bool exact /* = false */,\n+template <class GimpleOrTree>\n+static void\n+warn_string_no_nul (location_t loc, GimpleOrTree expr, const char *fname,\n+\t\t    tree arg, tree decl, tree size, bool exact,\n \t\t    const wide_int bndrng[2] /* = NULL */)\n {\n   const opt_code opt = OPT_Wstringop_overread;\n@@ -152,24 +230,88 @@ warn_string_no_nul (location_t loc, tree expr, const char *fname,\n \n   if (warned)\n     {\n-      inform (DECL_SOURCE_LOCATION (decl),\n+      inform (get_location (decl),\n \t      \"referenced argument declared here\");\n       suppress_warning (arg, opt);\n       if (expr)\n \tsuppress_warning (expr, opt);\n     }\n }\n \n+void\n+warn_string_no_nul (location_t loc, gimple *stmt, const char *fname,\n+\t\t    tree arg, tree decl, tree size /* = NULL_TREE */,\n+\t\t    bool exact /* = false */,\n+\t\t    const wide_int bndrng[2] /* = NULL */)\n+{\n+  return warn_string_no_nul<gimple *> (loc, stmt, fname,\n+\t\t\t\t       arg, decl, size, exact, bndrng);\n+}\n+\n+void\n+warn_string_no_nul (location_t loc, tree expr, const char *fname,\n+\t\t    tree arg, tree decl, tree size /* = NULL_TREE */,\n+\t\t    bool exact /* = false */,\n+\t\t    const wide_int bndrng[2] /* = NULL */)\n+{\n+  return warn_string_no_nul<tree> (loc, expr, fname,\n+\t\t\t\t   arg, decl, size, exact, bndrng);\n+}\n+\n+/* If EXP refers to an unterminated constant character array return\n+   the declaration of the object of which the array is a member or\n+   element and if SIZE is not null, set *SIZE to the size of\n+   the unterminated array and set *EXACT if the size is exact or\n+   clear it otherwise.  Otherwise return null.  */\n+\n+tree\n+unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n+{\n+  /* C_STRLEN will return NULL and set DECL in the info\n+     structure if EXP references a unterminated array.  */\n+  c_strlen_data lendata = { };\n+  tree len = c_strlen (exp, 1, &lendata);\n+  if (len || !lendata.minlen || !lendata.decl)\n+    return NULL_TREE;\n+\n+  if (!size)\n+    return lendata.decl;\n+\n+  len = lendata.minlen;\n+  if (lendata.off)\n+    {\n+      /* Constant offsets are already accounted for in LENDATA.MINLEN,\n+\t but not in a SSA_NAME + CST expression.  */\n+      if (TREE_CODE (lendata.off) == INTEGER_CST)\n+\t*exact = true;\n+      else if (TREE_CODE (lendata.off) == PLUS_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (lendata.off, 1)) == INTEGER_CST)\n+\t{\n+\t  /* Subtract the offset from the size of the array.  */\n+\t  *exact = false;\n+\t  tree temp = TREE_OPERAND (lendata.off, 1);\n+\t  temp = fold_convert (ssizetype, temp);\n+\t  len = fold_build2 (MINUS_EXPR, ssizetype, len, temp);\n+\t}\n+      else\n+\t*exact = false;\n+    }\n+  else\n+    *exact = true;\n+\n+  *size = len;\n+  return lendata.decl;\n+}\n+\n /* For a call EXPR (which may be null) that expects a string argument\n    SRC as an argument, returns false if SRC is a character array with\n    no terminating NUL.  When nonnull, BOUND is the number of characters\n-   in which to expect the terminating NUL.  RDONLY is true for read-only\n-   accesses such as strcmp, false for read-write such as strcpy.  When\n-   EXPR is also issues a warning.  */\n+   in which to expect the terminating NUL.  When EXPR is nonnull also\n+   issues a warning.  */\n \n-bool\n-check_nul_terminated_array (tree expr, tree src,\n-\t\t\t    tree bound /* = NULL_TREE */)\n+template <class GimpleOrTree>\n+static bool\n+check_nul_terminated_array (GimpleOrTree expr, tree src, tree bound)\n {\n   /* The constant size of the array SRC points to.  The actual size\n      may be less of EXACT is true, but not more.  */\n@@ -208,66 +350,355 @@ check_nul_terminated_array (tree expr, tree src,\n     }\n \n   if (expr)\n-    warn_string_no_nul (EXPR_LOCATION (expr), expr, NULL, src, nonstr,\n+    warn_string_no_nul (get_location (expr), expr, NULL, src, nonstr,\n \t\t\tsize, exact, bound ? bndrng : NULL);\n \n   return false;\n }\n \n-/* If EXP refers to an unterminated constant character array return\n-   the declaration of the object of which the array is a member or\n-   element and if SIZE is not null, set *SIZE to the size of\n-   the unterminated array and set *EXACT if the size is exact or\n-   clear it otherwise.  Otherwise return null.  */\n+bool\n+check_nul_terminated_array (gimple *stmt, tree src, tree bound /* = NULL_TREE */)\n+{\n+  return check_nul_terminated_array<gimple *>(stmt, src, bound);\n+}\n \n-tree\n-unterminated_array (tree exp, tree *size /* = NULL */, bool *exact /* = NULL */)\n+bool\n+check_nul_terminated_array (tree expr, tree src, tree bound /* = NULL_TREE */)\n {\n-  /* C_STRLEN will return NULL and set DECL in the info\n-     structure if EXP references a unterminated array.  */\n-  c_strlen_data lendata = { };\n-  tree len = c_strlen (exp, 1, &lendata);\n-  if (len == NULL_TREE && lendata.minlen && lendata.decl)\n-     {\n-       if (size)\n+  return check_nul_terminated_array<tree>(expr, src, bound);\n+}\n+\n+/* Warn about passing a non-string array/pointer to a built-in function\n+   that expects a nul-terminated string argument.  Returns true if\n+   a warning has been issued.*/\n+\n+template <class GimpleOrTree>\n+static bool\n+maybe_warn_nonstring_arg (tree fndecl, GimpleOrTree exp)\n+{\n+  if (!fndecl || !fndecl_built_in_p (fndecl, BUILT_IN_NORMAL))\n+    return false;\n+\n+  if (!warn_stringop_overread\n+      || warning_suppressed_p (exp, OPT_Wstringop_overread))\n+    return false;\n+\n+  /* Avoid clearly invalid calls (more checking done below).  */\n+  unsigned nargs = call_nargs (exp);\n+  if (!nargs)\n+    return false;\n+\n+  /* The bound argument to a bounded string function like strncpy.  */\n+  tree bound = NULL_TREE;\n+\n+  /* The longest known or possible string argument to one of the comparison\n+     functions.  If the length is less than the bound it is used instead.\n+     Since the length is only used for warning and not for code generation\n+     disable strict mode in the calls to get_range_strlen below.  */\n+  tree maxlen = NULL_TREE;\n+\n+  /* It's safe to call \"bounded\" string functions with a non-string\n+     argument since the functions provide an explicit bound for this\n+     purpose.  The exception is strncat where the bound may refer to\n+     either the destination or the source.  */\n+  int fncode = DECL_FUNCTION_CODE (fndecl);\n+  switch (fncode)\n+    {\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCASECMP:\n+      {\n+\t/* For these, if one argument refers to one or more of a set\n+\t   of string constants or arrays of known size, determine\n+\t   the range of their known or possible lengths and use it\n+\t   conservatively as the bound for the unbounded function,\n+\t   and to adjust the range of the bound of the bounded ones.  */\n+\tfor (unsigned argno = 0;\n+\t     argno < MIN (nargs, 2)\n+\t       && !(maxlen && TREE_CODE (maxlen) == INTEGER_CST); argno++)\n+\t  {\n+\t    tree arg = call_arg (exp, argno);\n+\t    if (!get_attr_nonstring_decl (arg))\n+\t      {\n+\t\tc_strlen_data lendata = { };\n+\t\t/* Set MAXBOUND to an arbitrary non-null non-integer\n+\t\t   node as a request to have it set to the length of\n+\t\t   the longest string in a PHI.  */\n+\t\tlendata.maxbound = arg;\n+\t\tget_range_strlen (arg, &lendata, /* eltsize = */ 1);\n+\t\tmaxlen = lendata.maxbound;\n+\t      }\n+\t  }\n+      }\n+      /* Fall through.  */\n+\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STRNCPY:\n+      if (nargs > 2)\n+\tbound = call_arg (exp, 2);\n+      break;\n+\n+    case BUILT_IN_STRNDUP:\n+      if (nargs < 2)\n+\treturn false;\n+      bound = call_arg (exp, 1);\n+      break;\n+\n+    case BUILT_IN_STRNLEN:\n+      {\n+\ttree arg = call_arg (exp, 0);\n+\tif (!get_attr_nonstring_decl (arg))\n+\t  {\n+\t    c_strlen_data lendata = { };\n+\t    /* Set MAXBOUND to an arbitrary non-null non-integer\n+\t       node as a request to have it set to the length of\n+\t       the longest string in a PHI.  */\n+\t    lendata.maxbound = arg;\n+\t    get_range_strlen (arg, &lendata, /* eltsize = */ 1);\n+\t    maxlen = lendata.maxbound;\n+\t  }\n+\tif (nargs > 1)\n+\t  bound = call_arg (exp, 1);\n+\tbreak;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Determine the range of the bound argument (if specified).  */\n+  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n+  if (bound)\n+    {\n+      STRIP_NOPS (bound);\n+      get_size_range (bound, bndrng);\n+    }\n+\n+  location_t loc = get_location (exp);\n+\n+  if (bndrng[0])\n+    {\n+      /* Diagnose excessive bound prior to the adjustment below and\n+\t regardless of attribute nonstring.  */\n+      tree maxobjsize = max_object_size ();\n+      if (tree_int_cst_lt (maxobjsize, bndrng[0]))\n \t{\n-\t  len = lendata.minlen;\n-\t  if (lendata.off)\n+\t  bool warned = false;\n+\t  if (tree_int_cst_equal (bndrng[0], bndrng[1]))\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qD specified bound %E \"\n+\t\t\t\t \"exceeds maximum object size %E\",\n+\t\t\t\t fndecl, bndrng[0], maxobjsize);\n+\t  else\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qD specified bound [%E, %E] \"\n+\t\t\t\t \"exceeds maximum object size %E\",\n+\t\t\t\t fndecl, bndrng[0], bndrng[1],\n+\t\t\t\t maxobjsize);\n+\t  if (warned)\n+\t    suppress_warning (exp, OPT_Wstringop_overread);\n+\n+\t  return warned;\n+\t}\n+    }\n+\n+  if (maxlen && !integer_all_onesp (maxlen))\n+    {\n+      /* Add one for the nul.  */\n+      maxlen = const_binop (PLUS_EXPR, TREE_TYPE (maxlen), maxlen,\n+\t\t\t    size_one_node);\n+\n+      if (!bndrng[0])\n+\t{\n+\t  /* Conservatively use the upper bound of the lengths for\n+\t     both the lower and the upper bound of the operation.  */\n+\t  bndrng[0] = maxlen;\n+\t  bndrng[1] = maxlen;\n+\t  bound = void_type_node;\n+\t}\n+      else if (maxlen)\n+\t{\n+\t  /* Replace the bound on the operation with the upper bound\n+\t     of the length of the string if the latter is smaller.  */\n+\t  if (tree_int_cst_lt (maxlen, bndrng[0]))\n+\t    bndrng[0] = maxlen;\n+\t  else if (tree_int_cst_lt (maxlen, bndrng[1]))\n+\t    bndrng[1] = maxlen;\n+\t}\n+    }\n+\n+  bool any_arg_warned = false;\n+  /* Iterate over the built-in function's formal arguments and check\n+     each const char* against the actual argument.  If the actual\n+     argument is declared attribute non-string issue a warning unless\n+     the argument's maximum length is bounded.  */\n+  function_args_iterator it;\n+  function_args_iter_init (&it, TREE_TYPE (fndecl));\n+\n+  for (unsigned argno = 0; ; ++argno, function_args_iter_next (&it))\n+    {\n+      /* Avoid iterating past the declared argument in a call\n+\t to function declared without a prototype.  */\n+      if (argno >= nargs)\n+\tbreak;\n+\n+      tree argtype = function_args_iter_cond (&it);\n+      if (!argtype)\n+\tbreak;\n+\n+      if (TREE_CODE (argtype) != POINTER_TYPE)\n+\tcontinue;\n+\n+      argtype = TREE_TYPE (argtype);\n+\n+      if (TREE_CODE (argtype) != INTEGER_TYPE\n+\t  || !TYPE_READONLY (argtype))\n+\tcontinue;\n+\n+      argtype = TYPE_MAIN_VARIANT (argtype);\n+      if (argtype != char_type_node)\n+\tcontinue;\n+\n+      tree callarg = call_arg (exp, argno);\n+      if (TREE_CODE (callarg) == ADDR_EXPR)\n+\tcallarg = TREE_OPERAND (callarg, 0);\n+\n+      /* See if the destination is declared with attribute \"nonstring\".  */\n+      tree decl = get_attr_nonstring_decl (callarg);\n+      if (!decl)\n+\tcontinue;\n+\n+      /* The maximum number of array elements accessed.  */\n+      offset_int wibnd = 0;\n+\n+      if (argno && fncode == BUILT_IN_STRNCAT)\n+\t{\n+\t  /* See if the bound in strncat is derived from the length\n+\t     of the strlen of the destination (as it's expected to be).\n+\t     If so, reset BOUND and FNCODE to trigger a warning.  */\n+\t  tree dstarg = call_arg (exp, 0);\n+\t  if (is_strlen_related_p (dstarg, bound))\n+\t    {\n+\t      /* The bound applies to the destination, not to the source,\n+\t\t so reset these to trigger a warning without mentioning\n+\t\t the bound.  */\n+\t      bound = NULL;\n+\t      fncode = 0;\n+\t    }\n+\t  else if (bndrng[1])\n+\t    /* Use the upper bound of the range for strncat.  */\n+\t    wibnd = wi::to_offset (bndrng[1]);\n+\t}\n+      else if (bndrng[0])\n+\t/* Use the lower bound of the range for functions other than\n+\t   strncat.  */\n+\twibnd = wi::to_offset (bndrng[0]);\n+\n+      /* Determine the size of the argument array if it is one.  */\n+      offset_int asize = wibnd;\n+      bool known_size = false;\n+      tree type = TREE_TYPE (decl);\n+\n+      /* Determine the array size.  For arrays of unknown bound and\n+\t pointers reset BOUND to trigger the appropriate warning.  */\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  if (tree arrbnd = TYPE_DOMAIN (type))\n \t    {\n-\t      /* Constant offsets are already accounted for in LENDATA.MINLEN,\n-\t\t but not in a SSA_NAME + CST expression.  */\n-\t      if (TREE_CODE (lendata.off) == INTEGER_CST)\n-\t\t*exact = true;\n-\t      else if (TREE_CODE (lendata.off) == PLUS_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND (lendata.off, 1)) == INTEGER_CST)\n+\t      if ((arrbnd = TYPE_MAX_VALUE (arrbnd)))\n \t\t{\n-\t\t  /* Subtract the offset from the size of the array.  */\n-\t\t  *exact = false;\n-\t\t  tree temp = TREE_OPERAND (lendata.off, 1);\n-\t\t  temp = fold_convert (ssizetype, temp);\n-\t\t  len = fold_build2 (MINUS_EXPR, ssizetype, len, temp);\n+\t\t  asize = wi::to_offset (arrbnd) + 1;\n+\t\t  known_size = true;\n \t\t}\n-\t      else\n-\t\t*exact = false;\n \t    }\n+\t  else if (bound == void_type_node)\n+\t    bound = NULL_TREE;\n+\t}\n+      else if (bound == void_type_node)\n+\tbound = NULL_TREE;\n+\n+      /* In a call to strncat with a bound in a range whose lower but\n+\t not upper bound is less than the array size, reset ASIZE to\n+\t be the same as the bound and the other variable to trigger\n+\t the apprpriate warning below.  */\n+      if (fncode == BUILT_IN_STRNCAT\n+\t  && bndrng[0] != bndrng[1]\n+\t  && wi::ltu_p (wi::to_offset (bndrng[0]), asize)\n+\t  && (!known_size\n+\t      || wi::ltu_p (asize, wibnd)))\n+\t{\n+\t  asize = wibnd;\n+\t  bound = NULL_TREE;\n+\t  fncode = 0;\n+\t}\n+\n+      bool warned = false;\n+\n+      auto_diagnostic_group d;\n+      if (wi::ltu_p (asize, wibnd))\n+\t{\n+\t  if (bndrng[0] == bndrng[1])\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qD argument %i declared attribute \"\n+\t\t\t\t \"%<nonstring%> is smaller than the specified \"\n+\t\t\t\t \"bound %wu\",\n+\t\t\t\t fndecl, argno + 1, wibnd.to_uhwi ());\n+\t  else if (wi::ltu_p (asize, wi::to_offset (bndrng[0])))\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qD argument %i declared attribute \"\n+\t\t\t\t \"%<nonstring%> is smaller than \"\n+\t\t\t\t \"the specified bound [%E, %E]\",\n+\t\t\t\t fndecl, argno + 1, bndrng[0], bndrng[1]);\n \t  else\n-\t    *exact = true;\n+\t    warned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t\t \"%qD argument %i declared attribute \"\n+\t\t\t\t \"%<nonstring%> may be smaller than \"\n+\t\t\t\t \"the specified bound [%E, %E]\",\n+\t\t\t\t fndecl, argno + 1, bndrng[0], bndrng[1]);\n+\t}\n+      else if (fncode == BUILT_IN_STRNCAT)\n+\t; /* Avoid warning for calls to strncat() when the bound\n+\t     is equal to the size of the non-string argument.  */\n+      else if (!bound)\n+\twarned = warning_at (loc, OPT_Wstringop_overread,\n+\t\t\t     \"%qD argument %i declared attribute %<nonstring%>\",\n+\t\t\t     fndecl, argno + 1);\n \n-\t  *size = len;\n+      if (warned)\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"argument %qD declared here\", decl);\n+\t  any_arg_warned = true;\n \t}\n-       return lendata.decl;\n-     }\n+    }\n+\n+  if (any_arg_warned)\n+    suppress_warning (exp, OPT_Wstringop_overread);\n+\n+  return any_arg_warned;\n+}\n+\n+bool\n+maybe_warn_nonstring_arg (tree fndecl, gimple *stmt)\n+{\n+  return maybe_warn_nonstring_arg<gimple *>(fndecl, stmt);\n+}\n \n-  return NULL_TREE;\n+\n+bool\n+maybe_warn_nonstring_arg (tree fndecl, tree expr)\n+{\n+  return maybe_warn_nonstring_arg<tree>(fndecl, expr);\n }\n \n /* Issue a warning OPT for a bounded call EXP with a bound in RANGE\n    accessing an object with SIZE.  */\n \n-bool\n-maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n-\t\t      tree bndrng[2], tree size,\n-\t\t      const access_data *pad /* = NULL */)\n+template <class GimpleOrTree>\n+static bool\n+maybe_warn_for_bound (opt_code opt, location_t loc, GimpleOrTree exp, tree func,\n+\t\t      tree bndrng[2], tree size, const access_data *pad)\n {\n   if (!bndrng[0] || warning_suppressed_p (exp, opt))\n     return false;\n@@ -352,15 +783,10 @@ maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n \t\t\t\tbndrng[0], bndrng[1], size));\n       if (warned)\n \t{\n-\t  if (pad && pad->src.ref)\n-\t    {\n-\t      if (DECL_P (pad->src.ref))\n-\t\tinform (DECL_SOURCE_LOCATION (pad->src.ref),\n-\t\t\t\"source object declared here\");\n-\t      else if (EXPR_HAS_LOCATION (pad->src.ref))\n-\t\tinform (EXPR_LOCATION (pad->src.ref),\n-\t\t\t\"source object allocated here\");\n-\t    }\n+\t  if (pad && pad->src.ref\n+\t      && has_location (pad->src.ref))\n+\t    inform (get_location (pad->src.ref),\n+\t\t    \"source object allocated here\");\n \t  suppress_warning (exp, opt);\n \t}\n \n@@ -440,31 +866,44 @@ maybe_warn_for_bound (opt_code opt, location_t loc, tree exp, tree func,\n \n   if (warned)\n     {\n-      if (pad && pad->dst.ref)\n-\t{\n-\t  if (DECL_P (pad->dst.ref))\n-\t    inform (DECL_SOURCE_LOCATION (pad->dst.ref),\n-\t\t    \"destination object declared here\");\n-\t  else if (EXPR_HAS_LOCATION (pad->dst.ref))\n-\t    inform (EXPR_LOCATION (pad->dst.ref),\n-\t\t    \"destination object allocated here\");\n-\t}\n+      if (pad && pad->dst.ref\n+\t  && has_location (pad->dst.ref))\n+\tinform (get_location (pad->dst.ref),\n+\t\t\"destination object allocated here\");\n       suppress_warning (exp, opt);\n     }\n \n   return warned;\n }\n \n+bool\n+maybe_warn_for_bound (opt_code opt, location_t loc, gimple *stmt, tree func,\n+\t\t      tree bndrng[2], tree size,\n+\t\t      const access_data *pad /* = NULL */)\n+{\n+  return maybe_warn_for_bound<gimple *> (opt, loc, stmt, func, bndrng, size,\n+\t\t\t\t\t pad);\n+}\n+\n+bool\n+maybe_warn_for_bound (opt_code opt, location_t loc, tree expr, tree func,\n+\t\t      tree bndrng[2], tree size,\n+\t\t      const access_data *pad /* = NULL */)\n+{\n+  return maybe_warn_for_bound<tree> (opt, loc, expr, func, bndrng, size, pad);\n+}\n+\n /* For an expression EXP issue an access warning controlled by option OPT\n    with access to a region SIZE bytes in size in the RANGE of sizes.\n    WRITE is true for a write access, READ for a read access, neither for\n    call that may or may not perform an access but for which the range\n    is expected to valid.\n    Returns true when a warning has been issued.  */\n \n+template <class GimpleOrTree>\n static bool\n-warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n-\t\t tree size, bool write, bool read, bool maybe)\n+warn_for_access (location_t loc, tree func, GimpleOrTree exp, int opt,\n+\t\t tree range[2], tree size, bool write, bool read, bool maybe)\n {\n   bool warned = false;\n \n@@ -719,6 +1158,22 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n   return warned;\n }\n \n+static bool\n+warn_for_access (location_t loc, tree func, gimple *stmt, int opt,\n+\t\t tree range[2], tree size, bool write, bool read, bool maybe)\n+{\n+  return warn_for_access<gimple *>(loc, func, stmt, opt, range, size,\n+\t\t\t\t   write, read, maybe);\n+}\n+\n+static bool\n+warn_for_access (location_t loc, tree func, tree expr, int opt,\n+\t\t tree range[2], tree size, bool write, bool read, bool maybe)\n+{\n+  return warn_for_access<tree>(loc, func, expr, opt, range, size,\n+\t\t\t       write, read, maybe);\n+}\n+\n /* Helper to set RANGE to the range of BOUND if it's nonnull, bounded\n    by BNDRNG if nonnull and valid.  */\n \n@@ -779,8 +1234,9 @@ get_size_range (tree bound, tree range[2], const offset_int bndrng[2])\n    If the call is successfully verified as safe return true, otherwise\n    return false.  */\n \n-bool\n-check_access (tree exp, tree dstwrite,\n+template <class GimpleOrTree>\n+static bool\n+check_access (GimpleOrTree exp, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n \t      access_mode mode, const access_data *pad /* = NULL */)\n {\n@@ -809,7 +1265,10 @@ check_access (tree exp, tree dstwrite,\n       if (POINTER_TYPE_P (TREE_TYPE (srcstr)))\n \t{\n \t  if (!check_nul_terminated_array (exp, srcstr, maxread))\n+\t    /* Return if the array is not nul-terminated and a warning\n+\t       has been issued.  */\n \t    return false;\n+\n \t  /* Try to determine the range of lengths the source string\n \t     refers to.  If it can be determined and is less than\n \t     the upper bound given by MAXREAD add one to it for\n@@ -881,7 +1340,7 @@ check_access (tree exp, tree dstwrite,\n       && TREE_CODE (range[0]) == INTEGER_CST\n       && tree_int_cst_lt (maxobjsize, range[0]))\n     {\n-      location_t loc = EXPR_LOCATION (exp);\n+      location_t loc = get_location (exp);\n       maybe_warn_for_bound (OPT_Wstringop_overflow_, loc, exp, func, range,\n \t\t\t    NULL_TREE, pad);\n       return false;\n@@ -909,7 +1368,7 @@ check_access (tree exp, tree dstwrite,\n \t\t  && warning_suppressed_p (pad->dst.ref, opt)))\n \t    return false;\n \n-\t  location_t loc = EXPR_LOCATION (exp);\n+\t  location_t loc = get_location (exp);\n \t  bool warned = false;\n \t  if (dstwrite == slen && at_least_one)\n \t    {\n@@ -962,7 +1421,7 @@ check_access (tree exp, tree dstwrite,\n \t PAD is nonnull and BNDRNG is valid.  */\n       get_size_range (maxread, range, pad ? pad->src.bndrng : NULL);\n \n-      location_t loc = EXPR_LOCATION (exp);\n+      location_t loc = get_location (exp);\n       tree size = dstsize;\n       if (pad && pad->mode == access_read_only)\n \tsize = wide_int_to_tree (sizetype, pad->src.sizrng[1]);\n@@ -1023,7 +1482,7 @@ check_access (tree exp, tree dstwrite,\n \t      && warning_suppressed_p (pad->src.ref, opt)))\n \treturn false;\n \n-      location_t loc = EXPR_LOCATION (exp);\n+      location_t loc = get_location (exp);\n       const bool read\n \t= mode == access_read_only || mode == access_read_write;\n       const bool maybe = pad && pad->dst.parmarray;\n@@ -1040,6 +1499,96 @@ check_access (tree exp, tree dstwrite,\n   return true;\n }\n \n+bool\n+check_access (gimple *stmt, tree dstwrite,\n+\t      tree maxread, tree srcstr, tree dstsize,\n+\t      access_mode mode, const access_data *pad /* = NULL */)\n+{\n+  return check_access<gimple *>(stmt, dstwrite, maxread, srcstr, dstsize,\n+\t\t\t\tmode, pad);\n+}\n+\n+bool\n+check_access (tree expr, tree dstwrite,\n+\t      tree maxread, tree srcstr, tree dstsize,\n+\t      access_mode mode, const access_data *pad /* = NULL */)\n+{\n+  return check_access<tree>(expr, dstwrite, maxread, srcstr, dstsize,\n+\t\t\t    mode, pad);\n+}\n+\n+/* Helper to determine and check the sizes of the source and the destination\n+   of calls to __builtin_{bzero,memcpy,mempcpy,memset} calls.  EXP is the\n+   call expression, DEST is the destination argument, SRC is the source\n+   argument or null, and LEN is the number of bytes.  Use Object Size type-0\n+   regardless of the OPT_Wstringop_overflow_ setting.  Return true on success\n+   (no overflow or invalid sizes), false otherwise.  */\n+\n+template <class GimpleOrTree>\n+static bool\n+check_memop_access (GimpleOrTree expr, tree dest, tree src, tree size)\n+{\n+  /* For functions like memset and memcpy that operate on raw memory\n+     try to determine the size of the largest source and destination\n+     object using type-0 Object Size regardless of the object size\n+     type specified by the option.  */\n+  access_data data (expr, access_read_write);\n+  tree srcsize = src ? compute_objsize (src, 0, &data.src) : NULL_TREE;\n+  tree dstsize = compute_objsize (dest, 0, &data.dst);\n+\n+  return check_access (expr, size, /*maxread=*/NULL_TREE,\n+\t\t       srcsize, dstsize, data.mode, &data);\n+}\n+\n+bool\n+check_memop_access (gimple *stmt, tree dest, tree src, tree size)\n+{\n+  return check_memop_access<gimple *>(stmt, dest, src, size);\n+}\n+\n+bool\n+check_memop_access (tree expr, tree dest, tree src, tree size)\n+{\n+  return check_memop_access<tree>(expr, dest, src, size);\n+}\n+\n+/* A convenience wrapper for check_access above to check access\n+   by a read-only function like puts.  */\n+\n+template <class GimpleOrTree>\n+static bool\n+check_read_access (GimpleOrTree expr, tree src, tree bound, int ost)\n+{\n+  if (!warn_stringop_overread)\n+    return true;\n+\n+  if (bound && !useless_type_conversion_p (size_type_node, TREE_TYPE (bound)))\n+    bound = fold_convert (size_type_node, bound);\n+\n+  tree fndecl = get_callee_fndecl (expr);\n+  maybe_warn_nonstring_arg (fndecl, expr);\n+\n+  access_data data (expr, access_read_only, NULL_TREE, false, bound, true);\n+  compute_objsize (src, ost, &data.src);\n+  return check_access (expr, /*dstwrite=*/ NULL_TREE, /*maxread=*/ bound,\n+\t\t       /*srcstr=*/ src, /*dstsize=*/ NULL_TREE, data.mode,\n+\t\t       &data);\n+}\n+\n+bool\n+check_read_access (gimple *stmt, tree src, tree bound /* = NULL_TREE */,\n+\t\t   int ost /* = 1 */)\n+{\n+  return check_read_access<gimple *>(stmt, src, bound, ost);\n+}\n+\n+bool\n+check_read_access (tree expr, tree src, tree bound /* = NULL_TREE */,\n+\t\t   int ost /* = 1 */)\n+{\n+  return check_read_access<tree>(expr, src, bound, ost);\n+}\n+\n /* Return true if STMT is a call to an allocation function.  Unless\n    ALL_ALLOC is set, consider only functions that return dynmamically\n    allocated objects.  Otherwise return true even for all forms of\n@@ -1523,13 +2072,13 @@ warn_dealloc_offset (location_t loc, gimple *call, const access_ref &aref)\n     return false;\n \n   if (DECL_P (aref.ref))\n-    inform (DECL_SOURCE_LOCATION (aref.ref), \"declared here\");\n+    inform (get_location (aref.ref), \"declared here\");\n   else if (TREE_CODE (aref.ref) == SSA_NAME)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (aref.ref);\n       if (is_gimple_call (def_stmt))\n \t{\n-\t  location_t def_loc = gimple_location (def_stmt);\n+\t  location_t def_loc = get_location (def_stmt);\n \t  tree alloc_decl = gimple_call_fndecl (def_stmt);\n \t  if (alloc_decl)\n \t    inform (def_loc,\n@@ -1550,7 +2099,7 @@ warn_dealloc_offset (location_t loc, gimple *call, const access_ref &aref)\n    a matching allocation function such as malloc or the corresponding\n    form of C++ operatorn new.  */\n \n-void\n+static void\n maybe_emit_free_warning (gcall *call)\n {\n   tree fndecl = gimple_call_fndecl (call);\n@@ -1584,10 +2133,7 @@ maybe_emit_free_warning (gcall *call)\n \t\t\t \"%qD called on unallocated object %qD\",\n \t\t\t dealloc_decl, ref))\n \t{\n-\t  loc = (DECL_P (ref)\n-\t\t ? DECL_SOURCE_LOCATION (ref)\n-\t\t : EXPR_LOCATION (ref));\n-\t  inform (loc, \"declared here\");\n+\t  inform (get_location (ref), \"declared here\");\n \t  return;\n \t}\n \n@@ -1704,8 +2250,14 @@ class pass_waccess : public gimple_opt_pass\n   virtual bool gate (function *);\n   virtual unsigned int execute (function *);\n \n+  /* Check a call to a built-in function.  */\n+  bool check_builtin (gcall *);\n+\n+  /* Check statements in a basic block.  */\n   void check (basic_block);\n-  void check (gcall *);\n+\n+  /* Check a call to a function.  */\n+ void check (gcall *);\n \n private:\n   gimple_ranger *m_ranger;\n@@ -1721,11 +2273,376 @@ pass_waccess::gate (function *)\n \t  || warn_mismatched_new_delete);\n }\n \n+/* Check a call STMT to strcat() for overflow and warn if it does.  */\n+\n+static void\n+check_strcat (gimple *stmt)\n+{\n+  if (!warn_stringop_overflow)\n+    return;\n+\n+  tree dest = call_arg (stmt, 0);\n+  tree src = call_arg (stmt, 1);\n+\n+  /* There is no way here to determine the length of the string in\n+     the destination to which the SRC string is being appended so\n+     just diagnose cases when the souce string is longer than\n+     the destination object.  */\n+  access_data data (stmt, access_read_write, NULL_TREE, true,\n+\t\t    NULL_TREE, true);\n+  const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+  compute_objsize (src, ost, &data.src);\n+  tree destsize = compute_objsize (dest, ost, &data.dst);\n+\n+  check_access (stmt, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n+\t\tsrc, destsize, data.mode, &data);\n+}\n+\n+/* Check a call STMT to strcat() for overflow and warn if it does.  */\n+\n+static void\n+check_strncat (gimple *stmt)\n+{\n+  if (!warn_stringop_overflow)\n+    return;\n+\n+  tree dest = call_arg (stmt, 0);\n+  tree src = call_arg (stmt, 1);\n+  /* The upper bound on the number of bytes to write.  */\n+  tree maxread = call_arg (stmt, 2);\n+\n+  /* Detect unterminated source (only).  */\n+  if (!check_nul_terminated_array (stmt, src, maxread))\n+    return;\n+\n+  /* The length of the source sequence.  */\n+  tree slen = c_strlen (src, 1);\n+\n+  /* Try to determine the range of lengths that the source expression\n+     refers to.  Since the lengths are only used for warning and not\n+     for code generation disable strict mode below.  */\n+  tree maxlen = slen;\n+  if (!maxlen)\n+    {\n+      c_strlen_data lendata = { };\n+      get_range_strlen (src, &lendata, /* eltsize = */ 1);\n+      maxlen = lendata.maxbound;\n+    }\n+\n+  access_data data (stmt, access_read_write);\n+  /* Try to verify that the destination is big enough for the shortest\n+     string.  First try to determine the size of the destination object\n+     into which the source is being copied.  */\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n+\n+  /* Add one for the terminating nul.  */\n+  tree srclen = (maxlen\n+\t\t ? fold_build2 (PLUS_EXPR, size_type_node, maxlen,\n+\t\t\t\tsize_one_node)\n+\t\t : NULL_TREE);\n+\n+  /* The strncat function copies at most MAXREAD bytes and always appends\n+     the terminating nul so the specified upper bound should never be equal\n+     to (or greater than) the size of the destination.  */\n+  if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (destsize)\n+      && tree_int_cst_equal (destsize, maxread))\n+    {\n+      location_t loc = get_location (stmt);\n+      warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t  \"%qD specified bound %E equals destination size\",\n+\t\t  get_callee_fndecl (stmt), maxread);\n+\n+      return;\n+    }\n+\n+  if (!srclen\n+      || (maxread && tree_fits_uhwi_p (maxread)\n+\t  && tree_fits_uhwi_p (srclen)\n+\t  && tree_int_cst_lt (maxread, srclen)))\n+    srclen = maxread;\n+\n+  check_access (stmt, /*dstwrite=*/NULL_TREE, maxread, srclen,\n+\t\tdestsize, data.mode, &data);\n+}\n+\n+/* Check a call STMT to stpcpy() or strcpy() for overflow and warn\n+   if it does.  */\n+\n+static void\n+check_stxcpy (gimple *stmt)\n+{\n+  tree dst = call_arg (stmt, 0);\n+  tree src = call_arg (stmt, 1);\n+\n+  tree size;\n+  bool exact;\n+  if (tree nonstr = unterminated_array (src, &size, &exact))\n+    {\n+      /* NONSTR refers to the non-nul terminated constant array.  */\n+      warn_string_no_nul (get_location (stmt), stmt, NULL, src, nonstr,\n+\t\t\t  size, exact);\n+      return;\n+    }\n+\n+  if (warn_stringop_overflow)\n+    {\n+      access_data data (stmt, access_read_write, NULL_TREE, true,\n+\t\t\tNULL_TREE, true);\n+      const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+      compute_objsize (src, ost, &data.src);\n+      tree dstsize = compute_objsize (dst, ost, &data.dst);\n+      check_access (stmt, /*dstwrite=*/ NULL_TREE,\n+\t\t    /*maxread=*/ NULL_TREE, /*srcstr=*/ src,\n+\t\t    dstsize, data.mode, &data);\n+    }\n+\n+  /* Check to see if the argument was declared attribute nonstring\n+     and if so, issue a warning since at this point it's not known\n+     to be nul-terminated.  */\n+  tree fndecl = get_callee_fndecl (stmt);\n+  maybe_warn_nonstring_arg (fndecl, stmt);\n+}\n+\n+/* Check a call STMT to stpncpy() or strncpy() for overflow and warn\n+   if it does.  */\n+\n+static void\n+check_stxncpy (gimple *stmt)\n+{\n+  if (!warn_stringop_overflow)\n+    return;\n+\n+  tree dst = call_arg (stmt, 0);\n+  tree src = call_arg (stmt, 1);\n+  /* The number of bytes to write (not the maximum).  */\n+  tree len = call_arg (stmt, 2);\n+\n+  access_data data (stmt, access_read_write, len, true, len, true);\n+  const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n+  compute_objsize (src, ost, &data.src);\n+  tree dstsize = compute_objsize (dst, ost, &data.dst);\n+\n+  check_access (stmt, /*dstwrite=*/len,\n+\t\t/*maxread=*/len, src, dstsize, data.mode, &data);\n+}\n+\n+/* Check a call STMT to stpncpy() or strncpy() for overflow and warn\n+   if it does.  */\n+\n+static void\n+check_strncmp (gimple *stmt)\n+{\n+  if (!warn_stringop_overread)\n+    return;\n+\n+  tree arg1 = call_arg (stmt, 0);\n+  tree arg2 = call_arg (stmt, 1);\n+  tree bound = call_arg (stmt, 2);\n+\n+  /* First check each argument separately, considering the bound.  */\n+  if (!check_nul_terminated_array (stmt, arg1, bound)\n+      || !check_nul_terminated_array (stmt, arg2, bound))\n+    return;\n+\n+  /* A strncmp read from each argument is constrained not just by\n+     the bound but also by the length of the shorter string.  Specifying\n+     a bound that's larger than the size of either array makes no sense\n+     and is likely a bug.  When the length of neither of the two strings\n+     is known but the sizes of both of the arrays they are stored in is,\n+     issue a warning if the bound is larger than than the size of\n+     the larger of the two arrays.  */\n+\n+  c_strlen_data lendata1{ }, lendata2{ };\n+  tree len1 = c_strlen (arg1, 1, &lendata1);\n+  tree len2 = c_strlen (arg2, 1, &lendata2);\n+\n+  if (len1 && len2)\n+    /* If the length of both arguments was computed they must both be\n+       nul-terminated and no further checking is necessary regardless\n+       of the bound.  */\n+    return;\n+\n+  /* Check to see if the argument was declared with attribute nonstring\n+     and if so, issue a warning since at this point it's not known to be\n+     nul-terminated.  */\n+  if (maybe_warn_nonstring_arg (get_callee_fndecl (stmt), stmt))\n+    return;\n+\n+  access_data adata1 (stmt, access_read_only, NULL_TREE, false, bound, true);\n+  access_data adata2 (stmt, access_read_only, NULL_TREE, false, bound, true);\n+\n+  /* Determine the range of the bound first and bail if it fails; it's\n+     cheaper than computing the size of the objects.  */\n+  tree bndrng[2] = { NULL_TREE, NULL_TREE };\n+  get_size_range (bound, bndrng, adata1.src.bndrng);\n+  if (!bndrng[0] || integer_zerop (bndrng[0]))\n+    return;\n+\n+  if (len1 && tree_int_cst_lt (len1, bndrng[0]))\n+    bndrng[0] = len1;\n+  if (len2 && tree_int_cst_lt (len2, bndrng[0]))\n+    bndrng[0] = len2;\n+\n+  /* compute_objsize almost never fails (and ultimately should never\n+     fail).  Don't bother to handle the rare case when it does.  */\n+  if (!compute_objsize (arg1, 1, &adata1.src)\n+      || !compute_objsize (arg2, 1, &adata2.src))\n+    return;\n+\n+  /* Compute the size of the remaining space in each array after\n+     subtracting any offset into it.  */\n+  offset_int rem1 = adata1.src.size_remaining ();\n+  offset_int rem2 = adata2.src.size_remaining ();\n+\n+  /* Cap REM1 and REM2 at the other if the other's argument is known\n+     to be an unterminated array, either because there's no space\n+     left in it after adding its offset or because it's constant and\n+     has no nul.  */\n+  if (rem1 == 0 || (rem1 < rem2 && lendata1.decl))\n+    rem2 = rem1;\n+  else if (rem2 == 0 || (rem2 < rem1 && lendata2.decl))\n+    rem1 = rem2;\n+\n+  /* Point PAD at the array to reference in the note if a warning\n+     is issued.  */\n+  access_data *pad = len1 ? &adata2 : &adata1;\n+  offset_int maxrem = wi::max (rem1, rem2, UNSIGNED);\n+  if (lendata1.decl || lendata2.decl\n+      || maxrem < wi::to_offset (bndrng[0]))\n+    {\n+      /* Warn when either argument isn't nul-terminated or the maximum\n+\t remaining space in the two arrays is less than the bound.  */\n+      tree func = get_callee_fndecl (stmt);\n+      location_t loc = gimple_location (stmt);\n+      maybe_warn_for_bound (OPT_Wstringop_overread, loc, stmt, func,\n+\t\t\t    bndrng, wide_int_to_tree (sizetype, maxrem),\n+\t\t\t    pad);\n+    }\n+}\n+\n+/* Check call STMT to a built-in function for invalid accesses.  Return\n+   true if a call has been handled.  */\n+\n+bool\n+pass_waccess::check_builtin (gcall *stmt)\n+{\n+  tree callee = gimple_call_fndecl (stmt);\n+  if (!callee)\n+    return false;\n+\n+  switch (DECL_FUNCTION_CODE (callee))\n+    {\n+    case BUILT_IN_GETTEXT:\n+    case BUILT_IN_PUTS:\n+    case BUILT_IN_PUTS_UNLOCKED:\n+    case BUILT_IN_STRDUP:\n+      check_read_access (stmt, call_arg (stmt, 0));\n+      return true;\n+\n+    case BUILT_IN_INDEX:\n+    case BUILT_IN_RINDEX:\n+    case BUILT_IN_STRCHR:\n+    case BUILT_IN_STRRCHR:\n+    case BUILT_IN_STRLEN:\n+      check_read_access (stmt, call_arg (stmt, 0));\n+      return true;\n+\n+    case BUILT_IN_FPUTS:\n+    case BUILT_IN_FPUTS_UNLOCKED:\n+      check_read_access (stmt, call_arg (stmt, 0));\n+      return true;\n+\n+    case BUILT_IN_STRNDUP:\n+    case BUILT_IN_STRNLEN:\n+      check_read_access (stmt, call_arg (stmt, 0), call_arg (stmt, 1));\n+      return true;\n+\n+    case BUILT_IN_STRCAT:\n+      check_strcat (stmt);\n+      return true;\n+\n+    case BUILT_IN_STRNCAT:\n+      check_strncat (stmt);\n+      return true;\n+\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STRCPY:\n+      check_stxcpy (stmt);\n+      return true;\n+\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STRNCPY:\n+      check_stxncpy (stmt);\n+      return true;\n+\n+    case BUILT_IN_STRCASECMP:\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRPBRK:\n+    case BUILT_IN_STRSPN:\n+    case BUILT_IN_STRCSPN:\n+    case BUILT_IN_STRSTR:\n+      check_read_access (stmt, call_arg (stmt, 0));\n+      check_read_access (stmt, call_arg (stmt, 1));\n+      return true;\n+\n+    case BUILT_IN_STRNCASECMP:\n+    case BUILT_IN_STRNCMP:\n+      check_strncmp (stmt);\n+      return true;\n+\n+    case BUILT_IN_MEMCMP:\n+      {\n+\ttree a1 = call_arg (stmt, 0);\n+\ttree a2 = call_arg (stmt, 1);\n+\ttree len = call_arg (stmt, 2);\n+\tcheck_read_access (stmt, a1, len, 0);\n+\tcheck_read_access (stmt, a2, len, 0);\n+\treturn true;\n+      }\n+\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMMOVE:\n+      {\n+\ttree dst = call_arg (stmt, 0);\n+\ttree src = call_arg (stmt, 1);\n+\ttree len = call_arg (stmt, 2);\n+\tcheck_memop_access (stmt, dst, src, len);\n+\treturn true;\n+      }\n+\n+    case BUILT_IN_MEMCHR:\n+      {\n+\ttree src = call_arg (stmt, 0);\n+\ttree len = call_arg (stmt, 2);\n+\tcheck_read_access (stmt, src, len, 0);\n+\treturn true;\n+      }\n+\n+    case BUILT_IN_MEMSET:\n+      {\n+\ttree dst = call_arg (stmt, 0);\n+\ttree len = call_arg (stmt, 2);\n+\tcheck_memop_access (stmt, dst, NULL_TREE, len);\n+\treturn true;\n+      }\n+\t\n+    default:\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n /* Check call STMT for invalid accesses.  */\n \n void\n pass_waccess::check (gcall *stmt)\n {\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+      && check_builtin (stmt))\n+    return;\n+\n   maybe_emit_free_warning (stmt);\n }\n "}, {"sha": "8b33ecbd4fb4aa742c71f43f00086f57cf14ffcd", "filename": "gcc/gimple-ssa-warn-access.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-ssa-warn-access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fgimple-ssa-warn-access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.h?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -24,14 +24,27 @@\n #define GCC_GIMPLE_SSA_WARN_ACCESS_H\n \n extern bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n+extern void warn_string_no_nul (location_t, gimple *, const char *, tree,\n+\t\t\t\ttree, tree = NULL_TREE, bool = false,\n+\t\t\t\tconst wide_int[2] = NULL);\n extern void warn_string_no_nul (location_t, tree, const char *, tree,\n \t\t\t\ttree, tree = NULL_TREE, bool = false,\n \t\t\t\tconst wide_int[2] = NULL);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern void get_size_range (tree, tree[2], const offset_int[2]);\n \n class access_data;\n+extern bool maybe_warn_for_bound (opt_code, location_t, gimple *, tree,\n+\t\t\t\t  tree[2], tree, const access_data * = NULL);\n extern bool maybe_warn_for_bound (opt_code, location_t, tree, tree,\n \t\t\t\t  tree[2], tree, const access_data * = NULL);\n \n+class access_data;\n+extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n+\t\t\t  const access_data * = NULL);\n+\n+extern bool check_memop_access (tree, tree, tree, tree);\n+extern bool check_read_access (gimple *, tree, tree = NULL_TREE, int ost = 1);\n+extern bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n+\n #endif   // GCC_GIMPLE_SSA_WARN_ACCESS_H"}, {"sha": "8bd538a3ac2a34b5e496cbd5b0c62b5d16dcfd70", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -203,14 +203,24 @@ class pointer_query\n    functions like memcpy.  */\n struct access_data\n {\n+  /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n+     at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n+  access_data (gimple *stmt, access_mode mode,\n+\t       tree maxwrite = NULL_TREE, bool minwrite = false,\n+\t       tree maxread = NULL_TREE, bool minread = false)\n+    : stmt (stmt), call (),\n+      dst (maxwrite, minwrite), src (maxread, minread), mode (mode) { }\n+\n   /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n      at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n   access_data (tree expr, access_mode mode,\n \t       tree maxwrite = NULL_TREE, bool minwrite = false,\n \t       tree maxread = NULL_TREE, bool minread = false)\n-    : call (expr),\n+    : stmt (), call (expr),\n       dst (maxwrite, minwrite), src (maxread, minread), mode (mode) { }\n \n+  /* Access statement.  */\n+  gimple *stmt;\n   /* Built-in function call.  */\n   tree call;\n   /* Destination and source of the access.  */"}, {"sha": "6c8866d2a24a19a4045ec4e4142e28f5ec4af3d2", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -1,7 +1,7 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n-/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-c++-compat -Wno-stringop-overflow\" { target c } } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-overread\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-c++-compat -Wno-stringop-overflow -Wno-stringop-overread\" { target c } } */\n /* { dg-require-effective-target alloca } */\n \n typedef __SIZE_TYPE__ size_t;"}, {"sha": "3add7fae4fef632f3f17915b13bcf9c3bb68a98e", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -379,9 +379,9 @@ void test_stnrdup_warn (struct MemArrays *p)\n   T (strndup (p->arr, N));\n \n \n-  T (strndup (arr, N + 1));     /* { dg-warning \"specified bound 5 exceeds source size 4\" } */\n+  T (strndup (arr, N + 1));     /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 5|specified bound 5 exceeds source size 4\" } */\n   T (strndup (parr, N + 1));\n-  T (strndup (p->arr, N + 1));  /* { dg-warning \"specified bound 5 exceeds source size 4\" } */\n+  T (strndup (p->arr, N + 1));  /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 5|specified bound 5 exceeds source size 4\" } */\n   T (strndup (p->parr, N + 1));\n }\n "}, {"sha": "cb00fa9c47d157957d492d4b035ff97bfb6c3777", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-39.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -5,6 +5,8 @@\n    { dg-do compile }\n    { dg-options \"-O2 -Wall\" }  */\n \n+#define NOIPA __attribute__ ((noipa))\n+\n typedef __SIZE_TYPE__ size_t;\n \n extern void* memcpy (void*, const void*, size_t);\n@@ -19,65 +21,65 @@ const char s1_0[1][0] = { };\n \n char d[4];\n \n-void* test_memcpy_s0_1 (void *d)\n+NOIPA void* test_memcpy_s0_1 (void *d)\n {\n   return memcpy (d, s0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_s0_2 (void *d)\n+NOIPA void* test_memcpy_s0_2 (void *d)\n {\n   return memcpy (d, s0, 2);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_s0_0_1 (void *d)\n+NOIPA void* test_memcpy_s0_0_1 (void *d)\n {\n   return memcpy (d, s0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_s0_0_2 (void *d)\n+NOIPA void* test_memcpy_s0_0_2 (void *d)\n {\n   return memcpy (d, s0_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n-void* test_memcpy_s0_1_1 (void *d)\n+NOIPA void* test_memcpy_s0_1_1 (void *d)\n {\n   return memcpy (d, s0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_s0_1_2 (void *d)\n+NOIPA void* test_memcpy_s0_1_2 (void *d)\n {\n   return memcpy (d, s0_1, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n-void* test_memcpy_s1_0_1 (void *d)\n+NOIPA void* test_memcpy_s1_0_1 (void *d)\n {\n   return memcpy (d, s1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_s1_0_2 (void *d)\n+NOIPA void* test_memcpy_s1_0_2 (void *d)\n {\n   return memcpy (d, s1_0, 2);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n-void* test_memmove_s0_1 (void *d)\n+NOIPA void* test_memmove_s0_1 (void *d)\n {\n   return memmove (d, s0, 1);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memmove_s0_2 (void *d)\n+NOIPA void* test_memmove_s0_2 (void *d)\n {\n   return memmove (d, s0, 2);      /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memmove_s0_0_1 (void *d)\n+NOIPA void* test_memmove_s0_0_1 (void *d)\n {\n   return memmove (d, s0_0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memmove_s0_0_2 (void *d)\n+NOIPA void* test_memmove_s0_0_2 (void *d)\n {\n   return memmove (d, s0_0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n@@ -90,59 +92,60 @@ const struct Empty e0_0[0][0] = { };\n const struct Empty e0_1[0][1] = { };\n const struct Empty e1_0[1][0] = { };\n \n-void* test_memcpy_e_1 (void *d)\n+NOIPA void* test_memcpy_e_1 (void *d)\n {\n   return memcpy (d, &e, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_e0_1 (void *d)\n+NOIPA void* test_memcpy_e0_1 (void *d)\n {\n   return memcpy (d, e0, 1);       /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_e0_0_1 (void *d)\n+NOIPA void* test_memcpy_e0_0_1 (void *d)\n {\n   return memcpy (d, e0_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_e0_1_1 (void *d)\n+NOIPA void* test_memcpy_e0_1_1 (void *d)\n {\n   return memcpy (d, e0_1, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-void* test_memcpy_e1_0_1 (void *d)\n+NOIPA void* test_memcpy_e1_0_1 (void *d)\n {\n   return memcpy (d, e1_0, 1);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n-char* test_strcpy_s0 (char *d)\n+NOIPA char*\n+test_strcpy_s0 (char *d)          /* { dg-bogus \"-Warray-bounds\" \"pr101679\" { xfail *-*-* } } */\n {\n   return strcpy (d, s0);          /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-char* test_strcpy_s0_0 (char *d)\n+NOIPA char* test_strcpy_s0_0 (char *d)\n {\n   return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n \n-char* test_strncpy_s0_1 (char *d)\n+NOIPA char* test_strncpy_s0_1 (char *d)\n {\n   return strncpy (d, s0, 1);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-char* test_strncpy_s0_2 (char *d)\n+NOIPA char* test_strncpy_s0_2 (char *d)\n {\n   return strncpy (d, s0, 2);    /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-char* test_strncpy_s0_0_1 (char *d)\n+NOIPA char* test_strncpy_s0_0_1 (char *d)\n {\n   return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }\n \n-char* test_strncpy_s0_0_2 (char *d)\n+NOIPA char* test_strncpy_s0_0_2 (char *d)\n {\n   return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overread\" } */\n }"}, {"sha": "6d0d5be9d779a770cd07d2f25e6138986d371a86", "filename": "gcc/testsuite/gcc.dg/Wstring-compare-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstring-compare-3.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/95673 - missing -Wstring-compare for an impossible strncmp test\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wstring-compare -ftrack-macro-expansion=0\" } */\n+   { dg-options \"-O2 -Wall -Wstring-compare -Wno-stringop-overread -ftrack-macro-expansion=0\" } */\n \n typedef __SIZE_TYPE__ size_t;\n "}, {"sha": "a8177a316cc1d692f29aa110879433559050efa7", "filename": "gcc/testsuite/gcc.dg/Wstringop-overread-6.c", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-6.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -0,0 +1,574 @@\n+/* Verify -Wstringop-overread is issued appropriately for calls to string\n+   functions at -O0 and without -Wall.\n+  { dg-do compile }\n+  { dg-options \"-O0 -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define S2 \"12\"\n+#define S9 \"123456789\"\n+\n+// <libint.h> functions.\n+\n+char* gettext (const char *);\n+\n+// <stdio.h> functions.\n+\n+typedef struct FILE FILE;\n+\n+int fputs (const char*, FILE*);\n+int fputs_unlocked (const char*, FILE*);\n+\n+int puts (const char*);\n+int puts_unlocked (const char*);\n+\n+// <string.h> functions.\n+\n+void* memchr (const void*, int, size_t);\n+int memcmp (const void*, const void*, size_t);\n+void* memcpy (void*, const void*, size_t);\n+void* mempcpy (void*, const void*, size_t);\n+void* memmove (void*, const void*, size_t);\n+\n+char* strchr (const char*, int);\n+char* strrchr (const char*, int);\n+\n+int strcmp (const char*, const char*);\n+int strncmp (const char*, const char*, size_t);\n+\n+char* strcat (char*, const char*);\n+char* stpcpy (char*, const char*);\n+char* strcpy (char*, const char*);\n+char* stpncpy (char*, const char*, size_t);\n+char* strncpy (char*, const char*, size_t);\n+char* strdup (const char*);\n+char* strndup (const char*, size_t);\n+\n+char* strpbrk (const char*, const char*);\n+size_t strcspn (const char*, const char*);\n+size_t strspn (const char*, const char*);\n+char* strstr (const char*, const char*);\n+\n+size_t strlen (const char*);\n+size_t strnlen (const char*, size_t);\n+\n+\n+extern void* malloc (size_t);\n+\n+void sink (void*);\n+\n+\n+extern char *d;\n+extern char a0[0];\n+\n+const char arr[7] = \"abc\\0def\";\n+\n+/* Unterminated array at the end of ARR above.  */\n+#define unterm (arr + __builtin_strlen (arr) + 1)\n+\n+/* Size of the unterminated array - 1.  */\n+#define unterm_size (sizeof arr - __builtin_strlen (arr) - 1)\n+\n+const void* nowarn_memchr (int x)\n+{\n+  const char *p1 = unterm;\n+  return memchr (p1, x, unterm_size);\n+}\n+\n+const void* warn_memchr (int x)\n+{\n+  const char *p1 = unterm;\n+  return memchr (p1, x, unterm_size + 1);       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void* nowarn_memcpy (void)\n+{\n+  const char *s = unterm;\n+  return memcpy (d, s, unterm_size);\n+}\n+\n+void* warn_memcpy (void)\n+{\n+  const char *s = unterm;\n+  /* Use + 2 for an odd size to prevent the memmove --> MEM_REF transform\n+     from defeating the warning (for now).  */\n+  return memcpy (d, s, unterm_size + 2 | 1);    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void* nowarn_mempcpy (void)\n+{\n+  const char *s = unterm;\n+  return mempcpy (d, s, unterm_size);\n+}\n+\n+void* warn_mempcpy (void)\n+{\n+  const char *s = unterm;\n+  /* Use + 2 for an odd size to prevent the memmove --> MEM_REF transform\n+     from defeating the warning (for now).  */\n+  return mempcpy (d, s, unterm_size + 2 | 1);   // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void* nowarn_memmove (void)\n+{\n+  const char *s = unterm;\n+  return memmove (d, s, unterm_size);\n+}\n+\n+void* warn_memmove (void)\n+{\n+  const char *s = unterm;\n+  /* Use + 2 for an odd size to prevent the memmove --> MEM_REF transform\n+     from defeating the warning (for now).  */\n+  return memmove (d, s, unterm_size + 2);       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int nowarn_memcmp_1 (const char *p2)\n+{\n+  const char *p1 = unterm;\n+  return memcmp (p1, p2, unterm_size);\n+}\n+\n+int warn_memcmp_1 (const char *p2)\n+{\n+  const char *p1 = unterm;\n+  return memcmp (p1, p2, unterm_size + 1);      // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int nowarn_memcmp_2 (const char *p1)\n+{\n+  const char *p2 = unterm;\n+  return memcmp (p1, p2, unterm_size);\n+}\n+\n+int warn_memcmp_2 (const char *p1)\n+{\n+  const char *p2 = unterm;\n+  return memcmp (p1, p2, unterm_size + 1);      // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void warn_strcat (void)\n+{\n+  strcat (d, unterm);                   // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strcat_a0 (void)\n+{\n+  strcat (d, a0);                       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strcat_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  strcat (d, s);                        // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpcpy (void)\n+{\n+  return stpcpy (d, unterm);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpcpy_a0 (void)\n+{\n+  return stpcpy (d, a0);                // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpcpy_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return stpcpy (d, s);                 // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpcpy_malloc0 (void)\n+{\n+  char *s = malloc (0);\n+  sink (s);\n+  return stpcpy (d, s);                 // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void warn_strcpy (void)\n+{\n+  strcpy (d, unterm);                   // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strcpy_a0 (void)\n+{\n+  strcpy (d, a0);                       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strcpy_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  strcpy (d, s);                        // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strcpy_malloc0 (void)\n+{\n+  char *s = malloc (0);\n+  sink (s);\n+  strcpy (d, s);                        // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+char* nowarn_stpncpy (void)\n+{\n+  const char *s = unterm;\n+  return stpncpy (d, s, unterm_size);\n+}\n+\n+char* warn_stpncpy (void)\n+{\n+  const char *s = unterm;\n+  return stpncpy (d, s, unterm_size + 1);       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpncpy_a0 (void)\n+{\n+  return stpncpy (d, a0, 3);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_stpncpy_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return stpncpy (d, s, sizeof arr);    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void nowarn_strncpy (void)\n+{\n+  const char *s = unterm;\n+  strncpy (d, s, unterm_size);\n+}\n+\n+void warn_strncpy (void)\n+{\n+  const char *s = unterm;\n+  strncpy (d, s, unterm_size + 1);      // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strncpy_a0 (void)\n+{\n+  const char *s = a0;\n+  strncpy (d, s, sizeof arr);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_strncpy_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  strncpy (d, s, sizeof arr);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int warn_strlen (void)\n+{\n+  return strlen (unterm);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strlen_a0 (void)\n+{\n+  return strlen (a0);                   // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strlen_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strlen (s);                    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strlen_malloc0 (void)\n+{\n+  char *s = malloc (0);\n+  sink (s);\n+  return strlen (s);                    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int nowarn_strnlen (void)\n+{\n+  return strnlen (unterm, unterm_size);\n+}\n+\n+int warn_strnlen (void)\n+{\n+  return strnlen (unterm, unterm_size + 1);   // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strnlen_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strnlen (s, 2);                // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int warn_strcmp_1 (const char *s)\n+{\n+  return strcmp (unterm, s);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strcmp_2 (const char *s)\n+{\n+  return strcmp (s, unterm);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strcmp_2_end (const char *s)\n+{\n+  const char *t = arr + sizeof arr;\n+  return strcmp (s, t);                 // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int nowarn_strncmp_1 (const char *s2)\n+{\n+  const char *s1 = unterm;\n+  return strncmp (s1, s2, unterm_size);\n+}\n+\n+int warn_strncmp_1 (const char *s2)\n+{\n+  const char *s1 = unterm;\n+  return strncmp (s1, s2, unterm_size + 1);  // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int nowarn_strncmp_2 (const char *s1)\n+{\n+  const char *s2 = unterm;\n+  return strncmp (s1, s2, unterm_size);\n+}\n+\n+int warn_strncmp_2 (const char *s1)\n+{\n+  const char *s2 = unterm;\n+  return strncmp (s1, s2, unterm_size + 1);  // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strncmp_2_end (const char *s1)\n+{\n+  const char *s2 = arr + sizeof arr;;\n+  return strncmp (s1, s2, sizeof arr);  // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+int nowarn_strncmp_1_s2 (void)\n+{\n+  /* Since the read is also bounded by the length of the S2 literal\n+     and so safe, expect no warning.  */\n+  const char *s = unterm;\n+  return strncmp (s, S2, unterm_size + 1);   // { dg-bogus \"-Wstringop-overread\" \"pr101778\" { xfail *-*-* } }\n+}\n+\n+int warn_strncmp_2_s2 (void)\n+{\n+  /* Same as above.  */\n+  const char *t = unterm;\n+  return strncmp (S2, t, unterm_size + 1);   // { dg-bogus \"-Wstringop-overread\" \"pr101778\" { xfail *-*-* } }\n+}\n+\n+\n+int warn_strncmp_1_s9 (void)\n+{\n+  /* Since both the bound and the length of the S9 literal are greater\n+     than the size of UNNTERM the call reads past the end of the array.\n+     Expect a warning.  */\n+  const char *s1 = unterm;\n+  return strncmp (s1, S9, unterm_size + 1);  // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+int warn_strncmp_2_s9 (void)\n+{\n+  /* Same as above.  */\n+  const char *s2 = unterm;\n+  return strncmp (S9, s2, unterm_size + 1);  // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_strchr (int x)\n+{\n+  return strchr (unterm, x);            // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_strchr_end (int x)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strchr (s, x);                 // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_strrchr (int x)\n+{\n+  return strrchr (unterm, x);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_strrchr_end (int x)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strrchr (s, x);                // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+char* warn_strdup (void)\n+{\n+  return strdup (unterm);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_strdup_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strdup (s);                    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+char* nowarn_strndup (void)\n+{\n+  return strndup (unterm, unterm_size);\n+}\n+\n+char* warn_strndup (void)\n+{\n+  return strndup (unterm, unterm_size + 1); // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+char* warn_strndup_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return strndup (s, sizeof arr);       // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_strpbrk_1 (const char *s2)\n+{\n+  return strpbrk (unterm, s2);          // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_strpbrk_2 (const char *s1)\n+{\n+  return strpbrk (s1, unterm);          // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+size_t warn_strspn_1 (const char *s2)\n+{\n+  return strspn (unterm, s2);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strspn_1_end (const char *s2)\n+{\n+  const char *s1 = arr + sizeof arr;\n+  return strspn (s1, s2);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strspn_2 (const char *s1)\n+{\n+  return strspn (s1, unterm);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strspn_2_end (const char *s1)\n+{\n+  const char *s2 = arr + sizeof arr;\n+  return strspn (s1, s2);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+size_t warn_strcspn_1 (const char *s2)\n+{\n+  return strcspn (unterm, s2);          // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strcspn_1_end (const char *s2)\n+{\n+  const char *s1 = arr + sizeof arr;\n+  return strcspn (s1, s2);              // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strcspn_2 (const char *s1)\n+{\n+  return strcspn (s1, unterm);          // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+size_t warn_strcspn_2_end (const char *s1)\n+{\n+  const char *s2 = arr + sizeof arr;\n+  return strcspn (s1, s2);              // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_strstr_1 (const char *s2)\n+{\n+  return strstr (unterm, s2);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_strstr_1_end (const char *s2)\n+{\n+  const char *s1 = arr + sizeof arr;\n+  return strstr (s1, s2);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_strstr_2 (const char *s1)\n+{\n+  return strstr (s1, unterm);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_strstr_2_end (const char *s1)\n+{\n+  const char *s2 = arr + sizeof arr;\n+  return strstr (s1, s2);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void warn_puts (void)\n+{\n+  puts (unterm);                        // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_puts_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  puts (s);                             // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void warn_fputs (FILE *f)\n+{\n+  fputs (unterm, f);                    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_fputs_end (FILE *f)\n+{\n+  const char *s = arr + sizeof arr;\n+  fputs (s, f);                         // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+void warn_puts_unlocked (void)\n+{\n+  puts_unlocked (unterm);               // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_puts_unlocked_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  puts_unlocked (s);                    // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+void warn_fputs_unlocked (FILE *f)\n+{\n+  fputs_unlocked (unterm, f);           // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+\n+const char* warn_gettext (void)\n+{\n+  return gettext (unterm);              // { dg-warning \"-Wstringop-overread\" }\n+}\n+\n+const char* warn_gettext_end (void)\n+{\n+  const char *s = arr + sizeof arr;\n+  return gettext (s);                   // { dg-warning \"-Wstringop-overread\" }\n+}"}, {"sha": "44a102c5a14c74fedf6bdeb1d325b6d09a5f6266", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-2.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-2.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -26,8 +26,8 @@ void test_strnlen_array_cst (void)\n   T (strnlen (ns3, 1));\n   T (strnlen (ns3, 2));\n   T (strnlen (ns3, 3));\n-  T (strnlen (ns3, 4));             /* { dg-warning \"specified bound 4 exceeds source size 3\" } */\n-  T (strnlen (ns3, DIFF_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size\" } */\n+  T (strnlen (ns3, 4));             /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 4|specified bound 4 exceeds source size 3\" } */\n+  T (strnlen (ns3, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound|specified bound \\[0-9\\]+ exceeds source size\" } */\n   T (strnlen (ns3, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   NONSTRING char ns5[5];\n@@ -37,8 +37,8 @@ void test_strnlen_array_cst (void)\n   T (strnlen (ns5, 1));\n   T (strnlen (ns5, 2));\n   T (strnlen (ns5, 3));\n-  T (strnlen (ns5, 6));             /* { dg-warning \"specified bound 6 exceeds source size 5\" } */\n-  T (strnlen (ns5, DIFF_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size 5\" } */\n+  T (strnlen (ns5, 6));             /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 6|specified bound 6 exceeds source size 5\" } */\n+  T (strnlen (ns5, DIFF_MAX));      /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound|specified bound \\[0-9\\]+ exceeds source size 5\" } */\n   T (strnlen (ns5, SIZE_MAX));      /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n }\n \n@@ -52,8 +52,8 @@ void test_strnlen_array_range (void)\n   T (strnlen (ns3, UR (0, 9)));\n   T (strnlen (ns3, UR (3, 4)));\n   T (strnlen (ns3, UR (3, DIFF_MAX)));\n-  T (strnlen (ns3, UR (4, 5)));     /* { dg-warning \"specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n-  T (strnlen (ns3, UR (DIFF_MAX, SIZE_MAX)));  /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 3 \" } */\n+  T (strnlen (ns3, UR (4, 5)));     /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[4, 5]|specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n+  T (strnlen (ns3, UR (DIFF_MAX, SIZE_MAX)));  /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] |specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 3 \" } */\n }\n \n \n@@ -73,8 +73,8 @@ void test_strnlen_string_cst (void)\n   T (3, \"12\",  3, 1);\n   T (3, \"12\",  3, 9);\n   T (3, \"123\", 3, 1);\n-  T (3, \"123\", 3, 4);               /* { dg-warning \"specified bound 4 exceeds source size 3\" } */\n-  T (3, \"123\", 3, 9);               /* { dg-warning \"specified bound 9 exceeds source size 3\" } */\n+  T (3, \"123\", 3, 4);               /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 4|specified bound 4 exceeds source size 3\" } */\n+  T (3, \"123\", 3, 9);               /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 9|specified bound 9 exceeds source size 3\" } */\n \n   T (5, \"1\",   2, 1);\n   T (5, \"1\",   2, 2);\n@@ -84,7 +84,7 @@ void test_strnlen_string_cst (void)\n   T (5, \"12\",  3, 9);\n   T (5, \"123\", 3, 1);\n   T (5, \"123\", 3, 5);\n-  T (5, \"123\", 3, 6);               /* { dg-warning \"specified bound 6 exceeds source size 5\" } */\n+  T (5, \"123\", 3, 6);               /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound 6|specified bound 6 exceeds source size 5\" } */\n \n   /* Strnlen shouldn't trigger a warning for arrays of unknown size\n      (except for accesses to uninitialized elements when those are\n@@ -110,6 +110,6 @@ void test_strnlen_string_range (void)\n {\n   T (3, \"1\",   2, UR (0, 1));\n   T (3, \"1\",   2, UR (3, 9));\n-  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n-  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"specified bound \\\\\\[5, 9] exceeds source size 3\" } */\n+  T (3, \"123\", 3, UR (4, 5));       /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[4, 5]|specified bound \\\\\\[4, 5] exceeds source size 3\" } */\n+  T (3, \"123\", 3, UR (5, 9));       /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[5, 9]|specified bound \\\\\\[5, 9] exceeds source size 3\" } */\n }"}, {"sha": "6f03a562026220594ed88e1b15f6bfa9d84ed43e", "filename": "gcc/testsuite/gcc.dg/attr-nonstring-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-nonstring-4.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -40,7 +40,7 @@ void strnlen_cst (void)\n   T (NS, /* [] */, n);\n   T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 9, n);                /* { dg-warning \"specified bound \\[0-9\\]+ exceeds source size 9\" } */\n+  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\d+|specified bound \\\\d+ exceeds source size 9\" } */\n   T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n }\n \n@@ -59,6 +59,6 @@ void strnlen_range (void)\n   T (NS, /* [] */, n);\n   T (NS, /* [] */, n + 1);     /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n \n-  T (NS, 9, n);                /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds source size 9\" } */\n+  T (NS, 9, n);                /* { dg-warning \"argument 1 declared attribute 'nonstring' is smaller than the specified bound \\\\\\[\\\\d+, \\\\d+]|specified bound \\\\\\[\\\\d+, \\\\d+] exceeds source size 9\" } */\n   T (NS, 10, n + 1);           /* { dg-warning \"specified bound \\\\\\[\\[0-9\\]+, \\[0-9\\]+] exceeds maximum object size \\[0-9\\]+\" } */\n }"}, {"sha": "aeff3fb16fb8d6e76694f4136f2ddbd41052139d", "filename": "gcc/testsuite/gcc.dg/sso-14.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81d6cdd335ffc60c216a020d5c99306f659377a2/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-14.c?ref=81d6cdd335ffc60c216a020d5c99306f659377a2", "patch": "@@ -46,10 +46,10 @@ int main(void)\n   int same;\n \n   msg1 = malloc (sizeof (t_s12));\n-  msg2 = malloc (sizeof (t_u12));\n+  msg2 = malloc (sizeof (t_s12));\n \n   memset (msg1, 0, sizeof (t_s12));\n-  memcpy (msg2, &msg1, sizeof (t_s12));\n+  memcpy (msg2, msg1, sizeof (t_s12));\n   same = memcmp (msg1, msg2, sizeof (t_s12));\n \n   return 0;"}]}