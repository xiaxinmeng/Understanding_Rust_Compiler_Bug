{"sha": "a0128b67f491807d78d52d37ed7144570a93c55a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAxMjhiNjdmNDkxODA3ZDc4ZDUyZDM3ZWQ3MTQ0NTcwYTkzYzU1YQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-06-06T19:10:27Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-06-06T19:10:27Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r12177", "tree": {"sha": "8c7d7afce7e53df2b36a61bcc96ca4493ef90183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c7d7afce7e53df2b36a61bcc96ca4493ef90183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0128b67f491807d78d52d37ed7144570a93c55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0128b67f491807d78d52d37ed7144570a93c55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0128b67f491807d78d52d37ed7144570a93c55a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0128b67f491807d78d52d37ed7144570a93c55a/comments", "author": null, "committer": null, "parents": [{"sha": "bb91b814bd698e504ccdcc5c426060ea659438fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb91b814bd698e504ccdcc5c426060ea659438fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb91b814bd698e504ccdcc5c426060ea659438fc"}], "stats": {"total": 387, "additions": 292, "deletions": 95}, "files": [{"sha": "fdc60977c26fbad65e1ef94fed431e33d3c8d1e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -3,6 +3,36 @@ Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n \t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n \t(finish_file): Likewise.\n \n+Tue Jun  4 15:41:45 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst_expr, case DECL_STMT): Don't pass\n+ \tLOOKUP_ONLYCONVERTING at all for now.\n+\n+\t* search.c (add_conversions): Put the conversion function in\n+ \tTREE_VALUE, the basetype in TREE_PURPOSE.\n+\t* cvt.c (build_type_conversion): Adjust.\n+\t* cvt.c (build_expr_type_conversion): Adjust.\n+\t* call.c (user_harshness): Adjust.\n+\n+Mon Jun  3 15:30:52 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (emit_thunk): Pretend this is a FUNCTION_DECL for the\n+ \tbackend's benefit.\n+\n+Fri May 31 14:56:13 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (OFFSET_REF): Remove.\n+\t* tree.def (CP_OFFSET_REF): Rename to OFFSET_REF.\n+\t* expr.c (cplus_expand_expr): Cleanup callers of expand_expr.\n+\t* init.c (expand_aggr_init_1): Ditto.\n+\t(build_new): Ditto.\n+\t* typeck.c (expand_target_expr): Ditto.\n+\n+Fri May 31 14:22:08 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Don't use TREE_VALUE on a\n+ \tTARGET_EXPR.\n+\n Wed May 29 17:04:33 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* cvt.c (build_up_reference): Redo how and when temporaries are"}, {"sha": "c9d3f8802abbd4251177748419c5a1d18b71386e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -640,18 +640,19 @@ user_harshness (type, parmtype)\n   for (conv = lookup_conversions (parmtype); conv; conv = TREE_CHAIN (conv))\n     {\n       struct harshness_code tmp;\n+      tree cand = TREE_VALUE (conv);\n \n-      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n+      if (winner && winner == cand)\n \tcontinue;\n \n-      if (tmp = convert_harshness (type, TREE_PURPOSE (conv), NULL_TREE),\n-\t  (tmp.code < USER_CODE) && (tmp.distance >= 0))\n+      tmp = convert_harshness (type, TREE_TYPE (TREE_TYPE (cand)), NULL_TREE);\n+      if ((tmp.code < USER_CODE) && (tmp.distance >= 0))\n \t{\n \t  if (winner)\n \t    return EVIL_CODE;\n \t  else\n \t    {\n-\t      winner = conv;\n+\t      winner = cand;\n \t      code = tmp.code;\n \t    }\n \t}"}, {"sha": "63a935564964d52b576009e91645084c693c5928", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -27,7 +27,7 @@ Boston, MA 02111-1307, USA.  */\n    Operand 0 is the object within which the offset is taken.\n    Operand 1 is the offset.  The language independent OFFSET_REF\n    just won't work for us.  */\n-DEFTREECODE (CP_OFFSET_REF, \"cp_offset_ref\", \"r\", 2)\n+DEFTREECODE (OFFSET_REF, \"offset_ref\", \"r\", 2)\n \n /* For DELETE_EXPR, operand 0 is the store to be destroyed.\n    Operand 1 is the value to pass to the destroying function\n@@ -50,7 +50,7 @@ DEFTREECODE (MEMBER_REF, \"member_ref\", \"r\", 2)\n    operator converts to.  Operand is expression to be converted.  */\n DEFTREECODE (TYPE_EXPR, \"type_expr\", \"e\", 1)\n \n-/* For CPLUS_NEW_EXPR, operand 0 is function which performs initialization,\n+/* For NEW_EXPR, operand 0 is function which performs initialization,\n    operand 1 is argument list to initialization function,\n    and operand 2 is the slot which was allocated for this expression.  */\n DEFTREECODE (NEW_EXPR, \"nw_expr\", \"e\", 3)"}, {"sha": "8e81909b264443c543d1a75c74a2b10f1464d355", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -318,10 +318,6 @@ enum cplus_tree_code {\n };\n #undef DEFTREECODE\n \n-/* Override OFFSET_REFs from the back-end, as we want our very own. */\n-/* Allow complex pointer to members to work correctly. */\n-#define OFFSET_REF CP_OFFSET_REF\n-\n enum languages { lang_c, lang_cplusplus };\n \n /* Macros to make error reporting functions' lives easier.  */"}, {"sha": "cdf9c135aa71a0cd03bb9959f60e9c93fa81122b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 245, "deletions": 77, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -1509,30 +1509,32 @@ build_type_conversion (code, xtype, expr, for_sure)\n   /* Nope; try looking for others.  */\n   for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n     {\n-      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n+      tree cand = TREE_VALUE (conv);\n+\n+      if (winner && winner == cand)\n \tcontinue;\n \n-      if (can_convert (xtype, TREE_PURPOSE (conv)))\n+      if (can_convert (xtype, TREE_TYPE (TREE_TYPE (cand))))\n \t{\n \t  if (winner)\n \t    {\n \t      if (for_sure)\n \t\t{\n \t\t  cp_error (\"ambiguous conversion from `%T' to `%T'\", basetype,\n \t\t\t    xtype);\n-\t\t  cp_error (\"  candidate conversions include `%T' and `%T'\",\n-\t\t\t    TREE_PURPOSE (winner), TREE_PURPOSE (conv));\n+\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n+\t\t\t    winner, cand);\n \t\t}\n \t      return NULL_TREE;\n \t    }\n \t  else\n-\t    winner = conv;\n+\t    winner = cand;\n \t}\n     }\n \n   if (winner)\n     return build_type_conversion_1 (xtype, basetype, expr,\n-\t\t\t\t    DECL_NAME (TREE_VALUE (winner)), for_sure);\n+\t\t\t\t    DECL_NAME (winner), for_sure);\n \n   return NULL_TREE;\n }\n@@ -1590,11 +1592,12 @@ build_expr_type_conversion (desires, expr, complain)\n     {\n       int win = 0;\n       tree candidate;\n+      tree cand = TREE_VALUE (conv);\n \n-      if (winner && TREE_VALUE (winner) == TREE_VALUE (conv))\n+      if (winner && winner == cand)\n \tcontinue;\n \n-      candidate = TREE_PURPOSE (conv);\n+      candidate = TREE_TYPE (TREE_TYPE (cand));\n       if (TREE_CODE (candidate) == REFERENCE_TYPE)\n \tcandidate = TREE_TYPE (candidate);\n \n@@ -1619,23 +1622,23 @@ build_expr_type_conversion (desires, expr, complain)\n \t\t{\n \t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n \t\t\t    basetype);\n-\t\t  cp_error (\"  candidate conversions include `%T' and `%T'\",\n-\t\t\t    TREE_PURPOSE (winner), TREE_PURPOSE (conv));\n+\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n+\t\t\t    winner, cand);\n \t\t}\n \t      return error_mark_node;\n \t    }\n \t  else\n-\t    winner = conv;\n+\t    winner = cand;\n \t}\n     }\n \n   if (winner)\n     {\n-      tree type = TREE_PURPOSE (winner);\n+      tree type = TREE_TYPE (TREE_TYPE (winner));\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \ttype = TREE_TYPE (type);\n       return build_type_conversion_1 (type, basetype, expr,\n-\t\t\t\t      DECL_NAME (TREE_VALUE (winner)), 1);\n+\t\t\t\t      DECL_NAME (winner), 1);\n     }\n \n   return NULL_TREE;\n@@ -1839,11 +1842,6 @@ build_conv (code, type, from)\n   int rank = ICS_STD_RANK (from);\n   switch (code)\n     {\n-    case PROMO_CONV:\n-      if (rank < PROMO_RANK)\n-\trank = PROMO_RANK;\n-      break;\n-      \n     case PTR_CONV:\n     case PMEM_CONV:\n     case BASE_CONV:\n@@ -1852,16 +1850,10 @@ build_conv (code, type, from)\n \trank = STD_RANK;\n       break;\n \n-    case PBOOL_CONV:\n-      if (rank < PBOOL_RANK)\n-\trank = PBOOL_RANK;\n-      break;\n-\n     default:\n       break;\n     }\n   ICS_STD_RANK (t) = rank;\n-  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n   return t;\n }\n \n@@ -1877,8 +1869,6 @@ standard_conversion (to, from, expr)\n     return from;\n \n   conv = build1 (EXACT_CONV, from, expr);\n-  if (TREE_CODE (expr) == USER_CONV)\n-    ICS_USER_FLAG (conv) = 1;\n \n   if (fcode == FUNCTION_TYPE)\n     {\n@@ -1979,25 +1969,25 @@ standard_conversion (to, from, expr)\n \t     || fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)))\n \treturn 0;\n \n-      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from))\n-\tconv = build_conv (PBOOL_CONV, to, conv);\n-      else\n-\tconv = build_conv (STD_CONV, to, conv);\n+      conv = build_conv (STD_CONV, to, conv);\n+      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)\n+\t  && ICS_STD_RANK (conv) < PBOOL_RANK)\n+\tICS_STD_RANK (conv) = PBOOL_RANK;\n     }\n   else if (INTEGRAL_CODE_P (tcode) || tcode == REAL_TYPE)\n     {\n       if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n \treturn 0;\n-      else if (to == type_promotes_to (from))\n-\tconv = build_conv (PROMO_CONV, to, conv);\n-      else \n-\tconv = build_conv (STD_CONV, to, conv);\n+      conv = build_conv (STD_CONV, to, conv);\n+\n+      /* Give this a better rank if it's a promotion.  */\n+      if (to == type_promotes_to (from)\n+\t  && ICS_STD_RANK (TREE_OPERAND (conv, 0)) <= PROMO_RANK)\n+\tICS_STD_RANK (conv) = PROMO_RANK;\n     }\n   else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t   && DERIVED_FROM_P (to, from))\n-    {\n-      conv = build_conv (BASE_CONV, to, conv);\n-    }\n+    conv = build_conv (BASE_CONV, to, conv);\n   else\n     return 0;\n \n@@ -2021,25 +2011,70 @@ implicit_conversion (to, from, expr, flags)\n   if (! cand)\n     return NULL_TREE;\n \n-  conv = cand->second_conv;\n-\n-  for (t = conv; TREE_CODE (TREE_OPERAND (t, 0)) != EXACT_MATCH; )\n-    t = TREE_OPERAND (t, 0));\n-\n-  TREE_OPERAND (t, 0) = build (USER_CONV\n-\n-  return conv;\n+  return cand->second_conv;\n }\n \n struct z_candidate *\n-add_method_candidate (candidates, method, instance, parms, flags)\n+add_function_candidate (candidates, fn, arglist, flags)\n      struct z_candidate *candidates;\n-     tree method, instance, parms;\n+     tree fn, args;\n      int flags;\n {\n-  \n+  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  int i, len = list_length (args);\n+  tree convs = make_tree_vec (len);\n+  tree parmnode = parmlist;\n+  tree argnode = arglist;\n+  int viable = 1;\n+  struct z_candidate *cand;\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      tree arg = TREE_VALUE (argnode);\n+      tree argtype = TREE_TYPE (arg);\n+      tree t;\n+\n+      if (parmnode == void_list_node)\n+\tbreak;\n+      else if (parmnode)\n+\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n+      else\n+\t{\n+\t  t = build1 (EXACT_CONV, argtype, arg);\n+\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t}\n+\n+      TREE_VEC_ELT (convs, i) = t;\n+      if (! t)\n+\t{\n+\t  viable = 0;\n+\t  break;\n+\t}\n+\n+      if (parm)\n+\tparm = TREE_CHAIN (parm);\n+      arg = TREE_CHAIN (arg);\n+    }\n+\n+  if (parmnode && parmnode != void_list_node)\n+    viable = 0;\n+\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+\n+  cand->fn = fn;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->template = NULL_TREE;\n+  cand->basetype_path = NULL_TREE;\n+  cand->next = candidates;\n+\n+  return cand;\n }\n \n+/* Returns the best overload candidate to perform the requested\n+   conversion.  */\n+\n struct z_candidate *\n build_user_type_conversion_1 (totype, expr, flags)\n      tree totype, expr;\n@@ -2048,6 +2083,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n   struct z_candidate *candidates, *cand;\n   tree fromtype = TREE_TYPE (expr);\n   tree ctors = NULL_TREE, convs = NULL_TREE, t;\n+  tree method_args;\n \n   if (IS_AGGR_TYPE (totype))\n     ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n@@ -2059,24 +2095,35 @@ build_user_type_conversion_1 (totype, expr, flags)\n   for (; ctors; ctors = DECL_CHAIN (ctors))\n     {\n       candidates = add_ctor_candidate (candidates, ctors, expr, flags);\n+      candidates->basetype_path = TYPE_BINFO (totype);\n     }\n \n+  method_args = build_tree_list\n+    (NULL_TREE, build_unary_op (ADDR_EXPR, expr, 0));\n+\n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n       tree fn = TREE_VALUE (convs);\n       tree ics = standard_conversion (totype, TREE_TYPE (TREE_TYPE (fn)), 0);\n       if (ics)\n \t{\n-\t  candidates = add_method_candidate\n-\t    (candidates, fn, expr, NULL_TREE, flags);\n+\t  candidates = add_function_candidate\n+\t    (candidates, fn, method_args, flags);\n \t  candidates->second_ics = ics;\n+\t  candidates->basetype_path = TREE_PURPOSE (convs);\n \t}\n     }\n \n   if (! any_viable (candidates))\n     {\n       if (flags & LOOKUP_COMPLAIN)\n-\tcp_error (\"no viable candidates\");\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    /* say why this one won't work or try to be loose */;\n+\t  else\n+\t    cp_error (\"no viable candidates\");\n+\t}\n+\n       return 0;\n     }\n \n@@ -2089,9 +2136,110 @@ build_user_type_conversion_1 (totype, expr, flags)\n \tcp_error (\"ambiguous user-defined type conversion\");\n     }\n \n+  for (t = cand->second_conv; TREE_CODE (TREE_OPERAND (t, 0)) != EXACT_MATCH; )\n+    t = TREE_OPERAND (t, 0);\n+\n+  TREE_OPERAND (t, 0) = build\n+    (USER_CONV, TREE_TYPE (TREE_TYPE (cand->fn)),\n+     NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n+  ICS_USER_FLAG (cand->second_conv) = 1;\n+\n   return cand;\n }\n \n+tree\n+build_user_type_conversion (totype, expr, flags)\n+     tree totype, expr, flags;\n+{\n+  struct z_candidate *cand\n+    = build_user_type_conversion_1 (totype, expr, flags);\n+\n+  return convert_like (cand->second_conv, expr);\n+}\n+\n+void\n+enforce_access (basetype_path, function)\n+     tree basetype_path, function;\n+{\n+  tree access = compute_access (basetype_path, function);\n+\n+  if (access == access_private_node)\n+    {\n+      cp_error_at (\"%s `%+#D' is %s\", name_kind, function, \n+\t\t   TREE_PRIVATE (function) ? \"private\"\n+\t\t   : \"from private base class\");\n+      error (\"within this context\");\n+    }\n+  else if (access == access_protected_node)\n+    {\n+      cp_error_at (\"%s `%+#D' %s\", name_kind, function,\n+\t\t   TREE_PROTECTED (function) ? \"is protected\"\n+\t\t   : \"has protected accessibility\");\n+      error (\"within this context\");\n+    }\n+}\n+\n+tree\n+convert_like (convs, expr)\n+     tree convs, expr;\n+{\n+  tree previous;\n+\n+  if (TREE_CODE (convs) == USER_CONV)\n+    {\n+      tree fn = TREE_OPERAND (convs, 1);\n+      enforce_access (TREE_OPERAND (convs, 3), fn);\n+      return build_over_call (TREE_OPERAND (convs, 1),\n+\t\t\t      TREE_OPERAND (convs, 2), expr, LOOKUP_NORMAL);\n+    }\n+  else if (TREE_CODE (convs) == EXACT_CONV)\n+    return expr;\n+\n+  previous = convert_like (TREE_OPERAND (convs, 0), expr);\n+  return convert (TREE_TYPE (convs), expr);\n+}\n+\n+tree\n+build_over_call (fn, convs, args, flags)\n+     tree fn, convs, args;\n+     int flags;\n+{\n+  tree converted_args;\n+  tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  tree conv = convs;\n+  tree arg = args;\n+\n+  if (TREE_CODE (arg) != TREE_LIST)\n+    arg = build_tree_list (NULL_TREE, arg);\n+\n+  for (; arg;\n+       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg),\n+       conv = TREE_CHAIN (conv))\n+    converted_args = tree_cons\n+      (NULL_TREE, convert_like (TREE_VALUE (conv), TREE_VALUE (arg)),\n+       converted_args);\n+\n+  for (; parm; parm = TREE_CHAIN (parm))\n+    converted_args = tree_cons\n+      (NULL_TREE,\n+       convert_for_ellipsis (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n+       converted_args);\n+\n+  converted_args = nreverse (converted_args);\n+\n+  return build_x_call (fn, converted_args, flags);\n+}\n+\n+tree\n+build_x_call (fn, args, flags)\n+     tree fn, args;\n+     int flags;\n+{\n+  if (DECL_FUNCTION_MEMBER_P (fn))\n+    {\n+    }\n+}\n+\n /* Compare two implicit conversion sequences according to the rules set out in\n    [over.ics.rank].  Return values:\n \n@@ -2139,29 +2287,6 @@ compare_ics (ics1, ics2)\n   /* A conversion that is not a conversion of a pointer,  or  pointer  to\n      member,  to  bool  is  better than another conversion that is such a\n      conversion.  */\n-  {\n-    int bool1 = TREE_CODE (ics1) == BOOL_CONV;\n-    int bool2 = TREE_CODE (ics2) == BOOL_CONV;\n-\n-    if (bool1)\n-      {\n-\ttree it = TREE_TYPE (TREE_OPERAND (ics1, 0));\n-\tif (TREE_CODE (it) != POINTER_TYPE\n-\t    && ! TYPE_PTRMEMFUNC_TYPE (it))\n-\t  bool1 = 0;\n-      }\n-    if (bool2)\n-      {\n-\ttree it = TREE_TYPE (TREE_OPERAND (ics2, 0));\n-\tif (TREE_CODE (it) != POINTER_TYPE\n-\t    && ! TYPE_PTRMEMFUNC_TYPE (it))\n-\t  bool2 = 0;\n-      }\n-    if (bool1 && ! bool2)\n-      return 1;\n-    if (bool2 && ! bool1)\n-      return -1;\n-  }\n #endif\n \n   if (TREE_CODE (ics1) == QUAL_CONV)\n@@ -2306,12 +2431,27 @@ compare_ics (ics1, ics2)\n   return 0;\n }\n \n+/* Compare two candidates for overloading as described in\n+   [over.match.best].  Return values:\n+\n+      1: cand1 is better than cand2\n+     -1: cand2 is better than cand1\n+      0: cand1 and cand2 are indistinguishable */\n+\n int joust (cand1, cand2)\n      struct z_candidate *cand1, *cand2;\n {\n   int winner = 0;\n   int i;\n \n+  /* a viable function F1\n+     is defined to be a better function than another viable function F2  if\n+     for  all arguments i, ICSi(F1) is not a worse conversion sequence than\n+     ICSi(F2), and then */\n+\n+  /* for some argument j, ICSj(F1) is a better conversion  sequence  than\n+     ICSj(F2) */\n+\n   for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n     {\n       int comp = compare_ics (TREE_VEC_ELT (cand1->convs, i),\n@@ -2325,21 +2465,45 @@ int joust (cand1, cand2)\n \t}\n     }\n \n-  if (winner == 0 && cand1->second_ics)\n+  if (winner)\n+    return winner;\n+\n+  /* or, if not that,\n+     F1 is a non-template function and F2 is a template function */\n+\n+  if (! cand1->template && cand2->template)\n+    return 1;\n+  else if (cand1->template && ! cand2->template)\n+    return -1;\n+\n+  /* or, if not that,\n+     the  context  is  an  initialization by user-defined conversion (see\n+     _dcl.init_  and  _over.match.user_)  and  the  standard   conversion\n+     sequence  from  the return type of F1 to the destination type (i.e.,\n+     the type of the entity being initialized)  is  a  better  conversion\n+     sequence  than the standard conversion sequence from the return type\n+     of F2 to the destination type. */\n+\n+  if (cand1->second_ics)\n     winner = compare_ics (cand1->second_ics, cand2->second_ics);\n \n   return winner;\n }\n \n+/* Given a list of candidates for overloading, find the best one, if any.\n+   This algorithm has a worst case of O(2n) (winner is last), and a best\n+   case of O(n/2) (totally ambiguous); much better than a sorting\n+   algorithm.  */\n+\n struct z_candidate *\n tourney (candidates)\n      struct z_candidate *candidates;\n {\n   struct z_candidate *champ = candidates, *challenger;\n   int fate;\n \n-  /* This algorithm has a worst case of O(2n) (winner is last) , and a best\n-     case of O(n/2) (no winner); much better than a sorting algorithm.  */\n+  /* Walk through the list once, comparing each current champ to the next\n+     candidate, knocking out a candidate or two with each comparison.  */\n \n   for (challenger = champ->next; challenger; )\n     {\n@@ -2361,6 +2525,10 @@ tourney (candidates)\n \t}\n     }\n \n+  /* Make sure the champ is better than all the candidates it hasn't yet\n+     been compared to.  This may do one more comparison than necessary.  Oh\n+     well.  */\n+\n   for (challenger = candidates; challenger != champ;\n        challenger = challenger->next)\n     {"}, {"sha": "7e8673b50a3aaa878c023f4110de125d030d8cf2", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -165,7 +165,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n \t\t    init = maybe_build_cleanup (convert_from_reference (init));\n \t\t    if (init != NULL_TREE)\n-\t\t      expand_expr (init, 0, 0, 0);\n+\t\t      expand_expr (init, const0_rtx, VOIDmode, 0);\n \t\t  }\n \t\tcall_target = return_target = DECL_RTL (slot);\n \t      }"}, {"sha": "1c892ba558f53fc72bf74f26392ee5a62f6c6534", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -1403,7 +1403,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t    /* Unify the initialization targets.  */\n \t\t    DECL_RTL (TREE_OPERAND (init, 0)) = DECL_RTL (exp);\n \t\t  else\n-\t\t    DECL_RTL (TREE_OPERAND (init, 0)) = expand_expr (exp, NULL_RTX, 0, 0);\n+\t\t    DECL_RTL (TREE_OPERAND (init, 0)) = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n \t\t  expand_expr_stmt (init);\n \t\t  return;\n@@ -2965,7 +2965,7 @@ build_new (placement, decl, init, use_global_new)\n \t      do_pending_stack_adjust ();\n \t      start_sequence_for_rtl_expr (xval);\n \t      emit_note (0, -1);\n-\t      rtxval = expand_expr (alloc_expr, NULL, VOIDmode, 0);\n+\t      rtxval = expand_expr (alloc_expr, NULL_RTX, VOIDmode, 0);\n \t      do_pending_stack_adjust ();\n \t      TREE_SIDE_EFFECTS (xval) = 1;\n \t      RTL_EXPR_SEQUENCE (xval) = get_insns ();"}, {"sha": "79097b2c830b21278a24a703b1b7495bd8f9b179", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -1750,6 +1750,8 @@ emit_thunk (thunk_fndecl)\n   if (current_function_decl)\n     abort ();\n   current_function_decl = thunk_fndecl;\n+\n+  TREE_SET_CODE (thunk_fndecl, FUNCTION_DECL);\n #ifdef ASM_OUTPUT_MI_THUNK\n   temporary_allocation ();\n   assemble_start_function (thunk_fndecl, fnname);\n@@ -1937,6 +1939,7 @@ emit_thunk (thunk_fndecl)\n   permanent_allocation (1);\n   flag_omit_frame_pointer = save_ofp;\n #endif /* ASM_OUTPUT_MI_THUNK */\n+  TREE_SET_CODE (thunk_fndecl, THUNK_DECL);\n \n   decl_printable_name = save_decl_printable_name;\n   current_function_decl = 0;"}, {"sha": "87cebbdfeaabc1095014be0b47ef5b22ba529360", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -2093,7 +2093,7 @@ tsubst_expr (t, args, nargs, in_decl)\n \t   tsubst (TREE_OPERAND (t, 2), args, nargs, in_decl));\n \tinit = tsubst_expr (TREE_OPERAND (t, 3), args, nargs, in_decl);\n \tcp_finish_decl\n-\t  (dcl, init, NULL_TREE, 1, init ? LOOKUP_ONLYCONVERTING : 0);\n+\t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n \tresume_momentary (i);\n \treturn dcl;\n       }"}, {"sha": "921db00c564f3f442887217ce1bc61ad3ccb6d3c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -3508,8 +3508,7 @@ add_conversions (binfo)\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n       if (! IDENTIFIER_TYPENAME_P (DECL_NAME (tmp)))\n \tbreak;\n-      conversions = tree_cons (TREE_TYPE (TREE_TYPE (tmp)), tmp,\n-\t\t\t       conversions);\n+      conversions = tree_cons (binfo, tmp, conversions);\n     }\n }\n "}, {"sha": "a729c218de04b25c6d934c9dcde0e038408a73b4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0128b67f491807d78d52d37ed7144570a93c55a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a0128b67f491807d78d52d37ed7144570a93c55a", "patch": "@@ -5370,7 +5370,7 @@ expand_target_expr (t)\n   do_pending_stack_adjust ();\n   start_sequence_for_rtl_expr (xval);\n   emit_note (0, -1);\n-  rtxval = expand_expr (t, NULL, VOIDmode, 0);\n+  rtxval = expand_expr (t, NULL_RTX, VOIDmode, 0);\n   do_pending_stack_adjust ();\n   TREE_SIDE_EFFECTS (xval) = 1;\n   RTL_EXPR_SEQUENCE (xval) = get_insns ();\n@@ -5803,7 +5803,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t expanded without a target.  */\n       if (TREE_CODE (newrhs) == TARGET_EXPR)\n \tnewrhs = build (COMPOUND_EXPR, TREE_TYPE (newrhs), newrhs,\n-\t\t\tTREE_VALUE (newrhs));\n+\t\t\tTREE_OPERAND (newrhs, 0));\n     }\n \n   if (TREE_CODE (newrhs) == ERROR_MARK)"}]}