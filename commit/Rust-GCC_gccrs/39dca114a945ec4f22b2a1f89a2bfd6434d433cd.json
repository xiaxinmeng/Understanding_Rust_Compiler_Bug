{"sha": "39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkY2ExMTRhOTQ1ZWM0ZjIyYjJhMWY4OWEyYmZkNjQzNGQ0MzNjZA==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2004-08-23T16:49:17Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2004-08-23T16:49:17Z"}, "message": "re PR libffi/13141 (FAIL: InvokeReturn output - source compiled test <libffi problem>)\n\n2004-08-23  David Daney <daney@avtrex.com>\n\n\tPR libgcj/13141\n\t* src/mips/ffitarget.h (FFI_O32_SOFT_FLOAT): New ABI.\n\t* src/mips/ffi.c (ffi_prep_args): Fix alignment calculation.\n\t(ffi_prep_cif_machdep): Handle FFI_O32_SOFT_FLOAT floating point\n\tparameters and return types.\n\t(ffi_call): Handle FFI_O32_SOFT_FLOAT ABI.\n\t(ffi_prep_closure): Ditto.\n\t(ffi_closure_mips_inner_O32): Handle FFI_O32_SOFT_FLOAT ABI, fix\n\talignment calculations.\n\t* src/mips/o32.S (ffi_closure_O32): Don't use floating point\n\tinstructions if FFI_O32_SOFT_FLOAT, make stack frame ABI compliant.\n\nFrom-SVN: r86429", "tree": {"sha": "626756a6b5df83c58d0ff6beaaa599cb6efca6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/626756a6b5df83c58d0ff6beaaa599cb6efca6ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/comments", "author": null, "committer": null, "parents": [{"sha": "106a7200994014087d9dfcc0ce8f437c8623bce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106a7200994014087d9dfcc0ce8f437c8623bce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106a7200994014087d9dfcc0ce8f437c8623bce9"}], "stats": {"total": 183, "additions": 139, "deletions": 44}, "files": [{"sha": "b33faeace235be64f4c2335df3d7463de840d23f", "filename": "libffi/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "patch": "@@ -1,3 +1,17 @@\n+2004-08-23  David Daney <daney@avtrex.com>\n+\n+\tPR libgcj/13141\n+\t* src/mips/ffitarget.h (FFI_O32_SOFT_FLOAT): New ABI.\n+\t* src/mips/ffi.c (ffi_prep_args): Fix alignment calculation.\n+\t(ffi_prep_cif_machdep): Handle FFI_O32_SOFT_FLOAT floating point\n+\tparameters and return types.\n+\t(ffi_call): Handle FFI_O32_SOFT_FLOAT ABI.\n+\t(ffi_prep_closure): Ditto.\n+\t(ffi_closure_mips_inner_O32): Handle FFI_O32_SOFT_FLOAT ABI, fix\n+\talignment calculations.\n+\t* src/mips/o32.S (ffi_closure_O32): Don't use floating point\n+\tinstructions if FFI_O32_SOFT_FLOAT, make stack frame ABI compliant.\n+\n 2004-08-14  Casey Marshall <csm@gnu.org>\n \n \t* src/mips/ffi.c (ffi_pref_cif_machdep): set `cif->flags' to"}, {"sha": "352226c7f547af59888fb8f40bc5d8a8a89d120b", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "patch": "@@ -85,10 +85,15 @@ static void ffi_prep_args(char *stack,\n   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types; i; i--, p_arg++)\n     {\n       size_t z;\n+      unsigned short a;\n \n       /* Align if necessary */\n-      if (((*p_arg)->alignment - 1) & (unsigned) argp) {\n-\targp = (char *) ALIGN(argp, (*p_arg)->alignment);\n+      a = (*p_arg)->alignment;\n+      if (a < FFI_SIZEOF_ARG)\n+        a = FFI_SIZEOF_ARG;\n+      \n+      if ((a - 1) & (unsigned) argp) {\n+\targp = (char *) ALIGN(argp, a);\n \tFIX_ARGP;\n       }\n \n@@ -268,9 +273,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   cif->flags = 0;\n \n #if _MIPS_SIM == _ABIO32\n-  /* Set the flags necessary for O32 processing */\n+  /* Set the flags necessary for O32 processing.  FFI_O32_SOFT_FLOAT\n+   * does not have special handling for floating point args.\n+   */\n \n-  if (cif->rtype->type != FFI_TYPE_STRUCT)\n+  if (cif->rtype->type != FFI_TYPE_STRUCT && cif->abi == FFI_O32)\n     {\n       if (cif->nargs > 0)\n \t{\n@@ -307,23 +314,49 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     }\n       \n   /* Set the return type flag */\n-  switch (cif->rtype->type)\n-    {\n-    case FFI_TYPE_VOID:\n-    case FFI_TYPE_STRUCT:\n-    case FFI_TYPE_FLOAT:\n-    case FFI_TYPE_DOUBLE:\n-      cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);\n-      break;\n \n-    case FFI_TYPE_SINT64:\n-    case FFI_TYPE_UINT64:\n-      cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);\n-      break;\n+  if (cif->abi == FFI_O32_SOFT_FLOAT)\n+    {\n+      switch (cif->rtype->type)\n+        {\n+        case FFI_TYPE_VOID:\n+        case FFI_TYPE_STRUCT:\n+          cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);\n+          break;\n+\n+        case FFI_TYPE_SINT64:\n+        case FFI_TYPE_UINT64:\n+        case FFI_TYPE_DOUBLE:\n+          cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);\n+          break;\n       \n-    default:\n-      cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);\n-      break;\n+        case FFI_TYPE_FLOAT:\n+        default:\n+          cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);\n+          break;\n+        }\n+    }\n+  else\n+    {\n+      /* FFI_O32 */      \n+      switch (cif->rtype->type)\n+        {\n+        case FFI_TYPE_VOID:\n+        case FFI_TYPE_STRUCT:\n+        case FFI_TYPE_FLOAT:\n+        case FFI_TYPE_DOUBLE:\n+          cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 2);\n+          break;\n+\n+        case FFI_TYPE_SINT64:\n+        case FFI_TYPE_UINT64:\n+          cif->flags += FFI_TYPE_UINT64 << (FFI_FLAG_BITS * 2);\n+          break;\n+      \n+        default:\n+          cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 2);\n+          break;\n+        }\n     }\n #endif\n \n@@ -448,6 +481,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     {\n #if _MIPS_SIM == _ABIO32\n     case FFI_O32:\n+    case FFI_O32_SOFT_FLOAT:\n       ffi_call_O32(ffi_prep_args, &ecif, cif->bytes, \n \t\t   cif->flags, ecif.rvalue, fn);\n       break;\n@@ -482,7 +516,7 @@ ffi_prep_closure (ffi_closure *closure,\n   unsigned int ctx = (unsigned int) closure;\n \n #if defined(FFI_MIPS_O32)\n-  FFI_ASSERT(cif->abi == FFI_O32);\n+  FFI_ASSERT(cif->abi == FFI_O32 || cif->abi == FFI_O32_SOFT_FLOAT);\n   fn = (unsigned int) ffi_closure_O32;\n #else /* FFI_MIPS_N32 */\n   FFI_ASSERT(cif->abi == FFI_N32);\n@@ -535,10 +569,10 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n   cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof (void *));\n \n-  seen_int = 0;\n+  seen_int = (cif->abi == FFI_O32_SOFT_FLOAT);\n   argn = 0;\n \n-  if (cif->flags == FFI_TYPE_STRUCT)\n+  if ((cif->flags >> (FFI_FLAG_BITS * 2)) == FFI_TYPE_STRUCT)\n     {\n       rvalue = (void *) ar[0];\n       argn = 1;\n@@ -558,12 +592,7 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \t}\n       else\n \t{\n-\t  /* 8-byte arguments are always 8-byte aligned. */\n-\t  if (arg_types[i]->size == 8 && (argn & 0x1))\n-\t    argn++;\n-\t  /* Float arguments take up two register slots. The float word\n-\t     is the upper one. */\n-\t  if (argn == 2 && arg_types[i]->type == FFI_TYPE_FLOAT)\n+\t  if (arg_types[i]->alignment == 8 && (argn & 0x1))\n \t    argn++;\n \t  avalue[i] = ((char *) &ar[argn]);\n \t  seen_int = 1;\n@@ -575,7 +604,22 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n   /* Invoke the closure. */\n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n-  return cif->rtype->type;\n+  if (cif->abi == FFI_O32_SOFT_FLOAT)\n+    {\n+      switch (cif->rtype->type)\n+        {\n+        case FFI_TYPE_FLOAT:\n+          return FFI_TYPE_INT;\n+        case FFI_TYPE_DOUBLE:\n+          return FFI_TYPE_UINT64;\n+        default:\n+          return cif->rtype->type;\n+        }\n+    }\n+  else\n+    {\n+      return cif->rtype->type;\n+    }\n }\n \n #endif /* FFI_CLOSURES */"}, {"sha": "6f28e70011132644a3cda36ac2f3e1de8282a917", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "patch": "@@ -138,9 +138,14 @@ typedef enum ffi_abi {\n   FFI_O32,\n   FFI_N32,\n   FFI_N64,\n+  FFI_O32_SOFT_FLOAT,\n \n #ifdef FFI_MIPS_O32\n+#ifdef __mips_soft_float\n+  FFI_DEFAULT_ABI = FFI_O32_SOFT_FLOAT,\n+#else\n   FFI_DEFAULT_ABI = FFI_O32,\n+#endif\n #else\n   FFI_DEFAULT_ABI = FFI_N32,\n #endif"}, {"sha": "7391ce3fbfb2f8f85cdec04dd6069b01bb283d70", "filename": "libffi/src/mips/o32.S", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fo32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dca114a945ec4f22b2a1f89a2bfd6434d433cd/libffi%2Fsrc%2Fmips%2Fo32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fo32.S?ref=39dca114a945ec4f22b2a1f89a2bfd6434d433cd", "patch": "@@ -36,7 +36,6 @@\n #define flags\t a3\n \t\t\n #define SIZEOF_FRAME\t( 4 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG )\n-#define SIZEOF_FRAME2\t( 8 * FFI_SIZEOF_ARG + 2 * FFI_SIZEOF_ARG )\n \n \t.text\n \t.align\t2\n@@ -188,7 +187,28 @@ $LFE0:\n /* ffi_closure_O32. Expects address of the passed-in ffi_closure\n \tin t0. Stores any arguments passed in registers onto the\n \tstack, then calls ffi_closure_mips_inner_O32, which\n-\tthen decodes them. */\n+\tthen decodes them.\n+\t\n+\tStack layout:\n+\n+\t14 - Start of parameters, original sp\n+\t13 - ra save\n+\t12 - fp save\n+\t11 - $16 (s0) save\n+\t10 - cprestore\n+\t 9 - return value high (v1)\n+\t 8 - return value low (v0)\n+\t 7 - f14 (le high, be low)\n+\t 6 - f14 (le low, be high)\n+\t 5 - f12 (le high, be low)\n+\t 4 - f12 (le low, be high)\n+\t 3 - Called function a3 save\n+\t 2 - Called function a2 save\n+\t 1 - Called function a1 save\n+\t 0 - Called function a0 save our sp, fp point here\n+\t */\n+\t\n+#define SIZEOF_FRAME2\t( 14 * FFI_SIZEOF_ARG )\n \n \t.text\n \t.align\t2\n@@ -202,10 +222,10 @@ $LFB1:\n \t.cpload\t$25\n \t.set\treorder\n \tSUBU\t$sp, SIZEOF_FRAME2\n-\t.cprestore SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG\n+\t.cprestore SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG\n $LCFI4:\n+\tREG_S\t$16, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\t # Save s0\n \tREG_S\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Save frame pointer\n-$LCFI5:\n \tREG_S\tra, SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Save return address\n $LCFI6:\n \tmove\t$fp, $sp\n@@ -218,14 +238,21 @@ $LCFI7:\n \tREG_S\t$6, SIZEOF_FRAME2 + 2*FFI_SIZEOF_ARG($fp)\n \tREG_S\t$7, SIZEOF_FRAME2 + 3*FFI_SIZEOF_ARG($fp)\n \n+\t# Load ABI enum to $16\n+\tREG_L\t$16, 20($8)\t# cif pointer follows tramp.\n+\tREG_L\t$16, 0($16)\t# abi is first member.\n+\n+\tli\t$13, 1\t\t# FFI_O32\n+\tbne\t$16, $13, 1f\t# Skip fp save if FFI_O32_SOFT_FLOAT\n+\t\n \t# Store all possible float/double registers.\n \ts.d\t$f12, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG($fp)\n \ts.d\t$f14, SIZEOF_FRAME2 -  8*FFI_SIZEOF_ARG($fp)\n-\n+1:\t\n \t# Call ffi_closure_mips_inner_O32 to do the work.\n \tla\t$25, ffi_closure_mips_inner_O32\n \tmove\t$4, $8\t # Pointer to the ffi_closure\n-\taddu\t$5, $fp, SIZEOF_FRAME2 -  4*FFI_SIZEOF_ARG\n+\taddu\t$5, $fp, SIZEOF_FRAME2 -  6*FFI_SIZEOF_ARG\n \taddu\t$6, $fp, SIZEOF_FRAME2 +  0*FFI_SIZEOF_ARG\n \taddu\t$7, $fp, SIZEOF_FRAME2 - 10*FFI_SIZEOF_ARG\n \tjal\t$31, $25\n@@ -235,28 +262,30 @@ $LCFI7:\n \tli\t$9, FFI_TYPE_VOID\n \tbeq\t$8, $9, closure_done\n \n+\tli\t$13, 1\t\t# FFI_O32\n+\tbne\t$16, $13, 1f\t# Skip fp restore if FFI_O32_SOFT_FLOAT\n+\n \tli\t$9, FFI_TYPE_FLOAT\n-\tl.s\t$f0, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\tl.s\t$f0, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n \tbeq\t$8, $9, closure_done\n \n \tli\t$9, FFI_TYPE_DOUBLE\n-\tl.d\t$f0, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\tl.d\t$f0, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n \tbeq\t$8, $9, closure_done\n-\n+1:\t\n \tli\t$9, FFI_TYPE_SINT64\n-\tREG_L\t$3, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($fp)\n+\tREG_L\t$3, SIZEOF_FRAME2 - 5*FFI_SIZEOF_ARG($fp)\n \tbeq\t$8, $9, integer\n-\n \tli\t$9, FFI_TYPE_UINT64\n-\tREG_L\t$3, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($fp)\n \tbeq\t$8, $9, integer\n \n integer:\n-\tREG_L\t$2, SIZEOF_FRAME2 - 4*FFI_SIZEOF_ARG($fp)\n+\tREG_L\t$2, SIZEOF_FRAME2 - 6*FFI_SIZEOF_ARG($fp)\n \n closure_done:\n \t# Epilogue\n \tmove\t$sp, $fp\n+\tREG_L\t$16, SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\t # Restore s0\n \tREG_L\t$fp, SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\t # Restore frame pointer\n \tREG_L\tra,  SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\t # Restore return address\n \tADDU\t$sp, SIZEOF_FRAME2\n@@ -319,10 +348,13 @@ $LASFDE1:\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n \t.4byte\t$LCFI4-$LFB1\n \t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 0x28\n+\t.uleb128 0x38\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n \t.4byte\t$LCFI6-$LCFI4\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x10\t # $16\n+\t.sleb128 -3\t # SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x1e\t # $fp\n \t.sleb128 -2\t # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n@@ -332,7 +364,7 @@ $LASFDE1:\n \t.4byte\t$LCFI7-$LCFI6\n \t.byte\t0xc\t # DW_CFA_def_cfa\n \t.uleb128 0x1e\n-\t.uleb128 0x28\n+\t.uleb128 0x38\n \t.align\t2\n $LEFDE1:\n "}]}