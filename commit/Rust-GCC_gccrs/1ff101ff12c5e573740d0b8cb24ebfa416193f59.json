{"sha": "1ff101ff12c5e573740d0b8cb24ebfa416193f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmMTAxZmYxMmM1ZTU3Mzc0MGQwYjhjYjI0ZWJmYTQxNjE5M2Y1OQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-11-09T16:04:42Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-11-09T16:04:42Z"}, "message": "PR 46686 Implement backtrace with _Unwind_Backtrace from libgcc.\n\n2011-11-09  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/46686\n\t* configure.ac: Don't check execinfo.h, backtrace,\n\tbacktrace_symbols_fd. Check execve instead of execvp. Call\n\tGCC_CHECK_UNWIND_GETIPINFO.\n\t* runtime/backtrace.c: Don't include unused headers, include\n\tlimits.h and unwind.h.\n\t(CAN_FORK): Check execve instead of execvp.\n\t(GLIBC_BACKTRACE): Remove.\n\t(bt_header): Conform to gdb backtrace format.\n\t(struct bt_state): New struct.\n\t(trace_function): New function.\n\t(show_backtrace): Use _Unwind_Backtrace from libgcc instead of\n\tglibc backtrace functions.\n\t* Makefile.in: Regenerated.\n\t* aclocal.m4: Regenerated.\n\t* config.h.in: Regenerated.\n\t* configure: Regenerated.\n\nFrom-SVN: r181209", "tree": {"sha": "b0dcabb54361e5e3a6242e307bb50ceb26cba8ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0dcabb54361e5e3a6242e307bb50ceb26cba8ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff101ff12c5e573740d0b8cb24ebfa416193f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff101ff12c5e573740d0b8cb24ebfa416193f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff101ff12c5e573740d0b8cb24ebfa416193f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff101ff12c5e573740d0b8cb24ebfa416193f59/comments", "author": null, "committer": null, "parents": [{"sha": "560bb0136fa74c8562d7e078eef29d3d1f7b6fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/560bb0136fa74c8562d7e078eef29d3d1f7b6fc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/560bb0136fa74c8562d7e078eef29d3d1f7b6fc5"}], "stats": {"total": 378, "additions": 189, "deletions": 189}, "files": [{"sha": "b553031aad2e43160a3cd82dda157cd3248d4a4b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -1,3 +1,23 @@\n+2011-11-09  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/46686\n+\t* configure.ac: Don't check execinfo.h, backtrace,\n+\tbacktrace_symbols_fd. Check execve instead of execvp. Call\n+\tGCC_CHECK_UNWIND_GETIPINFO.\n+\t* runtime/backtrace.c: Don't include unused headers, include\n+\tlimits.h and unwind.h.\n+\t(CAN_FORK): Check execve instead of execvp.\n+\t(GLIBC_BACKTRACE): Remove.\n+\t(bt_header): Conform to gdb backtrace format.\n+\t(struct bt_state): New struct.\n+\t(trace_function): New function.\n+\t(show_backtrace): Use _Unwind_Backtrace from libgcc instead of\n+\tglibc backtrace functions.\n+\t* Makefile.in: Regenerated.\n+\t* aclocal.m4: Regenerated.\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\n 2011-11-09  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         PR libfortran/50016"}, {"sha": "205037c7877ef015ba79178316d6e9907c62aae1", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -51,6 +51,7 @@ am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n \t$(top_srcdir)/../config/multi.m4 \\\n \t$(top_srcdir)/../config/override.m4 \\\n \t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n \t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n \t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n \t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../config/acx.m4 \\"}, {"sha": "ebf36069e9a14f8b5d809ca85f84edf8d37ee91b", "filename": "libgfortran/aclocal.m4", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Faclocal.m4?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -974,6 +974,7 @@ m4_include([../config/lthostflags.m4])\n m4_include([../config/multi.m4])\n m4_include([../config/override.m4])\n m4_include([../config/stdint.m4])\n+m4_include([../config/unwind_ipinfo.m4])\n m4_include([../ltoptions.m4])\n m4_include([../ltsugar.m4])\n m4_include([../ltversion.m4])"}, {"sha": "66d80665d9930c356ca119ef6b30106e46160546", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -81,12 +81,6 @@\n /* Define to 1 if the target supports __attribute__((visibility(...))). */\n #undef HAVE_ATTRIBUTE_VISIBILITY\n \n-/* Define to 1 if you have the `backtrace' function. */\n-#undef HAVE_BACKTRACE\n-\n-/* Define to 1 if you have the `backtrace_symbols_fd' function. */\n-#undef HAVE_BACKTRACE_SYMBOLS_FD\n-\n /* Define if powf is broken. */\n #undef HAVE_BROKEN_POWF\n \n@@ -348,14 +342,11 @@\n /* libm includes erfl */\n #undef HAVE_ERFL\n \n-/* Define to 1 if you have the <execinfo.h> header file. */\n-#undef HAVE_EXECINFO_H\n-\n /* Define to 1 if you have the `execl' function. */\n #undef HAVE_EXECL\n \n-/* Define to 1 if you have the `execvp' function. */\n-#undef HAVE_EXECVP\n+/* Define to 1 if you have the `execve' function. */\n+#undef HAVE_EXECVE\n \n /* libm includes exp */\n #undef HAVE_EXP\n@@ -453,6 +444,9 @@\n /* Define to 1 if you have the `gethostname' function. */\n #undef HAVE_GETHOSTNAME\n \n+/* Define if _Unwind_GetIPInfo is available. */\n+#undef HAVE_GETIPINFO\n+\n /* Define to 1 if you have the `getlogin' function. */\n #undef HAVE_GETLOGIN\n "}, {"sha": "0ee67d5d1a7c1ef48bb9bb222f470826eb78a02a", "filename": "libgfortran/configure", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -766,6 +766,7 @@ with_gnu_ld\n enable_libtool_lock\n enable_largefile\n enable_libquadmath_support\n+with_system_libunwind\n '\n       ac_precious_vars='build_alias\n host_alias\n@@ -1424,6 +1425,7 @@ Optional Packages:\n   --with-pic              try to use only PIC/non-PIC objects [default=use\n                           both]\n   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]\n+  --with-system-libunwind use installed libunwind\n \n Some influential environment variables:\n   CC          C compiler command\n@@ -12112,7 +12114,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12115 \"configure\"\n+#line 12117 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12218,7 +12220,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12221 \"configure\"\n+#line 12223 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -15919,7 +15921,7 @@ fi\n \n done\n \n-for ac_header in fenv.h fptrap.h float.h execinfo.h pwd.h\n+for ac_header in fenv.h fptrap.h float.h pwd.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -16419,7 +16421,7 @@ _ACEOF\n fi\n done\n \n-for ac_func in wait setmode execvp pipe dup2 close fdopen strcasestr getrlimit\n+for ac_func in wait setmode execve pipe dup2 close fdopen strcasestr getrlimit\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n@@ -16472,21 +16474,6 @@ fi\n done\n \n \n-# Check for glibc backtrace functions\n-for ac_func in backtrace backtrace_symbols_fd\n-do :\n-  as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n-ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n-eval as_val=\\$$as_ac_var\n-   if test \"x$as_val\" = x\"\"yes; then :\n-  cat >>confdefs.h <<_ACEOF\n-#define `$as_echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n-_ACEOF\n-\n-fi\n-done\n-\n-\n # Check libc for getgid, getpid, getuid\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for getgid in -lc\" >&5\n $as_echo_n \"checking for getgid in -lc... \" >&6; }\n@@ -25880,6 +25867,44 @@ $as_echo \"#define HAVE_CRLF 1\" >>confdefs.h\n \n fi\n \n+# Check whether we have _Unwind_GetIPInfo for backtrace\n+\n+\n+# Check whether --with-system-libunwind was given.\n+if test \"${with_system_libunwind+set}\" = set; then :\n+  withval=$with_system_libunwind;\n+fi\n+\n+  # If system-libunwind was not specifically set, pick a default setting.\n+  if test x$with_system_libunwind = x; then\n+    case ${target} in\n+      ia64-*-hpux*) with_system_libunwind=yes ;;\n+      *) with_system_libunwind=no ;;\n+    esac\n+  fi\n+  # Based on system-libunwind and target, do we have ipinfo?\n+  if  test x$with_system_libunwind = xyes; then\n+    case ${target} in\n+      ia64-*-*) have_unwind_getipinfo=no ;;\n+      *) have_unwind_getipinfo=yes ;;\n+    esac\n+  else\n+    # Darwin before version 9 does not have _Unwind_GetIPInfo.\n+\n+    case ${target} in\n+      *-*-darwin[3-8]|*-*-darwin[3-8].*) have_unwind_getipinfo=no ;;\n+      *) have_unwind_getipinfo=yes ;;\n+    esac\n+\n+  fi\n+\n+  if test x$have_unwind_getipinfo = xyes; then\n+\n+$as_echo \"#define HAVE_GETIPINFO 1\" >>confdefs.h\n+\n+  fi\n+\n+\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure"}, {"sha": "dbad8f5b16d40b4d23fc36562b1097e0fd45be84", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -249,7 +249,7 @@ AC_HEADER_TIME\n AC_HAVE_HEADERS(stdio.h stdlib.h string.h unistd.h signal.h stdarg.h)\n AC_CHECK_HEADERS(time.h sys/time.h sys/times.h sys/resource.h)\n AC_CHECK_HEADERS(sys/types.h sys/stat.h sys/wait.h floatingpoint.h ieeefp.h)\n-AC_CHECK_HEADERS(fenv.h fptrap.h float.h execinfo.h pwd.h)\n+AC_CHECK_HEADERS(fenv.h fptrap.h float.h pwd.h)\n AC_CHECK_HEADER([complex.h],[AC_DEFINE([HAVE_COMPLEX_H], [1], [complex.h exists])])\n GCC_HEADER_STDINT(gstdint.h)\n \n@@ -261,14 +261,11 @@ AC_CHECK_MEMBERS([struct stat.st_rdev])\n AC_CHECK_FUNCS(getrusage times mkstemp strtof strtold snprintf ftruncate chsize)\n AC_CHECK_FUNCS(chdir strerror getlogin gethostname kill link symlink perror)\n AC_CHECK_FUNCS(sleep time ttyname signal alarm clock access fork execl)\n-AC_CHECK_FUNCS(wait setmode execvp pipe dup2 close fdopen strcasestr getrlimit)\n+AC_CHECK_FUNCS(wait setmode execve pipe dup2 close fdopen strcasestr getrlimit)\n AC_CHECK_FUNCS(gettimeofday stat fstat lstat getpwuid vsnprintf dup getcwd)\n AC_CHECK_FUNCS(localtime_r gmtime_r strerror_r getpwuid_r ttyname_r)\n AC_CHECK_FUNCS(clock_gettime strftime readlink)\n \n-# Check for glibc backtrace functions\n-AC_CHECK_FUNCS(backtrace backtrace_symbols_fd)\n-\n # Check libc for getgid, getpid, getuid\n AC_CHECK_LIB([c],[getgid],[AC_DEFINE([HAVE_GETGID],[1],[libc includes getgid])])\n AC_CHECK_LIB([c],[getpid],[AC_DEFINE([HAVE_GETPID],[1],[libc includes getpid])])\n@@ -559,6 +556,9 @@ LIBGFOR_CHECK_UNLINK_OPEN_FILE\n # Check whether line terminator is LF or CRLF\n LIBGFOR_CHECK_CRLF\n \n+# Check whether we have _Unwind_GetIPInfo for backtrace\n+GCC_CHECK_UNWIND_GETIPINFO\n+\n AC_CACHE_SAVE\n \n if test ${multilib} = yes; then"}, {"sha": "70aae91cfe99f2ffefb1368be4a21dc7bbee50c4", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 113, "deletions": 154, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff101ff12c5e573740d0b8cb24ebfa416193f59/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=1ff101ff12c5e573740d0b8cb24ebfa416193f59", "patch": "@@ -26,46 +26,38 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include <string.h>\n \n-#ifdef HAVE_STDLIB_H\n-#include <stdlib.h>\n-#endif\n-\n-#ifdef HAVE_INTTYPES_H\n-#include <inttypes.h>\n-#endif\n-\n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n \n-#ifdef HAVE_EXECINFO_H\n-#include <execinfo.h>\n-#endif\n-\n #ifdef HAVE_SYS_WAIT_H\n #include <sys/wait.h>\n #endif\n \n-#include <ctype.h>\n+#include <limits.h>\n+\n+#include \"unwind.h\"\n \n \n /* Macros for common sets of capabilities: can we fork and exec, can\n    we use glibc-style backtrace functions, and can we use pipes.  */\n-#define CAN_FORK (defined(HAVE_FORK) && defined(HAVE_EXECVP) \\\n+#define CAN_FORK (defined(HAVE_FORK) && defined(HAVE_EXECVE) \\\n \t\t  && defined(HAVE_WAIT))\n-#define GLIBC_BACKTRACE (defined(HAVE_BACKTRACE) \\\n-\t\t\t && defined(HAVE_BACKTRACE_SYMBOLS_FD))\n #define CAN_PIPE (CAN_FORK && defined(HAVE_PIPE) \\\n \t\t  && defined(HAVE_DUP2) && defined(HAVE_FDOPEN) \\\n \t\t  && defined(HAVE_CLOSE))\n \n+#ifndef PATH_MAX\n+#define PATH_MAX 4096\n+#endif\n+\n \n /* GDB style #NUM index for each stack frame.  */\n \n static void \n bt_header (int num)\n {\n-  st_printf (\" #%d  \", num);\n+  st_printf (\"#%d  \", num);\n }\n \n \n@@ -106,24 +98,105 @@ fd_gets (char *s, int size, int fd)\n \n extern char *addr2line_path;\n \n+/* Struct containing backtrace state.  */\n+typedef struct\n+{\n+  int frame_number;\n+  int direct_output;\n+  int outfd;\n+  int infd;\n+  int error;\n+}\n+bt_state;\n \n-/* show_backtrace displays the backtrace, currently obtained by means of\n-   the glibc backtrace* functions.  */\n+static _Unwind_Reason_Code\n+trace_function (struct _Unwind_Context *context, void *state_ptr)\n+{\n+  bt_state* state = (bt_state*) state_ptr;\n+  _Unwind_Ptr ip;\n+#ifdef HAVE_GETIPINFO\n+  int ip_before_insn = 0;\n+  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n+  \n+  /* If the unwinder gave us a 'return' address, roll it back a little\n+     to ensure we get the correct line number for the call itself.  */\n+  if (! ip_before_insn)\n+    --ip;\n+#else  \n+  ip = _Unwind_GetIP (context);\n+#endif\n+\n+  if (state->direct_output)\n+    {\n+      bt_header(state->frame_number);\n+      st_printf (\"%p\\n\", (void*) ip);\n+    }\n+  else\n+    {\n+      char addr_buf[GFC_XTOA_BUF_SIZE], func[1024], file[PATH_MAX];\n+      char *p;\n+      const char* addr = gfc_xtoa (ip, addr_buf, sizeof (addr_buf));\n+      write (state->outfd, addr, strlen (addr));\n+      write (state->outfd, \"\\n\", 1);\n+\n+      if (! fd_gets (func, sizeof(func), state->infd))\n+\t{\n+\t  state->error = 1;\n+\t  goto done;\n+\t}\n+      if (! fd_gets (file, sizeof(file), state->infd))\n+\t{\n+\t  state->error = 1;\n+\t  goto done;\n+\t}\n+\t    \n+\tfor (p = func; *p != '\\n' && *p != '\\r'; p++)\n+\t  ;\n+\t*p = '\\0';\n+\t\n+\t/* _start is a setup routine that calls main(), and main() is\n+\t   the frontend routine that calls some setup stuff and then\n+\t   calls MAIN__, so at this point we should stop.  */\n+\tif (strcmp (func, \"_start\") == 0 || strcmp (func, \"main\") == 0)\n+\t  return _URC_END_OF_STACK;\n+\t\n+\tbt_header (state->frame_number);\n+\testr_write (\"0x\");\n+\testr_write (addr);\n+\n+\tif (func[0] != '?' && func[1] != '?')\n+\t  {\n+\t    estr_write (\" in \");\n+\t    estr_write (func);\n+\t  }\n+\t\n+\tif (strncmp (file, \"??\", 2) == 0)\n+\t  estr_write (\"\\n\");\n+\telse\n+\t  {\n+\t    estr_write (\" at \");\n+\t    estr_write (file);\n+\t  }\n+    }\n+\n+ done:\n+\n+  state->frame_number++;\n+  \n+  return _URC_NO_REASON;\n+}\n+\n+\n+/* Display the backtrace.  */\n \n void\n show_backtrace (void)\n {\n-#if GLIBC_BACKTRACE\n+  bt_state state;\n+  state.frame_number = 0;\n+  state.error = 0;\n \n-#define DEPTH 50\n-#define BUFSIZE 1024\n-\n-  void *trace[DEPTH];\n-  int depth;\n-\n-  depth = backtrace (trace, DEPTH);\n-  if (depth <= 0)\n-    return;\n+  estr_write (\"\\nA fatal error occurred! Backtrace for this error:\\n\");\n \n #if CAN_PIPE\n \n@@ -134,9 +207,7 @@ show_backtrace (void)\n   do\n   {\n     /* Local variables.  */\n-    int f[2], pid, bt[2], inp[2];\n-    char addr_buf[GFC_XTOA_BUF_SIZE], func[BUFSIZE], file[BUFSIZE];\n-    char *p;\n+    int f[2], pid, inp[2];\n \n     /* Don't output an error message if something goes wrong, we'll simply\n        fall back to the pstack and glibc backtraces.  */\n@@ -182,139 +253,27 @@ show_backtrace (void)\n     /* Father process.  */\n     close (f[1]);\n     close (inp[0]);\n-    if (pipe (bt) != 0)\n-      break;\n-    backtrace_symbols_fd (trace, depth, bt[1]);\n-    close (bt[1]);\n-\n-    estr_write (\"\\nBacktrace for this error:\\n\");\n-    for (int j = 0; j < depth; j++)\n-      {\n-\tconst char *addr = gfc_xtoa \n-\t  ((GFC_UINTEGER_LARGEST) (intptr_t) trace[j], \n-\t   addr_buf, sizeof (addr_buf));\n-\n-\twrite (inp[1], addr, strlen (addr));\n-\twrite (inp[1], \"\\n\", 1);\n-\t\n-\tif (! fd_gets (func, sizeof(func), f[0]))\n-\t  goto fallback;\n-\tif (! fd_gets (file, sizeof(file), f[0]))\n-\t  goto fallback;\n-\t    \n-\tfor (p = func; *p != '\\n' && *p != '\\r'; p++)\n-\t  ;\n-\t*p = '\\0';\n-\t\n-\t/* If we only have the address, use the glibc backtrace.  */\n-\tif (func[0] == '?' && func[1] == '?' && file[0] == '?'\n-\t    && file[1] == '?')\n-\t  {\n-\t    bt_header (j);\n-\t    while (1)\n-\t      {\n-\t\tchar bc;\n-\t\tssize_t nread = read (bt[0], &bc, 1);\n-\t\tif (nread != 1 || bc == '\\n')\n-\t\t  break;\n-\t\twrite (STDERR_FILENO, &bc, 1);\n-\t      }\n-\t    estr_write (\"\\n\");\n-\t    continue;\n-\t  }\n-\telse\n-\t  {\n-\t    /* Forward to the next entry in the backtrace. */\n-\t    while (1)\n-\t      {\n-\t\tchar bc;\n-\t\tssize_t nread = read (bt[0], &bc, 1);\n-\t\tif (nread != 1 || bc == '\\n')\n-\t\t  break;\n-\t      }\n-\t  }\n \n-\t/* _start is a setup routine that calls main(), and main() is\n-\t   the frontend routine that calls some setup stuff and then\n-\t   calls MAIN__, so at this point we should stop.  */\n-\tif (strcmp (func, \"_start\") == 0 || strcmp (func, \"main\") == 0)\n-\t  break;\n-\t\n-\tbt_header (j);\n-\testr_write (full_exe_path ());\n-\testr_write (\"[0x\");\n-\testr_write (addr);\n-\testr_write (\"] in \");\n-\testr_write (func);\n-\t\n-\tif (strncmp (file, \"??\", 2) == 0)\n-\t  estr_write (\"\\n\");\n-\telse\n-\t  {\n-\t    estr_write (\" at \");\n-\t    estr_write (file);\n-\t  }\n-      } /* Loop over each hex address.  */\n+    state.outfd = inp[1];\n+    state.infd = f[0];\n+    state.direct_output = 0;\n+    _Unwind_Backtrace (trace_function, &state);\n+    if (state.error)\n+      goto fallback;\n     close (inp[1]);\n-    close (bt[0]);\n     wait (NULL);\n     return;\n \n fallback:\n     estr_write (\"** Something went wrong while running addr2line. **\\n\"\n-\t\t\"** Falling back  to a simpler  backtrace scheme. **\\n\");\n+\t\t\"** Falling back to a simpler backtrace scheme. **\\n\");\n   }\n   while (0);\n \n-#undef DEPTH\n-#undef BUFSIZE\n-\n #endif /* CAN_PIPE */\n \n fallback_noerr:\n-  /* Fallback to the glibc backtrace.  */\n-  estr_write (\"\\nBacktrace for this error:\\n\");\n-  backtrace_symbols_fd (trace, depth, STDERR_FILENO);\n-  return;\n-\n-#elif defined(CAN_FORK) && defined(HAVE_GETPPID)\n-  /* Try to call pstack.  */\n-  do\n-  {\n-    /* Local variables.  */\n-    int pid;\n-\n-    /* Don't output an error message if something goes wrong, we'll simply\n-       fall back to the pstack and glibc backtraces.  */\n-    if ((pid = fork ()) == -1)\n-      break;\n-\n-    if (pid == 0)\n-      {\n-\t/* Child process.  */\n-#define NUM_ARGS 2\n-\tchar *arg[NUM_ARGS+1];\n-\tchar buf[20];\n-\n-\testr_write (\"\\nBacktrace for this error:\\n\");\n-\targ[0] = (char *) \"pstack\";\n-\tsnprintf (buf, sizeof(buf), \"%d\", (int) getppid ());\n-\targ[1] = buf;\n-\targ[2] = NULL;\n-\texecvp (arg[0], arg);\n-#undef NUM_ARGS\n-\n-\t/* pstack didn't work.  */\n-\testr_write (\"  unable to produce a backtrace, sorry!\\n\");\n-\t_exit (1);\n-      }\n-\n-    /* Father process.  */\n-    wait (NULL);\n-    return;\n-  }\n-  while(0);\n-#else\n-  estr_write (\"\\nBacktrace not yet available on this platform, sorry!\\n\");\n-#endif\n+  /* Fallback to the simple backtrace without addr2line.  */\n+  state.direct_output = 1;\n+  _Unwind_Backtrace (trace_function, &state);\n }"}]}