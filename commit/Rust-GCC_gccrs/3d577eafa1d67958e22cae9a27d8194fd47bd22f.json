{"sha": "3d577eafa1d67958e22cae9a27d8194fd47bd22f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q1NzdlYWZhMWQ2Nzk1OGUyMmNhZTlhMjdkODE5NGZkNDdiZDIyZg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-02-24T18:11:33Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-02-24T18:11:33Z"}, "message": "builtins.c (fold_builtin_modf): New.\n\n\t* builtins.c (fold_builtin_modf): New.\n\t(fold_builtin_2): Use it.\n\ntestsuite:\n\t* gcc.dg/torture/builtin-modf-1.c: New test.\n\nFrom-SVN: r122292", "tree": {"sha": "02890b0b9a4814d77189e87581d3c8ea66db9fe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02890b0b9a4814d77189e87581d3c8ea66db9fe3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d577eafa1d67958e22cae9a27d8194fd47bd22f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d577eafa1d67958e22cae9a27d8194fd47bd22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d577eafa1d67958e22cae9a27d8194fd47bd22f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d577eafa1d67958e22cae9a27d8194fd47bd22f/comments", "author": null, "committer": null, "parents": [{"sha": "00c73ae6373c0a4080b9a414b43cc6efebb0705c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c73ae6373c0a4080b9a414b43cc6efebb0705c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c73ae6373c0a4080b9a414b43cc6efebb0705c"}], "stats": {"total": 227, "additions": 227, "deletions": 0}, "files": [{"sha": "2e57a9bca7065d351799cc108bc0618162622654", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d577eafa1d67958e22cae9a27d8194fd47bd22f", "patch": "@@ -1,3 +1,8 @@\n+2007-02-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (fold_builtin_modf): New.\n+\t(fold_builtin_2): Use it.\n+\n 2007-02-24  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* loop-iv.c (implies_p): Detect additional cases where A implies B."}, {"sha": "3e1ab59a9765f00d2fb38fd85d9331fb68367088", "filename": "gcc/builtins.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3d577eafa1d67958e22cae9a27d8194fd47bd22f", "patch": "@@ -9214,6 +9214,62 @@ fold_builtin_load_exponent (tree arg0, tree arg1, tree type, bool ldexp)\n   return NULL_TREE;\n }\n \n+/* Fold a call to builtin modf.  */\n+\n+static tree\n+fold_builtin_modf (tree arg0, tree arg1, tree rettype)\n+{\n+  if (! validate_arg (arg0, REAL_TYPE) || ! validate_arg (arg1, POINTER_TYPE))\n+    return NULL_TREE;\n+  \n+  STRIP_NOPS (arg0);\n+      \n+  if (!(TREE_CODE (arg0) == REAL_CST && ! TREE_OVERFLOW (arg0)))\n+    return NULL_TREE;\n+  \n+  arg1 = build_fold_indirect_ref (arg1);\n+\n+  /* Proceed if a valid pointer type was passed in.  */\n+  if (TYPE_MAIN_VARIANT (TREE_TYPE (arg1)) == TYPE_MAIN_VARIANT (rettype))\n+    {\n+      const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (arg0);\n+      REAL_VALUE_TYPE trunc, frac;\n+\n+      switch (value->cl)\n+      {\n+      case rvc_nan:\n+      case rvc_zero:\n+\t/* For +-NaN or +-0, return (*arg1 = arg0, arg0).  */\n+\ttrunc = frac = *value;\n+\tbreak;\n+      case rvc_inf:\n+\t/* For +-Inf, return (*arg1 = arg0, +-0).  */\n+\tfrac = dconst0;\n+\tfrac.sign = value->sign;\n+\ttrunc = *value;\n+\tbreak;\n+      case rvc_normal:\n+\t/* Return (*arg1 = trunc(arg0), arg0-trunc(arg0)).  */\n+\treal_trunc (&trunc, VOIDmode, value);\n+\treal_arithmetic (&frac, MINUS_EXPR, value, &trunc);\n+\t/* If the original number was negative and already\n+\t   integral, then the fractional part is -0.0.  */\n+\tif (value->sign && frac.cl == rvc_zero)\n+\t  frac.sign = value->sign;\n+\tbreak;\n+      }\n+\t      \n+      /* Create the COMPOUND_EXPR (*arg1 = trunc, frac). */\n+      arg1 = fold_build2 (MODIFY_EXPR, rettype, arg1,\n+\t\t\t  build_real (rettype, trunc));\n+      TREE_SIDE_EFFECTS (arg1) = 1;\n+      return fold_build2 (COMPOUND_EXPR, rettype, arg1,\n+\t\t\t  build_real (rettype, frac));\n+    }\n+  \n+  return NULL_TREE;\n+}\n+\n /* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.\n    ARG is the argument for the call.  */\n \n@@ -9690,6 +9746,9 @@ fold_builtin_2 (tree fndecl, tree arg0, tree arg1, bool ignore)\n     CASE_FLT_FN (BUILT_IN_FREXP):\n       return fold_builtin_frexp (arg0, arg1, type);\n \n+    CASE_FLT_FN (BUILT_IN_MODF):\n+      return fold_builtin_modf (arg0, arg1, type);\n+\n     case BUILT_IN_BZERO:\n       return fold_builtin_bzero (arg0, arg1, ignore);\n "}, {"sha": "a4b1af912072c8f2e55123e59bc4e69f34c6396c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3d577eafa1d67958e22cae9a27d8194fd47bd22f", "patch": "@@ -1,3 +1,7 @@\n+2007-02-24  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-modf-1.c: New test.\n+\n 2007-02-23  Paolo Bonzini  <bonzini@gnu.org>\n \n         PR tree-optimization/30904"}, {"sha": "d6cfdfce56255d187979bba33c9771c96b42fada", "filename": "gcc/testsuite/gcc.dg/torture/builtin-modf-1.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d577eafa1d67958e22cae9a27d8194fd47bd22f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-modf-1.c?ref=3d577eafa1d67958e22cae9a27d8194fd47bd22f", "patch": "@@ -0,0 +1,159 @@\n+/* Copyright (C) 2007  Free Software Foundation.\n+\n+   Verify that built-in folding of modf is correctly performed by the\n+   compiler.\n+\n+   Origin: Kaveh R. Ghazi,  February 23, 2007.  */\n+\n+/* { dg-do link } */\n+\n+extern void link_error(int);\n+\n+/* Return TRUE if the sign of X != sign of Y.  This is important when\n+   comparing signed zeros.  */\n+#define CKSGN_F(X,Y) \\\n+  (__builtin_copysignf(1.0F,(X)) != __builtin_copysignf(1.0F,(Y)))\n+#define CKSGN(X,Y) \\\n+  (__builtin_copysign(1.0,(X)) != __builtin_copysign(1.0,(Y)))\n+#define CKSGN_L(X,Y) \\\n+  (__builtin_copysignl(1.0L,(X)) != __builtin_copysignl(1.0L,(Y)))\n+\n+/* We use these macros if we can only check these when optimizing.  In\n+   some cases we rely on other optimizations to propagate the value\n+   and fold away certain constructs.  Likewise for the sign testing.\n+   TRUE means an error occurred.  */\n+#ifdef __OPTIMIZE__\n+#define CKRES(X) (X)\n+#define CKIPTR(X,Y) X != Y\n+#define CKSGN_IPTR_F(X,Y) CKSGN_F(X,Y)\n+#define CKSGN_IPTR(X,Y) CKSGN(X,Y)\n+#define CKSGN_IPTR_L(X,Y) CKSGN_L(X,Y)\n+#else\n+#define CKRES(X) 0\n+#define CKIPTR(X,Y) 0\n+#define CKSGN_IPTR_F(X,Y) 0\n+#define CKSGN_IPTR(X,Y) 0\n+#define CKSGN_IPTR_L(X,Y) 0\n+#endif\n+\n+/* Test that modf(ARG1,&iptr) == FRACRES && iptr == INTRES.  Check the\n+   sign in case we get -0.0.  */\n+#define TESTIT_MODF(ARG,INTRES,FRACRES) do { \\\n+  float iptrf = 0.5; double iptr = 0.5; long double iptrl = 0.5; \\\n+  if (__builtin_modff(ARG##f,&iptrf) != FRACRES##f \\\n+      || CKIPTR(iptrf,INTRES##f) \\\n+      || CKSGN_F(__builtin_modff(ARG##f,&iptrf),FRACRES##f) \\\n+      || CKSGN_IPTR_F(iptrf,INTRES##f)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_modf(ARG,&iptr) != FRACRES \\\n+      || CKIPTR(iptr,INTRES) \\\n+      || CKSGN(__builtin_modf(ARG,&iptr),FRACRES) \\\n+      || CKSGN_IPTR(iptr,INTRES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_modfl(ARG##l,&iptrl) != FRACRES##l \\\n+      || CKIPTR(iptrl,INTRES##l) \\\n+      || CKSGN_L(__builtin_modfl(ARG##l,&iptrl),FRACRES##l) \\\n+      || CKSGN_IPTR_L(iptrl,INTRES##l)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that modf(NEG FUNCARG(ARGARG, &iptr)) == FRACRES &&\n+   FUNCRES(iptr) is true.  Check the sign of both as well.  This is\n+   for checking an argument of Inf.  */\n+#define TESTIT_MODF2(NEG,FUNCARG,ARGARG,FUNCRES,FRACRES) do { \\\n+  float iptrf = 0.5; double iptr = 0.5; long double iptrl = 0.5; \\\n+  if (__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf) != FRACRES##f \\\n+      || CKSGN_F(__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf), FRACRES##f) \\\n+      || CKIPTR(!__builtin_##FUNCRES##f(iptrf),0) \\\n+      || CKSGN_IPTR_F(iptrf,FRACRES##f)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr) != FRACRES \\\n+      || CKSGN(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr), FRACRES) \\\n+      || CKIPTR(!__builtin_##FUNCRES(iptr),0) \\\n+      || CKSGN_IPTR(iptr,FRACRES)) \\\n+    link_error(__LINE__); \\\n+  if (__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl) != FRACRES##l \\\n+      || CKSGN_L(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl), FRACRES##l) \\\n+      || CKIPTR(!__builtin_##FUNCRES##l(iptrl),0) \\\n+      || CKSGN_IPTR_L(iptrl,FRACRES##l)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+/* Test that FUNCRES(modf(NEG FUNCARG(ARGARG, &iptr))) is true &&\n+   FUNCRES(iptr) is true.  Check the sign of both as well.  This is\n+   for checking an argument of NaN.  */\n+#define TESTIT_MODF3(NEG,FUNCARG,ARGARG,FUNCRES) do { \\\n+  float iptrf = 0.5; double iptr = 0.5; long double iptrl = 0.5; \\\n+  if (CKRES(!__builtin_##FUNCRES##f(__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf))) \\\n+      || CKSGN_F(__builtin_modff(NEG __builtin_##FUNCARG##f(ARGARG),&iptrf), NEG 1) \\\n+      || CKIPTR(!__builtin_##FUNCRES##f(iptrf),0) \\\n+      || CKSGN_IPTR_F(iptrf,NEG 1)) \\\n+    link_error(__LINE__); \\\n+  if (CKRES(!__builtin_##FUNCRES(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr))) \\\n+      || CKSGN(__builtin_modf(NEG __builtin_##FUNCARG(ARGARG),&iptr), NEG 1) \\\n+      || CKIPTR(!__builtin_##FUNCRES(iptr),0) \\\n+      || CKSGN_IPTR(iptr,NEG 1)) \\\n+    link_error(__LINE__); \\\n+  if (CKRES(!__builtin_##FUNCRES##l(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl))) \\\n+      || CKSGN_L(__builtin_modfl(NEG __builtin_##FUNCARG##l(ARGARG),&iptrl), NEG 1) \\\n+      || CKIPTR(!__builtin_##FUNCRES##l(iptrl),0) \\\n+      || CKSGN_IPTR_L(iptrl,NEG 1)) \\\n+    link_error(__LINE__); \\\n+  } while (0)\n+\n+void __attribute__ ((__noinline__))\n+foo(void)\n+{\n+  /* Test that modf(ARG1,&iptr) -> ARG3 && iptr == ARG2.  */\n+  TESTIT_MODF (0x1p10F+0.5, 0x1p10, 0.5);\n+  TESTIT_MODF (0x1p10F+0x1p-10, 0x1p10, 0x1p-10);\n+  TESTIT_MODF (12345678L/17.0, 726216.0, -726216L+12345678L/17.0);\n+  TESTIT_MODF (555.555, 555.0, -555+555.555);\n+  TESTIT_MODF (5000/11.0, 454.0, -454+5000/11.0);\n+  TESTIT_MODF (1000/7.0, 142.0, -142+1000/7.0);\n+  TESTIT_MODF (123/7.0, 17.0, -17+123/7.0);\n+  TESTIT_MODF (117/7.0, 16.0, -16+117/7.0);\n+  TESTIT_MODF (5.5, 5.0, 0.5);\n+  TESTIT_MODF (1.5, 1.0, 0.5);\n+  TESTIT_MODF (4/3.0, 1.0, -1+4/3.0);\n+  TESTIT_MODF (1.0, 1.0, 0.0);\n+  TESTIT_MODF (0.5, 0.0, 0.5);\n+  TESTIT_MODF (4/9.0, 0.0, 4/9.0);\n+  TESTIT_MODF (1/3.0, 0.0, 1/3.0);\n+  TESTIT_MODF (1/9.0, 0.0, 1/9.0);\n+  TESTIT_MODF (0.0, 0.0, 0.0);\n+\n+  TESTIT_MODF (-0.0, -0.0, -0.0);\n+  TESTIT_MODF (-1/9.0, -0.0, -1/9.0);\n+  TESTIT_MODF (-1/3.0, -0.0, -1/3.0);\n+  TESTIT_MODF (-4/9.0, -0.0, -4/9.0);\n+  TESTIT_MODF (-0.5, -0.0, -0.5);\n+  TESTIT_MODF (-1.0, -1.0, -0.0);\n+  TESTIT_MODF (-4/3.0, -1.0, 1-4/3.0);\n+  TESTIT_MODF (-1.5, -1.0, -0.5);\n+  TESTIT_MODF (-5.5, -5.0, -0.5);\n+  TESTIT_MODF (-117/7.0, -16.0, 16-117/7.0);\n+  TESTIT_MODF (-123/7.0, -17.0, 17-123/7.0);\n+  TESTIT_MODF (-1000/7.0, -142.0, 142-1000/7.0);\n+  TESTIT_MODF (-5000/11.0, -454.0, 454-5000/11.0);\n+  TESTIT_MODF (-555.555, -555.0, 555-555.555);\n+  TESTIT_MODF (-12345678L/17.0, -726216.0, 726216L-12345678L/17.0);\n+  TESTIT_MODF (-0x1p10F-0x1p-10, -0x1p10, -0x1p-10);\n+  TESTIT_MODF (-0x1p10F-0.5, -0x1p10, -0.5);\n+\n+  \n+  /* Test for modf(+-Inf,&i) -> (i=+-0.0, +-Inf).  */\n+  TESTIT_MODF2 ( ,inf, , isinf, 0.0);\n+  TESTIT_MODF2 (- ,inf, , isinf, -0.0);\n+\n+  /* Test for and modf(+-NaN,&i) -> (i=+-NaN, +-NaN).  */\n+  TESTIT_MODF3 ( ,nan, \"\", isnan);\n+  TESTIT_MODF3 (- ,nan, \"\", isnan);\n+}\n+\n+int main()\n+{\n+  foo();\n+  \n+  return 0;\n+}"}]}