{"sha": "18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThhYmFiOWZlZTc0NGYzZTQ3NjU0YjRlN2VmYmFlYjZiZmJmOTU3NA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2012-11-11T19:47:00Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2012-11-11T19:47:00Z"}, "message": "extend.texi: Copy-edit to use \"built-in function\" instead of \"builtin\", per GCC coding standards.\n\n2012-11-11  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* doc/extend.texi: Copy-edit to use \"built-in function\" instead\n\tof \"builtin\", per GCC coding standards.  Also use consistent\n\tcapitalization in titles of sections describing built-in functions.\n\nFrom-SVN: r193411", "tree": {"sha": "4cbd9c7c4d5b218edaa3f378f0b5bfdcb8416bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cbd9c7c4d5b218edaa3f378f0b5bfdcb8416bd9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18abab9fee744f3e47654b4e7efbaeb6bfbf9574/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "324e93f12ecb6577e789bb6f0ab5abc95fcdb0cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/324e93f12ecb6577e789bb6f0ab5abc95fcdb0cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/324e93f12ecb6577e789bb6f0ab5abc95fcdb0cc"}], "stats": {"total": 63, "additions": 38, "deletions": 25}, "files": [{"sha": "96573108674f6fd61e706273dec19ef575d01354", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abab9fee744f3e47654b4e7efbaeb6bfbf9574/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abab9fee744f3e47654b4e7efbaeb6bfbf9574/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "patch": "@@ -1,3 +1,9 @@\n+2012-11-11  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* doc/extend.texi: Copy-edit to use \"built-in function\" instead\n+\tof \"builtin\", per GCC coding standards.  Also use consistent\n+\tcapitalization in titles of sections describing built-in functions.\n+\n 2012-11-11  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/55238"}, {"sha": "25dd685e0ab637ac893f9c4409e85bd4e39204cf", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18abab9fee744f3e47654b4e7efbaeb6bfbf9574/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18abab9fee744f3e47654b4e7efbaeb6bfbf9574/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=18abab9fee744f3e47654b4e7efbaeb6bfbf9574", "patch": "@@ -6815,7 +6815,7 @@ purposes.\n @end deftypefn\n \n @node Vector Extensions\n-@section Using vector instructions through built-in functions\n+@section Using Vector Instructions through Built-in Functions\n \n On some targets, the instruction set contains SIMD vector instructions which\n operate on multiple values contained in one large register at the same time.\n@@ -6999,9 +6999,10 @@ may be dependent.  In either case, @var{member} may consist of a single\n identifier, or a sequence of member accesses and array references.\n \n @node __sync Builtins\n-@section Legacy __sync built-in functions for atomic memory access\n+@section Legacy __sync Built-in Functions for Atomic Memory Access\n \n-The following builtins are intended to be compatible with those described\n+The following built-in functions\n+are intended to be compatible with those described\n in the @cite{Intel Itanium Processor-specific Application Binary Interface},\n section 7.4.  As such, they depart from the normal GCC practice of using\n the ``__builtin_'' prefix, and further that they are overloaded such that\n@@ -7015,14 +7016,16 @@ counterparts.  GCC allows any integral scalar or pointer type that is\n Not all operations are supported by all target processors.  If a particular\n operation cannot be implemented on the target processor, a warning is\n generated and a call an external function is generated.  The external\n-function carries the same name as the builtin, with an additional suffix\n+function carries the same name as the built-in version,\n+with an additional suffix\n @samp{_@var{n}} where @var{n} is the size of the data type.\n \n @c ??? Should we have a mechanism to suppress this warning?  This is almost\n @c useful for implementing the operation under the control of an external\n @c mutex.\n \n-In most cases, these builtins are considered a @dfn{full barrier}.  That is,\n+In most cases, these built-in functions are considered a @dfn{full barrier}.\n+That is,\n no memory operand is moved across the operation, either forward or\n backward.  Further, instructions are issued as necessary to prevent the\n processor from speculating loads across the operation and from queuing stores\n@@ -7050,7 +7053,7 @@ globally accessible variables.\n @findex __sync_fetch_and_and\n @findex __sync_fetch_and_xor\n @findex __sync_fetch_and_nand\n-These builtins perform the operation suggested by the name, and\n+These built-in functions perform the operation suggested by the name, and\n returns the value that had previously been in memory.  That is,\n \n @smallexample\n@@ -7059,7 +7062,7 @@ returns the value that had previously been in memory.  That is,\n @end smallexample\n \n @emph{Note:} GCC 4.4 and later implement @code{__sync_fetch_and_nand}\n-builtin as @code{*ptr = ~(tmp & value)} instead of @code{*ptr = ~tmp & value}.\n+as @code{*ptr = ~(tmp & value)} instead of @code{*ptr = ~tmp & value}.\n \n @item @var{type} __sync_add_and_fetch (@var{type} *ptr, @var{type} value, ...)\n @itemx @var{type} __sync_sub_and_fetch (@var{type} *ptr, @var{type} value, ...)\n@@ -7073,7 +7076,7 @@ builtin as @code{*ptr = ~(tmp & value)} instead of @code{*ptr = ~tmp & value}.\n @findex __sync_and_and_fetch\n @findex __sync_xor_and_fetch\n @findex __sync_nand_and_fetch\n-These builtins perform the operation suggested by the name, and\n+These built-in functions perform the operation suggested by the name, and\n return the new value.  That is,\n \n @smallexample\n@@ -7082,14 +7085,15 @@ return the new value.  That is,\n @end smallexample\n \n @emph{Note:} GCC 4.4 and later implement @code{__sync_nand_and_fetch}\n-builtin as @code{*ptr = ~(*ptr & value)} instead of\n+as @code{*ptr = ~(*ptr & value)} instead of\n @code{*ptr = ~*ptr & value}.\n \n @item bool __sync_bool_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)\n @itemx @var{type} __sync_val_compare_and_swap (@var{type} *ptr, @var{type} oldval, @var{type} newval, ...)\n @findex __sync_bool_compare_and_swap\n @findex __sync_val_compare_and_swap\n-These builtins perform an atomic compare and swap.  That is, if the current\n+These built-in functions perform an atomic compare and swap.\n+That is, if the current\n value of @code{*@var{ptr}} is @var{oldval}, then write @var{newval} into\n @code{*@var{ptr}}.\n \n@@ -7099,11 +7103,11 @@ of @code{*@var{ptr}} before the operation.\n \n @item __sync_synchronize (...)\n @findex __sync_synchronize\n-This builtin issues a full memory barrier.\n+This built-in function issues a full memory barrier.\n \n @item @var{type} __sync_lock_test_and_set (@var{type} *ptr, @var{type} value, ...)\n @findex __sync_lock_test_and_set\n-This builtin, as described by Intel, is not a traditional test-and-set\n+This built-in function, as described by Intel, is not a traditional test-and-set\n operation, but rather an atomic exchange operation.  It writes @var{value}\n into @code{*@var{ptr}}, and returns the previous contents of\n @code{*@var{ptr}}.\n@@ -7114,18 +7118,21 @@ functionality here by which the @emph{only} valid value to store is the\n immediate constant 1.  The exact value actually stored in @code{*@var{ptr}}\n is implementation defined.\n \n-This builtin is not a full barrier, but rather an @dfn{acquire barrier}.\n-This means that references after the builtin cannot move to (or be\n-speculated to) before the builtin, but previous memory stores may not\n+This built-in function is not a full barrier,\n+but rather an @dfn{acquire barrier}.\n+This means that references after the operation cannot move to (or be\n+speculated to) before the operation, but previous memory stores may not\n be globally visible yet, and previous memory loads may not yet be\n satisfied.\n \n @item void __sync_lock_release (@var{type} *ptr, ...)\n @findex __sync_lock_release\n-This builtin releases the lock acquired by @code{__sync_lock_test_and_set}.\n+This built-in function releases the lock acquired by\n+@code{__sync_lock_test_and_set}.\n Normally this means writing the constant 0 to @code{*@var{ptr}}.\n \n-This builtin is not a full barrier, but rather a @dfn{release barrier}.\n+This built-in function is not a full barrier,\n+but rather a @dfn{release barrier}.\n This means that all previous memory stores are globally visible, and all\n previous memory loads have been satisfied, but following memory reads\n are not prevented from being speculated to before the barrier.\n@@ -7394,7 +7401,7 @@ compiler may also ignore this parameter.\n @end deftypefn\n \n @node Object Size Checking\n-@section Object Size Checking Builtins\n+@section Object Size Checking Built-in Functions\n @findex __builtin_object_size\n @findex __builtin___memcpy_chk\n @findex __builtin___mempcpy_chk\n@@ -7527,7 +7534,7 @@ format string @var{fmt}.  If the compiler is able to optimize them to\n is called and the @var{flag} argument passed to it.\n \n @node Other Builtins\n-@section Other built-in functions provided by GCC\n+@section Other Built-in Functions Provided by GCC\n @cindex built-in functions\n @findex __builtin_fpclassify\n @findex __builtin_isfinite\n@@ -8064,7 +8071,7 @@ prefixed.  We intend for a library implementor to be able to simply\n In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},\n @code{isinf_sign} and @code{isnormal} built-ins used with\n @code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}\n-builtins appear both with and without the @code{__builtin_} prefix.\n+built-in functions appear both with and without the @code{__builtin_} prefix.\n \n @deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n \n@@ -8749,7 +8756,7 @@ long __builtin_alpha_ctlz (long)\n long __builtin_alpha_ctpop (long)\n @end smallexample\n \n-The following builtins are available on systems that use the OSF/1\n+The following built-in functions are available on systems that use the OSF/1\n PALcode.  Normally they invoke the @code{rduniq} and @code{wruniq}\n PAL calls, but when invoked with @option{-mtls-kernel}, they invoke\n @code{rdval} and @code{wrval}.\n@@ -9526,14 +9533,14 @@ check the target platform type.\n \n @deftypefn {Built-in Function} void __builtin_cpu_init (void)\n This function runs the CPU detection code to check the type of CPU and the\n-features supported.  This builtin needs to be invoked along with the builtins\n+features supported.  This built-in function needs to be invoked along with the built-in functions\n to check CPU type and features, @code{__builtin_cpu_is} and\n @code{__builtin_cpu_supports}, only when used in a function that is\n executed before any constructors are called.  The CPU detection code is\n automatically executed in a very high priority constructor.\n \n For example, this function has to be used in @code{ifunc} resolvers that\n-check for CPU type using the builtins @code{__builtin_cpu_is}\n+check for CPU type using the built-in functions @code{__builtin_cpu_is}\n and @code{__builtin_cpu_supports}, or in constructors on targets that\n don't support constructor priority.\n @smallexample\n@@ -13700,10 +13707,10 @@ void vec_vsx_st (vector bool char, int, unsigned char *);\n void vec_vsx_st (vector bool char, int, signed char *);\n @end smallexample\n \n-Note that the @samp{vec_ld} and @samp{vec_st} builtins always\n+Note that the @samp{vec_ld} and @samp{vec_st} built-in functions always\n generate the Altivec @samp{LVX} and @samp{STVX} instructions even\n if the VSX instruction set is available.  The @samp{vec_vsx_ld} and\n-@samp{vec_vsx_st} builtins always generate the VSX @samp{LXVD2X},\n+@samp{vec_vsx_st} built-in functions always generate the VSX @samp{LXVD2X},\n @samp{LXVW4X}, @samp{STXVD2X}, and @samp{STXVW4X} instructions.\n \n @node SH Built-in Functions"}]}