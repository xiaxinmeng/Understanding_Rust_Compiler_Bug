{"sha": "7670b6633e51afbbc4b3c8a5775accf7f2d887af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY3MGI2NjMzZTUxYWZiYmM0YjNjOGE1Nzc1YWNjZjdmMmQ4ODdhZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:42Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:42Z"}, "message": "vect: Simplify get_initial_def_for_reduction\n\nAfter previous patches, we can now easily provide the neutral op\nas an argument to get_initial_def_for_reduction.  This in turn\nallows the adjustment calculation to be moved outside of\nget_initial_def_for_reduction, which is the main motivation\nof the patch.\n\ngcc/\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Remove\n\tadjustment handling.  Take the neutral value as an argument,\n\tin place of the code argument.\n\t(vect_transform_cycle_phi): Update accordingly.  Handle the\n\tinitial values of cond reductions separately from code reductions.\n\tChoose the adjustment here rather than in\n\tget_initial_def_for_reduction.  Sink the splat of vec_initial_def.", "tree": {"sha": "095c86103bb9af7376779c16be9b9d796845a657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/095c86103bb9af7376779c16be9b9d796845a657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7670b6633e51afbbc4b3c8a5775accf7f2d887af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7670b6633e51afbbc4b3c8a5775accf7f2d887af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7670b6633e51afbbc4b3c8a5775accf7f2d887af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7670b6633e51afbbc4b3c8a5775accf7f2d887af/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "221bdb333b0917c927aec4d367a72e3667087d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/221bdb333b0917c927aec4d367a72e3667087d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/221bdb333b0917c927aec4d367a72e3667087d7a"}], "stats": {"total": 177, "additions": 59, "deletions": 118}, "files": [{"sha": "fe7e73f655fd1c5e2743cab64ab38c36c29e7979", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 59, "deletions": 118, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7670b6633e51afbbc4b3c8a5775accf7f2d887af/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7670b6633e51afbbc4b3c8a5775accf7f2d887af/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7670b6633e51afbbc4b3c8a5775accf7f2d887af", "patch": "@@ -4614,57 +4614,26 @@ vect_model_reduction_cost (loop_vec_info loop_vinfo,\n    Input:\n    REDUC_INFO - the info_for_reduction\n    INIT_VAL - the initial value of the reduction variable\n+   NEUTRAL_OP - a value that has no effect on the reduction, as per\n+\t\tneutral_op_for_reduction\n \n    Output:\n-   ADJUSTMENT_DEF - a tree that holds a value to be added to the final result\n-        of the reduction (used for adjusting the epilog - see below).\n    Return a vector variable, initialized according to the operation that\n \tSTMT_VINFO performs. This vector will be used as the initial value\n \tof the vector of partial results.\n \n-   Option1 (adjust in epilog): Initialize the vector as follows:\n-     add/bit or/xor:    [0,0,...,0,0]\n-     mult/bit and:      [1,1,...,1,1]\n-     min/max/cond_expr: [init_val,init_val,..,init_val,init_val]\n-   and when necessary (e.g. add/mult case) let the caller know\n-   that it needs to adjust the result by init_val.\n-\n-   Option2: Initialize the vector as follows:\n-     add/bit or/xor:    [init_val,0,0,...,0]\n-     mult/bit and:      [init_val,1,1,...,1]\n-     min/max/cond_expr: [init_val,init_val,...,init_val]\n-   and no adjustments are needed.\n-\n-   For example, for the following code:\n-\n-   s = init_val;\n-   for (i=0;i<n;i++)\n-     s = s + a[i];\n-\n-   STMT_VINFO is 's = s + a[i]', and the reduction variable is 's'.\n-   For a vector of 4 units, we want to return either [0,0,0,init_val],\n-   or [0,0,0,0] and let the caller know that it needs to adjust\n-   the result at the end by 'init_val'.\n-\n-   FORNOW, we are using the 'adjust in epilog' scheme, because this way the\n-   initialization vector is simpler (same element in all entries), if\n-   ADJUSTMENT_DEF is not NULL, and Option2 otherwise.\n-\n-   A cost model should help decide between these two schemes.  */\n+   The value we need is a vector in which element 0 has value INIT_VAL\n+   and every other element has value NEUTRAL_OP.  */\n \n static tree\n get_initial_def_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t       stmt_vec_info reduc_info,\n-\t\t\t       enum tree_code code, tree init_val,\n-                               tree *adjustment_def)\n+\t\t\t       tree init_val, tree neutral_op)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (init_val);\n   tree vectype = get_vectype_for_scalar_type (loop_vinfo, scalar_type);\n-  tree def_for_init;\n   tree init_def;\n-  REAL_VALUE_TYPE real_init_val = dconst0;\n-  int int_init_val = 0;\n   gimple_seq stmts = NULL;\n \n   gcc_assert (vectype);\n@@ -4675,75 +4644,34 @@ get_initial_def_for_reduction (loop_vec_info loop_vinfo,\n   gcc_assert (nested_in_vect_loop_p (loop, reduc_info)\n \t      || loop == (gimple_bb (reduc_info->stmt))->loop_father);\n \n-  /* ADJUSTMENT_DEF is NULL when called from\n-     vect_create_epilog_for_reduction to vectorize double reduction.  */\n-  if (adjustment_def)\n-    *adjustment_def = NULL;\n-\n-  switch (code)\n+  if (operand_equal_p (init_val, neutral_op))\n     {\n-    case WIDEN_SUM_EXPR:\n-    case DOT_PROD_EXPR:\n-    case SAD_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case MULT_EXPR:\n-    case BIT_AND_EXPR:\n-      {\n-        if (code == MULT_EXPR)\n-          {\n-            real_init_val = dconst1;\n-            int_init_val = 1;\n-          }\n-\n-        if (code == BIT_AND_EXPR)\n-          int_init_val = -1;\n-\n-        if (SCALAR_FLOAT_TYPE_P (scalar_type))\n-          def_for_init = build_real (scalar_type, real_init_val);\n-        else\n-          def_for_init = build_int_cst (scalar_type, int_init_val);\n-\n-\tif (adjustment_def || operand_equal_p (def_for_init, init_val, 0))\n-\t  {\n-\t    /* Option1: the first element is '0' or '1' as well.  */\n-\t    if (!operand_equal_p (def_for_init, init_val, 0))\n-\t      *adjustment_def = init_val;\n-\t    init_def = gimple_build_vector_from_val (&stmts, vectype,\n-\t\t\t\t\t\t     def_for_init);\n-\t  }\n-\telse if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant ())\n-\t  {\n-\t    /* Option2 (variable length): the first element is INIT_VAL.  */\n-\t    init_def = gimple_build_vector_from_val (&stmts, vectype,\n-\t\t\t\t\t\t     def_for_init);\n-\t    init_def = gimple_build (&stmts, CFN_VEC_SHL_INSERT,\n-\t\t\t\t     vectype, init_def, init_val);\n-\t  }\n-\telse\n-\t  {\n-\t    /* Option2: the first element is INIT_VAL.  */\n-\t    tree_vector_builder elts (vectype, 1, 2);\n-\t    elts.quick_push (init_val);\n-\t    elts.quick_push (def_for_init);\n-\t    init_def = gimple_build_vector (&stmts, &elts);\n-\t  }\n-      }\n-      break;\n-\n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-    case COND_EXPR:\n-      {\n-\tinit_val = gimple_convert (&stmts, TREE_TYPE (vectype), init_val);\n-\tinit_def = gimple_build_vector_from_val (&stmts, vectype, init_val);\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n+      /* If both elements are equal then the vector described above is\n+\t just a splat.  */\n+      neutral_op = gimple_convert (&stmts, TREE_TYPE (vectype), neutral_op);\n+      init_def = gimple_build_vector_from_val (&stmts, vectype, neutral_op);\n+    }\n+  else\n+    {\n+      neutral_op = gimple_convert (&stmts, TREE_TYPE (vectype), neutral_op);\n+      init_val = gimple_convert (&stmts, TREE_TYPE (vectype), init_val);\n+      if (!TYPE_VECTOR_SUBPARTS (vectype).is_constant ())\n+\t{\n+\t  /* Construct a splat of NEUTRAL_OP and insert INIT_VAL into\n+\t     element 0.  */\n+\t  init_def = gimple_build_vector_from_val (&stmts, vectype,\n+\t\t\t\t\t\t   neutral_op);\n+\t  init_def = gimple_build (&stmts, CFN_VEC_SHL_INSERT,\n+\t\t\t\t   vectype, init_def, init_val);\n+\t}\n+      else\n+\t{\n+\t  /* Build {INIT_VAL, NEUTRAL_OP, NEUTRAL_OP, ...}.  */\n+\t  tree_vector_builder elts (vectype, 1, 2);\n+\t  elts.quick_push (init_val);\n+\t  elts.quick_push (neutral_op);\n+\t  init_def = gimple_build_vector (&stmts, &elts);\n+\t}\n     }\n \n   if (stmts)\n@@ -7479,7 +7407,7 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t\t\t\t\t       vectype_out);\n \n   /* Get the loop-entry arguments.  */\n-  tree vec_initial_def;\n+  tree vec_initial_def = NULL_TREE;\n   auto_vec<tree> vec_initial_defs;\n   if (slp_node)\n     {\n@@ -7529,9 +7457,6 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (reduc_info) = NULL_TREE;\n \t    }\n \t  vec_initial_def = build_vector_from_val (vectype_out, induc_val);\n-\t  vec_initial_defs.create (ncopies);\n-\t  for (i = 0; i < ncopies; ++i)\n-\t    vec_initial_defs.quick_push (vec_initial_def);\n \t}\n       else if (nested_cycle)\n \t{\n@@ -7541,23 +7466,39 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t\t\t\t\t ncopies, initial_def,\n \t\t\t\t\t &vec_initial_defs);\n \t}\n+      else if (STMT_VINFO_REDUC_TYPE (reduc_info) == CONST_COND_REDUCTION\n+\t       || STMT_VINFO_REDUC_TYPE (reduc_info) == COND_REDUCTION)\n+\t/* Fill the initial vector with the initial scalar value.  */\n+\tvec_initial_def\n+\t  = get_initial_def_for_reduction (loop_vinfo, reduc_stmt_info,\n+\t\t\t\t\t   initial_def, initial_def);\n       else\n \t{\n-\t  tree adjustment_def = NULL_TREE;\n-\t  tree *adjustment_defp = &adjustment_def;\n \t  enum tree_code code = STMT_VINFO_REDUC_CODE (reduc_info);\n-\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_double_reduction_def)\n-\t    adjustment_defp = NULL;\n+\t  tree neutral_op = neutral_op_for_reduction (TREE_TYPE (initial_def),\n+\t\t\t\t\t\t      code, initial_def);\n+\t  gcc_assert (neutral_op);\n+\t  /* Try to simplify the vector initialization by applying an\n+\t     adjustment after the reduction has been performed.  */\n+\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def\n+\t      && !operand_equal_p (neutral_op, initial_def))\n+\t    {\n+\t      STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info) = initial_def;\n+\t      initial_def = neutral_op;\n+\t    }\n \t  vec_initial_def\n-\t    = get_initial_def_for_reduction (loop_vinfo, reduc_info, code,\n-\t\t\t\t\t     initial_def, adjustment_defp);\n-\t  STMT_VINFO_REDUC_EPILOGUE_ADJUSTMENT (reduc_info) = adjustment_def;\n-\t  vec_initial_defs.create (ncopies);\n-\t  for (i = 0; i < ncopies; ++i)\n-\t    vec_initial_defs.quick_push (vec_initial_def);\n+\t    = get_initial_def_for_reduction (loop_vinfo, reduc_info,\n+\t\t\t\t\t     initial_def, neutral_op);\n \t}\n     }\n \n+  if (vec_initial_def)\n+    {\n+      vec_initial_defs.create (ncopies);\n+      for (i = 0; i < ncopies; ++i)\n+\tvec_initial_defs.quick_push (vec_initial_def);\n+    }\n+\n   /* Generate the reduction PHIs upfront.  */\n   for (i = 0; i < vec_num; i++)\n     {"}]}