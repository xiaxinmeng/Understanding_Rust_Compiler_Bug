{"sha": "7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FiOGM2NDcwYzYyNzVmZDllNTgwMzhmMWRkM2U4NzQ0YmViZTJiYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-08-09T16:55:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-08-09T16:55:01Z"}, "message": "Adjust mangling of ABI tags on class template member functions.\n\n\t* class.c (missing_abi_tags): New.\n\t(check_abi_tags): Don't check template. Add just_checking mode.\n\t* mangle.c (abi_flag_at_least, any_abi_below, equal_abi_tags): New.\n\t(sorted_abi_tags): Split out from write_abi_tags.\n\t(struct releasing_vec): New.\n\t(write_unqualified_name): Only look for the primary\n\ttemplate for types.  Implement backward compatibility.\n\nFrom-SVN: r239298", "tree": {"sha": "6d10bd9ab296a60fd95c6b082467a0abef8aae07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d10bd9ab296a60fd95c6b082467a0abef8aae07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0bc3323eb5132b2d7e4c87ec2f213a18d72712d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bc3323eb5132b2d7e4c87ec2f213a18d72712d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bc3323eb5132b2d7e4c87ec2f213a18d72712d"}], "stats": {"total": 260, "additions": 230, "deletions": 30}, "files": [{"sha": "81ca1a1b04f473c5721d9b2a44b02a9471e8a1ee", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -1,5 +1,14 @@\n 2016-08-09  Jason Merrill  <jason@redhat.com>\n \n+\tAdjust mangling of ABI tags on class template member functions.\n+\t* class.c (missing_abi_tags): New.\n+\t(check_abi_tags): Don't check template. Add just_checking mode.\n+\t* mangle.c (abi_flag_at_least, any_abi_below, equal_abi_tags): New.\n+\t(sorted_abi_tags): Split out from write_abi_tags.\n+\t(struct releasing_vec): New.\n+\t(write_unqualified_name): Only look for the primary\n+\ttemplate for types.  Implement backward compatibility.\n+\n \tPR c++/72849\n \t* constexpr.c (cxx_eval_constant_expression): Check\n \tCOMPLETE_TYPE_P before calling is_really_empty_class."}, {"sha": "e21647a642eff4b23c4208fc4560553274eaab17", "filename": "gcc/cp/class.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -1561,20 +1561,20 @@ mark_abi_tags (tree t, bool val)\n \n /* Check that T has all the ABI tags that subobject SUBOB has, or\n    warn if not.  If T is a (variable or function) declaration, also\n-   add any missing tags.  */\n+   return any missing tags, and add them to T if JUST_CHECKING is false.  */\n \n-static void\n-check_abi_tags (tree t, tree subob)\n+static tree\n+check_abi_tags (tree t, tree subob, bool just_checking = false)\n {\n   bool inherit = DECL_P (t);\n \n   if (!inherit && !warn_abi_tag)\n-    return;\n+    return NULL_TREE;\n \n   tree decl = TYPE_P (t) ? TYPE_NAME (t) : t;\n   if (!TREE_PUBLIC (decl))\n     /* No need to worry about things local to this TU.  */\n-    return;\n+    return NULL_TREE;\n \n   mark_abi_tags (t, true);\n \n@@ -1585,7 +1585,15 @@ check_abi_tags (tree t, tree subob)\n \n   cp_walk_tree_without_duplicates (&subtype, find_abi_tags_r, &data);\n \n-  if (inherit && data.tags)\n+  if (!(inherit && data.tags))\n+    /* We don't need to do anything with data.tags.  */;\n+  else if (just_checking)\n+    for (tree t = data.tags; t; t = TREE_CHAIN (t))\n+      {\n+\ttree id = get_identifier (TREE_STRING_POINTER (TREE_VALUE (t)));\n+\tIDENTIFIER_MARKED (id) = false;\n+      }\n+  else\n     {\n       tree attr = lookup_attribute (\"abi_tag\", DECL_ATTRIBUTES (t));\n       if (attr)\n@@ -1597,6 +1605,8 @@ check_abi_tags (tree t, tree subob)\n     }\n \n   mark_abi_tags (t, false);\n+\n+  return data.tags;\n }\n \n /* Check that DECL has all the ABI tags that are used in parts of its type\n@@ -1605,22 +1615,29 @@ check_abi_tags (tree t, tree subob)\n void\n check_abi_tags (tree decl)\n {\n-  tree t;\n-  if (abi_version_at_least (10)\n-      && DECL_LANG_SPECIFIC (decl)\n-      && DECL_USE_TEMPLATE (decl)\n-      && (t = DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (decl)),\n-\t  t != decl))\n-    /* Make sure that our template has the appropriate tags, since\n-       write_unqualified_name looks for them there.  */\n-    check_abi_tags (t);\n   if (VAR_P (decl))\n     check_abi_tags (decl, TREE_TYPE (decl));\n   else if (TREE_CODE (decl) == FUNCTION_DECL\n \t   && !mangle_return_type_p (decl))\n     check_abi_tags (decl, TREE_TYPE (TREE_TYPE (decl)));\n }\n \n+/* Return any ABI tags that are used in parts of the type of DECL\n+   that are not reflected in its mangled name.  This function is only\n+   used in backward-compatible mangling for ABI <11.  */\n+\n+tree\n+missing_abi_tags (tree decl)\n+{\n+  if (VAR_P (decl))\n+    return check_abi_tags (decl, TREE_TYPE (decl), true);\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && !mangle_return_type_p (decl))\n+    return check_abi_tags (decl, TREE_TYPE (TREE_TYPE (decl)), true);\n+  else\n+    return NULL_TREE;\n+}\n+\n void\n inherit_targ_abi_tags (tree t)\n {"}, {"sha": "f32613c05b700822215c6935b50b95bab8258766", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -5686,6 +5686,7 @@ extern void inherit_targ_abi_tags\t\t(tree);\n extern void defaulted_late_check\t\t(tree);\n extern bool defaultable_fn_check\t\t(tree);\n extern void check_abi_tags\t\t\t(tree);\n+extern tree missing_abi_tags\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n extern void fixup_attribute_variants\t\t(tree);\n extern tree* decl_cloned_function_p\t\t(const_tree, bool);"}, {"sha": "f7ff221d9416d3faf0369e5fded1d6bf4c3f1bf5", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 107, "deletions": 15, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -91,6 +91,14 @@ along with GCC; see the file COPYING3.  If not see\n #define abi_warn_or_compat_version_crosses(N) \\\n   (abi_version_crosses (N) || abi_compat_version_crosses (N))\n \n+/* And sometimes we can simplify the code path if we don't need to worry about\n+   previous ABIs.  */\n+#define abi_flag_at_least(flag,N) (flag == 0 || flag >= N)\n+#define any_abi_below(N) \\\n+  (!abi_version_at_least (N) \\\n+   || !abi_flag_at_least (warn_abi_version, (N)) \\\n+   || !abi_flag_at_least (flag_abi_compat_version, (N)))\n+\n /* Things we only need one of.  This module is not reentrant.  */\n struct GTY(()) globals {\n   /* An array of the current substitution candidates, in the order\n@@ -224,6 +232,7 @@ static void dump_substitution_candidates (void);\n static tree mangle_decl_string (const tree);\n static int local_class_index (tree);\n static void maybe_check_abi_tags (tree, tree = NULL_TREE);\n+static bool equal_abi_tags (tree, tree);\n \n /* Control functions.  */\n \n@@ -1329,16 +1338,52 @@ write_unqualified_name (tree decl)\n         write_source_name (DECL_NAME (decl));\n     }\n \n-  /* We use the ABI tags from the primary template, ignoring tags on any\n+  /* We use the ABI tags from the primary class template, ignoring tags on any\n      specializations.  This is necessary because C++ doesn't require a\n-     specialization to be declared before it is used unless the use\n-     requires a complete type, but we need to get the tags right on\n-     incomplete types as well.  */\n+     specialization to be declared before it is used unless the use requires a\n+     complete type, but we need to get the tags right on incomplete types as\n+     well.  */\n   if (tree tmpl = most_general_template (decl))\n-    decl = DECL_TEMPLATE_RESULT (tmpl);\n-  /* Don't crash on an unbound class template.  */\n-  if (decl && TREE_CODE (decl) != NAMESPACE_DECL)\n-    write_abi_tags (get_abi_tags (decl));\n+    {\n+      tree res = DECL_TEMPLATE_RESULT (tmpl);\n+      if (res == NULL_TREE)\n+\t/* UNBOUND_CLASS_TEMPLATE.  */;\n+      else if (DECL_DECLARES_TYPE_P (decl))\n+\tdecl = res;\n+      else if (any_abi_below (11))\n+\t{\n+\t  /* ABI v10 implicit tags on the template.  */\n+\t  tree mtags = missing_abi_tags (res);\n+\t  /* Explicit tags on the template.  */\n+\t  tree ttags = get_abi_tags (res);\n+\t  /* Tags on the instantiation.  */\n+\t  tree dtags = get_abi_tags (decl);\n+\n+\t  if (mtags && abi_warn_or_compat_version_crosses (10))\n+\t    G.need_abi_warning = 1;\n+\n+\t  /* Add the v10 tags to the explicit tags now.  */\n+\t  mtags = chainon (mtags, ttags);\n+\n+\t  if (!G.need_abi_warning\n+\t      && abi_warn_or_compat_version_crosses (11)\n+\t      && !equal_abi_tags (dtags, mtags))\n+\t    G.need_abi_warning = 1;\n+\n+\t  if (!abi_version_at_least (10))\n+\t    /* In abi <10, we only got the explicit tags.  */\n+\t    decl = res;\n+\t  else if (flag_abi_version == 10)\n+\t    {\n+\t      /* In ABI 10, we want explict and implicit tags.  */\n+\t      write_abi_tags (mtags);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  tree tags = get_abi_tags (decl);\n+  write_abi_tags (tags);\n }\n \n /* Write the unqualified-name for a conversion operator to TYPE.  */\n@@ -1381,15 +1426,11 @@ tree_string_cmp (const void *p1, const void *p2)\n \t\t TREE_STRING_POINTER (s2));\n }\n \n-/* ID is the name of a function or type with abi_tags attribute TAGS.\n-   Write out the name, suitably decorated.  */\n+/* Return the TREE_LIST of TAGS as a sorted VEC.  */\n \n-static void\n-write_abi_tags (tree tags)\n+static vec<tree, va_gc> *\n+sorted_abi_tags (tree tags)\n {\n-  if (tags == NULL_TREE)\n-    return;\n-\n   vec<tree, va_gc> * vec = make_tree_vector();\n \n   for (tree t = tags; t; t = TREE_CHAIN (t))\n@@ -1402,6 +1443,20 @@ write_abi_tags (tree tags)\n \n   vec->qsort (tree_string_cmp);\n \n+  return vec;\n+}\n+\n+/* ID is the name of a function or type with abi_tags attribute TAGS.\n+   Write out the name, suitably decorated.  */\n+\n+static void\n+write_abi_tags (tree tags)\n+{\n+  if (tags == NULL_TREE)\n+    return;\n+\n+  vec<tree, va_gc> * vec = sorted_abi_tags (tags);\n+\n   unsigned i; tree str;\n   FOR_EACH_VEC_ELT (*vec, i, str)\n     {\n@@ -1413,6 +1468,43 @@ write_abi_tags (tree tags)\n   release_tree_vector (vec);\n }\n \n+/* Simplified unique_ptr clone to release a tree vec on exit.  */\n+\n+struct releasing_vec\n+{\n+  typedef vec<tree, va_gc> vec_t;\n+\n+  releasing_vec (vec_t *v): v(v) { }\n+  releasing_vec (): v(make_tree_vector ()) { }\n+\n+  vec_t &operator* () const { return *v; }\n+  vec_t *operator-> () const { return v; }\n+  vec_t *get () const { return v; }\n+  operator vec_t *() const { return v; }\n+  tree& operator[] (unsigned i) const { return (*v)[i]; }\n+\n+  ~releasing_vec() { release_tree_vector (v); }\n+private:\n+  vec_t *v;\n+};\n+\n+/* True iff the TREE_LISTS T1 and T2 of ABI tags are equivalent.  */\n+\n+static bool\n+equal_abi_tags (tree t1, tree t2)\n+{\n+  releasing_vec v1 = sorted_abi_tags (t1);\n+  releasing_vec v2 = sorted_abi_tags (t2);\n+\n+  unsigned len1 = v1->length();\n+  if (len1 != v2->length())\n+    return false;\n+  for (unsigned i = 0; i < len1; ++i)\n+    if (tree_string_cmp (v1[i], v2[i]) != 0)\n+      return false;\n+  return true;\n+}\n+\n /* Write a user-defined literal operator.\n           ::= li <source-name>    # \"\" <source-name>\n    IDENTIFIER is an LITERAL_IDENTIFIER_NODE.  */"}, {"sha": "53599f7f4c331815ceebf77f363ef92755b989fe", "filename": "gcc/testsuite/g++.dg/abi/abi-tag21.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21.C?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options -Wabi=10 }\n+\n+struct [[gnu::abi_tag (\"foo\")]] A\n+{\n+  template <class T> static T f();\n+  template <class T> static A g();\n+};\n+\n+template <class T> struct B\n+{\n+  static decltype(A::f<T>()) fa(decltype(A::f<T>()));\n+  static decltype(A::f<T>()) fv(); // { dg-warning \"mangled name\" }\n+  static decltype(A::g<T>()) ga(decltype(A::g<T>()));\n+  static decltype(A::g<T>()) gv();\n+  template <class U> \n+  static decltype(A::f<U>()) hv();\n+};\n+\n+int main()\n+{\n+  B<int>::fa(0);     // { dg-final { scan-assembler \"_ZN1BIiE2faEi\" } }\n+  B<int>::fv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2fvEv\" } }\n+  B<int>::ga(A());   // { dg-final { scan-assembler \"_ZN1BIiE2gaE1AB3foo\" } }\n+  B<int>::gv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2gvB3fooEv\" } }\n+  B<int>::hv<int>(); // { dg-final { scan-assembler \"_ZN1BIiE2hvIiEEDTclsr1AB3foo1fIT_EEEv\" } }\n+}"}, {"sha": "3c513336c016117e9bb84a7c89defd0b65ba870d", "filename": "gcc/testsuite/g++.dg/abi/abi-tag21a.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21a.C?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fabi-version=10 -Wabi\" }\n+\n+struct [[gnu::abi_tag (\"foo\")]] A\n+{\n+  template <class T> static T f();\n+  template <class T> static A g();\n+};\n+\n+template <class T> struct B\n+{\n+  static decltype(A::f<T>()) fa(decltype(A::f<T>()));\n+  static decltype(A::f<T>()) fv(); // { dg-warning \"mangled name\" }\n+  static decltype(A::g<T>()) ga(decltype(A::g<T>()));\n+  static decltype(A::g<T>()) gv();\n+  template <class U> \n+  static decltype(A::f<U>()) hv();\n+};\n+\n+int main()\n+{\n+  B<int>::fa(0);     // { dg-final { scan-assembler \"_ZN1BIiE2faEi\" } }\n+  B<int>::fv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2fvB3fooEv\" } }\n+  B<int>::ga(A());   // { dg-final { scan-assembler \"_ZN1BIiE2gaE1AB3foo\" } }\n+  B<int>::gv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2gvB3fooEv\" } }\n+  B<int>::hv<int>(); // { dg-final { scan-assembler \"_ZN1BIiE2hvIiEEDTclsr1AB3foo1fIT_EEEv\" } }\n+}"}, {"sha": "d4090f4843a87694f07798ef6f6ee0e56d07fad6", "filename": "gcc/testsuite/g++.dg/abi/abi-tag21b.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fabi-tag21b.C?ref=7ab8c6470c6275fd9e58038f1dd3e8744bebe2bc", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-fabi-version=9 -Wabi\" }\n+\n+struct [[gnu::abi_tag (\"foo\")]] A\n+{\n+  template <class T> static T f();\n+  template <class T> static A g();\n+};\n+\n+template <class T> struct B\n+{\n+  static decltype(A::f<T>()) fa(decltype(A::f<T>()));\n+  static decltype(A::f<T>()) fv();\n+  static decltype(A::g<T>()) ga(decltype(A::g<T>()));\n+  static decltype(A::g<T>()) gv(); // { dg-warning \"mangled name\" }\n+  template <class U> \n+  static decltype(A::f<U>()) hv();\n+};\n+\n+int main()\n+{\n+  B<int>::fa(0);     // { dg-final { scan-assembler \"_ZN1BIiE2faEi\" } }\n+  B<int>::fv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2fvEv\" } }\n+  B<int>::ga(A());   // { dg-final { scan-assembler \"_ZN1BIiE2gaE1AB3foo\" } }\n+  B<int>::gv();\t     // { dg-final { scan-assembler \"_ZN1BIiE2gvEv\" } }\n+  B<int>::hv<int>(); // { dg-final { scan-assembler \"_ZN1BIiE2hvIiEEDTclsr1AB3foo1fIT_EEEv\" } }\n+}"}]}