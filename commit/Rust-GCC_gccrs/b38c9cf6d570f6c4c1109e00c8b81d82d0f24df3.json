{"sha": "b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "node_id": "C_kwDOANBUbNoAKGIzOGM5Y2Y2ZDU3MGY2YzRjMTEwOWUwMGM4YjgxZDgyZDBmMjRkZjM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-25T07:36:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-25T07:36:20Z"}, "message": "c++: Implement C++23 P2128R6 - Multidimensional subscript operator [PR102611]\n\nThe following patch implements the C++23 Multidimensional subscript operator\nP2128R6 paper.\nAs C++20 and older only allow a single expression in between []s (albeit\nfor C++20 with a deprecation warning if it is a comma expression) and even\nin C++23 and for the coming years I think the vast majority of subscript\nexpressions will still have a single expression and even in C++23 it is\nquite special, as e.g. the builtin operator requires exactly one\nassignment expression, the patch attempts to optimize for that case and\nif possible not to slow down that common case (or use more memory for it).\nSo, already during parsing it differentiates between that (uses a single\nindex_exp tree in that case) and the new cases (zero or two+ expressions\nin the list), for which it sets index_exp to NULL_TREE and uses a\nreleasing_vec instead similarly to how e.g. finish_call_expr uses it.\nIn call.c it introduces new functions build_op_subscript{,_1} which are\nsomething in between build_new_op{,_1} and build_op_call{,_1}.\nThe former requires fixed number of arguments (and the patch still uses\nit for the common case of subscript with exactly one index expression),\nthe latter handles variable number of arguments but is too CALL_EXPR specific\nand handles various cases that are unnecessary for the subscript.\nRight now the subscript for 0 or 2+ expressions doesn't need to deal with\nbuiltin candidates and so is quite simple.\n\nAs discussed in the paper, for backwards compatibility, if for 2+ index\nexpressions build_op_subscript fails (called with tf_none) and the\nexpressions together form a valid comma expression (again checked with\ntf_none), it is used that C++20-ish way with a pedwarn about it, but if\neven that fails, build_op_subscript is called again with standard complain\nflags to diagnose it in the new way.  And similarly for the builtin case.\n\nThe -Wcomma-subscript warning used to be enabled by default unless\n-Wno-deprecated.  Since the C/C++98..20 behavior is no longer deprecated,\nbut ill-formed or changed meaning, it is now for C++23 enabled by\ndefault regardless of -Wno-deprecated and controls the pedwarn (but not the\nerrors emitted if something wasn't valid before and isn't valid in C++23\neither).\n\n2021-11-25  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/102611\ngcc/\n\t* doc/invoke.texi (-Wcomma-subscript): Document that for\n\t-std=c++20 the option isn't enabled by default with -Wno-deprecated\n\tbut for -std=c++23 it is.\ngcc/c-family/\n\t* c-opts.c (c_common_post_options): Enable -Wcomma-subscript by\n\tdefault for C++23 regardless of warn_deprecated.\n\t* c-cppbuiltin.c (c_cpp_builtins): Predefine\n\t__cpp_multidimensional_subscript=202110L for C++23.\ngcc/cp/\n\t* cp-tree.h (build_op_subscript): Implement P2128R6\n\t- Multidimensional subscript operator.  Declare.\n\t(class releasing_vec): Add release method.\n\t(grok_array_decl): Remove bool argument, add vec<tree, va_gc> **\n\tand tsubst_flags_t arguments.\n\t(build_min_non_dep_op_overload): Declare another overload.\n\t* parser.c (cp_parser_parenthesized_expression_list_elt): New function.\n\t(cp_parser_postfix_open_square_expression): Mention C++23 syntax in\n\tfunction comment.  For C++23 parse zero or more than one initializer\n\tclauses in expression list, adjust grok_array_decl caller.\n\t(cp_parser_parenthesized_expression_list): Use\n\tcp_parser_parenthesized_expression_list_elt.\n\t(cp_parser_builtin_offsetof): Adjust grok_array_decl caller.\n\t* decl.c (grok_op_properties): For C++23 don't check number\n\tof arguments of operator[].\n\t* decl2.c (grok_array_decl): Remove decltype_p argument, add\n\tindex_exp_list and complain arguments.  If index_exp is NULL,\n\thandle *index_exp_list as the subscript expression list.\n\t* tree.c (build_min_non_dep_op_overload): New overload.\n\t* call.c (add_operator_candidates, build_over_call): Adjust comments\n\tfor removal of build_new_op_1.\n\t(build_op_subscript): New function.\n\t* pt.c (tsubst_copy_and_build_call_args): New function.\n\t(tsubst_copy_and_build) <case ARRAY_REF>: If second\n\toperand is magic CALL_EXPR with ovl_op_identifier (ARRAY_REF)\n\tas CALL_EXPR_FN, tsubst CALL_EXPR arguments including expanding\n\tpack expressions in it and call grok_array_decl instead of\n\tbuild_x_array_ref.\n\t<case CALL_EXPR>: Use tsubst_copy_and_build_call_args.\n\t* semantics.c (handle_omp_array_sections_1): Adjust grok_array_decl\n\tcaller.\ngcc/testsuite/\n\t* g++.dg/cpp2a/comma1.C: Expect different diagnostics for C++23.\n\t* g++.dg/cpp2a/comma3.C: Likewise.\n\t* g++.dg/cpp2a/comma4.C: Expect diagnostics for C++23.\n\t* g++.dg/cpp2a/comma5.C: Expect different diagnostics for C++23.\n\t* g++.dg/cpp23/feat-cxx2b.C: Test __cpp_multidimensional_subscript\n\tpredefined macro.\n\t* g++.dg/cpp23/subscript1.C: New test.\n\t* g++.dg/cpp23/subscript2.C: New test.\n\t* g++.dg/cpp23/subscript3.C: New test.\n\t* g++.dg/cpp23/subscript4.C: New test.\n\t* g++.dg/cpp23/subscript5.C: New test.\n\t* g++.dg/cpp23/subscript6.C: New test.", "tree": {"sha": "78aa38700bd9118938075f5d215d5a89cec32ca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78aa38700bd9118938075f5d215d5a89cec32ca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f88e50780137503365192011b261498b06c75930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88e50780137503365192011b261498b06c75930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88e50780137503365192011b261498b06c75930"}], "stats": {"total": 914, "additions": 796, "deletions": 118}, "files": [{"sha": "feb7e611de6d4cb6983dcabe6977ac9672a38077", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -1073,6 +1073,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_size_t_suffix=202011L\");\n \t  cpp_define (pfile, \"__cpp_if_consteval=202106L\");\n \t  cpp_define (pfile, \"__cpp_constexpr=202110L\");\n+\t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n \t}\n       if (flag_concepts)\n         {"}, {"sha": "2030eb1a4cd9196d995ee0e2caa8442a8b0de055", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -946,7 +946,8 @@ c_common_post_options (const char **pfilename)\n   /* -Wcomma-subscript is enabled by default in C++20.  */\n   SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n \t\t       warn_comma_subscript,\n-\t\t       cxx_dialect >= cxx20 && warn_deprecated);\n+\t\t       cxx_dialect >= cxx23\n+\t\t       || (cxx_dialect == cxx20 && warn_deprecated));\n \n   /* -Wvolatile is enabled by default in C++20.  */\n   SET_OPTION_IF_UNSET (&global_options, &global_options_set, warn_volatile,"}, {"sha": "28bd8e0c260acb9f80065b67d12f30b34a772be7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 113, "deletions": 2, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -6283,7 +6283,7 @@ op_is_ordered (tree_code code)\n     }\n }\n \n-/* Subroutine of build_new_op_1: Add to CANDIDATES all candidates for the\n+/* Subroutine of build_new_op: Add to CANDIDATES all candidates for the\n    operator indicated by CODE/CODE2.  This function calls itself recursively to\n    handle C++20 rewritten comparison operator candidates.  */\n \n@@ -6932,6 +6932,117 @@ build_new_op (const op_location_t &loc, enum tree_code code, int flags,\n   return NULL_TREE;\n }\n \n+/* Build a new call to operator[].  This may change ARGS.  */\n+\n+tree\n+build_op_subscript (const op_location_t &loc, tree obj,\n+\t\t    vec<tree, va_gc> **args, tree *overload,\n+\t\t    tsubst_flags_t complain)\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree fns, first_mem_arg = NULL_TREE;\n+  bool any_viable_p;\n+  tree result = NULL_TREE;\n+  void *p;\n+\n+  auto_cond_timevar tv (TV_OVERLOAD);\n+\n+  obj = mark_lvalue_use (obj);\n+\n+  if (error_operand_p (obj))\n+    return error_mark_node;\n+\n+  tree type = TREE_TYPE (obj);\n+\n+  obj = prep_operand (obj);\n+\n+  if (TYPE_BINFO (type))\n+    {\n+      fns = lookup_fnfields (TYPE_BINFO (type), ovl_op_identifier (ARRAY_REF),\n+\t\t\t     1, complain);\n+      if (fns == error_mark_node)\n+\treturn error_mark_node;\n+    }\n+  else\n+    fns = NULL_TREE;\n+\n+  if (args != NULL && *args != NULL)\n+    {\n+      *args = resolve_args (*args, complain);\n+      if (*args == NULL)\n+\treturn error_mark_node;\n+    }\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  p = conversion_obstack_alloc (0);\n+\n+  if (fns)\n+    {\n+      first_mem_arg = obj;\n+\n+      add_candidates (BASELINK_FUNCTIONS (fns),\n+\t\t      first_mem_arg, *args, NULL_TREE,\n+\t\t      NULL_TREE, false,\n+\t\t      BASELINK_BINFO (fns), BASELINK_ACCESS_BINFO (fns),\n+\t\t      LOOKUP_NORMAL, &candidates, complain);\n+    }\n+\n+  /* Be strict here because if we choose a bad conversion candidate, the\n+     errors we get won't mention the call context.  */\n+  candidates = splice_viable (candidates, true, &any_viable_p);\n+  if (!any_viable_p)\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  error (\"no match for call to %<%T::operator[] (%A)%>\",\n+\t\t TREE_TYPE (obj), build_tree_list_vec (*args));\n+\t  print_z_candidates (loc, candidates);\n+\t}\n+      result = error_mark_node;\n+    }\n+  else\n+    {\n+      cand = tourney (candidates, complain);\n+      if (cand == 0)\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      auto_diagnostic_group d;\n+\t      error (\"call of %<%T::operator[] (%A)%> is ambiguous\",\n+\t\t     TREE_TYPE (obj), build_tree_list_vec (*args));\n+\t      print_z_candidates (loc, candidates);\n+\t    }\n+\t  result = error_mark_node;\n+\t}\n+      else if (TREE_CODE (cand->fn) == FUNCTION_DECL\n+\t       && DECL_OVERLOADED_OPERATOR_P (cand->fn)\n+\t       && DECL_OVERLOADED_OPERATOR_IS (cand->fn, ARRAY_REF))\n+\t{\n+\t  if (overload)\n+\t    *overload = cand->fn;\n+\t  result = build_over_call (cand, LOOKUP_NORMAL, complain);\n+\t  if (trivial_fn_p (cand->fn) || DECL_IMMEDIATE_FUNCTION_P (cand->fn))\n+\t    /* There won't be a CALL_EXPR.  */;\n+\t  else if (result && result != error_mark_node)\n+\t    {\n+\t      tree call = extract_call_expr (result);\n+\t      CALL_EXPR_OPERATOR_SYNTAX (call) = true;\n+\n+\t      /* Specify evaluation order as per P0145R2.  */\n+\t      CALL_EXPR_ORDERED_ARGS (call) = op_is_ordered (ARRAY_REF) == 1;\n+\t    }\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return result;\n+}\n+\n /* CALL was returned by some call-building function; extract the actual\n    CALL_EXPR from any bits that have been tacked on, e.g. by\n    convert_from_reference.  */\n@@ -9748,7 +9859,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   if (cand->flags & LOOKUP_LIST_INIT_CTOR)\n     {\n       tree c = extract_call_expr (call);\n-      /* build_new_op_1 will clear this when appropriate.  */\n+      /* build_new_op will clear this when appropriate.  */\n       CALL_EXPR_ORDERED_ARGS (c) = true;\n     }\n   if (warned_p)"}, {"sha": "477996911ff4ce0fba7cd468827ba4178cfac2db", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -1007,7 +1007,9 @@ class releasing_vec\n      (bootstrap/91828).  */\n   tree& operator[] (ptrdiff_t i) const { return (*v)[i]; }\n \n-  ~releasing_vec() { release_tree_vector (v); }\n+  void release () { release_tree_vector (v); v = NULL; }\n+\n+  ~releasing_vec () { release_tree_vector (v); }\n private:\n   vec_t *v;\n };\n@@ -6471,6 +6473,9 @@ inline tree build_new_op (const op_location_t &loc, enum tree_code code,\n }\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_op_subscript\t\t\t(const op_location_t &, tree,\n+\t\t\t\t\t\t vec<tree, va_gc> **, tree *,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern bool aligned_allocation_fn_p\t\t(tree);\n extern tree destroying_delete_p\t\t\t(tree);\n extern bool usual_deallocation_fn_p\t\t(tree);\n@@ -6813,7 +6818,8 @@ extern void maybe_make_one_only\t\t\t(tree);\n extern bool vague_linkage_p\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n \t\t\t\t\t\t enum overload_flags);\n-extern tree grok_array_decl\t\t\t(location_t, tree, tree, bool);\n+extern tree grok_array_decl\t\t\t(location_t, tree, tree,\n+\t\t\t\t\t\t vec<tree, va_gc> **, tsubst_flags_t);\n extern tree delete_sanity\t\t\t(location_t, tree, tree, bool,\n \t\t\t\t\t\t int, tsubst_flags_t);\n extern tree check_classfn\t\t\t(tree, tree, tree);\n@@ -7711,6 +7717,8 @@ extern tree build_min_nt_loc\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t ...);\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_non_dep_op_overload\t(enum tree_code, tree, tree, ...);\n+extern tree build_min_non_dep_op_overload\t(tree, tree, tree,\n+\t\t\t\t\t\t vec<tree, va_gc> *);\n extern tree build_min_nt_call_vec (tree, vec<tree, va_gc> *);\n extern tree build_min_non_dep_call_vec\t\t(tree, tree, vec<tree, va_gc> *);\n extern vec<tree, va_gc>* vec_copy_and_insert    (vec<tree, va_gc>*, tree, unsigned);"}, {"sha": "56f80775ca03e9e6648107c582c188eca331f9be", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -15140,6 +15140,8 @@ grok_op_properties (tree decl, bool complain)\n     case OVL_OP_FLAG_BINARY:\n       if (arity != 2)\n \t{\n+\t  if (operator_code == ARRAY_REF && cxx_dialect >= cxx23)\n+\t    break;\n \t  error_at (loc,\n \t\t    methodp\n \t\t    ? G_(\"%qD must have exactly one argument\")"}, {"sha": "99f5dc784b7b57a0924dca0700ccc5929eda5cfb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 108, "deletions": 17, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -363,16 +363,20 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags)\n }\n \n /* Create an ARRAY_REF, checking for the user doing things backwards\n-   along the way.  DECLTYPE_P is for N3276, as in the parser.  */\n+   along the way.\n+   If INDEX_EXP is non-NULL, then that is the index expression,\n+   otherwise INDEX_EXP_LIST is the list of index expressions.  */\n \n tree\n grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n-\t\t bool decltype_p)\n+\t\t vec<tree, va_gc> **index_exp_list, tsubst_flags_t complain)\n {\n   tree type;\n   tree expr;\n   tree orig_array_expr = array_expr;\n   tree orig_index_exp = index_exp;\n+  vec<tree, va_gc> *orig_index_exp_list\n+    = index_exp_list ? *index_exp_list : NULL;\n   tree overload = NULL_TREE;\n \n   if (error_operand_p (array_expr) || error_operand_p (index_exp))\n@@ -381,25 +385,68 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n   if (processing_template_decl)\n     {\n       if (type_dependent_expression_p (array_expr)\n-\t  || type_dependent_expression_p (index_exp))\n-\treturn build_min_nt_loc (loc, ARRAY_REF, array_expr, index_exp,\n-\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  || (index_exp ? type_dependent_expression_p (index_exp)\n+\t\t\t: any_type_dependent_arguments_p (*index_exp_list)))\n+\t{\n+\t  if (index_exp == NULL)\n+\t    index_exp = build_min_nt_call_vec (ovl_op_identifier (ARRAY_REF),\n+\t\t\t\t\t       *index_exp_list);\n+\t  return build_min_nt_loc (loc, ARRAY_REF, array_expr, index_exp,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t}\n       array_expr = build_non_dependent_expr (array_expr);\n-      index_exp = build_non_dependent_expr (index_exp);\n+      if (index_exp)\n+\tindex_exp = build_non_dependent_expr (index_exp);\n+      else\n+\t{\n+\t  orig_index_exp_list = make_tree_vector_copy (*index_exp_list);\n+\t  make_args_non_dependent (*index_exp_list);\n+\t}\n     }\n \n   type = TREE_TYPE (array_expr);\n   gcc_assert (type);\n   type = non_reference (type);\n \n   /* If they have an `operator[]', use that.  */\n-  if (MAYBE_CLASS_TYPE_P (type) || MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n-    {\n-      tsubst_flags_t complain = tf_warning_or_error;\n-      if (decltype_p)\n-\tcomplain |= tf_decltype;\n-      expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n-\t\t\t   index_exp, NULL_TREE, &overload, complain);\n+  if (MAYBE_CLASS_TYPE_P (type)\n+      || (index_exp && MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n+      || (index_exp == NULL_TREE\n+\t  && !(*index_exp_list)->is_empty ()\n+\t  && MAYBE_CLASS_TYPE_P (TREE_TYPE ((*index_exp_list)->last ()))))\n+    {\n+      if (index_exp)\n+\texpr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n+\t\t\t     index_exp, NULL_TREE, &overload, complain);\n+      else if ((*index_exp_list)->is_empty ())\n+\texpr = build_op_subscript (loc, array_expr, index_exp_list, &overload,\n+\t\t\t\t   complain);\n+      else\n+\t{\n+\t  expr = build_op_subscript (loc, array_expr, index_exp_list,\n+\t\t\t\t     &overload, complain & tf_decltype);\n+\t  if (expr == error_mark_node)\n+\t    {\n+\t      tree idx = build_x_compound_expr_from_vec (*index_exp_list, NULL,\n+\t\t\t\t\t\t\t tf_none);\n+\t      if (idx != error_mark_node)\n+\t\texpr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL, array_expr,\n+\t\t\t\t     idx, NULL_TREE, &overload,\n+\t\t\t\t     complain & tf_decltype);\n+\t      if (expr == error_mark_node)\n+\t\t{\n+\t\t  overload = NULL_TREE;\n+\t\t  expr = build_op_subscript (loc, array_expr, index_exp_list,\n+\t\t\t\t\t     &overload, complain);\n+\t\t}\n+\t      else\n+\t\t/* If it would be valid albeit deprecated expression in C++20,\n+\t\t   just pedwarn on it and treat it as if wrapped in ().  */\n+\t\tpedwarn (loc, OPT_Wcomma_subscript,\n+\t\t\t \"top-level comma expression in array subscript \"\n+\t\t\t \"changed meaning in C++23\");\n+\t    }\n+\t}\n     }\n   else\n     {\n@@ -415,6 +462,31 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n       else\n \tp1 = build_expr_type_conversion (WANT_POINTER, array_expr, false);\n \n+      if (index_exp == NULL_TREE)\n+\t{\n+\t  if ((*index_exp_list)->is_empty ())\n+\t    {\n+\t      error_at (loc, \"built-in subscript operator without expression \"\n+\t\t\t     \"list\");\n+\t      return error_mark_node;\n+\t    }\n+\t  tree idx = build_x_compound_expr_from_vec (*index_exp_list, NULL,\n+\t\t\t\t\t\t     tf_none);\n+\t  if (idx != error_mark_node)\n+\t    /* If it would be valid albeit deprecated expression in C++20,\n+\t       just pedwarn on it and treat it as if wrapped in ().  */\n+\t    pedwarn (loc, OPT_Wcomma_subscript,\n+\t\t     \"top-level comma expression in array subscript \"\n+\t\t     \"changed meaning in C++23\");\n+\t  else\n+\t    {\n+\t      error_at (loc, \"built-in subscript operator with more than one \"\n+\t\t\t     \"expression in expression list\");\n+\t      return error_mark_node;\n+\t    }\n+\t  index_exp = idx;\n+\t}\n+\n       if (TREE_CODE (TREE_TYPE (index_exp)) == ARRAY_TYPE)\n \tp2 = index_exp;\n       else\n@@ -457,11 +529,30 @@ grok_array_decl (location_t loc, tree array_expr, tree index_exp,\n   if (processing_template_decl && expr != error_mark_node)\n     {\n       if (overload != NULL_TREE)\n-\treturn (build_min_non_dep_op_overload\n-\t\t(ARRAY_REF, expr, overload, orig_array_expr, orig_index_exp));\n+\t{\n+\t  if (orig_index_exp == NULL_TREE)\n+\t    {\n+\t      expr = build_min_non_dep_op_overload (expr, overload,\n+\t\t\t\t\t\t    orig_array_expr,\n+\t\t\t\t\t\t    orig_index_exp_list);\n+\t      release_tree_vector (orig_index_exp_list);\n+\t      return expr;\n+\t    }\n+\t  return build_min_non_dep_op_overload (ARRAY_REF, expr, overload,\n+\t\t\t\t\t\torig_array_expr,\n+\t\t\t\t\t\torig_index_exp);\n+\t}\n+\n+      if (orig_index_exp == NULL_TREE)\n+\t{\n+\t  orig_index_exp\n+\t    = build_min_nt_call_vec (ovl_op_identifier (ARRAY_REF),\n+\t\t\t\t     orig_index_exp_list);\n+\t  release_tree_vector (orig_index_exp_list);\n+\t}\n \n-      return build_min_non_dep (ARRAY_REF, expr, orig_array_expr, orig_index_exp,\n-\t\t\t\tNULL_TREE, NULL_TREE);\n+      return build_min_non_dep (ARRAY_REF, expr, orig_array_expr,\n+\t\t\t\torig_index_exp, NULL_TREE, NULL_TREE);\n     }\n   return expr;\n }"}, {"sha": "0bd585257261b0abbd917be193118b0bc5c76b26", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 105, "deletions": 42, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -7898,11 +7898,62 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   return error_mark_node;\n }\n \n+/* Helper function for cp_parser_parenthesized_expression_list and\n+   cp_parser_postfix_open_square_expression.  Parse a single element\n+   of parenthesized expression list.  */\n+\n+static cp_expr\n+cp_parser_parenthesized_expression_list_elt (cp_parser *parser, bool cast_p,\n+\t\t\t\t\t     bool allow_expansion_p,\n+\t\t\t\t\t     bool fold_expr_p,\n+\t\t\t\t\t     bool *non_constant_p)\n+{\n+  cp_expr expr (NULL_TREE);\n+  bool expr_non_constant_p;\n+\n+  /* Parse the next assignment-expression.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+    {\n+      /* A braced-init-list.  */\n+      cp_lexer_set_source_position (parser->lexer);\n+      maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n+      expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n+      if (non_constant_p && expr_non_constant_p)\n+\t*non_constant_p = true;\n+    }\n+  else if (non_constant_p)\n+    {\n+      expr = cp_parser_constant_expression (parser,\n+\t\t\t\t\t    /*allow_non_constant_p=*/true,\n+\t\t\t\t\t    &expr_non_constant_p);\n+      if (expr_non_constant_p)\n+\t*non_constant_p = true;\n+    }\n+  else\n+    expr = cp_parser_assignment_expression (parser, /*pidk=*/NULL, cast_p);\n+\n+  if (fold_expr_p)\n+    expr = instantiate_non_dependent_expr (expr);\n+\n+  /* If we have an ellipsis, then this is an expression expansion.  */\n+  if (allow_expansion_p\n+      && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+    {\n+      /* Consume the `...'.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      /* Build the argument pack.  */\n+      expr = make_pack_expansion (expr);\n+    }\n+  return expr;\n+}\n+\n /* A subroutine of cp_parser_postfix_expression that also gets hijacked\n    by cp_parser_builtin_offsetof.  We're looking for\n \n      postfix-expression [ expression ]\n      postfix-expression [ braced-init-list ] (C++11)\n+     postfix-expression [ expression-list[opt] ] (C++23)\n \n    FOR_OFFSETOF is set if we're being called in that context, which\n    changes how we deal with integer constant expressions.  */\n@@ -7914,6 +7965,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t\t\t\t\t  bool decltype_p)\n {\n   tree index = NULL_TREE;\n+  releasing_vec expression_list = NULL;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n   bool saved_greater_than_is_operator_p;\n \n@@ -7935,7 +7987,49 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n     index = cp_parser_constant_expression (parser);\n   else\n     {\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+      if (cxx_dialect >= cxx23\n+\t  && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_SQUARE))\n+\t*&expression_list = make_tree_vector ();\n+      else if (cxx_dialect >= cxx23)\n+\t{\n+\t  while (true)\n+\t    {\n+\t      cp_expr expr\n+\t\t= cp_parser_parenthesized_expression_list_elt (parser,\n+\t\t\t\t\t\t\t       /*cast_p=*/\n+\t\t\t\t\t\t\t       false,\n+\t\t\t\t\t\t\t       /*allow_exp_p=*/\n+\t\t\t\t\t\t\t       true,\n+\t\t\t\t\t\t\t       /*fold_expr_p=*/\n+\t\t\t\t\t\t\t       false,\n+\t\t\t\t\t\t\t       /*non_cst_p=*/\n+\t\t\t\t\t\t\t       NULL);\n+\n+\t      if (expr == error_mark_node)\n+\t\tindex = error_mark_node;\n+\t      else if (expression_list.get () == NULL\n+\t\t       && !PACK_EXPANSION_P (expr.get_value ()))\n+\t\tindex = expr.get_value ();\n+\t      else\n+\t\tvec_safe_push (expression_list, expr.get_value ());\n+\n+\t      /* If the next token isn't a `,', then we are done.  */\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+\t\tbreak;\n+\n+\t      if (expression_list.get () == NULL && index != error_mark_node)\n+\t\t{\n+\t\t  *&expression_list = make_tree_vector_single (index);\n+\t\t  index = NULL_TREE;\n+\t\t}\n+\n+\t      /* Otherwise, consume the `,' and keep going.  */\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t  if (expression_list.get () && index == error_mark_node)\n+\t    expression_list.release ();\n+\t}\n+      else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t{\n \t  bool expr_nonconst_p;\n \t  cp_lexer_set_source_position (parser->lexer);\n@@ -7955,7 +8049,9 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \n   /* Build the ARRAY_REF.  */\n   postfix_expression = grok_array_decl (loc, postfix_expression,\n-\t\t\t\t\tindex, decltype_p);\n+\t\t\t\t\tindex, &expression_list,\n+\t\t\t\t\ttf_warning_or_error\n+\t\t\t\t\t| (decltype_p ? tf_decltype : 0));\n \n   /* When not doing offsetof, array references are not permitted in\n      constant-expressions.  */\n@@ -8315,44 +8411,11 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t  }\n \telse\n \t  {\n-\t    bool expr_non_constant_p;\n-\n-\t    /* Parse the next assignment-expression.  */\n-\t    if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\t      {\n-\t\t/* A braced-init-list.  */\n-\t\tcp_lexer_set_source_position (parser->lexer);\n-\t\tmaybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n-\t\texpr = cp_parser_braced_list (parser, &expr_non_constant_p);\n-\t\tif (non_constant_p && expr_non_constant_p)\n-\t\t  *non_constant_p = true;\n-\t      }\n-\t    else if (non_constant_p)\n-\t      {\n-\t\texpr = (cp_parser_constant_expression\n-\t\t\t(parser, /*allow_non_constant_p=*/true,\n-\t\t\t &expr_non_constant_p));\n-\t\tif (expr_non_constant_p)\n-\t\t  *non_constant_p = true;\n-\t      }\n-\t    else\n-\t      expr = cp_parser_assignment_expression (parser, /*pidk=*/NULL,\n-\t\t\t\t\t\t      cast_p);\n-\n-\t    if (fold_expr_p)\n-\t      expr = instantiate_non_dependent_expr (expr);\n-\n-            /* If we have an ellipsis, then this is an expression\n-\t       expansion.  */\n-            if (allow_expansion_p\n-                && cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n-              {\n-                /* Consume the `...'.  */\n-                cp_lexer_consume_token (parser->lexer);\n-\n-                /* Build the argument pack.  */\n-                expr = make_pack_expansion (expr);\n-              }\n+\t    expr\n+\t      = cp_parser_parenthesized_expression_list_elt (parser, cast_p,\n+\t\t\t\t\t\t\t     allow_expansion_p,\n+\t\t\t\t\t\t\t     fold_expr_p,\n+\t\t\t\t\t\t\t     non_constant_p);\n \n \t    if (wrap_locations_p)\n \t      expr.maybe_add_location_wrapper ();\n@@ -10625,8 +10688,8 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \n \tcase CPP_DEREF:\n \t  /* offsetof-member-designator \"->\" identifier */\n-\t  expr = grok_array_decl (token->location, expr,\n-\t\t\t\t  integer_zero_node, false);\n+\t  expr = grok_array_decl (token->location, expr, integer_zero_node,\n+\t\t\t\t  NULL, tf_warning_or_error);\n \t  /* FALLTHRU */\n \n \tcase CPP_DOT:"}, {"sha": "49e5745410edaad095efd09df75cb89a8fd10488", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -19654,6 +19654,49 @@ maybe_fold_fn_template_args (tree fn, tsubst_flags_t complain)\n   return fold_targs_r (targs, complain);\n }\n \n+/* Helper function for tsubst_copy_and_build CALL_EXPR and ARRAY_REF\n+   handling.  */\n+\n+static void\n+tsubst_copy_and_build_call_args (tree t, tree args, tsubst_flags_t complain,\n+\t\t\t\t tree in_decl,\n+\t\t\t\t bool integral_constant_expression_p,\n+\t\t\t\t releasing_vec &call_args)\n+{\n+  unsigned int nargs = call_expr_nargs (t);\n+  for (unsigned int i = 0; i < nargs; ++i)\n+    {\n+      tree arg = CALL_EXPR_ARG (t, i);\n+\n+      if (!PACK_EXPANSION_P (arg))\n+\tvec_safe_push (call_args,\n+\t\t       tsubst_copy_and_build (arg, args, complain, in_decl,\n+\t\t\t\t\t      /*function_p=*/false,\n+\t\t\t\t\t      integral_constant_expression_p));\n+      else\n+\t{\n+\t  /* Expand the pack expansion and push each entry onto CALL_ARGS.  */\n+\t  arg = tsubst_pack_expansion (arg, args, complain, in_decl);\n+\t  if (TREE_CODE (arg) == TREE_VEC)\n+\t    {\n+\t      unsigned int len, j;\n+\n+\t      len = TREE_VEC_LENGTH (arg);\n+\t      for (j = 0; j < len; ++j)\n+\t\t{\n+\t\t  tree value = TREE_VEC_ELT (arg, j);\n+\t\t  if (value != NULL_TREE)\n+\t\t    value = convert_from_reference (value);\n+\t\t  vec_safe_push (call_args, value);\n+\t\t}\n+\t    }\n+\t  else\n+\t    /* A partial substitution.  Add one entry.  */\n+\t    vec_safe_push (call_args, arg);\n+\t}\n+    }\n+}\n+\n /* Like tsubst but deals with expressions and performs semantic\n    analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\" or\n    \"F<TARGS> (ARGS)\".  */\n@@ -20053,6 +20096,28 @@ tsubst_copy_and_build (tree t,\n     case ARRAY_REF:\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == CALL_EXPR\n+\t  && (CALL_EXPR_FN (TREE_OPERAND (t, 1))\n+\t      == ovl_op_identifier (ARRAY_REF)))\n+\t{\n+\t  tree c = TREE_OPERAND (t, 1);\n+\t  releasing_vec index_exp_list;\n+\t  tsubst_copy_and_build_call_args (c, args, complain, in_decl,\n+\t\t\t\t\t   integral_constant_expression_p,\n+\t\t\t\t\t   index_exp_list);\n+\n+\t  tree r;\n+\t  if (vec_safe_length (index_exp_list) == 1\n+\t      && !PACK_EXPANSION_P (index_exp_list[0]))\n+\t    r = grok_array_decl (EXPR_LOCATION (t), op1,\n+\t\t\t\t index_exp_list[0], NULL,\n+\t\t\t\t complain | decltype_flag);\n+\t  else\n+\t    r = grok_array_decl (EXPR_LOCATION (t), op1,\n+\t\t\t\t NULL_TREE, &index_exp_list,\n+\t\t\t\t complain | decltype_flag);\n+\t  RETURN (r);\n+\t}\n       RETURN (build_x_array_ref (EXPR_LOCATION (t), op1,\n \t\t\t\t RECUR (TREE_OPERAND (t, 1)),\n \t\t\t\t complain|decltype_flag));\n@@ -20261,7 +20326,7 @@ tsubst_copy_and_build (tree t,\n     case CALL_EXPR:\n       {\n \ttree function;\n-\tunsigned int nargs, i;\n+\tunsigned int nargs;\n \tbool qualified_p;\n \tbool koenig_p;\n \ttree ret;\n@@ -20344,37 +20409,9 @@ tsubst_copy_and_build (tree t,\n \n \tnargs = call_expr_nargs (t);\n \treleasing_vec call_args;\n-\tfor (i = 0; i < nargs; ++i)\n-\t  {\n-\t    tree arg = CALL_EXPR_ARG (t, i);\n-\n-\t    if (!PACK_EXPANSION_P (arg))\n-\t      vec_safe_push (call_args, RECUR (CALL_EXPR_ARG (t, i)));\n-\t    else\n-\t      {\n-\t\t/* Expand the pack expansion and push each entry onto\n-\t\t   CALL_ARGS.  */\n-\t\targ = tsubst_pack_expansion (arg, args, complain, in_decl);\n-\t\tif (TREE_CODE (arg) == TREE_VEC)\n-\t\t  {\n-\t\t    unsigned int len, j;\n-\n-\t\t    len = TREE_VEC_LENGTH (arg);\n-\t\t    for (j = 0; j < len; ++j)\n-\t\t      {\n-\t\t\ttree value = TREE_VEC_ELT (arg, j);\n-\t\t\tif (value != NULL_TREE)\n-\t\t\t  value = convert_from_reference (value);\n-\t\t\tvec_safe_push (call_args, value);\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* A partial substitution.  Add one entry.  */\n-\t\t    vec_safe_push (call_args, arg);\n-\t\t  }\n-\t      }\n-\t  }\n+\ttsubst_copy_and_build_call_args (t, args, complain, in_decl,\n+\t\t\t\t\t integral_constant_expression_p,\n+\t\t\t\t\t call_args);\n \n \t/* Stripped-down processing for a call in a thunk.  Specifically, in\n \t   the thunk template for a generic lambda.  */"}, {"sha": "cd1956497f8cfe0e60034d7b802ee6a7fb1e81c8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -5394,7 +5394,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t      OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION);\n-  ret = grok_array_decl (OMP_CLAUSE_LOCATION (c), ret, low_bound, false);\n+  ret = grok_array_decl (OMP_CLAUSE_LOCATION (c), ret, low_bound, NULL,\n+\t\t\t tf_warning_or_error);\n   return ret;\n }\n "}, {"sha": "7c58e23db3c28ac261caab261b50b3e37be56960", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -3671,7 +3671,7 @@ build_min_non_dep_op_overload (enum tree_code op,\n \t}\n     }\n   else\n-   gcc_unreachable ();\n+    gcc_unreachable ();\n \n   va_end (p);\n   call = build_min_non_dep_call_vec (non_dep, fn, args);\n@@ -3685,6 +3685,35 @@ build_min_non_dep_op_overload (enum tree_code op,\n   return call;\n }\n \n+/* Similar to above build_min_non_dep_op_overload, but arguments\n+   are taken from ARGS vector.  */\n+\n+tree\n+build_min_non_dep_op_overload (tree non_dep, tree overload, tree object,\n+\t\t\t       vec<tree, va_gc> *args)\n+{\n+  non_dep = extract_call_expr (non_dep);\n+\n+  unsigned int nargs = call_expr_nargs (non_dep);\n+  gcc_assert (TREE_CODE (TREE_TYPE (overload)) == METHOD_TYPE);\n+  tree binfo = TYPE_BINFO (TREE_TYPE (object));\n+  tree method = build_baselink (binfo, binfo, overload, NULL_TREE);\n+  tree fn = build_min (COMPONENT_REF, TREE_TYPE (overload),\n+\t\t       object, method, NULL_TREE);\n+  nargs--;\n+  gcc_assert (vec_safe_length (args) == nargs);\n+\n+  tree call = build_min_non_dep_call_vec (non_dep, fn, args);\n+\n+  tree call_expr = extract_call_expr (call);\n+  KOENIG_LOOKUP_P (call_expr) = KOENIG_LOOKUP_P (non_dep);\n+  CALL_EXPR_OPERATOR_SYNTAX (call_expr) = true;\n+  CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (non_dep);\n+  CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (non_dep);\n+\n+  return call;\n+}\n+\n /* Return a new tree vec copied from VEC, with ELT inserted at index IDX.  */\n \n vec<tree, va_gc> *"}, {"sha": "d0ac59768b9df226b4c9d2dd278f4a0732419d1d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -3479,19 +3479,27 @@ about ABI tags.\n @opindex Wcomma-subscript\n @opindex Wno-comma-subscript\n Warn about uses of a comma expression within a subscripting expression.\n-This usage was deprecated in C++20.  However, a comma expression wrapped\n-in @code{( )} is not deprecated.  Example:\n+This usage was deprecated in C++20 and is going to be removed in C++23.\n+However, a comma expression wrapped in @code{( )} is not deprecated.  Example:\n \n @smallexample\n @group\n void f(int *a, int b, int c) @{\n-    a[b,c];     // deprecated\n+    a[b,c];     // deprecated in C++20, invalid in C++23\n     a[(b,c)];   // OK\n @}\n @end group\n @end smallexample\n \n-Enabled by default with @option{-std=c++20}.\n+In C++23 it is valid to have comma separated expressions in a subscript\n+when an overloaded subscript operator is found and supports the right\n+number and types of arguments.  G++ will accept the formerly valid syntax\n+for code that is not valid in C++23 but used to be valid but deprecated\n+in C++20 with a pedantic warning that can be disabled with\n+@option{-Wno-comma-subscript}.\n+\n+Enabled by default with @option{-std=c++20} unless @option{-Wno-deprecated},\n+and with @option{-std=c++23} regardless of @option{-Wno-deprecated}.\n \n @item -Wctad-maybe-unsupported @r{(C++ and Objective-C++ only)}\n @opindex Wctad-maybe-unsupported"}, {"sha": "923e6bcf65ec569f8606d77b838ebd48de5eddde", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -551,3 +551,9 @@\n #elif __cpp_if_consteval != 202106\n #  error \"__cpp_if_consteval != 202106\"\n #endif\n+\n+#ifndef __cpp_multidimensional_subscript\n+#  error \"__cpp_multidimensional_subscript\"\n+#elif __cpp_multidimensional_subscript != 202110\n+#  error \"__cpp_multidimensional_subscript != 202110\"\n+#endif"}, {"sha": "a96c93eef82f54019a28f61629a348febdee2200", "filename": "gcc/testsuite/g++.dg/cpp23/subscript1.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript1.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,55 @@\n+// P2128R6\n+// { dg-do run }\n+// { dg-options \"-std=c++23\" }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  constexpr S () : a {} {};\n+  constexpr S (int x, int y, int z) : a {x, y, z} {};\n+  constexpr int &operator[] () { return a[0]; }\n+  constexpr int &operator[] (int x) { return a[x]; }\n+  constexpr int &operator[] (int x, long y) { return a[x + y * 8]; }\n+  int a[64];\n+};\n+\n+struct T\n+{\n+  operator int () { return 42; };\n+};\n+\n+int buf[64];\n+\n+struct U\n+{\n+  operator int * () { return buf; }\n+};\n+\n+static_assert (S ()[1] == 0);\n+static_assert (S (1, 2, 42)[2] == 42);\n+static_assert (S ()[3, 4] == 0);\n+static_assert (S (1, 43, 2)[1, 0] == 43);\n+static_assert (S ()[] == 0);\n+static_assert (S (44, 1, 2)[] == 44);\n+\n+int\n+main ()\n+{\n+  S s;\n+  for (int i = 0; i < 64; i++)\n+    s.a[i] = 64 - i;\n+  if (s[] != 64 || s[3] != 61 || s[4, 5] != 20)\n+    abort ();\n+  s[]++;\n+  s[42]++;\n+  ++s[3, 2];\n+  if (s.a[0] != 65 || s.a[42] != 23 || s.a[19] != 46)\n+    abort ();\n+  T t;\n+  U u;\n+  if (&u[t] != &buf[42])\n+    abort ();\n+  if (&t[u] != &buf[42])\n+    abort ();\n+}"}, {"sha": "f8ec87d88efcb9d840179966cb1f1754aaa6a4b1", "filename": "gcc/testsuite/g++.dg/cpp23/subscript2.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript2.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,51 @@\n+// P2128R6\n+// { dg-do compile }\n+// { dg-options \"-std=c++23\" }\n+\n+struct S\n+{\n+  S () : a {} {};\n+  int &operator[] () { return a[0]; }\n+  int &operator[] (int x) { return a[x]; }\n+  int &operator[] (int x, long y) { return a[x + y * 8]; }\n+  int a[64];\n+};\n+\n+struct T\n+{\n+  operator int () { return 42; };\n+};\n+\n+int buf[64];\n+\n+struct U\n+{\n+  operator int * () { return buf; }\n+};\n+\n+struct V\n+{\n+  V () : a {} {};\n+  V (int x, int y, int z) : a {x, y, z} {};\n+  int &operator[] () { return a[0]; }\t\t\t\t// { dg-message \"candidate\" }\n+  int &operator[] (int x, long y) { return a[x + y * 8]; }\t// { dg-message \"candidate\" }\n+  int a[64];\n+};\n+\n+void\n+foo ()\n+{\n+  S s;\n+  T t;\n+  U u;\n+  V v;\n+  auto &a = buf[];\t\t// { dg-error \"built-in subscript operator without expression list\" }\n+  auto &b = buf[1, 2];\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" }\n+  auto &c = s[1, 2, 3];\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" }\n+  auto &d = v[1];\t\t// { dg-error \"no match for 'operator\\\\\\[\\\\\\]' in 'v\\\\\\[1\\\\\\]' \\\\\\(operand types are 'V' and 'int'\\\\\\)\" }\n+  auto &e = v[1, 2, 3];\t\t// { dg-error \"no match for call to 'V::operator\\\\\\[\\\\\\] \\\\\\(int, int, int\\\\\\)'\" }\n+  auto &f = t[42, u];\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" }\n+  auto &g = u[42, t];\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" }\n+  auto &h = buf[42, 2.5];\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" }\n+\t\t\t\t// { dg-error \"invalid types \\[^\\n\\r]* for array subscript\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "2d735e4e0e0ca347b68df680bc9f995c3dda5e49", "filename": "gcc/testsuite/g++.dg/cpp23/subscript3.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript3.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,90 @@\n+// P2128R6\n+// { dg-do run }\n+// { dg-options \"-std=c++23\" }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  constexpr S () : a {} {};\n+  constexpr S (int x, int y, int z) : a {x, y, z} {};\n+  constexpr int &operator[] () { return a[0]; }\n+  constexpr int &operator[] (int x) { return a[x]; }\n+  constexpr int &operator[] (int x, long y) { return a[x + y * 8]; }\n+  int a[64];\n+};\n+\n+struct T\n+{\n+  operator int () { return 42; };\n+};\n+\n+int buf[64];\n+\n+struct U\n+{\n+  operator int * () { return buf; }\n+};\n+\n+template <int N>\n+void\n+foo ()\n+{\n+  static_assert (S ()[1] == 0);\n+  static_assert (S (1, 2, 42)[2] == 42);\n+  static_assert (S ()[3, 4] == 0);\n+  static_assert (S (1, 43, 2)[1, 0] == 43);\n+  static_assert (S ()[] == 0);\n+  static_assert (S (44, 1, 2)[] == 44);\n+  S s;\n+  for (int i = 0; i < 64; i++)\n+    s.a[i] = 64 - i;\n+  if (s[] != 64 || s[3] != 61 || s[4, 5] != 20)\n+    abort ();\n+  s[]++;\n+  s[42]++;\n+  ++s[3, 2];\n+  if (s.a[0] != 65 || s.a[42] != 23 || s.a[19] != 46)\n+    abort ();\n+  T t;\n+  U u;\n+  if (&u[t] != &buf[42])\n+    abort ();\n+  if (&t[u] != &buf[42])\n+    abort ();\n+}\n+\n+template <typename V, typename W, typename X>\n+void\n+bar ()\n+{\n+  static_assert (V ()[1] == 0);\n+  static_assert (V (1, 2, 42)[2] == 42);\n+  static_assert (V ()[3, 4] == 0);\n+  static_assert (V (1, 43, 2)[1, 0] == 43);\n+  static_assert (V ()[] == 0);\n+  static_assert (V (44, 1, 2)[] == 44);\n+  V s;\n+  for (int i = 0; i < 64; i++)\n+    s.a[i] = 64 - i;\n+  if (s[] != 64 || s[3] != 61 || s[4, 5] != 20)\n+    abort ();\n+  s[]++;\n+  s[42]++;\n+  ++s[3, 2];\n+  if (s.a[0] != 65 || s.a[42] != 23 || s.a[19] != 46)\n+    abort ();\n+  W t;\n+  X u;\n+  if (&u[t] != &buf[42])\n+    abort ();\n+  if (&t[u] != &buf[42])\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  foo <0> ();\n+  bar <S, T, U> ();\n+}"}, {"sha": "085095d9dee6594bb4fcc4343ff06a63e9bc5c20", "filename": "gcc/testsuite/g++.dg/cpp23/subscript4.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript4.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,44 @@\n+// P2128R6\n+// { dg-do run }\n+// { dg-options \"-std=c++23\" }\n+\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  constexpr S () : a {} {};\n+  constexpr S (int x, int y, int z) : a {x, y, z} {};\n+  constexpr int &operator[] () { return a[0]; }\n+  constexpr int &operator[] (int x) { return a[x]; }\n+  constexpr int &operator[] (int x, long y) { return a[x + y * 8]; }\n+  int a[64];\n+};\n+int buf[26];\n+\n+template <class ...Ts>\n+auto &\n+foo (S &s, Ts... args)\n+{\n+  return s[args...];\n+}\n+\n+template <typename T, class ...Ts>\n+auto &\n+bar (T &s, Ts... args)\n+{\n+  return s[args...];\n+}\n+\n+int\n+main ()\n+{\n+  S s;\n+  if (&foo (s) != &s.a[0]\n+      || &foo (s, 42) != &s.a[42]\n+      || &foo (s, 5, 4) != &s.a[37]\n+      || &bar (s) != &s.a[0]\n+      || &bar (s, 22) != &s.a[22]\n+      || &bar (s, 17, 3L) != &s.a[41]\n+      || &bar (buf, 5) != &buf[5])\n+    abort ();\n+}"}, {"sha": "b36bc774ec4d1b6fecb6ef2c913964c672c6e7ae", "filename": "gcc/testsuite/g++.dg/cpp23/subscript5.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript5.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,28 @@\n+// P2128R6\n+// { dg-do run { target c++11 } }\n+\n+#include <initializer_list>\n+#include <cstdlib>\n+\n+struct S\n+{\n+  S () : a {} {};\n+  int &operator[] (std::initializer_list<int> l) {\n+    int sum = 0;\n+    for (auto x : l)\n+      sum += x;\n+    return a[sum];\n+  }\n+  int a[64];\n+};\n+\n+int\n+main ()\n+{\n+  S s;\n+  if (&s[{0}] != &s.a[0]\n+      || &s[{42}] != &s.a[42]\n+      || &s[{5, 7, 9}] != &s.a[5 + 7 + 9]\n+      || &s[{1, 2, 3, 4}] != &s.a[1 + 2 + 3 + 4])\n+    abort ();\n+}"}, {"sha": "72c7aef42af17dd138d260bee98025c38d9718ec", "filename": "gcc/testsuite/g++.dg/cpp23/subscript6.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fsubscript6.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -0,0 +1,31 @@\n+// P2128R6\n+// { dg-do run }\n+// { dg-options \"-std=c++23\" }\n+\n+#include <initializer_list>\n+#include <cstdlib>\n+\n+struct S\n+{\n+  S () : a {} {};\n+  int &operator[] (std::initializer_list<int> l, std::initializer_list<int> m) {\n+    int sum = 0;\n+    for (auto x : l)\n+      sum += x;\n+    for (auto x : m)\n+      sum += x;\n+    return a[sum];\n+  }\n+  int a[64];\n+};\n+\n+int\n+main ()\n+{\n+  S s;\n+  if (&s[{0}, {3, 1, 2}] != &s.a[0 + 3 + 1 + 2]\n+      || &s[{42}, {11, 1}] != &s.a[42 + 11 + 1]\n+      || &s[{5, 7, 9}, {3}] != &s.a[5 + 7 + 9 + 3]\n+      || &s[{1, 2, 3, 4}, {3, 5, 8}] != &s.a[1 + 2 + 3 + 4 + 3 + 5 + 8])\n+    abort ();\n+}"}, {"sha": "1799c187ad5cb2fc241ae0394d9f351c320c2f98", "filename": "gcc/testsuite/g++.dg/cpp2a/comma1.C", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma1.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -8,19 +8,24 @@ struct S {\n void\n fn (int *a, int b, int c)\n {\n-  a[b,c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20 } }\n+  a[b,c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_only } }\n+\t  // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(b,c)];\n \n-  a[(void) b, c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20 } }\n+  a[(void) b, c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_only } }\n+\t\t  // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, c)];\n \n-  a[(void) b, (void) c, (void) b, b]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20 } }\n+  a[(void) b, (void) c, (void) b, b]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_only } }\n+\t\t\t\t      // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, (void) c, (void) b, b)];\n \n-  a[S(), 10]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20 } }\n+  a[S(), 10]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_only } }\n+\t      // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(S(), 10)];\n \n   a[int{(1,2)}];\n-  a[int{(1,2)}, int{}]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20 } }\n+  a[int{(1,2)}, int{}]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_only } }\n+\t\t\t// { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(int{(1,2)}, int{})];\n }"}, {"sha": "daf5359604927755a378f037702dbca5a41911a2", "filename": "gcc/testsuite/g++.dg/cpp2a/comma3.C", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma3.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -9,19 +9,24 @@ struct S {\n void\n fn (int *a, int b, int c)\n {\n-  a[b,c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[b,c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t  // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(b,c)];\n \n-  a[(void) b, c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[(void) b, c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t  // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, c)];\n \n-  a[(void) b, (void) c, (void) b, b]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[(void) b, (void) c, (void) b, b]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t\t\t      // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, (void) c, (void) b, b)];\n \n-  a[S(), 10]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[S(), 10]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t      // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(S(), 10)];\n \n   a[int{(1,2)}];\n-  a[int{(1,2)}, int{}]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[int{(1,2)}, int{}]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(int{(1,2)}, int{})];\n }"}, {"sha": "11aff99c5db0cc0c3dccb27a6a6cfccfd267fcd7", "filename": "gcc/testsuite/g++.dg/cpp2a/comma4.C", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma4.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -10,18 +10,23 @@ void\n fn (int *a, int b, int c)\n {\n   a[b,c]; // { dg-bogus \"top-level comma expression in array subscript is deprecated\" }\n+\t  // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(b,c)];\n \n   a[(void) b, c]; // { dg-bogus \"top-level comma expression in array subscript is deprecated\" }\n+\t\t  // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, c)];\n \n   a[(void) b, (void) c, (void) b, b]; // { dg-bogus \"top-level comma expression in array subscript is deprecated\" }\n+\t\t\t\t      // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[((void) b, (void) c, (void) b, b)];\n \n   a[S(), 10]; // { dg-bogus \"top-level comma expression in array subscript is deprecated\" }\n+\t      // { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(S(), 10)];\n \n   a[int{(1,2)}];\n   a[int{(1,2)}, int{}]; // { dg-bogus \"top-level comma expression in array subscript is deprecated\" }\n+\t\t\t// { dg-warning \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(int{(1,2)}, int{})];\n }"}, {"sha": "8bf94d14ac9327970d8e24d5fb886e28cf3f5fa1", "filename": "gcc/testsuite/g++.dg/cpp2a/comma5.C", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fcomma5.C?ref=b38c9cf6d570f6c4c1109e00c8b81d82d0f24df3", "patch": "@@ -8,14 +8,20 @@ void\n fn (int *a, int b, int c)\n {\n   a[foo<int, int>(1, 2)];\n-  a[foo<int, int>(1, 2), foo<int, int>(3, 4)]; // { dg-warning \"24:top-level comma expression in array subscript is deprecated\" }\n+  a[foo<int, int>(1, 2), foo<int, int>(3, 4)]; // { dg-warning \"24:top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t\t\t\t       // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n \n-  a[b < c, b < c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n-  a[b < c, b > c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n-  a[b > c, b > c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n-  a[b > c, b < c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[b < c, b < c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t   // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n+  a[b < c, b > c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t   // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n+  a[b > c, b > c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t   // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n+  a[b > c, b < c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t   // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(b < c, b < c)];\n   a[(b < c, b > c)];\n-  a[b << c, b << c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" }\n+  a[b << c, b << c]; // { dg-warning \"top-level comma expression in array subscript is deprecated\" \"\" { target c++20_down } }\n+\t\t     // { dg-error \"top-level comma expression in array subscript changed meaning in\" \"\" { target c++23 } .-1 }\n   a[(b << c, b << c)]; \n }"}]}