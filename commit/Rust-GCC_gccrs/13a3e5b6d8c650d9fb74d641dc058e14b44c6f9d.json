{"sha": "13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNhM2U1YjZkOGM2NTBkOWZiNzRkNjQxZGMwNThlMTRiNDRjNmY5ZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2011-12-08T22:00:38Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2011-12-08T22:00:38Z"}, "message": "re PR middle-end/39976 (Big sixtrack degradation on powerpc 32/64 after revision r146817)\n\n2011-12-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR middle-end/39976\n\t* tree-ssa-dom.c (enum expr_kind): Add EXPR_PHI.\n\t(struct hashable_expr): Add struct phi field.\n\t(initialize_hash_element): Handle phis; change to use XCNEWVEC.\n\t(hashable_expr_equal_p): Handle phis.\n\t(iterative_hash_hashable_expr): Likewise.\n\t(print_expr_hash_elt): Likewise.\n\t(free_expr_hash_elt): Likewise.\n\t(dom_opt_enter_block): Create equivalences from redundant phis.\n\t(eliminate_redundant_computations): Handle redundant phis.\n\t(lookup_avail_expr): Handle phis.\n\nFrom-SVN: r182140", "tree": {"sha": "a6babca41ccd1cdaf1767fd479f5f3b0a4249742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6babca41ccd1cdaf1767fd479f5f3b0a4249742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4be257dcc48c64761d15bced7b292abe9ef1ffee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be257dcc48c64761d15bced7b292abe9ef1ffee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4be257dcc48c64761d15bced7b292abe9ef1ffee"}], "stats": {"total": 107, "additions": 102, "deletions": 5}, "files": [{"sha": "e6e29e53a4f011aa9d160b5155f8804e87cadf29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "patch": "@@ -1,3 +1,17 @@\n+2011-12-08  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR middle-end/39976\n+\t* tree-ssa-dom.c (enum expr_kind): Add EXPR_PHI.\n+\t(struct hashable_expr): Add struct phi field.\n+\t(initialize_hash_element): Handle phis; change to use XCNEWVEC.\n+\t(hashable_expr_equal_p): Handle phis.\n+\t(iterative_hash_hashable_expr): Likewise.\n+\t(print_expr_hash_elt): Likewise.\n+\t(free_expr_hash_elt): Likewise.\n+\t(dom_opt_enter_block): Create equivalences from redundant phis.\n+\t(eliminate_redundant_computations): Handle redundant phis.\n+\t(lookup_avail_expr): Handle phis.\n+\n 2011-12-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/51466"}, {"sha": "a9a658f2c44b9a51032d8cfe41baebef675e3407", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=13a3e5b6d8c650d9fb74d641dc058e14b44c6f9d", "patch": "@@ -52,7 +52,8 @@ enum expr_kind\n   EXPR_UNARY,\n   EXPR_BINARY,\n   EXPR_TERNARY,\n-  EXPR_CALL\n+  EXPR_CALL,\n+  EXPR_PHI\n };\n \n struct hashable_expr\n@@ -65,6 +66,7 @@ struct hashable_expr\n     struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n     struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n     struct { gimple fn_from; bool pure; size_t nargs; tree *args; } call;\n+    struct { size_t nargs; tree *args; } phi;\n   } ops;\n };\n \n@@ -265,7 +267,7 @@ initialize_hash_element (gimple stmt, tree lhs,\n         expr->ops.call.pure = false;\n \n       expr->ops.call.nargs = nargs;\n-      expr->ops.call.args = (tree *) xcalloc (nargs, sizeof (tree));\n+      expr->ops.call.args = XCNEWVEC (tree, nargs);\n       for (i = 0; i < nargs; i++)\n         expr->ops.call.args[i] = gimple_call_arg (stmt, i);\n     }\n@@ -281,6 +283,19 @@ initialize_hash_element (gimple stmt, tree lhs,\n       expr->kind = EXPR_SINGLE;\n       expr->ops.single.rhs = gimple_goto_dest (stmt);\n     }\n+  else if (code == GIMPLE_PHI)\n+    {\n+      size_t nargs = gimple_phi_num_args (stmt);\n+      size_t i;\n+\n+      expr->type = TREE_TYPE (gimple_phi_result (stmt));\n+      expr->kind = EXPR_PHI;\n+      expr->ops.phi.nargs = nargs;\n+      expr->ops.phi.args = XCNEWVEC (tree, nargs);\n+\n+      for (i = 0; i < nargs; i++)\n+        expr->ops.phi.args[i] = gimple_phi_arg_def (stmt, i);\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -439,6 +454,21 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n         return true;\n       }\n \n+    case EXPR_PHI:\n+      {\n+        size_t i;\n+\n+        if (expr0->ops.phi.nargs !=  expr1->ops.phi.nargs)\n+          return false;\n+\n+        for (i = 0; i < expr0->ops.phi.nargs; i++)\n+          if (! operand_equal_p (expr0->ops.phi.args[i],\n+                                 expr1->ops.phi.args[i], 0))\n+            return false;\n+\n+        return true;\n+      }\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -516,6 +546,15 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n       }\n       break;\n \n+    case EXPR_PHI:\n+      {\n+        size_t i;\n+\n+        for (i = 0; i < expr->ops.phi.nargs; i++)\n+          val = iterative_hash_expr (expr->ops.phi.args[i], val);\n+      }\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -588,6 +627,22 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n           fprintf (stream, \")\");\n         }\n         break;\n+\n+      case EXPR_PHI:\n+        {\n+          size_t i;\n+          size_t nargs = element->expr.ops.phi.nargs;\n+\n+          fprintf (stream, \"PHI <\");\n+          for (i = 0; i < nargs; i++)\n+            {\n+              print_generic_expr (stream, element->expr.ops.phi.args[i], 0);\n+              if (i + 1 < nargs)\n+                fprintf (stream, \", \");\n+            }\n+          fprintf (stream, \">\");\n+        }\n+        break;\n     }\n   fprintf (stream, \"\\n\");\n \n@@ -608,6 +663,9 @@ free_expr_hash_elt (void *elt)\n   if (element->expr.kind == EXPR_CALL)\n     free (element->expr.ops.call.args);\n \n+  if (element->expr.kind == EXPR_PHI)\n+    free (element->expr.ops.phi.args);\n+\n   free (element);\n }\n \n@@ -1688,6 +1746,14 @@ dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   /* PHI nodes can create equivalences too.  */\n   record_equivalences_from_phis (bb);\n \n+  /* Create equivalences from redundant PHIs.  PHIs are only truly\n+     redundant when they exist in the same block, so push another\n+     marker and unwind right afterwards.  */\n+  VEC_safe_push (expr_hash_elt_t, heap, avail_exprs_stack, NULL);\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    eliminate_redundant_computations (&gsi);\n+  remove_local_expressions_from_table ();\n+\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     optimize_stmt (bb, gsi);\n \n@@ -1818,12 +1884,16 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n {\n   tree expr_type;\n   tree cached_lhs;\n+  tree def;\n   bool insert = true;\n   bool assigns_var_p = false;\n \n   gimple stmt = gsi_stmt (*gsi);\n \n-  tree def = gimple_get_lhs (stmt);\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    def = gimple_phi_result (stmt);\n+  else\n+    def = gimple_get_lhs (stmt);\n \n   /* Certain expressions on the RHS can be optimized away, but can not\n      themselves be entered into the hash tables.  */\n@@ -1857,6 +1927,16 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi)\n     }\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n     expr_type = TREE_TYPE (gimple_switch_index (stmt));\n+  else if (gimple_code (stmt) == GIMPLE_PHI)\n+    /* We can't propagate into a phi, so the logic below doesn't apply.\n+       Instead record an equivalence between the cached LHS and the\n+       PHI result of this statement, provided they are in the same block.\n+       This should be sufficient to kill the redundant phi.  */\n+    {\n+      if (def && cached_lhs)\n+\trecord_const_or_copy (def, cached_lhs);\n+      return;\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -2297,8 +2377,11 @@ lookup_avail_expr (gimple stmt, bool insert)\n   tree temp;\n   struct expr_hash_elt element;\n \n-  /* Get LHS of assignment or call, else NULL_TREE.  */\n-  lhs = gimple_get_lhs (stmt);\n+  /* Get LHS of phi, assignment, or call; else NULL_TREE.  */\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    lhs = gimple_phi_result (stmt);\n+  else\n+    lhs = gimple_get_lhs (stmt);\n \n   initialize_hash_element (stmt, lhs, &element);\n "}]}