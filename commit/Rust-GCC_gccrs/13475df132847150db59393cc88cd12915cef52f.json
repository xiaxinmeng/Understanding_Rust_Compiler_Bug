{"sha": "13475df132847150db59393cc88cd12915cef52f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM0NzVkZjEzMjg0NzE1MGRiNTkzOTNjYzg4Y2QxMjkxNWNlZjUyZg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-12T13:21:41Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-12T13:21:41Z"}, "message": "graph.c: Include sbitmap.h and cfgloop.h.\n\n\t* graph.c: Include sbitmap.h and cfgloop.h.\n\t(draw_cfg_nodes_no_loops): New function to dump basic blocks in\n\ttopological order if the function does not have a loop tree.\n\tHandle unreachable blocks also.\n\t(draw_cfg_nodes_for_loop): New function to dump basic blocks in\n\tone loop tree node as a named cluster of nodes.\n\t(draw_cfg_nodes): New function to draw all CFG nodes.\n\t(draw_cfg_edges): New function to draw all CFG edges.\n\t(print_graph_cfg): Simplify using the new functions.\n\t* Makefile.in (graph.o): Fix dependencies.\n\nFrom-SVN: r194446", "tree": {"sha": "0065c0275ba2790fa72c6483563e1ce5917c5a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0065c0275ba2790fa72c6483563e1ce5917c5a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13475df132847150db59393cc88cd12915cef52f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13475df132847150db59393cc88cd12915cef52f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13475df132847150db59393cc88cd12915cef52f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13475df132847150db59393cc88cd12915cef52f/comments", "author": null, "committer": null, "parents": [{"sha": "af9acf911f1f6e0511414fa4d148a5e13edde08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af9acf911f1f6e0511414fa4d148a5e13edde08a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af9acf911f1f6e0511414fa4d148a5e13edde08a"}], "stats": {"total": 172, "additions": 144, "deletions": 28}, "files": [{"sha": "80e60d5cf959475fdb28235758e9c02fe717d015", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13475df132847150db59393cc88cd12915cef52f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13475df132847150db59393cc88cd12915cef52f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13475df132847150db59393cc88cd12915cef52f", "patch": "@@ -1,3 +1,16 @@\n+2012-12-12  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* graph.c: Include sbitmap.h and cfgloop.h.\n+\t(draw_cfg_nodes_no_loops): New function to dump basic blocks in\n+\ttopological order if the function does not have a loop tree.\n+\tHandle unreachable blocks also.\n+\t(draw_cfg_nodes_for_loop): New function to dump basic blocks in\n+\tone loop tree node as a named cluster of nodes.\n+\t(draw_cfg_nodes): New function to draw all CFG nodes.\n+\t(draw_cfg_edges): New function to draw all CFG edges.\n+\t(print_graph_cfg): Simplify using the new functions.\n+\t* Makefile.in (graph.o): Fix dependencies.\n+\n 2012-12-12  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* dumpfile.h (enum tree_dump_index): Remove TDI_vcg."}, {"sha": "edafeaf9c075c8d4ae8b2b51d58310f7076609a4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13475df132847150db59393cc88cd12915cef52f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13475df132847150db59393cc88cd12915cef52f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=13475df132847150db59393cc88cd12915cef52f", "patch": "@@ -1846,7 +1846,8 @@ gcc.srcextra: gengtype-lex.c\n \t-cp -p $^ $(srcdir)\n \n graph.o: graph.c graph.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-    $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) $(PRETTY_PRINT_H) dumpfile.h\n+    $(DIAGNOSTIC_CORE_H) sbitmap.h $(BASIC_BLOCK_H) $(CFGLOOP_H) \\\n+    $(PRETTY_PRINT_H) dumpfile.h\n \n sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)"}, {"sha": "6ede45642229d1bc49b38433efc5f57514a0e9e6", "filename": "gcc/graph.c", "status": "modified", "additions": 129, "deletions": 27, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13475df132847150db59393cc88cd12915cef52f/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13475df132847150db59393cc88cd12915cef52f/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=13475df132847150db59393cc88cd12915cef52f", "patch": "@@ -24,15 +24,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"diagnostic-core.h\" /* for fatal_error */\n+#include \"sbitmap.h\"\n #include \"basic-block.h\"\n+#include \"cfgloop.h\"\n #include \"graph.h\"\n #include \"dumpfile.h\"\n #include \"pretty-print.h\"\n \n /* DOT files with the .dot extension are recognized as document templates\n    by a well-known piece of word processing software out of Redmond, WA.\n    Therefore some recommend using the .gv extension instead.  Obstinately\n-   ignore that recommendatition...  */\n+   ignore that recommendation...  */\n static const char *const graph_ext = \".dot\";\n \n /* Open a file with MODE for dumping our graph to.\n@@ -163,44 +165,144 @@ draw_cfg_node_succ_edges (pretty_printer *pp, int funcdef_no, basic_block bb)\n   pp_flush (pp);\n }\n \n-/* Print a graphical representation of the CFG of function FUN.  */\n+/* Draw all the basic blocks in the CFG in case loops are not available.\n+   First compute a topological order of the blocks to get a good ranking of\n+   the nodes.  Then, if any nodes are not reachable from ENTRY, add them at\n+   the end.  */\n \n-void\n-print_graph_cfg (const char *base, struct function *fun)\n+static void\n+draw_cfg_nodes_no_loops (pretty_printer *pp, struct function *fun)\n {\n-  const char *funcname = function_name (fun);\n-  int funcdef_no = fun->funcdef_no;\n-  FILE *fp = open_graph_file (base, \"a\");\n-  int *rpo = XNEWVEC (int, n_basic_blocks);\n-  basic_block bb;\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_function (fun));\n   int i, n;\n-  pretty_printer *pp = init_graph_slim_pretty_print (fp);\n+  sbitmap visited;\n \n-  pp_printf (pp, \"subgraph \\\"%s\\\" {\\n\"\n-\t         \"\\tcolor=\\\"black\\\";\\n\"\n-\t\t \"\\tlabel=\\\"%s\\\";\\n\",\n-\t\t funcname, funcname);\n+  visited = sbitmap_alloc (last_basic_block);\n+  bitmap_clear (visited);\n \n-  /* First print all basic blocks.\n-     Visit the blocks in reverse post order to get a good ranking\n-     of the nodes.  */\n+  /* FIXME: pre_and_rev_post_order_compute only works if fun == cfun.  */\n   n = pre_and_rev_post_order_compute (NULL, rpo, true);\n   for (i = 0; i < n; i++)\n-    draw_cfg_node (pp, funcdef_no, BASIC_BLOCK (rpo[i]));\n+    {\n+      basic_block bb = BASIC_BLOCK (rpo[i]);\n+      draw_cfg_node (pp, fun->funcdef_no, bb);\n+      bitmap_set_bit (visited, bb->index);\n+    }\n+  free (rpo);\n \n-  /* Draw all edges at the end to get subgraphs right for GraphViz,\n-     which requires nodes to be defined before edges to cluster\n-     nodes properly.\n+  if (n != n_basic_blocks_for_function (fun))\n+    {\n+      /* Some blocks are unreachable.  We still want to dump them.  */\n+      basic_block bb;\n+      FOR_ALL_BB_FN (bb, fun)\n+\tif (! bitmap_bit_p (visited, bb->index))\n+\t  draw_cfg_node (pp, fun->funcdef_no, bb);\n+    }\n+\n+  sbitmap_free (visited);\n+}\n+\n+/* Draw all the basic blocks in LOOP.  Print the blocks in breath-first\n+   order to get a good ranking of the nodes.  This function is recursive:\n+   It first prints inner loops, then the body of LOOP itself.  */\n \n-     Draw retreating edges as not constraining, this makes the layout\n-     of the graph better.  (??? Calling mark_dfs_back may change the\n-     compiler's behavior when dumping, but computing back edges here\n-     for ourselves is also not desirable.)  */\n+static void\n+draw_cfg_nodes_for_loop (pretty_printer *pp, int funcdef_no,\n+\t\t\t struct loop *loop)\n+{\n+  basic_block *body;\n+  unsigned int i;\n+  const char *fillcolors[3] = { \"grey88\", \"grey77\", \"grey66\" };\n+\n+  if (loop->latch != EXIT_BLOCK_PTR)\n+    pp_printf (pp,\n+\t       \"\\tsubgraph cluster_%d_%d {\\n\"\n+\t       \"\\tstyle=\\\"filled\\\";\\n\"\n+\t       \"\\tcolor=\\\"darkgreen\\\";\\n\"\n+\t       \"\\tfillcolor=\\\"%s\\\";\\n\"\n+\t       \"\\tlabel=\\\"loop %d\\\";\\n\"\n+\t       \"\\tlabeljust=l;\\n\"\n+\t       \"\\tpenwidth=2;\\n\",\n+\t       funcdef_no, loop->num,\n+\t       fillcolors[(loop_depth (loop) - 1) % 3],\n+\t       loop->num);\n+\n+  for (struct loop *inner = loop->inner; inner; inner = inner->next)\n+    draw_cfg_nodes_for_loop (pp, funcdef_no, inner);\n+\n+  if (loop->latch == EXIT_BLOCK_PTR)\n+    body = get_loop_body (loop);\n+  else\n+    body = get_loop_body_in_bfs_order (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = body[i];\n+      if (bb->loop_father == loop)\n+\tdraw_cfg_node (pp, funcdef_no, bb);\n+    }\n+\n+  free (body);\n+\n+  if (loop->latch != EXIT_BLOCK_PTR)\n+    pp_printf (pp, \"\\t}\\n\");\n+}\n+\n+/* Draw all the basic blocks in the CFG in case the loop tree is available.\n+   All loop bodys are printed in clusters.  */\n+\n+static void\n+draw_cfg_nodes (pretty_printer *pp, struct function *fun)\n+{\n+  /* ??? This x_current_loops should be enapsulated.  */\n+  if (fun->x_current_loops)\n+    draw_cfg_nodes_for_loop (pp, fun->funcdef_no,\n+\t\t\t     fun->x_current_loops->tree_root);\n+  else\n+    draw_cfg_nodes_no_loops (pp, fun);\n+}\n+\n+/* Draw all edges in the CFG.  Retreating edges are drawin as not\n+   constraining, this makes the layout of the graph better.\n+   (??? Calling mark_dfs_back may change the compiler's behavior when\n+   dumping, but computing back edges here for ourselves is also not\n+   desirable.)  */\n+\n+static void\n+draw_cfg_edges (pretty_printer *pp, struct function *fun)\n+{\n+  basic_block bb;\n   mark_dfs_back_edges ();\n   FOR_ALL_BB (bb)\n-    draw_cfg_node_succ_edges (pp, funcdef_no, bb);\n+    draw_cfg_node_succ_edges (pp, fun->funcdef_no, bb);\n+\n+  /* Add an invisible edge from ENTRY to EXIT, to improve the graph layout.  */\n+  pp_printf (pp,\n+\t     \"\\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n \"\n+\t     \"[style=\\\"invis\\\",constraint=true];\\n\",\n+\t     fun->funcdef_no, ENTRY_BLOCK,\n+\t     fun->funcdef_no, EXIT_BLOCK);\n+  pp_flush (pp);\n+}\n \n-  pp_printf (pp, \"\\t}\\n\");\n+/* Print a graphical representation of the CFG of function FUN.\n+   First print all basic blocks.  Draw all edges at the end to get\n+   subgraphs right for GraphViz, which requires nodes to be defined\n+   before edges to cluster nodes properly.  */\n+\n+void\n+print_graph_cfg (const char *base, struct function *fun)\n+{\n+  const char *funcname = function_name (fun);\n+  FILE *fp = open_graph_file (base, \"a\");\n+  pretty_printer *pp = init_graph_slim_pretty_print (fp);\n+  pp_printf (pp, \"subgraph \\\"%s\\\" {\\n\"\n+\t         \"\\tcolor=\\\"black\\\";\\n\"\n+\t\t \"\\tlabel=\\\"%s\\\";\\n\",\n+\t\t funcname, funcname);\n+  draw_cfg_nodes (pp, fun);\n+  draw_cfg_edges (pp, fun);\n+  pp_printf (pp, \"}\\n\");\n   pp_flush (pp);\n   fclose (fp);\n }"}]}