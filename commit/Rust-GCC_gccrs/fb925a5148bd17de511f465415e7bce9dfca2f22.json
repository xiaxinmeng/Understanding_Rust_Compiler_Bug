{"sha": "fb925a5148bd17de511f465415e7bce9dfca2f22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI5MjVhNTE0OGJkMTdkZTUxMWY0NjU0MTVlN2JjZTlkZmNhMmYyMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@apple.com", "date": "2005-03-22T02:14:33Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-03-22T02:14:33Z"}, "message": "mf-heuristics.c: Fix whitespace at end of line.\n\n        * mf-heuristics.c: Fix whitespace at end of line.\n        * mf-hooks1.c: Likewise.\n        * mf-hooks2.c: Likewise.\n        * mf-hooks3.c: Likewise.\n        * mf-impl.h: Likewise.\n        * mf-runtime.c: Likewise.\n        * mf-runtime.h: Likewise.\n\nFrom-SVN: r96850", "tree": {"sha": "8df46577f17af9fa0b049896e430ac8dbbf0e148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8df46577f17af9fa0b049896e430ac8dbbf0e148"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb925a5148bd17de511f465415e7bce9dfca2f22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb925a5148bd17de511f465415e7bce9dfca2f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb925a5148bd17de511f465415e7bce9dfca2f22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb925a5148bd17de511f465415e7bce9dfca2f22/comments", "author": null, "committer": null, "parents": [{"sha": "b025006799b4a7db62c13770d14a5211ce2b94e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b025006799b4a7db62c13770d14a5211ce2b94e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b025006799b4a7db62c13770d14a5211ce2b94e8"}], "stats": {"total": 534, "additions": 272, "deletions": 262}, "files": [{"sha": "0fa7c2d7dc74c684f966f5c9cda42265d7f099f3", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -1,3 +1,13 @@\n+2005-03-21  Mike Stump  <mrs@apple.com>\n+\n+\t* mf-heuristics.c: Fix whitespace at end of line.\n+\t* mf-hooks1.c: Likewise.\n+\t* mf-hooks2.c: Likewise.\n+\t* mf-hooks3.c: Likewise.\n+\t* mf-impl.h: Likewise.\n+\t* mf-runtime.c: Likewise.\n+\t* mf-runtime.h: Likewise.\n+\n 2005-03-21  Zack Weinberg  <zack@codesourcery.com>\n \n \t* configure.ac: Do not invoke TL_AC_GCC_VERSION."}, {"sha": "df2a0391eaf0d9ad9cb30a05e64c2c947aada31f", "filename": "libmudflap/mf-heuristics.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-heuristics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-heuristics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-heuristics.c?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -4,7 +4,7 @@\n    and Graydon Hoare <graydon@redhat.com>\n \n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it under\n the terms of the GNU General Public License as published by the Free\n Software Foundation; either version 2, or (at your option) any later\n@@ -46,10 +46,10 @@ extern char _end;\n extern char _start;\n \n \n-/* Run some quick validation of the given region.  \n+/* Run some quick validation of the given region.\n    Return -1 / 0 / 1 if the access known-invalid, possibly-valid, or known-valid.\n */\n-int \n+int\n __mf_heuristic_check (uintptr_t ptr, uintptr_t ptr_high)\n {\n   VERBOSE_TRACE (\"mf: heuristic check\\n\");\n@@ -72,15 +72,15 @@ __mf_heuristic_check (uintptr_t ptr, uintptr_t ptr_high)\n       uintptr_t stack_segment_base = 0;\n #endif\n \n-      VERBOSE_TRACE (\"mf: stack estimated as %p-%p\\n\", \n+      VERBOSE_TRACE (\"mf: stack estimated as %p-%p\\n\",\n \t\t     (void *) stack_top_guess, (void *) stack_segment_base);\n \n       if (ptr_high <= stack_segment_base &&\n \t  ptr >= stack_top_guess &&\n \t  ptr_high >= ptr)\n \t{\n \t  return 1;\n-\t}            \n+\t}\n     }\n #endif\n \n@@ -118,13 +118,13 @@ __mf_heuristic_check (uintptr_t ptr, uintptr_t ptr_high)\n       if (! deja_vu)\n \t{\n \t  /* Time to run the heuristic.  Rescan /proc/self/maps; update the\n-\t     entry[] array; XXX: remove expired entries, add new ones.  \n+\t     entry[] array; XXX: remove expired entries, add new ones.\n \t     XXX: Consider entries that have grown (e.g., stack).  */\n \t  char buf[512];\n \t  char flags[4];\n \t  void *low, *high;\n \t  FILE *fp;\n-\t  \n+\n \t  fp = fopen (\"/proc/self/maps\", \"r\");\n \t  if (fp)\n \t    {\n@@ -145,17 +145,17 @@ __mf_heuristic_check (uintptr_t ptr, uintptr_t ptr_high)\n \t\t\t\t  break;\n \t\t\t\t}\n \t\t\t    }\n-\t\t\t  \n+\n \t\t\t  VERBOSE_TRACE (\"mf: registering region #%d \"\n \t\t\t\t\t \"%p-%p given %s\",\n \t\t\t\t\t i, (void *) low, (void *) high, buf);\n-\t\t\t  \n+\n \t\t\t  __mfu_register ((void *) low, (size_t) (high-low),\n-\t\t\t\t\t  __MF_TYPE_GUESS, \n+\t\t\t\t\t  __MF_TYPE_GUESS,\n \t\t\t\t\t  \"/proc/self/maps segment\");\n-\t\t\t  \n+\n \t\t\t  return 0; /* undecided (tending to cachable) */\n-\t\t\t} \n+\t\t\t}\n \t\t    }\n \t\t}\n \t      fclose (fp);"}, {"sha": "6f9d159e46102b960b7a5844b3aa8c9c13e3d20d", "filename": "libmudflap/mf-hooks1.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks1.c?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -42,7 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if !defined(__FreeBSD__)  && !defined(__APPLE__)\n #define _POSIX_SOURCE\n #endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE \n+#define _GNU_SOURCE\n #define _XOPEN_SOURCE\n #define _BSD_TYPES\n #define __EXTENSIONS__\n@@ -93,11 +93,11 @@ WRAPPER(void *, malloc, size_t c)\n   void *result;\n   BEGIN_PROTECT (malloc, c);\n \n-  size_with_crumple_zones = \n+  size_with_crumple_zones =\n     CLAMPADD(c,CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t__mf_opts.crumple_zone));\n   result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n-  \n+\n   if (LIKELY(result))\n     {\n       result += __mf_opts.crumple_zone;\n@@ -142,23 +142,23 @@ WRAPPER(void *, calloc, size_t c, size_t n)\n   DECLARE(void *, memset, void *, int, size_t);\n   char *result;\n   BEGIN_PROTECT (calloc, c, n);\n-  \n-  size_with_crumple_zones = \n+\n+  size_with_crumple_zones =\n     CLAMPADD((c * n), /* XXX: CLAMPMUL */\n \t     CLAMPADD(__mf_opts.crumple_zone,\n-\t\t      __mf_opts.crumple_zone));  \n+\t\t      __mf_opts.crumple_zone));\n   result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n-  \n+\n   if (LIKELY(result))\n     memset (result, 0, size_with_crumple_zones);\n-  \n+\n   if (LIKELY(result))\n     {\n       result += __mf_opts.crumple_zone;\n       __mf_register (result, c*n /* XXX: clamp */, __MF_TYPE_HEAP_I, \"calloc region\");\n       /* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */\n     }\n-  \n+\n   return result;\n }\n \n@@ -186,7 +186,7 @@ WRAPPER(void *, realloc, void *buf, size_t c)\n   if (LIKELY(buf))\n     base -= __mf_opts.crumple_zone;\n \n-  size_with_crumple_zones = \n+  size_with_crumple_zones =\n     CLAMPADD(c, CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t __mf_opts.crumple_zone));\n   result = (char *) CALL_REAL (realloc, base, size_with_crumple_zones);\n@@ -199,9 +199,9 @@ WRAPPER(void *, realloc, void *buf, size_t c)\n   __mf_opts.wipe_heap = 0;\n \n   if (LIKELY(buf))\n-    __mfu_unregister (buf, 0, __MF_TYPE_HEAP_I); \n+    __mfu_unregister (buf, 0, __MF_TYPE_HEAP_I);\n   /* NB: underlying region may have been __MF_TYPE_HEAP. */\n-  \n+\n   if (LIKELY(result))\n     {\n       result += __mf_opts.crumple_zone;\n@@ -235,8 +235,8 @@ WRAPPER(void, free, void *buf)\n   static void *free_queue [__MF_FREEQ_MAX];\n   static unsigned free_ptr = 0;\n   static int freeq_initialized = 0;\n-  DECLARE(void, free, void *);  \n- \n+  DECLARE(void, free, void *);\n+\n   BEGIN_PROTECT (free, buf);\n \n   if (UNLIKELY(buf == NULL))\n@@ -245,7 +245,7 @@ WRAPPER(void, free, void *buf)\n   LOCKTH ();\n   if (UNLIKELY(!freeq_initialized))\n     {\n-      memset (free_queue, 0, \n+      memset (free_queue, 0,\n \t\t     __MF_FREEQ_MAX * sizeof (void *));\n       freeq_initialized = 1;\n     }\n@@ -270,23 +270,23 @@ WRAPPER(void, free, void *buf)\n \t{\n \t  if (__mf_opts.trace_mf_calls)\n \t    {\n-\t      VERBOSE_TRACE (\"freeing deferred pointer %p (crumple %u)\\n\", \n+\t      VERBOSE_TRACE (\"freeing deferred pointer %p (crumple %u)\\n\",\n \t\t\t     (void *) freeme,\n \t\t\t     __mf_opts.crumple_zone);\n \t    }\n \t  CALL_REAL (free, freeme);\n \t}\n-    } \n-  else \n+    }\n+  else\n     {\n       /* back pointer up a bit to the beginning of crumple zone */\n       char *base = (char *)buf;\n       base -= __mf_opts.crumple_zone;\n       if (__mf_opts.trace_mf_calls)\n \t{\n \t  VERBOSE_TRACE (\"freeing pointer %p = %p - %u\\n\",\n-\t\t\t (void *) base, \n-\t\t\t (void *) buf, \n+\t\t\t (void *) base,\n+\t\t\t (void *) buf,\n \t\t\t __mf_opts.crumple_zone);\n \t}\n       CALL_REAL (free, base);\n@@ -305,20 +305,20 @@ __mf_0fn_mmap (void *start, size_t l, int prot, int f, int fd, off_t off)\n \n \n #undef mmap\n-WRAPPER(void *, mmap, \n-\tvoid  *start,  size_t length, int prot, \n+WRAPPER(void *, mmap,\n+\tvoid  *start,  size_t length, int prot,\n \tint flags, int fd, off_t offset)\n {\n-  DECLARE(void *, mmap, void *, size_t, int, \n+  DECLARE(void *, mmap, void *, size_t, int,\n \t\t\t    int, int, off_t);\n   void *result;\n   BEGIN_PROTECT (mmap, start, length, prot, flags, fd, offset);\n \n-  result = CALL_REAL (mmap, start, length, prot, \n+  result = CALL_REAL (mmap, start, length, prot,\n \t\t\tflags, fd, offset);\n \n   /*\n-  VERBOSE_TRACE (\"mmap (%08lx, %08lx, ...) => %08lx\\n\", \n+  VERBOSE_TRACE (\"mmap (%08lx, %08lx, ...) => %08lx\\n\",\n \t\t (uintptr_t) start, (uintptr_t) length,\n \t\t (uintptr_t) result);\n   */\n@@ -363,11 +363,11 @@ WRAPPER(int , munmap, void *start, size_t length)\n   DECLARE(int, munmap, void *, size_t);\n   int result;\n   BEGIN_PROTECT (munmap, start, length);\n-  \n+\n   result = CALL_REAL (munmap, start, length);\n \n   /*\n-  VERBOSE_TRACE (\"munmap (%08lx, %08lx, ...) => %08lx\\n\", \n+  VERBOSE_TRACE (\"munmap (%08lx, %08lx, ...) => %08lx\\n\",\n \t\t (uintptr_t) start, (uintptr_t) length,\n \t\t (uintptr_t) result);\n   */\n@@ -387,7 +387,7 @@ WRAPPER(int , munmap, void *start, size_t length)\n \n \n /* This wrapper is a little different, as it's called indirectly from\n-   __mf_fini also to clean up pending allocations.  */ \n+   __mf_fini also to clean up pending allocations.  */\n void *\n __mf_wrap_alloca_indirect (size_t c)\n {\n@@ -431,7 +431,7 @@ __mf_wrap_alloca_indirect (size_t c)\n   result = NULL;\n   if (LIKELY (c > 0)) /* alloca(0) causes no allocation.  */\n     {\n-      track = (struct alloca_tracking *) CALL_REAL (malloc, \n+      track = (struct alloca_tracking *) CALL_REAL (malloc,\n \t\t\t\t\t\t    sizeof (struct alloca_tracking));\n       if (LIKELY (track != NULL))\n \t{\n@@ -451,7 +451,7 @@ __mf_wrap_alloca_indirect (size_t c)\n \t    }\n \t}\n     }\n-  \n+\n   return result;\n }\n "}, {"sha": "87cb270b8fd59411ad2c5c6f94f6497a69043630", "filename": "libmudflap/mf-hooks2.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks2.c?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if !defined(__FreeBSD__) && !defined(__APPLE__)\n #define _POSIX_SOURCE\n #endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE \n+#define _GNU_SOURCE\n #define _XOPEN_SOURCE\n #define _BSD_TYPES\n #define __EXTENSIONS__\n@@ -192,7 +192,7 @@ WRAPPER2(char *, strcpy, char *dest, const char *src)\n \n   size_t n = strlen (src);\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, CLAMPADD(n, 1), __MF_CHECK_READ, \"strcpy src\"); \n+  MF_VALIDATE_EXTENT(src, CLAMPADD(n, 1), __MF_CHECK_READ, \"strcpy src\");\n   MF_VALIDATE_EXTENT(dest, CLAMPADD(n, 1), __MF_CHECK_WRITE, \"strcpy dest\");\n   return strcpy (dest, src);\n }\n@@ -216,7 +216,7 @@ WRAPPER2(char *, strcat, char *dest, const char *src)\n   size_t src_sz;\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   dest_sz = strlen (dest);\n-  src_sz = strlen (src);  \n+  src_sz = strlen (src);\n   MF_VALIDATE_EXTENT(src, CLAMPADD(src_sz, 1), __MF_CHECK_READ, \"strcat src\");\n   MF_VALIDATE_EXTENT(dest, CLAMPADD(dest_sz, CLAMPADD(src_sz, 1)),\n \t\t     __MF_CHECK_WRITE, \"strcat dest\");\n@@ -228,15 +228,15 @@ WRAPPER2(char *, strncat, char *dest, const char *src, size_t n)\n {\n \n   /* nb: validating the extents (s,n) might be a mistake for two reasons.\n-     \n-  (1) the string s might be shorter than n chars, and n is just a \n+\n+  (1) the string s might be shorter than n chars, and n is just a\n   poor choice by the programmer. this is not a \"true\" error in the\n   sense that the call to strncat would still be ok.\n-  \n+\n   (2) we could try to compensate for case (1) by calling strlen(s) and\n   using that as a bound for the extent to verify, but strlen might fall off\n   the end of a non-terminated string, leading to a false positive.\n-  \n+\n   so we will call strnlen(s,n) and use that as a bound.\n \n   if strnlen returns a length beyond the end of the registered extent\n@@ -265,7 +265,7 @@ WRAPPER2(int, strcmp, const char *s1, const char *s2)\n   size_t s2_sz;\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   s1_sz = strlen (s1);\n-  s2_sz = strlen (s2);  \n+  s2_sz = strlen (s2);\n   MF_VALIDATE_EXTENT(s1, CLAMPADD(s1_sz, 1), __MF_CHECK_READ, \"strcmp 1st arg\");\n   MF_VALIDATE_EXTENT(s2, CLAMPADD(s2_sz, 1), __MF_CHECK_WRITE, \"strcmp 2nd arg\");\n   return strcmp (s1, s2);\n@@ -278,7 +278,7 @@ WRAPPER2(int, strcasecmp, const char *s1, const char *s2)\n   size_t s2_sz;\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   s1_sz = strlen (s1);\n-  s2_sz = strlen (s2);  \n+  s2_sz = strlen (s2);\n   MF_VALIDATE_EXTENT(s1, CLAMPADD(s1_sz, 1), __MF_CHECK_READ, \"strcasecmp 1st arg\");\n   MF_VALIDATE_EXTENT(s2, CLAMPADD(s2_sz, 1), __MF_CHECK_READ, \"strcasecmp 2nd arg\");\n   return strcasecmp (s1, s2);\n@@ -318,7 +318,7 @@ WRAPPER2(char *, strdup, const char *s)\n   size_t n = strlen (s);\n   TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n   MF_VALIDATE_EXTENT(s, CLAMPADD(n,1), __MF_CHECK_READ, \"strdup region\");\n-  result = (char *)CALL_REAL(malloc, \n+  result = (char *)CALL_REAL(malloc,\n \t\t\t     CLAMPADD(CLAMPADD(n,1),\n \t\t\t\t      CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t\t\t       __mf_opts.crumple_zone)));\n@@ -343,11 +343,11 @@ WRAPPER2(char *, strndup, const char *s, size_t n)\n   MF_VALIDATE_EXTENT(s, sz, __MF_CHECK_READ, \"strndup region\"); /* nb: strNdup */\n \n   /* note: strndup still adds a \\0, even with the N limit! */\n-  result = (char *)CALL_REAL(malloc, \n+  result = (char *)CALL_REAL(malloc,\n \t\t\t     CLAMPADD(CLAMPADD(n,1),\n \t\t\t\t      CLAMPADD(__mf_opts.crumple_zone,\n \t\t\t\t\t       __mf_opts.crumple_zone)));\n-  \n+\n   if (UNLIKELY(! result)) return result;\n \n   result += __mf_opts.crumple_zone;\n@@ -393,7 +393,7 @@ WRAPPER2(char *, strstr, const char *haystack, const char *needle)\n \n \n #ifdef HAVE_MEMMEM\n-WRAPPER2(void *, memmem, \n+WRAPPER2(void *, memmem,\n \tconst void *haystack, size_t haystacklen,\n \tconst void *needle, size_t needlelen)\n {"}, {"sha": "f980c9bc14e77e29efae73e7e73ae5fed2981688", "filename": "libmudflap/mf-hooks3.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-hooks3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks3.c?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if !defined(__FreeBSD__) && !defined(__APPLE__)\n #define _POSIX_SOURCE\n #endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE \n+#define _GNU_SOURCE\n #define _XOPEN_SOURCE\n #define _BSD_TYPES\n #define __EXTENSIONS__\n@@ -125,7 +125,7 @@ static unsigned __mf_pthread_info_idx[LIBMUDFLAPTH_THREADS_MAX];\n \n /* Find any old empty entry in __mf_pthread_info; mark it used and\n    return it.  Return NULL if there are no more available slots.  */\n-struct pthread_info* \n+struct pthread_info*\n __mf_allocate_blank_threadinfo (unsigned* idx)\n {\n   static unsigned probe = LIBMUDFLAPTH_THREADS_MAX-1;\n@@ -158,7 +158,7 @@ __mf_allocate_blank_threadinfo (unsigned* idx)\n \t}\n     }\n   while (probe != probe_at_start);\n-  \n+\n   rc = pthread_mutex_unlock (& mutex);\n   assert (rc == 0);\n   return NULL;\n@@ -177,7 +177,7 @@ __mf_allocate_blank_threadinfo (unsigned* idx)\n    from this context, since a new thread might just be \"booting up\",\n    making printf unsafe to call.\n */\n-static struct pthread_info* \n+static struct pthread_info*\n __mf_find_threadinfo ()\n {\n   pthread_t it = pthread_self ();\n@@ -197,14 +197,14 @@ __mf_find_threadinfo ()\n     else for (i = 0; i < LIBMUDFLAPTH_THREADS_MAX; i++)\n       {\n \tstruct pthread_info* pi2 = & __mf_pthread_info [i];\n-\tif (pi2->used_p && pi2->self == it) \n+\tif (pi2->used_p && pi2->self == it)\n \t  {\n \t    *hash = i;\n \t    result = pi2;\n \t    break;\n \t  }\n       }\n-  }    \n+  }\n \n   if (result == NULL)\n     {\n@@ -247,7 +247,7 @@ __mf_find_threadinfo ()\n   if (last != it)\n     {\n       /*\n-      VERBOSE_TRACE (\"found threadinfo for %u, slot %u\\n\", \n+      VERBOSE_TRACE (\"found threadinfo for %u, slot %u\\n\",\n \t\t     (unsigned) it,\n \t\t     (unsigned) *hash);\n       */\n@@ -271,7 +271,7 @@ __mf_state_perthread ()\n }\n \n \n-static void \n+static void\n __mf_pthread_cleanup (void *arg)\n {\n   struct pthread_info *pi = arg;\n@@ -302,11 +302,11 @@ __mf_pthread_spawner (void *arg)\n   pi->state = active;\n \n   VERBOSE_TRACE (\"new user thread\\n\");\n-  \n+\n   if (__mf_opts.heur_std_data)\n     {\n       pi->thread_errno = & errno;\n-      __mf_register (pi->thread_errno, sizeof (int), \n+      __mf_register (pi->thread_errno, sizeof (int),\n \t\t     __MF_TYPE_GUESS, \"errno area (thread)\");\n       /* NB: we could use __MF_TYPE_STATIC above, but we guess that\n \t the thread errno is coming out of some dynamically allocated\n@@ -327,7 +327,7 @@ __mf_pthread_spawner (void *arg)\n \n     /* Signal the main thread to resume.  */\n     psi->thread_info = pi;\n-      \n+\n     result = (*user_fn)(user_arg);\n   }\n \n@@ -345,7 +345,7 @@ __mf_pthread_spawner (void *arg)\n #if PIC\n /* A special bootstrap variant. */\n int\n-__mf_0fn_pthread_create (pthread_t *thr, const pthread_attr_t *attr, \n+__mf_0fn_pthread_create (pthread_t *thr, const pthread_attr_t *attr,\n \t\t\t void * (*start) (void *), void *arg)\n {\n   return -1;\n@@ -354,12 +354,12 @@ __mf_0fn_pthread_create (pthread_t *thr, const pthread_attr_t *attr,\n \n \n #undef pthread_create\n-WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr, \n+WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n \t void * (*start) (void *), void *arg)\n {\n   DECLARE(int, munmap, void *p, size_t l);\n   DECLARE(void *, mmap, void *p, size_t l, int prot, int flags, int fd, off_t of);\n-  DECLARE(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr, \n+  DECLARE(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n \t  void * (*start) (void *), void *arg);\n   int result;\n   pthread_attr_t override_attr;\n@@ -383,7 +383,7 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n \n       /* VERBOSE_TRACE (\"thread %u pi %p stack cleanup deferred (%u)\\n\",\n \t (unsigned) pi->self, pi, pi->dead_p); */\n-\t      \n+\n       /* Delay actual deallocation by a few cycles, try to discourage the\n \t race mentioned at the end of __mf_pthread_spawner().  */\n       if (pi->dead_p)\n@@ -452,8 +452,8 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n #endif\n \n #ifdef MF_MAP_ANON\n-      override_stack = CALL_REAL (mmap, NULL, override_stacksize, \n-\t\t\t\t  PROT_READ|PROT_WRITE, \n+      override_stack = CALL_REAL (mmap, NULL, override_stacksize,\n+\t\t\t\t  PROT_READ|PROT_WRITE,\n \t\t\t\t  MAP_PRIVATE|MF_MAP_ANON,\n \t\t\t\t  0, 0);\n #else\n@@ -465,8 +465,8 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n         if (zerofd == -1)\n           override_stack = MAP_FAILED;\n         else\n-          override_stack = CALL_REAL (mmap, NULL, override_stacksize, \n-                                      PROT_READ|PROT_WRITE, \n+          override_stack = CALL_REAL (mmap, NULL, override_stacksize,\n+                                      PROT_READ|PROT_WRITE,\n                                       MAP_PRIVATE, zerofd, 0);\n       }\n #endif\n@@ -477,7 +477,7 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n \t  return -1;\n \t}\n \n-      VERBOSE_TRACE (\"thread stack alloc %p size %lu\\n\", \n+      VERBOSE_TRACE (\"thread stack alloc %p size %lu\\n\",\n \t\t     override_stack, (unsigned long) override_stacksize);\n \n       /* Save the original allocated values for later deallocation.  */\n@@ -492,10 +492,10 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n       override_stack = (void *)\n \t(((uintptr_t) override_stack + override_stacksize - alignment - perturb)\n \t & (~(uintptr_t)(alignment-1)));\n-      \n+\n       /* XXX: consider using POSIX2K attr_setstack() */\n       if (pthread_attr_setstackaddr (& override_attr, override_stack) != 0 ||\n-\t  pthread_attr_setstacksize (& override_attr, \n+\t  pthread_attr_setstacksize (& override_attr,\n \t\t\t\t     override_stacksize - alignment - perturb) != 0)\n \t{\n \t  /* This should not happen.  */\n@@ -509,12 +509,12 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n   {\n     struct pthread_start_info psi;\n     struct pthread_info *pi = NULL;\n-    \n+\n     /* Fill in startup-control fields.  */\n     psi.user_fn = start;\n     psi.user_arg = arg;\n     psi.thread_info = NULL;\n-    \n+\n     /* Actually create the thread.  */\n     __mf_state = reentrant;\n     result = CALL_REAL (pthread_create, thr, & override_attr,\n@@ -529,7 +529,7 @@ WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n       {\n \tvolatile struct pthread_start_info *psip = & psi;\n \tpi = psip->thread_info;\n-\tif (pi != NULL) \n+\tif (pi != NULL)\n \t  break;\n \tsched_yield ();\n       }\n@@ -574,7 +574,7 @@ WRAPPER(int, pthread_join, pthread_t thr, void **rc)\n   __mf_state = reentrant;\n   result = CALL_REAL (pthread_join, thr, rc);\n   __mf_state = active;\n-  \n+\n   return result;\n }\n "}, {"sha": "82d7d2aba145f0523550fd8ebd0b6556fb545781", "filename": "libmudflap/mf-impl.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-impl.h?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -1,16 +1,16 @@\n /* Implementation header for mudflap runtime library.\n-   Mudflap: narrow-pointer bounds-checking by tree rewriting.  \n-   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.  \n-   Contributed by Frank Ch. Eigler <fche@redhat.com> \n+   Mudflap: narrow-pointer bounds-checking by tree rewriting.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Frank Ch. Eigler <fche@redhat.com>\n    and Graydon Hoare <graydon@redhat.com>\n-   \n+\n This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify it under\n the terms of the GNU General Public License as published by the Free\n Software Foundation; either version 2, or (at your option) any later\n version.\n- \n+\n In addition to the permissions in the GNU General Public License, the\n Free Software Foundation gives you unlimited permission to link the\n compiled version of this file into combinations with other programs,\n@@ -19,12 +19,12 @@ from the use of this file.  (The General Public License restrictions\n do apply in other respects; for example, they cover modification of\n the file, and distribution when not linked into a combine\n executable.)\n- \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-                                                                                \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n@@ -82,10 +82,10 @@ typedef __mf_uintptr_t uintptr_t;\n \n \n \n-/* Private functions. */ \n+/* Private functions. */\n \n-extern void __mf_violation (void *ptr, size_t sz, \n-\t\t\t    uintptr_t pc, const char *location, \n+extern void __mf_violation (void *ptr, size_t sz,\n+\t\t\t    uintptr_t pc, const char *location,\n \t\t\t    int type);\n extern size_t __mf_backtrace (char ***, void *, unsigned);\n extern int __mf_heuristic_check (uintptr_t, uintptr_t);\n@@ -96,7 +96,7 @@ extern int __mf_heuristic_check (uintptr_t, uintptr_t);\n \n /* The mf_state type codes describe recursion and initialization order. */\n \n-enum __mf_state_enum { active, reentrant }; \n+enum __mf_state_enum { active, reentrant };\n \n /* The __mf_options structure records optional or tunable aspects of the\n  mudflap library's behavior. There is a single global instance of this\n@@ -124,10 +124,10 @@ struct __mf_options\n   unsigned adapt_cache;\n \n   /* Print list of leaked heap objects on shutdown. */\n-  unsigned print_leaks;       \n+  unsigned print_leaks;\n \n   /* Detect reads of uninitialized objects. */\n-  unsigned check_initialization;       \n+  unsigned check_initialization;\n \n   /* Print verbose description of violations. */\n   unsigned verbose_violations;\n@@ -142,7 +142,7 @@ struct __mf_options\n   unsigned wipe_stack;\n   unsigned wipe_heap;\n \n-  /* Maintain a queue of this many deferred free()s, \n+  /* Maintain a queue of this many deferred free()s,\n      to trap use of freed memory. */\n   unsigned free_queue_length;\n \n@@ -179,7 +179,7 @@ struct __mf_options\n   /* How to handle a violation. */\n   enum\n   {\n-    viol_nop,        /* Return control to application. */ \n+    viol_nop,        /* Return control to application. */\n     viol_segv,       /* Signal self with segv. */\n     viol_abort,      /* Call abort (). */\n     viol_gdb         /* Fork a debugger on self */\n@@ -208,11 +208,11 @@ struct __mf_dynamic_entry\n /* The definition of the array (mf-runtime.c) must match the enums!  */\n extern struct __mf_dynamic_entry __mf_dynamic[];\n enum __mf_dynamic_index\n-{ \n+{\n   dyn_calloc, dyn_free, dyn_malloc, dyn_mmap,\n-  dyn_munmap, dyn_realloc, \n+  dyn_munmap, dyn_realloc,\n   dyn_INITRESOLVE,  /* Marker for last init-time resolution. */\n-#ifdef LIBMUDFLAPTH \n+#ifdef LIBMUDFLAPTH\n   dyn_pthread_create,\n   dyn_pthread_join,\n   dyn_pthread_exit\n@@ -242,7 +242,7 @@ extern pthread_mutex_t __mf_biglock;\n #ifdef LIBMUDFLAPTH\n extern enum __mf_state_enum *__mf_state_perthread ();\n #define __mf_state (* __mf_state_perthread ())\n-#else \n+#else\n extern enum __mf_state_enum __mf_state;\n #endif\n extern int __mf_starting_p;\n@@ -285,15 +285,15 @@ extern struct __mf_options __mf_opts;\n #define __MF_PERSIST_MAX 256\n #define __MF_FREEQ_MAX 256\n \n-/* \n+/*\n    Wrapping and redirection:\n \n    Mudflap redirects a number of libc functions into itself, for \"cheap\"\n    verification (eg. strcpy, bzero, memcpy) and also to register /\n    unregister regions of memory as they are manipulated by the program\n    (eg. malloc/free, mmap/munmap).\n \n-   There are two methods of wrapping. \n+   There are two methods of wrapping.\n \n    (1) The static method involves a list of -wrap=foo flags being passed to\n    the linker, which then links references to \"foo\" to the symbol"}, {"sha": "a4adf3eee512d0cf9b9749cc13f138137af07a58", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -38,7 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #if !defined(__FreeBSD__) && !defined(__APPLE__)\n #define _POSIX_SOURCE\n #endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE \n+#define _GNU_SOURCE\n #define _XOPEN_SOURCE\n #define _BSD_TYPES\n #define __EXTENSIONS__\n@@ -263,11 +263,11 @@ static __mf_object_t *__mf_object_cemetary[__MF_TYPE_MAX_CEM+1][__MF_PERSIST_MAX\n \n void __mf_init () CTOR;\n static void __mf_sigusr1_respond ();\n-static unsigned __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high, \n+static unsigned __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n                                    __mf_object_t **objs, unsigned max_objs);\n-static unsigned __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high, \n+static unsigned __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n                                     __mf_object_t **objs, unsigned max_objs, int type);\n-static unsigned __mf_find_dead_objects (uintptr_t ptr_low, uintptr_t ptr_high, \n+static unsigned __mf_find_dead_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n                                         __mf_object_t **objs, unsigned max_objs);\n static void __mf_adapt_cache ();\n static void __mf_describe_object (__mf_object_t *obj);\n@@ -312,67 +312,67 @@ static struct option\n     } type;\n   unsigned value;\n   unsigned *target;\n-} \n+}\n options [] =\n   {\n-    {\"mode-nop\", \n-     \"mudflaps do nothing\", \n-     set_option, (unsigned)mode_nop, (unsigned *)&__mf_opts.mudflap_mode},    \n-    {\"mode-populate\", \n-     \"mudflaps populate object tree\", \n-     set_option, (unsigned)mode_populate, (unsigned *)&__mf_opts.mudflap_mode},    \n-    {\"mode-check\", \n+    {\"mode-nop\",\n+     \"mudflaps do nothing\",\n+     set_option, (unsigned)mode_nop, (unsigned *)&__mf_opts.mudflap_mode},\n+    {\"mode-populate\",\n+     \"mudflaps populate object tree\",\n+     set_option, (unsigned)mode_populate, (unsigned *)&__mf_opts.mudflap_mode},\n+    {\"mode-check\",\n      \"mudflaps check for memory violations\",\n      set_option, (unsigned)mode_check, (unsigned *)&__mf_opts.mudflap_mode},\n-    {\"mode-violate\", \n+    {\"mode-violate\",\n      \"mudflaps always cause violations (diagnostic)\",\n      set_option, (unsigned)mode_violate, (unsigned *)&__mf_opts.mudflap_mode},\n-   \n-    {\"viol-nop\", \n+\n+    {\"viol-nop\",\n      \"violations do not change program execution\",\n      set_option, (unsigned)viol_nop, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-abort\", \n+    {\"viol-abort\",\n      \"violations cause a call to abort()\",\n      set_option, (unsigned)viol_abort, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-segv\", \n+    {\"viol-segv\",\n      \"violations are promoted to SIGSEGV signals\",\n      set_option, (unsigned)viol_segv, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-gdb\", \n+    {\"viol-gdb\",\n      \"violations fork a gdb process attached to current program\",\n      set_option, (unsigned)viol_gdb, (unsigned *)&__mf_opts.violation_mode},\n-    {\"trace-calls\", \n+    {\"trace-calls\",\n      \"trace calls to mudflap runtime library\",\n      set_option, 1, &__mf_opts.trace_mf_calls},\n-    {\"verbose-trace\", \n+    {\"verbose-trace\",\n      \"trace internal events within mudflap runtime library\",\n      set_option, 1, &__mf_opts.verbose_trace},\n-    {\"collect-stats\", \n+    {\"collect-stats\",\n      \"collect statistics on mudflap's operation\",\n      set_option, 1, &__mf_opts.collect_stats},\n #ifdef SIGUSR1\n     {\"sigusr1-report\",\n      \"print report upon SIGUSR1\",\n      set_option, 1, &__mf_opts.sigusr1_report},\n #endif\n-    {\"internal-checking\", \n+    {\"internal-checking\",\n      \"perform more expensive internal checking\",\n      set_option, 1, &__mf_opts.internal_checking},\n-    {\"print-leaks\", \n+    {\"print-leaks\",\n      \"print any memory leaks at program shutdown\",\n      set_option, 1, &__mf_opts.print_leaks},\n-    {\"check-initialization\", \n+    {\"check-initialization\",\n      \"detect uninitialized object reads\",\n      set_option, 1, &__mf_opts.check_initialization},\n-    {\"verbose-violations\", \n+    {\"verbose-violations\",\n      \"print verbose messages when memory violations occur\",\n      set_option, 1, &__mf_opts.verbose_violations},\n-    {\"abbreviate\", \n+    {\"abbreviate\",\n      \"abbreviate repetitive listings\",\n      set_option, 1, &__mf_opts.abbreviate},\n-    {\"timestamps\", \n+    {\"timestamps\",\n      \"track object lifetime timestamps\",\n      set_option, 1, &__mf_opts.timestamps},\n-    {\"ignore-reads\", \n+    {\"ignore-reads\",\n      \"ignore read accesses - assume okay\",\n      set_option, 1, &__mf_opts.ignore_reads},\n     {\"wipe-stack\",\n@@ -381,43 +381,43 @@ options [] =\n     {\"wipe-heap\",\n      \"wipe heap objects at free\",\n      set_option, 1, &__mf_opts.wipe_heap},\n-    {\"heur-proc-map\", \n+    {\"heur-proc-map\",\n      \"support /proc/self/map heuristics\",\n      set_option, 1, &__mf_opts.heur_proc_map},\n     {\"heur-stack-bound\",\n      \"enable a simple upper stack bound heuristic\",\n      set_option, 1, &__mf_opts.heur_stack_bound},\n-    {\"heur-start-end\", \n+    {\"heur-start-end\",\n      \"support _start.._end heuristics\",\n      set_option, 1, &__mf_opts.heur_start_end},\n-    {\"heur-stdlib\", \n+    {\"heur-stdlib\",\n      \"register standard library data (argv, errno, stdin, ...)\",\n      set_option, 1, &__mf_opts.heur_std_data},\n-    {\"free-queue-length\", \n+    {\"free-queue-length\",\n      \"queue N deferred free() calls before performing them\",\n      read_integer_option, 0, &__mf_opts.free_queue_length},\n-    {\"persistent-count\", \n+    {\"persistent-count\",\n      \"keep a history of N unregistered regions\",\n      read_integer_option, 0, &__mf_opts.persistent_count},\n-    {\"crumple-zone\", \n+    {\"crumple-zone\",\n      \"surround allocations with crumple zones of N bytes\",\n      read_integer_option, 0, &__mf_opts.crumple_zone},\n     /* XXX: not type-safe.\n-    {\"lc-mask\", \n+    {\"lc-mask\",\n      \"set lookup cache size mask to N (2**M - 1)\",\n      read_integer_option, 0, (int *)(&__mf_lc_mask)},\n-    {\"lc-shift\", \n+    {\"lc-shift\",\n      \"set lookup cache pointer shift\",\n      read_integer_option, 0, (int *)(&__mf_lc_shift)},\n     */\n-    {\"lc-adapt\", \n+    {\"lc-adapt\",\n      \"adapt mask/shift parameters after N cache misses\",\n      read_integer_option, 1, &__mf_opts.adapt_cache},\n-    {\"backtrace\", \n+    {\"backtrace\",\n      \"keep an N-level stack trace of each call context\",\n      read_integer_option, 0, &__mf_opts.backtrace},\n #ifdef LIBMUDFLAPTH\n-    {\"thread-stack\", \n+    {\"thread-stack\",\n      \"override thread stacks allocation: N kB\",\n      read_integer_option, 0, &__mf_opts.thread_stack},\n #endif\n@@ -429,7 +429,7 @@ __mf_usage ()\n {\n   struct option *opt;\n \n-  fprintf (stderr, \n+  fprintf (stderr,\n            \"This is a %s%sGCC \\\"mudflap\\\" memory-checked binary.\\n\"\n            \"Mudflap is Copyright (C) 2002-2004 Free Software Foundation, Inc.\\n\"\n            \"\\n\"\n@@ -473,7 +473,7 @@ __mf_usage ()\n           strncpy (buf + strlen (opt->name), \"=N\", 2);\n           fprintf (stderr, \"-%-23.23s %s\", buf, opt->description);\n           fprintf (stderr, \" [%d]\\n\", * opt->target);\n-          break;          \n+          break;\n         default: abort();\n         }\n     }\n@@ -482,23 +482,23 @@ __mf_usage ()\n }\n \n \n-int \n+int\n __mf_set_options (const char *optstr)\n {\n   int rc;\n   LOCKTH ();\n   BEGIN_RECURSION_PROTECT ();\n   rc = __mfu_set_options (optstr);\n   /* XXX: It's not really that easy.  A change to a bunch of parameters\n-     can require updating auxiliary state or risk crashing: \n+     can require updating auxiliary state or risk crashing:\n      free_queue_length, crumple_zone ... */\n   END_RECURSION_PROTECT ();\n   UNLOCKTH ();\n   return rc;\n }\n \n \n-int \n+int\n __mfu_set_options (const char *optstr)\n {\n   struct option *opts = 0;\n@@ -520,30 +520,30 @@ __mfu_set_options (const char *optstr)\n \n       case '-':\n         if (*optstr+1)\n-          {         \n+          {\n             int negate = 0;\n             optstr++;\n \n-            if (*optstr == '?' || \n+            if (*optstr == '?' ||\n                 strncmp (optstr, \"help\", 4) == 0)\n               {\n                 /* Caller will print help and exit.  */\n                 return -1;\n               }\n-            \n+\n             if (strncmp (optstr, \"no-\", 3) == 0)\n               {\n                 negate = 1;\n                 optstr = & optstr[3];\n               }\n-            \n+\n             for (opts = options; opts->name; opts++)\n               {\n                 if (strncmp (optstr, opts->name, strlen (opts->name)) == 0)\n                   {\n                     optstr += strlen (opts->name);\n                     assert (opts->target);\n-                    switch (opts->type) \n+                    switch (opts->type)\n                       {\n                       case set_option:\n                         if (negate)\n@@ -558,7 +558,7 @@ __mfu_set_options (const char *optstr)\n                             tmp = strtol (optstr, &nxt, 10);\n                             if ((optstr != nxt) && (tmp != LONG_MAX))\n                               {\n-                                optstr = nxt;                           \n+                                optstr = nxt;\n                                 *(opts->target) = (int)tmp;\n                               }\n                           }\n@@ -570,9 +570,9 @@ __mfu_set_options (const char *optstr)\n               }\n           }\n         break;\n-        \n+\n       default:\n-        fprintf (stderr, \n+        fprintf (stderr,\n                  \"warning: unrecognized string '%s' in mudflap options\\n\",\n                  optstr);\n         optstr += strlen (optstr);\n@@ -602,7 +602,7 @@ __mfu_set_options (const char *optstr)\n \n #ifdef PIC\n \n-void \n+void\n __mf_resolve_single_dynamic (struct __mf_dynamic_entry *e)\n {\n   char *err;\n@@ -616,15 +616,15 @@ __mf_resolve_single_dynamic (struct __mf_dynamic_entry *e)\n   else\n #endif\n     e->pointer = dlsym (RTLD_NEXT, e->name);\n-  \n+\n   err = dlerror ();\n \n   if (err)\n     {\n       fprintf (stderr, \"mf: error in dlsym(\\\"%s\\\"): %s\\n\",\n                e->name, err);\n       abort ();\n-    }  \n+    }\n   if (! e->pointer)\n     {\n       fprintf (stderr, \"mf: dlsym(\\\"%s\\\") = NULL\\n\", e->name);\n@@ -633,8 +633,8 @@ __mf_resolve_single_dynamic (struct __mf_dynamic_entry *e)\n }\n \n \n-static void \n-__mf_resolve_dynamics () \n+static void\n+__mf_resolve_dynamics ()\n {\n   int i;\n   for (i = 0; i < dyn_INITRESOLVE; i++)\n@@ -819,7 +819,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n   TRACE (\"check ptr=%p b=%u size=%lu %s location=`%s'\\n\",\n          ptr, entry_idx, (unsigned long)sz,\n          (type == 0 ? \"read\" : \"write\"), location);\n-  \n+\n   switch (__mf_opts.mudflap_mode)\n     {\n     case mode_nop:\n@@ -842,7 +842,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n     case mode_check:\n       {\n         unsigned heuristics = 0;\n-        \n+\n         /* Advance aging/adaptation counters.  */\n         static unsigned adapt_count;\n         adapt_count ++;\n@@ -852,7 +852,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n             adapt_count = 0;\n             __mf_adapt_cache ();\n           }\n-        \n+\n         /* Looping only occurs if heuristics were triggered.  */\n         while (judgement == 0)\n           {\n@@ -877,7 +877,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                 assert (n == obj_count);\n                 dealloc_me = all_ovr_obj;\n               }\n-            else \n+            else\n               {\n                 all_ovr_obj = ovr_obj;\n                 dealloc_me = NULL;\n@@ -894,7 +894,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                   obj->write_count ++;\n                 obj->liveness ++;\n               }\n-            \n+\n             /* Iterate over the various objects.  There are a number of special cases.  */\n             for (i = 0; i < obj_count; i++)\n               {\n@@ -907,7 +907,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                 /* Any object with a watch flag is bad.  */\n                 if (UNLIKELY (obj->watching_p))\n                   judgement = -2; /* trigger VIOL_WATCH */\n-            \n+\n                 /* A read from an uninitialized object is bad. */\n                 if (UNLIKELY (__mf_opts.check_initialization\n                               /* reading */\n@@ -924,7 +924,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n               for (i = 0; i < obj_count; i++)\n                 {\n                   __mf_object_t *obj = all_ovr_obj[i];\n-                  \n+\n                   /* Is this access entirely contained within this object?  */\n                   if (LIKELY (ptr_low >= obj->low && ptr_high <= obj->high))\n                     {\n@@ -961,7 +961,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                         if (i == j) continue;\n \n                         /* Filter out objects that cannot be spanned across.  */\n-                        if (obj2->type == __MF_TYPE_STACK \n+                        if (obj2->type == __MF_TYPE_STACK\n                             || obj2->type == __MF_TYPE_STATIC)\n                           continue;\n \n@@ -974,7 +974,7 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n                               && (ptr_high >= obj2->low && ptr_higher <= obj2->high))\n                             uncovered_high_p = 0;\n                       }\n-                    \n+\n                     if (uncovered_low_p || uncovered_high_p)\n                       uncovered ++;\n                   }\n@@ -1010,23 +1010,23 @@ void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n   if (__mf_opts.collect_stats)\n     {\n       __mf_count_check ++;\n-      \n+\n       if (LIKELY (old_entry.low != entry->low || old_entry.high != entry->high))\n         /* && (old_entry.low != 0) && (old_entry.high != 0)) */\n-        __mf_lookup_cache_reusecount [entry_idx] ++;    \n+        __mf_lookup_cache_reusecount [entry_idx] ++;\n     }\n-  \n+\n   if (UNLIKELY (judgement < 0))\n     __mf_violation (ptr, sz,\n                     (uintptr_t) __builtin_return_address (0), location,\n-                    ((judgement == -1) ? \n+                    ((judgement == -1) ?\n                      (type == __MF_CHECK_READ ? __MF_VIOL_READ : __MF_VIOL_WRITE) :\n                      __MF_VIOL_WATCH));\n }\n \n \n static __mf_object_t *\n-__mf_insert_new_object (uintptr_t low, uintptr_t high, int type, \n+__mf_insert_new_object (uintptr_t low, uintptr_t high, int type,\n                         const char *name, uintptr_t pc)\n {\n   DECLARE (void *, calloc, size_t c, size_t n);\n@@ -1047,20 +1047,20 @@ __mf_insert_new_object (uintptr_t low, uintptr_t high, int type,\n #endif\n \n   if (__mf_opts.backtrace > 0 && (type == __MF_TYPE_HEAP || type == __MF_TYPE_HEAP_I))\n-    new_obj->alloc_backtrace_size = \n+    new_obj->alloc_backtrace_size =\n       __mf_backtrace (& new_obj->alloc_backtrace,\n                       (void *) pc, 2);\n-  \n+\n   __mf_link_object (new_obj);\n   return new_obj;\n }\n \n \n-static void \n+static void\n __mf_uncache_object (__mf_object_t *old_obj)\n {\n   /* Remove any low/high pointers for this object from the lookup cache.  */\n-  \n+\n   /* Can it possibly exist in the cache?  */\n   if (LIKELY (old_obj->read_count + old_obj->write_count))\n     {\n@@ -1074,7 +1074,7 @@ __mf_uncache_object (__mf_object_t *old_obj)\n           struct __mf_cache *entry = & __mf_lookup_cache [i];\n           /* NB: the \"||\" in the following test permits this code to\n              tolerate the situation introduced by __mf_check over\n-             contiguous objects, where a cache entry spans several \n+             contiguous objects, where a cache entry spans several\n              objects.  */\n           if (entry->low == low || entry->high == high)\n             {\n@@ -1100,14 +1100,14 @@ __mf_register (void *ptr, size_t sz, int type, const char *name)\n void\n __mfu_register (void *ptr, size_t sz, int type, const char *name)\n {\n-  TRACE (\"register ptr=%p size=%lu type=%x name='%s'\\n\", \n+  TRACE (\"register ptr=%p size=%lu type=%x name='%s'\\n\",\n          ptr, (unsigned long) sz, type, name ? name : \"\");\n \n   if (__mf_opts.collect_stats)\n     {\n       __mf_count_register ++;\n       __mf_total_register_size [(type < 0) ? 0 :\n-                                (type > __MF_TYPE_MAX) ? 0 : \n+                                (type > __MF_TYPE_MAX) ? 0 :\n                                 type] += sz;\n     }\n \n@@ -1118,7 +1118,7 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n     {\n     case mode_nop:\n       break;\n-      \n+\n     case mode_violate:\n       __mf_violation (ptr, sz, (uintptr_t) __builtin_return_address (0), NULL,\n                       __MF_VIOL_REGISTER);\n@@ -1140,7 +1140,7 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n         uintptr_t low = (uintptr_t) ptr;\n         uintptr_t high = CLAMPSZ (ptr, sz);\n         uintptr_t pc = (uintptr_t) __builtin_return_address (0);\n-        \n+\n         /* Treat unknown size indication as 1.  */\n         if (UNLIKELY (sz == 0)) sz = 1;\n \n@@ -1153,7 +1153,7 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n         if (UNLIKELY (num_overlapping_objs > 0))\n           {\n             __mf_object_t *ovr_obj = ovr_objs[0];\n-            \n+\n             /* Accept certain specific duplication pairs.  */\n             if (((type == __MF_TYPE_STATIC) || (type == __MF_TYPE_GUESS))\n                 && ovr_obj->low == low\n@@ -1162,8 +1162,8 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n               {\n                 /* Duplicate registration for static objects may come\n                    from distinct compilation units.  */\n-                VERBOSE_TRACE (\"harmless duplicate reg %p-%p `%s'\\n\", \n-                               (void *) low, (void *) high, \n+                VERBOSE_TRACE (\"harmless duplicate reg %p-%p `%s'\\n\",\n+                               (void *) low, (void *) high,\n                                (ovr_obj->name ? ovr_obj->name : \"\"));\n                 break;\n               }\n@@ -1179,7 +1179,7 @@ __mfu_register (void *ptr, size_t sz, int type, const char *name)\n           }\n         else /* No overlapping objects: AOK.  */\n           __mf_insert_new_object (low, high, type, name, pc);\n-        \n+\n         /* We could conceivably call __mf_check() here to prime the cache,\n            but then the read_count/write_count field is not reliable.  */\n         break;\n@@ -1210,7 +1210,7 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n   TRACE (\"unregister ptr=%p size=%lu type=%x\\n\", ptr, (unsigned long) sz, type);\n \n   switch (__mf_opts.mudflap_mode)\n-    { \n+    {\n     case mode_nop:\n       break;\n \n@@ -1264,17 +1264,17 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n \n         /* Wipe buffer contents if desired.  */\n         if ((__mf_opts.wipe_stack && old_obj->type == __MF_TYPE_STACK)\n-            || (__mf_opts.wipe_heap && (old_obj->type == __MF_TYPE_HEAP \n+            || (__mf_opts.wipe_heap && (old_obj->type == __MF_TYPE_HEAP\n                                         || old_obj->type == __MF_TYPE_HEAP_I)))\n           {\n             memset ((void *) old_obj->low,\n                     0,\n                     (size_t) (old_obj->high - old_obj->low + 1));\n           }\n-        \n+\n         /* Manage the object cemetary.  */\n-        if (__mf_opts.persistent_count > 0 && \n-            old_obj->type >= 0 && \n+        if (__mf_opts.persistent_count > 0 &&\n+            old_obj->type >= 0 &&\n             old_obj->type <= __MF_TYPE_MAX_CEM)\n           {\n             old_obj->deallocated_p = 1;\n@@ -1288,7 +1288,7 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n #endif\n \n             if (__mf_opts.backtrace > 0 && old_obj->type == __MF_TYPE_HEAP)\n-              old_obj->dealloc_backtrace_size = \n+              old_obj->dealloc_backtrace_size =\n                 __mf_backtrace (& old_obj->dealloc_backtrace,\n                                 NULL, 2);\n \n@@ -1300,7 +1300,7 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n             {\n               unsigned row = old_obj->type;\n               unsigned plot = __mf_object_dead_head [row];\n-              \n+\n               del_obj = __mf_object_cemetary [row][plot];\n               __mf_object_cemetary [row][plot] = old_obj;\n               plot ++;\n@@ -1310,20 +1310,20 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n           }\n         else\n           del_obj = old_obj;\n-        \n+\n         if (__mf_opts.print_leaks)\n           {\n             if ((old_obj->read_count + old_obj->write_count) == 0 &&\n-                (old_obj->type == __MF_TYPE_HEAP \n+                (old_obj->type == __MF_TYPE_HEAP\n                  || old_obj->type == __MF_TYPE_HEAP_I))\n               {\n-                fprintf (stderr, \n+                fprintf (stderr,\n                          \"*******\\n\"\n                          \"mudflap warning: unaccessed registered object:\\n\");\n                 __mf_describe_object (old_obj);\n               }\n           }\n-        \n+\n         if (del_obj != NULL) /* May or may not equal old_obj.  */\n           {\n             if (__mf_opts.backtrace > 0)\n@@ -1336,7 +1336,7 @@ __mfu_unregister (void *ptr, size_t sz, int type)\n               }\n             CALL_REAL(free, del_obj);\n           }\n-        \n+\n         break;\n       }\n     } /* end switch (__mf_opts.mudflap_mode) */\n@@ -1370,7 +1370,7 @@ __mf_adapt_cache_fn (mfsplay_tree_node n, void *param)\n   struct tree_stats *s = (struct tree_stats *) param;\n \n   assert (obj != NULL && s != NULL);\n-  \n+\n   /* Exclude never-accessed objects.  */\n   if (obj->read_count + obj->write_count)\n     {\n@@ -1449,7 +1449,7 @@ __mf_adapt_cache ()\n         break;\n     }\n   if (smoothed_new_shift < 0) smoothed_new_shift = __mf_lc_shift;\n-  /* Converge toward this slowly to reduce flapping. */  \n+  /* Converge toward this slowly to reduce flapping. */\n   smoothed_new_shift = 0.9*smoothed_new_shift + 0.1*i;\n   new_shift = (unsigned) (smoothed_new_shift + 0.5);\n   assert (new_shift < sizeof (uintptr_t)*8);\n@@ -1490,8 +1490,8 @@ __mf_adapt_cache ()\n    max_objs of their pointers in objs[].  Return total count of\n    overlaps (may exceed max_objs). */\n \n-unsigned \n-__mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high, \n+unsigned\n+__mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n                     __mf_object_t **objs, unsigned max_objs, int type)\n {\n   unsigned count = 0;\n@@ -1517,14 +1517,14 @@ __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n       while (1)\n         {\n           __mf_object_t *obj;\n-              \n+\n           n = (direction == 0 ? mfsplay_tree_successor (t, k) : mfsplay_tree_predecessor (t, k));\n           if (n == NULL) break;\n           obj = (__mf_object_t *) n->value;\n-              \n+\n           if (! (obj->low <= ptr_high && obj->high >= ptr_low)) /* No overlap? */\n             break;\n-              \n+\n           if (count < max_objs)\n             objs[count] = (__mf_object_t *) n->value;\n           count ++;\n@@ -1599,31 +1599,31 @@ __mf_find_dead_objects (uintptr_t low, uintptr_t high,\n       unsigned count = 0;\n       unsigned recollection = 0;\n       unsigned row = 0;\n-      \n+\n       assert (low <= high);\n       assert (max_objs == 0 || objs != NULL);\n-      \n+\n       /* Widen the search from the most recent plots in each row, looking\n          backward in time.  */\n       recollection = 0;\n       while (recollection < __mf_opts.persistent_count)\n         {\n           count = 0;\n-          \n+\n           for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n             {\n               unsigned plot;\n               unsigned i;\n-              \n+\n               plot = __mf_object_dead_head [row];\n               for (i = 0; i <= recollection; i ++)\n                 {\n                   __mf_object_t *obj;\n-                  \n+\n                   /* Look backward through row: it's a circular buffer.  */\n                   if (plot > 0) plot --;\n                   else plot = __mf_opts.persistent_count - 1;\n-                  \n+\n                   obj = __mf_object_cemetary [row][plot];\n                   if (obj && obj->low <= high && obj->high >= low)\n                     {\n@@ -1634,14 +1634,14 @@ __mf_find_dead_objects (uintptr_t low, uintptr_t high,\n                     }\n                 }\n             }\n-          \n+\n           if (count)\n             break;\n-          \n+\n           /* Look farther back in time.  */\n           recollection = (recollection * 2) + 1;\n         }\n-      \n+\n       return count;\n     } else {\n       return 0;\n@@ -1680,7 +1680,7 @@ __mf_describe_object (__mf_object_t *obj)\n #endif\n            \"\\n\",\n            (obj->deallocated_p ? \"dead \" : \"\"),\n-           (void *) obj, (obj->name ? obj->name : \"\"), \n+           (void *) obj, (obj->name ? obj->name : \"\"),\n            (void *) obj->low, (void *) obj->high,\n            (unsigned long) (obj->high - obj->low + 1),\n            (obj->type == __MF_TYPE_NOACCESS ? \"no-access\" :\n@@ -1690,9 +1690,9 @@ __mf_describe_object (__mf_object_t *obj)\n             obj->type == __MF_TYPE_STATIC ? \"static\" :\n             obj->type == __MF_TYPE_GUESS ? \"guess\" :\n             \"unknown\"),\n-           obj->read_count, obj->write_count, obj->liveness, \n+           obj->read_count, obj->write_count, obj->liveness,\n            obj->watching_p ? \" watching\" : \"\",\n-           obj->alloc_time.tv_sec, obj->alloc_time.tv_usec, \n+           obj->alloc_time.tv_sec, obj->alloc_time.tv_usec,\n            (void *) obj->alloc_pc\n #ifdef LIBMUDFLAPTH\n            , (unsigned) obj->alloc_thread\n@@ -1715,7 +1715,7 @@ __mf_describe_object (__mf_object_t *obj)\n                    \" thread=%u\"\n #endif\n                    \"\\n\",\n-                   obj->dealloc_time.tv_sec, obj->dealloc_time.tv_usec, \n+                   obj->dealloc_time.tv_sec, obj->dealloc_time.tv_usec,\n                    (void *) obj->dealloc_pc\n #ifdef LIBMUDFLAPTH\n                    , (unsigned) obj->dealloc_thread\n@@ -1904,7 +1904,7 @@ __mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n      ends up containing a non-NULL guess_pc, then trim everything\n      before that.  Otherwise, omit the first guess_omit_levels\n      entries. */\n-  \n+\n   if (guess_pc != NULL)\n     for (i=0; i<pc_array_size; i++)\n       if (pc_array [i] == guess_pc)\n@@ -1948,15 +1948,15 @@ __mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n /* __mf_violation */\n \n void\n-__mf_violation (void *ptr, size_t sz, uintptr_t pc, \n+__mf_violation (void *ptr, size_t sz, uintptr_t pc,\n                 const char *location, int type)\n {\n   char buf [128];\n   static unsigned violation_number;\n   DECLARE(void, free, void *ptr);\n \n-  TRACE (\"violation pc=%p location=%s type=%d ptr=%p size=%lu\\n\", \n-         (void *) pc, \n+  TRACE (\"violation pc=%p location=%s type=%d ptr=%p size=%lu\\n\",\n+         (void *) pc,\n          (location != NULL ? location : \"\"), type, ptr, (unsigned long) sz);\n \n   if (__mf_opts.collect_stats)\n@@ -1978,14 +1978,14 @@ __mf_violation (void *ptr, size_t sz, uintptr_t pc,\n     fprintf (stderr,\n              \"*******\\n\"\n              \"mudflap violation %u (%s): time=%lu.%06lu \"\n-             \"ptr=%p size=%lu\\npc=%p%s%s%s\\n\", \n+             \"ptr=%p size=%lu\\npc=%p%s%s%s\\n\",\n              violation_number,\n              ((type == __MF_VIOL_READ) ? \"check/read\" :\n               (type == __MF_VIOL_WRITE) ? \"check/write\" :\n               (type == __MF_VIOL_REGISTER) ? \"register\" :\n               (type == __MF_VIOL_UNREGISTER) ? \"unregister\" :\n               (type == __MF_VIOL_WATCH) ? \"watch\" : \"unknown\"),\n-             now.tv_sec, now.tv_usec, \n+             now.tv_sec, now.tv_usec,\n              (void *) ptr, (unsigned long)sz, (void *) pc,\n              (location != NULL ? \" location=`\" : \"\"),\n              (location != NULL ? location : \"\"),\n@@ -1995,26 +1995,26 @@ __mf_violation (void *ptr, size_t sz, uintptr_t pc,\n       {\n         char ** symbols;\n         unsigned i, num;\n-        \n+\n         num = __mf_backtrace (& symbols, (void *) pc, 2);\n         /* Note: backtrace_symbols calls malloc().  But since we're in\n            __mf_violation and presumably __mf_check, it'll detect\n            recursion, and not put the new string into the database.  */\n-        \n+\n         for (i=0; i<num; i++)\n           fprintf (stderr, \"      %s\\n\", symbols[i]);\n-        \n+\n         /* Calling free() here would trigger a violation.  */\n         CALL_REAL(free, symbols);\n       }\n-    \n-    \n+\n+\n     /* Look for nearby objects.  For this, we start with s_low/s_high\n        pointing to the given area, looking for overlapping objects.\n        If none show up, widen the search area and keep looking. */\n-    \n+\n     if (sz == 0) sz = 1;\n-    \n+\n     for (dead_p = 0; dead_p <= 1; dead_p ++) /* for dead_p in 0 1 */\n       {\n         enum {max_objs = 3}; /* magic */\n@@ -2023,7 +2023,7 @@ __mf_violation (void *ptr, size_t sz, uintptr_t pc,\n         uintptr_t s_low, s_high;\n         unsigned tries = 0;\n         unsigned i;\n-        \n+\n         s_low = (uintptr_t) ptr;\n         s_high = CLAMPSZ (ptr, sz);\n \n@@ -2131,7 +2131,7 @@ __mf_watch_or_not (void *ptr, size_t sz, char flag)\n \n   TRACE (\"%s ptr=%p size=%lu\\n\",\n          (flag ? \"watch\" : \"unwatch\"), ptr, (unsigned long) sz);\n-  \n+\n   switch (__mf_opts.mudflap_mode)\n     {\n     case mode_nop:\n@@ -2235,7 +2235,7 @@ write_itoa (int fd, unsigned n)\n       unsigned digit = n % 10;\n       buf[bufsize-2-i] = digit + '0';\n       n /= 10;\n-      if (n == 0) \n+      if (n == 0)\n         {\n           char *m = & buf [bufsize-2-i];\n           buf[bufsize-1] = '\\0';\n@@ -2253,7 +2253,7 @@ __assert_fail (const char *msg, const char *file, unsigned line, const char *fun\n   write2(\"mf\");\n #ifdef LIBMUDFLAPTH\n   write2(\"(\");\n-  write_itoa (2, (unsigned) pthread_self ());  \n+  write_itoa (2, (unsigned) pthread_self ());\n   write2(\")\");\n #endif\n   write2(\": assertion failure: `\");\n@@ -2497,9 +2497,9 @@ mfsplay_tree_splay (mfsplay_tree sp, mfsplay_tree_key key)\n      degenerate access patterns.  Unfortunately such patterns can occur\n      e.g. during static initialization, where many static objects might\n      be registered in increasing address sequence, or during a case where\n-     large tree-like heap data structures are allocated quickly. \n+     large tree-like heap data structures are allocated quickly.\n \n-     On x86, this corresponds to roughly 200K of stack usage. \n+     On x86, this corresponds to roughly 200K of stack usage.\n      XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */\n   sp->max_depth = 2500;\n   sp->rebalance_p = sp->depth = 0;\n@@ -2609,7 +2609,7 @@ mfsplay_tree_remove (mfsplay_tree sp, mfsplay_tree_key key)\n       if (left)\n         {\n           sp->root = left;\n-          /* If there was a right child as well, hang it off the \n+          /* If there was a right child as well, hang it off the\n              right-most leaf of the left child.  */\n           if (right)\n             {\n@@ -2623,7 +2623,7 @@ mfsplay_tree_remove (mfsplay_tree sp, mfsplay_tree_key key)\n     }\n }\n \n-/* Lookup KEY in SP, returning VALUE if present, and NULL \n+/* Lookup KEY in SP, returning VALUE if present, and NULL\n    otherwise.  */\n \n static mfsplay_tree_node\n@@ -2696,7 +2696,7 @@ mfsplay_tree_successor (mfsplay_tree sp, mfsplay_tree_key key)\n    in-order traversal.  If FN every returns a non-zero value, the\n    iteration ceases immediately, and the value is returned.\n    Otherwise, this function returns 0.\n-   \n+\n    This function simulates recursion using dynamically allocated\n    arrays, since it may be called from mfsplay_tree_rebalance(), which\n    in turn means that the tree is already uncomfortably deep for stack"}, {"sha": "dd66e217d7b97223e17cc66828cedf01621edf63", "filename": "libmudflap/mf-runtime.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-runtime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb925a5148bd17de511f465415e7bce9dfca2f22/libmudflap%2Fmf-runtime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.h?ref=fb925a5148bd17de511f465415e7bce9dfca2f22", "patch": "@@ -51,7 +51,7 @@ extern \"C\" {\n \n extern void __mf_check (void *ptr, __mf_size_t sz, int type, const char *location)\n        __attribute((nothrow));\n-extern void __mf_register (void *ptr, __mf_size_t sz, int type, const char *name) \n+extern void __mf_register (void *ptr, __mf_size_t sz, int type, const char *name)\n        __attribute((nothrow));\n extern void __mf_unregister (void *ptr, __mf_size_t sz, int type)\n        __attribute((nothrow));\n@@ -65,33 +65,33 @@ extern int __mf_set_options (const char *opts);\n    done by simple #define rather than linker wrapping, since only\n    instrumented modules are meant to be affected.  */\n \n-#ifdef _MUDFLAP  \n-#pragma redefine_extname memcpy __mfwrap_memcpy \n+#ifdef _MUDFLAP\n+#pragma redefine_extname memcpy __mfwrap_memcpy\n #pragma redefine_extname memmove __mfwrap_memmove\n-#pragma redefine_extname memset __mfwrap_memset \n-#pragma redefine_extname memcmp __mfwrap_memcmp \n-#pragma redefine_extname memchr __mfwrap_memchr \n+#pragma redefine_extname memset __mfwrap_memset\n+#pragma redefine_extname memcmp __mfwrap_memcmp\n+#pragma redefine_extname memchr __mfwrap_memchr\n #pragma redefine_extname memrchr __mfwrap_memrchr\n-#pragma redefine_extname strcpy __mfwrap_strcpy \n-#pragma redefine_extname strncpy __mfwrap_strncpy \n-#pragma redefine_extname strcat __mfwrap_strcat \n+#pragma redefine_extname strcpy __mfwrap_strcpy\n+#pragma redefine_extname strncpy __mfwrap_strncpy\n+#pragma redefine_extname strcat __mfwrap_strcat\n #pragma redefine_extname strncat __mfwrap_strncat\n-#pragma redefine_extname strcmp __mfwrap_strcmp \n-#pragma redefine_extname strcasecmp __mfwrap_strcasecmp \n-#pragma redefine_extname strncmp __mfwrap_strncmp \n+#pragma redefine_extname strcmp __mfwrap_strcmp\n+#pragma redefine_extname strcasecmp __mfwrap_strcasecmp\n+#pragma redefine_extname strncmp __mfwrap_strncmp\n #pragma redefine_extname strncasecmp __mfwrap_strncasecmp\n-#pragma redefine_extname strdup __mfwrap_strdup \n-#pragma redefine_extname strndup __mfwrap_strndup \n-#pragma redefine_extname strchr __mfwrap_strchr \n+#pragma redefine_extname strdup __mfwrap_strdup\n+#pragma redefine_extname strndup __mfwrap_strndup\n+#pragma redefine_extname strchr __mfwrap_strchr\n #pragma redefine_extname strrchr __mfwrap_strrchr\n-#pragma redefine_extname strstr __mfwrap_strstr \n-#pragma redefine_extname memmem __mfwrap_memmem \n-#pragma redefine_extname strlen __mfwrap_strlen \n+#pragma redefine_extname strstr __mfwrap_strstr\n+#pragma redefine_extname memmem __mfwrap_memmem\n+#pragma redefine_extname strlen __mfwrap_strlen\n #pragma redefine_extname strnlen __mfwrap_strnlen\n-#pragma redefine_extname bzero __mfwrap_bzero \n-#pragma redefine_extname bcopy __mfwrap_bcopy \n-#pragma redefine_extname bcmp __mfwrap_bcmp \n-#pragma redefine_extname index __mfwrap_index \n+#pragma redefine_extname bzero __mfwrap_bzero\n+#pragma redefine_extname bcopy __mfwrap_bcopy\n+#pragma redefine_extname bcmp __mfwrap_bcmp\n+#pragma redefine_extname index __mfwrap_index\n #pragma redefine_extname rindex __mfwrap_rindex\n #pragma redefine_extname asctime __mfwrap_asctime\n #pragma redefine_extname ctime __mfwrap_ctime"}]}