{"sha": "cee99fa01b0e014c24b91c6291ca0f0b51080be9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlOTlmYTAxYjBlMDE0YzI0YjkxYzYyOTFjYTBmMGI1MTA4MGJlOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-08T10:14:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-08T10:14:17Z"}, "message": "[AArch64] Predicated SVE comparison folds\n\nThis patch adds SVE patterns that combine a PTRUE-predicated\ncomparison with a separate AND.  The main benefit is for\noptimising ANDs with the loop predicate, as in the testcase.\nHowever, one of the potential drawbacks is that it triggers\neven for cases in which two naturally-parallel comparisons\nare ANDed together.  Whether that's a win or a less will\ndepend on the schedule, but it has the potential to be a win\nmore often than a loss.\n\nThe combine patterns are undeniably ugly.  One way of getting\naround them would be to allow 1->1 \"splits\" when combining\n2 instructions, as well as 1->2 splits when combining more\nthan 2 instructions (although that wouldn't really be a split).\nAnother would be to have a way of defining target-specific\nrtx simplifications.  branches/ARM/sve-branch has a prototype\nimplementation of that, but it would need some clean-up before being\nready to submit.  It would also be good to make it closer to the\nmatch.pd style.\n\nUntil then, I think what the combine patterns are doing is the\n\"correct\" implementation given the current infrastructure.\n\n2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-sve.md (*pred_cmp<cmp_op><mode>_combine)\n\t(*pred_cmp<cmp_op><mode>, *fcm<cmp_op><mode>_and_combine)\n\t(*fcmuo<mode>_and_combine, *fcm<cmp_op><mode>_and)\n\t(*fcmuo<mode>_and): New patterns.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/vcond_6.c: Do not expect any ANDs.\n\tXFAIL the BIC test.\n\t* gcc.target/aarch64/sve/vcond_7.c: New test.\n\t* gcc.target/aarch64/sve/vcond_7_run.c: Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r260031", "tree": {"sha": "b3c0ff532254546cee24c446329970937ff383c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3c0ff532254546cee24c446329970937ff383c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee99fa01b0e014c24b91c6291ca0f0b51080be9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee99fa01b0e014c24b91c6291ca0f0b51080be9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee99fa01b0e014c24b91c6291ca0f0b51080be9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee99fa01b0e014c24b91c6291ca0f0b51080be9/comments", "author": null, "committer": null, "parents": [{"sha": "4430130d282ddb77373e716376b66bf4c007bbfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4430130d282ddb77373e716376b66bf4c007bbfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4430130d282ddb77373e716376b66bf4c007bbfa"}], "stats": {"total": 404, "additions": 402, "deletions": 2}, "files": [{"sha": "748cf932f19ebda8fef345b3aa97d215280676ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -1,3 +1,12 @@\n+2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-sve.md (*pred_cmp<cmp_op><mode>_combine)\n+\t(*pred_cmp<cmp_op><mode>, *fcm<cmp_op><mode>_and_combine)\n+\t(*fcmuo<mode>_and_combine, *fcm<cmp_op><mode>_and)\n+\t(*fcmuo<mode>_and): New patterns.\n+\n 2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/aarch64/iterators.md (UNSPEC_COND_LO, UNSPEC_COND_LS)"}, {"sha": "5c1427d22b1d7743959f7c9997432a86389625a1", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -1358,6 +1358,49 @@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated integer comparisons, formed by combining a PTRUE-predicated\n+;; comparison with an AND.  Split the instruction into its preferred form\n+;; (below) at the earliest opportunity, in order to get rid of the\n+;; redundant operand 1.\n+(define_insn_and_split \"*pred_cmp<cmp_op><mode>_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n+       (and:<VPRED>\n+         (unspec:<VPRED>\n+           [(match_operand:<VPRED> 1)\n+            (SVE_INT_CMP:<VPRED>\n+              (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+              (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+           UNSPEC_MERGE_PTRUE)\n+         (match_operand:<VPRED> 4 \"register_operand\" \"Upl, Upl\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel\n+     [(set (match_dup 0)\n+          (and:<VPRED>\n+            (SVE_INT_CMP:<VPRED>\n+              (match_dup 2)\n+              (match_dup 3))\n+            (match_dup 4)))\n+      (clobber (reg:CC CC_REGNUM))])]\n+)\n+\n+;; Predicated integer comparisons.\n+(define_insn \"*pred_cmp<cmp_op><mode>\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n+\t(and:<VPRED>\n+\t  (SVE_INT_CMP:<VPRED>\n+\t    (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t    (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))\n+\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_SVE\"\n+  \"@\n+   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n+   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+)\n+\n ;; Floating-point comparisons predicated with a PTRUE.\n (define_insn \"*fcm<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n@@ -1385,6 +1428,83 @@\n   \"fcmuo\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Floating-point comparisons predicated on a PTRUE, with the results ANDed\n+;; with another predicate P.  This does not have the same trapping behavior\n+;; as predicating the comparison itself on P, but it's a legitimate fold,\n+;; since we can drop any potentially-trapping operations whose results\n+;; are not needed.\n+;;\n+;; Split the instruction into its preferred form (below) at the earliest\n+;; opportunity, in order to get rid of the redundant operand 1.\n+(define_insn_and_split \"*fcm<cmp_op><mode>_and_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n+\t(and:<VPRED>\n+\t  (unspec:<VPRED>\n+\t    [(match_operand:<VPRED> 1)\n+\t     (SVE_FP_CMP\n+\t       (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t       (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))]\n+\t    UNSPEC_MERGE_PTRUE)\n+\t  (match_operand:<VPRED> 4 \"register_operand\" \"Upl, Upl\")))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (SVE_FP_CMP:<VPRED>\n+\t    (match_dup 2)\n+\t    (match_dup 3))\n+\t  (match_dup 4)))]\n+)\n+\n+(define_insn_and_split \"*fcmuo<mode>_and_combine\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (unspec:<VPRED>\n+\t    [(match_operand:<VPRED> 1)\n+\t     (unordered\n+\t       (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t       (match_operand:SVE_F 3 \"register_operand\" \"w\"))]\n+\t    UNSPEC_MERGE_PTRUE)\n+\t  (match_operand:<VPRED> 4 \"register_operand\" \"Upl\")))]\n+  \"TARGET_SVE\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 0)\n+\t(and:<VPRED>\n+\t  (unordered:<VPRED>\n+\t    (match_dup 2)\n+\t    (match_dup 3))\n+\t  (match_dup 4)))]\n+)\n+\n+;; Unpredicated floating-point comparisons, with the results ANDed\n+;; with another predicate.  This is a valid fold for the same reasons\n+;; as above.\n+(define_insn \"*fcm<cmp_op><mode>_and\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n+\t(and:<VPRED>\n+\t  (SVE_FP_CMP:<VPRED>\n+\t    (match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t    (match_operand:SVE_F 3 \"aarch64_simd_reg_or_zero\" \"Dz, w\"))\n+\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")))]\n+  \"TARGET_SVE\"\n+  \"@\n+   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #0.0\n+   fcm<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+)\n+\n+(define_insn \"*fcmuo<mode>_and\"\n+  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa\")\n+\t(and:<VPRED>\n+\t  (unordered:<VPRED>\n+\t    (match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t    (match_operand:SVE_F 3 \"register_operand\" \"w\"))\n+\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl\")))]\n+  \"TARGET_SVE\"\n+  \"fcmuo\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+)\n+\n ;; Predicated floating-point comparisons.  We don't need a version\n ;; of this for unordered comparisons.\n (define_insn \"*pred_fcm<cmp_op><mode>\""}, {"sha": "a292ea04a6d997e1037aa60a149057b85d434ca6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -1,3 +1,12 @@\n+2018-05-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc.target/aarch64/sve/vcond_6.c: Do not expect any ANDs.\n+\tXFAIL the BIC test.\n+\t* gcc.target/aarch64/sve/vcond_7.c: New test.\n+\t* gcc.target/aarch64/sve/vcond_7_run.c: Likewise.\n+\n 2018-05-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/70563"}, {"sha": "a59f08d553a5d191d941717b5005b48e0f138907", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_6.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_6.c?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -43,10 +43,16 @@\n \n TEST_ALL (LOOP)\n \n-/* { dg-final { scan-assembler-times {\\tand\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n+/* ??? We predicate one of the comparisons on the result of the other,\n+   but whether that's a win or a loss will depend on the schedule.  */\n+/* { dg-final { scan-assembler-not {\\tand\\t} } } */\n /* { dg-final { scan-assembler-times {\\torr\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n /* { dg-final { scan-assembler-times {\\teor\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n /* { dg-final { scan-assembler-times {\\tnand\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n /* { dg-final { scan-assembler-times {\\tnor\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n-/* { dg-final { scan-assembler-times {\\tbic\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */\n+/* Currently we predicate one of the comparisons on the result of the other\n+   and then use NOT, but the original BIC sequence is better.  It's a fairly\n+   niche failure though.  We'd handle most other types of comparison by\n+   using the inverse operation instead of a separate NOT.  */\n+/* { dg-final { scan-assembler-times {\\tbic\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 { xfail *-*-* } } */\n /* { dg-final { scan-assembler-times {\\torn\\tp[0-9]+\\.b, p[0-9]+/z, p[0-9]+\\.b, p[0-9]+\\.b} 3 } } */"}, {"sha": "d2cdbdcff42ce180f7c588d709cb37a459572964", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_7.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7.c?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -0,0 +1,216 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define N 100\n+\n+#define eq(A, B) ((A) == (B))\n+#define ne(A, B) ((A) != (B))\n+#define lt(A, B) ((A) < (B))\n+#define le(A, B) ((A) <= (B))\n+#define ge(A, B) ((A) >= (B))\n+#define gt(A, B) ((A) > (B))\n+#define unordered(A, B) (__builtin_isunordered (A, B))\n+\n+#define DEF_CONST_LOOP(NAME, SUFFIX, TYPE, CONST)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\t\\\n+  NAME##_##SUFFIX##_##TYPE (TYPE *restrict dst, TYPE *restrict src)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (NAME (src[i], CONST))\t\t\t\t\t\t\\\n+\tdst[i] = 1;\t\t\t\t\t\t\t\\\n+  }\n+\n+#define DEF_LOOP(NAME, TYPE, CONST1, CONST2)\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\t\\\n+  NAME##_var_##TYPE (TYPE *restrict dst, TYPE *restrict src, TYPE x)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (NAME (src[i], x))\t\t\t\t\t\t\\\n+\tdst[i] = x;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  DEF_CONST_LOOP (NAME, const1, TYPE, CONST1)\t\t\t\t\\\n+  DEF_CONST_LOOP (NAME, const2, TYPE, CONST2)\n+\n+#define FOR_EACH_INT_OPERATOR(T, TYPE, CONST1, CONST2) \\\n+  T (eq, TYPE, CONST1, CONST2) \\\n+  T (ne, TYPE, CONST1, CONST2) \\\n+  T (le, TYPE, CONST1, CONST2) \\\n+  T (lt, TYPE, CONST1, CONST2) \\\n+  T (gt, TYPE, CONST1, CONST2) \\\n+  T (ge, TYPE, CONST1, CONST2)\n+\n+#define FOR_EACH_FLOAT_OPERATOR(T, TYPE, CONST1, CONST2) \\\n+  FOR_EACH_INT_OPERATOR(T, TYPE, CONST1, CONST2) \\\n+  T (unordered, TYPE, CONST1, CONST2)\n+\n+#define FOR_EACH_TYPE(T) \\\n+  FOR_EACH_INT_OPERATOR (T, int8_t, 2, 100) \\\n+  FOR_EACH_INT_OPERATOR (T, int16_t, 3, 1000) \\\n+  FOR_EACH_INT_OPERATOR (T, int32_t, 4, 2000) \\\n+  FOR_EACH_INT_OPERATOR (T, int64_t, 5, 3000) \\\n+  FOR_EACH_INT_OPERATOR (T, uint8_t, 2, 160) \\\n+  FOR_EACH_INT_OPERATOR (T, uint16_t, 3, 500) \\\n+  FOR_EACH_INT_OPERATOR (T, uint32_t, 4, 1500) \\\n+  FOR_EACH_INT_OPERATOR (T, uint64_t, 5, 2500) \\\n+  FOR_EACH_FLOAT_OPERATOR (T, _Float16, 0, 1) \\\n+  FOR_EACH_FLOAT_OPERATOR (T, float, 0, 1) \\\n+  FOR_EACH_FLOAT_OPERATOR (T, double, 0, 1)\n+\n+FOR_EACH_TYPE (DEF_LOOP)\n+\n+/* { dg-final { scan-assembler-not {\\tand\\t} } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpne\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmplt\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #4\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmple\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpge\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpge\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpge\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpge\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpgt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #4\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmplo\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplo\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplo\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmplo\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #4\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmpls\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #4\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #5\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmphs\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, z[0-9]+\\.b\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphs\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphs\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphs\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.b, p[0-7]/z, z[0-9]+\\.b, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #3\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tcmphi\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #4\\n} 1 } } */\n+\n+\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmeq\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmne\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmle\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmlt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmge\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, #0\\.0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmgt\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, #0\\.0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-7]\\.h, p[0-7]/z, z[0-9]+\\.h, z[0-9]+\\.h\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-7]\\.s, p[0-7]/z, z[0-9]+\\.s, z[0-9]+\\.s\\n} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tfcmuo\\tp[0-7]\\.d, p[0-7]/z, z[0-9]+\\.d, z[0-9]+\\.d\\n} 3 } } */"}, {"sha": "e440f3a67942cab8d2d937c2d6f18e525454724e", "filename": "gcc/testsuite/gcc.target/aarch64/sve/vcond_7_run.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee99fa01b0e014c24b91c6291ca0f0b51080be9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fvcond_7_run.c?ref=cee99fa01b0e014c24b91c6291ca0f0b51080be9", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"vcond_7.c\"\n+\n+#define TEST_CONST_LOOP(NAME, SUFFIX, TYPE, CONST)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tdst[i] = i * 3;\t\t\t\t\t\t\t\\\n+\tsrc[i] = i % (CONST + 3);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    NAME##_##SUFFIX##_##TYPE (dst, src);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (dst[i] != (NAME (src[i], CONST) ? (TYPE) 1 : (TYPE) (i * 3)))\t\\\n+\t__builtin_abort ();\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_LOOPS(NAME, TYPE, CONST1, CONST2)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE dst[N], src[N];\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tdst[i] = i * 2;\t\t\t\t\t\t\t\\\n+\tsrc[i] = i % 5;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    NAME##_var_##TYPE (dst, src, 3);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      if (dst[i] != (NAME (src[i], 3) ? (TYPE) 3 : (TYPE) (i * 2)))\t\\\n+\t__builtin_abort ();\t\t\t\t\t\t\\\n+    TEST_CONST_LOOP (NAME, const1, TYPE, CONST1)\t\t\t\\\n+    TEST_CONST_LOOP (NAME, const2, TYPE, CONST2)\t\t\t\\\n+  }\n+\n+int __attribute__ ((noipa))\n+main (void)\n+{\n+  FOR_EACH_TYPE (TEST_LOOPS);\n+  return 0;\n+}"}]}