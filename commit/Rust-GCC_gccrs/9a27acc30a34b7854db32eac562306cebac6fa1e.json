{"sha": "9a27acc30a34b7854db32eac562306cebac6fa1e", "node_id": "C_kwDOANBUbNoAKDlhMjdhY2MzMGEzNGI3ODU0ZGIzMmVhYzU2MjMwNmNlYmFjNmZhMWU", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-26T20:38:11Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-10-26T22:53:23Z"}, "message": "Make full use of context-sensitive ranges in access warnings.\n\ngcc/ChangeLog:\n\n\t* builtins.c (check_strncat_sizes): Pass access_data ctor additional\n\targuments.\n\t(expand_builtin_memcmp): Move code to gimple-ssa-warn-access.cc.\n\t(expand_builtin_fork_or_exec): Same.\n\t* gimple-array-bounds.cc (array_bounds_checker::check_mem_ref): Pass\n\tcompute_objsize additional arguments.\n\t(inbounds_memaccess_p): Same.\n\t(array_bounds_checker::check_array_bounds): Add an assert.  Stash\n\tstatement in a member.\n\t(check_array_bounds_dom_walker::before_dom_children): Same.\n\t* gimple-array-bounds.h (array_bounds_checker::m_stmt): New member.\n\t* gimple-ssa-sprintf.c (get_destination_size): Add an argument.\n\t(handle_printf_call): Pass a new argument.\n\t* gimple-ssa-warn-access.cc (get_size_range): Add an argument.\n\t(check_access): Add an argument and pass it along to callees.\n\t(check_read_access): Make a member function.\n\t(pass_waccess::check_strcat): Pass access_data ctor additional\n\targuments.\n\t(pass_waccess::check_strncat): Same.\n\t(pass_waccess::check_stxcpy): Same.\n\t(pass_waccess::check_stxncpy): Same.\n\t(pass_waccess::check_strncmp): Same.\n\t(pass_waccess::check_read_access): Same.\n\t(pass_waccess::check_builtin): Same.\n\t(pass_waccess::maybe_check_access_sizes): Same.\n\t(pass_waccess::maybe_check_dealloc_call): Same.\n\t* gimple-ssa-warn-access.h (check_read_access): Declare a new\n\tmember function.\n\t* pointer-query.cc (compute_objsize_r): Add an argument.\n\t(gimple_call_return_array): Same.\n\t(gimple_call_alloc_size): Same.\n\t(access_ref::access_ref): Same.\n\t(access_ref::get_ref): Same.\n\t(pointer_query::get_ref): Same.\n\t(handle_min_max_size): Pass an arguments to callees.\n\t(handle_array_ref): Add an argument.\n\t(handle_mem_ref): Same.\n\t(compute_objsize): Same.\n\t* pointer-query.h (struct access_ref): Adjust signatures.\n\t(struct access_data): Same.\n\t(gimple_call_alloc_size): Add an argument.\n\t(gimple_parm_array_size): Same.\n\t(compute_objsize): Same.\n\t* tree-ssa-strlen.c (strlen_pass::adjust_last_stmt): Pass an additional\n\targument to compute_objsize.\n\t(strlen_pass::maybe_warn_overflow): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/Wstringop-overflow-22.c: Correct typos.\n\t* gcc.dg/Wstringop-overflow-81.c: New test.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/21_strings/basic_string/capacity/1.cc: Also suppress\n\t-Wstringop-overread.\n\t* testsuite/27_io/filesystem/path/factory/u8path-char8_t.cc: Same.", "tree": {"sha": "50aec5b68739f53fc25c813f8ab5c029167141dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50aec5b68739f53fc25c813f8ab5c029167141dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a27acc30a34b7854db32eac562306cebac6fa1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a27acc30a34b7854db32eac562306cebac6fa1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a27acc30a34b7854db32eac562306cebac6fa1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a27acc30a34b7854db32eac562306cebac6fa1e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b504b7a8c5affb0ffa97990d22af2b199e36ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b504b7a8c5affb0ffa97990d22af2b199e36ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b504b7a8c5affb0ffa97990d22af2b199e36ed"}], "stats": {"total": 489, "additions": 263, "deletions": 226}, "files": [{"sha": "7d0f61fc98bc36372d9be1d3a3ddac2e21b5910b", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -3600,7 +3600,7 @@ check_strncat_sizes (tree exp, tree objsize)\n   /* Try to verify that the destination is big enough for the shortest\n      string.  */\n \n-  access_data data (exp, access_read_write, maxread, true);\n+  access_data data (nullptr, exp, access_read_write, maxread, true);\n   if (!objsize && warn_stringop_overflow)\n     {\n       /* If it hasn't been provided by __strncat_chk, try to determine\n@@ -4260,12 +4260,6 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  /* Diagnose calls where the specified length exceeds the size of either\n-     object.  */\n-  if (!check_read_access (exp, arg1, len, 0)\n-      || !check_read_access (exp, arg2, len, 0))\n-    return NULL_RTX;\n-\n   /* Due to the performance benefit, always inline the calls first\n      when result_eq is false.  */\n   rtx result = NULL_RTX;\n@@ -5486,27 +5480,6 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n   tree id, decl;\n   tree call;\n \n-  if (DECL_FUNCTION_CODE (fn) != BUILT_IN_FORK)\n-    {\n-      tree path = CALL_EXPR_ARG (exp, 0);\n-      /* Detect unterminated path.  */\n-      if (!check_read_access (exp, path))\n-\treturn NULL_RTX;\n-\n-      /* Also detect unterminated first argument.  */\n-      switch (DECL_FUNCTION_CODE (fn))\n-\t{\n-\tcase BUILT_IN_EXECL:\n-\tcase BUILT_IN_EXECLE:\n-\tcase BUILT_IN_EXECLP:\n-\t  if (!check_read_access (exp, path))\n-\t    return NULL_RTX;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-\n   /* If we are not profiling, just call the function.  */\n   if (!profile_arc_flag)\n     return NULL_RTX;"}, {"sha": "a35355989981bd3f5068e81658f6d556427ee91b", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -426,7 +426,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n       axssize = wi::to_offset (access_size);\n \n   access_ref aref;\n-  if (!compute_objsize (ref, 0, &aref, ranges))\n+  if (!compute_objsize (ref, m_stmt, 0, &aref, ranges))\n     return false;\n \n   if (aref.offset_in_range (axssize))\n@@ -667,7 +667,7 @@ array_bounds_checker::check_addr_expr (location_t location, tree t,\n    problems discussed in pr98266 and pr97595.  */\n \n static bool\n-inbounds_memaccess_p (tree t)\n+inbounds_memaccess_p (tree t, gimple *stmt)\n {\n   if (TREE_CODE (t) != COMPONENT_REF)\n     return false;\n@@ -686,7 +686,7 @@ inbounds_memaccess_p (tree t)\n      allocated).  */\n   access_ref aref;   // unused\n   tree refop = TREE_OPERAND (mref, 0);\n-  tree refsize = compute_objsize (refop, 1, &aref);\n+  tree refsize = compute_objsize (refop, stmt, 1, &aref);\n   if (!refsize || TREE_CODE (refsize) != INTEGER_CST)\n     return false;\n \n@@ -724,6 +724,7 @@ array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n {\n   tree t = *tp;\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+\n   location_t location;\n \n   if (EXPR_HAS_LOCATION (t))\n@@ -735,6 +736,8 @@ array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n \n   bool warned = false;\n   array_bounds_checker *checker = (array_bounds_checker *) wi->info;\n+  gcc_assert (checker->m_stmt == wi->stmt);\n+\n   if (TREE_CODE (t) == ARRAY_REF)\n     warned = checker->check_array_ref (location, t, wi->stmt,\n \t\t\t\t       false/*ignore_off_by_one*/);\n@@ -746,7 +749,7 @@ array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n       checker->check_addr_expr (location, t, wi->stmt);\n       *walk_subtree = false;\n     }\n-  else if (inbounds_memaccess_p (t))\n+  else if (inbounds_memaccess_p (t, wi->stmt))\n     /* Hack: Skip MEM_REF checks in accesses to a member of a base class\n        at an offset that's within the bounds of the enclosing object.\n        See pr98266 and pr97595.  */\n@@ -794,14 +797,13 @@ check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple *stmt = gsi_stmt (si);\n-      struct walk_stmt_info wi;\n       if (!gimple_has_location (stmt)\n \t  || is_gimple_debug (stmt))\n \tcontinue;\n \n-      memset (&wi, 0, sizeof (wi));\n-\n+      struct walk_stmt_info wi{ };\n       wi.info = checker;\n+      checker->m_stmt = stmt;\n \n       walk_gimple_op (stmt, array_bounds_checker::check_array_bounds, &wi);\n     }"}, {"sha": "d0e665eff11ad352961d2f2b7449477db9a36787", "filename": "gcc/gimple-array-bounds.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-array-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-array-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.h?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -36,8 +36,12 @@ class array_bounds_checker\n   void check_addr_expr (location_t, tree, gimple *);\n   const value_range *get_value_range (const_tree op, gimple *);\n \n+  /* Current function.  */\n   struct function *fun;\n+  /* Ranger instance.  */\n   range_query *ranges;\n+  /* Current statement.  */\n+  gimple *m_stmt;\n };\n \n #endif // GCC_GIMPLE_ARRAY_BOUNDS_H"}, {"sha": "8f42cb59540906c9167c03140a426d39e5ad2847", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -4030,19 +4030,19 @@ compute_format_length (call_info &info, format_result *res, range_query *query)\n   return success;\n }\n \n-/* Return the size of the object referenced by the expression DEST if\n-   available, or the maximum possible size otherwise.  */\n+/* Return the size of the object referenced by the expression DEST in\n+   statement STMT, if available, or the maximum possible size otherwise.  */\n \n static unsigned HOST_WIDE_INT\n-get_destination_size (tree dest, pointer_query &ptr_qry)\n+get_destination_size (tree dest, gimple *stmt, pointer_query &ptr_qry)\n {\n   /* When there is no destination return the maximum.  */\n   if (!dest)\n     return HOST_WIDE_INT_MAX;\n \n   /* Use compute_objsize to determine the size of the destination object.  */\n   access_ref aref;\n-  if (!ptr_qry.get_ref (dest, &aref))\n+  if (!ptr_qry.get_ref (dest, stmt, &aref))\n     return HOST_WIDE_INT_MAX;\n \n   offset_int remsize = aref.size_remaining ();\n@@ -4516,7 +4516,7 @@ handle_printf_call (gimple_stmt_iterator *gsi, pointer_query &ptr_qry)\n       /* For non-bounded functions like sprintf, determine the size\n \t of the destination from the object or pointer passed to it\n \t as the first argument.  */\n-      dstsize = get_destination_size (dstptr, ptr_qry);\n+      dstsize = get_destination_size (dstptr, info.callstmt, ptr_qry);\n     }\n   else if (tree size = gimple_call_arg (info.callstmt, idx_dstsize))\n     {"}, {"sha": "63fc27a14875e30cf9842a1dd94dcee72fee6e6f", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 99, "deletions": 85, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -1190,11 +1190,11 @@ warn_for_access (location_t loc, tree func, tree expr, int opt,\n    by BNDRNG if nonnull and valid.  */\n \n static void\n-get_size_range (range_query *query, tree bound, tree range[2],\n+get_size_range (range_query *query, tree bound, gimple *stmt, tree range[2],\n \t\tconst offset_int bndrng[2])\n {\n   if (bound)\n-    get_size_range (query, bound, NULL, range);\n+    get_size_range (query, bound, stmt, range);\n \n   if (!bndrng || (bndrng[0] == 0 && bndrng[1] == HOST_WIDE_INT_M1U))\n     return;\n@@ -1251,7 +1251,8 @@ template <class GimpleOrTree>\n static bool\n check_access (GimpleOrTree exp, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n-\t      access_mode mode, const access_data *pad /* = NULL */)\n+\t      access_mode mode, const access_data *pad,\n+\t      range_query *rvals)\n {\n   /* The size of the largest object is half the address space, or\n      PTRDIFF_MAX.  (This is way too permissive.)  */\n@@ -1338,7 +1339,8 @@ check_access (GimpleOrTree exp, tree dstwrite,\n \n   /* Set RANGE to that of DSTWRITE if non-null, bounded by PAD->DST.BNDRNG\n      if valid.  */\n-  get_size_range (NULL, dstwrite, range, pad ? pad->dst.bndrng : NULL);\n+  gimple *stmt = pad ? pad->stmt : nullptr;\n+  get_size_range (rvals, dstwrite, stmt, range, pad ? pad->dst.bndrng : NULL);\n \n   tree func = get_callee_fndecl (exp);\n   /* Read vs write access by built-ins can be determined from the const\n@@ -1432,7 +1434,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n     {\n       /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (NULL, maxread, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (rvals, maxread, stmt, range, pad ? pad->src.bndrng : NULL);\n \n       location_t loc = get_location (exp);\n       tree size = dstsize;\n@@ -1479,7 +1481,7 @@ check_access (GimpleOrTree exp, tree dstwrite,\n     {\n       /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n-      get_size_range (NULL, maxread, range, pad ? pad->src.bndrng : NULL);\n+      get_size_range (rvals, maxread, stmt, range, pad ? pad->src.bndrng : NULL);\n       /* Set OVERREAD for reads starting just past the end of an object.  */\n       overread = pad->src.sizrng[1] - pad->src.offrng[0] < pad->src.bndrng[0];\n       range[0] = wide_int_to_tree (sizetype, pad->src.bndrng[0]);\n@@ -1512,59 +1514,23 @@ check_access (GimpleOrTree exp, tree dstwrite,\n   return true;\n }\n \n-bool\n+static bool\n check_access (gimple *stmt, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n-\t      access_mode mode, const access_data *pad /* = NULL */)\n+\t      access_mode mode, const access_data *pad,\n+\t      range_query *rvals)\n {\n-  return check_access<gimple *>(stmt, dstwrite, maxread, srcstr, dstsize,\n-\t\t\t\tmode, pad);\n+  return check_access<gimple *> (stmt, dstwrite, maxread, srcstr, dstsize,\n+\t\t\t\t mode, pad, rvals);\n }\n \n bool\n check_access (tree expr, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n \t      access_mode mode, const access_data *pad /* = NULL */)\n {\n-  return check_access<tree>(expr, dstwrite, maxread, srcstr, dstsize,\n-\t\t\t    mode, pad);\n-}\n-\n-/* A convenience wrapper for check_access above to check access\n-   by a read-only function like puts.  */\n-\n-template <class GimpleOrTree>\n-static bool\n-check_read_access (GimpleOrTree expr, tree src, tree bound, int ost)\n-{\n-  if (!warn_stringop_overread)\n-    return true;\n-\n-  if (bound && !useless_type_conversion_p (size_type_node, TREE_TYPE (bound)))\n-    bound = fold_convert (size_type_node, bound);\n-\n-  tree fndecl = get_callee_fndecl (expr);\n-  maybe_warn_nonstring_arg (fndecl, expr);\n-\n-  access_data data (expr, access_read_only, NULL_TREE, false, bound, true);\n-  compute_objsize (src, ost, &data.src);\n-  return check_access (expr, /*dstwrite=*/ NULL_TREE, /*maxread=*/ bound,\n-\t\t       /*srcstr=*/ src, /*dstsize=*/ NULL_TREE, data.mode,\n-\t\t       &data);\n-}\n-\n-bool\n-check_read_access (gimple *stmt, tree src, tree bound /* = NULL_TREE */,\n-\t\t   int ost /* = 1 */)\n-{\n-  return check_read_access<gimple *>(stmt, src, bound, ost);\n-}\n-\n-bool\n-check_read_access (tree expr, tree src, tree bound /* = NULL_TREE */,\n-\t\t   int ost /* = 1 */)\n-{\n-  return check_read_access<tree>(expr, src, bound, ost);\n+  return check_access<tree> (expr, dstwrite, maxread, srcstr, dstsize,\n+\t\t\t     mode, pad, nullptr);\n }\n \n /* Return true if STMT is a call to an allocation function.  Unless\n@@ -2133,6 +2099,7 @@ class pass_waccess : public gimple_opt_pass\n   void check_stxncpy (gcall *);\n   void check_strncmp (gcall *);\n   void check_memop_access (gimple *, tree, tree, tree);\n+  void check_read_access (gimple *, tree, tree = NULL_TREE, int = 1);\n \n   void maybe_check_dealloc_call (gcall *);\n   void maybe_check_access_sizes (rdwr_map *, tree, tree, gimple *);\n@@ -2428,14 +2395,14 @@ pass_waccess::check_strcat (gcall *stmt)\n      the destination to which the SRC string is being appended so\n      just diagnose cases when the souce string is longer than\n      the destination object.  */\n-  access_data data (stmt, access_read_write, NULL_TREE, true,\n-\t\t    NULL_TREE, true);\n+  access_data data (m_ptr_qry.rvals, stmt, access_read_write, NULL_TREE,\n+\t\t    true, NULL_TREE, true);\n   const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-  compute_objsize (src, ost, &data.src, &m_ptr_qry);\n-  tree destsize = compute_objsize (dest, ost, &data.dst, &m_ptr_qry);\n+  compute_objsize (src, stmt, ost, &data.src, &m_ptr_qry);\n+  tree destsize = compute_objsize (dest, stmt, ost, &data.dst, &m_ptr_qry);\n \n   check_access (stmt, /*dstwrite=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\tsrc, destsize, data.mode, &data);\n+\t\tsrc, destsize, data.mode, &data, m_ptr_qry.rvals);\n }\n \n /* Check a call STMT to strcat() for overflow and warn if it does.  */\n@@ -2469,12 +2436,12 @@ pass_waccess::check_strncat (gcall *stmt)\n       maxlen = lendata.maxbound;\n     }\n \n-  access_data data (stmt, access_read_write);\n+  access_data data (m_ptr_qry.rvals, stmt, access_read_write);\n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n   const int ost = warn_stringop_overflow - 1;\n-  tree destsize = compute_objsize (dest, ost, &data.dst, &m_ptr_qry);\n+  tree destsize = compute_objsize (dest, stmt, ost, &data.dst, &m_ptr_qry);\n \n   /* Add one for the terminating nul.  */\n   tree srclen = (maxlen\n@@ -2503,7 +2470,7 @@ pass_waccess::check_strncat (gcall *stmt)\n     srclen = maxread;\n \n   check_access (stmt, /*dstwrite=*/NULL_TREE, maxread, srclen,\n-\t\tdestsize, data.mode, &data);\n+\t\tdestsize, data.mode, &data, m_ptr_qry.rvals);\n }\n \n /* Check a call STMT to stpcpy() or strcpy() for overflow and warn\n@@ -2527,14 +2494,14 @@ pass_waccess::check_stxcpy (gcall *stmt)\n \n   if (warn_stringop_overflow)\n     {\n-      access_data data (stmt, access_read_write, NULL_TREE, true,\n-\t\t\tNULL_TREE, true);\n+      access_data data (m_ptr_qry.rvals, stmt, access_read_write, NULL_TREE,\n+\t\t\ttrue, NULL_TREE, true);\n       const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-      compute_objsize (src, ost, &data.src, &m_ptr_qry);\n-      tree dstsize = compute_objsize (dst, ost, &data.dst, &m_ptr_qry);\n+      compute_objsize (src, stmt, ost, &data.src, &m_ptr_qry);\n+      tree dstsize = compute_objsize (dst, stmt, ost, &data.dst, &m_ptr_qry);\n       check_access (stmt, /*dstwrite=*/ NULL_TREE,\n \t\t    /*maxread=*/ NULL_TREE, /*srcstr=*/ src,\n-\t\t    dstsize, data.mode, &data);\n+\t\t    dstsize, data.mode, &data, m_ptr_qry.rvals);\n     }\n \n   /* Check to see if the argument was declared attribute nonstring\n@@ -2558,13 +2525,14 @@ pass_waccess::check_stxncpy (gcall *stmt)\n   /* The number of bytes to write (not the maximum).  */\n   tree len = call_arg (stmt, 2);\n \n-  access_data data (stmt, access_read_write, len, true, len, true);\n+  access_data data (m_ptr_qry.rvals, stmt, access_read_write, len, true, len,\n+\t\t    true);\n   const int ost = warn_stringop_overflow ? warn_stringop_overflow - 1 : 1;\n-  compute_objsize (src, ost, &data.src, &m_ptr_qry);\n-  tree dstsize = compute_objsize (dst, ost, &data.dst, &m_ptr_qry);\n+  compute_objsize (src, stmt, ost, &data.src, &m_ptr_qry);\n+  tree dstsize = compute_objsize (dst, stmt, ost, &data.dst, &m_ptr_qry);\n \n-  check_access (stmt, /*dstwrite=*/len,\n-\t\t/*maxread=*/len, src, dstsize, data.mode, &data);\n+  check_access (stmt, /*dstwrite=*/len, /*maxread=*/len, src, dstsize,\n+\t\tdata.mode, &data, m_ptr_qry.rvals);\n }\n \n /* Check a call STMT to stpncpy() or strncpy() for overflow and warn\n@@ -2597,6 +2565,11 @@ pass_waccess::check_strncmp (gcall *stmt)\n   tree len1 = c_strlen (arg1, 1, &lendata1);\n   tree len2 = c_strlen (arg2, 1, &lendata2);\n \n+  if (len1 && TREE_CODE (len1) != INTEGER_CST)\n+    len1 = NULL_TREE;\n+  if (len2 && TREE_CODE (len2) != INTEGER_CST)\n+    len2 = NULL_TREE;\n+\n   if (len1 && len2)\n     /* If the length of both arguments was computed they must both be\n        nul-terminated and no further checking is necessary regardless\n@@ -2609,13 +2582,15 @@ pass_waccess::check_strncmp (gcall *stmt)\n   if (maybe_warn_nonstring_arg (get_callee_fndecl (stmt), stmt))\n     return;\n \n-  access_data adata1 (stmt, access_read_only, NULL_TREE, false, bound, true);\n-  access_data adata2 (stmt, access_read_only, NULL_TREE, false, bound, true);\n+  access_data adata1 (m_ptr_qry.rvals, stmt, access_read_only, NULL_TREE, false,\n+\t\t      bound, true);\n+  access_data adata2 (m_ptr_qry.rvals, stmt, access_read_only, NULL_TREE, false,\n+\t\t      bound, true);\n \n   /* Determine the range of the bound first and bail if it fails; it's\n      cheaper than computing the size of the objects.  */\n   tree bndrng[2] = { NULL_TREE, NULL_TREE };\n-  get_size_range (m_ptr_qry.rvals, bound, bndrng, adata1.src.bndrng);\n+  get_size_range (m_ptr_qry.rvals, bound, stmt, bndrng, adata1.src.bndrng);\n   if (!bndrng[0] || integer_zerop (bndrng[0]))\n     return;\n \n@@ -2626,8 +2601,8 @@ pass_waccess::check_strncmp (gcall *stmt)\n \n   /* compute_objsize almost never fails (and ultimately should never\n      fail).  Don't bother to handle the rare case when it does.  */\n-  if (!compute_objsize (arg1, 1, &adata1.src, &m_ptr_qry)\n-      || !compute_objsize (arg2, 1, &adata2.src, &m_ptr_qry))\n+  if (!compute_objsize (arg1, stmt, 1, &adata1.src, &m_ptr_qry)\n+      || !compute_objsize (arg2, stmt, 1, &adata2.src, &m_ptr_qry))\n     return;\n \n   /* Compute the size of the remaining space in each array after\n@@ -2675,15 +2650,41 @@ pass_waccess::check_memop_access (gimple *stmt, tree dest, tree src, tree size)\n      try to determine the size of the largest source and destination\n      object using type-0 Object Size regardless of the object size\n      type specified by the option.  */\n-  access_data data (stmt, access_read_write);\n+  access_data data (m_ptr_qry.rvals, stmt, access_read_write);\n   tree srcsize\n-    = src ? compute_objsize (src, 0, &data.src, &m_ptr_qry) : NULL_TREE;\n-  tree dstsize = compute_objsize (dest, 0, &data.dst, &m_ptr_qry);\n+    = src ? compute_objsize (src, stmt, 0, &data.src, &m_ptr_qry) : NULL_TREE;\n+  tree dstsize = compute_objsize (dest, stmt, 0, &data.dst, &m_ptr_qry);\n+\n+  check_access (stmt, size, /*maxread=*/NULL_TREE, srcsize, dstsize,\n+\t\tdata.mode, &data, m_ptr_qry.rvals);\n+}\n+\n+/* A convenience wrapper for check_access to check access by a read-only\n+   function like puts or strcmp.  */\n+\n+void\n+pass_waccess::check_read_access (gimple *stmt, tree src,\n+\t\t\t\t tree bound /* = NULL_TREE */,\n+\t\t\t\t int ost /* = 1 */)\n+{\n+  if (!warn_stringop_overread)\n+    return;\n+\n+  if (bound && !useless_type_conversion_p (size_type_node, TREE_TYPE (bound)))\n+    bound = fold_convert (size_type_node, bound);\n+\n+  tree fndecl = get_callee_fndecl (stmt);\n+  maybe_warn_nonstring_arg (fndecl, stmt);\n \n-  check_access (stmt, size, /*maxread=*/NULL_TREE,\n-\t\tsrcsize, dstsize, data.mode, &data);\n+  access_data data (m_ptr_qry.rvals, stmt, access_read_only, NULL_TREE,\n+\t\t   false, bound, true);\n+  compute_objsize (src, stmt, ost, &data.src, &m_ptr_qry);\n+  check_access (stmt, /*dstwrite=*/ NULL_TREE, /*maxread=*/ bound,\n+\t\t/*srcstr=*/ src, /*dstsize=*/ NULL_TREE, data.mode,\n+\t\t&data, m_ptr_qry.rvals);\n }\n \n+\n /* Check a call STMT to an atomic or sync built-in.  */\n \n bool\n@@ -2783,6 +2784,15 @@ pass_waccess::check_builtin (gcall *stmt)\n       check_alloca (stmt);\n       return true;\n \n+    case BUILT_IN_EXECL:\n+    case BUILT_IN_EXECLE:\n+    case BUILT_IN_EXECLP:\n+    case BUILT_IN_EXECV:\n+    case BUILT_IN_EXECVE:\n+    case BUILT_IN_EXECVP:\n+      check_read_access (stmt, call_arg (stmt, 0));\n+      return true;\n+\n     case BUILT_IN_GETTEXT:\n     case BUILT_IN_PUTS:\n     case BUILT_IN_PUTS_UNLOCKED:\n@@ -2805,8 +2815,12 @@ pass_waccess::check_builtin (gcall *stmt)\n \n     case BUILT_IN_STRNDUP:\n     case BUILT_IN_STRNLEN:\n-      check_read_access (stmt, call_arg (stmt, 0), call_arg (stmt, 1));\n-      return true;\n+      {\n+\ttree str = call_arg (stmt, 0);\n+\ttree len = call_arg (stmt, 1);\n+\tcheck_read_access (stmt, str, len);\n+\treturn true;\n+      }\n \n     case BUILT_IN_STRCAT:\n       check_strcat (stmt);\n@@ -2985,7 +2999,7 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n       /* Format the value or range to avoid an explosion of messages.  */\n       char sizstr[80];\n       tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (m_ptr_qry.rvals, access_size, NULL, sizrng, 1))\n+      if (get_size_range (m_ptr_qry.rvals, access_size, stmt, sizrng, 1))\n \t{\n \t  char *s0 = print_generic_expr_to_str (sizrng[0]);\n \t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n@@ -3113,11 +3127,11 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \t    }\n \t}\n \n-      access_data data (ptr, access.second.mode, NULL_TREE, false,\n-\t\t\tNULL_TREE, false);\n+      access_data data (m_ptr_qry.rvals, stmt, access.second.mode,\n+\t\t\tNULL_TREE, false, NULL_TREE, false);\n       access_ref* const pobj = (access.second.mode == access_write_only\n \t\t\t\t? &data.dst : &data.src);\n-      tree objsize = compute_objsize (ptr, 1, pobj, &m_ptr_qry);\n+      tree objsize = compute_objsize (ptr, stmt, 1, pobj, &m_ptr_qry);\n \n       /* The size of the destination or source object.  */\n       tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n@@ -3149,7 +3163,7 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n       if (mode == access_deferred)\n \tmode = TYPE_READONLY (argtype) ? access_read_only : access_read_write;\n       check_access (stmt, access_size, /*maxread=*/ NULL_TREE, srcsize,\n-\t\t    dstsize, mode, &data);\n+\t\t    dstsize, mode, &data, m_ptr_qry.rvals);\n \n       if (warning_suppressed_p (stmt, OPT_Wstringop_overflow_))\n \topt_warned = OPT_Wstringop_overflow_;\n@@ -3272,7 +3286,7 @@ pass_waccess::maybe_check_dealloc_call (gcall *call)\n     return;\n \n   access_ref aref;\n-  if (!compute_objsize (ptr, 0, &aref, &m_ptr_qry))\n+  if (!compute_objsize (ptr, call, 0, &aref, &m_ptr_qry))\n     return;\n \n   tree ref = aref.ref;"}, {"sha": "124f3f530d3da2ef7fcc370e7e7b22c1c3335e09", "filename": "gcc/gimple-ssa-warn-access.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-warn-access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fgimple-ssa-warn-access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.h?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -45,7 +45,4 @@ class access_data;\n extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n \t\t\t  const access_data * = NULL);\n \n-extern bool check_read_access (gimple *, tree, tree = NULL_TREE, int ost = 1);\n-extern bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n-\n #endif   // GCC_GIMPLE_SSA_WARN_ACCESS_H"}, {"sha": "3b9f970846b90ac92d6925eec9ac5eb66de0a3c5", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 63, "deletions": 65, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -43,8 +43,8 @@\n #include \"tree-ssanames.h\"\n #include \"target.h\"\n \n-static bool compute_objsize_r (tree, int, access_ref *, ssa_name_limit_t &,\n-\t\t\t       pointer_query *);\n+static bool compute_objsize_r (tree, gimple *, int, access_ref *,\n+\t\t\t       ssa_name_limit_t &, pointer_query *);\n \n /* Wrapper around the wide_int overload of get_range that accepts\n    offset_int instead.  For middle end expressions returns the same\n@@ -115,7 +115,7 @@ get_offset_range (tree x, gimple *stmt, offset_int r[2], range_query *rvals)\n \n static tree\n gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n-\t\t\t  range_query *rvals)\n+\t\t\t  ssa_name_limit_t &snlim, pointer_query *qry)\n {\n   /* Clear and set below for the rare function(s) that might return\n      a past-the-end pointer.  */\n@@ -191,15 +191,15 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n \toffrng[0] = 0;\n \toffrng[1] = HOST_WIDE_INT_M1U;\n \ttree off = gimple_call_arg (stmt, 2);\n-\tbool off_valid = get_offset_range (off, stmt, offrng, rvals);\n+\tbool off_valid = get_offset_range (off, stmt, offrng, qry->rvals);\n \tif (!off_valid || offrng[0] != offrng[1])\n \t  {\n \t    /* If the offset is either indeterminate or in some range,\n \t       try to constrain its upper bound to at most the size\n \t       of the source object.  */\n \t    access_ref aref;\n \t    tree src = gimple_call_arg (stmt, 1);\n-\t    if (compute_objsize (src, 1, &aref, rvals)\n+\t    if (compute_objsize (src, stmt, 1, &aref, qry)\n \t\t&& aref.sizrng[1] < offrng[1])\n \t      offrng[1] = aref.sizrng[1];\n \t  }\n@@ -212,7 +212,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n     case BUILT_IN_MEMCHR:\n       {\n \ttree off = gimple_call_arg (stmt, 2);\n-\tif (get_offset_range (off, stmt, offrng, rvals))\n+\tif (get_offset_range (off, stmt, offrng, qry->rvals))\n \t  offrng[1] -= 1;\n \telse\n \t  offrng[1] = HOST_WIDE_INT_M1U;\n@@ -233,7 +233,7 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n       {\n \taccess_ref aref;\n \ttree src = gimple_call_arg (stmt, 1);\n-\tif (compute_objsize (src, 1, &aref, rvals))\n+\tif (compute_objsize_r (src, stmt, 1, &aref, snlim, qry))\n \t  offrng[1] = aref.sizrng[1] - 1;\n \telse\n \t  offrng[1] = HOST_WIDE_INT_M1U;\n@@ -250,15 +250,15 @@ gimple_call_return_array (gimple *stmt, offset_int offrng[2], bool *past_end,\n \t   and the source object size.  */\n \toffrng[1] = HOST_WIDE_INT_M1U;\n \ttree off = gimple_call_arg (stmt, 2);\n-\tif (!get_offset_range (off, stmt, offrng, rvals)\n+\tif (!get_offset_range (off, stmt, offrng, qry->rvals)\n \t    || offrng[0] != offrng[1])\n \t  {\n \t    /* If the offset is either indeterminate or in some range,\n \t       try to constrain its upper bound to at most the size\n \t       of the source object.  */\n \t    access_ref aref;\n \t    tree src = gimple_call_arg (stmt, 1);\n-\t    if (compute_objsize (src, 1, &aref, rvals)\n+\t    if (compute_objsize_r (src, stmt, 1, &aref, snlim, qry)\n \t\t&& aref.sizrng[1] < offrng[1])\n \t      offrng[1] = aref.sizrng[1];\n \t  }\n@@ -445,7 +445,7 @@ get_size_range (tree exp, tree range[2], int flags /* = 0 */)\n \n tree\n gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n-\t\t\trange_query * /* = NULL */)\n+\t\t\trange_query *qry /* = NULL */)\n {\n   if (!stmt || !is_gimple_call (stmt))\n     return NULL_TREE;\n@@ -503,7 +503,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   {\n     tree r[2];\n     /* Determine the largest valid range size, including zero.  */\n-    if (!get_size_range (size, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n+    if (!get_size_range (qry, size, stmt, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n       return NULL_TREE;\n     rng1[0] = wi::to_wide (r[0], prec);\n     rng1[1] = wi::to_wide (r[1], prec);\n@@ -519,7 +519,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   {\n     tree r[2];\n       /* As above, use the full non-negative range on failure.  */\n-    if (!get_size_range (n, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n+    if (!get_size_range (qry, n, stmt, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n       return NULL_TREE;\n     rng2[0] = wi::to_wide (r[0], prec);\n     rng2[1] = wi::to_wide (r[1], prec);\n@@ -546,7 +546,7 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n    Set STATIC_ARRAY if the array parameter has been declared [static].\n    Return the function parameter on success and null otherwise.  */\n \n-tree\n+static tree\n gimple_parm_array_size (tree ptr, wide_int rng[2],\n \t\t\tbool *static_array /* = NULL */)\n {\n@@ -596,10 +596,17 @@ gimple_parm_array_size (tree ptr, wide_int rng[2],\n   return var;\n }\n \n-access_ref::access_ref (tree bound /* = NULL_TREE */,\n+/* Given a statement STMT, set the bounds of the reference to at most\n+   as many bytes as BOUND or unknown when null, and at least one when\n+   the MINACCESS is true unless BOUND is a constant zero.  STMT is\n+   used for context to get accurate range info.  */\n+\n+access_ref::access_ref (range_query *qry /* = nullptr */,\n+\t\t\ttree bound /* = NULL_TREE */,\n+\t\t\tgimple *stmt /* = nullptr */,\n \t\t\tbool minaccess /* = false */)\n-: ref (), eval ([](tree x){ return x; }), deref (), trail1special (true),\n-  base0 (true), parmarray ()\n+  : ref (), eval ([](tree x){ return x; }), deref (), trail1special (true),\n+    base0 (true), parmarray ()\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n@@ -615,7 +622,7 @@ access_ref::access_ref (tree bound /* = NULL_TREE */,\n      set the bounds of the access to reflect both it and MINACCESS.\n      BNDRNG[0] is the size of the minimum access.  */\n   tree rng[2];\n-  if (bound && get_size_range (bound, rng, SR_ALLOW_ZERO))\n+  if (bound && get_size_range (qry, bound, stmt, rng, SR_ALLOW_ZERO))\n     {\n       bndrng[0] = wi::to_offset (rng[0]);\n       bndrng[1] = wi::to_offset (rng[1]);\n@@ -696,7 +703,8 @@ access_ref::get_ref (vec<access_ref> *all_refs,\n     {\n       access_ref phi_arg_ref;\n       tree arg = gimple_phi_arg_def (phi_stmt, i);\n-      if (!compute_objsize_r (arg, ostype, &phi_arg_ref, *psnlim, qry)\n+      if (!compute_objsize_r (arg, phi_stmt, ostype, &phi_arg_ref, *psnlim,\n+\t\t\t      qry)\n \t  || phi_arg_ref.sizrng[0] < 0)\n \t/* A PHI with all null pointer arguments.  */\n \treturn NULL_TREE;\n@@ -1312,7 +1320,7 @@ pointer_query::get_ref (tree ptr, int ostype /* = 1 */) const\n    there or compute it and insert it into the cache if it's nonnonull.  */\n \n bool\n-pointer_query::get_ref (tree ptr, access_ref *pref, int ostype /* = 1 */)\n+pointer_query::get_ref (tree ptr, gimple *stmt, access_ref *pref, int ostype /* = 1 */)\n {\n   const unsigned version\n     = TREE_CODE (ptr) == SSA_NAME ? SSA_NAME_VERSION (ptr) : 0;\n@@ -1335,7 +1343,7 @@ pointer_query::get_ref (tree ptr, access_ref *pref, int ostype /* = 1 */)\n       ++misses;\n     }\n \n-  if (!compute_objsize (ptr, ostype, pref, this))\n+  if (!compute_objsize (ptr, stmt, ostype, pref, this))\n     {\n       ++failures;\n       return false;\n@@ -1502,7 +1510,7 @@ static bool\n handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n \t\t     ssa_name_limit_t &snlim, pointer_query *qry)\n {\n-  const gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n+  gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n   const tree_code code = gimple_assign_rhs_code (stmt);\n \n   /* In a valid MAX_/MIN_EXPR both operands must refer to the same array.\n@@ -1512,7 +1520,7 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n      for the expression.  */\n   access_ref aref[2] = { *pref, *pref };\n   tree arg1 = gimple_assign_rhs1 (stmt);\n-  if (!compute_objsize_r (arg1, ostype, &aref[0], snlim, qry))\n+  if (!compute_objsize_r (arg1, stmt, ostype, &aref[0], snlim, qry))\n     {\n       aref[0].base0 = false;\n       aref[0].offrng[0] = aref[0].offrng[1] = 0;\n@@ -1521,7 +1529,7 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n     }\n \n   tree arg2 = gimple_assign_rhs2 (stmt);\n-  if (!compute_objsize_r (arg2, ostype, &aref[1], snlim, qry))\n+  if (!compute_objsize_r (arg2, stmt, ostype, &aref[1], snlim, qry))\n     {\n       aref[1].base0 = false;\n       aref[1].offrng[0] = aref[1].offrng[1] = 0;\n@@ -1589,8 +1597,9 @@ handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n    on success and false on failure.  */\n \n static bool\n-handle_array_ref (tree aref, bool addr, int ostype, access_ref *pref,\n-\t\t  ssa_name_limit_t &snlim, pointer_query *qry)\n+handle_array_ref (tree aref, gimple *stmt, bool addr, int ostype,\n+\t\t  access_ref *pref, ssa_name_limit_t &snlim,\n+\t\t  pointer_query *qry)\n {\n   gcc_assert (TREE_CODE (aref) == ARRAY_REF);\n \n@@ -1603,7 +1612,7 @@ handle_array_ref (tree aref, bool addr, int ostype, access_ref *pref,\n        of known bound.  */\n     return false;\n \n-  if (!compute_objsize_r (arefop, ostype, pref, snlim, qry))\n+  if (!compute_objsize_r (arefop, stmt, ostype, pref, snlim, qry))\n     return false;\n \n   offset_int orng[2];\n@@ -1668,7 +1677,7 @@ handle_array_ref (tree aref, bool addr, int ostype, access_ref *pref,\n    MREF.  Return true on success and false on failure.  */\n \n static bool\n-handle_mem_ref (tree mref, int ostype, access_ref *pref,\n+handle_mem_ref (tree mref, gimple *stmt, int ostype, access_ref *pref,\n \t\tssa_name_limit_t &snlim, pointer_query *qry)\n {\n   gcc_assert (TREE_CODE (mref) == MEM_REF);\n@@ -1690,7 +1699,7 @@ handle_mem_ref (tree mref, int ostype, access_ref *pref,\n     }\n \n   tree mrefop = TREE_OPERAND (mref, 0);\n-  if (!compute_objsize_r (mrefop, ostype, pref, snlim, qry))\n+  if (!compute_objsize_r (mrefop, stmt, ostype, pref, snlim, qry))\n     return false;\n \n   offset_int orng[2];\n@@ -1723,7 +1732,7 @@ handle_mem_ref (tree mref, int ostype, access_ref *pref,\n    to influence code generation or optimization.  */\n \n static bool\n-compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n+compute_objsize_r (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n \t\t   ssa_name_limit_t &snlim, pointer_query *qry)\n {\n   STRIP_NOPS (ptr);\n@@ -1774,7 +1783,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n   if (code == BIT_FIELD_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n+      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n \treturn false;\n \n       offset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n@@ -1796,7 +1805,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t  /* In OSTYPE zero (for raw memory functions like memcpy), use\n \t     the maximum size instead if the identity of the enclosing\n \t     object cannot be determined.  */\n-\t  if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n+\t  if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n \t    return false;\n \n \t  /* Otherwise, use the size of the enclosing object and add\n@@ -1850,15 +1859,15 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n     }\n \n   if (code == ARRAY_REF)\n-    return handle_array_ref (ptr, addr, ostype, pref, snlim, qry);\n+    return handle_array_ref (ptr, stmt, addr, ostype, pref, snlim, qry);\n \n   if (code == MEM_REF)\n-    return handle_mem_ref (ptr, ostype, pref, snlim, qry);\n+    return handle_mem_ref (ptr, stmt, ostype, pref, snlim, qry);\n \n   if (code == TARGET_MEM_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n+      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n \treturn false;\n \n       /* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n@@ -1903,7 +1912,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n   if (code == POINTER_PLUS_EXPR)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n-      if (!compute_objsize_r (ref, ostype, pref, snlim, qry))\n+      if (!compute_objsize_r (ref, stmt, ostype, pref, snlim, qry))\n \treturn false;\n \n       /* Clear DEREF since the offset is being applied to the target\n@@ -1922,7 +1931,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n   if (code == VIEW_CONVERT_EXPR)\n     {\n       ptr = TREE_OPERAND (ptr, 0);\n-      return compute_objsize_r (ptr, ostype, pref, snlim, qry);\n+      return compute_objsize_r (ptr, stmt, ostype, pref, snlim, qry);\n     }\n \n   if (code == SSA_NAME)\n@@ -1951,7 +1960,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t    }\n \t}\n \n-      gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n+      stmt = SSA_NAME_DEF_STMT (ptr);\n       if (is_gimple_call (stmt))\n \t{\n \t  /* If STMT is a call to an allocation function get the size\n@@ -1979,9 +1988,9 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \t      bool past_end;\n \t      offset_int offrng[2];\n \t      if (tree ret = gimple_call_return_array (stmt, offrng,\n-\t\t\t\t\t\t       &past_end, rvals))\n+\t\t\t\t\t\t       &past_end, snlim, qry))\n \t\t{\n-\t\t  if (!compute_objsize_r (ret, ostype, pref, snlim, qry))\n+\t\t  if (!compute_objsize_r (ret, stmt, ostype, pref, snlim, qry))\n \t\t    return false;\n \n \t\t  /* Cap OFFRNG[1] to at most the remaining size of\n@@ -2076,14 +2085,14 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n       if (code == ASSERT_EXPR)\n \t{\n \t  rhs = TREE_OPERAND (rhs, 0);\n-\t  return compute_objsize_r (rhs, ostype, pref, snlim, qry);\n+\t  return compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry);\n \t}\n \n       if (code == POINTER_PLUS_EXPR\n \t  && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n \t{\n \t  /* Compute the size of the object first. */\n-\t  if (!compute_objsize_r (rhs, ostype, pref, snlim, qry))\n+\t  if (!compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry))\n \t    return false;\n \n \t  offset_int orng[2];\n@@ -2099,7 +2108,7 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \n       if (code == ADDR_EXPR || code == SSA_NAME)\n \t{\n-\t  if (!compute_objsize_r (rhs, ostype, pref, snlim, qry))\n+\t  if (!compute_objsize_r (rhs, stmt, ostype, pref, snlim, qry))\n \t    return false;\n \t  qry->put_ref (ptr, *pref);\n \t  return true;\n@@ -2128,18 +2137,21 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n    instead.  */\n \n tree\n-compute_objsize (tree ptr, int ostype, access_ref *pref,\n-\t\t range_query *rvals /* = NULL */)\n+compute_objsize (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n+\t\t pointer_query *ptr_qry)\n {\n   pointer_query qry;\n-  qry.rvals = rvals;\n+  if (ptr_qry)\n+    ptr_qry->depth = 0;\n+  else\n+    ptr_qry = &qry;\n \n   /* Clear and invalidate in case *PREF is being reused.  */\n   pref->offrng[0] = pref->offrng[1] = 0;\n   pref->sizrng[0] = pref->sizrng[1] = -1;\n \n   ssa_name_limit_t snlim;\n-  if (!compute_objsize_r (ptr, ostype, pref, snlim, &qry))\n+  if (!compute_objsize_r (ptr, stmt, ostype, pref, snlim, ptr_qry))\n     return NULL_TREE;\n \n   offset_int maxsize = pref->size_remaining ();\n@@ -2152,26 +2164,12 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n    transition to the pointer_query API.  */\n \n tree\n-compute_objsize (tree ptr, int ostype, access_ref *pref, pointer_query *ptr_qry)\n+compute_objsize (tree ptr, gimple *stmt, int ostype, access_ref *pref,\n+\t\t range_query *rvals /* = NULL */)\n {\n   pointer_query qry;\n-  if (ptr_qry)\n-    ptr_qry->depth = 0;\n-  else\n-    ptr_qry = &qry;\n-\n-  /* Clear and invalidate in case *PREF is being reused.  */\n-  pref->offrng[0] = pref->offrng[1] = 0;\n-  pref->sizrng[0] = pref->sizrng[1] = -1;\n-\n-  ssa_name_limit_t snlim;\n-  if (!compute_objsize_r (ptr, ostype, pref, snlim, ptr_qry))\n-    return NULL_TREE;\n-\n-  offset_int maxsize = pref->size_remaining ();\n-  if (pref->base0 && pref->offrng[0] < 0 && pref->offrng[1] >= 0)\n-    pref->offrng[0] = 0;\n-  return wide_int_to_tree (sizetype, maxsize);\n+  qry.rvals = rvals;\n+  return compute_objsize (ptr, stmt, ostype, pref, &qry);\n }\n \n /* Legacy wrapper around the above.  The function should be removed\n@@ -2184,7 +2182,7 @@ compute_objsize (tree ptr, int ostype, tree *pdecl /* = NULL */,\n   /* Set the initial offsets to zero and size to negative to indicate\n      none has been computed yet.  */\n   access_ref ref;\n-  tree size = compute_objsize (ptr, ostype, &ref, rvals);\n+  tree size = compute_objsize (ptr, nullptr, ostype, &ref, rvals);\n   if (!size || !ref.base0)\n     return NULL_TREE;\n "}, {"sha": "96c500132b6ca752bb97df8e01819720fafed62a", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -60,18 +60,16 @@ class pointer_query;\n /* Describes a reference to an object used in an access.  */\n struct access_ref\n {\n-  /* Set the bounds of the reference to at most as many bytes\n-     as the first argument or unknown when null, and at least\n-     one when the second argument is true unless the first one\n-     is a constant zero.  */\n-  access_ref (tree = NULL_TREE, bool = false);\n+  /* Set the bounds of the reference.  */\n+  access_ref (range_query *query = nullptr, tree = NULL_TREE,\n+\t      gimple * = nullptr, bool = false);\n \n   /* Return the PHI node REF refers to or null if it doesn't.  */\n   gphi *phi () const;\n \n   /* Return the object to which REF refers.  */\n-  tree get_ref (vec<access_ref> *, access_ref * = NULL, int = 1,\n-\t\tssa_name_limit_t * = NULL, pointer_query * = NULL) const;\n+  tree get_ref (vec<access_ref> *, access_ref * = nullptr, int = 1,\n+\t\tssa_name_limit_t * = nullptr, pointer_query * = nullptr) const;\n \n   /* Return true if OFFRNG is the constant zero.  */\n   bool offset_zero () const\n@@ -85,7 +83,7 @@ struct access_ref\n \n   /* Return the maximum amount of space remaining and if non-null, set\n      argument to the minimum.  */\n-  offset_int size_remaining (offset_int * = NULL) const;\n+  offset_int size_remaining (offset_int * = nullptr) const;\n \n /* Return true if the offset and object size are in range for SIZE.  */\n   bool offset_in_range (const offset_int &) const;\n@@ -172,13 +170,13 @@ class pointer_query\n   };\n \n   /* Construct an object with the given Ranger instance and cache.  */\n-  explicit pointer_query (range_query * = NULL, cache_type * = NULL);\n+  explicit pointer_query (range_query * = nullptr, cache_type * = nullptr);\n \n   /* Retrieve the access_ref for a variable from cache if it's there.  */\n   const access_ref* get_ref (tree, int = 1) const;\n \n   /* Retrieve the access_ref for a variable from cache or compute it.  */\n-  bool get_ref (tree, access_ref*, int = 1);\n+  bool get_ref (tree, gimple *, access_ref*, int = 1);\n \n   /* Add an access_ref for the SSA_NAME to the cache.  */\n   void put_ref (tree, const access_ref&, int = 1);\n@@ -208,19 +206,23 @@ struct access_data\n {\n   /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n      at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n-  access_data (gimple *stmt, access_mode mode,\n+  access_data (range_query *query, gimple *stmt, access_mode mode,\n \t       tree maxwrite = NULL_TREE, bool minwrite = false,\n \t       tree maxread = NULL_TREE, bool minread = false)\n     : stmt (stmt), call (),\n-      dst (maxwrite, minwrite), src (maxread, minread), mode (mode) { }\n+      dst (query, maxwrite, stmt, minwrite),\n+      src (query, maxread, stmt, minread),\n+      mode (mode) { }\n \n   /* Set the access to at most MAXWRITE and MAXREAD bytes, and\n      at least 1 when MINWRITE or MINREAD, respectively, is set.  */\n-  access_data (tree expr, access_mode mode,\n+  access_data (range_query *query, tree expr, access_mode mode,\n \t       tree maxwrite = NULL_TREE, bool minwrite = false,\n \t       tree maxread = NULL_TREE, bool minread = false)\n     : stmt (), call (expr),\n-      dst (maxwrite, minwrite), src (maxread, minread), mode (mode) { }\n+      dst (query, maxwrite, nullptr, minwrite),\n+      src (query, maxread, nullptr, minread),\n+      mode (mode) { }\n \n   /* Access statement.  */\n   gimple *stmt;\n@@ -245,14 +247,23 @@ extern bool get_size_range (tree, tree[2], int = 0);\n extern bool get_size_range (range_query *, tree, gimple *, tree[2], int = 0);\n \n class range_query;\n-extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n-\t\t\t\t    range_query * = NULL);\n-extern tree gimple_parm_array_size (tree, wide_int[2], bool * = NULL);\n+extern tree gimple_call_alloc_size (gimple *, wide_int[2] = nullptr,\n+\t\t\t\t    range_query * = nullptr);\n+\n+/* Compute the size of an object referenced by the first argument in\n+   a statement given by second argument, using Object Size Type given\n+   by third argument.  Store result in an access_ref.  */\n+extern tree compute_objsize (tree, gimple *, int, access_ref *,\n+\t\t\t     range_query * = nullptr);\n+extern tree compute_objsize (tree, gimple *, int, access_ref *,\n+\t\t\t     pointer_query *);\n+inline tree compute_objsize (tree ptr, int ostype, access_ref *pref)\n+{\n+  return compute_objsize (ptr, nullptr, ostype, pref, (range_query *)nullptr);\n+}\n \n-extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n /* Legacy/transitional API.  Should not be used in new code.  */\n-extern tree compute_objsize (tree, int, access_ref *, pointer_query *);\n-extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n-\t\t\t     range_query * = NULL);\n+extern tree compute_objsize (tree, int, tree * = nullptr, tree * = nullptr,\n+\t\t\t     range_query * = nullptr);\n \n #endif   // GCC_POINTER_QUERY_H"}, {"sha": "764b1990276feb4629750b5ed79255251c759b0f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-22.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-22.c?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -260,13 +260,12 @@ T (puts_unlocked, a);       // { dg-warning \"missing terminating nul\" \"puts_unlo\n \n // Exerise exec functions.\n T (execl, a, s, NULL);      // { dg-warning \"missing terminating nul\" \"execl\" }\n-T (execl, a, s, NULL);      // { dg-warning \"missing terminating nul\" \"execl\" }\n-T (execle, a, s, NULL, NULL);   // { dg-warning \"missing terminating nul\" \"execl\" }\n-T (execlp, a, s, NULL);     // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execle, a, s, NULL, NULL);   // { dg-warning \"missing terminating nul\" \"execle\" }\n+T (execlp, a, s, NULL);     // { dg-warning \"missing terminating nul\" \"execlp\" }\n \n-T (execv, a, &d);           // { dg-warning \"missing terminating nul\" \"execl\" }\n-T (execve, a, &d, &d);      // { dg-warning \"missing terminating nul\" \"execl\" }\n-T (execvp, a, &d);          // { dg-warning \"missing terminating nul\" \"execl\" }\n+T (execv, a, &d);           // { dg-warning \"missing terminating nul\" \"execv\" }\n+T (execve, a, &d, &d);      // { dg-warning \"missing terminating nul\" \"execve\" }\n+T (execvp, a, &d);          // { dg-warning \"missing terminating nul\" \"execvp\" }\n \n T (gettext, a);             // { dg-warning \"missing terminating nul\" \"gettext\" }\n "}, {"sha": "e8bc327722a5ae346f815eeb6bd087297fd0847d", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-81.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-81.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-81.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-81.c?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -0,0 +1,38 @@\n+/* Verify that -Wstringop-overflow uses context-sensitive range info\n+   even at -O0.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+extern void* memset (void*, int, __SIZE_TYPE__);\n+\n+char a[8];\n+\n+void warn_offset_range (int i)\n+{\n+  if (i < 4)\n+    i = 4;\n+  memset (a + i, 0, 5);       // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+}\n+\n+void warn_size_range (int i, int n)\n+{\n+  if (n < 5)\n+    n = 5;\n+\n+  memset (a + 4, 1, n);      // { dg-warning \"writing between 5 and \\\\d+ bytes into a region of size 4 \" }\n+}\n+\n+void warn_offset_and_size_range (int i, int n)\n+{\n+  if (n < 5)\n+    n = 5;\n+\n+  if (i < 4)\n+    {\n+      if (n < 9)\n+\tn = 9;\n+      memset (a + i, 1, n);   // { dg-warning \"writing between 9 and \\\\d+ bytes into a region of size 8 \" }\n+    }\n+  else\n+    memset (a + i, 0, n);     // { dg-warning \"writing between 5 and \\\\d+ bytes into a region of size 4 \" }\n+}"}, {"sha": "2de7cb1a6a0555a4b7782f7c0cfc9599963094ae", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -1833,7 +1833,7 @@ strlen_pass::adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n       tree dst = gimple_call_arg (last.stmt, 0);\n \n       access_ref aref;\n-      tree size = compute_objsize (dst, 1, &aref, &ptr_qry);\n+      tree size = compute_objsize (dst, stmt, 1, &aref, &ptr_qry);\n       if (size && tree_int_cst_lt (size, len))\n \treturn;\n     }\n@@ -2035,7 +2035,7 @@ strlen_pass::maybe_warn_overflow (gimple *stmt, bool call_lhs, tree len,\n   access_ref aref;\n   /* The size of the destination region (which is smaller than\n      the destination object for stores at a non-zero offset).  */\n-  tree destsize = compute_objsize (dest, ostype, &aref, &ptr_qry);\n+  tree destsize = compute_objsize (dest, stmt, ostype, &aref, &ptr_qry);\n \n   if (!destsize)\n     {\n@@ -3115,7 +3115,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n     }\n \n   access_ref aref;\n-  if (tree dstsize = compute_objsize (dst, 1, &aref, ptr_qry))\n+  if (tree dstsize = compute_objsize (dst, stmt, 1, &aref, ptr_qry))\n     {\n       /* The source length is unknown.  Try to determine the destination\n \t size and see if it matches the specified bound.  If not, bail.\n@@ -3130,7 +3130,7 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n       /* Avoid warning for strncpy(a, b, N) calls where the following\n \t equalities hold:\n \t   N == sizeof a && N == sizeof b */\n-      if (tree srcsize = compute_objsize (src, 1, &aref, ptr_qry))\n+      if (tree srcsize = compute_objsize (src, stmt, 1, &aref, ptr_qry))\n \tif (wi::to_wide (srcsize) == cntrange[1])\n \t  return false;\n "}, {"sha": "b3990f6011a8240fbf75742cdd82cfcb1fce2bfc", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/capacity/1.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fcapacity%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fcapacity%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fcapacity%2F1.cc?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -17,7 +17,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-Wno-stringop-overflow\" }\n+// { dg-options \"-Wno-stringop-overflow -Wno-stringop-overread\" }\n \n // 21.3.3 string capacity\n "}, {"sha": "1f6b7a37aa3df8c8a085d361209d598d3047f441", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/factory/u8path-char8_t.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a27acc30a34b7854db32eac562306cebac6fa1e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path-char8_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a27acc30a34b7854db32eac562306cebac6fa1e/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path-char8_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Ffactory%2Fu8path-char8_t.cc?ref=9a27acc30a34b7854db32eac562306cebac6fa1e", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-fchar8_t\" }\n+// { dg-options \"-fchar8_t -Wno-stringop-overread\" }\n // { dg-do run { target c++17 } }\n \n #include <filesystem>\n@@ -36,6 +36,7 @@ test01()\n   p = fs::u8path(u8\"\\xf0\\x9d\\x84\\x9e\");\n   VERIFY( p.u8string() == u8\"\\U0001D11E\" );\n \n+  // The following triggers -Wstringop-overread.  See PR 102958.\n   std::u8string s1 = u8\"filename2\";\n   p = fs::u8path(s1);\n   VERIFY( p.u8string() == u8\"filename2\" );"}]}