{"sha": "d54a098e48987e7368ff190b703efd72aba9e6d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU0YTA5OGU0ODk4N2U3MzY4ZmYxOTBiNzAzZWZkNzJhYmE5ZTZkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-20T08:05:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-20T08:05:41Z"}, "message": "[1/n] PR85694: Allow pattern definition statements to be reused\n\nThis patch is the first part of a series to fix to PR85694.\nLater patches can make the pattern for a statement S2 reuse the\nresults of a PATTERN_DEF_SEQ statement attached to an earlier\nstatement S1.  Although vect_mark_stmts_to_be_vectorized handled\nthis fine, vect_analyze_stmt and vect_transform_loop both skipped the\nPATTERN_DEF_SEQ for S1 if S1's main pattern wasn't live or relevant.\n\nI couldn't wrap my head around the flow in vect_transform_loop,\nso ended up moving the per-statement handling into a subroutine.\nThat makes the patch look bigger than it actually is.\n\n2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-stmts.c (vect_analyze_stmt): Move the handling of pattern\n\tdefinition statements before the early exit for statements that aren't\n\tlive or relevant.\n\t* tree-vect-loop.c (vect_transform_loop_stmt): New function,\n\tsplit out from...\n\t(vect_transform_loop): ...here.  Process pattern definition\n\tstatements without first checking whether the main pattern\n\tstatement is live or relevant.\n\nFrom-SVN: r261784", "tree": {"sha": "dc8ea1dce60c622c8d4d910d5ae5cfda49695038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc8ea1dce60c622c8d4d910d5ae5cfda49695038"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d54a098e48987e7368ff190b703efd72aba9e6d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54a098e48987e7368ff190b703efd72aba9e6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54a098e48987e7368ff190b703efd72aba9e6d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54a098e48987e7368ff190b703efd72aba9e6d9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "036a90820ac4197c81f705bc79ad8613a3ab28cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/036a90820ac4197c81f705bc79ad8613a3ab28cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/036a90820ac4197c81f705bc79ad8613a3ab28cd"}], "stats": {"total": 356, "additions": 152, "deletions": 204}, "files": [{"sha": "983143f226b237a7756b9fca12a7eb03d4a4c3e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d54a098e48987e7368ff190b703efd72aba9e6d9", "patch": "@@ -1,3 +1,14 @@\n+2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-stmts.c (vect_analyze_stmt): Move the handling of pattern\n+\tdefinition statements before the early exit for statements that aren't\n+\tlive or relevant.\n+\t* tree-vect-loop.c (vect_transform_loop_stmt): New function,\n+\tsplit out from...\n+\t(vect_transform_loop): ...here.  Process pattern definition\n+\tstatements without first checking whether the main pattern\n+\tstatement is live or relevant.\n+\n 2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-cfgcleanup.c (tree_forwarder_block_p): Do not return false at"}, {"sha": "b07fcdecb724f1c757b04dc8aa01004b8494d93e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 113, "deletions": 176, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d54a098e48987e7368ff190b703efd72aba9e6d9", "patch": "@@ -8290,6 +8290,74 @@ scale_profile_for_vect_loop (struct loop *loop, unsigned vf)\n     scale_bbs_frequencies (&loop->latch, 1, exit_l->probability / prob);\n }\n \n+/* Vectorize STMT if relevant, inserting any new instructions before GSI.\n+   When vectorizing STMT as a store, set *SEEN_STORE to its stmt_vec_info.\n+   *SLP_SCHEDULE is a running record of whether we have called\n+   vect_schedule_slp.  */\n+\n+static void\n+vect_transform_loop_stmt (loop_vec_info loop_vinfo, gimple *stmt,\n+\t\t\t  gimple_stmt_iterator *gsi,\n+\t\t\t  stmt_vec_info *seen_store, bool *slp_scheduled)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  if (!stmt_info)\n+    return;\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"------>vectorizing statement: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+    }\n+\n+  if (MAY_HAVE_DEBUG_BIND_STMTS && !STMT_VINFO_LIVE_P (stmt_info))\n+    vect_loop_kill_debug_uses (loop, stmt);\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+      && !STMT_VINFO_LIVE_P (stmt_info))\n+    return;\n+\n+  if (STMT_VINFO_VECTYPE (stmt_info))\n+    {\n+      poly_uint64 nunits\n+\t= TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+      if (!STMT_SLP_TYPE (stmt_info)\n+\t  && maybe_ne (nunits, vf)\n+\t  && dump_enabled_p ())\n+\t/* For SLP VF is set according to unrolling factor, and not\n+\t   to vector size, hence for SLP this print is not valid.  */\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n+    }\n+\n+  /* SLP.  Schedule all the SLP instances when the first SLP stmt is\n+     reached.  */\n+  if (STMT_SLP_TYPE (stmt_info))\n+    {\n+      if (!*slp_scheduled)\n+\t{\n+\t  *slp_scheduled = true;\n+\n+\t  DUMP_VECT_SCOPE (\"scheduling SLP instances\");\n+\n+\t  vect_schedule_slp (loop_vinfo);\n+\t}\n+\n+      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n+      if (PURE_SLP_STMT (stmt_info))\n+\treturn;\n+    }\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\\n\");\n+\n+  bool grouped_store = false;\n+  if (vect_transform_stmt (stmt, gsi, &grouped_store, NULL, NULL))\n+    *seen_store = stmt_info;\n+}\n+\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -8310,12 +8378,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   tree niters_vector_mult_vf = NULL_TREE;\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   unsigned int lowest_vf = constant_lower_bound (vf);\n-  bool grouped_store;\n   bool slp_scheduled = false;\n-  gimple *stmt, *pattern_stmt;\n-  gimple_seq pattern_def_seq = NULL;\n-  gimple_stmt_iterator pattern_def_si = gsi_none ();\n-  bool transform_pattern_stmt = false;\n+  gimple *stmt;\n   bool check_profitability = false;\n   unsigned int th;\n \n@@ -8466,194 +8530,67 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n-      pattern_stmt = NULL;\n       for (gimple_stmt_iterator si = gsi_start_bb (bb);\n-\t   !gsi_end_p (si) || transform_pattern_stmt;)\n+\t   !gsi_end_p (si);)\n \t{\n-\t  bool is_store;\n-\n-          if (transform_pattern_stmt)\n-\t    stmt = pattern_stmt;\n-          else\n+\t  stmt = gsi_stmt (si);\n+\t  /* During vectorization remove existing clobber stmts.  */\n+\t  if (gimple_clobber_p (stmt))\n \t    {\n-\t      stmt = gsi_stmt (si);\n-\t      /* During vectorization remove existing clobber stmts.  */\n-\t      if (gimple_clobber_p (stmt))\n-\t\t{\n-\t\t  unlink_stmt_vdef (stmt);\n-\t\t  gsi_remove (&si, true);\n-\t\t  release_defs (stmt);\n-\t\t  continue;\n-\t\t}\n+\t      unlink_stmt_vdef (stmt);\n+\t      gsi_remove (&si, true);\n+\t      release_defs (stmt);\n \t    }\n-\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"------>vectorizing statement: \");\n-\t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n-\t    }\n-\n-\t  stmt_info = vinfo_for_stmt (stmt);\n-\n-\t  /* vector stmts created in the outer-loop during vectorization of\n-\t     stmts in an inner-loop may not have a stmt_info, and do not\n-\t     need to be vectorized.  */\n-\t  if (!stmt_info)\n+\t  else\n \t    {\n-\t      gsi_next (&si);\n-\t      continue;\n-\t    }\n-\n-\t  if (MAY_HAVE_DEBUG_BIND_STMTS && !STMT_VINFO_LIVE_P (stmt_info))\n-\t    vect_loop_kill_debug_uses (loop, stmt);\n+\t      stmt_info = vinfo_for_stmt (stmt);\n \n-\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n-\t      && !STMT_VINFO_LIVE_P (stmt_info))\n-            {\n-              if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-                  && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n-                  && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-                      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n-                {\n-                  stmt = pattern_stmt;\n-                  stmt_info = vinfo_for_stmt (stmt);\n-                }\n-              else\n-\t        {\n-   \t          gsi_next (&si);\n-\t          continue;\n-                }\n-\t    }\n-          else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-                   && (pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info))\n-                   && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-                       || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n-            transform_pattern_stmt = true;\n-\n-\t  /* If pattern statement has def stmts, vectorize them too.  */\n-\t  if (is_pattern_stmt_p (stmt_info))\n-\t    {\n-\t      if (pattern_def_seq == NULL)\n+\t      /* vector stmts created in the outer-loop during vectorization of\n+\t\t stmts in an inner-loop may not have a stmt_info, and do not\n+\t\t need to be vectorized.  */\n+\t      stmt_vec_info seen_store = NULL;\n+\t      if (stmt_info)\n \t\t{\n-\t\t  pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n-\t\t  pattern_def_si = gsi_start (pattern_def_seq);\n-\t\t}\n-\t      else if (!gsi_end_p (pattern_def_si))\n-\t\tgsi_next (&pattern_def_si);\n-\t      if (pattern_def_seq != NULL)\n-\t\t{\n-\t\t  gimple *pattern_def_stmt = NULL;\n-\t\t  stmt_vec_info pattern_def_stmt_info = NULL;\n-\n-\t\t  while (!gsi_end_p (pattern_def_si))\n+\t\t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t\t    {\n-\t\t      pattern_def_stmt = gsi_stmt (pattern_def_si);\n-\t\t      pattern_def_stmt_info\n-\t\t\t= vinfo_for_stmt (pattern_def_stmt);\n-\t\t      if (STMT_VINFO_RELEVANT_P (pattern_def_stmt_info)\n-\t\t\t  || STMT_VINFO_LIVE_P (pattern_def_stmt_info))\n-\t\t\tbreak;\n-\t\t      gsi_next (&pattern_def_si);\n-\t\t    }\n-\n-\t\t  if (!gsi_end_p (pattern_def_si))\n-\t\t    {\n-\t\t      if (dump_enabled_p ())\n-\t\t\t{\n-\t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t   \"==> vectorizing pattern def \"\n-\t\t\t\t\t   \"stmt: \");\n-\t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t\t    pattern_def_stmt, 0);\n-\t\t\t}\n-\n-\t\t      stmt = pattern_def_stmt;\n-\t\t      stmt_info = pattern_def_stmt_info;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      pattern_def_si = gsi_none ();\n-\t\t      transform_pattern_stmt = false;\n+\t\t      gimple *def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n+\t\t      for (gimple_stmt_iterator subsi = gsi_start (def_seq);\n+\t\t\t   !gsi_end_p (subsi); gsi_next (&subsi))\n+\t\t\tvect_transform_loop_stmt (loop_vinfo,\n+\t\t\t\t\t\t  gsi_stmt (subsi), &si,\n+\t\t\t\t\t\t  &seen_store,\n+\t\t\t\t\t\t  &slp_scheduled);\n+\t\t      gimple *pat_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\t\t      vect_transform_loop_stmt (loop_vinfo, pat_stmt, &si,\n+\t\t\t\t\t\t&seen_store, &slp_scheduled);\n \t\t    }\n+\t\t  vect_transform_loop_stmt (loop_vinfo, stmt, &si,\n+\t\t\t\t\t    &seen_store, &slp_scheduled);\n \t\t}\n-\t      else\n-\t\ttransform_pattern_stmt = false;\n-            }\n-\n-\t  if (STMT_VINFO_VECTYPE (stmt_info))\n-\t    {\n-\t      poly_uint64 nunits\n-\t\t= TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n-\t      if (!STMT_SLP_TYPE (stmt_info)\n-\t\t  && maybe_ne (nunits, vf)\n-\t\t  && dump_enabled_p ())\n-\t\t  /* For SLP VF is set according to unrolling factor, and not\n-\t\t     to vector size, hence for SLP this print is not valid.  */\n-\t\tdump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n-\t    }\n-\n-\t  /* SLP. Schedule all the SLP instances when the first SLP stmt is\n-\t     reached.  */\n-\t  if (STMT_SLP_TYPE (stmt_info))\n-\t    {\n-\t      if (!slp_scheduled)\n+\t      if (seen_store)\n \t\t{\n-\t\t  slp_scheduled = true;\n-\n-\t\t  DUMP_VECT_SCOPE (\"scheduling SLP instances\");\n-\n-\t\t  vect_schedule_slp (loop_vinfo);\n-\t\t}\n-\n-\t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */\n-\t      if (!vinfo_for_stmt (stmt) || PURE_SLP_STMT (stmt_info))\n-\t\t{\n-\t\t  if (!transform_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t\t  if (STMT_VINFO_GROUPED_ACCESS (seen_store))\n \t\t    {\n-\t\t      pattern_def_seq = NULL;\n+\t\t      /* Interleaving.  If IS_STORE is TRUE, the\n+\t\t\t vectorization of the interleaving chain was\n+\t\t\t completed - free all the stores in the chain.  */\n \t\t      gsi_next (&si);\n+\t\t      vect_remove_stores (DR_GROUP_FIRST_ELEMENT (seen_store));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Free the attached stmt_vec_info and remove the\n+\t\t\t stmt.  */\n+\t\t      free_stmt_vec_info (stmt);\n+\t\t      unlink_stmt_vdef (stmt);\n+\t\t      gsi_remove (&si, true);\n+\t\t      release_defs (stmt);\n \t\t    }\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  /* -------- vectorize statement ------------ */\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\\n\");\n-\n-\t  grouped_store = false;\n-\t  is_store = vect_transform_stmt (stmt, &si, &grouped_store, NULL, NULL);\n-          if (is_store)\n-            {\n-\t      if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t\t{\n-\t\t  /* Interleaving. If IS_STORE is TRUE, the vectorization of the\n-\t\t     interleaving chain was completed - free all the stores in\n-\t\t     the chain.  */\n-\t\t  gsi_next (&si);\n-\t\t  vect_remove_stores (DR_GROUP_FIRST_ELEMENT (stmt_info));\n \t\t}\n \t      else\n-\t\t{\n-\t\t  /* Free the attached stmt_vec_info and remove the stmt.  */\n-\t\t  gimple *store = gsi_stmt (si);\n-\t\t  free_stmt_vec_info (store);\n-\t\t  unlink_stmt_vdef (store);\n-\t\t  gsi_remove (&si, true);\n-\t\t  release_defs (store);\n-\t\t}\n-\n-\t      /* Stores can only appear at the end of pattern statements.  */\n-\t      gcc_assert (!transform_pattern_stmt);\n-\t      pattern_def_seq = NULL;\n+\t\tgsi_next (&si);\n \t    }\n-\t  else if (!transform_pattern_stmt && gsi_end_p (pattern_def_si))\n-\t    {\n-\t      pattern_def_seq = NULL;\n-\t      gsi_next (&si);\n-\t    }\n-\t}\t\t        /* stmts in BB */\n+\t}\n \n       /* Stub out scalar statements that must not survive vectorization.\n \t Doing this here helps with grouped statements, or statements that"}, {"sha": "047edcdae5f296ccc49f99493c35b9c03c722d43", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54a098e48987e7368ff190b703efd72aba9e6d9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d54a098e48987e7368ff190b703efd72aba9e6d9", "patch": "@@ -9393,6 +9393,34 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n       return false;\n     }\n \n+  if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n+      && node == NULL\n+      && (pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info)))\n+    {\n+      gimple_stmt_iterator si;\n+\n+      for (si = gsi_start (pattern_def_seq); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple *pattern_def_stmt = gsi_stmt (si);\n+\t  if (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n+\t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n+\t    {\n+\t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t   \"==> examining pattern def statement: \");\n+\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_def_stmt, 0);\n+\t\t}\n+\n+\t      if (!vect_analyze_stmt (pattern_def_stmt,\n+\t\t\t\t      need_to_vectorize, node, node_instance,\n+\t\t\t\t      cost_vec))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n   /* Skip stmts that do not need to be vectorized. In loops this is expected\n      to include:\n      - the COND_EXPR which is the loop exit condition\n@@ -9453,34 +9481,6 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n         return false;\n    }\n \n-  if (is_pattern_stmt_p (stmt_info)\n-      && node == NULL\n-      && (pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info)))\n-    {\n-      gimple_stmt_iterator si;\n-\n-      for (si = gsi_start (pattern_def_seq); !gsi_end_p (si); gsi_next (&si))\n-\t{\n-\t  gimple *pattern_def_stmt = gsi_stmt (si);\n-\t  if (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_def_stmt))\n-\t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n-\t    {\n-\t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-                                   \"==> examining pattern def statement: \");\n-\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_def_stmt, 0);\n-\t\t}\n-\n-\t      if (!vect_analyze_stmt (pattern_def_stmt,\n-\t\t\t\t      need_to_vectorize, node, node_instance,\n-\t\t\t\t      cost_vec))\n-\t\treturn false;\n-\t    }\n-\t}\n-    }\n-\n   switch (STMT_VINFO_DEF_TYPE (stmt_info))\n     {\n       case vect_internal_def:"}]}