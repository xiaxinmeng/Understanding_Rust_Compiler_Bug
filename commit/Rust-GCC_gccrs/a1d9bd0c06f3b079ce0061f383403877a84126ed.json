{"sha": "a1d9bd0c06f3b079ce0061f383403877a84126ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFkOWJkMGMwNmYzYjA3OWNlMDA2MWYzODM0MDM4NzdhODQxMjZlZA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-05-04T05:03:45Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-05-04T05:03:45Z"}, "message": "sparc.md (DFA schedulers): Split out...\n\n2002-05-03  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.md (DFA schedulers): Split out...\n\t* config/sparc/cypress.md, config/sparc/hypersparc.md,\n\tconfig/sparc/sparclet.md, config/sparc/supersparc.md,\n\tconfig/sparc/ultra1_2.md, config/sparc/ultra3.md: ... into here.\n\nFrom-SVN: r53146", "tree": {"sha": "ed7f60249865c4f7da0bed4baafd88f7f586650a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed7f60249865c4f7da0bed4baafd88f7f586650a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1d9bd0c06f3b079ce0061f383403877a84126ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d9bd0c06f3b079ce0061f383403877a84126ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d9bd0c06f3b079ce0061f383403877a84126ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d9bd0c06f3b079ce0061f383403877a84126ed/comments", "author": null, "committer": null, "parents": [{"sha": "e87bb82e16b6a5088361711f9aac5aed7514d9f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e87bb82e16b6a5088361711f9aac5aed7514d9f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e87bb82e16b6a5088361711f9aac5aed7514d9f8"}], "stats": {"total": 1202, "additions": 684, "deletions": 518}, "files": [{"sha": "df9380a1f49f6c340ee5e6106f80bf81e18b0378", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -1,5 +1,10 @@\n 2002-05-03  David S. Miller  <davem@redhat.com>\n \n+\t* config/sparc/sparc.md (DFA schedulers): Split out...\n+\t* config/sparc/cypress.md, config/sparc/hypersparc.md,\n+\tconfig/sparc/sparclet.md, config/sparc/supersparc.md,\n+\tconfig/sparc/ultra1_2.md, config/sparc/ultra3.md: ... into here.\n+\n \t* config/sparc/sparc.c (LEAF_REGISTERS): Do not do ifdef\n \tchecks on it, always defined for Sparc.\n "}, {"sha": "f871b1e00309668cb2b54688ac3df636651442e0", "filename": "gcc/config/sparc/cypress.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fcypress.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fcypress.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fcypress.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,51 @@\n+;; Scheduling description for Sparc Cypress.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The Cypress is a pretty simple single-issue processor.\n+\n+(define_automaton \"cypress_0,cypress_1\")\n+\n+(define_cpu_unit \"cyp_memory, cyp_fpalu\" \"cypress_0\")\n+(define_cpu_unit \"cyp_fpmds\" \"cypress_1\")\n+\n+(define_insn_reservation \"cyp_load\" 2\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"load,sload,fpload\"))\n+  \"cyp_memory, nothing\")\n+\n+(define_insn_reservation \"cyp_fp_alu\" 5\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fp,fpmove\"))\n+  \"cyp_fpalu, nothing*3\")\n+\n+(define_insn_reservation \"cyp_fp_mult\" 7\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  \"cyp_fpmds, nothing*5\")\n+\n+(define_insn_reservation \"cyp_fp_div\" 37\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpdivs,fpdivd\"))\n+  \"cyp_fpmds, nothing*35\")\n+\n+(define_insn_reservation \"cyp_fp_sqrt\" 63\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n+  \"cyp_fpmds, nothing*61\")"}, {"sha": "741f163234edf3e722df852d675ac712483f1642", "filename": "gcc/config/sparc/hypersparc.md", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fhypersparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fhypersparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fhypersparc.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,83 @@\n+;; Scheduling description for HyperSparc.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The HyperSparc is a dual-issue processor.  It is not all that fancy.\n+\n+;; ??? There are some things not modelled.  For example, sethi+or\n+;; ??? coming right after each other are specifically identified and\n+;; ??? dual-issued by the processor.  Similarly for sethi+ld[reg+lo].\n+;; ??? Actually, to be more precise that rule is sort of modelled now.\n+\n+(define_automaton \"hypersparc_0,hypersparc_1\")\n+\n+;; HyperSPARC/sparclite86x scheduling\n+\n+(define_cpu_unit \"hs_memory,hs_branch,hs_shift,hs_fpalu\" \"hypersparc_0\")\n+(define_cpu_unit \"hs_fpmds\" \"hypersparc_1\")\n+\n+(define_insn_reservation \"hs_load\" 1\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"load,sload,fpload\"))\n+  \"hs_memory\")\n+\n+(define_insn_reservation \"hs_store\" 2\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"hs_memory, nothing\")\n+\n+(define_insn_reservation \"hs_slbranch\" 1\n+  (and (eq_attr \"cpu\" \"sparclite86x\")\n+    (eq_attr \"type\" \"branch\"))\n+  \"hs_branch\")\n+\n+(define_insn_reservation \"hs_slshift\" 1\n+  (and (eq_attr \"cpu\" \"sparclite86x\")\n+    (eq_attr \"type\" \"shift\"))\n+  \"hs_shift\")\n+\n+(define_insn_reservation \"hs_fp_alu\" 1\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n+  \"hs_fpalu\")\n+\n+(define_insn_reservation \"hs_fp_mult\" 1\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpmul\"))\n+  \"hs_fpmds\")\n+\n+(define_insn_reservation \"hs_fp_divs\" 8\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpdivs\"))\n+  \"hs_fpmds*6, nothing*2\")\n+\n+(define_insn_reservation \"hs_fp_divd\" 12\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpdivd\"))\n+  \"hs_fpmds*10, nothing*2\")\n+\n+(define_insn_reservation \"hs_fp_sqrt\" 17\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n+  \"hs_fpmds*15, nothing*2\")\n+\n+(define_insn_reservation \"hs_imul\" 17\n+  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n+    (eq_attr \"type\" \"imul\"))\n+  \"hs_fpmds*15, nothing*2\")"}, {"sha": "8f19dc7fd1d6e9671d1f62318d53a703070616c6", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 8, "deletions": 518, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -247,524 +247,14 @@\n   [(eq_attr \"in_uncond_branch_delay\" \"true\")\n    (nil) (nil)])\n    \n-;; DFA scheduling on the SPARC\n-\n-(define_automaton \"cypress_0,cypress_1,supersparc_0,supersparc_1,hypersparc_0,hypersparc_1,sparclet,ultrasparc_0,ultrasparc_1,ultrasparc3_0,ultrasparc3_1\")\n-\n-;; Cypress scheduling\n-\n-(define_cpu_unit \"cyp_memory, cyp_fpalu\" \"cypress_0\")\n-(define_cpu_unit \"cyp_fpmds\" \"cypress_1\")\n-\n-(define_insn_reservation \"cyp_load\" 2\n-  (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"load,sload,fpload\"))\n-  \"cyp_memory, nothing\")\n-\n-(define_insn_reservation \"cyp_fp_alu\" 5\n-  (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"fp,fpmove\"))\n-  \"cyp_fpalu, nothing*3\")\n-\n-(define_insn_reservation \"cyp_fp_mult\" 7\n-  (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"fpmul\"))\n-  \"cyp_fpmds, nothing*5\")\n-\n-(define_insn_reservation \"cyp_fp_div\" 37\n-  (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"fpdivs,fpdivd\"))\n-  \"cyp_fpmds, nothing*35\")\n-\n-(define_insn_reservation \"cyp_fp_sqrt\" 63\n-  (and (eq_attr \"cpu\" \"cypress\")\n-    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  \"cyp_fpmds, nothing*61\")\n-\n-;; SuperSPARC scheduling\n-\n-(define_cpu_unit \"ss_memory, ss_shift, ss_iwport0, ss_iwport1\" \"supersparc_0\")\n-(define_cpu_unit \"ss_fpalu\" \"supersparc_0\")\n-(define_cpu_unit \"ss_fpmds\" \"supersparc_1\")\n-\n-(define_reservation \"ss_iwport\" \"(ss_iwport0 | ss_iwport1)\")\n-\n-(define_insn_reservation \"ss_iuload\" 1\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"load,sload\"))\n-  \"ss_memory\")\n-\n-;; Ok, fpu loads deliver the result in zero cycles.  But we\n-;; have to show the ss_memory reservation somehow, thus...\n-(define_insn_reservation \"ss_fpload\" 0\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpload\"))\n-  \"ss_memory\")\n-\n-(define_bypass 0 \"ss_fpload\" \"ss_fp_alu,ss_fp_mult,ss_fp_divs,ss_fp_divd,ss_fp_sqrt\")\n-\n-(define_insn_reservation \"ss_store\" 1\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  \"ss_memory\")\n-\n-(define_insn_reservation \"ss_ialu_shift\" 1\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"shift\"))\n-  \"ss_shift + ss_iwport\")\n-\n-(define_insn_reservation \"ss_ialu_any\" 1\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"load,sload,store,shift,ialu\"))\n-  \"ss_iwport\")\n-\n-(define_insn_reservation \"ss_fp_alu\" 3\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n-  \"ss_fpalu, nothing*2\")\n-\n-(define_insn_reservation \"ss_fp_mult\" 3\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpmul\"))\n-  \"ss_fpmds, nothing*2\")\n-\n-(define_insn_reservation \"ss_fp_divs\" 6\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpdivs\"))\n-  \"ss_fpmds*4, nothing*2\")\n-\n-(define_insn_reservation \"ss_fp_divd\" 9\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpdivd\"))\n-  \"ss_fpmds*7, nothing*2\")\n-\n-(define_insn_reservation \"ss_fp_sqrt\" 12\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  \"ss_fpmds*10, nothing*2\")\n-\n-(define_insn_reservation \"ss_imul\" 4\n-  (and (eq_attr \"cpu\" \"supersparc\")\n-    (eq_attr \"type\" \"imul\"))\n-  \"ss_fpmds*4\")\n-\n-;; HyperSPARC/sparclite86x scheduling\n-\n-(define_cpu_unit \"hs_memory,hs_branch,hs_shift,hs_fpalu\" \"hypersparc_0\")\n-(define_cpu_unit \"hs_fpmds\" \"hypersparc_1\")\n-\n-(define_insn_reservation \"hs_load\" 1\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"load,sload,fpload\"))\n-  \"hs_memory\")\n-\n-(define_insn_reservation \"hs_store\" 2\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  \"hs_memory, nothing\")\n-\n-(define_insn_reservation \"hs_slbranch\" 1\n-  (and (eq_attr \"cpu\" \"sparclite86x\")\n-    (eq_attr \"type\" \"branch\"))\n-  \"hs_branch\")\n-\n-(define_insn_reservation \"hs_slshift\" 1\n-  (and (eq_attr \"cpu\" \"sparclite86x\")\n-    (eq_attr \"type\" \"shift\"))\n-  \"hs_shift\")\n-\n-(define_insn_reservation \"hs_fp_alu\" 1\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n-  \"hs_fpalu\")\n-\n-(define_insn_reservation \"hs_fp_mult\" 1\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fpmul\"))\n-  \"hs_fpmds\")\n-\n-(define_insn_reservation \"hs_fp_divs\" 8\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fpdivs\"))\n-  \"hs_fpmds*6, nothing*2\")\n-\n-(define_insn_reservation \"hs_fp_divd\" 12\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fpdivd\"))\n-  \"hs_fpmds*10, nothing*2\")\n-\n-(define_insn_reservation \"hs_fp_sqrt\" 17\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n-  \"hs_fpmds*15, nothing*2\")\n-\n-(define_insn_reservation \"hs_imul\" 17\n-  (and (ior (eq_attr \"cpu\" \"hypersparc\") (eq_attr \"cpu\" \"sparclite86x\"))\n-    (eq_attr \"type\" \"imul\"))\n-  \"hs_fpmds*15, nothing*2\")\n-\n-;; Sparclet tsc701 scheduling\n-\n-(define_cpu_unit \"sl_load0,sl_load1,sl_load2,sl_load3\" \"sparclet\")\n-(define_cpu_unit \"sl_store,sl_imul\" \"sparclet\")\n-\n-(define_reservation \"sl_load_any\" \"(sl_load0 | sl_load1 | sl_load2 | sl_load3)\")\n-(define_reservation \"sl_load_all\" \"(sl_load0 + sl_load1 + sl_load2 + sl_load3)\")\n-\n-(define_insn_reservation \"sl_ld\" 3\n-  (and (eq_attr \"cpu\" \"tsc701\")\n-   (eq_attr \"type\" \"load,sload\"))\n-  \"sl_load_any, sl_load_any, sl_load_any\")\n-\n-(define_insn_reservation \"sl_st\" 3\n-  (and (eq_attr \"cpu\" \"tsc701\")\n-    (eq_attr \"type\" \"store\"))\n-  \"(sl_store+sl_load_all)*3\")\n-\n-(define_insn_reservation \"sl_imul\" 5\n-  (and (eq_attr \"cpu\" \"tsc701\")\n-    (eq_attr \"type\" \"imul\"))\n-  \"sl_imul*5\")\n-\n-;; UltraSPARC-I/II scheduling\n-\n-(define_cpu_unit \"us1_fdivider,us1_fpm\" \"ultrasparc_0\");\n-(define_cpu_unit \"us1_fpa,us1_load_writeback\" \"ultrasparc_1\")\n-(define_cpu_unit \"us1_fps_0,us1_fps_1,us1_fpd_0,us1_fpd_1\" \"ultrasparc_1\")\n-(define_cpu_unit \"us1_slot0,us1_slot1,us1_slot2,us1_slot3\" \"ultrasparc_1\")\n-(define_cpu_unit \"us1_ieu0,us1_ieu1,us1_cti,us1_lsu\" \"ultrasparc_1\")\n-\n-(define_reservation \"us1_slot012\" \"(us1_slot0 | us1_slot1 | us1_slot2)\")\n-(define_reservation \"us1_slotany\" \"(us1_slot0 | us1_slot1 | us1_slot2 | us1_slot3)\")\n-(define_reservation \"us1_single_issue\" \"us1_slot0 + us1_slot1 + us1_slot2 + us1_slot3\")\n-\n-(define_reservation \"us1_fp_single\" \"(us1_fps_0 | us1_fps_1)\")\n-(define_reservation \"us1_fp_double\" \"(us1_fpd_0 | us1_fpd_1)\")\n-;; This is a simplified representation of the issue at hand.\n-;; For most cases, going from one FP precision type insn to another\n-;; just breaks up the insn group.  However for some cases, such\n-;; a situation causes the second insn to stall 2 more cycles.\n-(exclusion_set \"us1_fps_0,us1_fps_1\" \"us1_fpd_0,us1_fpd_1\")\n-\n-;; If we have to schedule an ieu1 specific instruction and we want\n-;; to reserve the ieu0 unit as well, we must reserve it first.  So for\n-;; example we could not schedule this sequence:\n-;;\tCOMPARE\t\tIEU1\n-;;\tIALU\t\tIEU0\n-;; but we could schedule them together like this:\n-;;\tIALU\t\tIEU0\n-;;\tCOMPARE\t\tIEU1\n-;; This basically requires that ieu0 is reserved before ieu1 when\n-;; it is required that both be reserved.\n-(absence_set \"us1_ieu0\" \"us1_ieu1\")\n-\n-;; This defines the slotting order.  Most IEU instructions can only\n-;; execute in the first three slots, FPU and branches can go into\n-;; any slot.  We represent instructions which \"break the group\"\n-;; as requiring reservation of us1_slot0.\n-(absence_set \"us1_slot0\" \"us1_slot1,us1_slot2,us1_slot3\")\n-(absence_set \"us1_slot1\" \"us1_slot2,us1_slot3\")\n-(absence_set \"us1_slot2\" \"us1_slot3\")\n-\n-(define_insn_reservation \"us1_simple_ieuN\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"ialu\"))\n-  \"(us1_ieu0 | us1_ieu1) + us1_slot012\")\n-\n-(define_insn_reservation \"us1_simple_ieu0\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"shift\"))\n-  \"us1_ieu0 + us1_slot012\")\n-\n-(define_insn_reservation \"us1_simple_ieu1\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"compare\"))\n-  \"us1_ieu1 + us1_slot012\")\n-\n-(define_insn_reservation \"us1_cmove\" 2\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"cmove\"))\n-  \"us1_single_issue, nothing\")\n-\n-(define_insn_reservation \"us1_imul\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"imul\"))\n-  \"us1_single_issue\")\n-\n-(define_insn_reservation \"us1_idiv\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"idiv\"))\n-  \"us1_single_issue\")\n-\n-;; For loads, the \"delayed return mode\" behavior of the chip\n-;; is represented using the us1_load_writeback resource.\n-(define_insn_reservation \"us1_load\" 2\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"load,fpload\"))\n-  \"us1_lsu + us1_slot012, us1_load_writeback\")\n-\n-(define_insn_reservation \"us1_load_signed\" 3\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"sload\"))\n-  \"us1_lsu + us1_slot012, nothing, us1_load_writeback\")\n-\n-(define_insn_reservation \"us1_store\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  \"us1_lsu + us1_slot012\")\n-\n-(define_insn_reservation \"us1_branch\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"branch\"))\n-  \"us1_cti + us1_slotany\")\n-\n-(define_insn_reservation \"us1_call_jmpl\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n-  \"us1_cti + us1_ieu1 + us1_slot0\")\n-\n-(define_insn_reservation \"us1_fmov_single\" 1\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpmove\"))\n-       (eq_attr \"fptype\" \"single\"))\n-  \"us1_fpa + us1_fp_single + us1_slotany\")\n-\n-(define_insn_reservation \"us1_fmov_double\" 1\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpmove\"))\n-       (eq_attr \"fptype\" \"double\"))\n-  \"us1_fpa + us1_fp_double + us1_slotany\")\n-\n-(define_insn_reservation \"us1_fcmov_single\" 2\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n-       (eq_attr \"fptype\" \"single\"))\n-  \"us1_fpa + us1_fp_single + us1_slotany, nothing\")\n-\n-(define_insn_reservation \"us1_fcmov_double\" 2\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n-       (eq_attr \"fptype\" \"double\"))\n-  \"us1_fpa + us1_fp_double + us1_slotany, nothing\")\n-\n-(define_insn_reservation \"us1_faddsub_single\" 4\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fp\"))\n-       (eq_attr \"fptype\" \"single\"))\n-  \"us1_fpa + us1_fp_single + us1_slotany, nothing*3\")\n-\n-(define_insn_reservation \"us1_faddsub_double\" 4\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fp\"))\n-       (eq_attr \"fptype\" \"double\"))\n-  \"us1_fpa + us1_fp_double + us1_slotany, nothing*3\")\n-\n-(define_insn_reservation \"us1_fpcmp_single\" 1\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpcmp\"))\n-       (eq_attr \"fptype\" \"single\"))\n-  \"us1_fpa + us1_fp_single + us1_slotany\")\n-\n-(define_insn_reservation \"us1_fpcmp_double\" 1\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpcmp\"))\n-       (eq_attr \"fptype\" \"double\"))\n-  \"us1_fpa + us1_fp_double + us1_slotany\")\n-\n-(define_insn_reservation \"us1_fmult_single\" 4\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpmul\"))\n-       (eq_attr \"fptype\" \"single\"))\n-  \"us1_fpm + us1_fp_single + us1_slotany, nothing*3\")\n-\n-(define_insn_reservation \"us1_fmult_double\" 4\n-  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n-            (eq_attr \"type\" \"fpmul\"))\n-       (eq_attr \"fptype\" \"double\"))\n-  \"us1_fpm + us1_fp_double + us1_slotany, nothing*3\")\n-\n-;; This is actually in theory dangerous, because it is possible\n-;; for the chip to prematurely dispatch the dependant instruction\n-;; in the G stage, resulting in a 9 cycle stall.  However I have never\n-;; been able to trigger this case myself even with hand written code,\n-;; so it must require some rare complicated pipeline state.\n-(define_bypass 3\n-   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\"\n-   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n-\n-;; Floating point divide and square root use the multiplier unit\n-;; for final rounding 3 cycles before the divide/sqrt is complete.\n-\n-(define_insn_reservation \"us1_fdivs\"\n-  13\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n-  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*8, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n-  )\n-\n-(define_bypass\n-  12\n-  \"us1_fdivs\"\n-  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n-\n-(define_insn_reservation \"us1_fdivd\"\n-  23\n-  (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"fpdivd,fpsqrtd\"))\n-  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*18, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n-  )\n-(define_bypass\n-  22\n-  \"us1_fdivd\"\n-  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n-\n-;; Any store may multi issue with the insn creating the source\n-;; data as long as that creating insn is not an FPU div/sqrt.\n-;; We need a special guard function because this bypass does\n-;; not apply to the address inputs of the store.\n-(define_bypass 0 \"us1_simple_ieuN,us1_simple_ieu1,us1_simple_ieu0,us1_faddsub_single,us1_faddsub_double,us1_fmov_single,us1_fmov_double,us1_fcmov_single,us1_fcmov_double,us1_fmult_single,us1_fmult_double\" \"us1_store\"\n-   \"store_data_bypass_p\")\n-\n-;; An integer branch may execute in the same cycle as the compare\n-;; creating the condition codes.\n-(define_bypass 0 \"us1_simple_ieu1\" \"us1_branch\")\n-\n-;; UltraSPARC-III scheduling\n-;;\n-;; A much simpler beast, no silly slotting rules and both\n-;; integer units are fully symmetric.  It does still have\n-;; single-issue instructions though.\n-\n-(define_cpu_unit \"us3_a0,us3_a1,us3_ms,us3_br,us3_fpm\" \"ultrasparc3_0\")\n-(define_cpu_unit \"us3_slot0,us3_slot1,us3_slot2,us3_slot3,us3_fpa\" \"ultrasparc3_1\")\n-(define_cpu_unit \"us3_load_writeback\" \"ultrasparc3_1\")\n-\n-(define_reservation \"us3_slotany\" \"(us3_slot0 | us3_slot1 | us3_slot2 | us3_slot3)\")\n-(define_reservation \"us3_single_issue\" \"us3_slot0 + us3_slot1 + us3_slot2 + us3_slot3\")\n-(define_reservation \"us3_ax\" \"(us3_a0 | us3_a1)\")\n-\n-(define_insn_reservation \"us3_integer\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"ialu,shift,compare\"))\n-  \"us3_ax + us3_slotany\")\n-\n-(define_insn_reservation \"us3_cmove\" 2\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"cmove\"))\n-  \"us3_ms + us3_br + us3_slotany, nothing\")\n-\n-;; ??? Not entirely accurate.\n-;; ??? It can run from 6 to 9 cycles.  The first cycle the MS pipe\n-;; ??? is needed, and the instruction group is broken right after\n-;; ??? the imul.  Then 'helper' instructions are generated to perform\n-;; ??? each further stage of the multiplication, each such 'helper' is\n-;; ??? single group.  So, the reservation aspect is represented accurately\n-;; ??? here, but the variable cycles are not.\n-;; ??? Currently I have no idea how to determine the variability, but once\n-;; ??? known we can simply add a define_bypass or similar to model it.\n-(define_insn_reservation \"us3_imul\" 6\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"imul\"))\n-  \"us3_ms + us3_slotany, us3_single_issue*5\")\n-\n-(define_insn_reservation \"us3_idiv\" 71\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"idiv\"))\n-  \"us3_ms + us3_slotany, us3_single_issue*70\")\n-\n-;; UltraSPARC-III has a similar load delay as UltraSPARC-I/II except\n-;; that all loads except 32-bit/64-bit unsigned loads take the extra\n-;; delay for sign/zero extension.\n-(define_insn_reservation \"us3_2cycle_load\" 2\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (and (eq_attr \"type\" \"load,fpload\")\n-      (eq_attr \"us3load_type\" \"2cycle\")))\n-  \"us3_ms + us3_slotany, us3_load_writeback\")\n-\n-(define_insn_reservation \"us3_load_delayed\" 3\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (and (eq_attr \"type\" \"load,sload\")\n-      (eq_attr \"us3load_type\" \"3cycle\")))\n-  \"us3_ms + us3_slotany, nothing, us3_load_writeback\")\n-\n-(define_insn_reservation \"us3_store\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"store,fpstore\"))\n-  \"us3_ms + us3_slotany\")\n-\n-(define_insn_reservation \"us3_branch\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"branch\"))\n-  \"us3_br + us3_slotany\")\n-\n-(define_insn_reservation \"us3_call_jmpl\" 1\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n-  \"us3_br + us3_ms + us3_slotany\")\n-\n-(define_insn_reservation \"us3_fmov\" 3\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpmove\"))\n-  \"us3_fpa + us3_slotany, nothing*2\")\n-\n-(define_insn_reservation \"us3_fcmov\" 3\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpcmove\"))\n-  \"us3_fpa + us3_br + us3_slotany, nothing*2\")\n-\n-(define_insn_reservation \"us3_fcrmov\" 3\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpcrmove\"))\n-  \"us3_fpa + us3_ms + us3_slotany, nothing*2\")\n-\n-(define_insn_reservation \"us3_faddsub\" 4\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fp\"))\n-  \"us3_fpa + us3_slotany, nothing*3\")\n-\n-(define_insn_reservation \"us3_fpcmp\" 5\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpcmp\"))\n-  \"us3_fpa + us3_slotany, nothing*4\")\n-\n-(define_insn_reservation \"us3_fmult\" 4\n- (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpmul\"))\n-  \"us3_fpm + us3_slotany, nothing*3\")\n-\n-(define_insn_reservation \"us3_fdivs\" 17\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpdivs\"))\n-  \"(us3_fpm + us3_slotany), us3_fpm*14, nothing*2\")\n-\n-(define_insn_reservation \"us3_fsqrts\" 20\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpsqrts\"))\n-  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n-\n-(define_insn_reservation \"us3_fdivd\" 20\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpdivd\"))\n-  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n-\n-(define_insn_reservation \"us3_fsqrtd\" 29\n-  (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"fpsqrtd\"))\n-  \"(us3_fpm + us3_slotany), us3_fpm*26, nothing*2\")\n-\n-;; Any store may multi issue with the insn creating the source\n-;; data as long as that creating insn is not an FPU div/sqrt.\n-;; We need a special guard function because this bypass does\n-;; not apply to the address inputs of the store.\n-(define_bypass 0 \"us3_integer,us3_faddsub,us3_fmov,us3_fcmov,us3_fmult\" \"us3_store\"\n-   \"store_data_bypass_p\")\n-\n-;; An integer branch may execute in the same cycle as the compare\n-;; creating the condition codes.\n-(define_bypass 0 \"us3_integer\" \"us3_branch\")\n-\n-;; If FMOVfcc is user of FPCMP, latency is only 1 cycle.\n-(define_bypass 1 \"us3_fpcmp\" \"us3_fcmov\")\n+;; Include SPARC DFA schedulers\n+\n+(include \"cypress.md\")\n+(include \"supersparc.md\")\n+(include \"hypersparc.md\")\n+(include \"sparclet.md\")\n+(include \"ultra1_2.md\")\n+(include \"ultra3.md\")\n \n \f\n ;; Compare instructions."}, {"sha": "805bd29f92f09956a520391a176d2db2674549ea", "filename": "gcc/config/sparc/sparclet.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsparclet.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsparclet.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparclet.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,44 @@\n+;; Scheduling description for Sparclet.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The Sparclet is a single-issue processor.\n+\n+(define_automaton \"sparclet\")\n+\n+(define_cpu_unit \"sl_load0,sl_load1,sl_load2,sl_load3\" \"sparclet\")\n+(define_cpu_unit \"sl_store,sl_imul\" \"sparclet\")\n+\n+(define_reservation \"sl_load_any\" \"(sl_load0 | sl_load1 | sl_load2 | sl_load3)\")\n+(define_reservation \"sl_load_all\" \"(sl_load0 + sl_load1 + sl_load2 + sl_load3)\")\n+\n+(define_insn_reservation \"sl_ld\" 3\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+   (eq_attr \"type\" \"load,sload\"))\n+  \"sl_load_any, sl_load_any, sl_load_any\")\n+\n+(define_insn_reservation \"sl_st\" 3\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+    (eq_attr \"type\" \"store\"))\n+  \"(sl_store+sl_load_all)*3\")\n+\n+(define_insn_reservation \"sl_imul\" 5\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"sl_imul*5\")"}, {"sha": "21eadf492d6853e5819339008f57e2e895c7cb4e", "filename": "gcc/config/sparc/supersparc.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsupersparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fsupersparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsupersparc.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,93 @@\n+;; Scheduling description for SuperSparc.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The SuperSparc is a tri-issue, which was considered quite parallel\n+;; at the time it was released.  Much like UltraSPARC-I and UltraSPARC-II\n+;; there are two integer units but only one of them may take shifts.\n+;;\n+;; ??? If SuperSPARC has the same slotting rules as ultrasparc for these\n+;; ??? shifts, we should model that.\n+\n+(define_automaton \"supersparc_0,supersparc_1\")\n+\n+(define_cpu_unit \"ss_memory, ss_shift, ss_iwport0, ss_iwport1\" \"supersparc_0\")\n+(define_cpu_unit \"ss_fpalu\" \"supersparc_0\")\n+(define_cpu_unit \"ss_fpmds\" \"supersparc_1\")\n+\n+(define_reservation \"ss_iwport\" \"(ss_iwport0 | ss_iwport1)\")\n+\n+(define_insn_reservation \"ss_iuload\" 1\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"load,sload\"))\n+  \"ss_memory\")\n+\n+;; Ok, fpu loads deliver the result in zero cycles.  But we\n+;; have to show the ss_memory reservation somehow, thus...\n+(define_insn_reservation \"ss_fpload\" 0\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpload\"))\n+  \"ss_memory\")\n+\n+(define_bypass 0 \"ss_fpload\" \"ss_fp_alu,ss_fp_mult,ss_fp_divs,ss_fp_divd,ss_fp_sqrt\")\n+\n+(define_insn_reservation \"ss_store\" 1\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"ss_memory\")\n+\n+(define_insn_reservation \"ss_ialu_shift\" 1\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"shift\"))\n+  \"ss_shift + ss_iwport\")\n+\n+(define_insn_reservation \"ss_ialu_any\" 1\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"load,sload,store,shift,ialu\"))\n+  \"ss_iwport\")\n+\n+(define_insn_reservation \"ss_fp_alu\" 3\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n+  \"ss_fpalu, nothing*2\")\n+\n+(define_insn_reservation \"ss_fp_mult\" 3\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  \"ss_fpmds, nothing*2\")\n+\n+(define_insn_reservation \"ss_fp_divs\" 6\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpdivs\"))\n+  \"ss_fpmds*4, nothing*2\")\n+\n+(define_insn_reservation \"ss_fp_divd\" 9\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpdivd\"))\n+  \"ss_fpmds*7, nothing*2\")\n+\n+(define_insn_reservation \"ss_fp_sqrt\" 12\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpsqrts,fpsqrtd\"))\n+  \"ss_fpmds*10, nothing*2\")\n+\n+(define_insn_reservation \"ss_imul\" 4\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"ss_fpmds*4\")"}, {"sha": "873421534ea7c3ee53e3fef881f4f9d4a06e60cf", "filename": "gcc/config/sparc/ultra1_2.md", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra1_2.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,242 @@\n+;; Scheduling description for UltraSPARC-I/II.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; UltraSPARC-I and II are quad-issue processors.  Interesting features\n+;; to note:\n+;;\n+;; - Buffered loads, they can queue waiting for the actual data until\n+;;   an instruction actually tries to reference the destination register\n+;;   as an input\n+;; - Two integer units.  Only one of them can do shifts, and the other\n+;;   is the only one which may do condition code setting instructions.\n+;;   Complicating things further, a shift may go only into the first\n+;;   slot in a dispatched group.  And if you have a non-condition code\n+;;   setting instruction and one that does set the condition codes.  The\n+;;   former must be issued first in order for both of them to issue.\n+;; - Stores can issue before the value being stored is available.  As long\n+;;   as the input data becomes ready before the store is to move out of the\n+;;   store buffer, it will not cause a stall.\n+;; - Branches may issue in the same cycle as an instruction setting the\n+;;   condition codes being tested by that branch.  This does not apply\n+;;   to floating point, only integer.\n+\n+(define_automaton \"ultrasparc_0,ultrasparc_1\")\n+\n+(define_cpu_unit \"us1_fdivider,us1_fpm\" \"ultrasparc_0\");\n+(define_cpu_unit \"us1_fpa,us1_load_writeback\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_fps_0,us1_fps_1,us1_fpd_0,us1_fpd_1\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_slot0,us1_slot1,us1_slot2,us1_slot3\" \"ultrasparc_1\")\n+(define_cpu_unit \"us1_ieu0,us1_ieu1,us1_cti,us1_lsu\" \"ultrasparc_1\")\n+\n+(define_reservation \"us1_slot012\" \"(us1_slot0 | us1_slot1 | us1_slot2)\")\n+(define_reservation \"us1_slotany\" \"(us1_slot0 | us1_slot1 | us1_slot2 | us1_slot3)\")\n+(define_reservation \"us1_single_issue\" \"us1_slot0 + us1_slot1 + us1_slot2 + us1_slot3\")\n+\n+(define_reservation \"us1_fp_single\" \"(us1_fps_0 | us1_fps_1)\")\n+(define_reservation \"us1_fp_double\" \"(us1_fpd_0 | us1_fpd_1)\")\n+\n+;; This is a simplified representation of the issue at hand.\n+;; For most cases, going from one FP precision type insn to another\n+;; just breaks up the insn group.  However for some cases, such\n+;; a situation causes the second insn to stall 2 more cycles.\n+(exclusion_set \"us1_fps_0,us1_fps_1\" \"us1_fpd_0,us1_fpd_1\")\n+\n+;; If we have to schedule an ieu1 specific instruction and we want\n+;; to reserve the ieu0 unit as well, we must reserve it first.  So for\n+;; example we could not schedule this sequence:\n+;;\tCOMPARE\t\tIEU1\n+;;\tIALU\t\tIEU0\n+;; but we could schedule them together like this:\n+;;\tIALU\t\tIEU0\n+;;\tCOMPARE\t\tIEU1\n+;; This basically requires that ieu0 is reserved before ieu1 when\n+;; it is required that both be reserved.\n+(absence_set \"us1_ieu0\" \"us1_ieu1\")\n+\n+;; This defines the slotting order.  Most IEU instructions can only\n+;; execute in the first three slots, FPU and branches can go into\n+;; any slot.  We represent instructions which \"break the group\"\n+;; as requiring reservation of us1_slot0.\n+(absence_set \"us1_slot0\" \"us1_slot1,us1_slot2,us1_slot3\")\n+(absence_set \"us1_slot1\" \"us1_slot2,us1_slot3\")\n+(absence_set \"us1_slot2\" \"us1_slot3\")\n+\n+(define_insn_reservation \"us1_simple_ieuN\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"ialu\"))\n+  \"(us1_ieu0 | us1_ieu1) + us1_slot012\")\n+\n+(define_insn_reservation \"us1_simple_ieu0\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"shift\"))\n+  \"us1_ieu0 + us1_slot012\")\n+\n+(define_insn_reservation \"us1_simple_ieu1\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"compare\"))\n+  \"us1_ieu1 + us1_slot012\")\n+\n+(define_insn_reservation \"us1_cmove\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"cmove\"))\n+  \"us1_single_issue, nothing\")\n+\n+(define_insn_reservation \"us1_imul\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"us1_single_issue\")\n+\n+(define_insn_reservation \"us1_idiv\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"idiv\"))\n+  \"us1_single_issue\")\n+\n+;; For loads, the \"delayed return mode\" behavior of the chip\n+;; is represented using the us1_load_writeback resource.\n+(define_insn_reservation \"us1_load\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"load,fpload\"))\n+  \"us1_lsu + us1_slot012, us1_load_writeback\")\n+\n+(define_insn_reservation \"us1_load_signed\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"sload\"))\n+  \"us1_lsu + us1_slot012, nothing, us1_load_writeback\")\n+\n+(define_insn_reservation \"us1_store\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"us1_lsu + us1_slot012\")\n+\n+(define_insn_reservation \"us1_branch\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"branch\"))\n+  \"us1_cti + us1_slotany\")\n+\n+(define_insn_reservation \"us1_call_jmpl\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n+  \"us1_cti + us1_ieu1 + us1_slot0\")\n+\n+(define_insn_reservation \"us1_fmov_single\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmove\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fmov_double\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmove\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fcmov_single\" 2\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany, nothing\")\n+\n+(define_insn_reservation \"us1_fcmov_double\" 2\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmove,fpcrmove\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany, nothing\")\n+\n+(define_insn_reservation \"us1_faddsub_single\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_faddsub_double\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_fpcmp_single\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmp\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpa + us1_fp_single + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fpcmp_double\" 1\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpcmp\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpa + us1_fp_double + us1_slotany\")\n+\n+(define_insn_reservation \"us1_fmult_single\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmul\"))\n+       (eq_attr \"fptype\" \"single\"))\n+  \"us1_fpm + us1_fp_single + us1_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us1_fmult_double\" 4\n+  (and (and (eq_attr \"cpu\" \"ultrasparc\")\n+            (eq_attr \"type\" \"fpmul\"))\n+       (eq_attr \"fptype\" \"double\"))\n+  \"us1_fpm + us1_fp_double + us1_slotany, nothing*3\")\n+\n+;; This is actually in theory dangerous, because it is possible\n+;; for the chip to prematurely dispatch the dependant instruction\n+;; in the G stage, resulting in a 9 cycle stall.  However I have never\n+;; been able to trigger this case myself even with hand written code,\n+;; so it must require some rare complicated pipeline state.\n+(define_bypass 3\n+   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\"\n+   \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+;; Floating point divide and square root use the multiplier unit\n+;; for final rounding 3 cycles before the divide/sqrt is complete.\n+\n+(define_insn_reservation \"us1_fdivs\"\n+  13\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n+  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*8, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n+  )\n+\n+(define_bypass\n+  12\n+  \"us1_fdivs\"\n+  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+(define_insn_reservation \"us1_fdivd\"\n+  23\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivd,fpsqrtd\"))\n+  \"(us1_fpm + us1_fdivider + us1_slot0), us1_fdivider*18, (us1_fpm + us1_fdivider), us1_fdivider*2\"\n+  )\n+(define_bypass\n+  22\n+  \"us1_fdivd\"\n+  \"us1_faddsub_single,us1_faddsub_double,us1_fmult_single,us1_fmult_double\")\n+\n+;; Any store may multi issue with the insn creating the source\n+;; data as long as that creating insn is not an FPU div/sqrt.\n+;; We need a special guard function because this bypass does\n+;; not apply to the address inputs of the store.\n+(define_bypass 0 \"us1_simple_ieuN,us1_simple_ieu1,us1_simple_ieu0,us1_faddsub_single,us1_faddsub_double,us1_fmov_single,us1_fmov_double,us1_fcmov_single,us1_fcmov_double,us1_fmult_single,us1_fmult_double\" \"us1_store\"\n+   \"store_data_bypass_p\")\n+\n+;; An integer branch may execute in the same cycle as the compare\n+;; creating the condition codes.\n+(define_bypass 0 \"us1_simple_ieu1\" \"us1_branch\")"}, {"sha": "72cd33eafa49efe55fe1cdb3155c55dfc72a97ef", "filename": "gcc/config/sparc/ultra3.md", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fultra3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1d9bd0c06f3b079ce0061f383403877a84126ed/gcc%2Fconfig%2Fsparc%2Fultra3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra3.md?ref=a1d9bd0c06f3b079ce0061f383403877a84126ed", "patch": "@@ -0,0 +1,158 @@\n+;; Scheduling description for UltraSPARC-III.\n+;;   Copyright (C) 2002 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; UltraSPARC-III is a quad-issue processor.\n+;;\n+;; It is also a much simpler beast than Ultra-I/II, no silly\n+;; slotting rules and both integer units are fully symmetric.\n+;; It does still have single-issue instructions though.\n+\n+(define_automaton \"ultrasparc3_0,ultrasparc3_1\")\n+\n+(define_cpu_unit \"us3_a0,us3_a1,us3_ms,us3_br,us3_fpm\" \"ultrasparc3_0\")\n+(define_cpu_unit \"us3_slot0,us3_slot1,us3_slot2,us3_slot3,us3_fpa\" \"ultrasparc3_1\")\n+(define_cpu_unit \"us3_load_writeback\" \"ultrasparc3_1\")\n+\n+(define_reservation \"us3_slotany\" \"(us3_slot0 | us3_slot1 | us3_slot2 | us3_slot3)\")\n+(define_reservation \"us3_single_issue\" \"us3_slot0 + us3_slot1 + us3_slot2 + us3_slot3\")\n+(define_reservation \"us3_ax\" \"(us3_a0 | us3_a1)\")\n+\n+(define_insn_reservation \"us3_integer\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"ialu,shift,compare\"))\n+  \"us3_ax + us3_slotany\")\n+\n+(define_insn_reservation \"us3_cmove\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"cmove\"))\n+  \"us3_ms + us3_br + us3_slotany, nothing\")\n+\n+;; ??? Not entirely accurate.\n+;; ??? It can run from 6 to 9 cycles.  The first cycle the MS pipe\n+;; ??? is needed, and the instruction group is broken right after\n+;; ??? the imul.  Then 'helper' instructions are generated to perform\n+;; ??? each further stage of the multiplication, each such 'helper' is\n+;; ??? single group.  So, the reservation aspect is represented accurately\n+;; ??? here, but the variable cycles are not.\n+;; ??? Currently I have no idea how to determine the variability, but once\n+;; ??? known we can simply add a define_bypass or similar to model it.\n+(define_insn_reservation \"us3_imul\" 6\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"imul\"))\n+  \"us3_ms + us3_slotany, us3_single_issue*5\")\n+\n+(define_insn_reservation \"us3_idiv\" 71\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"idiv\"))\n+  \"us3_ms + us3_slotany, us3_single_issue*70\")\n+\n+;; UltraSPARC-III has a similar load delay as UltraSPARC-I/II except\n+;; that all loads except 32-bit/64-bit unsigned loads take the extra\n+;; delay for sign/zero extension.\n+(define_insn_reservation \"us3_2cycle_load\" 2\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (and (eq_attr \"type\" \"load,fpload\")\n+      (eq_attr \"us3load_type\" \"2cycle\")))\n+  \"us3_ms + us3_slotany, us3_load_writeback\")\n+\n+(define_insn_reservation \"us3_load_delayed\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (and (eq_attr \"type\" \"load,sload\")\n+      (eq_attr \"us3load_type\" \"3cycle\")))\n+  \"us3_ms + us3_slotany, nothing, us3_load_writeback\")\n+\n+(define_insn_reservation \"us3_store\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  \"us3_ms + us3_slotany\")\n+\n+(define_insn_reservation \"us3_branch\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"branch\"))\n+  \"us3_br + us3_slotany\")\n+\n+(define_insn_reservation \"us3_call_jmpl\" 1\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"call,sibcall,call_no_delay_slot,uncond_branch\"))\n+  \"us3_br + us3_ms + us3_slotany\")\n+\n+(define_insn_reservation \"us3_fmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpmove\"))\n+  \"us3_fpa + us3_slotany, nothing*2\")\n+\n+(define_insn_reservation \"us3_fcmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpcmove\"))\n+  \"us3_fpa + us3_br + us3_slotany, nothing*2\")\n+\n+(define_insn_reservation \"us3_fcrmov\" 3\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpcrmove\"))\n+  \"us3_fpa + us3_ms + us3_slotany, nothing*2\")\n+\n+(define_insn_reservation \"us3_faddsub\" 4\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fp\"))\n+  \"us3_fpa + us3_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us3_fpcmp\" 5\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpcmp\"))\n+  \"us3_fpa + us3_slotany, nothing*4\")\n+\n+(define_insn_reservation \"us3_fmult\" 4\n+ (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  \"us3_fpm + us3_slotany, nothing*3\")\n+\n+(define_insn_reservation \"us3_fdivs\" 17\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpdivs\"))\n+  \"(us3_fpm + us3_slotany), us3_fpm*14, nothing*2\")\n+\n+(define_insn_reservation \"us3_fsqrts\" 20\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpsqrts\"))\n+  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n+\n+(define_insn_reservation \"us3_fdivd\" 20\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpdivd\"))\n+  \"(us3_fpm + us3_slotany), us3_fpm*17, nothing*2\")\n+\n+(define_insn_reservation \"us3_fsqrtd\" 29\n+  (and (eq_attr \"cpu\" \"ultrasparc3\")\n+    (eq_attr \"type\" \"fpsqrtd\"))\n+  \"(us3_fpm + us3_slotany), us3_fpm*26, nothing*2\")\n+\n+;; Any store may multi issue with the insn creating the source\n+;; data as long as that creating insn is not an FPU div/sqrt.\n+;; We need a special guard function because this bypass does\n+;; not apply to the address inputs of the store.\n+(define_bypass 0 \"us3_integer,us3_faddsub,us3_fmov,us3_fcmov,us3_fmult\" \"us3_store\"\n+   \"store_data_bypass_p\")\n+\n+;; An integer branch may execute in the same cycle as the compare\n+;; creating the condition codes.\n+(define_bypass 0 \"us3_integer\" \"us3_branch\")\n+\n+;; If FMOVfcc is user of FPCMP, latency is only 1 cycle.\n+(define_bypass 1 \"us3_fpcmp\" \"us3_fcmov\")"}]}